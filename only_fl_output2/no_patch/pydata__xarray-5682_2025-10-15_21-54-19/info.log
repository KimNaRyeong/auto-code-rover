2025-10-15 21:54:19.662 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-15 21:54:21.046 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=891, output_tokens=12, cost=0.009270
2025-10-15 21:54:37.918 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1071, output_tokens=595, cost=0.028560
2025-10-15 21:54:39.977 | INFO     | registered non reproducing test 0
2025-10-15 21:54:50.432 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2536, output_tokens=508, cost=0.040600
2025-10-15 21:54:52.413 | INFO     | registered non reproducing test 1
2025-10-15 21:55:07.243 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2443, output_tokens=632, cost=0.043390
2025-10-15 21:55:09.230 | INFO     | registered non reproducing test 2
2025-10-15 21:55:09.230 | WARNING  | Failed to write a reproducer test; skipping reproducer tracing
2025-10-15 21:55:09.236 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 21:55:17.700 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1092, output_tokens=388, cost=0.022560
2025-10-15 21:55:17.710 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 21:55:20.796 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=742, output_tokens=55, cost=0.009070
2025-10-15 21:55:20.797 | DEBUG    | Extracted a valid json.
2025-10-15 21:55:20.797 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_class(\"DataArray\")",
        "search_code(\"matplotlib\")",
        "search_method_in_class(\"plot\", \"DataArray\")",
        "search_code(\"xlabel\")"
    ],
    "bug_locations": []
}
2025-10-15 21:55:20.952 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-15 21:55:20.953 | DEBUG    | <Agent search> Analyzing search results.
2025-10-15 21:55:41.044 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=6395, output_tokens=842, cost=0.089210
2025-10-15 21:55:41.061 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 21:55:48.458 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=7453, output_tokens=308, cost=0.083770
2025-10-15 21:55:48.465 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 21:55:56.073 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=662, output_tokens=305, cost=0.015770
2025-10-15 21:55:56.074 | DEBUG    | Extracted a valid json.
2025-10-15 21:55:56.075 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "xarray/plot/plot.py",
            "class": "",
            "method": "Relevant plotting methods (e.g., line plots, scatter plots)",
            "intended_behavior": "To resolve the issue, the plotting methods within this file should ensure that if a `long_name` attribute contains LaTeX expressions, it is correctly passed to matplotlib in a manner that enables LaTeX rendering. This means specifically checking for attributes that contain LaTeX strings and ensuring that matplotlib's rendering engine is explicitly instructed to interpret them as LaTeX. This may involve ensuring that the text properties passed to matplotlib plotting functions (like `xlabel`) correctly signal matplotlib to render the text as LaTeX, potentially by setting appropriate rcParams or directly formatting text labels."
        },
        {
            "file": "xarray/plot/utils.py",
            "class": "",
            "method": "Functions responsible for setting plot labels or any utility functions that format or prepare text for plotting",
            "intended_behavior": "Utility functions that handle plot labels should respect and preserve LaTeX formatting in text passed to them. When attributes are extracted and processed for plotting labels, the code should ensure that LaTeX strings are recognized and retained in a format that matplotlib can render as LaTeX. This could involve detecting LaTeX in strings and ensuring they are formatted correctly for matplotlib (e.g., wrapping in `$` if not already done so) and not escaping special characters accidentally."
        }
    ]
}
2025-10-15 21:55:56.079 | WARNING  | Too many fragments. Examine the method name: Relevant plotting methods (e.g., line plots, scatter plots)
2025-10-15 21:55:56.085 | DEBUG    | Bug location extracted successfully: [<file>xarray/plot/plot.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2 Use this module directly:
3     import xarray.plot as xplt
4 
5 Or use the methods on a DataArray or Dataset:
6     DataArray.plot._____
7     Dataset.plot._____
8 """
9 import functools
10 from distutils.version import LooseVersion
11 
12 import numpy as np
13 import pandas as pd
14 
15 from ..core.alignment import broadcast
16 from .facetgrid import _easy_facetgrid
17 from .utils import (
18     _add_colorbar,
19     _adjust_legend_subtitles,
20     _assert_valid_xy,
21     _ensure_plottable,
22     _infer_interval_breaks,
23     _infer_xy_labels,
24     _is_numeric,
25     _legend_add_subtitle,
26     _process_cmap_cbar_kwargs,
27     _rescale_imshow_rgb,
28     _resolve_intervals_1dplot,
29     _resolve_intervals_2dplot,
30     _update_axes,
31     get_axis,
32     import_matplotlib_pyplot,
33     label_from_attrs,
34     legend_elements,
35 )
36 
37 # copied from seaborn
38 _MARKERSIZE_RANGE = np.array([18.0, 72.0])
39 
40 
41 def _infer_scatter_metadata(darray, x, z, hue, hue_style, size):
42     def _determine_array(darray, name, array_style):
43         """Find and determine what type of array it is."""
44         array = darray[name]
45         array_is_numeric = _is_numeric(array.values)
46 
47         if array_style is None:
48             array_style = "continuous" if array_is_numeric else "discrete"
49         elif array_style not in ["discrete", "continuous"]:
50             raise ValueError(
51                 f"The style '{array_style}' is not valid, "
52                 "valid options are None, 'discrete' or 'continuous'."
53             )
54 
55         array_label = label_from_attrs(array)
56 
57         return array, array_style, array_label
58 
59     # Add nice looking labels:
60     out = dict(ylabel=label_from_attrs(darray))
61     out.update(
62         {
63             k: label_from_attrs(darray[v]) if v in darray.coords else None
64             for k, v in [("xlabel", x), ("zlabel", z)]
65         }
66     )
67 
68     # Add styles and labels for the dataarrays:
69     for type_, a, style in [("hue", hue, hue_style), ("size", size, None)]:
70         tp, stl, lbl = f"{type_}", f"{type_}_style", f"{type_}_label"
71         if a:
72             out[tp], out[stl], out[lbl] = _determine_array(darray, a, style)
73         else:
74             out[tp], out[stl], out[lbl] = None, None, None
75 
76     return out
77 
78 
79 # copied from seaborn
80 def _parse_size(data, norm, width):
81     """
82     Determine what type of data it is. Then normalize it to width.
83 
84     If the data is categorical, normalize it to numbers.
85     """
86     plt = import_matplotlib_pyplot()
87 
88     if data is None:
89         return None
90 
91     data = data.values.ravel()
92 
93     if not _is_numeric(data):
94         # Data is categorical.
95         # Use pd.unique instead of np.unique because that keeps
96         # the order of the labels:
97         levels = pd.unique(data)
98         numbers = np.arange(1, 1 + len(levels))
99     else:
100         levels = numbers = np.sort(np.unique(data))
101 
102     min_width, max_width = width
103     # width_range = min_width, max_width
104 
105     if norm is None:
106         norm = plt.Normalize()
107     elif isinstance(norm, tuple):
108         norm = plt.Normalize(*norm)
109     elif not isinstance(norm, plt.Normalize):
110         err = "``size_norm`` must be None, tuple, or Normalize object."
111         raise ValueError(err)
112 
113     norm.clip = True
114     if not norm.scaled():
115         norm(np.asarray(numbers))
116     # limits = norm.vmin, norm.vmax
117 
118     scl = norm(numbers)
119     widths = np.asarray(min_width + scl * (max_width - min_width))
120     if scl.mask.any():
121         widths[scl.mask] = 0
122     sizes = dict(zip(levels, widths))
123 
124     return pd.Series(sizes)
125 
126 
127 def _infer_scatter_data(
128     darray, x, z, hue, size, size_norm, size_mapping=None, size_range=(1, 10)
129 ):
130     # Broadcast together all the chosen variables:
131     to_broadcast = dict(y=darray)
132     to_broadcast.update(
133         {k: darray[v] for k, v in dict(x=x, z=z).items() if v is not None}
134     )
135     to_broadcast.update(
136         {k: darray[v] for k, v in dict(hue=hue, size=size).items() if v in darray.dims}
137     )
138     broadcasted = dict(zip(to_broadcast.keys(), broadcast(*(to_broadcast.values()))))
139 
140     # Normalize hue and size and create lookup tables:
141     for type_, mapping, norm, width in [
142         ("hue", None, None, [0, 1]),
143         ("size", size_mapping, size_norm, size_range),
144     ]:
145         broadcasted_type = broadcasted.get(type_, None)
146         if broadcasted_type is not None:
147             if mapping is None:
148                 mapping = _parse_size(broadcasted_type, norm, width)
149 
150             broadcasted[type_] = broadcasted_type.copy(
151                 data=np.reshape(
152                     mapping.loc[broadcasted_type.values.ravel()].values,
153                     broadcasted_type.shape,
154                 )
155             )
156             broadcasted[f"{type_}_to_label"] = pd.Series(mapping.index, index=mapping)
157 
158     return broadcasted
159 
160 
161 def _infer_line_data(darray, x, y, hue):
162 
163     ndims = len(darray.dims)
164 
165     if x is not None and y is not None:
166         raise ValueError("Cannot specify both x and y kwargs for line plots.")
167 
168     if x is not None:
169         _assert_valid_xy(darray, x, "x")
170 
171     if y is not None:
172         _assert_valid_xy(darray, y, "y")
173 
174     if ndims == 1:
175         huename = None
176         hueplt = None
177         huelabel = ""
178 
179         if x is not None:
180             xplt = darray[x]
181             yplt = darray
182 
183         elif y is not None:
184             xplt = darray
185             yplt = darray[y]
186 
187         else:  # Both x & y are None
188             dim = darray.dims[0]
189             xplt = darray[dim]
190             yplt = darray
191 
192     else:
193         if x is None and y is None and hue is None:
194             raise ValueError("For 2D inputs, please specify either hue, x or y.")
195 
196         if y is None:
197             if hue is not None:
198                 _assert_valid_xy(darray, hue, "hue")
199             xname, huename = _infer_xy_labels(darray=darray, x=x, y=hue)
200             xplt = darray[xname]
201             if xplt.ndim > 1:
202                 if huename in darray.dims:
203                     otherindex = 1 if darray.dims.index(huename) == 0 else 0
204                     otherdim = darray.dims[otherindex]
205                     yplt = darray.transpose(otherdim, huename, transpose_coords=False)
206                     xplt = xplt.transpose(otherdim, huename, transpose_coords=False)
207                 else:
208                     raise ValueError(
209                         "For 2D inputs, hue must be a dimension"
210                         " i.e. one of " + repr(darray.dims)
211                     )
212 
213             else:
214                 (xdim,) = darray[xname].dims
215                 (huedim,) = darray[huename].dims
216                 yplt = darray.transpose(xdim, huedim)
217 
218         else:
219             yname, huename = _infer_xy_labels(darray=darray, x=y, y=hue)
220             yplt = darray[yname]
221             if yplt.ndim > 1:
222                 if huename in darray.dims:
223                     otherindex = 1 if darray.dims.index(huename) == 0 else 0
224                     otherdim = darray.dims[otherindex]
225                     xplt = darray.transpose(otherdim, huename, transpose_coords=False)
226                     yplt = yplt.transpose(otherdim, huename, transpose_coords=False)
227                 else:
228                     raise ValueError(
229                         "For 2D inputs, hue must be a dimension"
230                         " i.e. one of " + repr(darray.dims)
231                     )
232 
233             else:
234                 (ydim,) = darray[yname].dims
235                 (huedim,) = darray[huename].dims
236                 xplt = darray.transpose(ydim, huedim)
237 
238         huelabel = label_from_attrs(darray[huename])
239         hueplt = darray[huename]
240 
241     return xplt, yplt, hueplt, huelabel
242 
243 
244 def plot(
245     darray,
246     row=None,
247     col=None,
248     col_wrap=None,
249     ax=None,
250     hue=None,
251     rtol=0.01,
252     subplot_kws=None,
253     **kwargs,
254 ):
255     """
256     Default plot of DataArray using :py:mod:`matplotlib:matplotlib.pyplot`.
257 
258     Calls xarray plotting function based on the dimensions of
259     the squeezed DataArray.
260 
261     =============== ===========================
262     Dimensions      Plotting function
263     =============== ===========================
264     1               :py:func:`xarray.plot.line`
265     2               :py:func:`xarray.plot.pcolormesh`
266     Anything else   :py:func:`xarray.plot.hist`
267     =============== ===========================
268 
269     Parameters
270     ----------
271     darray : DataArray
272     row : str, optional
273         If passed, make row faceted plots on this dimension name.
274     col : str, optional
275         If passed, make column faceted plots on this dimension name.
276     hue : str, optional
277         If passed, make faceted line plots with hue on this dimension name.
278     col_wrap : int, optional
279         Use together with ``col`` to wrap faceted plots.
280     ax : matplotlib axes object, optional
281         If ``None``, use the current axes. Not applicable when using facets.
282     rtol : float, optional
283         Relative tolerance used to determine if the indexes
284         are uniformly spaced. Usually a small positive number.
285     subplot_kws : dict, optional
286         Dictionary of keyword arguments for Matplotlib subplots
287         (see :py:meth:`matplotlib:matplotlib.figure.Figure.add_subplot`).
288     **kwargs : optional
289         Additional keyword arguments for Matplotlib.
290 
291     See Also
292     --------
293     xarray.DataArray.squeeze
294     """
295     darray = darray.squeeze().compute()
296 
297     plot_dims = set(darray.dims)
298     plot_dims.discard(row)
299     plot_dims.discard(col)
300     plot_dims.discard(hue)
301 
302     ndims = len(plot_dims)
303 
304     error_msg = (
305         "Only 1d and 2d plots are supported for facets in xarray. "
306         "See the package `Seaborn` for more options."
307     )
308 
309     if ndims in [1, 2]:
310         if row or col:
311             kwargs["subplot_kws"] = subplot_kws
312             kwargs["row"] = row
313             kwargs["col"] = col
314             kwargs["col_wrap"] = col_wrap
315         if ndims == 1:
316             plotfunc = line
317             kwargs["hue"] = hue
318         elif ndims == 2:
319             if hue:
320                 plotfunc = line
321                 kwargs["hue"] = hue
322             else:
323                 plotfunc = pcolormesh
324                 kwargs["subplot_kws"] = subplot_kws
325     else:
326         if row or col or hue:
327             raise ValueError(error_msg)
328         plotfunc = hist
329 
330     kwargs["ax"] = ax
331 
332     return plotfunc(darray, **kwargs)
333 
334 
335 # This function signature should not change so that it can use
336 # matplotlib format strings
337 def line(
338     darray,
339     *args,
340     row=None,
341     col=None,
342     figsize=None,
343     aspect=None,
344     size=None,
345     ax=None,
346     hue=None,
347     x=None,
348     y=None,
349     xincrease=None,
350     yincrease=None,
351     xscale=None,
352     yscale=None,
353     xticks=None,
354     yticks=None,
355     xlim=None,
356     ylim=None,
357     add_legend=True,
358     _labels=True,
359     **kwargs,
360 ):
361     """
362     Line plot of DataArray values.
363 
364     Wraps :py:func:`matplotlib:matplotlib.pyplot.plot`.
365 
366     Parameters
367     ----------
368     darray : DataArray
369         Either 1D or 2D. If 2D, one of ``hue``, ``x`` or ``y`` must be provided.
370     figsize : tuple, optional
371         A tuple (width, height) of the figure in inches.
372         Mutually exclusive with ``size`` and ``ax``.
373     aspect : scalar, optional
374         Aspect ratio of plot, so that ``aspect * size`` gives the *width* in
375         inches. Only used if a ``size`` is provided.
376     size : scalar, optional
377         If provided, create a new figure for the plot with the given size:
378         *height* (in inches) of each plot. See also: ``aspect``.
379     ax : matplotlib axes object, optional
380         Axes on which to plot. By default, the current is used.
381         Mutually exclusive with ``size`` and ``figsize``.
382     hue : str, optional
383         Dimension or coordinate for which you want multiple lines plotted.
384         If plotting against a 2D coordinate, ``hue`` must be a dimension.
385     x, y : str, optional
386         Dimension, coordinate or multi-index level for *x*, *y* axis.
387         Only one of these may be specified.
388         The other will be used for values from the DataArray on which this
389         plot method is called.
390     xscale, yscale : {'linear', 'symlog', 'log', 'logit'}, optional
391         Specifies scaling for the *x*- and *y*-axis, respectively.
392     xticks, yticks : array-like, optional
393         Specify tick locations for *x*- and *y*-axis.
394     xlim, ylim : array-like, optional
395         Specify *x*- and *y*-axis limits.
396     xincrease : None, True, or False, optional
397         Should the values on the *x* axis be increasing from left to right?
398         if ``None``, use the default for the Matplotlib function.
399     yincrease : None, True, or False, optional
400         Should the values on the *y* axis be increasing from top to bottom?
401         if ``None``, use the default for the Matplotlib function.
402     add_legend : bool, optional
403         Add legend with *y* axis coordinates (2D inputs only).
404     *args, **kwargs : optional
405         Additional arguments to :py:func:`matplotlib:matplotlib.pyplot.plot`.
406     """
407     # Handle facetgrids first
408     if row or col:
409         allargs = locals().copy()
410         allargs.update(allargs.pop("kwargs"))
411         allargs.pop("darray")
412         return _easy_facetgrid(darray, line, kind="line", **allargs)
413 
414     ndims = len(darray.dims)
415     if ndims > 2:
416         raise ValueError(
417             "Line plots are for 1- or 2-dimensional DataArrays. "
418             "Passed DataArray has {ndims} "
419             "dimensions".format(ndims=ndims)
420         )
421 
422     # The allargs dict passed to _easy_facetgrid above contains args
423     if args == ():
424         args = kwargs.pop("args", ())
425     else:
426         assert "args" not in kwargs
427 
428     ax = get_axis(figsize, size, aspect, ax)
429     xplt, yplt, hueplt, hue_label = _infer_line_data(darray, x, y, hue)
430 
431     # Remove pd.Intervals if contained in xplt.values and/or yplt.values.
432     xplt_val, yplt_val, x_suffix, y_suffix, kwargs = _resolve_intervals_1dplot(
433         xplt.to_numpy(), yplt.to_numpy(), kwargs
434     )
435     xlabel = label_from_attrs(xplt, extra=x_suffix)
436     ylabel = label_from_attrs(yplt, extra=y_suffix)
437 
438     _ensure_plottable(xplt_val, yplt_val)
439 
440     primitive = ax.plot(xplt_val, yplt_val, *args, **kwargs)
441 
442     if _labels:
443         if xlabel is not None:
444             ax.set_xlabel(xlabel)
445 
446         if ylabel is not None:
447             ax.set_ylabel(ylabel)
448 
449         ax.set_title(darray._title_for_slice())
450 
451     if darray.ndim == 2 and add_legend:
452         ax.legend(handles=primitive, labels=list(hueplt.to_numpy()), title=hue_label)
453 
454     # Rotate dates on xlabels
455     # Do this without calling autofmt_xdate so that x-axes ticks
456     # on other subplots (if any) are not deleted.
457     # https://stackoverflow.com/questions/17430105/autofmt-xdate-deletes-x-axis-labels-of-all-subplots
458     if np.issubdtype(xplt.dtype, np.datetime64):
459         for xlabels in ax.get_xticklabels():
460             xlabels.set_rotation(30)
461             xlabels.set_ha("right")
462 
463     _update_axes(ax, xincrease, yincrease, xscale, yscale, xticks, yticks, xlim, ylim)
464 
465     return primitive
466 
467 
468 def step(darray, *args, where="pre", drawstyle=None, ds=None, **kwargs):
469     """
470     Step plot of DataArray values.
471 
472     Similar to :py:func:`matplotlib:matplotlib.pyplot.step`.
473 
474     Parameters
475     ----------
476     where : {'pre', 'post', 'mid'}, default: 'pre'
477         Define where the steps should be placed:
478 
479         - ``'pre'``: The y value is continued constantly to the left from
480           every *x* position, i.e. the interval ``(x[i-1], x[i]]`` has the
481           value ``y[i]``.
482         - ``'post'``: The y value is continued constantly to the right from
483           every *x* position, i.e. the interval ``[x[i], x[i+1])`` has the
484           value ``y[i]``.
485         - ``'mid'``: Steps occur half-way between the *x* positions.
486 
487         Note that this parameter is ignored if one coordinate consists of
488         :py:class:`pandas.Interval` values, e.g. as a result of
489         :py:func:`xarray.Dataset.groupby_bins`. In this case, the actual
490         boundaries of the interval are used.
491     *args, **kwargs : optional
492         Additional arguments for :py:func:`xarray.plot.line`.
493     """
494     if where not in {"pre", "post", "mid"}:
495         raise ValueError("'where' argument to step must be 'pre', 'post' or 'mid'")
496 
497     if ds is not None:
498         if drawstyle is None:
499             drawstyle = ds
500         else:
501             raise TypeError("ds and drawstyle are mutually exclusive")
502     if drawstyle is None:
503         drawstyle = ""
504     drawstyle = "steps-" + where + drawstyle
505 
506     return line(darray, *args, drawstyle=drawstyle, **kwargs)
507 
508 
509 def hist(
510     darray,
511     figsize=None,
512     size=None,
513     aspect=None,
514     ax=None,
515     xincrease=None,
516     yincrease=None,
517     xscale=None,
518     yscale=None,
519     xticks=None,
520     yticks=None,
521     xlim=None,
522     ylim=None,
523     **kwargs,
524 ):
525     """
526     Histogram of DataArray.
527 
528     Wraps :py:func:`matplotlib:matplotlib.pyplot.hist`.
529 
530     Plots *N*-dimensional arrays by first flattening the array.
531 
532     Parameters
533     ----------
534     darray : DataArray
535         Can have any number of dimensions.
536     figsize : tuple, optional
537         A tuple (width, height) of the figure in inches.
538         Mutually exclusive with ``size`` and ``ax``.
539     aspect : scalar, optional
540         Aspect ratio of plot, so that ``aspect * size`` gives the *width* in
541         inches. Only used if a ``size`` is provided.
542     size : scalar, optional
543         If provided, create a new figure for the plot with the given size:
544         *height* (in inches) of each plot. See also: ``aspect``.
545     ax : matplotlib axes object, optional
546         Axes on which to plot. By default, use the current axes.
547         Mutually exclusive with ``size`` and ``figsize``.
548     **kwargs : optional
549         Additional keyword arguments to :py:func:`matplotlib:matplotlib.pyplot.hist`.
550 
551     """
552     ax = get_axis(figsize, size, aspect, ax)
553 
554     no_nan = np.ravel(darray.to_numpy())
555     no_nan = no_nan[pd.notnull(no_nan)]
556 
557     primitive = ax.hist(no_nan, **kwargs)
558 
559     ax.set_title("Histogram")
560     ax.set_xlabel(label_from_attrs(darray))
561 
562     _update_axes(ax, xincrease, yincrease, xscale, yscale, xticks, yticks, xlim, ylim)
563 
564     return primitive
565 
566 
567 def scatter(
568     darray,
569     *args,
570     row=None,
571     col=None,
572     figsize=None,
573     aspect=None,
574     size=None,
575     ax=None,
576     hue=None,
577     hue_style=None,
578     x=None,
579     z=None,
580     xincrease=None,
581     yincrease=None,
582     xscale=None,
583     yscale=None,
584     xticks=None,
585     yticks=None,
586     xlim=None,
587     ylim=None,
588     add_legend=None,
589     add_colorbar=None,
590     cbar_kwargs=None,
591     cbar_ax=None,
592     vmin=None,
593     vmax=None,
594     norm=None,
595     infer_intervals=None,
596     center=None,
597     levels=None,
598     robust=None,
599     colors=None,
600     extend=None,
601     cmap=None,
602     _labels=True,
603     **kwargs,
604 ):
605     """
606     Scatter plot a DataArray along some coordinates.
607 
608     Parameters
609     ----------
610     darray : DataArray
611         Dataarray to plot.
612     x, y : str
613         Variable names for x, y axis.
614     hue: str, optional
615         Variable by which to color scattered points
616     hue_style: str, optional
617         Can be either 'discrete' (legend) or 'continuous' (color bar).
618     markersize: str, optional
619         scatter only. Variable by which to vary size of scattered points.
620     size_norm: optional
621         Either None or 'Norm' instance to normalize the 'markersize' variable.
622     add_guide: bool, optional
623         Add a guide that depends on hue_style
624             - for "discrete", build a legend.
625               This is the default for non-numeric `hue` variables.
626             - for "continuous",  build a colorbar
627     row : str, optional
628         If passed, make row faceted plots on this dimension name
629     col : str, optional
630         If passed, make column faceted plots on this dimension name
631     col_wrap : int, optional
632         Use together with ``col`` to wrap faceted plots
633     ax : matplotlib axes object, optional
634         If None, uses the current axis. Not applicable when using facets.
635     subplot_kws : dict, optional
636         Dictionary of keyword arguments for matplotlib subplots. Only applies
637         to FacetGrid plotting.
638     aspect : scalar, optional
639         Aspect ratio of plot, so that ``aspect * size`` gives the width in
640         inches. Only used if a ``size`` is provided.
641     size : scalar, optional
642         If provided, create a new figure for the plot with the given size.
643         Height (in inches) of each plot. See also: ``aspect``.
644     norm : ``matplotlib.colors.Normalize`` instance, optional
645         If the ``norm`` has vmin or vmax specified, the corresponding kwarg
646         must be None.
647     vmin, vmax : float, optional
648         Values to anchor the colormap, otherwise they are inferred from the
649         data and other keyword arguments. When a diverging dataset is inferred,
650         setting one of these values will fix the other by symmetry around
651         ``center``. Setting both values prevents use of a diverging colormap.
652         If discrete levels are provided as an explicit list, both of these
653         values are ignored.
654     cmap : str or colormap, optional
655         The mapping from data values to color space. Either a
656         matplotlib colormap name or object. If not provided, this will
657         be either ``viridis`` (if the function infers a sequential
658         dataset) or ``RdBu_r`` (if the function infers a diverging
659         dataset).  When `Seaborn` is installed, ``cmap`` may also be a
660         `seaborn` color palette. If ``cmap`` is seaborn color palette
661         and the plot type is not ``contour`` or ``contourf``, ``levels``
662         must also be specified.
663     colors : color-like or list of color-like, optional
664         A single color or a list of colors. If the plot type is not ``contour``
665         or ``contourf``, the ``levels`` argument is required.
666     center : float, optional
667         The value at which to center the colormap. Passing this value implies
668         use of a diverging colormap. Setting it to ``False`` prevents use of a
669         diverging colormap.
670     robust : bool, optional
671         If True and ``vmin`` or ``vmax`` are absent, the colormap range is
672         computed with 2nd and 98th percentiles instead of the extreme values.
673     extend : {"neither", "both", "min", "max"}, optional
674         How to draw arrows extending the colorbar beyond its limits. If not
675         provided, extend is inferred from vmin, vmax and the data limits.
676     levels : int or list-like object, optional
677         Split the colormap (cmap) into discrete color intervals. If an integer
678         is provided, "nice" levels are chosen based on the data range: this can
679         imply that the final number of levels is not exactly the expected one.
680         Setting ``vmin`` and/or ``vmax`` with ``levels=N`` is equivalent to
681         setting ``levels=np.linspace(vmin, vmax, N)``.
682     **kwargs : optional
683         Additional keyword arguments to matplotlib
684     """
685     plt = import_matplotlib_pyplot()
686 
687     # Handle facetgrids first
688     if row or col:
689         allargs = locals().copy()
690         allargs.update(allargs.pop("kwargs"))
691         allargs.pop("darray")
692         subplot_kws = dict(projection="3d") if z is not None else None
693         return _easy_facetgrid(
694             darray, scatter, kind="dataarray", subplot_kws=subplot_kws, **allargs
695         )
696 
697     # Further
698     _is_facetgrid = kwargs.pop("_is_facetgrid", False)
699     if _is_facetgrid:
700         # Why do I need to pop these here?
701         kwargs.pop("y", None)
702         kwargs.pop("args", None)
703         kwargs.pop("add_labels", None)
704 
705     _sizes = kwargs.pop("markersize", kwargs.pop("linewidth", None))
706     size_norm = kwargs.pop("size_norm", None)
707     size_mapping = kwargs.pop("size_mapping", None)  # set by facetgrid
708     cmap_params = kwargs.pop("cmap_params", None)
709 
710     figsize = kwargs.pop("figsize", None)
711     subplot_kws = dict()
712     if z is not None and ax is None:
713         # TODO: Importing Axes3D is not necessary in matplotlib >= 3.2.
714         # Remove when minimum requirement of matplotlib is 3.2:
715         from mpl_toolkits.mplot3d import Axes3D  # type: ignore # noqa
716 
717         subplot_kws.update(projection="3d")
718         ax = get_axis(figsize, size, aspect, ax, **subplot_kws)
719         # Using 30, 30 minimizes rotation of the plot. Making it easier to
720         # build on your intuition from 2D plots:
721         if LooseVersion(plt.matplotlib.__version__) < "3.5.0":
722             ax.view_init(azim=30, elev=30)
723         else:
724             # https://github.com/matplotlib/matplotlib/pull/19873
725             ax.view_init(azim=30, elev=30, vertical_axis="y")
726     else:
727         ax = get_axis(figsize, size, aspect, ax, **subplot_kws)
728 
729     _data = _infer_scatter_metadata(darray, x, z, hue, hue_style, _sizes)
730 
731     add_guide = kwargs.pop("add_guide", None)
732     if add_legend is not None:
733         pass
734     elif add_guide is None or add_guide is True:
735         add_legend = True if _data["hue_style"] == "discrete" else False
736     elif add_legend is None:
737         add_legend = False
738 
739     if add_colorbar is not None:
740         pass
741     elif add_guide is None or add_guide is True:
742         add_colorbar = True if _data["hue_style"] == "continuous" else False
743     else:
744         add_colorbar = False
745 
746     # need to infer size_mapping with full dataset
747     _data.update(
748         _infer_scatter_data(
749             darray,
750             x,
751             z,
752             hue,
753             _sizes,
754             size_norm,
755             size_mapping,
756             _MARKERSIZE_RANGE,
757         )
758     )
759 
760     cmap_params_subset = {}
761     if _data["hue"] is not None:
762         kwargs.update(c=_data["hue"].values.ravel())
763         cmap_params, cbar_kwargs = _process_cmap_cbar_kwargs(
764             scatter, _data["hue"].values, **locals()
765         )
766 
767         # subset that can be passed to scatter, hist2d
768         cmap_params_subset = {
769             vv: cmap_params[vv] for vv in ["vmin", "vmax", "norm", "cmap"]
770         }
771 
772     if _data["size"] is not None:
773         kwargs.update(s=_data["size"].values.ravel())
774 
775     if LooseVersion(plt.matplotlib.__version__) < "3.5.0":
776         # Plot the data. 3d plots has the z value in upward direction
777         # instead of y. To make jumping between 2d and 3d easy and intuitive
778         # switch the order so that z is shown in the depthwise direction:
779         axis_order = ["x", "z", "y"]
780     else:
781         # Switching axis order not needed in 3.5.0, can also simplify the code
782         # that uses axis_order:
783         # https://github.com/matplotlib/matplotlib/pull/19873
784         axis_order = ["x", "y", "z"]
785 
786     primitive = ax.scatter(
787         *[
788             _data[v].values.ravel()
789             for v in axis_order
790             if _data.get(v, None) is not None
791         ],
792         **cmap_params_subset,
793         **kwargs,
794     )
795 
796     # Set x, y, z labels:
797     i = 0
798     set_label = [ax.set_xlabel, ax.set_ylabel, getattr(ax, "set_zlabel", None)]
799     for v in axis_order:
800         if _data.get(f"{v}label", None) is not None:
801             set_label[i](_data[f"{v}label"])
802             i += 1
803 
804     if add_legend:
805 
806         def to_label(data, key, x):
807             """Map prop values back to its original values."""
808             if key in data:
809                 # Use reindex to be less sensitive to float errors.
810                 # Return as numpy array since legend_elements
811                 # seems to require that:
812                 return data[key].reindex(x, method="nearest").to_numpy()
813             else:
814                 return x
815 
816         handles, labels = [], []
817         for subtitle, prop, func in [
818             (
819                 _data["hue_label"],
820                 "colors",
821                 functools.partial(to_label, _data, "hue_to_label"),
822             ),
823             (
824                 _data["size_label"],
825                 "sizes",
826                 functools.partial(to_label, _data, "size_to_label"),
827             ),
828         ]:
829             if subtitle:
830                 # Get legend handles and labels that displays the
831                 # values correctly. Order might be different because
832                 # legend_elements uses np.unique instead of pd.unique,
833                 # FacetGrid.add_legend might have troubles with this:
834                 hdl, lbl = legend_elements(primitive, prop, num="auto", func=func)
835                 hdl, lbl = _legend_add_subtitle(hdl, lbl, subtitle, ax.scatter)
836                 handles += hdl
837                 labels += lbl
838         legend = ax.legend(handles, labels, framealpha=0.5)
839         _adjust_legend_subtitles(legend)
840 
841     if add_colorbar and _data["hue_label"]:
842         if _data["hue_style"] == "discrete":
843             raise NotImplementedError("Cannot create a colorbar for non numerics.")
844         cbar_kwargs = {} if cbar_kwargs is None else cbar_kwargs
845         if "label" not in cbar_kwargs:
846             cbar_kwargs["label"] = _data["hue_label"]
847         _add_colorbar(primitive, ax, cbar_ax, cbar_kwargs, cmap_params)
848 
849     return primitive
850 
851 
852 # MUST run before any 2d plotting functions are defined since
853 # _plot2d decorator adds them as methods here.
854 class _PlotMethods:
855     """
856     Enables use of xarray.plot functions as attributes on a DataArray.
857     For example, DataArray.plot.imshow
858     """
859 
860     __slots__ = ("_da",)
861 
862     def __init__(self, darray):
863         self._da = darray
864 
865     def __call__(self, **kwargs):
866         return plot(self._da, **kwargs)
867 
868     # we can't use functools.wraps here since that also modifies the name / qualname
869     __doc__ = __call__.__doc__ = plot.__doc__
870     __call__.__wrapped__ = plot  # type: ignore[attr-defined]
871     __call__.__annotations__ = plot.__annotations__
872 
873     @functools.wraps(hist)
874     def hist(self, ax=None, **kwargs):
875         return hist(self._da, ax=ax, **kwargs)
876 
877     @functools.wraps(line)
878     def line(self, *args, **kwargs):
879         return line(self._da, *args, **kwargs)
880 
881     @functools.wraps(step)
882     def step(self, *args, **kwargs):
883         return step(self._da, *args, **kwargs)
884 
885     @functools.wraps(scatter)
886     def _scatter(self, *args, **kwargs):
887         return scatter(self._da, *args, **kwargs)
888 
889 
890 def override_signature(f):
891     def wrapper(func):
892         func.__wrapped__ = f
893 
894         return func
895 
896     return wrapper
897 
898 
899 def _plot2d(plotfunc):
900     """
901     Decorator for common 2d plotting logic
902 
903     Also adds the 2d plot method to class _PlotMethods
904     """
905     commondoc = """
906     Parameters
907     ----------
908     darray : DataArray
909         Must be two-dimensional, unless creating faceted plots.
910     x : str, optional
911         Coordinate for *x* axis. If ``None``, use ``darray.dims[1]``.
912     y : str, optional
913         Coordinate for *y* axis. If ``None``, use ``darray.dims[0]``.
914     figsize : tuple, optional
915         A tuple (width, height) of the figure in inches.
916         Mutually exclusive with ``size`` and ``ax``.
917     aspect : scalar, optional
918         Aspect ratio of plot, so that ``aspect * size`` gives the *width* in
919         inches. Only used if a ``size`` is provided.
920     size : scalar, optional
921         If provided, create a new figure for the plot with the given size:
922         *height* (in inches) of each plot. See also: ``aspect``.
923     ax : matplotlib axes object, optional
924         Axes on which to plot. By default, use the current axes.
925         Mutually exclusive with ``size`` and ``figsize``.
926     row : string, optional
927         If passed, make row faceted plots on this dimension name.
928     col : string, optional
929         If passed, make column faceted plots on this dimension name.
930     col_wrap : int, optional
931         Use together with ``col`` to wrap faceted plots.
932     xscale, yscale : {'linear', 'symlog', 'log', 'logit'}, optional
933         Specifies scaling for the *x*- and *y*-axis, respectively.
934     xticks, yticks : array-like, optional
935         Specify tick locations for *x*- and *y*-axis.
936     xlim, ylim : array-like, optional
937         Specify *x*- and *y*-axis limits.
938     xincrease : None, True, or False, optional
939         Should the values on the *x* axis be increasing from left to right?
940         If ``None``, use the default for the Matplotlib function.
941     yincrease : None, True, or False, optional
942         Should the values on the *y* axis be increasing from top to bottom?
943         If ``None``, use the default for the Matplotlib function.
944     add_colorbar : bool, optional
945         Add colorbar to axes.
946     add_labels : bool, optional
947         Use xarray metadata to label axes.
948     norm : matplotlib.colors.Normalize, optional
949         If ``norm`` has ``vmin`` or ``vmax`` specified, the corresponding
950         kwarg must be ``None``.
951     vmin, vmax : float, optional
952         Values to anchor the colormap, otherwise they are inferred from the
953         data and other keyword arguments. When a diverging dataset is inferred,
954         setting one of these values will fix the other by symmetry around
955         ``center``. Setting both values prevents use of a diverging colormap.
956         If discrete levels are provided as an explicit list, both of these
957         values are ignored.
958     cmap : matplotlib colormap name or colormap, optional
959         The mapping from data values to color space. If not provided, this
960         will be either be ``'viridis'`` (if the function infers a sequential
961         dataset) or ``'RdBu_r'`` (if the function infers a diverging dataset).
962         See :doc:`Choosing Colormaps in Matplotlib <matplotlib:tutorials/colors/colormaps>`
963         for more information.
964 
965         If *seaborn* is installed, ``cmap`` may also be a
966         `seaborn color palette <https://seaborn.pydata.org/tutorial/color_palettes.html>`_.
967         Note: if ``cmap`` is a seaborn color palette and the plot type
968         is not ``'contour'`` or ``'contourf'``, ``levels`` must also be specified.
969     colors : str or array-like of color-like, optional
970         A single color or a sequence of colors. If the plot type is not ``'contour'``
971         or ``'contourf'``, the ``levels`` argument is required.
972     center : float, optional
973         The value at which to center the colormap. Passing this value implies
974         use of a diverging colormap. Setting it to ``False`` prevents use of a
975         diverging colormap.
976     robust : bool, optional
977         If ``True`` and ``vmin`` or ``vmax`` are absent, the colormap range is
978         computed with 2nd and 98th percentiles instead of the extreme values.
979     extend : {'neither', 'both', 'min', 'max'}, optional
980         How to draw arrows extending the colorbar beyond its limits. If not
981         provided, ``extend`` is inferred from ``vmin``, ``vmax`` and the data limits.
982     levels : int or array-like, optional
983         Split the colormap (``cmap``) into discrete color intervals. If an integer
984         is provided, "nice" levels are chosen based on the data range: this can
985         imply that the final number of levels is not exactly the expected one.
986         Setting ``vmin`` and/or ``vmax`` with ``levels=N`` is equivalent to
987         setting ``levels=np.linspace(vmin, vmax, N)``.
988     infer_intervals : bool, optional
989         Only applies to pcolormesh. If ``True``, the coordinate intervals are
990         passed to pcolormesh. If ``False``, the original coordinates are used
991         (this can be useful for certain map projections). The default is to
992         always infer intervals, unless the mesh is irregular and plotted on
993         a map projection.
994     subplot_kws : dict, optional
995         Dictionary of keyword arguments for Matplotlib subplots. Only used
996         for 2D and faceted plots.
997         (see :py:meth:`matplotlib:matplotlib.figure.Figure.add_subplot`).
998     cbar_ax : matplotlib axes object, optional
999         Axes in which to draw the colorbar.
1000     cbar_kwargs : dict, optional
1001         Dictionary of keyword arguments to pass to the colorbar
1002         (see :meth:`matplotlib:matplotlib.figure.Figure.colorbar`).
1003     **kwargs : optional
1004         Additional keyword arguments to wrapped Matplotlib function.
1005 
1006     Returns
1007     -------
1008     artist :
1009         The same type of primitive artist that the wrapped Matplotlib
1010         function returns.
1011     """
1012 
1013     # Build on the original docstring
1014     plotfunc.__doc__ = f"{plotfunc.__doc__}\n{commondoc}"
1015 
1016     # plotfunc and newplotfunc have different signatures:
1017     # - plotfunc: (x, y, z, ax, **kwargs)
1018     # - newplotfunc: (darray, x, y, **kwargs)
1019     # where plotfunc accepts numpy arrays, while newplotfunc accepts a DataArray
1020     # and variable names. newplotfunc also explicitly lists most kwargs, so we
1021     # need to shorten it
1022     def signature(darray, x, y, **kwargs):
1023         pass
1024 
1025     @override_signature(signature)
1026     @functools.wraps(plotfunc)
1027     def newplotfunc(
1028         darray,
1029         x=None,
1030         y=None,
1031         figsize=None,
1032         size=None,
1033         aspect=None,
1034         ax=None,
1035         row=None,
1036         col=None,
1037         col_wrap=None,
1038         xincrease=True,
1039         yincrease=True,
1040         add_colorbar=None,
1041         add_labels=True,
1042         vmin=None,
1043         vmax=None,
1044         cmap=None,
1045         center=None,
1046         robust=False,
1047         extend=None,
1048         levels=None,
1049         infer_intervals=None,
1050         colors=None,
1051         subplot_kws=None,
1052         cbar_ax=None,
1053         cbar_kwargs=None,
1054         xscale=None,
1055         yscale=None,
1056         xticks=None,
1057         yticks=None,
1058         xlim=None,
1059         ylim=None,
1060         norm=None,
1061         **kwargs,
1062     ):
1063         # All 2d plots in xarray share this function signature.
1064         # Method signature below should be consistent.
1065 
1066         # Decide on a default for the colorbar before facetgrids
1067         if add_colorbar is None:
1068             add_colorbar = True
1069             if plotfunc.__name__ == "contour" or (
1070                 plotfunc.__name__ == "surface" and cmap is None
1071             ):
1072                 add_colorbar = False
1073         imshow_rgb = plotfunc.__name__ == "imshow" and darray.ndim == (
1074             3 + (row is not None) + (col is not None)
1075         )
1076         if imshow_rgb:
1077             # Don't add a colorbar when showing an image with explicit colors
1078             add_colorbar = False
1079             # Matplotlib does not support normalising RGB data, so do it here.
1080             # See eg. https://github.com/matplotlib/matplotlib/pull/10220
1081             if robust or vmax is not None or vmin is not None:
1082                 darray = _rescale_imshow_rgb(darray, vmin, vmax, robust)
1083                 vmin, vmax, robust = None, None, False
1084 
1085         if subplot_kws is None:
1086             subplot_kws = dict()
1087 
1088         if plotfunc.__name__ == "surface" and not kwargs.get("_is_facetgrid", False):
1089             if ax is None:
1090                 # TODO: Importing Axes3D is no longer necessary in matplotlib >= 3.2.
1091                 # Remove when minimum requirement of matplotlib is 3.2:
1092                 from mpl_toolkits.mplot3d import Axes3D  # type: ignore  # noqa: F401
1093 
1094                 # delete so it does not end up in locals()
1095                 del Axes3D
1096 
1097                 # Need to create a "3d" Axes instance for surface plots
1098                 subplot_kws["projection"] = "3d"
1099 
1100             # In facet grids, shared axis labels don't make sense for surface plots
1101             sharex = False
1102             sharey = False
1103 
1104         # Handle facetgrids first
1105         if row or col:
1106             allargs = locals().copy()
1107             del allargs["darray"]
1108             del allargs["imshow_rgb"]
1109             allargs.update(allargs.pop("kwargs"))
1110             # Need the decorated plotting function
1111             allargs["plotfunc"] = globals()[plotfunc.__name__]
1112             return _easy_facetgrid(darray, kind="dataarray", **allargs)
1113 
1114         plt = import_matplotlib_pyplot()
1115 
1116         if (
1117             plotfunc.__name__ == "surface"
1118             and not kwargs.get("_is_facetgrid", False)
1119             and ax is not None
1120         ):
1121             import mpl_toolkits  # type: ignore
1122 
1123             if not isinstance(ax, mpl_toolkits.mplot3d.Axes3D):
1124                 raise ValueError(
1125                     "If ax is passed to surface(), it must be created with "
1126                     'projection="3d"'
1127                 )
1128 
1129         rgb = kwargs.pop("rgb", None)
1130         if rgb is not None and plotfunc.__name__ != "imshow":
1131             raise ValueError('The "rgb" keyword is only valid for imshow()')
1132         elif rgb is not None and not imshow_rgb:
1133             raise ValueError(
1134                 'The "rgb" keyword is only valid for imshow()'
1135                 "with a three-dimensional array (per facet)"
1136             )
1137 
1138         xlab, ylab = _infer_xy_labels(
1139             darray=darray, x=x, y=y, imshow=imshow_rgb, rgb=rgb
1140         )
1141 
1142         xval = darray[xlab]
1143         yval = darray[ylab]
1144 
1145         if xval.ndim > 1 or yval.ndim > 1 or plotfunc.__name__ == "surface":
1146             # Passing 2d coordinate values, need to ensure they are transposed the same
1147             # way as darray.
1148             # Also surface plots always need 2d coordinates
1149             xval = xval.broadcast_like(darray)
1150             yval = yval.broadcast_like(darray)
1151             dims = darray.dims
1152         else:
1153             dims = (yval.dims[0], xval.dims[0])
1154 
1155         # better to pass the ndarrays directly to plotting functions
1156         xval = xval.to_numpy()
1157         yval = yval.to_numpy()
1158 
1159         # May need to transpose for correct x, y labels
1160         # xlab may be the name of a coord, we have to check for dim names
1161         if imshow_rgb:
1162             # For RGB[A] images, matplotlib requires the color dimension
1163             # to be last.  In Xarray the order should be unimportant, so
1164             # we transpose to (y, x, color) to make this work.
1165             yx_dims = (ylab, xlab)
1166             dims = yx_dims + tuple(d for d in darray.dims if d not in yx_dims)
1167 
1168         if dims != darray.dims:
1169             darray = darray.transpose(*dims, transpose_coords=True)
1170 
1171         # Pass the data as a masked ndarray too
1172         zval = darray.to_masked_array(copy=False)
1173 
1174         # Replace pd.Intervals if contained in xval or yval.
1175         xplt, xlab_extra = _resolve_intervals_2dplot(xval, plotfunc.__name__)
1176         yplt, ylab_extra = _resolve_intervals_2dplot(yval, plotfunc.__name__)
1177 
1178         _ensure_plottable(xplt, yplt, zval)
1179 
1180         cmap_params, cbar_kwargs = _process_cmap_cbar_kwargs(
1181             plotfunc,
1182             zval.data,
1183             **locals(),
1184             _is_facetgrid=kwargs.pop("_is_facetgrid", False),
1185         )
1186 
1187         if "contour" in plotfunc.__name__:
1188             # extend is a keyword argument only for contour and contourf, but
1189             # passing it to the colorbar is sufficient for imshow and
1190             # pcolormesh
1191             kwargs["extend"] = cmap_params["extend"]
1192             kwargs["levels"] = cmap_params["levels"]
1193             # if colors == a single color, matplotlib draws dashed negative
1194             # contours. we lose this feature if we pass cmap and not colors
1195             if isinstance(colors, str):
1196                 cmap_params["cmap"] = None
1197                 kwargs["colors"] = colors
1198 
1199         if "pcolormesh" == plotfunc.__name__:
1200             kwargs["infer_intervals"] = infer_intervals
1201             kwargs["xscale"] = xscale
1202             kwargs["yscale"] = yscale
1203 
1204         if "imshow" == plotfunc.__name__ and isinstance(aspect, str):
1205             # forbid usage of mpl strings
1206             raise ValueError("plt.imshow's `aspect` kwarg is not available in xarray")
1207 
1208         ax = get_axis(figsize, size, aspect, ax, **subplot_kws)
1209 
1210         primitive = plotfunc(
1211             xplt,
1212             yplt,
1213             zval,
1214             ax=ax,
1215             cmap=cmap_params["cmap"],
1216             vmin=cmap_params["vmin"],
1217             vmax=cmap_params["vmax"],
1218             norm=cmap_params["norm"],
1219             **kwargs,
1220         )
1221 
1222         # Label the plot with metadata
1223         if add_labels:
1224             ax.set_xlabel(label_from_attrs(darray[xlab], xlab_extra))
1225             ax.set_ylabel(label_from_attrs(darray[ylab], ylab_extra))
1226             ax.set_title(darray._title_for_slice())
1227             if plotfunc.__name__ == "surface":
1228                 ax.set_zlabel(label_from_attrs(darray))
1229 
1230         if add_colorbar:
1231             if add_labels and "label" not in cbar_kwargs:
1232                 cbar_kwargs["label"] = label_from_attrs(darray)
1233             cbar = _add_colorbar(primitive, ax, cbar_ax, cbar_kwargs, cmap_params)
1234         elif cbar_ax is not None or cbar_kwargs:
1235             # inform the user about keywords which aren't used
1236             raise ValueError(
1237                 "cbar_ax and cbar_kwargs can't be used with add_colorbar=False."
1238             )
1239 
1240         # origin kwarg overrides yincrease
1241         if "origin" in kwargs:
1242             yincrease = None
1243 
1244         _update_axes(
1245             ax, xincrease, yincrease, xscale, yscale, xticks, yticks, xlim, ylim
1246         )
1247 
1248         # Rotate dates on xlabels
1249         # Do this without calling autofmt_xdate so that x-axes ticks
1250         # on other subplots (if any) are not deleted.
1251         # https://stackoverflow.com/questions/17430105/autofmt-xdate-deletes-x-axis-labels-of-all-subplots
1252         if np.issubdtype(xplt.dtype, np.datetime64):
1253             for xlabels in ax.get_xticklabels():
1254                 xlabels.set_rotation(30)
1255                 xlabels.set_ha("right")
1256 
1257         return primitive
1258 
1259     # For use as DataArray.plot.plotmethod
1260     @functools.wraps(newplotfunc)
1261     def plotmethod(
1262         _PlotMethods_obj,
1263         x=None,
1264         y=None,
1265         figsize=None,
1266         size=None,
1267         aspect=None,
1268         ax=None,
1269         row=None,
1270         col=None,
1271         col_wrap=None,
1272         xincrease=True,
1273         yincrease=True,
1274         add_colorbar=None,
1275         add_labels=True,
1276         vmin=None,
1277         vmax=None,
1278         cmap=None,
1279         colors=None,
1280         center=None,
1281         robust=False,
1282         extend=None,
1283         levels=None,
1284         infer_intervals=None,
1285         subplot_kws=None,
1286         cbar_ax=None,
1287         cbar_kwargs=None,
1288         xscale=None,
1289         yscale=None,
1290         xticks=None,
1291         yticks=None,
1292         xlim=None,
1293         ylim=None,
1294         norm=None,
1295         **kwargs,
1296     ):
1297         """
1298         The method should have the same signature as the function.
1299 
1300         This just makes the method work on Plotmethods objects,
1301         and passes all the other arguments straight through.
1302         """
1303         allargs = locals()
1304         allargs["darray"] = _PlotMethods_obj._da
1305         allargs.update(kwargs)
1306         for arg in ["_PlotMethods_obj", "newplotfunc", "kwargs"]:
1307             del allargs[arg]
1308         return newplotfunc(**allargs)
1309 
1310     # Add to class _PlotMethods
1311     setattr(_PlotMethods, plotmethod.__name__, plotmethod)
1312 
1313     return newplotfunc
1314 
1315 
1316 @_plot2d
1317 def imshow(x, y, z, ax, **kwargs):
1318     """
1319     Image plot of 2D DataArray.
1320 
1321     Wraps :py:func:`matplotlib:matplotlib.pyplot.imshow`.
1322 
1323     While other plot methods require the DataArray to be strictly
1324     two-dimensional, ``imshow`` also accepts a 3D array where some
1325     dimension can be interpreted as RGB or RGBA color channels and
1326     allows this dimension to be specified via the kwarg ``rgb=``.
1327 
1328     Unlike :py:func:`matplotlib:matplotlib.pyplot.imshow`, which ignores ``vmin``/``vmax``
1329     for RGB(A) data,
1330     xarray *will* use ``vmin`` and ``vmax`` for RGB(A) data
1331     by applying a single scaling factor and offset to all bands.
1332     Passing  ``robust=True`` infers ``vmin`` and ``vmax``
1333     :ref:`in the usual way <robust-plotting>`.
1334 
1335     .. note::
1336         This function needs uniformly spaced coordinates to
1337         properly label the axes. Call :py:meth:`DataArray.plot` to check.
1338 
1339     The pixels are centered on the coordinates. For example, if the coordinate
1340     value is 3.2, then the pixels for those coordinates will be centered on 3.2.
1341     """
1342 
1343     if x.ndim != 1 or y.ndim != 1:
1344         raise ValueError(
1345             "imshow requires 1D coordinates, try using pcolormesh or contour(f)"
1346         )
1347 
1348     def _center_pixels(x):
1349         """Center the pixels on the coordinates."""
1350         if np.issubdtype(x.dtype, str):
1351             # When using strings as inputs imshow converts it to
1352             # integers. Choose extent values which puts the indices in
1353             # in the center of the pixels:
1354             return 0 - 0.5, len(x) - 0.5
1355 
1356         try:
1357             # Center the pixels assuming uniform spacing:
1358             xstep = 0.5 * (x[1] - x[0])
1359         except IndexError:
1360             # Arbitrary default value, similar to matplotlib behaviour:
1361             xstep = 0.1
1362 
1363         return x[0] - xstep, x[-1] + xstep
1364 
1365     # Center the pixels:
1366     left, right = _center_pixels(x)
1367     top, bottom = _center_pixels(y)
1368 
1369     defaults = {"origin": "upper", "interpolation": "nearest"}
1370 
1371     if not hasattr(ax, "projection"):
1372         # not for cartopy geoaxes
1373         defaults["aspect"] = "auto"
1374 
1375     # Allow user to override these defaults
1376     defaults.update(kwargs)
1377 
1378     if defaults["origin"] == "upper":
1379         defaults["extent"] = [left, right, bottom, top]
1380     else:
1381         defaults["extent"] = [left, right, top, bottom]
1382 
1383     if z.ndim == 3:
1384         # matplotlib imshow uses black for missing data, but Xarray makes
1385         # missing data transparent.  We therefore add an alpha channel if
1386         # there isn't one, and set it to transparent where data is masked.
1387         if z.shape[-1] == 3:
1388             alpha = np.ma.ones(z.shape[:2] + (1,), dtype=z.dtype)
1389             if np.issubdtype(z.dtype, np.integer):
1390                 alpha *= 255
1391             z = np.ma.concatenate((z, alpha), axis=2)
1392         else:
1393             z = z.copy()
1394         z[np.any(z.mask, axis=-1), -1] = 0
1395 
1396     primitive = ax.imshow(z, **defaults)
1397 
1398     # If x or y are strings the ticklabels have been replaced with
1399     # integer indices. Replace them back to strings:
1400     for axis, v in [("x", x), ("y", y)]:
1401         if np.issubdtype(v.dtype, str):
1402             getattr(ax, f"set_{axis}ticks")(np.arange(len(v)))
1403             getattr(ax, f"set_{axis}ticklabels")(v)
1404 
1405     return primitive
1406 
1407 
1408 @_plot2d
1409 def contour(x, y, z, ax, **kwargs):
1410     """
1411     Contour plot of 2D DataArray.
1412 
1413     Wraps :py:func:`matplotlib:matplotlib.pyplot.contour`.
1414     """
1415     primitive = ax.contour(x, y, z, **kwargs)
1416     return primitive
1417 
1418 
1419 @_plot2d
1420 def contourf(x, y, z, ax, **kwargs):
1421     """
1422     Filled contour plot of 2D DataArray.
1423 
1424     Wraps :py:func:`matplotlib:matplotlib.pyplot.contourf`.
1425     """
1426     primitive = ax.contourf(x, y, z, **kwargs)
1427     return primitive
1428 
1429 
1430 @_plot2d
1431 def pcolormesh(x, y, z, ax, xscale=None, yscale=None, infer_intervals=None, **kwargs):
1432     """
1433     Pseudocolor plot of 2D DataArray.
1434 
1435     Wraps :py:func:`matplotlib:matplotlib.pyplot.pcolormesh`.
1436     """
1437 
1438     # decide on a default for infer_intervals (GH781)
1439     x = np.asarray(x)
1440     if infer_intervals is None:
1441         if hasattr(ax, "projection"):
1442             if len(x.shape) == 1:
1443                 infer_intervals = True
1444             else:
1445                 infer_intervals = False
1446         else:
1447             infer_intervals = True
1448 
1449     if (
1450         infer_intervals
1451         and not np.issubdtype(x.dtype, str)
1452         and (
1453             (np.shape(x)[0] == np.shape(z)[1])
1454             or ((x.ndim > 1) and (np.shape(x)[1] == np.shape(z)[1]))
1455         )
1456     ):
1457         if len(x.shape) == 1:
1458             x = _infer_interval_breaks(x, check_monotonic=True, scale=xscale)
1459         else:
1460             # we have to infer the intervals on both axes
1461             x = _infer_interval_breaks(x, axis=1, scale=xscale)
1462             x = _infer_interval_breaks(x, axis=0, scale=xscale)
1463 
1464     if (
1465         infer_intervals
1466         and not np.issubdtype(y.dtype, str)
1467         and (np.shape(y)[0] == np.shape(z)[0])
1468     ):
1469         if len(y.shape) == 1:
1470             y = _infer_interval_breaks(y, check_monotonic=True, scale=yscale)
1471         else:
1472             # we have to infer the intervals on both axes
1473             y = _infer_interval_breaks(y, axis=1, scale=yscale)
1474             y = _infer_interval_breaks(y, axis=0, scale=yscale)
1475 
1476     primitive = ax.pcolormesh(x, y, z, **kwargs)
1477 
1478     # by default, pcolormesh picks "round" values for bounds
1479     # this results in ugly looking plots with lots of surrounding whitespace
1480     if not hasattr(ax, "projection") and x.ndim == 1 and y.ndim == 1:
1481         # not a cartopy geoaxis
1482         ax.set_xlim(x[0], x[-1])
1483         ax.set_ylim(y[0], y[-1])
1484 
1485     return primitive
1486 
1487 
1488 @_plot2d
1489 def surface(x, y, z, ax, **kwargs):
1490     """
1491     Surface plot of 2D DataArray.
1492 
1493     Wraps :py:meth:`matplotlib:mpl_toolkits.mplot3d.axes3d.Axes3D.plot_surface`.
1494     """
1495     primitive = ax.plot_surface(x, y, z, **kwargs)
1496     return primitive

</code><intended_behavior>To resolve the issue, the plotting methods within this file should ensure that if a `long_name` attribute contains LaTeX expressions, it is correctly passed to matplotlib in a manner that enables LaTeX rendering. This means specifically checking for attributes that contain LaTeX strings and ensuring that matplotlib's rendering engine is explicitly instructed to interpret them as LaTeX. This may involve ensuring that the text properties passed to matplotlib plotting functions (like `xlabel`) correctly signal matplotlib to render the text as LaTeX, potentially by setting appropriate rcParams or directly formatting text labels.</intended_behavior>, <file>xarray/plot/utils.py</file>
<class>None</class>
<method>None</method>
<code>
1 import itertools
2 import textwrap
3 import warnings
4 from datetime import datetime
5 from inspect import getfullargspec
6 from typing import Any, Iterable, Mapping, Tuple, Union
7 
8 import numpy as np
9 import pandas as pd
10 
11 from ..core.options import OPTIONS
12 from ..core.pycompat import DuckArrayModule
13 from ..core.utils import is_scalar
14 
15 try:
16     import nc_time_axis  # noqa: F401
17 
18     nc_time_axis_available = True
19 except ImportError:
20     nc_time_axis_available = False
21 
22 ROBUST_PERCENTILE = 2.0
23 
24 
25 _registered = False
26 
27 
28 def register_pandas_datetime_converter_if_needed():
29     # based on https://github.com/pandas-dev/pandas/pull/17710
30     global _registered
31     if not _registered:
32         pd.plotting.register_matplotlib_converters()
33         _registered = True
34 
35 
36 def import_matplotlib_pyplot():
37     """Import pyplot as register appropriate converters."""
38     register_pandas_datetime_converter_if_needed()
39     import matplotlib.pyplot as plt
40 
41     return plt
42 
43 
44 def _determine_extend(calc_data, vmin, vmax):
45     extend_min = calc_data.min() < vmin
46     extend_max = calc_data.max() > vmax
47     if extend_min and extend_max:
48         return "both"
49     elif extend_min:
50         return "min"
51     elif extend_max:
52         return "max"
53     else:
54         return "neither"
55 
56 
57 def _build_discrete_cmap(cmap, levels, extend, filled):
58     """
59     Build a discrete colormap and normalization of the data.
60     """
61     import matplotlib as mpl
62 
63     if len(levels) == 1:
64         levels = [levels[0], levels[0]]
65 
66     if not filled:
67         # non-filled contour plots
68         extend = "max"
69 
70     if extend == "both":
71         ext_n = 2
72     elif extend in ["min", "max"]:
73         ext_n = 1
74     else:
75         ext_n = 0
76 
77     n_colors = len(levels) + ext_n - 1
78     pal = _color_palette(cmap, n_colors)
79 
80     new_cmap, cnorm = mpl.colors.from_levels_and_colors(levels, pal, extend=extend)
81     # copy the old cmap name, for easier testing
82     new_cmap.name = getattr(cmap, "name", cmap)
83 
84     # copy colors to use for bad, under, and over values in case they have been
85     # set to non-default values
86     try:
87         # matplotlib<3.2 only uses bad color for masked values
88         bad = cmap(np.ma.masked_invalid([np.nan]))[0]
89     except TypeError:
90         # cmap was a str or list rather than a color-map object, so there are
91         # no bad, under or over values to check or copy
92         pass
93     else:
94         under = cmap(-np.inf)
95         over = cmap(np.inf)
96 
97         new_cmap.set_bad(bad)
98 
99         # Only update under and over if they were explicitly changed by the user
100         # (i.e. are different from the lowest or highest values in cmap). Otherwise
101         # leave unchanged so new_cmap uses its default values (its own lowest and
102         # highest values).
103         if under != cmap(0):
104             new_cmap.set_under(under)
105         if over != cmap(cmap.N - 1):
106             new_cmap.set_over(over)
107 
108     return new_cmap, cnorm
109 
110 
111 def _color_palette(cmap, n_colors):
112     import matplotlib.pyplot as plt
113     from matplotlib.colors import ListedColormap
114 
115     colors_i = np.linspace(0, 1.0, n_colors)
116     if isinstance(cmap, (list, tuple)):
117         # we have a list of colors
118         cmap = ListedColormap(cmap, N=n_colors)
119         pal = cmap(colors_i)
120     elif isinstance(cmap, str):
121         # we have some sort of named palette
122         try:
123             # is this a matplotlib cmap?
124             cmap = plt.get_cmap(cmap)
125             pal = cmap(colors_i)
126         except ValueError:
127             # ValueError happens when mpl doesn't like a colormap, try seaborn
128             try:
129                 from seaborn import color_palette
130 
131                 pal = color_palette(cmap, n_colors=n_colors)
132             except (ValueError, ImportError):
133                 # or maybe we just got a single color as a string
134                 cmap = ListedColormap([cmap], N=n_colors)
135                 pal = cmap(colors_i)
136     else:
137         # cmap better be a LinearSegmentedColormap (e.g. viridis)
138         pal = cmap(colors_i)
139 
140     return pal
141 
142 
143 # _determine_cmap_params is adapted from Seaborn:
144 # https://github.com/mwaskom/seaborn/blob/v0.6/seaborn/matrix.py#L158
145 # Used under the terms of Seaborn's license, see licenses/SEABORN_LICENSE.
146 
147 
148 def _determine_cmap_params(
149     plot_data,
150     vmin=None,
151     vmax=None,
152     cmap=None,
153     center=None,
154     robust=False,
155     extend=None,
156     levels=None,
157     filled=True,
158     norm=None,
159     _is_facetgrid=False,
160 ):
161     """
162     Use some heuristics to set good defaults for colorbar and range.
163 
164     Parameters
165     ----------
166     plot_data : Numpy array
167         Doesn't handle xarray objects
168 
169     Returns
170     -------
171     cmap_params : dict
172         Use depends on the type of the plotting function
173     """
174     import matplotlib as mpl
175 
176     if isinstance(levels, Iterable):
177         levels = sorted(levels)
178 
179     calc_data = np.ravel(plot_data[np.isfinite(plot_data)])
180 
181     # Handle all-NaN input data gracefully
182     if calc_data.size == 0:
183         # Arbitrary default for when all values are NaN
184         calc_data = np.array(0.0)
185 
186     # Setting center=False prevents a divergent cmap
187     possibly_divergent = center is not False
188 
189     # Set center to 0 so math below makes sense but remember its state
190     center_is_none = False
191     if center is None:
192         center = 0
193         center_is_none = True
194 
195     # Setting both vmin and vmax prevents a divergent cmap
196     if (vmin is not None) and (vmax is not None):
197         possibly_divergent = False
198 
199     # Setting vmin or vmax implies linspaced levels
200     user_minmax = (vmin is not None) or (vmax is not None)
201 
202     # vlim might be computed below
203     vlim = None
204 
205     # save state; needed later
206     vmin_was_none = vmin is None
207     vmax_was_none = vmax is None
208 
209     if vmin is None:
210         if robust:
211             vmin = np.percentile(calc_data, ROBUST_PERCENTILE)
212         else:
213             vmin = calc_data.min()
214     elif possibly_divergent:
215         vlim = abs(vmin - center)
216 
217     if vmax is None:
218         if robust:
219             vmax = np.percentile(calc_data, 100 - ROBUST_PERCENTILE)
220         else:
221             vmax = calc_data.max()
222     elif possibly_divergent:
223         vlim = abs(vmax - center)
224 
225     if possibly_divergent:
226         levels_are_divergent = (
227             isinstance(levels, Iterable) and levels[0] * levels[-1] < 0
228         )
229         # kwargs not specific about divergent or not: infer defaults from data
230         divergent = (
231             ((vmin < 0) and (vmax > 0)) or not center_is_none or levels_are_divergent
232         )
233     else:
234         divergent = False
235 
236     # A divergent map should be symmetric around the center value
237     if divergent:
238         if vlim is None:
239             vlim = max(abs(vmin - center), abs(vmax - center))
240         vmin, vmax = -vlim, vlim
241 
242     # Now add in the centering value and set the limits
243     vmin += center
244     vmax += center
245 
246     # now check norm and harmonize with vmin, vmax
247     if norm is not None:
248         if norm.vmin is None:
249             norm.vmin = vmin
250         else:
251             if not vmin_was_none and vmin != norm.vmin:
252                 raise ValueError("Cannot supply vmin and a norm with a different vmin.")
253             vmin = norm.vmin
254 
255         if norm.vmax is None:
256             norm.vmax = vmax
257         else:
258             if not vmax_was_none and vmax != norm.vmax:
259                 raise ValueError("Cannot supply vmax and a norm with a different vmax.")
260             vmax = norm.vmax
261 
262     # if BoundaryNorm, then set levels
263     if isinstance(norm, mpl.colors.BoundaryNorm):
264         levels = norm.boundaries
265 
266     # Choose default colormaps if not provided
267     if cmap is None:
268         if divergent:
269             cmap = OPTIONS["cmap_divergent"]
270         else:
271             cmap = OPTIONS["cmap_sequential"]
272 
273     # Handle discrete levels
274     if levels is not None:
275         if is_scalar(levels):
276             if user_minmax:
277                 levels = np.linspace(vmin, vmax, levels)
278             elif levels == 1:
279                 levels = np.asarray([(vmin + vmax) / 2])
280             else:
281                 # N in MaxNLocator refers to bins, not ticks
282                 ticker = mpl.ticker.MaxNLocator(levels - 1)
283                 levels = ticker.tick_values(vmin, vmax)
284         vmin, vmax = levels[0], levels[-1]
285 
286     # GH3734
287     if vmin == vmax:
288         vmin, vmax = mpl.ticker.LinearLocator(2).tick_values(vmin, vmax)
289 
290     if extend is None:
291         extend = _determine_extend(calc_data, vmin, vmax)
292 
293     if levels is not None or isinstance(norm, mpl.colors.BoundaryNorm):
294         cmap, newnorm = _build_discrete_cmap(cmap, levels, extend, filled)
295         norm = newnorm if norm is None else norm
296 
297     # vmin & vmax needs to be None if norm is passed
298     # TODO: always return a norm with vmin and vmax
299     if norm is not None:
300         vmin = None
301         vmax = None
302 
303     return dict(
304         vmin=vmin, vmax=vmax, cmap=cmap, extend=extend, levels=levels, norm=norm
305     )
306 
307 
308 def _infer_xy_labels_3d(darray, x, y, rgb):
309     """
310     Determine x and y labels for showing RGB images.
311 
312     Attempts to infer which dimension is RGB/RGBA by size and order of dims.
313 
314     """
315     assert rgb is None or rgb != x
316     assert rgb is None or rgb != y
317     # Start by detecting and reporting invalid combinations of arguments
318     assert darray.ndim == 3
319     not_none = [a for a in (x, y, rgb) if a is not None]
320     if len(set(not_none)) < len(not_none):
321         raise ValueError(
322             "Dimension names must be None or unique strings, but imshow was "
323             f"passed x={x!r}, y={y!r}, and rgb={rgb!r}."
324         )
325     for label in not_none:
326         if label not in darray.dims:
327             raise ValueError(f"{label!r} is not a dimension")
328 
329     # Then calculate rgb dimension if certain and check validity
330     could_be_color = [
331         label
332         for label in darray.dims
333         if darray[label].size in (3, 4) and label not in (x, y)
334     ]
335     if rgb is None and not could_be_color:
336         raise ValueError(
337             "A 3-dimensional array was passed to imshow(), but there is no "
338             "dimension that could be color.  At least one dimension must be "
339             "of size 3 (RGB) or 4 (RGBA), and not given as x or y."
340         )
341     if rgb is None and len(could_be_color) == 1:
342         rgb = could_be_color[0]
343     if rgb is not None and darray[rgb].size not in (3, 4):
344         raise ValueError(
345             f"Cannot interpret dim {rgb!r} of size {darray[rgb].size} as RGB or RGBA."
346         )
347 
348     # If rgb dimension is still unknown, there must be two or three dimensions
349     # in could_be_color.  We therefore warn, and use a heuristic to break ties.
350     if rgb is None:
351         assert len(could_be_color) in (2, 3)
352         rgb = could_be_color[-1]
353         warnings.warn(
354             "Several dimensions of this array could be colors.  Xarray "
355             f"will use the last possible dimension ({rgb!r}) to match "
356             "matplotlib.pyplot.imshow.  You can pass names of x, y, "
357             "and/or rgb dimensions to override this guess."
358         )
359     assert rgb is not None
360 
361     # Finally, we pick out the red slice and delegate to the 2D version:
362     return _infer_xy_labels(darray.isel(**{rgb: 0}), x, y)
363 
364 
365 def _infer_xy_labels(darray, x, y, imshow=False, rgb=None):
366     """
367     Determine x and y labels. For use in _plot2d
368 
369     darray must be a 2 dimensional data array, or 3d for imshow only.
370     """
371     if (x is not None) and (x == y):
372         raise ValueError("x and y cannot be equal.")
373 
374     if imshow and darray.ndim == 3:
375         return _infer_xy_labels_3d(darray, x, y, rgb)
376 
377     if x is None and y is None:
378         if darray.ndim != 2:
379             raise ValueError("DataArray must be 2d")
380         y, x = darray.dims
381     elif x is None:
382         _assert_valid_xy(darray, y, "y")
383         x = darray.dims[0] if y == darray.dims[1] else darray.dims[1]
384     elif y is None:
385         _assert_valid_xy(darray, x, "x")
386         y = darray.dims[0] if x == darray.dims[1] else darray.dims[1]
387     else:
388         _assert_valid_xy(darray, x, "x")
389         _assert_valid_xy(darray, y, "y")
390 
391         if (
392             all(k in darray._level_coords for k in (x, y))
393             and darray._level_coords[x] == darray._level_coords[y]
394         ):
395             raise ValueError("x and y cannot be levels of the same MultiIndex")
396 
397     return x, y
398 
399 
400 def _assert_valid_xy(darray, xy, name):
401     """
402     make sure x and y passed to plotting functions are valid
403     """
404 
405     # MultiIndex cannot be plotted; no point in allowing them here
406     multiindex = {darray._level_coords[lc] for lc in darray._level_coords}
407 
408     valid_xy = (
409         set(darray.dims) | set(darray.coords) | set(darray._level_coords)
410     ) - multiindex
411 
412     if xy not in valid_xy:
413         valid_xy_str = "', '".join(sorted(valid_xy))
414         raise ValueError(f"{name} must be one of None, '{valid_xy_str}'")
415 
416 
417 def get_axis(figsize=None, size=None, aspect=None, ax=None, **kwargs):
418     try:
419         import matplotlib as mpl
420         import matplotlib.pyplot as plt
421     except ImportError:
422         raise ImportError("matplotlib is required for plot.utils.get_axis")
423 
424     if figsize is not None:
425         if ax is not None:
426             raise ValueError("cannot provide both `figsize` and `ax` arguments")
427         if size is not None:
428             raise ValueError("cannot provide both `figsize` and `size` arguments")
429         _, ax = plt.subplots(figsize=figsize)
430     elif size is not None:
431         if ax is not None:
432             raise ValueError("cannot provide both `size` and `ax` arguments")
433         if aspect is None:
434             width, height = mpl.rcParams["figure.figsize"]
435             aspect = width / height
436         figsize = (size * aspect, size)
437         _, ax = plt.subplots(figsize=figsize)
438     elif aspect is not None:
439         raise ValueError("cannot provide `aspect` argument without `size`")
440 
441     if kwargs and ax is not None:
442         raise ValueError("cannot use subplot_kws with existing ax")
443 
444     if ax is None:
445         ax = _maybe_gca(**kwargs)
446 
447     return ax
448 
449 
450 def _maybe_gca(**kwargs):
451 
452     import matplotlib.pyplot as plt
453 
454     # can call gcf unconditionally: either it exists or would be created by plt.axes
455     f = plt.gcf()
456 
457     # only call gca if an active axes exists
458     if f.axes:
459         # can not pass kwargs to active axes
460         return plt.gca()
461 
462     return plt.axes(**kwargs)
463 
464 
465 def label_from_attrs(da, extra=""):
466     """Makes informative labels if variable metadata (attrs) follows
467     CF conventions."""
468 
469     if da.attrs.get("long_name"):
470         name = da.attrs["long_name"]
471     elif da.attrs.get("standard_name"):
472         name = da.attrs["standard_name"]
473     elif da.name is not None:
474         name = da.name
475     else:
476         name = ""
477 
478     def _get_units_from_attrs(da):
479         if da.attrs.get("units"):
480             units = " [{}]".format(da.attrs["units"])
481         elif da.attrs.get("unit"):
482             units = " [{}]".format(da.attrs["unit"])
483         else:
484             units = ""
485         return units
486 
487     pint_array_type = DuckArrayModule("pint").type
488     if isinstance(da.data, pint_array_type):
489         units = " [{}]".format(str(da.data.units))
490     else:
491         units = _get_units_from_attrs(da)
492 
493     return "\n".join(textwrap.wrap(name + extra + units, 30))
494 
495 
496 def _interval_to_mid_points(array):
497     """
498     Helper function which returns an array
499     with the Intervals' mid points.
500     """
501 
502     return np.array([x.mid for x in array])
503 
504 
505 def _interval_to_bound_points(array):
506     """
507     Helper function which returns an array
508     with the Intervals' boundaries.
509     """
510 
511     array_boundaries = np.array([x.left for x in array])
512     array_boundaries = np.concatenate((array_boundaries, np.array([array[-1].right])))
513 
514     return array_boundaries
515 
516 
517 def _interval_to_double_bound_points(xarray, yarray):
518     """
519     Helper function to deal with a xarray consisting of pd.Intervals. Each
520     interval is replaced with both boundaries. I.e. the length of xarray
521     doubles. yarray is modified so it matches the new shape of xarray.
522     """
523 
524     xarray1 = np.array([x.left for x in xarray])
525     xarray2 = np.array([x.right for x in xarray])
526 
527     xarray = list(itertools.chain.from_iterable(zip(xarray1, xarray2)))
528     yarray = list(itertools.chain.from_iterable(zip(yarray, yarray)))
529 
530     return xarray, yarray
531 
532 
533 def _resolve_intervals_1dplot(xval, yval, kwargs):
534     """
535     Helper function to replace the values of x and/or y coordinate arrays
536     containing pd.Interval with their mid-points or - for step plots - double
537     points which double the length.
538     """
539     x_suffix = ""
540     y_suffix = ""
541 
542     # Is it a step plot? (see matplotlib.Axes.step)
543     if kwargs.get("drawstyle", "").startswith("steps-"):
544 
545         remove_drawstyle = False
546         # Convert intervals to double points
547         if _valid_other_type(np.array([xval, yval]), [pd.Interval]):
548             raise TypeError("Can't step plot intervals against intervals.")
549         if _valid_other_type(xval, [pd.Interval]):
550             xval, yval = _interval_to_double_bound_points(xval, yval)
551             remove_drawstyle = True
552         if _valid_other_type(yval, [pd.Interval]):
553             yval, xval = _interval_to_double_bound_points(yval, xval)
554             remove_drawstyle = True
555 
556         # Remove steps-* to be sure that matplotlib is not confused
557         if remove_drawstyle:
558             del kwargs["drawstyle"]
559 
560     # Is it another kind of plot?
561     else:
562 
563         # Convert intervals to mid points and adjust labels
564         if _valid_other_type(xval, [pd.Interval]):
565             xval = _interval_to_mid_points(xval)
566             x_suffix = "_center"
567         if _valid_other_type(yval, [pd.Interval]):
568             yval = _interval_to_mid_points(yval)
569             y_suffix = "_center"
570 
571     # return converted arguments
572     return xval, yval, x_suffix, y_suffix, kwargs
573 
574 
575 def _resolve_intervals_2dplot(val, func_name):
576     """
577     Helper function to replace the values of a coordinate array containing
578     pd.Interval with their mid-points or - for pcolormesh - boundaries which
579     increases length by 1.
580     """
581     label_extra = ""
582     if _valid_other_type(val, [pd.Interval]):
583         if func_name == "pcolormesh":
584             val = _interval_to_bound_points(val)
585         else:
586             val = _interval_to_mid_points(val)
587             label_extra = "_center"
588 
589     return val, label_extra
590 
591 
592 def _valid_other_type(x, types):
593     """
594     Do all elements of x have a type from types?
595     """
596     return all(any(isinstance(el, t) for t in types) for el in np.ravel(x))
597 
598 
599 def _valid_numpy_subdtype(x, numpy_types):
600     """
601     Is any dtype from numpy_types superior to the dtype of x?
602     """
603     # If any of the types given in numpy_types is understood as numpy.generic,
604     # all possible x will be considered valid.  This is probably unwanted.
605     for t in numpy_types:
606         assert not np.issubdtype(np.generic, t)
607 
608     return any(np.issubdtype(x.dtype, t) for t in numpy_types)
609 
610 
611 def _ensure_plottable(*args):
612     """
613     Raise exception if there is anything in args that can't be plotted on an
614     axis by matplotlib.
615     """
616     numpy_types = [
617         np.floating,
618         np.integer,
619         np.timedelta64,
620         np.datetime64,
621         np.bool_,
622         np.str_,
623     ]
624     other_types = [datetime]
625     try:
626         import cftime
627 
628         cftime_datetime = [cftime.datetime]
629     except ImportError:
630         cftime_datetime = []
631     other_types = other_types + cftime_datetime
632     for x in args:
633         if not (
634             _valid_numpy_subdtype(np.array(x), numpy_types)
635             or _valid_other_type(np.array(x), other_types)
636         ):
637             raise TypeError(
638                 "Plotting requires coordinates to be numeric, boolean, "
639                 "or dates of type numpy.datetime64, "
640                 "datetime.datetime, cftime.datetime or "
641                 f"pandas.Interval. Received data of type {np.array(x).dtype} instead."
642             )
643         if (
644             _valid_other_type(np.array(x), cftime_datetime)
645             and not nc_time_axis_available
646         ):
647             raise ImportError(
648                 "Plotting of arrays of cftime.datetime "
649                 "objects or arrays indexed by "
650                 "cftime.datetime objects requires the "
651                 "optional `nc-time-axis` (v1.2.0 or later) "
652                 "package."
653             )
654 
655 
656 def _is_numeric(arr):
657     numpy_types = [np.floating, np.integer]
658     return _valid_numpy_subdtype(arr, numpy_types)
659 
660 
661 def _add_colorbar(primitive, ax, cbar_ax, cbar_kwargs, cmap_params):
662 
663     cbar_kwargs.setdefault("extend", cmap_params["extend"])
664     if cbar_ax is None:
665         cbar_kwargs.setdefault("ax", ax)
666     else:
667         cbar_kwargs.setdefault("cax", cbar_ax)
668 
669     # dont pass extend as kwarg if it is in the mappable
670     if hasattr(primitive, "extend"):
671         cbar_kwargs.pop("extend")
672 
673     fig = ax.get_figure()
674     cbar = fig.colorbar(primitive, **cbar_kwargs)
675 
676     return cbar
677 
678 
679 def _rescale_imshow_rgb(darray, vmin, vmax, robust):
680     assert robust or vmin is not None or vmax is not None
681 
682     # Calculate vmin and vmax automatically for `robust=True`
683     if robust:
684         if vmax is None:
685             vmax = np.nanpercentile(darray, 100 - ROBUST_PERCENTILE)
686         if vmin is None:
687             vmin = np.nanpercentile(darray, ROBUST_PERCENTILE)
688     # If not robust and one bound is None, calculate the default other bound
689     # and check that an interval between them exists.
690     elif vmax is None:
691         vmax = 255 if np.issubdtype(darray.dtype, np.integer) else 1
692         if vmax < vmin:
693             raise ValueError(
694                 f"vmin={vmin!r} is less than the default vmax ({vmax!r}) - you must supply "
695                 "a vmax > vmin in this case."
696             )
697     elif vmin is None:
698         vmin = 0
699         if vmin > vmax:
700             raise ValueError(
701                 f"vmax={vmax!r} is less than the default vmin (0) - you must supply "
702                 "a vmin < vmax in this case."
703             )
704     # Scale interval [vmin .. vmax] to [0 .. 1], with darray as 64-bit float
705     # to avoid precision loss, integer over/underflow, etc with extreme inputs.
706     # After scaling, downcast to 32-bit float.  This substantially reduces
707     # memory usage after we hand `darray` off to matplotlib.
708     darray = ((darray.astype("f8") - vmin) / (vmax - vmin)).astype("f4")
709     return np.minimum(np.maximum(darray, 0), 1)
710 
711 
712 def _update_axes(
713     ax,
714     xincrease,
715     yincrease,
716     xscale=None,
717     yscale=None,
718     xticks=None,
719     yticks=None,
720     xlim=None,
721     ylim=None,
722 ):
723     """
724     Update axes with provided parameters
725     """
726     if xincrease is None:
727         pass
728     elif xincrease and ax.xaxis_inverted():
729         ax.invert_xaxis()
730     elif not xincrease and not ax.xaxis_inverted():
731         ax.invert_xaxis()
732 
733     if yincrease is None:
734         pass
735     elif yincrease and ax.yaxis_inverted():
736         ax.invert_yaxis()
737     elif not yincrease and not ax.yaxis_inverted():
738         ax.invert_yaxis()
739 
740     # The default xscale, yscale needs to be None.
741     # If we set a scale it resets the axes formatters,
742     # This means that set_xscale('linear') on a datetime axis
743     # will remove the date labels. So only set the scale when explicitly
744     # asked to. https://github.com/matplotlib/matplotlib/issues/8740
745     if xscale is not None:
746         ax.set_xscale(xscale)
747     if yscale is not None:
748         ax.set_yscale(yscale)
749 
750     if xticks is not None:
751         ax.set_xticks(xticks)
752     if yticks is not None:
753         ax.set_yticks(yticks)
754 
755     if xlim is not None:
756         ax.set_xlim(xlim)
757     if ylim is not None:
758         ax.set_ylim(ylim)
759 
760 
761 def _is_monotonic(coord, axis=0):
762     """
763     >>> _is_monotonic(np.array([0, 1, 2]))
764     True
765     >>> _is_monotonic(np.array([2, 1, 0]))
766     True
767     >>> _is_monotonic(np.array([0, 2, 1]))
768     False
769     """
770     if coord.shape[axis] < 3:
771         return True
772     else:
773         n = coord.shape[axis]
774         delta_pos = coord.take(np.arange(1, n), axis=axis) >= coord.take(
775             np.arange(0, n - 1), axis=axis
776         )
777         delta_neg = coord.take(np.arange(1, n), axis=axis) <= coord.take(
778             np.arange(0, n - 1), axis=axis
779         )
780         return np.all(delta_pos) or np.all(delta_neg)
781 
782 
783 def _infer_interval_breaks(coord, axis=0, scale=None, check_monotonic=False):
784     """
785     >>> _infer_interval_breaks(np.arange(5))
786     array([-0.5,  0.5,  1.5,  2.5,  3.5,  4.5])
787     >>> _infer_interval_breaks([[0, 1], [3, 4]], axis=1)
788     array([[-0.5,  0.5,  1.5],
789            [ 2.5,  3.5,  4.5]])
790     >>> _infer_interval_breaks(np.logspace(-2, 2, 5), scale="log")
791     array([3.16227766e-03, 3.16227766e-02, 3.16227766e-01, 3.16227766e+00,
792            3.16227766e+01, 3.16227766e+02])
793     """
794     coord = np.asarray(coord)
795 
796     if check_monotonic and not _is_monotonic(coord, axis=axis):
797         raise ValueError(
798             "The input coordinate is not sorted in increasing "
799             "order along axis %d. This can lead to unexpected "
800             "results. Consider calling the `sortby` method on "
801             "the input DataArray. To plot data with categorical "
802             "axes, consider using the `heatmap` function from "
803             "the `seaborn` statistical plotting library." % axis
804         )
805 
806     # If logscale, compute the intervals in the logarithmic space
807     if scale == "log":
808         if (coord <= 0).any():
809             raise ValueError(
810                 "Found negative or zero value in coordinates. "
811                 + "Coordinates must be positive on logscale plots."
812             )
813         coord = np.log10(coord)
814 
815     deltas = 0.5 * np.diff(coord, axis=axis)
816     if deltas.size == 0:
817         deltas = np.array(0.0)
818     first = np.take(coord, [0], axis=axis) - np.take(deltas, [0], axis=axis)
819     last = np.take(coord, [-1], axis=axis) + np.take(deltas, [-1], axis=axis)
820     trim_last = tuple(
821         slice(None, -1) if n == axis else slice(None) for n in range(coord.ndim)
822     )
823     interval_breaks = np.concatenate(
824         [first, coord[trim_last] + deltas, last], axis=axis
825     )
826     if scale == "log":
827         # Recovert the intervals into the linear space
828         return np.power(10, interval_breaks)
829     return interval_breaks
830 
831 
832 def _process_cmap_cbar_kwargs(
833     func,
834     data,
835     cmap=None,
836     colors=None,
837     cbar_kwargs: Union[Iterable[Tuple[str, Any]], Mapping[str, Any]] = None,
838     levels=None,
839     _is_facetgrid=False,
840     **kwargs,
841 ):
842     """
843     Parameters
844     ----------
845     func : plotting function
846     data : ndarray,
847         Data values
848 
849     Returns
850     -------
851     cmap_params
852     cbar_kwargs
853     """
854     if func.__name__ == "surface":
855         # Leave user to specify cmap settings for surface plots
856         kwargs["cmap"] = cmap
857         return {
858             k: kwargs.get(k, None)
859             for k in ["vmin", "vmax", "cmap", "extend", "levels", "norm"]
860         }, {}
861 
862     cbar_kwargs = {} if cbar_kwargs is None else dict(cbar_kwargs)
863 
864     if "contour" in func.__name__ and levels is None:
865         levels = 7  # this is the matplotlib default
866 
867     # colors is mutually exclusive with cmap
868     if cmap and colors:
869         raise ValueError("Can't specify both cmap and colors.")
870 
871     # colors is only valid when levels is supplied or the plot is of type
872     # contour or contourf
873     if colors and (("contour" not in func.__name__) and (levels is None)):
874         raise ValueError("Can only specify colors with contour or levels")
875 
876     # we should not be getting a list of colors in cmap anymore
877     # is there a better way to do this test?
878     if isinstance(cmap, (list, tuple)):
879         raise ValueError(
880             "Specifying a list of colors in cmap is deprecated. "
881             "Use colors keyword instead."
882         )
883 
884     cmap_kwargs = {
885         "plot_data": data,
886         "levels": levels,
887         "cmap": colors if colors else cmap,
888         "filled": func.__name__ != "contour",
889     }
890 
891     cmap_args = getfullargspec(_determine_cmap_params).args
892     cmap_kwargs.update((a, kwargs[a]) for a in cmap_args if a in kwargs)
893     if not _is_facetgrid:
894         cmap_params = _determine_cmap_params(**cmap_kwargs)
895     else:
896         cmap_params = {
897             k: cmap_kwargs[k]
898             for k in ["vmin", "vmax", "cmap", "extend", "levels", "norm"]
899         }
900 
901     return cmap_params, cbar_kwargs
902 
903 
904 def _get_nice_quiver_magnitude(u, v):
905     import matplotlib as mpl
906 
907     ticker = mpl.ticker.MaxNLocator(3)
908     mean = np.mean(np.hypot(u.to_numpy(), v.to_numpy()))
909     magnitude = ticker.tick_values(0, mean)[-2]
910     return magnitude
911 
912 
913 # Copied from matplotlib, tweaked so func can return strings.
914 # https://github.com/matplotlib/matplotlib/issues/19555
915 def legend_elements(
916     self, prop="colors", num="auto", fmt=None, func=lambda x: x, **kwargs
917 ):
918     """
919     Create legend handles and labels for a PathCollection.
920 
921     Each legend handle is a `.Line2D` representing the Path that was drawn,
922     and each label is a string what each Path represents.
923 
924     This is useful for obtaining a legend for a `~.Axes.scatter` plot;
925     e.g.::
926 
927         scatter = plt.scatter([1, 2, 3],  [4, 5, 6],  c=[7, 2, 3])
928         plt.legend(*scatter.legend_elements())
929 
930     creates three legend elements, one for each color with the numerical
931     values passed to *c* as the labels.
932 
933     Also see the :ref:`automatedlegendcreation` example.
934 
935 
936     Parameters
937     ----------
938     prop : {"colors", "sizes"}, default: "colors"
939         If "colors", the legend handles will show the different colors of
940         the collection. If "sizes", the legend will show the different
941         sizes. To set both, use *kwargs* to directly edit the `.Line2D`
942         properties.
943     num : int, None, "auto" (default), array-like, or `~.ticker.Locator`
944         Target number of elements to create.
945         If None, use all unique elements of the mappable array. If an
946         integer, target to use *num* elements in the normed range.
947         If *"auto"*, try to determine which option better suits the nature
948         of the data.
949         The number of created elements may slightly deviate from *num* due
950         to a `~.ticker.Locator` being used to find useful locations.
951         If a list or array, use exactly those elements for the legend.
952         Finally, a `~.ticker.Locator` can be provided.
953     fmt : str, `~matplotlib.ticker.Formatter`, or None (default)
954         The format or formatter to use for the labels. If a string must be
955         a valid input for a `~.StrMethodFormatter`. If None (the default),
956         use a `~.ScalarFormatter`.
957     func : function, default: ``lambda x: x``
958         Function to calculate the labels.  Often the size (or color)
959         argument to `~.Axes.scatter` will have been pre-processed by the
960         user using a function ``s = f(x)`` to make the markers visible;
961         e.g. ``size = np.log10(x)``.  Providing the inverse of this
962         function here allows that pre-processing to be inverted, so that
963         the legend labels have the correct values; e.g. ``func = lambda
964         x: 10**x``.
965     **kwargs
966         Allowed keyword arguments are *color* and *size*. E.g. it may be
967         useful to set the color of the markers if *prop="sizes"* is used;
968         similarly to set the size of the markers if *prop="colors"* is
969         used. Any further parameters are passed onto the `.Line2D`
970         instance. This may be useful to e.g. specify a different
971         *markeredgecolor* or *alpha* for the legend handles.
972 
973     Returns
974     -------
975     handles : list of `.Line2D`
976         Visual representation of each element of the legend.
977     labels : list of str
978         The string labels for elements of the legend.
979     """
980     import warnings
981 
982     import matplotlib as mpl
983 
984     mlines = mpl.lines
985 
986     handles = []
987     labels = []
988 
989     if prop == "colors":
990         arr = self.get_array()
991         if arr is None:
992             warnings.warn(
993                 "Collection without array used. Make sure to "
994                 "specify the values to be colormapped via the "
995                 "`c` argument."
996             )
997             return handles, labels
998         _size = kwargs.pop("size", mpl.rcParams["lines.markersize"])
999 
1000         def _get_color_and_size(value):
1001             return self.cmap(self.norm(value)), _size
1002 
1003     elif prop == "sizes":
1004         arr = self.get_sizes()
1005         _color = kwargs.pop("color", "k")
1006 
1007         def _get_color_and_size(value):
1008             return _color, np.sqrt(value)
1009 
1010     else:
1011         raise ValueError(
1012             "Valid values for `prop` are 'colors' or "
1013             f"'sizes'. You supplied '{prop}' instead."
1014         )
1015 
1016     # Get the unique values and their labels:
1017     values = np.unique(arr)
1018     label_values = np.asarray(func(values))
1019     label_values_are_numeric = np.issubdtype(label_values.dtype, np.number)
1020 
1021     # Handle the label format:
1022     if fmt is None and label_values_are_numeric:
1023         fmt = mpl.ticker.ScalarFormatter(useOffset=False, useMathText=True)
1024     elif fmt is None and not label_values_are_numeric:
1025         fmt = mpl.ticker.StrMethodFormatter("{x}")
1026     elif isinstance(fmt, str):
1027         fmt = mpl.ticker.StrMethodFormatter(fmt)
1028     fmt.create_dummy_axis()
1029 
1030     if num == "auto":
1031         num = 9
1032         if len(values) <= num:
1033             num = None
1034 
1035     if label_values_are_numeric:
1036         label_values_min = label_values.min()
1037         label_values_max = label_values.max()
1038         fmt.set_bounds(label_values_min, label_values_max)
1039 
1040         if num is not None:
1041             # Labels are numerical but larger than the target
1042             # number of elements, reduce to target using matplotlibs
1043             # ticker classes:
1044             if isinstance(num, mpl.ticker.Locator):
1045                 loc = num
1046             elif np.iterable(num):
1047                 loc = mpl.ticker.FixedLocator(num)
1048             else:
1049                 num = int(num)
1050                 loc = mpl.ticker.MaxNLocator(
1051                     nbins=num, min_n_ticks=num - 1, steps=[1, 2, 2.5, 3, 5, 6, 8, 10]
1052                 )
1053 
1054             # Get nicely spaced label_values:
1055             label_values = loc.tick_values(label_values_min, label_values_max)
1056 
1057             # Remove extrapolated label_values:
1058             cond = (label_values >= label_values_min) & (
1059                 label_values <= label_values_max
1060             )
1061             label_values = label_values[cond]
1062 
1063             # Get the corresponding values by creating a linear interpolant
1064             # with small step size:
1065             values_interp = np.linspace(values.min(), values.max(), 256)
1066             label_values_interp = func(values_interp)
1067             ix = np.argsort(label_values_interp)
1068             values = np.interp(label_values, label_values_interp[ix], values_interp[ix])
1069     elif num is not None and not label_values_are_numeric:
1070         # Labels are not numerical so modifying label_values is not
1071         # possible, instead filter the array with nicely distributed
1072         # indexes:
1073         if type(num) == int:
1074             loc = mpl.ticker.LinearLocator(num)
1075         else:
1076             raise ValueError("`num` only supports integers for non-numeric labels.")
1077 
1078         ind = loc.tick_values(0, len(label_values) - 1).astype(int)
1079         label_values = label_values[ind]
1080         values = values[ind]
1081 
1082     # Some formatters requires set_locs:
1083     if hasattr(fmt, "set_locs"):
1084         fmt.set_locs(label_values)
1085 
1086     # Default settings for handles, add or override with kwargs:
1087     kw = dict(markeredgewidth=self.get_linewidths()[0], alpha=self.get_alpha())
1088     kw.update(kwargs)
1089 
1090     for val, lab in zip(values, label_values):
1091         color, size = _get_color_and_size(val)
1092         h = mlines.Line2D(
1093             [0], [0], ls="", color=color, ms=size, marker=self.get_paths()[0], **kw
1094         )
1095         handles.append(h)
1096         labels.append(fmt(lab))
1097 
1098     return handles, labels
1099 
1100 
1101 def _legend_add_subtitle(handles, labels, text, func):
1102     """Add a subtitle to legend handles."""
1103     if text and len(handles) > 1:
1104         # Create a blank handle that's not visible, the
1105         # invisibillity will be used to discern which are subtitles
1106         # or not:
1107         blank_handle = func([], [], label=text)
1108         blank_handle.set_visible(False)
1109 
1110         # Subtitles are shown first:
1111         handles = [blank_handle] + handles
1112         labels = [text] + labels
1113 
1114     return handles, labels
1115 
1116 
1117 def _adjust_legend_subtitles(legend):
1118     """Make invisible-handle "subtitles" entries look more like titles."""
1119     plt = import_matplotlib_pyplot()
1120 
1121     # Legend title not in rcParams until 3.0
1122     font_size = plt.rcParams.get("legend.title_fontsize", None)
1123     hpackers = legend.findobj(plt.matplotlib.offsetbox.VPacker)[0].get_children()
1124     for hpack in hpackers:
1125         draw_area, text_area = hpack.get_children()
1126         handles = draw_area.get_children()
1127 
1128         # Assume that all artists that are not visible are
1129         # subtitles:
1130         if not all(artist.get_visible() for artist in handles):
1131             # Remove the dummy marker which will bring the text
1132             # more to the center:
1133             draw_area.set_width(0)
1134             for text in text_area.get_children():
1135                 if font_size is not None:
1136                     # The sutbtitles should have the same font size
1137                     # as normal legend titles:
1138                     text.set_size(font_size)

</code><intended_behavior>Utility functions that handle plot labels should respect and preserve LaTeX formatting in text passed to them. When attributes are extracted and processed for plotting labels, the code should ensure that LaTeX strings are recognized and retained in a format that matplotlib can render as LaTeX. This could involve detecting LaTeX in strings and ensuring they are formatted correctly for matplotlib (e.g., wrapping in `$` if not already done so) and not escaping special characters accidentally.</intended_behavior>]
2025-10-15 21:55:56.086 | INFO     | Search completed. Bug locations: [<file>xarray/plot/plot.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2 Use this module directly:
3     import xarray.plot as xplt
4 
5 Or use the methods on a DataArray or Dataset:
6     DataArray.plot._____
7     Dataset.plot._____
8 """
9 import functools
10 from distutils.version import LooseVersion
11 
12 import numpy as np
13 import pandas as pd
14 
15 from ..core.alignment import broadcast
16 from .facetgrid import _easy_facetgrid
17 from .utils import (
18     _add_colorbar,
19     _adjust_legend_subtitles,
20     _assert_valid_xy,
21     _ensure_plottable,
22     _infer_interval_breaks,
23     _infer_xy_labels,
24     _is_numeric,
25     _legend_add_subtitle,
26     _process_cmap_cbar_kwargs,
27     _rescale_imshow_rgb,
28     _resolve_intervals_1dplot,
29     _resolve_intervals_2dplot,
30     _update_axes,
31     get_axis,
32     import_matplotlib_pyplot,
33     label_from_attrs,
34     legend_elements,
35 )
36 
37 # copied from seaborn
38 _MARKERSIZE_RANGE = np.array([18.0, 72.0])
39 
40 
41 def _infer_scatter_metadata(darray, x, z, hue, hue_style, size):
42     def _determine_array(darray, name, array_style):
43         """Find and determine what type of array it is."""
44         array = darray[name]
45         array_is_numeric = _is_numeric(array.values)
46 
47         if array_style is None:
48             array_style = "continuous" if array_is_numeric else "discrete"
49         elif array_style not in ["discrete", "continuous"]:
50             raise ValueError(
51                 f"The style '{array_style}' is not valid, "
52                 "valid options are None, 'discrete' or 'continuous'."
53             )
54 
55         array_label = label_from_attrs(array)
56 
57         return array, array_style, array_label
58 
59     # Add nice looking labels:
60     out = dict(ylabel=label_from_attrs(darray))
61     out.update(
62         {
63             k: label_from_attrs(darray[v]) if v in darray.coords else None
64             for k, v in [("xlabel", x), ("zlabel", z)]
65         }
66     )
67 
68     # Add styles and labels for the dataarrays:
69     for type_, a, style in [("hue", hue, hue_style), ("size", size, None)]:
70         tp, stl, lbl = f"{type_}", f"{type_}_style", f"{type_}_label"
71         if a:
72             out[tp], out[stl], out[lbl] = _determine_array(darray, a, style)
73         else:
74             out[tp], out[stl], out[lbl] = None, None, None
75 
76     return out
77 
78 
79 # copied from seaborn
80 def _parse_size(data, norm, width):
81     """
82     Determine what type of data it is. Then normalize it to width.
83 
84     If the data is categorical, normalize it to numbers.
85     """
86     plt = import_matplotlib_pyplot()
87 
88     if data is None:
89         return None
90 
91     data = data.values.ravel()
92 
93     if not _is_numeric(data):
94         # Data is categorical.
95         # Use pd.unique instead of np.unique because that keeps
96         # the order of the labels:
97         levels = pd.unique(data)
98         numbers = np.arange(1, 1 + len(levels))
99     else:
100         levels = numbers = np.sort(np.unique(data))
101 
102     min_width, max_width = width
103     # width_range = min_width, max_width
104 
105     if norm is None:
106         norm = plt.Normalize()
107     elif isinstance(norm, tuple):
108         norm = plt.Normalize(*norm)
109     elif not isinstance(norm, plt.Normalize):
110         err = "``size_norm`` must be None, tuple, or Normalize object."
111         raise ValueError(err)
112 
113     norm.clip = True
114     if not norm.scaled():
115         norm(np.asarray(numbers))
116     # limits = norm.vmin, norm.vmax
117 
118     scl = norm(numbers)
119     widths = np.asarray(min_width + scl * (max_width - min_width))
120     if scl.mask.any():
121         widths[scl.mask] = 0
122     sizes = dict(zip(levels, widths))
123 
124     return pd.Series(sizes)
125 
126 
127 def _infer_scatter_data(
128     darray, x, z, hue, size, size_norm, size_mapping=None, size_range=(1, 10)
129 ):
130     # Broadcast together all the chosen variables:
131     to_broadcast = dict(y=darray)
132     to_broadcast.update(
133         {k: darray[v] for k, v in dict(x=x, z=z).items() if v is not None}
134     )
135     to_broadcast.update(
136         {k: darray[v] for k, v in dict(hue=hue, size=size).items() if v in darray.dims}
137     )
138     broadcasted = dict(zip(to_broadcast.keys(), broadcast(*(to_broadcast.values()))))
139 
140     # Normalize hue and size and create lookup tables:
141     for type_, mapping, norm, width in [
142         ("hue", None, None, [0, 1]),
143         ("size", size_mapping, size_norm, size_range),
144     ]:
145         broadcasted_type = broadcasted.get(type_, None)
146         if broadcasted_type is not None:
147             if mapping is None:
148                 mapping = _parse_size(broadcasted_type, norm, width)
149 
150             broadcasted[type_] = broadcasted_type.copy(
151                 data=np.reshape(
152                     mapping.loc[broadcasted_type.values.ravel()].values,
153                     broadcasted_type.shape,
154                 )
155             )
156             broadcasted[f"{type_}_to_label"] = pd.Series(mapping.index, index=mapping)
157 
158     return broadcasted
159 
160 
161 def _infer_line_data(darray, x, y, hue):
162 
163     ndims = len(darray.dims)
164 
165     if x is not None and y is not None:
166         raise ValueError("Cannot specify both x and y kwargs for line plots.")
167 
168     if x is not None:
169         _assert_valid_xy(darray, x, "x")
170 
171     if y is not None:
172         _assert_valid_xy(darray, y, "y")
173 
174     if ndims == 1:
175         huename = None
176         hueplt = None
177         huelabel = ""
178 
179         if x is not None:
180             xplt = darray[x]
181             yplt = darray
182 
183         elif y is not None:
184             xplt = darray
185             yplt = darray[y]
186 
187         else:  # Both x & y are None
188             dim = darray.dims[0]
189             xplt = darray[dim]
190             yplt = darray
191 
192     else:
193         if x is None and y is None and hue is None:
194             raise ValueError("For 2D inputs, please specify either hue, x or y.")
195 
196         if y is None:
197             if hue is not None:
198                 _assert_valid_xy(darray, hue, "hue")
199             xname, huename = _infer_xy_labels(darray=darray, x=x, y=hue)
200             xplt = darray[xname]
201             if xplt.ndim > 1:
202                 if huename in darray.dims:
203                     otherindex = 1 if darray.dims.index(huename) == 0 else 0
204                     otherdim = darray.dims[otherindex]
205                     yplt = darray.transpose(otherdim, huename, transpose_coords=False)
206                     xplt = xplt.transpose(otherdim, huename, transpose_coords=False)
207                 else:
208                     raise ValueError(
209                         "For 2D inputs, hue must be a dimension"
210                         " i.e. one of " + repr(darray.dims)
211                     )
212 
213             else:
214                 (xdim,) = darray[xname].dims
215                 (huedim,) = darray[huename].dims
216                 yplt = darray.transpose(xdim, huedim)
217 
218         else:
219             yname, huename = _infer_xy_labels(darray=darray, x=y, y=hue)
220             yplt = darray[yname]
221             if yplt.ndim > 1:
222                 if huename in darray.dims:
223                     otherindex = 1 if darray.dims.index(huename) == 0 else 0
224                     otherdim = darray.dims[otherindex]
225                     xplt = darray.transpose(otherdim, huename, transpose_coords=False)
226                     yplt = yplt.transpose(otherdim, huename, transpose_coords=False)
227                 else:
228                     raise ValueError(
229                         "For 2D inputs, hue must be a dimension"
230                         " i.e. one of " + repr(darray.dims)
231                     )
232 
233             else:
234                 (ydim,) = darray[yname].dims
235                 (huedim,) = darray[huename].dims
236                 xplt = darray.transpose(ydim, huedim)
237 
238         huelabel = label_from_attrs(darray[huename])
239         hueplt = darray[huename]
240 
241     return xplt, yplt, hueplt, huelabel
242 
243 
244 def plot(
245     darray,
246     row=None,
247     col=None,
248     col_wrap=None,
249     ax=None,
250     hue=None,
251     rtol=0.01,
252     subplot_kws=None,
253     **kwargs,
254 ):
255     """
256     Default plot of DataArray using :py:mod:`matplotlib:matplotlib.pyplot`.
257 
258     Calls xarray plotting function based on the dimensions of
259     the squeezed DataArray.
260 
261     =============== ===========================
262     Dimensions      Plotting function
263     =============== ===========================
264     1               :py:func:`xarray.plot.line`
265     2               :py:func:`xarray.plot.pcolormesh`
266     Anything else   :py:func:`xarray.plot.hist`
267     =============== ===========================
268 
269     Parameters
270     ----------
271     darray : DataArray
272     row : str, optional
273         If passed, make row faceted plots on this dimension name.
274     col : str, optional
275         If passed, make column faceted plots on this dimension name.
276     hue : str, optional
277         If passed, make faceted line plots with hue on this dimension name.
278     col_wrap : int, optional
279         Use together with ``col`` to wrap faceted plots.
280     ax : matplotlib axes object, optional
281         If ``None``, use the current axes. Not applicable when using facets.
282     rtol : float, optional
283         Relative tolerance used to determine if the indexes
284         are uniformly spaced. Usually a small positive number.
285     subplot_kws : dict, optional
286         Dictionary of keyword arguments for Matplotlib subplots
287         (see :py:meth:`matplotlib:matplotlib.figure.Figure.add_subplot`).
288     **kwargs : optional
289         Additional keyword arguments for Matplotlib.
290 
291     See Also
292     --------
293     xarray.DataArray.squeeze
294     """
295     darray = darray.squeeze().compute()
296 
297     plot_dims = set(darray.dims)
298     plot_dims.discard(row)
299     plot_dims.discard(col)
300     plot_dims.discard(hue)
301 
302     ndims = len(plot_dims)
303 
304     error_msg = (
305         "Only 1d and 2d plots are supported for facets in xarray. "
306         "See the package `Seaborn` for more options."
307     )
308 
309     if ndims in [1, 2]:
310         if row or col:
311             kwargs["subplot_kws"] = subplot_kws
312             kwargs["row"] = row
313             kwargs["col"] = col
314             kwargs["col_wrap"] = col_wrap
315         if ndims == 1:
316             plotfunc = line
317             kwargs["hue"] = hue
318         elif ndims == 2:
319             if hue:
320                 plotfunc = line
321                 kwargs["hue"] = hue
322             else:
323                 plotfunc = pcolormesh
324                 kwargs["subplot_kws"] = subplot_kws
325     else:
326         if row or col or hue:
327             raise ValueError(error_msg)
328         plotfunc = hist
329 
330     kwargs["ax"] = ax
331 
332     return plotfunc(darray, **kwargs)
333 
334 
335 # This function signature should not change so that it can use
336 # matplotlib format strings
337 def line(
338     darray,
339     *args,
340     row=None,
341     col=None,
342     figsize=None,
343     aspect=None,
344     size=None,
345     ax=None,
346     hue=None,
347     x=None,
348     y=None,
349     xincrease=None,
350     yincrease=None,
351     xscale=None,
352     yscale=None,
353     xticks=None,
354     yticks=None,
355     xlim=None,
356     ylim=None,
357     add_legend=True,
358     _labels=True,
359     **kwargs,
360 ):
361     """
362     Line plot of DataArray values.
363 
364     Wraps :py:func:`matplotlib:matplotlib.pyplot.plot`.
365 
366     Parameters
367     ----------
368     darray : DataArray
369         Either 1D or 2D. If 2D, one of ``hue``, ``x`` or ``y`` must be provided.
370     figsize : tuple, optional
371         A tuple (width, height) of the figure in inches.
372         Mutually exclusive with ``size`` and ``ax``.
373     aspect : scalar, optional
374         Aspect ratio of plot, so that ``aspect * size`` gives the *width* in
375         inches. Only used if a ``size`` is provided.
376     size : scalar, optional
377         If provided, create a new figure for the plot with the given size:
378         *height* (in inches) of each plot. See also: ``aspect``.
379     ax : matplotlib axes object, optional
380         Axes on which to plot. By default, the current is used.
381         Mutually exclusive with ``size`` and ``figsize``.
382     hue : str, optional
383         Dimension or coordinate for which you want multiple lines plotted.
384         If plotting against a 2D coordinate, ``hue`` must be a dimension.
385     x, y : str, optional
386         Dimension, coordinate or multi-index level for *x*, *y* axis.
387         Only one of these may be specified.
388         The other will be used for values from the DataArray on which this
389         plot method is called.
390     xscale, yscale : {'linear', 'symlog', 'log', 'logit'}, optional
391         Specifies scaling for the *x*- and *y*-axis, respectively.
392     xticks, yticks : array-like, optional
393         Specify tick locations for *x*- and *y*-axis.
394     xlim, ylim : array-like, optional
395         Specify *x*- and *y*-axis limits.
396     xincrease : None, True, or False, optional
397         Should the values on the *x* axis be increasing from left to right?
398         if ``None``, use the default for the Matplotlib function.
399     yincrease : None, True, or False, optional
400         Should the values on the *y* axis be increasing from top to bottom?
401         if ``None``, use the default for the Matplotlib function.
402     add_legend : bool, optional
403         Add legend with *y* axis coordinates (2D inputs only).
404     *args, **kwargs : optional
405         Additional arguments to :py:func:`matplotlib:matplotlib.pyplot.plot`.
406     """
407     # Handle facetgrids first
408     if row or col:
409         allargs = locals().copy()
410         allargs.update(allargs.pop("kwargs"))
411         allargs.pop("darray")
412         return _easy_facetgrid(darray, line, kind="line", **allargs)
413 
414     ndims = len(darray.dims)
415     if ndims > 2:
416         raise ValueError(
417             "Line plots are for 1- or 2-dimensional DataArrays. "
418             "Passed DataArray has {ndims} "
419             "dimensions".format(ndims=ndims)
420         )
421 
422     # The allargs dict passed to _easy_facetgrid above contains args
423     if args == ():
424         args = kwargs.pop("args", ())
425     else:
426         assert "args" not in kwargs
427 
428     ax = get_axis(figsize, size, aspect, ax)
429     xplt, yplt, hueplt, hue_label = _infer_line_data(darray, x, y, hue)
430 
431     # Remove pd.Intervals if contained in xplt.values and/or yplt.values.
432     xplt_val, yplt_val, x_suffix, y_suffix, kwargs = _resolve_intervals_1dplot(
433         xplt.to_numpy(), yplt.to_numpy(), kwargs
434     )
435     xlabel = label_from_attrs(xplt, extra=x_suffix)
436     ylabel = label_from_attrs(yplt, extra=y_suffix)
437 
438     _ensure_plottable(xplt_val, yplt_val)
439 
440     primitive = ax.plot(xplt_val, yplt_val, *args, **kwargs)
441 
442     if _labels:
443         if xlabel is not None:
444             ax.set_xlabel(xlabel)
445 
446         if ylabel is not None:
447             ax.set_ylabel(ylabel)
448 
449         ax.set_title(darray._title_for_slice())
450 
451     if darray.ndim == 2 and add_legend:
452         ax.legend(handles=primitive, labels=list(hueplt.to_numpy()), title=hue_label)
453 
454     # Rotate dates on xlabels
455     # Do this without calling autofmt_xdate so that x-axes ticks
456     # on other subplots (if any) are not deleted.
457     # https://stackoverflow.com/questions/17430105/autofmt-xdate-deletes-x-axis-labels-of-all-subplots
458     if np.issubdtype(xplt.dtype, np.datetime64):
459         for xlabels in ax.get_xticklabels():
460             xlabels.set_rotation(30)
461             xlabels.set_ha("right")
462 
463     _update_axes(ax, xincrease, yincrease, xscale, yscale, xticks, yticks, xlim, ylim)
464 
465     return primitive
466 
467 
468 def step(darray, *args, where="pre", drawstyle=None, ds=None, **kwargs):
469     """
470     Step plot of DataArray values.
471 
472     Similar to :py:func:`matplotlib:matplotlib.pyplot.step`.
473 
474     Parameters
475     ----------
476     where : {'pre', 'post', 'mid'}, default: 'pre'
477         Define where the steps should be placed:
478 
479         - ``'pre'``: The y value is continued constantly to the left from
480           every *x* position, i.e. the interval ``(x[i-1], x[i]]`` has the
481           value ``y[i]``.
482         - ``'post'``: The y value is continued constantly to the right from
483           every *x* position, i.e. the interval ``[x[i], x[i+1])`` has the
484           value ``y[i]``.
485         - ``'mid'``: Steps occur half-way between the *x* positions.
486 
487         Note that this parameter is ignored if one coordinate consists of
488         :py:class:`pandas.Interval` values, e.g. as a result of
489         :py:func:`xarray.Dataset.groupby_bins`. In this case, the actual
490         boundaries of the interval are used.
491     *args, **kwargs : optional
492         Additional arguments for :py:func:`xarray.plot.line`.
493     """
494     if where not in {"pre", "post", "mid"}:
495         raise ValueError("'where' argument to step must be 'pre', 'post' or 'mid'")
496 
497     if ds is not None:
498         if drawstyle is None:
499             drawstyle = ds
500         else:
501             raise TypeError("ds and drawstyle are mutually exclusive")
502     if drawstyle is None:
503         drawstyle = ""
504     drawstyle = "steps-" + where + drawstyle
505 
506     return line(darray, *args, drawstyle=drawstyle, **kwargs)
507 
508 
509 def hist(
510     darray,
511     figsize=None,
512     size=None,
513     aspect=None,
514     ax=None,
515     xincrease=None,
516     yincrease=None,
517     xscale=None,
518     yscale=None,
519     xticks=None,
520     yticks=None,
521     xlim=None,
522     ylim=None,
523     **kwargs,
524 ):
525     """
526     Histogram of DataArray.
527 
528     Wraps :py:func:`matplotlib:matplotlib.pyplot.hist`.
529 
530     Plots *N*-dimensional arrays by first flattening the array.
531 
532     Parameters
533     ----------
534     darray : DataArray
535         Can have any number of dimensions.
536     figsize : tuple, optional
537         A tuple (width, height) of the figure in inches.
538         Mutually exclusive with ``size`` and ``ax``.
539     aspect : scalar, optional
540         Aspect ratio of plot, so that ``aspect * size`` gives the *width* in
541         inches. Only used if a ``size`` is provided.
542     size : scalar, optional
543         If provided, create a new figure for the plot with the given size:
544         *height* (in inches) of each plot. See also: ``aspect``.
545     ax : matplotlib axes object, optional
546         Axes on which to plot. By default, use the current axes.
547         Mutually exclusive with ``size`` and ``figsize``.
548     **kwargs : optional
549         Additional keyword arguments to :py:func:`matplotlib:matplotlib.pyplot.hist`.
550 
551     """
552     ax = get_axis(figsize, size, aspect, ax)
553 
554     no_nan = np.ravel(darray.to_numpy())
555     no_nan = no_nan[pd.notnull(no_nan)]
556 
557     primitive = ax.hist(no_nan, **kwargs)
558 
559     ax.set_title("Histogram")
560     ax.set_xlabel(label_from_attrs(darray))
561 
562     _update_axes(ax, xincrease, yincrease, xscale, yscale, xticks, yticks, xlim, ylim)
563 
564     return primitive
565 
566 
567 def scatter(
568     darray,
569     *args,
570     row=None,
571     col=None,
572     figsize=None,
573     aspect=None,
574     size=None,
575     ax=None,
576     hue=None,
577     hue_style=None,
578     x=None,
579     z=None,
580     xincrease=None,
581     yincrease=None,
582     xscale=None,
583     yscale=None,
584     xticks=None,
585     yticks=None,
586     xlim=None,
587     ylim=None,
588     add_legend=None,
589     add_colorbar=None,
590     cbar_kwargs=None,
591     cbar_ax=None,
592     vmin=None,
593     vmax=None,
594     norm=None,
595     infer_intervals=None,
596     center=None,
597     levels=None,
598     robust=None,
599     colors=None,
600     extend=None,
601     cmap=None,
602     _labels=True,
603     **kwargs,
604 ):
605     """
606     Scatter plot a DataArray along some coordinates.
607 
608     Parameters
609     ----------
610     darray : DataArray
611         Dataarray to plot.
612     x, y : str
613         Variable names for x, y axis.
614     hue: str, optional
615         Variable by which to color scattered points
616     hue_style: str, optional
617         Can be either 'discrete' (legend) or 'continuous' (color bar).
618     markersize: str, optional
619         scatter only. Variable by which to vary size of scattered points.
620     size_norm: optional
621         Either None or 'Norm' instance to normalize the 'markersize' variable.
622     add_guide: bool, optional
623         Add a guide that depends on hue_style
624             - for "discrete", build a legend.
625               This is the default for non-numeric `hue` variables.
626             - for "continuous",  build a colorbar
627     row : str, optional
628         If passed, make row faceted plots on this dimension name
629     col : str, optional
630         If passed, make column faceted plots on this dimension name
631     col_wrap : int, optional
632         Use together with ``col`` to wrap faceted plots
633     ax : matplotlib axes object, optional
634         If None, uses the current axis. Not applicable when using facets.
635     subplot_kws : dict, optional
636         Dictionary of keyword arguments for matplotlib subplots. Only applies
637         to FacetGrid plotting.
638     aspect : scalar, optional
639         Aspect ratio of plot, so that ``aspect * size`` gives the width in
640         inches. Only used if a ``size`` is provided.
641     size : scalar, optional
642         If provided, create a new figure for the plot with the given size.
643         Height (in inches) of each plot. See also: ``aspect``.
644     norm : ``matplotlib.colors.Normalize`` instance, optional
645         If the ``norm`` has vmin or vmax specified, the corresponding kwarg
646         must be None.
647     vmin, vmax : float, optional
648         Values to anchor the colormap, otherwise they are inferred from the
649         data and other keyword arguments. When a diverging dataset is inferred,
650         setting one of these values will fix the other by symmetry around
651         ``center``. Setting both values prevents use of a diverging colormap.
652         If discrete levels are provided as an explicit list, both of these
653         values are ignored.
654     cmap : str or colormap, optional
655         The mapping from data values to color space. Either a
656         matplotlib colormap name or object. If not provided, this will
657         be either ``viridis`` (if the function infers a sequential
658         dataset) or ``RdBu_r`` (if the function infers a diverging
659         dataset).  When `Seaborn` is installed, ``cmap`` may also be a
660         `seaborn` color palette. If ``cmap`` is seaborn color palette
661         and the plot type is not ``contour`` or ``contourf``, ``levels``
662         must also be specified.
663     colors : color-like or list of color-like, optional
664         A single color or a list of colors. If the plot type is not ``contour``
665         or ``contourf``, the ``levels`` argument is required.
666     center : float, optional
667         The value at which to center the colormap. Passing this value implies
668         use of a diverging colormap. Setting it to ``False`` prevents use of a
669         diverging colormap.
670     robust : bool, optional
671         If True and ``vmin`` or ``vmax`` are absent, the colormap range is
672         computed with 2nd and 98th percentiles instead of the extreme values.
673     extend : {"neither", "both", "min", "max"}, optional
674         How to draw arrows extending the colorbar beyond its limits. If not
675         provided, extend is inferred from vmin, vmax and the data limits.
676     levels : int or list-like object, optional
677         Split the colormap (cmap) into discrete color intervals. If an integer
678         is provided, "nice" levels are chosen based on the data range: this can
679         imply that the final number of levels is not exactly the expected one.
680         Setting ``vmin`` and/or ``vmax`` with ``levels=N`` is equivalent to
681         setting ``levels=np.linspace(vmin, vmax, N)``.
682     **kwargs : optional
683         Additional keyword arguments to matplotlib
684     """
685     plt = import_matplotlib_pyplot()
686 
687     # Handle facetgrids first
688     if row or col:
689         allargs = locals().copy()
690         allargs.update(allargs.pop("kwargs"))
691         allargs.pop("darray")
692         subplot_kws = dict(projection="3d") if z is not None else None
693         return _easy_facetgrid(
694             darray, scatter, kind="dataarray", subplot_kws=subplot_kws, **allargs
695         )
696 
697     # Further
698     _is_facetgrid = kwargs.pop("_is_facetgrid", False)
699     if _is_facetgrid:
700         # Why do I need to pop these here?
701         kwargs.pop("y", None)
702         kwargs.pop("args", None)
703         kwargs.pop("add_labels", None)
704 
705     _sizes = kwargs.pop("markersize", kwargs.pop("linewidth", None))
706     size_norm = kwargs.pop("size_norm", None)
707     size_mapping = kwargs.pop("size_mapping", None)  # set by facetgrid
708     cmap_params = kwargs.pop("cmap_params", None)
709 
710     figsize = kwargs.pop("figsize", None)
711     subplot_kws = dict()
712     if z is not None and ax is None:
713         # TODO: Importing Axes3D is not necessary in matplotlib >= 3.2.
714         # Remove when minimum requirement of matplotlib is 3.2:
715         from mpl_toolkits.mplot3d import Axes3D  # type: ignore # noqa
716 
717         subplot_kws.update(projection="3d")
718         ax = get_axis(figsize, size, aspect, ax, **subplot_kws)
719         # Using 30, 30 minimizes rotation of the plot. Making it easier to
720         # build on your intuition from 2D plots:
721         if LooseVersion(plt.matplotlib.__version__) < "3.5.0":
722             ax.view_init(azim=30, elev=30)
723         else:
724             # https://github.com/matplotlib/matplotlib/pull/19873
725             ax.view_init(azim=30, elev=30, vertical_axis="y")
726     else:
727         ax = get_axis(figsize, size, aspect, ax, **subplot_kws)
728 
729     _data = _infer_scatter_metadata(darray, x, z, hue, hue_style, _sizes)
730 
731     add_guide = kwargs.pop("add_guide", None)
732     if add_legend is not None:
733         pass
734     elif add_guide is None or add_guide is True:
735         add_legend = True if _data["hue_style"] == "discrete" else False
736     elif add_legend is None:
737         add_legend = False
738 
739     if add_colorbar is not None:
740         pass
741     elif add_guide is None or add_guide is True:
742         add_colorbar = True if _data["hue_style"] == "continuous" else False
743     else:
744         add_colorbar = False
745 
746     # need to infer size_mapping with full dataset
747     _data.update(
748         _infer_scatter_data(
749             darray,
750             x,
751             z,
752             hue,
753             _sizes,
754             size_norm,
755             size_mapping,
756             _MARKERSIZE_RANGE,
757         )
758     )
759 
760     cmap_params_subset = {}
761     if _data["hue"] is not None:
762         kwargs.update(c=_data["hue"].values.ravel())
763         cmap_params, cbar_kwargs = _process_cmap_cbar_kwargs(
764             scatter, _data["hue"].values, **locals()
765         )
766 
767         # subset that can be passed to scatter, hist2d
768         cmap_params_subset = {
769             vv: cmap_params[vv] for vv in ["vmin", "vmax", "norm", "cmap"]
770         }
771 
772     if _data["size"] is not None:
773         kwargs.update(s=_data["size"].values.ravel())
774 
775     if LooseVersion(plt.matplotlib.__version__) < "3.5.0":
776         # Plot the data. 3d plots has the z value in upward direction
777         # instead of y. To make jumping between 2d and 3d easy and intuitive
778         # switch the order so that z is shown in the depthwise direction:
779         axis_order = ["x", "z", "y"]
780     else:
781         # Switching axis order not needed in 3.5.0, can also simplify the code
782         # that uses axis_order:
783         # https://github.com/matplotlib/matplotlib/pull/19873
784         axis_order = ["x", "y", "z"]
785 
786     primitive = ax.scatter(
787         *[
788             _data[v].values.ravel()
789             for v in axis_order
790             if _data.get(v, None) is not None
791         ],
792         **cmap_params_subset,
793         **kwargs,
794     )
795 
796     # Set x, y, z labels:
797     i = 0
798     set_label = [ax.set_xlabel, ax.set_ylabel, getattr(ax, "set_zlabel", None)]
799     for v in axis_order:
800         if _data.get(f"{v}label", None) is not None:
801             set_label[i](_data[f"{v}label"])
802             i += 1
803 
804     if add_legend:
805 
806         def to_label(data, key, x):
807             """Map prop values back to its original values."""
808             if key in data:
809                 # Use reindex to be less sensitive to float errors.
810                 # Return as numpy array since legend_elements
811                 # seems to require that:
812                 return data[key].reindex(x, method="nearest").to_numpy()
813             else:
814                 return x
815 
816         handles, labels = [], []
817         for subtitle, prop, func in [
818             (
819                 _data["hue_label"],
820                 "colors",
821                 functools.partial(to_label, _data, "hue_to_label"),
822             ),
823             (
824                 _data["size_label"],
825                 "sizes",
826                 functools.partial(to_label, _data, "size_to_label"),
827             ),
828         ]:
829             if subtitle:
830                 # Get legend handles and labels that displays the
831                 # values correctly. Order might be different because
832                 # legend_elements uses np.unique instead of pd.unique,
833                 # FacetGrid.add_legend might have troubles with this:
834                 hdl, lbl = legend_elements(primitive, prop, num="auto", func=func)
835                 hdl, lbl = _legend_add_subtitle(hdl, lbl, subtitle, ax.scatter)
836                 handles += hdl
837                 labels += lbl
838         legend = ax.legend(handles, labels, framealpha=0.5)
839         _adjust_legend_subtitles(legend)
840 
841     if add_colorbar and _data["hue_label"]:
842         if _data["hue_style"] == "discrete":
843             raise NotImplementedError("Cannot create a colorbar for non numerics.")
844         cbar_kwargs = {} if cbar_kwargs is None else cbar_kwargs
845         if "label" not in cbar_kwargs:
846             cbar_kwargs["label"] = _data["hue_label"]
847         _add_colorbar(primitive, ax, cbar_ax, cbar_kwargs, cmap_params)
848 
849     return primitive
850 
851 
852 # MUST run before any 2d plotting functions are defined since
853 # _plot2d decorator adds them as methods here.
854 class _PlotMethods:
855     """
856     Enables use of xarray.plot functions as attributes on a DataArray.
857     For example, DataArray.plot.imshow
858     """
859 
860     __slots__ = ("_da",)
861 
862     def __init__(self, darray):
863         self._da = darray
864 
865     def __call__(self, **kwargs):
866         return plot(self._da, **kwargs)
867 
868     # we can't use functools.wraps here since that also modifies the name / qualname
869     __doc__ = __call__.__doc__ = plot.__doc__
870     __call__.__wrapped__ = plot  # type: ignore[attr-defined]
871     __call__.__annotations__ = plot.__annotations__
872 
873     @functools.wraps(hist)
874     def hist(self, ax=None, **kwargs):
875         return hist(self._da, ax=ax, **kwargs)
876 
877     @functools.wraps(line)
878     def line(self, *args, **kwargs):
879         return line(self._da, *args, **kwargs)
880 
881     @functools.wraps(step)
882     def step(self, *args, **kwargs):
883         return step(self._da, *args, **kwargs)
884 
885     @functools.wraps(scatter)
886     def _scatter(self, *args, **kwargs):
887         return scatter(self._da, *args, **kwargs)
888 
889 
890 def override_signature(f):
891     def wrapper(func):
892         func.__wrapped__ = f
893 
894         return func
895 
896     return wrapper
897 
898 
899 def _plot2d(plotfunc):
900     """
901     Decorator for common 2d plotting logic
902 
903     Also adds the 2d plot method to class _PlotMethods
904     """
905     commondoc = """
906     Parameters
907     ----------
908     darray : DataArray
909         Must be two-dimensional, unless creating faceted plots.
910     x : str, optional
911         Coordinate for *x* axis. If ``None``, use ``darray.dims[1]``.
912     y : str, optional
913         Coordinate for *y* axis. If ``None``, use ``darray.dims[0]``.
914     figsize : tuple, optional
915         A tuple (width, height) of the figure in inches.
916         Mutually exclusive with ``size`` and ``ax``.
917     aspect : scalar, optional
918         Aspect ratio of plot, so that ``aspect * size`` gives the *width* in
919         inches. Only used if a ``size`` is provided.
920     size : scalar, optional
921         If provided, create a new figure for the plot with the given size:
922         *height* (in inches) of each plot. See also: ``aspect``.
923     ax : matplotlib axes object, optional
924         Axes on which to plot. By default, use the current axes.
925         Mutually exclusive with ``size`` and ``figsize``.
926     row : string, optional
927         If passed, make row faceted plots on this dimension name.
928     col : string, optional
929         If passed, make column faceted plots on this dimension name.
930     col_wrap : int, optional
931         Use together with ``col`` to wrap faceted plots.
932     xscale, yscale : {'linear', 'symlog', 'log', 'logit'}, optional
933         Specifies scaling for the *x*- and *y*-axis, respectively.
934     xticks, yticks : array-like, optional
935         Specify tick locations for *x*- and *y*-axis.
936     xlim, ylim : array-like, optional
937         Specify *x*- and *y*-axis limits.
938     xincrease : None, True, or False, optional
939         Should the values on the *x* axis be increasing from left to right?
940         If ``None``, use the default for the Matplotlib function.
941     yincrease : None, True, or False, optional
942         Should the values on the *y* axis be increasing from top to bottom?
943         If ``None``, use the default for the Matplotlib function.
944     add_colorbar : bool, optional
945         Add colorbar to axes.
946     add_labels : bool, optional
947         Use xarray metadata to label axes.
948     norm : matplotlib.colors.Normalize, optional
949         If ``norm`` has ``vmin`` or ``vmax`` specified, the corresponding
950         kwarg must be ``None``.
951     vmin, vmax : float, optional
952         Values to anchor the colormap, otherwise they are inferred from the
953         data and other keyword arguments. When a diverging dataset is inferred,
954         setting one of these values will fix the other by symmetry around
955         ``center``. Setting both values prevents use of a diverging colormap.
956         If discrete levels are provided as an explicit list, both of these
957         values are ignored.
958     cmap : matplotlib colormap name or colormap, optional
959         The mapping from data values to color space. If not provided, this
960         will be either be ``'viridis'`` (if the function infers a sequential
961         dataset) or ``'RdBu_r'`` (if the function infers a diverging dataset).
962         See :doc:`Choosing Colormaps in Matplotlib <matplotlib:tutorials/colors/colormaps>`
963         for more information.
964 
965         If *seaborn* is installed, ``cmap`` may also be a
966         `seaborn color palette <https://seaborn.pydata.org/tutorial/color_palettes.html>`_.
967         Note: if ``cmap`` is a seaborn color palette and the plot type
968         is not ``'contour'`` or ``'contourf'``, ``levels`` must also be specified.
969     colors : str or array-like of color-like, optional
970         A single color or a sequence of colors. If the plot type is not ``'contour'``
971         or ``'contourf'``, the ``levels`` argument is required.
972     center : float, optional
973         The value at which to center the colormap. Passing this value implies
974         use of a diverging colormap. Setting it to ``False`` prevents use of a
975         diverging colormap.
976     robust : bool, optional
977         If ``True`` and ``vmin`` or ``vmax`` are absent, the colormap range is
978         computed with 2nd and 98th percentiles instead of the extreme values.
979     extend : {'neither', 'both', 'min', 'max'}, optional
980         How to draw arrows extending the colorbar beyond its limits. If not
981         provided, ``extend`` is inferred from ``vmin``, ``vmax`` and the data limits.
982     levels : int or array-like, optional
983         Split the colormap (``cmap``) into discrete color intervals. If an integer
984         is provided, "nice" levels are chosen based on the data range: this can
985         imply that the final number of levels is not exactly the expected one.
986         Setting ``vmin`` and/or ``vmax`` with ``levels=N`` is equivalent to
987         setting ``levels=np.linspace(vmin, vmax, N)``.
988     infer_intervals : bool, optional
989         Only applies to pcolormesh. If ``True``, the coordinate intervals are
990         passed to pcolormesh. If ``False``, the original coordinates are used
991         (this can be useful for certain map projections). The default is to
992         always infer intervals, unless the mesh is irregular and plotted on
993         a map projection.
994     subplot_kws : dict, optional
995         Dictionary of keyword arguments for Matplotlib subplots. Only used
996         for 2D and faceted plots.
997         (see :py:meth:`matplotlib:matplotlib.figure.Figure.add_subplot`).
998     cbar_ax : matplotlib axes object, optional
999         Axes in which to draw the colorbar.
1000     cbar_kwargs : dict, optional
1001         Dictionary of keyword arguments to pass to the colorbar
1002         (see :meth:`matplotlib:matplotlib.figure.Figure.colorbar`).
1003     **kwargs : optional
1004         Additional keyword arguments to wrapped Matplotlib function.
1005 
1006     Returns
1007     -------
1008     artist :
1009         The same type of primitive artist that the wrapped Matplotlib
1010         function returns.
1011     """
1012 
1013     # Build on the original docstring
1014     plotfunc.__doc__ = f"{plotfunc.__doc__}\n{commondoc}"
1015 
1016     # plotfunc and newplotfunc have different signatures:
1017     # - plotfunc: (x, y, z, ax, **kwargs)
1018     # - newplotfunc: (darray, x, y, **kwargs)
1019     # where plotfunc accepts numpy arrays, while newplotfunc accepts a DataArray
1020     # and variable names. newplotfunc also explicitly lists most kwargs, so we
1021     # need to shorten it
1022     def signature(darray, x, y, **kwargs):
1023         pass
1024 
1025     @override_signature(signature)
1026     @functools.wraps(plotfunc)
1027     def newplotfunc(
1028         darray,
1029         x=None,
1030         y=None,
1031         figsize=None,
1032         size=None,
1033         aspect=None,
1034         ax=None,
1035         row=None,
1036         col=None,
1037         col_wrap=None,
1038         xincrease=True,
1039         yincrease=True,
1040         add_colorbar=None,
1041         add_labels=True,
1042         vmin=None,
1043         vmax=None,
1044         cmap=None,
1045         center=None,
1046         robust=False,
1047         extend=None,
1048         levels=None,
1049         infer_intervals=None,
1050         colors=None,
1051         subplot_kws=None,
1052         cbar_ax=None,
1053         cbar_kwargs=None,
1054         xscale=None,
1055         yscale=None,
1056         xticks=None,
1057         yticks=None,
1058         xlim=None,
1059         ylim=None,
1060         norm=None,
1061         **kwargs,
1062     ):
1063         # All 2d plots in xarray share this function signature.
1064         # Method signature below should be consistent.
1065 
1066         # Decide on a default for the colorbar before facetgrids
1067         if add_colorbar is None:
1068             add_colorbar = True
1069             if plotfunc.__name__ == "contour" or (
1070                 plotfunc.__name__ == "surface" and cmap is None
1071             ):
1072                 add_colorbar = False
1073         imshow_rgb = plotfunc.__name__ == "imshow" and darray.ndim == (
1074             3 + (row is not None) + (col is not None)
1075         )
1076         if imshow_rgb:
1077             # Don't add a colorbar when showing an image with explicit colors
1078             add_colorbar = False
1079             # Matplotlib does not support normalising RGB data, so do it here.
1080             # See eg. https://github.com/matplotlib/matplotlib/pull/10220
1081             if robust or vmax is not None or vmin is not None:
1082                 darray = _rescale_imshow_rgb(darray, vmin, vmax, robust)
1083                 vmin, vmax, robust = None, None, False
1084 
1085         if subplot_kws is None:
1086             subplot_kws = dict()
1087 
1088         if plotfunc.__name__ == "surface" and not kwargs.get("_is_facetgrid", False):
1089             if ax is None:
1090                 # TODO: Importing Axes3D is no longer necessary in matplotlib >= 3.2.
1091                 # Remove when minimum requirement of matplotlib is 3.2:
1092                 from mpl_toolkits.mplot3d import Axes3D  # type: ignore  # noqa: F401
1093 
1094                 # delete so it does not end up in locals()
1095                 del Axes3D
1096 
1097                 # Need to create a "3d" Axes instance for surface plots
1098                 subplot_kws["projection"] = "3d"
1099 
1100             # In facet grids, shared axis labels don't make sense for surface plots
1101             sharex = False
1102             sharey = False
1103 
1104         # Handle facetgrids first
1105         if row or col:
1106             allargs = locals().copy()
1107             del allargs["darray"]
1108             del allargs["imshow_rgb"]
1109             allargs.update(allargs.pop("kwargs"))
1110             # Need the decorated plotting function
1111             allargs["plotfunc"] = globals()[plotfunc.__name__]
1112             return _easy_facetgrid(darray, kind="dataarray", **allargs)
1113 
1114         plt = import_matplotlib_pyplot()
1115 
1116         if (
1117             plotfunc.__name__ == "surface"
1118             and not kwargs.get("_is_facetgrid", False)
1119             and ax is not None
1120         ):
1121             import mpl_toolkits  # type: ignore
1122 
1123             if not isinstance(ax, mpl_toolkits.mplot3d.Axes3D):
1124                 raise ValueError(
1125                     "If ax is passed to surface(), it must be created with "
1126                     'projection="3d"'
1127                 )
1128 
1129         rgb = kwargs.pop("rgb", None)
1130         if rgb is not None and plotfunc.__name__ != "imshow":
1131             raise ValueError('The "rgb" keyword is only valid for imshow()')
1132         elif rgb is not None and not imshow_rgb:
1133             raise ValueError(
1134                 'The "rgb" keyword is only valid for imshow()'
1135                 "with a three-dimensional array (per facet)"
1136             )
1137 
1138         xlab, ylab = _infer_xy_labels(
1139             darray=darray, x=x, y=y, imshow=imshow_rgb, rgb=rgb
1140         )
1141 
1142         xval = darray[xlab]
1143         yval = darray[ylab]
1144 
1145         if xval.ndim > 1 or yval.ndim > 1 or plotfunc.__name__ == "surface":
1146             # Passing 2d coordinate values, need to ensure they are transposed the same
1147             # way as darray.
1148             # Also surface plots always need 2d coordinates
1149             xval = xval.broadcast_like(darray)
1150             yval = yval.broadcast_like(darray)
1151             dims = darray.dims
1152         else:
1153             dims = (yval.dims[0], xval.dims[0])
1154 
1155         # better to pass the ndarrays directly to plotting functions
1156         xval = xval.to_numpy()
1157         yval = yval.to_numpy()
1158 
1159         # May need to transpose for correct x, y labels
1160         # xlab may be the name of a coord, we have to check for dim names
1161         if imshow_rgb:
1162             # For RGB[A] images, matplotlib requires the color dimension
1163             # to be last.  In Xarray the order should be unimportant, so
1164             # we transpose to (y, x, color) to make this work.
1165             yx_dims = (ylab, xlab)
1166             dims = yx_dims + tuple(d for d in darray.dims if d not in yx_dims)
1167 
1168         if dims != darray.dims:
1169             darray = darray.transpose(*dims, transpose_coords=True)
1170 
1171         # Pass the data as a masked ndarray too
1172         zval = darray.to_masked_array(copy=False)
1173 
1174         # Replace pd.Intervals if contained in xval or yval.
1175         xplt, xlab_extra = _resolve_intervals_2dplot(xval, plotfunc.__name__)
1176         yplt, ylab_extra = _resolve_intervals_2dplot(yval, plotfunc.__name__)
1177 
1178         _ensure_plottable(xplt, yplt, zval)
1179 
1180         cmap_params, cbar_kwargs = _process_cmap_cbar_kwargs(
1181             plotfunc,
1182             zval.data,
1183             **locals(),
1184             _is_facetgrid=kwargs.pop("_is_facetgrid", False),
1185         )
1186 
1187         if "contour" in plotfunc.__name__:
1188             # extend is a keyword argument only for contour and contourf, but
1189             # passing it to the colorbar is sufficient for imshow and
1190             # pcolormesh
1191             kwargs["extend"] = cmap_params["extend"]
1192             kwargs["levels"] = cmap_params["levels"]
1193             # if colors == a single color, matplotlib draws dashed negative
1194             # contours. we lose this feature if we pass cmap and not colors
1195             if isinstance(colors, str):
1196                 cmap_params["cmap"] = None
1197                 kwargs["colors"] = colors
1198 
1199         if "pcolormesh" == plotfunc.__name__:
1200             kwargs["infer_intervals"] = infer_intervals
1201             kwargs["xscale"] = xscale
1202             kwargs["yscale"] = yscale
1203 
1204         if "imshow" == plotfunc.__name__ and isinstance(aspect, str):
1205             # forbid usage of mpl strings
1206             raise ValueError("plt.imshow's `aspect` kwarg is not available in xarray")
1207 
1208         ax = get_axis(figsize, size, aspect, ax, **subplot_kws)
1209 
1210         primitive = plotfunc(
1211             xplt,
1212             yplt,
1213             zval,
1214             ax=ax,
1215             cmap=cmap_params["cmap"],
1216             vmin=cmap_params["vmin"],
1217             vmax=cmap_params["vmax"],
1218             norm=cmap_params["norm"],
1219             **kwargs,
1220         )
1221 
1222         # Label the plot with metadata
1223         if add_labels:
1224             ax.set_xlabel(label_from_attrs(darray[xlab], xlab_extra))
1225             ax.set_ylabel(label_from_attrs(darray[ylab], ylab_extra))
1226             ax.set_title(darray._title_for_slice())
1227             if plotfunc.__name__ == "surface":
1228                 ax.set_zlabel(label_from_attrs(darray))
1229 
1230         if add_colorbar:
1231             if add_labels and "label" not in cbar_kwargs:
1232                 cbar_kwargs["label"] = label_from_attrs(darray)
1233             cbar = _add_colorbar(primitive, ax, cbar_ax, cbar_kwargs, cmap_params)
1234         elif cbar_ax is not None or cbar_kwargs:
1235             # inform the user about keywords which aren't used
1236             raise ValueError(
1237                 "cbar_ax and cbar_kwargs can't be used with add_colorbar=False."
1238             )
1239 
1240         # origin kwarg overrides yincrease
1241         if "origin" in kwargs:
1242             yincrease = None
1243 
1244         _update_axes(
1245             ax, xincrease, yincrease, xscale, yscale, xticks, yticks, xlim, ylim
1246         )
1247 
1248         # Rotate dates on xlabels
1249         # Do this without calling autofmt_xdate so that x-axes ticks
1250         # on other subplots (if any) are not deleted.
1251         # https://stackoverflow.com/questions/17430105/autofmt-xdate-deletes-x-axis-labels-of-all-subplots
1252         if np.issubdtype(xplt.dtype, np.datetime64):
1253             for xlabels in ax.get_xticklabels():
1254                 xlabels.set_rotation(30)
1255                 xlabels.set_ha("right")
1256 
1257         return primitive
1258 
1259     # For use as DataArray.plot.plotmethod
1260     @functools.wraps(newplotfunc)
1261     def plotmethod(
1262         _PlotMethods_obj,
1263         x=None,
1264         y=None,
1265         figsize=None,
1266         size=None,
1267         aspect=None,
1268         ax=None,
1269         row=None,
1270         col=None,
1271         col_wrap=None,
1272         xincrease=True,
1273         yincrease=True,
1274         add_colorbar=None,
1275         add_labels=True,
1276         vmin=None,
1277         vmax=None,
1278         cmap=None,
1279         colors=None,
1280         center=None,
1281         robust=False,
1282         extend=None,
1283         levels=None,
1284         infer_intervals=None,
1285         subplot_kws=None,
1286         cbar_ax=None,
1287         cbar_kwargs=None,
1288         xscale=None,
1289         yscale=None,
1290         xticks=None,
1291         yticks=None,
1292         xlim=None,
1293         ylim=None,
1294         norm=None,
1295         **kwargs,
1296     ):
1297         """
1298         The method should have the same signature as the function.
1299 
1300         This just makes the method work on Plotmethods objects,
1301         and passes all the other arguments straight through.
1302         """
1303         allargs = locals()
1304         allargs["darray"] = _PlotMethods_obj._da
1305         allargs.update(kwargs)
1306         for arg in ["_PlotMethods_obj", "newplotfunc", "kwargs"]:
1307             del allargs[arg]
1308         return newplotfunc(**allargs)
1309 
1310     # Add to class _PlotMethods
1311     setattr(_PlotMethods, plotmethod.__name__, plotmethod)
1312 
1313     return newplotfunc
1314 
1315 
1316 @_plot2d
1317 def imshow(x, y, z, ax, **kwargs):
1318     """
1319     Image plot of 2D DataArray.
1320 
1321     Wraps :py:func:`matplotlib:matplotlib.pyplot.imshow`.
1322 
1323     While other plot methods require the DataArray to be strictly
1324     two-dimensional, ``imshow`` also accepts a 3D array where some
1325     dimension can be interpreted as RGB or RGBA color channels and
1326     allows this dimension to be specified via the kwarg ``rgb=``.
1327 
1328     Unlike :py:func:`matplotlib:matplotlib.pyplot.imshow`, which ignores ``vmin``/``vmax``
1329     for RGB(A) data,
1330     xarray *will* use ``vmin`` and ``vmax`` for RGB(A) data
1331     by applying a single scaling factor and offset to all bands.
1332     Passing  ``robust=True`` infers ``vmin`` and ``vmax``
1333     :ref:`in the usual way <robust-plotting>`.
1334 
1335     .. note::
1336         This function needs uniformly spaced coordinates to
1337         properly label the axes. Call :py:meth:`DataArray.plot` to check.
1338 
1339     The pixels are centered on the coordinates. For example, if the coordinate
1340     value is 3.2, then the pixels for those coordinates will be centered on 3.2.
1341     """
1342 
1343     if x.ndim != 1 or y.ndim != 1:
1344         raise ValueError(
1345             "imshow requires 1D coordinates, try using pcolormesh or contour(f)"
1346         )
1347 
1348     def _center_pixels(x):
1349         """Center the pixels on the coordinates."""
1350         if np.issubdtype(x.dtype, str):
1351             # When using strings as inputs imshow converts it to
1352             # integers. Choose extent values which puts the indices in
1353             # in the center of the pixels:
1354             return 0 - 0.5, len(x) - 0.5
1355 
1356         try:
1357             # Center the pixels assuming uniform spacing:
1358             xstep = 0.5 * (x[1] - x[0])
1359         except IndexError:
1360             # Arbitrary default value, similar to matplotlib behaviour:
1361             xstep = 0.1
1362 
1363         return x[0] - xstep, x[-1] + xstep
1364 
1365     # Center the pixels:
1366     left, right = _center_pixels(x)
1367     top, bottom = _center_pixels(y)
1368 
1369     defaults = {"origin": "upper", "interpolation": "nearest"}
1370 
1371     if not hasattr(ax, "projection"):
1372         # not for cartopy geoaxes
1373         defaults["aspect"] = "auto"
1374 
1375     # Allow user to override these defaults
1376     defaults.update(kwargs)
1377 
1378     if defaults["origin"] == "upper":
1379         defaults["extent"] = [left, right, bottom, top]
1380     else:
1381         defaults["extent"] = [left, right, top, bottom]
1382 
1383     if z.ndim == 3:
1384         # matplotlib imshow uses black for missing data, but Xarray makes
1385         # missing data transparent.  We therefore add an alpha channel if
1386         # there isn't one, and set it to transparent where data is masked.
1387         if z.shape[-1] == 3:
1388             alpha = np.ma.ones(z.shape[:2] + (1,), dtype=z.dtype)
1389             if np.issubdtype(z.dtype, np.integer):
1390                 alpha *= 255
1391             z = np.ma.concatenate((z, alpha), axis=2)
1392         else:
1393             z = z.copy()
1394         z[np.any(z.mask, axis=-1), -1] = 0
1395 
1396     primitive = ax.imshow(z, **defaults)
1397 
1398     # If x or y are strings the ticklabels have been replaced with
1399     # integer indices. Replace them back to strings:
1400     for axis, v in [("x", x), ("y", y)]:
1401         if np.issubdtype(v.dtype, str):
1402             getattr(ax, f"set_{axis}ticks")(np.arange(len(v)))
1403             getattr(ax, f"set_{axis}ticklabels")(v)
1404 
1405     return primitive
1406 
1407 
1408 @_plot2d
1409 def contour(x, y, z, ax, **kwargs):
1410     """
1411     Contour plot of 2D DataArray.
1412 
1413     Wraps :py:func:`matplotlib:matplotlib.pyplot.contour`.
1414     """
1415     primitive = ax.contour(x, y, z, **kwargs)
1416     return primitive
1417 
1418 
1419 @_plot2d
1420 def contourf(x, y, z, ax, **kwargs):
1421     """
1422     Filled contour plot of 2D DataArray.
1423 
1424     Wraps :py:func:`matplotlib:matplotlib.pyplot.contourf`.
1425     """
1426     primitive = ax.contourf(x, y, z, **kwargs)
1427     return primitive
1428 
1429 
1430 @_plot2d
1431 def pcolormesh(x, y, z, ax, xscale=None, yscale=None, infer_intervals=None, **kwargs):
1432     """
1433     Pseudocolor plot of 2D DataArray.
1434 
1435     Wraps :py:func:`matplotlib:matplotlib.pyplot.pcolormesh`.
1436     """
1437 
1438     # decide on a default for infer_intervals (GH781)
1439     x = np.asarray(x)
1440     if infer_intervals is None:
1441         if hasattr(ax, "projection"):
1442             if len(x.shape) == 1:
1443                 infer_intervals = True
1444             else:
1445                 infer_intervals = False
1446         else:
1447             infer_intervals = True
1448 
1449     if (
1450         infer_intervals
1451         and not np.issubdtype(x.dtype, str)
1452         and (
1453             (np.shape(x)[0] == np.shape(z)[1])
1454             or ((x.ndim > 1) and (np.shape(x)[1] == np.shape(z)[1]))
1455         )
1456     ):
1457         if len(x.shape) == 1:
1458             x = _infer_interval_breaks(x, check_monotonic=True, scale=xscale)
1459         else:
1460             # we have to infer the intervals on both axes
1461             x = _infer_interval_breaks(x, axis=1, scale=xscale)
1462             x = _infer_interval_breaks(x, axis=0, scale=xscale)
1463 
1464     if (
1465         infer_intervals
1466         and not np.issubdtype(y.dtype, str)
1467         and (np.shape(y)[0] == np.shape(z)[0])
1468     ):
1469         if len(y.shape) == 1:
1470             y = _infer_interval_breaks(y, check_monotonic=True, scale=yscale)
1471         else:
1472             # we have to infer the intervals on both axes
1473             y = _infer_interval_breaks(y, axis=1, scale=yscale)
1474             y = _infer_interval_breaks(y, axis=0, scale=yscale)
1475 
1476     primitive = ax.pcolormesh(x, y, z, **kwargs)
1477 
1478     # by default, pcolormesh picks "round" values for bounds
1479     # this results in ugly looking plots with lots of surrounding whitespace
1480     if not hasattr(ax, "projection") and x.ndim == 1 and y.ndim == 1:
1481         # not a cartopy geoaxis
1482         ax.set_xlim(x[0], x[-1])
1483         ax.set_ylim(y[0], y[-1])
1484 
1485     return primitive
1486 
1487 
1488 @_plot2d
1489 def surface(x, y, z, ax, **kwargs):
1490     """
1491     Surface plot of 2D DataArray.
1492 
1493     Wraps :py:meth:`matplotlib:mpl_toolkits.mplot3d.axes3d.Axes3D.plot_surface`.
1494     """
1495     primitive = ax.plot_surface(x, y, z, **kwargs)
1496     return primitive

</code><intended_behavior>To resolve the issue, the plotting methods within this file should ensure that if a `long_name` attribute contains LaTeX expressions, it is correctly passed to matplotlib in a manner that enables LaTeX rendering. This means specifically checking for attributes that contain LaTeX strings and ensuring that matplotlib's rendering engine is explicitly instructed to interpret them as LaTeX. This may involve ensuring that the text properties passed to matplotlib plotting functions (like `xlabel`) correctly signal matplotlib to render the text as LaTeX, potentially by setting appropriate rcParams or directly formatting text labels.</intended_behavior>, <file>xarray/plot/utils.py</file>
<class>None</class>
<method>None</method>
<code>
1 import itertools
2 import textwrap
3 import warnings
4 from datetime import datetime
5 from inspect import getfullargspec
6 from typing import Any, Iterable, Mapping, Tuple, Union
7 
8 import numpy as np
9 import pandas as pd
10 
11 from ..core.options import OPTIONS
12 from ..core.pycompat import DuckArrayModule
13 from ..core.utils import is_scalar
14 
15 try:
16     import nc_time_axis  # noqa: F401
17 
18     nc_time_axis_available = True
19 except ImportError:
20     nc_time_axis_available = False
21 
22 ROBUST_PERCENTILE = 2.0
23 
24 
25 _registered = False
26 
27 
28 def register_pandas_datetime_converter_if_needed():
29     # based on https://github.com/pandas-dev/pandas/pull/17710
30     global _registered
31     if not _registered:
32         pd.plotting.register_matplotlib_converters()
33         _registered = True
34 
35 
36 def import_matplotlib_pyplot():
37     """Import pyplot as register appropriate converters."""
38     register_pandas_datetime_converter_if_needed()
39     import matplotlib.pyplot as plt
40 
41     return plt
42 
43 
44 def _determine_extend(calc_data, vmin, vmax):
45     extend_min = calc_data.min() < vmin
46     extend_max = calc_data.max() > vmax
47     if extend_min and extend_max:
48         return "both"
49     elif extend_min:
50         return "min"
51     elif extend_max:
52         return "max"
53     else:
54         return "neither"
55 
56 
57 def _build_discrete_cmap(cmap, levels, extend, filled):
58     """
59     Build a discrete colormap and normalization of the data.
60     """
61     import matplotlib as mpl
62 
63     if len(levels) == 1:
64         levels = [levels[0], levels[0]]
65 
66     if not filled:
67         # non-filled contour plots
68         extend = "max"
69 
70     if extend == "both":
71         ext_n = 2
72     elif extend in ["min", "max"]:
73         ext_n = 1
74     else:
75         ext_n = 0
76 
77     n_colors = len(levels) + ext_n - 1
78     pal = _color_palette(cmap, n_colors)
79 
80     new_cmap, cnorm = mpl.colors.from_levels_and_colors(levels, pal, extend=extend)
81     # copy the old cmap name, for easier testing
82     new_cmap.name = getattr(cmap, "name", cmap)
83 
84     # copy colors to use for bad, under, and over values in case they have been
85     # set to non-default values
86     try:
87         # matplotlib<3.2 only uses bad color for masked values
88         bad = cmap(np.ma.masked_invalid([np.nan]))[0]
89     except TypeError:
90         # cmap was a str or list rather than a color-map object, so there are
91         # no bad, under or over values to check or copy
92         pass
93     else:
94         under = cmap(-np.inf)
95         over = cmap(np.inf)
96 
97         new_cmap.set_bad(bad)
98 
99         # Only update under and over if they were explicitly changed by the user
100         # (i.e. are different from the lowest or highest values in cmap). Otherwise
101         # leave unchanged so new_cmap uses its default values (its own lowest and
102         # highest values).
103         if under != cmap(0):
104             new_cmap.set_under(under)
105         if over != cmap(cmap.N - 1):
106             new_cmap.set_over(over)
107 
108     return new_cmap, cnorm
109 
110 
111 def _color_palette(cmap, n_colors):
112     import matplotlib.pyplot as plt
113     from matplotlib.colors import ListedColormap
114 
115     colors_i = np.linspace(0, 1.0, n_colors)
116     if isinstance(cmap, (list, tuple)):
117         # we have a list of colors
118         cmap = ListedColormap(cmap, N=n_colors)
119         pal = cmap(colors_i)
120     elif isinstance(cmap, str):
121         # we have some sort of named palette
122         try:
123             # is this a matplotlib cmap?
124             cmap = plt.get_cmap(cmap)
125             pal = cmap(colors_i)
126         except ValueError:
127             # ValueError happens when mpl doesn't like a colormap, try seaborn
128             try:
129                 from seaborn import color_palette
130 
131                 pal = color_palette(cmap, n_colors=n_colors)
132             except (ValueError, ImportError):
133                 # or maybe we just got a single color as a string
134                 cmap = ListedColormap([cmap], N=n_colors)
135                 pal = cmap(colors_i)
136     else:
137         # cmap better be a LinearSegmentedColormap (e.g. viridis)
138         pal = cmap(colors_i)
139 
140     return pal
141 
142 
143 # _determine_cmap_params is adapted from Seaborn:
144 # https://github.com/mwaskom/seaborn/blob/v0.6/seaborn/matrix.py#L158
145 # Used under the terms of Seaborn's license, see licenses/SEABORN_LICENSE.
146 
147 
148 def _determine_cmap_params(
149     plot_data,
150     vmin=None,
151     vmax=None,
152     cmap=None,
153     center=None,
154     robust=False,
155     extend=None,
156     levels=None,
157     filled=True,
158     norm=None,
159     _is_facetgrid=False,
160 ):
161     """
162     Use some heuristics to set good defaults for colorbar and range.
163 
164     Parameters
165     ----------
166     plot_data : Numpy array
167         Doesn't handle xarray objects
168 
169     Returns
170     -------
171     cmap_params : dict
172         Use depends on the type of the plotting function
173     """
174     import matplotlib as mpl
175 
176     if isinstance(levels, Iterable):
177         levels = sorted(levels)
178 
179     calc_data = np.ravel(plot_data[np.isfinite(plot_data)])
180 
181     # Handle all-NaN input data gracefully
182     if calc_data.size == 0:
183         # Arbitrary default for when all values are NaN
184         calc_data = np.array(0.0)
185 
186     # Setting center=False prevents a divergent cmap
187     possibly_divergent = center is not False
188 
189     # Set center to 0 so math below makes sense but remember its state
190     center_is_none = False
191     if center is None:
192         center = 0
193         center_is_none = True
194 
195     # Setting both vmin and vmax prevents a divergent cmap
196     if (vmin is not None) and (vmax is not None):
197         possibly_divergent = False
198 
199     # Setting vmin or vmax implies linspaced levels
200     user_minmax = (vmin is not None) or (vmax is not None)
201 
202     # vlim might be computed below
203     vlim = None
204 
205     # save state; needed later
206     vmin_was_none = vmin is None
207     vmax_was_none = vmax is None
208 
209     if vmin is None:
210         if robust:
211             vmin = np.percentile(calc_data, ROBUST_PERCENTILE)
212         else:
213             vmin = calc_data.min()
214     elif possibly_divergent:
215         vlim = abs(vmin - center)
216 
217     if vmax is None:
218         if robust:
219             vmax = np.percentile(calc_data, 100 - ROBUST_PERCENTILE)
220         else:
221             vmax = calc_data.max()
222     elif possibly_divergent:
223         vlim = abs(vmax - center)
224 
225     if possibly_divergent:
226         levels_are_divergent = (
227             isinstance(levels, Iterable) and levels[0] * levels[-1] < 0
228         )
229         # kwargs not specific about divergent or not: infer defaults from data
230         divergent = (
231             ((vmin < 0) and (vmax > 0)) or not center_is_none or levels_are_divergent
232         )
233     else:
234         divergent = False
235 
236     # A divergent map should be symmetric around the center value
237     if divergent:
238         if vlim is None:
239             vlim = max(abs(vmin - center), abs(vmax - center))
240         vmin, vmax = -vlim, vlim
241 
242     # Now add in the centering value and set the limits
243     vmin += center
244     vmax += center
245 
246     # now check norm and harmonize with vmin, vmax
247     if norm is not None:
248         if norm.vmin is None:
249             norm.vmin = vmin
250         else:
251             if not vmin_was_none and vmin != norm.vmin:
252                 raise ValueError("Cannot supply vmin and a norm with a different vmin.")
253             vmin = norm.vmin
254 
255         if norm.vmax is None:
256             norm.vmax = vmax
257         else:
258             if not vmax_was_none and vmax != norm.vmax:
259                 raise ValueError("Cannot supply vmax and a norm with a different vmax.")
260             vmax = norm.vmax
261 
262     # if BoundaryNorm, then set levels
263     if isinstance(norm, mpl.colors.BoundaryNorm):
264         levels = norm.boundaries
265 
266     # Choose default colormaps if not provided
267     if cmap is None:
268         if divergent:
269             cmap = OPTIONS["cmap_divergent"]
270         else:
271             cmap = OPTIONS["cmap_sequential"]
272 
273     # Handle discrete levels
274     if levels is not None:
275         if is_scalar(levels):
276             if user_minmax:
277                 levels = np.linspace(vmin, vmax, levels)
278             elif levels == 1:
279                 levels = np.asarray([(vmin + vmax) / 2])
280             else:
281                 # N in MaxNLocator refers to bins, not ticks
282                 ticker = mpl.ticker.MaxNLocator(levels - 1)
283                 levels = ticker.tick_values(vmin, vmax)
284         vmin, vmax = levels[0], levels[-1]
285 
286     # GH3734
287     if vmin == vmax:
288         vmin, vmax = mpl.ticker.LinearLocator(2).tick_values(vmin, vmax)
289 
290     if extend is None:
291         extend = _determine_extend(calc_data, vmin, vmax)
292 
293     if levels is not None or isinstance(norm, mpl.colors.BoundaryNorm):
294         cmap, newnorm = _build_discrete_cmap(cmap, levels, extend, filled)
295         norm = newnorm if norm is None else norm
296 
297     # vmin & vmax needs to be None if norm is passed
298     # TODO: always return a norm with vmin and vmax
299     if norm is not None:
300         vmin = None
301         vmax = None
302 
303     return dict(
304         vmin=vmin, vmax=vmax, cmap=cmap, extend=extend, levels=levels, norm=norm
305     )
306 
307 
308 def _infer_xy_labels_3d(darray, x, y, rgb):
309     """
310     Determine x and y labels for showing RGB images.
311 
312     Attempts to infer which dimension is RGB/RGBA by size and order of dims.
313 
314     """
315     assert rgb is None or rgb != x
316     assert rgb is None or rgb != y
317     # Start by detecting and reporting invalid combinations of arguments
318     assert darray.ndim == 3
319     not_none = [a for a in (x, y, rgb) if a is not None]
320     if len(set(not_none)) < len(not_none):
321         raise ValueError(
322             "Dimension names must be None or unique strings, but imshow was "
323             f"passed x={x!r}, y={y!r}, and rgb={rgb!r}."
324         )
325     for label in not_none:
326         if label not in darray.dims:
327             raise ValueError(f"{label!r} is not a dimension")
328 
329     # Then calculate rgb dimension if certain and check validity
330     could_be_color = [
331         label
332         for label in darray.dims
333         if darray[label].size in (3, 4) and label not in (x, y)
334     ]
335     if rgb is None and not could_be_color:
336         raise ValueError(
337             "A 3-dimensional array was passed to imshow(), but there is no "
338             "dimension that could be color.  At least one dimension must be "
339             "of size 3 (RGB) or 4 (RGBA), and not given as x or y."
340         )
341     if rgb is None and len(could_be_color) == 1:
342         rgb = could_be_color[0]
343     if rgb is not None and darray[rgb].size not in (3, 4):
344         raise ValueError(
345             f"Cannot interpret dim {rgb!r} of size {darray[rgb].size} as RGB or RGBA."
346         )
347 
348     # If rgb dimension is still unknown, there must be two or three dimensions
349     # in could_be_color.  We therefore warn, and use a heuristic to break ties.
350     if rgb is None:
351         assert len(could_be_color) in (2, 3)
352         rgb = could_be_color[-1]
353         warnings.warn(
354             "Several dimensions of this array could be colors.  Xarray "
355             f"will use the last possible dimension ({rgb!r}) to match "
356             "matplotlib.pyplot.imshow.  You can pass names of x, y, "
357             "and/or rgb dimensions to override this guess."
358         )
359     assert rgb is not None
360 
361     # Finally, we pick out the red slice and delegate to the 2D version:
362     return _infer_xy_labels(darray.isel(**{rgb: 0}), x, y)
363 
364 
365 def _infer_xy_labels(darray, x, y, imshow=False, rgb=None):
366     """
367     Determine x and y labels. For use in _plot2d
368 
369     darray must be a 2 dimensional data array, or 3d for imshow only.
370     """
371     if (x is not None) and (x == y):
372         raise ValueError("x and y cannot be equal.")
373 
374     if imshow and darray.ndim == 3:
375         return _infer_xy_labels_3d(darray, x, y, rgb)
376 
377     if x is None and y is None:
378         if darray.ndim != 2:
379             raise ValueError("DataArray must be 2d")
380         y, x = darray.dims
381     elif x is None:
382         _assert_valid_xy(darray, y, "y")
383         x = darray.dims[0] if y == darray.dims[1] else darray.dims[1]
384     elif y is None:
385         _assert_valid_xy(darray, x, "x")
386         y = darray.dims[0] if x == darray.dims[1] else darray.dims[1]
387     else:
388         _assert_valid_xy(darray, x, "x")
389         _assert_valid_xy(darray, y, "y")
390 
391         if (
392             all(k in darray._level_coords for k in (x, y))
393             and darray._level_coords[x] == darray._level_coords[y]
394         ):
395             raise ValueError("x and y cannot be levels of the same MultiIndex")
396 
397     return x, y
398 
399 
400 def _assert_valid_xy(darray, xy, name):
401     """
402     make sure x and y passed to plotting functions are valid
403     """
404 
405     # MultiIndex cannot be plotted; no point in allowing them here
406     multiindex = {darray._level_coords[lc] for lc in darray._level_coords}
407 
408     valid_xy = (
409         set(darray.dims) | set(darray.coords) | set(darray._level_coords)
410     ) - multiindex
411 
412     if xy not in valid_xy:
413         valid_xy_str = "', '".join(sorted(valid_xy))
414         raise ValueError(f"{name} must be one of None, '{valid_xy_str}'")
415 
416 
417 def get_axis(figsize=None, size=None, aspect=None, ax=None, **kwargs):
418     try:
419         import matplotlib as mpl
420         import matplotlib.pyplot as plt
421     except ImportError:
422         raise ImportError("matplotlib is required for plot.utils.get_axis")
423 
424     if figsize is not None:
425         if ax is not None:
426             raise ValueError("cannot provide both `figsize` and `ax` arguments")
427         if size is not None:
428             raise ValueError("cannot provide both `figsize` and `size` arguments")
429         _, ax = plt.subplots(figsize=figsize)
430     elif size is not None:
431         if ax is not None:
432             raise ValueError("cannot provide both `size` and `ax` arguments")
433         if aspect is None:
434             width, height = mpl.rcParams["figure.figsize"]
435             aspect = width / height
436         figsize = (size * aspect, size)
437         _, ax = plt.subplots(figsize=figsize)
438     elif aspect is not None:
439         raise ValueError("cannot provide `aspect` argument without `size`")
440 
441     if kwargs and ax is not None:
442         raise ValueError("cannot use subplot_kws with existing ax")
443 
444     if ax is None:
445         ax = _maybe_gca(**kwargs)
446 
447     return ax
448 
449 
450 def _maybe_gca(**kwargs):
451 
452     import matplotlib.pyplot as plt
453 
454     # can call gcf unconditionally: either it exists or would be created by plt.axes
455     f = plt.gcf()
456 
457     # only call gca if an active axes exists
458     if f.axes:
459         # can not pass kwargs to active axes
460         return plt.gca()
461 
462     return plt.axes(**kwargs)
463 
464 
465 def label_from_attrs(da, extra=""):
466     """Makes informative labels if variable metadata (attrs) follows
467     CF conventions."""
468 
469     if da.attrs.get("long_name"):
470         name = da.attrs["long_name"]
471     elif da.attrs.get("standard_name"):
472         name = da.attrs["standard_name"]
473     elif da.name is not None:
474         name = da.name
475     else:
476         name = ""
477 
478     def _get_units_from_attrs(da):
479         if da.attrs.get("units"):
480             units = " [{}]".format(da.attrs["units"])
481         elif da.attrs.get("unit"):
482             units = " [{}]".format(da.attrs["unit"])
483         else:
484             units = ""
485         return units
486 
487     pint_array_type = DuckArrayModule("pint").type
488     if isinstance(da.data, pint_array_type):
489         units = " [{}]".format(str(da.data.units))
490     else:
491         units = _get_units_from_attrs(da)
492 
493     return "\n".join(textwrap.wrap(name + extra + units, 30))
494 
495 
496 def _interval_to_mid_points(array):
497     """
498     Helper function which returns an array
499     with the Intervals' mid points.
500     """
501 
502     return np.array([x.mid for x in array])
503 
504 
505 def _interval_to_bound_points(array):
506     """
507     Helper function which returns an array
508     with the Intervals' boundaries.
509     """
510 
511     array_boundaries = np.array([x.left for x in array])
512     array_boundaries = np.concatenate((array_boundaries, np.array([array[-1].right])))
513 
514     return array_boundaries
515 
516 
517 def _interval_to_double_bound_points(xarray, yarray):
518     """
519     Helper function to deal with a xarray consisting of pd.Intervals. Each
520     interval is replaced with both boundaries. I.e. the length of xarray
521     doubles. yarray is modified so it matches the new shape of xarray.
522     """
523 
524     xarray1 = np.array([x.left for x in xarray])
525     xarray2 = np.array([x.right for x in xarray])
526 
527     xarray = list(itertools.chain.from_iterable(zip(xarray1, xarray2)))
528     yarray = list(itertools.chain.from_iterable(zip(yarray, yarray)))
529 
530     return xarray, yarray
531 
532 
533 def _resolve_intervals_1dplot(xval, yval, kwargs):
534     """
535     Helper function to replace the values of x and/or y coordinate arrays
536     containing pd.Interval with their mid-points or - for step plots - double
537     points which double the length.
538     """
539     x_suffix = ""
540     y_suffix = ""
541 
542     # Is it a step plot? (see matplotlib.Axes.step)
543     if kwargs.get("drawstyle", "").startswith("steps-"):
544 
545         remove_drawstyle = False
546         # Convert intervals to double points
547         if _valid_other_type(np.array([xval, yval]), [pd.Interval]):
548             raise TypeError("Can't step plot intervals against intervals.")
549         if _valid_other_type(xval, [pd.Interval]):
550             xval, yval = _interval_to_double_bound_points(xval, yval)
551             remove_drawstyle = True
552         if _valid_other_type(yval, [pd.Interval]):
553             yval, xval = _interval_to_double_bound_points(yval, xval)
554             remove_drawstyle = True
555 
556         # Remove steps-* to be sure that matplotlib is not confused
557         if remove_drawstyle:
558             del kwargs["drawstyle"]
559 
560     # Is it another kind of plot?
561     else:
562 
563         # Convert intervals to mid points and adjust labels
564         if _valid_other_type(xval, [pd.Interval]):
565             xval = _interval_to_mid_points(xval)
566             x_suffix = "_center"
567         if _valid_other_type(yval, [pd.Interval]):
568             yval = _interval_to_mid_points(yval)
569             y_suffix = "_center"
570 
571     # return converted arguments
572     return xval, yval, x_suffix, y_suffix, kwargs
573 
574 
575 def _resolve_intervals_2dplot(val, func_name):
576     """
577     Helper function to replace the values of a coordinate array containing
578     pd.Interval with their mid-points or - for pcolormesh - boundaries which
579     increases length by 1.
580     """
581     label_extra = ""
582     if _valid_other_type(val, [pd.Interval]):
583         if func_name == "pcolormesh":
584             val = _interval_to_bound_points(val)
585         else:
586             val = _interval_to_mid_points(val)
587             label_extra = "_center"
588 
589     return val, label_extra
590 
591 
592 def _valid_other_type(x, types):
593     """
594     Do all elements of x have a type from types?
595     """
596     return all(any(isinstance(el, t) for t in types) for el in np.ravel(x))
597 
598 
599 def _valid_numpy_subdtype(x, numpy_types):
600     """
601     Is any dtype from numpy_types superior to the dtype of x?
602     """
603     # If any of the types given in numpy_types is understood as numpy.generic,
604     # all possible x will be considered valid.  This is probably unwanted.
605     for t in numpy_types:
606         assert not np.issubdtype(np.generic, t)
607 
608     return any(np.issubdtype(x.dtype, t) for t in numpy_types)
609 
610 
611 def _ensure_plottable(*args):
612     """
613     Raise exception if there is anything in args that can't be plotted on an
614     axis by matplotlib.
615     """
616     numpy_types = [
617         np.floating,
618         np.integer,
619         np.timedelta64,
620         np.datetime64,
621         np.bool_,
622         np.str_,
623     ]
624     other_types = [datetime]
625     try:
626         import cftime
627 
628         cftime_datetime = [cftime.datetime]
629     except ImportError:
630         cftime_datetime = []
631     other_types = other_types + cftime_datetime
632     for x in args:
633         if not (
634             _valid_numpy_subdtype(np.array(x), numpy_types)
635             or _valid_other_type(np.array(x), other_types)
636         ):
637             raise TypeError(
638                 "Plotting requires coordinates to be numeric, boolean, "
639                 "or dates of type numpy.datetime64, "
640                 "datetime.datetime, cftime.datetime or "
641                 f"pandas.Interval. Received data of type {np.array(x).dtype} instead."
642             )
643         if (
644             _valid_other_type(np.array(x), cftime_datetime)
645             and not nc_time_axis_available
646         ):
647             raise ImportError(
648                 "Plotting of arrays of cftime.datetime "
649                 "objects or arrays indexed by "
650                 "cftime.datetime objects requires the "
651                 "optional `nc-time-axis` (v1.2.0 or later) "
652                 "package."
653             )
654 
655 
656 def _is_numeric(arr):
657     numpy_types = [np.floating, np.integer]
658     return _valid_numpy_subdtype(arr, numpy_types)
659 
660 
661 def _add_colorbar(primitive, ax, cbar_ax, cbar_kwargs, cmap_params):
662 
663     cbar_kwargs.setdefault("extend", cmap_params["extend"])
664     if cbar_ax is None:
665         cbar_kwargs.setdefault("ax", ax)
666     else:
667         cbar_kwargs.setdefault("cax", cbar_ax)
668 
669     # dont pass extend as kwarg if it is in the mappable
670     if hasattr(primitive, "extend"):
671         cbar_kwargs.pop("extend")
672 
673     fig = ax.get_figure()
674     cbar = fig.colorbar(primitive, **cbar_kwargs)
675 
676     return cbar
677 
678 
679 def _rescale_imshow_rgb(darray, vmin, vmax, robust):
680     assert robust or vmin is not None or vmax is not None
681 
682     # Calculate vmin and vmax automatically for `robust=True`
683     if robust:
684         if vmax is None:
685             vmax = np.nanpercentile(darray, 100 - ROBUST_PERCENTILE)
686         if vmin is None:
687             vmin = np.nanpercentile(darray, ROBUST_PERCENTILE)
688     # If not robust and one bound is None, calculate the default other bound
689     # and check that an interval between them exists.
690     elif vmax is None:
691         vmax = 255 if np.issubdtype(darray.dtype, np.integer) else 1
692         if vmax < vmin:
693             raise ValueError(
694                 f"vmin={vmin!r} is less than the default vmax ({vmax!r}) - you must supply "
695                 "a vmax > vmin in this case."
696             )
697     elif vmin is None:
698         vmin = 0
699         if vmin > vmax:
700             raise ValueError(
701                 f"vmax={vmax!r} is less than the default vmin (0) - you must supply "
702                 "a vmin < vmax in this case."
703             )
704     # Scale interval [vmin .. vmax] to [0 .. 1], with darray as 64-bit float
705     # to avoid precision loss, integer over/underflow, etc with extreme inputs.
706     # After scaling, downcast to 32-bit float.  This substantially reduces
707     # memory usage after we hand `darray` off to matplotlib.
708     darray = ((darray.astype("f8") - vmin) / (vmax - vmin)).astype("f4")
709     return np.minimum(np.maximum(darray, 0), 1)
710 
711 
712 def _update_axes(
713     ax,
714     xincrease,
715     yincrease,
716     xscale=None,
717     yscale=None,
718     xticks=None,
719     yticks=None,
720     xlim=None,
721     ylim=None,
722 ):
723     """
724     Update axes with provided parameters
725     """
726     if xincrease is None:
727         pass
728     elif xincrease and ax.xaxis_inverted():
729         ax.invert_xaxis()
730     elif not xincrease and not ax.xaxis_inverted():
731         ax.invert_xaxis()
732 
733     if yincrease is None:
734         pass
735     elif yincrease and ax.yaxis_inverted():
736         ax.invert_yaxis()
737     elif not yincrease and not ax.yaxis_inverted():
738         ax.invert_yaxis()
739 
740     # The default xscale, yscale needs to be None.
741     # If we set a scale it resets the axes formatters,
742     # This means that set_xscale('linear') on a datetime axis
743     # will remove the date labels. So only set the scale when explicitly
744     # asked to. https://github.com/matplotlib/matplotlib/issues/8740
745     if xscale is not None:
746         ax.set_xscale(xscale)
747     if yscale is not None:
748         ax.set_yscale(yscale)
749 
750     if xticks is not None:
751         ax.set_xticks(xticks)
752     if yticks is not None:
753         ax.set_yticks(yticks)
754 
755     if xlim is not None:
756         ax.set_xlim(xlim)
757     if ylim is not None:
758         ax.set_ylim(ylim)
759 
760 
761 def _is_monotonic(coord, axis=0):
762     """
763     >>> _is_monotonic(np.array([0, 1, 2]))
764     True
765     >>> _is_monotonic(np.array([2, 1, 0]))
766     True
767     >>> _is_monotonic(np.array([0, 2, 1]))
768     False
769     """
770     if coord.shape[axis] < 3:
771         return True
772     else:
773         n = coord.shape[axis]
774         delta_pos = coord.take(np.arange(1, n), axis=axis) >= coord.take(
775             np.arange(0, n - 1), axis=axis
776         )
777         delta_neg = coord.take(np.arange(1, n), axis=axis) <= coord.take(
778             np.arange(0, n - 1), axis=axis
779         )
780         return np.all(delta_pos) or np.all(delta_neg)
781 
782 
783 def _infer_interval_breaks(coord, axis=0, scale=None, check_monotonic=False):
784     """
785     >>> _infer_interval_breaks(np.arange(5))
786     array([-0.5,  0.5,  1.5,  2.5,  3.5,  4.5])
787     >>> _infer_interval_breaks([[0, 1], [3, 4]], axis=1)
788     array([[-0.5,  0.5,  1.5],
789            [ 2.5,  3.5,  4.5]])
790     >>> _infer_interval_breaks(np.logspace(-2, 2, 5), scale="log")
791     array([3.16227766e-03, 3.16227766e-02, 3.16227766e-01, 3.16227766e+00,
792            3.16227766e+01, 3.16227766e+02])
793     """
794     coord = np.asarray(coord)
795 
796     if check_monotonic and not _is_monotonic(coord, axis=axis):
797         raise ValueError(
798             "The input coordinate is not sorted in increasing "
799             "order along axis %d. This can lead to unexpected "
800             "results. Consider calling the `sortby` method on "
801             "the input DataArray. To plot data with categorical "
802             "axes, consider using the `heatmap` function from "
803             "the `seaborn` statistical plotting library." % axis
804         )
805 
806     # If logscale, compute the intervals in the logarithmic space
807     if scale == "log":
808         if (coord <= 0).any():
809             raise ValueError(
810                 "Found negative or zero value in coordinates. "
811                 + "Coordinates must be positive on logscale plots."
812             )
813         coord = np.log10(coord)
814 
815     deltas = 0.5 * np.diff(coord, axis=axis)
816     if deltas.size == 0:
817         deltas = np.array(0.0)
818     first = np.take(coord, [0], axis=axis) - np.take(deltas, [0], axis=axis)
819     last = np.take(coord, [-1], axis=axis) + np.take(deltas, [-1], axis=axis)
820     trim_last = tuple(
821         slice(None, -1) if n == axis else slice(None) for n in range(coord.ndim)
822     )
823     interval_breaks = np.concatenate(
824         [first, coord[trim_last] + deltas, last], axis=axis
825     )
826     if scale == "log":
827         # Recovert the intervals into the linear space
828         return np.power(10, interval_breaks)
829     return interval_breaks
830 
831 
832 def _process_cmap_cbar_kwargs(
833     func,
834     data,
835     cmap=None,
836     colors=None,
837     cbar_kwargs: Union[Iterable[Tuple[str, Any]], Mapping[str, Any]] = None,
838     levels=None,
839     _is_facetgrid=False,
840     **kwargs,
841 ):
842     """
843     Parameters
844     ----------
845     func : plotting function
846     data : ndarray,
847         Data values
848 
849     Returns
850     -------
851     cmap_params
852     cbar_kwargs
853     """
854     if func.__name__ == "surface":
855         # Leave user to specify cmap settings for surface plots
856         kwargs["cmap"] = cmap
857         return {
858             k: kwargs.get(k, None)
859             for k in ["vmin", "vmax", "cmap", "extend", "levels", "norm"]
860         }, {}
861 
862     cbar_kwargs = {} if cbar_kwargs is None else dict(cbar_kwargs)
863 
864     if "contour" in func.__name__ and levels is None:
865         levels = 7  # this is the matplotlib default
866 
867     # colors is mutually exclusive with cmap
868     if cmap and colors:
869         raise ValueError("Can't specify both cmap and colors.")
870 
871     # colors is only valid when levels is supplied or the plot is of type
872     # contour or contourf
873     if colors and (("contour" not in func.__name__) and (levels is None)):
874         raise ValueError("Can only specify colors with contour or levels")
875 
876     # we should not be getting a list of colors in cmap anymore
877     # is there a better way to do this test?
878     if isinstance(cmap, (list, tuple)):
879         raise ValueError(
880             "Specifying a list of colors in cmap is deprecated. "
881             "Use colors keyword instead."
882         )
883 
884     cmap_kwargs = {
885         "plot_data": data,
886         "levels": levels,
887         "cmap": colors if colors else cmap,
888         "filled": func.__name__ != "contour",
889     }
890 
891     cmap_args = getfullargspec(_determine_cmap_params).args
892     cmap_kwargs.update((a, kwargs[a]) for a in cmap_args if a in kwargs)
893     if not _is_facetgrid:
894         cmap_params = _determine_cmap_params(**cmap_kwargs)
895     else:
896         cmap_params = {
897             k: cmap_kwargs[k]
898             for k in ["vmin", "vmax", "cmap", "extend", "levels", "norm"]
899         }
900 
901     return cmap_params, cbar_kwargs
902 
903 
904 def _get_nice_quiver_magnitude(u, v):
905     import matplotlib as mpl
906 
907     ticker = mpl.ticker.MaxNLocator(3)
908     mean = np.mean(np.hypot(u.to_numpy(), v.to_numpy()))
909     magnitude = ticker.tick_values(0, mean)[-2]
910     return magnitude
911 
912 
913 # Copied from matplotlib, tweaked so func can return strings.
914 # https://github.com/matplotlib/matplotlib/issues/19555
915 def legend_elements(
916     self, prop="colors", num="auto", fmt=None, func=lambda x: x, **kwargs
917 ):
918     """
919     Create legend handles and labels for a PathCollection.
920 
921     Each legend handle is a `.Line2D` representing the Path that was drawn,
922     and each label is a string what each Path represents.
923 
924     This is useful for obtaining a legend for a `~.Axes.scatter` plot;
925     e.g.::
926 
927         scatter = plt.scatter([1, 2, 3],  [4, 5, 6],  c=[7, 2, 3])
928         plt.legend(*scatter.legend_elements())
929 
930     creates three legend elements, one for each color with the numerical
931     values passed to *c* as the labels.
932 
933     Also see the :ref:`automatedlegendcreation` example.
934 
935 
936     Parameters
937     ----------
938     prop : {"colors", "sizes"}, default: "colors"
939         If "colors", the legend handles will show the different colors of
940         the collection. If "sizes", the legend will show the different
941         sizes. To set both, use *kwargs* to directly edit the `.Line2D`
942         properties.
943     num : int, None, "auto" (default), array-like, or `~.ticker.Locator`
944         Target number of elements to create.
945         If None, use all unique elements of the mappable array. If an
946         integer, target to use *num* elements in the normed range.
947         If *"auto"*, try to determine which option better suits the nature
948         of the data.
949         The number of created elements may slightly deviate from *num* due
950         to a `~.ticker.Locator` being used to find useful locations.
951         If a list or array, use exactly those elements for the legend.
952         Finally, a `~.ticker.Locator` can be provided.
953     fmt : str, `~matplotlib.ticker.Formatter`, or None (default)
954         The format or formatter to use for the labels. If a string must be
955         a valid input for a `~.StrMethodFormatter`. If None (the default),
956         use a `~.ScalarFormatter`.
957     func : function, default: ``lambda x: x``
958         Function to calculate the labels.  Often the size (or color)
959         argument to `~.Axes.scatter` will have been pre-processed by the
960         user using a function ``s = f(x)`` to make the markers visible;
961         e.g. ``size = np.log10(x)``.  Providing the inverse of this
962         function here allows that pre-processing to be inverted, so that
963         the legend labels have the correct values; e.g. ``func = lambda
964         x: 10**x``.
965     **kwargs
966         Allowed keyword arguments are *color* and *size*. E.g. it may be
967         useful to set the color of the markers if *prop="sizes"* is used;
968         similarly to set the size of the markers if *prop="colors"* is
969         used. Any further parameters are passed onto the `.Line2D`
970         instance. This may be useful to e.g. specify a different
971         *markeredgecolor* or *alpha* for the legend handles.
972 
973     Returns
974     -------
975     handles : list of `.Line2D`
976         Visual representation of each element of the legend.
977     labels : list of str
978         The string labels for elements of the legend.
979     """
980     import warnings
981 
982     import matplotlib as mpl
983 
984     mlines = mpl.lines
985 
986     handles = []
987     labels = []
988 
989     if prop == "colors":
990         arr = self.get_array()
991         if arr is None:
992             warnings.warn(
993                 "Collection without array used. Make sure to "
994                 "specify the values to be colormapped via the "
995                 "`c` argument."
996             )
997             return handles, labels
998         _size = kwargs.pop("size", mpl.rcParams["lines.markersize"])
999 
1000         def _get_color_and_size(value):
1001             return self.cmap(self.norm(value)), _size
1002 
1003     elif prop == "sizes":
1004         arr = self.get_sizes()
1005         _color = kwargs.pop("color", "k")
1006 
1007         def _get_color_and_size(value):
1008             return _color, np.sqrt(value)
1009 
1010     else:
1011         raise ValueError(
1012             "Valid values for `prop` are 'colors' or "
1013             f"'sizes'. You supplied '{prop}' instead."
1014         )
1015 
1016     # Get the unique values and their labels:
1017     values = np.unique(arr)
1018     label_values = np.asarray(func(values))
1019     label_values_are_numeric = np.issubdtype(label_values.dtype, np.number)
1020 
1021     # Handle the label format:
1022     if fmt is None and label_values_are_numeric:
1023         fmt = mpl.ticker.ScalarFormatter(useOffset=False, useMathText=True)
1024     elif fmt is None and not label_values_are_numeric:
1025         fmt = mpl.ticker.StrMethodFormatter("{x}")
1026     elif isinstance(fmt, str):
1027         fmt = mpl.ticker.StrMethodFormatter(fmt)
1028     fmt.create_dummy_axis()
1029 
1030     if num == "auto":
1031         num = 9
1032         if len(values) <= num:
1033             num = None
1034 
1035     if label_values_are_numeric:
1036         label_values_min = label_values.min()
1037         label_values_max = label_values.max()
1038         fmt.set_bounds(label_values_min, label_values_max)
1039 
1040         if num is not None:
1041             # Labels are numerical but larger than the target
1042             # number of elements, reduce to target using matplotlibs
1043             # ticker classes:
1044             if isinstance(num, mpl.ticker.Locator):
1045                 loc = num
1046             elif np.iterable(num):
1047                 loc = mpl.ticker.FixedLocator(num)
1048             else:
1049                 num = int(num)
1050                 loc = mpl.ticker.MaxNLocator(
1051                     nbins=num, min_n_ticks=num - 1, steps=[1, 2, 2.5, 3, 5, 6, 8, 10]
1052                 )
1053 
1054             # Get nicely spaced label_values:
1055             label_values = loc.tick_values(label_values_min, label_values_max)
1056 
1057             # Remove extrapolated label_values:
1058             cond = (label_values >= label_values_min) & (
1059                 label_values <= label_values_max
1060             )
1061             label_values = label_values[cond]
1062 
1063             # Get the corresponding values by creating a linear interpolant
1064             # with small step size:
1065             values_interp = np.linspace(values.min(), values.max(), 256)
1066             label_values_interp = func(values_interp)
1067             ix = np.argsort(label_values_interp)
1068             values = np.interp(label_values, label_values_interp[ix], values_interp[ix])
1069     elif num is not None and not label_values_are_numeric:
1070         # Labels are not numerical so modifying label_values is not
1071         # possible, instead filter the array with nicely distributed
1072         # indexes:
1073         if type(num) == int:
1074             loc = mpl.ticker.LinearLocator(num)
1075         else:
1076             raise ValueError("`num` only supports integers for non-numeric labels.")
1077 
1078         ind = loc.tick_values(0, len(label_values) - 1).astype(int)
1079         label_values = label_values[ind]
1080         values = values[ind]
1081 
1082     # Some formatters requires set_locs:
1083     if hasattr(fmt, "set_locs"):
1084         fmt.set_locs(label_values)
1085 
1086     # Default settings for handles, add or override with kwargs:
1087     kw = dict(markeredgewidth=self.get_linewidths()[0], alpha=self.get_alpha())
1088     kw.update(kwargs)
1089 
1090     for val, lab in zip(values, label_values):
1091         color, size = _get_color_and_size(val)
1092         h = mlines.Line2D(
1093             [0], [0], ls="", color=color, ms=size, marker=self.get_paths()[0], **kw
1094         )
1095         handles.append(h)
1096         labels.append(fmt(lab))
1097 
1098     return handles, labels
1099 
1100 
1101 def _legend_add_subtitle(handles, labels, text, func):
1102     """Add a subtitle to legend handles."""
1103     if text and len(handles) > 1:
1104         # Create a blank handle that's not visible, the
1105         # invisibillity will be used to discern which are subtitles
1106         # or not:
1107         blank_handle = func([], [], label=text)
1108         blank_handle.set_visible(False)
1109 
1110         # Subtitles are shown first:
1111         handles = [blank_handle] + handles
1112         labels = [text] + labels
1113 
1114     return handles, labels
1115 
1116 
1117 def _adjust_legend_subtitles(legend):
1118     """Make invisible-handle "subtitles" entries look more like titles."""
1119     plt = import_matplotlib_pyplot()
1120 
1121     # Legend title not in rcParams until 3.0
1122     font_size = plt.rcParams.get("legend.title_fontsize", None)
1123     hpackers = legend.findobj(plt.matplotlib.offsetbox.VPacker)[0].get_children()
1124     for hpack in hpackers:
1125         draw_area, text_area = hpack.get_children()
1126         handles = draw_area.get_children()
1127 
1128         # Assume that all artists that are not visible are
1129         # subtitles:
1130         if not all(artist.get_visible() for artist in handles):
1131             # Remove the dummy marker which will bring the text
1132             # more to the center:
1133             draw_area.set_width(0)
1134             for text in text_area.get_children():
1135                 if font_size is not None:
1136                     # The sutbtitles should have the same font size
1137                     # as normal legend titles:
1138                     text.set_size(font_size)

</code><intended_behavior>Utility functions that handle plot labels should respect and preserve LaTeX formatting in text passed to them. When attributes are extracted and processed for plotting labels, the code should ensure that LaTeX strings are recognized and retained in a format that matplotlib can render as LaTeX. This could involve detecting LaTeX in strings and ensuring they are formatted correctly for matplotlib (e.g., wrapping in `$` if not already done so) and not escaping special characters accidentally.</intended_behavior>]
2025-10-15 21:55:56.086 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-15 21:55:56.086 | INFO     | Search-only: skipping patch selection
2025-10-15 21:55:56.151 | INFO     | Task pydata__xarray-5682 completed successfully.
2025-10-15 21:55:56.152 | INFO     | No patch generated. You can try running ACR again.
