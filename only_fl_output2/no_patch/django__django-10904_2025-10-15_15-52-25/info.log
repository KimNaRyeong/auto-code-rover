2025-10-15 15:52:25.600 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-15 15:52:28.918 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=344, output_tokens=12, cost=0.003800
2025-10-15 15:52:28.919 | INFO     | Test agent decides that the issue statement does not contain reproduction steps; skipping reproducer tracing
2025-10-15 15:52:28.923 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 15:52:39.321 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=653, output_tokens=339, cost=0.016700
2025-10-15 15:52:39.329 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 15:52:42.596 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=693, output_tokens=80, cost=0.009330
2025-10-15 15:52:42.597 | DEBUG    | Extracted a valid json.
2025-10-15 15:52:42.597 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_code(\"IOError\")",
        "search_code(\"EnvironmentError\")",
        "search_code(\"WindowsError\")",
        "search_code(\"mmap.error\")",
        "search_code(\"socket.error\")",
        "search_code(\"select.error\")",
        "search_code(\"SMTPException\")"
    ],
    "bug_locations": []
}
2025-10-15 15:52:42.760 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-15 15:52:42.760 | DEBUG    | <Agent search> Analyzing search results.
2025-10-15 15:53:05.162 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2023, output_tokens=703, cost=0.041320
2025-10-15 15:53:05.176 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 15:53:24.535 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2942, output_tokens=686, cost=0.050000
2025-10-15 15:53:24.551 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 15:53:47.815 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1040, output_tokens=710, cost=0.031700
2025-10-15 15:53:47.816 | DEBUG    | Extracted a valid json.
2025-10-15 15:53:47.816 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "django/middleware/csrf.py",
            "class": "",
            "method": "",
            "intended_behavior": "Replace IOError with OSError in exception handling to align with modern Python practices. Preserve logic for handling cases where I/O errors occur."
        },
        {
            "file": "django/http/response.py",
            "class": "",
            "method": "",
            "intended_behavior": "Update exception handling to use OSError instead of IOError, ensuring responses continue to gracefully handle file-related errors during processing."
        },
        {
            "file": "django/http/request.py",
            "class": "",
            "method": "",
            "intended_behavior": "Swap IOError for OSError in file upload and reading operations, maintaining robustness in request handling."
        },
        {
            "file": "django/utils/translation/trans_real.py",
            "class": "",
            "method": "",
            "intended_behavior": "Use OSError to handle file-related translation loading issues, keeping functionality to catch and manage translation file errors."
        },
        {
            "file": "django/views/debug.py",
            "class": "",
            "method": "",
            "intended_behavior": "Amend to use OSError for managing file access errors in debug views, ensuring error pages render correctly upon issues."
        },
        {
            "file": "django/contrib/staticfiles/storage.py",
            "class": "",
            "method": "",
            "intended_behavior": "Replace IOError with OSError for static files storage operations, preserving integrity in static file serving and error logging."
        },
        {
            "file": "django/contrib/sessions/backends/file.py",
            "class": "",
            "method": "",
            "intended_behavior": "Update session file backend to use OSError for session file management errors, maintaining session data integrity and error handling."
        },
        {
            "file": "django/contrib/gis/geos/libgeos.py",
            "class": "",
            "method": "load_geos",
            "intended_behavior": "Transition from EnvironmentError to OSError while loading GEOS libraries, ensuring library path issues are captured under a unified exception."
        },
        {
            "file": "django/contrib/gis/gdal/libgdal.py",
            "class": "",
            "method": "",
            "intended_behavior": "Use OSError for handling GDAL library path configurations, keeping the GIS component adaptable to configuration and file access issues."
        },
        {
            "file": "django/core/management/commands/runserver.py",
            "class": "",
            "method": "",
            "intended_behavior": "Change socket.error to capture with OSError during server run operations, to handle network-related errors uniformly."
        },
        {
            "file": "django/core/servers/basehttp.py",
            "class": "",
            "method": "",
            "intended_behavior": "Update exception handling to OSError instead of socket.error for HTTP server operations to manage connection and network errors consistently."
        },
        {
            "file": "django/core/mail/backends/smtp.py",
            "class": "EmailBackend",
            "method": "open, close, _send",
            "intended_behavior": "For SMTP operations, adjust to use OSError while considering to keep or remove specific catches for smtplib.SMTPException based on whether the additional granularity is required for email sending error handling."
        }
    ]
}
2025-10-15 15:53:47.839 | DEBUG    | Bug location extracted successfully: [<file>django/middleware/csrf.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2 Cross Site Request Forgery Middleware.
3 
4 This module provides a middleware that implements protection
5 against request forgeries from other sites.
6 """
7 import logging
8 import re
9 import string
10 from urllib.parse import urlparse
11 
12 from django.conf import settings
13 from django.core.exceptions import DisallowedHost, ImproperlyConfigured
14 from django.urls import get_callable
15 from django.utils.cache import patch_vary_headers
16 from django.utils.crypto import constant_time_compare, get_random_string
17 from django.utils.deprecation import MiddlewareMixin
18 from django.utils.http import is_same_domain
19 from django.utils.log import log_response
20 
21 logger = logging.getLogger('django.security.csrf')
22 
23 REASON_NO_REFERER = "Referer checking failed - no Referer."
24 REASON_BAD_REFERER = "Referer checking failed - %s does not match any trusted origins."
25 REASON_NO_CSRF_COOKIE = "CSRF cookie not set."
26 REASON_BAD_TOKEN = "CSRF token missing or incorrect."
27 REASON_MALFORMED_REFERER = "Referer checking failed - Referer is malformed."
28 REASON_INSECURE_REFERER = "Referer checking failed - Referer is insecure while host is secure."
29 
30 CSRF_SECRET_LENGTH = 32
31 CSRF_TOKEN_LENGTH = 2 * CSRF_SECRET_LENGTH
32 CSRF_ALLOWED_CHARS = string.ascii_letters + string.digits
33 CSRF_SESSION_KEY = '_csrftoken'
34 
35 
36 def _get_failure_view():
37     """Return the view to be used for CSRF rejections."""
38     return get_callable(settings.CSRF_FAILURE_VIEW)
39 
40 
41 def _get_new_csrf_string():
42     return get_random_string(CSRF_SECRET_LENGTH, allowed_chars=CSRF_ALLOWED_CHARS)
43 
44 
45 def _salt_cipher_secret(secret):
46     """
47     Given a secret (assumed to be a string of CSRF_ALLOWED_CHARS), generate a
48     token by adding a salt and using it to encrypt the secret.
49     """
50     salt = _get_new_csrf_string()
51     chars = CSRF_ALLOWED_CHARS
52     pairs = zip((chars.index(x) for x in secret), (chars.index(x) for x in salt))
53     cipher = ''.join(chars[(x + y) % len(chars)] for x, y in pairs)
54     return salt + cipher
55 
56 
57 def _unsalt_cipher_token(token):
58     """
59     Given a token (assumed to be a string of CSRF_ALLOWED_CHARS, of length
60     CSRF_TOKEN_LENGTH, and that its first half is a salt), use it to decrypt
61     the second half to produce the original secret.
62     """
63     salt = token[:CSRF_SECRET_LENGTH]
64     token = token[CSRF_SECRET_LENGTH:]
65     chars = CSRF_ALLOWED_CHARS
66     pairs = zip((chars.index(x) for x in token), (chars.index(x) for x in salt))
67     secret = ''.join(chars[x - y] for x, y in pairs)  # Note negative values are ok
68     return secret
69 
70 
71 def _get_new_csrf_token():
72     return _salt_cipher_secret(_get_new_csrf_string())
73 
74 
75 def get_token(request):
76     """
77     Return the CSRF token required for a POST form. The token is an
78     alphanumeric value. A new token is created if one is not already set.
79 
80     A side effect of calling this function is to make the csrf_protect
81     decorator and the CsrfViewMiddleware add a CSRF cookie and a 'Vary: Cookie'
82     header to the outgoing response.  For this reason, you may need to use this
83     function lazily, as is done by the csrf context processor.
84     """
85     if "CSRF_COOKIE" not in request.META:
86         csrf_secret = _get_new_csrf_string()
87         request.META["CSRF_COOKIE"] = _salt_cipher_secret(csrf_secret)
88     else:
89         csrf_secret = _unsalt_cipher_token(request.META["CSRF_COOKIE"])
90     request.META["CSRF_COOKIE_USED"] = True
91     return _salt_cipher_secret(csrf_secret)
92 
93 
94 def rotate_token(request):
95     """
96     Change the CSRF token in use for a request - should be done on login
97     for security purposes.
98     """
99     request.META.update({
100         "CSRF_COOKIE_USED": True,
101         "CSRF_COOKIE": _get_new_csrf_token(),
102     })
103     request.csrf_cookie_needs_reset = True
104 
105 
106 def _sanitize_token(token):
107     # Allow only ASCII alphanumerics
108     if re.search('[^a-zA-Z0-9]', token):
109         return _get_new_csrf_token()
110     elif len(token) == CSRF_TOKEN_LENGTH:
111         return token
112     elif len(token) == CSRF_SECRET_LENGTH:
113         # Older Django versions set cookies to values of CSRF_SECRET_LENGTH
114         # alphanumeric characters. For backwards compatibility, accept
115         # such values as unsalted secrets.
116         # It's easier to salt here and be consistent later, rather than add
117         # different code paths in the checks, although that might be a tad more
118         # efficient.
119         return _salt_cipher_secret(token)
120     return _get_new_csrf_token()
121 
122 
123 def _compare_salted_tokens(request_csrf_token, csrf_token):
124     # Assume both arguments are sanitized -- that is, strings of
125     # length CSRF_TOKEN_LENGTH, all CSRF_ALLOWED_CHARS.
126     return constant_time_compare(
127         _unsalt_cipher_token(request_csrf_token),
128         _unsalt_cipher_token(csrf_token),
129     )
130 
131 
132 class CsrfViewMiddleware(MiddlewareMixin):
133     """
134     Require a present and correct csrfmiddlewaretoken for POST requests that
135     have a CSRF cookie, and set an outgoing CSRF cookie.
136 
137     This middleware should be used in conjunction with the {% csrf_token %}
138     template tag.
139     """
140     # The _accept and _reject methods currently only exist for the sake of the
141     # requires_csrf_token decorator.
142     def _accept(self, request):
143         # Avoid checking the request twice by adding a custom attribute to
144         # request.  This will be relevant when both decorator and middleware
145         # are used.
146         request.csrf_processing_done = True
147         return None
148 
149     def _reject(self, request, reason):
150         response = _get_failure_view()(request, reason=reason)
151         log_response(
152             'Forbidden (%s): %s', reason, request.path,
153             response=response,
154             request=request,
155             logger=logger,
156         )
157         return response
158 
159     def _get_token(self, request):
160         if settings.CSRF_USE_SESSIONS:
161             try:
162                 return request.session.get(CSRF_SESSION_KEY)
163             except AttributeError:
164                 raise ImproperlyConfigured(
165                     'CSRF_USE_SESSIONS is enabled, but request.session is not '
166                     'set. SessionMiddleware must appear before CsrfViewMiddleware '
167                     'in MIDDLEWARE%s.' % ('_CLASSES' if settings.MIDDLEWARE is None else '')
168                 )
169         else:
170             try:
171                 cookie_token = request.COOKIES[settings.CSRF_COOKIE_NAME]
172             except KeyError:
173                 return None
174 
175             csrf_token = _sanitize_token(cookie_token)
176             if csrf_token != cookie_token:
177                 # Cookie token needed to be replaced;
178                 # the cookie needs to be reset.
179                 request.csrf_cookie_needs_reset = True
180             return csrf_token
181 
182     def _set_token(self, request, response):
183         if settings.CSRF_USE_SESSIONS:
184             if request.session.get(CSRF_SESSION_KEY) != request.META['CSRF_COOKIE']:
185                 request.session[CSRF_SESSION_KEY] = request.META['CSRF_COOKIE']
186         else:
187             response.set_cookie(
188                 settings.CSRF_COOKIE_NAME,
189                 request.META['CSRF_COOKIE'],
190                 max_age=settings.CSRF_COOKIE_AGE,
191                 domain=settings.CSRF_COOKIE_DOMAIN,
192                 path=settings.CSRF_COOKIE_PATH,
193                 secure=settings.CSRF_COOKIE_SECURE,
194                 httponly=settings.CSRF_COOKIE_HTTPONLY,
195                 samesite=settings.CSRF_COOKIE_SAMESITE,
196             )
197             # Set the Vary header since content varies with the CSRF cookie.
198             patch_vary_headers(response, ('Cookie',))
199 
200     def process_request(self, request):
201         csrf_token = self._get_token(request)
202         if csrf_token is not None:
203             # Use same token next time.
204             request.META['CSRF_COOKIE'] = csrf_token
205 
206     def process_view(self, request, callback, callback_args, callback_kwargs):
207         if getattr(request, 'csrf_processing_done', False):
208             return None
209 
210         # Wait until request.META["CSRF_COOKIE"] has been manipulated before
211         # bailing out, so that get_token still works
212         if getattr(callback, 'csrf_exempt', False):
213             return None
214 
215         # Assume that anything not defined as 'safe' by RFC7231 needs protection
216         if request.method not in ('GET', 'HEAD', 'OPTIONS', 'TRACE'):
217             if getattr(request, '_dont_enforce_csrf_checks', False):
218                 # Mechanism to turn off CSRF checks for test suite.
219                 # It comes after the creation of CSRF cookies, so that
220                 # everything else continues to work exactly the same
221                 # (e.g. cookies are sent, etc.), but before any
222                 # branches that call reject().
223                 return self._accept(request)
224 
225             if request.is_secure():
226                 # Suppose user visits http://example.com/
227                 # An active network attacker (man-in-the-middle, MITM) sends a
228                 # POST form that targets https://example.com/detonate-bomb/ and
229                 # submits it via JavaScript.
230                 #
231                 # The attacker will need to provide a CSRF cookie and token, but
232                 # that's no problem for a MITM and the session-independent
233                 # secret we're using. So the MITM can circumvent the CSRF
234                 # protection. This is true for any HTTP connection, but anyone
235                 # using HTTPS expects better! For this reason, for
236                 # https://example.com/ we need additional protection that treats
237                 # http://example.com/ as completely untrusted. Under HTTPS,
238                 # Barth et al. found that the Referer header is missing for
239                 # same-domain requests in only about 0.2% of cases or less, so
240                 # we can use strict Referer checking.
241                 referer = request.META.get('HTTP_REFERER')
242                 if referer is None:
243                     return self._reject(request, REASON_NO_REFERER)
244 
245                 referer = urlparse(referer)
246 
247                 # Make sure we have a valid URL for Referer.
248                 if '' in (referer.scheme, referer.netloc):
249                     return self._reject(request, REASON_MALFORMED_REFERER)
250 
251                 # Ensure that our Referer is also secure.
252                 if referer.scheme != 'https':
253                     return self._reject(request, REASON_INSECURE_REFERER)
254 
255                 # If there isn't a CSRF_COOKIE_DOMAIN, require an exact match
256                 # match on host:port. If not, obey the cookie rules (or those
257                 # for the session cookie, if CSRF_USE_SESSIONS).
258                 good_referer = (
259                     settings.SESSION_COOKIE_DOMAIN
260                     if settings.CSRF_USE_SESSIONS
261                     else settings.CSRF_COOKIE_DOMAIN
262                 )
263                 if good_referer is not None:
264                     server_port = request.get_port()
265                     if server_port not in ('443', '80'):
266                         good_referer = '%s:%s' % (good_referer, server_port)
267                 else:
268                     try:
269                         # request.get_host() includes the port.
270                         good_referer = request.get_host()
271                     except DisallowedHost:
272                         pass
273 
274                 # Create a list of all acceptable HTTP referers, including the
275                 # current host if it's permitted by ALLOWED_HOSTS.
276                 good_hosts = list(settings.CSRF_TRUSTED_ORIGINS)
277                 if good_referer is not None:
278                     good_hosts.append(good_referer)
279 
280                 if not any(is_same_domain(referer.netloc, host) for host in good_hosts):
281                     reason = REASON_BAD_REFERER % referer.geturl()
282                     return self._reject(request, reason)
283 
284             csrf_token = request.META.get('CSRF_COOKIE')
285             if csrf_token is None:
286                 # No CSRF cookie. For POST requests, we insist on a CSRF cookie,
287                 # and in this way we can avoid all CSRF attacks, including login
288                 # CSRF.
289                 return self._reject(request, REASON_NO_CSRF_COOKIE)
290 
291             # Check non-cookie token for match.
292             request_csrf_token = ""
293             if request.method == "POST":
294                 try:
295                     request_csrf_token = request.POST.get('csrfmiddlewaretoken', '')
296                 except IOError:
297                     # Handle a broken connection before we've completed reading
298                     # the POST data. process_view shouldn't raise any
299                     # exceptions, so we'll ignore and serve the user a 403
300                     # (assuming they're still listening, which they probably
301                     # aren't because of the error).
302                     pass
303 
304             if request_csrf_token == "":
305                 # Fall back to X-CSRFToken, to make things easier for AJAX,
306                 # and possible for PUT/DELETE.
307                 request_csrf_token = request.META.get(settings.CSRF_HEADER_NAME, '')
308 
309             request_csrf_token = _sanitize_token(request_csrf_token)
310             if not _compare_salted_tokens(request_csrf_token, csrf_token):
311                 return self._reject(request, REASON_BAD_TOKEN)
312 
313         return self._accept(request)
314 
315     def process_response(self, request, response):
316         if not getattr(request, 'csrf_cookie_needs_reset', False):
317             if getattr(response, 'csrf_cookie_set', False):
318                 return response
319 
320         if not request.META.get("CSRF_COOKIE_USED", False):
321             return response
322 
323         # Set the CSRF cookie even if it's already set, so we renew
324         # the expiry timer.
325         self._set_token(request, response)
326         response.csrf_cookie_set = True
327         return response

</code><intended_behavior>Replace IOError with OSError in exception handling to align with modern Python practices. Preserve logic for handling cases where I/O errors occur.</intended_behavior>, <file>django/http/response.py</file>
<class>None</class>
<method>None</method>
<code>
1 import datetime
2 import json
3 import mimetypes
4 import os
5 import re
6 import sys
7 import time
8 from email.header import Header
9 from http.client import responses
10 from urllib.parse import quote, urlparse
11 
12 from django.conf import settings
13 from django.core import signals, signing
14 from django.core.exceptions import DisallowedRedirect
15 from django.core.serializers.json import DjangoJSONEncoder
16 from django.http.cookie import SimpleCookie
17 from django.utils import timezone
18 from django.utils.encoding import iri_to_uri
19 from django.utils.http import http_date
20 
21 _charset_from_content_type_re = re.compile(r';\s*charset=(?P<charset>[^\s;]+)', re.I)
22 
23 
24 class BadHeaderError(ValueError):
25     pass
26 
27 
28 class HttpResponseBase:
29     """
30     An HTTP response base class with dictionary-accessed headers.
31 
32     This class doesn't handle content. It should not be used directly.
33     Use the HttpResponse and StreamingHttpResponse subclasses instead.
34     """
35 
36     status_code = 200
37 
38     def __init__(self, content_type=None, status=None, reason=None, charset=None):
39         # _headers is a mapping of the lowercase name to the original case of
40         # the header (required for working with legacy systems) and the header
41         # value. Both the name of the header and its value are ASCII strings.
42         self._headers = {}
43         self._closable_objects = []
44         # This parameter is set by the handler. It's necessary to preserve the
45         # historical behavior of request_finished.
46         self._handler_class = None
47         self.cookies = SimpleCookie()
48         self.closed = False
49         if status is not None:
50             try:
51                 self.status_code = int(status)
52             except (ValueError, TypeError):
53                 raise TypeError('HTTP status code must be an integer.')
54 
55             if not 100 <= self.status_code <= 599:
56                 raise ValueError('HTTP status code must be an integer from 100 to 599.')
57         self._reason_phrase = reason
58         self._charset = charset
59         if content_type is None:
60             content_type = 'text/html; charset=%s' % self.charset
61         self['Content-Type'] = content_type
62 
63     @property
64     def reason_phrase(self):
65         if self._reason_phrase is not None:
66             return self._reason_phrase
67         # Leave self._reason_phrase unset in order to use the default
68         # reason phrase for status code.
69         return responses.get(self.status_code, 'Unknown Status Code')
70 
71     @reason_phrase.setter
72     def reason_phrase(self, value):
73         self._reason_phrase = value
74 
75     @property
76     def charset(self):
77         if self._charset is not None:
78             return self._charset
79         content_type = self.get('Content-Type', '')
80         matched = _charset_from_content_type_re.search(content_type)
81         if matched:
82             # Extract the charset and strip its double quotes
83             return matched.group('charset').replace('"', '')
84         return settings.DEFAULT_CHARSET
85 
86     @charset.setter
87     def charset(self, value):
88         self._charset = value
89 
90     def serialize_headers(self):
91         """HTTP headers as a bytestring."""
92         def to_bytes(val, encoding):
93             return val if isinstance(val, bytes) else val.encode(encoding)
94 
95         headers = [
96             (to_bytes(key, 'ascii') + b': ' + to_bytes(value, 'latin-1'))
97             for key, value in self._headers.values()
98         ]
99         return b'\r\n'.join(headers)
100 
101     __bytes__ = serialize_headers
102 
103     @property
104     def _content_type_for_repr(self):
105         return ', "%s"' % self['Content-Type'] if 'Content-Type' in self else ''
106 
107     def _convert_to_charset(self, value, charset, mime_encode=False):
108         """
109         Convert headers key/value to ascii/latin-1 native strings.
110 
111         `charset` must be 'ascii' or 'latin-1'. If `mime_encode` is True and
112         `value` can't be represented in the given charset, apply MIME-encoding.
113         """
114         if not isinstance(value, (bytes, str)):
115             value = str(value)
116         if ((isinstance(value, bytes) and (b'\n' in value or b'\r' in value)) or
117                 isinstance(value, str) and ('\n' in value or '\r' in value)):
118             raise BadHeaderError("Header values can't contain newlines (got %r)" % value)
119         try:
120             if isinstance(value, str):
121                 # Ensure string is valid in given charset
122                 value.encode(charset)
123             else:
124                 # Convert bytestring using given charset
125                 value = value.decode(charset)
126         except UnicodeError as e:
127             if mime_encode:
128                 value = Header(value, 'utf-8', maxlinelen=sys.maxsize).encode()
129             else:
130                 e.reason += ', HTTP response headers must be in %s format' % charset
131                 raise
132         return value
133 
134     def __setitem__(self, header, value):
135         header = self._convert_to_charset(header, 'ascii')
136         value = self._convert_to_charset(value, 'latin-1', mime_encode=True)
137         self._headers[header.lower()] = (header, value)
138 
139     def __delitem__(self, header):
140         self._headers.pop(header.lower(), False)
141 
142     def __getitem__(self, header):
143         return self._headers[header.lower()][1]
144 
145     def has_header(self, header):
146         """Case-insensitive check for a header."""
147         return header.lower() in self._headers
148 
149     __contains__ = has_header
150 
151     def items(self):
152         return self._headers.values()
153 
154     def get(self, header, alternate=None):
155         return self._headers.get(header.lower(), (None, alternate))[1]
156 
157     def set_cookie(self, key, value='', max_age=None, expires=None, path='/',
158                    domain=None, secure=False, httponly=False, samesite=None):
159         """
160         Set a cookie.
161 
162         ``expires`` can be:
163         - a string in the correct format,
164         - a naive ``datetime.datetime`` object in UTC,
165         - an aware ``datetime.datetime`` object in any time zone.
166         If it is a ``datetime.datetime`` object then calculate ``max_age``.
167         """
168         self.cookies[key] = value
169         if expires is not None:
170             if isinstance(expires, datetime.datetime):
171                 if timezone.is_aware(expires):
172                     expires = timezone.make_naive(expires, timezone.utc)
173                 delta = expires - expires.utcnow()
174                 # Add one second so the date matches exactly (a fraction of
175                 # time gets lost between converting to a timedelta and
176                 # then the date string).
177                 delta = delta + datetime.timedelta(seconds=1)
178                 # Just set max_age - the max_age logic will set expires.
179                 expires = None
180                 max_age = max(0, delta.days * 86400 + delta.seconds)
181             else:
182                 self.cookies[key]['expires'] = expires
183         else:
184             self.cookies[key]['expires'] = ''
185         if max_age is not None:
186             self.cookies[key]['max-age'] = max_age
187             # IE requires expires, so set it if hasn't been already.
188             if not expires:
189                 self.cookies[key]['expires'] = http_date(time.time() + max_age)
190         if path is not None:
191             self.cookies[key]['path'] = path
192         if domain is not None:
193             self.cookies[key]['domain'] = domain
194         if secure:
195             self.cookies[key]['secure'] = True
196         if httponly:
197             self.cookies[key]['httponly'] = True
198         if samesite:
199             if samesite.lower() not in ('lax', 'strict'):
200                 raise ValueError('samesite must be "lax" or "strict".')
201             self.cookies[key]['samesite'] = samesite
202 
203     def setdefault(self, key, value):
204         """Set a header unless it has already been set."""
205         if key not in self:
206             self[key] = value
207 
208     def set_signed_cookie(self, key, value, salt='', **kwargs):
209         value = signing.get_cookie_signer(salt=key + salt).sign(value)
210         return self.set_cookie(key, value, **kwargs)
211 
212     def delete_cookie(self, key, path='/', domain=None):
213         # Most browsers ignore the Set-Cookie header if the cookie name starts
214         # with __Host- or __Secure- and the cookie doesn't use the secure flag.
215         secure = key.startswith(('__Secure-', '__Host-'))
216         self.set_cookie(
217             key, max_age=0, path=path, domain=domain, secure=secure,
218             expires='Thu, 01 Jan 1970 00:00:00 GMT',
219         )
220 
221     # Common methods used by subclasses
222 
223     def make_bytes(self, value):
224         """Turn a value into a bytestring encoded in the output charset."""
225         # Per PEP 3333, this response body must be bytes. To avoid returning
226         # an instance of a subclass, this function returns `bytes(value)`.
227         # This doesn't make a copy when `value` already contains bytes.
228 
229         # Handle string types -- we can't rely on force_bytes here because:
230         # - Python attempts str conversion first
231         # - when self._charset != 'utf-8' it re-encodes the content
232         if isinstance(value, bytes):
233             return bytes(value)
234         if isinstance(value, str):
235             return bytes(value.encode(self.charset))
236         # Handle non-string types.
237         return str(value).encode(self.charset)
238 
239     # These methods partially implement the file-like object interface.
240     # See https://docs.python.org/library/io.html#io.IOBase
241 
242     # The WSGI server must call this method upon completion of the request.
243     # See http://blog.dscpl.com.au/2012/10/obligations-for-calling-close-on.html
244     def close(self):
245         for closable in self._closable_objects:
246             try:
247                 closable.close()
248             except Exception:
249                 pass
250         self.closed = True
251         signals.request_finished.send(sender=self._handler_class)
252 
253     def write(self, content):
254         raise IOError("This %s instance is not writable" % self.__class__.__name__)
255 
256     def flush(self):
257         pass
258 
259     def tell(self):
260         raise IOError("This %s instance cannot tell its position" % self.__class__.__name__)
261 
262     # These methods partially implement a stream-like object interface.
263     # See https://docs.python.org/library/io.html#io.IOBase
264 
265     def readable(self):
266         return False
267 
268     def seekable(self):
269         return False
270 
271     def writable(self):
272         return False
273 
274     def writelines(self, lines):
275         raise IOError("This %s instance is not writable" % self.__class__.__name__)
276 
277 
278 class HttpResponse(HttpResponseBase):
279     """
280     An HTTP response class with a string as content.
281 
282     This content that can be read, appended to, or replaced.
283     """
284 
285     streaming = False
286 
287     def __init__(self, content=b'', *args, **kwargs):
288         super().__init__(*args, **kwargs)
289         # Content is a bytestring. See the `content` property methods.
290         self.content = content
291 
292     def __repr__(self):
293         return '<%(cls)s status_code=%(status_code)d%(content_type)s>' % {
294             'cls': self.__class__.__name__,
295             'status_code': self.status_code,
296             'content_type': self._content_type_for_repr,
297         }
298 
299     def serialize(self):
300         """Full HTTP message, including headers, as a bytestring."""
301         return self.serialize_headers() + b'\r\n\r\n' + self.content
302 
303     __bytes__ = serialize
304 
305     @property
306     def content(self):
307         return b''.join(self._container)
308 
309     @content.setter
310     def content(self, value):
311         # Consume iterators upon assignment to allow repeated iteration.
312         if hasattr(value, '__iter__') and not isinstance(value, (bytes, str)):
313             content = b''.join(self.make_bytes(chunk) for chunk in value)
314             if hasattr(value, 'close'):
315                 try:
316                     value.close()
317                 except Exception:
318                     pass
319         else:
320             content = self.make_bytes(value)
321         # Create a list of properly encoded bytestrings to support write().
322         self._container = [content]
323 
324     def __iter__(self):
325         return iter(self._container)
326 
327     def write(self, content):
328         self._container.append(self.make_bytes(content))
329 
330     def tell(self):
331         return len(self.content)
332 
333     def getvalue(self):
334         return self.content
335 
336     def writable(self):
337         return True
338 
339     def writelines(self, lines):
340         for line in lines:
341             self.write(line)
342 
343 
344 class StreamingHttpResponse(HttpResponseBase):
345     """
346     A streaming HTTP response class with an iterator as content.
347 
348     This should only be iterated once, when the response is streamed to the
349     client. However, it can be appended to or replaced with a new iterator
350     that wraps the original content (or yields entirely new content).
351     """
352 
353     streaming = True
354 
355     def __init__(self, streaming_content=(), *args, **kwargs):
356         super().__init__(*args, **kwargs)
357         # `streaming_content` should be an iterable of bytestrings.
358         # See the `streaming_content` property methods.
359         self.streaming_content = streaming_content
360 
361     @property
362     def content(self):
363         raise AttributeError(
364             "This %s instance has no `content` attribute. Use "
365             "`streaming_content` instead." % self.__class__.__name__
366         )
367 
368     @property
369     def streaming_content(self):
370         return map(self.make_bytes, self._iterator)
371 
372     @streaming_content.setter
373     def streaming_content(self, value):
374         self._set_streaming_content(value)
375 
376     def _set_streaming_content(self, value):
377         # Ensure we can never iterate on "value" more than once.
378         self._iterator = iter(value)
379         if hasattr(value, 'close'):
380             self._closable_objects.append(value)
381 
382     def __iter__(self):
383         return self.streaming_content
384 
385     def getvalue(self):
386         return b''.join(self.streaming_content)
387 
388 
389 class FileResponse(StreamingHttpResponse):
390     """
391     A streaming HTTP response class optimized for files.
392     """
393     block_size = 4096
394 
395     def __init__(self, *args, as_attachment=False, filename='', **kwargs):
396         self.as_attachment = as_attachment
397         self.filename = filename
398         super().__init__(*args, **kwargs)
399 
400     def _set_streaming_content(self, value):
401         if not hasattr(value, 'read'):
402             self.file_to_stream = None
403             return super()._set_streaming_content(value)
404 
405         self.file_to_stream = filelike = value
406         if hasattr(filelike, 'close'):
407             self._closable_objects.append(filelike)
408         value = iter(lambda: filelike.read(self.block_size), b'')
409         self.set_headers(filelike)
410         super()._set_streaming_content(value)
411 
412     def set_headers(self, filelike):
413         """
414         Set some common response headers (Content-Length, Content-Type, and
415         Content-Disposition) based on the `filelike` response content.
416         """
417         encoding_map = {
418             'bzip2': 'application/x-bzip',
419             'gzip': 'application/gzip',
420             'xz': 'application/x-xz',
421         }
422         filename = getattr(filelike, 'name', None)
423         filename = filename if (isinstance(filename, str) and filename) else self.filename
424         if os.path.isabs(filename):
425             self['Content-Length'] = os.path.getsize(filelike.name)
426         elif hasattr(filelike, 'getbuffer'):
427             self['Content-Length'] = filelike.getbuffer().nbytes
428 
429         if self.get('Content-Type', '').startswith('text/html'):
430             if filename:
431                 content_type, encoding = mimetypes.guess_type(filename)
432                 # Encoding isn't set to prevent browsers from automatically
433                 # uncompressing files.
434                 content_type = encoding_map.get(encoding, content_type)
435                 self['Content-Type'] = content_type or 'application/octet-stream'
436             else:
437                 self['Content-Type'] = 'application/octet-stream'
438 
439         if self.as_attachment:
440             filename = self.filename or os.path.basename(filename)
441             if filename:
442                 try:
443                     filename.encode('ascii')
444                     file_expr = 'filename="{}"'.format(filename)
445                 except UnicodeEncodeError:
446                     file_expr = "filename*=utf-8''{}".format(quote(filename))
447                 self['Content-Disposition'] = 'attachment; {}'.format(file_expr)
448 
449 
450 class HttpResponseRedirectBase(HttpResponse):
451     allowed_schemes = ['http', 'https', 'ftp']
452 
453     def __init__(self, redirect_to, *args, **kwargs):
454         super().__init__(*args, **kwargs)
455         self['Location'] = iri_to_uri(redirect_to)
456         parsed = urlparse(str(redirect_to))
457         if parsed.scheme and parsed.scheme not in self.allowed_schemes:
458             raise DisallowedRedirect("Unsafe redirect to URL with protocol '%s'" % parsed.scheme)
459 
460     url = property(lambda self: self['Location'])
461 
462     def __repr__(self):
463         return '<%(cls)s status_code=%(status_code)d%(content_type)s, url="%(url)s">' % {
464             'cls': self.__class__.__name__,
465             'status_code': self.status_code,
466             'content_type': self._content_type_for_repr,
467             'url': self.url,
468         }
469 
470 
471 class HttpResponseRedirect(HttpResponseRedirectBase):
472     status_code = 302
473 
474 
475 class HttpResponsePermanentRedirect(HttpResponseRedirectBase):
476     status_code = 301
477 
478 
479 class HttpResponseNotModified(HttpResponse):
480     status_code = 304
481 
482     def __init__(self, *args, **kwargs):
483         super().__init__(*args, **kwargs)
484         del self['content-type']
485 
486     @HttpResponse.content.setter
487     def content(self, value):
488         if value:
489             raise AttributeError("You cannot set content to a 304 (Not Modified) response")
490         self._container = []
491 
492 
493 class HttpResponseBadRequest(HttpResponse):
494     status_code = 400
495 
496 
497 class HttpResponseNotFound(HttpResponse):
498     status_code = 404
499 
500 
501 class HttpResponseForbidden(HttpResponse):
502     status_code = 403
503 
504 
505 class HttpResponseNotAllowed(HttpResponse):
506     status_code = 405
507 
508     def __init__(self, permitted_methods, *args, **kwargs):
509         super().__init__(*args, **kwargs)
510         self['Allow'] = ', '.join(permitted_methods)
511 
512     def __repr__(self):
513         return '<%(cls)s [%(methods)s] status_code=%(status_code)d%(content_type)s>' % {
514             'cls': self.__class__.__name__,
515             'status_code': self.status_code,
516             'content_type': self._content_type_for_repr,
517             'methods': self['Allow'],
518         }
519 
520 
521 class HttpResponseGone(HttpResponse):
522     status_code = 410
523 
524 
525 class HttpResponseServerError(HttpResponse):
526     status_code = 500
527 
528 
529 class Http404(Exception):
530     pass
531 
532 
533 class JsonResponse(HttpResponse):
534     """
535     An HTTP response class that consumes data to be serialized to JSON.
536 
537     :param data: Data to be dumped into json. By default only ``dict`` objects
538       are allowed to be passed due to a security flaw before EcmaScript 5. See
539       the ``safe`` parameter for more information.
540     :param encoder: Should be a json encoder class. Defaults to
541       ``django.core.serializers.json.DjangoJSONEncoder``.
542     :param safe: Controls if only ``dict`` objects may be serialized. Defaults
543       to ``True``.
544     :param json_dumps_params: A dictionary of kwargs passed to json.dumps().
545     """
546 
547     def __init__(self, data, encoder=DjangoJSONEncoder, safe=True,
548                  json_dumps_params=None, **kwargs):
549         if safe and not isinstance(data, dict):
550             raise TypeError(
551                 'In order to allow non-dict objects to be serialized set the '
552                 'safe parameter to False.'
553             )
554         if json_dumps_params is None:
555             json_dumps_params = {}
556         kwargs.setdefault('content_type', 'application/json')
557         data = json.dumps(data, cls=encoder, **json_dumps_params)
558         super().__init__(content=data, **kwargs)

</code><intended_behavior>Update exception handling to use OSError instead of IOError, ensuring responses continue to gracefully handle file-related errors during processing.</intended_behavior>, <file>django/http/request.py</file>
<class>None</class>
<method>None</method>
<code>
1 import copy
2 import re
3 from io import BytesIO
4 from itertools import chain
5 from urllib.parse import quote, urlencode, urljoin, urlsplit
6 
7 from django.conf import settings
8 from django.core import signing
9 from django.core.exceptions import (
10     DisallowedHost, ImproperlyConfigured, RequestDataTooBig,
11 )
12 from django.core.files import uploadhandler
13 from django.http.multipartparser import MultiPartParser, MultiPartParserError
14 from django.utils.datastructures import (
15     CaseInsensitiveMapping, ImmutableList, MultiValueDict,
16 )
17 from django.utils.encoding import escape_uri_path, iri_to_uri
18 from django.utils.functional import cached_property
19 from django.utils.http import is_same_domain, limited_parse_qsl
20 
21 RAISE_ERROR = object()
22 host_validation_re = re.compile(r"^([a-z0-9.-]+|\[[a-f0-9]*:[a-f0-9\.:]+\])(:\d+)?$")
23 
24 
25 class UnreadablePostError(IOError):
26     pass
27 
28 
29 class RawPostDataException(Exception):
30     """
31     You cannot access raw_post_data from a request that has
32     multipart/* POST data if it has been accessed via POST,
33     FILES, etc..
34     """
35     pass
36 
37 
38 class HttpRequest:
39     """A basic HTTP request."""
40 
41     # The encoding used in GET/POST dicts. None means use default setting.
42     _encoding = None
43     _upload_handlers = []
44 
45     def __init__(self):
46         # WARNING: The `WSGIRequest` subclass doesn't call `super`.
47         # Any variable assignment made here should also happen in
48         # `WSGIRequest.__init__()`.
49 
50         self.GET = QueryDict(mutable=True)
51         self.POST = QueryDict(mutable=True)
52         self.COOKIES = {}
53         self.META = {}
54         self.FILES = MultiValueDict()
55 
56         self.path = ''
57         self.path_info = ''
58         self.method = None
59         self.resolver_match = None
60         self.content_type = None
61         self.content_params = None
62 
63     def __repr__(self):
64         if self.method is None or not self.get_full_path():
65             return '<%s>' % self.__class__.__name__
66         return '<%s: %s %r>' % (self.__class__.__name__, self.method, self.get_full_path())
67 
68     @cached_property
69     def headers(self):
70         return HttpHeaders(self.META)
71 
72     def _get_raw_host(self):
73         """
74         Return the HTTP host using the environment or request headers. Skip
75         allowed hosts protection, so may return an insecure host.
76         """
77         # We try three options, in order of decreasing preference.
78         if settings.USE_X_FORWARDED_HOST and (
79                 'HTTP_X_FORWARDED_HOST' in self.META):
80             host = self.META['HTTP_X_FORWARDED_HOST']
81         elif 'HTTP_HOST' in self.META:
82             host = self.META['HTTP_HOST']
83         else:
84             # Reconstruct the host using the algorithm from PEP 333.
85             host = self.META['SERVER_NAME']
86             server_port = self.get_port()
87             if server_port != ('443' if self.is_secure() else '80'):
88                 host = '%s:%s' % (host, server_port)
89         return host
90 
91     def get_host(self):
92         """Return the HTTP host using the environment or request headers."""
93         host = self._get_raw_host()
94 
95         # Allow variants of localhost if ALLOWED_HOSTS is empty and DEBUG=True.
96         allowed_hosts = settings.ALLOWED_HOSTS
97         if settings.DEBUG and not allowed_hosts:
98             allowed_hosts = ['localhost', '127.0.0.1', '[::1]']
99 
100         domain, port = split_domain_port(host)
101         if domain and validate_host(domain, allowed_hosts):
102             return host
103         else:
104             msg = "Invalid HTTP_HOST header: %r." % host
105             if domain:
106                 msg += " You may need to add %r to ALLOWED_HOSTS." % domain
107             else:
108                 msg += " The domain name provided is not valid according to RFC 1034/1035."
109             raise DisallowedHost(msg)
110 
111     def get_port(self):
112         """Return the port number for the request as a string."""
113         if settings.USE_X_FORWARDED_PORT and 'HTTP_X_FORWARDED_PORT' in self.META:
114             port = self.META['HTTP_X_FORWARDED_PORT']
115         else:
116             port = self.META['SERVER_PORT']
117         return str(port)
118 
119     def get_full_path(self, force_append_slash=False):
120         return self._get_full_path(self.path, force_append_slash)
121 
122     def get_full_path_info(self, force_append_slash=False):
123         return self._get_full_path(self.path_info, force_append_slash)
124 
125     def _get_full_path(self, path, force_append_slash):
126         # RFC 3986 requires query string arguments to be in the ASCII range.
127         # Rather than crash if this doesn't happen, we encode defensively.
128         return '%s%s%s' % (
129             escape_uri_path(path),
130             '/' if force_append_slash and not path.endswith('/') else '',
131             ('?' + iri_to_uri(self.META.get('QUERY_STRING', ''))) if self.META.get('QUERY_STRING', '') else ''
132         )
133 
134     def get_signed_cookie(self, key, default=RAISE_ERROR, salt='', max_age=None):
135         """
136         Attempt to return a signed cookie. If the signature fails or the
137         cookie has expired, raise an exception, unless the `default` argument
138         is provided,  in which case return that value.
139         """
140         try:
141             cookie_value = self.COOKIES[key]
142         except KeyError:
143             if default is not RAISE_ERROR:
144                 return default
145             else:
146                 raise
147         try:
148             value = signing.get_cookie_signer(salt=key + salt).unsign(
149                 cookie_value, max_age=max_age)
150         except signing.BadSignature:
151             if default is not RAISE_ERROR:
152                 return default
153             else:
154                 raise
155         return value
156 
157     def get_raw_uri(self):
158         """
159         Return an absolute URI from variables available in this request. Skip
160         allowed hosts protection, so may return insecure URI.
161         """
162         return '{scheme}://{host}{path}'.format(
163             scheme=self.scheme,
164             host=self._get_raw_host(),
165             path=self.get_full_path(),
166         )
167 
168     def build_absolute_uri(self, location=None):
169         """
170         Build an absolute URI from the location and the variables available in
171         this request. If no ``location`` is specified, build the absolute URI
172         using request.get_full_path(). If the location is absolute, convert it
173         to an RFC 3987 compliant URI and return it. If location is relative or
174         is scheme-relative (i.e., ``//example.com/``), urljoin() it to a base
175         URL constructed from the request variables.
176         """
177         if location is None:
178             # Make it an absolute url (but schemeless and domainless) for the
179             # edge case that the path starts with '//'.
180             location = '//%s' % self.get_full_path()
181         bits = urlsplit(location)
182         if not (bits.scheme and bits.netloc):
183             # Handle the simple, most common case. If the location is absolute
184             # and a scheme or host (netloc) isn't provided, skip an expensive
185             # urljoin() as long as no path segments are '.' or '..'.
186             if (bits.path.startswith('/') and not bits.scheme and not bits.netloc and
187                     '/./' not in bits.path and '/../' not in bits.path):
188                 # If location starts with '//' but has no netloc, reuse the
189                 # schema and netloc from the current request. Strip the double
190                 # slashes and continue as if it wasn't specified.
191                 if location.startswith('//'):
192                     location = location[2:]
193                 location = self._current_scheme_host + location
194             else:
195                 # Join the constructed URL with the provided location, which
196                 # allows the provided location to apply query strings to the
197                 # base path.
198                 location = urljoin(self._current_scheme_host + self.path, location)
199         return iri_to_uri(location)
200 
201     @cached_property
202     def _current_scheme_host(self):
203         return '{}://{}'.format(self.scheme, self.get_host())
204 
205     def _get_scheme(self):
206         """
207         Hook for subclasses like WSGIRequest to implement. Return 'http' by
208         default.
209         """
210         return 'http'
211 
212     @property
213     def scheme(self):
214         if settings.SECURE_PROXY_SSL_HEADER:
215             try:
216                 header, value = settings.SECURE_PROXY_SSL_HEADER
217             except ValueError:
218                 raise ImproperlyConfigured(
219                     'The SECURE_PROXY_SSL_HEADER setting must be a tuple containing two values.'
220                 )
221             if self.META.get(header) == value:
222                 return 'https'
223         return self._get_scheme()
224 
225     def is_secure(self):
226         return self.scheme == 'https'
227 
228     def is_ajax(self):
229         return self.META.get('HTTP_X_REQUESTED_WITH') == 'XMLHttpRequest'
230 
231     @property
232     def encoding(self):
233         return self._encoding
234 
235     @encoding.setter
236     def encoding(self, val):
237         """
238         Set the encoding used for GET/POST accesses. If the GET or POST
239         dictionary has already been created, remove and recreate it on the
240         next access (so that it is decoded correctly).
241         """
242         self._encoding = val
243         if hasattr(self, 'GET'):
244             del self.GET
245         if hasattr(self, '_post'):
246             del self._post
247 
248     def _initialize_handlers(self):
249         self._upload_handlers = [uploadhandler.load_handler(handler, self)
250                                  for handler in settings.FILE_UPLOAD_HANDLERS]
251 
252     @property
253     def upload_handlers(self):
254         if not self._upload_handlers:
255             # If there are no upload handlers defined, initialize them from settings.
256             self._initialize_handlers()
257         return self._upload_handlers
258 
259     @upload_handlers.setter
260     def upload_handlers(self, upload_handlers):
261         if hasattr(self, '_files'):
262             raise AttributeError("You cannot set the upload handlers after the upload has been processed.")
263         self._upload_handlers = upload_handlers
264 
265     def parse_file_upload(self, META, post_data):
266         """Return a tuple of (POST QueryDict, FILES MultiValueDict)."""
267         self.upload_handlers = ImmutableList(
268             self.upload_handlers,
269             warning="You cannot alter upload handlers after the upload has been processed."
270         )
271         parser = MultiPartParser(META, post_data, self.upload_handlers, self.encoding)
272         return parser.parse()
273 
274     @property
275     def body(self):
276         if not hasattr(self, '_body'):
277             if self._read_started:
278                 raise RawPostDataException("You cannot access body after reading from request's data stream")
279 
280             # Limit the maximum request data size that will be handled in-memory.
281             if (settings.DATA_UPLOAD_MAX_MEMORY_SIZE is not None and
282                     int(self.META.get('CONTENT_LENGTH') or 0) > settings.DATA_UPLOAD_MAX_MEMORY_SIZE):
283                 raise RequestDataTooBig('Request body exceeded settings.DATA_UPLOAD_MAX_MEMORY_SIZE.')
284 
285             try:
286                 self._body = self.read()
287             except IOError as e:
288                 raise UnreadablePostError(*e.args) from e
289             self._stream = BytesIO(self._body)
290         return self._body
291 
292     def _mark_post_parse_error(self):
293         self._post = QueryDict()
294         self._files = MultiValueDict()
295 
296     def _load_post_and_files(self):
297         """Populate self._post and self._files if the content-type is a form type"""
298         if self.method != 'POST':
299             self._post, self._files = QueryDict(encoding=self._encoding), MultiValueDict()
300             return
301         if self._read_started and not hasattr(self, '_body'):
302             self._mark_post_parse_error()
303             return
304 
305         if self.content_type == 'multipart/form-data':
306             if hasattr(self, '_body'):
307                 # Use already read data
308                 data = BytesIO(self._body)
309             else:
310                 data = self
311             try:
312                 self._post, self._files = self.parse_file_upload(self.META, data)
313             except MultiPartParserError:
314                 # An error occurred while parsing POST data. Since when
315                 # formatting the error the request handler might access
316                 # self.POST, set self._post and self._file to prevent
317                 # attempts to parse POST data again.
318                 self._mark_post_parse_error()
319                 raise
320         elif self.content_type == 'application/x-www-form-urlencoded':
321             self._post, self._files = QueryDict(self.body, encoding=self._encoding), MultiValueDict()
322         else:
323             self._post, self._files = QueryDict(encoding=self._encoding), MultiValueDict()
324 
325     def close(self):
326         if hasattr(self, '_files'):
327             for f in chain.from_iterable(l[1] for l in self._files.lists()):
328                 f.close()
329 
330     # File-like and iterator interface.
331     #
332     # Expects self._stream to be set to an appropriate source of bytes by
333     # a corresponding request subclass (e.g. WSGIRequest).
334     # Also when request data has already been read by request.POST or
335     # request.body, self._stream points to a BytesIO instance
336     # containing that data.
337 
338     def read(self, *args, **kwargs):
339         self._read_started = True
340         try:
341             return self._stream.read(*args, **kwargs)
342         except IOError as e:
343             raise UnreadablePostError(*e.args) from e
344 
345     def readline(self, *args, **kwargs):
346         self._read_started = True
347         try:
348             return self._stream.readline(*args, **kwargs)
349         except IOError as e:
350             raise UnreadablePostError(*e.args) from e
351 
352     def __iter__(self):
353         return iter(self.readline, b'')
354 
355     def readlines(self):
356         return list(self)
357 
358 
359 class HttpHeaders(CaseInsensitiveMapping):
360     HTTP_PREFIX = 'HTTP_'
361     # PEP 333 gives two headers which aren't prepended with HTTP_.
362     UNPREFIXED_HEADERS = {'CONTENT_TYPE', 'CONTENT_LENGTH'}
363 
364     def __init__(self, environ):
365         headers = {}
366         for header, value in environ.items():
367             name = self.parse_header_name(header)
368             if name:
369                 headers[name] = value
370         super().__init__(headers)
371 
372     @classmethod
373     def parse_header_name(cls, header):
374         if header.startswith(cls.HTTP_PREFIX):
375             header = header[len(cls.HTTP_PREFIX):]
376         elif header not in cls.UNPREFIXED_HEADERS:
377             return None
378         return header.replace('_', '-').title()
379 
380 
381 class QueryDict(MultiValueDict):
382     """
383     A specialized MultiValueDict which represents a query string.
384 
385     A QueryDict can be used to represent GET or POST data. It subclasses
386     MultiValueDict since keys in such data can be repeated, for instance
387     in the data from a form with a <select multiple> field.
388 
389     By default QueryDicts are immutable, though the copy() method
390     will always return a mutable copy.
391 
392     Both keys and values set on this class are converted from the given encoding
393     (DEFAULT_CHARSET by default) to str.
394     """
395 
396     # These are both reset in __init__, but is specified here at the class
397     # level so that unpickling will have valid values
398     _mutable = True
399     _encoding = None
400 
401     def __init__(self, query_string=None, mutable=False, encoding=None):
402         super().__init__()
403         self.encoding = encoding or settings.DEFAULT_CHARSET
404         query_string = query_string or ''
405         parse_qsl_kwargs = {
406             'keep_blank_values': True,
407             'fields_limit': settings.DATA_UPLOAD_MAX_NUMBER_FIELDS,
408             'encoding': self.encoding,
409         }
410         if isinstance(query_string, bytes):
411             # query_string normally contains URL-encoded data, a subset of ASCII.
412             try:
413                 query_string = query_string.decode(self.encoding)
414             except UnicodeDecodeError:
415                 # ... but some user agents are misbehaving :-(
416                 query_string = query_string.decode('iso-8859-1')
417         for key, value in limited_parse_qsl(query_string, **parse_qsl_kwargs):
418             self.appendlist(key, value)
419         self._mutable = mutable
420 
421     @classmethod
422     def fromkeys(cls, iterable, value='', mutable=False, encoding=None):
423         """
424         Return a new QueryDict with keys (may be repeated) from an iterable and
425         values from value.
426         """
427         q = cls('', mutable=True, encoding=encoding)
428         for key in iterable:
429             q.appendlist(key, value)
430         if not mutable:
431             q._mutable = False
432         return q
433 
434     @property
435     def encoding(self):
436         if self._encoding is None:
437             self._encoding = settings.DEFAULT_CHARSET
438         return self._encoding
439 
440     @encoding.setter
441     def encoding(self, value):
442         self._encoding = value
443 
444     def _assert_mutable(self):
445         if not self._mutable:
446             raise AttributeError("This QueryDict instance is immutable")
447 
448     def __setitem__(self, key, value):
449         self._assert_mutable()
450         key = bytes_to_text(key, self.encoding)
451         value = bytes_to_text(value, self.encoding)
452         super().__setitem__(key, value)
453 
454     def __delitem__(self, key):
455         self._assert_mutable()
456         super().__delitem__(key)
457 
458     def __copy__(self):
459         result = self.__class__('', mutable=True, encoding=self.encoding)
460         for key, value in self.lists():
461             result.setlist(key, value)
462         return result
463 
464     def __deepcopy__(self, memo):
465         result = self.__class__('', mutable=True, encoding=self.encoding)
466         memo[id(self)] = result
467         for key, value in self.lists():
468             result.setlist(copy.deepcopy(key, memo), copy.deepcopy(value, memo))
469         return result
470 
471     def setlist(self, key, list_):
472         self._assert_mutable()
473         key = bytes_to_text(key, self.encoding)
474         list_ = [bytes_to_text(elt, self.encoding) for elt in list_]
475         super().setlist(key, list_)
476 
477     def setlistdefault(self, key, default_list=None):
478         self._assert_mutable()
479         return super().setlistdefault(key, default_list)
480 
481     def appendlist(self, key, value):
482         self._assert_mutable()
483         key = bytes_to_text(key, self.encoding)
484         value = bytes_to_text(value, self.encoding)
485         super().appendlist(key, value)
486 
487     def pop(self, key, *args):
488         self._assert_mutable()
489         return super().pop(key, *args)
490 
491     def popitem(self):
492         self._assert_mutable()
493         return super().popitem()
494 
495     def clear(self):
496         self._assert_mutable()
497         super().clear()
498 
499     def setdefault(self, key, default=None):
500         self._assert_mutable()
501         key = bytes_to_text(key, self.encoding)
502         default = bytes_to_text(default, self.encoding)
503         return super().setdefault(key, default)
504 
505     def copy(self):
506         """Return a mutable copy of this object."""
507         return self.__deepcopy__({})
508 
509     def urlencode(self, safe=None):
510         """
511         Return an encoded string of all query string arguments.
512 
513         `safe` specifies characters which don't require quoting, for example::
514 
515             >>> q = QueryDict(mutable=True)
516             >>> q['next'] = '/a&b/'
517             >>> q.urlencode()
518             'next=%2Fa%26b%2F'
519             >>> q.urlencode(safe='/')
520             'next=/a%26b/'
521         """
522         output = []
523         if safe:
524             safe = safe.encode(self.encoding)
525 
526             def encode(k, v):
527                 return '%s=%s' % ((quote(k, safe), quote(v, safe)))
528         else:
529             def encode(k, v):
530                 return urlencode({k: v})
531         for k, list_ in self.lists():
532             output.extend(
533                 encode(k.encode(self.encoding), str(v).encode(self.encoding))
534                 for v in list_
535             )
536         return '&'.join(output)
537 
538 
539 # It's neither necessary nor appropriate to use
540 # django.utils.encoding.force_text for parsing URLs and form inputs. Thus,
541 # this slightly more restricted function, used by QueryDict.
542 def bytes_to_text(s, encoding):
543     """
544     Convert bytes objects to strings, using the given encoding. Illegally
545     encoded input characters are replaced with Unicode "unknown" codepoint
546     (\ufffd).
547 
548     Return any non-bytes objects without change.
549     """
550     if isinstance(s, bytes):
551         return str(s, encoding, 'replace')
552     else:
553         return s
554 
555 
556 def split_domain_port(host):
557     """
558     Return a (domain, port) tuple from a given host.
559 
560     Returned domain is lowercased. If the host is invalid, the domain will be
561     empty.
562     """
563     host = host.lower()
564 
565     if not host_validation_re.match(host):
566         return '', ''
567 
568     if host[-1] == ']':
569         # It's an IPv6 address without a port.
570         return host, ''
571     bits = host.rsplit(':', 1)
572     domain, port = bits if len(bits) == 2 else (bits[0], '')
573     # Remove a trailing dot (if present) from the domain.
574     domain = domain[:-1] if domain.endswith('.') else domain
575     return domain, port
576 
577 
578 def validate_host(host, allowed_hosts):
579     """
580     Validate the given host for this site.
581 
582     Check that the host looks valid and matches a host or host pattern in the
583     given list of ``allowed_hosts``. Any pattern beginning with a period
584     matches a domain and all its subdomains (e.g. ``.example.com`` matches
585     ``example.com`` and any subdomain), ``*`` matches anything, and anything
586     else must match exactly.
587 
588     Note: This function assumes that the given host is lowercased and has
589     already had the port, if any, stripped off.
590 
591     Return ``True`` for a valid host, ``False`` otherwise.
592     """
593     return any(pattern == '*' or is_same_domain(host, pattern) for pattern in allowed_hosts)

</code><intended_behavior>Swap IOError for OSError in file upload and reading operations, maintaining robustness in request handling.</intended_behavior>, <file>django/utils/translation/trans_real.py</file>
<class>None</class>
<method>None</method>
<code>
1 """Translation helper functions."""
2 import functools
3 import gettext as gettext_module
4 import os
5 import re
6 import sys
7 import warnings
8 from collections import OrderedDict
9 from threading import local
10 
11 from django.apps import apps
12 from django.conf import settings
13 from django.conf.locale import LANG_INFO
14 from django.core.exceptions import AppRegistryNotReady
15 from django.core.signals import setting_changed
16 from django.dispatch import receiver
17 from django.utils.safestring import SafeData, mark_safe
18 
19 from . import LANGUAGE_SESSION_KEY, to_language, to_locale
20 
21 # Translations are cached in a dictionary for every language.
22 # The active translations are stored by threadid to make them thread local.
23 _translations = {}
24 _active = local()
25 
26 # The default translation is based on the settings file.
27 _default = None
28 
29 # magic gettext number to separate context from message
30 CONTEXT_SEPARATOR = "\x04"
31 
32 # Format of Accept-Language header values. From RFC 2616, section 14.4 and 3.9
33 # and RFC 3066, section 2.1
34 accept_language_re = re.compile(r'''
35         ([A-Za-z]{1,8}(?:-[A-Za-z0-9]{1,8})*|\*)      # "en", "en-au", "x-y-z", "es-419", "*"
36         (?:\s*;\s*q=(0(?:\.\d{,3})?|1(?:\.0{,3})?))?  # Optional "q=1.00", "q=0.8"
37         (?:\s*,\s*|$)                                 # Multiple accepts per header.
38         ''', re.VERBOSE)
39 
40 language_code_re = re.compile(
41     r'^[a-z]{1,8}(?:-[a-z0-9]{1,8})*(?:@[a-z0-9]{1,20})?$',
42     re.IGNORECASE
43 )
44 
45 language_code_prefix_re = re.compile(r'^/(\w+([@-]\w+)?)(/|$)')
46 
47 
48 @receiver(setting_changed)
49 def reset_cache(**kwargs):
50     """
51     Reset global state when LANGUAGES setting has been changed, as some
52     languages should no longer be accepted.
53     """
54     if kwargs['setting'] in ('LANGUAGES', 'LANGUAGE_CODE'):
55         check_for_language.cache_clear()
56         get_languages.cache_clear()
57         get_supported_language_variant.cache_clear()
58 
59 
60 class DjangoTranslation(gettext_module.GNUTranslations):
61     """
62     Set up the GNUTranslations context with regard to output charset.
63 
64     This translation object will be constructed out of multiple GNUTranslations
65     objects by merging their catalogs. It will construct an object for the
66     requested language and add a fallback to the default language, if it's
67     different from the requested language.
68     """
69     domain = 'django'
70 
71     def __init__(self, language, domain=None, localedirs=None):
72         """Create a GNUTranslations() using many locale directories"""
73         gettext_module.GNUTranslations.__init__(self)
74         if domain is not None:
75             self.domain = domain
76 
77         self.__language = language
78         self.__to_language = to_language(language)
79         self.__locale = to_locale(language)
80         self._catalog = None
81         # If a language doesn't have a catalog, use the Germanic default for
82         # pluralization: anything except one is pluralized.
83         self.plural = lambda n: int(n != 1)
84 
85         if self.domain == 'django':
86             if localedirs is not None:
87                 # A module-level cache is used for caching 'django' translations
88                 warnings.warn("localedirs is ignored when domain is 'django'.", RuntimeWarning)
89                 localedirs = None
90             self._init_translation_catalog()
91 
92         if localedirs:
93             for localedir in localedirs:
94                 translation = self._new_gnu_trans(localedir)
95                 self.merge(translation)
96         else:
97             self._add_installed_apps_translations()
98 
99         self._add_local_translations()
100         if self.__language == settings.LANGUAGE_CODE and self.domain == 'django' and self._catalog is None:
101             # default lang should have at least one translation file available.
102             raise IOError("No translation files found for default language %s." % settings.LANGUAGE_CODE)
103         self._add_fallback(localedirs)
104         if self._catalog is None:
105             # No catalogs found for this language, set an empty catalog.
106             self._catalog = {}
107 
108     def __repr__(self):
109         return "<DjangoTranslation lang:%s>" % self.__language
110 
111     def _new_gnu_trans(self, localedir, use_null_fallback=True):
112         """
113         Return a mergeable gettext.GNUTranslations instance.
114 
115         A convenience wrapper. By default gettext uses 'fallback=False'.
116         Using param `use_null_fallback` to avoid confusion with any other
117         references to 'fallback'.
118         """
119         return gettext_module.translation(
120             domain=self.domain,
121             localedir=localedir,
122             languages=[self.__locale],
123             fallback=use_null_fallback,
124         )
125 
126     def _init_translation_catalog(self):
127         """Create a base catalog using global django translations."""
128         settingsfile = sys.modules[settings.__module__].__file__
129         localedir = os.path.join(os.path.dirname(settingsfile), 'locale')
130         translation = self._new_gnu_trans(localedir)
131         self.merge(translation)
132 
133     def _add_installed_apps_translations(self):
134         """Merge translations from each installed app."""
135         try:
136             app_configs = reversed(list(apps.get_app_configs()))
137         except AppRegistryNotReady:
138             raise AppRegistryNotReady(
139                 "The translation infrastructure cannot be initialized before the "
140                 "apps registry is ready. Check that you don't make non-lazy "
141                 "gettext calls at import time.")
142         for app_config in app_configs:
143             localedir = os.path.join(app_config.path, 'locale')
144             if os.path.exists(localedir):
145                 translation = self._new_gnu_trans(localedir)
146                 self.merge(translation)
147 
148     def _add_local_translations(self):
149         """Merge translations defined in LOCALE_PATHS."""
150         for localedir in reversed(settings.LOCALE_PATHS):
151             translation = self._new_gnu_trans(localedir)
152             self.merge(translation)
153 
154     def _add_fallback(self, localedirs=None):
155         """Set the GNUTranslations() fallback with the default language."""
156         # Don't set a fallback for the default language or any English variant
157         # (as it's empty, so it'll ALWAYS fall back to the default language)
158         if self.__language == settings.LANGUAGE_CODE or self.__language.startswith('en'):
159             return
160         if self.domain == 'django':
161             # Get from cache
162             default_translation = translation(settings.LANGUAGE_CODE)
163         else:
164             default_translation = DjangoTranslation(
165                 settings.LANGUAGE_CODE, domain=self.domain, localedirs=localedirs
166             )
167         self.add_fallback(default_translation)
168 
169     def merge(self, other):
170         """Merge another translation into this catalog."""
171         if not getattr(other, '_catalog', None):
172             return  # NullTranslations() has no _catalog
173         if self._catalog is None:
174             # Take plural and _info from first catalog found (generally Django's).
175             self.plural = other.plural
176             self._info = other._info.copy()
177             self._catalog = other._catalog.copy()
178         else:
179             self._catalog.update(other._catalog)
180         if other._fallback:
181             self.add_fallback(other._fallback)
182 
183     def language(self):
184         """Return the translation language."""
185         return self.__language
186 
187     def to_language(self):
188         """Return the translation language name."""
189         return self.__to_language
190 
191 
192 def translation(language):
193     """
194     Return a translation object in the default 'django' domain.
195     """
196     global _translations
197     if language not in _translations:
198         _translations[language] = DjangoTranslation(language)
199     return _translations[language]
200 
201 
202 def activate(language):
203     """
204     Fetch the translation object for a given language and install it as the
205     current translation object for the current thread.
206     """
207     if not language:
208         return
209     _active.value = translation(language)
210 
211 
212 def deactivate():
213     """
214     Uninstall the active translation object so that further _() calls resolve
215     to the default translation object.
216     """
217     if hasattr(_active, "value"):
218         del _active.value
219 
220 
221 def deactivate_all():
222     """
223     Make the active translation object a NullTranslations() instance. This is
224     useful when we want delayed translations to appear as the original string
225     for some reason.
226     """
227     _active.value = gettext_module.NullTranslations()
228     _active.value.to_language = lambda *args: None
229 
230 
231 def get_language():
232     """Return the currently selected language."""
233     t = getattr(_active, "value", None)
234     if t is not None:
235         try:
236             return t.to_language()
237         except AttributeError:
238             pass
239     # If we don't have a real translation object, assume it's the default language.
240     return settings.LANGUAGE_CODE
241 
242 
243 def get_language_bidi():
244     """
245     Return selected language's BiDi layout.
246 
247     * False = left-to-right layout
248     * True = right-to-left layout
249     """
250     lang = get_language()
251     if lang is None:
252         return False
253     else:
254         base_lang = get_language().split('-')[0]
255         return base_lang in settings.LANGUAGES_BIDI
256 
257 
258 def catalog():
259     """
260     Return the current active catalog for further processing.
261     This can be used if you need to modify the catalog or want to access the
262     whole message catalog instead of just translating one string.
263     """
264     global _default
265 
266     t = getattr(_active, "value", None)
267     if t is not None:
268         return t
269     if _default is None:
270         _default = translation(settings.LANGUAGE_CODE)
271     return _default
272 
273 
274 def gettext(message):
275     """
276     Translate the 'message' string. It uses the current thread to find the
277     translation object to use. If no current translation is activated, the
278     message will be run through the default translation object.
279     """
280     global _default
281 
282     eol_message = message.replace('\r\n', '\n').replace('\r', '\n')
283 
284     if eol_message:
285         _default = _default or translation(settings.LANGUAGE_CODE)
286         translation_object = getattr(_active, "value", _default)
287 
288         result = translation_object.gettext(eol_message)
289     else:
290         # Return an empty value of the corresponding type if an empty message
291         # is given, instead of metadata, which is the default gettext behavior.
292         result = type(message)('')
293 
294     if isinstance(message, SafeData):
295         return mark_safe(result)
296 
297     return result
298 
299 
300 def pgettext(context, message):
301     msg_with_ctxt = "%s%s%s" % (context, CONTEXT_SEPARATOR, message)
302     result = gettext(msg_with_ctxt)
303     if CONTEXT_SEPARATOR in result:
304         # Translation not found
305         result = message
306     elif isinstance(message, SafeData):
307         result = mark_safe(result)
308     return result
309 
310 
311 def gettext_noop(message):
312     """
313     Mark strings for translation but don't translate them now. This can be
314     used to store strings in global variables that should stay in the base
315     language (because they might be used externally) and will be translated
316     later.
317     """
318     return message
319 
320 
321 def do_ntranslate(singular, plural, number, translation_function):
322     global _default
323 
324     t = getattr(_active, "value", None)
325     if t is not None:
326         return getattr(t, translation_function)(singular, plural, number)
327     if _default is None:
328         _default = translation(settings.LANGUAGE_CODE)
329     return getattr(_default, translation_function)(singular, plural, number)
330 
331 
332 def ngettext(singular, plural, number):
333     """
334     Return a string of the translation of either the singular or plural,
335     based on the number.
336     """
337     return do_ntranslate(singular, plural, number, 'ngettext')
338 
339 
340 def npgettext(context, singular, plural, number):
341     msgs_with_ctxt = ("%s%s%s" % (context, CONTEXT_SEPARATOR, singular),
342                       "%s%s%s" % (context, CONTEXT_SEPARATOR, plural),
343                       number)
344     result = ngettext(*msgs_with_ctxt)
345     if CONTEXT_SEPARATOR in result:
346         # Translation not found
347         result = ngettext(singular, plural, number)
348     return result
349 
350 
351 def all_locale_paths():
352     """
353     Return a list of paths to user-provides languages files.
354     """
355     globalpath = os.path.join(
356         os.path.dirname(sys.modules[settings.__module__].__file__), 'locale')
357     app_paths = []
358     for app_config in apps.get_app_configs():
359         locale_path = os.path.join(app_config.path, 'locale')
360         if os.path.exists(locale_path):
361             app_paths.append(locale_path)
362     return [globalpath, *settings.LOCALE_PATHS, *app_paths]
363 
364 
365 @functools.lru_cache(maxsize=1000)
366 def check_for_language(lang_code):
367     """
368     Check whether there is a global language file for the given language
369     code. This is used to decide whether a user-provided language is
370     available.
371 
372     lru_cache should have a maxsize to prevent from memory exhaustion attacks,
373     as the provided language codes are taken from the HTTP request. See also
374     <https://www.djangoproject.com/weblog/2007/oct/26/security-fix/>.
375     """
376     # First, a quick check to make sure lang_code is well-formed (#21458)
377     if lang_code is None or not language_code_re.search(lang_code):
378         return False
379     return any(
380         gettext_module.find('django', path, [to_locale(lang_code)]) is not None
381         for path in all_locale_paths()
382     )
383 
384 
385 @functools.lru_cache()
386 def get_languages():
387     """
388     Cache of settings.LANGUAGES in an OrderedDict for easy lookups by key.
389     """
390     return OrderedDict(settings.LANGUAGES)
391 
392 
393 @functools.lru_cache(maxsize=1000)
394 def get_supported_language_variant(lang_code, strict=False):
395     """
396     Return the language code that's listed in supported languages, possibly
397     selecting a more generic variant. Raise LookupError if nothing is found.
398 
399     If `strict` is False (the default), look for a country-specific variant
400     when neither the language code nor its generic variant is found.
401 
402     lru_cache should have a maxsize to prevent from memory exhaustion attacks,
403     as the provided language codes are taken from the HTTP request. See also
404     <https://www.djangoproject.com/weblog/2007/oct/26/security-fix/>.
405     """
406     if lang_code:
407         # If 'fr-ca' is not supported, try special fallback or language-only 'fr'.
408         possible_lang_codes = [lang_code]
409         try:
410             possible_lang_codes.extend(LANG_INFO[lang_code]['fallback'])
411         except KeyError:
412             pass
413         generic_lang_code = lang_code.split('-')[0]
414         possible_lang_codes.append(generic_lang_code)
415         supported_lang_codes = get_languages()
416 
417         for code in possible_lang_codes:
418             if code in supported_lang_codes and check_for_language(code):
419                 return code
420         if not strict:
421             # if fr-fr is not supported, try fr-ca.
422             for supported_code in supported_lang_codes:
423                 if supported_code.startswith(generic_lang_code + '-'):
424                     return supported_code
425     raise LookupError(lang_code)
426 
427 
428 def get_language_from_path(path, strict=False):
429     """
430     Return the language code if there's a valid language code found in `path`.
431 
432     If `strict` is False (the default), look for a country-specific variant
433     when neither the language code nor its generic variant is found.
434     """
435     regex_match = language_code_prefix_re.match(path)
436     if not regex_match:
437         return None
438     lang_code = regex_match.group(1)
439     try:
440         return get_supported_language_variant(lang_code, strict=strict)
441     except LookupError:
442         return None
443 
444 
445 def get_language_from_request(request, check_path=False):
446     """
447     Analyze the request to find what language the user wants the system to
448     show. Only languages listed in settings.LANGUAGES are taken into account.
449     If the user requests a sublanguage where we have a main language, we send
450     out the main language.
451 
452     If check_path is True, the URL path prefix will be checked for a language
453     code, otherwise this is skipped for backwards compatibility.
454     """
455     if check_path:
456         lang_code = get_language_from_path(request.path_info)
457         if lang_code is not None:
458             return lang_code
459 
460     supported_lang_codes = get_languages()
461 
462     if hasattr(request, 'session'):
463         lang_code = request.session.get(LANGUAGE_SESSION_KEY)
464         if lang_code in supported_lang_codes and lang_code is not None and check_for_language(lang_code):
465             return lang_code
466 
467     lang_code = request.COOKIES.get(settings.LANGUAGE_COOKIE_NAME)
468 
469     try:
470         return get_supported_language_variant(lang_code)
471     except LookupError:
472         pass
473 
474     accept = request.META.get('HTTP_ACCEPT_LANGUAGE', '')
475     for accept_lang, unused in parse_accept_lang_header(accept):
476         if accept_lang == '*':
477             break
478 
479         if not language_code_re.search(accept_lang):
480             continue
481 
482         try:
483             return get_supported_language_variant(accept_lang)
484         except LookupError:
485             continue
486 
487     try:
488         return get_supported_language_variant(settings.LANGUAGE_CODE)
489     except LookupError:
490         return settings.LANGUAGE_CODE
491 
492 
493 @functools.lru_cache(maxsize=1000)
494 def parse_accept_lang_header(lang_string):
495     """
496     Parse the lang_string, which is the body of an HTTP Accept-Language
497     header, and return a tuple of (lang, q-value), ordered by 'q' values.
498 
499     Return an empty tuple if there are any format errors in lang_string.
500     """
501     result = []
502     pieces = accept_language_re.split(lang_string.lower())
503     if pieces[-1]:
504         return ()
505     for i in range(0, len(pieces) - 1, 3):
506         first, lang, priority = pieces[i:i + 3]
507         if first:
508             return ()
509         if priority:
510             priority = float(priority)
511         else:
512             priority = 1.0
513         result.append((lang, priority))
514     result.sort(key=lambda k: k[1], reverse=True)
515     return tuple(result)

</code><intended_behavior>Use OSError to handle file-related translation loading issues, keeping functionality to catch and manage translation file errors.</intended_behavior>, <file>django/views/debug.py</file>
<class>None</class>
<method>None</method>
<code>
1 import functools
2 import re
3 import sys
4 import types
5 from pathlib import Path
6 
7 from django.conf import settings
8 from django.http import HttpResponse, HttpResponseNotFound
9 from django.template import Context, Engine, TemplateDoesNotExist
10 from django.template.defaultfilters import pprint
11 from django.urls import Resolver404, resolve
12 from django.utils import timezone
13 from django.utils.datastructures import MultiValueDict
14 from django.utils.encoding import force_text
15 from django.utils.module_loading import import_string
16 from django.utils.version import get_docs_version
17 
18 # Minimal Django templates engine to render the error templates
19 # regardless of the project's TEMPLATES setting. Templates are
20 # read directly from the filesystem so that the error handler
21 # works even if the template loader is broken.
22 DEBUG_ENGINE = Engine(
23     debug=True,
24     libraries={'i18n': 'django.templatetags.i18n'},
25 )
26 
27 HIDDEN_SETTINGS = re.compile('API|TOKEN|KEY|SECRET|PASS|SIGNATURE', flags=re.IGNORECASE)
28 
29 CLEANSED_SUBSTITUTE = '********************'
30 
31 CURRENT_DIR = Path(__file__).parent
32 
33 
34 class CallableSettingWrapper:
35     """
36     Object to wrap callable appearing in settings.
37     * Not to call in the debug page (#21345).
38     * Not to break the debug page if the callable forbidding to set attributes
39       (#23070).
40     """
41     def __init__(self, callable_setting):
42         self._wrapped = callable_setting
43 
44     def __repr__(self):
45         return repr(self._wrapped)
46 
47 
48 def cleanse_setting(key, value):
49     """
50     Cleanse an individual setting key/value of sensitive content. If the value
51     is a dictionary, recursively cleanse the keys in that dictionary.
52     """
53     try:
54         if HIDDEN_SETTINGS.search(key):
55             cleansed = CLEANSED_SUBSTITUTE
56         else:
57             if isinstance(value, dict):
58                 cleansed = {k: cleanse_setting(k, v) for k, v in value.items()}
59             else:
60                 cleansed = value
61     except TypeError:
62         # If the key isn't regex-able, just return as-is.
63         cleansed = value
64 
65     if callable(cleansed):
66         # For fixing #21345 and #23070
67         cleansed = CallableSettingWrapper(cleansed)
68 
69     return cleansed
70 
71 
72 def get_safe_settings():
73     """
74     Return a dictionary of the settings module with values of sensitive
75     settings replaced with stars (*********).
76     """
77     settings_dict = {}
78     for k in dir(settings):
79         if k.isupper():
80             settings_dict[k] = cleanse_setting(k, getattr(settings, k))
81     return settings_dict
82 
83 
84 def technical_500_response(request, exc_type, exc_value, tb, status_code=500):
85     """
86     Create a technical server error response. The last three arguments are
87     the values returned from sys.exc_info() and friends.
88     """
89     reporter = ExceptionReporter(request, exc_type, exc_value, tb)
90     if request.is_ajax():
91         text = reporter.get_traceback_text()
92         return HttpResponse(text, status=status_code, content_type='text/plain; charset=utf-8')
93     else:
94         html = reporter.get_traceback_html()
95         return HttpResponse(html, status=status_code, content_type='text/html')
96 
97 
98 @functools.lru_cache()
99 def get_default_exception_reporter_filter():
100     # Instantiate the default filter for the first time and cache it.
101     return import_string(settings.DEFAULT_EXCEPTION_REPORTER_FILTER)()
102 
103 
104 def get_exception_reporter_filter(request):
105     default_filter = get_default_exception_reporter_filter()
106     return getattr(request, 'exception_reporter_filter', default_filter)
107 
108 
109 class ExceptionReporterFilter:
110     """
111     Base for all exception reporter filter classes. All overridable hooks
112     contain lenient default behaviors.
113     """
114 
115     def get_post_parameters(self, request):
116         if request is None:
117             return {}
118         else:
119             return request.POST
120 
121     def get_traceback_frame_variables(self, request, tb_frame):
122         return list(tb_frame.f_locals.items())
123 
124 
125 class SafeExceptionReporterFilter(ExceptionReporterFilter):
126     """
127     Use annotations made by the sensitive_post_parameters and
128     sensitive_variables decorators to filter out sensitive information.
129     """
130 
131     def is_active(self, request):
132         """
133         This filter is to add safety in production environments (i.e. DEBUG
134         is False). If DEBUG is True then your site is not safe anyway.
135         This hook is provided as a convenience to easily activate or
136         deactivate the filter on a per request basis.
137         """
138         return settings.DEBUG is False
139 
140     def get_cleansed_multivaluedict(self, request, multivaluedict):
141         """
142         Replace the keys in a MultiValueDict marked as sensitive with stars.
143         This mitigates leaking sensitive POST parameters if something like
144         request.POST['nonexistent_key'] throws an exception (#21098).
145         """
146         sensitive_post_parameters = getattr(request, 'sensitive_post_parameters', [])
147         if self.is_active(request) and sensitive_post_parameters:
148             multivaluedict = multivaluedict.copy()
149             for param in sensitive_post_parameters:
150                 if param in multivaluedict:
151                     multivaluedict[param] = CLEANSED_SUBSTITUTE
152         return multivaluedict
153 
154     def get_post_parameters(self, request):
155         """
156         Replace the values of POST parameters marked as sensitive with
157         stars (*********).
158         """
159         if request is None:
160             return {}
161         else:
162             sensitive_post_parameters = getattr(request, 'sensitive_post_parameters', [])
163             if self.is_active(request) and sensitive_post_parameters:
164                 cleansed = request.POST.copy()
165                 if sensitive_post_parameters == '__ALL__':
166                     # Cleanse all parameters.
167                     for k in cleansed:
168                         cleansed[k] = CLEANSED_SUBSTITUTE
169                     return cleansed
170                 else:
171                     # Cleanse only the specified parameters.
172                     for param in sensitive_post_parameters:
173                         if param in cleansed:
174                             cleansed[param] = CLEANSED_SUBSTITUTE
175                     return cleansed
176             else:
177                 return request.POST
178 
179     def cleanse_special_types(self, request, value):
180         try:
181             # If value is lazy or a complex object of another kind, this check
182             # might raise an exception. isinstance checks that lazy
183             # MultiValueDicts will have a return value.
184             is_multivalue_dict = isinstance(value, MultiValueDict)
185         except Exception as e:
186             return '{!r} while evaluating {!r}'.format(e, value)
187 
188         if is_multivalue_dict:
189             # Cleanse MultiValueDicts (request.POST is the one we usually care about)
190             value = self.get_cleansed_multivaluedict(request, value)
191         return value
192 
193     def get_traceback_frame_variables(self, request, tb_frame):
194         """
195         Replace the values of variables marked as sensitive with
196         stars (*********).
197         """
198         # Loop through the frame's callers to see if the sensitive_variables
199         # decorator was used.
200         current_frame = tb_frame.f_back
201         sensitive_variables = None
202         while current_frame is not None:
203             if (current_frame.f_code.co_name == 'sensitive_variables_wrapper' and
204                     'sensitive_variables_wrapper' in current_frame.f_locals):
205                 # The sensitive_variables decorator was used, so we take note
206                 # of the sensitive variables' names.
207                 wrapper = current_frame.f_locals['sensitive_variables_wrapper']
208                 sensitive_variables = getattr(wrapper, 'sensitive_variables', None)
209                 break
210             current_frame = current_frame.f_back
211 
212         cleansed = {}
213         if self.is_active(request) and sensitive_variables:
214             if sensitive_variables == '__ALL__':
215                 # Cleanse all variables
216                 for name in tb_frame.f_locals:
217                     cleansed[name] = CLEANSED_SUBSTITUTE
218             else:
219                 # Cleanse specified variables
220                 for name, value in tb_frame.f_locals.items():
221                     if name in sensitive_variables:
222                         value = CLEANSED_SUBSTITUTE
223                     else:
224                         value = self.cleanse_special_types(request, value)
225                     cleansed[name] = value
226         else:
227             # Potentially cleanse the request and any MultiValueDicts if they
228             # are one of the frame variables.
229             for name, value in tb_frame.f_locals.items():
230                 cleansed[name] = self.cleanse_special_types(request, value)
231 
232         if (tb_frame.f_code.co_name == 'sensitive_variables_wrapper' and
233                 'sensitive_variables_wrapper' in tb_frame.f_locals):
234             # For good measure, obfuscate the decorated function's arguments in
235             # the sensitive_variables decorator's frame, in case the variables
236             # associated with those arguments were meant to be obfuscated from
237             # the decorated function's frame.
238             cleansed['func_args'] = CLEANSED_SUBSTITUTE
239             cleansed['func_kwargs'] = CLEANSED_SUBSTITUTE
240 
241         return cleansed.items()
242 
243 
244 class ExceptionReporter:
245     """Organize and coordinate reporting on exceptions."""
246     def __init__(self, request, exc_type, exc_value, tb, is_email=False):
247         self.request = request
248         self.filter = get_exception_reporter_filter(self.request)
249         self.exc_type = exc_type
250         self.exc_value = exc_value
251         self.tb = tb
252         self.is_email = is_email
253 
254         self.template_info = getattr(self.exc_value, 'template_debug', None)
255         self.template_does_not_exist = False
256         self.postmortem = None
257 
258     def get_traceback_data(self):
259         """Return a dictionary containing traceback information."""
260         if self.exc_type and issubclass(self.exc_type, TemplateDoesNotExist):
261             self.template_does_not_exist = True
262             self.postmortem = self.exc_value.chain or [self.exc_value]
263 
264         frames = self.get_traceback_frames()
265         for i, frame in enumerate(frames):
266             if 'vars' in frame:
267                 frame_vars = []
268                 for k, v in frame['vars']:
269                     v = pprint(v)
270                     # Trim large blobs of data
271                     if len(v) > 4096:
272                         v = '%s… <trimmed %d bytes string>' % (v[0:4096], len(v))
273                     frame_vars.append((k, v))
274                 frame['vars'] = frame_vars
275             frames[i] = frame
276 
277         unicode_hint = ''
278         if self.exc_type and issubclass(self.exc_type, UnicodeError):
279             start = getattr(self.exc_value, 'start', None)
280             end = getattr(self.exc_value, 'end', None)
281             if start is not None and end is not None:
282                 unicode_str = self.exc_value.args[1]
283                 unicode_hint = force_text(
284                     unicode_str[max(start - 5, 0):min(end + 5, len(unicode_str))],
285                     'ascii', errors='replace'
286                 )
287         from django import get_version
288 
289         if self.request is None:
290             user_str = None
291         else:
292             try:
293                 user_str = str(self.request.user)
294             except Exception:
295                 # request.user may raise OperationalError if the database is
296                 # unavailable, for example.
297                 user_str = '[unable to retrieve the current user]'
298 
299         c = {
300             'is_email': self.is_email,
301             'unicode_hint': unicode_hint,
302             'frames': frames,
303             'request': self.request,
304             'user_str': user_str,
305             'filtered_POST_items': list(self.filter.get_post_parameters(self.request).items()),
306             'settings': get_safe_settings(),
307             'sys_executable': sys.executable,
308             'sys_version_info': '%d.%d.%d' % sys.version_info[0:3],
309             'server_time': timezone.now(),
310             'django_version_info': get_version(),
311             'sys_path': sys.path,
312             'template_info': self.template_info,
313             'template_does_not_exist': self.template_does_not_exist,
314             'postmortem': self.postmortem,
315         }
316         if self.request is not None:
317             c['request_GET_items'] = self.request.GET.items()
318             c['request_FILES_items'] = self.request.FILES.items()
319             c['request_COOKIES_items'] = self.request.COOKIES.items()
320         # Check whether exception info is available
321         if self.exc_type:
322             c['exception_type'] = self.exc_type.__name__
323         if self.exc_value:
324             c['exception_value'] = str(self.exc_value)
325         if frames:
326             c['lastframe'] = frames[-1]
327         return c
328 
329     def get_traceback_html(self):
330         """Return HTML version of debug 500 HTTP error page."""
331         with Path(CURRENT_DIR, 'templates', 'technical_500.html').open() as fh:
332             t = DEBUG_ENGINE.from_string(fh.read())
333         c = Context(self.get_traceback_data(), use_l10n=False)
334         return t.render(c)
335 
336     def get_traceback_text(self):
337         """Return plain text version of debug 500 HTTP error page."""
338         with Path(CURRENT_DIR, 'templates', 'technical_500.txt').open() as fh:
339             t = DEBUG_ENGINE.from_string(fh.read())
340         c = Context(self.get_traceback_data(), autoescape=False, use_l10n=False)
341         return t.render(c)
342 
343     def _get_lines_from_file(self, filename, lineno, context_lines, loader=None, module_name=None):
344         """
345         Return context_lines before and after lineno from file.
346         Return (pre_context_lineno, pre_context, context_line, post_context).
347         """
348         source = None
349         if hasattr(loader, 'get_source'):
350             try:
351                 source = loader.get_source(module_name)
352             except ImportError:
353                 pass
354             if source is not None:
355                 source = source.splitlines()
356         if source is None:
357             try:
358                 with open(filename, 'rb') as fp:
359                     source = fp.read().splitlines()
360             except (OSError, IOError):
361                 pass
362         if source is None:
363             return None, [], None, []
364 
365         # If we just read the source from a file, or if the loader did not
366         # apply tokenize.detect_encoding to decode the source into a
367         # string, then we should do that ourselves.
368         if isinstance(source[0], bytes):
369             encoding = 'ascii'
370             for line in source[:2]:
371                 # File coding may be specified. Match pattern from PEP-263
372                 # (https://www.python.org/dev/peps/pep-0263/)
373                 match = re.search(br'coding[:=]\s*([-\w.]+)', line)
374                 if match:
375                     encoding = match.group(1).decode('ascii')
376                     break
377             source = [str(sline, encoding, 'replace') for sline in source]
378 
379         lower_bound = max(0, lineno - context_lines)
380         upper_bound = lineno + context_lines
381 
382         pre_context = source[lower_bound:lineno]
383         context_line = source[lineno]
384         post_context = source[lineno + 1:upper_bound]
385 
386         return lower_bound, pre_context, context_line, post_context
387 
388     def get_traceback_frames(self):
389         def explicit_or_implicit_cause(exc_value):
390             explicit = getattr(exc_value, '__cause__', None)
391             implicit = getattr(exc_value, '__context__', None)
392             return explicit or implicit
393 
394         # Get the exception and all its causes
395         exceptions = []
396         exc_value = self.exc_value
397         while exc_value:
398             exceptions.append(exc_value)
399             exc_value = explicit_or_implicit_cause(exc_value)
400 
401         frames = []
402         # No exceptions were supplied to ExceptionReporter
403         if not exceptions:
404             return frames
405 
406         # In case there's just one exception, take the traceback from self.tb
407         exc_value = exceptions.pop()
408         tb = self.tb if not exceptions else exc_value.__traceback__
409 
410         while tb is not None:
411             # Support for __traceback_hide__ which is used by a few libraries
412             # to hide internal frames.
413             if tb.tb_frame.f_locals.get('__traceback_hide__'):
414                 tb = tb.tb_next
415                 continue
416             filename = tb.tb_frame.f_code.co_filename
417             function = tb.tb_frame.f_code.co_name
418             lineno = tb.tb_lineno - 1
419             loader = tb.tb_frame.f_globals.get('__loader__')
420             module_name = tb.tb_frame.f_globals.get('__name__') or ''
421             pre_context_lineno, pre_context, context_line, post_context = self._get_lines_from_file(
422                 filename, lineno, 7, loader, module_name,
423             )
424             if pre_context_lineno is None:
425                 pre_context_lineno = lineno
426                 pre_context = []
427                 context_line = '<source code not available>'
428                 post_context = []
429             frames.append({
430                 'exc_cause': explicit_or_implicit_cause(exc_value),
431                 'exc_cause_explicit': getattr(exc_value, '__cause__', True),
432                 'tb': tb,
433                 'type': 'django' if module_name.startswith('django.') else 'user',
434                 'filename': filename,
435                 'function': function,
436                 'lineno': lineno + 1,
437                 'vars': self.filter.get_traceback_frame_variables(self.request, tb.tb_frame),
438                 'id': id(tb),
439                 'pre_context': pre_context,
440                 'context_line': context_line,
441                 'post_context': post_context,
442                 'pre_context_lineno': pre_context_lineno + 1,
443             })
444 
445             # If the traceback for current exception is consumed, try the
446             # other exception.
447             if not tb.tb_next and exceptions:
448                 exc_value = exceptions.pop()
449                 tb = exc_value.__traceback__
450             else:
451                 tb = tb.tb_next
452 
453         return frames
454 
455 
456 def technical_404_response(request, exception):
457     """Create a technical 404 error response. `exception` is the Http404."""
458     try:
459         error_url = exception.args[0]['path']
460     except (IndexError, TypeError, KeyError):
461         error_url = request.path_info[1:]  # Trim leading slash
462 
463     try:
464         tried = exception.args[0]['tried']
465     except (IndexError, TypeError, KeyError):
466         tried = []
467     else:
468         if (not tried or (                  # empty URLconf
469             request.path == '/' and
470             len(tried) == 1 and             # default URLconf
471             len(tried[0]) == 1 and
472             getattr(tried[0][0], 'app_name', '') == getattr(tried[0][0], 'namespace', '') == 'admin'
473         )):
474             return default_urlconf(request)
475 
476     urlconf = getattr(request, 'urlconf', settings.ROOT_URLCONF)
477     if isinstance(urlconf, types.ModuleType):
478         urlconf = urlconf.__name__
479 
480     caller = ''
481     try:
482         resolver_match = resolve(request.path)
483     except Resolver404:
484         pass
485     else:
486         obj = resolver_match.func
487 
488         if hasattr(obj, '__name__'):
489             caller = obj.__name__
490         elif hasattr(obj, '__class__') and hasattr(obj.__class__, '__name__'):
491             caller = obj.__class__.__name__
492 
493         if hasattr(obj, '__module__'):
494             module = obj.__module__
495             caller = '%s.%s' % (module, caller)
496 
497     with Path(CURRENT_DIR, 'templates', 'technical_404.html').open() as fh:
498         t = DEBUG_ENGINE.from_string(fh.read())
499     c = Context({
500         'urlconf': urlconf,
501         'root_urlconf': settings.ROOT_URLCONF,
502         'request_path': error_url,
503         'urlpatterns': tried,
504         'reason': str(exception),
505         'request': request,
506         'settings': get_safe_settings(),
507         'raising_view_name': caller,
508     })
509     return HttpResponseNotFound(t.render(c), content_type='text/html')
510 
511 
512 def default_urlconf(request):
513     """Create an empty URLconf 404 error response."""
514     with Path(CURRENT_DIR, 'templates', 'default_urlconf.html').open() as fh:
515         t = DEBUG_ENGINE.from_string(fh.read())
516     c = Context({
517         'version': get_docs_version(),
518     })
519 
520     return HttpResponse(t.render(c), content_type='text/html')

</code><intended_behavior>Amend to use OSError for managing file access errors in debug views, ensuring error pages render correctly upon issues.</intended_behavior>, <file>django/contrib/staticfiles/storage.py</file>
<class>None</class>
<method>None</method>
<code>
1 import hashlib
2 import json
3 import os
4 import posixpath
5 import re
6 import warnings
7 from collections import OrderedDict
8 from urllib.parse import unquote, urldefrag, urlsplit, urlunsplit
9 
10 from django.conf import settings
11 from django.contrib.staticfiles.utils import check_settings, matches_patterns
12 from django.core.cache import (
13     InvalidCacheBackendError, cache as default_cache, caches,
14 )
15 from django.core.exceptions import ImproperlyConfigured
16 from django.core.files.base import ContentFile
17 from django.core.files.storage import FileSystemStorage, get_storage_class
18 from django.utils.deprecation import RemovedInDjango31Warning
19 from django.utils.functional import LazyObject
20 
21 
22 class StaticFilesStorage(FileSystemStorage):
23     """
24     Standard file system storage for static files.
25 
26     The defaults for ``location`` and ``base_url`` are
27     ``STATIC_ROOT`` and ``STATIC_URL``.
28     """
29     def __init__(self, location=None, base_url=None, *args, **kwargs):
30         if location is None:
31             location = settings.STATIC_ROOT
32         if base_url is None:
33             base_url = settings.STATIC_URL
34         check_settings(base_url)
35         super().__init__(location, base_url, *args, **kwargs)
36         # FileSystemStorage fallbacks to MEDIA_ROOT when location
37         # is empty, so we restore the empty value.
38         if not location:
39             self.base_location = None
40             self.location = None
41 
42     def path(self, name):
43         if not self.location:
44             raise ImproperlyConfigured("You're using the staticfiles app "
45                                        "without having set the STATIC_ROOT "
46                                        "setting to a filesystem path.")
47         return super().path(name)
48 
49 
50 class HashedFilesMixin:
51     default_template = """url("%s")"""
52     max_post_process_passes = 5
53     patterns = (
54         ("*.css", (
55             r"""(url\(['"]{0,1}\s*(.*?)["']{0,1}\))""",
56             (r"""(@import\s*["']\s*(.*?)["'])""", """@import url("%s")"""),
57         )),
58     )
59 
60     def __init__(self, *args, **kwargs):
61         super().__init__(*args, **kwargs)
62         self._patterns = OrderedDict()
63         self.hashed_files = {}
64         for extension, patterns in self.patterns:
65             for pattern in patterns:
66                 if isinstance(pattern, (tuple, list)):
67                     pattern, template = pattern
68                 else:
69                     template = self.default_template
70                 compiled = re.compile(pattern, re.IGNORECASE)
71                 self._patterns.setdefault(extension, []).append((compiled, template))
72 
73     def file_hash(self, name, content=None):
74         """
75         Return a hash of the file with the given name and optional content.
76         """
77         if content is None:
78             return None
79         md5 = hashlib.md5()
80         for chunk in content.chunks():
81             md5.update(chunk)
82         return md5.hexdigest()[:12]
83 
84     def hashed_name(self, name, content=None, filename=None):
85         # `filename` is the name of file to hash if `content` isn't given.
86         # `name` is the base name to construct the new hashed filename from.
87         parsed_name = urlsplit(unquote(name))
88         clean_name = parsed_name.path.strip()
89         filename = (filename and urlsplit(unquote(filename)).path.strip()) or clean_name
90         opened = content is None
91         if opened:
92             if not self.exists(filename):
93                 raise ValueError("The file '%s' could not be found with %r." % (filename, self))
94             try:
95                 content = self.open(filename)
96             except IOError:
97                 # Handle directory paths and fragments
98                 return name
99         try:
100             file_hash = self.file_hash(clean_name, content)
101         finally:
102             if opened:
103                 content.close()
104         path, filename = os.path.split(clean_name)
105         root, ext = os.path.splitext(filename)
106         if file_hash is not None:
107             file_hash = ".%s" % file_hash
108         hashed_name = os.path.join(path, "%s%s%s" %
109                                    (root, file_hash, ext))
110         unparsed_name = list(parsed_name)
111         unparsed_name[2] = hashed_name
112         # Special casing for a @font-face hack, like url(myfont.eot?#iefix")
113         # http://www.fontspring.com/blog/the-new-bulletproof-font-face-syntax
114         if '?#' in name and not unparsed_name[3]:
115             unparsed_name[2] += '?'
116         return urlunsplit(unparsed_name)
117 
118     def _url(self, hashed_name_func, name, force=False, hashed_files=None):
119         """
120         Return the non-hashed URL in DEBUG mode.
121         """
122         if settings.DEBUG and not force:
123             hashed_name, fragment = name, ''
124         else:
125             clean_name, fragment = urldefrag(name)
126             if urlsplit(clean_name).path.endswith('/'):  # don't hash paths
127                 hashed_name = name
128             else:
129                 args = (clean_name,)
130                 if hashed_files is not None:
131                     args += (hashed_files,)
132                 hashed_name = hashed_name_func(*args)
133 
134         final_url = super().url(hashed_name)
135 
136         # Special casing for a @font-face hack, like url(myfont.eot?#iefix")
137         # http://www.fontspring.com/blog/the-new-bulletproof-font-face-syntax
138         query_fragment = '?#' in name  # [sic!]
139         if fragment or query_fragment:
140             urlparts = list(urlsplit(final_url))
141             if fragment and not urlparts[4]:
142                 urlparts[4] = fragment
143             if query_fragment and not urlparts[3]:
144                 urlparts[2] += '?'
145             final_url = urlunsplit(urlparts)
146 
147         return unquote(final_url)
148 
149     def url(self, name, force=False):
150         """
151         Return the non-hashed URL in DEBUG mode.
152         """
153         return self._url(self.stored_name, name, force)
154 
155     def url_converter(self, name, hashed_files, template=None):
156         """
157         Return the custom URL converter for the given file name.
158         """
159         if template is None:
160             template = self.default_template
161 
162         def converter(matchobj):
163             """
164             Convert the matched URL to a normalized and hashed URL.
165 
166             This requires figuring out which files the matched URL resolves
167             to and calling the url() method of the storage.
168             """
169             matched, url = matchobj.groups()
170 
171             # Ignore absolute/protocol-relative and data-uri URLs.
172             if re.match(r'^[a-z]+:', url):
173                 return matched
174 
175             # Ignore absolute URLs that don't point to a static file (dynamic
176             # CSS / JS?). Note that STATIC_URL cannot be empty.
177             if url.startswith('/') and not url.startswith(settings.STATIC_URL):
178                 return matched
179 
180             # Strip off the fragment so a path-like fragment won't interfere.
181             url_path, fragment = urldefrag(url)
182 
183             if url_path.startswith('/'):
184                 # Otherwise the condition above would have returned prematurely.
185                 assert url_path.startswith(settings.STATIC_URL)
186                 target_name = url_path[len(settings.STATIC_URL):]
187             else:
188                 # We're using the posixpath module to mix paths and URLs conveniently.
189                 source_name = name if os.sep == '/' else name.replace(os.sep, '/')
190                 target_name = posixpath.join(posixpath.dirname(source_name), url_path)
191 
192             # Determine the hashed name of the target file with the storage backend.
193             hashed_url = self._url(
194                 self._stored_name, unquote(target_name),
195                 force=True, hashed_files=hashed_files,
196             )
197 
198             transformed_url = '/'.join(url_path.split('/')[:-1] + hashed_url.split('/')[-1:])
199 
200             # Restore the fragment that was stripped off earlier.
201             if fragment:
202                 transformed_url += ('?#' if '?#' in url else '#') + fragment
203 
204             # Return the hashed version to the file
205             return template % unquote(transformed_url)
206 
207         return converter
208 
209     def post_process(self, paths, dry_run=False, **options):
210         """
211         Post process the given OrderedDict of files (called from collectstatic).
212 
213         Processing is actually two separate operations:
214 
215         1. renaming files to include a hash of their content for cache-busting,
216            and copying those files to the target storage.
217         2. adjusting files which contain references to other files so they
218            refer to the cache-busting filenames.
219 
220         If either of these are performed on a file, then that file is considered
221         post-processed.
222         """
223         # don't even dare to process the files if we're in dry run mode
224         if dry_run:
225             return
226 
227         # where to store the new paths
228         hashed_files = OrderedDict()
229 
230         # build a list of adjustable files
231         adjustable_paths = [
232             path for path in paths
233             if matches_patterns(path, self._patterns)
234         ]
235         # Do a single pass first. Post-process all files once, then repeat for
236         # adjustable files.
237         for name, hashed_name, processed, _ in self._post_process(paths, adjustable_paths, hashed_files):
238             yield name, hashed_name, processed
239 
240         paths = {path: paths[path] for path in adjustable_paths}
241 
242         for i in range(self.max_post_process_passes):
243             substitutions = False
244             for name, hashed_name, processed, subst in self._post_process(paths, adjustable_paths, hashed_files):
245                 yield name, hashed_name, processed
246                 substitutions = substitutions or subst
247 
248             if not substitutions:
249                 break
250 
251         if substitutions:
252             yield 'All', None, RuntimeError('Max post-process passes exceeded.')
253 
254         # Store the processed paths
255         self.hashed_files.update(hashed_files)
256 
257     def _post_process(self, paths, adjustable_paths, hashed_files):
258         # Sort the files by directory level
259         def path_level(name):
260             return len(name.split(os.sep))
261 
262         for name in sorted(paths, key=path_level, reverse=True):
263             substitutions = True
264             # use the original, local file, not the copied-but-unprocessed
265             # file, which might be somewhere far away, like S3
266             storage, path = paths[name]
267             with storage.open(path) as original_file:
268                 cleaned_name = self.clean_name(name)
269                 hash_key = self.hash_key(cleaned_name)
270 
271                 # generate the hash with the original content, even for
272                 # adjustable files.
273                 if hash_key not in hashed_files:
274                     hashed_name = self.hashed_name(name, original_file)
275                 else:
276                     hashed_name = hashed_files[hash_key]
277 
278                 # then get the original's file content..
279                 if hasattr(original_file, 'seek'):
280                     original_file.seek(0)
281 
282                 hashed_file_exists = self.exists(hashed_name)
283                 processed = False
284 
285                 # ..to apply each replacement pattern to the content
286                 if name in adjustable_paths:
287                     old_hashed_name = hashed_name
288                     content = original_file.read().decode(settings.FILE_CHARSET)
289                     for extension, patterns in self._patterns.items():
290                         if matches_patterns(path, (extension,)):
291                             for pattern, template in patterns:
292                                 converter = self.url_converter(name, hashed_files, template)
293                                 try:
294                                     content = pattern.sub(converter, content)
295                                 except ValueError as exc:
296                                     yield name, None, exc, False
297                     if hashed_file_exists:
298                         self.delete(hashed_name)
299                     # then save the processed result
300                     content_file = ContentFile(content.encode())
301                     # Save intermediate file for reference
302                     saved_name = self._save(hashed_name, content_file)
303                     hashed_name = self.hashed_name(name, content_file)
304 
305                     if self.exists(hashed_name):
306                         self.delete(hashed_name)
307 
308                     saved_name = self._save(hashed_name, content_file)
309                     hashed_name = self.clean_name(saved_name)
310                     # If the file hash stayed the same, this file didn't change
311                     if old_hashed_name == hashed_name:
312                         substitutions = False
313                     processed = True
314 
315                 if not processed:
316                     # or handle the case in which neither processing nor
317                     # a change to the original file happened
318                     if not hashed_file_exists:
319                         processed = True
320                         saved_name = self._save(hashed_name, original_file)
321                         hashed_name = self.clean_name(saved_name)
322 
323                 # and then set the cache accordingly
324                 hashed_files[hash_key] = hashed_name
325 
326                 yield name, hashed_name, processed, substitutions
327 
328     def clean_name(self, name):
329         return name.replace('\\', '/')
330 
331     def hash_key(self, name):
332         return name
333 
334     def _stored_name(self, name, hashed_files):
335         # Normalize the path to avoid multiple names for the same file like
336         # ../foo/bar.css and ../foo/../foo/bar.css which normalize to the same
337         # path.
338         name = posixpath.normpath(name)
339         cleaned_name = self.clean_name(name)
340         hash_key = self.hash_key(cleaned_name)
341         cache_name = hashed_files.get(hash_key)
342         if cache_name is None:
343             cache_name = self.clean_name(self.hashed_name(name))
344         return cache_name
345 
346     def stored_name(self, name):
347         cleaned_name = self.clean_name(name)
348         hash_key = self.hash_key(cleaned_name)
349         cache_name = self.hashed_files.get(hash_key)
350         if cache_name:
351             return cache_name
352         # No cached name found, recalculate it from the files.
353         intermediate_name = name
354         for i in range(self.max_post_process_passes + 1):
355             cache_name = self.clean_name(
356                 self.hashed_name(name, content=None, filename=intermediate_name)
357             )
358             if intermediate_name == cache_name:
359                 # Store the hashed name if there was a miss.
360                 self.hashed_files[hash_key] = cache_name
361                 return cache_name
362             else:
363                 # Move on to the next intermediate file.
364                 intermediate_name = cache_name
365         # If the cache name can't be determined after the max number of passes,
366         # the intermediate files on disk may be corrupt; avoid an infinite loop.
367         raise ValueError("The name '%s' could not be hashed with %r." % (name, self))
368 
369 
370 class ManifestFilesMixin(HashedFilesMixin):
371     manifest_version = '1.0'  # the manifest format standard
372     manifest_name = 'staticfiles.json'
373     manifest_strict = True
374 
375     def __init__(self, *args, **kwargs):
376         super().__init__(*args, **kwargs)
377         self.hashed_files = self.load_manifest()
378 
379     def read_manifest(self):
380         try:
381             with self.open(self.manifest_name) as manifest:
382                 return manifest.read().decode()
383         except IOError:
384             return None
385 
386     def load_manifest(self):
387         content = self.read_manifest()
388         if content is None:
389             return OrderedDict()
390         try:
391             stored = json.loads(content, object_pairs_hook=OrderedDict)
392         except json.JSONDecodeError:
393             pass
394         else:
395             version = stored.get('version')
396             if version == '1.0':
397                 return stored.get('paths', OrderedDict())
398         raise ValueError("Couldn't load manifest '%s' (version %s)" %
399                          (self.manifest_name, self.manifest_version))
400 
401     def post_process(self, *args, **kwargs):
402         self.hashed_files = OrderedDict()
403         yield from super().post_process(*args, **kwargs)
404         self.save_manifest()
405 
406     def save_manifest(self):
407         payload = {'paths': self.hashed_files, 'version': self.manifest_version}
408         if self.exists(self.manifest_name):
409             self.delete(self.manifest_name)
410         contents = json.dumps(payload).encode()
411         self._save(self.manifest_name, ContentFile(contents))
412 
413     def stored_name(self, name):
414         parsed_name = urlsplit(unquote(name))
415         clean_name = parsed_name.path.strip()
416         hash_key = self.hash_key(clean_name)
417         cache_name = self.hashed_files.get(hash_key)
418         if cache_name is None:
419             if self.manifest_strict:
420                 raise ValueError("Missing staticfiles manifest entry for '%s'" % clean_name)
421             cache_name = self.clean_name(self.hashed_name(name))
422         unparsed_name = list(parsed_name)
423         unparsed_name[2] = cache_name
424         # Special casing for a @font-face hack, like url(myfont.eot?#iefix")
425         # http://www.fontspring.com/blog/the-new-bulletproof-font-face-syntax
426         if '?#' in name and not unparsed_name[3]:
427             unparsed_name[2] += '?'
428         return urlunsplit(unparsed_name)
429 
430 
431 class _MappingCache:
432     """
433     A small dict-like wrapper for a given cache backend instance.
434     """
435     def __init__(self, cache):
436         self.cache = cache
437 
438     def __setitem__(self, key, value):
439         self.cache.set(key, value)
440 
441     def __getitem__(self, key):
442         value = self.cache.get(key)
443         if value is None:
444             raise KeyError("Couldn't find a file name '%s'" % key)
445         return value
446 
447     def clear(self):
448         self.cache.clear()
449 
450     def update(self, data):
451         self.cache.set_many(data)
452 
453     def get(self, key, default=None):
454         try:
455             return self[key]
456         except KeyError:
457             return default
458 
459 
460 class CachedFilesMixin(HashedFilesMixin):
461     def __init__(self, *args, **kwargs):
462         super().__init__(*args, **kwargs)
463         try:
464             self.hashed_files = _MappingCache(caches['staticfiles'])
465         except InvalidCacheBackendError:
466             # Use the default backend
467             self.hashed_files = _MappingCache(default_cache)
468 
469     def hash_key(self, name):
470         key = hashlib.md5(self.clean_name(name).encode()).hexdigest()
471         return 'staticfiles:%s' % key
472 
473 
474 class CachedStaticFilesStorage(CachedFilesMixin, StaticFilesStorage):
475     """
476     A static file system storage backend which also saves
477     hashed copies of the files it saves.
478     """
479     def __init__(self, *args, **kwargs):
480         warnings.warn(
481             'CachedStaticFilesStorage is deprecated in favor of '
482             'ManifestStaticFilesStorage.',
483             RemovedInDjango31Warning, stacklevel=2,
484         )
485         super().__init__(*args, **kwargs)
486 
487 
488 class ManifestStaticFilesStorage(ManifestFilesMixin, StaticFilesStorage):
489     """
490     A static file system storage backend which also saves
491     hashed copies of the files it saves.
492     """
493     pass
494 
495 
496 class ConfiguredStorage(LazyObject):
497     def _setup(self):
498         self._wrapped = get_storage_class(settings.STATICFILES_STORAGE)()
499 
500 
501 staticfiles_storage = ConfiguredStorage()

</code><intended_behavior>Replace IOError with OSError for static files storage operations, preserving integrity in static file serving and error logging.</intended_behavior>, <file>django/contrib/sessions/backends/file.py</file>
<class>None</class>
<method>None</method>
<code>
1 import datetime
2 import logging
3 import os
4 import shutil
5 import tempfile
6 
7 from django.conf import settings
8 from django.contrib.sessions.backends.base import (
9     VALID_KEY_CHARS, CreateError, SessionBase, UpdateError,
10 )
11 from django.contrib.sessions.exceptions import InvalidSessionKey
12 from django.core.exceptions import ImproperlyConfigured, SuspiciousOperation
13 from django.utils import timezone
14 
15 
16 class SessionStore(SessionBase):
17     """
18     Implement a file based session store.
19     """
20     def __init__(self, session_key=None):
21         self.storage_path = type(self)._get_storage_path()
22         self.file_prefix = settings.SESSION_COOKIE_NAME
23         super().__init__(session_key)
24 
25     @classmethod
26     def _get_storage_path(cls):
27         try:
28             return cls._storage_path
29         except AttributeError:
30             storage_path = getattr(settings, 'SESSION_FILE_PATH', None) or tempfile.gettempdir()
31             # Make sure the storage path is valid.
32             if not os.path.isdir(storage_path):
33                 raise ImproperlyConfigured(
34                     "The session storage path %r doesn't exist. Please set your"
35                     " SESSION_FILE_PATH setting to an existing directory in which"
36                     " Django can store session data." % storage_path)
37 
38             cls._storage_path = storage_path
39             return storage_path
40 
41     def _key_to_file(self, session_key=None):
42         """
43         Get the file associated with this session key.
44         """
45         if session_key is None:
46             session_key = self._get_or_create_session_key()
47 
48         # Make sure we're not vulnerable to directory traversal. Session keys
49         # should always be md5s, so they should never contain directory
50         # components.
51         if not set(session_key).issubset(VALID_KEY_CHARS):
52             raise InvalidSessionKey(
53                 "Invalid characters in session key")
54 
55         return os.path.join(self.storage_path, self.file_prefix + session_key)
56 
57     def _last_modification(self):
58         """
59         Return the modification time of the file storing the session's content.
60         """
61         modification = os.stat(self._key_to_file()).st_mtime
62         if settings.USE_TZ:
63             modification = datetime.datetime.utcfromtimestamp(modification)
64             return modification.replace(tzinfo=timezone.utc)
65         return datetime.datetime.fromtimestamp(modification)
66 
67     def _expiry_date(self, session_data):
68         """
69         Return the expiry time of the file storing the session's content.
70         """
71         return session_data.get('_session_expiry') or (
72             self._last_modification() + datetime.timedelta(seconds=settings.SESSION_COOKIE_AGE)
73         )
74 
75     def load(self):
76         session_data = {}
77         try:
78             with open(self._key_to_file(), encoding='ascii') as session_file:
79                 file_data = session_file.read()
80             # Don't fail if there is no data in the session file.
81             # We may have opened the empty placeholder file.
82             if file_data:
83                 try:
84                     session_data = self.decode(file_data)
85                 except (EOFError, SuspiciousOperation) as e:
86                     if isinstance(e, SuspiciousOperation):
87                         logger = logging.getLogger('django.security.%s' % e.__class__.__name__)
88                         logger.warning(str(e))
89                     self.create()
90 
91                 # Remove expired sessions.
92                 expiry_age = self.get_expiry_age(expiry=self._expiry_date(session_data))
93                 if expiry_age <= 0:
94                     session_data = {}
95                     self.delete()
96                     self.create()
97         except (IOError, SuspiciousOperation):
98             self._session_key = None
99         return session_data
100 
101     def create(self):
102         while True:
103             self._session_key = self._get_new_session_key()
104             try:
105                 self.save(must_create=True)
106             except CreateError:
107                 continue
108             self.modified = True
109             return
110 
111     def save(self, must_create=False):
112         if self.session_key is None:
113             return self.create()
114         # Get the session data now, before we start messing
115         # with the file it is stored within.
116         session_data = self._get_session(no_load=must_create)
117 
118         session_file_name = self._key_to_file()
119 
120         try:
121             # Make sure the file exists.  If it does not already exist, an
122             # empty placeholder file is created.
123             flags = os.O_WRONLY | getattr(os, 'O_BINARY', 0)
124             if must_create:
125                 flags |= os.O_EXCL | os.O_CREAT
126             fd = os.open(session_file_name, flags)
127             os.close(fd)
128         except FileNotFoundError:
129             if not must_create:
130                 raise UpdateError
131         except FileExistsError:
132             if must_create:
133                 raise CreateError
134 
135         # Write the session file without interfering with other threads
136         # or processes.  By writing to an atomically generated temporary
137         # file and then using the atomic os.rename() to make the complete
138         # file visible, we avoid having to lock the session file, while
139         # still maintaining its integrity.
140         #
141         # Note: Locking the session file was explored, but rejected in part
142         # because in order to be atomic and cross-platform, it required a
143         # long-lived lock file for each session, doubling the number of
144         # files in the session storage directory at any given time.  This
145         # rename solution is cleaner and avoids any additional overhead
146         # when reading the session data, which is the more common case
147         # unless SESSION_SAVE_EVERY_REQUEST = True.
148         #
149         # See ticket #8616.
150         dir, prefix = os.path.split(session_file_name)
151 
152         try:
153             output_file_fd, output_file_name = tempfile.mkstemp(dir=dir, prefix=prefix + '_out_')
154             renamed = False
155             try:
156                 try:
157                     os.write(output_file_fd, self.encode(session_data).encode())
158                 finally:
159                     os.close(output_file_fd)
160 
161                 # This will atomically rename the file (os.rename) if the OS
162                 # supports it. Otherwise this will result in a shutil.copy2
163                 # and os.unlink (for example on Windows). See #9084.
164                 shutil.move(output_file_name, session_file_name)
165                 renamed = True
166             finally:
167                 if not renamed:
168                     os.unlink(output_file_name)
169         except (OSError, IOError, EOFError):
170             pass
171 
172     def exists(self, session_key):
173         return os.path.exists(self._key_to_file(session_key))
174 
175     def delete(self, session_key=None):
176         if session_key is None:
177             if self.session_key is None:
178                 return
179             session_key = self.session_key
180         try:
181             os.unlink(self._key_to_file(session_key))
182         except OSError:
183             pass
184 
185     def clean(self):
186         pass
187 
188     @classmethod
189     def clear_expired(cls):
190         storage_path = cls._get_storage_path()
191         file_prefix = settings.SESSION_COOKIE_NAME
192 
193         for session_file in os.listdir(storage_path):
194             if not session_file.startswith(file_prefix):
195                 continue
196             session_key = session_file[len(file_prefix):]
197             session = cls(session_key)
198             # When an expired session is loaded, its file is removed, and a
199             # new file is immediately created. Prevent this by disabling
200             # the create() method.
201             session.create = lambda: None
202             session.load()

</code><intended_behavior>Update session file backend to use OSError for session file management errors, maintaining session data integrity and error handling.</intended_behavior>, <file>django/contrib/gis/geos/libgeos.py</file>
<class>None</class>
<method>load_geos</method>
<code>
21 def load_geos():
22     # Custom library path set?
23     try:
24         from django.conf import settings
25         lib_path = settings.GEOS_LIBRARY_PATH
26     except (AttributeError, EnvironmentError,
27             ImportError, ImproperlyConfigured):
28         lib_path = None
29 
30     # Setting the appropriate names for the GEOS-C library.
31     if lib_path:
32         lib_names = None
33     elif os.name == 'nt':
34         # Windows NT libraries
35         lib_names = ['geos_c', 'libgeos_c-1']
36     elif os.name == 'posix':
37         # *NIX libraries
38         lib_names = ['geos_c', 'GEOS']
39     else:
40         raise ImportError('Unsupported OS "%s"' % os.name)
41 
42     # Using the ctypes `find_library` utility to find the path to the GEOS
43     # shared library.  This is better than manually specifying each library name
44     # and extension (e.g., libgeos_c.[so|so.1|dylib].).
45     if lib_names:
46         for lib_name in lib_names:
47             lib_path = find_library(lib_name)
48             if lib_path is not None:
49                 break
50 
51     # No GEOS library could be found.
52     if lib_path is None:
53         raise ImportError(
54             'Could not find the GEOS library (tried "%s"). '
55             'Try setting GEOS_LIBRARY_PATH in your settings.' %
56             '", "'.join(lib_names)
57         )
58     # Getting the GEOS C library.  The C interface (CDLL) is used for
59     # both *NIX and Windows.
60     # See the GEOS C API source code for more details on the library function calls:
61     #  http://geos.refractions.net/ro/doxygen_docs/html/geos__c_8h-source.html
62     _lgeos = CDLL(lib_path)
63     # Here we set up the prototypes for the initGEOS_r and finishGEOS_r
64     # routines.  These functions aren't actually called until they are
65     # attached to a GEOS context handle -- this actually occurs in
66     # geos/prototypes/threadsafe.py.
67     _lgeos.initGEOS_r.restype = CONTEXT_PTR
68     _lgeos.finishGEOS_r.argtypes = [CONTEXT_PTR]
69     # Set restype for compatibility across 32 and 64-bit platforms.
70     _lgeos.GEOSversion.restype = c_char_p
71     return _lgeos

</code><intended_behavior>Transition from EnvironmentError to OSError while loading GEOS libraries, ensuring library path issues are captured under a unified exception.</intended_behavior>, <file>django/contrib/gis/gdal/libgdal.py</file>
<class>None</class>
<method>None</method>
<code>
1 import logging
2 import os
3 import re
4 from ctypes import CDLL, CFUNCTYPE, c_char_p, c_int
5 from ctypes.util import find_library
6 
7 from django.contrib.gis.gdal.error import GDALException
8 from django.core.exceptions import ImproperlyConfigured
9 
10 logger = logging.getLogger('django.contrib.gis')
11 
12 # Custom library path set?
13 try:
14     from django.conf import settings
15     lib_path = settings.GDAL_LIBRARY_PATH
16 except (AttributeError, EnvironmentError,
17         ImportError, ImproperlyConfigured):
18     lib_path = None
19 
20 if lib_path:
21     lib_names = None
22 elif os.name == 'nt':
23     # Windows NT shared libraries
24     lib_names = ['gdal203', 'gdal202', 'gdal201', 'gdal20', 'gdal111']
25 elif os.name == 'posix':
26     # *NIX library names.
27     lib_names = ['gdal', 'GDAL', 'gdal2.3.0', 'gdal2.2.0', 'gdal2.1.0', 'gdal2.0.0', 'gdal1.11.0']
28 else:
29     raise ImproperlyConfigured('GDAL is unsupported on OS "%s".' % os.name)
30 
31 # Using the ctypes `find_library` utility  to find the
32 # path to the GDAL library from the list of library names.
33 if lib_names:
34     for lib_name in lib_names:
35         lib_path = find_library(lib_name)
36         if lib_path is not None:
37             break
38 
39 if lib_path is None:
40     raise ImproperlyConfigured(
41         'Could not find the GDAL library (tried "%s"). Is GDAL installed? '
42         'If it is, try setting GDAL_LIBRARY_PATH in your settings.'
43         % '", "'.join(lib_names)
44     )
45 
46 # This loads the GDAL/OGR C library
47 lgdal = CDLL(lib_path)
48 
49 # On Windows, the GDAL binaries have some OSR routines exported with
50 # STDCALL, while others are not.  Thus, the library will also need to
51 # be loaded up as WinDLL for said OSR functions that require the
52 # different calling convention.
53 if os.name == 'nt':
54     from ctypes import WinDLL
55     lwingdal = WinDLL(lib_path)
56 
57 
58 def std_call(func):
59     """
60     Return the correct STDCALL function for certain OSR routines on Win32
61     platforms.
62     """
63     if os.name == 'nt':
64         return lwingdal[func]
65     else:
66         return lgdal[func]
67 
68 
69 # #### Version-information functions. ####
70 
71 # Return GDAL library version information with the given key.
72 _version_info = std_call('GDALVersionInfo')
73 _version_info.argtypes = [c_char_p]
74 _version_info.restype = c_char_p
75 
76 
77 def gdal_version():
78     "Return only the GDAL version number information."
79     return _version_info(b'RELEASE_NAME')
80 
81 
82 def gdal_full_version():
83     "Return the full GDAL version information."
84     return _version_info('')
85 
86 
87 version_regex = re.compile(r'^(?P<major>\d+)\.(?P<minor>\d+)(\.(?P<subminor>\d+))?')
88 
89 
90 def gdal_version_info():
91     ver = gdal_version().decode()
92     m = version_regex.match(ver)
93     if not m:
94         raise GDALException('Could not parse GDAL version string "%s"' % ver)
95     return {key: m.group(key) for key in ('major', 'minor', 'subminor')}
96 
97 
98 _verinfo = gdal_version_info()
99 GDAL_MAJOR_VERSION = int(_verinfo['major'])
100 GDAL_MINOR_VERSION = int(_verinfo['minor'])
101 GDAL_SUBMINOR_VERSION = _verinfo['subminor'] and int(_verinfo['subminor'])
102 GDAL_VERSION = (GDAL_MAJOR_VERSION, GDAL_MINOR_VERSION, GDAL_SUBMINOR_VERSION)
103 del _verinfo
104 
105 # Set library error handling so as errors are logged
106 CPLErrorHandler = CFUNCTYPE(None, c_int, c_int, c_char_p)
107 
108 
109 def err_handler(error_class, error_number, message):
110     logger.error('GDAL_ERROR %d: %s', error_number, message)
111 
112 
113 err_handler = CPLErrorHandler(err_handler)
114 
115 
116 def function(name, args, restype):
117     func = std_call(name)
118     func.argtypes = args
119     func.restype = restype
120     return func
121 
122 
123 set_error_handler = function('CPLSetErrorHandler', [CPLErrorHandler], CPLErrorHandler)
124 set_error_handler(err_handler)

</code><intended_behavior>Use OSError for handling GDAL library path configurations, keeping the GIS component adaptable to configuration and file access issues.</intended_behavior>, <file>django/core/management/commands/runserver.py</file>
<class>None</class>
<method>None</method>
<code>
1 import errno
2 import os
3 import re
4 import socket
5 import sys
6 from datetime import datetime
7 
8 from django.conf import settings
9 from django.core.management.base import BaseCommand, CommandError
10 from django.core.servers.basehttp import (
11     WSGIServer, get_internal_wsgi_application, run,
12 )
13 from django.utils import autoreload
14 
15 naiveip_re = re.compile(r"""^(?:
16 (?P<addr>
17     (?P<ipv4>\d{1,3}(?:\.\d{1,3}){3}) |         # IPv4 address
18     (?P<ipv6>\[[a-fA-F0-9:]+\]) |               # IPv6 address
19     (?P<fqdn>[a-zA-Z0-9-]+(?:\.[a-zA-Z0-9-]+)*) # FQDN
20 ):)?(?P<port>\d+)$""", re.X)
21 
22 
23 class Command(BaseCommand):
24     help = "Starts a lightweight Web server for development."
25 
26     # Validation is called explicitly each time the server is reloaded.
27     requires_system_checks = False
28     stealth_options = ('shutdown_message',)
29 
30     default_addr = '127.0.0.1'
31     default_addr_ipv6 = '::1'
32     default_port = '8000'
33     protocol = 'http'
34     server_cls = WSGIServer
35 
36     def add_arguments(self, parser):
37         parser.add_argument(
38             'addrport', nargs='?',
39             help='Optional port number, or ipaddr:port'
40         )
41         parser.add_argument(
42             '--ipv6', '-6', action='store_true', dest='use_ipv6',
43             help='Tells Django to use an IPv6 address.',
44         )
45         parser.add_argument(
46             '--nothreading', action='store_false', dest='use_threading',
47             help='Tells Django to NOT use threading.',
48         )
49         parser.add_argument(
50             '--noreload', action='store_false', dest='use_reloader',
51             help='Tells Django to NOT use the auto-reloader.',
52         )
53 
54     def execute(self, *args, **options):
55         if options['no_color']:
56             # We rely on the environment because it's currently the only
57             # way to reach WSGIRequestHandler. This seems an acceptable
58             # compromise considering `runserver` runs indefinitely.
59             os.environ["DJANGO_COLORS"] = "nocolor"
60         super().execute(*args, **options)
61 
62     def get_handler(self, *args, **options):
63         """Return the default WSGI handler for the runner."""
64         return get_internal_wsgi_application()
65 
66     def handle(self, *args, **options):
67         if not settings.DEBUG and not settings.ALLOWED_HOSTS:
68             raise CommandError('You must set settings.ALLOWED_HOSTS if DEBUG is False.')
69 
70         self.use_ipv6 = options['use_ipv6']
71         if self.use_ipv6 and not socket.has_ipv6:
72             raise CommandError('Your Python does not support IPv6.')
73         self._raw_ipv6 = False
74         if not options['addrport']:
75             self.addr = ''
76             self.port = self.default_port
77         else:
78             m = re.match(naiveip_re, options['addrport'])
79             if m is None:
80                 raise CommandError('"%s" is not a valid port number '
81                                    'or address:port pair.' % options['addrport'])
82             self.addr, _ipv4, _ipv6, _fqdn, self.port = m.groups()
83             if not self.port.isdigit():
84                 raise CommandError("%r is not a valid port number." % self.port)
85             if self.addr:
86                 if _ipv6:
87                     self.addr = self.addr[1:-1]
88                     self.use_ipv6 = True
89                     self._raw_ipv6 = True
90                 elif self.use_ipv6 and not _fqdn:
91                     raise CommandError('"%s" is not a valid IPv6 address.' % self.addr)
92         if not self.addr:
93             self.addr = self.default_addr_ipv6 if self.use_ipv6 else self.default_addr
94             self._raw_ipv6 = self.use_ipv6
95         self.run(**options)
96 
97     def run(self, **options):
98         """Run the server, using the autoreloader if needed."""
99         use_reloader = options['use_reloader']
100 
101         if use_reloader:
102             autoreload.run_with_reloader(self.inner_run, **options)
103         else:
104             self.inner_run(None, **options)
105 
106     def inner_run(self, *args, **options):
107         # If an exception was silenced in ManagementUtility.execute in order
108         # to be raised in the child process, raise it now.
109         autoreload.raise_last_exception()
110 
111         threading = options['use_threading']
112         # 'shutdown_message' is a stealth option.
113         shutdown_message = options.get('shutdown_message', '')
114         quit_command = 'CTRL-BREAK' if sys.platform == 'win32' else 'CONTROL-C'
115 
116         self.stdout.write("Performing system checks…\n\n")
117         self.check(display_num_errors=True)
118         # Need to check migrations here, so can't use the
119         # requires_migrations_check attribute.
120         self.check_migrations()
121         now = datetime.now().strftime('%B %d, %Y - %X')
122         self.stdout.write(now)
123         self.stdout.write((
124             "Django version %(version)s, using settings %(settings)r\n"
125             "Starting development server at %(protocol)s://%(addr)s:%(port)s/\n"
126             "Quit the server with %(quit_command)s.\n"
127         ) % {
128             "version": self.get_version(),
129             "settings": settings.SETTINGS_MODULE,
130             "protocol": self.protocol,
131             "addr": '[%s]' % self.addr if self._raw_ipv6 else self.addr,
132             "port": self.port,
133             "quit_command": quit_command,
134         })
135 
136         try:
137             handler = self.get_handler(*args, **options)
138             run(self.addr, int(self.port), handler,
139                 ipv6=self.use_ipv6, threading=threading, server_cls=self.server_cls)
140         except socket.error as e:
141             # Use helpful error messages instead of ugly tracebacks.
142             ERRORS = {
143                 errno.EACCES: "You don't have permission to access that port.",
144                 errno.EADDRINUSE: "That port is already in use.",
145                 errno.EADDRNOTAVAIL: "That IP address can't be assigned to.",
146             }
147             try:
148                 error_text = ERRORS[e.errno]
149             except KeyError:
150                 error_text = e
151             self.stderr.write("Error: %s" % error_text)
152             # Need to use an OS exit because sys.exit doesn't work in a thread
153             os._exit(1)
154         except KeyboardInterrupt:
155             if shutdown_message:
156                 self.stdout.write(shutdown_message)
157             sys.exit(0)
158 
159 
160 # Kept for backward compatibility
161 BaseRunserverCommand = Command

</code><intended_behavior>Change socket.error to capture with OSError during server run operations, to handle network-related errors uniformly.</intended_behavior>, <file>django/core/servers/basehttp.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2 HTTP server that implements the Python WSGI protocol (PEP 333, rev 1.21).
3 
4 Based on wsgiref.simple_server which is part of the standard library since 2.5.
5 
6 This is a simple server for use in testing or debugging Django apps. It hasn't
7 been reviewed for security issues. DON'T USE IT FOR PRODUCTION USE!
8 """
9 
10 import logging
11 import socket
12 import socketserver
13 import sys
14 from wsgiref import simple_server
15 
16 from django.core.exceptions import ImproperlyConfigured
17 from django.core.handlers.wsgi import LimitedStream
18 from django.core.wsgi import get_wsgi_application
19 from django.utils.module_loading import import_string
20 
21 __all__ = ('WSGIServer', 'WSGIRequestHandler')
22 
23 logger = logging.getLogger('django.server')
24 
25 
26 def get_internal_wsgi_application():
27     """
28     Load and return the WSGI application as configured by the user in
29     ``settings.WSGI_APPLICATION``. With the default ``startproject`` layout,
30     this will be the ``application`` object in ``projectname/wsgi.py``.
31 
32     This function, and the ``WSGI_APPLICATION`` setting itself, are only useful
33     for Django's internal server (runserver); external WSGI servers should just
34     be configured to point to the correct application object directly.
35 
36     If settings.WSGI_APPLICATION is not set (is ``None``), return
37     whatever ``django.core.wsgi.get_wsgi_application`` returns.
38     """
39     from django.conf import settings
40     app_path = getattr(settings, 'WSGI_APPLICATION')
41     if app_path is None:
42         return get_wsgi_application()
43 
44     try:
45         return import_string(app_path)
46     except ImportError as err:
47         raise ImproperlyConfigured(
48             "WSGI application '%s' could not be loaded; "
49             "Error importing module." % app_path
50         ) from err
51 
52 
53 def is_broken_pipe_error():
54     exc_type, exc_value = sys.exc_info()[:2]
55     return issubclass(exc_type, socket.error) and exc_value.args[0] == 32
56 
57 
58 class WSGIServer(simple_server.WSGIServer):
59     """BaseHTTPServer that implements the Python WSGI protocol"""
60 
61     request_queue_size = 10
62 
63     def __init__(self, *args, ipv6=False, allow_reuse_address=True, **kwargs):
64         if ipv6:
65             self.address_family = socket.AF_INET6
66         self.allow_reuse_address = allow_reuse_address
67         super().__init__(*args, **kwargs)
68 
69     def handle_error(self, request, client_address):
70         if is_broken_pipe_error():
71             logger.info("- Broken pipe from %s\n", client_address)
72         else:
73             super().handle_error(request, client_address)
74 
75 
76 class ThreadedWSGIServer(socketserver.ThreadingMixIn, WSGIServer):
77     """A threaded version of the WSGIServer"""
78     daemon_threads = True
79 
80 
81 class ServerHandler(simple_server.ServerHandler):
82     http_version = '1.1'
83 
84     def __init__(self, stdin, stdout, stderr, environ, **kwargs):
85         """
86         Use a LimitedStream so that unread request data will be ignored at
87         the end of the request. WSGIRequest uses a LimitedStream but it
88         shouldn't discard the data since the upstream servers usually do this.
89         This fix applies only for testserver/runserver.
90         """
91         try:
92             content_length = int(environ.get('CONTENT_LENGTH'))
93         except (ValueError, TypeError):
94             content_length = 0
95         super().__init__(LimitedStream(stdin, content_length), stdout, stderr, environ, **kwargs)
96 
97     def cleanup_headers(self):
98         super().cleanup_headers()
99         # HTTP/1.1 requires support for persistent connections. Send 'close' if
100         # the content length is unknown to prevent clients from reusing the
101         # connection.
102         if 'Content-Length' not in self.headers:
103             self.headers['Connection'] = 'close'
104         # Mark the connection for closing if it's set as such above or if the
105         # application sent the header.
106         if self.headers.get('Connection') == 'close':
107             self.request_handler.close_connection = True
108 
109     def close(self):
110         self.get_stdin()._read_limited()
111         super().close()
112 
113     def handle_error(self):
114         # Ignore broken pipe errors, otherwise pass on
115         if not is_broken_pipe_error():
116             super().handle_error()
117 
118 
119 class WSGIRequestHandler(simple_server.WSGIRequestHandler):
120     protocol_version = 'HTTP/1.1'
121 
122     def address_string(self):
123         # Short-circuit parent method to not call socket.getfqdn
124         return self.client_address[0]
125 
126     def log_message(self, format, *args):
127         extra = {
128             'request': self.request,
129             'server_time': self.log_date_time_string(),
130         }
131         if args[1][0] == '4':
132             # 0x16 = Handshake, 0x03 = SSL 3.0 or TLS 1.x
133             if args[0].startswith('\x16\x03'):
134                 extra['status_code'] = 500
135                 logger.error(
136                     "You're accessing the development server over HTTPS, but "
137                     "it only supports HTTP.\n", extra=extra,
138                 )
139                 return
140 
141         if args[1].isdigit() and len(args[1]) == 3:
142             status_code = int(args[1])
143             extra['status_code'] = status_code
144 
145             if status_code >= 500:
146                 level = logger.error
147             elif status_code >= 400:
148                 level = logger.warning
149             else:
150                 level = logger.info
151         else:
152             level = logger.info
153 
154         level(format, *args, extra=extra)
155 
156     def get_environ(self):
157         # Strip all headers with underscores in the name before constructing
158         # the WSGI environ. This prevents header-spoofing based on ambiguity
159         # between underscores and dashes both normalized to underscores in WSGI
160         # env vars. Nginx and Apache 2.4+ both do this as well.
161         for k in self.headers:
162             if '_' in k:
163                 del self.headers[k]
164 
165         return super().get_environ()
166 
167     def handle(self):
168         self.close_connection = True
169         self.handle_one_request()
170         while not self.close_connection:
171             self.handle_one_request()
172         try:
173             self.connection.shutdown(socket.SHUT_WR)
174         except (socket.error, AttributeError):
175             pass
176 
177     def handle_one_request(self):
178         """Copy of WSGIRequestHandler.handle() but with different ServerHandler"""
179         self.raw_requestline = self.rfile.readline(65537)
180         if len(self.raw_requestline) > 65536:
181             self.requestline = ''
182             self.request_version = ''
183             self.command = ''
184             self.send_error(414)
185             return
186 
187         if not self.parse_request():  # An error code has been sent, just exit
188             return
189 
190         handler = ServerHandler(
191             self.rfile, self.wfile, self.get_stderr(), self.get_environ()
192         )
193         handler.request_handler = self      # backpointer for logging & connection closing
194         handler.run(self.server.get_app())
195 
196 
197 def run(addr, port, wsgi_handler, ipv6=False, threading=False, server_cls=WSGIServer):
198     server_address = (addr, port)
199     if threading:
200         httpd_cls = type('WSGIServer', (socketserver.ThreadingMixIn, server_cls), {})
201     else:
202         httpd_cls = server_cls
203     httpd = httpd_cls(server_address, WSGIRequestHandler, ipv6=ipv6)
204     if threading:
205         # ThreadingMixIn.daemon_threads indicates how threads will behave on an
206         # abrupt shutdown; like quitting the server by the user or restarting
207         # by the auto-reloader. True means the server will not wait for thread
208         # termination before it quits. This will make auto-reloader faster
209         # and will prevent the need to kill the server manually if a thread
210         # isn't terminating correctly.
211         httpd.daemon_threads = True
212     httpd.set_app(wsgi_handler)
213     httpd.serve_forever()

</code><intended_behavior>Update exception handling to OSError instead of socket.error for HTTP server operations to manage connection and network errors consistently.</intended_behavior>, <file>django/core/mail/backends/smtp.py</file>
<class>EmailBackend</class>
<method>None</method>
<code>
13 class EmailBackend(BaseEmailBackend):
14     """
15     A wrapper that manages the SMTP network connection.
16     """
17     def __init__(self, host=None, port=None, username=None, password=None,
18                  use_tls=None, fail_silently=False, use_ssl=None, timeout=None,
19                  ssl_keyfile=None, ssl_certfile=None,
20                  **kwargs):
21         super().__init__(fail_silently=fail_silently)
22         self.host = host or settings.EMAIL_HOST
23         self.port = port or settings.EMAIL_PORT
24         self.username = settings.EMAIL_HOST_USER if username is None else username
25         self.password = settings.EMAIL_HOST_PASSWORD if password is None else password
26         self.use_tls = settings.EMAIL_USE_TLS if use_tls is None else use_tls
27         self.use_ssl = settings.EMAIL_USE_SSL if use_ssl is None else use_ssl
28         self.timeout = settings.EMAIL_TIMEOUT if timeout is None else timeout
29         self.ssl_keyfile = settings.EMAIL_SSL_KEYFILE if ssl_keyfile is None else ssl_keyfile
30         self.ssl_certfile = settings.EMAIL_SSL_CERTFILE if ssl_certfile is None else ssl_certfile
31         if self.use_ssl and self.use_tls:
32             raise ValueError(
33                 "EMAIL_USE_TLS/EMAIL_USE_SSL are mutually exclusive, so only set "
34                 "one of those settings to True.")
35         self.connection = None
36         self._lock = threading.RLock()
37 
38     @property
39     def connection_class(self):
40         return smtplib.SMTP_SSL if self.use_ssl else smtplib.SMTP
41 
42     def open(self):
43         """
44         Ensure an open connection to the email server. Return whether or not a
45         new connection was required (True or False) or None if an exception
46         passed silently.
47         """
48         if self.connection:
49             # Nothing to do if the connection is already open.
50             return False
51 
52         # If local_hostname is not specified, socket.getfqdn() gets used.
53         # For performance, we use the cached FQDN for local_hostname.
54         connection_params = {'local_hostname': DNS_NAME.get_fqdn()}
55         if self.timeout is not None:
56             connection_params['timeout'] = self.timeout
57         if self.use_ssl:
58             connection_params.update({
59                 'keyfile': self.ssl_keyfile,
60                 'certfile': self.ssl_certfile,
61             })
62         try:
63             self.connection = self.connection_class(self.host, self.port, **connection_params)
64 
65             # TLS/SSL are mutually exclusive, so only attempt TLS over
66             # non-secure connections.
67             if not self.use_ssl and self.use_tls:
68                 self.connection.starttls(keyfile=self.ssl_keyfile, certfile=self.ssl_certfile)
69             if self.username and self.password:
70                 self.connection.login(self.username, self.password)
71             return True
72         except (smtplib.SMTPException, socket.error):
73             if not self.fail_silently:
74                 raise
75 
76     def close(self):
77         """Close the connection to the email server."""
78         if self.connection is None:
79             return
80         try:
81             try:
82                 self.connection.quit()
83             except (ssl.SSLError, smtplib.SMTPServerDisconnected):
84                 # This happens when calling quit() on a TLS connection
85                 # sometimes, or when the connection was already disconnected
86                 # by the server.
87                 self.connection.close()
88             except smtplib.SMTPException:
89                 if self.fail_silently:
90                     return
91                 raise
92         finally:
93             self.connection = None
94 
95     def send_messages(self, email_messages):
96         """
97         Send one or more EmailMessage objects and return the number of email
98         messages sent.
99         """
100         if not email_messages:
101             return 0
102         with self._lock:
103             new_conn_created = self.open()
104             if not self.connection or new_conn_created is None:
105                 # We failed silently on open().
106                 # Trying to send would be pointless.
107                 return 0
108             num_sent = 0
109             for message in email_messages:
110                 sent = self._send(message)
111                 if sent:
112                     num_sent += 1
113             if new_conn_created:
114                 self.close()
115         return num_sent
116 
117     def _send(self, email_message):
118         """A helper method that does the actual sending."""
119         if not email_message.recipients():
120             return False
121         encoding = email_message.encoding or settings.DEFAULT_CHARSET
122         from_email = sanitize_address(email_message.from_email, encoding)
123         recipients = [sanitize_address(addr, encoding) for addr in email_message.recipients()]
124         message = email_message.message()
125         try:
126             self.connection.sendmail(from_email, recipients, message.as_bytes(linesep='\r\n'))
127         except smtplib.SMTPException:
128             if not self.fail_silently:
129                 raise
130             return False
131         return True

</code><intended_behavior>For SMTP operations, adjust to use OSError while considering to keep or remove specific catches for smtplib.SMTPException based on whether the additional granularity is required for email sending error handling.</intended_behavior>]
2025-10-15 15:53:47.840 | INFO     | Search completed. Bug locations: [<file>django/middleware/csrf.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2 Cross Site Request Forgery Middleware.
3 
4 This module provides a middleware that implements protection
5 against request forgeries from other sites.
6 """
7 import logging
8 import re
9 import string
10 from urllib.parse import urlparse
11 
12 from django.conf import settings
13 from django.core.exceptions import DisallowedHost, ImproperlyConfigured
14 from django.urls import get_callable
15 from django.utils.cache import patch_vary_headers
16 from django.utils.crypto import constant_time_compare, get_random_string
17 from django.utils.deprecation import MiddlewareMixin
18 from django.utils.http import is_same_domain
19 from django.utils.log import log_response
20 
21 logger = logging.getLogger('django.security.csrf')
22 
23 REASON_NO_REFERER = "Referer checking failed - no Referer."
24 REASON_BAD_REFERER = "Referer checking failed - %s does not match any trusted origins."
25 REASON_NO_CSRF_COOKIE = "CSRF cookie not set."
26 REASON_BAD_TOKEN = "CSRF token missing or incorrect."
27 REASON_MALFORMED_REFERER = "Referer checking failed - Referer is malformed."
28 REASON_INSECURE_REFERER = "Referer checking failed - Referer is insecure while host is secure."
29 
30 CSRF_SECRET_LENGTH = 32
31 CSRF_TOKEN_LENGTH = 2 * CSRF_SECRET_LENGTH
32 CSRF_ALLOWED_CHARS = string.ascii_letters + string.digits
33 CSRF_SESSION_KEY = '_csrftoken'
34 
35 
36 def _get_failure_view():
37     """Return the view to be used for CSRF rejections."""
38     return get_callable(settings.CSRF_FAILURE_VIEW)
39 
40 
41 def _get_new_csrf_string():
42     return get_random_string(CSRF_SECRET_LENGTH, allowed_chars=CSRF_ALLOWED_CHARS)
43 
44 
45 def _salt_cipher_secret(secret):
46     """
47     Given a secret (assumed to be a string of CSRF_ALLOWED_CHARS), generate a
48     token by adding a salt and using it to encrypt the secret.
49     """
50     salt = _get_new_csrf_string()
51     chars = CSRF_ALLOWED_CHARS
52     pairs = zip((chars.index(x) for x in secret), (chars.index(x) for x in salt))
53     cipher = ''.join(chars[(x + y) % len(chars)] for x, y in pairs)
54     return salt + cipher
55 
56 
57 def _unsalt_cipher_token(token):
58     """
59     Given a token (assumed to be a string of CSRF_ALLOWED_CHARS, of length
60     CSRF_TOKEN_LENGTH, and that its first half is a salt), use it to decrypt
61     the second half to produce the original secret.
62     """
63     salt = token[:CSRF_SECRET_LENGTH]
64     token = token[CSRF_SECRET_LENGTH:]
65     chars = CSRF_ALLOWED_CHARS
66     pairs = zip((chars.index(x) for x in token), (chars.index(x) for x in salt))
67     secret = ''.join(chars[x - y] for x, y in pairs)  # Note negative values are ok
68     return secret
69 
70 
71 def _get_new_csrf_token():
72     return _salt_cipher_secret(_get_new_csrf_string())
73 
74 
75 def get_token(request):
76     """
77     Return the CSRF token required for a POST form. The token is an
78     alphanumeric value. A new token is created if one is not already set.
79 
80     A side effect of calling this function is to make the csrf_protect
81     decorator and the CsrfViewMiddleware add a CSRF cookie and a 'Vary: Cookie'
82     header to the outgoing response.  For this reason, you may need to use this
83     function lazily, as is done by the csrf context processor.
84     """
85     if "CSRF_COOKIE" not in request.META:
86         csrf_secret = _get_new_csrf_string()
87         request.META["CSRF_COOKIE"] = _salt_cipher_secret(csrf_secret)
88     else:
89         csrf_secret = _unsalt_cipher_token(request.META["CSRF_COOKIE"])
90     request.META["CSRF_COOKIE_USED"] = True
91     return _salt_cipher_secret(csrf_secret)
92 
93 
94 def rotate_token(request):
95     """
96     Change the CSRF token in use for a request - should be done on login
97     for security purposes.
98     """
99     request.META.update({
100         "CSRF_COOKIE_USED": True,
101         "CSRF_COOKIE": _get_new_csrf_token(),
102     })
103     request.csrf_cookie_needs_reset = True
104 
105 
106 def _sanitize_token(token):
107     # Allow only ASCII alphanumerics
108     if re.search('[^a-zA-Z0-9]', token):
109         return _get_new_csrf_token()
110     elif len(token) == CSRF_TOKEN_LENGTH:
111         return token
112     elif len(token) == CSRF_SECRET_LENGTH:
113         # Older Django versions set cookies to values of CSRF_SECRET_LENGTH
114         # alphanumeric characters. For backwards compatibility, accept
115         # such values as unsalted secrets.
116         # It's easier to salt here and be consistent later, rather than add
117         # different code paths in the checks, although that might be a tad more
118         # efficient.
119         return _salt_cipher_secret(token)
120     return _get_new_csrf_token()
121 
122 
123 def _compare_salted_tokens(request_csrf_token, csrf_token):
124     # Assume both arguments are sanitized -- that is, strings of
125     # length CSRF_TOKEN_LENGTH, all CSRF_ALLOWED_CHARS.
126     return constant_time_compare(
127         _unsalt_cipher_token(request_csrf_token),
128         _unsalt_cipher_token(csrf_token),
129     )
130 
131 
132 class CsrfViewMiddleware(MiddlewareMixin):
133     """
134     Require a present and correct csrfmiddlewaretoken for POST requests that
135     have a CSRF cookie, and set an outgoing CSRF cookie.
136 
137     This middleware should be used in conjunction with the {% csrf_token %}
138     template tag.
139     """
140     # The _accept and _reject methods currently only exist for the sake of the
141     # requires_csrf_token decorator.
142     def _accept(self, request):
143         # Avoid checking the request twice by adding a custom attribute to
144         # request.  This will be relevant when both decorator and middleware
145         # are used.
146         request.csrf_processing_done = True
147         return None
148 
149     def _reject(self, request, reason):
150         response = _get_failure_view()(request, reason=reason)
151         log_response(
152             'Forbidden (%s): %s', reason, request.path,
153             response=response,
154             request=request,
155             logger=logger,
156         )
157         return response
158 
159     def _get_token(self, request):
160         if settings.CSRF_USE_SESSIONS:
161             try:
162                 return request.session.get(CSRF_SESSION_KEY)
163             except AttributeError:
164                 raise ImproperlyConfigured(
165                     'CSRF_USE_SESSIONS is enabled, but request.session is not '
166                     'set. SessionMiddleware must appear before CsrfViewMiddleware '
167                     'in MIDDLEWARE%s.' % ('_CLASSES' if settings.MIDDLEWARE is None else '')
168                 )
169         else:
170             try:
171                 cookie_token = request.COOKIES[settings.CSRF_COOKIE_NAME]
172             except KeyError:
173                 return None
174 
175             csrf_token = _sanitize_token(cookie_token)
176             if csrf_token != cookie_token:
177                 # Cookie token needed to be replaced;
178                 # the cookie needs to be reset.
179                 request.csrf_cookie_needs_reset = True
180             return csrf_token
181 
182     def _set_token(self, request, response):
183         if settings.CSRF_USE_SESSIONS:
184             if request.session.get(CSRF_SESSION_KEY) != request.META['CSRF_COOKIE']:
185                 request.session[CSRF_SESSION_KEY] = request.META['CSRF_COOKIE']
186         else:
187             response.set_cookie(
188                 settings.CSRF_COOKIE_NAME,
189                 request.META['CSRF_COOKIE'],
190                 max_age=settings.CSRF_COOKIE_AGE,
191                 domain=settings.CSRF_COOKIE_DOMAIN,
192                 path=settings.CSRF_COOKIE_PATH,
193                 secure=settings.CSRF_COOKIE_SECURE,
194                 httponly=settings.CSRF_COOKIE_HTTPONLY,
195                 samesite=settings.CSRF_COOKIE_SAMESITE,
196             )
197             # Set the Vary header since content varies with the CSRF cookie.
198             patch_vary_headers(response, ('Cookie',))
199 
200     def process_request(self, request):
201         csrf_token = self._get_token(request)
202         if csrf_token is not None:
203             # Use same token next time.
204             request.META['CSRF_COOKIE'] = csrf_token
205 
206     def process_view(self, request, callback, callback_args, callback_kwargs):
207         if getattr(request, 'csrf_processing_done', False):
208             return None
209 
210         # Wait until request.META["CSRF_COOKIE"] has been manipulated before
211         # bailing out, so that get_token still works
212         if getattr(callback, 'csrf_exempt', False):
213             return None
214 
215         # Assume that anything not defined as 'safe' by RFC7231 needs protection
216         if request.method not in ('GET', 'HEAD', 'OPTIONS', 'TRACE'):
217             if getattr(request, '_dont_enforce_csrf_checks', False):
218                 # Mechanism to turn off CSRF checks for test suite.
219                 # It comes after the creation of CSRF cookies, so that
220                 # everything else continues to work exactly the same
221                 # (e.g. cookies are sent, etc.), but before any
222                 # branches that call reject().
223                 return self._accept(request)
224 
225             if request.is_secure():
226                 # Suppose user visits http://example.com/
227                 # An active network attacker (man-in-the-middle, MITM) sends a
228                 # POST form that targets https://example.com/detonate-bomb/ and
229                 # submits it via JavaScript.
230                 #
231                 # The attacker will need to provide a CSRF cookie and token, but
232                 # that's no problem for a MITM and the session-independent
233                 # secret we're using. So the MITM can circumvent the CSRF
234                 # protection. This is true for any HTTP connection, but anyone
235                 # using HTTPS expects better! For this reason, for
236                 # https://example.com/ we need additional protection that treats
237                 # http://example.com/ as completely untrusted. Under HTTPS,
238                 # Barth et al. found that the Referer header is missing for
239                 # same-domain requests in only about 0.2% of cases or less, so
240                 # we can use strict Referer checking.
241                 referer = request.META.get('HTTP_REFERER')
242                 if referer is None:
243                     return self._reject(request, REASON_NO_REFERER)
244 
245                 referer = urlparse(referer)
246 
247                 # Make sure we have a valid URL for Referer.
248                 if '' in (referer.scheme, referer.netloc):
249                     return self._reject(request, REASON_MALFORMED_REFERER)
250 
251                 # Ensure that our Referer is also secure.
252                 if referer.scheme != 'https':
253                     return self._reject(request, REASON_INSECURE_REFERER)
254 
255                 # If there isn't a CSRF_COOKIE_DOMAIN, require an exact match
256                 # match on host:port. If not, obey the cookie rules (or those
257                 # for the session cookie, if CSRF_USE_SESSIONS).
258                 good_referer = (
259                     settings.SESSION_COOKIE_DOMAIN
260                     if settings.CSRF_USE_SESSIONS
261                     else settings.CSRF_COOKIE_DOMAIN
262                 )
263                 if good_referer is not None:
264                     server_port = request.get_port()
265                     if server_port not in ('443', '80'):
266                         good_referer = '%s:%s' % (good_referer, server_port)
267                 else:
268                     try:
269                         # request.get_host() includes the port.
270                         good_referer = request.get_host()
271                     except DisallowedHost:
272                         pass
273 
274                 # Create a list of all acceptable HTTP referers, including the
275                 # current host if it's permitted by ALLOWED_HOSTS.
276                 good_hosts = list(settings.CSRF_TRUSTED_ORIGINS)
277                 if good_referer is not None:
278                     good_hosts.append(good_referer)
279 
280                 if not any(is_same_domain(referer.netloc, host) for host in good_hosts):
281                     reason = REASON_BAD_REFERER % referer.geturl()
282                     return self._reject(request, reason)
283 
284             csrf_token = request.META.get('CSRF_COOKIE')
285             if csrf_token is None:
286                 # No CSRF cookie. For POST requests, we insist on a CSRF cookie,
287                 # and in this way we can avoid all CSRF attacks, including login
288                 # CSRF.
289                 return self._reject(request, REASON_NO_CSRF_COOKIE)
290 
291             # Check non-cookie token for match.
292             request_csrf_token = ""
293             if request.method == "POST":
294                 try:
295                     request_csrf_token = request.POST.get('csrfmiddlewaretoken', '')
296                 except IOError:
297                     # Handle a broken connection before we've completed reading
298                     # the POST data. process_view shouldn't raise any
299                     # exceptions, so we'll ignore and serve the user a 403
300                     # (assuming they're still listening, which they probably
301                     # aren't because of the error).
302                     pass
303 
304             if request_csrf_token == "":
305                 # Fall back to X-CSRFToken, to make things easier for AJAX,
306                 # and possible for PUT/DELETE.
307                 request_csrf_token = request.META.get(settings.CSRF_HEADER_NAME, '')
308 
309             request_csrf_token = _sanitize_token(request_csrf_token)
310             if not _compare_salted_tokens(request_csrf_token, csrf_token):
311                 return self._reject(request, REASON_BAD_TOKEN)
312 
313         return self._accept(request)
314 
315     def process_response(self, request, response):
316         if not getattr(request, 'csrf_cookie_needs_reset', False):
317             if getattr(response, 'csrf_cookie_set', False):
318                 return response
319 
320         if not request.META.get("CSRF_COOKIE_USED", False):
321             return response
322 
323         # Set the CSRF cookie even if it's already set, so we renew
324         # the expiry timer.
325         self._set_token(request, response)
326         response.csrf_cookie_set = True
327         return response

</code><intended_behavior>Replace IOError with OSError in exception handling to align with modern Python practices. Preserve logic for handling cases where I/O errors occur.</intended_behavior>, <file>django/http/response.py</file>
<class>None</class>
<method>None</method>
<code>
1 import datetime
2 import json
3 import mimetypes
4 import os
5 import re
6 import sys
7 import time
8 from email.header import Header
9 from http.client import responses
10 from urllib.parse import quote, urlparse
11 
12 from django.conf import settings
13 from django.core import signals, signing
14 from django.core.exceptions import DisallowedRedirect
15 from django.core.serializers.json import DjangoJSONEncoder
16 from django.http.cookie import SimpleCookie
17 from django.utils import timezone
18 from django.utils.encoding import iri_to_uri
19 from django.utils.http import http_date
20 
21 _charset_from_content_type_re = re.compile(r';\s*charset=(?P<charset>[^\s;]+)', re.I)
22 
23 
24 class BadHeaderError(ValueError):
25     pass
26 
27 
28 class HttpResponseBase:
29     """
30     An HTTP response base class with dictionary-accessed headers.
31 
32     This class doesn't handle content. It should not be used directly.
33     Use the HttpResponse and StreamingHttpResponse subclasses instead.
34     """
35 
36     status_code = 200
37 
38     def __init__(self, content_type=None, status=None, reason=None, charset=None):
39         # _headers is a mapping of the lowercase name to the original case of
40         # the header (required for working with legacy systems) and the header
41         # value. Both the name of the header and its value are ASCII strings.
42         self._headers = {}
43         self._closable_objects = []
44         # This parameter is set by the handler. It's necessary to preserve the
45         # historical behavior of request_finished.
46         self._handler_class = None
47         self.cookies = SimpleCookie()
48         self.closed = False
49         if status is not None:
50             try:
51                 self.status_code = int(status)
52             except (ValueError, TypeError):
53                 raise TypeError('HTTP status code must be an integer.')
54 
55             if not 100 <= self.status_code <= 599:
56                 raise ValueError('HTTP status code must be an integer from 100 to 599.')
57         self._reason_phrase = reason
58         self._charset = charset
59         if content_type is None:
60             content_type = 'text/html; charset=%s' % self.charset
61         self['Content-Type'] = content_type
62 
63     @property
64     def reason_phrase(self):
65         if self._reason_phrase is not None:
66             return self._reason_phrase
67         # Leave self._reason_phrase unset in order to use the default
68         # reason phrase for status code.
69         return responses.get(self.status_code, 'Unknown Status Code')
70 
71     @reason_phrase.setter
72     def reason_phrase(self, value):
73         self._reason_phrase = value
74 
75     @property
76     def charset(self):
77         if self._charset is not None:
78             return self._charset
79         content_type = self.get('Content-Type', '')
80         matched = _charset_from_content_type_re.search(content_type)
81         if matched:
82             # Extract the charset and strip its double quotes
83             return matched.group('charset').replace('"', '')
84         return settings.DEFAULT_CHARSET
85 
86     @charset.setter
87     def charset(self, value):
88         self._charset = value
89 
90     def serialize_headers(self):
91         """HTTP headers as a bytestring."""
92         def to_bytes(val, encoding):
93             return val if isinstance(val, bytes) else val.encode(encoding)
94 
95         headers = [
96             (to_bytes(key, 'ascii') + b': ' + to_bytes(value, 'latin-1'))
97             for key, value in self._headers.values()
98         ]
99         return b'\r\n'.join(headers)
100 
101     __bytes__ = serialize_headers
102 
103     @property
104     def _content_type_for_repr(self):
105         return ', "%s"' % self['Content-Type'] if 'Content-Type' in self else ''
106 
107     def _convert_to_charset(self, value, charset, mime_encode=False):
108         """
109         Convert headers key/value to ascii/latin-1 native strings.
110 
111         `charset` must be 'ascii' or 'latin-1'. If `mime_encode` is True and
112         `value` can't be represented in the given charset, apply MIME-encoding.
113         """
114         if not isinstance(value, (bytes, str)):
115             value = str(value)
116         if ((isinstance(value, bytes) and (b'\n' in value or b'\r' in value)) or
117                 isinstance(value, str) and ('\n' in value or '\r' in value)):
118             raise BadHeaderError("Header values can't contain newlines (got %r)" % value)
119         try:
120             if isinstance(value, str):
121                 # Ensure string is valid in given charset
122                 value.encode(charset)
123             else:
124                 # Convert bytestring using given charset
125                 value = value.decode(charset)
126         except UnicodeError as e:
127             if mime_encode:
128                 value = Header(value, 'utf-8', maxlinelen=sys.maxsize).encode()
129             else:
130                 e.reason += ', HTTP response headers must be in %s format' % charset
131                 raise
132         return value
133 
134     def __setitem__(self, header, value):
135         header = self._convert_to_charset(header, 'ascii')
136         value = self._convert_to_charset(value, 'latin-1', mime_encode=True)
137         self._headers[header.lower()] = (header, value)
138 
139     def __delitem__(self, header):
140         self._headers.pop(header.lower(), False)
141 
142     def __getitem__(self, header):
143         return self._headers[header.lower()][1]
144 
145     def has_header(self, header):
146         """Case-insensitive check for a header."""
147         return header.lower() in self._headers
148 
149     __contains__ = has_header
150 
151     def items(self):
152         return self._headers.values()
153 
154     def get(self, header, alternate=None):
155         return self._headers.get(header.lower(), (None, alternate))[1]
156 
157     def set_cookie(self, key, value='', max_age=None, expires=None, path='/',
158                    domain=None, secure=False, httponly=False, samesite=None):
159         """
160         Set a cookie.
161 
162         ``expires`` can be:
163         - a string in the correct format,
164         - a naive ``datetime.datetime`` object in UTC,
165         - an aware ``datetime.datetime`` object in any time zone.
166         If it is a ``datetime.datetime`` object then calculate ``max_age``.
167         """
168         self.cookies[key] = value
169         if expires is not None:
170             if isinstance(expires, datetime.datetime):
171                 if timezone.is_aware(expires):
172                     expires = timezone.make_naive(expires, timezone.utc)
173                 delta = expires - expires.utcnow()
174                 # Add one second so the date matches exactly (a fraction of
175                 # time gets lost between converting to a timedelta and
176                 # then the date string).
177                 delta = delta + datetime.timedelta(seconds=1)
178                 # Just set max_age - the max_age logic will set expires.
179                 expires = None
180                 max_age = max(0, delta.days * 86400 + delta.seconds)
181             else:
182                 self.cookies[key]['expires'] = expires
183         else:
184             self.cookies[key]['expires'] = ''
185         if max_age is not None:
186             self.cookies[key]['max-age'] = max_age
187             # IE requires expires, so set it if hasn't been already.
188             if not expires:
189                 self.cookies[key]['expires'] = http_date(time.time() + max_age)
190         if path is not None:
191             self.cookies[key]['path'] = path
192         if domain is not None:
193             self.cookies[key]['domain'] = domain
194         if secure:
195             self.cookies[key]['secure'] = True
196         if httponly:
197             self.cookies[key]['httponly'] = True
198         if samesite:
199             if samesite.lower() not in ('lax', 'strict'):
200                 raise ValueError('samesite must be "lax" or "strict".')
201             self.cookies[key]['samesite'] = samesite
202 
203     def setdefault(self, key, value):
204         """Set a header unless it has already been set."""
205         if key not in self:
206             self[key] = value
207 
208     def set_signed_cookie(self, key, value, salt='', **kwargs):
209         value = signing.get_cookie_signer(salt=key + salt).sign(value)
210         return self.set_cookie(key, value, **kwargs)
211 
212     def delete_cookie(self, key, path='/', domain=None):
213         # Most browsers ignore the Set-Cookie header if the cookie name starts
214         # with __Host- or __Secure- and the cookie doesn't use the secure flag.
215         secure = key.startswith(('__Secure-', '__Host-'))
216         self.set_cookie(
217             key, max_age=0, path=path, domain=domain, secure=secure,
218             expires='Thu, 01 Jan 1970 00:00:00 GMT',
219         )
220 
221     # Common methods used by subclasses
222 
223     def make_bytes(self, value):
224         """Turn a value into a bytestring encoded in the output charset."""
225         # Per PEP 3333, this response body must be bytes. To avoid returning
226         # an instance of a subclass, this function returns `bytes(value)`.
227         # This doesn't make a copy when `value` already contains bytes.
228 
229         # Handle string types -- we can't rely on force_bytes here because:
230         # - Python attempts str conversion first
231         # - when self._charset != 'utf-8' it re-encodes the content
232         if isinstance(value, bytes):
233             return bytes(value)
234         if isinstance(value, str):
235             return bytes(value.encode(self.charset))
236         # Handle non-string types.
237         return str(value).encode(self.charset)
238 
239     # These methods partially implement the file-like object interface.
240     # See https://docs.python.org/library/io.html#io.IOBase
241 
242     # The WSGI server must call this method upon completion of the request.
243     # See http://blog.dscpl.com.au/2012/10/obligations-for-calling-close-on.html
244     def close(self):
245         for closable in self._closable_objects:
246             try:
247                 closable.close()
248             except Exception:
249                 pass
250         self.closed = True
251         signals.request_finished.send(sender=self._handler_class)
252 
253     def write(self, content):
254         raise IOError("This %s instance is not writable" % self.__class__.__name__)
255 
256     def flush(self):
257         pass
258 
259     def tell(self):
260         raise IOError("This %s instance cannot tell its position" % self.__class__.__name__)
261 
262     # These methods partially implement a stream-like object interface.
263     # See https://docs.python.org/library/io.html#io.IOBase
264 
265     def readable(self):
266         return False
267 
268     def seekable(self):
269         return False
270 
271     def writable(self):
272         return False
273 
274     def writelines(self, lines):
275         raise IOError("This %s instance is not writable" % self.__class__.__name__)
276 
277 
278 class HttpResponse(HttpResponseBase):
279     """
280     An HTTP response class with a string as content.
281 
282     This content that can be read, appended to, or replaced.
283     """
284 
285     streaming = False
286 
287     def __init__(self, content=b'', *args, **kwargs):
288         super().__init__(*args, **kwargs)
289         # Content is a bytestring. See the `content` property methods.
290         self.content = content
291 
292     def __repr__(self):
293         return '<%(cls)s status_code=%(status_code)d%(content_type)s>' % {
294             'cls': self.__class__.__name__,
295             'status_code': self.status_code,
296             'content_type': self._content_type_for_repr,
297         }
298 
299     def serialize(self):
300         """Full HTTP message, including headers, as a bytestring."""
301         return self.serialize_headers() + b'\r\n\r\n' + self.content
302 
303     __bytes__ = serialize
304 
305     @property
306     def content(self):
307         return b''.join(self._container)
308 
309     @content.setter
310     def content(self, value):
311         # Consume iterators upon assignment to allow repeated iteration.
312         if hasattr(value, '__iter__') and not isinstance(value, (bytes, str)):
313             content = b''.join(self.make_bytes(chunk) for chunk in value)
314             if hasattr(value, 'close'):
315                 try:
316                     value.close()
317                 except Exception:
318                     pass
319         else:
320             content = self.make_bytes(value)
321         # Create a list of properly encoded bytestrings to support write().
322         self._container = [content]
323 
324     def __iter__(self):
325         return iter(self._container)
326 
327     def write(self, content):
328         self._container.append(self.make_bytes(content))
329 
330     def tell(self):
331         return len(self.content)
332 
333     def getvalue(self):
334         return self.content
335 
336     def writable(self):
337         return True
338 
339     def writelines(self, lines):
340         for line in lines:
341             self.write(line)
342 
343 
344 class StreamingHttpResponse(HttpResponseBase):
345     """
346     A streaming HTTP response class with an iterator as content.
347 
348     This should only be iterated once, when the response is streamed to the
349     client. However, it can be appended to or replaced with a new iterator
350     that wraps the original content (or yields entirely new content).
351     """
352 
353     streaming = True
354 
355     def __init__(self, streaming_content=(), *args, **kwargs):
356         super().__init__(*args, **kwargs)
357         # `streaming_content` should be an iterable of bytestrings.
358         # See the `streaming_content` property methods.
359         self.streaming_content = streaming_content
360 
361     @property
362     def content(self):
363         raise AttributeError(
364             "This %s instance has no `content` attribute. Use "
365             "`streaming_content` instead." % self.__class__.__name__
366         )
367 
368     @property
369     def streaming_content(self):
370         return map(self.make_bytes, self._iterator)
371 
372     @streaming_content.setter
373     def streaming_content(self, value):
374         self._set_streaming_content(value)
375 
376     def _set_streaming_content(self, value):
377         # Ensure we can never iterate on "value" more than once.
378         self._iterator = iter(value)
379         if hasattr(value, 'close'):
380             self._closable_objects.append(value)
381 
382     def __iter__(self):
383         return self.streaming_content
384 
385     def getvalue(self):
386         return b''.join(self.streaming_content)
387 
388 
389 class FileResponse(StreamingHttpResponse):
390     """
391     A streaming HTTP response class optimized for files.
392     """
393     block_size = 4096
394 
395     def __init__(self, *args, as_attachment=False, filename='', **kwargs):
396         self.as_attachment = as_attachment
397         self.filename = filename
398         super().__init__(*args, **kwargs)
399 
400     def _set_streaming_content(self, value):
401         if not hasattr(value, 'read'):
402             self.file_to_stream = None
403             return super()._set_streaming_content(value)
404 
405         self.file_to_stream = filelike = value
406         if hasattr(filelike, 'close'):
407             self._closable_objects.append(filelike)
408         value = iter(lambda: filelike.read(self.block_size), b'')
409         self.set_headers(filelike)
410         super()._set_streaming_content(value)
411 
412     def set_headers(self, filelike):
413         """
414         Set some common response headers (Content-Length, Content-Type, and
415         Content-Disposition) based on the `filelike` response content.
416         """
417         encoding_map = {
418             'bzip2': 'application/x-bzip',
419             'gzip': 'application/gzip',
420             'xz': 'application/x-xz',
421         }
422         filename = getattr(filelike, 'name', None)
423         filename = filename if (isinstance(filename, str) and filename) else self.filename
424         if os.path.isabs(filename):
425             self['Content-Length'] = os.path.getsize(filelike.name)
426         elif hasattr(filelike, 'getbuffer'):
427             self['Content-Length'] = filelike.getbuffer().nbytes
428 
429         if self.get('Content-Type', '').startswith('text/html'):
430             if filename:
431                 content_type, encoding = mimetypes.guess_type(filename)
432                 # Encoding isn't set to prevent browsers from automatically
433                 # uncompressing files.
434                 content_type = encoding_map.get(encoding, content_type)
435                 self['Content-Type'] = content_type or 'application/octet-stream'
436             else:
437                 self['Content-Type'] = 'application/octet-stream'
438 
439         if self.as_attachment:
440             filename = self.filename or os.path.basename(filename)
441             if filename:
442                 try:
443                     filename.encode('ascii')
444                     file_expr = 'filename="{}"'.format(filename)
445                 except UnicodeEncodeError:
446                     file_expr = "filename*=utf-8''{}".format(quote(filename))
447                 self['Content-Disposition'] = 'attachment; {}'.format(file_expr)
448 
449 
450 class HttpResponseRedirectBase(HttpResponse):
451     allowed_schemes = ['http', 'https', 'ftp']
452 
453     def __init__(self, redirect_to, *args, **kwargs):
454         super().__init__(*args, **kwargs)
455         self['Location'] = iri_to_uri(redirect_to)
456         parsed = urlparse(str(redirect_to))
457         if parsed.scheme and parsed.scheme not in self.allowed_schemes:
458             raise DisallowedRedirect("Unsafe redirect to URL with protocol '%s'" % parsed.scheme)
459 
460     url = property(lambda self: self['Location'])
461 
462     def __repr__(self):
463         return '<%(cls)s status_code=%(status_code)d%(content_type)s, url="%(url)s">' % {
464             'cls': self.__class__.__name__,
465             'status_code': self.status_code,
466             'content_type': self._content_type_for_repr,
467             'url': self.url,
468         }
469 
470 
471 class HttpResponseRedirect(HttpResponseRedirectBase):
472     status_code = 302
473 
474 
475 class HttpResponsePermanentRedirect(HttpResponseRedirectBase):
476     status_code = 301
477 
478 
479 class HttpResponseNotModified(HttpResponse):
480     status_code = 304
481 
482     def __init__(self, *args, **kwargs):
483         super().__init__(*args, **kwargs)
484         del self['content-type']
485 
486     @HttpResponse.content.setter
487     def content(self, value):
488         if value:
489             raise AttributeError("You cannot set content to a 304 (Not Modified) response")
490         self._container = []
491 
492 
493 class HttpResponseBadRequest(HttpResponse):
494     status_code = 400
495 
496 
497 class HttpResponseNotFound(HttpResponse):
498     status_code = 404
499 
500 
501 class HttpResponseForbidden(HttpResponse):
502     status_code = 403
503 
504 
505 class HttpResponseNotAllowed(HttpResponse):
506     status_code = 405
507 
508     def __init__(self, permitted_methods, *args, **kwargs):
509         super().__init__(*args, **kwargs)
510         self['Allow'] = ', '.join(permitted_methods)
511 
512     def __repr__(self):
513         return '<%(cls)s [%(methods)s] status_code=%(status_code)d%(content_type)s>' % {
514             'cls': self.__class__.__name__,
515             'status_code': self.status_code,
516             'content_type': self._content_type_for_repr,
517             'methods': self['Allow'],
518         }
519 
520 
521 class HttpResponseGone(HttpResponse):
522     status_code = 410
523 
524 
525 class HttpResponseServerError(HttpResponse):
526     status_code = 500
527 
528 
529 class Http404(Exception):
530     pass
531 
532 
533 class JsonResponse(HttpResponse):
534     """
535     An HTTP response class that consumes data to be serialized to JSON.
536 
537     :param data: Data to be dumped into json. By default only ``dict`` objects
538       are allowed to be passed due to a security flaw before EcmaScript 5. See
539       the ``safe`` parameter for more information.
540     :param encoder: Should be a json encoder class. Defaults to
541       ``django.core.serializers.json.DjangoJSONEncoder``.
542     :param safe: Controls if only ``dict`` objects may be serialized. Defaults
543       to ``True``.
544     :param json_dumps_params: A dictionary of kwargs passed to json.dumps().
545     """
546 
547     def __init__(self, data, encoder=DjangoJSONEncoder, safe=True,
548                  json_dumps_params=None, **kwargs):
549         if safe and not isinstance(data, dict):
550             raise TypeError(
551                 'In order to allow non-dict objects to be serialized set the '
552                 'safe parameter to False.'
553             )
554         if json_dumps_params is None:
555             json_dumps_params = {}
556         kwargs.setdefault('content_type', 'application/json')
557         data = json.dumps(data, cls=encoder, **json_dumps_params)
558         super().__init__(content=data, **kwargs)

</code><intended_behavior>Update exception handling to use OSError instead of IOError, ensuring responses continue to gracefully handle file-related errors during processing.</intended_behavior>, <file>django/http/request.py</file>
<class>None</class>
<method>None</method>
<code>
1 import copy
2 import re
3 from io import BytesIO
4 from itertools import chain
5 from urllib.parse import quote, urlencode, urljoin, urlsplit
6 
7 from django.conf import settings
8 from django.core import signing
9 from django.core.exceptions import (
10     DisallowedHost, ImproperlyConfigured, RequestDataTooBig,
11 )
12 from django.core.files import uploadhandler
13 from django.http.multipartparser import MultiPartParser, MultiPartParserError
14 from django.utils.datastructures import (
15     CaseInsensitiveMapping, ImmutableList, MultiValueDict,
16 )
17 from django.utils.encoding import escape_uri_path, iri_to_uri
18 from django.utils.functional import cached_property
19 from django.utils.http import is_same_domain, limited_parse_qsl
20 
21 RAISE_ERROR = object()
22 host_validation_re = re.compile(r"^([a-z0-9.-]+|\[[a-f0-9]*:[a-f0-9\.:]+\])(:\d+)?$")
23 
24 
25 class UnreadablePostError(IOError):
26     pass
27 
28 
29 class RawPostDataException(Exception):
30     """
31     You cannot access raw_post_data from a request that has
32     multipart/* POST data if it has been accessed via POST,
33     FILES, etc..
34     """
35     pass
36 
37 
38 class HttpRequest:
39     """A basic HTTP request."""
40 
41     # The encoding used in GET/POST dicts. None means use default setting.
42     _encoding = None
43     _upload_handlers = []
44 
45     def __init__(self):
46         # WARNING: The `WSGIRequest` subclass doesn't call `super`.
47         # Any variable assignment made here should also happen in
48         # `WSGIRequest.__init__()`.
49 
50         self.GET = QueryDict(mutable=True)
51         self.POST = QueryDict(mutable=True)
52         self.COOKIES = {}
53         self.META = {}
54         self.FILES = MultiValueDict()
55 
56         self.path = ''
57         self.path_info = ''
58         self.method = None
59         self.resolver_match = None
60         self.content_type = None
61         self.content_params = None
62 
63     def __repr__(self):
64         if self.method is None or not self.get_full_path():
65             return '<%s>' % self.__class__.__name__
66         return '<%s: %s %r>' % (self.__class__.__name__, self.method, self.get_full_path())
67 
68     @cached_property
69     def headers(self):
70         return HttpHeaders(self.META)
71 
72     def _get_raw_host(self):
73         """
74         Return the HTTP host using the environment or request headers. Skip
75         allowed hosts protection, so may return an insecure host.
76         """
77         # We try three options, in order of decreasing preference.
78         if settings.USE_X_FORWARDED_HOST and (
79                 'HTTP_X_FORWARDED_HOST' in self.META):
80             host = self.META['HTTP_X_FORWARDED_HOST']
81         elif 'HTTP_HOST' in self.META:
82             host = self.META['HTTP_HOST']
83         else:
84             # Reconstruct the host using the algorithm from PEP 333.
85             host = self.META['SERVER_NAME']
86             server_port = self.get_port()
87             if server_port != ('443' if self.is_secure() else '80'):
88                 host = '%s:%s' % (host, server_port)
89         return host
90 
91     def get_host(self):
92         """Return the HTTP host using the environment or request headers."""
93         host = self._get_raw_host()
94 
95         # Allow variants of localhost if ALLOWED_HOSTS is empty and DEBUG=True.
96         allowed_hosts = settings.ALLOWED_HOSTS
97         if settings.DEBUG and not allowed_hosts:
98             allowed_hosts = ['localhost', '127.0.0.1', '[::1]']
99 
100         domain, port = split_domain_port(host)
101         if domain and validate_host(domain, allowed_hosts):
102             return host
103         else:
104             msg = "Invalid HTTP_HOST header: %r." % host
105             if domain:
106                 msg += " You may need to add %r to ALLOWED_HOSTS." % domain
107             else:
108                 msg += " The domain name provided is not valid according to RFC 1034/1035."
109             raise DisallowedHost(msg)
110 
111     def get_port(self):
112         """Return the port number for the request as a string."""
113         if settings.USE_X_FORWARDED_PORT and 'HTTP_X_FORWARDED_PORT' in self.META:
114             port = self.META['HTTP_X_FORWARDED_PORT']
115         else:
116             port = self.META['SERVER_PORT']
117         return str(port)
118 
119     def get_full_path(self, force_append_slash=False):
120         return self._get_full_path(self.path, force_append_slash)
121 
122     def get_full_path_info(self, force_append_slash=False):
123         return self._get_full_path(self.path_info, force_append_slash)
124 
125     def _get_full_path(self, path, force_append_slash):
126         # RFC 3986 requires query string arguments to be in the ASCII range.
127         # Rather than crash if this doesn't happen, we encode defensively.
128         return '%s%s%s' % (
129             escape_uri_path(path),
130             '/' if force_append_slash and not path.endswith('/') else '',
131             ('?' + iri_to_uri(self.META.get('QUERY_STRING', ''))) if self.META.get('QUERY_STRING', '') else ''
132         )
133 
134     def get_signed_cookie(self, key, default=RAISE_ERROR, salt='', max_age=None):
135         """
136         Attempt to return a signed cookie. If the signature fails or the
137         cookie has expired, raise an exception, unless the `default` argument
138         is provided,  in which case return that value.
139         """
140         try:
141             cookie_value = self.COOKIES[key]
142         except KeyError:
143             if default is not RAISE_ERROR:
144                 return default
145             else:
146                 raise
147         try:
148             value = signing.get_cookie_signer(salt=key + salt).unsign(
149                 cookie_value, max_age=max_age)
150         except signing.BadSignature:
151             if default is not RAISE_ERROR:
152                 return default
153             else:
154                 raise
155         return value
156 
157     def get_raw_uri(self):
158         """
159         Return an absolute URI from variables available in this request. Skip
160         allowed hosts protection, so may return insecure URI.
161         """
162         return '{scheme}://{host}{path}'.format(
163             scheme=self.scheme,
164             host=self._get_raw_host(),
165             path=self.get_full_path(),
166         )
167 
168     def build_absolute_uri(self, location=None):
169         """
170         Build an absolute URI from the location and the variables available in
171         this request. If no ``location`` is specified, build the absolute URI
172         using request.get_full_path(). If the location is absolute, convert it
173         to an RFC 3987 compliant URI and return it. If location is relative or
174         is scheme-relative (i.e., ``//example.com/``), urljoin() it to a base
175         URL constructed from the request variables.
176         """
177         if location is None:
178             # Make it an absolute url (but schemeless and domainless) for the
179             # edge case that the path starts with '//'.
180             location = '//%s' % self.get_full_path()
181         bits = urlsplit(location)
182         if not (bits.scheme and bits.netloc):
183             # Handle the simple, most common case. If the location is absolute
184             # and a scheme or host (netloc) isn't provided, skip an expensive
185             # urljoin() as long as no path segments are '.' or '..'.
186             if (bits.path.startswith('/') and not bits.scheme and not bits.netloc and
187                     '/./' not in bits.path and '/../' not in bits.path):
188                 # If location starts with '//' but has no netloc, reuse the
189                 # schema and netloc from the current request. Strip the double
190                 # slashes and continue as if it wasn't specified.
191                 if location.startswith('//'):
192                     location = location[2:]
193                 location = self._current_scheme_host + location
194             else:
195                 # Join the constructed URL with the provided location, which
196                 # allows the provided location to apply query strings to the
197                 # base path.
198                 location = urljoin(self._current_scheme_host + self.path, location)
199         return iri_to_uri(location)
200 
201     @cached_property
202     def _current_scheme_host(self):
203         return '{}://{}'.format(self.scheme, self.get_host())
204 
205     def _get_scheme(self):
206         """
207         Hook for subclasses like WSGIRequest to implement. Return 'http' by
208         default.
209         """
210         return 'http'
211 
212     @property
213     def scheme(self):
214         if settings.SECURE_PROXY_SSL_HEADER:
215             try:
216                 header, value = settings.SECURE_PROXY_SSL_HEADER
217             except ValueError:
218                 raise ImproperlyConfigured(
219                     'The SECURE_PROXY_SSL_HEADER setting must be a tuple containing two values.'
220                 )
221             if self.META.get(header) == value:
222                 return 'https'
223         return self._get_scheme()
224 
225     def is_secure(self):
226         return self.scheme == 'https'
227 
228     def is_ajax(self):
229         return self.META.get('HTTP_X_REQUESTED_WITH') == 'XMLHttpRequest'
230 
231     @property
232     def encoding(self):
233         return self._encoding
234 
235     @encoding.setter
236     def encoding(self, val):
237         """
238         Set the encoding used for GET/POST accesses. If the GET or POST
239         dictionary has already been created, remove and recreate it on the
240         next access (so that it is decoded correctly).
241         """
242         self._encoding = val
243         if hasattr(self, 'GET'):
244             del self.GET
245         if hasattr(self, '_post'):
246             del self._post
247 
248     def _initialize_handlers(self):
249         self._upload_handlers = [uploadhandler.load_handler(handler, self)
250                                  for handler in settings.FILE_UPLOAD_HANDLERS]
251 
252     @property
253     def upload_handlers(self):
254         if not self._upload_handlers:
255             # If there are no upload handlers defined, initialize them from settings.
256             self._initialize_handlers()
257         return self._upload_handlers
258 
259     @upload_handlers.setter
260     def upload_handlers(self, upload_handlers):
261         if hasattr(self, '_files'):
262             raise AttributeError("You cannot set the upload handlers after the upload has been processed.")
263         self._upload_handlers = upload_handlers
264 
265     def parse_file_upload(self, META, post_data):
266         """Return a tuple of (POST QueryDict, FILES MultiValueDict)."""
267         self.upload_handlers = ImmutableList(
268             self.upload_handlers,
269             warning="You cannot alter upload handlers after the upload has been processed."
270         )
271         parser = MultiPartParser(META, post_data, self.upload_handlers, self.encoding)
272         return parser.parse()
273 
274     @property
275     def body(self):
276         if not hasattr(self, '_body'):
277             if self._read_started:
278                 raise RawPostDataException("You cannot access body after reading from request's data stream")
279 
280             # Limit the maximum request data size that will be handled in-memory.
281             if (settings.DATA_UPLOAD_MAX_MEMORY_SIZE is not None and
282                     int(self.META.get('CONTENT_LENGTH') or 0) > settings.DATA_UPLOAD_MAX_MEMORY_SIZE):
283                 raise RequestDataTooBig('Request body exceeded settings.DATA_UPLOAD_MAX_MEMORY_SIZE.')
284 
285             try:
286                 self._body = self.read()
287             except IOError as e:
288                 raise UnreadablePostError(*e.args) from e
289             self._stream = BytesIO(self._body)
290         return self._body
291 
292     def _mark_post_parse_error(self):
293         self._post = QueryDict()
294         self._files = MultiValueDict()
295 
296     def _load_post_and_files(self):
297         """Populate self._post and self._files if the content-type is a form type"""
298         if self.method != 'POST':
299             self._post, self._files = QueryDict(encoding=self._encoding), MultiValueDict()
300             return
301         if self._read_started and not hasattr(self, '_body'):
302             self._mark_post_parse_error()
303             return
304 
305         if self.content_type == 'multipart/form-data':
306             if hasattr(self, '_body'):
307                 # Use already read data
308                 data = BytesIO(self._body)
309             else:
310                 data = self
311             try:
312                 self._post, self._files = self.parse_file_upload(self.META, data)
313             except MultiPartParserError:
314                 # An error occurred while parsing POST data. Since when
315                 # formatting the error the request handler might access
316                 # self.POST, set self._post and self._file to prevent
317                 # attempts to parse POST data again.
318                 self._mark_post_parse_error()
319                 raise
320         elif self.content_type == 'application/x-www-form-urlencoded':
321             self._post, self._files = QueryDict(self.body, encoding=self._encoding), MultiValueDict()
322         else:
323             self._post, self._files = QueryDict(encoding=self._encoding), MultiValueDict()
324 
325     def close(self):
326         if hasattr(self, '_files'):
327             for f in chain.from_iterable(l[1] for l in self._files.lists()):
328                 f.close()
329 
330     # File-like and iterator interface.
331     #
332     # Expects self._stream to be set to an appropriate source of bytes by
333     # a corresponding request subclass (e.g. WSGIRequest).
334     # Also when request data has already been read by request.POST or
335     # request.body, self._stream points to a BytesIO instance
336     # containing that data.
337 
338     def read(self, *args, **kwargs):
339         self._read_started = True
340         try:
341             return self._stream.read(*args, **kwargs)
342         except IOError as e:
343             raise UnreadablePostError(*e.args) from e
344 
345     def readline(self, *args, **kwargs):
346         self._read_started = True
347         try:
348             return self._stream.readline(*args, **kwargs)
349         except IOError as e:
350             raise UnreadablePostError(*e.args) from e
351 
352     def __iter__(self):
353         return iter(self.readline, b'')
354 
355     def readlines(self):
356         return list(self)
357 
358 
359 class HttpHeaders(CaseInsensitiveMapping):
360     HTTP_PREFIX = 'HTTP_'
361     # PEP 333 gives two headers which aren't prepended with HTTP_.
362     UNPREFIXED_HEADERS = {'CONTENT_TYPE', 'CONTENT_LENGTH'}
363 
364     def __init__(self, environ):
365         headers = {}
366         for header, value in environ.items():
367             name = self.parse_header_name(header)
368             if name:
369                 headers[name] = value
370         super().__init__(headers)
371 
372     @classmethod
373     def parse_header_name(cls, header):
374         if header.startswith(cls.HTTP_PREFIX):
375             header = header[len(cls.HTTP_PREFIX):]
376         elif header not in cls.UNPREFIXED_HEADERS:
377             return None
378         return header.replace('_', '-').title()
379 
380 
381 class QueryDict(MultiValueDict):
382     """
383     A specialized MultiValueDict which represents a query string.
384 
385     A QueryDict can be used to represent GET or POST data. It subclasses
386     MultiValueDict since keys in such data can be repeated, for instance
387     in the data from a form with a <select multiple> field.
388 
389     By default QueryDicts are immutable, though the copy() method
390     will always return a mutable copy.
391 
392     Both keys and values set on this class are converted from the given encoding
393     (DEFAULT_CHARSET by default) to str.
394     """
395 
396     # These are both reset in __init__, but is specified here at the class
397     # level so that unpickling will have valid values
398     _mutable = True
399     _encoding = None
400 
401     def __init__(self, query_string=None, mutable=False, encoding=None):
402         super().__init__()
403         self.encoding = encoding or settings.DEFAULT_CHARSET
404         query_string = query_string or ''
405         parse_qsl_kwargs = {
406             'keep_blank_values': True,
407             'fields_limit': settings.DATA_UPLOAD_MAX_NUMBER_FIELDS,
408             'encoding': self.encoding,
409         }
410         if isinstance(query_string, bytes):
411             # query_string normally contains URL-encoded data, a subset of ASCII.
412             try:
413                 query_string = query_string.decode(self.encoding)
414             except UnicodeDecodeError:
415                 # ... but some user agents are misbehaving :-(
416                 query_string = query_string.decode('iso-8859-1')
417         for key, value in limited_parse_qsl(query_string, **parse_qsl_kwargs):
418             self.appendlist(key, value)
419         self._mutable = mutable
420 
421     @classmethod
422     def fromkeys(cls, iterable, value='', mutable=False, encoding=None):
423         """
424         Return a new QueryDict with keys (may be repeated) from an iterable and
425         values from value.
426         """
427         q = cls('', mutable=True, encoding=encoding)
428         for key in iterable:
429             q.appendlist(key, value)
430         if not mutable:
431             q._mutable = False
432         return q
433 
434     @property
435     def encoding(self):
436         if self._encoding is None:
437             self._encoding = settings.DEFAULT_CHARSET
438         return self._encoding
439 
440     @encoding.setter
441     def encoding(self, value):
442         self._encoding = value
443 
444     def _assert_mutable(self):
445         if not self._mutable:
446             raise AttributeError("This QueryDict instance is immutable")
447 
448     def __setitem__(self, key, value):
449         self._assert_mutable()
450         key = bytes_to_text(key, self.encoding)
451         value = bytes_to_text(value, self.encoding)
452         super().__setitem__(key, value)
453 
454     def __delitem__(self, key):
455         self._assert_mutable()
456         super().__delitem__(key)
457 
458     def __copy__(self):
459         result = self.__class__('', mutable=True, encoding=self.encoding)
460         for key, value in self.lists():
461             result.setlist(key, value)
462         return result
463 
464     def __deepcopy__(self, memo):
465         result = self.__class__('', mutable=True, encoding=self.encoding)
466         memo[id(self)] = result
467         for key, value in self.lists():
468             result.setlist(copy.deepcopy(key, memo), copy.deepcopy(value, memo))
469         return result
470 
471     def setlist(self, key, list_):
472         self._assert_mutable()
473         key = bytes_to_text(key, self.encoding)
474         list_ = [bytes_to_text(elt, self.encoding) for elt in list_]
475         super().setlist(key, list_)
476 
477     def setlistdefault(self, key, default_list=None):
478         self._assert_mutable()
479         return super().setlistdefault(key, default_list)
480 
481     def appendlist(self, key, value):
482         self._assert_mutable()
483         key = bytes_to_text(key, self.encoding)
484         value = bytes_to_text(value, self.encoding)
485         super().appendlist(key, value)
486 
487     def pop(self, key, *args):
488         self._assert_mutable()
489         return super().pop(key, *args)
490 
491     def popitem(self):
492         self._assert_mutable()
493         return super().popitem()
494 
495     def clear(self):
496         self._assert_mutable()
497         super().clear()
498 
499     def setdefault(self, key, default=None):
500         self._assert_mutable()
501         key = bytes_to_text(key, self.encoding)
502         default = bytes_to_text(default, self.encoding)
503         return super().setdefault(key, default)
504 
505     def copy(self):
506         """Return a mutable copy of this object."""
507         return self.__deepcopy__({})
508 
509     def urlencode(self, safe=None):
510         """
511         Return an encoded string of all query string arguments.
512 
513         `safe` specifies characters which don't require quoting, for example::
514 
515             >>> q = QueryDict(mutable=True)
516             >>> q['next'] = '/a&b/'
517             >>> q.urlencode()
518             'next=%2Fa%26b%2F'
519             >>> q.urlencode(safe='/')
520             'next=/a%26b/'
521         """
522         output = []
523         if safe:
524             safe = safe.encode(self.encoding)
525 
526             def encode(k, v):
527                 return '%s=%s' % ((quote(k, safe), quote(v, safe)))
528         else:
529             def encode(k, v):
530                 return urlencode({k: v})
531         for k, list_ in self.lists():
532             output.extend(
533                 encode(k.encode(self.encoding), str(v).encode(self.encoding))
534                 for v in list_
535             )
536         return '&'.join(output)
537 
538 
539 # It's neither necessary nor appropriate to use
540 # django.utils.encoding.force_text for parsing URLs and form inputs. Thus,
541 # this slightly more restricted function, used by QueryDict.
542 def bytes_to_text(s, encoding):
543     """
544     Convert bytes objects to strings, using the given encoding. Illegally
545     encoded input characters are replaced with Unicode "unknown" codepoint
546     (\ufffd).
547 
548     Return any non-bytes objects without change.
549     """
550     if isinstance(s, bytes):
551         return str(s, encoding, 'replace')
552     else:
553         return s
554 
555 
556 def split_domain_port(host):
557     """
558     Return a (domain, port) tuple from a given host.
559 
560     Returned domain is lowercased. If the host is invalid, the domain will be
561     empty.
562     """
563     host = host.lower()
564 
565     if not host_validation_re.match(host):
566         return '', ''
567 
568     if host[-1] == ']':
569         # It's an IPv6 address without a port.
570         return host, ''
571     bits = host.rsplit(':', 1)
572     domain, port = bits if len(bits) == 2 else (bits[0], '')
573     # Remove a trailing dot (if present) from the domain.
574     domain = domain[:-1] if domain.endswith('.') else domain
575     return domain, port
576 
577 
578 def validate_host(host, allowed_hosts):
579     """
580     Validate the given host for this site.
581 
582     Check that the host looks valid and matches a host or host pattern in the
583     given list of ``allowed_hosts``. Any pattern beginning with a period
584     matches a domain and all its subdomains (e.g. ``.example.com`` matches
585     ``example.com`` and any subdomain), ``*`` matches anything, and anything
586     else must match exactly.
587 
588     Note: This function assumes that the given host is lowercased and has
589     already had the port, if any, stripped off.
590 
591     Return ``True`` for a valid host, ``False`` otherwise.
592     """
593     return any(pattern == '*' or is_same_domain(host, pattern) for pattern in allowed_hosts)

</code><intended_behavior>Swap IOError for OSError in file upload and reading operations, maintaining robustness in request handling.</intended_behavior>, <file>django/utils/translation/trans_real.py</file>
<class>None</class>
<method>None</method>
<code>
1 """Translation helper functions."""
2 import functools
3 import gettext as gettext_module
4 import os
5 import re
6 import sys
7 import warnings
8 from collections import OrderedDict
9 from threading import local
10 
11 from django.apps import apps
12 from django.conf import settings
13 from django.conf.locale import LANG_INFO
14 from django.core.exceptions import AppRegistryNotReady
15 from django.core.signals import setting_changed
16 from django.dispatch import receiver
17 from django.utils.safestring import SafeData, mark_safe
18 
19 from . import LANGUAGE_SESSION_KEY, to_language, to_locale
20 
21 # Translations are cached in a dictionary for every language.
22 # The active translations are stored by threadid to make them thread local.
23 _translations = {}
24 _active = local()
25 
26 # The default translation is based on the settings file.
27 _default = None
28 
29 # magic gettext number to separate context from message
30 CONTEXT_SEPARATOR = "\x04"
31 
32 # Format of Accept-Language header values. From RFC 2616, section 14.4 and 3.9
33 # and RFC 3066, section 2.1
34 accept_language_re = re.compile(r'''
35         ([A-Za-z]{1,8}(?:-[A-Za-z0-9]{1,8})*|\*)      # "en", "en-au", "x-y-z", "es-419", "*"
36         (?:\s*;\s*q=(0(?:\.\d{,3})?|1(?:\.0{,3})?))?  # Optional "q=1.00", "q=0.8"
37         (?:\s*,\s*|$)                                 # Multiple accepts per header.
38         ''', re.VERBOSE)
39 
40 language_code_re = re.compile(
41     r'^[a-z]{1,8}(?:-[a-z0-9]{1,8})*(?:@[a-z0-9]{1,20})?$',
42     re.IGNORECASE
43 )
44 
45 language_code_prefix_re = re.compile(r'^/(\w+([@-]\w+)?)(/|$)')
46 
47 
48 @receiver(setting_changed)
49 def reset_cache(**kwargs):
50     """
51     Reset global state when LANGUAGES setting has been changed, as some
52     languages should no longer be accepted.
53     """
54     if kwargs['setting'] in ('LANGUAGES', 'LANGUAGE_CODE'):
55         check_for_language.cache_clear()
56         get_languages.cache_clear()
57         get_supported_language_variant.cache_clear()
58 
59 
60 class DjangoTranslation(gettext_module.GNUTranslations):
61     """
62     Set up the GNUTranslations context with regard to output charset.
63 
64     This translation object will be constructed out of multiple GNUTranslations
65     objects by merging their catalogs. It will construct an object for the
66     requested language and add a fallback to the default language, if it's
67     different from the requested language.
68     """
69     domain = 'django'
70 
71     def __init__(self, language, domain=None, localedirs=None):
72         """Create a GNUTranslations() using many locale directories"""
73         gettext_module.GNUTranslations.__init__(self)
74         if domain is not None:
75             self.domain = domain
76 
77         self.__language = language
78         self.__to_language = to_language(language)
79         self.__locale = to_locale(language)
80         self._catalog = None
81         # If a language doesn't have a catalog, use the Germanic default for
82         # pluralization: anything except one is pluralized.
83         self.plural = lambda n: int(n != 1)
84 
85         if self.domain == 'django':
86             if localedirs is not None:
87                 # A module-level cache is used for caching 'django' translations
88                 warnings.warn("localedirs is ignored when domain is 'django'.", RuntimeWarning)
89                 localedirs = None
90             self._init_translation_catalog()
91 
92         if localedirs:
93             for localedir in localedirs:
94                 translation = self._new_gnu_trans(localedir)
95                 self.merge(translation)
96         else:
97             self._add_installed_apps_translations()
98 
99         self._add_local_translations()
100         if self.__language == settings.LANGUAGE_CODE and self.domain == 'django' and self._catalog is None:
101             # default lang should have at least one translation file available.
102             raise IOError("No translation files found for default language %s." % settings.LANGUAGE_CODE)
103         self._add_fallback(localedirs)
104         if self._catalog is None:
105             # No catalogs found for this language, set an empty catalog.
106             self._catalog = {}
107 
108     def __repr__(self):
109         return "<DjangoTranslation lang:%s>" % self.__language
110 
111     def _new_gnu_trans(self, localedir, use_null_fallback=True):
112         """
113         Return a mergeable gettext.GNUTranslations instance.
114 
115         A convenience wrapper. By default gettext uses 'fallback=False'.
116         Using param `use_null_fallback` to avoid confusion with any other
117         references to 'fallback'.
118         """
119         return gettext_module.translation(
120             domain=self.domain,
121             localedir=localedir,
122             languages=[self.__locale],
123             fallback=use_null_fallback,
124         )
125 
126     def _init_translation_catalog(self):
127         """Create a base catalog using global django translations."""
128         settingsfile = sys.modules[settings.__module__].__file__
129         localedir = os.path.join(os.path.dirname(settingsfile), 'locale')
130         translation = self._new_gnu_trans(localedir)
131         self.merge(translation)
132 
133     def _add_installed_apps_translations(self):
134         """Merge translations from each installed app."""
135         try:
136             app_configs = reversed(list(apps.get_app_configs()))
137         except AppRegistryNotReady:
138             raise AppRegistryNotReady(
139                 "The translation infrastructure cannot be initialized before the "
140                 "apps registry is ready. Check that you don't make non-lazy "
141                 "gettext calls at import time.")
142         for app_config in app_configs:
143             localedir = os.path.join(app_config.path, 'locale')
144             if os.path.exists(localedir):
145                 translation = self._new_gnu_trans(localedir)
146                 self.merge(translation)
147 
148     def _add_local_translations(self):
149         """Merge translations defined in LOCALE_PATHS."""
150         for localedir in reversed(settings.LOCALE_PATHS):
151             translation = self._new_gnu_trans(localedir)
152             self.merge(translation)
153 
154     def _add_fallback(self, localedirs=None):
155         """Set the GNUTranslations() fallback with the default language."""
156         # Don't set a fallback for the default language or any English variant
157         # (as it's empty, so it'll ALWAYS fall back to the default language)
158         if self.__language == settings.LANGUAGE_CODE or self.__language.startswith('en'):
159             return
160         if self.domain == 'django':
161             # Get from cache
162             default_translation = translation(settings.LANGUAGE_CODE)
163         else:
164             default_translation = DjangoTranslation(
165                 settings.LANGUAGE_CODE, domain=self.domain, localedirs=localedirs
166             )
167         self.add_fallback(default_translation)
168 
169     def merge(self, other):
170         """Merge another translation into this catalog."""
171         if not getattr(other, '_catalog', None):
172             return  # NullTranslations() has no _catalog
173         if self._catalog is None:
174             # Take plural and _info from first catalog found (generally Django's).
175             self.plural = other.plural
176             self._info = other._info.copy()
177             self._catalog = other._catalog.copy()
178         else:
179             self._catalog.update(other._catalog)
180         if other._fallback:
181             self.add_fallback(other._fallback)
182 
183     def language(self):
184         """Return the translation language."""
185         return self.__language
186 
187     def to_language(self):
188         """Return the translation language name."""
189         return self.__to_language
190 
191 
192 def translation(language):
193     """
194     Return a translation object in the default 'django' domain.
195     """
196     global _translations
197     if language not in _translations:
198         _translations[language] = DjangoTranslation(language)
199     return _translations[language]
200 
201 
202 def activate(language):
203     """
204     Fetch the translation object for a given language and install it as the
205     current translation object for the current thread.
206     """
207     if not language:
208         return
209     _active.value = translation(language)
210 
211 
212 def deactivate():
213     """
214     Uninstall the active translation object so that further _() calls resolve
215     to the default translation object.
216     """
217     if hasattr(_active, "value"):
218         del _active.value
219 
220 
221 def deactivate_all():
222     """
223     Make the active translation object a NullTranslations() instance. This is
224     useful when we want delayed translations to appear as the original string
225     for some reason.
226     """
227     _active.value = gettext_module.NullTranslations()
228     _active.value.to_language = lambda *args: None
229 
230 
231 def get_language():
232     """Return the currently selected language."""
233     t = getattr(_active, "value", None)
234     if t is not None:
235         try:
236             return t.to_language()
237         except AttributeError:
238             pass
239     # If we don't have a real translation object, assume it's the default language.
240     return settings.LANGUAGE_CODE
241 
242 
243 def get_language_bidi():
244     """
245     Return selected language's BiDi layout.
246 
247     * False = left-to-right layout
248     * True = right-to-left layout
249     """
250     lang = get_language()
251     if lang is None:
252         return False
253     else:
254         base_lang = get_language().split('-')[0]
255         return base_lang in settings.LANGUAGES_BIDI
256 
257 
258 def catalog():
259     """
260     Return the current active catalog for further processing.
261     This can be used if you need to modify the catalog or want to access the
262     whole message catalog instead of just translating one string.
263     """
264     global _default
265 
266     t = getattr(_active, "value", None)
267     if t is not None:
268         return t
269     if _default is None:
270         _default = translation(settings.LANGUAGE_CODE)
271     return _default
272 
273 
274 def gettext(message):
275     """
276     Translate the 'message' string. It uses the current thread to find the
277     translation object to use. If no current translation is activated, the
278     message will be run through the default translation object.
279     """
280     global _default
281 
282     eol_message = message.replace('\r\n', '\n').replace('\r', '\n')
283 
284     if eol_message:
285         _default = _default or translation(settings.LANGUAGE_CODE)
286         translation_object = getattr(_active, "value", _default)
287 
288         result = translation_object.gettext(eol_message)
289     else:
290         # Return an empty value of the corresponding type if an empty message
291         # is given, instead of metadata, which is the default gettext behavior.
292         result = type(message)('')
293 
294     if isinstance(message, SafeData):
295         return mark_safe(result)
296 
297     return result
298 
299 
300 def pgettext(context, message):
301     msg_with_ctxt = "%s%s%s" % (context, CONTEXT_SEPARATOR, message)
302     result = gettext(msg_with_ctxt)
303     if CONTEXT_SEPARATOR in result:
304         # Translation not found
305         result = message
306     elif isinstance(message, SafeData):
307         result = mark_safe(result)
308     return result
309 
310 
311 def gettext_noop(message):
312     """
313     Mark strings for translation but don't translate them now. This can be
314     used to store strings in global variables that should stay in the base
315     language (because they might be used externally) and will be translated
316     later.
317     """
318     return message
319 
320 
321 def do_ntranslate(singular, plural, number, translation_function):
322     global _default
323 
324     t = getattr(_active, "value", None)
325     if t is not None:
326         return getattr(t, translation_function)(singular, plural, number)
327     if _default is None:
328         _default = translation(settings.LANGUAGE_CODE)
329     return getattr(_default, translation_function)(singular, plural, number)
330 
331 
332 def ngettext(singular, plural, number):
333     """
334     Return a string of the translation of either the singular or plural,
335     based on the number.
336     """
337     return do_ntranslate(singular, plural, number, 'ngettext')
338 
339 
340 def npgettext(context, singular, plural, number):
341     msgs_with_ctxt = ("%s%s%s" % (context, CONTEXT_SEPARATOR, singular),
342                       "%s%s%s" % (context, CONTEXT_SEPARATOR, plural),
343                       number)
344     result = ngettext(*msgs_with_ctxt)
345     if CONTEXT_SEPARATOR in result:
346         # Translation not found
347         result = ngettext(singular, plural, number)
348     return result
349 
350 
351 def all_locale_paths():
352     """
353     Return a list of paths to user-provides languages files.
354     """
355     globalpath = os.path.join(
356         os.path.dirname(sys.modules[settings.__module__].__file__), 'locale')
357     app_paths = []
358     for app_config in apps.get_app_configs():
359         locale_path = os.path.join(app_config.path, 'locale')
360         if os.path.exists(locale_path):
361             app_paths.append(locale_path)
362     return [globalpath, *settings.LOCALE_PATHS, *app_paths]
363 
364 
365 @functools.lru_cache(maxsize=1000)
366 def check_for_language(lang_code):
367     """
368     Check whether there is a global language file for the given language
369     code. This is used to decide whether a user-provided language is
370     available.
371 
372     lru_cache should have a maxsize to prevent from memory exhaustion attacks,
373     as the provided language codes are taken from the HTTP request. See also
374     <https://www.djangoproject.com/weblog/2007/oct/26/security-fix/>.
375     """
376     # First, a quick check to make sure lang_code is well-formed (#21458)
377     if lang_code is None or not language_code_re.search(lang_code):
378         return False
379     return any(
380         gettext_module.find('django', path, [to_locale(lang_code)]) is not None
381         for path in all_locale_paths()
382     )
383 
384 
385 @functools.lru_cache()
386 def get_languages():
387     """
388     Cache of settings.LANGUAGES in an OrderedDict for easy lookups by key.
389     """
390     return OrderedDict(settings.LANGUAGES)
391 
392 
393 @functools.lru_cache(maxsize=1000)
394 def get_supported_language_variant(lang_code, strict=False):
395     """
396     Return the language code that's listed in supported languages, possibly
397     selecting a more generic variant. Raise LookupError if nothing is found.
398 
399     If `strict` is False (the default), look for a country-specific variant
400     when neither the language code nor its generic variant is found.
401 
402     lru_cache should have a maxsize to prevent from memory exhaustion attacks,
403     as the provided language codes are taken from the HTTP request. See also
404     <https://www.djangoproject.com/weblog/2007/oct/26/security-fix/>.
405     """
406     if lang_code:
407         # If 'fr-ca' is not supported, try special fallback or language-only 'fr'.
408         possible_lang_codes = [lang_code]
409         try:
410             possible_lang_codes.extend(LANG_INFO[lang_code]['fallback'])
411         except KeyError:
412             pass
413         generic_lang_code = lang_code.split('-')[0]
414         possible_lang_codes.append(generic_lang_code)
415         supported_lang_codes = get_languages()
416 
417         for code in possible_lang_codes:
418             if code in supported_lang_codes and check_for_language(code):
419                 return code
420         if not strict:
421             # if fr-fr is not supported, try fr-ca.
422             for supported_code in supported_lang_codes:
423                 if supported_code.startswith(generic_lang_code + '-'):
424                     return supported_code
425     raise LookupError(lang_code)
426 
427 
428 def get_language_from_path(path, strict=False):
429     """
430     Return the language code if there's a valid language code found in `path`.
431 
432     If `strict` is False (the default), look for a country-specific variant
433     when neither the language code nor its generic variant is found.
434     """
435     regex_match = language_code_prefix_re.match(path)
436     if not regex_match:
437         return None
438     lang_code = regex_match.group(1)
439     try:
440         return get_supported_language_variant(lang_code, strict=strict)
441     except LookupError:
442         return None
443 
444 
445 def get_language_from_request(request, check_path=False):
446     """
447     Analyze the request to find what language the user wants the system to
448     show. Only languages listed in settings.LANGUAGES are taken into account.
449     If the user requests a sublanguage where we have a main language, we send
450     out the main language.
451 
452     If check_path is True, the URL path prefix will be checked for a language
453     code, otherwise this is skipped for backwards compatibility.
454     """
455     if check_path:
456         lang_code = get_language_from_path(request.path_info)
457         if lang_code is not None:
458             return lang_code
459 
460     supported_lang_codes = get_languages()
461 
462     if hasattr(request, 'session'):
463         lang_code = request.session.get(LANGUAGE_SESSION_KEY)
464         if lang_code in supported_lang_codes and lang_code is not None and check_for_language(lang_code):
465             return lang_code
466 
467     lang_code = request.COOKIES.get(settings.LANGUAGE_COOKIE_NAME)
468 
469     try:
470         return get_supported_language_variant(lang_code)
471     except LookupError:
472         pass
473 
474     accept = request.META.get('HTTP_ACCEPT_LANGUAGE', '')
475     for accept_lang, unused in parse_accept_lang_header(accept):
476         if accept_lang == '*':
477             break
478 
479         if not language_code_re.search(accept_lang):
480             continue
481 
482         try:
483             return get_supported_language_variant(accept_lang)
484         except LookupError:
485             continue
486 
487     try:
488         return get_supported_language_variant(settings.LANGUAGE_CODE)
489     except LookupError:
490         return settings.LANGUAGE_CODE
491 
492 
493 @functools.lru_cache(maxsize=1000)
494 def parse_accept_lang_header(lang_string):
495     """
496     Parse the lang_string, which is the body of an HTTP Accept-Language
497     header, and return a tuple of (lang, q-value), ordered by 'q' values.
498 
499     Return an empty tuple if there are any format errors in lang_string.
500     """
501     result = []
502     pieces = accept_language_re.split(lang_string.lower())
503     if pieces[-1]:
504         return ()
505     for i in range(0, len(pieces) - 1, 3):
506         first, lang, priority = pieces[i:i + 3]
507         if first:
508             return ()
509         if priority:
510             priority = float(priority)
511         else:
512             priority = 1.0
513         result.append((lang, priority))
514     result.sort(key=lambda k: k[1], reverse=True)
515     return tuple(result)

</code><intended_behavior>Use OSError to handle file-related translation loading issues, keeping functionality to catch and manage translation file errors.</intended_behavior>, <file>django/views/debug.py</file>
<class>None</class>
<method>None</method>
<code>
1 import functools
2 import re
3 import sys
4 import types
5 from pathlib import Path
6 
7 from django.conf import settings
8 from django.http import HttpResponse, HttpResponseNotFound
9 from django.template import Context, Engine, TemplateDoesNotExist
10 from django.template.defaultfilters import pprint
11 from django.urls import Resolver404, resolve
12 from django.utils import timezone
13 from django.utils.datastructures import MultiValueDict
14 from django.utils.encoding import force_text
15 from django.utils.module_loading import import_string
16 from django.utils.version import get_docs_version
17 
18 # Minimal Django templates engine to render the error templates
19 # regardless of the project's TEMPLATES setting. Templates are
20 # read directly from the filesystem so that the error handler
21 # works even if the template loader is broken.
22 DEBUG_ENGINE = Engine(
23     debug=True,
24     libraries={'i18n': 'django.templatetags.i18n'},
25 )
26 
27 HIDDEN_SETTINGS = re.compile('API|TOKEN|KEY|SECRET|PASS|SIGNATURE', flags=re.IGNORECASE)
28 
29 CLEANSED_SUBSTITUTE = '********************'
30 
31 CURRENT_DIR = Path(__file__).parent
32 
33 
34 class CallableSettingWrapper:
35     """
36     Object to wrap callable appearing in settings.
37     * Not to call in the debug page (#21345).
38     * Not to break the debug page if the callable forbidding to set attributes
39       (#23070).
40     """
41     def __init__(self, callable_setting):
42         self._wrapped = callable_setting
43 
44     def __repr__(self):
45         return repr(self._wrapped)
46 
47 
48 def cleanse_setting(key, value):
49     """
50     Cleanse an individual setting key/value of sensitive content. If the value
51     is a dictionary, recursively cleanse the keys in that dictionary.
52     """
53     try:
54         if HIDDEN_SETTINGS.search(key):
55             cleansed = CLEANSED_SUBSTITUTE
56         else:
57             if isinstance(value, dict):
58                 cleansed = {k: cleanse_setting(k, v) for k, v in value.items()}
59             else:
60                 cleansed = value
61     except TypeError:
62         # If the key isn't regex-able, just return as-is.
63         cleansed = value
64 
65     if callable(cleansed):
66         # For fixing #21345 and #23070
67         cleansed = CallableSettingWrapper(cleansed)
68 
69     return cleansed
70 
71 
72 def get_safe_settings():
73     """
74     Return a dictionary of the settings module with values of sensitive
75     settings replaced with stars (*********).
76     """
77     settings_dict = {}
78     for k in dir(settings):
79         if k.isupper():
80             settings_dict[k] = cleanse_setting(k, getattr(settings, k))
81     return settings_dict
82 
83 
84 def technical_500_response(request, exc_type, exc_value, tb, status_code=500):
85     """
86     Create a technical server error response. The last three arguments are
87     the values returned from sys.exc_info() and friends.
88     """
89     reporter = ExceptionReporter(request, exc_type, exc_value, tb)
90     if request.is_ajax():
91         text = reporter.get_traceback_text()
92         return HttpResponse(text, status=status_code, content_type='text/plain; charset=utf-8')
93     else:
94         html = reporter.get_traceback_html()
95         return HttpResponse(html, status=status_code, content_type='text/html')
96 
97 
98 @functools.lru_cache()
99 def get_default_exception_reporter_filter():
100     # Instantiate the default filter for the first time and cache it.
101     return import_string(settings.DEFAULT_EXCEPTION_REPORTER_FILTER)()
102 
103 
104 def get_exception_reporter_filter(request):
105     default_filter = get_default_exception_reporter_filter()
106     return getattr(request, 'exception_reporter_filter', default_filter)
107 
108 
109 class ExceptionReporterFilter:
110     """
111     Base for all exception reporter filter classes. All overridable hooks
112     contain lenient default behaviors.
113     """
114 
115     def get_post_parameters(self, request):
116         if request is None:
117             return {}
118         else:
119             return request.POST
120 
121     def get_traceback_frame_variables(self, request, tb_frame):
122         return list(tb_frame.f_locals.items())
123 
124 
125 class SafeExceptionReporterFilter(ExceptionReporterFilter):
126     """
127     Use annotations made by the sensitive_post_parameters and
128     sensitive_variables decorators to filter out sensitive information.
129     """
130 
131     def is_active(self, request):
132         """
133         This filter is to add safety in production environments (i.e. DEBUG
134         is False). If DEBUG is True then your site is not safe anyway.
135         This hook is provided as a convenience to easily activate or
136         deactivate the filter on a per request basis.
137         """
138         return settings.DEBUG is False
139 
140     def get_cleansed_multivaluedict(self, request, multivaluedict):
141         """
142         Replace the keys in a MultiValueDict marked as sensitive with stars.
143         This mitigates leaking sensitive POST parameters if something like
144         request.POST['nonexistent_key'] throws an exception (#21098).
145         """
146         sensitive_post_parameters = getattr(request, 'sensitive_post_parameters', [])
147         if self.is_active(request) and sensitive_post_parameters:
148             multivaluedict = multivaluedict.copy()
149             for param in sensitive_post_parameters:
150                 if param in multivaluedict:
151                     multivaluedict[param] = CLEANSED_SUBSTITUTE
152         return multivaluedict
153 
154     def get_post_parameters(self, request):
155         """
156         Replace the values of POST parameters marked as sensitive with
157         stars (*********).
158         """
159         if request is None:
160             return {}
161         else:
162             sensitive_post_parameters = getattr(request, 'sensitive_post_parameters', [])
163             if self.is_active(request) and sensitive_post_parameters:
164                 cleansed = request.POST.copy()
165                 if sensitive_post_parameters == '__ALL__':
166                     # Cleanse all parameters.
167                     for k in cleansed:
168                         cleansed[k] = CLEANSED_SUBSTITUTE
169                     return cleansed
170                 else:
171                     # Cleanse only the specified parameters.
172                     for param in sensitive_post_parameters:
173                         if param in cleansed:
174                             cleansed[param] = CLEANSED_SUBSTITUTE
175                     return cleansed
176             else:
177                 return request.POST
178 
179     def cleanse_special_types(self, request, value):
180         try:
181             # If value is lazy or a complex object of another kind, this check
182             # might raise an exception. isinstance checks that lazy
183             # MultiValueDicts will have a return value.
184             is_multivalue_dict = isinstance(value, MultiValueDict)
185         except Exception as e:
186             return '{!r} while evaluating {!r}'.format(e, value)
187 
188         if is_multivalue_dict:
189             # Cleanse MultiValueDicts (request.POST is the one we usually care about)
190             value = self.get_cleansed_multivaluedict(request, value)
191         return value
192 
193     def get_traceback_frame_variables(self, request, tb_frame):
194         """
195         Replace the values of variables marked as sensitive with
196         stars (*********).
197         """
198         # Loop through the frame's callers to see if the sensitive_variables
199         # decorator was used.
200         current_frame = tb_frame.f_back
201         sensitive_variables = None
202         while current_frame is not None:
203             if (current_frame.f_code.co_name == 'sensitive_variables_wrapper' and
204                     'sensitive_variables_wrapper' in current_frame.f_locals):
205                 # The sensitive_variables decorator was used, so we take note
206                 # of the sensitive variables' names.
207                 wrapper = current_frame.f_locals['sensitive_variables_wrapper']
208                 sensitive_variables = getattr(wrapper, 'sensitive_variables', None)
209                 break
210             current_frame = current_frame.f_back
211 
212         cleansed = {}
213         if self.is_active(request) and sensitive_variables:
214             if sensitive_variables == '__ALL__':
215                 # Cleanse all variables
216                 for name in tb_frame.f_locals:
217                     cleansed[name] = CLEANSED_SUBSTITUTE
218             else:
219                 # Cleanse specified variables
220                 for name, value in tb_frame.f_locals.items():
221                     if name in sensitive_variables:
222                         value = CLEANSED_SUBSTITUTE
223                     else:
224                         value = self.cleanse_special_types(request, value)
225                     cleansed[name] = value
226         else:
227             # Potentially cleanse the request and any MultiValueDicts if they
228             # are one of the frame variables.
229             for name, value in tb_frame.f_locals.items():
230                 cleansed[name] = self.cleanse_special_types(request, value)
231 
232         if (tb_frame.f_code.co_name == 'sensitive_variables_wrapper' and
233                 'sensitive_variables_wrapper' in tb_frame.f_locals):
234             # For good measure, obfuscate the decorated function's arguments in
235             # the sensitive_variables decorator's frame, in case the variables
236             # associated with those arguments were meant to be obfuscated from
237             # the decorated function's frame.
238             cleansed['func_args'] = CLEANSED_SUBSTITUTE
239             cleansed['func_kwargs'] = CLEANSED_SUBSTITUTE
240 
241         return cleansed.items()
242 
243 
244 class ExceptionReporter:
245     """Organize and coordinate reporting on exceptions."""
246     def __init__(self, request, exc_type, exc_value, tb, is_email=False):
247         self.request = request
248         self.filter = get_exception_reporter_filter(self.request)
249         self.exc_type = exc_type
250         self.exc_value = exc_value
251         self.tb = tb
252         self.is_email = is_email
253 
254         self.template_info = getattr(self.exc_value, 'template_debug', None)
255         self.template_does_not_exist = False
256         self.postmortem = None
257 
258     def get_traceback_data(self):
259         """Return a dictionary containing traceback information."""
260         if self.exc_type and issubclass(self.exc_type, TemplateDoesNotExist):
261             self.template_does_not_exist = True
262             self.postmortem = self.exc_value.chain or [self.exc_value]
263 
264         frames = self.get_traceback_frames()
265         for i, frame in enumerate(frames):
266             if 'vars' in frame:
267                 frame_vars = []
268                 for k, v in frame['vars']:
269                     v = pprint(v)
270                     # Trim large blobs of data
271                     if len(v) > 4096:
272                         v = '%s… <trimmed %d bytes string>' % (v[0:4096], len(v))
273                     frame_vars.append((k, v))
274                 frame['vars'] = frame_vars
275             frames[i] = frame
276 
277         unicode_hint = ''
278         if self.exc_type and issubclass(self.exc_type, UnicodeError):
279             start = getattr(self.exc_value, 'start', None)
280             end = getattr(self.exc_value, 'end', None)
281             if start is not None and end is not None:
282                 unicode_str = self.exc_value.args[1]
283                 unicode_hint = force_text(
284                     unicode_str[max(start - 5, 0):min(end + 5, len(unicode_str))],
285                     'ascii', errors='replace'
286                 )
287         from django import get_version
288 
289         if self.request is None:
290             user_str = None
291         else:
292             try:
293                 user_str = str(self.request.user)
294             except Exception:
295                 # request.user may raise OperationalError if the database is
296                 # unavailable, for example.
297                 user_str = '[unable to retrieve the current user]'
298 
299         c = {
300             'is_email': self.is_email,
301             'unicode_hint': unicode_hint,
302             'frames': frames,
303             'request': self.request,
304             'user_str': user_str,
305             'filtered_POST_items': list(self.filter.get_post_parameters(self.request).items()),
306             'settings': get_safe_settings(),
307             'sys_executable': sys.executable,
308             'sys_version_info': '%d.%d.%d' % sys.version_info[0:3],
309             'server_time': timezone.now(),
310             'django_version_info': get_version(),
311             'sys_path': sys.path,
312             'template_info': self.template_info,
313             'template_does_not_exist': self.template_does_not_exist,
314             'postmortem': self.postmortem,
315         }
316         if self.request is not None:
317             c['request_GET_items'] = self.request.GET.items()
318             c['request_FILES_items'] = self.request.FILES.items()
319             c['request_COOKIES_items'] = self.request.COOKIES.items()
320         # Check whether exception info is available
321         if self.exc_type:
322             c['exception_type'] = self.exc_type.__name__
323         if self.exc_value:
324             c['exception_value'] = str(self.exc_value)
325         if frames:
326             c['lastframe'] = frames[-1]
327         return c
328 
329     def get_traceback_html(self):
330         """Return HTML version of debug 500 HTTP error page."""
331         with Path(CURRENT_DIR, 'templates', 'technical_500.html').open() as fh:
332             t = DEBUG_ENGINE.from_string(fh.read())
333         c = Context(self.get_traceback_data(), use_l10n=False)
334         return t.render(c)
335 
336     def get_traceback_text(self):
337         """Return plain text version of debug 500 HTTP error page."""
338         with Path(CURRENT_DIR, 'templates', 'technical_500.txt').open() as fh:
339             t = DEBUG_ENGINE.from_string(fh.read())
340         c = Context(self.get_traceback_data(), autoescape=False, use_l10n=False)
341         return t.render(c)
342 
343     def _get_lines_from_file(self, filename, lineno, context_lines, loader=None, module_name=None):
344         """
345         Return context_lines before and after lineno from file.
346         Return (pre_context_lineno, pre_context, context_line, post_context).
347         """
348         source = None
349         if hasattr(loader, 'get_source'):
350             try:
351                 source = loader.get_source(module_name)
352             except ImportError:
353                 pass
354             if source is not None:
355                 source = source.splitlines()
356         if source is None:
357             try:
358                 with open(filename, 'rb') as fp:
359                     source = fp.read().splitlines()
360             except (OSError, IOError):
361                 pass
362         if source is None:
363             return None, [], None, []
364 
365         # If we just read the source from a file, or if the loader did not
366         # apply tokenize.detect_encoding to decode the source into a
367         # string, then we should do that ourselves.
368         if isinstance(source[0], bytes):
369             encoding = 'ascii'
370             for line in source[:2]:
371                 # File coding may be specified. Match pattern from PEP-263
372                 # (https://www.python.org/dev/peps/pep-0263/)
373                 match = re.search(br'coding[:=]\s*([-\w.]+)', line)
374                 if match:
375                     encoding = match.group(1).decode('ascii')
376                     break
377             source = [str(sline, encoding, 'replace') for sline in source]
378 
379         lower_bound = max(0, lineno - context_lines)
380         upper_bound = lineno + context_lines
381 
382         pre_context = source[lower_bound:lineno]
383         context_line = source[lineno]
384         post_context = source[lineno + 1:upper_bound]
385 
386         return lower_bound, pre_context, context_line, post_context
387 
388     def get_traceback_frames(self):
389         def explicit_or_implicit_cause(exc_value):
390             explicit = getattr(exc_value, '__cause__', None)
391             implicit = getattr(exc_value, '__context__', None)
392             return explicit or implicit
393 
394         # Get the exception and all its causes
395         exceptions = []
396         exc_value = self.exc_value
397         while exc_value:
398             exceptions.append(exc_value)
399             exc_value = explicit_or_implicit_cause(exc_value)
400 
401         frames = []
402         # No exceptions were supplied to ExceptionReporter
403         if not exceptions:
404             return frames
405 
406         # In case there's just one exception, take the traceback from self.tb
407         exc_value = exceptions.pop()
408         tb = self.tb if not exceptions else exc_value.__traceback__
409 
410         while tb is not None:
411             # Support for __traceback_hide__ which is used by a few libraries
412             # to hide internal frames.
413             if tb.tb_frame.f_locals.get('__traceback_hide__'):
414                 tb = tb.tb_next
415                 continue
416             filename = tb.tb_frame.f_code.co_filename
417             function = tb.tb_frame.f_code.co_name
418             lineno = tb.tb_lineno - 1
419             loader = tb.tb_frame.f_globals.get('__loader__')
420             module_name = tb.tb_frame.f_globals.get('__name__') or ''
421             pre_context_lineno, pre_context, context_line, post_context = self._get_lines_from_file(
422                 filename, lineno, 7, loader, module_name,
423             )
424             if pre_context_lineno is None:
425                 pre_context_lineno = lineno
426                 pre_context = []
427                 context_line = '<source code not available>'
428                 post_context = []
429             frames.append({
430                 'exc_cause': explicit_or_implicit_cause(exc_value),
431                 'exc_cause_explicit': getattr(exc_value, '__cause__', True),
432                 'tb': tb,
433                 'type': 'django' if module_name.startswith('django.') else 'user',
434                 'filename': filename,
435                 'function': function,
436                 'lineno': lineno + 1,
437                 'vars': self.filter.get_traceback_frame_variables(self.request, tb.tb_frame),
438                 'id': id(tb),
439                 'pre_context': pre_context,
440                 'context_line': context_line,
441                 'post_context': post_context,
442                 'pre_context_lineno': pre_context_lineno + 1,
443             })
444 
445             # If the traceback for current exception is consumed, try the
446             # other exception.
447             if not tb.tb_next and exceptions:
448                 exc_value = exceptions.pop()
449                 tb = exc_value.__traceback__
450             else:
451                 tb = tb.tb_next
452 
453         return frames
454 
455 
456 def technical_404_response(request, exception):
457     """Create a technical 404 error response. `exception` is the Http404."""
458     try:
459         error_url = exception.args[0]['path']
460     except (IndexError, TypeError, KeyError):
461         error_url = request.path_info[1:]  # Trim leading slash
462 
463     try:
464         tried = exception.args[0]['tried']
465     except (IndexError, TypeError, KeyError):
466         tried = []
467     else:
468         if (not tried or (                  # empty URLconf
469             request.path == '/' and
470             len(tried) == 1 and             # default URLconf
471             len(tried[0]) == 1 and
472             getattr(tried[0][0], 'app_name', '') == getattr(tried[0][0], 'namespace', '') == 'admin'
473         )):
474             return default_urlconf(request)
475 
476     urlconf = getattr(request, 'urlconf', settings.ROOT_URLCONF)
477     if isinstance(urlconf, types.ModuleType):
478         urlconf = urlconf.__name__
479 
480     caller = ''
481     try:
482         resolver_match = resolve(request.path)
483     except Resolver404:
484         pass
485     else:
486         obj = resolver_match.func
487 
488         if hasattr(obj, '__name__'):
489             caller = obj.__name__
490         elif hasattr(obj, '__class__') and hasattr(obj.__class__, '__name__'):
491             caller = obj.__class__.__name__
492 
493         if hasattr(obj, '__module__'):
494             module = obj.__module__
495             caller = '%s.%s' % (module, caller)
496 
497     with Path(CURRENT_DIR, 'templates', 'technical_404.html').open() as fh:
498         t = DEBUG_ENGINE.from_string(fh.read())
499     c = Context({
500         'urlconf': urlconf,
501         'root_urlconf': settings.ROOT_URLCONF,
502         'request_path': error_url,
503         'urlpatterns': tried,
504         'reason': str(exception),
505         'request': request,
506         'settings': get_safe_settings(),
507         'raising_view_name': caller,
508     })
509     return HttpResponseNotFound(t.render(c), content_type='text/html')
510 
511 
512 def default_urlconf(request):
513     """Create an empty URLconf 404 error response."""
514     with Path(CURRENT_DIR, 'templates', 'default_urlconf.html').open() as fh:
515         t = DEBUG_ENGINE.from_string(fh.read())
516     c = Context({
517         'version': get_docs_version(),
518     })
519 
520     return HttpResponse(t.render(c), content_type='text/html')

</code><intended_behavior>Amend to use OSError for managing file access errors in debug views, ensuring error pages render correctly upon issues.</intended_behavior>, <file>django/contrib/staticfiles/storage.py</file>
<class>None</class>
<method>None</method>
<code>
1 import hashlib
2 import json
3 import os
4 import posixpath
5 import re
6 import warnings
7 from collections import OrderedDict
8 from urllib.parse import unquote, urldefrag, urlsplit, urlunsplit
9 
10 from django.conf import settings
11 from django.contrib.staticfiles.utils import check_settings, matches_patterns
12 from django.core.cache import (
13     InvalidCacheBackendError, cache as default_cache, caches,
14 )
15 from django.core.exceptions import ImproperlyConfigured
16 from django.core.files.base import ContentFile
17 from django.core.files.storage import FileSystemStorage, get_storage_class
18 from django.utils.deprecation import RemovedInDjango31Warning
19 from django.utils.functional import LazyObject
20 
21 
22 class StaticFilesStorage(FileSystemStorage):
23     """
24     Standard file system storage for static files.
25 
26     The defaults for ``location`` and ``base_url`` are
27     ``STATIC_ROOT`` and ``STATIC_URL``.
28     """
29     def __init__(self, location=None, base_url=None, *args, **kwargs):
30         if location is None:
31             location = settings.STATIC_ROOT
32         if base_url is None:
33             base_url = settings.STATIC_URL
34         check_settings(base_url)
35         super().__init__(location, base_url, *args, **kwargs)
36         # FileSystemStorage fallbacks to MEDIA_ROOT when location
37         # is empty, so we restore the empty value.
38         if not location:
39             self.base_location = None
40             self.location = None
41 
42     def path(self, name):
43         if not self.location:
44             raise ImproperlyConfigured("You're using the staticfiles app "
45                                        "without having set the STATIC_ROOT "
46                                        "setting to a filesystem path.")
47         return super().path(name)
48 
49 
50 class HashedFilesMixin:
51     default_template = """url("%s")"""
52     max_post_process_passes = 5
53     patterns = (
54         ("*.css", (
55             r"""(url\(['"]{0,1}\s*(.*?)["']{0,1}\))""",
56             (r"""(@import\s*["']\s*(.*?)["'])""", """@import url("%s")"""),
57         )),
58     )
59 
60     def __init__(self, *args, **kwargs):
61         super().__init__(*args, **kwargs)
62         self._patterns = OrderedDict()
63         self.hashed_files = {}
64         for extension, patterns in self.patterns:
65             for pattern in patterns:
66                 if isinstance(pattern, (tuple, list)):
67                     pattern, template = pattern
68                 else:
69                     template = self.default_template
70                 compiled = re.compile(pattern, re.IGNORECASE)
71                 self._patterns.setdefault(extension, []).append((compiled, template))
72 
73     def file_hash(self, name, content=None):
74         """
75         Return a hash of the file with the given name and optional content.
76         """
77         if content is None:
78             return None
79         md5 = hashlib.md5()
80         for chunk in content.chunks():
81             md5.update(chunk)
82         return md5.hexdigest()[:12]
83 
84     def hashed_name(self, name, content=None, filename=None):
85         # `filename` is the name of file to hash if `content` isn't given.
86         # `name` is the base name to construct the new hashed filename from.
87         parsed_name = urlsplit(unquote(name))
88         clean_name = parsed_name.path.strip()
89         filename = (filename and urlsplit(unquote(filename)).path.strip()) or clean_name
90         opened = content is None
91         if opened:
92             if not self.exists(filename):
93                 raise ValueError("The file '%s' could not be found with %r." % (filename, self))
94             try:
95                 content = self.open(filename)
96             except IOError:
97                 # Handle directory paths and fragments
98                 return name
99         try:
100             file_hash = self.file_hash(clean_name, content)
101         finally:
102             if opened:
103                 content.close()
104         path, filename = os.path.split(clean_name)
105         root, ext = os.path.splitext(filename)
106         if file_hash is not None:
107             file_hash = ".%s" % file_hash
108         hashed_name = os.path.join(path, "%s%s%s" %
109                                    (root, file_hash, ext))
110         unparsed_name = list(parsed_name)
111         unparsed_name[2] = hashed_name
112         # Special casing for a @font-face hack, like url(myfont.eot?#iefix")
113         # http://www.fontspring.com/blog/the-new-bulletproof-font-face-syntax
114         if '?#' in name and not unparsed_name[3]:
115             unparsed_name[2] += '?'
116         return urlunsplit(unparsed_name)
117 
118     def _url(self, hashed_name_func, name, force=False, hashed_files=None):
119         """
120         Return the non-hashed URL in DEBUG mode.
121         """
122         if settings.DEBUG and not force:
123             hashed_name, fragment = name, ''
124         else:
125             clean_name, fragment = urldefrag(name)
126             if urlsplit(clean_name).path.endswith('/'):  # don't hash paths
127                 hashed_name = name
128             else:
129                 args = (clean_name,)
130                 if hashed_files is not None:
131                     args += (hashed_files,)
132                 hashed_name = hashed_name_func(*args)
133 
134         final_url = super().url(hashed_name)
135 
136         # Special casing for a @font-face hack, like url(myfont.eot?#iefix")
137         # http://www.fontspring.com/blog/the-new-bulletproof-font-face-syntax
138         query_fragment = '?#' in name  # [sic!]
139         if fragment or query_fragment:
140             urlparts = list(urlsplit(final_url))
141             if fragment and not urlparts[4]:
142                 urlparts[4] = fragment
143             if query_fragment and not urlparts[3]:
144                 urlparts[2] += '?'
145             final_url = urlunsplit(urlparts)
146 
147         return unquote(final_url)
148 
149     def url(self, name, force=False):
150         """
151         Return the non-hashed URL in DEBUG mode.
152         """
153         return self._url(self.stored_name, name, force)
154 
155     def url_converter(self, name, hashed_files, template=None):
156         """
157         Return the custom URL converter for the given file name.
158         """
159         if template is None:
160             template = self.default_template
161 
162         def converter(matchobj):
163             """
164             Convert the matched URL to a normalized and hashed URL.
165 
166             This requires figuring out which files the matched URL resolves
167             to and calling the url() method of the storage.
168             """
169             matched, url = matchobj.groups()
170 
171             # Ignore absolute/protocol-relative and data-uri URLs.
172             if re.match(r'^[a-z]+:', url):
173                 return matched
174 
175             # Ignore absolute URLs that don't point to a static file (dynamic
176             # CSS / JS?). Note that STATIC_URL cannot be empty.
177             if url.startswith('/') and not url.startswith(settings.STATIC_URL):
178                 return matched
179 
180             # Strip off the fragment so a path-like fragment won't interfere.
181             url_path, fragment = urldefrag(url)
182 
183             if url_path.startswith('/'):
184                 # Otherwise the condition above would have returned prematurely.
185                 assert url_path.startswith(settings.STATIC_URL)
186                 target_name = url_path[len(settings.STATIC_URL):]
187             else:
188                 # We're using the posixpath module to mix paths and URLs conveniently.
189                 source_name = name if os.sep == '/' else name.replace(os.sep, '/')
190                 target_name = posixpath.join(posixpath.dirname(source_name), url_path)
191 
192             # Determine the hashed name of the target file with the storage backend.
193             hashed_url = self._url(
194                 self._stored_name, unquote(target_name),
195                 force=True, hashed_files=hashed_files,
196             )
197 
198             transformed_url = '/'.join(url_path.split('/')[:-1] + hashed_url.split('/')[-1:])
199 
200             # Restore the fragment that was stripped off earlier.
201             if fragment:
202                 transformed_url += ('?#' if '?#' in url else '#') + fragment
203 
204             # Return the hashed version to the file
205             return template % unquote(transformed_url)
206 
207         return converter
208 
209     def post_process(self, paths, dry_run=False, **options):
210         """
211         Post process the given OrderedDict of files (called from collectstatic).
212 
213         Processing is actually two separate operations:
214 
215         1. renaming files to include a hash of their content for cache-busting,
216            and copying those files to the target storage.
217         2. adjusting files which contain references to other files so they
218            refer to the cache-busting filenames.
219 
220         If either of these are performed on a file, then that file is considered
221         post-processed.
222         """
223         # don't even dare to process the files if we're in dry run mode
224         if dry_run:
225             return
226 
227         # where to store the new paths
228         hashed_files = OrderedDict()
229 
230         # build a list of adjustable files
231         adjustable_paths = [
232             path for path in paths
233             if matches_patterns(path, self._patterns)
234         ]
235         # Do a single pass first. Post-process all files once, then repeat for
236         # adjustable files.
237         for name, hashed_name, processed, _ in self._post_process(paths, adjustable_paths, hashed_files):
238             yield name, hashed_name, processed
239 
240         paths = {path: paths[path] for path in adjustable_paths}
241 
242         for i in range(self.max_post_process_passes):
243             substitutions = False
244             for name, hashed_name, processed, subst in self._post_process(paths, adjustable_paths, hashed_files):
245                 yield name, hashed_name, processed
246                 substitutions = substitutions or subst
247 
248             if not substitutions:
249                 break
250 
251         if substitutions:
252             yield 'All', None, RuntimeError('Max post-process passes exceeded.')
253 
254         # Store the processed paths
255         self.hashed_files.update(hashed_files)
256 
257     def _post_process(self, paths, adjustable_paths, hashed_files):
258         # Sort the files by directory level
259         def path_level(name):
260             return len(name.split(os.sep))
261 
262         for name in sorted(paths, key=path_level, reverse=True):
263             substitutions = True
264             # use the original, local file, not the copied-but-unprocessed
265             # file, which might be somewhere far away, like S3
266             storage, path = paths[name]
267             with storage.open(path) as original_file:
268                 cleaned_name = self.clean_name(name)
269                 hash_key = self.hash_key(cleaned_name)
270 
271                 # generate the hash with the original content, even for
272                 # adjustable files.
273                 if hash_key not in hashed_files:
274                     hashed_name = self.hashed_name(name, original_file)
275                 else:
276                     hashed_name = hashed_files[hash_key]
277 
278                 # then get the original's file content..
279                 if hasattr(original_file, 'seek'):
280                     original_file.seek(0)
281 
282                 hashed_file_exists = self.exists(hashed_name)
283                 processed = False
284 
285                 # ..to apply each replacement pattern to the content
286                 if name in adjustable_paths:
287                     old_hashed_name = hashed_name
288                     content = original_file.read().decode(settings.FILE_CHARSET)
289                     for extension, patterns in self._patterns.items():
290                         if matches_patterns(path, (extension,)):
291                             for pattern, template in patterns:
292                                 converter = self.url_converter(name, hashed_files, template)
293                                 try:
294                                     content = pattern.sub(converter, content)
295                                 except ValueError as exc:
296                                     yield name, None, exc, False
297                     if hashed_file_exists:
298                         self.delete(hashed_name)
299                     # then save the processed result
300                     content_file = ContentFile(content.encode())
301                     # Save intermediate file for reference
302                     saved_name = self._save(hashed_name, content_file)
303                     hashed_name = self.hashed_name(name, content_file)
304 
305                     if self.exists(hashed_name):
306                         self.delete(hashed_name)
307 
308                     saved_name = self._save(hashed_name, content_file)
309                     hashed_name = self.clean_name(saved_name)
310                     # If the file hash stayed the same, this file didn't change
311                     if old_hashed_name == hashed_name:
312                         substitutions = False
313                     processed = True
314 
315                 if not processed:
316                     # or handle the case in which neither processing nor
317                     # a change to the original file happened
318                     if not hashed_file_exists:
319                         processed = True
320                         saved_name = self._save(hashed_name, original_file)
321                         hashed_name = self.clean_name(saved_name)
322 
323                 # and then set the cache accordingly
324                 hashed_files[hash_key] = hashed_name
325 
326                 yield name, hashed_name, processed, substitutions
327 
328     def clean_name(self, name):
329         return name.replace('\\', '/')
330 
331     def hash_key(self, name):
332         return name
333 
334     def _stored_name(self, name, hashed_files):
335         # Normalize the path to avoid multiple names for the same file like
336         # ../foo/bar.css and ../foo/../foo/bar.css which normalize to the same
337         # path.
338         name = posixpath.normpath(name)
339         cleaned_name = self.clean_name(name)
340         hash_key = self.hash_key(cleaned_name)
341         cache_name = hashed_files.get(hash_key)
342         if cache_name is None:
343             cache_name = self.clean_name(self.hashed_name(name))
344         return cache_name
345 
346     def stored_name(self, name):
347         cleaned_name = self.clean_name(name)
348         hash_key = self.hash_key(cleaned_name)
349         cache_name = self.hashed_files.get(hash_key)
350         if cache_name:
351             return cache_name
352         # No cached name found, recalculate it from the files.
353         intermediate_name = name
354         for i in range(self.max_post_process_passes + 1):
355             cache_name = self.clean_name(
356                 self.hashed_name(name, content=None, filename=intermediate_name)
357             )
358             if intermediate_name == cache_name:
359                 # Store the hashed name if there was a miss.
360                 self.hashed_files[hash_key] = cache_name
361                 return cache_name
362             else:
363                 # Move on to the next intermediate file.
364                 intermediate_name = cache_name
365         # If the cache name can't be determined after the max number of passes,
366         # the intermediate files on disk may be corrupt; avoid an infinite loop.
367         raise ValueError("The name '%s' could not be hashed with %r." % (name, self))
368 
369 
370 class ManifestFilesMixin(HashedFilesMixin):
371     manifest_version = '1.0'  # the manifest format standard
372     manifest_name = 'staticfiles.json'
373     manifest_strict = True
374 
375     def __init__(self, *args, **kwargs):
376         super().__init__(*args, **kwargs)
377         self.hashed_files = self.load_manifest()
378 
379     def read_manifest(self):
380         try:
381             with self.open(self.manifest_name) as manifest:
382                 return manifest.read().decode()
383         except IOError:
384             return None
385 
386     def load_manifest(self):
387         content = self.read_manifest()
388         if content is None:
389             return OrderedDict()
390         try:
391             stored = json.loads(content, object_pairs_hook=OrderedDict)
392         except json.JSONDecodeError:
393             pass
394         else:
395             version = stored.get('version')
396             if version == '1.0':
397                 return stored.get('paths', OrderedDict())
398         raise ValueError("Couldn't load manifest '%s' (version %s)" %
399                          (self.manifest_name, self.manifest_version))
400 
401     def post_process(self, *args, **kwargs):
402         self.hashed_files = OrderedDict()
403         yield from super().post_process(*args, **kwargs)
404         self.save_manifest()
405 
406     def save_manifest(self):
407         payload = {'paths': self.hashed_files, 'version': self.manifest_version}
408         if self.exists(self.manifest_name):
409             self.delete(self.manifest_name)
410         contents = json.dumps(payload).encode()
411         self._save(self.manifest_name, ContentFile(contents))
412 
413     def stored_name(self, name):
414         parsed_name = urlsplit(unquote(name))
415         clean_name = parsed_name.path.strip()
416         hash_key = self.hash_key(clean_name)
417         cache_name = self.hashed_files.get(hash_key)
418         if cache_name is None:
419             if self.manifest_strict:
420                 raise ValueError("Missing staticfiles manifest entry for '%s'" % clean_name)
421             cache_name = self.clean_name(self.hashed_name(name))
422         unparsed_name = list(parsed_name)
423         unparsed_name[2] = cache_name
424         # Special casing for a @font-face hack, like url(myfont.eot?#iefix")
425         # http://www.fontspring.com/blog/the-new-bulletproof-font-face-syntax
426         if '?#' in name and not unparsed_name[3]:
427             unparsed_name[2] += '?'
428         return urlunsplit(unparsed_name)
429 
430 
431 class _MappingCache:
432     """
433     A small dict-like wrapper for a given cache backend instance.
434     """
435     def __init__(self, cache):
436         self.cache = cache
437 
438     def __setitem__(self, key, value):
439         self.cache.set(key, value)
440 
441     def __getitem__(self, key):
442         value = self.cache.get(key)
443         if value is None:
444             raise KeyError("Couldn't find a file name '%s'" % key)
445         return value
446 
447     def clear(self):
448         self.cache.clear()
449 
450     def update(self, data):
451         self.cache.set_many(data)
452 
453     def get(self, key, default=None):
454         try:
455             return self[key]
456         except KeyError:
457             return default
458 
459 
460 class CachedFilesMixin(HashedFilesMixin):
461     def __init__(self, *args, **kwargs):
462         super().__init__(*args, **kwargs)
463         try:
464             self.hashed_files = _MappingCache(caches['staticfiles'])
465         except InvalidCacheBackendError:
466             # Use the default backend
467             self.hashed_files = _MappingCache(default_cache)
468 
469     def hash_key(self, name):
470         key = hashlib.md5(self.clean_name(name).encode()).hexdigest()
471         return 'staticfiles:%s' % key
472 
473 
474 class CachedStaticFilesStorage(CachedFilesMixin, StaticFilesStorage):
475     """
476     A static file system storage backend which also saves
477     hashed copies of the files it saves.
478     """
479     def __init__(self, *args, **kwargs):
480         warnings.warn(
481             'CachedStaticFilesStorage is deprecated in favor of '
482             'ManifestStaticFilesStorage.',
483             RemovedInDjango31Warning, stacklevel=2,
484         )
485         super().__init__(*args, **kwargs)
486 
487 
488 class ManifestStaticFilesStorage(ManifestFilesMixin, StaticFilesStorage):
489     """
490     A static file system storage backend which also saves
491     hashed copies of the files it saves.
492     """
493     pass
494 
495 
496 class ConfiguredStorage(LazyObject):
497     def _setup(self):
498         self._wrapped = get_storage_class(settings.STATICFILES_STORAGE)()
499 
500 
501 staticfiles_storage = ConfiguredStorage()

</code><intended_behavior>Replace IOError with OSError for static files storage operations, preserving integrity in static file serving and error logging.</intended_behavior>, <file>django/contrib/sessions/backends/file.py</file>
<class>None</class>
<method>None</method>
<code>
1 import datetime
2 import logging
3 import os
4 import shutil
5 import tempfile
6 
7 from django.conf import settings
8 from django.contrib.sessions.backends.base import (
9     VALID_KEY_CHARS, CreateError, SessionBase, UpdateError,
10 )
11 from django.contrib.sessions.exceptions import InvalidSessionKey
12 from django.core.exceptions import ImproperlyConfigured, SuspiciousOperation
13 from django.utils import timezone
14 
15 
16 class SessionStore(SessionBase):
17     """
18     Implement a file based session store.
19     """
20     def __init__(self, session_key=None):
21         self.storage_path = type(self)._get_storage_path()
22         self.file_prefix = settings.SESSION_COOKIE_NAME
23         super().__init__(session_key)
24 
25     @classmethod
26     def _get_storage_path(cls):
27         try:
28             return cls._storage_path
29         except AttributeError:
30             storage_path = getattr(settings, 'SESSION_FILE_PATH', None) or tempfile.gettempdir()
31             # Make sure the storage path is valid.
32             if not os.path.isdir(storage_path):
33                 raise ImproperlyConfigured(
34                     "The session storage path %r doesn't exist. Please set your"
35                     " SESSION_FILE_PATH setting to an existing directory in which"
36                     " Django can store session data." % storage_path)
37 
38             cls._storage_path = storage_path
39             return storage_path
40 
41     def _key_to_file(self, session_key=None):
42         """
43         Get the file associated with this session key.
44         """
45         if session_key is None:
46             session_key = self._get_or_create_session_key()
47 
48         # Make sure we're not vulnerable to directory traversal. Session keys
49         # should always be md5s, so they should never contain directory
50         # components.
51         if not set(session_key).issubset(VALID_KEY_CHARS):
52             raise InvalidSessionKey(
53                 "Invalid characters in session key")
54 
55         return os.path.join(self.storage_path, self.file_prefix + session_key)
56 
57     def _last_modification(self):
58         """
59         Return the modification time of the file storing the session's content.
60         """
61         modification = os.stat(self._key_to_file()).st_mtime
62         if settings.USE_TZ:
63             modification = datetime.datetime.utcfromtimestamp(modification)
64             return modification.replace(tzinfo=timezone.utc)
65         return datetime.datetime.fromtimestamp(modification)
66 
67     def _expiry_date(self, session_data):
68         """
69         Return the expiry time of the file storing the session's content.
70         """
71         return session_data.get('_session_expiry') or (
72             self._last_modification() + datetime.timedelta(seconds=settings.SESSION_COOKIE_AGE)
73         )
74 
75     def load(self):
76         session_data = {}
77         try:
78             with open(self._key_to_file(), encoding='ascii') as session_file:
79                 file_data = session_file.read()
80             # Don't fail if there is no data in the session file.
81             # We may have opened the empty placeholder file.
82             if file_data:
83                 try:
84                     session_data = self.decode(file_data)
85                 except (EOFError, SuspiciousOperation) as e:
86                     if isinstance(e, SuspiciousOperation):
87                         logger = logging.getLogger('django.security.%s' % e.__class__.__name__)
88                         logger.warning(str(e))
89                     self.create()
90 
91                 # Remove expired sessions.
92                 expiry_age = self.get_expiry_age(expiry=self._expiry_date(session_data))
93                 if expiry_age <= 0:
94                     session_data = {}
95                     self.delete()
96                     self.create()
97         except (IOError, SuspiciousOperation):
98             self._session_key = None
99         return session_data
100 
101     def create(self):
102         while True:
103             self._session_key = self._get_new_session_key()
104             try:
105                 self.save(must_create=True)
106             except CreateError:
107                 continue
108             self.modified = True
109             return
110 
111     def save(self, must_create=False):
112         if self.session_key is None:
113             return self.create()
114         # Get the session data now, before we start messing
115         # with the file it is stored within.
116         session_data = self._get_session(no_load=must_create)
117 
118         session_file_name = self._key_to_file()
119 
120         try:
121             # Make sure the file exists.  If it does not already exist, an
122             # empty placeholder file is created.
123             flags = os.O_WRONLY | getattr(os, 'O_BINARY', 0)
124             if must_create:
125                 flags |= os.O_EXCL | os.O_CREAT
126             fd = os.open(session_file_name, flags)
127             os.close(fd)
128         except FileNotFoundError:
129             if not must_create:
130                 raise UpdateError
131         except FileExistsError:
132             if must_create:
133                 raise CreateError
134 
135         # Write the session file without interfering with other threads
136         # or processes.  By writing to an atomically generated temporary
137         # file and then using the atomic os.rename() to make the complete
138         # file visible, we avoid having to lock the session file, while
139         # still maintaining its integrity.
140         #
141         # Note: Locking the session file was explored, but rejected in part
142         # because in order to be atomic and cross-platform, it required a
143         # long-lived lock file for each session, doubling the number of
144         # files in the session storage directory at any given time.  This
145         # rename solution is cleaner and avoids any additional overhead
146         # when reading the session data, which is the more common case
147         # unless SESSION_SAVE_EVERY_REQUEST = True.
148         #
149         # See ticket #8616.
150         dir, prefix = os.path.split(session_file_name)
151 
152         try:
153             output_file_fd, output_file_name = tempfile.mkstemp(dir=dir, prefix=prefix + '_out_')
154             renamed = False
155             try:
156                 try:
157                     os.write(output_file_fd, self.encode(session_data).encode())
158                 finally:
159                     os.close(output_file_fd)
160 
161                 # This will atomically rename the file (os.rename) if the OS
162                 # supports it. Otherwise this will result in a shutil.copy2
163                 # and os.unlink (for example on Windows). See #9084.
164                 shutil.move(output_file_name, session_file_name)
165                 renamed = True
166             finally:
167                 if not renamed:
168                     os.unlink(output_file_name)
169         except (OSError, IOError, EOFError):
170             pass
171 
172     def exists(self, session_key):
173         return os.path.exists(self._key_to_file(session_key))
174 
175     def delete(self, session_key=None):
176         if session_key is None:
177             if self.session_key is None:
178                 return
179             session_key = self.session_key
180         try:
181             os.unlink(self._key_to_file(session_key))
182         except OSError:
183             pass
184 
185     def clean(self):
186         pass
187 
188     @classmethod
189     def clear_expired(cls):
190         storage_path = cls._get_storage_path()
191         file_prefix = settings.SESSION_COOKIE_NAME
192 
193         for session_file in os.listdir(storage_path):
194             if not session_file.startswith(file_prefix):
195                 continue
196             session_key = session_file[len(file_prefix):]
197             session = cls(session_key)
198             # When an expired session is loaded, its file is removed, and a
199             # new file is immediately created. Prevent this by disabling
200             # the create() method.
201             session.create = lambda: None
202             session.load()

</code><intended_behavior>Update session file backend to use OSError for session file management errors, maintaining session data integrity and error handling.</intended_behavior>, <file>django/contrib/gis/geos/libgeos.py</file>
<class>None</class>
<method>load_geos</method>
<code>
21 def load_geos():
22     # Custom library path set?
23     try:
24         from django.conf import settings
25         lib_path = settings.GEOS_LIBRARY_PATH
26     except (AttributeError, EnvironmentError,
27             ImportError, ImproperlyConfigured):
28         lib_path = None
29 
30     # Setting the appropriate names for the GEOS-C library.
31     if lib_path:
32         lib_names = None
33     elif os.name == 'nt':
34         # Windows NT libraries
35         lib_names = ['geos_c', 'libgeos_c-1']
36     elif os.name == 'posix':
37         # *NIX libraries
38         lib_names = ['geos_c', 'GEOS']
39     else:
40         raise ImportError('Unsupported OS "%s"' % os.name)
41 
42     # Using the ctypes `find_library` utility to find the path to the GEOS
43     # shared library.  This is better than manually specifying each library name
44     # and extension (e.g., libgeos_c.[so|so.1|dylib].).
45     if lib_names:
46         for lib_name in lib_names:
47             lib_path = find_library(lib_name)
48             if lib_path is not None:
49                 break
50 
51     # No GEOS library could be found.
52     if lib_path is None:
53         raise ImportError(
54             'Could not find the GEOS library (tried "%s"). '
55             'Try setting GEOS_LIBRARY_PATH in your settings.' %
56             '", "'.join(lib_names)
57         )
58     # Getting the GEOS C library.  The C interface (CDLL) is used for
59     # both *NIX and Windows.
60     # See the GEOS C API source code for more details on the library function calls:
61     #  http://geos.refractions.net/ro/doxygen_docs/html/geos__c_8h-source.html
62     _lgeos = CDLL(lib_path)
63     # Here we set up the prototypes for the initGEOS_r and finishGEOS_r
64     # routines.  These functions aren't actually called until they are
65     # attached to a GEOS context handle -- this actually occurs in
66     # geos/prototypes/threadsafe.py.
67     _lgeos.initGEOS_r.restype = CONTEXT_PTR
68     _lgeos.finishGEOS_r.argtypes = [CONTEXT_PTR]
69     # Set restype for compatibility across 32 and 64-bit platforms.
70     _lgeos.GEOSversion.restype = c_char_p
71     return _lgeos

</code><intended_behavior>Transition from EnvironmentError to OSError while loading GEOS libraries, ensuring library path issues are captured under a unified exception.</intended_behavior>, <file>django/contrib/gis/gdal/libgdal.py</file>
<class>None</class>
<method>None</method>
<code>
1 import logging
2 import os
3 import re
4 from ctypes import CDLL, CFUNCTYPE, c_char_p, c_int
5 from ctypes.util import find_library
6 
7 from django.contrib.gis.gdal.error import GDALException
8 from django.core.exceptions import ImproperlyConfigured
9 
10 logger = logging.getLogger('django.contrib.gis')
11 
12 # Custom library path set?
13 try:
14     from django.conf import settings
15     lib_path = settings.GDAL_LIBRARY_PATH
16 except (AttributeError, EnvironmentError,
17         ImportError, ImproperlyConfigured):
18     lib_path = None
19 
20 if lib_path:
21     lib_names = None
22 elif os.name == 'nt':
23     # Windows NT shared libraries
24     lib_names = ['gdal203', 'gdal202', 'gdal201', 'gdal20', 'gdal111']
25 elif os.name == 'posix':
26     # *NIX library names.
27     lib_names = ['gdal', 'GDAL', 'gdal2.3.0', 'gdal2.2.0', 'gdal2.1.0', 'gdal2.0.0', 'gdal1.11.0']
28 else:
29     raise ImproperlyConfigured('GDAL is unsupported on OS "%s".' % os.name)
30 
31 # Using the ctypes `find_library` utility  to find the
32 # path to the GDAL library from the list of library names.
33 if lib_names:
34     for lib_name in lib_names:
35         lib_path = find_library(lib_name)
36         if lib_path is not None:
37             break
38 
39 if lib_path is None:
40     raise ImproperlyConfigured(
41         'Could not find the GDAL library (tried "%s"). Is GDAL installed? '
42         'If it is, try setting GDAL_LIBRARY_PATH in your settings.'
43         % '", "'.join(lib_names)
44     )
45 
46 # This loads the GDAL/OGR C library
47 lgdal = CDLL(lib_path)
48 
49 # On Windows, the GDAL binaries have some OSR routines exported with
50 # STDCALL, while others are not.  Thus, the library will also need to
51 # be loaded up as WinDLL for said OSR functions that require the
52 # different calling convention.
53 if os.name == 'nt':
54     from ctypes import WinDLL
55     lwingdal = WinDLL(lib_path)
56 
57 
58 def std_call(func):
59     """
60     Return the correct STDCALL function for certain OSR routines on Win32
61     platforms.
62     """
63     if os.name == 'nt':
64         return lwingdal[func]
65     else:
66         return lgdal[func]
67 
68 
69 # #### Version-information functions. ####
70 
71 # Return GDAL library version information with the given key.
72 _version_info = std_call('GDALVersionInfo')
73 _version_info.argtypes = [c_char_p]
74 _version_info.restype = c_char_p
75 
76 
77 def gdal_version():
78     "Return only the GDAL version number information."
79     return _version_info(b'RELEASE_NAME')
80 
81 
82 def gdal_full_version():
83     "Return the full GDAL version information."
84     return _version_info('')
85 
86 
87 version_regex = re.compile(r'^(?P<major>\d+)\.(?P<minor>\d+)(\.(?P<subminor>\d+))?')
88 
89 
90 def gdal_version_info():
91     ver = gdal_version().decode()
92     m = version_regex.match(ver)
93     if not m:
94         raise GDALException('Could not parse GDAL version string "%s"' % ver)
95     return {key: m.group(key) for key in ('major', 'minor', 'subminor')}
96 
97 
98 _verinfo = gdal_version_info()
99 GDAL_MAJOR_VERSION = int(_verinfo['major'])
100 GDAL_MINOR_VERSION = int(_verinfo['minor'])
101 GDAL_SUBMINOR_VERSION = _verinfo['subminor'] and int(_verinfo['subminor'])
102 GDAL_VERSION = (GDAL_MAJOR_VERSION, GDAL_MINOR_VERSION, GDAL_SUBMINOR_VERSION)
103 del _verinfo
104 
105 # Set library error handling so as errors are logged
106 CPLErrorHandler = CFUNCTYPE(None, c_int, c_int, c_char_p)
107 
108 
109 def err_handler(error_class, error_number, message):
110     logger.error('GDAL_ERROR %d: %s', error_number, message)
111 
112 
113 err_handler = CPLErrorHandler(err_handler)
114 
115 
116 def function(name, args, restype):
117     func = std_call(name)
118     func.argtypes = args
119     func.restype = restype
120     return func
121 
122 
123 set_error_handler = function('CPLSetErrorHandler', [CPLErrorHandler], CPLErrorHandler)
124 set_error_handler(err_handler)

</code><intended_behavior>Use OSError for handling GDAL library path configurations, keeping the GIS component adaptable to configuration and file access issues.</intended_behavior>, <file>django/core/management/commands/runserver.py</file>
<class>None</class>
<method>None</method>
<code>
1 import errno
2 import os
3 import re
4 import socket
5 import sys
6 from datetime import datetime
7 
8 from django.conf import settings
9 from django.core.management.base import BaseCommand, CommandError
10 from django.core.servers.basehttp import (
11     WSGIServer, get_internal_wsgi_application, run,
12 )
13 from django.utils import autoreload
14 
15 naiveip_re = re.compile(r"""^(?:
16 (?P<addr>
17     (?P<ipv4>\d{1,3}(?:\.\d{1,3}){3}) |         # IPv4 address
18     (?P<ipv6>\[[a-fA-F0-9:]+\]) |               # IPv6 address
19     (?P<fqdn>[a-zA-Z0-9-]+(?:\.[a-zA-Z0-9-]+)*) # FQDN
20 ):)?(?P<port>\d+)$""", re.X)
21 
22 
23 class Command(BaseCommand):
24     help = "Starts a lightweight Web server for development."
25 
26     # Validation is called explicitly each time the server is reloaded.
27     requires_system_checks = False
28     stealth_options = ('shutdown_message',)
29 
30     default_addr = '127.0.0.1'
31     default_addr_ipv6 = '::1'
32     default_port = '8000'
33     protocol = 'http'
34     server_cls = WSGIServer
35 
36     def add_arguments(self, parser):
37         parser.add_argument(
38             'addrport', nargs='?',
39             help='Optional port number, or ipaddr:port'
40         )
41         parser.add_argument(
42             '--ipv6', '-6', action='store_true', dest='use_ipv6',
43             help='Tells Django to use an IPv6 address.',
44         )
45         parser.add_argument(
46             '--nothreading', action='store_false', dest='use_threading',
47             help='Tells Django to NOT use threading.',
48         )
49         parser.add_argument(
50             '--noreload', action='store_false', dest='use_reloader',
51             help='Tells Django to NOT use the auto-reloader.',
52         )
53 
54     def execute(self, *args, **options):
55         if options['no_color']:
56             # We rely on the environment because it's currently the only
57             # way to reach WSGIRequestHandler. This seems an acceptable
58             # compromise considering `runserver` runs indefinitely.
59             os.environ["DJANGO_COLORS"] = "nocolor"
60         super().execute(*args, **options)
61 
62     def get_handler(self, *args, **options):
63         """Return the default WSGI handler for the runner."""
64         return get_internal_wsgi_application()
65 
66     def handle(self, *args, **options):
67         if not settings.DEBUG and not settings.ALLOWED_HOSTS:
68             raise CommandError('You must set settings.ALLOWED_HOSTS if DEBUG is False.')
69 
70         self.use_ipv6 = options['use_ipv6']
71         if self.use_ipv6 and not socket.has_ipv6:
72             raise CommandError('Your Python does not support IPv6.')
73         self._raw_ipv6 = False
74         if not options['addrport']:
75             self.addr = ''
76             self.port = self.default_port
77         else:
78             m = re.match(naiveip_re, options['addrport'])
79             if m is None:
80                 raise CommandError('"%s" is not a valid port number '
81                                    'or address:port pair.' % options['addrport'])
82             self.addr, _ipv4, _ipv6, _fqdn, self.port = m.groups()
83             if not self.port.isdigit():
84                 raise CommandError("%r is not a valid port number." % self.port)
85             if self.addr:
86                 if _ipv6:
87                     self.addr = self.addr[1:-1]
88                     self.use_ipv6 = True
89                     self._raw_ipv6 = True
90                 elif self.use_ipv6 and not _fqdn:
91                     raise CommandError('"%s" is not a valid IPv6 address.' % self.addr)
92         if not self.addr:
93             self.addr = self.default_addr_ipv6 if self.use_ipv6 else self.default_addr
94             self._raw_ipv6 = self.use_ipv6
95         self.run(**options)
96 
97     def run(self, **options):
98         """Run the server, using the autoreloader if needed."""
99         use_reloader = options['use_reloader']
100 
101         if use_reloader:
102             autoreload.run_with_reloader(self.inner_run, **options)
103         else:
104             self.inner_run(None, **options)
105 
106     def inner_run(self, *args, **options):
107         # If an exception was silenced in ManagementUtility.execute in order
108         # to be raised in the child process, raise it now.
109         autoreload.raise_last_exception()
110 
111         threading = options['use_threading']
112         # 'shutdown_message' is a stealth option.
113         shutdown_message = options.get('shutdown_message', '')
114         quit_command = 'CTRL-BREAK' if sys.platform == 'win32' else 'CONTROL-C'
115 
116         self.stdout.write("Performing system checks…\n\n")
117         self.check(display_num_errors=True)
118         # Need to check migrations here, so can't use the
119         # requires_migrations_check attribute.
120         self.check_migrations()
121         now = datetime.now().strftime('%B %d, %Y - %X')
122         self.stdout.write(now)
123         self.stdout.write((
124             "Django version %(version)s, using settings %(settings)r\n"
125             "Starting development server at %(protocol)s://%(addr)s:%(port)s/\n"
126             "Quit the server with %(quit_command)s.\n"
127         ) % {
128             "version": self.get_version(),
129             "settings": settings.SETTINGS_MODULE,
130             "protocol": self.protocol,
131             "addr": '[%s]' % self.addr if self._raw_ipv6 else self.addr,
132             "port": self.port,
133             "quit_command": quit_command,
134         })
135 
136         try:
137             handler = self.get_handler(*args, **options)
138             run(self.addr, int(self.port), handler,
139                 ipv6=self.use_ipv6, threading=threading, server_cls=self.server_cls)
140         except socket.error as e:
141             # Use helpful error messages instead of ugly tracebacks.
142             ERRORS = {
143                 errno.EACCES: "You don't have permission to access that port.",
144                 errno.EADDRINUSE: "That port is already in use.",
145                 errno.EADDRNOTAVAIL: "That IP address can't be assigned to.",
146             }
147             try:
148                 error_text = ERRORS[e.errno]
149             except KeyError:
150                 error_text = e
151             self.stderr.write("Error: %s" % error_text)
152             # Need to use an OS exit because sys.exit doesn't work in a thread
153             os._exit(1)
154         except KeyboardInterrupt:
155             if shutdown_message:
156                 self.stdout.write(shutdown_message)
157             sys.exit(0)
158 
159 
160 # Kept for backward compatibility
161 BaseRunserverCommand = Command

</code><intended_behavior>Change socket.error to capture with OSError during server run operations, to handle network-related errors uniformly.</intended_behavior>, <file>django/core/servers/basehttp.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2 HTTP server that implements the Python WSGI protocol (PEP 333, rev 1.21).
3 
4 Based on wsgiref.simple_server which is part of the standard library since 2.5.
5 
6 This is a simple server for use in testing or debugging Django apps. It hasn't
7 been reviewed for security issues. DON'T USE IT FOR PRODUCTION USE!
8 """
9 
10 import logging
11 import socket
12 import socketserver
13 import sys
14 from wsgiref import simple_server
15 
16 from django.core.exceptions import ImproperlyConfigured
17 from django.core.handlers.wsgi import LimitedStream
18 from django.core.wsgi import get_wsgi_application
19 from django.utils.module_loading import import_string
20 
21 __all__ = ('WSGIServer', 'WSGIRequestHandler')
22 
23 logger = logging.getLogger('django.server')
24 
25 
26 def get_internal_wsgi_application():
27     """
28     Load and return the WSGI application as configured by the user in
29     ``settings.WSGI_APPLICATION``. With the default ``startproject`` layout,
30     this will be the ``application`` object in ``projectname/wsgi.py``.
31 
32     This function, and the ``WSGI_APPLICATION`` setting itself, are only useful
33     for Django's internal server (runserver); external WSGI servers should just
34     be configured to point to the correct application object directly.
35 
36     If settings.WSGI_APPLICATION is not set (is ``None``), return
37     whatever ``django.core.wsgi.get_wsgi_application`` returns.
38     """
39     from django.conf import settings
40     app_path = getattr(settings, 'WSGI_APPLICATION')
41     if app_path is None:
42         return get_wsgi_application()
43 
44     try:
45         return import_string(app_path)
46     except ImportError as err:
47         raise ImproperlyConfigured(
48             "WSGI application '%s' could not be loaded; "
49             "Error importing module." % app_path
50         ) from err
51 
52 
53 def is_broken_pipe_error():
54     exc_type, exc_value = sys.exc_info()[:2]
55     return issubclass(exc_type, socket.error) and exc_value.args[0] == 32
56 
57 
58 class WSGIServer(simple_server.WSGIServer):
59     """BaseHTTPServer that implements the Python WSGI protocol"""
60 
61     request_queue_size = 10
62 
63     def __init__(self, *args, ipv6=False, allow_reuse_address=True, **kwargs):
64         if ipv6:
65             self.address_family = socket.AF_INET6
66         self.allow_reuse_address = allow_reuse_address
67         super().__init__(*args, **kwargs)
68 
69     def handle_error(self, request, client_address):
70         if is_broken_pipe_error():
71             logger.info("- Broken pipe from %s\n", client_address)
72         else:
73             super().handle_error(request, client_address)
74 
75 
76 class ThreadedWSGIServer(socketserver.ThreadingMixIn, WSGIServer):
77     """A threaded version of the WSGIServer"""
78     daemon_threads = True
79 
80 
81 class ServerHandler(simple_server.ServerHandler):
82     http_version = '1.1'
83 
84     def __init__(self, stdin, stdout, stderr, environ, **kwargs):
85         """
86         Use a LimitedStream so that unread request data will be ignored at
87         the end of the request. WSGIRequest uses a LimitedStream but it
88         shouldn't discard the data since the upstream servers usually do this.
89         This fix applies only for testserver/runserver.
90         """
91         try:
92             content_length = int(environ.get('CONTENT_LENGTH'))
93         except (ValueError, TypeError):
94             content_length = 0
95         super().__init__(LimitedStream(stdin, content_length), stdout, stderr, environ, **kwargs)
96 
97     def cleanup_headers(self):
98         super().cleanup_headers()
99         # HTTP/1.1 requires support for persistent connections. Send 'close' if
100         # the content length is unknown to prevent clients from reusing the
101         # connection.
102         if 'Content-Length' not in self.headers:
103             self.headers['Connection'] = 'close'
104         # Mark the connection for closing if it's set as such above or if the
105         # application sent the header.
106         if self.headers.get('Connection') == 'close':
107             self.request_handler.close_connection = True
108 
109     def close(self):
110         self.get_stdin()._read_limited()
111         super().close()
112 
113     def handle_error(self):
114         # Ignore broken pipe errors, otherwise pass on
115         if not is_broken_pipe_error():
116             super().handle_error()
117 
118 
119 class WSGIRequestHandler(simple_server.WSGIRequestHandler):
120     protocol_version = 'HTTP/1.1'
121 
122     def address_string(self):
123         # Short-circuit parent method to not call socket.getfqdn
124         return self.client_address[0]
125 
126     def log_message(self, format, *args):
127         extra = {
128             'request': self.request,
129             'server_time': self.log_date_time_string(),
130         }
131         if args[1][0] == '4':
132             # 0x16 = Handshake, 0x03 = SSL 3.0 or TLS 1.x
133             if args[0].startswith('\x16\x03'):
134                 extra['status_code'] = 500
135                 logger.error(
136                     "You're accessing the development server over HTTPS, but "
137                     "it only supports HTTP.\n", extra=extra,
138                 )
139                 return
140 
141         if args[1].isdigit() and len(args[1]) == 3:
142             status_code = int(args[1])
143             extra['status_code'] = status_code
144 
145             if status_code >= 500:
146                 level = logger.error
147             elif status_code >= 400:
148                 level = logger.warning
149             else:
150                 level = logger.info
151         else:
152             level = logger.info
153 
154         level(format, *args, extra=extra)
155 
156     def get_environ(self):
157         # Strip all headers with underscores in the name before constructing
158         # the WSGI environ. This prevents header-spoofing based on ambiguity
159         # between underscores and dashes both normalized to underscores in WSGI
160         # env vars. Nginx and Apache 2.4+ both do this as well.
161         for k in self.headers:
162             if '_' in k:
163                 del self.headers[k]
164 
165         return super().get_environ()
166 
167     def handle(self):
168         self.close_connection = True
169         self.handle_one_request()
170         while not self.close_connection:
171             self.handle_one_request()
172         try:
173             self.connection.shutdown(socket.SHUT_WR)
174         except (socket.error, AttributeError):
175             pass
176 
177     def handle_one_request(self):
178         """Copy of WSGIRequestHandler.handle() but with different ServerHandler"""
179         self.raw_requestline = self.rfile.readline(65537)
180         if len(self.raw_requestline) > 65536:
181             self.requestline = ''
182             self.request_version = ''
183             self.command = ''
184             self.send_error(414)
185             return
186 
187         if not self.parse_request():  # An error code has been sent, just exit
188             return
189 
190         handler = ServerHandler(
191             self.rfile, self.wfile, self.get_stderr(), self.get_environ()
192         )
193         handler.request_handler = self      # backpointer for logging & connection closing
194         handler.run(self.server.get_app())
195 
196 
197 def run(addr, port, wsgi_handler, ipv6=False, threading=False, server_cls=WSGIServer):
198     server_address = (addr, port)
199     if threading:
200         httpd_cls = type('WSGIServer', (socketserver.ThreadingMixIn, server_cls), {})
201     else:
202         httpd_cls = server_cls
203     httpd = httpd_cls(server_address, WSGIRequestHandler, ipv6=ipv6)
204     if threading:
205         # ThreadingMixIn.daemon_threads indicates how threads will behave on an
206         # abrupt shutdown; like quitting the server by the user or restarting
207         # by the auto-reloader. True means the server will not wait for thread
208         # termination before it quits. This will make auto-reloader faster
209         # and will prevent the need to kill the server manually if a thread
210         # isn't terminating correctly.
211         httpd.daemon_threads = True
212     httpd.set_app(wsgi_handler)
213     httpd.serve_forever()

</code><intended_behavior>Update exception handling to OSError instead of socket.error for HTTP server operations to manage connection and network errors consistently.</intended_behavior>, <file>django/core/mail/backends/smtp.py</file>
<class>EmailBackend</class>
<method>None</method>
<code>
13 class EmailBackend(BaseEmailBackend):
14     """
15     A wrapper that manages the SMTP network connection.
16     """
17     def __init__(self, host=None, port=None, username=None, password=None,
18                  use_tls=None, fail_silently=False, use_ssl=None, timeout=None,
19                  ssl_keyfile=None, ssl_certfile=None,
20                  **kwargs):
21         super().__init__(fail_silently=fail_silently)
22         self.host = host or settings.EMAIL_HOST
23         self.port = port or settings.EMAIL_PORT
24         self.username = settings.EMAIL_HOST_USER if username is None else username
25         self.password = settings.EMAIL_HOST_PASSWORD if password is None else password
26         self.use_tls = settings.EMAIL_USE_TLS if use_tls is None else use_tls
27         self.use_ssl = settings.EMAIL_USE_SSL if use_ssl is None else use_ssl
28         self.timeout = settings.EMAIL_TIMEOUT if timeout is None else timeout
29         self.ssl_keyfile = settings.EMAIL_SSL_KEYFILE if ssl_keyfile is None else ssl_keyfile
30         self.ssl_certfile = settings.EMAIL_SSL_CERTFILE if ssl_certfile is None else ssl_certfile
31         if self.use_ssl and self.use_tls:
32             raise ValueError(
33                 "EMAIL_USE_TLS/EMAIL_USE_SSL are mutually exclusive, so only set "
34                 "one of those settings to True.")
35         self.connection = None
36         self._lock = threading.RLock()
37 
38     @property
39     def connection_class(self):
40         return smtplib.SMTP_SSL if self.use_ssl else smtplib.SMTP
41 
42     def open(self):
43         """
44         Ensure an open connection to the email server. Return whether or not a
45         new connection was required (True or False) or None if an exception
46         passed silently.
47         """
48         if self.connection:
49             # Nothing to do if the connection is already open.
50             return False
51 
52         # If local_hostname is not specified, socket.getfqdn() gets used.
53         # For performance, we use the cached FQDN for local_hostname.
54         connection_params = {'local_hostname': DNS_NAME.get_fqdn()}
55         if self.timeout is not None:
56             connection_params['timeout'] = self.timeout
57         if self.use_ssl:
58             connection_params.update({
59                 'keyfile': self.ssl_keyfile,
60                 'certfile': self.ssl_certfile,
61             })
62         try:
63             self.connection = self.connection_class(self.host, self.port, **connection_params)
64 
65             # TLS/SSL are mutually exclusive, so only attempt TLS over
66             # non-secure connections.
67             if not self.use_ssl and self.use_tls:
68                 self.connection.starttls(keyfile=self.ssl_keyfile, certfile=self.ssl_certfile)
69             if self.username and self.password:
70                 self.connection.login(self.username, self.password)
71             return True
72         except (smtplib.SMTPException, socket.error):
73             if not self.fail_silently:
74                 raise
75 
76     def close(self):
77         """Close the connection to the email server."""
78         if self.connection is None:
79             return
80         try:
81             try:
82                 self.connection.quit()
83             except (ssl.SSLError, smtplib.SMTPServerDisconnected):
84                 # This happens when calling quit() on a TLS connection
85                 # sometimes, or when the connection was already disconnected
86                 # by the server.
87                 self.connection.close()
88             except smtplib.SMTPException:
89                 if self.fail_silently:
90                     return
91                 raise
92         finally:
93             self.connection = None
94 
95     def send_messages(self, email_messages):
96         """
97         Send one or more EmailMessage objects and return the number of email
98         messages sent.
99         """
100         if not email_messages:
101             return 0
102         with self._lock:
103             new_conn_created = self.open()
104             if not self.connection or new_conn_created is None:
105                 # We failed silently on open().
106                 # Trying to send would be pointless.
107                 return 0
108             num_sent = 0
109             for message in email_messages:
110                 sent = self._send(message)
111                 if sent:
112                     num_sent += 1
113             if new_conn_created:
114                 self.close()
115         return num_sent
116 
117     def _send(self, email_message):
118         """A helper method that does the actual sending."""
119         if not email_message.recipients():
120             return False
121         encoding = email_message.encoding or settings.DEFAULT_CHARSET
122         from_email = sanitize_address(email_message.from_email, encoding)
123         recipients = [sanitize_address(addr, encoding) for addr in email_message.recipients()]
124         message = email_message.message()
125         try:
126             self.connection.sendmail(from_email, recipients, message.as_bytes(linesep='\r\n'))
127         except smtplib.SMTPException:
128             if not self.fail_silently:
129                 raise
130             return False
131         return True

</code><intended_behavior>For SMTP operations, adjust to use OSError while considering to keep or remove specific catches for smtplib.SMTPException based on whether the additional granularity is required for email sending error handling.</intended_behavior>]
2025-10-15 15:53:47.840 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-15 15:53:47.841 | INFO     | Search-only: skipping patch selection
2025-10-15 15:53:47.998 | INFO     | Task django__django-10904 completed successfully.
2025-10-15 15:53:47.999 | INFO     | No patch generated. You can try running ACR again.
