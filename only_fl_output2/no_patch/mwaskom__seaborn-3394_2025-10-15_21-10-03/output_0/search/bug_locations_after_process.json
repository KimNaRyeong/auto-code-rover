[
    {
        "rel_file_path": "seaborn/_core/scales.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/mwaskom__seaborn/setup_mwaskom__seaborn__0.13/seaborn/_core/scales.py",
        "start": 164,
        "end": 200,
        "class_name": "Boolean",
        "method_name": "_setup",
        "code": "164     def _setup(\n165         self, data: Series, prop: Property, axis: Axis | None = None,\n166     ) -> Scale:\n167 \n168         new = copy(self)\n169         if new._tick_params is None:\n170             new = new.tick()\n171         if new._label_params is None:\n172             new = new.label()\n173 \n174         def na_safe_cast(x):\n175             # TODO this doesn't actually need to be a closure\n176             if np.isscalar(x):\n177                 return float(bool(x))\n178             else:\n179                 if hasattr(x, \"notna\"):\n180                     # Handle pd.NA; np<>pd interop with NA is tricky\n181                     use = x.notna().to_numpy()\n182                 else:\n183                     use = np.isfinite(x)\n184                 out = np.full(len(x), np.nan, dtype=float)\n185                 out[use] = x[use].astype(bool).astype(float)\n186                 return out\n187 \n188         new._pipeline = [na_safe_cast, prop.get_mapping(new, data)]\n189         new._spacer = _default_spacer\n190         if prop.legend:\n191             new._legend = [True, False], [\"True\", \"False\"]\n192 \n193         forward, inverse = _make_identity_transforms()\n194         mpl_scale = new._get_scale(str(data.name), forward, inverse)\n195 \n196         axis = PseudoAxis(mpl_scale) if axis is None else axis\n197         mpl_scale.set_default_locators_and_formatters(axis)\n198         new._matplotlib_scale = mpl_scale\n199 \n200         return new\n",
        "intended_behavior": "The method's handling of `pd.NA` values should ensure that these values do not affect the dataset's inherent order during plotting preparations. To resolve the issue, the method might need an enhancement to explicitly ensure that the conversion of boolean masks to NumPy arrays (for handling `pd.NA`) preserves the original ordering of data. This means checking and potentially adjusting the logic that deals with missing data to assure that axis ordering remains consistent, regardless of whether `pd.NA` or `np.nan` is used.\n- Further, ensure that when `pd.NA` values are filtered out or translated into a format that seaborn's plotting functions can understand, this process does not introduce any inconsistencies in data ordering. It might involve adding checks or adjustments after `use = x.notna().to_numpy()` to ensure that the subsequent operations on `use` do not misinterpret data ordering due to the presence of `pd.NA`.\n- This solution would preserve the existing functionality while correcting the unintended reversing of axis order when `pd.NA` is present. The key is maintaining a consistent approach to handling missing data across different data types, ensuring that `pd.NA` is adequately recognized and does not lead to unexpected plot behaviors."
    },
    {
        "rel_file_path": "seaborn/_core/scales.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/mwaskom__seaborn/setup_mwaskom__seaborn__0.13/seaborn/_core/scales.py",
        "start": 149,
        "end": 238,
        "class_name": "Boolean",
        "method_name": null,
        "code": "149 class Boolean(Scale):\n150     \"\"\"\n151     A scale with a discrete domain of True and False values.\n152 \n153     The behavior is similar to the :class:`Nominal` scale, but property\n154     mappings and legends will use a [True, False] ordering rather than\n155     a sort using numeric rules. Coordinate variables accomplish this by\n156     inverting axis limits so as to maintain underlying numeric positioning.\n157     Input data are cast to boolean values, respecting missing data.\n158 \n159     \"\"\"\n160     values: tuple | list | dict | None = None\n161 \n162     _priority: ClassVar[int] = 3\n163 \n164     def _setup(\n165         self, data: Series, prop: Property, axis: Axis | None = None,\n166     ) -> Scale:\n167 \n168         new = copy(self)\n169         if new._tick_params is None:\n170             new = new.tick()\n171         if new._label_params is None:\n172             new = new.label()\n173 \n174         def na_safe_cast(x):\n175             # TODO this doesn't actually need to be a closure\n176             if np.isscalar(x):\n177                 return float(bool(x))\n178             else:\n179                 if hasattr(x, \"notna\"):\n180                     # Handle pd.NA; np<>pd interop with NA is tricky\n181                     use = x.notna().to_numpy()\n182                 else:\n183                     use = np.isfinite(x)\n184                 out = np.full(len(x), np.nan, dtype=float)\n185                 out[use] = x[use].astype(bool).astype(float)\n186                 return out\n187 \n188         new._pipeline = [na_safe_cast, prop.get_mapping(new, data)]\n189         new._spacer = _default_spacer\n190         if prop.legend:\n191             new._legend = [True, False], [\"True\", \"False\"]\n192 \n193         forward, inverse = _make_identity_transforms()\n194         mpl_scale = new._get_scale(str(data.name), forward, inverse)\n195 \n196         axis = PseudoAxis(mpl_scale) if axis is None else axis\n197         mpl_scale.set_default_locators_and_formatters(axis)\n198         new._matplotlib_scale = mpl_scale\n199 \n200         return new\n201 \n202     def _finalize(self, p: Plot, axis: Axis) -> None:\n203 \n204         # We want values to appear in a True, False order but also want\n205         # True/False to be drawn at 1/0 positions respectively to avoid nasty\n206         # surprises if additional artists are added through the matplotlib API.\n207         # We accomplish this using axis inversion akin to what we do in Nominal.\n208 \n209         ax = axis.axes\n210         name = axis.axis_name\n211         axis.grid(False, which=\"both\")\n212         if name not in p._limits:\n213             nticks = len(axis.get_major_ticks())\n214             lo, hi = -.5, nticks - .5\n215             if name == \"x\":\n216                 lo, hi = hi, lo\n217             set_lim = getattr(ax, f\"set_{name}lim\")\n218             set_lim(lo, hi, auto=None)\n219 \n220     def tick(self, locator: Locator | None = None):\n221         new = copy(self)\n222         new._tick_params = {\"locator\": locator}\n223         return new\n224 \n225     def label(self, formatter: Formatter | None = None):\n226         new = copy(self)\n227         new._label_params = {\"formatter\": formatter}\n228         return new\n229 \n230     def _get_locators(self, locator):\n231         if locator is not None:\n232             return locator\n233         return FixedLocator([0, 1]), None\n234 \n235     def _get_formatter(self, locator, formatter):\n236         if formatter is not None:\n237             return formatter\n238         return FuncFormatter(lambda x, _: str(bool(x)))\n",
        "intended_behavior": "This class provides additional context to the issue."
    }
]