2025-10-16 02:49:50.330 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-16 02:49:58.875 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=397, output_tokens=12, cost=0.004330
2025-10-16 02:49:58.876 | INFO     | Test agent decides that the issue statement does not contain reproduction steps; skipping reproducer tracing
2025-10-16 02:49:58.879 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-16 02:50:08.735 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=529, output_tokens=399, cost=0.017260
2025-10-16 02:50:08.760 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-16 02:50:11.910 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=753, output_tokens=61, cost=0.009360
2025-10-16 02:50:11.912 | DEBUG    | Extracted a valid json.
2025-10-16 02:50:11.912 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_class(\"Normal\")",
        "search_class(\"Binomial\")",
        "search_class(\"Poisson\")",
        "search_method(\"check_parameters\")",
        "search_method(\"set_attributes\")"
    ],
    "bug_locations": []
}
2025-10-16 02:50:11.918 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-16 02:50:11.919 | DEBUG    | <Agent search> Analyzing search results.
2025-10-16 02:50:25.106 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1138, output_tokens=583, cost=0.028870
2025-10-16 02:50:25.121 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-16 02:50:39.469 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1937, output_tokens=591, cost=0.037100
2025-10-16 02:50:39.480 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-16 02:50:45.160 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=945, output_tokens=222, cost=0.016110
2025-10-16 02:50:45.161 | DEBUG    | Extracted a valid json.
2025-10-16 02:50:45.161 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "some_distribution_file.py",
            "class": "SomeDistribution",
            "method": "Potentially `__init__` or specific setter methods",
            "intended_behavior": "Methods responsible for initializing instances of distributions or setting their attributes should include comprehensive validation checks for all input parameters to ensure they meet the distribution's constraints (e.g., non-negative, within a specific range, or matching certain type expectations). Additionally, any attributes that are core to the distributions' functionality and consistency should be explicitly set during initialization or through dedicated methods with proper validations."
        },
        {
            "file": "another_distribution_file.py",
            "class": "AnotherDistribution",
            "intended_behavior": "If the issue indicates a systemic problem across multiple distributions, similar enhancements need to be implemented across all affected classes. This might involve adding new methods or enhancing existing ones to incorporate the missing checks and attribute setting. These methods should ensure the correctness and consistency of the distribution objects throughout their lifecycle."
        }
    ]
}
2025-10-16 02:50:45.167 | DEBUG    | Failed to retrieve code from all bug locations. Asking search agent to re-generate response.
2025-10-16 02:50:45.168 | DEBUG    | <Agent search> Downstream could not consume our last response. Will retry.
2025-10-16 02:50:45.168 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-16 02:50:59.687 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2562, output_tokens=595, cost=0.043470
2025-10-16 02:50:59.698 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-16 02:51:06.604 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=949, output_tokens=245, cost=0.016840
2025-10-16 02:51:06.605 | DEBUG    | Extracted a valid json.
2025-10-16 02:51:06.605 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_class_in_file('rv', 'sympy/stats/rv.py')",
        "search_class_in_file('distribution', 'sympy/stats/distribution.py')",
        "search_class('rv')",
        "search_code_in_file('__init__', 'sympy/stats/*.py')",
        "search_code('set_params()')"
    ],
    "bug_locations": [
        {
            "file": "sympy/stats/rv.py",
            "class": "",
            "method": "__init__",
            "intended_behavior": "Ensure that all constructor methods (__init__) of distribution classes perform comprehensive parameter validation, including checking for parameter types, value ranges, or other distribution-specific constraints."
        },
        {
            "file": "sympy/stats/distribution.py",
            "class": "",
            "method": "set_params",
            "intended_behavior": "Introduce or refine methods to include checks ensuring that attributes are not only set but are valid according to the distribution's requirements. If attributes are missing, reasonable defaults should be provided, or errors/exceptions should be raised to inform of incorrect usage."
        }
    ]
}
2025-10-16 02:51:06.660 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-16 02:51:06.661 | DEBUG    | <Agent search> Analyzing search results.
2025-10-16 02:51:20.943 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3403, output_tokens=640, cost=0.053230
2025-10-16 02:51:20.956 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-16 02:51:36.361 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=4259, output_tokens=507, cost=0.057800
2025-10-16 02:51:36.371 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-16 02:51:38.824 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=861, output_tokens=14, cost=0.009030
2025-10-16 02:51:38.825 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-16 02:51:38.825 | DEBUG    | Trying to convert API calls/bug locations into json. Try 2 of 5.
2025-10-16 02:51:40.954 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=861, output_tokens=14, cost=0.009030
2025-10-16 02:51:40.955 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-16 02:51:40.955 | DEBUG    | Trying to convert API calls/bug locations into json. Try 3 of 5.
2025-10-16 02:51:43.415 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=861, output_tokens=14, cost=0.009030
2025-10-16 02:51:43.416 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-16 02:51:43.416 | DEBUG    | Trying to convert API calls/bug locations into json. Try 4 of 5.
2025-10-16 02:51:44.838 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=861, output_tokens=14, cost=0.009030
2025-10-16 02:51:44.839 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-16 02:51:44.839 | DEBUG    | Trying to convert API calls/bug locations into json. Try 5 of 5.
2025-10-16 02:51:46.523 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=861, output_tokens=14, cost=0.009030
2025-10-16 02:51:46.524 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-16 02:51:46.530 | DEBUG    | Agent proxy return the following json: None
2025-10-16 02:51:46.531 | DEBUG    | Could not extract API calls from agent search response, asking search agent to re-generate response.
2025-10-16 02:51:46.531 | DEBUG    | <Agent search> Downstream could not consume our last response. Will retry.
2025-10-16 02:51:46.531 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-16 02:51:59.607 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=4793, output_tokens=527, cost=0.063740
2025-10-16 02:51:59.617 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-16 02:52:02.287 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=881, output_tokens=76, cost=0.011090
2025-10-16 02:52:02.288 | DEBUG    | Extracted a valid json.
2025-10-16 02:52:02.289 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_class(\"sympy.stats\")",
        "search_code(\"docstring\")",
        "search_code(\"comments\")",
        "search_code(\"distribution\")",
        "search_code(\"validate\")",
        "search_code(\"parameter\")",
        "search_code(\"attribute\")"
    ],
    "bug_locations": []
}
2025-10-16 02:52:07.352 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-16 02:52:07.353 | DEBUG    | <Agent search> Analyzing search results.
2025-10-16 02:52:26.515 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=11995, output_tokens=680, cost=0.140350
2025-10-16 02:52:26.527 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-16 02:52:42.723 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=12891, output_tokens=593, cost=0.146700
2025-10-16 02:52:42.735 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-16 02:52:54.806 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=947, output_tokens=399, cost=0.021440
2025-10-16 02:52:54.807 | DEBUG    | Extracted a valid json.
2025-10-16 02:52:54.807 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "sympy/stats/crv_types.py",
            "class": "Various distribution classes",
            "method": "Various methods, e.g., Normal.__init__",
            "intended_behavior": "Ensure the initialization methods of distribution classes rigorously validate input parameters against the mathematical constraints and logical rules applicable to those distributions. For example, in a Normal distribution, ensuring the standard deviation is positive. This preserves existing functionality by validating inputs that were previously assumed to be correct."
        },
        {
            "file": "sympy/stats/rv.py",
            "class": "",
            "method": "Methods handling parameter inputs, e.g., Rational.__new__",
            "intended_behavior": "Implement or enhance parameter checking logic to ensure that parameters passed to random variable creation functions meet the required constraints, throwing informative exceptions when invalid parameters are encountered. This would help in catching errors early and making debug processes more manageable for library users."
        },
        {
            "file": "sympy/stats/joint_rv_types.py",
            "class": "",
            "method": "Specific distribution methods requiring complex validations",
            "intended_behavior": "Where distributions involve multiple variables or parameters interdependent in complex ways, ensure validations account for these relationships accurately. This could include checking for matching dimensions between parameters or ensuring the parameters jointly fulfill specific criteria required for the model to work correctly."
        },
        {
            "file": "sympy/stats/drv_types.py",
            "class": "Discrete distributions, e.g., Poisson",
            "method": "",
            "intended_behavior": "For discrete distributions, include checks for the discreteness of parameters where applicable, such as ensuring rate parameters are positive numbers. Additionally, attributes that determine the distribution's behavior, like mean or variance, should be accurately calculated and stored upon validation of parameters."
        }
    ]
}
2025-10-16 02:52:54.817 | WARNING  | Too many fragments. Examine the method name: Methods handling parameter inputs, e.g., Rational.__new__
2025-10-16 02:52:54.824 | DEBUG    | Bug location extracted successfully: [<file>sympy/stats/crv_types.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2 Continuous Random Variables - Prebuilt variables
3 
4 Contains
5 ========
6 Arcsin
7 Benini
8 Beta
9 BetaNoncentral
10 BetaPrime
11 Cauchy
12 Chi
13 ChiNoncentral
14 ChiSquared
15 Dagum
16 Erlang
17 Exponential
18 FDistribution
19 FisherZ
20 Frechet
21 Gamma
22 GammaInverse
23 Gumbel
24 Gompertz
25 Kumaraswamy
26 Laplace
27 Logistic
28 LogNormal
29 Maxwell
30 Nakagami
31 Normal
32 Pareto
33 QuadraticU
34 RaisedCosine
35 Rayleigh
36 ShiftedGompertz
37 StudentT
38 Trapezoidal
39 Triangular
40 Uniform
41 UniformSum
42 VonMises
43 Weibull
44 WignerSemicircle
45 """
46 
47 from __future__ import print_function, division
48 
49 from sympy import (log, sqrt, pi, S, Dummy, Interval, sympify, gamma,
50                    Piecewise, And, Eq, binomial, factorial, Sum, floor, Abs,
51                    Lambda, Basic, lowergamma, erf, erfi,  erfinv, I, hyper,
52                    uppergamma, sinh, atan, Ne, expint)
53 
54 from sympy import beta as beta_fn
55 from sympy import cos, sin, tan, atan, exp, besseli, besselj, besselk
56 from sympy.external import import_module
57 from sympy.matrices import MatrixBase
58 from sympy.stats.crv import (SingleContinuousPSpace, SingleContinuousDistribution,
59         ContinuousDistributionHandmade)
60 from sympy.stats.joint_rv import JointPSpace, CompoundDistribution
61 from sympy.stats.joint_rv_types import multivariate_rv
62 from sympy.stats.rv import _value_check, RandomSymbol
63 import random
64 
65 oo = S.Infinity
66 
67 __all__ = ['ContinuousRV',
68 'Arcsin',
69 'Benini',
70 'Beta',
71 'BetaNoncentral',
72 'BetaPrime',
73 'Cauchy',
74 'Chi',
75 'ChiNoncentral',
76 'ChiSquared',
77 'Dagum',
78 'Erlang',
79 'Exponential',
80 'FDistribution',
81 'FisherZ',
82 'Frechet',
83 'Gamma',
84 'GammaInverse',
85 'Gompertz',
86 'Gumbel',
87 'Kumaraswamy',
88 'Laplace',
89 'Logistic',
90 'LogNormal',
91 'Maxwell',
92 'Nakagami',
93 'Normal',
94 'Pareto',
95 'QuadraticU',
96 'RaisedCosine',
97 'Rayleigh',
98 'StudentT',
99 'ShiftedGompertz',
100 'Trapezoidal',
101 'Triangular',
102 'Uniform',
103 'UniformSum',
104 'VonMises',
105 'Weibull',
106 'WignerSemicircle'
107 ]
108 
109 
110 
111 def ContinuousRV(symbol, density, set=Interval(-oo, oo)):
112     """
113     Create a Continuous Random Variable given the following:
114 
115     -- a symbol
116     -- a probability density function
117     -- set on which the pdf is valid (defaults to entire real line)
118 
119     Returns a RandomSymbol.
120 
121     Many common continuous random variable types are already implemented.
122     This function should be necessary only very rarely.
123 
124     Examples
125     ========
126 
127     >>> from sympy import Symbol, sqrt, exp, pi
128     >>> from sympy.stats import ContinuousRV, P, E
129 
130     >>> x = Symbol("x")
131 
132     >>> pdf = sqrt(2)*exp(-x**2/2)/(2*sqrt(pi)) # Normal distribution
133     >>> X = ContinuousRV(x, pdf)
134 
135     >>> E(X)
136     0
137     >>> P(X>0)
138     1/2
139     """
140     pdf = Piecewise((density, set.as_relational(symbol)), (0, True))
141     pdf = Lambda(symbol, pdf)
142     dist = ContinuousDistributionHandmade(pdf, set)
143     return SingleContinuousPSpace(symbol, dist).value
144 
145 
146 def rv(symbol, cls, args):
147     args = list(map(sympify, args))
148     dist = cls(*args)
149     dist.check(*args)
150     pspace = SingleContinuousPSpace(symbol, dist)
151     if any(isinstance(arg, RandomSymbol) for arg in args):
152         pspace = JointPSpace(symbol, CompoundDistribution(dist))
153     return pspace.value
154 
155 ########################################
156 # Continuous Probability Distributions #
157 ########################################
158 
159 #-------------------------------------------------------------------------------
160 # Arcsin distribution ----------------------------------------------------------
161 
162 
163 class ArcsinDistribution(SingleContinuousDistribution):
164     _argnames = ('a', 'b')
165 
166     def pdf(self, x):
167         return 1/(pi*sqrt((x - self.a)*(self.b - x)))
168 
169     def _cdf(self, x):
170         from sympy import asin
171         a, b = self.a, self.b
172         return Piecewise(
173             (S.Zero, x < a),
174             (2*asin(sqrt((x - a)/(b - a)))/pi, x <= b),
175             (S.One, True))
176 
177 
178 def Arcsin(name, a=0, b=1):
179     r"""
180     Create a Continuous Random Variable with an arcsin distribution.
181 
182     The density of the arcsin distribution is given by
183 
184     .. math::
185         f(x) := \frac{1}{\pi\sqrt{(x-a)(b-x)}}
186 
187     with :math:`x \in (a,b)`. It must hold that :math:`-\infty < a < b < \infty`.
188 
189     Parameters
190     ==========
191 
192     a : Real number, the left interval boundary
193     b : Real number, the right interval boundary
194 
195     Returns
196     =======
197 
198     A RandomSymbol.
199 
200     Examples
201     ========
202 
203     >>> from sympy.stats import Arcsin, density, cdf
204     >>> from sympy import Symbol, simplify
205 
206     >>> a = Symbol("a", real=True)
207     >>> b = Symbol("b", real=True)
208     >>> z = Symbol("z")
209 
210     >>> X = Arcsin("x", a, b)
211 
212     >>> density(X)(z)
213     1/(pi*sqrt((-a + z)*(b - z)))
214 
215     >>> cdf(X)(z)
216     Piecewise((0, a > z),
217             (2*asin(sqrt((-a + z)/(-a + b)))/pi, b >= z),
218             (1, True))
219 
220 
221     References
222     ==========
223 
224     .. [1] https://en.wikipedia.org/wiki/Arcsine_distribution
225 
226     """
227 
228     return rv(name, ArcsinDistribution, (a, b))
229 
230 #-------------------------------------------------------------------------------
231 # Benini distribution ----------------------------------------------------------
232 
233 
234 class BeniniDistribution(SingleContinuousDistribution):
235     _argnames = ('alpha', 'beta', 'sigma')
236 
237     @staticmethod
238     def check(alpha, beta, sigma):
239         _value_check(alpha > 0, "Shape parameter Alpha must be positive.")
240         _value_check(beta > 0, "Shape parameter Beta must be positive.")
241         _value_check(sigma > 0, "Scale parameter Sigma must be positive.")
242 
243     @property
244     def set(self):
245         return Interval(self.sigma, oo)
246 
247     def pdf(self, x):
248         alpha, beta, sigma = self.alpha, self.beta, self.sigma
249         return (exp(-alpha*log(x/sigma) - beta*log(x/sigma)**2)
250                *(alpha/x + 2*beta*log(x/sigma)/x))
251 
252     def _moment_generating_function(self, t):
253         raise NotImplementedError('The moment generating function of the '
254                                   'Benini distribution does not exist.')
255 
256 def Benini(name, alpha, beta, sigma):
257     r"""
258     Create a Continuous Random Variable with a Benini distribution.
259 
260     The density of the Benini distribution is given by
261 
262     .. math::
263         f(x) := e^{-\alpha\log{\frac{x}{\sigma}}
264                 -\beta\log^2\left[{\frac{x}{\sigma}}\right]}
265                 \left(\frac{\alpha}{x}+\frac{2\beta\log{\frac{x}{\sigma}}}{x}\right)
266 
267     This is a heavy-tailed distrubtion and is also known as the log-Rayleigh
268     distribution.
269 
270     Parameters
271     ==========
272 
273     alpha : Real number, `\alpha > 0`, a shape
274     beta : Real number, `\beta > 0`, a shape
275     sigma : Real number, `\sigma > 0`, a scale
276 
277     Returns
278     =======
279 
280     A RandomSymbol.
281 
282     Examples
283     ========
284 
285     >>> from sympy.stats import Benini, density, cdf
286     >>> from sympy import Symbol, simplify, pprint
287 
288     >>> alpha = Symbol("alpha", positive=True)
289     >>> beta = Symbol("beta", positive=True)
290     >>> sigma = Symbol("sigma", positive=True)
291     >>> z = Symbol("z")
292 
293     >>> X = Benini("x", alpha, beta, sigma)
294 
295     >>> D = density(X)(z)
296     >>> pprint(D, use_unicode=False)
297     /                  /  z  \\             /  z  \            2/  z  \
298     |        2*beta*log|-----||  - alpha*log|-----| - beta*log  |-----|
299     |alpha             \sigma/|             \sigma/             \sigma/
300     |----- + -----------------|*e
301     \  z             z        /
302 
303     >>> cdf(X)(z)
304     Piecewise((1 - exp(-alpha*log(z/sigma) - beta*log(z/sigma)**2), sigma <= z),
305             (0, True))
306 
307 
308     References
309     ==========
310 
311     .. [1] https://en.wikipedia.org/wiki/Benini_distribution
312     .. [2] http://reference.wolfram.com/legacy/v8/ref/BeniniDistribution.html
313 
314     """
315 
316     return rv(name, BeniniDistribution, (alpha, beta, sigma))
317 
318 #-------------------------------------------------------------------------------
319 # Beta distribution ------------------------------------------------------------
320 
321 
322 class BetaDistribution(SingleContinuousDistribution):
323     _argnames = ('alpha', 'beta')
324 
325     set = Interval(0, 1)
326 
327     @staticmethod
328     def check(alpha, beta):
329         _value_check(alpha > 0, "Shape parameter Alpha must be positive.")
330         _value_check(beta > 0, "Shape parameter Beta must be positive.")
331 
332     def pdf(self, x):
333         alpha, beta = self.alpha, self.beta
334         return x**(alpha - 1) * (1 - x)**(beta - 1) / beta_fn(alpha, beta)
335 
336     def sample(self):
337         return random.betavariate(self.alpha, self.beta)
338 
339     def _characteristic_function(self, t):
340         return hyper((self.alpha,), (self.alpha + self.beta,), I*t)
341 
342     def _moment_generating_function(self, t):
343         return hyper((self.alpha,), (self.alpha + self.beta,), t)
344 
345 def Beta(name, alpha, beta):
346     r"""
347     Create a Continuous Random Variable with a Beta distribution.
348 
349     The density of the Beta distribution is given by
350 
351     .. math::
352         f(x) := \frac{x^{\alpha-1}(1-x)^{\beta-1}} {\mathrm{B}(\alpha,\beta)}
353 
354     with :math:`x \in [0,1]`.
355 
356     Parameters
357     ==========
358 
359     alpha : Real number, `\alpha > 0`, a shape
360     beta : Real number, `\beta > 0`, a shape
361 
362     Returns
363     =======
364 
365     A RandomSymbol.
366 
367     Examples
368     ========
369 
370     >>> from sympy.stats import Beta, density, E, variance
371     >>> from sympy import Symbol, simplify, pprint, factor
372 
373     >>> alpha = Symbol("alpha", positive=True)
374     >>> beta = Symbol("beta", positive=True)
375     >>> z = Symbol("z")
376 
377     >>> X = Beta("x", alpha, beta)
378 
379     >>> D = density(X)(z)
380     >>> pprint(D, use_unicode=False)
381      alpha - 1        beta - 1
382     z         *(1 - z)
383     --------------------------
384           B(alpha, beta)
385 
386     >>> simplify(E(X))
387     alpha/(alpha + beta)
388 
389     >>> factor(simplify(variance(X)))  #doctest: +SKIP
390     alpha*beta/((alpha + beta)**2*(alpha + beta + 1))
391 
392     References
393     ==========
394 
395     .. [1] https://en.wikipedia.org/wiki/Beta_distribution
396     .. [2] http://mathworld.wolfram.com/BetaDistribution.html
397 
398     """
399 
400     return rv(name, BetaDistribution, (alpha, beta))
401 
402 #-------------------------------------------------------------------------------
403 # Noncentral Beta distribution ------------------------------------------------------------
404 
405 
406 class BetaNoncentralDistribution(SingleContinuousDistribution):
407     _argnames = ('alpha', 'beta', 'lamda')
408 
409     set = Interval(0, 1)
410 
411     @staticmethod
412     def check(alpha, beta, lamda):
413         _value_check(alpha > 0, "Shape parameter Alpha must be positive.")
414         _value_check(beta > 0, "Shape parameter Beta must be positive.")
415         _value_check(lamda >= 0, "Noncentrality parameter Lambda must be positive")
416 
417     def pdf(self, x):
418         alpha, beta, lamda = self.alpha, self.beta, self.lamda
419         k = Dummy("k")
420         return Sum(exp(-lamda / 2) * (lamda / 2)**k * x**(alpha + k - 1) *(
421             1 - x)**(beta - 1) / (factorial(k) * beta_fn(alpha + k, beta)), (k, 0, oo))
422 
423 def BetaNoncentral(name, alpha, beta, lamda):
424     r"""
425     Create a Continuous Random Variable with a Type I Noncentral Beta distribution.
426 
427     The density of the Noncentral Beta distribution is given by
428 
429     .. math::
430         f(x) := \sum_{k=0}^\infty e^{-\lambda/2}\frac{(\lambda/2)^k}{k!}
431                 \frac{x^{\alpha+k-1}(1-x)^{\beta-1}}{\mathrm{B}(\alpha+k,\beta)}
432 
433     with :math:`x \in [0,1]`.
434 
435     Parameters
436     ==========
437 
438     alpha : Real number, `\alpha > 0`, a shape
439     beta : Real number, `\beta > 0`, a shape
440     lamda: Real number, `\lambda >= 0`, noncentrality parameter
441 
442     Returns
443     =======
444 
445     A RandomSymbol.
446 
447     Examples
448     ========
449 
450     >>> from sympy.stats import BetaNoncentral, density, cdf
451     >>> from sympy import Symbol, pprint
452 
453     >>> alpha = Symbol("alpha", positive=True)
454     >>> beta = Symbol("beta", positive=True)
455     >>> lamda = Symbol("lamda", nonnegative=True)
456     >>> z = Symbol("z")
457 
458     >>> X = BetaNoncentral("x", alpha, beta, lamda)
459 
460     >>> D = density(X)(z)
461     >>> pprint(D, use_unicode=False)
462       oo
463     _____
464     \    `
465      \                                              -lamda
466       \                          k                  -------
467        \    k + alpha - 1 /lamda\         beta - 1     2
468         )  z             *|-----| *(1 - z)        *e
469        /                  \  2  /
470       /    ------------------------------------------------
471      /                  B(k + alpha, beta)*k!
472     /____,
473     k = 0
474 
475     Compute cdf with specific 'x', 'alpha', 'beta' and 'lamda' values as follows :
476     >>> cdf(BetaNoncentral("x", 1, 1, 1), evaluate=False)(2).doit()
477     exp(-1/2)*Integral(Sum(2**(-_k)*_x**_k/(beta(_k + 1, 1)*factorial(_k)), (_k, 0, oo)), (_x, 0, 2))
478 
479     The argument evaluate=False prevents an attempt at evaluation
480     of the sum for general x, before the argument 2 is passed.
481 
482     References
483     ==========
484 
485     .. [1] https://en.wikipedia.org/wiki/Noncentral_beta_distribution
486     .. [2] https://reference.wolfram.com/language/ref/NoncentralBetaDistribution.html
487 
488     """
489 
490     return rv(name, BetaNoncentralDistribution, (alpha, beta, lamda))
491 
492 
493 #-------------------------------------------------------------------------------
494 # Beta prime distribution ------------------------------------------------------
495 
496 
497 class BetaPrimeDistribution(SingleContinuousDistribution):
498     _argnames = ('alpha', 'beta')
499 
500     @staticmethod
501     def check(alpha, beta):
502         _value_check(alpha > 0, "Shape parameter Alpha must be positive.")
503         _value_check(beta > 0, "Shape parameter Beta must be positive.")
504 
505     set = Interval(0, oo)
506 
507     def pdf(self, x):
508         alpha, beta = self.alpha, self.beta
509         return x**(alpha - 1)*(1 + x)**(-alpha - beta)/beta_fn(alpha, beta)
510 
511 def BetaPrime(name, alpha, beta):
512     r"""
513     Create a continuous random variable with a Beta prime distribution.
514 
515     The density of the Beta prime distribution is given by
516 
517     .. math::
518         f(x) := \frac{x^{\alpha-1} (1+x)^{-\alpha -\beta}}{B(\alpha,\beta)}
519 
520     with :math:`x > 0`.
521 
522     Parameters
523     ==========
524 
525     alpha : Real number, `\alpha > 0`, a shape
526     beta : Real number, `\beta > 0`, a shape
527 
528     Returns
529     =======
530 
531     A RandomSymbol.
532 
533     Examples
534     ========
535 
536     >>> from sympy.stats import BetaPrime, density
537     >>> from sympy import Symbol, pprint
538 
539     >>> alpha = Symbol("alpha", positive=True)
540     >>> beta = Symbol("beta", positive=True)
541     >>> z = Symbol("z")
542 
543     >>> X = BetaPrime("x", alpha, beta)
544 
545     >>> D = density(X)(z)
546     >>> pprint(D, use_unicode=False)
547      alpha - 1        -alpha - beta
548     z         *(z + 1)
549     -------------------------------
550              B(alpha, beta)
551 
552     References
553     ==========
554 
555     .. [1] https://en.wikipedia.org/wiki/Beta_prime_distribution
556     .. [2] http://mathworld.wolfram.com/BetaPrimeDistribution.html
557 
558     """
559 
560     return rv(name, BetaPrimeDistribution, (alpha, beta))
561 
562 #-------------------------------------------------------------------------------
563 # Cauchy distribution ----------------------------------------------------------
564 
565 
566 class CauchyDistribution(SingleContinuousDistribution):
567     _argnames = ('x0', 'gamma')
568 
569     @staticmethod
570     def check(x0, gamma):
571         _value_check(gamma > 0, "Scale parameter Gamma must be positive.")
572 
573     def pdf(self, x):
574         return 1/(pi*self.gamma*(1 + ((x - self.x0)/self.gamma)**2))
575 
576     def _cdf(self, x):
577         x0, gamma = self.x0, self.gamma
578         return (1/pi)*atan((x - x0)/gamma) + S.Half
579 
580     def _characteristic_function(self, t):
581         return exp(self.x0 * I * t -  self.gamma * Abs(t))
582 
583     def _moment_generating_function(self, t):
584         raise NotImplementedError("The moment generating function for the "
585                                   "Cauchy distribution does not exist.")
586 
587     def _quantile(self, p):
588         return self.x0 + self.gamma*tan(pi*(p - S.Half))
589 
590 def Cauchy(name, x0, gamma):
591     r"""
592     Create a continuous random variable with a Cauchy distribution.
593 
594     The density of the Cauchy distribution is given by
595 
596     .. math::
597         f(x) := \frac{1}{\pi \gamma [1 + {(\frac{x-x_0}{\gamma})}^2]}
598 
599     Parameters
600     ==========
601 
602     x0 : Real number, the location
603     gamma : Real number, `\gamma > 0`, a scale
604 
605     Returns
606     =======
607 
608     A RandomSymbol.
609 
610     Examples
611     ========
612 
613     >>> from sympy.stats import Cauchy, density
614     >>> from sympy import Symbol
615 
616     >>> x0 = Symbol("x0")
617     >>> gamma = Symbol("gamma", positive=True)
618     >>> z = Symbol("z")
619 
620     >>> X = Cauchy("x", x0, gamma)
621 
622     >>> density(X)(z)
623     1/(pi*gamma*(1 + (-x0 + z)**2/gamma**2))
624 
625     References
626     ==========
627 
628     .. [1] https://en.wikipedia.org/wiki/Cauchy_distribution
629     .. [2] http://mathworld.wolfram.com/CauchyDistribution.html
630 
631     """
632 
633     return rv(name, CauchyDistribution, (x0, gamma))
634 
635 #-------------------------------------------------------------------------------
636 # Chi distribution -------------------------------------------------------------
637 
638 
639 class ChiDistribution(SingleContinuousDistribution):
640     _argnames = ('k',)
641 
642     @staticmethod
643     def check(k):
644         _value_check(k > 0, "Number of degrees of freedom (k) must be positive.")
645         _value_check(k.is_integer, "Number of degrees of freedom (k) must be an integer.")
646 
647     set = Interval(0, oo)
648 
649     def pdf(self, x):
650         return 2**(1 - self.k/2)*x**(self.k - 1)*exp(-x**2/2)/gamma(self.k/2)
651 
652     def _characteristic_function(self, t):
653         k = self.k
654 
655         part_1 = hyper((k/2,), (S(1)/2,), -t**2/2)
656         part_2 = I*t*sqrt(2)*gamma((k+1)/2)/gamma(k/2)
657         part_3 = hyper(((k+1)/2,), (S(3)/2,), -t**2/2)
658         return part_1 + part_2*part_3
659 
660     def _moment_generating_function(self, t):
661         k = self.k
662 
663         part_1 = hyper((k / 2,), (S(1) / 2,), t ** 2 / 2)
664         part_2 = t * sqrt(2) * gamma((k + 1) / 2) / gamma(k / 2)
665         part_3 = hyper(((k + 1) / 2,), (S(3) / 2,), t ** 2 / 2)
666         return part_1 + part_2 * part_3
667 
668 def Chi(name, k):
669     r"""
670     Create a continuous random variable with a Chi distribution.
671 
672     The density of the Chi distribution is given by
673 
674     .. math::
675         f(x) := \frac{2^{1-k/2}x^{k-1}e^{-x^2/2}}{\Gamma(k/2)}
676 
677     with :math:`x \geq 0`.
678 
679     Parameters
680     ==========
681 
682     k : Positive integer, The number of degrees of freedom
683 
684     Returns
685     =======
686 
687     A RandomSymbol.
688 
689     Examples
690     ========
691 
692     >>> from sympy.stats import Chi, density, E
693     >>> from sympy import Symbol, simplify
694 
695     >>> k = Symbol("k", integer=True)
696     >>> z = Symbol("z")
697 
698     >>> X = Chi("x", k)
699 
700     >>> density(X)(z)
701     2**(1 - k/2)*z**(k - 1)*exp(-z**2/2)/gamma(k/2)
702 
703     >>> simplify(E(X))
704     sqrt(2)*gamma(k/2 + 1/2)/gamma(k/2)
705 
706     References
707     ==========
708 
709     .. [1] https://en.wikipedia.org/wiki/Chi_distribution
710     .. [2] http://mathworld.wolfram.com/ChiDistribution.html
711 
712     """
713 
714     return rv(name, ChiDistribution, (k,))
715 
716 #-------------------------------------------------------------------------------
717 # Non-central Chi distribution -------------------------------------------------
718 
719 
720 class ChiNoncentralDistribution(SingleContinuousDistribution):
721     _argnames = ('k', 'l')
722 
723     @staticmethod
724     def check(k, l):
725         _value_check(k > 0, "Number of degrees of freedom (k) must be positive.")
726         _value_check(k.is_integer, "Number of degrees of freedom (k) must be an integer.")
727         _value_check(l > 0, "Shift parameter Lambda must be positive.")
728 
729     set = Interval(0, oo)
730 
731     def pdf(self, x):
732         k, l = self.k, self.l
733         return exp(-(x**2+l**2)/2)*x**k*l / (l*x)**(k/2) * besseli(k/2-1, l*x)
734 
735 def ChiNoncentral(name, k, l):
736     r"""
737     Create a continuous random variable with a non-central Chi distribution.
738 
739     The density of the non-central Chi distribution is given by
740 
741     .. math::
742         f(x) := \frac{e^{-(x^2+\lambda^2)/2} x^k\lambda}
743                 {(\lambda x)^{k/2}} I_{k/2-1}(\lambda x)
744 
745     with `x \geq 0`. Here, `I_\nu (x)` is the
746     :ref:`modified Bessel function of the first kind <besseli>`.
747 
748     Parameters
749     ==========
750 
751     k : A positive Integer, `k > 0`, the number of degrees of freedom
752     lambda : Real number, `\lambda > 0`, Shift parameter
753 
754     Returns
755     =======
756 
757     A RandomSymbol.
758 
759     Examples
760     ========
761 
762     >>> from sympy.stats import ChiNoncentral, density
763     >>> from sympy import Symbol
764 
765     >>> k = Symbol("k", integer=True)
766     >>> l = Symbol("l")
767     >>> z = Symbol("z")
768 
769     >>> X = ChiNoncentral("x", k, l)
770 
771     >>> density(X)(z)
772     l*z**k*(l*z)**(-k/2)*exp(-l**2/2 - z**2/2)*besseli(k/2 - 1, l*z)
773 
774     References
775     ==========
776 
777     .. [1] https://en.wikipedia.org/wiki/Noncentral_chi_distribution
778     """
779 
780     return rv(name, ChiNoncentralDistribution, (k, l))
781 
782 #-------------------------------------------------------------------------------
783 # Chi squared distribution -----------------------------------------------------
784 
785 
786 class ChiSquaredDistribution(SingleContinuousDistribution):
787     _argnames = ('k',)
788 
789     @staticmethod
790     def check(k):
791         _value_check(k > 0, "Number of degrees of freedom (k) must be positive.")
792         _value_check(k.is_integer, "Number of degrees of freedom (k) must be an integer.")
793 
794     set = Interval(0, oo)
795 
796     def pdf(self, x):
797         k = self.k
798         return 1/(2**(k/2)*gamma(k/2))*x**(k/2 - 1)*exp(-x/2)
799 
800     def _cdf(self, x):
801         k = self.k
802         return Piecewise(
803                 (S.One/gamma(k/2)*lowergamma(k/2, x/2), x >= 0),
804                 (0, True)
805         )
806 
807     def _characteristic_function(self, t):
808         return (1 - 2*I*t)**(-self.k/2)
809 
810     def  _moment_generating_function(self, t):
811         return (1 - 2*t)**(-self.k/2)
812 
813 def ChiSquared(name, k):
814     r"""
815     Create a continuous random variable with a Chi-squared distribution.
816 
817     The density of the Chi-squared distribution is given by
818 
819     .. math::
820         f(x) := \frac{1}{2^{\frac{k}{2}}\Gamma\left(\frac{k}{2}\right)}
821                 x^{\frac{k}{2}-1} e^{-\frac{x}{2}}
822 
823     with :math:`x \geq 0`.
824 
825     Parameters
826     ==========
827 
828     k : Positive integer, The number of degrees of freedom
829 
830     Returns
831     =======
832 
833     A RandomSymbol.
834 
835     Examples
836     ========
837 
838     >>> from sympy.stats import ChiSquared, density, E, variance, moment
839     >>> from sympy import Symbol
840 
841     >>> k = Symbol("k", integer=True, positive=True)
842     >>> z = Symbol("z")
843 
844     >>> X = ChiSquared("x", k)
845 
846     >>> density(X)(z)
847     2**(-k/2)*z**(k/2 - 1)*exp(-z/2)/gamma(k/2)
848 
849     >>> E(X)
850     k
851 
852     >>> variance(X)
853     2*k
854 
855     >>> moment(X, 3)
856     k**3 + 6*k**2 + 8*k
857 
858     References
859     ==========
860 
861     .. [1] https://en.wikipedia.org/wiki/Chi_squared_distribution
862     .. [2] http://mathworld.wolfram.com/Chi-SquaredDistribution.html
863     """
864 
865     return rv(name, ChiSquaredDistribution, (k, ))
866 
867 #-------------------------------------------------------------------------------
868 # Dagum distribution -----------------------------------------------------------
869 
870 
871 class DagumDistribution(SingleContinuousDistribution):
872     _argnames = ('p', 'a', 'b')
873 
874     @staticmethod
875     def check(p, a, b):
876         _value_check(p > 0, "Shape parameter p must be positive.")
877         _value_check(a > 0, "Shape parameter a must be positive.")
878         _value_check(b > 0, "Scale parameter b must be positive.")
879 
880     def pdf(self, x):
881         p, a, b = self.p, self.a, self.b
882         return a*p/x*((x/b)**(a*p)/(((x/b)**a + 1)**(p + 1)))
883 
884     def _cdf(self, x):
885         p, a, b = self.p, self.a, self.b
886         return Piecewise(((S.One + (S(x)/b)**-a)**-p, x>=0),
887                     (S.Zero, True))
888 
889 def Dagum(name, p, a, b):
890     r"""
891     Create a continuous random variable with a Dagum distribution.
892 
893     The density of the Dagum distribution is given by
894 
895     .. math::
896         f(x) := \frac{a p}{x} \left( \frac{\left(\tfrac{x}{b}\right)^{a p}}
897                 {\left(\left(\tfrac{x}{b}\right)^a + 1 \right)^{p+1}} \right)
898 
899     with :math:`x > 0`.
900 
901     Parameters
902     ==========
903 
904     p : Real number, `p > 0`, a shape
905     a : Real number, `a > 0`, a shape
906     b : Real number, `b > 0`, a scale
907 
908     Returns
909     =======
910 
911     A RandomSymbol.
912 
913     Examples
914     ========
915 
916     >>> from sympy.stats import Dagum, density, cdf
917     >>> from sympy import Symbol
918 
919     >>> p = Symbol("p", positive=True)
920     >>> a = Symbol("a", positive=True)
921     >>> b = Symbol("b", positive=True)
922     >>> z = Symbol("z")
923 
924     >>> X = Dagum("x", p, a, b)
925 
926     >>> density(X)(z)
927     a*p*(z/b)**(a*p)*((z/b)**a + 1)**(-p - 1)/z
928 
929     >>> cdf(X)(z)
930     Piecewise(((1 + (z/b)**(-a))**(-p), z >= 0), (0, True))
931 
932 
933     References
934     ==========
935 
936     .. [1] https://en.wikipedia.org/wiki/Dagum_distribution
937 
938     """
939 
940     return rv(name, DagumDistribution, (p, a, b))
941 
942 #-------------------------------------------------------------------------------
943 # Erlang distribution ----------------------------------------------------------
944 
945 
946 def Erlang(name, k, l):
947     r"""
948     Create a continuous random variable with an Erlang distribution.
949 
950     The density of the Erlang distribution is given by
951 
952     .. math::
953         f(x) := \frac{\lambda^k x^{k-1} e^{-\lambda x}}{(k-1)!}
954 
955     with :math:`x \in [0,\infty]`.
956 
957     Parameters
958     ==========
959 
960     k : Positive integer
961     l : Real number, `\lambda > 0`, the rate
962 
963     Returns
964     =======
965 
966     A RandomSymbol.
967 
968     Examples
969     ========
970 
971     >>> from sympy.stats import Erlang, density, cdf, E, variance
972     >>> from sympy import Symbol, simplify, pprint
973 
974     >>> k = Symbol("k", integer=True, positive=True)
975     >>> l = Symbol("l", positive=True)
976     >>> z = Symbol("z")
977 
978     >>> X = Erlang("x", k, l)
979 
980     >>> D = density(X)(z)
981     >>> pprint(D, use_unicode=False)
982      k  k - 1  -l*z
983     l *z     *e
984     ---------------
985         Gamma(k)
986 
987     >>> C = cdf(X)(z)
988     >>> pprint(C, use_unicode=False)
989     /lowergamma(k, l*z)
990     |------------------  for z > 0
991     <     Gamma(k)
992     |
993     \        0           otherwise
994 
995 
996     >>> E(X)
997     k/l
998 
999     >>> simplify(variance(X))
1000     k/l**2
1001 
1002     References
1003     ==========
1004 
1005     .. [1] https://en.wikipedia.org/wiki/Erlang_distribution
1006     .. [2] http://mathworld.wolfram.com/ErlangDistribution.html
1007 
1008     """
1009 
1010     return rv(name, GammaDistribution, (k, S.One/l))
1011 
1012 #-------------------------------------------------------------------------------
1013 # Exponential distribution -----------------------------------------------------
1014 
1015 
1016 class ExponentialDistribution(SingleContinuousDistribution):
1017     _argnames = ('rate',)
1018 
1019     set  = Interval(0, oo)
1020 
1021     @staticmethod
1022     def check(rate):
1023         _value_check(rate > 0, "Rate must be positive.")
1024 
1025     def pdf(self, x):
1026         return self.rate * exp(-self.rate*x)
1027 
1028     def sample(self):
1029         return random.expovariate(self.rate)
1030 
1031     def _cdf(self, x):
1032         return Piecewise(
1033                 (S.One - exp(-self.rate*x), x >= 0),
1034                 (0, True),
1035         )
1036 
1037     def _characteristic_function(self, t):
1038         rate = self.rate
1039         return rate / (rate - I*t)
1040 
1041     def _moment_generating_function(self, t):
1042         rate = self.rate
1043         return rate / (rate - t)
1044 
1045     def _quantile(self, p):
1046         return -log(1-p)/self.rate
1047 
1048 def Exponential(name, rate):
1049     r"""
1050     Create a continuous random variable with an Exponential distribution.
1051 
1052     The density of the exponential distribution is given by
1053 
1054     .. math::
1055         f(x) := \lambda \exp(-\lambda x)
1056 
1057     with `x > 0`. Note that the expected value is `1/\lambda`.
1058 
1059     Parameters
1060     ==========
1061 
1062     rate : A positive Real number, `\lambda > 0`, the rate (or inverse scale/inverse mean)
1063 
1064     Returns
1065     =======
1066 
1067     A RandomSymbol.
1068 
1069     Examples
1070     ========
1071 
1072     >>> from sympy.stats import Exponential, density, cdf, E
1073     >>> from sympy.stats import variance, std, skewness, quantile
1074     >>> from sympy import Symbol, symbols
1075 
1076     >>> l = Symbol("lambda", positive=True)
1077     >>> z = Symbol("z")
1078     >>> p = Symbol("p")
1079     >>> X = Exponential("x", l)
1080 
1081     >>> density(X)(z)
1082     lambda*exp(-lambda*z)
1083 
1084     >>> cdf(X)(z)
1085     Piecewise((1 - exp(-lambda*z), z >= 0), (0, True))
1086 
1087     >>> quantile(X)(p)
1088     -log(1 - p)/lambda
1089 
1090     >>> E(X)
1091     1/lambda
1092 
1093     >>> variance(X)
1094     lambda**(-2)
1095 
1096     >>> skewness(X)
1097     2
1098 
1099     >>> X = Exponential('x', 10)
1100 
1101     >>> density(X)(z)
1102     10*exp(-10*z)
1103 
1104     >>> E(X)
1105     1/10
1106 
1107     >>> std(X)
1108     1/10
1109 
1110     References
1111     ==========
1112 
1113     .. [1] https://en.wikipedia.org/wiki/Exponential_distribution
1114     .. [2] http://mathworld.wolfram.com/ExponentialDistribution.html
1115 
1116     """
1117 
1118     return rv(name, ExponentialDistribution, (rate, ))
1119 
1120 #-------------------------------------------------------------------------------
1121 # F distribution ---------------------------------------------------------------
1122 
1123 
1124 class FDistributionDistribution(SingleContinuousDistribution):
1125     _argnames = ('d1', 'd2')
1126 
1127     set = Interval(0, oo)
1128 
1129     @staticmethod
1130     def check(d1, d2):
1131         _value_check((d1 > 0, d1.is_integer),
1132             "Degrees of freedom d1 must be positive integer.")
1133         _value_check((d2 > 0, d2.is_integer),
1134             "Degrees of freedom d2 must be positive integer.")
1135 
1136     def pdf(self, x):
1137         d1, d2 = self.d1, self.d2
1138         return (sqrt((d1*x)**d1*d2**d2 / (d1*x+d2)**(d1+d2))
1139                / (x * beta_fn(d1/2, d2/2)))
1140 
1141     def _moment_generating_function(self, t):
1142         raise NotImplementedError('The moment generating function for the '
1143                                   'F-distribution does not exist.')
1144 
1145 def FDistribution(name, d1, d2):
1146     r"""
1147     Create a continuous random variable with a F distribution.
1148 
1149     The density of the F distribution is given by
1150 
1151     .. math::
1152         f(x) := \frac{\sqrt{\frac{(d_1 x)^{d_1} d_2^{d_2}}
1153                 {(d_1 x + d_2)^{d_1 + d_2}}}}
1154                 {x \mathrm{B} \left(\frac{d_1}{2}, \frac{d_2}{2}\right)}
1155 
1156     with :math:`x > 0`.
1157 
1158     Parameters
1159     ==========
1160 
1161     d1 : `d_1 > 0`, where d_1 is the degrees of freedom (n_1 - 1)
1162     d2 : `d_2 > 0`, where d_2 is the degrees of freedom (n_2 - 1)
1163 
1164     Returns
1165     =======
1166 
1167     A RandomSymbol.
1168 
1169     Examples
1170     ========
1171 
1172     >>> from sympy.stats import FDistribution, density
1173     >>> from sympy import Symbol, simplify, pprint
1174 
1175     >>> d1 = Symbol("d1", positive=True)
1176     >>> d2 = Symbol("d2", positive=True)
1177     >>> z = Symbol("z")
1178 
1179     >>> X = FDistribution("x", d1, d2)
1180 
1181     >>> D = density(X)(z)
1182     >>> pprint(D, use_unicode=False)
1183       d2
1184       --    ______________________________
1185       2    /       d1            -d1 - d2
1186     d2  *\/  (d1*z)  *(d1*z + d2)
1187     --------------------------------------
1188                     /d1  d2\
1189                  z*B|--, --|
1190                     \2   2 /
1191 
1192     References
1193     ==========
1194 
1195     .. [1] https://en.wikipedia.org/wiki/F-distribution
1196     .. [2] http://mathworld.wolfram.com/F-Distribution.html
1197 
1198     """
1199 
1200     return rv(name, FDistributionDistribution, (d1, d2))
1201 
1202 #-------------------------------------------------------------------------------
1203 # Fisher Z distribution --------------------------------------------------------
1204 
1205 class FisherZDistribution(SingleContinuousDistribution):
1206     _argnames = ('d1', 'd2')
1207 
1208     def pdf(self, x):
1209         d1, d2 = self.d1, self.d2
1210         return (2*d1**(d1/2)*d2**(d2/2) / beta_fn(d1/2, d2/2) *
1211                exp(d1*x) / (d1*exp(2*x)+d2)**((d1+d2)/2))
1212 
1213 def FisherZ(name, d1, d2):
1214     r"""
1215     Create a Continuous Random Variable with an Fisher's Z distribution.
1216 
1217     The density of the Fisher's Z distribution is given by
1218 
1219     .. math::
1220         f(x) := \frac{2d_1^{d_1/2} d_2^{d_2/2}} {\mathrm{B}(d_1/2, d_2/2)}
1221                 \frac{e^{d_1z}}{\left(d_1e^{2z}+d_2\right)^{\left(d_1+d_2\right)/2}}
1222 
1223 
1224     .. TODO - What is the difference between these degrees of freedom?
1225 
1226     Parameters
1227     ==========
1228 
1229     d1 : `d_1 > 0`, degree of freedom
1230     d2 : `d_2 > 0`, degree of freedom
1231 
1232     Returns
1233     =======
1234 
1235     A RandomSymbol.
1236 
1237     Examples
1238     ========
1239 
1240     >>> from sympy.stats import FisherZ, density
1241     >>> from sympy import Symbol, simplify, pprint
1242 
1243     >>> d1 = Symbol("d1", positive=True)
1244     >>> d2 = Symbol("d2", positive=True)
1245     >>> z = Symbol("z")
1246 
1247     >>> X = FisherZ("x", d1, d2)
1248 
1249     >>> D = density(X)(z)
1250     >>> pprint(D, use_unicode=False)
1251                                 d1   d2
1252         d1   d2               - -- - --
1253         --   --                 2    2
1254         2    2  /    2*z     \           d1*z
1255     2*d1  *d2  *\d1*e    + d2/         *e
1256     -----------------------------------------
1257                      /d1  d2\
1258                     B|--, --|
1259                      \2   2 /
1260 
1261     References
1262     ==========
1263 
1264     .. [1] https://en.wikipedia.org/wiki/Fisher%27s_z-distribution
1265     .. [2] http://mathworld.wolfram.com/Fishersz-Distribution.html
1266 
1267     """
1268 
1269     return rv(name, FisherZDistribution, (d1, d2))
1270 
1271 #-------------------------------------------------------------------------------
1272 # Frechet distribution ---------------------------------------------------------
1273 
1274 class FrechetDistribution(SingleContinuousDistribution):
1275     _argnames = ('a', 's', 'm')
1276 
1277     set = Interval(0, oo)
1278 
1279     def __new__(cls, a, s=1, m=0):
1280         a, s, m = list(map(sympify, (a, s, m)))
1281         return Basic.__new__(cls, a, s, m)
1282 
1283     def pdf(self, x):
1284         a, s, m = self.a, self.s, self.m
1285         return a/s * ((x-m)/s)**(-1-a) * exp(-((x-m)/s)**(-a))
1286 
1287     def _cdf(self, x):
1288         a, s, m = self.a, self.s, self.m
1289         return Piecewise((exp(-((x-m)/s)**(-a)), x >= m),
1290                         (S.Zero, True))
1291 
1292 def Frechet(name, a, s=1, m=0):
1293     r"""
1294     Create a continuous random variable with a Frechet distribution.
1295 
1296     The density of the Frechet distribution is given by
1297 
1298     .. math::
1299         f(x) := \frac{\alpha}{s} \left(\frac{x-m}{s}\right)^{-1-\alpha}
1300                  e^{-(\frac{x-m}{s})^{-\alpha}}
1301 
1302     with :math:`x \geq m`.
1303 
1304     Parameters
1305     ==========
1306 
1307     a : Real number, :math:`a \in \left(0, \infty\right)` the shape
1308     s : Real number, :math:`s \in \left(0, \infty\right)` the scale
1309     m : Real number, :math:`m \in \left(-\infty, \infty\right)` the minimum
1310 
1311     Returns
1312     =======
1313 
1314     A RandomSymbol.
1315 
1316     Examples
1317     ========
1318 
1319     >>> from sympy.stats import Frechet, density, E, std, cdf
1320     >>> from sympy import Symbol, simplify
1321 
1322     >>> a = Symbol("a", positive=True)
1323     >>> s = Symbol("s", positive=True)
1324     >>> m = Symbol("m", real=True)
1325     >>> z = Symbol("z")
1326 
1327     >>> X = Frechet("x", a, s, m)
1328 
1329     >>> density(X)(z)
1330     a*((-m + z)/s)**(-a - 1)*exp(-((-m + z)/s)**(-a))/s
1331 
1332     >>> cdf(X)(z)
1333      Piecewise((exp(-((-m + z)/s)**(-a)), m <= z), (0, True))
1334 
1335     References
1336     ==========
1337 
1338     .. [1] https://en.wikipedia.org/wiki/Fr%C3%A9chet_distribution
1339 
1340     """
1341 
1342     return rv(name, FrechetDistribution, (a, s, m))
1343 
1344 #-------------------------------------------------------------------------------
1345 # Gamma distribution -----------------------------------------------------------
1346 
1347 
1348 class GammaDistribution(SingleContinuousDistribution):
1349     _argnames = ('k', 'theta')
1350 
1351     set = Interval(0, oo)
1352 
1353     @staticmethod
1354     def check(k, theta):
1355         _value_check(k > 0, "k must be positive")
1356         _value_check(theta > 0, "Theta must be positive")
1357 
1358     def pdf(self, x):
1359         k, theta = self.k, self.theta
1360         return x**(k - 1) * exp(-x/theta) / (gamma(k)*theta**k)
1361 
1362     def sample(self):
1363         return random.gammavariate(self.k, self.theta)
1364 
1365     def _cdf(self, x):
1366         k, theta = self.k, self.theta
1367         return Piecewise(
1368                     (lowergamma(k, S(x)/theta)/gamma(k), x > 0),
1369                     (S.Zero, True))
1370 
1371     def _characteristic_function(self, t):
1372         return (1 - self.theta*I*t)**(-self.k)
1373 
1374     def _moment_generating_function(self, t):
1375         return (1- self.theta*t)**(-self.k)
1376 
1377 def Gamma(name, k, theta):
1378     r"""
1379     Create a continuous random variable with a Gamma distribution.
1380 
1381     The density of the Gamma distribution is given by
1382 
1383     .. math::
1384         f(x) := \frac{1}{\Gamma(k) \theta^k} x^{k - 1} e^{-\frac{x}{\theta}}
1385 
1386     with :math:`x \in [0,1]`.
1387 
1388     Parameters
1389     ==========
1390 
1391     k : Real number, `k > 0`, a shape
1392     theta : Real number, `\theta > 0`, a scale
1393 
1394     Returns
1395     =======
1396 
1397     A RandomSymbol.
1398 
1399     Examples
1400     ========
1401 
1402     >>> from sympy.stats import Gamma, density, cdf, E, variance
1403     >>> from sympy import Symbol, pprint, simplify
1404 
1405     >>> k = Symbol("k", positive=True)
1406     >>> theta = Symbol("theta", positive=True)
1407     >>> z = Symbol("z")
1408 
1409     >>> X = Gamma("x", k, theta)
1410 
1411     >>> D = density(X)(z)
1412     >>> pprint(D, use_unicode=False)
1413                       -z
1414                     -----
1415          -k  k - 1  theta
1416     theta  *z     *e
1417     ---------------------
1418            Gamma(k)
1419 
1420     >>> C = cdf(X, meijerg=True)(z)
1421     >>> pprint(C, use_unicode=False)
1422     /            /     z  \
1423     |k*lowergamma|k, -----|
1424     |            \   theta/
1425     <----------------------  for z >= 0
1426     |     Gamma(k + 1)
1427     |
1428     \          0             otherwise
1429 
1430     >>> E(X)
1431     k*theta
1432 
1433     >>> V = simplify(variance(X))
1434     >>> pprint(V, use_unicode=False)
1435            2
1436     k*theta
1437 
1438 
1439     References
1440     ==========
1441 
1442     .. [1] https://en.wikipedia.org/wiki/Gamma_distribution
1443     .. [2] http://mathworld.wolfram.com/GammaDistribution.html
1444 
1445     """
1446 
1447     return rv(name, GammaDistribution, (k, theta))
1448 
1449 #-------------------------------------------------------------------------------
1450 # Inverse Gamma distribution ---------------------------------------------------
1451 
1452 
1453 class GammaInverseDistribution(SingleContinuousDistribution):
1454     _argnames = ('a', 'b')
1455 
1456     set = Interval(0, oo)
1457 
1458     @staticmethod
1459     def check(a, b):
1460         _value_check(a > 0, "alpha must be positive")
1461         _value_check(b > 0, "beta must be positive")
1462 
1463     def pdf(self, x):
1464         a, b = self.a, self.b
1465         return b**a/gamma(a) * x**(-a-1) * exp(-b/x)
1466 
1467     def _cdf(self, x):
1468         a, b = self.a, self.b
1469         return Piecewise((uppergamma(a,b/x)/gamma(a), x > 0),
1470                         (S.Zero, True))
1471 
1472     def sample(self):
1473         scipy = import_module('scipy')
1474         if scipy:
1475             from scipy.stats import invgamma
1476             return invgamma.rvs(float(self.a), 0, float(self.b))
1477         else:
1478             raise NotImplementedError('Sampling the inverse Gamma Distribution requires Scipy.')
1479 
1480     def _characteristic_function(self, t):
1481         a, b = self.a, self.b
1482         return 2 * (-I*b*t)**(a/2) * besselk(sqrt(-4*I*b*t)) / gamma(a)
1483 
1484     def _moment_generating_function(self, t):
1485         raise NotImplementedError('The moment generating function for the '
1486                                   'gamma inverse distribution does not exist.')
1487 
1488 def GammaInverse(name, a, b):
1489     r"""
1490     Create a continuous random variable with an inverse Gamma distribution.
1491 
1492     The density of the inverse Gamma distribution is given by
1493 
1494     .. math::
1495         f(x) := \frac{\beta^\alpha}{\Gamma(\alpha)} x^{-\alpha - 1}
1496                 \exp\left(\frac{-\beta}{x}\right)
1497 
1498     with :math:`x > 0`.
1499 
1500     Parameters
1501     ==========
1502 
1503     a : Real number, `a > 0` a shape
1504     b : Real number, `b > 0` a scale
1505 
1506     Returns
1507     =======
1508 
1509     A RandomSymbol.
1510 
1511     Examples
1512     ========
1513 
1514     >>> from sympy.stats import GammaInverse, density, cdf, E, variance
1515     >>> from sympy import Symbol, pprint
1516 
1517     >>> a = Symbol("a", positive=True)
1518     >>> b = Symbol("b", positive=True)
1519     >>> z = Symbol("z")
1520 
1521     >>> X = GammaInverse("x", a, b)
1522 
1523     >>> D = density(X)(z)
1524     >>> pprint(D, use_unicode=False)
1525                 -b
1526                 ---
1527      a  -a - 1   z
1528     b *z      *e
1529     ---------------
1530        Gamma(a)
1531 
1532     >>> cdf(X)(z)
1533     Piecewise((uppergamma(a, b/z)/gamma(a), z > 0), (0, True))
1534 
1535 
1536     References
1537     ==========
1538 
1539     .. [1] https://en.wikipedia.org/wiki/Inverse-gamma_distribution
1540 
1541     """
1542 
1543     return rv(name, GammaInverseDistribution, (a, b))
1544 
1545 #-------------------------------------------------------------------------------
1546 # Gumbel distribution --------------------------------------------------------
1547 
1548 
1549 class GumbelDistribution(SingleContinuousDistribution):
1550     _argnames = ('beta', 'mu')
1551 
1552     set = Interval(-oo, oo)
1553 
1554     def pdf(self, x):
1555         beta, mu = self.beta, self.mu
1556         z = (x - mu)/beta
1557         return (1/beta)*exp(-(z + exp(-z)))
1558 
1559     def _cdf(self, x):
1560         beta, mu = self.beta, self.mu
1561         return exp(-exp((mu - x)/beta))
1562 
1563     def _characteristic_function(self, t):
1564         return gamma(1 - I*self.beta*t) * exp(I*self.mu*t)
1565 
1566     def _moment_generating_function(self, t):
1567         return gamma(1 - self.beta*t) * exp(I*self.mu*t)
1568 
1569 def Gumbel(name, beta, mu):
1570     r"""
1571     Create a Continuous Random Variable with Gumbel distribution.
1572 
1573     The density of the Gumbel distribution is given by
1574 
1575     .. math::
1576         f(x) := \dfrac{1}{\beta} \exp \left( -\dfrac{x-\mu}{\beta}
1577                 - \exp \left( -\dfrac{x - \mu}{\beta} \right) \right)
1578 
1579     with :math:`x \in [ - \infty, \infty ]`.
1580 
1581     Parameters
1582     ==========
1583 
1584     mu: Real number, 'mu' is a location
1585     beta: Real number, 'beta > 0' is a scale
1586 
1587     Returns
1588     ==========
1589 
1590     A RandomSymbol
1591 
1592     Examples
1593     ==========
1594     >>> from sympy.stats import Gumbel, density, E, variance, cdf
1595     >>> from sympy import Symbol, simplify, pprint
1596     >>> x = Symbol("x")
1597     >>> mu = Symbol("mu")
1598     >>> beta = Symbol("beta", positive=True)
1599     >>> X = Gumbel("x", beta, mu)
1600     >>> density(X)(x)
1601     exp(-exp(-(-mu + x)/beta) - (-mu + x)/beta)/beta
1602     >>> cdf(X)(x)
1603     exp(-exp((mu - x)/beta))
1604 
1605     References
1606     ==========
1607 
1608     .. [1] http://mathworld.wolfram.com/GumbelDistribution.html
1609     .. [2] https://en.wikipedia.org/wiki/Gumbel_distribution
1610 
1611     """
1612     return rv(name, GumbelDistribution, (beta, mu))
1613 
1614 #-------------------------------------------------------------------------------
1615 # Gompertz distribution --------------------------------------------------------
1616 
1617 class GompertzDistribution(SingleContinuousDistribution):
1618     _argnames = ('b', 'eta')
1619 
1620     set = Interval(0, oo)
1621 
1622     @staticmethod
1623     def check(b, eta):
1624         _value_check(b > 0, "b must be positive")
1625         _value_check(eta > 0, "eta must be positive")
1626 
1627     def pdf(self, x):
1628         eta, b = self.eta, self.b
1629         return b*eta*exp(b*x)*exp(eta)*exp(-eta*exp(b*x))
1630 
1631     def _cdf(self, x):
1632         eta, b = self.eta, self.b
1633         return 1 - exp(eta)*exp(-eta*exp(b*x))
1634 
1635     def _moment_generating_function(self, t):
1636         eta, b = self.eta, self.b
1637         return eta * exp(eta) * expint(t/b, eta)
1638 
1639 def Gompertz(name, b, eta):
1640     r"""
1641     Create a Continuous Random Variable with Gompertz distribution.
1642 
1643     The density of the Gompertz distribution is given by
1644 
1645     .. math::
1646         f(x) := b \eta e^{b x} e^{\eta} \exp \left(-\eta e^{bx} \right)
1647 
1648     with :math: 'x \in [0, \inf)'.
1649 
1650     Parameters
1651     ==========
1652 
1653     b: Real number, 'b > 0' a scale
1654     eta: Real number, 'eta > 0' a shape
1655 
1656     Returns
1657     =======
1658 
1659     A RandomSymbol.
1660 
1661     Examples
1662     ========
1663 
1664     >>> from sympy.stats import Gompertz, density, E, variance
1665     >>> from sympy import Symbol, simplify, pprint
1666 
1667     >>> b = Symbol("b", positive=True)
1668     >>> eta = Symbol("eta", positive=True)
1669     >>> z = Symbol("z")
1670 
1671     >>> X = Gompertz("x", b, eta)
1672 
1673     >>> density(X)(z)
1674     b*eta*exp(eta)*exp(b*z)*exp(-eta*exp(b*z))
1675 
1676     References
1677     ==========
1678 
1679     .. [1] https://en.wikipedia.org/wiki/Gompertz_distribution
1680 
1681     """
1682     return rv(name, GompertzDistribution, (b, eta))
1683 
1684 #-------------------------------------------------------------------------------
1685 # Kumaraswamy distribution -----------------------------------------------------
1686 
1687 
1688 class KumaraswamyDistribution(SingleContinuousDistribution):
1689     _argnames = ('a', 'b')
1690 
1691     set = Interval(0, oo)
1692 
1693     @staticmethod
1694     def check(a, b):
1695         _value_check(a > 0, "a must be positive")
1696         _value_check(b > 0, "b must be positive")
1697 
1698     def pdf(self, x):
1699         a, b = self.a, self.b
1700         return a * b * x**(a-1) * (1-x**a)**(b-1)
1701 
1702     def _cdf(self, x):
1703         a, b = self.a, self.b
1704         return Piecewise(
1705             (S.Zero, x < S.Zero),
1706             (1 - (1 - x**a)**b, x <= S.One),
1707             (S.One, True))
1708 
1709 def Kumaraswamy(name, a, b):
1710     r"""
1711     Create a Continuous Random Variable with a Kumaraswamy distribution.
1712 
1713     The density of the Kumaraswamy distribution is given by
1714 
1715     .. math::
1716         f(x) := a b x^{a-1} (1-x^a)^{b-1}
1717 
1718     with :math:`x \in [0,1]`.
1719 
1720     Parameters
1721     ==========
1722 
1723     a : Real number, `a > 0` a shape
1724     b : Real number, `b > 0` a shape
1725 
1726     Returns
1727     =======
1728 
1729     A RandomSymbol.
1730 
1731     Examples
1732     ========
1733 
1734     >>> from sympy.stats import Kumaraswamy, density, E, variance, cdf
1735     >>> from sympy import Symbol, simplify, pprint
1736 
1737     >>> a = Symbol("a", positive=True)
1738     >>> b = Symbol("b", positive=True)
1739     >>> z = Symbol("z")
1740 
1741     >>> X = Kumaraswamy("x", a, b)
1742 
1743     >>> D = density(X)(z)
1744     >>> pprint(D, use_unicode=False)
1745                        b - 1
1746          a - 1 /     a\
1747     a*b*z     *\1 - z /
1748 
1749     >>> cdf(X)(z)
1750     Piecewise((0, z < 0), (1 - (1 - z**a)**b, z <= 1), (1, True))
1751 
1752     References
1753     ==========
1754 
1755     .. [1] https://en.wikipedia.org/wiki/Kumaraswamy_distribution
1756 
1757     """
1758 
1759     return rv(name, KumaraswamyDistribution, (a, b))
1760 
1761 #-------------------------------------------------------------------------------
1762 # Laplace distribution ---------------------------------------------------------
1763 
1764 
1765 class LaplaceDistribution(SingleContinuousDistribution):
1766     _argnames = ('mu', 'b')
1767 
1768     def pdf(self, x):
1769         mu, b = self.mu, self.b
1770         return 1/(2*b)*exp(-Abs(x - mu)/b)
1771 
1772     def _cdf(self, x):
1773         mu, b = self.mu, self.b
1774         return Piecewise(
1775                     (S.Half*exp((x - mu)/b), x < mu),
1776                     (S.One - S.Half*exp(-(x - mu)/b), x >= mu)
1777                         )
1778 
1779     def _characteristic_function(self, t):
1780         return exp(self.mu*I*t) / (1 + self.b**2*t**2)
1781 
1782     def _moment_generating_function(self, t):
1783         return exp(self.mu*t) / (1 - self.b**2*t**2)
1784 
1785 def Laplace(name, mu, b):
1786     r"""
1787     Create a continuous random variable with a Laplace distribution.
1788 
1789     The density of the Laplace distribution is given by
1790 
1791     .. math::
1792         f(x) := \frac{1}{2 b} \exp \left(-\frac{|x-\mu|}b \right)
1793 
1794     Parameters
1795     ==========
1796 
1797     mu : Real number or a list/matrix, the location (mean) or the
1798         location vector
1799     b : Real number or a positive definite matrix, representing a scale
1800         or the covariance matrix.
1801 
1802     Returns
1803     =======
1804 
1805     A RandomSymbol.
1806 
1807     Examples
1808     ========
1809 
1810     >>> from sympy.stats import Laplace, density, cdf
1811     >>> from sympy import Symbol, pprint
1812 
1813     >>> mu = Symbol("mu")
1814     >>> b = Symbol("b", positive=True)
1815     >>> z = Symbol("z")
1816 
1817     >>> X = Laplace("x", mu, b)
1818 
1819     >>> density(X)(z)
1820     exp(-Abs(mu - z)/b)/(2*b)
1821 
1822     >>> cdf(X)(z)
1823     Piecewise((exp((-mu + z)/b)/2, mu > z), (1 - exp((mu - z)/b)/2, True))
1824 
1825     >>> L = Laplace('L', [1, 2], [[1, 0], [0, 1]])
1826     >>> pprint(density(L)(1, 2), use_unicode=False)
1827      5        /     ____\
1828     e *besselk\0, \/ 35 /
1829     ---------------------
1830               pi
1831 
1832     References
1833     ==========
1834 
1835     .. [1] https://en.wikipedia.org/wiki/Laplace_distribution
1836     .. [2] http://mathworld.wolfram.com/LaplaceDistribution.html
1837 
1838     """
1839 
1840     if isinstance(mu, (list, MatrixBase)) and\
1841         isinstance(b, (list, MatrixBase)):
1842         from sympy.stats.joint_rv_types import MultivariateLaplaceDistribution
1843         return multivariate_rv(
1844             MultivariateLaplaceDistribution, name, mu, b)
1845 
1846     return rv(name, LaplaceDistribution, (mu, b))
1847 
1848 #-------------------------------------------------------------------------------
1849 # Logistic distribution --------------------------------------------------------
1850 
1851 
1852 class LogisticDistribution(SingleContinuousDistribution):
1853     _argnames = ('mu', 's')
1854 
1855     def pdf(self, x):
1856         mu, s = self.mu, self.s
1857         return exp(-(x - mu)/s)/(s*(1 + exp(-(x - mu)/s))**2)
1858 
1859     def _cdf(self, x):
1860         mu, s = self.mu, self.s
1861         return S.One/(1 + exp(-(x - mu)/s))
1862 
1863     def _characteristic_function(self, t):
1864         return Piecewise((exp(I*t*self.mu) * pi*self.s*t / sinh(pi*self.s*t), Ne(t, 0)), (S.One, True))
1865 
1866     def _moment_generating_function(self, t):
1867         return exp(self.mu*t) * Beta(1 - self.s*t, 1 + self.s*t)
1868 
1869     def _quantile(self, p):
1870         return self.mu - self.s*log(-S.One + S.One/p)
1871 
1872 def Logistic(name, mu, s):
1873     r"""
1874     Create a continuous random variable with a logistic distribution.
1875 
1876     The density of the logistic distribution is given by
1877 
1878     .. math::
1879         f(x) := \frac{e^{-(x-\mu)/s}} {s\left(1+e^{-(x-\mu)/s}\right)^2}
1880 
1881     Parameters
1882     ==========
1883 
1884     mu : Real number, the location (mean)
1885     s : Real number, `s > 0` a scale
1886 
1887     Returns
1888     =======
1889 
1890     A RandomSymbol.
1891 
1892     Examples
1893     ========
1894 
1895     >>> from sympy.stats import Logistic, density, cdf
1896     >>> from sympy import Symbol
1897 
1898     >>> mu = Symbol("mu", real=True)
1899     >>> s = Symbol("s", positive=True)
1900     >>> z = Symbol("z")
1901 
1902     >>> X = Logistic("x", mu, s)
1903 
1904     >>> density(X)(z)
1905     exp((mu - z)/s)/(s*(exp((mu - z)/s) + 1)**2)
1906 
1907     >>> cdf(X)(z)
1908     1/(exp((mu - z)/s) + 1)
1909 
1910     References
1911     ==========
1912 
1913     .. [1] https://en.wikipedia.org/wiki/Logistic_distribution
1914     .. [2] http://mathworld.wolfram.com/LogisticDistribution.html
1915 
1916     """
1917 
1918     return rv(name, LogisticDistribution, (mu, s))
1919 
1920 #-------------------------------------------------------------------------------
1921 # Log Normal distribution ------------------------------------------------------
1922 
1923 
1924 class LogNormalDistribution(SingleContinuousDistribution):
1925     _argnames = ('mean', 'std')
1926 
1927     set = Interval(0, oo)
1928 
1929     def pdf(self, x):
1930         mean, std = self.mean, self.std
1931         return exp(-(log(x) - mean)**2 / (2*std**2)) / (x*sqrt(2*pi)*std)
1932 
1933     def sample(self):
1934         return random.lognormvariate(self.mean, self.std)
1935 
1936     def _cdf(self, x):
1937         mean, std = self.mean, self.std
1938         return Piecewise(
1939                 (S.Half + S.Half*erf((log(x) - mean)/sqrt(2)/std), x > 0),
1940                 (S.Zero, True)
1941         )
1942 
1943     def _moment_generating_function(self, t):
1944         raise NotImplementedError('Moment generating function of the log-normal distribution is not defined.')
1945 
1946 def LogNormal(name, mean, std):
1947     r"""
1948     Create a continuous random variable with a log-normal distribution.
1949 
1950     The density of the log-normal distribution is given by
1951 
1952     .. math::
1953         f(x) := \frac{1}{x\sqrt{2\pi\sigma^2}}
1954                 e^{-\frac{\left(\ln x-\mu\right)^2}{2\sigma^2}}
1955 
1956     with :math:`x \geq 0`.
1957 
1958     Parameters
1959     ==========
1960 
1961     mu : Real number, the log-scale
1962     sigma : Real number, :math:`\sigma^2 > 0` a shape
1963 
1964     Returns
1965     =======
1966 
1967     A RandomSymbol.
1968 
1969     Examples
1970     ========
1971 
1972     >>> from sympy.stats import LogNormal, density
1973     >>> from sympy import Symbol, simplify, pprint
1974 
1975     >>> mu = Symbol("mu", real=True)
1976     >>> sigma = Symbol("sigma", positive=True)
1977     >>> z = Symbol("z")
1978 
1979     >>> X = LogNormal("x", mu, sigma)
1980 
1981     >>> D = density(X)(z)
1982     >>> pprint(D, use_unicode=False)
1983                           2
1984            -(-mu + log(z))
1985            -----------------
1986                       2
1987       ___      2*sigma
1988     \/ 2 *e
1989     ------------------------
1990             ____
1991         2*\/ pi *sigma*z
1992 
1993 
1994     >>> X = LogNormal('x', 0, 1) # Mean 0, standard deviation 1
1995 
1996     >>> density(X)(z)
1997     sqrt(2)*exp(-log(z)**2/2)/(2*sqrt(pi)*z)
1998 
1999     References
2000     ==========
2001 
2002     .. [1] https://en.wikipedia.org/wiki/Lognormal
2003     .. [2] http://mathworld.wolfram.com/LogNormalDistribution.html
2004 
2005     """
2006 
2007     return rv(name, LogNormalDistribution, (mean, std))
2008 
2009 #-------------------------------------------------------------------------------
2010 # Maxwell distribution ---------------------------------------------------------
2011 
2012 
2013 class MaxwellDistribution(SingleContinuousDistribution):
2014     _argnames = ('a',)
2015 
2016     set = Interval(0, oo)
2017 
2018     def pdf(self, x):
2019         a = self.a
2020         return sqrt(2/pi)*x**2*exp(-x**2/(2*a**2))/a**3
2021 
2022     def _cdf(self, x):
2023         a = self.a
2024         return erf(sqrt(2)*x/(2*a)) - sqrt(2)*x*exp(-x**2/(2*a**2))/(sqrt(pi)*a)
2025 
2026 def Maxwell(name, a):
2027     r"""
2028     Create a continuous random variable with a Maxwell distribution.
2029 
2030     The density of the Maxwell distribution is given by
2031 
2032     .. math::
2033         f(x) := \sqrt{\frac{2}{\pi}} \frac{x^2 e^{-x^2/(2a^2)}}{a^3}
2034 
2035     with :math:`x \geq 0`.
2036 
2037     .. TODO - what does the parameter mean?
2038 
2039     Parameters
2040     ==========
2041 
2042     a : Real number, `a > 0`
2043 
2044     Returns
2045     =======
2046 
2047     A RandomSymbol.
2048 
2049     Examples
2050     ========
2051 
2052     >>> from sympy.stats import Maxwell, density, E, variance
2053     >>> from sympy import Symbol, simplify
2054 
2055     >>> a = Symbol("a", positive=True)
2056     >>> z = Symbol("z")
2057 
2058     >>> X = Maxwell("x", a)
2059 
2060     >>> density(X)(z)
2061     sqrt(2)*z**2*exp(-z**2/(2*a**2))/(sqrt(pi)*a**3)
2062 
2063     >>> E(X)
2064     2*sqrt(2)*a/sqrt(pi)
2065 
2066     >>> simplify(variance(X))
2067     a**2*(-8 + 3*pi)/pi
2068 
2069     References
2070     ==========
2071 
2072     .. [1] https://en.wikipedia.org/wiki/Maxwell_distribution
2073     .. [2] http://mathworld.wolfram.com/MaxwellDistribution.html
2074 
2075     """
2076 
2077     return rv(name, MaxwellDistribution, (a, ))
2078 
2079 #-------------------------------------------------------------------------------
2080 # Nakagami distribution --------------------------------------------------------
2081 
2082 
2083 class NakagamiDistribution(SingleContinuousDistribution):
2084     _argnames = ('mu', 'omega')
2085 
2086     set = Interval(0, oo)
2087 
2088     def pdf(self, x):
2089         mu, omega = self.mu, self.omega
2090         return 2*mu**mu/(gamma(mu)*omega**mu)*x**(2*mu - 1)*exp(-mu/omega*x**2)
2091 
2092     def _cdf(self, x):
2093         mu, omega = self.mu, self.omega
2094         return Piecewise(
2095                     (lowergamma(mu, (mu/omega)*x**2)/gamma(mu), x > 0),
2096                     (S.Zero, True))
2097 
2098 def Nakagami(name, mu, omega):
2099     r"""
2100     Create a continuous random variable with a Nakagami distribution.
2101 
2102     The density of the Nakagami distribution is given by
2103 
2104     .. math::
2105         f(x) := \frac{2\mu^\mu}{\Gamma(\mu)\omega^\mu} x^{2\mu-1}
2106                 \exp\left(-\frac{\mu}{\omega}x^2 \right)
2107 
2108     with :math:`x > 0`.
2109 
2110     Parameters
2111     ==========
2112 
2113     mu : Real number, `\mu \geq \frac{1}{2}` a shape
2114     omega : Real number, `\omega > 0`, the spread
2115 
2116     Returns
2117     =======
2118 
2119     A RandomSymbol.
2120 
2121     Examples
2122     ========
2123 
2124     >>> from sympy.stats import Nakagami, density, E, variance, cdf
2125     >>> from sympy import Symbol, simplify, pprint
2126 
2127     >>> mu = Symbol("mu", positive=True)
2128     >>> omega = Symbol("omega", positive=True)
2129     >>> z = Symbol("z")
2130 
2131     >>> X = Nakagami("x", mu, omega)
2132 
2133     >>> D = density(X)(z)
2134     >>> pprint(D, use_unicode=False)
2135                                     2
2136                                -mu*z
2137                                -------
2138         mu      -mu  2*mu - 1  omega
2139     2*mu  *omega   *z        *e
2140     ----------------------------------
2141                 Gamma(mu)
2142 
2143     >>> simplify(E(X))
2144     sqrt(mu)*sqrt(omega)*gamma(mu + 1/2)/gamma(mu + 1)
2145 
2146     >>> V = simplify(variance(X))
2147     >>> pprint(V, use_unicode=False)
2148                         2
2149              omega*Gamma (mu + 1/2)
2150     omega - -----------------------
2151             Gamma(mu)*Gamma(mu + 1)
2152 
2153     >>> cdf(X)(z)
2154     Piecewise((lowergamma(mu, mu*z**2/omega)/gamma(mu), z > 0),
2155             (0, True))
2156 
2157 
2158     References
2159     ==========
2160 
2161     .. [1] https://en.wikipedia.org/wiki/Nakagami_distribution
2162 
2163     """
2164 
2165     return rv(name, NakagamiDistribution, (mu, omega))
2166 
2167 #-------------------------------------------------------------------------------
2168 # Normal distribution ----------------------------------------------------------
2169 
2170 
2171 class NormalDistribution(SingleContinuousDistribution):
2172     _argnames = ('mean', 'std')
2173 
2174     @staticmethod
2175     def check(mean, std):
2176         _value_check(std > 0, "Standard deviation must be positive")
2177 
2178     def pdf(self, x):
2179         return exp(-(x - self.mean)**2 / (2*self.std**2)) / (sqrt(2*pi)*self.std)
2180 
2181     def sample(self):
2182         return random.normalvariate(self.mean, self.std)
2183 
2184     def _cdf(self, x):
2185         mean, std = self.mean, self.std
2186         return erf(sqrt(2)*(-mean + x)/(2*std))/2 + S.Half
2187 
2188     def _characteristic_function(self, t):
2189         mean, std = self.mean, self.std
2190         return exp(I*mean*t - std**2*t**2/2)
2191 
2192     def _moment_generating_function(self, t):
2193         mean, std = self.mean, self.std
2194         return exp(mean*t + std**2*t**2/2)
2195 
2196     def _quantile(self, p):
2197         mean, std = self.mean, self.std
2198         return mean + std*sqrt(2)*erfinv(2*p - 1)
2199 
2200 def Normal(name, mean, std):
2201     r"""
2202     Create a continuous random variable with a Normal distribution.
2203 
2204     The density of the Normal distribution is given by
2205 
2206     .. math::
2207         f(x) := \frac{1}{\sigma\sqrt{2\pi}} e^{ -\frac{(x-\mu)^2}{2\sigma^2} }
2208 
2209     Parameters
2210     ==========
2211 
2212     mu : Real number or a list representing the mean or the mean vector
2213     sigma : Real number or a positive definite sqaure matrix,
2214          :math:`\sigma^2 > 0` the variance
2215 
2216     Returns
2217     =======
2218 
2219     A RandomSymbol.
2220 
2221     Examples
2222     ========
2223 
2224     >>> from sympy.stats import Normal, density, E, std, cdf, skewness, quantile
2225     >>> from sympy import Symbol, simplify, pprint, factor, together, factor_terms
2226 
2227     >>> mu = Symbol("mu")
2228     >>> sigma = Symbol("sigma", positive=True)
2229     >>> z = Symbol("z")
2230     >>> y = Symbol("y")
2231     >>> p = Symbol("p")
2232     >>> X = Normal("x", mu, sigma)
2233 
2234     >>> density(X)(z)
2235     sqrt(2)*exp(-(-mu + z)**2/(2*sigma**2))/(2*sqrt(pi)*sigma)
2236 
2237     >>> C = simplify(cdf(X))(z) # it needs a little more help...
2238     >>> pprint(C, use_unicode=False)
2239        /  ___          \
2240        |\/ 2 *(-mu + z)|
2241     erf|---------------|
2242        \    2*sigma    /   1
2243     -------------------- + -
2244              2             2
2245 
2246     >>> quantile(X)(p)
2247     mu + sqrt(2)*sigma*erfinv(2*p - 1)
2248 
2249     >>> simplify(skewness(X))
2250     0
2251 
2252     >>> X = Normal("x", 0, 1) # Mean 0, standard deviation 1
2253     >>> density(X)(z)
2254     sqrt(2)*exp(-z**2/2)/(2*sqrt(pi))
2255 
2256     >>> E(2*X + 1)
2257     1
2258 
2259     >>> simplify(std(2*X + 1))
2260     2
2261 
2262     >>> m = Normal('X', [1, 2], [[2, 1], [1, 2]])
2263     >>> from sympy.stats.joint_rv import marginal_distribution
2264     >>> pprint(density(m)(y, z))
2265            /1   y\ /2*y   z\   /    z\ /  y   2*z    \
2266            |- - -|*|--- - -| + |1 - -|*|- - + --- - 1|
2267       ___  \2   2/ \ 3    3/   \    2/ \  3    3     /
2268     \/ 3 *e
2269     --------------------------------------------------
2270                            6*pi
2271 
2272     >>> marginal_distribution(m, m[0])(1)
2273      1/(2*sqrt(pi))
2274 
2275 
2276     References
2277     ==========
2278 
2279     .. [1] https://en.wikipedia.org/wiki/Normal_distribution
2280     .. [2] http://mathworld.wolfram.com/NormalDistributionFunction.html
2281 
2282     """
2283 
2284     if isinstance(mean, (list, MatrixBase)) and\
2285         isinstance(std, (list, MatrixBase)):
2286         from sympy.stats.joint_rv_types import MultivariateNormalDistribution
2287         return multivariate_rv(
2288             MultivariateNormalDistribution, name, mean, std)
2289     return rv(name, NormalDistribution, (mean, std))
2290 
2291 #-------------------------------------------------------------------------------
2292 # Pareto distribution ----------------------------------------------------------
2293 
2294 
2295 class ParetoDistribution(SingleContinuousDistribution):
2296     _argnames = ('xm', 'alpha')
2297 
2298     @property
2299     def set(self):
2300         return Interval(self.xm, oo)
2301 
2302     @staticmethod
2303     def check(xm, alpha):
2304         _value_check(xm > 0, "Xm must be positive")
2305         _value_check(alpha > 0, "Alpha must be positive")
2306 
2307     def pdf(self, x):
2308         xm, alpha = self.xm, self.alpha
2309         return alpha * xm**alpha / x**(alpha + 1)
2310 
2311     def sample(self):
2312         return random.paretovariate(self.alpha)
2313 
2314     def _cdf(self, x):
2315         xm, alpha = self.xm, self.alpha
2316         return Piecewise(
2317                 (S.One - xm**alpha/x**alpha, x>=xm),
2318                 (0, True),
2319         )
2320 
2321     def _moment_generating_function(self, t):
2322         xm, alpha = self.xm, self.alpha
2323         return alpha * (-xm*t)**alpha * uppergamma(-alpha, -xm*t)
2324 
2325     def _characteristic_function(self, t):
2326         xm, alpha = self.xm, self.alpha
2327         return alpha * (-I * xm * t) ** alpha * uppergamma(-alpha, -I * xm * t)
2328 
2329 
2330 def Pareto(name, xm, alpha):
2331     r"""
2332     Create a continuous random variable with the Pareto distribution.
2333 
2334     The density of the Pareto distribution is given by
2335 
2336     .. math::
2337         f(x) := \frac{\alpha\,x_m^\alpha}{x^{\alpha+1}}
2338 
2339     with :math:`x \in [x_m,\infty]`.
2340 
2341     Parameters
2342     ==========
2343 
2344     xm : Real number, `x_m > 0`, a scale
2345     alpha : Real number, `\alpha > 0`, a shape
2346 
2347     Returns
2348     =======
2349 
2350     A RandomSymbol.
2351 
2352     Examples
2353     ========
2354 
2355     >>> from sympy.stats import Pareto, density
2356     >>> from sympy import Symbol
2357 
2358     >>> xm = Symbol("xm", positive=True)
2359     >>> beta = Symbol("beta", positive=True)
2360     >>> z = Symbol("z")
2361 
2362     >>> X = Pareto("x", xm, beta)
2363 
2364     >>> density(X)(z)
2365     beta*xm**beta*z**(-beta - 1)
2366 
2367     References
2368     ==========
2369 
2370     .. [1] https://en.wikipedia.org/wiki/Pareto_distribution
2371     .. [2] http://mathworld.wolfram.com/ParetoDistribution.html
2372 
2373     """
2374 
2375     return rv(name, ParetoDistribution, (xm, alpha))
2376 
2377 #-------------------------------------------------------------------------------
2378 # QuadraticU distribution ------------------------------------------------------
2379 
2380 
2381 class QuadraticUDistribution(SingleContinuousDistribution):
2382     _argnames = ('a', 'b')
2383 
2384     @property
2385     def set(self):
2386         return Interval(self.a, self.b)
2387 
2388     def pdf(self, x):
2389         a, b = self.a, self.b
2390         alpha = 12 / (b-a)**3
2391         beta = (a+b) / 2
2392         return Piecewise(
2393                   (alpha * (x-beta)**2, And(a<=x, x<=b)),
2394                   (S.Zero, True))
2395 
2396     def _moment_generating_function(self, t):
2397         a, b = self.a, self.b
2398 
2399         return -3 * (exp(a*t) * (4  + (a**2 + 2*a*(-2 + b) + b**2) * t) - exp(b*t) * (4 + (-4*b + (a + b)**2) * t)) / ((a-b)**3 * t**2)
2400 
2401     def _characteristic_function(self, t):
2402         def _moment_generating_function(self, t):
2403             a, b = self.a, self.b
2404 
2405             return -3*I*(exp(I*a*t*exp(I*b*t)) * (4*I - (-4*b + (a+b)**2)*t)) / ((a-b)**3 * t**2)
2406 
2407 
2408 def QuadraticU(name, a, b):
2409     r"""
2410     Create a Continuous Random Variable with a U-quadratic distribution.
2411 
2412     The density of the U-quadratic distribution is given by
2413 
2414     .. math::
2415         f(x) := \alpha (x-\beta)^2
2416 
2417     with :math:`x \in [a,b]`.
2418 
2419     Parameters
2420     ==========
2421 
2422     a : Real number
2423     b : Real number, :math:`a < b`
2424 
2425     Returns
2426     =======
2427 
2428     A RandomSymbol.
2429 
2430     Examples
2431     ========
2432 
2433     >>> from sympy.stats import QuadraticU, density, E, variance
2434     >>> from sympy import Symbol, simplify, factor, pprint
2435 
2436     >>> a = Symbol("a", real=True)
2437     >>> b = Symbol("b", real=True)
2438     >>> z = Symbol("z")
2439 
2440     >>> X = QuadraticU("x", a, b)
2441 
2442     >>> D = density(X)(z)
2443     >>> pprint(D, use_unicode=False)
2444     /                2
2445     |   /  a   b    \
2446     |12*|- - - - + z|
2447     |   \  2   2    /
2448     <-----------------  for And(b >= z, a <= z)
2449     |            3
2450     |    (-a + b)
2451     |
2452     \        0                 otherwise
2453 
2454     References
2455     ==========
2456 
2457     .. [1] https://en.wikipedia.org/wiki/U-quadratic_distribution
2458 
2459     """
2460 
2461     return rv(name, QuadraticUDistribution, (a, b))
2462 
2463 #-------------------------------------------------------------------------------
2464 # RaisedCosine distribution ----------------------------------------------------
2465 
2466 
2467 class RaisedCosineDistribution(SingleContinuousDistribution):
2468     _argnames = ('mu', 's')
2469 
2470     @property
2471     def set(self):
2472         return Interval(self.mu - self.s, self.mu + self.s)
2473 
2474     @staticmethod
2475     def check(mu, s):
2476         _value_check(s > 0, "s must be positive")
2477 
2478     def pdf(self, x):
2479         mu, s = self.mu, self.s
2480         return Piecewise(
2481                 ((1+cos(pi*(x-mu)/s)) / (2*s), And(mu-s<=x, x<=mu+s)),
2482                 (S.Zero, True))
2483 
2484     def _characteristic_function(self, t):
2485         mu, s = self.mu, self.s
2486         return Piecewise((exp(-I*pi*mu/s)/2, Eq(t, -pi/s)),
2487                          (exp(I*pi*mu/s)/2, Eq(t, pi/s)),
2488                          (pi**2*sin(s*t)*exp(I*mu*t) / (s*t*(pi**2 - s**2*t**2)), True))
2489 
2490     def _moment_generating_function(self, t):
2491         mu, s = self.mu, self.s
2492         return pi**2 * sinh(s*t) * exp(mu*t) /  (s*t*(pi**2 + s**2*t**2))
2493 
2494 def RaisedCosine(name, mu, s):
2495     r"""
2496     Create a Continuous Random Variable with a raised cosine distribution.
2497 
2498     The density of the raised cosine distribution is given by
2499 
2500     .. math::
2501         f(x) := \frac{1}{2s}\left(1+\cos\left(\frac{x-\mu}{s}\pi\right)\right)
2502 
2503     with :math:`x \in [\mu-s,\mu+s]`.
2504 
2505     Parameters
2506     ==========
2507 
2508     mu : Real number
2509     s : Real number, `s > 0`
2510 
2511     Returns
2512     =======
2513 
2514     A RandomSymbol.
2515 
2516     Examples
2517     ========
2518 
2519     >>> from sympy.stats import RaisedCosine, density, E, variance
2520     >>> from sympy import Symbol, simplify, pprint
2521 
2522     >>> mu = Symbol("mu", real=True)
2523     >>> s = Symbol("s", positive=True)
2524     >>> z = Symbol("z")
2525 
2526     >>> X = RaisedCosine("x", mu, s)
2527 
2528     >>> D = density(X)(z)
2529     >>> pprint(D, use_unicode=False)
2530     /   /pi*(-mu + z)\
2531     |cos|------------| + 1
2532     |   \     s      /
2533     <---------------------  for And(z >= mu - s, z <= mu + s)
2534     |         2*s
2535     |
2536     \          0                        otherwise
2537 
2538     References
2539     ==========
2540 
2541     .. [1] https://en.wikipedia.org/wiki/Raised_cosine_distribution
2542 
2543     """
2544 
2545     return rv(name, RaisedCosineDistribution, (mu, s))
2546 
2547 #-------------------------------------------------------------------------------
2548 # Rayleigh distribution --------------------------------------------------------
2549 
2550 
2551 class RayleighDistribution(SingleContinuousDistribution):
2552     _argnames = ('sigma',)
2553 
2554     set = Interval(0, oo)
2555 
2556     def pdf(self, x):
2557         sigma = self.sigma
2558         return x/sigma**2*exp(-x**2/(2*sigma**2))
2559 
2560     def _cdf(self, x):
2561         sigma = self.sigma
2562         return 1 - exp(-(x**2/(2*sigma**2)))
2563 
2564     def _characteristic_function(self, t):
2565         sigma = self.sigma
2566         return 1 - sigma*t*exp(-sigma**2*t**2/2) * sqrt(pi/2) * (erfi(sigma*t/sqrt(2)) - I)
2567 
2568     def _moment_generating_function(self, t):
2569         sigma = self.sigma
2570         return 1 + sigma*t*exp(sigma**2*t**2/2) * sqrt(pi/2) * (erf(sigma*t/sqrt(2)) + 1)
2571 
2572 
2573 def Rayleigh(name, sigma):
2574     r"""
2575     Create a continuous random variable with a Rayleigh distribution.
2576 
2577     The density of the Rayleigh distribution is given by
2578 
2579     .. math ::
2580         f(x) := \frac{x}{\sigma^2} e^{-x^2/2\sigma^2}
2581 
2582     with :math:`x > 0`.
2583 
2584     Parameters
2585     ==========
2586 
2587     sigma : Real number, `\sigma > 0`
2588 
2589     Returns
2590     =======
2591 
2592     A RandomSymbol.
2593 
2594     Examples
2595     ========
2596 
2597     >>> from sympy.stats import Rayleigh, density, E, variance
2598     >>> from sympy import Symbol, simplify
2599 
2600     >>> sigma = Symbol("sigma", positive=True)
2601     >>> z = Symbol("z")
2602 
2603     >>> X = Rayleigh("x", sigma)
2604 
2605     >>> density(X)(z)
2606     z*exp(-z**2/(2*sigma**2))/sigma**2
2607 
2608     >>> E(X)
2609     sqrt(2)*sqrt(pi)*sigma/2
2610 
2611     >>> variance(X)
2612     -pi*sigma**2/2 + 2*sigma**2
2613 
2614     References
2615     ==========
2616 
2617     .. [1] https://en.wikipedia.org/wiki/Rayleigh_distribution
2618     .. [2] http://mathworld.wolfram.com/RayleighDistribution.html
2619 
2620     """
2621 
2622     return rv(name, RayleighDistribution, (sigma, ))
2623 
2624 #-------------------------------------------------------------------------------
2625 # Shifted Gompertz distribution ------------------------------------------------
2626 
2627 
2628 class ShiftedGompertzDistribution(SingleContinuousDistribution):
2629     _argnames = ('b', 'eta')
2630 
2631     set = Interval(0, oo)
2632 
2633     @staticmethod
2634     def check(b, eta):
2635         _value_check(b > 0, "b must be positive")
2636         _value_check(eta > 0, "eta must be positive")
2637 
2638     def pdf(self, x):
2639         b, eta = self.b, self.eta
2640         return b*exp(-b*x)*exp(-eta*exp(-b*x))*(1+eta*(1-exp(-b*x)))
2641 
2642 def ShiftedGompertz(name, b, eta):
2643     r"""
2644     Create a continuous random variable with a Shifted Gompertz distribution.
2645 
2646     The density of the Shifted Gompertz distribution is given by
2647 
2648     .. math::
2649         f(x) := b e^{-b x} e^{-\eta \exp(-b x)} \left[1 + \eta(1 - e^(-bx)) \right]
2650 
2651     with :math: 'x \in [0, \inf)'.
2652 
2653     Parameters
2654     ==========
2655 
2656     b: Real number, 'b > 0' a scale
2657     eta: Real number, 'eta > 0' a shape
2658 
2659     Returns
2660     =======
2661 
2662     A RandomSymbol.
2663 
2664     Examples
2665     ========
2666     >>> from sympy.stats import ShiftedGompertz, density, E, variance
2667     >>> from sympy import Symbol
2668 
2669     >>> b = Symbol("b", positive=True)
2670     >>> eta = Symbol("eta", positive=True)
2671     >>> x = Symbol("x")
2672 
2673     >>> X = ShiftedGompertz("x", b, eta)
2674 
2675     >>> density(X)(x)
2676     b*(eta*(1 - exp(-b*x)) + 1)*exp(-b*x)*exp(-eta*exp(-b*x))
2677 
2678     References
2679     ==========
2680 
2681     .. [1] https://en.wikipedia.org/wiki/Shifted_Gompertz_distribution
2682 
2683     """
2684     return rv(name, ShiftedGompertzDistribution, (b, eta))
2685 
2686 #-------------------------------------------------------------------------------
2687 # StudentT distribution --------------------------------------------------------
2688 
2689 
2690 class StudentTDistribution(SingleContinuousDistribution):
2691     _argnames = ('nu',)
2692 
2693     def pdf(self, x):
2694         nu = self.nu
2695         return 1/(sqrt(nu)*beta_fn(S(1)/2, nu/2))*(1 + x**2/nu)**(-(nu + 1)/2)
2696 
2697     def _cdf(self, x):
2698         nu = self.nu
2699         return S.Half + x*gamma((nu+1)/2)*hyper((S.Half, (nu+1)/2),
2700                                 (S(3)/2,), -x**2/nu)/(sqrt(pi*nu)*gamma(nu/2))
2701 
2702     def _moment_generating_function(self, t):
2703         raise NotImplementedError('The moment generating function for the Student-T distribution is undefined.')
2704 
2705 def StudentT(name, nu):
2706     r"""
2707     Create a continuous random variable with a student's t distribution.
2708 
2709     The density of the student's t distribution is given by
2710 
2711     .. math::
2712         f(x) := \frac{\Gamma \left(\frac{\nu+1}{2} \right)}
2713                 {\sqrt{\nu\pi}\Gamma \left(\frac{\nu}{2} \right)}
2714                 \left(1+\frac{x^2}{\nu} \right)^{-\frac{\nu+1}{2}}
2715 
2716     Parameters
2717     ==========
2718 
2719     nu : Real number, `\nu > 0`, the degrees of freedom
2720 
2721     Returns
2722     =======
2723 
2724     A RandomSymbol.
2725 
2726     Examples
2727     ========
2728 
2729     >>> from sympy.stats import StudentT, density, E, variance, cdf
2730     >>> from sympy import Symbol, simplify, pprint
2731 
2732     >>> nu = Symbol("nu", positive=True)
2733     >>> z = Symbol("z")
2734 
2735     >>> X = StudentT("x", nu)
2736 
2737     >>> D = density(X)(z)
2738     >>> pprint(D, use_unicode=False)
2739                nu   1
2740              - -- - -
2741                2    2
2742      /     2\
2743      |    z |
2744      |1 + --|
2745      \    nu/
2746     -----------------
2747       ____  /     nu\
2748     \/ nu *B|1/2, --|
2749             \     2 /
2750 
2751     >>> cdf(X)(z)
2752     1/2 + z*gamma(nu/2 + 1/2)*hyper((1/2, nu/2 + 1/2), (3/2,),
2753                                 -z**2/nu)/(sqrt(pi)*sqrt(nu)*gamma(nu/2))
2754 
2755 
2756     References
2757     ==========
2758 
2759     .. [1] https://en.wikipedia.org/wiki/Student_t-distribution
2760     .. [2] http://mathworld.wolfram.com/Studentst-Distribution.html
2761 
2762     """
2763 
2764     return rv(name, StudentTDistribution, (nu, ))
2765 
2766 #-------------------------------------------------------------------------------
2767 # Trapezoidal distribution ------------------------------------------------------
2768 
2769 
2770 class TrapezoidalDistribution(SingleContinuousDistribution):
2771     _argnames = ('a', 'b', 'c', 'd')
2772 
2773     def pdf(self, x):
2774         a, b, c, d = self.a, self.b, self.c, self.d
2775         return Piecewise(
2776             (2*(x-a) / ((b-a)*(d+c-a-b)), And(a <= x, x < b)),
2777             (2 / (d+c-a-b), And(b <= x, x < c)),
2778             (2*(d-x) / ((d-c)*(d+c-a-b)), And(c <= x, x <= d)),
2779             (S.Zero, True))
2780 
2781 def Trapezoidal(name, a, b, c, d):
2782     r"""
2783     Create a continuous random variable with a trapezoidal distribution.
2784 
2785     The density of the trapezoidal distribution is given by
2786 
2787     .. math::
2788         f(x) := \begin{cases}
2789                   0 & \mathrm{for\ } x < a, \\
2790                   \frac{2(x-a)}{(b-a)(d+c-a-b)} & \mathrm{for\ } a \le x < b, \\
2791                   \frac{2}{d+c-a-b} & \mathrm{for\ } b \le x < c, \\
2792                   \frac{2(d-x)}{(d-c)(d+c-a-b)} & \mathrm{for\ } c \le x < d, \\
2793                   0 & \mathrm{for\ } d < x.
2794                 \end{cases}
2795 
2796     Parameters
2797     ==========
2798 
2799     a : Real number, :math:`a < d`
2800     b : Real number, :math:`a <= b < c`
2801     c : Real number, :math:`b < c <= d`
2802     d : Real number
2803 
2804     Returns
2805     =======
2806 
2807     A RandomSymbol.
2808 
2809     Examples
2810     ========
2811 
2812     >>> from sympy.stats import Trapezoidal, density, E
2813     >>> from sympy import Symbol, pprint
2814 
2815     >>> a = Symbol("a")
2816     >>> b = Symbol("b")
2817     >>> c = Symbol("c")
2818     >>> d = Symbol("d")
2819     >>> z = Symbol("z")
2820 
2821     >>> X = Trapezoidal("x", a,b,c,d)
2822 
2823     >>> pprint(density(X)(z), use_unicode=False)
2824     /        -2*a + 2*z
2825     |-------------------------  for And(a <= z, b > z)
2826     |(-a + b)*(-a - b + c + d)
2827     |
2828     |           2
2829     |     --------------        for And(b <= z, c > z)
2830     <     -a - b + c + d
2831     |
2832     |        2*d - 2*z
2833     |-------------------------  for And(d >= z, c <= z)
2834     |(-c + d)*(-a - b + c + d)
2835     |
2836     \            0                     otherwise
2837 
2838     References
2839     ==========
2840 
2841     .. [1] https://en.wikipedia.org/wiki/Trapezoidal_distribution
2842 
2843     """
2844     return rv(name, TrapezoidalDistribution, (a, b, c, d))
2845 
2846 #-------------------------------------------------------------------------------
2847 # Triangular distribution ------------------------------------------------------
2848 
2849 
2850 class TriangularDistribution(SingleContinuousDistribution):
2851     _argnames = ('a', 'b', 'c')
2852 
2853     def pdf(self, x):
2854         a, b, c = self.a, self.b, self.c
2855         return Piecewise(
2856             (2*(x - a)/((b - a)*(c - a)), And(a <= x, x < c)),
2857             (2/(b - a), Eq(x, c)),
2858             (2*(b - x)/((b - a)*(b - c)), And(c < x, x <= b)),
2859             (S.Zero, True))
2860 
2861     def _characteristic_function(self, t):
2862         a, b, c = self.a, self.b, self.c
2863         return -2 *((b-c) * exp(I*a*t) - (b-a) * exp(I*c*t) + (c-a) * exp(I*b*t)) / ((b-a)*(c-a)*(b-c)*t**2)
2864 
2865     def _moment_generating_function(self, t):
2866         a, b, c = self.a, self.b, self.c
2867         return 2 * ((b - c) * exp(a * t) - (b - a) * exp(c * t) + (c + a) * exp(b * t)) / (
2868         (b - a) * (c - a) * (b - c) * t ** 2)
2869 
2870 
2871 def Triangular(name, a, b, c):
2872     r"""
2873     Create a continuous random variable with a triangular distribution.
2874 
2875     The density of the triangular distribution is given by
2876 
2877     .. math::
2878         f(x) := \begin{cases}
2879                   0 & \mathrm{for\ } x < a, \\
2880                   \frac{2(x-a)}{(b-a)(c-a)} & \mathrm{for\ } a \le x < c, \\
2881                   \frac{2}{b-a} & \mathrm{for\ } x = c, \\
2882                   \frac{2(b-x)}{(b-a)(b-c)} & \mathrm{for\ } c < x \le b, \\
2883                   0 & \mathrm{for\ } b < x.
2884                 \end{cases}
2885 
2886     Parameters
2887     ==========
2888 
2889     a : Real number, :math:`a \in \left(-\infty, \infty\right)`
2890     b : Real number, :math:`a < b`
2891     c : Real number, :math:`a \leq c \leq b`
2892 
2893     Returns
2894     =======
2895 
2896     A RandomSymbol.
2897 
2898     Examples
2899     ========
2900 
2901     >>> from sympy.stats import Triangular, density, E
2902     >>> from sympy import Symbol, pprint
2903 
2904     >>> a = Symbol("a")
2905     >>> b = Symbol("b")
2906     >>> c = Symbol("c")
2907     >>> z = Symbol("z")
2908 
2909     >>> X = Triangular("x", a,b,c)
2910 
2911     >>> pprint(density(X)(z), use_unicode=False)
2912     /    -2*a + 2*z
2913     |-----------------  for And(a <= z, c > z)
2914     |(-a + b)*(-a + c)
2915     |
2916     |       2
2917     |     ------              for c = z
2918     <     -a + b
2919     |
2920     |   2*b - 2*z
2921     |----------------   for And(b >= z, c < z)
2922     |(-a + b)*(b - c)
2923     |
2924     \        0                otherwise
2925 
2926     References
2927     ==========
2928 
2929     .. [1] https://en.wikipedia.org/wiki/Triangular_distribution
2930     .. [2] http://mathworld.wolfram.com/TriangularDistribution.html
2931 
2932     """
2933 
2934     return rv(name, TriangularDistribution, (a, b, c))
2935 
2936 #-------------------------------------------------------------------------------
2937 # Uniform distribution ---------------------------------------------------------
2938 
2939 
2940 class UniformDistribution(SingleContinuousDistribution):
2941     _argnames = ('left', 'right')
2942 
2943     def pdf(self, x):
2944         left, right = self.left, self.right
2945         return Piecewise(
2946             (S.One/(right - left), And(left <= x, x <= right)),
2947             (S.Zero, True)
2948         )
2949 
2950     def _cdf(self, x):
2951         left, right = self.left, self.right
2952         return Piecewise(
2953             (S.Zero, x < left),
2954             ((x - left)/(right - left), x <= right),
2955             (S.One, True)
2956         )
2957 
2958     def _characteristic_function(self, t):
2959         left, right = self.left, self.right
2960         return Piecewise(((exp(I*t*right) - exp(I*t*left)) / (I*t*(right - left)), Ne(t, 0)),
2961                          (S.One, True))
2962 
2963     def _moment_generating_function(self, t):
2964         left, right = self.left, self.right
2965         return Piecewise(((exp(t*right) - exp(t*left)) / (t * (right - left)), Ne(t, 0)),
2966                          (S.One, True))
2967 
2968     def expectation(self, expr, var, **kwargs):
2969         from sympy import Max, Min
2970         kwargs['evaluate'] = True
2971         result = SingleContinuousDistribution.expectation(self, expr, var, **kwargs)
2972         result = result.subs({Max(self.left, self.right): self.right,
2973                               Min(self.left, self.right): self.left})
2974         return result
2975 
2976     def sample(self):
2977         return random.uniform(self.left, self.right)
2978 
2979 
2980 def Uniform(name, left, right):
2981     r"""
2982     Create a continuous random variable with a uniform distribution.
2983 
2984     The density of the uniform distribution is given by
2985 
2986     .. math::
2987         f(x) := \begin{cases}
2988                   \frac{1}{b - a} & \text{for } x \in [a,b]  \\
2989                   0               & \text{otherwise}
2990                 \end{cases}
2991 
2992     with :math:`x \in [a,b]`.
2993 
2994     Parameters
2995     ==========
2996 
2997     a : Real number, :math:`-\infty < a` the left boundary
2998     b : Real number, :math:`a < b < \infty` the right boundary
2999 
3000     Returns
3001     =======
3002 
3003     A RandomSymbol.
3004 
3005     Examples
3006     ========
3007 
3008     >>> from sympy.stats import Uniform, density, cdf, E, variance, skewness
3009     >>> from sympy import Symbol, simplify
3010 
3011     >>> a = Symbol("a", negative=True)
3012     >>> b = Symbol("b", positive=True)
3013     >>> z = Symbol("z")
3014 
3015     >>> X = Uniform("x", a, b)
3016 
3017     >>> density(X)(z)
3018     Piecewise((1/(-a + b), (b >= z) & (a <= z)), (0, True))
3019 
3020     >>> cdf(X)(z)  # doctest: +SKIP
3021     -a/(-a + b) + z/(-a + b)
3022 
3023     >>> simplify(E(X))
3024     a/2 + b/2
3025 
3026     >>> simplify(variance(X))
3027     a**2/12 - a*b/6 + b**2/12
3028 
3029     References
3030     ==========
3031 
3032     .. [1] https://en.wikipedia.org/wiki/Uniform_distribution_%28continuous%29
3033     .. [2] http://mathworld.wolfram.com/UniformDistribution.html
3034 
3035     """
3036 
3037     return rv(name, UniformDistribution, (left, right))
3038 
3039 #-------------------------------------------------------------------------------
3040 # UniformSum distribution ------------------------------------------------------
3041 
3042 
3043 class UniformSumDistribution(SingleContinuousDistribution):
3044     _argnames = ('n',)
3045 
3046     @property
3047     def set(self):
3048         return Interval(0, self.n)
3049 
3050     def pdf(self, x):
3051         n = self.n
3052         k = Dummy("k")
3053         return 1/factorial(
3054             n - 1)*Sum((-1)**k*binomial(n, k)*(x - k)**(n - 1), (k, 0, floor(x)))
3055 
3056     def _cdf(self, x):
3057         n = self.n
3058         k = Dummy("k")
3059         return Piecewise((S.Zero, x < 0),
3060                         (1/factorial(n)*Sum((-1)**k*binomial(n, k)*(x - k)**(n),
3061                         (k, 0, floor(x))), x <= n),
3062                         (S.One, True))
3063 
3064     def _characteristic_function(self, t):
3065         return ((exp(I*t) - 1) / (I*t))**self.n
3066 
3067     def _moment_generating_function(self, t):
3068         return ((exp(t) - 1) / t)**self.n
3069 
3070 def UniformSum(name, n):
3071     r"""
3072     Create a continuous random variable with an Irwin-Hall distribution.
3073 
3074     The probability distribution function depends on a single parameter
3075     `n` which is an integer.
3076 
3077     The density of the Irwin-Hall distribution is given by
3078 
3079     .. math ::
3080         f(x) := \frac{1}{(n-1)!}\sum_{k=0}^{\left\lfloor x\right\rfloor}(-1)^k
3081                 \binom{n}{k}(x-k)^{n-1}
3082 
3083     Parameters
3084     ==========
3085 
3086     n : A positive Integer, `n > 0`
3087 
3088     Returns
3089     =======
3090 
3091     A RandomSymbol.
3092 
3093     Examples
3094     ========
3095 
3096     >>> from sympy.stats import UniformSum, density, cdf
3097     >>> from sympy import Symbol, pprint
3098 
3099     >>> n = Symbol("n", integer=True)
3100     >>> z = Symbol("z")
3101 
3102     >>> X = UniformSum("x", n)
3103 
3104     >>> D = density(X)(z)
3105     >>> pprint(D, use_unicode=False)
3106     floor(z)
3107       ___
3108       \  `
3109        \         k         n - 1 /n\
3110         )    (-1) *(-k + z)     *| |
3111        /                         \k/
3112       /__,
3113      k = 0
3114     --------------------------------
3115                 (n - 1)!
3116 
3117     >>> cdf(X)(z)
3118     Piecewise((0, z < 0), (Sum((-1)**_k*(-_k + z)**n*binomial(n, _k),
3119                     (_k, 0, floor(z)))/factorial(n), n >= z), (1, True))
3120 
3121 
3122     Compute cdf with specific 'x' and 'n' values as follows :
3123     >>> cdf(UniformSum("x", 5), evaluate=False)(2).doit()
3124     9/40
3125 
3126     The argument evaluate=False prevents an attempt at evaluation
3127     of the sum for general n, before the argument 2 is passed.
3128 
3129     References
3130     ==========
3131 
3132     .. [1] https://en.wikipedia.org/wiki/Uniform_sum_distribution
3133     .. [2] http://mathworld.wolfram.com/UniformSumDistribution.html
3134 
3135     """
3136 
3137     return rv(name, UniformSumDistribution, (n, ))
3138 
3139 #-------------------------------------------------------------------------------
3140 # VonMises distribution --------------------------------------------------------
3141 
3142 
3143 class VonMisesDistribution(SingleContinuousDistribution):
3144     _argnames = ('mu', 'k')
3145 
3146     set = Interval(0, 2*pi)
3147 
3148     @staticmethod
3149     def check(mu, k):
3150         _value_check(k > 0, "k must be positive")
3151 
3152     def pdf(self, x):
3153         mu, k = self.mu, self.k
3154         return exp(k*cos(x-mu)) / (2*pi*besseli(0, k))
3155 
3156 def VonMises(name, mu, k):
3157     r"""
3158     Create a Continuous Random Variable with a von Mises distribution.
3159 
3160     The density of the von Mises distribution is given by
3161 
3162     .. math::
3163         f(x) := \frac{e^{\kappa\cos(x-\mu)}}{2\pi I_0(\kappa)}
3164 
3165     with :math:`x \in [0,2\pi]`.
3166 
3167     Parameters
3168     ==========
3169 
3170     mu : Real number, measure of location
3171     k : Real number, measure of concentration
3172 
3173     Returns
3174     =======
3175 
3176     A RandomSymbol.
3177 
3178     Examples
3179     ========
3180 
3181     >>> from sympy.stats import VonMises, density, E, variance
3182     >>> from sympy import Symbol, simplify, pprint
3183 
3184     >>> mu = Symbol("mu")
3185     >>> k = Symbol("k", positive=True)
3186     >>> z = Symbol("z")
3187 
3188     >>> X = VonMises("x", mu, k)
3189 
3190     >>> D = density(X)(z)
3191     >>> pprint(D, use_unicode=False)
3192          k*cos(mu - z)
3193         e
3194     ------------------
3195     2*pi*besseli(0, k)
3196 
3197 
3198     References
3199     ==========
3200 
3201     .. [1] https://en.wikipedia.org/wiki/Von_Mises_distribution
3202     .. [2] http://mathworld.wolfram.com/vonMisesDistribution.html
3203 
3204     """
3205 
3206     return rv(name, VonMisesDistribution, (mu, k))
3207 
3208 #-------------------------------------------------------------------------------
3209 # Weibull distribution ---------------------------------------------------------
3210 
3211 
3212 class WeibullDistribution(SingleContinuousDistribution):
3213     _argnames = ('alpha', 'beta')
3214 
3215     set = Interval(0, oo)
3216 
3217     @staticmethod
3218     def check(alpha, beta):
3219         _value_check(alpha > 0, "Alpha must be positive")
3220         _value_check(beta > 0, "Beta must be positive")
3221 
3222     def pdf(self, x):
3223         alpha, beta = self.alpha, self.beta
3224         return beta * (x/alpha)**(beta - 1) * exp(-(x/alpha)**beta) / alpha
3225 
3226     def sample(self):
3227         return random.weibullvariate(self.alpha, self.beta)
3228 
3229 def Weibull(name, alpha, beta):
3230     r"""
3231     Create a continuous random variable with a Weibull distribution.
3232 
3233     The density of the Weibull distribution is given by
3234 
3235     .. math::
3236         f(x) := \begin{cases}
3237                   \frac{k}{\lambda}\left(\frac{x}{\lambda}\right)^{k-1}
3238                   e^{-(x/\lambda)^{k}} & x\geq0\\
3239                   0 & x<0
3240                 \end{cases}
3241 
3242     Parameters
3243     ==========
3244 
3245     lambda : Real number, :math:`\lambda > 0` a scale
3246     k : Real number, `k > 0` a shape
3247 
3248     Returns
3249     =======
3250 
3251     A RandomSymbol.
3252 
3253     Examples
3254     ========
3255 
3256     >>> from sympy.stats import Weibull, density, E, variance
3257     >>> from sympy import Symbol, simplify
3258 
3259     >>> l = Symbol("lambda", positive=True)
3260     >>> k = Symbol("k", positive=True)
3261     >>> z = Symbol("z")
3262 
3263     >>> X = Weibull("x", l, k)
3264 
3265     >>> density(X)(z)
3266     k*(z/lambda)**(k - 1)*exp(-(z/lambda)**k)/lambda
3267 
3268     >>> simplify(E(X))
3269     lambda*gamma(1 + 1/k)
3270 
3271     >>> simplify(variance(X))
3272     lambda**2*(-gamma(1 + 1/k)**2 + gamma(1 + 2/k))
3273 
3274     References
3275     ==========
3276 
3277     .. [1] https://en.wikipedia.org/wiki/Weibull_distribution
3278     .. [2] http://mathworld.wolfram.com/WeibullDistribution.html
3279 
3280     """
3281 
3282     return rv(name, WeibullDistribution, (alpha, beta))
3283 
3284 #-------------------------------------------------------------------------------
3285 # Wigner semicircle distribution -----------------------------------------------
3286 
3287 
3288 class WignerSemicircleDistribution(SingleContinuousDistribution):
3289     _argnames = ('R',)
3290 
3291     @property
3292     def set(self):
3293         return Interval(-self.R, self.R)
3294 
3295     def pdf(self, x):
3296         R = self.R
3297         return 2/(pi*R**2)*sqrt(R**2 - x**2)
3298 
3299     def _characteristic_function(self, t):
3300         return Piecewise((2 * besselj(1, self.R*t) / (self.R*t), Ne(t, 0)),
3301                          (S.One, True))
3302 
3303     def _moment_generating_function(self, t):
3304         return Piecewise((2 * besseli(1, self.R*t) / (self.R*t), Ne(t, 0)),
3305                          (S.One, True))
3306 
3307 def WignerSemicircle(name, R):
3308     r"""
3309     Create a continuous random variable with a Wigner semicircle distribution.
3310 
3311     The density of the Wigner semicircle distribution is given by
3312 
3313     .. math::
3314         f(x) := \frac2{\pi R^2}\,\sqrt{R^2-x^2}
3315 
3316     with :math:`x \in [-R,R]`.
3317 
3318     Parameters
3319     ==========
3320 
3321     R : Real number, `R > 0`, the radius
3322 
3323     Returns
3324     =======
3325 
3326     A `RandomSymbol`.
3327 
3328     Examples
3329     ========
3330 
3331     >>> from sympy.stats import WignerSemicircle, density, E
3332     >>> from sympy import Symbol, simplify
3333 
3334     >>> R = Symbol("R", positive=True)
3335     >>> z = Symbol("z")
3336 
3337     >>> X = WignerSemicircle("x", R)
3338 
3339     >>> density(X)(z)
3340     2*sqrt(R**2 - z**2)/(pi*R**2)
3341 
3342     >>> E(X)
3343     0
3344 
3345     References
3346     ==========
3347 
3348     .. [1] https://en.wikipedia.org/wiki/Wigner_semicircle_distribution
3349     .. [2] http://mathworld.wolfram.com/WignersSemicircleLaw.html
3350 
3351     """
3352 
3353     return rv(name, WignerSemicircleDistribution, (R,))

</code><intended_behavior>Ensure the initialization methods of distribution classes rigorously validate input parameters against the mathematical constraints and logical rules applicable to those distributions. For example, in a Normal distribution, ensuring the standard deviation is positive. This preserves existing functionality by validating inputs that were previously assumed to be correct.</intended_behavior>, <file>sympy/stats/rv.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2 Main Random Variables Module
3 
4 Defines abstract random variable type.
5 Contains interfaces for probability space object (PSpace) as well as standard
6 operators, P, E, sample, density, where, quantile
7 
8 See Also
9 ========
10 
11 sympy.stats.crv
12 sympy.stats.frv
13 sympy.stats.rv_interface
14 """
15 
16 from __future__ import print_function, division
17 
18 from sympy import (Basic, S, Expr, Symbol, Tuple, And, Add, Eq, lambdify,
19         Equality, Lambda, sympify, Dummy, Ne, KroneckerDelta,
20         DiracDelta, Mul)
21 from sympy.abc import x
22 from sympy.core.compatibility import string_types
23 from sympy.core.relational import Relational
24 from sympy.logic.boolalg import Boolean
25 from sympy.sets.sets import FiniteSet, ProductSet, Intersection
26 from sympy.solvers.solveset import solveset
27 
28 
29 class RandomDomain(Basic):
30     """
31     Represents a set of variables and the values which they can take
32 
33     See Also
34     ========
35 
36     sympy.stats.crv.ContinuousDomain
37     sympy.stats.frv.FiniteDomain
38     """
39 
40     is_ProductDomain = False
41     is_Finite = False
42     is_Continuous = False
43     is_Discrete = False
44 
45     def __new__(cls, symbols, *args):
46         symbols = FiniteSet(*symbols)
47         return Basic.__new__(cls, symbols, *args)
48 
49     @property
50     def symbols(self):
51         return self.args[0]
52 
53     @property
54     def set(self):
55         return self.args[1]
56 
57     def __contains__(self, other):
58         raise NotImplementedError()
59 
60     def compute_expectation(self, expr):
61         raise NotImplementedError()
62 
63 
64 class SingleDomain(RandomDomain):
65     """
66     A single variable and its domain
67 
68     See Also
69     ========
70 
71     sympy.stats.crv.SingleContinuousDomain
72     sympy.stats.frv.SingleFiniteDomain
73     """
74     def __new__(cls, symbol, set):
75         assert symbol.is_Symbol
76         return Basic.__new__(cls, symbol, set)
77 
78     @property
79     def symbol(self):
80         return self.args[0]
81 
82     @property
83     def symbols(self):
84         return FiniteSet(self.symbol)
85 
86     def __contains__(self, other):
87         if len(other) != 1:
88             return False
89         sym, val = tuple(other)[0]
90         return self.symbol == sym and val in self.set
91 
92 
93 class ConditionalDomain(RandomDomain):
94     """
95     A RandomDomain with an attached condition
96 
97     See Also
98     ========
99 
100     sympy.stats.crv.ConditionalContinuousDomain
101     sympy.stats.frv.ConditionalFiniteDomain
102     """
103     def __new__(cls, fulldomain, condition):
104         condition = condition.xreplace(dict((rs, rs.symbol)
105             for rs in random_symbols(condition)))
106         return Basic.__new__(cls, fulldomain, condition)
107 
108     @property
109     def symbols(self):
110         return self.fulldomain.symbols
111 
112     @property
113     def fulldomain(self):
114         return self.args[0]
115 
116     @property
117     def condition(self):
118         return self.args[1]
119 
120     @property
121     def set(self):
122         raise NotImplementedError("Set of Conditional Domain not Implemented")
123 
124     def as_boolean(self):
125         return And(self.fulldomain.as_boolean(), self.condition)
126 
127 
128 class PSpace(Basic):
129     """
130     A Probability Space
131 
132     Probability Spaces encode processes that equal different values
133     probabilistically. These underly Random Symbols which occur in SymPy
134     expressions and contain the mechanics to evaluate statistical statements.
135 
136     See Also
137     ========
138 
139     sympy.stats.crv.ContinuousPSpace
140     sympy.stats.frv.FinitePSpace
141     """
142 
143     is_Finite = None
144     is_Continuous = None
145     is_Discrete = None
146     is_real = None
147 
148     @property
149     def domain(self):
150         return self.args[0]
151 
152     @property
153     def density(self):
154         return self.args[1]
155 
156     @property
157     def values(self):
158         return frozenset(RandomSymbol(sym, self) for sym in self.symbols)
159 
160     @property
161     def symbols(self):
162         return self.domain.symbols
163 
164     def where(self, condition):
165         raise NotImplementedError()
166 
167     def compute_density(self, expr):
168         raise NotImplementedError()
169 
170     def sample(self):
171         raise NotImplementedError()
172 
173     def probability(self, condition):
174         raise NotImplementedError()
175 
176     def compute_expectation(self, expr):
177         raise NotImplementedError()
178 
179 
180 class SinglePSpace(PSpace):
181     """
182     Represents the probabilities of a set of random events that can be
183     attributed to a single variable/symbol.
184     """
185     def __new__(cls, s, distribution):
186         if isinstance(s, string_types):
187             s = Symbol(s)
188         if not isinstance(s, Symbol):
189             raise TypeError("s should have been string or Symbol")
190         return Basic.__new__(cls, s, distribution)
191 
192     @property
193     def value(self):
194         return RandomSymbol(self.symbol, self)
195 
196     @property
197     def symbol(self):
198         return self.args[0]
199 
200     @property
201     def distribution(self):
202         return self.args[1]
203 
204     @property
205     def pdf(self):
206         return self.distribution.pdf(self.symbol)
207 
208 
209 class RandomSymbol(Expr):
210     """
211     Random Symbols represent ProbabilitySpaces in SymPy Expressions
212     In principle they can take on any value that their symbol can take on
213     within the associated PSpace with probability determined by the PSpace
214     Density.
215 
216     Random Symbols contain pspace and symbol properties.
217     The pspace property points to the represented Probability Space
218     The symbol is a standard SymPy Symbol that is used in that probability space
219     for example in defining a density.
220 
221     You can form normal SymPy expressions using RandomSymbols and operate on
222     those expressions with the Functions
223 
224     E - Expectation of a random expression
225     P - Probability of a condition
226     density - Probability Density of an expression
227     given - A new random expression (with new random symbols) given a condition
228 
229     An object of the RandomSymbol type should almost never be created by the
230     user. They tend to be created instead by the PSpace class's value method.
231     Traditionally a user doesn't even do this but instead calls one of the
232     convenience functions Normal, Exponential, Coin, Die, FiniteRV, etc....
233     """
234 
235     def __new__(cls, symbol, pspace=None):
236         from sympy.stats.joint_rv import JointRandomSymbol
237         if pspace is None:
238             # Allow single arg, representing pspace == PSpace()
239             pspace = PSpace()
240         if not isinstance(symbol, Symbol):
241             raise TypeError("symbol should be of type Symbol")
242         if not isinstance(pspace, PSpace):
243             raise TypeError("pspace variable should be of type PSpace")
244         if cls == JointRandomSymbol and isinstance(pspace, SinglePSpace):
245             cls = RandomSymbol
246         return Basic.__new__(cls, symbol, pspace)
247 
248     is_finite = True
249     is_symbol = True
250     is_Atom = True
251 
252     _diff_wrt = True
253 
254     pspace = property(lambda self: self.args[1])
255     symbol = property(lambda self: self.args[0])
256     name   = property(lambda self: self.symbol.name)
257 
258     def _eval_is_positive(self):
259         return self.symbol.is_positive
260 
261     def _eval_is_integer(self):
262         return self.symbol.is_integer
263 
264     def _eval_is_real(self):
265         return self.symbol.is_real or self.pspace.is_real
266 
267     @property
268     def is_commutative(self):
269         return self.symbol.is_commutative
270 
271     def _hashable_content(self):
272         return self.pspace, self.symbol
273 
274     @property
275     def free_symbols(self):
276         return {self}
277 
278 
279 class ProductPSpace(PSpace):
280     """
281     Abstract class for representing probability spaces with multiple random
282     variables.
283 
284     See Also
285     ========
286 
287     sympy.stats.rv.IndependentProductPSpace
288     sympy.stats.joint_rv.JointPSpace
289     """
290     pass
291 
292 class IndependentProductPSpace(ProductPSpace):
293     """
294     A probability space resulting from the merger of two independent probability
295     spaces.
296 
297     Often created using the function, pspace
298     """
299 
300     def __new__(cls, *spaces):
301         rs_space_dict = {}
302         for space in spaces:
303             for value in space.values:
304                 rs_space_dict[value] = space
305 
306         symbols = FiniteSet(*[val.symbol for val in rs_space_dict.keys()])
307 
308         # Overlapping symbols
309         from sympy.stats.joint_rv import MarginalDistribution, CompoundDistribution
310         if len(symbols) < sum(len(space.symbols) for space in spaces if not
311          isinstance(space.distribution, (
312             CompoundDistribution, MarginalDistribution))):
313             raise ValueError("Overlapping Random Variables")
314 
315         if all(space.is_Finite for space in spaces):
316             from sympy.stats.frv import ProductFinitePSpace
317             cls = ProductFinitePSpace
318 
319         obj = Basic.__new__(cls, *FiniteSet(*spaces))
320 
321         return obj
322 
323     @property
324     def pdf(self):
325         p = Mul(*[space.pdf for space in self.spaces])
326         return p.subs(dict((rv, rv.symbol) for rv in self.values))
327 
328     @property
329     def rs_space_dict(self):
330         d = {}
331         for space in self.spaces:
332             for value in space.values:
333                 d[value] = space
334         return d
335 
336     @property
337     def symbols(self):
338         return FiniteSet(*[val.symbol for val in self.rs_space_dict.keys()])
339 
340     @property
341     def spaces(self):
342         return FiniteSet(*self.args)
343 
344     @property
345     def values(self):
346         return sumsets(space.values for space in self.spaces)
347 
348     def compute_expectation(self, expr, rvs=None, evaluate=False, **kwargs):
349         rvs = rvs or self.values
350         rvs = frozenset(rvs)
351         for space in self.spaces:
352             expr = space.compute_expectation(expr, rvs & space.values, evaluate=False, **kwargs)
353         if evaluate and hasattr(expr, 'doit'):
354             return expr.doit(**kwargs)
355         return expr
356 
357     @property
358     def domain(self):
359         return ProductDomain(*[space.domain for space in self.spaces])
360 
361     @property
362     def density(self):
363         raise NotImplementedError("Density not available for ProductSpaces")
364 
365     def sample(self):
366         return {k: v for space in self.spaces
367             for k, v in space.sample().items()}
368 
369     def probability(self, condition, **kwargs):
370         cond_inv = False
371         if isinstance(condition, Ne):
372             condition = Eq(condition.args[0], condition.args[1])
373             cond_inv = True
374         expr = condition.lhs - condition.rhs
375         rvs = random_symbols(expr)
376         z = Dummy('z', real=True, Finite=True)
377         dens = self.compute_density(expr)
378         if any([pspace(rv).is_Continuous for rv in rvs]):
379             from sympy.stats.crv import (ContinuousDistributionHandmade,
380                 SingleContinuousPSpace)
381             if expr in self.values:
382                 # Marginalize all other random symbols out of the density
383                 randomsymbols = tuple(set(self.values) - frozenset([expr]))
384                 symbols = tuple(rs.symbol for rs in randomsymbols)
385                 pdf = self.domain.integrate(self.pdf, symbols, **kwargs)
386                 return Lambda(expr.symbol, pdf)
387             dens = ContinuousDistributionHandmade(dens)
388             space = SingleContinuousPSpace(z, dens)
389             result = space.probability(condition.__class__(space.value, 0))
390         else:
391             from sympy.stats.drv import (DiscreteDistributionHandmade,
392                 SingleDiscretePSpace)
393             dens = DiscreteDistributionHandmade(dens)
394             space = SingleDiscretePSpace(z, dens)
395             result = space.probability(condition.__class__(space.value, 0))
396         return result if not cond_inv else S.One - result
397 
398     def compute_density(self, expr, **kwargs):
399         z = Dummy('z', real=True, finite=True)
400         rvs = random_symbols(expr)
401         if any(pspace(rv).is_Continuous for rv in rvs):
402             expr = self.compute_expectation(DiracDelta(expr - z),
403              **kwargs)
404         else:
405             expr = self.compute_expectation(KroneckerDelta(expr, z),
406              **kwargs)
407         return Lambda(z, expr)
408 
409     def compute_cdf(self, expr, **kwargs):
410         raise ValueError("CDF not well defined on multivariate expressions")
411 
412     def conditional_space(self, condition, normalize=True, **kwargs):
413         rvs = random_symbols(condition)
414         condition = condition.xreplace(dict((rv, rv.symbol) for rv in self.values))
415         if any([pspace(rv).is_Continuous for rv in rvs]):
416             from sympy.stats.crv import (ConditionalContinuousDomain,
417                 ContinuousPSpace)
418             space = ContinuousPSpace
419             domain = ConditionalContinuousDomain(self.domain, condition)
420         elif any([pspace(rv).is_Discrete for rv in rvs]):
421             from sympy.stats.drv import (ConditionalDiscreteDomain,
422                 DiscretePSpace)
423             space = DiscretePSpace
424             domain = ConditionalDiscreteDomain(self.domain, condition)
425         elif all([pspace(rv).is_Finite for rv in rvs]):
426             from sympy.stats.frv import FinitePSpace
427             return FinitePSpace.conditional_space(self, condition)
428         if normalize:
429             replacement  = {rv: Dummy(str(rv)) for rv in self.symbols}
430             norm = domain.compute_expectation(self.pdf, **kwargs)
431             pdf = self.pdf / norm.xreplace(replacement)
432             density = Lambda(domain.symbols, pdf)
433 
434         return space(domain, density)
435 
436 class ProductDomain(RandomDomain):
437     """
438     A domain resulting from the merger of two independent domains
439 
440     See Also
441     ========
442     sympy.stats.crv.ProductContinuousDomain
443     sympy.stats.frv.ProductFiniteDomain
444     """
445     is_ProductDomain = True
446 
447     def __new__(cls, *domains):
448         # Flatten any product of products
449         domains2 = []
450         for domain in domains:
451             if not domain.is_ProductDomain:
452                 domains2.append(domain)
453             else:
454                 domains2.extend(domain.domains)
455         domains2 = FiniteSet(*domains2)
456 
457         if all(domain.is_Finite for domain in domains2):
458             from sympy.stats.frv import ProductFiniteDomain
459             cls = ProductFiniteDomain
460         if all(domain.is_Continuous for domain in domains2):
461             from sympy.stats.crv import ProductContinuousDomain
462             cls = ProductContinuousDomain
463         if all(domain.is_Discrete for domain in domains2):
464             from sympy.stats.drv import ProductDiscreteDomain
465             cls = ProductDiscreteDomain
466 
467         return Basic.__new__(cls, *domains2)
468 
469     @property
470     def sym_domain_dict(self):
471         return dict((symbol, domain) for domain in self.domains
472                                      for symbol in domain.symbols)
473 
474     @property
475     def symbols(self):
476         return FiniteSet(*[sym for domain in self.domains
477                                for sym    in domain.symbols])
478 
479     @property
480     def domains(self):
481         return self.args
482 
483     @property
484     def set(self):
485         return ProductSet(domain.set for domain in self.domains)
486 
487     def __contains__(self, other):
488         # Split event into each subdomain
489         for domain in self.domains:
490             # Collect the parts of this event which associate to this domain
491             elem = frozenset([item for item in other
492                               if sympify(domain.symbols.contains(item[0]))
493                               is S.true])
494             # Test this sub-event
495             if elem not in domain:
496                 return False
497         # All subevents passed
498         return True
499 
500     def as_boolean(self):
501         return And(*[domain.as_boolean() for domain in self.domains])
502 
503 
504 def random_symbols(expr):
505     """
506     Returns all RandomSymbols within a SymPy Expression.
507     """
508     atoms = getattr(expr, 'atoms', None)
509     if atoms is not None:
510         return list(atoms(RandomSymbol))
511     else:
512         return []
513 
514 
515 def pspace(expr):
516     """
517     Returns the underlying Probability Space of a random expression.
518 
519     For internal use.
520 
521     Examples
522     ========
523 
524     >>> from sympy.stats import pspace, Normal
525     >>> from sympy.stats.rv import IndependentProductPSpace
526     >>> X = Normal('X', 0, 1)
527     >>> pspace(2*X + 1) == X.pspace
528     True
529     """
530     expr = sympify(expr)
531     if isinstance(expr, RandomSymbol) and expr.pspace is not None:
532         return expr.pspace
533     rvs = random_symbols(expr)
534     if not rvs:
535         raise ValueError("Expression containing Random Variable expected, not %s" % (expr))
536     # If only one space present
537     if all(rv.pspace == rvs[0].pspace for rv in rvs):
538         return rvs[0].pspace
539     # Otherwise make a product space
540     return IndependentProductPSpace(*[rv.pspace for rv in rvs])
541 
542 
543 def sumsets(sets):
544     """
545     Union of sets
546     """
547     return frozenset().union(*sets)
548 
549 
550 def rs_swap(a, b):
551     """
552     Build a dictionary to swap RandomSymbols based on their underlying symbol.
553 
554     i.e.
555     if    ``X = ('x', pspace1)``
556     and   ``Y = ('x', pspace2)``
557     then ``X`` and ``Y`` match and the key, value pair
558     ``{X:Y}`` will appear in the result
559 
560     Inputs: collections a and b of random variables which share common symbols
561     Output: dict mapping RVs in a to RVs in b
562     """
563     d = {}
564     for rsa in a:
565         d[rsa] = [rsb for rsb in b if rsa.symbol == rsb.symbol][0]
566     return d
567 
568 
569 def given(expr, condition=None, **kwargs):
570     r""" Conditional Random Expression
571     From a random expression and a condition on that expression creates a new
572     probability space from the condition and returns the same expression on that
573     conditional probability space.
574 
575     Examples
576     ========
577 
578     >>> from sympy.stats import given, density, Die
579     >>> X = Die('X', 6)
580     >>> Y = given(X, X > 3)
581     >>> density(Y).dict
582     {4: 1/3, 5: 1/3, 6: 1/3}
583 
584     Following convention, if the condition is a random symbol then that symbol
585     is considered fixed.
586 
587     >>> from sympy.stats import Normal
588     >>> from sympy import pprint
589     >>> from sympy.abc import z
590 
591     >>> X = Normal('X', 0, 1)
592     >>> Y = Normal('Y', 0, 1)
593     >>> pprint(density(X + Y, Y)(z), use_unicode=False)
594                     2
595            -(-Y + z)
596            -----------
597       ___       2
598     \/ 2 *e
599     ------------------
600              ____
601          2*\/ pi
602     """
603 
604     if not random_symbols(condition) or pspace_independent(expr, condition):
605         return expr
606 
607     if isinstance(condition, RandomSymbol):
608         condition = Eq(condition, condition.symbol)
609 
610     condsymbols = random_symbols(condition)
611     if (isinstance(condition, Equality) and len(condsymbols) == 1 and
612         not isinstance(pspace(expr).domain, ConditionalDomain)):
613         rv = tuple(condsymbols)[0]
614 
615         results = solveset(condition, rv)
616         if isinstance(results, Intersection) and S.Reals in results.args:
617             results = list(results.args[1])
618 
619         sums = 0
620         for res in results:
621             temp = expr.subs(rv, res)
622             if temp == True:
623                 return True
624             if temp != False:
625                 sums += expr.subs(rv, res)
626         if sums == 0:
627             return False
628         return sums
629 
630     # Get full probability space of both the expression and the condition
631     fullspace = pspace(Tuple(expr, condition))
632     # Build new space given the condition
633     space = fullspace.conditional_space(condition, **kwargs)
634     # Dictionary to swap out RandomSymbols in expr with new RandomSymbols
635     # That point to the new conditional space
636     swapdict = rs_swap(fullspace.values, space.values)
637     # Swap random variables in the expression
638     expr = expr.xreplace(swapdict)
639     return expr
640 
641 
642 def expectation(expr, condition=None, numsamples=None, evaluate=True, **kwargs):
643     """
644     Returns the expected value of a random expression
645 
646     Parameters
647     ==========
648 
649     expr : Expr containing RandomSymbols
650         The expression of which you want to compute the expectation value
651     given : Expr containing RandomSymbols
652         A conditional expression. E(X, X>0) is expectation of X given X > 0
653     numsamples : int
654         Enables sampling and approximates the expectation with this many samples
655     evalf : Bool (defaults to True)
656         If sampling return a number rather than a complex expression
657     evaluate : Bool (defaults to True)
658         In case of continuous systems return unevaluated integral
659 
660     Examples
661     ========
662 
663     >>> from sympy.stats import E, Die
664     >>> X = Die('X', 6)
665     >>> E(X)
666     7/2
667     >>> E(2*X + 1)
668     8
669 
670     >>> E(X, X > 3) # Expectation of X given that it is above 3
671     5
672     """
673 
674     if not random_symbols(expr):  # expr isn't random?
675         return expr
676     if numsamples:  # Computing by monte carlo sampling?
677         return sampling_E(expr, condition, numsamples=numsamples)
678 
679     # Create new expr and recompute E
680     if condition is not None:  # If there is a condition
681         return expectation(given(expr, condition), evaluate=evaluate)
682 
683     # A few known statements for efficiency
684 
685     if expr.is_Add:  # We know that E is Linear
686         return Add(*[expectation(arg, evaluate=evaluate)
687                      for arg in expr.args])
688 
689     # Otherwise case is simple, pass work off to the ProbabilitySpace
690     result = pspace(expr).compute_expectation(expr, evaluate=evaluate, **kwargs)
691     if evaluate and hasattr(result, 'doit'):
692         return result.doit(**kwargs)
693     else:
694         return result
695 
696 
697 def probability(condition, given_condition=None, numsamples=None,
698                 evaluate=True, **kwargs):
699     """
700     Probability that a condition is true, optionally given a second condition
701 
702     Parameters
703     ==========
704 
705     condition : Combination of Relationals containing RandomSymbols
706         The condition of which you want to compute the probability
707     given_condition : Combination of Relationals containing RandomSymbols
708         A conditional expression. P(X > 1, X > 0) is expectation of X > 1
709         given X > 0
710     numsamples : int
711         Enables sampling and approximates the probability with this many samples
712     evaluate : Bool (defaults to True)
713         In case of continuous systems return unevaluated integral
714 
715     Examples
716     ========
717 
718     >>> from sympy.stats import P, Die
719     >>> from sympy import Eq
720     >>> X, Y = Die('X', 6), Die('Y', 6)
721     >>> P(X > 3)
722     1/2
723     >>> P(Eq(X, 5), X > 2) # Probability that X == 5 given that X > 2
724     1/4
725     >>> P(X > Y)
726     5/12
727     """
728 
729     condition = sympify(condition)
730     given_condition = sympify(given_condition)
731 
732     if isinstance(given_condition, RandomSymbol):
733         if any([dependent(rv, given_condition) for rv in random_symbols(condition)]):
734             from sympy.stats.symbolic_probability import Probability
735             return Probability(condition, given_condition)
736         else:
737             return probability(condition)
738 
739     if given_condition is not None and \
740             not isinstance(given_condition, (Relational, Boolean)):
741         raise ValueError("%s is not a relational or combination of relationals"
742                 % (given_condition))
743     if given_condition == False:
744         return S.Zero
745     if not isinstance(condition, (Relational, Boolean)):
746         raise ValueError("%s is not a relational or combination of relationals"
747                 % (condition))
748     if condition is S.true:
749         return S.One
750     if condition is S.false:
751         return S.Zero
752 
753     if numsamples:
754         return sampling_P(condition, given_condition, numsamples=numsamples,
755                 **kwargs)
756     if given_condition is not None:  # If there is a condition
757         # Recompute on new conditional expr
758         return probability(given(condition, given_condition, **kwargs), **kwargs)
759 
760     # Otherwise pass work off to the ProbabilitySpace
761     result = pspace(condition).probability(condition, **kwargs)
762     if evaluate and hasattr(result, 'doit'):
763         return result.doit()
764     else:
765         return result
766 
767 
768 class Density(Basic):
769     expr = property(lambda self: self.args[0])
770 
771     @property
772     def condition(self):
773         if len(self.args) > 1:
774             return self.args[1]
775         else:
776             return None
777 
778     def doit(self, evaluate=True, **kwargs):
779         from sympy.stats.joint_rv import JointPSpace
780         expr, condition = self.expr, self.condition
781         if condition is not None:
782             # Recompute on new conditional expr
783             expr = given(expr, condition, **kwargs)
784         if isinstance(expr, RandomSymbol) and \
785             isinstance(expr.pspace, JointPSpace):
786             return expr.pspace.distribution
787         if not random_symbols(expr):
788             return Lambda(x, DiracDelta(x - expr))
789         if (isinstance(expr, RandomSymbol) and
790             hasattr(expr.pspace, 'distribution') and
791             isinstance(pspace(expr), (SinglePSpace))):
792             return expr.pspace.distribution
793         result = pspace(expr).compute_density(expr, **kwargs)
794 
795         if evaluate and hasattr(result, 'doit'):
796             return result.doit()
797         else:
798             return result
799 
800 
801 def density(expr, condition=None, evaluate=True, numsamples=None, **kwargs):
802     """
803     Probability density of a random expression, optionally given a second
804     condition.
805 
806     This density will take on different forms for different types of
807     probability spaces. Discrete variables produce Dicts. Continuous
808     variables produce Lambdas.
809 
810     Parameters
811     ==========
812 
813     expr : Expr containing RandomSymbols
814         The expression of which you want to compute the density value
815     condition : Relational containing RandomSymbols
816         A conditional expression. density(X > 1, X > 0) is density of X > 1
817         given X > 0
818     numsamples : int
819         Enables sampling and approximates the density with this many samples
820 
821     Examples
822     ========
823 
824     >>> from sympy.stats import density, Die, Normal
825     >>> from sympy import Symbol
826 
827     >>> x = Symbol('x')
828     >>> D = Die('D', 6)
829     >>> X = Normal(x, 0, 1)
830 
831     >>> density(D).dict
832     {1: 1/6, 2: 1/6, 3: 1/6, 4: 1/6, 5: 1/6, 6: 1/6}
833     >>> density(2*D).dict
834     {2: 1/6, 4: 1/6, 6: 1/6, 8: 1/6, 10: 1/6, 12: 1/6}
835     >>> density(X)(x)
836     sqrt(2)*exp(-x**2/2)/(2*sqrt(pi))
837     """
838 
839     if numsamples:
840         return sampling_density(expr, condition, numsamples=numsamples,
841                 **kwargs)
842 
843     return Density(expr, condition).doit(evaluate=evaluate, **kwargs)
844 
845 
846 def cdf(expr, condition=None, evaluate=True, **kwargs):
847     """
848     Cumulative Distribution Function of a random expression.
849 
850     optionally given a second condition
851 
852     This density will take on different forms for different types of
853     probability spaces.
854     Discrete variables produce Dicts.
855     Continuous variables produce Lambdas.
856 
857     Examples
858     ========
859 
860     >>> from sympy.stats import density, Die, Normal, cdf
861 
862     >>> D = Die('D', 6)
863     >>> X = Normal('X', 0, 1)
864 
865     >>> density(D).dict
866     {1: 1/6, 2: 1/6, 3: 1/6, 4: 1/6, 5: 1/6, 6: 1/6}
867     >>> cdf(D)
868     {1: 1/6, 2: 1/3, 3: 1/2, 4: 2/3, 5: 5/6, 6: 1}
869     >>> cdf(3*D, D > 2)
870     {9: 1/4, 12: 1/2, 15: 3/4, 18: 1}
871 
872     >>> cdf(X)
873     Lambda(_z, erf(sqrt(2)*_z/2)/2 + 1/2)
874     """
875     if condition is not None:  # If there is a condition
876         # Recompute on new conditional expr
877         return cdf(given(expr, condition, **kwargs), **kwargs)
878 
879     # Otherwise pass work off to the ProbabilitySpace
880     result = pspace(expr).compute_cdf(expr, **kwargs)
881 
882     if evaluate and hasattr(result, 'doit'):
883         return result.doit()
884     else:
885         return result
886 
887 
888 def characteristic_function(expr, condition=None, evaluate=True, **kwargs):
889     """
890     Characteristic function of a random expression, optionally given a second condition
891 
892     Returns a Lambda
893 
894     Examples
895     ========
896 
897     >>> from sympy.stats import Normal, DiscreteUniform, Poisson, characteristic_function
898 
899     >>> X = Normal('X', 0, 1)
900     >>> characteristic_function(X)
901     Lambda(_t, exp(-_t**2/2))
902 
903     >>> Y = DiscreteUniform('Y', [1, 2, 7])
904     >>> characteristic_function(Y)
905     Lambda(_t, exp(7*_t*I)/3 + exp(2*_t*I)/3 + exp(_t*I)/3)
906 
907     >>> Z = Poisson('Z', 2)
908     >>> characteristic_function(Z)
909     Lambda(_t, exp(2*exp(_t*I) - 2))
910     """
911     if condition is not None:
912         return characteristic_function(given(expr, condition, **kwargs), **kwargs)
913 
914     result = pspace(expr).compute_characteristic_function(expr, **kwargs)
915 
916     if evaluate and hasattr(result, 'doit'):
917         return result.doit()
918     else:
919         return result
920 
921 def moment_generating_function(expr, condition=None, evaluate=True, **kwargs):
922     if condition is not None:
923         return moment_generating_function(given(expr, condition, **kwargs), **kwargs)
924 
925     result = pspace(expr).compute_moment_generating_function(expr, **kwargs)
926 
927     if evaluate and hasattr(result, 'doit'):
928         return result.doit()
929     else:
930         return result
931 
932 def where(condition, given_condition=None, **kwargs):
933     """
934     Returns the domain where a condition is True.
935 
936     Examples
937     ========
938 
939     >>> from sympy.stats import where, Die, Normal
940     >>> from sympy import symbols, And
941 
942     >>> D1, D2 = Die('a', 6), Die('b', 6)
943     >>> a, b = D1.symbol, D2.symbol
944     >>> X = Normal('x', 0, 1)
945 
946     >>> where(X**2<1)
947     Domain: (-1 < x) & (x < 1)
948 
949     >>> where(X**2<1).set
950     Interval.open(-1, 1)
951 
952     >>> where(And(D1<=D2 , D2<3))
953     Domain: (Eq(a, 1) & Eq(b, 1)) | (Eq(a, 1) & Eq(b, 2)) | (Eq(a, 2) & Eq(b, 2))
954     """
955     if given_condition is not None:  # If there is a condition
956         # Recompute on new conditional expr
957         return where(given(condition, given_condition, **kwargs), **kwargs)
958 
959     # Otherwise pass work off to the ProbabilitySpace
960     return pspace(condition).where(condition, **kwargs)
961 
962 
963 def sample(expr, condition=None, **kwargs):
964     """
965     A realization of the random expression
966 
967     Examples
968     ========
969 
970     >>> from sympy.stats import Die, sample
971     >>> X, Y, Z = Die('X', 6), Die('Y', 6), Die('Z', 6)
972 
973     >>> die_roll = sample(X + Y + Z) # A random realization of three dice
974     """
975     return next(sample_iter(expr, condition, numsamples=1))
976 
977 
978 def sample_iter(expr, condition=None, numsamples=S.Infinity, **kwargs):
979     """
980     Returns an iterator of realizations from the expression given a condition
981 
982     Parameters
983     ==========
984 
985     expr: Expr
986         Random expression to be realized
987     condition: Expr, optional
988         A conditional expression
989     numsamples: integer, optional
990         Length of the iterator (defaults to infinity)
991 
992     Examples
993     ========
994 
995     >>> from sympy.stats import Normal, sample_iter
996     >>> X = Normal('X', 0, 1)
997     >>> expr = X*X + 3
998     >>> iterator = sample_iter(expr, numsamples=3)
999     >>> list(iterator) # doctest: +SKIP
1000     [12, 4, 7]
1001 
1002     See Also
1003     ========
1004 
1005     sample
1006     sampling_P
1007     sampling_E
1008     sample_iter_lambdify
1009     sample_iter_subs
1010 
1011     """
1012     # lambdify is much faster but not as robust
1013     try:
1014         return sample_iter_lambdify(expr, condition, numsamples, **kwargs)
1015     # use subs when lambdify fails
1016     except TypeError:
1017         return sample_iter_subs(expr, condition, numsamples, **kwargs)
1018 
1019 def quantile(expr, evaluate=True, **kwargs):
1020     r"""
1021     Return the :math:`p^{th}` order quantile of a probability distribution.
1022 
1023     Quantile is defined as the value at which the probability of the random
1024     variable is less than or equal to the given probability.
1025 
1026     ..math::
1027         Q(p) = inf{x \in (-\infty, \infty) such that p <= F(x)}
1028 
1029     Examples
1030     ========
1031 
1032     >>> from sympy.stats import quantile, Die, Exponential
1033     >>> from sympy import Symbol, pprint
1034     >>> p = Symbol("p")
1035 
1036     >>> l = Symbol("lambda", positive=True)
1037     >>> X = Exponential("x", l)
1038     >>> quantile(X)(p)
1039     -log(1 - p)/lambda
1040 
1041     >>> D = Die("d", 6)
1042     >>> pprint(quantile(D)(p), use_unicode=False)
1043     /nan  for Or(p > 1, p < 0)
1044     |
1045     | 1       for p <= 1/6
1046     |
1047     | 2       for p <= 1/3
1048     |
1049     < 3       for p <= 1/2
1050     |
1051     | 4       for p <= 2/3
1052     |
1053     | 5       for p <= 5/6
1054     |
1055     \ 6        for p <= 1
1056 
1057     """
1058     result = pspace(expr).compute_quantile(expr, **kwargs)
1059 
1060     if evaluate and hasattr(result, 'doit'):
1061         return result.doit()
1062     else:
1063         return result
1064 
1065 def sample_iter_lambdify(expr, condition=None, numsamples=S.Infinity, **kwargs):
1066     """
1067     See sample_iter
1068 
1069     Uses lambdify for computation. This is fast but does not always work.
1070     """
1071     if condition:
1072         ps = pspace(Tuple(expr, condition))
1073     else:
1074         ps = pspace(expr)
1075 
1076     rvs = list(ps.values)
1077     fn = lambdify(rvs, expr, **kwargs)
1078     if condition:
1079         given_fn = lambdify(rvs, condition, **kwargs)
1080 
1081     # Check that lambdify can handle the expression
1082     # Some operations like Sum can prove difficult
1083     try:
1084         d = ps.sample()  # a dictionary that maps RVs to values
1085         args = [d[rv] for rv in rvs]
1086         fn(*args)
1087         if condition:
1088             given_fn(*args)
1089     except Exception:
1090         raise TypeError("Expr/condition too complex for lambdify")
1091 
1092     def return_generator():
1093         count = 0
1094         while count < numsamples:
1095             d = ps.sample()  # a dictionary that maps RVs to values
1096             args = [d[rv] for rv in rvs]
1097 
1098             if condition:  # Check that these values satisfy the condition
1099                 gd = given_fn(*args)
1100                 if gd != True and gd != False:
1101                     raise ValueError(
1102                         "Conditions must not contain free symbols")
1103                 if not gd:  # If the values don't satisfy then try again
1104                     continue
1105 
1106             yield fn(*args)
1107             count += 1
1108     return return_generator()
1109 
1110 
1111 def sample_iter_subs(expr, condition=None, numsamples=S.Infinity, **kwargs):
1112     """
1113     See sample_iter
1114 
1115     Uses subs for computation. This is slow but almost always works.
1116     """
1117     if condition is not None:
1118         ps = pspace(Tuple(expr, condition))
1119     else:
1120         ps = pspace(expr)
1121 
1122     count = 0
1123     while count < numsamples:
1124         d = ps.sample()  # a dictionary that maps RVs to values
1125 
1126         if condition is not None:  # Check that these values satisfy the condition
1127             gd = condition.xreplace(d)
1128             if gd != True and gd != False:
1129                 raise ValueError("Conditions must not contain free symbols")
1130             if not gd:  # If the values don't satisfy then try again
1131                 continue
1132 
1133         yield expr.xreplace(d)
1134         count += 1
1135 
1136 
1137 def sampling_P(condition, given_condition=None, numsamples=1,
1138                evalf=True, **kwargs):
1139     """
1140     Sampling version of P
1141 
1142     See Also
1143     ========
1144 
1145     P
1146     sampling_E
1147     sampling_density
1148 
1149     """
1150 
1151     count_true = 0
1152     count_false = 0
1153 
1154     samples = sample_iter(condition, given_condition,
1155                           numsamples=numsamples, **kwargs)
1156 
1157     for sample in samples:
1158         if sample != True and sample != False:
1159             raise ValueError("Conditions must not contain free symbols")
1160 
1161         if sample:
1162             count_true += 1
1163         else:
1164             count_false += 1
1165 
1166     result = S(count_true) / numsamples
1167     if evalf:
1168         return result.evalf()
1169     else:
1170         return result
1171 
1172 
1173 def sampling_E(expr, given_condition=None, numsamples=1,
1174                evalf=True, **kwargs):
1175     """
1176     Sampling version of E
1177 
1178     See Also
1179     ========
1180 
1181     P
1182     sampling_P
1183     sampling_density
1184     """
1185 
1186     samples = sample_iter(expr, given_condition,
1187                           numsamples=numsamples, **kwargs)
1188 
1189     result = Add(*list(samples)) / numsamples
1190     if evalf:
1191         return result.evalf()
1192     else:
1193         return result
1194 
1195 def sampling_density(expr, given_condition=None, numsamples=1, **kwargs):
1196     """
1197     Sampling version of density
1198 
1199     See Also
1200     ========
1201     density
1202     sampling_P
1203     sampling_E
1204     """
1205 
1206     results = {}
1207     for result in sample_iter(expr, given_condition,
1208                               numsamples=numsamples, **kwargs):
1209         results[result] = results.get(result, 0) + 1
1210     return results
1211 
1212 
1213 def dependent(a, b):
1214     """
1215     Dependence of two random expressions
1216 
1217     Two expressions are independent if knowledge of one does not change
1218     computations on the other.
1219 
1220     Examples
1221     ========
1222 
1223     >>> from sympy.stats import Normal, dependent, given
1224     >>> from sympy import Tuple, Eq
1225 
1226     >>> X, Y = Normal('X', 0, 1), Normal('Y', 0, 1)
1227     >>> dependent(X, Y)
1228     False
1229     >>> dependent(2*X + Y, -Y)
1230     True
1231     >>> X, Y = given(Tuple(X, Y), Eq(X + Y, 3))
1232     >>> dependent(X, Y)
1233     True
1234 
1235     See Also
1236     ========
1237 
1238     independent
1239     """
1240     if pspace_independent(a, b):
1241         return False
1242 
1243     z = Symbol('z', real=True)
1244     # Dependent if density is unchanged when one is given information about
1245     # the other
1246     return (density(a, Eq(b, z)) != density(a) or
1247             density(b, Eq(a, z)) != density(b))
1248 
1249 
1250 def independent(a, b):
1251     """
1252     Independence of two random expressions
1253 
1254     Two expressions are independent if knowledge of one does not change
1255     computations on the other.
1256 
1257     Examples
1258     ========
1259 
1260     >>> from sympy.stats import Normal, independent, given
1261     >>> from sympy import Tuple, Eq
1262 
1263     >>> X, Y = Normal('X', 0, 1), Normal('Y', 0, 1)
1264     >>> independent(X, Y)
1265     True
1266     >>> independent(2*X + Y, -Y)
1267     False
1268     >>> X, Y = given(Tuple(X, Y), Eq(X + Y, 3))
1269     >>> independent(X, Y)
1270     False
1271 
1272     See Also
1273     ========
1274 
1275     dependent
1276     """
1277     return not dependent(a, b)
1278 
1279 
1280 def pspace_independent(a, b):
1281     """
1282     Tests for independence between a and b by checking if their PSpaces have
1283     overlapping symbols. This is a sufficient but not necessary condition for
1284     independence and is intended to be used internally.
1285 
1286     Notes
1287     =====
1288 
1289     pspace_independent(a, b) implies independent(a, b)
1290     independent(a, b) does not imply pspace_independent(a, b)
1291     """
1292     a_symbols = set(pspace(b).symbols)
1293     b_symbols = set(pspace(a).symbols)
1294 
1295     if len(set(random_symbols(a)).intersection(random_symbols(b))) != 0:
1296         return False
1297 
1298     if len(a_symbols.intersection(b_symbols)) == 0:
1299         return True
1300     return None
1301 
1302 
1303 def rv_subs(expr, symbols=None):
1304     """
1305     Given a random expression replace all random variables with their symbols.
1306 
1307     If symbols keyword is given restrict the swap to only the symbols listed.
1308     """
1309     if symbols is None:
1310         symbols = random_symbols(expr)
1311     if not symbols:
1312         return expr
1313     swapdict = {rv: rv.symbol for rv in symbols}
1314     return expr.xreplace(swapdict)
1315 
1316 class NamedArgsMixin(object):
1317     _argnames = ()
1318 
1319     def __getattr__(self, attr):
1320         try:
1321             return self.args[self._argnames.index(attr)]
1322         except ValueError:
1323             raise AttributeError("'%s' object has no attribute '%s'" % (
1324                 type(self).__name__, attr))
1325 
1326 def _value_check(condition, message):
1327     """
1328     Raise a ValueError with message if condition is False, else
1329     return True if all conditions were True, else False.
1330 
1331     Examples
1332     ========
1333 
1334     >>> from sympy.stats.rv import _value_check
1335     >>> from sympy.abc import a, b, c
1336     >>> from sympy import And, Dummy
1337 
1338     >>> _value_check(2 < 3, '')
1339     True
1340 
1341     Here, the condition is not False, but it doesn't evaluate to True
1342     so False is returned (but no error is raised). So checking if the
1343     return value is True or False will tell you if all conditions were
1344     evaluated.
1345 
1346     >>> _value_check(a < b, '')
1347     False
1348 
1349     In this case the condition is False so an error is raised:
1350 
1351     >>> r = Dummy(real=True)
1352     >>> _value_check(r < r - 1, 'condition is not true')
1353     Traceback (most recent call last):
1354     ...
1355     ValueError: condition is not true
1356 
1357     If no condition of many conditions must be False, they can be
1358     checked by passing them as an iterable:
1359 
1360     >>> _value_check((a < 0, b < 0, c < 0), '')
1361     False
1362 
1363     The iterable can be a generator, too:
1364 
1365     >>> _value_check((i < 0 for i in (a, b, c)), '')
1366     False
1367 
1368     The following are equivalent to the above but do not pass
1369     an iterable:
1370 
1371     >>> all(_value_check(i < 0, '') for i in (a, b, c))
1372     False
1373     >>> _value_check(And(a < 0, b < 0, c < 0), '')
1374     False
1375     """
1376     from sympy.core.compatibility import iterable
1377     from sympy.core.logic import fuzzy_and
1378     if not iterable(condition):
1379         condition = [condition]
1380     truth = fuzzy_and(condition)
1381     if truth == False:
1382         raise ValueError(message)
1383     return truth == True

</code><intended_behavior>Implement or enhance parameter checking logic to ensure that parameters passed to random variable creation functions meet the required constraints, throwing informative exceptions when invalid parameters are encountered. This would help in catching errors early and making debug processes more manageable for library users.</intended_behavior>, <file>sympy/stats/joint_rv_types.py</file>
<class>None</class>
<method>None</method>
<code>
1 from sympy import (sympify, S, pi, sqrt, exp, Lambda, Indexed, Gt, IndexedBase,
2                     besselk, gamma, Interval, Range, factorial, Mul, Integer,
3                     Add, rf, Eq, Piecewise, Symbol, imageset, Intersection)
4 from sympy.matrices import ImmutableMatrix
5 from sympy.matrices.expressions.determinant import det
6 from sympy.stats.joint_rv import (JointDistribution, JointPSpace,
7     JointDistributionHandmade, MarginalDistribution)
8 from sympy.stats.rv import _value_check, random_symbols
9 
10 # __all__ = ['MultivariateNormal',
11 # 'MultivariateLaplace',
12 # 'MultivariateT',
13 # 'NormalGamma'
14 # ]
15 
16 def multivariate_rv(cls, sym, *args):
17     args = list(map(sympify, args))
18     dist = cls(*args)
19     args = dist.args
20     dist.check(*args)
21     return JointPSpace(sym, dist).value
22 
23 def JointRV(symbol, pdf, _set=None):
24     """
25     Create a Joint Random Variable where each of its component is conitinuous,
26     given the following:
27 
28     -- a symbol
29     -- a PDF in terms of indexed symbols of the symbol given
30      as the first argument
31 
32     NOTE: As of now, the set for each component for a `JointRV` is
33     equal to the set of all integers, which can not be changed.
34 
35     Returns a RandomSymbol.
36 
37     Examples
38     ========
39 
40     >>> from sympy import symbols, exp, pi, Indexed, S
41     >>> from sympy.stats import density
42     >>> from sympy.stats.joint_rv_types import JointRV
43 
44     >>> x1, x2 = (Indexed('x', i) for i in (1, 2))
45     >>> pdf = exp(-x1**2/2 + x1 - x2**2/2 - S(1)/2)/(2*pi)
46 
47     >>> N1 = JointRV('x', pdf) #Multivariate Normal distribution
48     >>> density(N1)(1, 2)
49     exp(-2)/(2*pi)
50     """
51     #TODO: Add support for sets provided by the user
52     symbol = sympify(symbol)
53     syms = list(i for i in pdf.free_symbols if isinstance(i, Indexed)
54         and i.base == IndexedBase(symbol))
55     syms.sort(key = lambda index: index.args[1])
56     _set = S.Reals**len(syms)
57     pdf = Lambda(syms, pdf)
58     dist = JointDistributionHandmade(pdf, _set)
59     jrv = JointPSpace(symbol, dist).value
60     rvs = random_symbols(pdf)
61     if len(rvs) != 0:
62         dist = MarginalDistribution(dist, (jrv,))
63         return JointPSpace(symbol, dist).value
64     return jrv
65 
66 #-------------------------------------------------------------------------------
67 # Multivariate Normal distribution ---------------------------------------------------------
68 
69 class MultivariateNormalDistribution(JointDistribution):
70     _argnames = ['mu', 'sigma']
71 
72     is_Continuous=True
73 
74     @property
75     def set(self):
76         k = len(self.mu)
77         return S.Reals**k
78 
79     def check(self, mu, sigma):
80         _value_check(len(mu) == len(sigma.col(0)),
81             "Size of the mean vector and covariance matrix are incorrect.")
82         #check if covariance matrix is positive definite or not.
83         _value_check((i > 0 for i in sigma.eigenvals().keys()),
84             "The covariance matrix must be positive definite. ")
85 
86     def pdf(self, *args):
87         mu, sigma = self.mu, self.sigma
88         k = len(mu)
89         args = ImmutableMatrix(args)
90         x = args - mu
91         return  S(1)/sqrt((2*pi)**(k)*det(sigma))*exp(
92             -S(1)/2*x.transpose()*(sigma.inv()*\
93                 x))[0]
94 
95     def marginal_distribution(self, indices, sym):
96         sym = ImmutableMatrix([Indexed(sym, i) for i in indices])
97         _mu, _sigma = self.mu, self.sigma
98         k = len(self.mu)
99         for i in range(k):
100             if i not in indices:
101                 _mu = _mu.row_del(i)
102                 _sigma = _sigma.col_del(i)
103                 _sigma = _sigma.row_del(i)
104         return Lambda(sym, S(1)/sqrt((2*pi)**(len(_mu))*det(_sigma))*exp(
105             -S(1)/2*(_mu - sym).transpose()*(_sigma.inv()*\
106                 (_mu - sym)))[0])
107 
108 #-------------------------------------------------------------------------------
109 # Multivariate Laplace distribution ---------------------------------------------------------
110 
111 class MultivariateLaplaceDistribution(JointDistribution):
112     _argnames = ['mu', 'sigma']
113     is_Continuous=True
114 
115     @property
116     def set(self):
117         k = len(self.mu)
118         return S.Reals**k
119 
120     def check(self, mu, sigma):
121         _value_check(len(mu) == len(sigma.col(0)),
122             "Size of the mean vector and covariance matrix are incorrect.")
123         #check if covariance matrix is positive definite or not.
124         _value_check((i > 0 for i in sigma.eigenvals().keys()),
125             "The covariance matrix must be positive definite. ")
126 
127     def pdf(self, *args):
128         mu, sigma = self.mu, self.sigma
129         mu_T = mu.transpose()
130         k = S(len(mu))
131         sigma_inv = sigma.inv()
132         args = ImmutableMatrix(args)
133         args_T = args.transpose()
134         x = (mu_T*sigma_inv*mu)[0]
135         y = (args_T*sigma_inv*args)[0]
136         v = 1 - k/2
137         return S(2)/((2*pi)**(S(k)/2)*sqrt(det(sigma)))\
138         *(y/(2 + x))**(S(v)/2)*besselk(v, sqrt((2 + x)*(y)))\
139         *exp((args_T*sigma_inv*mu)[0])
140 
141 
142 #-------------------------------------------------------------------------------
143 # Multivariate StudentT distribution ---------------------------------------------------------
144 
145 class MultivariateTDistribution(JointDistribution):
146     _argnames = ['mu', 'shape_mat', 'dof']
147     is_Continuous=True
148 
149     @property
150     def set(self):
151         k = len(self.mu)
152         return S.Reals**k
153 
154     def check(self, mu, sigma, v):
155         _value_check(len(mu) == len(sigma.col(0)),
156             "Size of the location vector and shape matrix are incorrect.")
157         #check if covariance matrix is positive definite or not.
158         _value_check((i > 0 for i in sigma.eigenvals().keys()),
159             "The shape matrix must be positive definite. ")
160 
161     def pdf(self, *args):
162         mu, sigma = self.mu, self.shape_mat
163         v = S(self.dof)
164         k = S(len(mu))
165         sigma_inv = sigma.inv()
166         args = ImmutableMatrix(args)
167         x = args - mu
168         return gamma((k + v)/2)/(gamma(v/2)*(v*pi)**(k/2)*sqrt(det(sigma)))\
169         *(1 + 1/v*(x.transpose()*sigma_inv*x)[0])**((-v - k)/2)
170 
171 def MultivariateT(syms, mu, sigma, v):
172     """
173     Creates a joint random variable with multivariate T-distribution.
174 
175     Parameters
176     ==========
177 
178     syms: list/tuple/set of symbols for identifying each component
179     mu: A list/tuple/set consisting of k means,represents a k
180         dimensional location vector
181     sigma: The shape matrix for the distribution
182 
183     Returns
184     =======
185 
186     A random symbol
187     """
188     return multivariate_rv(MultivariateTDistribution, syms, mu, sigma, v)
189 
190 
191 #-------------------------------------------------------------------------------
192 # Multivariate Normal Gamma distribution ---------------------------------------------------------
193 
194 class NormalGammaDistribution(JointDistribution):
195 
196     _argnames = ['mu', 'lamda', 'alpha', 'beta']
197     is_Continuous=True
198 
199     def check(self, mu, lamda, alpha, beta):
200         _value_check(mu.is_real, "Location must be real.")
201         _value_check(lamda > 0, "Lambda must be positive")
202         _value_check(alpha > 0, "alpha must be positive")
203         _value_check(beta > 0, "beta must be positive")
204 
205     @property
206     def set(self):
207         return S.Reals*Interval(0, S.Infinity)
208 
209     def pdf(self, x, tau):
210         beta, alpha, lamda = self.beta, self.alpha, self.lamda
211         mu = self.mu
212 
213         return beta**alpha*sqrt(lamda)/(gamma(alpha)*sqrt(2*pi))*\
214         tau**(alpha - S(1)/2)*exp(-1*beta*tau)*\
215         exp(-1*(lamda*tau*(x - mu)**2)/S(2))
216 
217     def marginal_distribution(self, indices, *sym):
218         if len(indices) == 2:
219             return self.pdf(*sym)
220         if indices[0] == 0:
221             #For marginal over `x`, return non-standardized Student-T's
222             #distribution
223             x = sym[0]
224             v, mu, sigma = self.alpha - S(1)/2, self.mu, \
225                 S(self.beta)/(self.lamda * self.alpha)
226             return Lambda(sym, gamma((v + 1)/2)/(gamma(v/2)*sqrt(pi*v)*sigma)*\
227                 (1 + 1/v*((x - mu)/sigma)**2)**((-v -1)/2))
228         #For marginal over `tau`, return Gamma distribution as per construction
229         from sympy.stats.crv_types import GammaDistribution
230         return Lambda(sym, GammaDistribution(self.alpha, self.beta)(sym[0]))
231 
232 def NormalGamma(syms, mu, lamda, alpha, beta):
233     """
234     Creates a bivariate joint random variable with multivariate Normal gamma
235     distribution.
236 
237     Parameters
238     ==========
239 
240     syms: list/tuple/set of two symbols for identifying each component
241     mu: A real number, as the mean of the normal distribution
242     alpha: a positive integer
243     beta: a positive integer
244     lamda: a positive integer
245 
246     Returns
247     =======
248 
249     A random symbol
250     """
251     return multivariate_rv(NormalGammaDistribution, syms, mu, lamda, alpha, beta)
252 
253 #-------------------------------------------------------------------------------
254 # Multivariate Beta/Dirichlet distribution ---------------------------------------------------------
255 
256 class MultivariateBetaDistribution(JointDistribution):
257 
258     _argnames = ['alpha']
259     is_Continuous = True
260 
261     def check(self, alpha):
262         _value_check(len(alpha) >= 2, "At least two categories should be passed.")
263         for a_k in alpha:
264             _value_check((a_k > 0) != False, "Each concentration parameter"
265                                             " should be positive.")
266 
267     @property
268     def set(self):
269         k = len(self.alpha)
270         return Interval(0, 1)**k
271 
272     def pdf(self, *syms):
273         alpha = self.alpha
274         B = Mul.fromiter(map(gamma, alpha))/gamma(Add(*alpha))
275         return Mul.fromiter([sym**(a_k - 1) for a_k, sym in zip(alpha, syms)])/B
276 
277 def MultivariateBeta(syms, *alpha):
278     """
279     Creates a continuous random variable with Dirichlet/Multivariate Beta
280     Distribution.
281 
282     The density of the dirichlet distribution can be found at [1].
283 
284     Parameters
285     ==========
286 
287     alpha: positive real numbers signifying concentration numbers.
288 
289     Returns
290     =======
291 
292     A RandomSymbol.
293 
294     Examples
295     ========
296 
297     >>> from sympy.stats import density
298     >>> from sympy.stats.joint_rv import marginal_distribution
299     >>> from sympy.stats.joint_rv_types import MultivariateBeta
300     >>> from sympy import Symbol
301     >>> a1 = Symbol('a1', positive=True)
302     >>> a2 = Symbol('a2', positive=True)
303     >>> B = MultivariateBeta('B', [a1, a2])
304     >>> C = MultivariateBeta('C', a1, a2)
305     >>> x = Symbol('x')
306     >>> y = Symbol('y')
307     >>> density(B)(x, y)
308     x**(a1 - 1)*y**(a2 - 1)*gamma(a1 + a2)/(gamma(a1)*gamma(a2))
309     >>> marginal_distribution(C, C[0])(x)
310     x**(a1 - 1)*gamma(a1 + a2)/(a2*gamma(a1)*gamma(a2))
311 
312     References
313     ==========
314 
315     .. [1] https://en.wikipedia.org/wiki/Dirichlet_distribution
316     .. [2] http://mathworld.wolfram.com/DirichletDistribution.html
317 
318     """
319     if not isinstance(alpha[0], list):
320         alpha = (list(alpha),)
321     return multivariate_rv(MultivariateBetaDistribution, syms, alpha[0])
322 
323 Dirichlet = MultivariateBeta
324 
325 #-------------------------------------------------------------------------------
326 # Multivariate Ewens distribution ---------------------------------------------------------
327 
328 class MultivariateEwensDistribution(JointDistribution):
329 
330     _argnames = ['n', 'theta']
331     is_Discrete = True
332     is_Continuous = False
333 
334     def check(self, n, theta):
335         _value_check(isinstance(n, Integer) and (n > 0) == True,
336                         "sample size should be positive integer.")
337         _value_check(theta.is_positive, "mutation rate should be positive.")
338 
339     @property
340     def set(self):
341         prod_set = Range(0, self.n//1 + 1)
342         for i in range(2, self.n + 1):
343             prod_set *= Range(0, self.n//i + 1)
344         return prod_set
345 
346     def pdf(self, *syms):
347         n, theta = self.n, self.theta
348         term_1 = factorial(n)/rf(theta, n)
349         term_2 = Mul.fromiter([theta**syms[j]/((j+1)**syms[j]*factorial(syms[j]))
350                             for j in range(n)])
351         cond = Eq(sum([(k+1)*syms[k] for k in range(n)]), n)
352         return Piecewise((term_1 * term_2, cond), (0, True))
353 
354 def MultivariateEwens(syms, n, theta):
355     """
356     Creates a discrete random variable with Multivariate Ewens
357     Distribution.
358 
359     The density of the said distribution can be found at [1].
360 
361     Parameters
362     ==========
363 
364     n: positive integer of class Integer,
365             size of the sample or the integer whose partitions are considered
366     theta: mutation rate, must be positive real number.
367 
368     Returns
369     =======
370 
371     A RandomSymbol.
372 
373     Examples
374     ========
375 
376     >>> from sympy.stats import density
377     >>> from sympy.stats.joint_rv import marginal_distribution
378     >>> from sympy.stats.joint_rv_types import MultivariateEwens
379     >>> from sympy import Symbol
380     >>> a1 = Symbol('a1', positive=True)
381     >>> a2 = Symbol('a2', positive=True)
382     >>> ed = MultivariateEwens('E', 2, 1)
383     >>> density(ed)(a1, a2)
384     Piecewise((2**(-a2)/(factorial(a1)*factorial(a2)), Eq(a1 + 2*a2, 2)), (0, True))
385     >>> marginal_distribution(ed, ed[0])(a1)
386     Piecewise((1/factorial(a1), Eq(a1, 2)), (0, True))
387 
388     References
389     ==========
390 
391     .. [1] https://en.wikipedia.org/wiki/Ewens%27s_sampling_formula
392     .. [2] http://www.stat.rutgers.edu/home/hcrane/Papers/STS529.pdf
393 
394     """
395     return multivariate_rv(MultivariateEwensDistribution, syms, n, theta)
396 
397 #-------------------------------------------------------------------------------
398 # Multinomial distribution ---------------------------------------------------------
399 
400 class MultinomialDistribution(JointDistribution):
401 
402     _argnames = ['n', 'p']
403     is_Continuous=False
404     is_Discrete = True
405 
406     def check(self, n, p):
407         _value_check(n > 0,
408                         "number of trials must be a positve integer")
409         for p_k in p:
410             _value_check((p_k >= 0, p_k <= 1),
411                         "probability must be in range [0, 1]")
412         _value_check(Eq(sum(p), 1),
413                         "probabilities must sum to 1")
414 
415     @property
416     def set(self):
417         return Intersection(S.Naturals0, Interval(0, self.n))**len(self.p)
418 
419     def pdf(self, *x):
420         n, p = self.n, self.p
421         term_1 = factorial(n)/Mul.fromiter([factorial(x_k) for x_k in x])
422         term_2 = Mul.fromiter([p_k**x_k for p_k, x_k in zip(p, x)])
423         return Piecewise((term_1 * term_2, Eq(sum(x), n)), (0, True))
424 
425 def Multinomial(syms, n, *p):
426     """
427     Creates a discrete random variable with Multinomial Distribution.
428 
429     The density of the said distribution can be found at [1].
430 
431     Parameters
432     ==========
433     n: positive integer of class Integer,
434        number of trials
435     p: event probabilites, >= 0 and <= 1
436 
437     Returns
438     =======
439     A RandomSymbol.
440 
441     Examples
442     ========
443     >>> from sympy.stats import density
444     >>> from sympy.stats.joint_rv import marginal_distribution
445     >>> from sympy.stats.joint_rv_types import Multinomial
446     >>> from sympy import symbols
447     >>> x1, x2, x3 = symbols('x1, x2, x3', nonnegative=True, integer=True)
448     >>> p1, p2, p3 = symbols('p1, p2, p3', positive=True)
449     >>> M = Multinomial('M', 3, p1, p2, p3)
450     >>> density(M)(x1, x2, x3)
451     Piecewise((6*p1**x1*p2**x2*p3**x3/(factorial(x1)*factorial(x2)*factorial(x3)),
452     Eq(x1 + x2 + x3, 3)), (0, True))
453     >>> marginal_distribution(M, M[0])(x1).subs(x1, 1)
454     3*p1*p2**2 + 6*p1*p2*p3 + 3*p1*p3**2
455 
456     References
457     ==========
458     .. [1] https://en.wikipedia.org/wiki/Multinomial_distribution
459     .. [2] http://mathworld.wolfram.com/MultinomialDistribution.html
460     """
461     if not isinstance(p[0], list):
462         p = (list(p), )
463     return multivariate_rv(MultinomialDistribution, syms, n, p[0])
464 
465 #-------------------------------------------------------------------------------
466 # Negative Multinomial Distribution ---------------------------------------------------------
467 
468 class NegativeMultinomialDistribution(JointDistribution):
469 
470     _argnames = ['k0', 'p']
471     is_Continuous=False
472     is_Discrete = True
473 
474     def check(self, k0, p):
475         _value_check(k0 > 0,
476                         "number of failures must be a positve integer")
477         for p_k in p:
478             _value_check((p_k >= 0, p_k <= 1),
479                         "probability must be in range [0, 1].")
480         _value_check(sum(p) <= 1,
481                         "success probabilities must not be greater than 1.")
482 
483     @property
484     def set(self):
485         return Range(0, S.Infinity)**len(self.p)
486 
487     def pdf(self, *k):
488         k0, p = self.k0, self.p
489         term_1 = (gamma(k0 + sum(k))*(1 - sum(p))**k0)/gamma(k0)
490         term_2 = Mul.fromiter([pi**ki/factorial(ki) for pi, ki in zip(p, k)])
491         return term_1 * term_2
492 
493 def NegativeMultinomial(syms, k0, *p):
494     """
495     Creates a discrete random variable with Negative Multinomial Distribution.
496 
497     The density of the said distribution can be found at [1].
498 
499     Parameters
500     ==========
501     k0: positive integer of class Integer,
502         number of failures before the experiment is stopped
503     p: event probabilites, >= 0 and <= 1
504 
505     Returns
506     =======
507     A RandomSymbol.
508 
509     Examples
510     ========
511     >>> from sympy.stats import density
512     >>> from sympy.stats.joint_rv import marginal_distribution
513     >>> from sympy.stats.joint_rv_types import NegativeMultinomial
514     >>> from sympy import symbols
515     >>> x1, x2, x3 = symbols('x1, x2, x3', nonnegative=True, integer=True)
516     >>> p1, p2, p3 = symbols('p1, p2, p3', positive=True)
517     >>> N = NegativeMultinomial('M', 3, p1, p2, p3)
518     >>> N_c = NegativeMultinomial('M', 3, 0.1, 0.1, 0.1)
519     >>> density(N)(x1, x2, x3)
520     p1**x1*p2**x2*p3**x3*(-p1 - p2 - p3 + 1)**3*gamma(x1 + x2 +
521     x3 + 3)/(2*factorial(x1)*factorial(x2)*factorial(x3))
522     >>> marginal_distribution(N_c, N_c[0])(1).evalf().round(2)
523     0.25
524 
525 
526     References
527     ==========
528     .. [1] https://en.wikipedia.org/wiki/Negative_multinomial_distribution
529     .. [2] http://mathworld.wolfram.com/NegativeBinomialDistribution.html
530     """
531     if not isinstance(p[0], list):
532         p = (list(p), )
533     return multivariate_rv(NegativeMultinomialDistribution, syms, k0, p[0])

</code><intended_behavior>Where distributions involve multiple variables or parameters interdependent in complex ways, ensure validations account for these relationships accurately. This could include checking for matching dimensions between parameters or ensuring the parameters jointly fulfill specific criteria required for the model to work correctly.</intended_behavior>, <file>sympy/stats/drv_types.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2 
3 Contains
4 ========
5 Geometric
6 Poisson
7 Logarithmic
8 NegativeBinomial
9 Poisson
10 YuleSimon
11 Zeta
12 """
13 
14 
15 from __future__ import print_function, division
16 
17 from sympy import (factorial, exp, S, sympify, And, I, zeta, polylog, log, beta,
18     hyper, binomial, Piecewise, floor)
19 from sympy.stats import density
20 from sympy.stats.drv import SingleDiscreteDistribution, SingleDiscretePSpace
21 from sympy.stats.joint_rv import JointPSpace, CompoundDistribution
22 from sympy.stats.rv import _value_check, RandomSymbol
23 import random
24 
25 __all__ = ['Geometric',
26 'Logarithmic',
27 'NegativeBinomial',
28 'Poisson',
29 'YuleSimon',
30 'Zeta'
31 ]
32 
33 
34 def rv(symbol, cls, *args):
35     args = list(map(sympify, args))
36     dist = cls(*args)
37     dist.check(*args)
38     pspace = SingleDiscretePSpace(symbol, dist)
39     if any(isinstance(arg, RandomSymbol) for arg in args):
40         pspace = JointPSpace(symbol, CompoundDistribution(dist))
41     return pspace.value
42 
43 
44 #-------------------------------------------------------------------------------
45 # Geometric distribution ------------------------------------------------------------
46 
47 class GeometricDistribution(SingleDiscreteDistribution):
48     _argnames = ('p',)
49     set = S.Naturals
50 
51     @staticmethod
52     def check(p):
53         _value_check((0 < p, p <= 1), "p must be between 0 and 1")
54 
55     def pdf(self, k):
56         return (1 - self.p)**(k - 1) * self.p
57 
58     def _characteristic_function(self, t):
59         p = self.p
60         return p * exp(I*t) / (1 - (1 - p)*exp(I*t))
61 
62     def _moment_generating_function(self, t):
63         p = self.p
64         return p * exp(t) / (1 - (1 - p) * exp(t))
65 
66 def Geometric(name, p):
67     r"""
68     Create a discrete random variable with a Geometric distribution.
69 
70     The density of the Geometric distribution is given by
71 
72     .. math::
73         f(k) := p (1 - p)^{k - 1}
74 
75     Parameters
76     ==========
77 
78     p: A probability between 0 and 1
79 
80     Returns
81     =======
82 
83     A RandomSymbol.
84 
85     Examples
86     ========
87 
88     >>> from sympy.stats import Geometric, density, E, variance
89     >>> from sympy import Symbol, S
90 
91     >>> p = S.One / 5
92     >>> z = Symbol("z")
93 
94     >>> X = Geometric("x", p)
95 
96     >>> density(X)(z)
97     (4/5)**(z - 1)/5
98 
99     >>> E(X)
100     5
101 
102     >>> variance(X)
103     20
104 
105     References
106     ==========
107 
108     .. [1] https://en.wikipedia.org/wiki/Geometric_distribution
109     .. [2] http://mathworld.wolfram.com/GeometricDistribution.html
110 
111     """
112     return rv(name, GeometricDistribution, p)
113 
114 
115 #-------------------------------------------------------------------------------
116 # Logarithmic distribution ------------------------------------------------------------
117 
118 class LogarithmicDistribution(SingleDiscreteDistribution):
119     _argnames = ('p',)
120 
121     set = S.Naturals
122 
123     @staticmethod
124     def check(p):
125         _value_check((p > 0, p < 1), "p should be between 0 and 1")
126 
127     def pdf(self, k):
128         p = self.p
129         return (-1) * p**k / (k * log(1 - p))
130 
131     def _characteristic_function(self, t):
132         p = self.p
133         return log(1 - p * exp(I*t)) / log(1 - p)
134 
135     def _moment_generating_function(self, t):
136         p = self.p
137         return log(1 - p * exp(t)) / log(1 - p)
138 
139     def sample(self):
140         ### TODO
141         raise NotImplementedError("Sampling of %s is not implemented" % density(self))
142 
143 
144 def Logarithmic(name, p):
145     r"""
146     Create a discrete random variable with a Logarithmic distribution.
147 
148     The density of the Logarithmic distribution is given by
149 
150     .. math::
151         f(k) := \frac{-p^k}{k \ln{(1 - p)}}
152 
153     Parameters
154     ==========
155 
156     p: A value between 0 and 1
157 
158     Returns
159     =======
160 
161     A RandomSymbol.
162 
163     Examples
164     ========
165 
166     >>> from sympy.stats import Logarithmic, density, E, variance
167     >>> from sympy import Symbol, S
168 
169     >>> p = S.One / 5
170     >>> z = Symbol("z")
171 
172     >>> X = Logarithmic("x", p)
173 
174     >>> density(X)(z)
175     -5**(-z)/(z*log(4/5))
176 
177     >>> E(X)
178     -1/(-4*log(5) + 8*log(2))
179 
180     >>> variance(X)
181     -1/((-4*log(5) + 8*log(2))*(-2*log(5) + 4*log(2))) + 1/(-64*log(2)*log(5) + 64*log(2)**2 + 16*log(5)**2) - 10/(-32*log(5) + 64*log(2))
182 
183     References
184     ==========
185 
186     .. [1] https://en.wikipedia.org/wiki/Logarithmic_distribution
187     .. [2] http://mathworld.wolfram.com/LogarithmicDistribution.html
188 
189     """
190     return rv(name, LogarithmicDistribution, p)
191 
192 
193 #-------------------------------------------------------------------------------
194 # Negative binomial distribution ------------------------------------------------------------
195 
196 class NegativeBinomialDistribution(SingleDiscreteDistribution):
197     _argnames = ('r', 'p')
198     set = S.Naturals0
199 
200     @staticmethod
201     def check(r, p):
202         _value_check(r > 0, 'r should be positive')
203         _value_check((p > 0, p < 1), 'p should be between 0 and 1')
204 
205     def pdf(self, k):
206         r = self.r
207         p = self.p
208 
209         return binomial(k + r - 1, k) * (1 - p)**r * p**k
210 
211     def _characteristic_function(self, t):
212         r = self.r
213         p = self.p
214 
215         return ((1 - p) / (1 - p * exp(I*t)))**r
216 
217     def _moment_generating_function(self, t):
218         r = self.r
219         p = self.p
220 
221         return ((1 - p) / (1 - p * exp(t)))**r
222 
223     def sample(self):
224         ### TODO
225         raise NotImplementedError("Sampling of %s is not implemented" % density(self))
226 
227 
228 def NegativeBinomial(name, r, p):
229     r"""
230     Create a discrete random variable with a Negative Binomial distribution.
231 
232     The density of the Negative Binomial distribution is given by
233 
234     .. math::
235         f(k) := \binom{k + r - 1}{k} (1 - p)^r p^k
236 
237     Parameters
238     ==========
239 
240     r: A positive value
241     p: A value between 0 and 1
242 
243     Returns
244     =======
245 
246     A RandomSymbol.
247 
248     Examples
249     ========
250 
251     >>> from sympy.stats import NegativeBinomial, density, E, variance
252     >>> from sympy import Symbol, S
253 
254     >>> r = 5
255     >>> p = S.One / 5
256     >>> z = Symbol("z")
257 
258     >>> X = NegativeBinomial("x", r, p)
259 
260     >>> density(X)(z)
261     1024*5**(-z)*binomial(z + 4, z)/3125
262 
263     >>> E(X)
264     5/4
265 
266     >>> variance(X)
267     25/16
268 
269     References
270     ==========
271 
272     .. [1] https://en.wikipedia.org/wiki/Negative_binomial_distribution
273     .. [2] http://mathworld.wolfram.com/NegativeBinomialDistribution.html
274 
275     """
276     return rv(name, NegativeBinomialDistribution, r, p)
277 
278 
279 #-------------------------------------------------------------------------------
280 # Poisson distribution ------------------------------------------------------------
281 
282 class PoissonDistribution(SingleDiscreteDistribution):
283     _argnames = ('lamda',)
284 
285     set = S.Naturals0
286 
287     @staticmethod
288     def check(lamda):
289         _value_check(lamda > 0, "Lambda must be positive")
290 
291     def pdf(self, k):
292         return self.lamda**k / factorial(k) * exp(-self.lamda)
293 
294     def sample(self):
295         def search(x, y, u):
296             while x < y:
297                 mid = (x + y)//2
298                 if u <= self.cdf(mid):
299                     y = mid
300                 else:
301                     x = mid + 1
302             return x
303 
304         u = random.uniform(0, 1)
305         if u <= self.cdf(S.Zero):
306             return S.Zero
307         n = S.One
308         while True:
309             if u > self.cdf(2*n):
310                 n *= 2
311             else:
312                 return search(n, 2*n, u)
313 
314     def _characteristic_function(self, t):
315         return exp(self.lamda * (exp(I*t) - 1))
316 
317     def _moment_generating_function(self, t):
318         return exp(self.lamda * (exp(t) - 1))
319 
320 
321 def Poisson(name, lamda):
322     r"""
323     Create a discrete random variable with a Poisson distribution.
324 
325     The density of the Poisson distribution is given by
326 
327     .. math::
328         f(k) := \frac{\lambda^{k} e^{- \lambda}}{k!}
329 
330     Parameters
331     ==========
332 
333     lamda: Positive number, a rate
334 
335     Returns
336     =======
337 
338     A RandomSymbol.
339 
340     Examples
341     ========
342 
343     >>> from sympy.stats import Poisson, density, E, variance
344     >>> from sympy import Symbol, simplify
345 
346     >>> rate = Symbol("lambda", positive=True)
347     >>> z = Symbol("z")
348 
349     >>> X = Poisson("x", rate)
350 
351     >>> density(X)(z)
352     lambda**z*exp(-lambda)/factorial(z)
353 
354     >>> E(X)
355     lambda
356 
357     >>> simplify(variance(X))
358     lambda
359 
360     References
361     ==========
362 
363     .. [1] https://en.wikipedia.org/wiki/Poisson_distribution
364     .. [2] http://mathworld.wolfram.com/PoissonDistribution.html
365 
366     """
367     return rv(name, PoissonDistribution, lamda)
368 
369 
370 #-------------------------------------------------------------------------------
371 # Yule-Simon distribution ------------------------------------------------------------
372 
373 class YuleSimonDistribution(SingleDiscreteDistribution):
374     _argnames = ('rho',)
375     set = S.Naturals
376 
377     @staticmethod
378     def check(rho):
379         _value_check(rho > 0, 'rho should be positive')
380 
381     def pdf(self, k):
382         rho = self.rho
383         return rho * beta(k, rho + 1)
384 
385     def _cdf(self, x):
386         return Piecewise((1 - floor(x) * beta(floor(x), self.rho + 1), x >= 1), (0, True))
387 
388     def _characteristic_function(self, t):
389         rho = self.rho
390         return rho * hyper((1, 1), (rho + 2,), exp(I*t)) * exp(I*t) / (rho + 1)
391 
392     def _moment_generating_function(self, t):
393         rho = self.rho
394         return rho * hyper((1, 1), (rho + 2,), exp(t)) * exp(t) / (rho + 1)
395 
396     def sample(self):
397         ### TODO
398         raise NotImplementedError("Sampling of %s is not implemented" % density(self))
399 
400 
401 def YuleSimon(name, rho):
402     r"""
403     Create a discrete random variable with a Yule-Simon distribution.
404 
405     The density of the Yule-Simon distribution is given by
406 
407     .. math::
408         f(k) := \rho B(k, \rho + 1)
409 
410     Parameters
411     ==========
412 
413     rho: A positive value
414 
415     Returns
416     =======
417 
418     A RandomSymbol.
419 
420     Examples
421     ========
422 
423     >>> from sympy.stats import YuleSimon, density, E, variance
424     >>> from sympy import Symbol, simplify
425 
426     >>> p = 5
427     >>> z = Symbol("z")
428 
429     >>> X = YuleSimon("x", p)
430 
431     >>> density(X)(z)
432     5*beta(z, 6)
433 
434     >>> simplify(E(X))
435     5/4
436 
437     >>> simplify(variance(X))
438     25/48
439 
440     References
441     ==========
442 
443     .. [1] https://en.wikipedia.org/wiki/Yule%E2%80%93Simon_distribution
444 
445     """
446     return rv(name, YuleSimonDistribution, rho)
447 
448 
449 #-------------------------------------------------------------------------------
450 # Zeta distribution ------------------------------------------------------------
451 
452 class ZetaDistribution(SingleDiscreteDistribution):
453     _argnames = ('s',)
454     set = S.Naturals
455 
456     @staticmethod
457     def check(s):
458         _value_check(s > 1, 's should be greater than 1')
459 
460     def pdf(self, k):
461         s = self.s
462         return 1 / (k**s * zeta(s))
463 
464     def _characteristic_function(self, t):
465         return polylog(self.s, exp(I*t)) / zeta(self.s)
466 
467     def _moment_generating_function(self, t):
468         return polylog(self.s, exp(t)) / zeta(self.s)
469 
470     def sample(self):
471         ### TODO
472         raise NotImplementedError("Sampling of %s is not implemented" % density(self))
473 
474 
475 def Zeta(name, s):
476     r"""
477     Create a discrete random variable with a Zeta distribution.
478 
479     The density of the Zeta distribution is given by
480 
481     .. math::
482         f(k) := \frac{1}{k^s \zeta{(s)}}
483 
484     Parameters
485     ==========
486 
487     s: A value greater than 1
488 
489     Returns
490     =======
491 
492     A RandomSymbol.
493 
494     Examples
495     ========
496 
497     >>> from sympy.stats import Zeta, density, E, variance
498     >>> from sympy import Symbol
499 
500     >>> s = 5
501     >>> z = Symbol("z")
502 
503     >>> X = Zeta("x", s)
504 
505     >>> density(X)(z)
506     1/(z**5*zeta(5))
507 
508     >>> E(X)
509     pi**4/(90*zeta(5))
510 
511     >>> variance(X)
512     -pi**8/(8100*zeta(5)**2) + zeta(3)/zeta(5)
513 
514     References
515     ==========
516 
517     .. [1] https://en.wikipedia.org/wiki/Zeta_distribution
518 
519     """
520     return rv(name, ZetaDistribution, s)

</code><intended_behavior>For discrete distributions, include checks for the discreteness of parameters where applicable, such as ensuring rate parameters are positive numbers. Additionally, attributes that determine the distribution's behavior, like mean or variance, should be accurately calculated and stored upon validation of parameters.</intended_behavior>]
2025-10-16 02:52:54.825 | INFO     | Search completed. Bug locations: [<file>sympy/stats/crv_types.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2 Continuous Random Variables - Prebuilt variables
3 
4 Contains
5 ========
6 Arcsin
7 Benini
8 Beta
9 BetaNoncentral
10 BetaPrime
11 Cauchy
12 Chi
13 ChiNoncentral
14 ChiSquared
15 Dagum
16 Erlang
17 Exponential
18 FDistribution
19 FisherZ
20 Frechet
21 Gamma
22 GammaInverse
23 Gumbel
24 Gompertz
25 Kumaraswamy
26 Laplace
27 Logistic
28 LogNormal
29 Maxwell
30 Nakagami
31 Normal
32 Pareto
33 QuadraticU
34 RaisedCosine
35 Rayleigh
36 ShiftedGompertz
37 StudentT
38 Trapezoidal
39 Triangular
40 Uniform
41 UniformSum
42 VonMises
43 Weibull
44 WignerSemicircle
45 """
46 
47 from __future__ import print_function, division
48 
49 from sympy import (log, sqrt, pi, S, Dummy, Interval, sympify, gamma,
50                    Piecewise, And, Eq, binomial, factorial, Sum, floor, Abs,
51                    Lambda, Basic, lowergamma, erf, erfi,  erfinv, I, hyper,
52                    uppergamma, sinh, atan, Ne, expint)
53 
54 from sympy import beta as beta_fn
55 from sympy import cos, sin, tan, atan, exp, besseli, besselj, besselk
56 from sympy.external import import_module
57 from sympy.matrices import MatrixBase
58 from sympy.stats.crv import (SingleContinuousPSpace, SingleContinuousDistribution,
59         ContinuousDistributionHandmade)
60 from sympy.stats.joint_rv import JointPSpace, CompoundDistribution
61 from sympy.stats.joint_rv_types import multivariate_rv
62 from sympy.stats.rv import _value_check, RandomSymbol
63 import random
64 
65 oo = S.Infinity
66 
67 __all__ = ['ContinuousRV',
68 'Arcsin',
69 'Benini',
70 'Beta',
71 'BetaNoncentral',
72 'BetaPrime',
73 'Cauchy',
74 'Chi',
75 'ChiNoncentral',
76 'ChiSquared',
77 'Dagum',
78 'Erlang',
79 'Exponential',
80 'FDistribution',
81 'FisherZ',
82 'Frechet',
83 'Gamma',
84 'GammaInverse',
85 'Gompertz',
86 'Gumbel',
87 'Kumaraswamy',
88 'Laplace',
89 'Logistic',
90 'LogNormal',
91 'Maxwell',
92 'Nakagami',
93 'Normal',
94 'Pareto',
95 'QuadraticU',
96 'RaisedCosine',
97 'Rayleigh',
98 'StudentT',
99 'ShiftedGompertz',
100 'Trapezoidal',
101 'Triangular',
102 'Uniform',
103 'UniformSum',
104 'VonMises',
105 'Weibull',
106 'WignerSemicircle'
107 ]
108 
109 
110 
111 def ContinuousRV(symbol, density, set=Interval(-oo, oo)):
112     """
113     Create a Continuous Random Variable given the following:
114 
115     -- a symbol
116     -- a probability density function
117     -- set on which the pdf is valid (defaults to entire real line)
118 
119     Returns a RandomSymbol.
120 
121     Many common continuous random variable types are already implemented.
122     This function should be necessary only very rarely.
123 
124     Examples
125     ========
126 
127     >>> from sympy import Symbol, sqrt, exp, pi
128     >>> from sympy.stats import ContinuousRV, P, E
129 
130     >>> x = Symbol("x")
131 
132     >>> pdf = sqrt(2)*exp(-x**2/2)/(2*sqrt(pi)) # Normal distribution
133     >>> X = ContinuousRV(x, pdf)
134 
135     >>> E(X)
136     0
137     >>> P(X>0)
138     1/2
139     """
140     pdf = Piecewise((density, set.as_relational(symbol)), (0, True))
141     pdf = Lambda(symbol, pdf)
142     dist = ContinuousDistributionHandmade(pdf, set)
143     return SingleContinuousPSpace(symbol, dist).value
144 
145 
146 def rv(symbol, cls, args):
147     args = list(map(sympify, args))
148     dist = cls(*args)
149     dist.check(*args)
150     pspace = SingleContinuousPSpace(symbol, dist)
151     if any(isinstance(arg, RandomSymbol) for arg in args):
152         pspace = JointPSpace(symbol, CompoundDistribution(dist))
153     return pspace.value
154 
155 ########################################
156 # Continuous Probability Distributions #
157 ########################################
158 
159 #-------------------------------------------------------------------------------
160 # Arcsin distribution ----------------------------------------------------------
161 
162 
163 class ArcsinDistribution(SingleContinuousDistribution):
164     _argnames = ('a', 'b')
165 
166     def pdf(self, x):
167         return 1/(pi*sqrt((x - self.a)*(self.b - x)))
168 
169     def _cdf(self, x):
170         from sympy import asin
171         a, b = self.a, self.b
172         return Piecewise(
173             (S.Zero, x < a),
174             (2*asin(sqrt((x - a)/(b - a)))/pi, x <= b),
175             (S.One, True))
176 
177 
178 def Arcsin(name, a=0, b=1):
179     r"""
180     Create a Continuous Random Variable with an arcsin distribution.
181 
182     The density of the arcsin distribution is given by
183 
184     .. math::
185         f(x) := \frac{1}{\pi\sqrt{(x-a)(b-x)}}
186 
187     with :math:`x \in (a,b)`. It must hold that :math:`-\infty < a < b < \infty`.
188 
189     Parameters
190     ==========
191 
192     a : Real number, the left interval boundary
193     b : Real number, the right interval boundary
194 
195     Returns
196     =======
197 
198     A RandomSymbol.
199 
200     Examples
201     ========
202 
203     >>> from sympy.stats import Arcsin, density, cdf
204     >>> from sympy import Symbol, simplify
205 
206     >>> a = Symbol("a", real=True)
207     >>> b = Symbol("b", real=True)
208     >>> z = Symbol("z")
209 
210     >>> X = Arcsin("x", a, b)
211 
212     >>> density(X)(z)
213     1/(pi*sqrt((-a + z)*(b - z)))
214 
215     >>> cdf(X)(z)
216     Piecewise((0, a > z),
217             (2*asin(sqrt((-a + z)/(-a + b)))/pi, b >= z),
218             (1, True))
219 
220 
221     References
222     ==========
223 
224     .. [1] https://en.wikipedia.org/wiki/Arcsine_distribution
225 
226     """
227 
228     return rv(name, ArcsinDistribution, (a, b))
229 
230 #-------------------------------------------------------------------------------
231 # Benini distribution ----------------------------------------------------------
232 
233 
234 class BeniniDistribution(SingleContinuousDistribution):
235     _argnames = ('alpha', 'beta', 'sigma')
236 
237     @staticmethod
238     def check(alpha, beta, sigma):
239         _value_check(alpha > 0, "Shape parameter Alpha must be positive.")
240         _value_check(beta > 0, "Shape parameter Beta must be positive.")
241         _value_check(sigma > 0, "Scale parameter Sigma must be positive.")
242 
243     @property
244     def set(self):
245         return Interval(self.sigma, oo)
246 
247     def pdf(self, x):
248         alpha, beta, sigma = self.alpha, self.beta, self.sigma
249         return (exp(-alpha*log(x/sigma) - beta*log(x/sigma)**2)
250                *(alpha/x + 2*beta*log(x/sigma)/x))
251 
252     def _moment_generating_function(self, t):
253         raise NotImplementedError('The moment generating function of the '
254                                   'Benini distribution does not exist.')
255 
256 def Benini(name, alpha, beta, sigma):
257     r"""
258     Create a Continuous Random Variable with a Benini distribution.
259 
260     The density of the Benini distribution is given by
261 
262     .. math::
263         f(x) := e^{-\alpha\log{\frac{x}{\sigma}}
264                 -\beta\log^2\left[{\frac{x}{\sigma}}\right]}
265                 \left(\frac{\alpha}{x}+\frac{2\beta\log{\frac{x}{\sigma}}}{x}\right)
266 
267     This is a heavy-tailed distrubtion and is also known as the log-Rayleigh
268     distribution.
269 
270     Parameters
271     ==========
272 
273     alpha : Real number, `\alpha > 0`, a shape
274     beta : Real number, `\beta > 0`, a shape
275     sigma : Real number, `\sigma > 0`, a scale
276 
277     Returns
278     =======
279 
280     A RandomSymbol.
281 
282     Examples
283     ========
284 
285     >>> from sympy.stats import Benini, density, cdf
286     >>> from sympy import Symbol, simplify, pprint
287 
288     >>> alpha = Symbol("alpha", positive=True)
289     >>> beta = Symbol("beta", positive=True)
290     >>> sigma = Symbol("sigma", positive=True)
291     >>> z = Symbol("z")
292 
293     >>> X = Benini("x", alpha, beta, sigma)
294 
295     >>> D = density(X)(z)
296     >>> pprint(D, use_unicode=False)
297     /                  /  z  \\             /  z  \            2/  z  \
298     |        2*beta*log|-----||  - alpha*log|-----| - beta*log  |-----|
299     |alpha             \sigma/|             \sigma/             \sigma/
300     |----- + -----------------|*e
301     \  z             z        /
302 
303     >>> cdf(X)(z)
304     Piecewise((1 - exp(-alpha*log(z/sigma) - beta*log(z/sigma)**2), sigma <= z),
305             (0, True))
306 
307 
308     References
309     ==========
310 
311     .. [1] https://en.wikipedia.org/wiki/Benini_distribution
312     .. [2] http://reference.wolfram.com/legacy/v8/ref/BeniniDistribution.html
313 
314     """
315 
316     return rv(name, BeniniDistribution, (alpha, beta, sigma))
317 
318 #-------------------------------------------------------------------------------
319 # Beta distribution ------------------------------------------------------------
320 
321 
322 class BetaDistribution(SingleContinuousDistribution):
323     _argnames = ('alpha', 'beta')
324 
325     set = Interval(0, 1)
326 
327     @staticmethod
328     def check(alpha, beta):
329         _value_check(alpha > 0, "Shape parameter Alpha must be positive.")
330         _value_check(beta > 0, "Shape parameter Beta must be positive.")
331 
332     def pdf(self, x):
333         alpha, beta = self.alpha, self.beta
334         return x**(alpha - 1) * (1 - x)**(beta - 1) / beta_fn(alpha, beta)
335 
336     def sample(self):
337         return random.betavariate(self.alpha, self.beta)
338 
339     def _characteristic_function(self, t):
340         return hyper((self.alpha,), (self.alpha + self.beta,), I*t)
341 
342     def _moment_generating_function(self, t):
343         return hyper((self.alpha,), (self.alpha + self.beta,), t)
344 
345 def Beta(name, alpha, beta):
346     r"""
347     Create a Continuous Random Variable with a Beta distribution.
348 
349     The density of the Beta distribution is given by
350 
351     .. math::
352         f(x) := \frac{x^{\alpha-1}(1-x)^{\beta-1}} {\mathrm{B}(\alpha,\beta)}
353 
354     with :math:`x \in [0,1]`.
355 
356     Parameters
357     ==========
358 
359     alpha : Real number, `\alpha > 0`, a shape
360     beta : Real number, `\beta > 0`, a shape
361 
362     Returns
363     =======
364 
365     A RandomSymbol.
366 
367     Examples
368     ========
369 
370     >>> from sympy.stats import Beta, density, E, variance
371     >>> from sympy import Symbol, simplify, pprint, factor
372 
373     >>> alpha = Symbol("alpha", positive=True)
374     >>> beta = Symbol("beta", positive=True)
375     >>> z = Symbol("z")
376 
377     >>> X = Beta("x", alpha, beta)
378 
379     >>> D = density(X)(z)
380     >>> pprint(D, use_unicode=False)
381      alpha - 1        beta - 1
382     z         *(1 - z)
383     --------------------------
384           B(alpha, beta)
385 
386     >>> simplify(E(X))
387     alpha/(alpha + beta)
388 
389     >>> factor(simplify(variance(X)))  #doctest: +SKIP
390     alpha*beta/((alpha + beta)**2*(alpha + beta + 1))
391 
392     References
393     ==========
394 
395     .. [1] https://en.wikipedia.org/wiki/Beta_distribution
396     .. [2] http://mathworld.wolfram.com/BetaDistribution.html
397 
398     """
399 
400     return rv(name, BetaDistribution, (alpha, beta))
401 
402 #-------------------------------------------------------------------------------
403 # Noncentral Beta distribution ------------------------------------------------------------
404 
405 
406 class BetaNoncentralDistribution(SingleContinuousDistribution):
407     _argnames = ('alpha', 'beta', 'lamda')
408 
409     set = Interval(0, 1)
410 
411     @staticmethod
412     def check(alpha, beta, lamda):
413         _value_check(alpha > 0, "Shape parameter Alpha must be positive.")
414         _value_check(beta > 0, "Shape parameter Beta must be positive.")
415         _value_check(lamda >= 0, "Noncentrality parameter Lambda must be positive")
416 
417     def pdf(self, x):
418         alpha, beta, lamda = self.alpha, self.beta, self.lamda
419         k = Dummy("k")
420         return Sum(exp(-lamda / 2) * (lamda / 2)**k * x**(alpha + k - 1) *(
421             1 - x)**(beta - 1) / (factorial(k) * beta_fn(alpha + k, beta)), (k, 0, oo))
422 
423 def BetaNoncentral(name, alpha, beta, lamda):
424     r"""
425     Create a Continuous Random Variable with a Type I Noncentral Beta distribution.
426 
427     The density of the Noncentral Beta distribution is given by
428 
429     .. math::
430         f(x) := \sum_{k=0}^\infty e^{-\lambda/2}\frac{(\lambda/2)^k}{k!}
431                 \frac{x^{\alpha+k-1}(1-x)^{\beta-1}}{\mathrm{B}(\alpha+k,\beta)}
432 
433     with :math:`x \in [0,1]`.
434 
435     Parameters
436     ==========
437 
438     alpha : Real number, `\alpha > 0`, a shape
439     beta : Real number, `\beta > 0`, a shape
440     lamda: Real number, `\lambda >= 0`, noncentrality parameter
441 
442     Returns
443     =======
444 
445     A RandomSymbol.
446 
447     Examples
448     ========
449 
450     >>> from sympy.stats import BetaNoncentral, density, cdf
451     >>> from sympy import Symbol, pprint
452 
453     >>> alpha = Symbol("alpha", positive=True)
454     >>> beta = Symbol("beta", positive=True)
455     >>> lamda = Symbol("lamda", nonnegative=True)
456     >>> z = Symbol("z")
457 
458     >>> X = BetaNoncentral("x", alpha, beta, lamda)
459 
460     >>> D = density(X)(z)
461     >>> pprint(D, use_unicode=False)
462       oo
463     _____
464     \    `
465      \                                              -lamda
466       \                          k                  -------
467        \    k + alpha - 1 /lamda\         beta - 1     2
468         )  z             *|-----| *(1 - z)        *e
469        /                  \  2  /
470       /    ------------------------------------------------
471      /                  B(k + alpha, beta)*k!
472     /____,
473     k = 0
474 
475     Compute cdf with specific 'x', 'alpha', 'beta' and 'lamda' values as follows :
476     >>> cdf(BetaNoncentral("x", 1, 1, 1), evaluate=False)(2).doit()
477     exp(-1/2)*Integral(Sum(2**(-_k)*_x**_k/(beta(_k + 1, 1)*factorial(_k)), (_k, 0, oo)), (_x, 0, 2))
478 
479     The argument evaluate=False prevents an attempt at evaluation
480     of the sum for general x, before the argument 2 is passed.
481 
482     References
483     ==========
484 
485     .. [1] https://en.wikipedia.org/wiki/Noncentral_beta_distribution
486     .. [2] https://reference.wolfram.com/language/ref/NoncentralBetaDistribution.html
487 
488     """
489 
490     return rv(name, BetaNoncentralDistribution, (alpha, beta, lamda))
491 
492 
493 #-------------------------------------------------------------------------------
494 # Beta prime distribution ------------------------------------------------------
495 
496 
497 class BetaPrimeDistribution(SingleContinuousDistribution):
498     _argnames = ('alpha', 'beta')
499 
500     @staticmethod
501     def check(alpha, beta):
502         _value_check(alpha > 0, "Shape parameter Alpha must be positive.")
503         _value_check(beta > 0, "Shape parameter Beta must be positive.")
504 
505     set = Interval(0, oo)
506 
507     def pdf(self, x):
508         alpha, beta = self.alpha, self.beta
509         return x**(alpha - 1)*(1 + x)**(-alpha - beta)/beta_fn(alpha, beta)
510 
511 def BetaPrime(name, alpha, beta):
512     r"""
513     Create a continuous random variable with a Beta prime distribution.
514 
515     The density of the Beta prime distribution is given by
516 
517     .. math::
518         f(x) := \frac{x^{\alpha-1} (1+x)^{-\alpha -\beta}}{B(\alpha,\beta)}
519 
520     with :math:`x > 0`.
521 
522     Parameters
523     ==========
524 
525     alpha : Real number, `\alpha > 0`, a shape
526     beta : Real number, `\beta > 0`, a shape
527 
528     Returns
529     =======
530 
531     A RandomSymbol.
532 
533     Examples
534     ========
535 
536     >>> from sympy.stats import BetaPrime, density
537     >>> from sympy import Symbol, pprint
538 
539     >>> alpha = Symbol("alpha", positive=True)
540     >>> beta = Symbol("beta", positive=True)
541     >>> z = Symbol("z")
542 
543     >>> X = BetaPrime("x", alpha, beta)
544 
545     >>> D = density(X)(z)
546     >>> pprint(D, use_unicode=False)
547      alpha - 1        -alpha - beta
548     z         *(z + 1)
549     -------------------------------
550              B(alpha, beta)
551 
552     References
553     ==========
554 
555     .. [1] https://en.wikipedia.org/wiki/Beta_prime_distribution
556     .. [2] http://mathworld.wolfram.com/BetaPrimeDistribution.html
557 
558     """
559 
560     return rv(name, BetaPrimeDistribution, (alpha, beta))
561 
562 #-------------------------------------------------------------------------------
563 # Cauchy distribution ----------------------------------------------------------
564 
565 
566 class CauchyDistribution(SingleContinuousDistribution):
567     _argnames = ('x0', 'gamma')
568 
569     @staticmethod
570     def check(x0, gamma):
571         _value_check(gamma > 0, "Scale parameter Gamma must be positive.")
572 
573     def pdf(self, x):
574         return 1/(pi*self.gamma*(1 + ((x - self.x0)/self.gamma)**2))
575 
576     def _cdf(self, x):
577         x0, gamma = self.x0, self.gamma
578         return (1/pi)*atan((x - x0)/gamma) + S.Half
579 
580     def _characteristic_function(self, t):
581         return exp(self.x0 * I * t -  self.gamma * Abs(t))
582 
583     def _moment_generating_function(self, t):
584         raise NotImplementedError("The moment generating function for the "
585                                   "Cauchy distribution does not exist.")
586 
587     def _quantile(self, p):
588         return self.x0 + self.gamma*tan(pi*(p - S.Half))
589 
590 def Cauchy(name, x0, gamma):
591     r"""
592     Create a continuous random variable with a Cauchy distribution.
593 
594     The density of the Cauchy distribution is given by
595 
596     .. math::
597         f(x) := \frac{1}{\pi \gamma [1 + {(\frac{x-x_0}{\gamma})}^2]}
598 
599     Parameters
600     ==========
601 
602     x0 : Real number, the location
603     gamma : Real number, `\gamma > 0`, a scale
604 
605     Returns
606     =======
607 
608     A RandomSymbol.
609 
610     Examples
611     ========
612 
613     >>> from sympy.stats import Cauchy, density
614     >>> from sympy import Symbol
615 
616     >>> x0 = Symbol("x0")
617     >>> gamma = Symbol("gamma", positive=True)
618     >>> z = Symbol("z")
619 
620     >>> X = Cauchy("x", x0, gamma)
621 
622     >>> density(X)(z)
623     1/(pi*gamma*(1 + (-x0 + z)**2/gamma**2))
624 
625     References
626     ==========
627 
628     .. [1] https://en.wikipedia.org/wiki/Cauchy_distribution
629     .. [2] http://mathworld.wolfram.com/CauchyDistribution.html
630 
631     """
632 
633     return rv(name, CauchyDistribution, (x0, gamma))
634 
635 #-------------------------------------------------------------------------------
636 # Chi distribution -------------------------------------------------------------
637 
638 
639 class ChiDistribution(SingleContinuousDistribution):
640     _argnames = ('k',)
641 
642     @staticmethod
643     def check(k):
644         _value_check(k > 0, "Number of degrees of freedom (k) must be positive.")
645         _value_check(k.is_integer, "Number of degrees of freedom (k) must be an integer.")
646 
647     set = Interval(0, oo)
648 
649     def pdf(self, x):
650         return 2**(1 - self.k/2)*x**(self.k - 1)*exp(-x**2/2)/gamma(self.k/2)
651 
652     def _characteristic_function(self, t):
653         k = self.k
654 
655         part_1 = hyper((k/2,), (S(1)/2,), -t**2/2)
656         part_2 = I*t*sqrt(2)*gamma((k+1)/2)/gamma(k/2)
657         part_3 = hyper(((k+1)/2,), (S(3)/2,), -t**2/2)
658         return part_1 + part_2*part_3
659 
660     def _moment_generating_function(self, t):
661         k = self.k
662 
663         part_1 = hyper((k / 2,), (S(1) / 2,), t ** 2 / 2)
664         part_2 = t * sqrt(2) * gamma((k + 1) / 2) / gamma(k / 2)
665         part_3 = hyper(((k + 1) / 2,), (S(3) / 2,), t ** 2 / 2)
666         return part_1 + part_2 * part_3
667 
668 def Chi(name, k):
669     r"""
670     Create a continuous random variable with a Chi distribution.
671 
672     The density of the Chi distribution is given by
673 
674     .. math::
675         f(x) := \frac{2^{1-k/2}x^{k-1}e^{-x^2/2}}{\Gamma(k/2)}
676 
677     with :math:`x \geq 0`.
678 
679     Parameters
680     ==========
681 
682     k : Positive integer, The number of degrees of freedom
683 
684     Returns
685     =======
686 
687     A RandomSymbol.
688 
689     Examples
690     ========
691 
692     >>> from sympy.stats import Chi, density, E
693     >>> from sympy import Symbol, simplify
694 
695     >>> k = Symbol("k", integer=True)
696     >>> z = Symbol("z")
697 
698     >>> X = Chi("x", k)
699 
700     >>> density(X)(z)
701     2**(1 - k/2)*z**(k - 1)*exp(-z**2/2)/gamma(k/2)
702 
703     >>> simplify(E(X))
704     sqrt(2)*gamma(k/2 + 1/2)/gamma(k/2)
705 
706     References
707     ==========
708 
709     .. [1] https://en.wikipedia.org/wiki/Chi_distribution
710     .. [2] http://mathworld.wolfram.com/ChiDistribution.html
711 
712     """
713 
714     return rv(name, ChiDistribution, (k,))
715 
716 #-------------------------------------------------------------------------------
717 # Non-central Chi distribution -------------------------------------------------
718 
719 
720 class ChiNoncentralDistribution(SingleContinuousDistribution):
721     _argnames = ('k', 'l')
722 
723     @staticmethod
724     def check(k, l):
725         _value_check(k > 0, "Number of degrees of freedom (k) must be positive.")
726         _value_check(k.is_integer, "Number of degrees of freedom (k) must be an integer.")
727         _value_check(l > 0, "Shift parameter Lambda must be positive.")
728 
729     set = Interval(0, oo)
730 
731     def pdf(self, x):
732         k, l = self.k, self.l
733         return exp(-(x**2+l**2)/2)*x**k*l / (l*x)**(k/2) * besseli(k/2-1, l*x)
734 
735 def ChiNoncentral(name, k, l):
736     r"""
737     Create a continuous random variable with a non-central Chi distribution.
738 
739     The density of the non-central Chi distribution is given by
740 
741     .. math::
742         f(x) := \frac{e^{-(x^2+\lambda^2)/2} x^k\lambda}
743                 {(\lambda x)^{k/2}} I_{k/2-1}(\lambda x)
744 
745     with `x \geq 0`. Here, `I_\nu (x)` is the
746     :ref:`modified Bessel function of the first kind <besseli>`.
747 
748     Parameters
749     ==========
750 
751     k : A positive Integer, `k > 0`, the number of degrees of freedom
752     lambda : Real number, `\lambda > 0`, Shift parameter
753 
754     Returns
755     =======
756 
757     A RandomSymbol.
758 
759     Examples
760     ========
761 
762     >>> from sympy.stats import ChiNoncentral, density
763     >>> from sympy import Symbol
764 
765     >>> k = Symbol("k", integer=True)
766     >>> l = Symbol("l")
767     >>> z = Symbol("z")
768 
769     >>> X = ChiNoncentral("x", k, l)
770 
771     >>> density(X)(z)
772     l*z**k*(l*z)**(-k/2)*exp(-l**2/2 - z**2/2)*besseli(k/2 - 1, l*z)
773 
774     References
775     ==========
776 
777     .. [1] https://en.wikipedia.org/wiki/Noncentral_chi_distribution
778     """
779 
780     return rv(name, ChiNoncentralDistribution, (k, l))
781 
782 #-------------------------------------------------------------------------------
783 # Chi squared distribution -----------------------------------------------------
784 
785 
786 class ChiSquaredDistribution(SingleContinuousDistribution):
787     _argnames = ('k',)
788 
789     @staticmethod
790     def check(k):
791         _value_check(k > 0, "Number of degrees of freedom (k) must be positive.")
792         _value_check(k.is_integer, "Number of degrees of freedom (k) must be an integer.")
793 
794     set = Interval(0, oo)
795 
796     def pdf(self, x):
797         k = self.k
798         return 1/(2**(k/2)*gamma(k/2))*x**(k/2 - 1)*exp(-x/2)
799 
800     def _cdf(self, x):
801         k = self.k
802         return Piecewise(
803                 (S.One/gamma(k/2)*lowergamma(k/2, x/2), x >= 0),
804                 (0, True)
805         )
806 
807     def _characteristic_function(self, t):
808         return (1 - 2*I*t)**(-self.k/2)
809 
810     def  _moment_generating_function(self, t):
811         return (1 - 2*t)**(-self.k/2)
812 
813 def ChiSquared(name, k):
814     r"""
815     Create a continuous random variable with a Chi-squared distribution.
816 
817     The density of the Chi-squared distribution is given by
818 
819     .. math::
820         f(x) := \frac{1}{2^{\frac{k}{2}}\Gamma\left(\frac{k}{2}\right)}
821                 x^{\frac{k}{2}-1} e^{-\frac{x}{2}}
822 
823     with :math:`x \geq 0`.
824 
825     Parameters
826     ==========
827 
828     k : Positive integer, The number of degrees of freedom
829 
830     Returns
831     =======
832 
833     A RandomSymbol.
834 
835     Examples
836     ========
837 
838     >>> from sympy.stats import ChiSquared, density, E, variance, moment
839     >>> from sympy import Symbol
840 
841     >>> k = Symbol("k", integer=True, positive=True)
842     >>> z = Symbol("z")
843 
844     >>> X = ChiSquared("x", k)
845 
846     >>> density(X)(z)
847     2**(-k/2)*z**(k/2 - 1)*exp(-z/2)/gamma(k/2)
848 
849     >>> E(X)
850     k
851 
852     >>> variance(X)
853     2*k
854 
855     >>> moment(X, 3)
856     k**3 + 6*k**2 + 8*k
857 
858     References
859     ==========
860 
861     .. [1] https://en.wikipedia.org/wiki/Chi_squared_distribution
862     .. [2] http://mathworld.wolfram.com/Chi-SquaredDistribution.html
863     """
864 
865     return rv(name, ChiSquaredDistribution, (k, ))
866 
867 #-------------------------------------------------------------------------------
868 # Dagum distribution -----------------------------------------------------------
869 
870 
871 class DagumDistribution(SingleContinuousDistribution):
872     _argnames = ('p', 'a', 'b')
873 
874     @staticmethod
875     def check(p, a, b):
876         _value_check(p > 0, "Shape parameter p must be positive.")
877         _value_check(a > 0, "Shape parameter a must be positive.")
878         _value_check(b > 0, "Scale parameter b must be positive.")
879 
880     def pdf(self, x):
881         p, a, b = self.p, self.a, self.b
882         return a*p/x*((x/b)**(a*p)/(((x/b)**a + 1)**(p + 1)))
883 
884     def _cdf(self, x):
885         p, a, b = self.p, self.a, self.b
886         return Piecewise(((S.One + (S(x)/b)**-a)**-p, x>=0),
887                     (S.Zero, True))
888 
889 def Dagum(name, p, a, b):
890     r"""
891     Create a continuous random variable with a Dagum distribution.
892 
893     The density of the Dagum distribution is given by
894 
895     .. math::
896         f(x) := \frac{a p}{x} \left( \frac{\left(\tfrac{x}{b}\right)^{a p}}
897                 {\left(\left(\tfrac{x}{b}\right)^a + 1 \right)^{p+1}} \right)
898 
899     with :math:`x > 0`.
900 
901     Parameters
902     ==========
903 
904     p : Real number, `p > 0`, a shape
905     a : Real number, `a > 0`, a shape
906     b : Real number, `b > 0`, a scale
907 
908     Returns
909     =======
910 
911     A RandomSymbol.
912 
913     Examples
914     ========
915 
916     >>> from sympy.stats import Dagum, density, cdf
917     >>> from sympy import Symbol
918 
919     >>> p = Symbol("p", positive=True)
920     >>> a = Symbol("a", positive=True)
921     >>> b = Symbol("b", positive=True)
922     >>> z = Symbol("z")
923 
924     >>> X = Dagum("x", p, a, b)
925 
926     >>> density(X)(z)
927     a*p*(z/b)**(a*p)*((z/b)**a + 1)**(-p - 1)/z
928 
929     >>> cdf(X)(z)
930     Piecewise(((1 + (z/b)**(-a))**(-p), z >= 0), (0, True))
931 
932 
933     References
934     ==========
935 
936     .. [1] https://en.wikipedia.org/wiki/Dagum_distribution
937 
938     """
939 
940     return rv(name, DagumDistribution, (p, a, b))
941 
942 #-------------------------------------------------------------------------------
943 # Erlang distribution ----------------------------------------------------------
944 
945 
946 def Erlang(name, k, l):
947     r"""
948     Create a continuous random variable with an Erlang distribution.
949 
950     The density of the Erlang distribution is given by
951 
952     .. math::
953         f(x) := \frac{\lambda^k x^{k-1} e^{-\lambda x}}{(k-1)!}
954 
955     with :math:`x \in [0,\infty]`.
956 
957     Parameters
958     ==========
959 
960     k : Positive integer
961     l : Real number, `\lambda > 0`, the rate
962 
963     Returns
964     =======
965 
966     A RandomSymbol.
967 
968     Examples
969     ========
970 
971     >>> from sympy.stats import Erlang, density, cdf, E, variance
972     >>> from sympy import Symbol, simplify, pprint
973 
974     >>> k = Symbol("k", integer=True, positive=True)
975     >>> l = Symbol("l", positive=True)
976     >>> z = Symbol("z")
977 
978     >>> X = Erlang("x", k, l)
979 
980     >>> D = density(X)(z)
981     >>> pprint(D, use_unicode=False)
982      k  k - 1  -l*z
983     l *z     *e
984     ---------------
985         Gamma(k)
986 
987     >>> C = cdf(X)(z)
988     >>> pprint(C, use_unicode=False)
989     /lowergamma(k, l*z)
990     |------------------  for z > 0
991     <     Gamma(k)
992     |
993     \        0           otherwise
994 
995 
996     >>> E(X)
997     k/l
998 
999     >>> simplify(variance(X))
1000     k/l**2
1001 
1002     References
1003     ==========
1004 
1005     .. [1] https://en.wikipedia.org/wiki/Erlang_distribution
1006     .. [2] http://mathworld.wolfram.com/ErlangDistribution.html
1007 
1008     """
1009 
1010     return rv(name, GammaDistribution, (k, S.One/l))
1011 
1012 #-------------------------------------------------------------------------------
1013 # Exponential distribution -----------------------------------------------------
1014 
1015 
1016 class ExponentialDistribution(SingleContinuousDistribution):
1017     _argnames = ('rate',)
1018 
1019     set  = Interval(0, oo)
1020 
1021     @staticmethod
1022     def check(rate):
1023         _value_check(rate > 0, "Rate must be positive.")
1024 
1025     def pdf(self, x):
1026         return self.rate * exp(-self.rate*x)
1027 
1028     def sample(self):
1029         return random.expovariate(self.rate)
1030 
1031     def _cdf(self, x):
1032         return Piecewise(
1033                 (S.One - exp(-self.rate*x), x >= 0),
1034                 (0, True),
1035         )
1036 
1037     def _characteristic_function(self, t):
1038         rate = self.rate
1039         return rate / (rate - I*t)
1040 
1041     def _moment_generating_function(self, t):
1042         rate = self.rate
1043         return rate / (rate - t)
1044 
1045     def _quantile(self, p):
1046         return -log(1-p)/self.rate
1047 
1048 def Exponential(name, rate):
1049     r"""
1050     Create a continuous random variable with an Exponential distribution.
1051 
1052     The density of the exponential distribution is given by
1053 
1054     .. math::
1055         f(x) := \lambda \exp(-\lambda x)
1056 
1057     with `x > 0`. Note that the expected value is `1/\lambda`.
1058 
1059     Parameters
1060     ==========
1061 
1062     rate : A positive Real number, `\lambda > 0`, the rate (or inverse scale/inverse mean)
1063 
1064     Returns
1065     =======
1066 
1067     A RandomSymbol.
1068 
1069     Examples
1070     ========
1071 
1072     >>> from sympy.stats import Exponential, density, cdf, E
1073     >>> from sympy.stats import variance, std, skewness, quantile
1074     >>> from sympy import Symbol, symbols
1075 
1076     >>> l = Symbol("lambda", positive=True)
1077     >>> z = Symbol("z")
1078     >>> p = Symbol("p")
1079     >>> X = Exponential("x", l)
1080 
1081     >>> density(X)(z)
1082     lambda*exp(-lambda*z)
1083 
1084     >>> cdf(X)(z)
1085     Piecewise((1 - exp(-lambda*z), z >= 0), (0, True))
1086 
1087     >>> quantile(X)(p)
1088     -log(1 - p)/lambda
1089 
1090     >>> E(X)
1091     1/lambda
1092 
1093     >>> variance(X)
1094     lambda**(-2)
1095 
1096     >>> skewness(X)
1097     2
1098 
1099     >>> X = Exponential('x', 10)
1100 
1101     >>> density(X)(z)
1102     10*exp(-10*z)
1103 
1104     >>> E(X)
1105     1/10
1106 
1107     >>> std(X)
1108     1/10
1109 
1110     References
1111     ==========
1112 
1113     .. [1] https://en.wikipedia.org/wiki/Exponential_distribution
1114     .. [2] http://mathworld.wolfram.com/ExponentialDistribution.html
1115 
1116     """
1117 
1118     return rv(name, ExponentialDistribution, (rate, ))
1119 
1120 #-------------------------------------------------------------------------------
1121 # F distribution ---------------------------------------------------------------
1122 
1123 
1124 class FDistributionDistribution(SingleContinuousDistribution):
1125     _argnames = ('d1', 'd2')
1126 
1127     set = Interval(0, oo)
1128 
1129     @staticmethod
1130     def check(d1, d2):
1131         _value_check((d1 > 0, d1.is_integer),
1132             "Degrees of freedom d1 must be positive integer.")
1133         _value_check((d2 > 0, d2.is_integer),
1134             "Degrees of freedom d2 must be positive integer.")
1135 
1136     def pdf(self, x):
1137         d1, d2 = self.d1, self.d2
1138         return (sqrt((d1*x)**d1*d2**d2 / (d1*x+d2)**(d1+d2))
1139                / (x * beta_fn(d1/2, d2/2)))
1140 
1141     def _moment_generating_function(self, t):
1142         raise NotImplementedError('The moment generating function for the '
1143                                   'F-distribution does not exist.')
1144 
1145 def FDistribution(name, d1, d2):
1146     r"""
1147     Create a continuous random variable with a F distribution.
1148 
1149     The density of the F distribution is given by
1150 
1151     .. math::
1152         f(x) := \frac{\sqrt{\frac{(d_1 x)^{d_1} d_2^{d_2}}
1153                 {(d_1 x + d_2)^{d_1 + d_2}}}}
1154                 {x \mathrm{B} \left(\frac{d_1}{2}, \frac{d_2}{2}\right)}
1155 
1156     with :math:`x > 0`.
1157 
1158     Parameters
1159     ==========
1160 
1161     d1 : `d_1 > 0`, where d_1 is the degrees of freedom (n_1 - 1)
1162     d2 : `d_2 > 0`, where d_2 is the degrees of freedom (n_2 - 1)
1163 
1164     Returns
1165     =======
1166 
1167     A RandomSymbol.
1168 
1169     Examples
1170     ========
1171 
1172     >>> from sympy.stats import FDistribution, density
1173     >>> from sympy import Symbol, simplify, pprint
1174 
1175     >>> d1 = Symbol("d1", positive=True)
1176     >>> d2 = Symbol("d2", positive=True)
1177     >>> z = Symbol("z")
1178 
1179     >>> X = FDistribution("x", d1, d2)
1180 
1181     >>> D = density(X)(z)
1182     >>> pprint(D, use_unicode=False)
1183       d2
1184       --    ______________________________
1185       2    /       d1            -d1 - d2
1186     d2  *\/  (d1*z)  *(d1*z + d2)
1187     --------------------------------------
1188                     /d1  d2\
1189                  z*B|--, --|
1190                     \2   2 /
1191 
1192     References
1193     ==========
1194 
1195     .. [1] https://en.wikipedia.org/wiki/F-distribution
1196     .. [2] http://mathworld.wolfram.com/F-Distribution.html
1197 
1198     """
1199 
1200     return rv(name, FDistributionDistribution, (d1, d2))
1201 
1202 #-------------------------------------------------------------------------------
1203 # Fisher Z distribution --------------------------------------------------------
1204 
1205 class FisherZDistribution(SingleContinuousDistribution):
1206     _argnames = ('d1', 'd2')
1207 
1208     def pdf(self, x):
1209         d1, d2 = self.d1, self.d2
1210         return (2*d1**(d1/2)*d2**(d2/2) / beta_fn(d1/2, d2/2) *
1211                exp(d1*x) / (d1*exp(2*x)+d2)**((d1+d2)/2))
1212 
1213 def FisherZ(name, d1, d2):
1214     r"""
1215     Create a Continuous Random Variable with an Fisher's Z distribution.
1216 
1217     The density of the Fisher's Z distribution is given by
1218 
1219     .. math::
1220         f(x) := \frac{2d_1^{d_1/2} d_2^{d_2/2}} {\mathrm{B}(d_1/2, d_2/2)}
1221                 \frac{e^{d_1z}}{\left(d_1e^{2z}+d_2\right)^{\left(d_1+d_2\right)/2}}
1222 
1223 
1224     .. TODO - What is the difference between these degrees of freedom?
1225 
1226     Parameters
1227     ==========
1228 
1229     d1 : `d_1 > 0`, degree of freedom
1230     d2 : `d_2 > 0`, degree of freedom
1231 
1232     Returns
1233     =======
1234 
1235     A RandomSymbol.
1236 
1237     Examples
1238     ========
1239 
1240     >>> from sympy.stats import FisherZ, density
1241     >>> from sympy import Symbol, simplify, pprint
1242 
1243     >>> d1 = Symbol("d1", positive=True)
1244     >>> d2 = Symbol("d2", positive=True)
1245     >>> z = Symbol("z")
1246 
1247     >>> X = FisherZ("x", d1, d2)
1248 
1249     >>> D = density(X)(z)
1250     >>> pprint(D, use_unicode=False)
1251                                 d1   d2
1252         d1   d2               - -- - --
1253         --   --                 2    2
1254         2    2  /    2*z     \           d1*z
1255     2*d1  *d2  *\d1*e    + d2/         *e
1256     -----------------------------------------
1257                      /d1  d2\
1258                     B|--, --|
1259                      \2   2 /
1260 
1261     References
1262     ==========
1263 
1264     .. [1] https://en.wikipedia.org/wiki/Fisher%27s_z-distribution
1265     .. [2] http://mathworld.wolfram.com/Fishersz-Distribution.html
1266 
1267     """
1268 
1269     return rv(name, FisherZDistribution, (d1, d2))
1270 
1271 #-------------------------------------------------------------------------------
1272 # Frechet distribution ---------------------------------------------------------
1273 
1274 class FrechetDistribution(SingleContinuousDistribution):
1275     _argnames = ('a', 's', 'm')
1276 
1277     set = Interval(0, oo)
1278 
1279     def __new__(cls, a, s=1, m=0):
1280         a, s, m = list(map(sympify, (a, s, m)))
1281         return Basic.__new__(cls, a, s, m)
1282 
1283     def pdf(self, x):
1284         a, s, m = self.a, self.s, self.m
1285         return a/s * ((x-m)/s)**(-1-a) * exp(-((x-m)/s)**(-a))
1286 
1287     def _cdf(self, x):
1288         a, s, m = self.a, self.s, self.m
1289         return Piecewise((exp(-((x-m)/s)**(-a)), x >= m),
1290                         (S.Zero, True))
1291 
1292 def Frechet(name, a, s=1, m=0):
1293     r"""
1294     Create a continuous random variable with a Frechet distribution.
1295 
1296     The density of the Frechet distribution is given by
1297 
1298     .. math::
1299         f(x) := \frac{\alpha}{s} \left(\frac{x-m}{s}\right)^{-1-\alpha}
1300                  e^{-(\frac{x-m}{s})^{-\alpha}}
1301 
1302     with :math:`x \geq m`.
1303 
1304     Parameters
1305     ==========
1306 
1307     a : Real number, :math:`a \in \left(0, \infty\right)` the shape
1308     s : Real number, :math:`s \in \left(0, \infty\right)` the scale
1309     m : Real number, :math:`m \in \left(-\infty, \infty\right)` the minimum
1310 
1311     Returns
1312     =======
1313 
1314     A RandomSymbol.
1315 
1316     Examples
1317     ========
1318 
1319     >>> from sympy.stats import Frechet, density, E, std, cdf
1320     >>> from sympy import Symbol, simplify
1321 
1322     >>> a = Symbol("a", positive=True)
1323     >>> s = Symbol("s", positive=True)
1324     >>> m = Symbol("m", real=True)
1325     >>> z = Symbol("z")
1326 
1327     >>> X = Frechet("x", a, s, m)
1328 
1329     >>> density(X)(z)
1330     a*((-m + z)/s)**(-a - 1)*exp(-((-m + z)/s)**(-a))/s
1331 
1332     >>> cdf(X)(z)
1333      Piecewise((exp(-((-m + z)/s)**(-a)), m <= z), (0, True))
1334 
1335     References
1336     ==========
1337 
1338     .. [1] https://en.wikipedia.org/wiki/Fr%C3%A9chet_distribution
1339 
1340     """
1341 
1342     return rv(name, FrechetDistribution, (a, s, m))
1343 
1344 #-------------------------------------------------------------------------------
1345 # Gamma distribution -----------------------------------------------------------
1346 
1347 
1348 class GammaDistribution(SingleContinuousDistribution):
1349     _argnames = ('k', 'theta')
1350 
1351     set = Interval(0, oo)
1352 
1353     @staticmethod
1354     def check(k, theta):
1355         _value_check(k > 0, "k must be positive")
1356         _value_check(theta > 0, "Theta must be positive")
1357 
1358     def pdf(self, x):
1359         k, theta = self.k, self.theta
1360         return x**(k - 1) * exp(-x/theta) / (gamma(k)*theta**k)
1361 
1362     def sample(self):
1363         return random.gammavariate(self.k, self.theta)
1364 
1365     def _cdf(self, x):
1366         k, theta = self.k, self.theta
1367         return Piecewise(
1368                     (lowergamma(k, S(x)/theta)/gamma(k), x > 0),
1369                     (S.Zero, True))
1370 
1371     def _characteristic_function(self, t):
1372         return (1 - self.theta*I*t)**(-self.k)
1373 
1374     def _moment_generating_function(self, t):
1375         return (1- self.theta*t)**(-self.k)
1376 
1377 def Gamma(name, k, theta):
1378     r"""
1379     Create a continuous random variable with a Gamma distribution.
1380 
1381     The density of the Gamma distribution is given by
1382 
1383     .. math::
1384         f(x) := \frac{1}{\Gamma(k) \theta^k} x^{k - 1} e^{-\frac{x}{\theta}}
1385 
1386     with :math:`x \in [0,1]`.
1387 
1388     Parameters
1389     ==========
1390 
1391     k : Real number, `k > 0`, a shape
1392     theta : Real number, `\theta > 0`, a scale
1393 
1394     Returns
1395     =======
1396 
1397     A RandomSymbol.
1398 
1399     Examples
1400     ========
1401 
1402     >>> from sympy.stats import Gamma, density, cdf, E, variance
1403     >>> from sympy import Symbol, pprint, simplify
1404 
1405     >>> k = Symbol("k", positive=True)
1406     >>> theta = Symbol("theta", positive=True)
1407     >>> z = Symbol("z")
1408 
1409     >>> X = Gamma("x", k, theta)
1410 
1411     >>> D = density(X)(z)
1412     >>> pprint(D, use_unicode=False)
1413                       -z
1414                     -----
1415          -k  k - 1  theta
1416     theta  *z     *e
1417     ---------------------
1418            Gamma(k)
1419 
1420     >>> C = cdf(X, meijerg=True)(z)
1421     >>> pprint(C, use_unicode=False)
1422     /            /     z  \
1423     |k*lowergamma|k, -----|
1424     |            \   theta/
1425     <----------------------  for z >= 0
1426     |     Gamma(k + 1)
1427     |
1428     \          0             otherwise
1429 
1430     >>> E(X)
1431     k*theta
1432 
1433     >>> V = simplify(variance(X))
1434     >>> pprint(V, use_unicode=False)
1435            2
1436     k*theta
1437 
1438 
1439     References
1440     ==========
1441 
1442     .. [1] https://en.wikipedia.org/wiki/Gamma_distribution
1443     .. [2] http://mathworld.wolfram.com/GammaDistribution.html
1444 
1445     """
1446 
1447     return rv(name, GammaDistribution, (k, theta))
1448 
1449 #-------------------------------------------------------------------------------
1450 # Inverse Gamma distribution ---------------------------------------------------
1451 
1452 
1453 class GammaInverseDistribution(SingleContinuousDistribution):
1454     _argnames = ('a', 'b')
1455 
1456     set = Interval(0, oo)
1457 
1458     @staticmethod
1459     def check(a, b):
1460         _value_check(a > 0, "alpha must be positive")
1461         _value_check(b > 0, "beta must be positive")
1462 
1463     def pdf(self, x):
1464         a, b = self.a, self.b
1465         return b**a/gamma(a) * x**(-a-1) * exp(-b/x)
1466 
1467     def _cdf(self, x):
1468         a, b = self.a, self.b
1469         return Piecewise((uppergamma(a,b/x)/gamma(a), x > 0),
1470                         (S.Zero, True))
1471 
1472     def sample(self):
1473         scipy = import_module('scipy')
1474         if scipy:
1475             from scipy.stats import invgamma
1476             return invgamma.rvs(float(self.a), 0, float(self.b))
1477         else:
1478             raise NotImplementedError('Sampling the inverse Gamma Distribution requires Scipy.')
1479 
1480     def _characteristic_function(self, t):
1481         a, b = self.a, self.b
1482         return 2 * (-I*b*t)**(a/2) * besselk(sqrt(-4*I*b*t)) / gamma(a)
1483 
1484     def _moment_generating_function(self, t):
1485         raise NotImplementedError('The moment generating function for the '
1486                                   'gamma inverse distribution does not exist.')
1487 
1488 def GammaInverse(name, a, b):
1489     r"""
1490     Create a continuous random variable with an inverse Gamma distribution.
1491 
1492     The density of the inverse Gamma distribution is given by
1493 
1494     .. math::
1495         f(x) := \frac{\beta^\alpha}{\Gamma(\alpha)} x^{-\alpha - 1}
1496                 \exp\left(\frac{-\beta}{x}\right)
1497 
1498     with :math:`x > 0`.
1499 
1500     Parameters
1501     ==========
1502 
1503     a : Real number, `a > 0` a shape
1504     b : Real number, `b > 0` a scale
1505 
1506     Returns
1507     =======
1508 
1509     A RandomSymbol.
1510 
1511     Examples
1512     ========
1513 
1514     >>> from sympy.stats import GammaInverse, density, cdf, E, variance
1515     >>> from sympy import Symbol, pprint
1516 
1517     >>> a = Symbol("a", positive=True)
1518     >>> b = Symbol("b", positive=True)
1519     >>> z = Symbol("z")
1520 
1521     >>> X = GammaInverse("x", a, b)
1522 
1523     >>> D = density(X)(z)
1524     >>> pprint(D, use_unicode=False)
1525                 -b
1526                 ---
1527      a  -a - 1   z
1528     b *z      *e
1529     ---------------
1530        Gamma(a)
1531 
1532     >>> cdf(X)(z)
1533     Piecewise((uppergamma(a, b/z)/gamma(a), z > 0), (0, True))
1534 
1535 
1536     References
1537     ==========
1538 
1539     .. [1] https://en.wikipedia.org/wiki/Inverse-gamma_distribution
1540 
1541     """
1542 
1543     return rv(name, GammaInverseDistribution, (a, b))
1544 
1545 #-------------------------------------------------------------------------------
1546 # Gumbel distribution --------------------------------------------------------
1547 
1548 
1549 class GumbelDistribution(SingleContinuousDistribution):
1550     _argnames = ('beta', 'mu')
1551 
1552     set = Interval(-oo, oo)
1553 
1554     def pdf(self, x):
1555         beta, mu = self.beta, self.mu
1556         z = (x - mu)/beta
1557         return (1/beta)*exp(-(z + exp(-z)))
1558 
1559     def _cdf(self, x):
1560         beta, mu = self.beta, self.mu
1561         return exp(-exp((mu - x)/beta))
1562 
1563     def _characteristic_function(self, t):
1564         return gamma(1 - I*self.beta*t) * exp(I*self.mu*t)
1565 
1566     def _moment_generating_function(self, t):
1567         return gamma(1 - self.beta*t) * exp(I*self.mu*t)
1568 
1569 def Gumbel(name, beta, mu):
1570     r"""
1571     Create a Continuous Random Variable with Gumbel distribution.
1572 
1573     The density of the Gumbel distribution is given by
1574 
1575     .. math::
1576         f(x) := \dfrac{1}{\beta} \exp \left( -\dfrac{x-\mu}{\beta}
1577                 - \exp \left( -\dfrac{x - \mu}{\beta} \right) \right)
1578 
1579     with :math:`x \in [ - \infty, \infty ]`.
1580 
1581     Parameters
1582     ==========
1583 
1584     mu: Real number, 'mu' is a location
1585     beta: Real number, 'beta > 0' is a scale
1586 
1587     Returns
1588     ==========
1589 
1590     A RandomSymbol
1591 
1592     Examples
1593     ==========
1594     >>> from sympy.stats import Gumbel, density, E, variance, cdf
1595     >>> from sympy import Symbol, simplify, pprint
1596     >>> x = Symbol("x")
1597     >>> mu = Symbol("mu")
1598     >>> beta = Symbol("beta", positive=True)
1599     >>> X = Gumbel("x", beta, mu)
1600     >>> density(X)(x)
1601     exp(-exp(-(-mu + x)/beta) - (-mu + x)/beta)/beta
1602     >>> cdf(X)(x)
1603     exp(-exp((mu - x)/beta))
1604 
1605     References
1606     ==========
1607 
1608     .. [1] http://mathworld.wolfram.com/GumbelDistribution.html
1609     .. [2] https://en.wikipedia.org/wiki/Gumbel_distribution
1610 
1611     """
1612     return rv(name, GumbelDistribution, (beta, mu))
1613 
1614 #-------------------------------------------------------------------------------
1615 # Gompertz distribution --------------------------------------------------------
1616 
1617 class GompertzDistribution(SingleContinuousDistribution):
1618     _argnames = ('b', 'eta')
1619 
1620     set = Interval(0, oo)
1621 
1622     @staticmethod
1623     def check(b, eta):
1624         _value_check(b > 0, "b must be positive")
1625         _value_check(eta > 0, "eta must be positive")
1626 
1627     def pdf(self, x):
1628         eta, b = self.eta, self.b
1629         return b*eta*exp(b*x)*exp(eta)*exp(-eta*exp(b*x))
1630 
1631     def _cdf(self, x):
1632         eta, b = self.eta, self.b
1633         return 1 - exp(eta)*exp(-eta*exp(b*x))
1634 
1635     def _moment_generating_function(self, t):
1636         eta, b = self.eta, self.b
1637         return eta * exp(eta) * expint(t/b, eta)
1638 
1639 def Gompertz(name, b, eta):
1640     r"""
1641     Create a Continuous Random Variable with Gompertz distribution.
1642 
1643     The density of the Gompertz distribution is given by
1644 
1645     .. math::
1646         f(x) := b \eta e^{b x} e^{\eta} \exp \left(-\eta e^{bx} \right)
1647 
1648     with :math: 'x \in [0, \inf)'.
1649 
1650     Parameters
1651     ==========
1652 
1653     b: Real number, 'b > 0' a scale
1654     eta: Real number, 'eta > 0' a shape
1655 
1656     Returns
1657     =======
1658 
1659     A RandomSymbol.
1660 
1661     Examples
1662     ========
1663 
1664     >>> from sympy.stats import Gompertz, density, E, variance
1665     >>> from sympy import Symbol, simplify, pprint
1666 
1667     >>> b = Symbol("b", positive=True)
1668     >>> eta = Symbol("eta", positive=True)
1669     >>> z = Symbol("z")
1670 
1671     >>> X = Gompertz("x", b, eta)
1672 
1673     >>> density(X)(z)
1674     b*eta*exp(eta)*exp(b*z)*exp(-eta*exp(b*z))
1675 
1676     References
1677     ==========
1678 
1679     .. [1] https://en.wikipedia.org/wiki/Gompertz_distribution
1680 
1681     """
1682     return rv(name, GompertzDistribution, (b, eta))
1683 
1684 #-------------------------------------------------------------------------------
1685 # Kumaraswamy distribution -----------------------------------------------------
1686 
1687 
1688 class KumaraswamyDistribution(SingleContinuousDistribution):
1689     _argnames = ('a', 'b')
1690 
1691     set = Interval(0, oo)
1692 
1693     @staticmethod
1694     def check(a, b):
1695         _value_check(a > 0, "a must be positive")
1696         _value_check(b > 0, "b must be positive")
1697 
1698     def pdf(self, x):
1699         a, b = self.a, self.b
1700         return a * b * x**(a-1) * (1-x**a)**(b-1)
1701 
1702     def _cdf(self, x):
1703         a, b = self.a, self.b
1704         return Piecewise(
1705             (S.Zero, x < S.Zero),
1706             (1 - (1 - x**a)**b, x <= S.One),
1707             (S.One, True))
1708 
1709 def Kumaraswamy(name, a, b):
1710     r"""
1711     Create a Continuous Random Variable with a Kumaraswamy distribution.
1712 
1713     The density of the Kumaraswamy distribution is given by
1714 
1715     .. math::
1716         f(x) := a b x^{a-1} (1-x^a)^{b-1}
1717 
1718     with :math:`x \in [0,1]`.
1719 
1720     Parameters
1721     ==========
1722 
1723     a : Real number, `a > 0` a shape
1724     b : Real number, `b > 0` a shape
1725 
1726     Returns
1727     =======
1728 
1729     A RandomSymbol.
1730 
1731     Examples
1732     ========
1733 
1734     >>> from sympy.stats import Kumaraswamy, density, E, variance, cdf
1735     >>> from sympy import Symbol, simplify, pprint
1736 
1737     >>> a = Symbol("a", positive=True)
1738     >>> b = Symbol("b", positive=True)
1739     >>> z = Symbol("z")
1740 
1741     >>> X = Kumaraswamy("x", a, b)
1742 
1743     >>> D = density(X)(z)
1744     >>> pprint(D, use_unicode=False)
1745                        b - 1
1746          a - 1 /     a\
1747     a*b*z     *\1 - z /
1748 
1749     >>> cdf(X)(z)
1750     Piecewise((0, z < 0), (1 - (1 - z**a)**b, z <= 1), (1, True))
1751 
1752     References
1753     ==========
1754 
1755     .. [1] https://en.wikipedia.org/wiki/Kumaraswamy_distribution
1756 
1757     """
1758 
1759     return rv(name, KumaraswamyDistribution, (a, b))
1760 
1761 #-------------------------------------------------------------------------------
1762 # Laplace distribution ---------------------------------------------------------
1763 
1764 
1765 class LaplaceDistribution(SingleContinuousDistribution):
1766     _argnames = ('mu', 'b')
1767 
1768     def pdf(self, x):
1769         mu, b = self.mu, self.b
1770         return 1/(2*b)*exp(-Abs(x - mu)/b)
1771 
1772     def _cdf(self, x):
1773         mu, b = self.mu, self.b
1774         return Piecewise(
1775                     (S.Half*exp((x - mu)/b), x < mu),
1776                     (S.One - S.Half*exp(-(x - mu)/b), x >= mu)
1777                         )
1778 
1779     def _characteristic_function(self, t):
1780         return exp(self.mu*I*t) / (1 + self.b**2*t**2)
1781 
1782     def _moment_generating_function(self, t):
1783         return exp(self.mu*t) / (1 - self.b**2*t**2)
1784 
1785 def Laplace(name, mu, b):
1786     r"""
1787     Create a continuous random variable with a Laplace distribution.
1788 
1789     The density of the Laplace distribution is given by
1790 
1791     .. math::
1792         f(x) := \frac{1}{2 b} \exp \left(-\frac{|x-\mu|}b \right)
1793 
1794     Parameters
1795     ==========
1796 
1797     mu : Real number or a list/matrix, the location (mean) or the
1798         location vector
1799     b : Real number or a positive definite matrix, representing a scale
1800         or the covariance matrix.
1801 
1802     Returns
1803     =======
1804 
1805     A RandomSymbol.
1806 
1807     Examples
1808     ========
1809 
1810     >>> from sympy.stats import Laplace, density, cdf
1811     >>> from sympy import Symbol, pprint
1812 
1813     >>> mu = Symbol("mu")
1814     >>> b = Symbol("b", positive=True)
1815     >>> z = Symbol("z")
1816 
1817     >>> X = Laplace("x", mu, b)
1818 
1819     >>> density(X)(z)
1820     exp(-Abs(mu - z)/b)/(2*b)
1821 
1822     >>> cdf(X)(z)
1823     Piecewise((exp((-mu + z)/b)/2, mu > z), (1 - exp((mu - z)/b)/2, True))
1824 
1825     >>> L = Laplace('L', [1, 2], [[1, 0], [0, 1]])
1826     >>> pprint(density(L)(1, 2), use_unicode=False)
1827      5        /     ____\
1828     e *besselk\0, \/ 35 /
1829     ---------------------
1830               pi
1831 
1832     References
1833     ==========
1834 
1835     .. [1] https://en.wikipedia.org/wiki/Laplace_distribution
1836     .. [2] http://mathworld.wolfram.com/LaplaceDistribution.html
1837 
1838     """
1839 
1840     if isinstance(mu, (list, MatrixBase)) and\
1841         isinstance(b, (list, MatrixBase)):
1842         from sympy.stats.joint_rv_types import MultivariateLaplaceDistribution
1843         return multivariate_rv(
1844             MultivariateLaplaceDistribution, name, mu, b)
1845 
1846     return rv(name, LaplaceDistribution, (mu, b))
1847 
1848 #-------------------------------------------------------------------------------
1849 # Logistic distribution --------------------------------------------------------
1850 
1851 
1852 class LogisticDistribution(SingleContinuousDistribution):
1853     _argnames = ('mu', 's')
1854 
1855     def pdf(self, x):
1856         mu, s = self.mu, self.s
1857         return exp(-(x - mu)/s)/(s*(1 + exp(-(x - mu)/s))**2)
1858 
1859     def _cdf(self, x):
1860         mu, s = self.mu, self.s
1861         return S.One/(1 + exp(-(x - mu)/s))
1862 
1863     def _characteristic_function(self, t):
1864         return Piecewise((exp(I*t*self.mu) * pi*self.s*t / sinh(pi*self.s*t), Ne(t, 0)), (S.One, True))
1865 
1866     def _moment_generating_function(self, t):
1867         return exp(self.mu*t) * Beta(1 - self.s*t, 1 + self.s*t)
1868 
1869     def _quantile(self, p):
1870         return self.mu - self.s*log(-S.One + S.One/p)
1871 
1872 def Logistic(name, mu, s):
1873     r"""
1874     Create a continuous random variable with a logistic distribution.
1875 
1876     The density of the logistic distribution is given by
1877 
1878     .. math::
1879         f(x) := \frac{e^{-(x-\mu)/s}} {s\left(1+e^{-(x-\mu)/s}\right)^2}
1880 
1881     Parameters
1882     ==========
1883 
1884     mu : Real number, the location (mean)
1885     s : Real number, `s > 0` a scale
1886 
1887     Returns
1888     =======
1889 
1890     A RandomSymbol.
1891 
1892     Examples
1893     ========
1894 
1895     >>> from sympy.stats import Logistic, density, cdf
1896     >>> from sympy import Symbol
1897 
1898     >>> mu = Symbol("mu", real=True)
1899     >>> s = Symbol("s", positive=True)
1900     >>> z = Symbol("z")
1901 
1902     >>> X = Logistic("x", mu, s)
1903 
1904     >>> density(X)(z)
1905     exp((mu - z)/s)/(s*(exp((mu - z)/s) + 1)**2)
1906 
1907     >>> cdf(X)(z)
1908     1/(exp((mu - z)/s) + 1)
1909 
1910     References
1911     ==========
1912 
1913     .. [1] https://en.wikipedia.org/wiki/Logistic_distribution
1914     .. [2] http://mathworld.wolfram.com/LogisticDistribution.html
1915 
1916     """
1917 
1918     return rv(name, LogisticDistribution, (mu, s))
1919 
1920 #-------------------------------------------------------------------------------
1921 # Log Normal distribution ------------------------------------------------------
1922 
1923 
1924 class LogNormalDistribution(SingleContinuousDistribution):
1925     _argnames = ('mean', 'std')
1926 
1927     set = Interval(0, oo)
1928 
1929     def pdf(self, x):
1930         mean, std = self.mean, self.std
1931         return exp(-(log(x) - mean)**2 / (2*std**2)) / (x*sqrt(2*pi)*std)
1932 
1933     def sample(self):
1934         return random.lognormvariate(self.mean, self.std)
1935 
1936     def _cdf(self, x):
1937         mean, std = self.mean, self.std
1938         return Piecewise(
1939                 (S.Half + S.Half*erf((log(x) - mean)/sqrt(2)/std), x > 0),
1940                 (S.Zero, True)
1941         )
1942 
1943     def _moment_generating_function(self, t):
1944         raise NotImplementedError('Moment generating function of the log-normal distribution is not defined.')
1945 
1946 def LogNormal(name, mean, std):
1947     r"""
1948     Create a continuous random variable with a log-normal distribution.
1949 
1950     The density of the log-normal distribution is given by
1951 
1952     .. math::
1953         f(x) := \frac{1}{x\sqrt{2\pi\sigma^2}}
1954                 e^{-\frac{\left(\ln x-\mu\right)^2}{2\sigma^2}}
1955 
1956     with :math:`x \geq 0`.
1957 
1958     Parameters
1959     ==========
1960 
1961     mu : Real number, the log-scale
1962     sigma : Real number, :math:`\sigma^2 > 0` a shape
1963 
1964     Returns
1965     =======
1966 
1967     A RandomSymbol.
1968 
1969     Examples
1970     ========
1971 
1972     >>> from sympy.stats import LogNormal, density
1973     >>> from sympy import Symbol, simplify, pprint
1974 
1975     >>> mu = Symbol("mu", real=True)
1976     >>> sigma = Symbol("sigma", positive=True)
1977     >>> z = Symbol("z")
1978 
1979     >>> X = LogNormal("x", mu, sigma)
1980 
1981     >>> D = density(X)(z)
1982     >>> pprint(D, use_unicode=False)
1983                           2
1984            -(-mu + log(z))
1985            -----------------
1986                       2
1987       ___      2*sigma
1988     \/ 2 *e
1989     ------------------------
1990             ____
1991         2*\/ pi *sigma*z
1992 
1993 
1994     >>> X = LogNormal('x', 0, 1) # Mean 0, standard deviation 1
1995 
1996     >>> density(X)(z)
1997     sqrt(2)*exp(-log(z)**2/2)/(2*sqrt(pi)*z)
1998 
1999     References
2000     ==========
2001 
2002     .. [1] https://en.wikipedia.org/wiki/Lognormal
2003     .. [2] http://mathworld.wolfram.com/LogNormalDistribution.html
2004 
2005     """
2006 
2007     return rv(name, LogNormalDistribution, (mean, std))
2008 
2009 #-------------------------------------------------------------------------------
2010 # Maxwell distribution ---------------------------------------------------------
2011 
2012 
2013 class MaxwellDistribution(SingleContinuousDistribution):
2014     _argnames = ('a',)
2015 
2016     set = Interval(0, oo)
2017 
2018     def pdf(self, x):
2019         a = self.a
2020         return sqrt(2/pi)*x**2*exp(-x**2/(2*a**2))/a**3
2021 
2022     def _cdf(self, x):
2023         a = self.a
2024         return erf(sqrt(2)*x/(2*a)) - sqrt(2)*x*exp(-x**2/(2*a**2))/(sqrt(pi)*a)
2025 
2026 def Maxwell(name, a):
2027     r"""
2028     Create a continuous random variable with a Maxwell distribution.
2029 
2030     The density of the Maxwell distribution is given by
2031 
2032     .. math::
2033         f(x) := \sqrt{\frac{2}{\pi}} \frac{x^2 e^{-x^2/(2a^2)}}{a^3}
2034 
2035     with :math:`x \geq 0`.
2036 
2037     .. TODO - what does the parameter mean?
2038 
2039     Parameters
2040     ==========
2041 
2042     a : Real number, `a > 0`
2043 
2044     Returns
2045     =======
2046 
2047     A RandomSymbol.
2048 
2049     Examples
2050     ========
2051 
2052     >>> from sympy.stats import Maxwell, density, E, variance
2053     >>> from sympy import Symbol, simplify
2054 
2055     >>> a = Symbol("a", positive=True)
2056     >>> z = Symbol("z")
2057 
2058     >>> X = Maxwell("x", a)
2059 
2060     >>> density(X)(z)
2061     sqrt(2)*z**2*exp(-z**2/(2*a**2))/(sqrt(pi)*a**3)
2062 
2063     >>> E(X)
2064     2*sqrt(2)*a/sqrt(pi)
2065 
2066     >>> simplify(variance(X))
2067     a**2*(-8 + 3*pi)/pi
2068 
2069     References
2070     ==========
2071 
2072     .. [1] https://en.wikipedia.org/wiki/Maxwell_distribution
2073     .. [2] http://mathworld.wolfram.com/MaxwellDistribution.html
2074 
2075     """
2076 
2077     return rv(name, MaxwellDistribution, (a, ))
2078 
2079 #-------------------------------------------------------------------------------
2080 # Nakagami distribution --------------------------------------------------------
2081 
2082 
2083 class NakagamiDistribution(SingleContinuousDistribution):
2084     _argnames = ('mu', 'omega')
2085 
2086     set = Interval(0, oo)
2087 
2088     def pdf(self, x):
2089         mu, omega = self.mu, self.omega
2090         return 2*mu**mu/(gamma(mu)*omega**mu)*x**(2*mu - 1)*exp(-mu/omega*x**2)
2091 
2092     def _cdf(self, x):
2093         mu, omega = self.mu, self.omega
2094         return Piecewise(
2095                     (lowergamma(mu, (mu/omega)*x**2)/gamma(mu), x > 0),
2096                     (S.Zero, True))
2097 
2098 def Nakagami(name, mu, omega):
2099     r"""
2100     Create a continuous random variable with a Nakagami distribution.
2101 
2102     The density of the Nakagami distribution is given by
2103 
2104     .. math::
2105         f(x) := \frac{2\mu^\mu}{\Gamma(\mu)\omega^\mu} x^{2\mu-1}
2106                 \exp\left(-\frac{\mu}{\omega}x^2 \right)
2107 
2108     with :math:`x > 0`.
2109 
2110     Parameters
2111     ==========
2112 
2113     mu : Real number, `\mu \geq \frac{1}{2}` a shape
2114     omega : Real number, `\omega > 0`, the spread
2115 
2116     Returns
2117     =======
2118 
2119     A RandomSymbol.
2120 
2121     Examples
2122     ========
2123 
2124     >>> from sympy.stats import Nakagami, density, E, variance, cdf
2125     >>> from sympy import Symbol, simplify, pprint
2126 
2127     >>> mu = Symbol("mu", positive=True)
2128     >>> omega = Symbol("omega", positive=True)
2129     >>> z = Symbol("z")
2130 
2131     >>> X = Nakagami("x", mu, omega)
2132 
2133     >>> D = density(X)(z)
2134     >>> pprint(D, use_unicode=False)
2135                                     2
2136                                -mu*z
2137                                -------
2138         mu      -mu  2*mu - 1  omega
2139     2*mu  *omega   *z        *e
2140     ----------------------------------
2141                 Gamma(mu)
2142 
2143     >>> simplify(E(X))
2144     sqrt(mu)*sqrt(omega)*gamma(mu + 1/2)/gamma(mu + 1)
2145 
2146     >>> V = simplify(variance(X))
2147     >>> pprint(V, use_unicode=False)
2148                         2
2149              omega*Gamma (mu + 1/2)
2150     omega - -----------------------
2151             Gamma(mu)*Gamma(mu + 1)
2152 
2153     >>> cdf(X)(z)
2154     Piecewise((lowergamma(mu, mu*z**2/omega)/gamma(mu), z > 0),
2155             (0, True))
2156 
2157 
2158     References
2159     ==========
2160 
2161     .. [1] https://en.wikipedia.org/wiki/Nakagami_distribution
2162 
2163     """
2164 
2165     return rv(name, NakagamiDistribution, (mu, omega))
2166 
2167 #-------------------------------------------------------------------------------
2168 # Normal distribution ----------------------------------------------------------
2169 
2170 
2171 class NormalDistribution(SingleContinuousDistribution):
2172     _argnames = ('mean', 'std')
2173 
2174     @staticmethod
2175     def check(mean, std):
2176         _value_check(std > 0, "Standard deviation must be positive")
2177 
2178     def pdf(self, x):
2179         return exp(-(x - self.mean)**2 / (2*self.std**2)) / (sqrt(2*pi)*self.std)
2180 
2181     def sample(self):
2182         return random.normalvariate(self.mean, self.std)
2183 
2184     def _cdf(self, x):
2185         mean, std = self.mean, self.std
2186         return erf(sqrt(2)*(-mean + x)/(2*std))/2 + S.Half
2187 
2188     def _characteristic_function(self, t):
2189         mean, std = self.mean, self.std
2190         return exp(I*mean*t - std**2*t**2/2)
2191 
2192     def _moment_generating_function(self, t):
2193         mean, std = self.mean, self.std
2194         return exp(mean*t + std**2*t**2/2)
2195 
2196     def _quantile(self, p):
2197         mean, std = self.mean, self.std
2198         return mean + std*sqrt(2)*erfinv(2*p - 1)
2199 
2200 def Normal(name, mean, std):
2201     r"""
2202     Create a continuous random variable with a Normal distribution.
2203 
2204     The density of the Normal distribution is given by
2205 
2206     .. math::
2207         f(x) := \frac{1}{\sigma\sqrt{2\pi}} e^{ -\frac{(x-\mu)^2}{2\sigma^2} }
2208 
2209     Parameters
2210     ==========
2211 
2212     mu : Real number or a list representing the mean or the mean vector
2213     sigma : Real number or a positive definite sqaure matrix,
2214          :math:`\sigma^2 > 0` the variance
2215 
2216     Returns
2217     =======
2218 
2219     A RandomSymbol.
2220 
2221     Examples
2222     ========
2223 
2224     >>> from sympy.stats import Normal, density, E, std, cdf, skewness, quantile
2225     >>> from sympy import Symbol, simplify, pprint, factor, together, factor_terms
2226 
2227     >>> mu = Symbol("mu")
2228     >>> sigma = Symbol("sigma", positive=True)
2229     >>> z = Symbol("z")
2230     >>> y = Symbol("y")
2231     >>> p = Symbol("p")
2232     >>> X = Normal("x", mu, sigma)
2233 
2234     >>> density(X)(z)
2235     sqrt(2)*exp(-(-mu + z)**2/(2*sigma**2))/(2*sqrt(pi)*sigma)
2236 
2237     >>> C = simplify(cdf(X))(z) # it needs a little more help...
2238     >>> pprint(C, use_unicode=False)
2239        /  ___          \
2240        |\/ 2 *(-mu + z)|
2241     erf|---------------|
2242        \    2*sigma    /   1
2243     -------------------- + -
2244              2             2
2245 
2246     >>> quantile(X)(p)
2247     mu + sqrt(2)*sigma*erfinv(2*p - 1)
2248 
2249     >>> simplify(skewness(X))
2250     0
2251 
2252     >>> X = Normal("x", 0, 1) # Mean 0, standard deviation 1
2253     >>> density(X)(z)
2254     sqrt(2)*exp(-z**2/2)/(2*sqrt(pi))
2255 
2256     >>> E(2*X + 1)
2257     1
2258 
2259     >>> simplify(std(2*X + 1))
2260     2
2261 
2262     >>> m = Normal('X', [1, 2], [[2, 1], [1, 2]])
2263     >>> from sympy.stats.joint_rv import marginal_distribution
2264     >>> pprint(density(m)(y, z))
2265            /1   y\ /2*y   z\   /    z\ /  y   2*z    \
2266            |- - -|*|--- - -| + |1 - -|*|- - + --- - 1|
2267       ___  \2   2/ \ 3    3/   \    2/ \  3    3     /
2268     \/ 3 *e
2269     --------------------------------------------------
2270                            6*pi
2271 
2272     >>> marginal_distribution(m, m[0])(1)
2273      1/(2*sqrt(pi))
2274 
2275 
2276     References
2277     ==========
2278 
2279     .. [1] https://en.wikipedia.org/wiki/Normal_distribution
2280     .. [2] http://mathworld.wolfram.com/NormalDistributionFunction.html
2281 
2282     """
2283 
2284     if isinstance(mean, (list, MatrixBase)) and\
2285         isinstance(std, (list, MatrixBase)):
2286         from sympy.stats.joint_rv_types import MultivariateNormalDistribution
2287         return multivariate_rv(
2288             MultivariateNormalDistribution, name, mean, std)
2289     return rv(name, NormalDistribution, (mean, std))
2290 
2291 #-------------------------------------------------------------------------------
2292 # Pareto distribution ----------------------------------------------------------
2293 
2294 
2295 class ParetoDistribution(SingleContinuousDistribution):
2296     _argnames = ('xm', 'alpha')
2297 
2298     @property
2299     def set(self):
2300         return Interval(self.xm, oo)
2301 
2302     @staticmethod
2303     def check(xm, alpha):
2304         _value_check(xm > 0, "Xm must be positive")
2305         _value_check(alpha > 0, "Alpha must be positive")
2306 
2307     def pdf(self, x):
2308         xm, alpha = self.xm, self.alpha
2309         return alpha * xm**alpha / x**(alpha + 1)
2310 
2311     def sample(self):
2312         return random.paretovariate(self.alpha)
2313 
2314     def _cdf(self, x):
2315         xm, alpha = self.xm, self.alpha
2316         return Piecewise(
2317                 (S.One - xm**alpha/x**alpha, x>=xm),
2318                 (0, True),
2319         )
2320 
2321     def _moment_generating_function(self, t):
2322         xm, alpha = self.xm, self.alpha
2323         return alpha * (-xm*t)**alpha * uppergamma(-alpha, -xm*t)
2324 
2325     def _characteristic_function(self, t):
2326         xm, alpha = self.xm, self.alpha
2327         return alpha * (-I * xm * t) ** alpha * uppergamma(-alpha, -I * xm * t)
2328 
2329 
2330 def Pareto(name, xm, alpha):
2331     r"""
2332     Create a continuous random variable with the Pareto distribution.
2333 
2334     The density of the Pareto distribution is given by
2335 
2336     .. math::
2337         f(x) := \frac{\alpha\,x_m^\alpha}{x^{\alpha+1}}
2338 
2339     with :math:`x \in [x_m,\infty]`.
2340 
2341     Parameters
2342     ==========
2343 
2344     xm : Real number, `x_m > 0`, a scale
2345     alpha : Real number, `\alpha > 0`, a shape
2346 
2347     Returns
2348     =======
2349 
2350     A RandomSymbol.
2351 
2352     Examples
2353     ========
2354 
2355     >>> from sympy.stats import Pareto, density
2356     >>> from sympy import Symbol
2357 
2358     >>> xm = Symbol("xm", positive=True)
2359     >>> beta = Symbol("beta", positive=True)
2360     >>> z = Symbol("z")
2361 
2362     >>> X = Pareto("x", xm, beta)
2363 
2364     >>> density(X)(z)
2365     beta*xm**beta*z**(-beta - 1)
2366 
2367     References
2368     ==========
2369 
2370     .. [1] https://en.wikipedia.org/wiki/Pareto_distribution
2371     .. [2] http://mathworld.wolfram.com/ParetoDistribution.html
2372 
2373     """
2374 
2375     return rv(name, ParetoDistribution, (xm, alpha))
2376 
2377 #-------------------------------------------------------------------------------
2378 # QuadraticU distribution ------------------------------------------------------
2379 
2380 
2381 class QuadraticUDistribution(SingleContinuousDistribution):
2382     _argnames = ('a', 'b')
2383 
2384     @property
2385     def set(self):
2386         return Interval(self.a, self.b)
2387 
2388     def pdf(self, x):
2389         a, b = self.a, self.b
2390         alpha = 12 / (b-a)**3
2391         beta = (a+b) / 2
2392         return Piecewise(
2393                   (alpha * (x-beta)**2, And(a<=x, x<=b)),
2394                   (S.Zero, True))
2395 
2396     def _moment_generating_function(self, t):
2397         a, b = self.a, self.b
2398 
2399         return -3 * (exp(a*t) * (4  + (a**2 + 2*a*(-2 + b) + b**2) * t) - exp(b*t) * (4 + (-4*b + (a + b)**2) * t)) / ((a-b)**3 * t**2)
2400 
2401     def _characteristic_function(self, t):
2402         def _moment_generating_function(self, t):
2403             a, b = self.a, self.b
2404 
2405             return -3*I*(exp(I*a*t*exp(I*b*t)) * (4*I - (-4*b + (a+b)**2)*t)) / ((a-b)**3 * t**2)
2406 
2407 
2408 def QuadraticU(name, a, b):
2409     r"""
2410     Create a Continuous Random Variable with a U-quadratic distribution.
2411 
2412     The density of the U-quadratic distribution is given by
2413 
2414     .. math::
2415         f(x) := \alpha (x-\beta)^2
2416 
2417     with :math:`x \in [a,b]`.
2418 
2419     Parameters
2420     ==========
2421 
2422     a : Real number
2423     b : Real number, :math:`a < b`
2424 
2425     Returns
2426     =======
2427 
2428     A RandomSymbol.
2429 
2430     Examples
2431     ========
2432 
2433     >>> from sympy.stats import QuadraticU, density, E, variance
2434     >>> from sympy import Symbol, simplify, factor, pprint
2435 
2436     >>> a = Symbol("a", real=True)
2437     >>> b = Symbol("b", real=True)
2438     >>> z = Symbol("z")
2439 
2440     >>> X = QuadraticU("x", a, b)
2441 
2442     >>> D = density(X)(z)
2443     >>> pprint(D, use_unicode=False)
2444     /                2
2445     |   /  a   b    \
2446     |12*|- - - - + z|
2447     |   \  2   2    /
2448     <-----------------  for And(b >= z, a <= z)
2449     |            3
2450     |    (-a + b)
2451     |
2452     \        0                 otherwise
2453 
2454     References
2455     ==========
2456 
2457     .. [1] https://en.wikipedia.org/wiki/U-quadratic_distribution
2458 
2459     """
2460 
2461     return rv(name, QuadraticUDistribution, (a, b))
2462 
2463 #-------------------------------------------------------------------------------
2464 # RaisedCosine distribution ----------------------------------------------------
2465 
2466 
2467 class RaisedCosineDistribution(SingleContinuousDistribution):
2468     _argnames = ('mu', 's')
2469 
2470     @property
2471     def set(self):
2472         return Interval(self.mu - self.s, self.mu + self.s)
2473 
2474     @staticmethod
2475     def check(mu, s):
2476         _value_check(s > 0, "s must be positive")
2477 
2478     def pdf(self, x):
2479         mu, s = self.mu, self.s
2480         return Piecewise(
2481                 ((1+cos(pi*(x-mu)/s)) / (2*s), And(mu-s<=x, x<=mu+s)),
2482                 (S.Zero, True))
2483 
2484     def _characteristic_function(self, t):
2485         mu, s = self.mu, self.s
2486         return Piecewise((exp(-I*pi*mu/s)/2, Eq(t, -pi/s)),
2487                          (exp(I*pi*mu/s)/2, Eq(t, pi/s)),
2488                          (pi**2*sin(s*t)*exp(I*mu*t) / (s*t*(pi**2 - s**2*t**2)), True))
2489 
2490     def _moment_generating_function(self, t):
2491         mu, s = self.mu, self.s
2492         return pi**2 * sinh(s*t) * exp(mu*t) /  (s*t*(pi**2 + s**2*t**2))
2493 
2494 def RaisedCosine(name, mu, s):
2495     r"""
2496     Create a Continuous Random Variable with a raised cosine distribution.
2497 
2498     The density of the raised cosine distribution is given by
2499 
2500     .. math::
2501         f(x) := \frac{1}{2s}\left(1+\cos\left(\frac{x-\mu}{s}\pi\right)\right)
2502 
2503     with :math:`x \in [\mu-s,\mu+s]`.
2504 
2505     Parameters
2506     ==========
2507 
2508     mu : Real number
2509     s : Real number, `s > 0`
2510 
2511     Returns
2512     =======
2513 
2514     A RandomSymbol.
2515 
2516     Examples
2517     ========
2518 
2519     >>> from sympy.stats import RaisedCosine, density, E, variance
2520     >>> from sympy import Symbol, simplify, pprint
2521 
2522     >>> mu = Symbol("mu", real=True)
2523     >>> s = Symbol("s", positive=True)
2524     >>> z = Symbol("z")
2525 
2526     >>> X = RaisedCosine("x", mu, s)
2527 
2528     >>> D = density(X)(z)
2529     >>> pprint(D, use_unicode=False)
2530     /   /pi*(-mu + z)\
2531     |cos|------------| + 1
2532     |   \     s      /
2533     <---------------------  for And(z >= mu - s, z <= mu + s)
2534     |         2*s
2535     |
2536     \          0                        otherwise
2537 
2538     References
2539     ==========
2540 
2541     .. [1] https://en.wikipedia.org/wiki/Raised_cosine_distribution
2542 
2543     """
2544 
2545     return rv(name, RaisedCosineDistribution, (mu, s))
2546 
2547 #-------------------------------------------------------------------------------
2548 # Rayleigh distribution --------------------------------------------------------
2549 
2550 
2551 class RayleighDistribution(SingleContinuousDistribution):
2552     _argnames = ('sigma',)
2553 
2554     set = Interval(0, oo)
2555 
2556     def pdf(self, x):
2557         sigma = self.sigma
2558         return x/sigma**2*exp(-x**2/(2*sigma**2))
2559 
2560     def _cdf(self, x):
2561         sigma = self.sigma
2562         return 1 - exp(-(x**2/(2*sigma**2)))
2563 
2564     def _characteristic_function(self, t):
2565         sigma = self.sigma
2566         return 1 - sigma*t*exp(-sigma**2*t**2/2) * sqrt(pi/2) * (erfi(sigma*t/sqrt(2)) - I)
2567 
2568     def _moment_generating_function(self, t):
2569         sigma = self.sigma
2570         return 1 + sigma*t*exp(sigma**2*t**2/2) * sqrt(pi/2) * (erf(sigma*t/sqrt(2)) + 1)
2571 
2572 
2573 def Rayleigh(name, sigma):
2574     r"""
2575     Create a continuous random variable with a Rayleigh distribution.
2576 
2577     The density of the Rayleigh distribution is given by
2578 
2579     .. math ::
2580         f(x) := \frac{x}{\sigma^2} e^{-x^2/2\sigma^2}
2581 
2582     with :math:`x > 0`.
2583 
2584     Parameters
2585     ==========
2586 
2587     sigma : Real number, `\sigma > 0`
2588 
2589     Returns
2590     =======
2591 
2592     A RandomSymbol.
2593 
2594     Examples
2595     ========
2596 
2597     >>> from sympy.stats import Rayleigh, density, E, variance
2598     >>> from sympy import Symbol, simplify
2599 
2600     >>> sigma = Symbol("sigma", positive=True)
2601     >>> z = Symbol("z")
2602 
2603     >>> X = Rayleigh("x", sigma)
2604 
2605     >>> density(X)(z)
2606     z*exp(-z**2/(2*sigma**2))/sigma**2
2607 
2608     >>> E(X)
2609     sqrt(2)*sqrt(pi)*sigma/2
2610 
2611     >>> variance(X)
2612     -pi*sigma**2/2 + 2*sigma**2
2613 
2614     References
2615     ==========
2616 
2617     .. [1] https://en.wikipedia.org/wiki/Rayleigh_distribution
2618     .. [2] http://mathworld.wolfram.com/RayleighDistribution.html
2619 
2620     """
2621 
2622     return rv(name, RayleighDistribution, (sigma, ))
2623 
2624 #-------------------------------------------------------------------------------
2625 # Shifted Gompertz distribution ------------------------------------------------
2626 
2627 
2628 class ShiftedGompertzDistribution(SingleContinuousDistribution):
2629     _argnames = ('b', 'eta')
2630 
2631     set = Interval(0, oo)
2632 
2633     @staticmethod
2634     def check(b, eta):
2635         _value_check(b > 0, "b must be positive")
2636         _value_check(eta > 0, "eta must be positive")
2637 
2638     def pdf(self, x):
2639         b, eta = self.b, self.eta
2640         return b*exp(-b*x)*exp(-eta*exp(-b*x))*(1+eta*(1-exp(-b*x)))
2641 
2642 def ShiftedGompertz(name, b, eta):
2643     r"""
2644     Create a continuous random variable with a Shifted Gompertz distribution.
2645 
2646     The density of the Shifted Gompertz distribution is given by
2647 
2648     .. math::
2649         f(x) := b e^{-b x} e^{-\eta \exp(-b x)} \left[1 + \eta(1 - e^(-bx)) \right]
2650 
2651     with :math: 'x \in [0, \inf)'.
2652 
2653     Parameters
2654     ==========
2655 
2656     b: Real number, 'b > 0' a scale
2657     eta: Real number, 'eta > 0' a shape
2658 
2659     Returns
2660     =======
2661 
2662     A RandomSymbol.
2663 
2664     Examples
2665     ========
2666     >>> from sympy.stats import ShiftedGompertz, density, E, variance
2667     >>> from sympy import Symbol
2668 
2669     >>> b = Symbol("b", positive=True)
2670     >>> eta = Symbol("eta", positive=True)
2671     >>> x = Symbol("x")
2672 
2673     >>> X = ShiftedGompertz("x", b, eta)
2674 
2675     >>> density(X)(x)
2676     b*(eta*(1 - exp(-b*x)) + 1)*exp(-b*x)*exp(-eta*exp(-b*x))
2677 
2678     References
2679     ==========
2680 
2681     .. [1] https://en.wikipedia.org/wiki/Shifted_Gompertz_distribution
2682 
2683     """
2684     return rv(name, ShiftedGompertzDistribution, (b, eta))
2685 
2686 #-------------------------------------------------------------------------------
2687 # StudentT distribution --------------------------------------------------------
2688 
2689 
2690 class StudentTDistribution(SingleContinuousDistribution):
2691     _argnames = ('nu',)
2692 
2693     def pdf(self, x):
2694         nu = self.nu
2695         return 1/(sqrt(nu)*beta_fn(S(1)/2, nu/2))*(1 + x**2/nu)**(-(nu + 1)/2)
2696 
2697     def _cdf(self, x):
2698         nu = self.nu
2699         return S.Half + x*gamma((nu+1)/2)*hyper((S.Half, (nu+1)/2),
2700                                 (S(3)/2,), -x**2/nu)/(sqrt(pi*nu)*gamma(nu/2))
2701 
2702     def _moment_generating_function(self, t):
2703         raise NotImplementedError('The moment generating function for the Student-T distribution is undefined.')
2704 
2705 def StudentT(name, nu):
2706     r"""
2707     Create a continuous random variable with a student's t distribution.
2708 
2709     The density of the student's t distribution is given by
2710 
2711     .. math::
2712         f(x) := \frac{\Gamma \left(\frac{\nu+1}{2} \right)}
2713                 {\sqrt{\nu\pi}\Gamma \left(\frac{\nu}{2} \right)}
2714                 \left(1+\frac{x^2}{\nu} \right)^{-\frac{\nu+1}{2}}
2715 
2716     Parameters
2717     ==========
2718 
2719     nu : Real number, `\nu > 0`, the degrees of freedom
2720 
2721     Returns
2722     =======
2723 
2724     A RandomSymbol.
2725 
2726     Examples
2727     ========
2728 
2729     >>> from sympy.stats import StudentT, density, E, variance, cdf
2730     >>> from sympy import Symbol, simplify, pprint
2731 
2732     >>> nu = Symbol("nu", positive=True)
2733     >>> z = Symbol("z")
2734 
2735     >>> X = StudentT("x", nu)
2736 
2737     >>> D = density(X)(z)
2738     >>> pprint(D, use_unicode=False)
2739                nu   1
2740              - -- - -
2741                2    2
2742      /     2\
2743      |    z |
2744      |1 + --|
2745      \    nu/
2746     -----------------
2747       ____  /     nu\
2748     \/ nu *B|1/2, --|
2749             \     2 /
2750 
2751     >>> cdf(X)(z)
2752     1/2 + z*gamma(nu/2 + 1/2)*hyper((1/2, nu/2 + 1/2), (3/2,),
2753                                 -z**2/nu)/(sqrt(pi)*sqrt(nu)*gamma(nu/2))
2754 
2755 
2756     References
2757     ==========
2758 
2759     .. [1] https://en.wikipedia.org/wiki/Student_t-distribution
2760     .. [2] http://mathworld.wolfram.com/Studentst-Distribution.html
2761 
2762     """
2763 
2764     return rv(name, StudentTDistribution, (nu, ))
2765 
2766 #-------------------------------------------------------------------------------
2767 # Trapezoidal distribution ------------------------------------------------------
2768 
2769 
2770 class TrapezoidalDistribution(SingleContinuousDistribution):
2771     _argnames = ('a', 'b', 'c', 'd')
2772 
2773     def pdf(self, x):
2774         a, b, c, d = self.a, self.b, self.c, self.d
2775         return Piecewise(
2776             (2*(x-a) / ((b-a)*(d+c-a-b)), And(a <= x, x < b)),
2777             (2 / (d+c-a-b), And(b <= x, x < c)),
2778             (2*(d-x) / ((d-c)*(d+c-a-b)), And(c <= x, x <= d)),
2779             (S.Zero, True))
2780 
2781 def Trapezoidal(name, a, b, c, d):
2782     r"""
2783     Create a continuous random variable with a trapezoidal distribution.
2784 
2785     The density of the trapezoidal distribution is given by
2786 
2787     .. math::
2788         f(x) := \begin{cases}
2789                   0 & \mathrm{for\ } x < a, \\
2790                   \frac{2(x-a)}{(b-a)(d+c-a-b)} & \mathrm{for\ } a \le x < b, \\
2791                   \frac{2}{d+c-a-b} & \mathrm{for\ } b \le x < c, \\
2792                   \frac{2(d-x)}{(d-c)(d+c-a-b)} & \mathrm{for\ } c \le x < d, \\
2793                   0 & \mathrm{for\ } d < x.
2794                 \end{cases}
2795 
2796     Parameters
2797     ==========
2798 
2799     a : Real number, :math:`a < d`
2800     b : Real number, :math:`a <= b < c`
2801     c : Real number, :math:`b < c <= d`
2802     d : Real number
2803 
2804     Returns
2805     =======
2806 
2807     A RandomSymbol.
2808 
2809     Examples
2810     ========
2811 
2812     >>> from sympy.stats import Trapezoidal, density, E
2813     >>> from sympy import Symbol, pprint
2814 
2815     >>> a = Symbol("a")
2816     >>> b = Symbol("b")
2817     >>> c = Symbol("c")
2818     >>> d = Symbol("d")
2819     >>> z = Symbol("z")
2820 
2821     >>> X = Trapezoidal("x", a,b,c,d)
2822 
2823     >>> pprint(density(X)(z), use_unicode=False)
2824     /        -2*a + 2*z
2825     |-------------------------  for And(a <= z, b > z)
2826     |(-a + b)*(-a - b + c + d)
2827     |
2828     |           2
2829     |     --------------        for And(b <= z, c > z)
2830     <     -a - b + c + d
2831     |
2832     |        2*d - 2*z
2833     |-------------------------  for And(d >= z, c <= z)
2834     |(-c + d)*(-a - b + c + d)
2835     |
2836     \            0                     otherwise
2837 
2838     References
2839     ==========
2840 
2841     .. [1] https://en.wikipedia.org/wiki/Trapezoidal_distribution
2842 
2843     """
2844     return rv(name, TrapezoidalDistribution, (a, b, c, d))
2845 
2846 #-------------------------------------------------------------------------------
2847 # Triangular distribution ------------------------------------------------------
2848 
2849 
2850 class TriangularDistribution(SingleContinuousDistribution):
2851     _argnames = ('a', 'b', 'c')
2852 
2853     def pdf(self, x):
2854         a, b, c = self.a, self.b, self.c
2855         return Piecewise(
2856             (2*(x - a)/((b - a)*(c - a)), And(a <= x, x < c)),
2857             (2/(b - a), Eq(x, c)),
2858             (2*(b - x)/((b - a)*(b - c)), And(c < x, x <= b)),
2859             (S.Zero, True))
2860 
2861     def _characteristic_function(self, t):
2862         a, b, c = self.a, self.b, self.c
2863         return -2 *((b-c) * exp(I*a*t) - (b-a) * exp(I*c*t) + (c-a) * exp(I*b*t)) / ((b-a)*(c-a)*(b-c)*t**2)
2864 
2865     def _moment_generating_function(self, t):
2866         a, b, c = self.a, self.b, self.c
2867         return 2 * ((b - c) * exp(a * t) - (b - a) * exp(c * t) + (c + a) * exp(b * t)) / (
2868         (b - a) * (c - a) * (b - c) * t ** 2)
2869 
2870 
2871 def Triangular(name, a, b, c):
2872     r"""
2873     Create a continuous random variable with a triangular distribution.
2874 
2875     The density of the triangular distribution is given by
2876 
2877     .. math::
2878         f(x) := \begin{cases}
2879                   0 & \mathrm{for\ } x < a, \\
2880                   \frac{2(x-a)}{(b-a)(c-a)} & \mathrm{for\ } a \le x < c, \\
2881                   \frac{2}{b-a} & \mathrm{for\ } x = c, \\
2882                   \frac{2(b-x)}{(b-a)(b-c)} & \mathrm{for\ } c < x \le b, \\
2883                   0 & \mathrm{for\ } b < x.
2884                 \end{cases}
2885 
2886     Parameters
2887     ==========
2888 
2889     a : Real number, :math:`a \in \left(-\infty, \infty\right)`
2890     b : Real number, :math:`a < b`
2891     c : Real number, :math:`a \leq c \leq b`
2892 
2893     Returns
2894     =======
2895 
2896     A RandomSymbol.
2897 
2898     Examples
2899     ========
2900 
2901     >>> from sympy.stats import Triangular, density, E
2902     >>> from sympy import Symbol, pprint
2903 
2904     >>> a = Symbol("a")
2905     >>> b = Symbol("b")
2906     >>> c = Symbol("c")
2907     >>> z = Symbol("z")
2908 
2909     >>> X = Triangular("x", a,b,c)
2910 
2911     >>> pprint(density(X)(z), use_unicode=False)
2912     /    -2*a + 2*z
2913     |-----------------  for And(a <= z, c > z)
2914     |(-a + b)*(-a + c)
2915     |
2916     |       2
2917     |     ------              for c = z
2918     <     -a + b
2919     |
2920     |   2*b - 2*z
2921     |----------------   for And(b >= z, c < z)
2922     |(-a + b)*(b - c)
2923     |
2924     \        0                otherwise
2925 
2926     References
2927     ==========
2928 
2929     .. [1] https://en.wikipedia.org/wiki/Triangular_distribution
2930     .. [2] http://mathworld.wolfram.com/TriangularDistribution.html
2931 
2932     """
2933 
2934     return rv(name, TriangularDistribution, (a, b, c))
2935 
2936 #-------------------------------------------------------------------------------
2937 # Uniform distribution ---------------------------------------------------------
2938 
2939 
2940 class UniformDistribution(SingleContinuousDistribution):
2941     _argnames = ('left', 'right')
2942 
2943     def pdf(self, x):
2944         left, right = self.left, self.right
2945         return Piecewise(
2946             (S.One/(right - left), And(left <= x, x <= right)),
2947             (S.Zero, True)
2948         )
2949 
2950     def _cdf(self, x):
2951         left, right = self.left, self.right
2952         return Piecewise(
2953             (S.Zero, x < left),
2954             ((x - left)/(right - left), x <= right),
2955             (S.One, True)
2956         )
2957 
2958     def _characteristic_function(self, t):
2959         left, right = self.left, self.right
2960         return Piecewise(((exp(I*t*right) - exp(I*t*left)) / (I*t*(right - left)), Ne(t, 0)),
2961                          (S.One, True))
2962 
2963     def _moment_generating_function(self, t):
2964         left, right = self.left, self.right
2965         return Piecewise(((exp(t*right) - exp(t*left)) / (t * (right - left)), Ne(t, 0)),
2966                          (S.One, True))
2967 
2968     def expectation(self, expr, var, **kwargs):
2969         from sympy import Max, Min
2970         kwargs['evaluate'] = True
2971         result = SingleContinuousDistribution.expectation(self, expr, var, **kwargs)
2972         result = result.subs({Max(self.left, self.right): self.right,
2973                               Min(self.left, self.right): self.left})
2974         return result
2975 
2976     def sample(self):
2977         return random.uniform(self.left, self.right)
2978 
2979 
2980 def Uniform(name, left, right):
2981     r"""
2982     Create a continuous random variable with a uniform distribution.
2983 
2984     The density of the uniform distribution is given by
2985 
2986     .. math::
2987         f(x) := \begin{cases}
2988                   \frac{1}{b - a} & \text{for } x \in [a,b]  \\
2989                   0               & \text{otherwise}
2990                 \end{cases}
2991 
2992     with :math:`x \in [a,b]`.
2993 
2994     Parameters
2995     ==========
2996 
2997     a : Real number, :math:`-\infty < a` the left boundary
2998     b : Real number, :math:`a < b < \infty` the right boundary
2999 
3000     Returns
3001     =======
3002 
3003     A RandomSymbol.
3004 
3005     Examples
3006     ========
3007 
3008     >>> from sympy.stats import Uniform, density, cdf, E, variance, skewness
3009     >>> from sympy import Symbol, simplify
3010 
3011     >>> a = Symbol("a", negative=True)
3012     >>> b = Symbol("b", positive=True)
3013     >>> z = Symbol("z")
3014 
3015     >>> X = Uniform("x", a, b)
3016 
3017     >>> density(X)(z)
3018     Piecewise((1/(-a + b), (b >= z) & (a <= z)), (0, True))
3019 
3020     >>> cdf(X)(z)  # doctest: +SKIP
3021     -a/(-a + b) + z/(-a + b)
3022 
3023     >>> simplify(E(X))
3024     a/2 + b/2
3025 
3026     >>> simplify(variance(X))
3027     a**2/12 - a*b/6 + b**2/12
3028 
3029     References
3030     ==========
3031 
3032     .. [1] https://en.wikipedia.org/wiki/Uniform_distribution_%28continuous%29
3033     .. [2] http://mathworld.wolfram.com/UniformDistribution.html
3034 
3035     """
3036 
3037     return rv(name, UniformDistribution, (left, right))
3038 
3039 #-------------------------------------------------------------------------------
3040 # UniformSum distribution ------------------------------------------------------
3041 
3042 
3043 class UniformSumDistribution(SingleContinuousDistribution):
3044     _argnames = ('n',)
3045 
3046     @property
3047     def set(self):
3048         return Interval(0, self.n)
3049 
3050     def pdf(self, x):
3051         n = self.n
3052         k = Dummy("k")
3053         return 1/factorial(
3054             n - 1)*Sum((-1)**k*binomial(n, k)*(x - k)**(n - 1), (k, 0, floor(x)))
3055 
3056     def _cdf(self, x):
3057         n = self.n
3058         k = Dummy("k")
3059         return Piecewise((S.Zero, x < 0),
3060                         (1/factorial(n)*Sum((-1)**k*binomial(n, k)*(x - k)**(n),
3061                         (k, 0, floor(x))), x <= n),
3062                         (S.One, True))
3063 
3064     def _characteristic_function(self, t):
3065         return ((exp(I*t) - 1) / (I*t))**self.n
3066 
3067     def _moment_generating_function(self, t):
3068         return ((exp(t) - 1) / t)**self.n
3069 
3070 def UniformSum(name, n):
3071     r"""
3072     Create a continuous random variable with an Irwin-Hall distribution.
3073 
3074     The probability distribution function depends on a single parameter
3075     `n` which is an integer.
3076 
3077     The density of the Irwin-Hall distribution is given by
3078 
3079     .. math ::
3080         f(x) := \frac{1}{(n-1)!}\sum_{k=0}^{\left\lfloor x\right\rfloor}(-1)^k
3081                 \binom{n}{k}(x-k)^{n-1}
3082 
3083     Parameters
3084     ==========
3085 
3086     n : A positive Integer, `n > 0`
3087 
3088     Returns
3089     =======
3090 
3091     A RandomSymbol.
3092 
3093     Examples
3094     ========
3095 
3096     >>> from sympy.stats import UniformSum, density, cdf
3097     >>> from sympy import Symbol, pprint
3098 
3099     >>> n = Symbol("n", integer=True)
3100     >>> z = Symbol("z")
3101 
3102     >>> X = UniformSum("x", n)
3103 
3104     >>> D = density(X)(z)
3105     >>> pprint(D, use_unicode=False)
3106     floor(z)
3107       ___
3108       \  `
3109        \         k         n - 1 /n\
3110         )    (-1) *(-k + z)     *| |
3111        /                         \k/
3112       /__,
3113      k = 0
3114     --------------------------------
3115                 (n - 1)!
3116 
3117     >>> cdf(X)(z)
3118     Piecewise((0, z < 0), (Sum((-1)**_k*(-_k + z)**n*binomial(n, _k),
3119                     (_k, 0, floor(z)))/factorial(n), n >= z), (1, True))
3120 
3121 
3122     Compute cdf with specific 'x' and 'n' values as follows :
3123     >>> cdf(UniformSum("x", 5), evaluate=False)(2).doit()
3124     9/40
3125 
3126     The argument evaluate=False prevents an attempt at evaluation
3127     of the sum for general n, before the argument 2 is passed.
3128 
3129     References
3130     ==========
3131 
3132     .. [1] https://en.wikipedia.org/wiki/Uniform_sum_distribution
3133     .. [2] http://mathworld.wolfram.com/UniformSumDistribution.html
3134 
3135     """
3136 
3137     return rv(name, UniformSumDistribution, (n, ))
3138 
3139 #-------------------------------------------------------------------------------
3140 # VonMises distribution --------------------------------------------------------
3141 
3142 
3143 class VonMisesDistribution(SingleContinuousDistribution):
3144     _argnames = ('mu', 'k')
3145 
3146     set = Interval(0, 2*pi)
3147 
3148     @staticmethod
3149     def check(mu, k):
3150         _value_check(k > 0, "k must be positive")
3151 
3152     def pdf(self, x):
3153         mu, k = self.mu, self.k
3154         return exp(k*cos(x-mu)) / (2*pi*besseli(0, k))
3155 
3156 def VonMises(name, mu, k):
3157     r"""
3158     Create a Continuous Random Variable with a von Mises distribution.
3159 
3160     The density of the von Mises distribution is given by
3161 
3162     .. math::
3163         f(x) := \frac{e^{\kappa\cos(x-\mu)}}{2\pi I_0(\kappa)}
3164 
3165     with :math:`x \in [0,2\pi]`.
3166 
3167     Parameters
3168     ==========
3169 
3170     mu : Real number, measure of location
3171     k : Real number, measure of concentration
3172 
3173     Returns
3174     =======
3175 
3176     A RandomSymbol.
3177 
3178     Examples
3179     ========
3180 
3181     >>> from sympy.stats import VonMises, density, E, variance
3182     >>> from sympy import Symbol, simplify, pprint
3183 
3184     >>> mu = Symbol("mu")
3185     >>> k = Symbol("k", positive=True)
3186     >>> z = Symbol("z")
3187 
3188     >>> X = VonMises("x", mu, k)
3189 
3190     >>> D = density(X)(z)
3191     >>> pprint(D, use_unicode=False)
3192          k*cos(mu - z)
3193         e
3194     ------------------
3195     2*pi*besseli(0, k)
3196 
3197 
3198     References
3199     ==========
3200 
3201     .. [1] https://en.wikipedia.org/wiki/Von_Mises_distribution
3202     .. [2] http://mathworld.wolfram.com/vonMisesDistribution.html
3203 
3204     """
3205 
3206     return rv(name, VonMisesDistribution, (mu, k))
3207 
3208 #-------------------------------------------------------------------------------
3209 # Weibull distribution ---------------------------------------------------------
3210 
3211 
3212 class WeibullDistribution(SingleContinuousDistribution):
3213     _argnames = ('alpha', 'beta')
3214 
3215     set = Interval(0, oo)
3216 
3217     @staticmethod
3218     def check(alpha, beta):
3219         _value_check(alpha > 0, "Alpha must be positive")
3220         _value_check(beta > 0, "Beta must be positive")
3221 
3222     def pdf(self, x):
3223         alpha, beta = self.alpha, self.beta
3224         return beta * (x/alpha)**(beta - 1) * exp(-(x/alpha)**beta) / alpha
3225 
3226     def sample(self):
3227         return random.weibullvariate(self.alpha, self.beta)
3228 
3229 def Weibull(name, alpha, beta):
3230     r"""
3231     Create a continuous random variable with a Weibull distribution.
3232 
3233     The density of the Weibull distribution is given by
3234 
3235     .. math::
3236         f(x) := \begin{cases}
3237                   \frac{k}{\lambda}\left(\frac{x}{\lambda}\right)^{k-1}
3238                   e^{-(x/\lambda)^{k}} & x\geq0\\
3239                   0 & x<0
3240                 \end{cases}
3241 
3242     Parameters
3243     ==========
3244 
3245     lambda : Real number, :math:`\lambda > 0` a scale
3246     k : Real number, `k > 0` a shape
3247 
3248     Returns
3249     =======
3250 
3251     A RandomSymbol.
3252 
3253     Examples
3254     ========
3255 
3256     >>> from sympy.stats import Weibull, density, E, variance
3257     >>> from sympy import Symbol, simplify
3258 
3259     >>> l = Symbol("lambda", positive=True)
3260     >>> k = Symbol("k", positive=True)
3261     >>> z = Symbol("z")
3262 
3263     >>> X = Weibull("x", l, k)
3264 
3265     >>> density(X)(z)
3266     k*(z/lambda)**(k - 1)*exp(-(z/lambda)**k)/lambda
3267 
3268     >>> simplify(E(X))
3269     lambda*gamma(1 + 1/k)
3270 
3271     >>> simplify(variance(X))
3272     lambda**2*(-gamma(1 + 1/k)**2 + gamma(1 + 2/k))
3273 
3274     References
3275     ==========
3276 
3277     .. [1] https://en.wikipedia.org/wiki/Weibull_distribution
3278     .. [2] http://mathworld.wolfram.com/WeibullDistribution.html
3279 
3280     """
3281 
3282     return rv(name, WeibullDistribution, (alpha, beta))
3283 
3284 #-------------------------------------------------------------------------------
3285 # Wigner semicircle distribution -----------------------------------------------
3286 
3287 
3288 class WignerSemicircleDistribution(SingleContinuousDistribution):
3289     _argnames = ('R',)
3290 
3291     @property
3292     def set(self):
3293         return Interval(-self.R, self.R)
3294 
3295     def pdf(self, x):
3296         R = self.R
3297         return 2/(pi*R**2)*sqrt(R**2 - x**2)
3298 
3299     def _characteristic_function(self, t):
3300         return Piecewise((2 * besselj(1, self.R*t) / (self.R*t), Ne(t, 0)),
3301                          (S.One, True))
3302 
3303     def _moment_generating_function(self, t):
3304         return Piecewise((2 * besseli(1, self.R*t) / (self.R*t), Ne(t, 0)),
3305                          (S.One, True))
3306 
3307 def WignerSemicircle(name, R):
3308     r"""
3309     Create a continuous random variable with a Wigner semicircle distribution.
3310 
3311     The density of the Wigner semicircle distribution is given by
3312 
3313     .. math::
3314         f(x) := \frac2{\pi R^2}\,\sqrt{R^2-x^2}
3315 
3316     with :math:`x \in [-R,R]`.
3317 
3318     Parameters
3319     ==========
3320 
3321     R : Real number, `R > 0`, the radius
3322 
3323     Returns
3324     =======
3325 
3326     A `RandomSymbol`.
3327 
3328     Examples
3329     ========
3330 
3331     >>> from sympy.stats import WignerSemicircle, density, E
3332     >>> from sympy import Symbol, simplify
3333 
3334     >>> R = Symbol("R", positive=True)
3335     >>> z = Symbol("z")
3336 
3337     >>> X = WignerSemicircle("x", R)
3338 
3339     >>> density(X)(z)
3340     2*sqrt(R**2 - z**2)/(pi*R**2)
3341 
3342     >>> E(X)
3343     0
3344 
3345     References
3346     ==========
3347 
3348     .. [1] https://en.wikipedia.org/wiki/Wigner_semicircle_distribution
3349     .. [2] http://mathworld.wolfram.com/WignersSemicircleLaw.html
3350 
3351     """
3352 
3353     return rv(name, WignerSemicircleDistribution, (R,))

</code><intended_behavior>Ensure the initialization methods of distribution classes rigorously validate input parameters against the mathematical constraints and logical rules applicable to those distributions. For example, in a Normal distribution, ensuring the standard deviation is positive. This preserves existing functionality by validating inputs that were previously assumed to be correct.</intended_behavior>, <file>sympy/stats/rv.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2 Main Random Variables Module
3 
4 Defines abstract random variable type.
5 Contains interfaces for probability space object (PSpace) as well as standard
6 operators, P, E, sample, density, where, quantile
7 
8 See Also
9 ========
10 
11 sympy.stats.crv
12 sympy.stats.frv
13 sympy.stats.rv_interface
14 """
15 
16 from __future__ import print_function, division
17 
18 from sympy import (Basic, S, Expr, Symbol, Tuple, And, Add, Eq, lambdify,
19         Equality, Lambda, sympify, Dummy, Ne, KroneckerDelta,
20         DiracDelta, Mul)
21 from sympy.abc import x
22 from sympy.core.compatibility import string_types
23 from sympy.core.relational import Relational
24 from sympy.logic.boolalg import Boolean
25 from sympy.sets.sets import FiniteSet, ProductSet, Intersection
26 from sympy.solvers.solveset import solveset
27 
28 
29 class RandomDomain(Basic):
30     """
31     Represents a set of variables and the values which they can take
32 
33     See Also
34     ========
35 
36     sympy.stats.crv.ContinuousDomain
37     sympy.stats.frv.FiniteDomain
38     """
39 
40     is_ProductDomain = False
41     is_Finite = False
42     is_Continuous = False
43     is_Discrete = False
44 
45     def __new__(cls, symbols, *args):
46         symbols = FiniteSet(*symbols)
47         return Basic.__new__(cls, symbols, *args)
48 
49     @property
50     def symbols(self):
51         return self.args[0]
52 
53     @property
54     def set(self):
55         return self.args[1]
56 
57     def __contains__(self, other):
58         raise NotImplementedError()
59 
60     def compute_expectation(self, expr):
61         raise NotImplementedError()
62 
63 
64 class SingleDomain(RandomDomain):
65     """
66     A single variable and its domain
67 
68     See Also
69     ========
70 
71     sympy.stats.crv.SingleContinuousDomain
72     sympy.stats.frv.SingleFiniteDomain
73     """
74     def __new__(cls, symbol, set):
75         assert symbol.is_Symbol
76         return Basic.__new__(cls, symbol, set)
77 
78     @property
79     def symbol(self):
80         return self.args[0]
81 
82     @property
83     def symbols(self):
84         return FiniteSet(self.symbol)
85 
86     def __contains__(self, other):
87         if len(other) != 1:
88             return False
89         sym, val = tuple(other)[0]
90         return self.symbol == sym and val in self.set
91 
92 
93 class ConditionalDomain(RandomDomain):
94     """
95     A RandomDomain with an attached condition
96 
97     See Also
98     ========
99 
100     sympy.stats.crv.ConditionalContinuousDomain
101     sympy.stats.frv.ConditionalFiniteDomain
102     """
103     def __new__(cls, fulldomain, condition):
104         condition = condition.xreplace(dict((rs, rs.symbol)
105             for rs in random_symbols(condition)))
106         return Basic.__new__(cls, fulldomain, condition)
107 
108     @property
109     def symbols(self):
110         return self.fulldomain.symbols
111 
112     @property
113     def fulldomain(self):
114         return self.args[0]
115 
116     @property
117     def condition(self):
118         return self.args[1]
119 
120     @property
121     def set(self):
122         raise NotImplementedError("Set of Conditional Domain not Implemented")
123 
124     def as_boolean(self):
125         return And(self.fulldomain.as_boolean(), self.condition)
126 
127 
128 class PSpace(Basic):
129     """
130     A Probability Space
131 
132     Probability Spaces encode processes that equal different values
133     probabilistically. These underly Random Symbols which occur in SymPy
134     expressions and contain the mechanics to evaluate statistical statements.
135 
136     See Also
137     ========
138 
139     sympy.stats.crv.ContinuousPSpace
140     sympy.stats.frv.FinitePSpace
141     """
142 
143     is_Finite = None
144     is_Continuous = None
145     is_Discrete = None
146     is_real = None
147 
148     @property
149     def domain(self):
150         return self.args[0]
151 
152     @property
153     def density(self):
154         return self.args[1]
155 
156     @property
157     def values(self):
158         return frozenset(RandomSymbol(sym, self) for sym in self.symbols)
159 
160     @property
161     def symbols(self):
162         return self.domain.symbols
163 
164     def where(self, condition):
165         raise NotImplementedError()
166 
167     def compute_density(self, expr):
168         raise NotImplementedError()
169 
170     def sample(self):
171         raise NotImplementedError()
172 
173     def probability(self, condition):
174         raise NotImplementedError()
175 
176     def compute_expectation(self, expr):
177         raise NotImplementedError()
178 
179 
180 class SinglePSpace(PSpace):
181     """
182     Represents the probabilities of a set of random events that can be
183     attributed to a single variable/symbol.
184     """
185     def __new__(cls, s, distribution):
186         if isinstance(s, string_types):
187             s = Symbol(s)
188         if not isinstance(s, Symbol):
189             raise TypeError("s should have been string or Symbol")
190         return Basic.__new__(cls, s, distribution)
191 
192     @property
193     def value(self):
194         return RandomSymbol(self.symbol, self)
195 
196     @property
197     def symbol(self):
198         return self.args[0]
199 
200     @property
201     def distribution(self):
202         return self.args[1]
203 
204     @property
205     def pdf(self):
206         return self.distribution.pdf(self.symbol)
207 
208 
209 class RandomSymbol(Expr):
210     """
211     Random Symbols represent ProbabilitySpaces in SymPy Expressions
212     In principle they can take on any value that their symbol can take on
213     within the associated PSpace with probability determined by the PSpace
214     Density.
215 
216     Random Symbols contain pspace and symbol properties.
217     The pspace property points to the represented Probability Space
218     The symbol is a standard SymPy Symbol that is used in that probability space
219     for example in defining a density.
220 
221     You can form normal SymPy expressions using RandomSymbols and operate on
222     those expressions with the Functions
223 
224     E - Expectation of a random expression
225     P - Probability of a condition
226     density - Probability Density of an expression
227     given - A new random expression (with new random symbols) given a condition
228 
229     An object of the RandomSymbol type should almost never be created by the
230     user. They tend to be created instead by the PSpace class's value method.
231     Traditionally a user doesn't even do this but instead calls one of the
232     convenience functions Normal, Exponential, Coin, Die, FiniteRV, etc....
233     """
234 
235     def __new__(cls, symbol, pspace=None):
236         from sympy.stats.joint_rv import JointRandomSymbol
237         if pspace is None:
238             # Allow single arg, representing pspace == PSpace()
239             pspace = PSpace()
240         if not isinstance(symbol, Symbol):
241             raise TypeError("symbol should be of type Symbol")
242         if not isinstance(pspace, PSpace):
243             raise TypeError("pspace variable should be of type PSpace")
244         if cls == JointRandomSymbol and isinstance(pspace, SinglePSpace):
245             cls = RandomSymbol
246         return Basic.__new__(cls, symbol, pspace)
247 
248     is_finite = True
249     is_symbol = True
250     is_Atom = True
251 
252     _diff_wrt = True
253 
254     pspace = property(lambda self: self.args[1])
255     symbol = property(lambda self: self.args[0])
256     name   = property(lambda self: self.symbol.name)
257 
258     def _eval_is_positive(self):
259         return self.symbol.is_positive
260 
261     def _eval_is_integer(self):
262         return self.symbol.is_integer
263 
264     def _eval_is_real(self):
265         return self.symbol.is_real or self.pspace.is_real
266 
267     @property
268     def is_commutative(self):
269         return self.symbol.is_commutative
270 
271     def _hashable_content(self):
272         return self.pspace, self.symbol
273 
274     @property
275     def free_symbols(self):
276         return {self}
277 
278 
279 class ProductPSpace(PSpace):
280     """
281     Abstract class for representing probability spaces with multiple random
282     variables.
283 
284     See Also
285     ========
286 
287     sympy.stats.rv.IndependentProductPSpace
288     sympy.stats.joint_rv.JointPSpace
289     """
290     pass
291 
292 class IndependentProductPSpace(ProductPSpace):
293     """
294     A probability space resulting from the merger of two independent probability
295     spaces.
296 
297     Often created using the function, pspace
298     """
299 
300     def __new__(cls, *spaces):
301         rs_space_dict = {}
302         for space in spaces:
303             for value in space.values:
304                 rs_space_dict[value] = space
305 
306         symbols = FiniteSet(*[val.symbol for val in rs_space_dict.keys()])
307 
308         # Overlapping symbols
309         from sympy.stats.joint_rv import MarginalDistribution, CompoundDistribution
310         if len(symbols) < sum(len(space.symbols) for space in spaces if not
311          isinstance(space.distribution, (
312             CompoundDistribution, MarginalDistribution))):
313             raise ValueError("Overlapping Random Variables")
314 
315         if all(space.is_Finite for space in spaces):
316             from sympy.stats.frv import ProductFinitePSpace
317             cls = ProductFinitePSpace
318 
319         obj = Basic.__new__(cls, *FiniteSet(*spaces))
320 
321         return obj
322 
323     @property
324     def pdf(self):
325         p = Mul(*[space.pdf for space in self.spaces])
326         return p.subs(dict((rv, rv.symbol) for rv in self.values))
327 
328     @property
329     def rs_space_dict(self):
330         d = {}
331         for space in self.spaces:
332             for value in space.values:
333                 d[value] = space
334         return d
335 
336     @property
337     def symbols(self):
338         return FiniteSet(*[val.symbol for val in self.rs_space_dict.keys()])
339 
340     @property
341     def spaces(self):
342         return FiniteSet(*self.args)
343 
344     @property
345     def values(self):
346         return sumsets(space.values for space in self.spaces)
347 
348     def compute_expectation(self, expr, rvs=None, evaluate=False, **kwargs):
349         rvs = rvs or self.values
350         rvs = frozenset(rvs)
351         for space in self.spaces:
352             expr = space.compute_expectation(expr, rvs & space.values, evaluate=False, **kwargs)
353         if evaluate and hasattr(expr, 'doit'):
354             return expr.doit(**kwargs)
355         return expr
356 
357     @property
358     def domain(self):
359         return ProductDomain(*[space.domain for space in self.spaces])
360 
361     @property
362     def density(self):
363         raise NotImplementedError("Density not available for ProductSpaces")
364 
365     def sample(self):
366         return {k: v for space in self.spaces
367             for k, v in space.sample().items()}
368 
369     def probability(self, condition, **kwargs):
370         cond_inv = False
371         if isinstance(condition, Ne):
372             condition = Eq(condition.args[0], condition.args[1])
373             cond_inv = True
374         expr = condition.lhs - condition.rhs
375         rvs = random_symbols(expr)
376         z = Dummy('z', real=True, Finite=True)
377         dens = self.compute_density(expr)
378         if any([pspace(rv).is_Continuous for rv in rvs]):
379             from sympy.stats.crv import (ContinuousDistributionHandmade,
380                 SingleContinuousPSpace)
381             if expr in self.values:
382                 # Marginalize all other random symbols out of the density
383                 randomsymbols = tuple(set(self.values) - frozenset([expr]))
384                 symbols = tuple(rs.symbol for rs in randomsymbols)
385                 pdf = self.domain.integrate(self.pdf, symbols, **kwargs)
386                 return Lambda(expr.symbol, pdf)
387             dens = ContinuousDistributionHandmade(dens)
388             space = SingleContinuousPSpace(z, dens)
389             result = space.probability(condition.__class__(space.value, 0))
390         else:
391             from sympy.stats.drv import (DiscreteDistributionHandmade,
392                 SingleDiscretePSpace)
393             dens = DiscreteDistributionHandmade(dens)
394             space = SingleDiscretePSpace(z, dens)
395             result = space.probability(condition.__class__(space.value, 0))
396         return result if not cond_inv else S.One - result
397 
398     def compute_density(self, expr, **kwargs):
399         z = Dummy('z', real=True, finite=True)
400         rvs = random_symbols(expr)
401         if any(pspace(rv).is_Continuous for rv in rvs):
402             expr = self.compute_expectation(DiracDelta(expr - z),
403              **kwargs)
404         else:
405             expr = self.compute_expectation(KroneckerDelta(expr, z),
406              **kwargs)
407         return Lambda(z, expr)
408 
409     def compute_cdf(self, expr, **kwargs):
410         raise ValueError("CDF not well defined on multivariate expressions")
411 
412     def conditional_space(self, condition, normalize=True, **kwargs):
413         rvs = random_symbols(condition)
414         condition = condition.xreplace(dict((rv, rv.symbol) for rv in self.values))
415         if any([pspace(rv).is_Continuous for rv in rvs]):
416             from sympy.stats.crv import (ConditionalContinuousDomain,
417                 ContinuousPSpace)
418             space = ContinuousPSpace
419             domain = ConditionalContinuousDomain(self.domain, condition)
420         elif any([pspace(rv).is_Discrete for rv in rvs]):
421             from sympy.stats.drv import (ConditionalDiscreteDomain,
422                 DiscretePSpace)
423             space = DiscretePSpace
424             domain = ConditionalDiscreteDomain(self.domain, condition)
425         elif all([pspace(rv).is_Finite for rv in rvs]):
426             from sympy.stats.frv import FinitePSpace
427             return FinitePSpace.conditional_space(self, condition)
428         if normalize:
429             replacement  = {rv: Dummy(str(rv)) for rv in self.symbols}
430             norm = domain.compute_expectation(self.pdf, **kwargs)
431             pdf = self.pdf / norm.xreplace(replacement)
432             density = Lambda(domain.symbols, pdf)
433 
434         return space(domain, density)
435 
436 class ProductDomain(RandomDomain):
437     """
438     A domain resulting from the merger of two independent domains
439 
440     See Also
441     ========
442     sympy.stats.crv.ProductContinuousDomain
443     sympy.stats.frv.ProductFiniteDomain
444     """
445     is_ProductDomain = True
446 
447     def __new__(cls, *domains):
448         # Flatten any product of products
449         domains2 = []
450         for domain in domains:
451             if not domain.is_ProductDomain:
452                 domains2.append(domain)
453             else:
454                 domains2.extend(domain.domains)
455         domains2 = FiniteSet(*domains2)
456 
457         if all(domain.is_Finite for domain in domains2):
458             from sympy.stats.frv import ProductFiniteDomain
459             cls = ProductFiniteDomain
460         if all(domain.is_Continuous for domain in domains2):
461             from sympy.stats.crv import ProductContinuousDomain
462             cls = ProductContinuousDomain
463         if all(domain.is_Discrete for domain in domains2):
464             from sympy.stats.drv import ProductDiscreteDomain
465             cls = ProductDiscreteDomain
466 
467         return Basic.__new__(cls, *domains2)
468 
469     @property
470     def sym_domain_dict(self):
471         return dict((symbol, domain) for domain in self.domains
472                                      for symbol in domain.symbols)
473 
474     @property
475     def symbols(self):
476         return FiniteSet(*[sym for domain in self.domains
477                                for sym    in domain.symbols])
478 
479     @property
480     def domains(self):
481         return self.args
482 
483     @property
484     def set(self):
485         return ProductSet(domain.set for domain in self.domains)
486 
487     def __contains__(self, other):
488         # Split event into each subdomain
489         for domain in self.domains:
490             # Collect the parts of this event which associate to this domain
491             elem = frozenset([item for item in other
492                               if sympify(domain.symbols.contains(item[0]))
493                               is S.true])
494             # Test this sub-event
495             if elem not in domain:
496                 return False
497         # All subevents passed
498         return True
499 
500     def as_boolean(self):
501         return And(*[domain.as_boolean() for domain in self.domains])
502 
503 
504 def random_symbols(expr):
505     """
506     Returns all RandomSymbols within a SymPy Expression.
507     """
508     atoms = getattr(expr, 'atoms', None)
509     if atoms is not None:
510         return list(atoms(RandomSymbol))
511     else:
512         return []
513 
514 
515 def pspace(expr):
516     """
517     Returns the underlying Probability Space of a random expression.
518 
519     For internal use.
520 
521     Examples
522     ========
523 
524     >>> from sympy.stats import pspace, Normal
525     >>> from sympy.stats.rv import IndependentProductPSpace
526     >>> X = Normal('X', 0, 1)
527     >>> pspace(2*X + 1) == X.pspace
528     True
529     """
530     expr = sympify(expr)
531     if isinstance(expr, RandomSymbol) and expr.pspace is not None:
532         return expr.pspace
533     rvs = random_symbols(expr)
534     if not rvs:
535         raise ValueError("Expression containing Random Variable expected, not %s" % (expr))
536     # If only one space present
537     if all(rv.pspace == rvs[0].pspace for rv in rvs):
538         return rvs[0].pspace
539     # Otherwise make a product space
540     return IndependentProductPSpace(*[rv.pspace for rv in rvs])
541 
542 
543 def sumsets(sets):
544     """
545     Union of sets
546     """
547     return frozenset().union(*sets)
548 
549 
550 def rs_swap(a, b):
551     """
552     Build a dictionary to swap RandomSymbols based on their underlying symbol.
553 
554     i.e.
555     if    ``X = ('x', pspace1)``
556     and   ``Y = ('x', pspace2)``
557     then ``X`` and ``Y`` match and the key, value pair
558     ``{X:Y}`` will appear in the result
559 
560     Inputs: collections a and b of random variables which share common symbols
561     Output: dict mapping RVs in a to RVs in b
562     """
563     d = {}
564     for rsa in a:
565         d[rsa] = [rsb for rsb in b if rsa.symbol == rsb.symbol][0]
566     return d
567 
568 
569 def given(expr, condition=None, **kwargs):
570     r""" Conditional Random Expression
571     From a random expression and a condition on that expression creates a new
572     probability space from the condition and returns the same expression on that
573     conditional probability space.
574 
575     Examples
576     ========
577 
578     >>> from sympy.stats import given, density, Die
579     >>> X = Die('X', 6)
580     >>> Y = given(X, X > 3)
581     >>> density(Y).dict
582     {4: 1/3, 5: 1/3, 6: 1/3}
583 
584     Following convention, if the condition is a random symbol then that symbol
585     is considered fixed.
586 
587     >>> from sympy.stats import Normal
588     >>> from sympy import pprint
589     >>> from sympy.abc import z
590 
591     >>> X = Normal('X', 0, 1)
592     >>> Y = Normal('Y', 0, 1)
593     >>> pprint(density(X + Y, Y)(z), use_unicode=False)
594                     2
595            -(-Y + z)
596            -----------
597       ___       2
598     \/ 2 *e
599     ------------------
600              ____
601          2*\/ pi
602     """
603 
604     if not random_symbols(condition) or pspace_independent(expr, condition):
605         return expr
606 
607     if isinstance(condition, RandomSymbol):
608         condition = Eq(condition, condition.symbol)
609 
610     condsymbols = random_symbols(condition)
611     if (isinstance(condition, Equality) and len(condsymbols) == 1 and
612         not isinstance(pspace(expr).domain, ConditionalDomain)):
613         rv = tuple(condsymbols)[0]
614 
615         results = solveset(condition, rv)
616         if isinstance(results, Intersection) and S.Reals in results.args:
617             results = list(results.args[1])
618 
619         sums = 0
620         for res in results:
621             temp = expr.subs(rv, res)
622             if temp == True:
623                 return True
624             if temp != False:
625                 sums += expr.subs(rv, res)
626         if sums == 0:
627             return False
628         return sums
629 
630     # Get full probability space of both the expression and the condition
631     fullspace = pspace(Tuple(expr, condition))
632     # Build new space given the condition
633     space = fullspace.conditional_space(condition, **kwargs)
634     # Dictionary to swap out RandomSymbols in expr with new RandomSymbols
635     # That point to the new conditional space
636     swapdict = rs_swap(fullspace.values, space.values)
637     # Swap random variables in the expression
638     expr = expr.xreplace(swapdict)
639     return expr
640 
641 
642 def expectation(expr, condition=None, numsamples=None, evaluate=True, **kwargs):
643     """
644     Returns the expected value of a random expression
645 
646     Parameters
647     ==========
648 
649     expr : Expr containing RandomSymbols
650         The expression of which you want to compute the expectation value
651     given : Expr containing RandomSymbols
652         A conditional expression. E(X, X>0) is expectation of X given X > 0
653     numsamples : int
654         Enables sampling and approximates the expectation with this many samples
655     evalf : Bool (defaults to True)
656         If sampling return a number rather than a complex expression
657     evaluate : Bool (defaults to True)
658         In case of continuous systems return unevaluated integral
659 
660     Examples
661     ========
662 
663     >>> from sympy.stats import E, Die
664     >>> X = Die('X', 6)
665     >>> E(X)
666     7/2
667     >>> E(2*X + 1)
668     8
669 
670     >>> E(X, X > 3) # Expectation of X given that it is above 3
671     5
672     """
673 
674     if not random_symbols(expr):  # expr isn't random?
675         return expr
676     if numsamples:  # Computing by monte carlo sampling?
677         return sampling_E(expr, condition, numsamples=numsamples)
678 
679     # Create new expr and recompute E
680     if condition is not None:  # If there is a condition
681         return expectation(given(expr, condition), evaluate=evaluate)
682 
683     # A few known statements for efficiency
684 
685     if expr.is_Add:  # We know that E is Linear
686         return Add(*[expectation(arg, evaluate=evaluate)
687                      for arg in expr.args])
688 
689     # Otherwise case is simple, pass work off to the ProbabilitySpace
690     result = pspace(expr).compute_expectation(expr, evaluate=evaluate, **kwargs)
691     if evaluate and hasattr(result, 'doit'):
692         return result.doit(**kwargs)
693     else:
694         return result
695 
696 
697 def probability(condition, given_condition=None, numsamples=None,
698                 evaluate=True, **kwargs):
699     """
700     Probability that a condition is true, optionally given a second condition
701 
702     Parameters
703     ==========
704 
705     condition : Combination of Relationals containing RandomSymbols
706         The condition of which you want to compute the probability
707     given_condition : Combination of Relationals containing RandomSymbols
708         A conditional expression. P(X > 1, X > 0) is expectation of X > 1
709         given X > 0
710     numsamples : int
711         Enables sampling and approximates the probability with this many samples
712     evaluate : Bool (defaults to True)
713         In case of continuous systems return unevaluated integral
714 
715     Examples
716     ========
717 
718     >>> from sympy.stats import P, Die
719     >>> from sympy import Eq
720     >>> X, Y = Die('X', 6), Die('Y', 6)
721     >>> P(X > 3)
722     1/2
723     >>> P(Eq(X, 5), X > 2) # Probability that X == 5 given that X > 2
724     1/4
725     >>> P(X > Y)
726     5/12
727     """
728 
729     condition = sympify(condition)
730     given_condition = sympify(given_condition)
731 
732     if isinstance(given_condition, RandomSymbol):
733         if any([dependent(rv, given_condition) for rv in random_symbols(condition)]):
734             from sympy.stats.symbolic_probability import Probability
735             return Probability(condition, given_condition)
736         else:
737             return probability(condition)
738 
739     if given_condition is not None and \
740             not isinstance(given_condition, (Relational, Boolean)):
741         raise ValueError("%s is not a relational or combination of relationals"
742                 % (given_condition))
743     if given_condition == False:
744         return S.Zero
745     if not isinstance(condition, (Relational, Boolean)):
746         raise ValueError("%s is not a relational or combination of relationals"
747                 % (condition))
748     if condition is S.true:
749         return S.One
750     if condition is S.false:
751         return S.Zero
752 
753     if numsamples:
754         return sampling_P(condition, given_condition, numsamples=numsamples,
755                 **kwargs)
756     if given_condition is not None:  # If there is a condition
757         # Recompute on new conditional expr
758         return probability(given(condition, given_condition, **kwargs), **kwargs)
759 
760     # Otherwise pass work off to the ProbabilitySpace
761     result = pspace(condition).probability(condition, **kwargs)
762     if evaluate and hasattr(result, 'doit'):
763         return result.doit()
764     else:
765         return result
766 
767 
768 class Density(Basic):
769     expr = property(lambda self: self.args[0])
770 
771     @property
772     def condition(self):
773         if len(self.args) > 1:
774             return self.args[1]
775         else:
776             return None
777 
778     def doit(self, evaluate=True, **kwargs):
779         from sympy.stats.joint_rv import JointPSpace
780         expr, condition = self.expr, self.condition
781         if condition is not None:
782             # Recompute on new conditional expr
783             expr = given(expr, condition, **kwargs)
784         if isinstance(expr, RandomSymbol) and \
785             isinstance(expr.pspace, JointPSpace):
786             return expr.pspace.distribution
787         if not random_symbols(expr):
788             return Lambda(x, DiracDelta(x - expr))
789         if (isinstance(expr, RandomSymbol) and
790             hasattr(expr.pspace, 'distribution') and
791             isinstance(pspace(expr), (SinglePSpace))):
792             return expr.pspace.distribution
793         result = pspace(expr).compute_density(expr, **kwargs)
794 
795         if evaluate and hasattr(result, 'doit'):
796             return result.doit()
797         else:
798             return result
799 
800 
801 def density(expr, condition=None, evaluate=True, numsamples=None, **kwargs):
802     """
803     Probability density of a random expression, optionally given a second
804     condition.
805 
806     This density will take on different forms for different types of
807     probability spaces. Discrete variables produce Dicts. Continuous
808     variables produce Lambdas.
809 
810     Parameters
811     ==========
812 
813     expr : Expr containing RandomSymbols
814         The expression of which you want to compute the density value
815     condition : Relational containing RandomSymbols
816         A conditional expression. density(X > 1, X > 0) is density of X > 1
817         given X > 0
818     numsamples : int
819         Enables sampling and approximates the density with this many samples
820 
821     Examples
822     ========
823 
824     >>> from sympy.stats import density, Die, Normal
825     >>> from sympy import Symbol
826 
827     >>> x = Symbol('x')
828     >>> D = Die('D', 6)
829     >>> X = Normal(x, 0, 1)
830 
831     >>> density(D).dict
832     {1: 1/6, 2: 1/6, 3: 1/6, 4: 1/6, 5: 1/6, 6: 1/6}
833     >>> density(2*D).dict
834     {2: 1/6, 4: 1/6, 6: 1/6, 8: 1/6, 10: 1/6, 12: 1/6}
835     >>> density(X)(x)
836     sqrt(2)*exp(-x**2/2)/(2*sqrt(pi))
837     """
838 
839     if numsamples:
840         return sampling_density(expr, condition, numsamples=numsamples,
841                 **kwargs)
842 
843     return Density(expr, condition).doit(evaluate=evaluate, **kwargs)
844 
845 
846 def cdf(expr, condition=None, evaluate=True, **kwargs):
847     """
848     Cumulative Distribution Function of a random expression.
849 
850     optionally given a second condition
851 
852     This density will take on different forms for different types of
853     probability spaces.
854     Discrete variables produce Dicts.
855     Continuous variables produce Lambdas.
856 
857     Examples
858     ========
859 
860     >>> from sympy.stats import density, Die, Normal, cdf
861 
862     >>> D = Die('D', 6)
863     >>> X = Normal('X', 0, 1)
864 
865     >>> density(D).dict
866     {1: 1/6, 2: 1/6, 3: 1/6, 4: 1/6, 5: 1/6, 6: 1/6}
867     >>> cdf(D)
868     {1: 1/6, 2: 1/3, 3: 1/2, 4: 2/3, 5: 5/6, 6: 1}
869     >>> cdf(3*D, D > 2)
870     {9: 1/4, 12: 1/2, 15: 3/4, 18: 1}
871 
872     >>> cdf(X)
873     Lambda(_z, erf(sqrt(2)*_z/2)/2 + 1/2)
874     """
875     if condition is not None:  # If there is a condition
876         # Recompute on new conditional expr
877         return cdf(given(expr, condition, **kwargs), **kwargs)
878 
879     # Otherwise pass work off to the ProbabilitySpace
880     result = pspace(expr).compute_cdf(expr, **kwargs)
881 
882     if evaluate and hasattr(result, 'doit'):
883         return result.doit()
884     else:
885         return result
886 
887 
888 def characteristic_function(expr, condition=None, evaluate=True, **kwargs):
889     """
890     Characteristic function of a random expression, optionally given a second condition
891 
892     Returns a Lambda
893 
894     Examples
895     ========
896 
897     >>> from sympy.stats import Normal, DiscreteUniform, Poisson, characteristic_function
898 
899     >>> X = Normal('X', 0, 1)
900     >>> characteristic_function(X)
901     Lambda(_t, exp(-_t**2/2))
902 
903     >>> Y = DiscreteUniform('Y', [1, 2, 7])
904     >>> characteristic_function(Y)
905     Lambda(_t, exp(7*_t*I)/3 + exp(2*_t*I)/3 + exp(_t*I)/3)
906 
907     >>> Z = Poisson('Z', 2)
908     >>> characteristic_function(Z)
909     Lambda(_t, exp(2*exp(_t*I) - 2))
910     """
911     if condition is not None:
912         return characteristic_function(given(expr, condition, **kwargs), **kwargs)
913 
914     result = pspace(expr).compute_characteristic_function(expr, **kwargs)
915 
916     if evaluate and hasattr(result, 'doit'):
917         return result.doit()
918     else:
919         return result
920 
921 def moment_generating_function(expr, condition=None, evaluate=True, **kwargs):
922     if condition is not None:
923         return moment_generating_function(given(expr, condition, **kwargs), **kwargs)
924 
925     result = pspace(expr).compute_moment_generating_function(expr, **kwargs)
926 
927     if evaluate and hasattr(result, 'doit'):
928         return result.doit()
929     else:
930         return result
931 
932 def where(condition, given_condition=None, **kwargs):
933     """
934     Returns the domain where a condition is True.
935 
936     Examples
937     ========
938 
939     >>> from sympy.stats import where, Die, Normal
940     >>> from sympy import symbols, And
941 
942     >>> D1, D2 = Die('a', 6), Die('b', 6)
943     >>> a, b = D1.symbol, D2.symbol
944     >>> X = Normal('x', 0, 1)
945 
946     >>> where(X**2<1)
947     Domain: (-1 < x) & (x < 1)
948 
949     >>> where(X**2<1).set
950     Interval.open(-1, 1)
951 
952     >>> where(And(D1<=D2 , D2<3))
953     Domain: (Eq(a, 1) & Eq(b, 1)) | (Eq(a, 1) & Eq(b, 2)) | (Eq(a, 2) & Eq(b, 2))
954     """
955     if given_condition is not None:  # If there is a condition
956         # Recompute on new conditional expr
957         return where(given(condition, given_condition, **kwargs), **kwargs)
958 
959     # Otherwise pass work off to the ProbabilitySpace
960     return pspace(condition).where(condition, **kwargs)
961 
962 
963 def sample(expr, condition=None, **kwargs):
964     """
965     A realization of the random expression
966 
967     Examples
968     ========
969 
970     >>> from sympy.stats import Die, sample
971     >>> X, Y, Z = Die('X', 6), Die('Y', 6), Die('Z', 6)
972 
973     >>> die_roll = sample(X + Y + Z) # A random realization of three dice
974     """
975     return next(sample_iter(expr, condition, numsamples=1))
976 
977 
978 def sample_iter(expr, condition=None, numsamples=S.Infinity, **kwargs):
979     """
980     Returns an iterator of realizations from the expression given a condition
981 
982     Parameters
983     ==========
984 
985     expr: Expr
986         Random expression to be realized
987     condition: Expr, optional
988         A conditional expression
989     numsamples: integer, optional
990         Length of the iterator (defaults to infinity)
991 
992     Examples
993     ========
994 
995     >>> from sympy.stats import Normal, sample_iter
996     >>> X = Normal('X', 0, 1)
997     >>> expr = X*X + 3
998     >>> iterator = sample_iter(expr, numsamples=3)
999     >>> list(iterator) # doctest: +SKIP
1000     [12, 4, 7]
1001 
1002     See Also
1003     ========
1004 
1005     sample
1006     sampling_P
1007     sampling_E
1008     sample_iter_lambdify
1009     sample_iter_subs
1010 
1011     """
1012     # lambdify is much faster but not as robust
1013     try:
1014         return sample_iter_lambdify(expr, condition, numsamples, **kwargs)
1015     # use subs when lambdify fails
1016     except TypeError:
1017         return sample_iter_subs(expr, condition, numsamples, **kwargs)
1018 
1019 def quantile(expr, evaluate=True, **kwargs):
1020     r"""
1021     Return the :math:`p^{th}` order quantile of a probability distribution.
1022 
1023     Quantile is defined as the value at which the probability of the random
1024     variable is less than or equal to the given probability.
1025 
1026     ..math::
1027         Q(p) = inf{x \in (-\infty, \infty) such that p <= F(x)}
1028 
1029     Examples
1030     ========
1031 
1032     >>> from sympy.stats import quantile, Die, Exponential
1033     >>> from sympy import Symbol, pprint
1034     >>> p = Symbol("p")
1035 
1036     >>> l = Symbol("lambda", positive=True)
1037     >>> X = Exponential("x", l)
1038     >>> quantile(X)(p)
1039     -log(1 - p)/lambda
1040 
1041     >>> D = Die("d", 6)
1042     >>> pprint(quantile(D)(p), use_unicode=False)
1043     /nan  for Or(p > 1, p < 0)
1044     |
1045     | 1       for p <= 1/6
1046     |
1047     | 2       for p <= 1/3
1048     |
1049     < 3       for p <= 1/2
1050     |
1051     | 4       for p <= 2/3
1052     |
1053     | 5       for p <= 5/6
1054     |
1055     \ 6        for p <= 1
1056 
1057     """
1058     result = pspace(expr).compute_quantile(expr, **kwargs)
1059 
1060     if evaluate and hasattr(result, 'doit'):
1061         return result.doit()
1062     else:
1063         return result
1064 
1065 def sample_iter_lambdify(expr, condition=None, numsamples=S.Infinity, **kwargs):
1066     """
1067     See sample_iter
1068 
1069     Uses lambdify for computation. This is fast but does not always work.
1070     """
1071     if condition:
1072         ps = pspace(Tuple(expr, condition))
1073     else:
1074         ps = pspace(expr)
1075 
1076     rvs = list(ps.values)
1077     fn = lambdify(rvs, expr, **kwargs)
1078     if condition:
1079         given_fn = lambdify(rvs, condition, **kwargs)
1080 
1081     # Check that lambdify can handle the expression
1082     # Some operations like Sum can prove difficult
1083     try:
1084         d = ps.sample()  # a dictionary that maps RVs to values
1085         args = [d[rv] for rv in rvs]
1086         fn(*args)
1087         if condition:
1088             given_fn(*args)
1089     except Exception:
1090         raise TypeError("Expr/condition too complex for lambdify")
1091 
1092     def return_generator():
1093         count = 0
1094         while count < numsamples:
1095             d = ps.sample()  # a dictionary that maps RVs to values
1096             args = [d[rv] for rv in rvs]
1097 
1098             if condition:  # Check that these values satisfy the condition
1099                 gd = given_fn(*args)
1100                 if gd != True and gd != False:
1101                     raise ValueError(
1102                         "Conditions must not contain free symbols")
1103                 if not gd:  # If the values don't satisfy then try again
1104                     continue
1105 
1106             yield fn(*args)
1107             count += 1
1108     return return_generator()
1109 
1110 
1111 def sample_iter_subs(expr, condition=None, numsamples=S.Infinity, **kwargs):
1112     """
1113     See sample_iter
1114 
1115     Uses subs for computation. This is slow but almost always works.
1116     """
1117     if condition is not None:
1118         ps = pspace(Tuple(expr, condition))
1119     else:
1120         ps = pspace(expr)
1121 
1122     count = 0
1123     while count < numsamples:
1124         d = ps.sample()  # a dictionary that maps RVs to values
1125 
1126         if condition is not None:  # Check that these values satisfy the condition
1127             gd = condition.xreplace(d)
1128             if gd != True and gd != False:
1129                 raise ValueError("Conditions must not contain free symbols")
1130             if not gd:  # If the values don't satisfy then try again
1131                 continue
1132 
1133         yield expr.xreplace(d)
1134         count += 1
1135 
1136 
1137 def sampling_P(condition, given_condition=None, numsamples=1,
1138                evalf=True, **kwargs):
1139     """
1140     Sampling version of P
1141 
1142     See Also
1143     ========
1144 
1145     P
1146     sampling_E
1147     sampling_density
1148 
1149     """
1150 
1151     count_true = 0
1152     count_false = 0
1153 
1154     samples = sample_iter(condition, given_condition,
1155                           numsamples=numsamples, **kwargs)
1156 
1157     for sample in samples:
1158         if sample != True and sample != False:
1159             raise ValueError("Conditions must not contain free symbols")
1160 
1161         if sample:
1162             count_true += 1
1163         else:
1164             count_false += 1
1165 
1166     result = S(count_true) / numsamples
1167     if evalf:
1168         return result.evalf()
1169     else:
1170         return result
1171 
1172 
1173 def sampling_E(expr, given_condition=None, numsamples=1,
1174                evalf=True, **kwargs):
1175     """
1176     Sampling version of E
1177 
1178     See Also
1179     ========
1180 
1181     P
1182     sampling_P
1183     sampling_density
1184     """
1185 
1186     samples = sample_iter(expr, given_condition,
1187                           numsamples=numsamples, **kwargs)
1188 
1189     result = Add(*list(samples)) / numsamples
1190     if evalf:
1191         return result.evalf()
1192     else:
1193         return result
1194 
1195 def sampling_density(expr, given_condition=None, numsamples=1, **kwargs):
1196     """
1197     Sampling version of density
1198 
1199     See Also
1200     ========
1201     density
1202     sampling_P
1203     sampling_E
1204     """
1205 
1206     results = {}
1207     for result in sample_iter(expr, given_condition,
1208                               numsamples=numsamples, **kwargs):
1209         results[result] = results.get(result, 0) + 1
1210     return results
1211 
1212 
1213 def dependent(a, b):
1214     """
1215     Dependence of two random expressions
1216 
1217     Two expressions are independent if knowledge of one does not change
1218     computations on the other.
1219 
1220     Examples
1221     ========
1222 
1223     >>> from sympy.stats import Normal, dependent, given
1224     >>> from sympy import Tuple, Eq
1225 
1226     >>> X, Y = Normal('X', 0, 1), Normal('Y', 0, 1)
1227     >>> dependent(X, Y)
1228     False
1229     >>> dependent(2*X + Y, -Y)
1230     True
1231     >>> X, Y = given(Tuple(X, Y), Eq(X + Y, 3))
1232     >>> dependent(X, Y)
1233     True
1234 
1235     See Also
1236     ========
1237 
1238     independent
1239     """
1240     if pspace_independent(a, b):
1241         return False
1242 
1243     z = Symbol('z', real=True)
1244     # Dependent if density is unchanged when one is given information about
1245     # the other
1246     return (density(a, Eq(b, z)) != density(a) or
1247             density(b, Eq(a, z)) != density(b))
1248 
1249 
1250 def independent(a, b):
1251     """
1252     Independence of two random expressions
1253 
1254     Two expressions are independent if knowledge of one does not change
1255     computations on the other.
1256 
1257     Examples
1258     ========
1259 
1260     >>> from sympy.stats import Normal, independent, given
1261     >>> from sympy import Tuple, Eq
1262 
1263     >>> X, Y = Normal('X', 0, 1), Normal('Y', 0, 1)
1264     >>> independent(X, Y)
1265     True
1266     >>> independent(2*X + Y, -Y)
1267     False
1268     >>> X, Y = given(Tuple(X, Y), Eq(X + Y, 3))
1269     >>> independent(X, Y)
1270     False
1271 
1272     See Also
1273     ========
1274 
1275     dependent
1276     """
1277     return not dependent(a, b)
1278 
1279 
1280 def pspace_independent(a, b):
1281     """
1282     Tests for independence between a and b by checking if their PSpaces have
1283     overlapping symbols. This is a sufficient but not necessary condition for
1284     independence and is intended to be used internally.
1285 
1286     Notes
1287     =====
1288 
1289     pspace_independent(a, b) implies independent(a, b)
1290     independent(a, b) does not imply pspace_independent(a, b)
1291     """
1292     a_symbols = set(pspace(b).symbols)
1293     b_symbols = set(pspace(a).symbols)
1294 
1295     if len(set(random_symbols(a)).intersection(random_symbols(b))) != 0:
1296         return False
1297 
1298     if len(a_symbols.intersection(b_symbols)) == 0:
1299         return True
1300     return None
1301 
1302 
1303 def rv_subs(expr, symbols=None):
1304     """
1305     Given a random expression replace all random variables with their symbols.
1306 
1307     If symbols keyword is given restrict the swap to only the symbols listed.
1308     """
1309     if symbols is None:
1310         symbols = random_symbols(expr)
1311     if not symbols:
1312         return expr
1313     swapdict = {rv: rv.symbol for rv in symbols}
1314     return expr.xreplace(swapdict)
1315 
1316 class NamedArgsMixin(object):
1317     _argnames = ()
1318 
1319     def __getattr__(self, attr):
1320         try:
1321             return self.args[self._argnames.index(attr)]
1322         except ValueError:
1323             raise AttributeError("'%s' object has no attribute '%s'" % (
1324                 type(self).__name__, attr))
1325 
1326 def _value_check(condition, message):
1327     """
1328     Raise a ValueError with message if condition is False, else
1329     return True if all conditions were True, else False.
1330 
1331     Examples
1332     ========
1333 
1334     >>> from sympy.stats.rv import _value_check
1335     >>> from sympy.abc import a, b, c
1336     >>> from sympy import And, Dummy
1337 
1338     >>> _value_check(2 < 3, '')
1339     True
1340 
1341     Here, the condition is not False, but it doesn't evaluate to True
1342     so False is returned (but no error is raised). So checking if the
1343     return value is True or False will tell you if all conditions were
1344     evaluated.
1345 
1346     >>> _value_check(a < b, '')
1347     False
1348 
1349     In this case the condition is False so an error is raised:
1350 
1351     >>> r = Dummy(real=True)
1352     >>> _value_check(r < r - 1, 'condition is not true')
1353     Traceback (most recent call last):
1354     ...
1355     ValueError: condition is not true
1356 
1357     If no condition of many conditions must be False, they can be
1358     checked by passing them as an iterable:
1359 
1360     >>> _value_check((a < 0, b < 0, c < 0), '')
1361     False
1362 
1363     The iterable can be a generator, too:
1364 
1365     >>> _value_check((i < 0 for i in (a, b, c)), '')
1366     False
1367 
1368     The following are equivalent to the above but do not pass
1369     an iterable:
1370 
1371     >>> all(_value_check(i < 0, '') for i in (a, b, c))
1372     False
1373     >>> _value_check(And(a < 0, b < 0, c < 0), '')
1374     False
1375     """
1376     from sympy.core.compatibility import iterable
1377     from sympy.core.logic import fuzzy_and
1378     if not iterable(condition):
1379         condition = [condition]
1380     truth = fuzzy_and(condition)
1381     if truth == False:
1382         raise ValueError(message)
1383     return truth == True

</code><intended_behavior>Implement or enhance parameter checking logic to ensure that parameters passed to random variable creation functions meet the required constraints, throwing informative exceptions when invalid parameters are encountered. This would help in catching errors early and making debug processes more manageable for library users.</intended_behavior>, <file>sympy/stats/joint_rv_types.py</file>
<class>None</class>
<method>None</method>
<code>
1 from sympy import (sympify, S, pi, sqrt, exp, Lambda, Indexed, Gt, IndexedBase,
2                     besselk, gamma, Interval, Range, factorial, Mul, Integer,
3                     Add, rf, Eq, Piecewise, Symbol, imageset, Intersection)
4 from sympy.matrices import ImmutableMatrix
5 from sympy.matrices.expressions.determinant import det
6 from sympy.stats.joint_rv import (JointDistribution, JointPSpace,
7     JointDistributionHandmade, MarginalDistribution)
8 from sympy.stats.rv import _value_check, random_symbols
9 
10 # __all__ = ['MultivariateNormal',
11 # 'MultivariateLaplace',
12 # 'MultivariateT',
13 # 'NormalGamma'
14 # ]
15 
16 def multivariate_rv(cls, sym, *args):
17     args = list(map(sympify, args))
18     dist = cls(*args)
19     args = dist.args
20     dist.check(*args)
21     return JointPSpace(sym, dist).value
22 
23 def JointRV(symbol, pdf, _set=None):
24     """
25     Create a Joint Random Variable where each of its component is conitinuous,
26     given the following:
27 
28     -- a symbol
29     -- a PDF in terms of indexed symbols of the symbol given
30      as the first argument
31 
32     NOTE: As of now, the set for each component for a `JointRV` is
33     equal to the set of all integers, which can not be changed.
34 
35     Returns a RandomSymbol.
36 
37     Examples
38     ========
39 
40     >>> from sympy import symbols, exp, pi, Indexed, S
41     >>> from sympy.stats import density
42     >>> from sympy.stats.joint_rv_types import JointRV
43 
44     >>> x1, x2 = (Indexed('x', i) for i in (1, 2))
45     >>> pdf = exp(-x1**2/2 + x1 - x2**2/2 - S(1)/2)/(2*pi)
46 
47     >>> N1 = JointRV('x', pdf) #Multivariate Normal distribution
48     >>> density(N1)(1, 2)
49     exp(-2)/(2*pi)
50     """
51     #TODO: Add support for sets provided by the user
52     symbol = sympify(symbol)
53     syms = list(i for i in pdf.free_symbols if isinstance(i, Indexed)
54         and i.base == IndexedBase(symbol))
55     syms.sort(key = lambda index: index.args[1])
56     _set = S.Reals**len(syms)
57     pdf = Lambda(syms, pdf)
58     dist = JointDistributionHandmade(pdf, _set)
59     jrv = JointPSpace(symbol, dist).value
60     rvs = random_symbols(pdf)
61     if len(rvs) != 0:
62         dist = MarginalDistribution(dist, (jrv,))
63         return JointPSpace(symbol, dist).value
64     return jrv
65 
66 #-------------------------------------------------------------------------------
67 # Multivariate Normal distribution ---------------------------------------------------------
68 
69 class MultivariateNormalDistribution(JointDistribution):
70     _argnames = ['mu', 'sigma']
71 
72     is_Continuous=True
73 
74     @property
75     def set(self):
76         k = len(self.mu)
77         return S.Reals**k
78 
79     def check(self, mu, sigma):
80         _value_check(len(mu) == len(sigma.col(0)),
81             "Size of the mean vector and covariance matrix are incorrect.")
82         #check if covariance matrix is positive definite or not.
83         _value_check((i > 0 for i in sigma.eigenvals().keys()),
84             "The covariance matrix must be positive definite. ")
85 
86     def pdf(self, *args):
87         mu, sigma = self.mu, self.sigma
88         k = len(mu)
89         args = ImmutableMatrix(args)
90         x = args - mu
91         return  S(1)/sqrt((2*pi)**(k)*det(sigma))*exp(
92             -S(1)/2*x.transpose()*(sigma.inv()*\
93                 x))[0]
94 
95     def marginal_distribution(self, indices, sym):
96         sym = ImmutableMatrix([Indexed(sym, i) for i in indices])
97         _mu, _sigma = self.mu, self.sigma
98         k = len(self.mu)
99         for i in range(k):
100             if i not in indices:
101                 _mu = _mu.row_del(i)
102                 _sigma = _sigma.col_del(i)
103                 _sigma = _sigma.row_del(i)
104         return Lambda(sym, S(1)/sqrt((2*pi)**(len(_mu))*det(_sigma))*exp(
105             -S(1)/2*(_mu - sym).transpose()*(_sigma.inv()*\
106                 (_mu - sym)))[0])
107 
108 #-------------------------------------------------------------------------------
109 # Multivariate Laplace distribution ---------------------------------------------------------
110 
111 class MultivariateLaplaceDistribution(JointDistribution):
112     _argnames = ['mu', 'sigma']
113     is_Continuous=True
114 
115     @property
116     def set(self):
117         k = len(self.mu)
118         return S.Reals**k
119 
120     def check(self, mu, sigma):
121         _value_check(len(mu) == len(sigma.col(0)),
122             "Size of the mean vector and covariance matrix are incorrect.")
123         #check if covariance matrix is positive definite or not.
124         _value_check((i > 0 for i in sigma.eigenvals().keys()),
125             "The covariance matrix must be positive definite. ")
126 
127     def pdf(self, *args):
128         mu, sigma = self.mu, self.sigma
129         mu_T = mu.transpose()
130         k = S(len(mu))
131         sigma_inv = sigma.inv()
132         args = ImmutableMatrix(args)
133         args_T = args.transpose()
134         x = (mu_T*sigma_inv*mu)[0]
135         y = (args_T*sigma_inv*args)[0]
136         v = 1 - k/2
137         return S(2)/((2*pi)**(S(k)/2)*sqrt(det(sigma)))\
138         *(y/(2 + x))**(S(v)/2)*besselk(v, sqrt((2 + x)*(y)))\
139         *exp((args_T*sigma_inv*mu)[0])
140 
141 
142 #-------------------------------------------------------------------------------
143 # Multivariate StudentT distribution ---------------------------------------------------------
144 
145 class MultivariateTDistribution(JointDistribution):
146     _argnames = ['mu', 'shape_mat', 'dof']
147     is_Continuous=True
148 
149     @property
150     def set(self):
151         k = len(self.mu)
152         return S.Reals**k
153 
154     def check(self, mu, sigma, v):
155         _value_check(len(mu) == len(sigma.col(0)),
156             "Size of the location vector and shape matrix are incorrect.")
157         #check if covariance matrix is positive definite or not.
158         _value_check((i > 0 for i in sigma.eigenvals().keys()),
159             "The shape matrix must be positive definite. ")
160 
161     def pdf(self, *args):
162         mu, sigma = self.mu, self.shape_mat
163         v = S(self.dof)
164         k = S(len(mu))
165         sigma_inv = sigma.inv()
166         args = ImmutableMatrix(args)
167         x = args - mu
168         return gamma((k + v)/2)/(gamma(v/2)*(v*pi)**(k/2)*sqrt(det(sigma)))\
169         *(1 + 1/v*(x.transpose()*sigma_inv*x)[0])**((-v - k)/2)
170 
171 def MultivariateT(syms, mu, sigma, v):
172     """
173     Creates a joint random variable with multivariate T-distribution.
174 
175     Parameters
176     ==========
177 
178     syms: list/tuple/set of symbols for identifying each component
179     mu: A list/tuple/set consisting of k means,represents a k
180         dimensional location vector
181     sigma: The shape matrix for the distribution
182 
183     Returns
184     =======
185 
186     A random symbol
187     """
188     return multivariate_rv(MultivariateTDistribution, syms, mu, sigma, v)
189 
190 
191 #-------------------------------------------------------------------------------
192 # Multivariate Normal Gamma distribution ---------------------------------------------------------
193 
194 class NormalGammaDistribution(JointDistribution):
195 
196     _argnames = ['mu', 'lamda', 'alpha', 'beta']
197     is_Continuous=True
198 
199     def check(self, mu, lamda, alpha, beta):
200         _value_check(mu.is_real, "Location must be real.")
201         _value_check(lamda > 0, "Lambda must be positive")
202         _value_check(alpha > 0, "alpha must be positive")
203         _value_check(beta > 0, "beta must be positive")
204 
205     @property
206     def set(self):
207         return S.Reals*Interval(0, S.Infinity)
208 
209     def pdf(self, x, tau):
210         beta, alpha, lamda = self.beta, self.alpha, self.lamda
211         mu = self.mu
212 
213         return beta**alpha*sqrt(lamda)/(gamma(alpha)*sqrt(2*pi))*\
214         tau**(alpha - S(1)/2)*exp(-1*beta*tau)*\
215         exp(-1*(lamda*tau*(x - mu)**2)/S(2))
216 
217     def marginal_distribution(self, indices, *sym):
218         if len(indices) == 2:
219             return self.pdf(*sym)
220         if indices[0] == 0:
221             #For marginal over `x`, return non-standardized Student-T's
222             #distribution
223             x = sym[0]
224             v, mu, sigma = self.alpha - S(1)/2, self.mu, \
225                 S(self.beta)/(self.lamda * self.alpha)
226             return Lambda(sym, gamma((v + 1)/2)/(gamma(v/2)*sqrt(pi*v)*sigma)*\
227                 (1 + 1/v*((x - mu)/sigma)**2)**((-v -1)/2))
228         #For marginal over `tau`, return Gamma distribution as per construction
229         from sympy.stats.crv_types import GammaDistribution
230         return Lambda(sym, GammaDistribution(self.alpha, self.beta)(sym[0]))
231 
232 def NormalGamma(syms, mu, lamda, alpha, beta):
233     """
234     Creates a bivariate joint random variable with multivariate Normal gamma
235     distribution.
236 
237     Parameters
238     ==========
239 
240     syms: list/tuple/set of two symbols for identifying each component
241     mu: A real number, as the mean of the normal distribution
242     alpha: a positive integer
243     beta: a positive integer
244     lamda: a positive integer
245 
246     Returns
247     =======
248 
249     A random symbol
250     """
251     return multivariate_rv(NormalGammaDistribution, syms, mu, lamda, alpha, beta)
252 
253 #-------------------------------------------------------------------------------
254 # Multivariate Beta/Dirichlet distribution ---------------------------------------------------------
255 
256 class MultivariateBetaDistribution(JointDistribution):
257 
258     _argnames = ['alpha']
259     is_Continuous = True
260 
261     def check(self, alpha):
262         _value_check(len(alpha) >= 2, "At least two categories should be passed.")
263         for a_k in alpha:
264             _value_check((a_k > 0) != False, "Each concentration parameter"
265                                             " should be positive.")
266 
267     @property
268     def set(self):
269         k = len(self.alpha)
270         return Interval(0, 1)**k
271 
272     def pdf(self, *syms):
273         alpha = self.alpha
274         B = Mul.fromiter(map(gamma, alpha))/gamma(Add(*alpha))
275         return Mul.fromiter([sym**(a_k - 1) for a_k, sym in zip(alpha, syms)])/B
276 
277 def MultivariateBeta(syms, *alpha):
278     """
279     Creates a continuous random variable with Dirichlet/Multivariate Beta
280     Distribution.
281 
282     The density of the dirichlet distribution can be found at [1].
283 
284     Parameters
285     ==========
286 
287     alpha: positive real numbers signifying concentration numbers.
288 
289     Returns
290     =======
291 
292     A RandomSymbol.
293 
294     Examples
295     ========
296 
297     >>> from sympy.stats import density
298     >>> from sympy.stats.joint_rv import marginal_distribution
299     >>> from sympy.stats.joint_rv_types import MultivariateBeta
300     >>> from sympy import Symbol
301     >>> a1 = Symbol('a1', positive=True)
302     >>> a2 = Symbol('a2', positive=True)
303     >>> B = MultivariateBeta('B', [a1, a2])
304     >>> C = MultivariateBeta('C', a1, a2)
305     >>> x = Symbol('x')
306     >>> y = Symbol('y')
307     >>> density(B)(x, y)
308     x**(a1 - 1)*y**(a2 - 1)*gamma(a1 + a2)/(gamma(a1)*gamma(a2))
309     >>> marginal_distribution(C, C[0])(x)
310     x**(a1 - 1)*gamma(a1 + a2)/(a2*gamma(a1)*gamma(a2))
311 
312     References
313     ==========
314 
315     .. [1] https://en.wikipedia.org/wiki/Dirichlet_distribution
316     .. [2] http://mathworld.wolfram.com/DirichletDistribution.html
317 
318     """
319     if not isinstance(alpha[0], list):
320         alpha = (list(alpha),)
321     return multivariate_rv(MultivariateBetaDistribution, syms, alpha[0])
322 
323 Dirichlet = MultivariateBeta
324 
325 #-------------------------------------------------------------------------------
326 # Multivariate Ewens distribution ---------------------------------------------------------
327 
328 class MultivariateEwensDistribution(JointDistribution):
329 
330     _argnames = ['n', 'theta']
331     is_Discrete = True
332     is_Continuous = False
333 
334     def check(self, n, theta):
335         _value_check(isinstance(n, Integer) and (n > 0) == True,
336                         "sample size should be positive integer.")
337         _value_check(theta.is_positive, "mutation rate should be positive.")
338 
339     @property
340     def set(self):
341         prod_set = Range(0, self.n//1 + 1)
342         for i in range(2, self.n + 1):
343             prod_set *= Range(0, self.n//i + 1)
344         return prod_set
345 
346     def pdf(self, *syms):
347         n, theta = self.n, self.theta
348         term_1 = factorial(n)/rf(theta, n)
349         term_2 = Mul.fromiter([theta**syms[j]/((j+1)**syms[j]*factorial(syms[j]))
350                             for j in range(n)])
351         cond = Eq(sum([(k+1)*syms[k] for k in range(n)]), n)
352         return Piecewise((term_1 * term_2, cond), (0, True))
353 
354 def MultivariateEwens(syms, n, theta):
355     """
356     Creates a discrete random variable with Multivariate Ewens
357     Distribution.
358 
359     The density of the said distribution can be found at [1].
360 
361     Parameters
362     ==========
363 
364     n: positive integer of class Integer,
365             size of the sample or the integer whose partitions are considered
366     theta: mutation rate, must be positive real number.
367 
368     Returns
369     =======
370 
371     A RandomSymbol.
372 
373     Examples
374     ========
375 
376     >>> from sympy.stats import density
377     >>> from sympy.stats.joint_rv import marginal_distribution
378     >>> from sympy.stats.joint_rv_types import MultivariateEwens
379     >>> from sympy import Symbol
380     >>> a1 = Symbol('a1', positive=True)
381     >>> a2 = Symbol('a2', positive=True)
382     >>> ed = MultivariateEwens('E', 2, 1)
383     >>> density(ed)(a1, a2)
384     Piecewise((2**(-a2)/(factorial(a1)*factorial(a2)), Eq(a1 + 2*a2, 2)), (0, True))
385     >>> marginal_distribution(ed, ed[0])(a1)
386     Piecewise((1/factorial(a1), Eq(a1, 2)), (0, True))
387 
388     References
389     ==========
390 
391     .. [1] https://en.wikipedia.org/wiki/Ewens%27s_sampling_formula
392     .. [2] http://www.stat.rutgers.edu/home/hcrane/Papers/STS529.pdf
393 
394     """
395     return multivariate_rv(MultivariateEwensDistribution, syms, n, theta)
396 
397 #-------------------------------------------------------------------------------
398 # Multinomial distribution ---------------------------------------------------------
399 
400 class MultinomialDistribution(JointDistribution):
401 
402     _argnames = ['n', 'p']
403     is_Continuous=False
404     is_Discrete = True
405 
406     def check(self, n, p):
407         _value_check(n > 0,
408                         "number of trials must be a positve integer")
409         for p_k in p:
410             _value_check((p_k >= 0, p_k <= 1),
411                         "probability must be in range [0, 1]")
412         _value_check(Eq(sum(p), 1),
413                         "probabilities must sum to 1")
414 
415     @property
416     def set(self):
417         return Intersection(S.Naturals0, Interval(0, self.n))**len(self.p)
418 
419     def pdf(self, *x):
420         n, p = self.n, self.p
421         term_1 = factorial(n)/Mul.fromiter([factorial(x_k) for x_k in x])
422         term_2 = Mul.fromiter([p_k**x_k for p_k, x_k in zip(p, x)])
423         return Piecewise((term_1 * term_2, Eq(sum(x), n)), (0, True))
424 
425 def Multinomial(syms, n, *p):
426     """
427     Creates a discrete random variable with Multinomial Distribution.
428 
429     The density of the said distribution can be found at [1].
430 
431     Parameters
432     ==========
433     n: positive integer of class Integer,
434        number of trials
435     p: event probabilites, >= 0 and <= 1
436 
437     Returns
438     =======
439     A RandomSymbol.
440 
441     Examples
442     ========
443     >>> from sympy.stats import density
444     >>> from sympy.stats.joint_rv import marginal_distribution
445     >>> from sympy.stats.joint_rv_types import Multinomial
446     >>> from sympy import symbols
447     >>> x1, x2, x3 = symbols('x1, x2, x3', nonnegative=True, integer=True)
448     >>> p1, p2, p3 = symbols('p1, p2, p3', positive=True)
449     >>> M = Multinomial('M', 3, p1, p2, p3)
450     >>> density(M)(x1, x2, x3)
451     Piecewise((6*p1**x1*p2**x2*p3**x3/(factorial(x1)*factorial(x2)*factorial(x3)),
452     Eq(x1 + x2 + x3, 3)), (0, True))
453     >>> marginal_distribution(M, M[0])(x1).subs(x1, 1)
454     3*p1*p2**2 + 6*p1*p2*p3 + 3*p1*p3**2
455 
456     References
457     ==========
458     .. [1] https://en.wikipedia.org/wiki/Multinomial_distribution
459     .. [2] http://mathworld.wolfram.com/MultinomialDistribution.html
460     """
461     if not isinstance(p[0], list):
462         p = (list(p), )
463     return multivariate_rv(MultinomialDistribution, syms, n, p[0])
464 
465 #-------------------------------------------------------------------------------
466 # Negative Multinomial Distribution ---------------------------------------------------------
467 
468 class NegativeMultinomialDistribution(JointDistribution):
469 
470     _argnames = ['k0', 'p']
471     is_Continuous=False
472     is_Discrete = True
473 
474     def check(self, k0, p):
475         _value_check(k0 > 0,
476                         "number of failures must be a positve integer")
477         for p_k in p:
478             _value_check((p_k >= 0, p_k <= 1),
479                         "probability must be in range [0, 1].")
480         _value_check(sum(p) <= 1,
481                         "success probabilities must not be greater than 1.")
482 
483     @property
484     def set(self):
485         return Range(0, S.Infinity)**len(self.p)
486 
487     def pdf(self, *k):
488         k0, p = self.k0, self.p
489         term_1 = (gamma(k0 + sum(k))*(1 - sum(p))**k0)/gamma(k0)
490         term_2 = Mul.fromiter([pi**ki/factorial(ki) for pi, ki in zip(p, k)])
491         return term_1 * term_2
492 
493 def NegativeMultinomial(syms, k0, *p):
494     """
495     Creates a discrete random variable with Negative Multinomial Distribution.
496 
497     The density of the said distribution can be found at [1].
498 
499     Parameters
500     ==========
501     k0: positive integer of class Integer,
502         number of failures before the experiment is stopped
503     p: event probabilites, >= 0 and <= 1
504 
505     Returns
506     =======
507     A RandomSymbol.
508 
509     Examples
510     ========
511     >>> from sympy.stats import density
512     >>> from sympy.stats.joint_rv import marginal_distribution
513     >>> from sympy.stats.joint_rv_types import NegativeMultinomial
514     >>> from sympy import symbols
515     >>> x1, x2, x3 = symbols('x1, x2, x3', nonnegative=True, integer=True)
516     >>> p1, p2, p3 = symbols('p1, p2, p3', positive=True)
517     >>> N = NegativeMultinomial('M', 3, p1, p2, p3)
518     >>> N_c = NegativeMultinomial('M', 3, 0.1, 0.1, 0.1)
519     >>> density(N)(x1, x2, x3)
520     p1**x1*p2**x2*p3**x3*(-p1 - p2 - p3 + 1)**3*gamma(x1 + x2 +
521     x3 + 3)/(2*factorial(x1)*factorial(x2)*factorial(x3))
522     >>> marginal_distribution(N_c, N_c[0])(1).evalf().round(2)
523     0.25
524 
525 
526     References
527     ==========
528     .. [1] https://en.wikipedia.org/wiki/Negative_multinomial_distribution
529     .. [2] http://mathworld.wolfram.com/NegativeBinomialDistribution.html
530     """
531     if not isinstance(p[0], list):
532         p = (list(p), )
533     return multivariate_rv(NegativeMultinomialDistribution, syms, k0, p[0])

</code><intended_behavior>Where distributions involve multiple variables or parameters interdependent in complex ways, ensure validations account for these relationships accurately. This could include checking for matching dimensions between parameters or ensuring the parameters jointly fulfill specific criteria required for the model to work correctly.</intended_behavior>, <file>sympy/stats/drv_types.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2 
3 Contains
4 ========
5 Geometric
6 Poisson
7 Logarithmic
8 NegativeBinomial
9 Poisson
10 YuleSimon
11 Zeta
12 """
13 
14 
15 from __future__ import print_function, division
16 
17 from sympy import (factorial, exp, S, sympify, And, I, zeta, polylog, log, beta,
18     hyper, binomial, Piecewise, floor)
19 from sympy.stats import density
20 from sympy.stats.drv import SingleDiscreteDistribution, SingleDiscretePSpace
21 from sympy.stats.joint_rv import JointPSpace, CompoundDistribution
22 from sympy.stats.rv import _value_check, RandomSymbol
23 import random
24 
25 __all__ = ['Geometric',
26 'Logarithmic',
27 'NegativeBinomial',
28 'Poisson',
29 'YuleSimon',
30 'Zeta'
31 ]
32 
33 
34 def rv(symbol, cls, *args):
35     args = list(map(sympify, args))
36     dist = cls(*args)
37     dist.check(*args)
38     pspace = SingleDiscretePSpace(symbol, dist)
39     if any(isinstance(arg, RandomSymbol) for arg in args):
40         pspace = JointPSpace(symbol, CompoundDistribution(dist))
41     return pspace.value
42 
43 
44 #-------------------------------------------------------------------------------
45 # Geometric distribution ------------------------------------------------------------
46 
47 class GeometricDistribution(SingleDiscreteDistribution):
48     _argnames = ('p',)
49     set = S.Naturals
50 
51     @staticmethod
52     def check(p):
53         _value_check((0 < p, p <= 1), "p must be between 0 and 1")
54 
55     def pdf(self, k):
56         return (1 - self.p)**(k - 1) * self.p
57 
58     def _characteristic_function(self, t):
59         p = self.p
60         return p * exp(I*t) / (1 - (1 - p)*exp(I*t))
61 
62     def _moment_generating_function(self, t):
63         p = self.p
64         return p * exp(t) / (1 - (1 - p) * exp(t))
65 
66 def Geometric(name, p):
67     r"""
68     Create a discrete random variable with a Geometric distribution.
69 
70     The density of the Geometric distribution is given by
71 
72     .. math::
73         f(k) := p (1 - p)^{k - 1}
74 
75     Parameters
76     ==========
77 
78     p: A probability between 0 and 1
79 
80     Returns
81     =======
82 
83     A RandomSymbol.
84 
85     Examples
86     ========
87 
88     >>> from sympy.stats import Geometric, density, E, variance
89     >>> from sympy import Symbol, S
90 
91     >>> p = S.One / 5
92     >>> z = Symbol("z")
93 
94     >>> X = Geometric("x", p)
95 
96     >>> density(X)(z)
97     (4/5)**(z - 1)/5
98 
99     >>> E(X)
100     5
101 
102     >>> variance(X)
103     20
104 
105     References
106     ==========
107 
108     .. [1] https://en.wikipedia.org/wiki/Geometric_distribution
109     .. [2] http://mathworld.wolfram.com/GeometricDistribution.html
110 
111     """
112     return rv(name, GeometricDistribution, p)
113 
114 
115 #-------------------------------------------------------------------------------
116 # Logarithmic distribution ------------------------------------------------------------
117 
118 class LogarithmicDistribution(SingleDiscreteDistribution):
119     _argnames = ('p',)
120 
121     set = S.Naturals
122 
123     @staticmethod
124     def check(p):
125         _value_check((p > 0, p < 1), "p should be between 0 and 1")
126 
127     def pdf(self, k):
128         p = self.p
129         return (-1) * p**k / (k * log(1 - p))
130 
131     def _characteristic_function(self, t):
132         p = self.p
133         return log(1 - p * exp(I*t)) / log(1 - p)
134 
135     def _moment_generating_function(self, t):
136         p = self.p
137         return log(1 - p * exp(t)) / log(1 - p)
138 
139     def sample(self):
140         ### TODO
141         raise NotImplementedError("Sampling of %s is not implemented" % density(self))
142 
143 
144 def Logarithmic(name, p):
145     r"""
146     Create a discrete random variable with a Logarithmic distribution.
147 
148     The density of the Logarithmic distribution is given by
149 
150     .. math::
151         f(k) := \frac{-p^k}{k \ln{(1 - p)}}
152 
153     Parameters
154     ==========
155 
156     p: A value between 0 and 1
157 
158     Returns
159     =======
160 
161     A RandomSymbol.
162 
163     Examples
164     ========
165 
166     >>> from sympy.stats import Logarithmic, density, E, variance
167     >>> from sympy import Symbol, S
168 
169     >>> p = S.One / 5
170     >>> z = Symbol("z")
171 
172     >>> X = Logarithmic("x", p)
173 
174     >>> density(X)(z)
175     -5**(-z)/(z*log(4/5))
176 
177     >>> E(X)
178     -1/(-4*log(5) + 8*log(2))
179 
180     >>> variance(X)
181     -1/((-4*log(5) + 8*log(2))*(-2*log(5) + 4*log(2))) + 1/(-64*log(2)*log(5) + 64*log(2)**2 + 16*log(5)**2) - 10/(-32*log(5) + 64*log(2))
182 
183     References
184     ==========
185 
186     .. [1] https://en.wikipedia.org/wiki/Logarithmic_distribution
187     .. [2] http://mathworld.wolfram.com/LogarithmicDistribution.html
188 
189     """
190     return rv(name, LogarithmicDistribution, p)
191 
192 
193 #-------------------------------------------------------------------------------
194 # Negative binomial distribution ------------------------------------------------------------
195 
196 class NegativeBinomialDistribution(SingleDiscreteDistribution):
197     _argnames = ('r', 'p')
198     set = S.Naturals0
199 
200     @staticmethod
201     def check(r, p):
202         _value_check(r > 0, 'r should be positive')
203         _value_check((p > 0, p < 1), 'p should be between 0 and 1')
204 
205     def pdf(self, k):
206         r = self.r
207         p = self.p
208 
209         return binomial(k + r - 1, k) * (1 - p)**r * p**k
210 
211     def _characteristic_function(self, t):
212         r = self.r
213         p = self.p
214 
215         return ((1 - p) / (1 - p * exp(I*t)))**r
216 
217     def _moment_generating_function(self, t):
218         r = self.r
219         p = self.p
220 
221         return ((1 - p) / (1 - p * exp(t)))**r
222 
223     def sample(self):
224         ### TODO
225         raise NotImplementedError("Sampling of %s is not implemented" % density(self))
226 
227 
228 def NegativeBinomial(name, r, p):
229     r"""
230     Create a discrete random variable with a Negative Binomial distribution.
231 
232     The density of the Negative Binomial distribution is given by
233 
234     .. math::
235         f(k) := \binom{k + r - 1}{k} (1 - p)^r p^k
236 
237     Parameters
238     ==========
239 
240     r: A positive value
241     p: A value between 0 and 1
242 
243     Returns
244     =======
245 
246     A RandomSymbol.
247 
248     Examples
249     ========
250 
251     >>> from sympy.stats import NegativeBinomial, density, E, variance
252     >>> from sympy import Symbol, S
253 
254     >>> r = 5
255     >>> p = S.One / 5
256     >>> z = Symbol("z")
257 
258     >>> X = NegativeBinomial("x", r, p)
259 
260     >>> density(X)(z)
261     1024*5**(-z)*binomial(z + 4, z)/3125
262 
263     >>> E(X)
264     5/4
265 
266     >>> variance(X)
267     25/16
268 
269     References
270     ==========
271 
272     .. [1] https://en.wikipedia.org/wiki/Negative_binomial_distribution
273     .. [2] http://mathworld.wolfram.com/NegativeBinomialDistribution.html
274 
275     """
276     return rv(name, NegativeBinomialDistribution, r, p)
277 
278 
279 #-------------------------------------------------------------------------------
280 # Poisson distribution ------------------------------------------------------------
281 
282 class PoissonDistribution(SingleDiscreteDistribution):
283     _argnames = ('lamda',)
284 
285     set = S.Naturals0
286 
287     @staticmethod
288     def check(lamda):
289         _value_check(lamda > 0, "Lambda must be positive")
290 
291     def pdf(self, k):
292         return self.lamda**k / factorial(k) * exp(-self.lamda)
293 
294     def sample(self):
295         def search(x, y, u):
296             while x < y:
297                 mid = (x + y)//2
298                 if u <= self.cdf(mid):
299                     y = mid
300                 else:
301                     x = mid + 1
302             return x
303 
304         u = random.uniform(0, 1)
305         if u <= self.cdf(S.Zero):
306             return S.Zero
307         n = S.One
308         while True:
309             if u > self.cdf(2*n):
310                 n *= 2
311             else:
312                 return search(n, 2*n, u)
313 
314     def _characteristic_function(self, t):
315         return exp(self.lamda * (exp(I*t) - 1))
316 
317     def _moment_generating_function(self, t):
318         return exp(self.lamda * (exp(t) - 1))
319 
320 
321 def Poisson(name, lamda):
322     r"""
323     Create a discrete random variable with a Poisson distribution.
324 
325     The density of the Poisson distribution is given by
326 
327     .. math::
328         f(k) := \frac{\lambda^{k} e^{- \lambda}}{k!}
329 
330     Parameters
331     ==========
332 
333     lamda: Positive number, a rate
334 
335     Returns
336     =======
337 
338     A RandomSymbol.
339 
340     Examples
341     ========
342 
343     >>> from sympy.stats import Poisson, density, E, variance
344     >>> from sympy import Symbol, simplify
345 
346     >>> rate = Symbol("lambda", positive=True)
347     >>> z = Symbol("z")
348 
349     >>> X = Poisson("x", rate)
350 
351     >>> density(X)(z)
352     lambda**z*exp(-lambda)/factorial(z)
353 
354     >>> E(X)
355     lambda
356 
357     >>> simplify(variance(X))
358     lambda
359 
360     References
361     ==========
362 
363     .. [1] https://en.wikipedia.org/wiki/Poisson_distribution
364     .. [2] http://mathworld.wolfram.com/PoissonDistribution.html
365 
366     """
367     return rv(name, PoissonDistribution, lamda)
368 
369 
370 #-------------------------------------------------------------------------------
371 # Yule-Simon distribution ------------------------------------------------------------
372 
373 class YuleSimonDistribution(SingleDiscreteDistribution):
374     _argnames = ('rho',)
375     set = S.Naturals
376 
377     @staticmethod
378     def check(rho):
379         _value_check(rho > 0, 'rho should be positive')
380 
381     def pdf(self, k):
382         rho = self.rho
383         return rho * beta(k, rho + 1)
384 
385     def _cdf(self, x):
386         return Piecewise((1 - floor(x) * beta(floor(x), self.rho + 1), x >= 1), (0, True))
387 
388     def _characteristic_function(self, t):
389         rho = self.rho
390         return rho * hyper((1, 1), (rho + 2,), exp(I*t)) * exp(I*t) / (rho + 1)
391 
392     def _moment_generating_function(self, t):
393         rho = self.rho
394         return rho * hyper((1, 1), (rho + 2,), exp(t)) * exp(t) / (rho + 1)
395 
396     def sample(self):
397         ### TODO
398         raise NotImplementedError("Sampling of %s is not implemented" % density(self))
399 
400 
401 def YuleSimon(name, rho):
402     r"""
403     Create a discrete random variable with a Yule-Simon distribution.
404 
405     The density of the Yule-Simon distribution is given by
406 
407     .. math::
408         f(k) := \rho B(k, \rho + 1)
409 
410     Parameters
411     ==========
412 
413     rho: A positive value
414 
415     Returns
416     =======
417 
418     A RandomSymbol.
419 
420     Examples
421     ========
422 
423     >>> from sympy.stats import YuleSimon, density, E, variance
424     >>> from sympy import Symbol, simplify
425 
426     >>> p = 5
427     >>> z = Symbol("z")
428 
429     >>> X = YuleSimon("x", p)
430 
431     >>> density(X)(z)
432     5*beta(z, 6)
433 
434     >>> simplify(E(X))
435     5/4
436 
437     >>> simplify(variance(X))
438     25/48
439 
440     References
441     ==========
442 
443     .. [1] https://en.wikipedia.org/wiki/Yule%E2%80%93Simon_distribution
444 
445     """
446     return rv(name, YuleSimonDistribution, rho)
447 
448 
449 #-------------------------------------------------------------------------------
450 # Zeta distribution ------------------------------------------------------------
451 
452 class ZetaDistribution(SingleDiscreteDistribution):
453     _argnames = ('s',)
454     set = S.Naturals
455 
456     @staticmethod
457     def check(s):
458         _value_check(s > 1, 's should be greater than 1')
459 
460     def pdf(self, k):
461         s = self.s
462         return 1 / (k**s * zeta(s))
463 
464     def _characteristic_function(self, t):
465         return polylog(self.s, exp(I*t)) / zeta(self.s)
466 
467     def _moment_generating_function(self, t):
468         return polylog(self.s, exp(t)) / zeta(self.s)
469 
470     def sample(self):
471         ### TODO
472         raise NotImplementedError("Sampling of %s is not implemented" % density(self))
473 
474 
475 def Zeta(name, s):
476     r"""
477     Create a discrete random variable with a Zeta distribution.
478 
479     The density of the Zeta distribution is given by
480 
481     .. math::
482         f(k) := \frac{1}{k^s \zeta{(s)}}
483 
484     Parameters
485     ==========
486 
487     s: A value greater than 1
488 
489     Returns
490     =======
491 
492     A RandomSymbol.
493 
494     Examples
495     ========
496 
497     >>> from sympy.stats import Zeta, density, E, variance
498     >>> from sympy import Symbol
499 
500     >>> s = 5
501     >>> z = Symbol("z")
502 
503     >>> X = Zeta("x", s)
504 
505     >>> density(X)(z)
506     1/(z**5*zeta(5))
507 
508     >>> E(X)
509     pi**4/(90*zeta(5))
510 
511     >>> variance(X)
512     -pi**8/(8100*zeta(5)**2) + zeta(3)/zeta(5)
513 
514     References
515     ==========
516 
517     .. [1] https://en.wikipedia.org/wiki/Zeta_distribution
518 
519     """
520     return rv(name, ZetaDistribution, s)

</code><intended_behavior>For discrete distributions, include checks for the discreteness of parameters where applicable, such as ensuring rate parameters are positive numbers. Additionally, attributes that determine the distribution's behavior, like mean or variance, should be accurately calculated and stored upon validation of parameters.</intended_behavior>]
2025-10-16 02:52:54.825 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-16 02:52:54.825 | INFO     | Search-only: skipping patch selection
2025-10-16 02:52:54.909 | INFO     | Task sympy__sympy-16858 completed successfully.
2025-10-16 02:52:54.910 | INFO     | No patch generated. You can try running ACR again.
