2025-10-15 15:39:30.578 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-15 15:39:34.427 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=416, output_tokens=12, cost=0.004520
2025-10-15 15:39:51.904 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=596, output_tokens=591, cost=0.023690
2025-10-15 15:39:52.933 | INFO     | registered non reproducing test 0
2025-10-15 15:40:11.040 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1954, output_tokens=678, cost=0.039880
2025-10-15 15:40:12.034 | INFO     | registered non reproducing test 1
2025-10-15 15:40:26.841 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1648, output_tokens=525, cost=0.032230
2025-10-15 15:40:27.850 | INFO     | registered non reproducing test 2
2025-10-15 15:40:27.851 | WARNING  | Failed to write a reproducer test; skipping reproducer tracing
2025-10-15 15:40:27.857 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 15:40:35.932 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=721, output_tokens=341, cost=0.017440
2025-10-15 15:40:35.936 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 15:40:38.700 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=695, output_tokens=75, cost=0.009200
2025-10-15 15:40:38.701 | DEBUG    | Extracted a valid json.
2025-10-15 15:40:38.701 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_method(\"to_string\")",
        "search_method(\"decompose\")",
        "search_code(\"f'{(u.m**-1):unicode}'\")",
        "search_code(\"f'{(u.eV*u.s**2).decompose():unicode}'\")"
    ],
    "bug_locations": []
}
2025-10-15 15:40:38.765 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-15 15:40:38.766 | DEBUG    | <Agent search> Analyzing search results.
2025-10-15 15:40:56.707 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1684, output_tokens=806, cost=0.041020
2025-10-15 15:40:56.721 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 15:41:10.613 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2706, output_tokens=428, cost=0.039900
2025-10-15 15:41:10.623 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 15:41:19.497 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=782, output_tokens=281, cost=0.016250
2025-10-15 15:41:19.498 | DEBUG    | Extracted a valid json.
2025-10-15 15:41:19.498 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "astropy/units/core.py",
            "class": "",
            "method": "",
            "intended_behavior": "The `to_string` method or its variants that are responsible for formatting units in different styles should be adjusted to ensure that there is no extraneous space at the beginning of the string representation for any unit, regardless of the formatting style (including `unicode` and `console`). This might involve checking and possibly modifying the conditions or logic that prepends spaces based on unit scale factors or the presence of certain unit components. Any modification should preserve the method's existing functionality to accurately represent units in their requested format, adjusting only for the leading space inconsistency."
        },
        {
            "file": "astropy/units/format/console.py",
            "class": "",
            "method": "",
            "intended_behavior": "These methods should be verified and possibly corrected to ensure they do not introduce an unintended leading space in their output, especially under conditions where unit scale factors are present or absent. The logic handling the format-specific concatenations and space insertions needs careful inspection to eliminate the inconsistency. As with `core.py`, the aim would be to preserve the integrity and accuracy of the unit representation while aligning with the expected behavior of no leading spaces in all scenarios."
        }
    ]
}
2025-10-15 15:41:19.508 | DEBUG    | Bug location extracted successfully: [<file>astropy/units/core.py</file>
<class>None</class>
<method>None</method>
<code>
1 # Licensed under a 3-clause BSD style license - see LICENSE.rst
2 
3 """
4 Core units classes and functions.
5 """
6 
7 
8 import inspect
9 import operator
10 import textwrap
11 import warnings
12 
13 import numpy as np
14 
15 from astropy.utils.decorators import lazyproperty
16 from astropy.utils.exceptions import AstropyWarning
17 from astropy.utils.misc import isiterable
18 
19 from . import format as unit_format
20 from .utils import (
21     is_effectively_unity,
22     resolve_fractions,
23     sanitize_scale,
24     validate_power,
25 )
26 
27 __all__ = [
28     "UnitsError",
29     "UnitsWarning",
30     "UnitConversionError",
31     "UnitTypeError",
32     "UnitBase",
33     "NamedUnit",
34     "IrreducibleUnit",
35     "Unit",
36     "CompositeUnit",
37     "PrefixUnit",
38     "UnrecognizedUnit",
39     "def_unit",
40     "get_current_unit_registry",
41     "set_enabled_units",
42     "add_enabled_units",
43     "set_enabled_equivalencies",
44     "add_enabled_equivalencies",
45     "set_enabled_aliases",
46     "add_enabled_aliases",
47     "dimensionless_unscaled",
48     "one",
49 ]
50 
51 UNITY = 1.0
52 
53 
54 def _flatten_units_collection(items):
55     """
56     Given a list of sequences, modules or dictionaries of units, or
57     single units, return a flat set of all the units found.
58     """
59     if not isinstance(items, list):
60         items = [items]
61 
62     result = set()
63     for item in items:
64         if isinstance(item, UnitBase):
65             result.add(item)
66         else:
67             if isinstance(item, dict):
68                 units = item.values()
69             elif inspect.ismodule(item):
70                 units = vars(item).values()
71             elif isiterable(item):
72                 units = item
73             else:
74                 continue
75 
76             for unit in units:
77                 if isinstance(unit, UnitBase):
78                     result.add(unit)
79 
80     return result
81 
82 
83 def _normalize_equivalencies(equivalencies):
84     """Normalizes equivalencies ensuring each is a 4-tuple.
85 
86     The resulting tuple is of the form::
87 
88         (from_unit, to_unit, forward_func, backward_func)
89 
90     Parameters
91     ----------
92     equivalencies : list of equivalency pairs
93 
94     Raises
95     ------
96     ValueError if an equivalency cannot be interpreted
97     """
98     if equivalencies is None:
99         return []
100 
101     normalized = []
102 
103     for i, equiv in enumerate(equivalencies):
104         if len(equiv) == 2:
105             funit, tunit = equiv
106             a = b = lambda x: x
107         elif len(equiv) == 3:
108             funit, tunit, a = equiv
109             b = a
110         elif len(equiv) == 4:
111             funit, tunit, a, b = equiv
112         else:
113             raise ValueError(f"Invalid equivalence entry {i}: {equiv!r}")
114         if not (
115             funit is Unit(funit)
116             and (tunit is None or tunit is Unit(tunit))
117             and callable(a)
118             and callable(b)
119         ):
120             raise ValueError(f"Invalid equivalence entry {i}: {equiv!r}")
121         normalized.append((funit, tunit, a, b))
122 
123     return normalized
124 
125 
126 class _UnitRegistry:
127     """
128     Manages a registry of the enabled units.
129     """
130 
131     def __init__(self, init=[], equivalencies=[], aliases={}):
132         if isinstance(init, _UnitRegistry):
133             # If passed another registry we don't need to rebuild everything.
134             # but because these are mutable types we don't want to create
135             # conflicts so everything needs to be copied.
136             self._equivalencies = init._equivalencies.copy()
137             self._aliases = init._aliases.copy()
138             self._all_units = init._all_units.copy()
139             self._registry = init._registry.copy()
140             self._non_prefix_units = init._non_prefix_units.copy()
141             # The physical type is a dictionary containing sets as values.
142             # All of these must be copied otherwise we could alter the old
143             # registry.
144             self._by_physical_type = {
145                 k: v.copy() for k, v in init._by_physical_type.items()
146             }
147 
148         else:
149             self._reset_units()
150             self._reset_equivalencies()
151             self._reset_aliases()
152             self.add_enabled_units(init)
153             self.add_enabled_equivalencies(equivalencies)
154             self.add_enabled_aliases(aliases)
155 
156     def _reset_units(self):
157         self._all_units = set()
158         self._non_prefix_units = set()
159         self._registry = {}
160         self._by_physical_type = {}
161 
162     def _reset_equivalencies(self):
163         self._equivalencies = set()
164 
165     def _reset_aliases(self):
166         self._aliases = {}
167 
168     @property
169     def registry(self):
170         return self._registry
171 
172     @property
173     def all_units(self):
174         return self._all_units
175 
176     @property
177     def non_prefix_units(self):
178         return self._non_prefix_units
179 
180     def set_enabled_units(self, units):
181         """
182         Sets the units enabled in the unit registry.
183 
184         These units are searched when using
185         `UnitBase.find_equivalent_units`, for example.
186 
187         Parameters
188         ----------
189         units : list of sequence, dict, or module
190             This is a list of things in which units may be found
191             (sequences, dicts or modules), or units themselves.  The
192             entire set will be "enabled" for searching through by
193             methods like `UnitBase.find_equivalent_units` and
194             `UnitBase.compose`.
195         """
196         self._reset_units()
197         return self.add_enabled_units(units)
198 
199     def add_enabled_units(self, units):
200         """
201         Adds to the set of units enabled in the unit registry.
202 
203         These units are searched when using
204         `UnitBase.find_equivalent_units`, for example.
205 
206         Parameters
207         ----------
208         units : list of sequence, dict, or module
209             This is a list of things in which units may be found
210             (sequences, dicts or modules), or units themselves.  The
211             entire set will be added to the "enabled" set for
212             searching through by methods like
213             `UnitBase.find_equivalent_units` and `UnitBase.compose`.
214         """
215         units = _flatten_units_collection(units)
216 
217         for unit in units:
218             # Loop through all of the names first, to ensure all of them
219             # are new, then add them all as a single "transaction" below.
220             for st in unit._names:
221                 if st in self._registry and unit != self._registry[st]:
222                     raise ValueError(
223                         f"Object with name {st!r} already exists in namespace. "
224                         "Filter the set of units to avoid name clashes before "
225                         "enabling them."
226                     )
227 
228             for st in unit._names:
229                 self._registry[st] = unit
230 
231             self._all_units.add(unit)
232             if not isinstance(unit, PrefixUnit):
233                 self._non_prefix_units.add(unit)
234 
235             hash = unit._get_physical_type_id()
236             self._by_physical_type.setdefault(hash, set()).add(unit)
237 
238     def get_units_with_physical_type(self, unit):
239         """
240         Get all units in the registry with the same physical type as
241         the given unit.
242 
243         Parameters
244         ----------
245         unit : UnitBase instance
246         """
247         return self._by_physical_type.get(unit._get_physical_type_id(), set())
248 
249     @property
250     def equivalencies(self):
251         return list(self._equivalencies)
252 
253     def set_enabled_equivalencies(self, equivalencies):
254         """
255         Sets the equivalencies enabled in the unit registry.
256 
257         These equivalencies are used if no explicit equivalencies are given,
258         both in unit conversion and in finding equivalent units.
259 
260         This is meant in particular for allowing angles to be dimensionless.
261         Use with care.
262 
263         Parameters
264         ----------
265         equivalencies : list of tuple
266             List of equivalent pairs, e.g., as returned by
267             `~astropy.units.equivalencies.dimensionless_angles`.
268         """
269         self._reset_equivalencies()
270         return self.add_enabled_equivalencies(equivalencies)
271 
272     def add_enabled_equivalencies(self, equivalencies):
273         """
274         Adds to the set of equivalencies enabled in the unit registry.
275 
276         These equivalencies are used if no explicit equivalencies are given,
277         both in unit conversion and in finding equivalent units.
278 
279         This is meant in particular for allowing angles to be dimensionless.
280         Use with care.
281 
282         Parameters
283         ----------
284         equivalencies : list of tuple
285             List of equivalent pairs, e.g., as returned by
286             `~astropy.units.equivalencies.dimensionless_angles`.
287         """
288         # pre-normalize list to help catch mistakes
289         equivalencies = _normalize_equivalencies(equivalencies)
290         self._equivalencies |= set(equivalencies)
291 
292     @property
293     def aliases(self):
294         return self._aliases
295 
296     def set_enabled_aliases(self, aliases):
297         """
298         Set aliases for units.
299 
300         Parameters
301         ----------
302         aliases : dict of str, Unit
303             The aliases to set. The keys must be the string aliases, and values
304             must be the `astropy.units.Unit` that the alias will be mapped to.
305 
306         Raises
307         ------
308         ValueError
309             If the alias already defines a different unit.
310 
311         """
312         self._reset_aliases()
313         self.add_enabled_aliases(aliases)
314 
315     def add_enabled_aliases(self, aliases):
316         """
317         Add aliases for units.
318 
319         Parameters
320         ----------
321         aliases : dict of str, Unit
322             The aliases to add. The keys must be the string aliases, and values
323             must be the `astropy.units.Unit` that the alias will be mapped to.
324 
325         Raises
326         ------
327         ValueError
328             If the alias already defines a different unit.
329 
330         """
331         for alias, unit in aliases.items():
332             if alias in self._registry and unit != self._registry[alias]:
333                 raise ValueError(
334                     f"{alias} already means {self._registry[alias]}, so "
335                     f"cannot be used as an alias for {unit}."
336                 )
337             if alias in self._aliases and unit != self._aliases[alias]:
338                 raise ValueError(
339                     f"{alias} already is an alias for {self._aliases[alias]}, so "
340                     f"cannot be used as an alias for {unit}."
341                 )
342 
343         for alias, unit in aliases.items():
344             if alias not in self._registry and alias not in self._aliases:
345                 self._aliases[alias] = unit
346 
347 
348 class _UnitContext:
349     def __init__(self, init=[], equivalencies=[]):
350         _unit_registries.append(_UnitRegistry(init=init, equivalencies=equivalencies))
351 
352     def __enter__(self):
353         pass
354 
355     def __exit__(self, type, value, tb):
356         _unit_registries.pop()
357 
358 
359 _unit_registries = [_UnitRegistry()]
360 
361 
362 def get_current_unit_registry():
363     return _unit_registries[-1]
364 
365 
366 def set_enabled_units(units):
367     """
368     Sets the units enabled in the unit registry.
369 
370     These units are searched when using
371     `UnitBase.find_equivalent_units`, for example.
372 
373     This may be used either permanently, or as a context manager using
374     the ``with`` statement (see example below).
375 
376     Parameters
377     ----------
378     units : list of sequence, dict, or module
379         This is a list of things in which units may be found
380         (sequences, dicts or modules), or units themselves.  The
381         entire set will be "enabled" for searching through by methods
382         like `UnitBase.find_equivalent_units` and `UnitBase.compose`.
383 
384     Examples
385     --------
386     >>> from astropy import units as u
387     >>> with u.set_enabled_units([u.pc]):
388     ...     u.m.find_equivalent_units()
389     ...
390       Primary name | Unit definition | Aliases
391     [
392       pc           | 3.08568e+16 m   | parsec  ,
393     ]
394     >>> u.m.find_equivalent_units()
395       Primary name | Unit definition | Aliases
396     [
397       AU           | 1.49598e+11 m   | au, astronomical_unit            ,
398       Angstrom     | 1e-10 m         | AA, angstrom                     ,
399       cm           | 0.01 m          | centimeter                       ,
400       earthRad     | 6.3781e+06 m    | R_earth, Rearth                  ,
401       jupiterRad   | 7.1492e+07 m    | R_jup, Rjup, R_jupiter, Rjupiter ,
402       lsec         | 2.99792e+08 m   | lightsecond                      ,
403       lyr          | 9.46073e+15 m   | lightyear                        ,
404       m            | irreducible     | meter                            ,
405       micron       | 1e-06 m         |                                  ,
406       pc           | 3.08568e+16 m   | parsec                           ,
407       solRad       | 6.957e+08 m     | R_sun, Rsun                      ,
408     ]
409     """
410     # get a context with a new registry, using equivalencies of the current one
411     context = _UnitContext(equivalencies=get_current_unit_registry().equivalencies)
412     # in this new current registry, enable the units requested
413     get_current_unit_registry().set_enabled_units(units)
414     return context
415 
416 
417 def add_enabled_units(units):
418     """
419     Adds to the set of units enabled in the unit registry.
420 
421     These units are searched when using
422     `UnitBase.find_equivalent_units`, for example.
423 
424     This may be used either permanently, or as a context manager using
425     the ``with`` statement (see example below).
426 
427     Parameters
428     ----------
429     units : list of sequence, dict, or module
430         This is a list of things in which units may be found
431         (sequences, dicts or modules), or units themselves.  The
432         entire set will be added to the "enabled" set for searching
433         through by methods like `UnitBase.find_equivalent_units` and
434         `UnitBase.compose`.
435 
436     Examples
437     --------
438     >>> from astropy import units as u
439     >>> from astropy.units import imperial
440     >>> with u.add_enabled_units(imperial):
441     ...     u.m.find_equivalent_units()
442     ...
443       Primary name | Unit definition | Aliases
444     [
445       AU           | 1.49598e+11 m   | au, astronomical_unit            ,
446       Angstrom     | 1e-10 m         | AA, angstrom                     ,
447       cm           | 0.01 m          | centimeter                       ,
448       earthRad     | 6.3781e+06 m    | R_earth, Rearth                  ,
449       ft           | 0.3048 m        | foot                             ,
450       fur          | 201.168 m       | furlong                          ,
451       inch         | 0.0254 m        |                                  ,
452       jupiterRad   | 7.1492e+07 m    | R_jup, Rjup, R_jupiter, Rjupiter ,
453       lsec         | 2.99792e+08 m   | lightsecond                      ,
454       lyr          | 9.46073e+15 m   | lightyear                        ,
455       m            | irreducible     | meter                            ,
456       mi           | 1609.34 m       | mile                             ,
457       micron       | 1e-06 m         |                                  ,
458       mil          | 2.54e-05 m      | thou                             ,
459       nmi          | 1852 m          | nauticalmile, NM                 ,
460       pc           | 3.08568e+16 m   | parsec                           ,
461       solRad       | 6.957e+08 m     | R_sun, Rsun                      ,
462       yd           | 0.9144 m        | yard                             ,
463     ]
464     """
465     # get a context with a new registry, which is a copy of the current one
466     context = _UnitContext(get_current_unit_registry())
467     # in this new current registry, enable the further units requested
468     get_current_unit_registry().add_enabled_units(units)
469     return context
470 
471 
472 def set_enabled_equivalencies(equivalencies):
473     """
474     Sets the equivalencies enabled in the unit registry.
475 
476     These equivalencies are used if no explicit equivalencies are given,
477     both in unit conversion and in finding equivalent units.
478 
479     This is meant in particular for allowing angles to be dimensionless.
480     Use with care.
481 
482     Parameters
483     ----------
484     equivalencies : list of tuple
485         list of equivalent pairs, e.g., as returned by
486         `~astropy.units.equivalencies.dimensionless_angles`.
487 
488     Examples
489     --------
490     Exponentiation normally requires dimensionless quantities.  To avoid
491     problems with complex phases::
492 
493         >>> from astropy import units as u
494         >>> with u.set_enabled_equivalencies(u.dimensionless_angles()):
495         ...     phase = 0.5 * u.cycle
496         ...     np.exp(1j*phase)  # doctest: +FLOAT_CMP
497         <Quantity -1.+1.2246468e-16j>
498     """
499     # get a context with a new registry, using all units of the current one
500     context = _UnitContext(get_current_unit_registry())
501     # in this new current registry, enable the equivalencies requested
502     get_current_unit_registry().set_enabled_equivalencies(equivalencies)
503     return context
504 
505 
506 def add_enabled_equivalencies(equivalencies):
507     """
508     Adds to the equivalencies enabled in the unit registry.
509 
510     These equivalencies are used if no explicit equivalencies are given,
511     both in unit conversion and in finding equivalent units.
512 
513     This is meant in particular for allowing angles to be dimensionless.
514     Since no equivalencies are enabled by default, generally it is recommended
515     to use `set_enabled_equivalencies`.
516 
517     Parameters
518     ----------
519     equivalencies : list of tuple
520         list of equivalent pairs, e.g., as returned by
521         `~astropy.units.equivalencies.dimensionless_angles`.
522     """
523     # get a context with a new registry, which is a copy of the current one
524     context = _UnitContext(get_current_unit_registry())
525     # in this new current registry, enable the further equivalencies requested
526     get_current_unit_registry().add_enabled_equivalencies(equivalencies)
527     return context
528 
529 
530 def set_enabled_aliases(aliases):
531     """
532     Set aliases for units.
533 
534     This is useful for handling alternate spellings for units, or
535     misspelled units in files one is trying to read.
536 
537     Parameters
538     ----------
539     aliases : dict of str, Unit
540         The aliases to set. The keys must be the string aliases, and values
541         must be the `astropy.units.Unit` that the alias will be mapped to.
542 
543     Raises
544     ------
545     ValueError
546         If the alias already defines a different unit.
547 
548     Examples
549     --------
550     To temporarily allow for a misspelled 'Angstroem' unit::
551 
552         >>> from astropy import units as u
553         >>> with u.set_enabled_aliases({'Angstroem': u.Angstrom}):
554         ...     print(u.Unit("Angstroem", parse_strict="raise") == u.Angstrom)
555         True
556 
557     """
558     # get a context with a new registry, which is a copy of the current one
559     context = _UnitContext(get_current_unit_registry())
560     # in this new current registry, enable the further equivalencies requested
561     get_current_unit_registry().set_enabled_aliases(aliases)
562     return context
563 
564 
565 def add_enabled_aliases(aliases):
566     """
567     Add aliases for units.
568 
569     This is useful for handling alternate spellings for units, or
570     misspelled units in files one is trying to read.
571 
572     Since no aliases are enabled by default, generally it is recommended
573     to use `set_enabled_aliases`.
574 
575     Parameters
576     ----------
577     aliases : dict of str, Unit
578         The aliases to add. The keys must be the string aliases, and values
579         must be the `astropy.units.Unit` that the alias will be mapped to.
580 
581     Raises
582     ------
583     ValueError
584         If the alias already defines a different unit.
585 
586     Examples
587     --------
588     To temporarily allow for a misspelled 'Angstroem' unit::
589 
590         >>> from astropy import units as u
591         >>> with u.add_enabled_aliases({'Angstroem': u.Angstrom}):
592         ...     print(u.Unit("Angstroem", parse_strict="raise") == u.Angstrom)
593         True
594 
595     """
596     # get a context with a new registry, which is a copy of the current one
597     context = _UnitContext(get_current_unit_registry())
598     # in this new current registry, enable the further equivalencies requested
599     get_current_unit_registry().add_enabled_aliases(aliases)
600     return context
601 
602 
603 class UnitsError(Exception):
604     """
605     The base class for unit-specific exceptions.
606     """
607 
608 
609 class UnitScaleError(UnitsError, ValueError):
610     """
611     Used to catch the errors involving scaled units,
612     which are not recognized by FITS format.
613     """
614 
615     pass
616 
617 
618 class UnitConversionError(UnitsError, ValueError):
619     """
620     Used specifically for errors related to converting between units or
621     interpreting units in terms of other units.
622     """
623 
624 
625 class UnitTypeError(UnitsError, TypeError):
626     """
627     Used specifically for errors in setting to units not allowed by a class.
628 
629     E.g., would be raised if the unit of an `~astropy.coordinates.Angle`
630     instances were set to a non-angular unit.
631     """
632 
633 
634 class UnitsWarning(AstropyWarning):
635     """
636     The base class for unit-specific warnings.
637     """
638 
639 
640 class UnitBase:
641     """
642     Abstract base class for units.
643 
644     Most of the arithmetic operations on units are defined in this
645     base class.
646 
647     Should not be instantiated by users directly.
648     """
649 
650     # Make sure that __rmul__ of units gets called over the __mul__ of Numpy
651     # arrays to avoid element-wise multiplication.
652     __array_priority__ = 1000
653 
654     _hash = None
655     _type_id = None
656 
657     def __deepcopy__(self, memo):
658         # This may look odd, but the units conversion will be very
659         # broken after deep-copying if we don't guarantee that a given
660         # physical unit corresponds to only one instance
661         return self
662 
663     def _repr_latex_(self):
664         """
665         Generate latex representation of unit name.  This is used by
666         the IPython notebook to print a unit with a nice layout.
667 
668         Returns
669         -------
670         Latex string
671         """
672         return unit_format.Latex.to_string(self)
673 
674     def __bytes__(self):
675         """Return string representation for unit."""
676         return unit_format.Generic.to_string(self).encode("unicode_escape")
677 
678     def __str__(self):
679         """Return string representation for unit."""
680         return unit_format.Generic.to_string(self)
681 
682     def __repr__(self):
683         string = unit_format.Generic.to_string(self)
684 
685         return f'Unit("{string}")'
686 
687     def _get_physical_type_id(self):
688         """
689         Returns an identifier that uniquely identifies the physical
690         type of this unit.  It is comprised of the bases and powers of
691         this unit, without the scale.  Since it is hashable, it is
692         useful as a dictionary key.
693         """
694         if self._type_id is None:
695             unit = self.decompose()
696             self._type_id = tuple(zip((base.name for base in unit.bases), unit.powers))
697 
698         return self._type_id
699 
700     @property
701     def names(self):
702         """
703         Returns all of the names associated with this unit.
704         """
705         raise AttributeError(
706             "Can not get names from unnamed units. Perhaps you meant to_string()?"
707         )
708 
709     @property
710     def name(self):
711         """
712         Returns the canonical (short) name associated with this unit.
713         """
714         raise AttributeError(
715             "Can not get names from unnamed units. Perhaps you meant to_string()?"
716         )
717 
718     @property
719     def aliases(self):
720         """
721         Returns the alias (long) names for this unit.
722         """
723         raise AttributeError(
724             "Can not get aliases from unnamed units. Perhaps you meant to_string()?"
725         )
726 
727     @property
728     def scale(self):
729         """
730         Return the scale of the unit.
731         """
732         return 1.0
733 
734     @property
735     def bases(self):
736         """
737         Return the bases of the unit.
738         """
739         return [self]
740 
741     @property
742     def powers(self):
743         """
744         Return the powers of the unit.
745         """
746         return [1]
747 
748     def to_string(self, format=unit_format.Generic, **kwargs):
749         """Output the unit in the given format as a string.
750 
751         Parameters
752         ----------
753         format : `astropy.units.format.Base` instance or str
754             The name of a format or a formatter object.  If not
755             provided, defaults to the generic format.
756 
757         **kwargs :
758             Further options forwarded to the formatter. Currently
759             recognized is **inline** (:class:`bool`) for the
760             ``"latex"``, ``"console"``, and``"unicode"`` formats.
761 
762         """
763         f = unit_format.get_format(format)
764         return f.to_string(self, **kwargs)
765 
766     def __format__(self, format_spec):
767         """Try to format units using a formatter."""
768         try:
769             return self.to_string(format=format_spec)
770         except ValueError:
771             return format(str(self), format_spec)
772 
773     @staticmethod
774     def _normalize_equivalencies(equivalencies):
775         """Normalizes equivalencies, ensuring each is a 4-tuple.
776 
777         The resulting tuple is of the form::
778 
779             (from_unit, to_unit, forward_func, backward_func)
780 
781         Parameters
782         ----------
783         equivalencies : list of equivalency pairs, or None
784 
785         Returns
786         -------
787         A normalized list, including possible global defaults set by, e.g.,
788         `set_enabled_equivalencies`, except when `equivalencies`=`None`,
789         in which case the returned list is always empty.
790 
791         Raises
792         ------
793         ValueError if an equivalency cannot be interpreted
794         """
795         normalized = _normalize_equivalencies(equivalencies)
796         if equivalencies is not None:
797             normalized += get_current_unit_registry().equivalencies
798 
799         return normalized
800 
801     def __pow__(self, p):
802         p = validate_power(p)
803         return CompositeUnit(1, [self], [p], _error_check=False)
804 
805     def __truediv__(self, m):
806         if isinstance(m, (bytes, str)):
807             m = Unit(m)
808 
809         if isinstance(m, UnitBase):
810             if m.is_unity():
811                 return self
812             return CompositeUnit(1, [self, m], [1, -1], _error_check=False)
813 
814         try:
815             # Cannot handle this as Unit, re-try as Quantity
816             from .quantity import Quantity
817 
818             return Quantity(1, self) / m
819         except TypeError:
820             return NotImplemented
821 
822     def __rtruediv__(self, m):
823         if isinstance(m, (bytes, str)):
824             return Unit(m) / self
825 
826         try:
827             # Cannot handle this as Unit.  Here, m cannot be a Quantity,
828             # so we make it into one, fasttracking when it does not have a
829             # unit, for the common case of <array> / <unit>.
830             from .quantity import Quantity
831 
832             if hasattr(m, "unit"):
833                 result = Quantity(m)
834                 result /= self
835                 return result
836             else:
837                 return Quantity(m, self ** (-1))
838         except TypeError:
839             return NotImplemented
840 
841     def __mul__(self, m):
842         if isinstance(m, (bytes, str)):
843             m = Unit(m)
844 
845         if isinstance(m, UnitBase):
846             if m.is_unity():
847                 return self
848             elif self.is_unity():
849                 return m
850             return CompositeUnit(1, [self, m], [1, 1], _error_check=False)
851 
852         # Cannot handle this as Unit, re-try as Quantity.
853         try:
854             from .quantity import Quantity
855 
856             return Quantity(1, unit=self) * m
857         except TypeError:
858             return NotImplemented
859 
860     def __rmul__(self, m):
861         if isinstance(m, (bytes, str)):
862             return Unit(m) * self
863 
864         # Cannot handle this as Unit.  Here, m cannot be a Quantity,
865         # so we make it into one, fasttracking when it does not have a unit
866         # for the common case of <array> * <unit>.
867         try:
868             from .quantity import Quantity
869 
870             if hasattr(m, "unit"):
871                 result = Quantity(m)
872                 result *= self
873                 return result
874             else:
875                 return Quantity(m, unit=self)
876         except TypeError:
877             return NotImplemented
878 
879     def __rlshift__(self, m):
880         try:
881             from .quantity import Quantity
882 
883             return Quantity(m, self, copy=False, subok=True)
884         except Exception:
885             return NotImplemented
886 
887     def __rrshift__(self, m):
888         warnings.warn(
889             ">> is not implemented. Did you mean to convert "
890             f"to a Quantity with unit {m} using '<<'?",
891             AstropyWarning,
892         )
893         return NotImplemented
894 
895     def __hash__(self):
896         if self._hash is None:
897             parts = (
898                 [str(self.scale)]
899                 + [x.name for x in self.bases]
900                 + [str(x) for x in self.powers]
901             )
902             self._hash = hash(tuple(parts))
903         return self._hash
904 
905     def __getstate__(self):
906         # If we get pickled, we should *not* store the memoized members since
907         # hashes of strings vary between sessions.
908         state = self.__dict__.copy()
909         state.pop("_hash", None)
910         state.pop("_type_id", None)
911         return state
912 
913     def __eq__(self, other):
914         if self is other:
915             return True
916 
917         try:
918             other = Unit(other, parse_strict="silent")
919         except (ValueError, UnitsError, TypeError):
920             return NotImplemented
921 
922         # Other is unit-like, but the test below requires it is a UnitBase
923         # instance; if it is not, give up (so that other can try).
924         if not isinstance(other, UnitBase):
925             return NotImplemented
926 
927         try:
928             return is_effectively_unity(self._to(other))
929         except UnitsError:
930             return False
931 
932     def __ne__(self, other):
933         return not (self == other)
934 
935     def __le__(self, other):
936         scale = self._to(Unit(other))
937         return scale <= 1.0 or is_effectively_unity(scale)
938 
939     def __ge__(self, other):
940         scale = self._to(Unit(other))
941         return scale >= 1.0 or is_effectively_unity(scale)
942 
943     def __lt__(self, other):
944         return not (self >= other)
945 
946     def __gt__(self, other):
947         return not (self <= other)
948 
949     def __neg__(self):
950         return self * -1.0
951 
952     def is_equivalent(self, other, equivalencies=[]):
953         """
954         Returns `True` if this unit is equivalent to ``other``.
955 
956         Parameters
957         ----------
958         other : `~astropy.units.Unit`, str, or tuple
959             The unit to convert to. If a tuple of units is specified, this
960             method returns true if the unit matches any of those in the tuple.
961 
962         equivalencies : list of tuple
963             A list of equivalence pairs to try if the units are not
964             directly convertible.  See :ref:`astropy:unit_equivalencies`.
965             This list is in addition to possible global defaults set by, e.g.,
966             `set_enabled_equivalencies`.
967             Use `None` to turn off all equivalencies.
968 
969         Returns
970         -------
971         bool
972         """
973         equivalencies = self._normalize_equivalencies(equivalencies)
974 
975         if isinstance(other, tuple):
976             return any(self.is_equivalent(u, equivalencies) for u in other)
977 
978         other = Unit(other, parse_strict="silent")
979 
980         return self._is_equivalent(other, equivalencies)
981 
982     def _is_equivalent(self, other, equivalencies=[]):
983         """Returns `True` if this unit is equivalent to `other`.
984         See `is_equivalent`, except that a proper Unit object should be
985         given (i.e., no string) and that the equivalency list should be
986         normalized using `_normalize_equivalencies`.
987         """
988         if isinstance(other, UnrecognizedUnit):
989             return False
990 
991         if self._get_physical_type_id() == other._get_physical_type_id():
992             return True
993         elif len(equivalencies):
994             unit = self.decompose()
995             other = other.decompose()
996             for a, b, forward, backward in equivalencies:
997                 if b is None:
998                     # after canceling, is what's left convertible
999                     # to dimensionless (according to the equivalency)?
1000                     try:
1001                         (other / unit).decompose([a])
1002                         return True
1003                     except Exception:
1004                         pass
1005                 elif (a._is_equivalent(unit) and b._is_equivalent(other)) or (
1006                     b._is_equivalent(unit) and a._is_equivalent(other)
1007                 ):
1008                     return True
1009 
1010         return False
1011 
1012     def _apply_equivalencies(self, unit, other, equivalencies):
1013         """
1014         Internal function (used from `_get_converter`) to apply
1015         equivalence pairs.
1016         """
1017 
1018         def make_converter(scale1, func, scale2):
1019             def convert(v):
1020                 return func(_condition_arg(v) / scale1) * scale2
1021 
1022             return convert
1023 
1024         for funit, tunit, a, b in equivalencies:
1025             if tunit is None:
1026                 ratio = other.decompose() / unit.decompose()
1027                 try:
1028                     ratio_in_funit = ratio.decompose([funit])
1029                     return make_converter(ratio_in_funit.scale, a, 1.0)
1030                 except UnitsError:
1031                     pass
1032             else:
1033                 try:
1034                     scale1 = funit._to(unit)
1035                     scale2 = tunit._to(other)
1036                     return make_converter(scale1, a, scale2)
1037                 except UnitsError:
1038                     pass
1039                 try:
1040                     scale1 = tunit._to(unit)
1041                     scale2 = funit._to(other)
1042                     return make_converter(scale1, b, scale2)
1043                 except UnitsError:
1044                     pass
1045 
1046         def get_err_str(unit):
1047             unit_str = unit.to_string("unscaled")
1048             physical_type = unit.physical_type
1049             if physical_type != "unknown":
1050                 unit_str = f"'{unit_str}' ({physical_type})"
1051             else:
1052                 unit_str = f"'{unit_str}'"
1053             return unit_str
1054 
1055         unit_str = get_err_str(unit)
1056         other_str = get_err_str(other)
1057 
1058         raise UnitConversionError(f"{unit_str} and {other_str} are not convertible")
1059 
1060     def _get_converter(self, other, equivalencies=[]):
1061         """Get a converter for values in ``self`` to ``other``.
1062 
1063         If no conversion is necessary, returns ``unit_scale_converter``
1064         (which is used as a check in quantity helpers).
1065 
1066         """
1067         # First see if it is just a scaling.
1068         try:
1069             scale = self._to(other)
1070         except UnitsError:
1071             pass
1072         else:
1073             if scale == 1.0:
1074                 return unit_scale_converter
1075             else:
1076                 return lambda val: scale * _condition_arg(val)
1077 
1078         # if that doesn't work, maybe we can do it with equivalencies?
1079         try:
1080             return self._apply_equivalencies(
1081                 self, other, self._normalize_equivalencies(equivalencies)
1082             )
1083         except UnitsError as exc:
1084             # Last hope: maybe other knows how to do it?
1085             # We assume the equivalencies have the unit itself as first item.
1086             # TODO: maybe better for other to have a `_back_converter` method?
1087             if hasattr(other, "equivalencies"):
1088                 for funit, tunit, a, b in other.equivalencies:
1089                     if other is funit:
1090                         try:
1091                             converter = self._get_converter(tunit, equivalencies)
1092                         except Exception:
1093                             pass
1094                         else:
1095                             return lambda v: b(converter(v))
1096 
1097             raise exc
1098 
1099     def _to(self, other):
1100         """
1101         Returns the scale to the specified unit.
1102 
1103         See `to`, except that a Unit object should be given (i.e., no
1104         string), and that all defaults are used, i.e., no
1105         equivalencies and value=1.
1106         """
1107         # There are many cases where we just want to ensure a Quantity is
1108         # of a particular unit, without checking whether it's already in
1109         # a particular unit.  If we're being asked to convert from a unit
1110         # to itself, we can short-circuit all of this.
1111         if self is other:
1112             return 1.0
1113 
1114         # Don't presume decomposition is possible; e.g.,
1115         # conversion to function units is through equivalencies.
1116         if isinstance(other, UnitBase):
1117             self_decomposed = self.decompose()
1118             other_decomposed = other.decompose()
1119 
1120             # Check quickly whether equivalent.  This is faster than
1121             # `is_equivalent`, because it doesn't generate the entire
1122             # physical type list of both units.  In other words it "fails
1123             # fast".
1124             if self_decomposed.powers == other_decomposed.powers and all(
1125                 self_base is other_base
1126                 for (self_base, other_base) in zip(
1127                     self_decomposed.bases, other_decomposed.bases
1128                 )
1129             ):
1130                 return self_decomposed.scale / other_decomposed.scale
1131 
1132         raise UnitConversionError(f"'{self!r}' is not a scaled version of '{other!r}'")
1133 
1134     def to(self, other, value=UNITY, equivalencies=[]):
1135         """
1136         Return the converted values in the specified unit.
1137 
1138         Parameters
1139         ----------
1140         other : unit-like
1141             The unit to convert to.
1142 
1143         value : int, float, or scalar array-like, optional
1144             Value(s) in the current unit to be converted to the
1145             specified unit.  If not provided, defaults to 1.0
1146 
1147         equivalencies : list of tuple
1148             A list of equivalence pairs to try if the units are not
1149             directly convertible.  See :ref:`astropy:unit_equivalencies`.
1150             This list is in addition to possible global defaults set by, e.g.,
1151             `set_enabled_equivalencies`.
1152             Use `None` to turn off all equivalencies.
1153 
1154         Returns
1155         -------
1156         values : scalar or array
1157             Converted value(s). Input value sequences are returned as
1158             numpy arrays.
1159 
1160         Raises
1161         ------
1162         UnitsError
1163             If units are inconsistent
1164         """
1165         if other is self and value is UNITY:
1166             return UNITY
1167         else:
1168             return self._get_converter(Unit(other), equivalencies)(value)
1169 
1170     def in_units(self, other, value=1.0, equivalencies=[]):
1171         """
1172         Alias for `to` for backward compatibility with pynbody.
1173         """
1174         return self.to(other, value=value, equivalencies=equivalencies)
1175 
1176     def decompose(self, bases=set()):
1177         """
1178         Return a unit object composed of only irreducible units.
1179 
1180         Parameters
1181         ----------
1182         bases : sequence of UnitBase, optional
1183             The bases to decompose into.  When not provided,
1184             decomposes down to any irreducible units.  When provided,
1185             the decomposed result will only contain the given units.
1186             This will raises a `UnitsError` if it's not possible
1187             to do so.
1188 
1189         Returns
1190         -------
1191         unit : `~astropy.units.CompositeUnit`
1192             New object containing only irreducible unit objects.
1193         """
1194         raise NotImplementedError()
1195 
1196     def _compose(
1197         self, equivalencies=[], namespace=[], max_depth=2, depth=0, cached_results=None
1198     ):
1199         def is_final_result(unit):
1200             # Returns True if this result contains only the expected
1201             # units
1202             return all(base in namespace for base in unit.bases)
1203 
1204         unit = self.decompose()
1205         key = hash(unit)
1206 
1207         cached = cached_results.get(key)
1208         if cached is not None:
1209             if isinstance(cached, Exception):
1210                 raise cached
1211             return cached
1212 
1213         # Prevent too many levels of recursion
1214         # And special case for dimensionless unit
1215         if depth >= max_depth:
1216             cached_results[key] = [unit]
1217             return [unit]
1218 
1219         # Make a list including all of the equivalent units
1220         units = [unit]
1221         for funit, tunit, a, b in equivalencies:
1222             if tunit is not None:
1223                 if self._is_equivalent(funit):
1224                     scale = funit.decompose().scale / unit.scale
1225                     units.append(Unit(a(1.0 / scale) * tunit).decompose())
1226                 elif self._is_equivalent(tunit):
1227                     scale = tunit.decompose().scale / unit.scale
1228                     units.append(Unit(b(1.0 / scale) * funit).decompose())
1229             else:
1230                 if self._is_equivalent(funit):
1231                     units.append(Unit(unit.scale))
1232 
1233         # Store partial results
1234         partial_results = []
1235         # Store final results that reduce to a single unit or pair of
1236         # units
1237         if len(unit.bases) == 0:
1238             final_results = [{unit}, set()]
1239         else:
1240             final_results = [set(), set()]
1241 
1242         for tunit in namespace:
1243             tunit_decomposed = tunit.decompose()
1244             for u in units:
1245                 # If the unit is a base unit, look for an exact match
1246                 # to one of the bases of the target unit.  If found,
1247                 # factor by the same power as the target unit's base.
1248                 # This allows us to factor out fractional powers
1249                 # without needing to do an exhaustive search.
1250                 if len(tunit_decomposed.bases) == 1:
1251                     for base, power in zip(u.bases, u.powers):
1252                         if tunit_decomposed._is_equivalent(base):
1253                             tunit = tunit**power
1254                             tunit_decomposed = tunit_decomposed**power
1255                             break
1256 
1257                 composed = (u / tunit_decomposed).decompose()
1258                 factored = composed * tunit
1259                 len_bases = len(composed.bases)
1260                 if is_final_result(factored) and len_bases <= 1:
1261                     final_results[len_bases].add(factored)
1262                 else:
1263                     partial_results.append((len_bases, composed, tunit))
1264 
1265         # Do we have any minimal results?
1266         for final_result in final_results:
1267             if len(final_result):
1268                 results = final_results[0].union(final_results[1])
1269                 cached_results[key] = results
1270                 return results
1271 
1272         partial_results.sort(key=operator.itemgetter(0))
1273 
1274         # ...we have to recurse and try to further compose
1275         results = []
1276         for len_bases, composed, tunit in partial_results:
1277             try:
1278                 composed_list = composed._compose(
1279                     equivalencies=equivalencies,
1280                     namespace=namespace,
1281                     max_depth=max_depth,
1282                     depth=depth + 1,
1283                     cached_results=cached_results,
1284                 )
1285             except UnitsError:
1286                 composed_list = []
1287             for subcomposed in composed_list:
1288                 results.append((len(subcomposed.bases), subcomposed, tunit))
1289 
1290         if len(results):
1291             results.sort(key=operator.itemgetter(0))
1292 
1293             min_length = results[0][0]
1294             subresults = set()
1295             for len_bases, composed, tunit in results:
1296                 if len_bases > min_length:
1297                     break
1298                 else:
1299                     factored = composed * tunit
1300                     if is_final_result(factored):
1301                         subresults.add(factored)
1302 
1303             if len(subresults):
1304                 cached_results[key] = subresults
1305                 return subresults
1306 
1307         if not is_final_result(self):
1308             result = UnitsError(
1309                 f"Cannot represent unit {self} in terms of the given units"
1310             )
1311             cached_results[key] = result
1312             raise result
1313 
1314         cached_results[key] = [self]
1315         return [self]
1316 
1317     def compose(
1318         self, equivalencies=[], units=None, max_depth=2, include_prefix_units=None
1319     ):
1320         """
1321         Return the simplest possible composite unit(s) that represent
1322         the given unit.  Since there may be multiple equally simple
1323         compositions of the unit, a list of units is always returned.
1324 
1325         Parameters
1326         ----------
1327         equivalencies : list of tuple
1328             A list of equivalence pairs to also list.  See
1329             :ref:`astropy:unit_equivalencies`.
1330             This list is in addition to possible global defaults set by, e.g.,
1331             `set_enabled_equivalencies`.
1332             Use `None` to turn off all equivalencies.
1333 
1334         units : set of `~astropy.units.Unit`, optional
1335             If not provided, any known units may be used to compose
1336             into.  Otherwise, ``units`` is a dict, module or sequence
1337             containing the units to compose into.
1338 
1339         max_depth : int, optional
1340             The maximum recursion depth to use when composing into
1341             composite units.
1342 
1343         include_prefix_units : bool, optional
1344             When `True`, include prefixed units in the result.
1345             Default is `True` if a sequence is passed in to ``units``,
1346             `False` otherwise.
1347 
1348         Returns
1349         -------
1350         units : list of `CompositeUnit`
1351             A list of candidate compositions.  These will all be
1352             equally simple, but it may not be possible to
1353             automatically determine which of the candidates are
1354             better.
1355         """
1356         # if units parameter is specified and is a sequence (list|tuple),
1357         # include_prefix_units is turned on by default.  Ex: units=[u.kpc]
1358         if include_prefix_units is None:
1359             include_prefix_units = isinstance(units, (list, tuple))
1360 
1361         # Pre-normalize the equivalencies list
1362         equivalencies = self._normalize_equivalencies(equivalencies)
1363 
1364         # The namespace of units to compose into should be filtered to
1365         # only include units with bases in common with self, otherwise
1366         # they can't possibly provide useful results.  Having too many
1367         # destination units greatly increases the search space.
1368 
1369         def has_bases_in_common(a, b):
1370             if len(a.bases) == 0 and len(b.bases) == 0:
1371                 return True
1372             for ab in a.bases:
1373                 for bb in b.bases:
1374                     if ab == bb:
1375                         return True
1376             return False
1377 
1378         def has_bases_in_common_with_equiv(unit, other):
1379             if has_bases_in_common(unit, other):
1380                 return True
1381             for funit, tunit, a, b in equivalencies:
1382                 if tunit is not None:
1383                     if unit._is_equivalent(funit):
1384                         if has_bases_in_common(tunit.decompose(), other):
1385                             return True
1386                     elif unit._is_equivalent(tunit):
1387                         if has_bases_in_common(funit.decompose(), other):
1388                             return True
1389                 else:
1390                     if unit._is_equivalent(funit):
1391                         if has_bases_in_common(dimensionless_unscaled, other):
1392                             return True
1393             return False
1394 
1395         def filter_units(units):
1396             filtered_namespace = set()
1397             for tunit in units:
1398                 if (
1399                     isinstance(tunit, UnitBase)
1400                     and (include_prefix_units or not isinstance(tunit, PrefixUnit))
1401                     and has_bases_in_common_with_equiv(decomposed, tunit.decompose())
1402                 ):
1403                     filtered_namespace.add(tunit)
1404             return filtered_namespace
1405 
1406         decomposed = self.decompose()
1407 
1408         if units is None:
1409             units = filter_units(self._get_units_with_same_physical_type(equivalencies))
1410             if len(units) == 0:
1411                 units = get_current_unit_registry().non_prefix_units
1412         elif isinstance(units, dict):
1413             units = set(filter_units(units.values()))
1414         elif inspect.ismodule(units):
1415             units = filter_units(vars(units).values())
1416         else:
1417             units = filter_units(_flatten_units_collection(units))
1418 
1419         def sort_results(results):
1420             if not len(results):
1421                 return []
1422 
1423             # Sort the results so the simplest ones appear first.
1424             # Simplest is defined as "the minimum sum of absolute
1425             # powers" (i.e. the fewest bases), and preference should
1426             # be given to results where the sum of powers is positive
1427             # and the scale is exactly equal to 1.0
1428             results = list(results)
1429             results.sort(key=lambda x: np.abs(x.scale))
1430             results.sort(key=lambda x: np.sum(np.abs(x.powers)))
1431             results.sort(key=lambda x: np.sum(x.powers) < 0.0)
1432             results.sort(key=lambda x: not is_effectively_unity(x.scale))
1433 
1434             last_result = results[0]
1435             filtered = [last_result]
1436             for result in results[1:]:
1437                 if str(result) != str(last_result):
1438                     filtered.append(result)
1439                 last_result = result
1440 
1441             return filtered
1442 
1443         return sort_results(
1444             self._compose(
1445                 equivalencies=equivalencies,
1446                 namespace=units,
1447                 max_depth=max_depth,
1448                 depth=0,
1449                 cached_results={},
1450             )
1451         )
1452 
1453     def to_system(self, system):
1454         """
1455         Converts this unit into ones belonging to the given system.
1456         Since more than one result may be possible, a list is always
1457         returned.
1458 
1459         Parameters
1460         ----------
1461         system : module
1462             The module that defines the unit system.  Commonly used
1463             ones include `astropy.units.si` and `astropy.units.cgs`.
1464 
1465             To use your own module it must contain unit objects and a
1466             sequence member named ``bases`` containing the base units of
1467             the system.
1468 
1469         Returns
1470         -------
1471         units : list of `CompositeUnit`
1472             The list is ranked so that units containing only the base
1473             units of that system will appear first.
1474         """
1475         bases = set(system.bases)
1476 
1477         def score(compose):
1478             # In case that compose._bases has no elements we return
1479             # 'np.inf' as 'score value'.  It does not really matter which
1480             # number we would return. This case occurs for instance for
1481             # dimensionless quantities:
1482             compose_bases = compose.bases
1483             if len(compose_bases) == 0:
1484                 return np.inf
1485             else:
1486                 sum = 0
1487                 for base in compose_bases:
1488                     if base in bases:
1489                         sum += 1
1490 
1491                 return sum / float(len(compose_bases))
1492 
1493         x = self.decompose(bases=bases)
1494         composed = x.compose(units=system)
1495         composed = sorted(composed, key=score, reverse=True)
1496         return composed
1497 
1498     @lazyproperty
1499     def si(self):
1500         """
1501         Returns a copy of the current `Unit` instance in SI units.
1502         """
1503         from . import si
1504 
1505         return self.to_system(si)[0]
1506 
1507     @lazyproperty
1508     def cgs(self):
1509         """
1510         Returns a copy of the current `Unit` instance with CGS units.
1511         """
1512         from . import cgs
1513 
1514         return self.to_system(cgs)[0]
1515 
1516     @property
1517     def physical_type(self):
1518         """
1519         Physical type(s) dimensionally compatible with the unit.
1520 
1521         Returns
1522         -------
1523         `~astropy.units.physical.PhysicalType`
1524             A representation of the physical type(s) of a unit.
1525 
1526         Examples
1527         --------
1528         >>> from astropy import units as u
1529         >>> u.m.physical_type
1530         PhysicalType('length')
1531         >>> (u.m ** 2 / u.s).physical_type
1532         PhysicalType({'diffusivity', 'kinematic viscosity'})
1533 
1534         Physical types can be compared to other physical types
1535         (recommended in packages) or to strings.
1536 
1537         >>> area = (u.m ** 2).physical_type
1538         >>> area == u.m.physical_type ** 2
1539         True
1540         >>> area == "area"
1541         True
1542 
1543         `~astropy.units.physical.PhysicalType` objects can be used for
1544         dimensional analysis.
1545 
1546         >>> number_density = u.m.physical_type ** -3
1547         >>> velocity = (u.m / u.s).physical_type
1548         >>> number_density * velocity
1549         PhysicalType('particle flux')
1550         """
1551         from . import physical
1552 
1553         return physical.get_physical_type(self)
1554 
1555     def _get_units_with_same_physical_type(self, equivalencies=[]):
1556         """
1557         Return a list of registered units with the same physical type
1558         as this unit.
1559 
1560         This function is used by Quantity to add its built-in
1561         conversions to equivalent units.
1562 
1563         This is a private method, since end users should be encouraged
1564         to use the more powerful `compose` and `find_equivalent_units`
1565         methods (which use this under the hood).
1566 
1567         Parameters
1568         ----------
1569         equivalencies : list of tuple
1570             A list of equivalence pairs to also pull options from.
1571             See :ref:`astropy:unit_equivalencies`.  It must already be
1572             normalized using `_normalize_equivalencies`.
1573         """
1574         unit_registry = get_current_unit_registry()
1575         units = set(unit_registry.get_units_with_physical_type(self))
1576         for funit, tunit, a, b in equivalencies:
1577             if tunit is not None:
1578                 if self.is_equivalent(funit) and tunit not in units:
1579                     units.update(unit_registry.get_units_with_physical_type(tunit))
1580                 if self._is_equivalent(tunit) and funit not in units:
1581                     units.update(unit_registry.get_units_with_physical_type(funit))
1582             else:
1583                 if self.is_equivalent(funit):
1584                     units.add(dimensionless_unscaled)
1585         return units
1586 
1587     class EquivalentUnitsList(list):
1588         """
1589         A class to handle pretty-printing the result of
1590         `find_equivalent_units`.
1591         """
1592 
1593         HEADING_NAMES = ("Primary name", "Unit definition", "Aliases")
1594         ROW_LEN = 3  # len(HEADING_NAMES), but hard-code since it is constant
1595         NO_EQUIV_UNITS_MSG = "There are no equivalent units"
1596 
1597         def __repr__(self):
1598             if len(self) == 0:
1599                 return self.NO_EQUIV_UNITS_MSG
1600             else:
1601                 lines = self._process_equivalent_units(self)
1602                 lines.insert(0, self.HEADING_NAMES)
1603                 widths = [0] * self.ROW_LEN
1604                 for line in lines:
1605                     for i, col in enumerate(line):
1606                         widths[i] = max(widths[i], len(col))
1607 
1608                 f = "  {{0:<{}s}} | {{1:<{}s}} | {{2:<{}s}}".format(*widths)
1609                 lines = [f.format(*line) for line in lines]
1610                 lines = lines[0:1] + ["["] + [f"{x} ," for x in lines[1:]] + ["]"]
1611                 return "\n".join(lines)
1612 
1613         def _repr_html_(self):
1614             """
1615             Outputs a HTML table representation within Jupyter notebooks.
1616             """
1617             if len(self) == 0:
1618                 return f"<p>{self.NO_EQUIV_UNITS_MSG}</p>"
1619             else:
1620                 # HTML tags to use to compose the table in HTML
1621                 blank_table = '<table style="width:50%">{}</table>'
1622                 blank_row_container = "<tr>{}</tr>"
1623                 heading_row_content = "<th>{}</th>" * self.ROW_LEN
1624                 data_row_content = "<td>{}</td>" * self.ROW_LEN
1625 
1626                 # The HTML will be rendered & the table is simple, so don't
1627                 # bother to include newlines & indentation for the HTML code.
1628                 heading_row = blank_row_container.format(
1629                     heading_row_content.format(*self.HEADING_NAMES)
1630                 )
1631                 data_rows = self._process_equivalent_units(self)
1632                 all_rows = heading_row
1633                 for row in data_rows:
1634                     html_row = blank_row_container.format(data_row_content.format(*row))
1635                     all_rows += html_row
1636                 return blank_table.format(all_rows)
1637 
1638         @staticmethod
1639         def _process_equivalent_units(equiv_units_data):
1640             """
1641             Extract attributes, and sort, the equivalent units pre-formatting.
1642             """
1643             processed_equiv_units = []
1644             for u in equiv_units_data:
1645                 irred = u.decompose().to_string()
1646                 if irred == u.name:
1647                     irred = "irreducible"
1648                 processed_equiv_units.append((u.name, irred, ", ".join(u.aliases)))
1649             processed_equiv_units.sort()
1650             return processed_equiv_units
1651 
1652     def find_equivalent_units(
1653         self, equivalencies=[], units=None, include_prefix_units=False
1654     ):
1655         """
1656         Return a list of all the units that are the same type as ``self``.
1657 
1658         Parameters
1659         ----------
1660         equivalencies : list of tuple
1661             A list of equivalence pairs to also list.  See
1662             :ref:`astropy:unit_equivalencies`.
1663             Any list given, including an empty one, supersedes global defaults
1664             that may be in effect (as set by `set_enabled_equivalencies`)
1665 
1666         units : set of `~astropy.units.Unit`, optional
1667             If not provided, all defined units will be searched for
1668             equivalencies.  Otherwise, may be a dict, module or
1669             sequence containing the units to search for equivalencies.
1670 
1671         include_prefix_units : bool, optional
1672             When `True`, include prefixed units in the result.
1673             Default is `False`.
1674 
1675         Returns
1676         -------
1677         units : list of `UnitBase`
1678             A list of unit objects that match ``u``.  A subclass of
1679             `list` (``EquivalentUnitsList``) is returned that
1680             pretty-prints the list of units when output.
1681         """
1682         results = self.compose(
1683             equivalencies=equivalencies,
1684             units=units,
1685             max_depth=1,
1686             include_prefix_units=include_prefix_units,
1687         )
1688         results = {x.bases[0] for x in results if len(x.bases) == 1}
1689         return self.EquivalentUnitsList(results)
1690 
1691     def is_unity(self):
1692         """
1693         Returns `True` if the unit is unscaled and dimensionless.
1694         """
1695         return False
1696 
1697 
1698 class NamedUnit(UnitBase):
1699     """
1700     The base class of units that have a name.
1701 
1702     Parameters
1703     ----------
1704     st : str, list of str, 2-tuple
1705         The name of the unit.  If a list of strings, the first element
1706         is the canonical (short) name, and the rest of the elements
1707         are aliases.  If a tuple of lists, the first element is a list
1708         of short names, and the second element is a list of long
1709         names; all but the first short name are considered "aliases".
1710         Each name *should* be a valid Python identifier to make it
1711         easy to access, but this is not required.
1712 
1713     namespace : dict, optional
1714         When provided, inject the unit, and all of its aliases, in the
1715         given namespace dictionary.  If a unit by the same name is
1716         already in the namespace, a ValueError is raised.
1717 
1718     doc : str, optional
1719         A docstring describing the unit.
1720 
1721     format : dict, optional
1722         A mapping to format-specific representations of this unit.
1723         For example, for the ``Ohm`` unit, it might be nice to have it
1724         displayed as ``\\Omega`` by the ``latex`` formatter.  In that
1725         case, `format` argument should be set to::
1726 
1727             {'latex': r'\\Omega'}
1728 
1729     Raises
1730     ------
1731     ValueError
1732         If any of the given unit names are already in the registry.
1733 
1734     ValueError
1735         If any of the given unit names are not valid Python tokens.
1736     """
1737 
1738     def __init__(self, st, doc=None, format=None, namespace=None):
1739         UnitBase.__init__(self)
1740 
1741         if isinstance(st, (bytes, str)):
1742             self._names = [st]
1743             self._short_names = [st]
1744             self._long_names = []
1745         elif isinstance(st, tuple):
1746             if not len(st) == 2:
1747                 raise ValueError("st must be string, list or 2-tuple")
1748             self._names = st[0] + [n for n in st[1] if n not in st[0]]
1749             if not len(self._names):
1750                 raise ValueError("must provide at least one name")
1751             self._short_names = st[0][:]
1752             self._long_names = st[1][:]
1753         else:
1754             if len(st) == 0:
1755                 raise ValueError("st list must have at least one entry")
1756             self._names = st[:]
1757             self._short_names = [st[0]]
1758             self._long_names = st[1:]
1759 
1760         if format is None:
1761             format = {}
1762         self._format = format
1763 
1764         if doc is None:
1765             doc = self._generate_doc()
1766         else:
1767             doc = textwrap.dedent(doc)
1768             doc = textwrap.fill(doc)
1769 
1770         self.__doc__ = doc
1771 
1772         self._inject(namespace)
1773 
1774     def _generate_doc(self):
1775         """
1776         Generate a docstring for the unit if the user didn't supply
1777         one.  This is only used from the constructor and may be
1778         overridden in subclasses.
1779         """
1780         names = self.names
1781         if len(self.names) > 1:
1782             return f"{names[1]} ({names[0]})"
1783         else:
1784             return names[0]
1785 
1786     def get_format_name(self, format):
1787         """
1788         Get a name for this unit that is specific to a particular
1789         format.
1790 
1791         Uses the dictionary passed into the `format` kwarg in the
1792         constructor.
1793 
1794         Parameters
1795         ----------
1796         format : str
1797             The name of the format
1798 
1799         Returns
1800         -------
1801         name : str
1802             The name of the unit for the given format.
1803         """
1804         return self._format.get(format, self.name)
1805 
1806     @property
1807     def names(self):
1808         """
1809         Returns all of the names associated with this unit.
1810         """
1811         return self._names
1812 
1813     @property
1814     def name(self):
1815         """
1816         Returns the canonical (short) name associated with this unit.
1817         """
1818         return self._names[0]
1819 
1820     @property
1821     def aliases(self):
1822         """
1823         Returns the alias (long) names for this unit.
1824         """
1825         return self._names[1:]
1826 
1827     @property
1828     def short_names(self):
1829         """
1830         Returns all of the short names associated with this unit.
1831         """
1832         return self._short_names
1833 
1834     @property
1835     def long_names(self):
1836         """
1837         Returns all of the long names associated with this unit.
1838         """
1839         return self._long_names
1840 
1841     def _inject(self, namespace=None):
1842         """
1843         Injects the unit, and all of its aliases, in the given
1844         namespace dictionary.
1845         """
1846         if namespace is None:
1847             return
1848 
1849         # Loop through all of the names first, to ensure all of them
1850         # are new, then add them all as a single "transaction" below.
1851         for name in self._names:
1852             if name in namespace and self != namespace[name]:
1853                 raise ValueError(
1854                     f"Object with name {name!r} already exists in "
1855                     f"given namespace ({namespace[name]!r})."
1856                 )
1857 
1858         for name in self._names:
1859             namespace[name] = self
1860 
1861 
1862 def _recreate_irreducible_unit(cls, names, registered):
1863     """
1864     This is used to reconstruct units when passed around by
1865     multiprocessing.
1866     """
1867     registry = get_current_unit_registry().registry
1868     if names[0] in registry:
1869         # If in local registry return that object.
1870         return registry[names[0]]
1871     else:
1872         # otherwise, recreate the unit.
1873         unit = cls(names)
1874         if registered:
1875             # If not in local registry but registered in origin registry,
1876             # enable unit in local registry.
1877             get_current_unit_registry().add_enabled_units([unit])
1878 
1879         return unit
1880 
1881 
1882 class IrreducibleUnit(NamedUnit):
1883     """
1884     Irreducible units are the units that all other units are defined
1885     in terms of.
1886 
1887     Examples are meters, seconds, kilograms, amperes, etc.  There is
1888     only once instance of such a unit per type.
1889     """
1890 
1891     def __reduce__(self):
1892         # When IrreducibleUnit objects are passed to other processes
1893         # over multiprocessing, they need to be recreated to be the
1894         # ones already in the subprocesses' namespace, not new
1895         # objects, or they will be considered "unconvertible".
1896         # Therefore, we have a custom pickler/unpickler that
1897         # understands how to recreate the Unit on the other side.
1898         registry = get_current_unit_registry().registry
1899         return (
1900             _recreate_irreducible_unit,
1901             (self.__class__, list(self.names), self.name in registry),
1902             self.__getstate__(),
1903         )
1904 
1905     @property
1906     def represents(self):
1907         """The unit that this named unit represents.
1908 
1909         For an irreducible unit, that is always itself.
1910         """
1911         return self
1912 
1913     def decompose(self, bases=set()):
1914         if len(bases) and self not in bases:
1915             for base in bases:
1916                 try:
1917                     scale = self._to(base)
1918                 except UnitsError:
1919                     pass
1920                 else:
1921                     if is_effectively_unity(scale):
1922                         return base
1923                     else:
1924                         return CompositeUnit(scale, [base], [1], _error_check=False)
1925 
1926             raise UnitConversionError(
1927                 f"Unit {self} can not be decomposed into the requested bases"
1928             )
1929 
1930         return self
1931 
1932 
1933 class UnrecognizedUnit(IrreducibleUnit):
1934     """
1935     A unit that did not parse correctly.  This allows for
1936     round-tripping it as a string, but no unit operations actually work
1937     on it.
1938 
1939     Parameters
1940     ----------
1941     st : str
1942         The name of the unit.
1943     """
1944 
1945     # For UnrecognizedUnits, we want to use "standard" Python
1946     # pickling, not the special case that is used for
1947     # IrreducibleUnits.
1948     __reduce__ = object.__reduce__
1949 
1950     def __repr__(self):
1951         return f"UnrecognizedUnit({str(self)})"
1952 
1953     def __bytes__(self):
1954         return self.name.encode("ascii", "replace")
1955 
1956     def __str__(self):
1957         return self.name
1958 
1959     def to_string(self, format=None):
1960         return self.name
1961 
1962     def _unrecognized_operator(self, *args, **kwargs):
1963         raise ValueError(
1964             f"The unit {self.name!r} is unrecognized, so all arithmetic operations "
1965             "with it are invalid."
1966         )
1967 
1968     __pow__ = __truediv__ = __rtruediv__ = __mul__ = __rmul__ = _unrecognized_operator
1969     __lt__ = __gt__ = __le__ = __ge__ = __neg__ = _unrecognized_operator
1970 
1971     def __eq__(self, other):
1972         try:
1973             other = Unit(other, parse_strict="silent")
1974         except (ValueError, UnitsError, TypeError):
1975             return NotImplemented
1976 
1977         return isinstance(other, type(self)) and self.name == other.name
1978 
1979     def __ne__(self, other):
1980         return not (self == other)
1981 
1982     def is_equivalent(self, other, equivalencies=None):
1983         self._normalize_equivalencies(equivalencies)
1984         return self == other
1985 
1986     def _get_converter(self, other, equivalencies=None):
1987         self._normalize_equivalencies(equivalencies)
1988         raise ValueError(
1989             f"The unit {self.name!r} is unrecognized.  It can not be converted "
1990             "to other units."
1991         )
1992 
1993     def get_format_name(self, format):
1994         return self.name
1995 
1996     def is_unity(self):
1997         return False
1998 
1999 
2000 class _UnitMetaClass(type):
2001     """
2002     This metaclass exists because the Unit constructor should
2003     sometimes return instances that already exist.  This "overrides"
2004     the constructor before the new instance is actually created, so we
2005     can return an existing one.
2006     """
2007 
2008     def __call__(
2009         self,
2010         s="",
2011         represents=None,
2012         format=None,
2013         namespace=None,
2014         doc=None,
2015         parse_strict="raise",
2016     ):
2017         # Short-circuit if we're already a unit
2018         if hasattr(s, "_get_physical_type_id"):
2019             return s
2020 
2021         # turn possible Quantity input for s or represents into a Unit
2022         from .quantity import Quantity
2023 
2024         if isinstance(represents, Quantity):
2025             if is_effectively_unity(represents.value):
2026                 represents = represents.unit
2027             else:
2028                 represents = CompositeUnit(
2029                     represents.value * represents.unit.scale,
2030                     bases=represents.unit.bases,
2031                     powers=represents.unit.powers,
2032                     _error_check=False,
2033                 )
2034 
2035         if isinstance(s, Quantity):
2036             if is_effectively_unity(s.value):
2037                 s = s.unit
2038             else:
2039                 s = CompositeUnit(
2040                     s.value * s.unit.scale,
2041                     bases=s.unit.bases,
2042                     powers=s.unit.powers,
2043                     _error_check=False,
2044                 )
2045 
2046         # now decide what we really need to do; define derived Unit?
2047         if isinstance(represents, UnitBase):
2048             # This has the effect of calling the real __new__ and
2049             # __init__ on the Unit class.
2050             return super().__call__(
2051                 s, represents, format=format, namespace=namespace, doc=doc
2052             )
2053 
2054         # or interpret a Quantity (now became unit), string or number?
2055         if isinstance(s, UnitBase):
2056             return s
2057 
2058         elif isinstance(s, (bytes, str)):
2059             if len(s.strip()) == 0:
2060                 # Return the NULL unit
2061                 return dimensionless_unscaled
2062 
2063             if format is None:
2064                 format = unit_format.Generic
2065 
2066             f = unit_format.get_format(format)
2067             if isinstance(s, bytes):
2068                 s = s.decode("ascii")
2069 
2070             try:
2071                 return f.parse(s)
2072             except NotImplementedError:
2073                 raise
2074             except Exception as e:
2075                 if parse_strict == "silent":
2076                     pass
2077                 else:
2078                     # Deliberately not issubclass here. Subclasses
2079                     # should use their name.
2080                     if f is not unit_format.Generic:
2081                         format_clause = f.name + " "
2082                     else:
2083                         format_clause = ""
2084                     msg = (
2085                         f"'{s}' did not parse as {format_clause}unit: {str(e)} "
2086                         "If this is meant to be a custom unit, "
2087                         "define it with 'u.def_unit'. To have it "
2088                         "recognized inside a file reader or other code, "
2089                         "enable it with 'u.add_enabled_units'. "
2090                         "For details, see "
2091                         "https://docs.astropy.org/en/latest/units/combining_and_defining.html"
2092                     )
2093                     if parse_strict == "raise":
2094                         raise ValueError(msg)
2095                     elif parse_strict == "warn":
2096                         warnings.warn(msg, UnitsWarning)
2097                     else:
2098                         raise ValueError(
2099                             "'parse_strict' must be 'warn', 'raise' or 'silent'"
2100                         )
2101                 return UnrecognizedUnit(s)
2102 
2103         elif isinstance(s, (int, float, np.floating, np.integer)):
2104             return CompositeUnit(s, [], [], _error_check=False)
2105 
2106         elif isinstance(s, tuple):
2107             from .structured import StructuredUnit
2108 
2109             return StructuredUnit(s)
2110 
2111         elif s is None:
2112             raise TypeError("None is not a valid Unit")
2113 
2114         else:
2115             raise TypeError(f"{s} can not be converted to a Unit")
2116 
2117 
2118 class Unit(NamedUnit, metaclass=_UnitMetaClass):
2119     """
2120     The main unit class.
2121 
2122     There are a number of different ways to construct a Unit, but
2123     always returns a `UnitBase` instance.  If the arguments refer to
2124     an already-existing unit, that existing unit instance is returned,
2125     rather than a new one.
2126 
2127     - From a string::
2128 
2129         Unit(s, format=None, parse_strict='silent')
2130 
2131       Construct from a string representing a (possibly compound) unit.
2132 
2133       The optional `format` keyword argument specifies the format the
2134       string is in, by default ``"generic"``.  For a description of
2135       the available formats, see `astropy.units.format`.
2136 
2137       The optional ``parse_strict`` keyword controls what happens when an
2138       unrecognized unit string is passed in.  It may be one of the following:
2139 
2140          - ``'raise'``: (default) raise a ValueError exception.
2141 
2142          - ``'warn'``: emit a Warning, and return an
2143            `UnrecognizedUnit` instance.
2144 
2145          - ``'silent'``: return an `UnrecognizedUnit` instance.
2146 
2147     - From a number::
2148 
2149         Unit(number)
2150 
2151       Creates a dimensionless unit.
2152 
2153     - From a `UnitBase` instance::
2154 
2155         Unit(unit)
2156 
2157       Returns the given unit unchanged.
2158 
2159     - From no arguments::
2160 
2161         Unit()
2162 
2163       Returns the dimensionless unit.
2164 
2165     - The last form, which creates a new `Unit` is described in detail
2166       below.
2167 
2168     See also: https://docs.astropy.org/en/stable/units/
2169 
2170     Parameters
2171     ----------
2172     st : str or list of str
2173         The name of the unit.  If a list, the first element is the
2174         canonical (short) name, and the rest of the elements are
2175         aliases.
2176 
2177     represents : UnitBase instance
2178         The unit that this named unit represents.
2179 
2180     doc : str, optional
2181         A docstring describing the unit.
2182 
2183     format : dict, optional
2184         A mapping to format-specific representations of this unit.
2185         For example, for the ``Ohm`` unit, it might be nice to have it
2186         displayed as ``\\Omega`` by the ``latex`` formatter.  In that
2187         case, `format` argument should be set to::
2188 
2189             {'latex': r'\\Omega'}
2190 
2191     namespace : dict, optional
2192         When provided, inject the unit (and all of its aliases) into
2193         the given namespace.
2194 
2195     Raises
2196     ------
2197     ValueError
2198         If any of the given unit names are already in the registry.
2199 
2200     ValueError
2201         If any of the given unit names are not valid Python tokens.
2202     """
2203 
2204     def __init__(self, st, represents=None, doc=None, format=None, namespace=None):
2205         represents = Unit(represents)
2206         self._represents = represents
2207 
2208         NamedUnit.__init__(self, st, namespace=namespace, doc=doc, format=format)
2209 
2210     @property
2211     def represents(self):
2212         """The unit that this named unit represents."""
2213         return self._represents
2214 
2215     def decompose(self, bases=set()):
2216         return self._represents.decompose(bases=bases)
2217 
2218     def is_unity(self):
2219         return self._represents.is_unity()
2220 
2221     def __hash__(self):
2222         if self._hash is None:
2223             self._hash = hash((self.name, self._represents))
2224         return self._hash
2225 
2226     @classmethod
2227     def _from_physical_type_id(cls, physical_type_id):
2228         # get string bases and powers from the ID tuple
2229         bases = [cls(base) for base, _ in physical_type_id]
2230         powers = [power for _, power in physical_type_id]
2231 
2232         if len(physical_type_id) == 1 and powers[0] == 1:
2233             unit = bases[0]
2234         else:
2235             unit = CompositeUnit(1, bases, powers, _error_check=False)
2236 
2237         return unit
2238 
2239 
2240 class PrefixUnit(Unit):
2241     """
2242     A unit that is simply a SI-prefixed version of another unit.
2243 
2244     For example, ``mm`` is a `PrefixUnit` of ``.001 * m``.
2245 
2246     The constructor is the same as for `Unit`.
2247     """
2248 
2249 
2250 class CompositeUnit(UnitBase):
2251     """
2252     Create a composite unit using expressions of previously defined
2253     units.
2254 
2255     Direct use of this class is not recommended. Instead use the
2256     factory function `Unit` and arithmetic operators to compose
2257     units.
2258 
2259     Parameters
2260     ----------
2261     scale : number
2262         A scaling factor for the unit.
2263 
2264     bases : sequence of `UnitBase`
2265         A sequence of units this unit is composed of.
2266 
2267     powers : sequence of numbers
2268         A sequence of powers (in parallel with ``bases``) for each
2269         of the base units.
2270     """
2271 
2272     _decomposed_cache = None
2273 
2274     def __init__(
2275         self,
2276         scale,
2277         bases,
2278         powers,
2279         decompose=False,
2280         decompose_bases=set(),
2281         _error_check=True,
2282     ):
2283         # There are many cases internal to astropy.units where we
2284         # already know that all the bases are Unit objects, and the
2285         # powers have been validated.  In those cases, we can skip the
2286         # error checking for performance reasons.  When the private
2287         # kwarg `_error_check` is False, the error checking is turned
2288         # off.
2289         if _error_check:
2290             for base in bases:
2291                 if not isinstance(base, UnitBase):
2292                     raise TypeError("bases must be sequence of UnitBase instances")
2293             powers = [validate_power(p) for p in powers]
2294 
2295         if not decompose and len(bases) == 1 and powers[0] >= 0:
2296             # Short-cut; with one unit there's nothing to expand and gather,
2297             # as that has happened already when creating the unit.  But do only
2298             # positive powers, since for negative powers we need to re-sort.
2299             unit = bases[0]
2300             power = powers[0]
2301             if power == 1:
2302                 scale *= unit.scale
2303                 self._bases = unit.bases
2304                 self._powers = unit.powers
2305             elif power == 0:
2306                 self._bases = []
2307                 self._powers = []
2308             else:
2309                 scale *= unit.scale**power
2310                 self._bases = unit.bases
2311                 self._powers = [
2312                     operator.mul(*resolve_fractions(p, power)) for p in unit.powers
2313                 ]
2314 
2315             self._scale = sanitize_scale(scale)
2316         else:
2317             # Regular case: use inputs as preliminary scale, bases, and powers,
2318             # then "expand and gather" identical bases, sanitize the scale, &c.
2319             self._scale = scale
2320             self._bases = bases
2321             self._powers = powers
2322             self._expand_and_gather(decompose=decompose, bases=decompose_bases)
2323 
2324     def __repr__(self):
2325         if len(self._bases):
2326             return super().__repr__()
2327         else:
2328             if self._scale != 1.0:
2329                 return f"Unit(dimensionless with a scale of {self._scale})"
2330             else:
2331                 return "Unit(dimensionless)"
2332 
2333     @property
2334     def scale(self):
2335         """
2336         Return the scale of the composite unit.
2337         """
2338         return self._scale
2339 
2340     @property
2341     def bases(self):
2342         """
2343         Return the bases of the composite unit.
2344         """
2345         return self._bases
2346 
2347     @property
2348     def powers(self):
2349         """
2350         Return the powers of the composite unit.
2351         """
2352         return self._powers
2353 
2354     def _expand_and_gather(self, decompose=False, bases=set()):
2355         def add_unit(unit, power, scale):
2356             if bases and unit not in bases:
2357                 for base in bases:
2358                     try:
2359                         scale *= unit._to(base) ** power
2360                     except UnitsError:
2361                         pass
2362                     else:
2363                         unit = base
2364                         break
2365 
2366             if unit in new_parts:
2367                 a, b = resolve_fractions(new_parts[unit], power)
2368                 new_parts[unit] = a + b
2369             else:
2370                 new_parts[unit] = power
2371             return scale
2372 
2373         new_parts = {}
2374         scale = self._scale
2375 
2376         for b, p in zip(self._bases, self._powers):
2377             if decompose and b not in bases:
2378                 b = b.decompose(bases=bases)
2379 
2380             if isinstance(b, CompositeUnit):
2381                 scale *= b._scale**p
2382                 for b_sub, p_sub in zip(b._bases, b._powers):
2383                     a, b = resolve_fractions(p_sub, p)
2384                     scale = add_unit(b_sub, a * b, scale)
2385             else:
2386                 scale = add_unit(b, p, scale)
2387 
2388         new_parts = [x for x in new_parts.items() if x[1] != 0]
2389         new_parts.sort(key=lambda x: (-x[1], getattr(x[0], "name", "")))
2390 
2391         self._bases = [x[0] for x in new_parts]
2392         self._powers = [x[1] for x in new_parts]
2393         self._scale = sanitize_scale(scale)
2394 
2395     def __copy__(self):
2396         """
2397         For compatibility with python copy module.
2398         """
2399         return CompositeUnit(self._scale, self._bases[:], self._powers[:])
2400 
2401     def decompose(self, bases=set()):
2402         if len(bases) == 0 and self._decomposed_cache is not None:
2403             return self._decomposed_cache
2404 
2405         for base in self.bases:
2406             if not isinstance(base, IrreducibleUnit) or (
2407                 len(bases) and base not in bases
2408             ):
2409                 break
2410         else:
2411             if len(bases) == 0:
2412                 self._decomposed_cache = self
2413             return self
2414 
2415         x = CompositeUnit(
2416             self.scale, self.bases, self.powers, decompose=True, decompose_bases=bases
2417         )
2418         if len(bases) == 0:
2419             self._decomposed_cache = x
2420         return x
2421 
2422     def is_unity(self):
2423         unit = self.decompose()
2424         return len(unit.bases) == 0 and unit.scale == 1.0
2425 
2426 
2427 si_prefixes = [
2428     (["Q"], ["quetta"], 1e30),
2429     (["R"], ["ronna"], 1e27),
2430     (["Y"], ["yotta"], 1e24),
2431     (["Z"], ["zetta"], 1e21),
2432     (["E"], ["exa"], 1e18),
2433     (["P"], ["peta"], 1e15),
2434     (["T"], ["tera"], 1e12),
2435     (["G"], ["giga"], 1e9),
2436     (["M"], ["mega"], 1e6),
2437     (["k"], ["kilo"], 1e3),
2438     (["h"], ["hecto"], 1e2),
2439     (["da"], ["deka", "deca"], 1e1),
2440     (["d"], ["deci"], 1e-1),
2441     (["c"], ["centi"], 1e-2),
2442     (["m"], ["milli"], 1e-3),
2443     (["u"], ["micro"], 1e-6),
2444     (["n"], ["nano"], 1e-9),
2445     (["p"], ["pico"], 1e-12),
2446     (["f"], ["femto"], 1e-15),
2447     (["a"], ["atto"], 1e-18),
2448     (["z"], ["zepto"], 1e-21),
2449     (["y"], ["yocto"], 1e-24),
2450     (["r"], ["ronto"], 1e-27),
2451     (["q"], ["quecto"], 1e-30),
2452 ]
2453 
2454 
2455 binary_prefixes = [
2456     (["Ki"], ["kibi"], 2**10),
2457     (["Mi"], ["mebi"], 2**20),
2458     (["Gi"], ["gibi"], 2**30),
2459     (["Ti"], ["tebi"], 2**40),
2460     (["Pi"], ["pebi"], 2**50),
2461     (["Ei"], ["exbi"], 2**60),
2462 ]
2463 
2464 
2465 def _add_prefixes(u, excludes=[], namespace=None, prefixes=False):
2466     """
2467     Set up all of the standard metric prefixes for a unit.  This
2468     function should not be used directly, but instead use the
2469     `prefixes` kwarg on `def_unit`.
2470 
2471     Parameters
2472     ----------
2473     excludes : list of str, optional
2474         Any prefixes to exclude from creation to avoid namespace
2475         collisions.
2476 
2477     namespace : dict, optional
2478         When provided, inject the unit (and all of its aliases) into
2479         the given namespace dictionary.
2480 
2481     prefixes : list, optional
2482         When provided, it is a list of prefix definitions of the form:
2483 
2484             (short_names, long_tables, factor)
2485     """
2486     if prefixes is True:
2487         prefixes = si_prefixes
2488     elif prefixes is False:
2489         prefixes = []
2490 
2491     for short, full, factor in prefixes:
2492         names = []
2493         format = {}
2494         for prefix in short:
2495             if prefix in excludes:
2496                 continue
2497 
2498             for alias in u.short_names:
2499                 names.append(prefix + alias)
2500 
2501                 # This is a hack to use Greek mu as a prefix
2502                 # for some formatters.
2503                 if prefix == "u":
2504                     format["latex"] = r"\mu " + u.get_format_name("latex")
2505                     format["unicode"] = "\N{MICRO SIGN}" + u.get_format_name("unicode")
2506 
2507                 for key, val in u._format.items():
2508                     format.setdefault(key, prefix + val)
2509 
2510         for prefix in full:
2511             if prefix in excludes:
2512                 continue
2513 
2514             for alias in u.long_names:
2515                 names.append(prefix + alias)
2516 
2517         if len(names):
2518             PrefixUnit(
2519                 names,
2520                 CompositeUnit(factor, [u], [1], _error_check=False),
2521                 namespace=namespace,
2522                 format=format,
2523             )
2524 
2525 
2526 def def_unit(
2527     s,
2528     represents=None,
2529     doc=None,
2530     format=None,
2531     prefixes=False,
2532     exclude_prefixes=[],
2533     namespace=None,
2534 ):
2535     """
2536     Factory function for defining new units.
2537 
2538     Parameters
2539     ----------
2540     s : str or list of str
2541         The name of the unit.  If a list, the first element is the
2542         canonical (short) name, and the rest of the elements are
2543         aliases.
2544 
2545     represents : UnitBase instance, optional
2546         The unit that this named unit represents.  If not provided,
2547         a new `IrreducibleUnit` is created.
2548 
2549     doc : str, optional
2550         A docstring describing the unit.
2551 
2552     format : dict, optional
2553         A mapping to format-specific representations of this unit.
2554         For example, for the ``Ohm`` unit, it might be nice to
2555         have it displayed as ``\\Omega`` by the ``latex``
2556         formatter.  In that case, `format` argument should be set
2557         to::
2558 
2559             {'latex': r'\\Omega'}
2560 
2561     prefixes : bool or list, optional
2562         When `True`, generate all of the SI prefixed versions of the
2563         unit as well.  For example, for a given unit ``m``, will
2564         generate ``mm``, ``cm``, ``km``, etc.  When a list, it is a list of
2565         prefix definitions of the form:
2566 
2567             (short_names, long_tables, factor)
2568 
2569         Default is `False`.  This function always returns the base
2570         unit object, even if multiple scaled versions of the unit were
2571         created.
2572 
2573     exclude_prefixes : list of str, optional
2574         If any of the SI prefixes need to be excluded, they may be
2575         listed here.  For example, ``Pa`` can be interpreted either as
2576         "petaannum" or "Pascal".  Therefore, when defining the
2577         prefixes for ``a``, ``exclude_prefixes`` should be set to
2578         ``["P"]``.
2579 
2580     namespace : dict, optional
2581         When provided, inject the unit (and all of its aliases and
2582         prefixes), into the given namespace dictionary.
2583 
2584     Returns
2585     -------
2586     unit : `~astropy.units.UnitBase`
2587         The newly-defined unit, or a matching unit that was already
2588         defined.
2589     """
2590     if represents is not None:
2591         result = Unit(s, represents, namespace=namespace, doc=doc, format=format)
2592     else:
2593         result = IrreducibleUnit(s, namespace=namespace, doc=doc, format=format)
2594 
2595     if prefixes:
2596         _add_prefixes(
2597             result, excludes=exclude_prefixes, namespace=namespace, prefixes=prefixes
2598         )
2599     return result
2600 
2601 
2602 def _condition_arg(value):
2603     """
2604     Validate value is acceptable for conversion purposes.
2605 
2606     Will convert into an array if not a scalar, and can be converted
2607     into an array
2608 
2609     Parameters
2610     ----------
2611     value : int or float value, or sequence of such values
2612 
2613     Returns
2614     -------
2615     Scalar value or numpy array
2616 
2617     Raises
2618     ------
2619     ValueError
2620         If value is not as expected
2621     """
2622     if isinstance(value, (np.ndarray, float, int, complex, np.void)):
2623         return value
2624 
2625     avalue = np.array(value)
2626     if avalue.dtype.kind not in ["i", "f", "c"]:
2627         raise ValueError(
2628             "Value not scalar compatible or convertible to "
2629             "an int, float, or complex array"
2630         )
2631     return avalue
2632 
2633 
2634 def unit_scale_converter(val):
2635     """Function that just multiplies the value by unity.
2636 
2637     This is a separate function so it can be recognized and
2638     discarded in unit conversion.
2639     """
2640     return 1.0 * _condition_arg(val)
2641 
2642 
2643 dimensionless_unscaled = CompositeUnit(1, [], [], _error_check=False)
2644 # Abbreviation of the above, see #1980
2645 one = dimensionless_unscaled
2646 
2647 # Maintain error in old location for backward compatibility
2648 # TODO: Is this still needed? Should there be a deprecation warning?
2649 unit_format.fits.UnitScaleError = UnitScaleError

</code><intended_behavior>The `to_string` method or its variants that are responsible for formatting units in different styles should be adjusted to ensure that there is no extraneous space at the beginning of the string representation for any unit, regardless of the formatting style (including `unicode` and `console`). This might involve checking and possibly modifying the conditions or logic that prepends spaces based on unit scale factors or the presence of certain unit components. Any modification should preserve the method's existing functionality to accurately represent units in their requested format, adjusting only for the leading space inconsistency.</intended_behavior>, <file>astropy/units/format/console.py</file>
<class>None</class>
<method>None</method>
<code>
1 # Licensed under a 3-clause BSD style license - see LICENSE.rst
2 
3 """
4 Handles the "Console" unit format.
5 """
6 
7 
8 from . import base, core, utils
9 
10 
11 class Console(base.Base):
12     """
13     Output-only format for to display pretty formatting at the
14     console.
15 
16     For example::
17 
18       >>> import astropy.units as u
19       >>> print(u.Ry.decompose().to_string('console'))  # doctest: +FLOAT_CMP
20       2.1798721*10^-18m^2 kg s^-2
21       >>> print(u.Ry.decompose().to_string('console', inline=False))  # doctest: +FLOAT_CMP
22                        m^2 kg
23       2.1798721*10^-18 ------
24                         s^2
25     """
26 
27     _times = "*"
28     _line = "-"
29 
30     @classmethod
31     def _get_unit_name(cls, unit):
32         return unit.get_format_name("console")
33 
34     @classmethod
35     def _format_superscript(cls, number):
36         return f"^{number}"
37 
38     @classmethod
39     def _format_unit_list(cls, units):
40         out = []
41         for base_, power in units:
42             if power == 1:
43                 out.append(cls._get_unit_name(base_))
44             else:
45                 out.append(
46                     cls._get_unit_name(base_)
47                     + cls._format_superscript(utils.format_power(power))
48                 )
49         return " ".join(out)
50 
51     @classmethod
52     def format_exponential_notation(cls, val):
53         m, ex = utils.split_mantissa_exponent(val)
54 
55         parts = []
56         if m:
57             parts.append(m)
58 
59         if ex:
60             parts.append(f"10{cls._format_superscript(ex)}")
61 
62         return cls._times.join(parts)
63 
64     @classmethod
65     def to_string(cls, unit, inline=True):
66         if isinstance(unit, core.CompositeUnit):
67             if unit.scale == 1:
68                 s = ""
69             else:
70                 s = cls.format_exponential_notation(unit.scale)
71 
72             if len(unit.bases):
73                 if inline:
74                     nominator = zip(unit.bases, unit.powers)
75                     denominator = []
76                 else:
77                     nominator, denominator = utils.get_grouped_by_powers(
78                         unit.bases, unit.powers
79                     )
80                 if len(denominator):
81                     if len(nominator):
82                         nominator = cls._format_unit_list(nominator)
83                     else:
84                         nominator = "1"
85                     denominator = cls._format_unit_list(denominator)
86                     fraclength = max(len(nominator), len(denominator))
87                     f = f"{{0:^{len(s)}s}} {{1:^{fraclength}s}}"
88 
89                     lines = [
90                         f.format("", nominator),
91                         f.format(s, cls._line * fraclength),
92                         f.format("", denominator),
93                     ]
94 
95                     s = "\n".join(lines)
96                 else:
97                     nominator = cls._format_unit_list(nominator)
98                     s += nominator
99         elif isinstance(unit, core.NamedUnit):
100             s = cls._get_unit_name(unit)
101 
102         return s

</code><intended_behavior>These methods should be verified and possibly corrected to ensure they do not introduce an unintended leading space in their output, especially under conditions where unit scale factors are present or absent. The logic handling the format-specific concatenations and space insertions needs careful inspection to eliminate the inconsistency. As with `core.py`, the aim would be to preserve the integrity and accuracy of the unit representation while aligning with the expected behavior of no leading spaces in all scenarios.</intended_behavior>]
2025-10-15 15:41:19.509 | INFO     | Search completed. Bug locations: [<file>astropy/units/core.py</file>
<class>None</class>
<method>None</method>
<code>
1 # Licensed under a 3-clause BSD style license - see LICENSE.rst
2 
3 """
4 Core units classes and functions.
5 """
6 
7 
8 import inspect
9 import operator
10 import textwrap
11 import warnings
12 
13 import numpy as np
14 
15 from astropy.utils.decorators import lazyproperty
16 from astropy.utils.exceptions import AstropyWarning
17 from astropy.utils.misc import isiterable
18 
19 from . import format as unit_format
20 from .utils import (
21     is_effectively_unity,
22     resolve_fractions,
23     sanitize_scale,
24     validate_power,
25 )
26 
27 __all__ = [
28     "UnitsError",
29     "UnitsWarning",
30     "UnitConversionError",
31     "UnitTypeError",
32     "UnitBase",
33     "NamedUnit",
34     "IrreducibleUnit",
35     "Unit",
36     "CompositeUnit",
37     "PrefixUnit",
38     "UnrecognizedUnit",
39     "def_unit",
40     "get_current_unit_registry",
41     "set_enabled_units",
42     "add_enabled_units",
43     "set_enabled_equivalencies",
44     "add_enabled_equivalencies",
45     "set_enabled_aliases",
46     "add_enabled_aliases",
47     "dimensionless_unscaled",
48     "one",
49 ]
50 
51 UNITY = 1.0
52 
53 
54 def _flatten_units_collection(items):
55     """
56     Given a list of sequences, modules or dictionaries of units, or
57     single units, return a flat set of all the units found.
58     """
59     if not isinstance(items, list):
60         items = [items]
61 
62     result = set()
63     for item in items:
64         if isinstance(item, UnitBase):
65             result.add(item)
66         else:
67             if isinstance(item, dict):
68                 units = item.values()
69             elif inspect.ismodule(item):
70                 units = vars(item).values()
71             elif isiterable(item):
72                 units = item
73             else:
74                 continue
75 
76             for unit in units:
77                 if isinstance(unit, UnitBase):
78                     result.add(unit)
79 
80     return result
81 
82 
83 def _normalize_equivalencies(equivalencies):
84     """Normalizes equivalencies ensuring each is a 4-tuple.
85 
86     The resulting tuple is of the form::
87 
88         (from_unit, to_unit, forward_func, backward_func)
89 
90     Parameters
91     ----------
92     equivalencies : list of equivalency pairs
93 
94     Raises
95     ------
96     ValueError if an equivalency cannot be interpreted
97     """
98     if equivalencies is None:
99         return []
100 
101     normalized = []
102 
103     for i, equiv in enumerate(equivalencies):
104         if len(equiv) == 2:
105             funit, tunit = equiv
106             a = b = lambda x: x
107         elif len(equiv) == 3:
108             funit, tunit, a = equiv
109             b = a
110         elif len(equiv) == 4:
111             funit, tunit, a, b = equiv
112         else:
113             raise ValueError(f"Invalid equivalence entry {i}: {equiv!r}")
114         if not (
115             funit is Unit(funit)
116             and (tunit is None or tunit is Unit(tunit))
117             and callable(a)
118             and callable(b)
119         ):
120             raise ValueError(f"Invalid equivalence entry {i}: {equiv!r}")
121         normalized.append((funit, tunit, a, b))
122 
123     return normalized
124 
125 
126 class _UnitRegistry:
127     """
128     Manages a registry of the enabled units.
129     """
130 
131     def __init__(self, init=[], equivalencies=[], aliases={}):
132         if isinstance(init, _UnitRegistry):
133             # If passed another registry we don't need to rebuild everything.
134             # but because these are mutable types we don't want to create
135             # conflicts so everything needs to be copied.
136             self._equivalencies = init._equivalencies.copy()
137             self._aliases = init._aliases.copy()
138             self._all_units = init._all_units.copy()
139             self._registry = init._registry.copy()
140             self._non_prefix_units = init._non_prefix_units.copy()
141             # The physical type is a dictionary containing sets as values.
142             # All of these must be copied otherwise we could alter the old
143             # registry.
144             self._by_physical_type = {
145                 k: v.copy() for k, v in init._by_physical_type.items()
146             }
147 
148         else:
149             self._reset_units()
150             self._reset_equivalencies()
151             self._reset_aliases()
152             self.add_enabled_units(init)
153             self.add_enabled_equivalencies(equivalencies)
154             self.add_enabled_aliases(aliases)
155 
156     def _reset_units(self):
157         self._all_units = set()
158         self._non_prefix_units = set()
159         self._registry = {}
160         self._by_physical_type = {}
161 
162     def _reset_equivalencies(self):
163         self._equivalencies = set()
164 
165     def _reset_aliases(self):
166         self._aliases = {}
167 
168     @property
169     def registry(self):
170         return self._registry
171 
172     @property
173     def all_units(self):
174         return self._all_units
175 
176     @property
177     def non_prefix_units(self):
178         return self._non_prefix_units
179 
180     def set_enabled_units(self, units):
181         """
182         Sets the units enabled in the unit registry.
183 
184         These units are searched when using
185         `UnitBase.find_equivalent_units`, for example.
186 
187         Parameters
188         ----------
189         units : list of sequence, dict, or module
190             This is a list of things in which units may be found
191             (sequences, dicts or modules), or units themselves.  The
192             entire set will be "enabled" for searching through by
193             methods like `UnitBase.find_equivalent_units` and
194             `UnitBase.compose`.
195         """
196         self._reset_units()
197         return self.add_enabled_units(units)
198 
199     def add_enabled_units(self, units):
200         """
201         Adds to the set of units enabled in the unit registry.
202 
203         These units are searched when using
204         `UnitBase.find_equivalent_units`, for example.
205 
206         Parameters
207         ----------
208         units : list of sequence, dict, or module
209             This is a list of things in which units may be found
210             (sequences, dicts or modules), or units themselves.  The
211             entire set will be added to the "enabled" set for
212             searching through by methods like
213             `UnitBase.find_equivalent_units` and `UnitBase.compose`.
214         """
215         units = _flatten_units_collection(units)
216 
217         for unit in units:
218             # Loop through all of the names first, to ensure all of them
219             # are new, then add them all as a single "transaction" below.
220             for st in unit._names:
221                 if st in self._registry and unit != self._registry[st]:
222                     raise ValueError(
223                         f"Object with name {st!r} already exists in namespace. "
224                         "Filter the set of units to avoid name clashes before "
225                         "enabling them."
226                     )
227 
228             for st in unit._names:
229                 self._registry[st] = unit
230 
231             self._all_units.add(unit)
232             if not isinstance(unit, PrefixUnit):
233                 self._non_prefix_units.add(unit)
234 
235             hash = unit._get_physical_type_id()
236             self._by_physical_type.setdefault(hash, set()).add(unit)
237 
238     def get_units_with_physical_type(self, unit):
239         """
240         Get all units in the registry with the same physical type as
241         the given unit.
242 
243         Parameters
244         ----------
245         unit : UnitBase instance
246         """
247         return self._by_physical_type.get(unit._get_physical_type_id(), set())
248 
249     @property
250     def equivalencies(self):
251         return list(self._equivalencies)
252 
253     def set_enabled_equivalencies(self, equivalencies):
254         """
255         Sets the equivalencies enabled in the unit registry.
256 
257         These equivalencies are used if no explicit equivalencies are given,
258         both in unit conversion and in finding equivalent units.
259 
260         This is meant in particular for allowing angles to be dimensionless.
261         Use with care.
262 
263         Parameters
264         ----------
265         equivalencies : list of tuple
266             List of equivalent pairs, e.g., as returned by
267             `~astropy.units.equivalencies.dimensionless_angles`.
268         """
269         self._reset_equivalencies()
270         return self.add_enabled_equivalencies(equivalencies)
271 
272     def add_enabled_equivalencies(self, equivalencies):
273         """
274         Adds to the set of equivalencies enabled in the unit registry.
275 
276         These equivalencies are used if no explicit equivalencies are given,
277         both in unit conversion and in finding equivalent units.
278 
279         This is meant in particular for allowing angles to be dimensionless.
280         Use with care.
281 
282         Parameters
283         ----------
284         equivalencies : list of tuple
285             List of equivalent pairs, e.g., as returned by
286             `~astropy.units.equivalencies.dimensionless_angles`.
287         """
288         # pre-normalize list to help catch mistakes
289         equivalencies = _normalize_equivalencies(equivalencies)
290         self._equivalencies |= set(equivalencies)
291 
292     @property
293     def aliases(self):
294         return self._aliases
295 
296     def set_enabled_aliases(self, aliases):
297         """
298         Set aliases for units.
299 
300         Parameters
301         ----------
302         aliases : dict of str, Unit
303             The aliases to set. The keys must be the string aliases, and values
304             must be the `astropy.units.Unit` that the alias will be mapped to.
305 
306         Raises
307         ------
308         ValueError
309             If the alias already defines a different unit.
310 
311         """
312         self._reset_aliases()
313         self.add_enabled_aliases(aliases)
314 
315     def add_enabled_aliases(self, aliases):
316         """
317         Add aliases for units.
318 
319         Parameters
320         ----------
321         aliases : dict of str, Unit
322             The aliases to add. The keys must be the string aliases, and values
323             must be the `astropy.units.Unit` that the alias will be mapped to.
324 
325         Raises
326         ------
327         ValueError
328             If the alias already defines a different unit.
329 
330         """
331         for alias, unit in aliases.items():
332             if alias in self._registry and unit != self._registry[alias]:
333                 raise ValueError(
334                     f"{alias} already means {self._registry[alias]}, so "
335                     f"cannot be used as an alias for {unit}."
336                 )
337             if alias in self._aliases and unit != self._aliases[alias]:
338                 raise ValueError(
339                     f"{alias} already is an alias for {self._aliases[alias]}, so "
340                     f"cannot be used as an alias for {unit}."
341                 )
342 
343         for alias, unit in aliases.items():
344             if alias not in self._registry and alias not in self._aliases:
345                 self._aliases[alias] = unit
346 
347 
348 class _UnitContext:
349     def __init__(self, init=[], equivalencies=[]):
350         _unit_registries.append(_UnitRegistry(init=init, equivalencies=equivalencies))
351 
352     def __enter__(self):
353         pass
354 
355     def __exit__(self, type, value, tb):
356         _unit_registries.pop()
357 
358 
359 _unit_registries = [_UnitRegistry()]
360 
361 
362 def get_current_unit_registry():
363     return _unit_registries[-1]
364 
365 
366 def set_enabled_units(units):
367     """
368     Sets the units enabled in the unit registry.
369 
370     These units are searched when using
371     `UnitBase.find_equivalent_units`, for example.
372 
373     This may be used either permanently, or as a context manager using
374     the ``with`` statement (see example below).
375 
376     Parameters
377     ----------
378     units : list of sequence, dict, or module
379         This is a list of things in which units may be found
380         (sequences, dicts or modules), or units themselves.  The
381         entire set will be "enabled" for searching through by methods
382         like `UnitBase.find_equivalent_units` and `UnitBase.compose`.
383 
384     Examples
385     --------
386     >>> from astropy import units as u
387     >>> with u.set_enabled_units([u.pc]):
388     ...     u.m.find_equivalent_units()
389     ...
390       Primary name | Unit definition | Aliases
391     [
392       pc           | 3.08568e+16 m   | parsec  ,
393     ]
394     >>> u.m.find_equivalent_units()
395       Primary name | Unit definition | Aliases
396     [
397       AU           | 1.49598e+11 m   | au, astronomical_unit            ,
398       Angstrom     | 1e-10 m         | AA, angstrom                     ,
399       cm           | 0.01 m          | centimeter                       ,
400       earthRad     | 6.3781e+06 m    | R_earth, Rearth                  ,
401       jupiterRad   | 7.1492e+07 m    | R_jup, Rjup, R_jupiter, Rjupiter ,
402       lsec         | 2.99792e+08 m   | lightsecond                      ,
403       lyr          | 9.46073e+15 m   | lightyear                        ,
404       m            | irreducible     | meter                            ,
405       micron       | 1e-06 m         |                                  ,
406       pc           | 3.08568e+16 m   | parsec                           ,
407       solRad       | 6.957e+08 m     | R_sun, Rsun                      ,
408     ]
409     """
410     # get a context with a new registry, using equivalencies of the current one
411     context = _UnitContext(equivalencies=get_current_unit_registry().equivalencies)
412     # in this new current registry, enable the units requested
413     get_current_unit_registry().set_enabled_units(units)
414     return context
415 
416 
417 def add_enabled_units(units):
418     """
419     Adds to the set of units enabled in the unit registry.
420 
421     These units are searched when using
422     `UnitBase.find_equivalent_units`, for example.
423 
424     This may be used either permanently, or as a context manager using
425     the ``with`` statement (see example below).
426 
427     Parameters
428     ----------
429     units : list of sequence, dict, or module
430         This is a list of things in which units may be found
431         (sequences, dicts or modules), or units themselves.  The
432         entire set will be added to the "enabled" set for searching
433         through by methods like `UnitBase.find_equivalent_units` and
434         `UnitBase.compose`.
435 
436     Examples
437     --------
438     >>> from astropy import units as u
439     >>> from astropy.units import imperial
440     >>> with u.add_enabled_units(imperial):
441     ...     u.m.find_equivalent_units()
442     ...
443       Primary name | Unit definition | Aliases
444     [
445       AU           | 1.49598e+11 m   | au, astronomical_unit            ,
446       Angstrom     | 1e-10 m         | AA, angstrom                     ,
447       cm           | 0.01 m          | centimeter                       ,
448       earthRad     | 6.3781e+06 m    | R_earth, Rearth                  ,
449       ft           | 0.3048 m        | foot                             ,
450       fur          | 201.168 m       | furlong                          ,
451       inch         | 0.0254 m        |                                  ,
452       jupiterRad   | 7.1492e+07 m    | R_jup, Rjup, R_jupiter, Rjupiter ,
453       lsec         | 2.99792e+08 m   | lightsecond                      ,
454       lyr          | 9.46073e+15 m   | lightyear                        ,
455       m            | irreducible     | meter                            ,
456       mi           | 1609.34 m       | mile                             ,
457       micron       | 1e-06 m         |                                  ,
458       mil          | 2.54e-05 m      | thou                             ,
459       nmi          | 1852 m          | nauticalmile, NM                 ,
460       pc           | 3.08568e+16 m   | parsec                           ,
461       solRad       | 6.957e+08 m     | R_sun, Rsun                      ,
462       yd           | 0.9144 m        | yard                             ,
463     ]
464     """
465     # get a context with a new registry, which is a copy of the current one
466     context = _UnitContext(get_current_unit_registry())
467     # in this new current registry, enable the further units requested
468     get_current_unit_registry().add_enabled_units(units)
469     return context
470 
471 
472 def set_enabled_equivalencies(equivalencies):
473     """
474     Sets the equivalencies enabled in the unit registry.
475 
476     These equivalencies are used if no explicit equivalencies are given,
477     both in unit conversion and in finding equivalent units.
478 
479     This is meant in particular for allowing angles to be dimensionless.
480     Use with care.
481 
482     Parameters
483     ----------
484     equivalencies : list of tuple
485         list of equivalent pairs, e.g., as returned by
486         `~astropy.units.equivalencies.dimensionless_angles`.
487 
488     Examples
489     --------
490     Exponentiation normally requires dimensionless quantities.  To avoid
491     problems with complex phases::
492 
493         >>> from astropy import units as u
494         >>> with u.set_enabled_equivalencies(u.dimensionless_angles()):
495         ...     phase = 0.5 * u.cycle
496         ...     np.exp(1j*phase)  # doctest: +FLOAT_CMP
497         <Quantity -1.+1.2246468e-16j>
498     """
499     # get a context with a new registry, using all units of the current one
500     context = _UnitContext(get_current_unit_registry())
501     # in this new current registry, enable the equivalencies requested
502     get_current_unit_registry().set_enabled_equivalencies(equivalencies)
503     return context
504 
505 
506 def add_enabled_equivalencies(equivalencies):
507     """
508     Adds to the equivalencies enabled in the unit registry.
509 
510     These equivalencies are used if no explicit equivalencies are given,
511     both in unit conversion and in finding equivalent units.
512 
513     This is meant in particular for allowing angles to be dimensionless.
514     Since no equivalencies are enabled by default, generally it is recommended
515     to use `set_enabled_equivalencies`.
516 
517     Parameters
518     ----------
519     equivalencies : list of tuple
520         list of equivalent pairs, e.g., as returned by
521         `~astropy.units.equivalencies.dimensionless_angles`.
522     """
523     # get a context with a new registry, which is a copy of the current one
524     context = _UnitContext(get_current_unit_registry())
525     # in this new current registry, enable the further equivalencies requested
526     get_current_unit_registry().add_enabled_equivalencies(equivalencies)
527     return context
528 
529 
530 def set_enabled_aliases(aliases):
531     """
532     Set aliases for units.
533 
534     This is useful for handling alternate spellings for units, or
535     misspelled units in files one is trying to read.
536 
537     Parameters
538     ----------
539     aliases : dict of str, Unit
540         The aliases to set. The keys must be the string aliases, and values
541         must be the `astropy.units.Unit` that the alias will be mapped to.
542 
543     Raises
544     ------
545     ValueError
546         If the alias already defines a different unit.
547 
548     Examples
549     --------
550     To temporarily allow for a misspelled 'Angstroem' unit::
551 
552         >>> from astropy import units as u
553         >>> with u.set_enabled_aliases({'Angstroem': u.Angstrom}):
554         ...     print(u.Unit("Angstroem", parse_strict="raise") == u.Angstrom)
555         True
556 
557     """
558     # get a context with a new registry, which is a copy of the current one
559     context = _UnitContext(get_current_unit_registry())
560     # in this new current registry, enable the further equivalencies requested
561     get_current_unit_registry().set_enabled_aliases(aliases)
562     return context
563 
564 
565 def add_enabled_aliases(aliases):
566     """
567     Add aliases for units.
568 
569     This is useful for handling alternate spellings for units, or
570     misspelled units in files one is trying to read.
571 
572     Since no aliases are enabled by default, generally it is recommended
573     to use `set_enabled_aliases`.
574 
575     Parameters
576     ----------
577     aliases : dict of str, Unit
578         The aliases to add. The keys must be the string aliases, and values
579         must be the `astropy.units.Unit` that the alias will be mapped to.
580 
581     Raises
582     ------
583     ValueError
584         If the alias already defines a different unit.
585 
586     Examples
587     --------
588     To temporarily allow for a misspelled 'Angstroem' unit::
589 
590         >>> from astropy import units as u
591         >>> with u.add_enabled_aliases({'Angstroem': u.Angstrom}):
592         ...     print(u.Unit("Angstroem", parse_strict="raise") == u.Angstrom)
593         True
594 
595     """
596     # get a context with a new registry, which is a copy of the current one
597     context = _UnitContext(get_current_unit_registry())
598     # in this new current registry, enable the further equivalencies requested
599     get_current_unit_registry().add_enabled_aliases(aliases)
600     return context
601 
602 
603 class UnitsError(Exception):
604     """
605     The base class for unit-specific exceptions.
606     """
607 
608 
609 class UnitScaleError(UnitsError, ValueError):
610     """
611     Used to catch the errors involving scaled units,
612     which are not recognized by FITS format.
613     """
614 
615     pass
616 
617 
618 class UnitConversionError(UnitsError, ValueError):
619     """
620     Used specifically for errors related to converting between units or
621     interpreting units in terms of other units.
622     """
623 
624 
625 class UnitTypeError(UnitsError, TypeError):
626     """
627     Used specifically for errors in setting to units not allowed by a class.
628 
629     E.g., would be raised if the unit of an `~astropy.coordinates.Angle`
630     instances were set to a non-angular unit.
631     """
632 
633 
634 class UnitsWarning(AstropyWarning):
635     """
636     The base class for unit-specific warnings.
637     """
638 
639 
640 class UnitBase:
641     """
642     Abstract base class for units.
643 
644     Most of the arithmetic operations on units are defined in this
645     base class.
646 
647     Should not be instantiated by users directly.
648     """
649 
650     # Make sure that __rmul__ of units gets called over the __mul__ of Numpy
651     # arrays to avoid element-wise multiplication.
652     __array_priority__ = 1000
653 
654     _hash = None
655     _type_id = None
656 
657     def __deepcopy__(self, memo):
658         # This may look odd, but the units conversion will be very
659         # broken after deep-copying if we don't guarantee that a given
660         # physical unit corresponds to only one instance
661         return self
662 
663     def _repr_latex_(self):
664         """
665         Generate latex representation of unit name.  This is used by
666         the IPython notebook to print a unit with a nice layout.
667 
668         Returns
669         -------
670         Latex string
671         """
672         return unit_format.Latex.to_string(self)
673 
674     def __bytes__(self):
675         """Return string representation for unit."""
676         return unit_format.Generic.to_string(self).encode("unicode_escape")
677 
678     def __str__(self):
679         """Return string representation for unit."""
680         return unit_format.Generic.to_string(self)
681 
682     def __repr__(self):
683         string = unit_format.Generic.to_string(self)
684 
685         return f'Unit("{string}")'
686 
687     def _get_physical_type_id(self):
688         """
689         Returns an identifier that uniquely identifies the physical
690         type of this unit.  It is comprised of the bases and powers of
691         this unit, without the scale.  Since it is hashable, it is
692         useful as a dictionary key.
693         """
694         if self._type_id is None:
695             unit = self.decompose()
696             self._type_id = tuple(zip((base.name for base in unit.bases), unit.powers))
697 
698         return self._type_id
699 
700     @property
701     def names(self):
702         """
703         Returns all of the names associated with this unit.
704         """
705         raise AttributeError(
706             "Can not get names from unnamed units. Perhaps you meant to_string()?"
707         )
708 
709     @property
710     def name(self):
711         """
712         Returns the canonical (short) name associated with this unit.
713         """
714         raise AttributeError(
715             "Can not get names from unnamed units. Perhaps you meant to_string()?"
716         )
717 
718     @property
719     def aliases(self):
720         """
721         Returns the alias (long) names for this unit.
722         """
723         raise AttributeError(
724             "Can not get aliases from unnamed units. Perhaps you meant to_string()?"
725         )
726 
727     @property
728     def scale(self):
729         """
730         Return the scale of the unit.
731         """
732         return 1.0
733 
734     @property
735     def bases(self):
736         """
737         Return the bases of the unit.
738         """
739         return [self]
740 
741     @property
742     def powers(self):
743         """
744         Return the powers of the unit.
745         """
746         return [1]
747 
748     def to_string(self, format=unit_format.Generic, **kwargs):
749         """Output the unit in the given format as a string.
750 
751         Parameters
752         ----------
753         format : `astropy.units.format.Base` instance or str
754             The name of a format or a formatter object.  If not
755             provided, defaults to the generic format.
756 
757         **kwargs :
758             Further options forwarded to the formatter. Currently
759             recognized is **inline** (:class:`bool`) for the
760             ``"latex"``, ``"console"``, and``"unicode"`` formats.
761 
762         """
763         f = unit_format.get_format(format)
764         return f.to_string(self, **kwargs)
765 
766     def __format__(self, format_spec):
767         """Try to format units using a formatter."""
768         try:
769             return self.to_string(format=format_spec)
770         except ValueError:
771             return format(str(self), format_spec)
772 
773     @staticmethod
774     def _normalize_equivalencies(equivalencies):
775         """Normalizes equivalencies, ensuring each is a 4-tuple.
776 
777         The resulting tuple is of the form::
778 
779             (from_unit, to_unit, forward_func, backward_func)
780 
781         Parameters
782         ----------
783         equivalencies : list of equivalency pairs, or None
784 
785         Returns
786         -------
787         A normalized list, including possible global defaults set by, e.g.,
788         `set_enabled_equivalencies`, except when `equivalencies`=`None`,
789         in which case the returned list is always empty.
790 
791         Raises
792         ------
793         ValueError if an equivalency cannot be interpreted
794         """
795         normalized = _normalize_equivalencies(equivalencies)
796         if equivalencies is not None:
797             normalized += get_current_unit_registry().equivalencies
798 
799         return normalized
800 
801     def __pow__(self, p):
802         p = validate_power(p)
803         return CompositeUnit(1, [self], [p], _error_check=False)
804 
805     def __truediv__(self, m):
806         if isinstance(m, (bytes, str)):
807             m = Unit(m)
808 
809         if isinstance(m, UnitBase):
810             if m.is_unity():
811                 return self
812             return CompositeUnit(1, [self, m], [1, -1], _error_check=False)
813 
814         try:
815             # Cannot handle this as Unit, re-try as Quantity
816             from .quantity import Quantity
817 
818             return Quantity(1, self) / m
819         except TypeError:
820             return NotImplemented
821 
822     def __rtruediv__(self, m):
823         if isinstance(m, (bytes, str)):
824             return Unit(m) / self
825 
826         try:
827             # Cannot handle this as Unit.  Here, m cannot be a Quantity,
828             # so we make it into one, fasttracking when it does not have a
829             # unit, for the common case of <array> / <unit>.
830             from .quantity import Quantity
831 
832             if hasattr(m, "unit"):
833                 result = Quantity(m)
834                 result /= self
835                 return result
836             else:
837                 return Quantity(m, self ** (-1))
838         except TypeError:
839             return NotImplemented
840 
841     def __mul__(self, m):
842         if isinstance(m, (bytes, str)):
843             m = Unit(m)
844 
845         if isinstance(m, UnitBase):
846             if m.is_unity():
847                 return self
848             elif self.is_unity():
849                 return m
850             return CompositeUnit(1, [self, m], [1, 1], _error_check=False)
851 
852         # Cannot handle this as Unit, re-try as Quantity.
853         try:
854             from .quantity import Quantity
855 
856             return Quantity(1, unit=self) * m
857         except TypeError:
858             return NotImplemented
859 
860     def __rmul__(self, m):
861         if isinstance(m, (bytes, str)):
862             return Unit(m) * self
863 
864         # Cannot handle this as Unit.  Here, m cannot be a Quantity,
865         # so we make it into one, fasttracking when it does not have a unit
866         # for the common case of <array> * <unit>.
867         try:
868             from .quantity import Quantity
869 
870             if hasattr(m, "unit"):
871                 result = Quantity(m)
872                 result *= self
873                 return result
874             else:
875                 return Quantity(m, unit=self)
876         except TypeError:
877             return NotImplemented
878 
879     def __rlshift__(self, m):
880         try:
881             from .quantity import Quantity
882 
883             return Quantity(m, self, copy=False, subok=True)
884         except Exception:
885             return NotImplemented
886 
887     def __rrshift__(self, m):
888         warnings.warn(
889             ">> is not implemented. Did you mean to convert "
890             f"to a Quantity with unit {m} using '<<'?",
891             AstropyWarning,
892         )
893         return NotImplemented
894 
895     def __hash__(self):
896         if self._hash is None:
897             parts = (
898                 [str(self.scale)]
899                 + [x.name for x in self.bases]
900                 + [str(x) for x in self.powers]
901             )
902             self._hash = hash(tuple(parts))
903         return self._hash
904 
905     def __getstate__(self):
906         # If we get pickled, we should *not* store the memoized members since
907         # hashes of strings vary between sessions.
908         state = self.__dict__.copy()
909         state.pop("_hash", None)
910         state.pop("_type_id", None)
911         return state
912 
913     def __eq__(self, other):
914         if self is other:
915             return True
916 
917         try:
918             other = Unit(other, parse_strict="silent")
919         except (ValueError, UnitsError, TypeError):
920             return NotImplemented
921 
922         # Other is unit-like, but the test below requires it is a UnitBase
923         # instance; if it is not, give up (so that other can try).
924         if not isinstance(other, UnitBase):
925             return NotImplemented
926 
927         try:
928             return is_effectively_unity(self._to(other))
929         except UnitsError:
930             return False
931 
932     def __ne__(self, other):
933         return not (self == other)
934 
935     def __le__(self, other):
936         scale = self._to(Unit(other))
937         return scale <= 1.0 or is_effectively_unity(scale)
938 
939     def __ge__(self, other):
940         scale = self._to(Unit(other))
941         return scale >= 1.0 or is_effectively_unity(scale)
942 
943     def __lt__(self, other):
944         return not (self >= other)
945 
946     def __gt__(self, other):
947         return not (self <= other)
948 
949     def __neg__(self):
950         return self * -1.0
951 
952     def is_equivalent(self, other, equivalencies=[]):
953         """
954         Returns `True` if this unit is equivalent to ``other``.
955 
956         Parameters
957         ----------
958         other : `~astropy.units.Unit`, str, or tuple
959             The unit to convert to. If a tuple of units is specified, this
960             method returns true if the unit matches any of those in the tuple.
961 
962         equivalencies : list of tuple
963             A list of equivalence pairs to try if the units are not
964             directly convertible.  See :ref:`astropy:unit_equivalencies`.
965             This list is in addition to possible global defaults set by, e.g.,
966             `set_enabled_equivalencies`.
967             Use `None` to turn off all equivalencies.
968 
969         Returns
970         -------
971         bool
972         """
973         equivalencies = self._normalize_equivalencies(equivalencies)
974 
975         if isinstance(other, tuple):
976             return any(self.is_equivalent(u, equivalencies) for u in other)
977 
978         other = Unit(other, parse_strict="silent")
979 
980         return self._is_equivalent(other, equivalencies)
981 
982     def _is_equivalent(self, other, equivalencies=[]):
983         """Returns `True` if this unit is equivalent to `other`.
984         See `is_equivalent`, except that a proper Unit object should be
985         given (i.e., no string) and that the equivalency list should be
986         normalized using `_normalize_equivalencies`.
987         """
988         if isinstance(other, UnrecognizedUnit):
989             return False
990 
991         if self._get_physical_type_id() == other._get_physical_type_id():
992             return True
993         elif len(equivalencies):
994             unit = self.decompose()
995             other = other.decompose()
996             for a, b, forward, backward in equivalencies:
997                 if b is None:
998                     # after canceling, is what's left convertible
999                     # to dimensionless (according to the equivalency)?
1000                     try:
1001                         (other / unit).decompose([a])
1002                         return True
1003                     except Exception:
1004                         pass
1005                 elif (a._is_equivalent(unit) and b._is_equivalent(other)) or (
1006                     b._is_equivalent(unit) and a._is_equivalent(other)
1007                 ):
1008                     return True
1009 
1010         return False
1011 
1012     def _apply_equivalencies(self, unit, other, equivalencies):
1013         """
1014         Internal function (used from `_get_converter`) to apply
1015         equivalence pairs.
1016         """
1017 
1018         def make_converter(scale1, func, scale2):
1019             def convert(v):
1020                 return func(_condition_arg(v) / scale1) * scale2
1021 
1022             return convert
1023 
1024         for funit, tunit, a, b in equivalencies:
1025             if tunit is None:
1026                 ratio = other.decompose() / unit.decompose()
1027                 try:
1028                     ratio_in_funit = ratio.decompose([funit])
1029                     return make_converter(ratio_in_funit.scale, a, 1.0)
1030                 except UnitsError:
1031                     pass
1032             else:
1033                 try:
1034                     scale1 = funit._to(unit)
1035                     scale2 = tunit._to(other)
1036                     return make_converter(scale1, a, scale2)
1037                 except UnitsError:
1038                     pass
1039                 try:
1040                     scale1 = tunit._to(unit)
1041                     scale2 = funit._to(other)
1042                     return make_converter(scale1, b, scale2)
1043                 except UnitsError:
1044                     pass
1045 
1046         def get_err_str(unit):
1047             unit_str = unit.to_string("unscaled")
1048             physical_type = unit.physical_type
1049             if physical_type != "unknown":
1050                 unit_str = f"'{unit_str}' ({physical_type})"
1051             else:
1052                 unit_str = f"'{unit_str}'"
1053             return unit_str
1054 
1055         unit_str = get_err_str(unit)
1056         other_str = get_err_str(other)
1057 
1058         raise UnitConversionError(f"{unit_str} and {other_str} are not convertible")
1059 
1060     def _get_converter(self, other, equivalencies=[]):
1061         """Get a converter for values in ``self`` to ``other``.
1062 
1063         If no conversion is necessary, returns ``unit_scale_converter``
1064         (which is used as a check in quantity helpers).
1065 
1066         """
1067         # First see if it is just a scaling.
1068         try:
1069             scale = self._to(other)
1070         except UnitsError:
1071             pass
1072         else:
1073             if scale == 1.0:
1074                 return unit_scale_converter
1075             else:
1076                 return lambda val: scale * _condition_arg(val)
1077 
1078         # if that doesn't work, maybe we can do it with equivalencies?
1079         try:
1080             return self._apply_equivalencies(
1081                 self, other, self._normalize_equivalencies(equivalencies)
1082             )
1083         except UnitsError as exc:
1084             # Last hope: maybe other knows how to do it?
1085             # We assume the equivalencies have the unit itself as first item.
1086             # TODO: maybe better for other to have a `_back_converter` method?
1087             if hasattr(other, "equivalencies"):
1088                 for funit, tunit, a, b in other.equivalencies:
1089                     if other is funit:
1090                         try:
1091                             converter = self._get_converter(tunit, equivalencies)
1092                         except Exception:
1093                             pass
1094                         else:
1095                             return lambda v: b(converter(v))
1096 
1097             raise exc
1098 
1099     def _to(self, other):
1100         """
1101         Returns the scale to the specified unit.
1102 
1103         See `to`, except that a Unit object should be given (i.e., no
1104         string), and that all defaults are used, i.e., no
1105         equivalencies and value=1.
1106         """
1107         # There are many cases where we just want to ensure a Quantity is
1108         # of a particular unit, without checking whether it's already in
1109         # a particular unit.  If we're being asked to convert from a unit
1110         # to itself, we can short-circuit all of this.
1111         if self is other:
1112             return 1.0
1113 
1114         # Don't presume decomposition is possible; e.g.,
1115         # conversion to function units is through equivalencies.
1116         if isinstance(other, UnitBase):
1117             self_decomposed = self.decompose()
1118             other_decomposed = other.decompose()
1119 
1120             # Check quickly whether equivalent.  This is faster than
1121             # `is_equivalent`, because it doesn't generate the entire
1122             # physical type list of both units.  In other words it "fails
1123             # fast".
1124             if self_decomposed.powers == other_decomposed.powers and all(
1125                 self_base is other_base
1126                 for (self_base, other_base) in zip(
1127                     self_decomposed.bases, other_decomposed.bases
1128                 )
1129             ):
1130                 return self_decomposed.scale / other_decomposed.scale
1131 
1132         raise UnitConversionError(f"'{self!r}' is not a scaled version of '{other!r}'")
1133 
1134     def to(self, other, value=UNITY, equivalencies=[]):
1135         """
1136         Return the converted values in the specified unit.
1137 
1138         Parameters
1139         ----------
1140         other : unit-like
1141             The unit to convert to.
1142 
1143         value : int, float, or scalar array-like, optional
1144             Value(s) in the current unit to be converted to the
1145             specified unit.  If not provided, defaults to 1.0
1146 
1147         equivalencies : list of tuple
1148             A list of equivalence pairs to try if the units are not
1149             directly convertible.  See :ref:`astropy:unit_equivalencies`.
1150             This list is in addition to possible global defaults set by, e.g.,
1151             `set_enabled_equivalencies`.
1152             Use `None` to turn off all equivalencies.
1153 
1154         Returns
1155         -------
1156         values : scalar or array
1157             Converted value(s). Input value sequences are returned as
1158             numpy arrays.
1159 
1160         Raises
1161         ------
1162         UnitsError
1163             If units are inconsistent
1164         """
1165         if other is self and value is UNITY:
1166             return UNITY
1167         else:
1168             return self._get_converter(Unit(other), equivalencies)(value)
1169 
1170     def in_units(self, other, value=1.0, equivalencies=[]):
1171         """
1172         Alias for `to` for backward compatibility with pynbody.
1173         """
1174         return self.to(other, value=value, equivalencies=equivalencies)
1175 
1176     def decompose(self, bases=set()):
1177         """
1178         Return a unit object composed of only irreducible units.
1179 
1180         Parameters
1181         ----------
1182         bases : sequence of UnitBase, optional
1183             The bases to decompose into.  When not provided,
1184             decomposes down to any irreducible units.  When provided,
1185             the decomposed result will only contain the given units.
1186             This will raises a `UnitsError` if it's not possible
1187             to do so.
1188 
1189         Returns
1190         -------
1191         unit : `~astropy.units.CompositeUnit`
1192             New object containing only irreducible unit objects.
1193         """
1194         raise NotImplementedError()
1195 
1196     def _compose(
1197         self, equivalencies=[], namespace=[], max_depth=2, depth=0, cached_results=None
1198     ):
1199         def is_final_result(unit):
1200             # Returns True if this result contains only the expected
1201             # units
1202             return all(base in namespace for base in unit.bases)
1203 
1204         unit = self.decompose()
1205         key = hash(unit)
1206 
1207         cached = cached_results.get(key)
1208         if cached is not None:
1209             if isinstance(cached, Exception):
1210                 raise cached
1211             return cached
1212 
1213         # Prevent too many levels of recursion
1214         # And special case for dimensionless unit
1215         if depth >= max_depth:
1216             cached_results[key] = [unit]
1217             return [unit]
1218 
1219         # Make a list including all of the equivalent units
1220         units = [unit]
1221         for funit, tunit, a, b in equivalencies:
1222             if tunit is not None:
1223                 if self._is_equivalent(funit):
1224                     scale = funit.decompose().scale / unit.scale
1225                     units.append(Unit(a(1.0 / scale) * tunit).decompose())
1226                 elif self._is_equivalent(tunit):
1227                     scale = tunit.decompose().scale / unit.scale
1228                     units.append(Unit(b(1.0 / scale) * funit).decompose())
1229             else:
1230                 if self._is_equivalent(funit):
1231                     units.append(Unit(unit.scale))
1232 
1233         # Store partial results
1234         partial_results = []
1235         # Store final results that reduce to a single unit or pair of
1236         # units
1237         if len(unit.bases) == 0:
1238             final_results = [{unit}, set()]
1239         else:
1240             final_results = [set(), set()]
1241 
1242         for tunit in namespace:
1243             tunit_decomposed = tunit.decompose()
1244             for u in units:
1245                 # If the unit is a base unit, look for an exact match
1246                 # to one of the bases of the target unit.  If found,
1247                 # factor by the same power as the target unit's base.
1248                 # This allows us to factor out fractional powers
1249                 # without needing to do an exhaustive search.
1250                 if len(tunit_decomposed.bases) == 1:
1251                     for base, power in zip(u.bases, u.powers):
1252                         if tunit_decomposed._is_equivalent(base):
1253                             tunit = tunit**power
1254                             tunit_decomposed = tunit_decomposed**power
1255                             break
1256 
1257                 composed = (u / tunit_decomposed).decompose()
1258                 factored = composed * tunit
1259                 len_bases = len(composed.bases)
1260                 if is_final_result(factored) and len_bases <= 1:
1261                     final_results[len_bases].add(factored)
1262                 else:
1263                     partial_results.append((len_bases, composed, tunit))
1264 
1265         # Do we have any minimal results?
1266         for final_result in final_results:
1267             if len(final_result):
1268                 results = final_results[0].union(final_results[1])
1269                 cached_results[key] = results
1270                 return results
1271 
1272         partial_results.sort(key=operator.itemgetter(0))
1273 
1274         # ...we have to recurse and try to further compose
1275         results = []
1276         for len_bases, composed, tunit in partial_results:
1277             try:
1278                 composed_list = composed._compose(
1279                     equivalencies=equivalencies,
1280                     namespace=namespace,
1281                     max_depth=max_depth,
1282                     depth=depth + 1,
1283                     cached_results=cached_results,
1284                 )
1285             except UnitsError:
1286                 composed_list = []
1287             for subcomposed in composed_list:
1288                 results.append((len(subcomposed.bases), subcomposed, tunit))
1289 
1290         if len(results):
1291             results.sort(key=operator.itemgetter(0))
1292 
1293             min_length = results[0][0]
1294             subresults = set()
1295             for len_bases, composed, tunit in results:
1296                 if len_bases > min_length:
1297                     break
1298                 else:
1299                     factored = composed * tunit
1300                     if is_final_result(factored):
1301                         subresults.add(factored)
1302 
1303             if len(subresults):
1304                 cached_results[key] = subresults
1305                 return subresults
1306 
1307         if not is_final_result(self):
1308             result = UnitsError(
1309                 f"Cannot represent unit {self} in terms of the given units"
1310             )
1311             cached_results[key] = result
1312             raise result
1313 
1314         cached_results[key] = [self]
1315         return [self]
1316 
1317     def compose(
1318         self, equivalencies=[], units=None, max_depth=2, include_prefix_units=None
1319     ):
1320         """
1321         Return the simplest possible composite unit(s) that represent
1322         the given unit.  Since there may be multiple equally simple
1323         compositions of the unit, a list of units is always returned.
1324 
1325         Parameters
1326         ----------
1327         equivalencies : list of tuple
1328             A list of equivalence pairs to also list.  See
1329             :ref:`astropy:unit_equivalencies`.
1330             This list is in addition to possible global defaults set by, e.g.,
1331             `set_enabled_equivalencies`.
1332             Use `None` to turn off all equivalencies.
1333 
1334         units : set of `~astropy.units.Unit`, optional
1335             If not provided, any known units may be used to compose
1336             into.  Otherwise, ``units`` is a dict, module or sequence
1337             containing the units to compose into.
1338 
1339         max_depth : int, optional
1340             The maximum recursion depth to use when composing into
1341             composite units.
1342 
1343         include_prefix_units : bool, optional
1344             When `True`, include prefixed units in the result.
1345             Default is `True` if a sequence is passed in to ``units``,
1346             `False` otherwise.
1347 
1348         Returns
1349         -------
1350         units : list of `CompositeUnit`
1351             A list of candidate compositions.  These will all be
1352             equally simple, but it may not be possible to
1353             automatically determine which of the candidates are
1354             better.
1355         """
1356         # if units parameter is specified and is a sequence (list|tuple),
1357         # include_prefix_units is turned on by default.  Ex: units=[u.kpc]
1358         if include_prefix_units is None:
1359             include_prefix_units = isinstance(units, (list, tuple))
1360 
1361         # Pre-normalize the equivalencies list
1362         equivalencies = self._normalize_equivalencies(equivalencies)
1363 
1364         # The namespace of units to compose into should be filtered to
1365         # only include units with bases in common with self, otherwise
1366         # they can't possibly provide useful results.  Having too many
1367         # destination units greatly increases the search space.
1368 
1369         def has_bases_in_common(a, b):
1370             if len(a.bases) == 0 and len(b.bases) == 0:
1371                 return True
1372             for ab in a.bases:
1373                 for bb in b.bases:
1374                     if ab == bb:
1375                         return True
1376             return False
1377 
1378         def has_bases_in_common_with_equiv(unit, other):
1379             if has_bases_in_common(unit, other):
1380                 return True
1381             for funit, tunit, a, b in equivalencies:
1382                 if tunit is not None:
1383                     if unit._is_equivalent(funit):
1384                         if has_bases_in_common(tunit.decompose(), other):
1385                             return True
1386                     elif unit._is_equivalent(tunit):
1387                         if has_bases_in_common(funit.decompose(), other):
1388                             return True
1389                 else:
1390                     if unit._is_equivalent(funit):
1391                         if has_bases_in_common(dimensionless_unscaled, other):
1392                             return True
1393             return False
1394 
1395         def filter_units(units):
1396             filtered_namespace = set()
1397             for tunit in units:
1398                 if (
1399                     isinstance(tunit, UnitBase)
1400                     and (include_prefix_units or not isinstance(tunit, PrefixUnit))
1401                     and has_bases_in_common_with_equiv(decomposed, tunit.decompose())
1402                 ):
1403                     filtered_namespace.add(tunit)
1404             return filtered_namespace
1405 
1406         decomposed = self.decompose()
1407 
1408         if units is None:
1409             units = filter_units(self._get_units_with_same_physical_type(equivalencies))
1410             if len(units) == 0:
1411                 units = get_current_unit_registry().non_prefix_units
1412         elif isinstance(units, dict):
1413             units = set(filter_units(units.values()))
1414         elif inspect.ismodule(units):
1415             units = filter_units(vars(units).values())
1416         else:
1417             units = filter_units(_flatten_units_collection(units))
1418 
1419         def sort_results(results):
1420             if not len(results):
1421                 return []
1422 
1423             # Sort the results so the simplest ones appear first.
1424             # Simplest is defined as "the minimum sum of absolute
1425             # powers" (i.e. the fewest bases), and preference should
1426             # be given to results where the sum of powers is positive
1427             # and the scale is exactly equal to 1.0
1428             results = list(results)
1429             results.sort(key=lambda x: np.abs(x.scale))
1430             results.sort(key=lambda x: np.sum(np.abs(x.powers)))
1431             results.sort(key=lambda x: np.sum(x.powers) < 0.0)
1432             results.sort(key=lambda x: not is_effectively_unity(x.scale))
1433 
1434             last_result = results[0]
1435             filtered = [last_result]
1436             for result in results[1:]:
1437                 if str(result) != str(last_result):
1438                     filtered.append(result)
1439                 last_result = result
1440 
1441             return filtered
1442 
1443         return sort_results(
1444             self._compose(
1445                 equivalencies=equivalencies,
1446                 namespace=units,
1447                 max_depth=max_depth,
1448                 depth=0,
1449                 cached_results={},
1450             )
1451         )
1452 
1453     def to_system(self, system):
1454         """
1455         Converts this unit into ones belonging to the given system.
1456         Since more than one result may be possible, a list is always
1457         returned.
1458 
1459         Parameters
1460         ----------
1461         system : module
1462             The module that defines the unit system.  Commonly used
1463             ones include `astropy.units.si` and `astropy.units.cgs`.
1464 
1465             To use your own module it must contain unit objects and a
1466             sequence member named ``bases`` containing the base units of
1467             the system.
1468 
1469         Returns
1470         -------
1471         units : list of `CompositeUnit`
1472             The list is ranked so that units containing only the base
1473             units of that system will appear first.
1474         """
1475         bases = set(system.bases)
1476 
1477         def score(compose):
1478             # In case that compose._bases has no elements we return
1479             # 'np.inf' as 'score value'.  It does not really matter which
1480             # number we would return. This case occurs for instance for
1481             # dimensionless quantities:
1482             compose_bases = compose.bases
1483             if len(compose_bases) == 0:
1484                 return np.inf
1485             else:
1486                 sum = 0
1487                 for base in compose_bases:
1488                     if base in bases:
1489                         sum += 1
1490 
1491                 return sum / float(len(compose_bases))
1492 
1493         x = self.decompose(bases=bases)
1494         composed = x.compose(units=system)
1495         composed = sorted(composed, key=score, reverse=True)
1496         return composed
1497 
1498     @lazyproperty
1499     def si(self):
1500         """
1501         Returns a copy of the current `Unit` instance in SI units.
1502         """
1503         from . import si
1504 
1505         return self.to_system(si)[0]
1506 
1507     @lazyproperty
1508     def cgs(self):
1509         """
1510         Returns a copy of the current `Unit` instance with CGS units.
1511         """
1512         from . import cgs
1513 
1514         return self.to_system(cgs)[0]
1515 
1516     @property
1517     def physical_type(self):
1518         """
1519         Physical type(s) dimensionally compatible with the unit.
1520 
1521         Returns
1522         -------
1523         `~astropy.units.physical.PhysicalType`
1524             A representation of the physical type(s) of a unit.
1525 
1526         Examples
1527         --------
1528         >>> from astropy import units as u
1529         >>> u.m.physical_type
1530         PhysicalType('length')
1531         >>> (u.m ** 2 / u.s).physical_type
1532         PhysicalType({'diffusivity', 'kinematic viscosity'})
1533 
1534         Physical types can be compared to other physical types
1535         (recommended in packages) or to strings.
1536 
1537         >>> area = (u.m ** 2).physical_type
1538         >>> area == u.m.physical_type ** 2
1539         True
1540         >>> area == "area"
1541         True
1542 
1543         `~astropy.units.physical.PhysicalType` objects can be used for
1544         dimensional analysis.
1545 
1546         >>> number_density = u.m.physical_type ** -3
1547         >>> velocity = (u.m / u.s).physical_type
1548         >>> number_density * velocity
1549         PhysicalType('particle flux')
1550         """
1551         from . import physical
1552 
1553         return physical.get_physical_type(self)
1554 
1555     def _get_units_with_same_physical_type(self, equivalencies=[]):
1556         """
1557         Return a list of registered units with the same physical type
1558         as this unit.
1559 
1560         This function is used by Quantity to add its built-in
1561         conversions to equivalent units.
1562 
1563         This is a private method, since end users should be encouraged
1564         to use the more powerful `compose` and `find_equivalent_units`
1565         methods (which use this under the hood).
1566 
1567         Parameters
1568         ----------
1569         equivalencies : list of tuple
1570             A list of equivalence pairs to also pull options from.
1571             See :ref:`astropy:unit_equivalencies`.  It must already be
1572             normalized using `_normalize_equivalencies`.
1573         """
1574         unit_registry = get_current_unit_registry()
1575         units = set(unit_registry.get_units_with_physical_type(self))
1576         for funit, tunit, a, b in equivalencies:
1577             if tunit is not None:
1578                 if self.is_equivalent(funit) and tunit not in units:
1579                     units.update(unit_registry.get_units_with_physical_type(tunit))
1580                 if self._is_equivalent(tunit) and funit not in units:
1581                     units.update(unit_registry.get_units_with_physical_type(funit))
1582             else:
1583                 if self.is_equivalent(funit):
1584                     units.add(dimensionless_unscaled)
1585         return units
1586 
1587     class EquivalentUnitsList(list):
1588         """
1589         A class to handle pretty-printing the result of
1590         `find_equivalent_units`.
1591         """
1592 
1593         HEADING_NAMES = ("Primary name", "Unit definition", "Aliases")
1594         ROW_LEN = 3  # len(HEADING_NAMES), but hard-code since it is constant
1595         NO_EQUIV_UNITS_MSG = "There are no equivalent units"
1596 
1597         def __repr__(self):
1598             if len(self) == 0:
1599                 return self.NO_EQUIV_UNITS_MSG
1600             else:
1601                 lines = self._process_equivalent_units(self)
1602                 lines.insert(0, self.HEADING_NAMES)
1603                 widths = [0] * self.ROW_LEN
1604                 for line in lines:
1605                     for i, col in enumerate(line):
1606                         widths[i] = max(widths[i], len(col))
1607 
1608                 f = "  {{0:<{}s}} | {{1:<{}s}} | {{2:<{}s}}".format(*widths)
1609                 lines = [f.format(*line) for line in lines]
1610                 lines = lines[0:1] + ["["] + [f"{x} ," for x in lines[1:]] + ["]"]
1611                 return "\n".join(lines)
1612 
1613         def _repr_html_(self):
1614             """
1615             Outputs a HTML table representation within Jupyter notebooks.
1616             """
1617             if len(self) == 0:
1618                 return f"<p>{self.NO_EQUIV_UNITS_MSG}</p>"
1619             else:
1620                 # HTML tags to use to compose the table in HTML
1621                 blank_table = '<table style="width:50%">{}</table>'
1622                 blank_row_container = "<tr>{}</tr>"
1623                 heading_row_content = "<th>{}</th>" * self.ROW_LEN
1624                 data_row_content = "<td>{}</td>" * self.ROW_LEN
1625 
1626                 # The HTML will be rendered & the table is simple, so don't
1627                 # bother to include newlines & indentation for the HTML code.
1628                 heading_row = blank_row_container.format(
1629                     heading_row_content.format(*self.HEADING_NAMES)
1630                 )
1631                 data_rows = self._process_equivalent_units(self)
1632                 all_rows = heading_row
1633                 for row in data_rows:
1634                     html_row = blank_row_container.format(data_row_content.format(*row))
1635                     all_rows += html_row
1636                 return blank_table.format(all_rows)
1637 
1638         @staticmethod
1639         def _process_equivalent_units(equiv_units_data):
1640             """
1641             Extract attributes, and sort, the equivalent units pre-formatting.
1642             """
1643             processed_equiv_units = []
1644             for u in equiv_units_data:
1645                 irred = u.decompose().to_string()
1646                 if irred == u.name:
1647                     irred = "irreducible"
1648                 processed_equiv_units.append((u.name, irred, ", ".join(u.aliases)))
1649             processed_equiv_units.sort()
1650             return processed_equiv_units
1651 
1652     def find_equivalent_units(
1653         self, equivalencies=[], units=None, include_prefix_units=False
1654     ):
1655         """
1656         Return a list of all the units that are the same type as ``self``.
1657 
1658         Parameters
1659         ----------
1660         equivalencies : list of tuple
1661             A list of equivalence pairs to also list.  See
1662             :ref:`astropy:unit_equivalencies`.
1663             Any list given, including an empty one, supersedes global defaults
1664             that may be in effect (as set by `set_enabled_equivalencies`)
1665 
1666         units : set of `~astropy.units.Unit`, optional
1667             If not provided, all defined units will be searched for
1668             equivalencies.  Otherwise, may be a dict, module or
1669             sequence containing the units to search for equivalencies.
1670 
1671         include_prefix_units : bool, optional
1672             When `True`, include prefixed units in the result.
1673             Default is `False`.
1674 
1675         Returns
1676         -------
1677         units : list of `UnitBase`
1678             A list of unit objects that match ``u``.  A subclass of
1679             `list` (``EquivalentUnitsList``) is returned that
1680             pretty-prints the list of units when output.
1681         """
1682         results = self.compose(
1683             equivalencies=equivalencies,
1684             units=units,
1685             max_depth=1,
1686             include_prefix_units=include_prefix_units,
1687         )
1688         results = {x.bases[0] for x in results if len(x.bases) == 1}
1689         return self.EquivalentUnitsList(results)
1690 
1691     def is_unity(self):
1692         """
1693         Returns `True` if the unit is unscaled and dimensionless.
1694         """
1695         return False
1696 
1697 
1698 class NamedUnit(UnitBase):
1699     """
1700     The base class of units that have a name.
1701 
1702     Parameters
1703     ----------
1704     st : str, list of str, 2-tuple
1705         The name of the unit.  If a list of strings, the first element
1706         is the canonical (short) name, and the rest of the elements
1707         are aliases.  If a tuple of lists, the first element is a list
1708         of short names, and the second element is a list of long
1709         names; all but the first short name are considered "aliases".
1710         Each name *should* be a valid Python identifier to make it
1711         easy to access, but this is not required.
1712 
1713     namespace : dict, optional
1714         When provided, inject the unit, and all of its aliases, in the
1715         given namespace dictionary.  If a unit by the same name is
1716         already in the namespace, a ValueError is raised.
1717 
1718     doc : str, optional
1719         A docstring describing the unit.
1720 
1721     format : dict, optional
1722         A mapping to format-specific representations of this unit.
1723         For example, for the ``Ohm`` unit, it might be nice to have it
1724         displayed as ``\\Omega`` by the ``latex`` formatter.  In that
1725         case, `format` argument should be set to::
1726 
1727             {'latex': r'\\Omega'}
1728 
1729     Raises
1730     ------
1731     ValueError
1732         If any of the given unit names are already in the registry.
1733 
1734     ValueError
1735         If any of the given unit names are not valid Python tokens.
1736     """
1737 
1738     def __init__(self, st, doc=None, format=None, namespace=None):
1739         UnitBase.__init__(self)
1740 
1741         if isinstance(st, (bytes, str)):
1742             self._names = [st]
1743             self._short_names = [st]
1744             self._long_names = []
1745         elif isinstance(st, tuple):
1746             if not len(st) == 2:
1747                 raise ValueError("st must be string, list or 2-tuple")
1748             self._names = st[0] + [n for n in st[1] if n not in st[0]]
1749             if not len(self._names):
1750                 raise ValueError("must provide at least one name")
1751             self._short_names = st[0][:]
1752             self._long_names = st[1][:]
1753         else:
1754             if len(st) == 0:
1755                 raise ValueError("st list must have at least one entry")
1756             self._names = st[:]
1757             self._short_names = [st[0]]
1758             self._long_names = st[1:]
1759 
1760         if format is None:
1761             format = {}
1762         self._format = format
1763 
1764         if doc is None:
1765             doc = self._generate_doc()
1766         else:
1767             doc = textwrap.dedent(doc)
1768             doc = textwrap.fill(doc)
1769 
1770         self.__doc__ = doc
1771 
1772         self._inject(namespace)
1773 
1774     def _generate_doc(self):
1775         """
1776         Generate a docstring for the unit if the user didn't supply
1777         one.  This is only used from the constructor and may be
1778         overridden in subclasses.
1779         """
1780         names = self.names
1781         if len(self.names) > 1:
1782             return f"{names[1]} ({names[0]})"
1783         else:
1784             return names[0]
1785 
1786     def get_format_name(self, format):
1787         """
1788         Get a name for this unit that is specific to a particular
1789         format.
1790 
1791         Uses the dictionary passed into the `format` kwarg in the
1792         constructor.
1793 
1794         Parameters
1795         ----------
1796         format : str
1797             The name of the format
1798 
1799         Returns
1800         -------
1801         name : str
1802             The name of the unit for the given format.
1803         """
1804         return self._format.get(format, self.name)
1805 
1806     @property
1807     def names(self):
1808         """
1809         Returns all of the names associated with this unit.
1810         """
1811         return self._names
1812 
1813     @property
1814     def name(self):
1815         """
1816         Returns the canonical (short) name associated with this unit.
1817         """
1818         return self._names[0]
1819 
1820     @property
1821     def aliases(self):
1822         """
1823         Returns the alias (long) names for this unit.
1824         """
1825         return self._names[1:]
1826 
1827     @property
1828     def short_names(self):
1829         """
1830         Returns all of the short names associated with this unit.
1831         """
1832         return self._short_names
1833 
1834     @property
1835     def long_names(self):
1836         """
1837         Returns all of the long names associated with this unit.
1838         """
1839         return self._long_names
1840 
1841     def _inject(self, namespace=None):
1842         """
1843         Injects the unit, and all of its aliases, in the given
1844         namespace dictionary.
1845         """
1846         if namespace is None:
1847             return
1848 
1849         # Loop through all of the names first, to ensure all of them
1850         # are new, then add them all as a single "transaction" below.
1851         for name in self._names:
1852             if name in namespace and self != namespace[name]:
1853                 raise ValueError(
1854                     f"Object with name {name!r} already exists in "
1855                     f"given namespace ({namespace[name]!r})."
1856                 )
1857 
1858         for name in self._names:
1859             namespace[name] = self
1860 
1861 
1862 def _recreate_irreducible_unit(cls, names, registered):
1863     """
1864     This is used to reconstruct units when passed around by
1865     multiprocessing.
1866     """
1867     registry = get_current_unit_registry().registry
1868     if names[0] in registry:
1869         # If in local registry return that object.
1870         return registry[names[0]]
1871     else:
1872         # otherwise, recreate the unit.
1873         unit = cls(names)
1874         if registered:
1875             # If not in local registry but registered in origin registry,
1876             # enable unit in local registry.
1877             get_current_unit_registry().add_enabled_units([unit])
1878 
1879         return unit
1880 
1881 
1882 class IrreducibleUnit(NamedUnit):
1883     """
1884     Irreducible units are the units that all other units are defined
1885     in terms of.
1886 
1887     Examples are meters, seconds, kilograms, amperes, etc.  There is
1888     only once instance of such a unit per type.
1889     """
1890 
1891     def __reduce__(self):
1892         # When IrreducibleUnit objects are passed to other processes
1893         # over multiprocessing, they need to be recreated to be the
1894         # ones already in the subprocesses' namespace, not new
1895         # objects, or they will be considered "unconvertible".
1896         # Therefore, we have a custom pickler/unpickler that
1897         # understands how to recreate the Unit on the other side.
1898         registry = get_current_unit_registry().registry
1899         return (
1900             _recreate_irreducible_unit,
1901             (self.__class__, list(self.names), self.name in registry),
1902             self.__getstate__(),
1903         )
1904 
1905     @property
1906     def represents(self):
1907         """The unit that this named unit represents.
1908 
1909         For an irreducible unit, that is always itself.
1910         """
1911         return self
1912 
1913     def decompose(self, bases=set()):
1914         if len(bases) and self not in bases:
1915             for base in bases:
1916                 try:
1917                     scale = self._to(base)
1918                 except UnitsError:
1919                     pass
1920                 else:
1921                     if is_effectively_unity(scale):
1922                         return base
1923                     else:
1924                         return CompositeUnit(scale, [base], [1], _error_check=False)
1925 
1926             raise UnitConversionError(
1927                 f"Unit {self} can not be decomposed into the requested bases"
1928             )
1929 
1930         return self
1931 
1932 
1933 class UnrecognizedUnit(IrreducibleUnit):
1934     """
1935     A unit that did not parse correctly.  This allows for
1936     round-tripping it as a string, but no unit operations actually work
1937     on it.
1938 
1939     Parameters
1940     ----------
1941     st : str
1942         The name of the unit.
1943     """
1944 
1945     # For UnrecognizedUnits, we want to use "standard" Python
1946     # pickling, not the special case that is used for
1947     # IrreducibleUnits.
1948     __reduce__ = object.__reduce__
1949 
1950     def __repr__(self):
1951         return f"UnrecognizedUnit({str(self)})"
1952 
1953     def __bytes__(self):
1954         return self.name.encode("ascii", "replace")
1955 
1956     def __str__(self):
1957         return self.name
1958 
1959     def to_string(self, format=None):
1960         return self.name
1961 
1962     def _unrecognized_operator(self, *args, **kwargs):
1963         raise ValueError(
1964             f"The unit {self.name!r} is unrecognized, so all arithmetic operations "
1965             "with it are invalid."
1966         )
1967 
1968     __pow__ = __truediv__ = __rtruediv__ = __mul__ = __rmul__ = _unrecognized_operator
1969     __lt__ = __gt__ = __le__ = __ge__ = __neg__ = _unrecognized_operator
1970 
1971     def __eq__(self, other):
1972         try:
1973             other = Unit(other, parse_strict="silent")
1974         except (ValueError, UnitsError, TypeError):
1975             return NotImplemented
1976 
1977         return isinstance(other, type(self)) and self.name == other.name
1978 
1979     def __ne__(self, other):
1980         return not (self == other)
1981 
1982     def is_equivalent(self, other, equivalencies=None):
1983         self._normalize_equivalencies(equivalencies)
1984         return self == other
1985 
1986     def _get_converter(self, other, equivalencies=None):
1987         self._normalize_equivalencies(equivalencies)
1988         raise ValueError(
1989             f"The unit {self.name!r} is unrecognized.  It can not be converted "
1990             "to other units."
1991         )
1992 
1993     def get_format_name(self, format):
1994         return self.name
1995 
1996     def is_unity(self):
1997         return False
1998 
1999 
2000 class _UnitMetaClass(type):
2001     """
2002     This metaclass exists because the Unit constructor should
2003     sometimes return instances that already exist.  This "overrides"
2004     the constructor before the new instance is actually created, so we
2005     can return an existing one.
2006     """
2007 
2008     def __call__(
2009         self,
2010         s="",
2011         represents=None,
2012         format=None,
2013         namespace=None,
2014         doc=None,
2015         parse_strict="raise",
2016     ):
2017         # Short-circuit if we're already a unit
2018         if hasattr(s, "_get_physical_type_id"):
2019             return s
2020 
2021         # turn possible Quantity input for s or represents into a Unit
2022         from .quantity import Quantity
2023 
2024         if isinstance(represents, Quantity):
2025             if is_effectively_unity(represents.value):
2026                 represents = represents.unit
2027             else:
2028                 represents = CompositeUnit(
2029                     represents.value * represents.unit.scale,
2030                     bases=represents.unit.bases,
2031                     powers=represents.unit.powers,
2032                     _error_check=False,
2033                 )
2034 
2035         if isinstance(s, Quantity):
2036             if is_effectively_unity(s.value):
2037                 s = s.unit
2038             else:
2039                 s = CompositeUnit(
2040                     s.value * s.unit.scale,
2041                     bases=s.unit.bases,
2042                     powers=s.unit.powers,
2043                     _error_check=False,
2044                 )
2045 
2046         # now decide what we really need to do; define derived Unit?
2047         if isinstance(represents, UnitBase):
2048             # This has the effect of calling the real __new__ and
2049             # __init__ on the Unit class.
2050             return super().__call__(
2051                 s, represents, format=format, namespace=namespace, doc=doc
2052             )
2053 
2054         # or interpret a Quantity (now became unit), string or number?
2055         if isinstance(s, UnitBase):
2056             return s
2057 
2058         elif isinstance(s, (bytes, str)):
2059             if len(s.strip()) == 0:
2060                 # Return the NULL unit
2061                 return dimensionless_unscaled
2062 
2063             if format is None:
2064                 format = unit_format.Generic
2065 
2066             f = unit_format.get_format(format)
2067             if isinstance(s, bytes):
2068                 s = s.decode("ascii")
2069 
2070             try:
2071                 return f.parse(s)
2072             except NotImplementedError:
2073                 raise
2074             except Exception as e:
2075                 if parse_strict == "silent":
2076                     pass
2077                 else:
2078                     # Deliberately not issubclass here. Subclasses
2079                     # should use their name.
2080                     if f is not unit_format.Generic:
2081                         format_clause = f.name + " "
2082                     else:
2083                         format_clause = ""
2084                     msg = (
2085                         f"'{s}' did not parse as {format_clause}unit: {str(e)} "
2086                         "If this is meant to be a custom unit, "
2087                         "define it with 'u.def_unit'. To have it "
2088                         "recognized inside a file reader or other code, "
2089                         "enable it with 'u.add_enabled_units'. "
2090                         "For details, see "
2091                         "https://docs.astropy.org/en/latest/units/combining_and_defining.html"
2092                     )
2093                     if parse_strict == "raise":
2094                         raise ValueError(msg)
2095                     elif parse_strict == "warn":
2096                         warnings.warn(msg, UnitsWarning)
2097                     else:
2098                         raise ValueError(
2099                             "'parse_strict' must be 'warn', 'raise' or 'silent'"
2100                         )
2101                 return UnrecognizedUnit(s)
2102 
2103         elif isinstance(s, (int, float, np.floating, np.integer)):
2104             return CompositeUnit(s, [], [], _error_check=False)
2105 
2106         elif isinstance(s, tuple):
2107             from .structured import StructuredUnit
2108 
2109             return StructuredUnit(s)
2110 
2111         elif s is None:
2112             raise TypeError("None is not a valid Unit")
2113 
2114         else:
2115             raise TypeError(f"{s} can not be converted to a Unit")
2116 
2117 
2118 class Unit(NamedUnit, metaclass=_UnitMetaClass):
2119     """
2120     The main unit class.
2121 
2122     There are a number of different ways to construct a Unit, but
2123     always returns a `UnitBase` instance.  If the arguments refer to
2124     an already-existing unit, that existing unit instance is returned,
2125     rather than a new one.
2126 
2127     - From a string::
2128 
2129         Unit(s, format=None, parse_strict='silent')
2130 
2131       Construct from a string representing a (possibly compound) unit.
2132 
2133       The optional `format` keyword argument specifies the format the
2134       string is in, by default ``"generic"``.  For a description of
2135       the available formats, see `astropy.units.format`.
2136 
2137       The optional ``parse_strict`` keyword controls what happens when an
2138       unrecognized unit string is passed in.  It may be one of the following:
2139 
2140          - ``'raise'``: (default) raise a ValueError exception.
2141 
2142          - ``'warn'``: emit a Warning, and return an
2143            `UnrecognizedUnit` instance.
2144 
2145          - ``'silent'``: return an `UnrecognizedUnit` instance.
2146 
2147     - From a number::
2148 
2149         Unit(number)
2150 
2151       Creates a dimensionless unit.
2152 
2153     - From a `UnitBase` instance::
2154 
2155         Unit(unit)
2156 
2157       Returns the given unit unchanged.
2158 
2159     - From no arguments::
2160 
2161         Unit()
2162 
2163       Returns the dimensionless unit.
2164 
2165     - The last form, which creates a new `Unit` is described in detail
2166       below.
2167 
2168     See also: https://docs.astropy.org/en/stable/units/
2169 
2170     Parameters
2171     ----------
2172     st : str or list of str
2173         The name of the unit.  If a list, the first element is the
2174         canonical (short) name, and the rest of the elements are
2175         aliases.
2176 
2177     represents : UnitBase instance
2178         The unit that this named unit represents.
2179 
2180     doc : str, optional
2181         A docstring describing the unit.
2182 
2183     format : dict, optional
2184         A mapping to format-specific representations of this unit.
2185         For example, for the ``Ohm`` unit, it might be nice to have it
2186         displayed as ``\\Omega`` by the ``latex`` formatter.  In that
2187         case, `format` argument should be set to::
2188 
2189             {'latex': r'\\Omega'}
2190 
2191     namespace : dict, optional
2192         When provided, inject the unit (and all of its aliases) into
2193         the given namespace.
2194 
2195     Raises
2196     ------
2197     ValueError
2198         If any of the given unit names are already in the registry.
2199 
2200     ValueError
2201         If any of the given unit names are not valid Python tokens.
2202     """
2203 
2204     def __init__(self, st, represents=None, doc=None, format=None, namespace=None):
2205         represents = Unit(represents)
2206         self._represents = represents
2207 
2208         NamedUnit.__init__(self, st, namespace=namespace, doc=doc, format=format)
2209 
2210     @property
2211     def represents(self):
2212         """The unit that this named unit represents."""
2213         return self._represents
2214 
2215     def decompose(self, bases=set()):
2216         return self._represents.decompose(bases=bases)
2217 
2218     def is_unity(self):
2219         return self._represents.is_unity()
2220 
2221     def __hash__(self):
2222         if self._hash is None:
2223             self._hash = hash((self.name, self._represents))
2224         return self._hash
2225 
2226     @classmethod
2227     def _from_physical_type_id(cls, physical_type_id):
2228         # get string bases and powers from the ID tuple
2229         bases = [cls(base) for base, _ in physical_type_id]
2230         powers = [power for _, power in physical_type_id]
2231 
2232         if len(physical_type_id) == 1 and powers[0] == 1:
2233             unit = bases[0]
2234         else:
2235             unit = CompositeUnit(1, bases, powers, _error_check=False)
2236 
2237         return unit
2238 
2239 
2240 class PrefixUnit(Unit):
2241     """
2242     A unit that is simply a SI-prefixed version of another unit.
2243 
2244     For example, ``mm`` is a `PrefixUnit` of ``.001 * m``.
2245 
2246     The constructor is the same as for `Unit`.
2247     """
2248 
2249 
2250 class CompositeUnit(UnitBase):
2251     """
2252     Create a composite unit using expressions of previously defined
2253     units.
2254 
2255     Direct use of this class is not recommended. Instead use the
2256     factory function `Unit` and arithmetic operators to compose
2257     units.
2258 
2259     Parameters
2260     ----------
2261     scale : number
2262         A scaling factor for the unit.
2263 
2264     bases : sequence of `UnitBase`
2265         A sequence of units this unit is composed of.
2266 
2267     powers : sequence of numbers
2268         A sequence of powers (in parallel with ``bases``) for each
2269         of the base units.
2270     """
2271 
2272     _decomposed_cache = None
2273 
2274     def __init__(
2275         self,
2276         scale,
2277         bases,
2278         powers,
2279         decompose=False,
2280         decompose_bases=set(),
2281         _error_check=True,
2282     ):
2283         # There are many cases internal to astropy.units where we
2284         # already know that all the bases are Unit objects, and the
2285         # powers have been validated.  In those cases, we can skip the
2286         # error checking for performance reasons.  When the private
2287         # kwarg `_error_check` is False, the error checking is turned
2288         # off.
2289         if _error_check:
2290             for base in bases:
2291                 if not isinstance(base, UnitBase):
2292                     raise TypeError("bases must be sequence of UnitBase instances")
2293             powers = [validate_power(p) for p in powers]
2294 
2295         if not decompose and len(bases) == 1 and powers[0] >= 0:
2296             # Short-cut; with one unit there's nothing to expand and gather,
2297             # as that has happened already when creating the unit.  But do only
2298             # positive powers, since for negative powers we need to re-sort.
2299             unit = bases[0]
2300             power = powers[0]
2301             if power == 1:
2302                 scale *= unit.scale
2303                 self._bases = unit.bases
2304                 self._powers = unit.powers
2305             elif power == 0:
2306                 self._bases = []
2307                 self._powers = []
2308             else:
2309                 scale *= unit.scale**power
2310                 self._bases = unit.bases
2311                 self._powers = [
2312                     operator.mul(*resolve_fractions(p, power)) for p in unit.powers
2313                 ]
2314 
2315             self._scale = sanitize_scale(scale)
2316         else:
2317             # Regular case: use inputs as preliminary scale, bases, and powers,
2318             # then "expand and gather" identical bases, sanitize the scale, &c.
2319             self._scale = scale
2320             self._bases = bases
2321             self._powers = powers
2322             self._expand_and_gather(decompose=decompose, bases=decompose_bases)
2323 
2324     def __repr__(self):
2325         if len(self._bases):
2326             return super().__repr__()
2327         else:
2328             if self._scale != 1.0:
2329                 return f"Unit(dimensionless with a scale of {self._scale})"
2330             else:
2331                 return "Unit(dimensionless)"
2332 
2333     @property
2334     def scale(self):
2335         """
2336         Return the scale of the composite unit.
2337         """
2338         return self._scale
2339 
2340     @property
2341     def bases(self):
2342         """
2343         Return the bases of the composite unit.
2344         """
2345         return self._bases
2346 
2347     @property
2348     def powers(self):
2349         """
2350         Return the powers of the composite unit.
2351         """
2352         return self._powers
2353 
2354     def _expand_and_gather(self, decompose=False, bases=set()):
2355         def add_unit(unit, power, scale):
2356             if bases and unit not in bases:
2357                 for base in bases:
2358                     try:
2359                         scale *= unit._to(base) ** power
2360                     except UnitsError:
2361                         pass
2362                     else:
2363                         unit = base
2364                         break
2365 
2366             if unit in new_parts:
2367                 a, b = resolve_fractions(new_parts[unit], power)
2368                 new_parts[unit] = a + b
2369             else:
2370                 new_parts[unit] = power
2371             return scale
2372 
2373         new_parts = {}
2374         scale = self._scale
2375 
2376         for b, p in zip(self._bases, self._powers):
2377             if decompose and b not in bases:
2378                 b = b.decompose(bases=bases)
2379 
2380             if isinstance(b, CompositeUnit):
2381                 scale *= b._scale**p
2382                 for b_sub, p_sub in zip(b._bases, b._powers):
2383                     a, b = resolve_fractions(p_sub, p)
2384                     scale = add_unit(b_sub, a * b, scale)
2385             else:
2386                 scale = add_unit(b, p, scale)
2387 
2388         new_parts = [x for x in new_parts.items() if x[1] != 0]
2389         new_parts.sort(key=lambda x: (-x[1], getattr(x[0], "name", "")))
2390 
2391         self._bases = [x[0] for x in new_parts]
2392         self._powers = [x[1] for x in new_parts]
2393         self._scale = sanitize_scale(scale)
2394 
2395     def __copy__(self):
2396         """
2397         For compatibility with python copy module.
2398         """
2399         return CompositeUnit(self._scale, self._bases[:], self._powers[:])
2400 
2401     def decompose(self, bases=set()):
2402         if len(bases) == 0 and self._decomposed_cache is not None:
2403             return self._decomposed_cache
2404 
2405         for base in self.bases:
2406             if not isinstance(base, IrreducibleUnit) or (
2407                 len(bases) and base not in bases
2408             ):
2409                 break
2410         else:
2411             if len(bases) == 0:
2412                 self._decomposed_cache = self
2413             return self
2414 
2415         x = CompositeUnit(
2416             self.scale, self.bases, self.powers, decompose=True, decompose_bases=bases
2417         )
2418         if len(bases) == 0:
2419             self._decomposed_cache = x
2420         return x
2421 
2422     def is_unity(self):
2423         unit = self.decompose()
2424         return len(unit.bases) == 0 and unit.scale == 1.0
2425 
2426 
2427 si_prefixes = [
2428     (["Q"], ["quetta"], 1e30),
2429     (["R"], ["ronna"], 1e27),
2430     (["Y"], ["yotta"], 1e24),
2431     (["Z"], ["zetta"], 1e21),
2432     (["E"], ["exa"], 1e18),
2433     (["P"], ["peta"], 1e15),
2434     (["T"], ["tera"], 1e12),
2435     (["G"], ["giga"], 1e9),
2436     (["M"], ["mega"], 1e6),
2437     (["k"], ["kilo"], 1e3),
2438     (["h"], ["hecto"], 1e2),
2439     (["da"], ["deka", "deca"], 1e1),
2440     (["d"], ["deci"], 1e-1),
2441     (["c"], ["centi"], 1e-2),
2442     (["m"], ["milli"], 1e-3),
2443     (["u"], ["micro"], 1e-6),
2444     (["n"], ["nano"], 1e-9),
2445     (["p"], ["pico"], 1e-12),
2446     (["f"], ["femto"], 1e-15),
2447     (["a"], ["atto"], 1e-18),
2448     (["z"], ["zepto"], 1e-21),
2449     (["y"], ["yocto"], 1e-24),
2450     (["r"], ["ronto"], 1e-27),
2451     (["q"], ["quecto"], 1e-30),
2452 ]
2453 
2454 
2455 binary_prefixes = [
2456     (["Ki"], ["kibi"], 2**10),
2457     (["Mi"], ["mebi"], 2**20),
2458     (["Gi"], ["gibi"], 2**30),
2459     (["Ti"], ["tebi"], 2**40),
2460     (["Pi"], ["pebi"], 2**50),
2461     (["Ei"], ["exbi"], 2**60),
2462 ]
2463 
2464 
2465 def _add_prefixes(u, excludes=[], namespace=None, prefixes=False):
2466     """
2467     Set up all of the standard metric prefixes for a unit.  This
2468     function should not be used directly, but instead use the
2469     `prefixes` kwarg on `def_unit`.
2470 
2471     Parameters
2472     ----------
2473     excludes : list of str, optional
2474         Any prefixes to exclude from creation to avoid namespace
2475         collisions.
2476 
2477     namespace : dict, optional
2478         When provided, inject the unit (and all of its aliases) into
2479         the given namespace dictionary.
2480 
2481     prefixes : list, optional
2482         When provided, it is a list of prefix definitions of the form:
2483 
2484             (short_names, long_tables, factor)
2485     """
2486     if prefixes is True:
2487         prefixes = si_prefixes
2488     elif prefixes is False:
2489         prefixes = []
2490 
2491     for short, full, factor in prefixes:
2492         names = []
2493         format = {}
2494         for prefix in short:
2495             if prefix in excludes:
2496                 continue
2497 
2498             for alias in u.short_names:
2499                 names.append(prefix + alias)
2500 
2501                 # This is a hack to use Greek mu as a prefix
2502                 # for some formatters.
2503                 if prefix == "u":
2504                     format["latex"] = r"\mu " + u.get_format_name("latex")
2505                     format["unicode"] = "\N{MICRO SIGN}" + u.get_format_name("unicode")
2506 
2507                 for key, val in u._format.items():
2508                     format.setdefault(key, prefix + val)
2509 
2510         for prefix in full:
2511             if prefix in excludes:
2512                 continue
2513 
2514             for alias in u.long_names:
2515                 names.append(prefix + alias)
2516 
2517         if len(names):
2518             PrefixUnit(
2519                 names,
2520                 CompositeUnit(factor, [u], [1], _error_check=False),
2521                 namespace=namespace,
2522                 format=format,
2523             )
2524 
2525 
2526 def def_unit(
2527     s,
2528     represents=None,
2529     doc=None,
2530     format=None,
2531     prefixes=False,
2532     exclude_prefixes=[],
2533     namespace=None,
2534 ):
2535     """
2536     Factory function for defining new units.
2537 
2538     Parameters
2539     ----------
2540     s : str or list of str
2541         The name of the unit.  If a list, the first element is the
2542         canonical (short) name, and the rest of the elements are
2543         aliases.
2544 
2545     represents : UnitBase instance, optional
2546         The unit that this named unit represents.  If not provided,
2547         a new `IrreducibleUnit` is created.
2548 
2549     doc : str, optional
2550         A docstring describing the unit.
2551 
2552     format : dict, optional
2553         A mapping to format-specific representations of this unit.
2554         For example, for the ``Ohm`` unit, it might be nice to
2555         have it displayed as ``\\Omega`` by the ``latex``
2556         formatter.  In that case, `format` argument should be set
2557         to::
2558 
2559             {'latex': r'\\Omega'}
2560 
2561     prefixes : bool or list, optional
2562         When `True`, generate all of the SI prefixed versions of the
2563         unit as well.  For example, for a given unit ``m``, will
2564         generate ``mm``, ``cm``, ``km``, etc.  When a list, it is a list of
2565         prefix definitions of the form:
2566 
2567             (short_names, long_tables, factor)
2568 
2569         Default is `False`.  This function always returns the base
2570         unit object, even if multiple scaled versions of the unit were
2571         created.
2572 
2573     exclude_prefixes : list of str, optional
2574         If any of the SI prefixes need to be excluded, they may be
2575         listed here.  For example, ``Pa`` can be interpreted either as
2576         "petaannum" or "Pascal".  Therefore, when defining the
2577         prefixes for ``a``, ``exclude_prefixes`` should be set to
2578         ``["P"]``.
2579 
2580     namespace : dict, optional
2581         When provided, inject the unit (and all of its aliases and
2582         prefixes), into the given namespace dictionary.
2583 
2584     Returns
2585     -------
2586     unit : `~astropy.units.UnitBase`
2587         The newly-defined unit, or a matching unit that was already
2588         defined.
2589     """
2590     if represents is not None:
2591         result = Unit(s, represents, namespace=namespace, doc=doc, format=format)
2592     else:
2593         result = IrreducibleUnit(s, namespace=namespace, doc=doc, format=format)
2594 
2595     if prefixes:
2596         _add_prefixes(
2597             result, excludes=exclude_prefixes, namespace=namespace, prefixes=prefixes
2598         )
2599     return result
2600 
2601 
2602 def _condition_arg(value):
2603     """
2604     Validate value is acceptable for conversion purposes.
2605 
2606     Will convert into an array if not a scalar, and can be converted
2607     into an array
2608 
2609     Parameters
2610     ----------
2611     value : int or float value, or sequence of such values
2612 
2613     Returns
2614     -------
2615     Scalar value or numpy array
2616 
2617     Raises
2618     ------
2619     ValueError
2620         If value is not as expected
2621     """
2622     if isinstance(value, (np.ndarray, float, int, complex, np.void)):
2623         return value
2624 
2625     avalue = np.array(value)
2626     if avalue.dtype.kind not in ["i", "f", "c"]:
2627         raise ValueError(
2628             "Value not scalar compatible or convertible to "
2629             "an int, float, or complex array"
2630         )
2631     return avalue
2632 
2633 
2634 def unit_scale_converter(val):
2635     """Function that just multiplies the value by unity.
2636 
2637     This is a separate function so it can be recognized and
2638     discarded in unit conversion.
2639     """
2640     return 1.0 * _condition_arg(val)
2641 
2642 
2643 dimensionless_unscaled = CompositeUnit(1, [], [], _error_check=False)
2644 # Abbreviation of the above, see #1980
2645 one = dimensionless_unscaled
2646 
2647 # Maintain error in old location for backward compatibility
2648 # TODO: Is this still needed? Should there be a deprecation warning?
2649 unit_format.fits.UnitScaleError = UnitScaleError

</code><intended_behavior>The `to_string` method or its variants that are responsible for formatting units in different styles should be adjusted to ensure that there is no extraneous space at the beginning of the string representation for any unit, regardless of the formatting style (including `unicode` and `console`). This might involve checking and possibly modifying the conditions or logic that prepends spaces based on unit scale factors or the presence of certain unit components. Any modification should preserve the method's existing functionality to accurately represent units in their requested format, adjusting only for the leading space inconsistency.</intended_behavior>, <file>astropy/units/format/console.py</file>
<class>None</class>
<method>None</method>
<code>
1 # Licensed under a 3-clause BSD style license - see LICENSE.rst
2 
3 """
4 Handles the "Console" unit format.
5 """
6 
7 
8 from . import base, core, utils
9 
10 
11 class Console(base.Base):
12     """
13     Output-only format for to display pretty formatting at the
14     console.
15 
16     For example::
17 
18       >>> import astropy.units as u
19       >>> print(u.Ry.decompose().to_string('console'))  # doctest: +FLOAT_CMP
20       2.1798721*10^-18m^2 kg s^-2
21       >>> print(u.Ry.decompose().to_string('console', inline=False))  # doctest: +FLOAT_CMP
22                        m^2 kg
23       2.1798721*10^-18 ------
24                         s^2
25     """
26 
27     _times = "*"
28     _line = "-"
29 
30     @classmethod
31     def _get_unit_name(cls, unit):
32         return unit.get_format_name("console")
33 
34     @classmethod
35     def _format_superscript(cls, number):
36         return f"^{number}"
37 
38     @classmethod
39     def _format_unit_list(cls, units):
40         out = []
41         for base_, power in units:
42             if power == 1:
43                 out.append(cls._get_unit_name(base_))
44             else:
45                 out.append(
46                     cls._get_unit_name(base_)
47                     + cls._format_superscript(utils.format_power(power))
48                 )
49         return " ".join(out)
50 
51     @classmethod
52     def format_exponential_notation(cls, val):
53         m, ex = utils.split_mantissa_exponent(val)
54 
55         parts = []
56         if m:
57             parts.append(m)
58 
59         if ex:
60             parts.append(f"10{cls._format_superscript(ex)}")
61 
62         return cls._times.join(parts)
63 
64     @classmethod
65     def to_string(cls, unit, inline=True):
66         if isinstance(unit, core.CompositeUnit):
67             if unit.scale == 1:
68                 s = ""
69             else:
70                 s = cls.format_exponential_notation(unit.scale)
71 
72             if len(unit.bases):
73                 if inline:
74                     nominator = zip(unit.bases, unit.powers)
75                     denominator = []
76                 else:
77                     nominator, denominator = utils.get_grouped_by_powers(
78                         unit.bases, unit.powers
79                     )
80                 if len(denominator):
81                     if len(nominator):
82                         nominator = cls._format_unit_list(nominator)
83                     else:
84                         nominator = "1"
85                     denominator = cls._format_unit_list(denominator)
86                     fraclength = max(len(nominator), len(denominator))
87                     f = f"{{0:^{len(s)}s}} {{1:^{fraclength}s}}"
88 
89                     lines = [
90                         f.format("", nominator),
91                         f.format(s, cls._line * fraclength),
92                         f.format("", denominator),
93                     ]
94 
95                     s = "\n".join(lines)
96                 else:
97                     nominator = cls._format_unit_list(nominator)
98                     s += nominator
99         elif isinstance(unit, core.NamedUnit):
100             s = cls._get_unit_name(unit)
101 
102         return s

</code><intended_behavior>These methods should be verified and possibly corrected to ensure they do not introduce an unintended leading space in their output, especially under conditions where unit scale factors are present or absent. The logic handling the format-specific concatenations and space insertions needs careful inspection to eliminate the inconsistency. As with `core.py`, the aim would be to preserve the integrity and accuracy of the unit representation while aligning with the expected behavior of no leading spaces in all scenarios.</intended_behavior>]
2025-10-15 15:41:19.509 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-15 15:41:19.509 | INFO     | Search-only: skipping patch selection
2025-10-15 15:41:19.663 | INFO     | Task astropy__astropy-14413 completed successfully.
2025-10-15 15:41:19.664 | INFO     | No patch generated. You can try running ACR again.
