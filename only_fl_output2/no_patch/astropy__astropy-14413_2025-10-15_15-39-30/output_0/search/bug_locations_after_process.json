[
    {
        "rel_file_path": "astropy/units/core.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/astropy__astropy/setup_astropy__astropy__5.1/astropy/units/core.py",
        "start": 1,
        "end": 2649,
        "class_name": null,
        "method_name": null,
        "code": "1 # Licensed under a 3-clause BSD style license - see LICENSE.rst\n2 \n3 \"\"\"\n4 Core units classes and functions.\n5 \"\"\"\n6 \n7 \n8 import inspect\n9 import operator\n10 import textwrap\n11 import warnings\n12 \n13 import numpy as np\n14 \n15 from astropy.utils.decorators import lazyproperty\n16 from astropy.utils.exceptions import AstropyWarning\n17 from astropy.utils.misc import isiterable\n18 \n19 from . import format as unit_format\n20 from .utils import (\n21     is_effectively_unity,\n22     resolve_fractions,\n23     sanitize_scale,\n24     validate_power,\n25 )\n26 \n27 __all__ = [\n28     \"UnitsError\",\n29     \"UnitsWarning\",\n30     \"UnitConversionError\",\n31     \"UnitTypeError\",\n32     \"UnitBase\",\n33     \"NamedUnit\",\n34     \"IrreducibleUnit\",\n35     \"Unit\",\n36     \"CompositeUnit\",\n37     \"PrefixUnit\",\n38     \"UnrecognizedUnit\",\n39     \"def_unit\",\n40     \"get_current_unit_registry\",\n41     \"set_enabled_units\",\n42     \"add_enabled_units\",\n43     \"set_enabled_equivalencies\",\n44     \"add_enabled_equivalencies\",\n45     \"set_enabled_aliases\",\n46     \"add_enabled_aliases\",\n47     \"dimensionless_unscaled\",\n48     \"one\",\n49 ]\n50 \n51 UNITY = 1.0\n52 \n53 \n54 def _flatten_units_collection(items):\n55     \"\"\"\n56     Given a list of sequences, modules or dictionaries of units, or\n57     single units, return a flat set of all the units found.\n58     \"\"\"\n59     if not isinstance(items, list):\n60         items = [items]\n61 \n62     result = set()\n63     for item in items:\n64         if isinstance(item, UnitBase):\n65             result.add(item)\n66         else:\n67             if isinstance(item, dict):\n68                 units = item.values()\n69             elif inspect.ismodule(item):\n70                 units = vars(item).values()\n71             elif isiterable(item):\n72                 units = item\n73             else:\n74                 continue\n75 \n76             for unit in units:\n77                 if isinstance(unit, UnitBase):\n78                     result.add(unit)\n79 \n80     return result\n81 \n82 \n83 def _normalize_equivalencies(equivalencies):\n84     \"\"\"Normalizes equivalencies ensuring each is a 4-tuple.\n85 \n86     The resulting tuple is of the form::\n87 \n88         (from_unit, to_unit, forward_func, backward_func)\n89 \n90     Parameters\n91     ----------\n92     equivalencies : list of equivalency pairs\n93 \n94     Raises\n95     ------\n96     ValueError if an equivalency cannot be interpreted\n97     \"\"\"\n98     if equivalencies is None:\n99         return []\n100 \n101     normalized = []\n102 \n103     for i, equiv in enumerate(equivalencies):\n104         if len(equiv) == 2:\n105             funit, tunit = equiv\n106             a = b = lambda x: x\n107         elif len(equiv) == 3:\n108             funit, tunit, a = equiv\n109             b = a\n110         elif len(equiv) == 4:\n111             funit, tunit, a, b = equiv\n112         else:\n113             raise ValueError(f\"Invalid equivalence entry {i}: {equiv!r}\")\n114         if not (\n115             funit is Unit(funit)\n116             and (tunit is None or tunit is Unit(tunit))\n117             and callable(a)\n118             and callable(b)\n119         ):\n120             raise ValueError(f\"Invalid equivalence entry {i}: {equiv!r}\")\n121         normalized.append((funit, tunit, a, b))\n122 \n123     return normalized\n124 \n125 \n126 class _UnitRegistry:\n127     \"\"\"\n128     Manages a registry of the enabled units.\n129     \"\"\"\n130 \n131     def __init__(self, init=[], equivalencies=[], aliases={}):\n132         if isinstance(init, _UnitRegistry):\n133             # If passed another registry we don't need to rebuild everything.\n134             # but because these are mutable types we don't want to create\n135             # conflicts so everything needs to be copied.\n136             self._equivalencies = init._equivalencies.copy()\n137             self._aliases = init._aliases.copy()\n138             self._all_units = init._all_units.copy()\n139             self._registry = init._registry.copy()\n140             self._non_prefix_units = init._non_prefix_units.copy()\n141             # The physical type is a dictionary containing sets as values.\n142             # All of these must be copied otherwise we could alter the old\n143             # registry.\n144             self._by_physical_type = {\n145                 k: v.copy() for k, v in init._by_physical_type.items()\n146             }\n147 \n148         else:\n149             self._reset_units()\n150             self._reset_equivalencies()\n151             self._reset_aliases()\n152             self.add_enabled_units(init)\n153             self.add_enabled_equivalencies(equivalencies)\n154             self.add_enabled_aliases(aliases)\n155 \n156     def _reset_units(self):\n157         self._all_units = set()\n158         self._non_prefix_units = set()\n159         self._registry = {}\n160         self._by_physical_type = {}\n161 \n162     def _reset_equivalencies(self):\n163         self._equivalencies = set()\n164 \n165     def _reset_aliases(self):\n166         self._aliases = {}\n167 \n168     @property\n169     def registry(self):\n170         return self._registry\n171 \n172     @property\n173     def all_units(self):\n174         return self._all_units\n175 \n176     @property\n177     def non_prefix_units(self):\n178         return self._non_prefix_units\n179 \n180     def set_enabled_units(self, units):\n181         \"\"\"\n182         Sets the units enabled in the unit registry.\n183 \n184         These units are searched when using\n185         `UnitBase.find_equivalent_units`, for example.\n186 \n187         Parameters\n188         ----------\n189         units : list of sequence, dict, or module\n190             This is a list of things in which units may be found\n191             (sequences, dicts or modules), or units themselves.  The\n192             entire set will be \"enabled\" for searching through by\n193             methods like `UnitBase.find_equivalent_units` and\n194             `UnitBase.compose`.\n195         \"\"\"\n196         self._reset_units()\n197         return self.add_enabled_units(units)\n198 \n199     def add_enabled_units(self, units):\n200         \"\"\"\n201         Adds to the set of units enabled in the unit registry.\n202 \n203         These units are searched when using\n204         `UnitBase.find_equivalent_units`, for example.\n205 \n206         Parameters\n207         ----------\n208         units : list of sequence, dict, or module\n209             This is a list of things in which units may be found\n210             (sequences, dicts or modules), or units themselves.  The\n211             entire set will be added to the \"enabled\" set for\n212             searching through by methods like\n213             `UnitBase.find_equivalent_units` and `UnitBase.compose`.\n214         \"\"\"\n215         units = _flatten_units_collection(units)\n216 \n217         for unit in units:\n218             # Loop through all of the names first, to ensure all of them\n219             # are new, then add them all as a single \"transaction\" below.\n220             for st in unit._names:\n221                 if st in self._registry and unit != self._registry[st]:\n222                     raise ValueError(\n223                         f\"Object with name {st!r} already exists in namespace. \"\n224                         \"Filter the set of units to avoid name clashes before \"\n225                         \"enabling them.\"\n226                     )\n227 \n228             for st in unit._names:\n229                 self._registry[st] = unit\n230 \n231             self._all_units.add(unit)\n232             if not isinstance(unit, PrefixUnit):\n233                 self._non_prefix_units.add(unit)\n234 \n235             hash = unit._get_physical_type_id()\n236             self._by_physical_type.setdefault(hash, set()).add(unit)\n237 \n238     def get_units_with_physical_type(self, unit):\n239         \"\"\"\n240         Get all units in the registry with the same physical type as\n241         the given unit.\n242 \n243         Parameters\n244         ----------\n245         unit : UnitBase instance\n246         \"\"\"\n247         return self._by_physical_type.get(unit._get_physical_type_id(), set())\n248 \n249     @property\n250     def equivalencies(self):\n251         return list(self._equivalencies)\n252 \n253     def set_enabled_equivalencies(self, equivalencies):\n254         \"\"\"\n255         Sets the equivalencies enabled in the unit registry.\n256 \n257         These equivalencies are used if no explicit equivalencies are given,\n258         both in unit conversion and in finding equivalent units.\n259 \n260         This is meant in particular for allowing angles to be dimensionless.\n261         Use with care.\n262 \n263         Parameters\n264         ----------\n265         equivalencies : list of tuple\n266             List of equivalent pairs, e.g., as returned by\n267             `~astropy.units.equivalencies.dimensionless_angles`.\n268         \"\"\"\n269         self._reset_equivalencies()\n270         return self.add_enabled_equivalencies(equivalencies)\n271 \n272     def add_enabled_equivalencies(self, equivalencies):\n273         \"\"\"\n274         Adds to the set of equivalencies enabled in the unit registry.\n275 \n276         These equivalencies are used if no explicit equivalencies are given,\n277         both in unit conversion and in finding equivalent units.\n278 \n279         This is meant in particular for allowing angles to be dimensionless.\n280         Use with care.\n281 \n282         Parameters\n283         ----------\n284         equivalencies : list of tuple\n285             List of equivalent pairs, e.g., as returned by\n286             `~astropy.units.equivalencies.dimensionless_angles`.\n287         \"\"\"\n288         # pre-normalize list to help catch mistakes\n289         equivalencies = _normalize_equivalencies(equivalencies)\n290         self._equivalencies |= set(equivalencies)\n291 \n292     @property\n293     def aliases(self):\n294         return self._aliases\n295 \n296     def set_enabled_aliases(self, aliases):\n297         \"\"\"\n298         Set aliases for units.\n299 \n300         Parameters\n301         ----------\n302         aliases : dict of str, Unit\n303             The aliases to set. The keys must be the string aliases, and values\n304             must be the `astropy.units.Unit` that the alias will be mapped to.\n305 \n306         Raises\n307         ------\n308         ValueError\n309             If the alias already defines a different unit.\n310 \n311         \"\"\"\n312         self._reset_aliases()\n313         self.add_enabled_aliases(aliases)\n314 \n315     def add_enabled_aliases(self, aliases):\n316         \"\"\"\n317         Add aliases for units.\n318 \n319         Parameters\n320         ----------\n321         aliases : dict of str, Unit\n322             The aliases to add. The keys must be the string aliases, and values\n323             must be the `astropy.units.Unit` that the alias will be mapped to.\n324 \n325         Raises\n326         ------\n327         ValueError\n328             If the alias already defines a different unit.\n329 \n330         \"\"\"\n331         for alias, unit in aliases.items():\n332             if alias in self._registry and unit != self._registry[alias]:\n333                 raise ValueError(\n334                     f\"{alias} already means {self._registry[alias]}, so \"\n335                     f\"cannot be used as an alias for {unit}.\"\n336                 )\n337             if alias in self._aliases and unit != self._aliases[alias]:\n338                 raise ValueError(\n339                     f\"{alias} already is an alias for {self._aliases[alias]}, so \"\n340                     f\"cannot be used as an alias for {unit}.\"\n341                 )\n342 \n343         for alias, unit in aliases.items():\n344             if alias not in self._registry and alias not in self._aliases:\n345                 self._aliases[alias] = unit\n346 \n347 \n348 class _UnitContext:\n349     def __init__(self, init=[], equivalencies=[]):\n350         _unit_registries.append(_UnitRegistry(init=init, equivalencies=equivalencies))\n351 \n352     def __enter__(self):\n353         pass\n354 \n355     def __exit__(self, type, value, tb):\n356         _unit_registries.pop()\n357 \n358 \n359 _unit_registries = [_UnitRegistry()]\n360 \n361 \n362 def get_current_unit_registry():\n363     return _unit_registries[-1]\n364 \n365 \n366 def set_enabled_units(units):\n367     \"\"\"\n368     Sets the units enabled in the unit registry.\n369 \n370     These units are searched when using\n371     `UnitBase.find_equivalent_units`, for example.\n372 \n373     This may be used either permanently, or as a context manager using\n374     the ``with`` statement (see example below).\n375 \n376     Parameters\n377     ----------\n378     units : list of sequence, dict, or module\n379         This is a list of things in which units may be found\n380         (sequences, dicts or modules), or units themselves.  The\n381         entire set will be \"enabled\" for searching through by methods\n382         like `UnitBase.find_equivalent_units` and `UnitBase.compose`.\n383 \n384     Examples\n385     --------\n386     >>> from astropy import units as u\n387     >>> with u.set_enabled_units([u.pc]):\n388     ...     u.m.find_equivalent_units()\n389     ...\n390       Primary name | Unit definition | Aliases\n391     [\n392       pc           | 3.08568e+16 m   | parsec  ,\n393     ]\n394     >>> u.m.find_equivalent_units()\n395       Primary name | Unit definition | Aliases\n396     [\n397       AU           | 1.49598e+11 m   | au, astronomical_unit            ,\n398       Angstrom     | 1e-10 m         | AA, angstrom                     ,\n399       cm           | 0.01 m          | centimeter                       ,\n400       earthRad     | 6.3781e+06 m    | R_earth, Rearth                  ,\n401       jupiterRad   | 7.1492e+07 m    | R_jup, Rjup, R_jupiter, Rjupiter ,\n402       lsec         | 2.99792e+08 m   | lightsecond                      ,\n403       lyr          | 9.46073e+15 m   | lightyear                        ,\n404       m            | irreducible     | meter                            ,\n405       micron       | 1e-06 m         |                                  ,\n406       pc           | 3.08568e+16 m   | parsec                           ,\n407       solRad       | 6.957e+08 m     | R_sun, Rsun                      ,\n408     ]\n409     \"\"\"\n410     # get a context with a new registry, using equivalencies of the current one\n411     context = _UnitContext(equivalencies=get_current_unit_registry().equivalencies)\n412     # in this new current registry, enable the units requested\n413     get_current_unit_registry().set_enabled_units(units)\n414     return context\n415 \n416 \n417 def add_enabled_units(units):\n418     \"\"\"\n419     Adds to the set of units enabled in the unit registry.\n420 \n421     These units are searched when using\n422     `UnitBase.find_equivalent_units`, for example.\n423 \n424     This may be used either permanently, or as a context manager using\n425     the ``with`` statement (see example below).\n426 \n427     Parameters\n428     ----------\n429     units : list of sequence, dict, or module\n430         This is a list of things in which units may be found\n431         (sequences, dicts or modules), or units themselves.  The\n432         entire set will be added to the \"enabled\" set for searching\n433         through by methods like `UnitBase.find_equivalent_units` and\n434         `UnitBase.compose`.\n435 \n436     Examples\n437     --------\n438     >>> from astropy import units as u\n439     >>> from astropy.units import imperial\n440     >>> with u.add_enabled_units(imperial):\n441     ...     u.m.find_equivalent_units()\n442     ...\n443       Primary name | Unit definition | Aliases\n444     [\n445       AU           | 1.49598e+11 m   | au, astronomical_unit            ,\n446       Angstrom     | 1e-10 m         | AA, angstrom                     ,\n447       cm           | 0.01 m          | centimeter                       ,\n448       earthRad     | 6.3781e+06 m    | R_earth, Rearth                  ,\n449       ft           | 0.3048 m        | foot                             ,\n450       fur          | 201.168 m       | furlong                          ,\n451       inch         | 0.0254 m        |                                  ,\n452       jupiterRad   | 7.1492e+07 m    | R_jup, Rjup, R_jupiter, Rjupiter ,\n453       lsec         | 2.99792e+08 m   | lightsecond                      ,\n454       lyr          | 9.46073e+15 m   | lightyear                        ,\n455       m            | irreducible     | meter                            ,\n456       mi           | 1609.34 m       | mile                             ,\n457       micron       | 1e-06 m         |                                  ,\n458       mil          | 2.54e-05 m      | thou                             ,\n459       nmi          | 1852 m          | nauticalmile, NM                 ,\n460       pc           | 3.08568e+16 m   | parsec                           ,\n461       solRad       | 6.957e+08 m     | R_sun, Rsun                      ,\n462       yd           | 0.9144 m        | yard                             ,\n463     ]\n464     \"\"\"\n465     # get a context with a new registry, which is a copy of the current one\n466     context = _UnitContext(get_current_unit_registry())\n467     # in this new current registry, enable the further units requested\n468     get_current_unit_registry().add_enabled_units(units)\n469     return context\n470 \n471 \n472 def set_enabled_equivalencies(equivalencies):\n473     \"\"\"\n474     Sets the equivalencies enabled in the unit registry.\n475 \n476     These equivalencies are used if no explicit equivalencies are given,\n477     both in unit conversion and in finding equivalent units.\n478 \n479     This is meant in particular for allowing angles to be dimensionless.\n480     Use with care.\n481 \n482     Parameters\n483     ----------\n484     equivalencies : list of tuple\n485         list of equivalent pairs, e.g., as returned by\n486         `~astropy.units.equivalencies.dimensionless_angles`.\n487 \n488     Examples\n489     --------\n490     Exponentiation normally requires dimensionless quantities.  To avoid\n491     problems with complex phases::\n492 \n493         >>> from astropy import units as u\n494         >>> with u.set_enabled_equivalencies(u.dimensionless_angles()):\n495         ...     phase = 0.5 * u.cycle\n496         ...     np.exp(1j*phase)  # doctest: +FLOAT_CMP\n497         <Quantity -1.+1.2246468e-16j>\n498     \"\"\"\n499     # get a context with a new registry, using all units of the current one\n500     context = _UnitContext(get_current_unit_registry())\n501     # in this new current registry, enable the equivalencies requested\n502     get_current_unit_registry().set_enabled_equivalencies(equivalencies)\n503     return context\n504 \n505 \n506 def add_enabled_equivalencies(equivalencies):\n507     \"\"\"\n508     Adds to the equivalencies enabled in the unit registry.\n509 \n510     These equivalencies are used if no explicit equivalencies are given,\n511     both in unit conversion and in finding equivalent units.\n512 \n513     This is meant in particular for allowing angles to be dimensionless.\n514     Since no equivalencies are enabled by default, generally it is recommended\n515     to use `set_enabled_equivalencies`.\n516 \n517     Parameters\n518     ----------\n519     equivalencies : list of tuple\n520         list of equivalent pairs, e.g., as returned by\n521         `~astropy.units.equivalencies.dimensionless_angles`.\n522     \"\"\"\n523     # get a context with a new registry, which is a copy of the current one\n524     context = _UnitContext(get_current_unit_registry())\n525     # in this new current registry, enable the further equivalencies requested\n526     get_current_unit_registry().add_enabled_equivalencies(equivalencies)\n527     return context\n528 \n529 \n530 def set_enabled_aliases(aliases):\n531     \"\"\"\n532     Set aliases for units.\n533 \n534     This is useful for handling alternate spellings for units, or\n535     misspelled units in files one is trying to read.\n536 \n537     Parameters\n538     ----------\n539     aliases : dict of str, Unit\n540         The aliases to set. The keys must be the string aliases, and values\n541         must be the `astropy.units.Unit` that the alias will be mapped to.\n542 \n543     Raises\n544     ------\n545     ValueError\n546         If the alias already defines a different unit.\n547 \n548     Examples\n549     --------\n550     To temporarily allow for a misspelled 'Angstroem' unit::\n551 \n552         >>> from astropy import units as u\n553         >>> with u.set_enabled_aliases({'Angstroem': u.Angstrom}):\n554         ...     print(u.Unit(\"Angstroem\", parse_strict=\"raise\") == u.Angstrom)\n555         True\n556 \n557     \"\"\"\n558     # get a context with a new registry, which is a copy of the current one\n559     context = _UnitContext(get_current_unit_registry())\n560     # in this new current registry, enable the further equivalencies requested\n561     get_current_unit_registry().set_enabled_aliases(aliases)\n562     return context\n563 \n564 \n565 def add_enabled_aliases(aliases):\n566     \"\"\"\n567     Add aliases for units.\n568 \n569     This is useful for handling alternate spellings for units, or\n570     misspelled units in files one is trying to read.\n571 \n572     Since no aliases are enabled by default, generally it is recommended\n573     to use `set_enabled_aliases`.\n574 \n575     Parameters\n576     ----------\n577     aliases : dict of str, Unit\n578         The aliases to add. The keys must be the string aliases, and values\n579         must be the `astropy.units.Unit` that the alias will be mapped to.\n580 \n581     Raises\n582     ------\n583     ValueError\n584         If the alias already defines a different unit.\n585 \n586     Examples\n587     --------\n588     To temporarily allow for a misspelled 'Angstroem' unit::\n589 \n590         >>> from astropy import units as u\n591         >>> with u.add_enabled_aliases({'Angstroem': u.Angstrom}):\n592         ...     print(u.Unit(\"Angstroem\", parse_strict=\"raise\") == u.Angstrom)\n593         True\n594 \n595     \"\"\"\n596     # get a context with a new registry, which is a copy of the current one\n597     context = _UnitContext(get_current_unit_registry())\n598     # in this new current registry, enable the further equivalencies requested\n599     get_current_unit_registry().add_enabled_aliases(aliases)\n600     return context\n601 \n602 \n603 class UnitsError(Exception):\n604     \"\"\"\n605     The base class for unit-specific exceptions.\n606     \"\"\"\n607 \n608 \n609 class UnitScaleError(UnitsError, ValueError):\n610     \"\"\"\n611     Used to catch the errors involving scaled units,\n612     which are not recognized by FITS format.\n613     \"\"\"\n614 \n615     pass\n616 \n617 \n618 class UnitConversionError(UnitsError, ValueError):\n619     \"\"\"\n620     Used specifically for errors related to converting between units or\n621     interpreting units in terms of other units.\n622     \"\"\"\n623 \n624 \n625 class UnitTypeError(UnitsError, TypeError):\n626     \"\"\"\n627     Used specifically for errors in setting to units not allowed by a class.\n628 \n629     E.g., would be raised if the unit of an `~astropy.coordinates.Angle`\n630     instances were set to a non-angular unit.\n631     \"\"\"\n632 \n633 \n634 class UnitsWarning(AstropyWarning):\n635     \"\"\"\n636     The base class for unit-specific warnings.\n637     \"\"\"\n638 \n639 \n640 class UnitBase:\n641     \"\"\"\n642     Abstract base class for units.\n643 \n644     Most of the arithmetic operations on units are defined in this\n645     base class.\n646 \n647     Should not be instantiated by users directly.\n648     \"\"\"\n649 \n650     # Make sure that __rmul__ of units gets called over the __mul__ of Numpy\n651     # arrays to avoid element-wise multiplication.\n652     __array_priority__ = 1000\n653 \n654     _hash = None\n655     _type_id = None\n656 \n657     def __deepcopy__(self, memo):\n658         # This may look odd, but the units conversion will be very\n659         # broken after deep-copying if we don't guarantee that a given\n660         # physical unit corresponds to only one instance\n661         return self\n662 \n663     def _repr_latex_(self):\n664         \"\"\"\n665         Generate latex representation of unit name.  This is used by\n666         the IPython notebook to print a unit with a nice layout.\n667 \n668         Returns\n669         -------\n670         Latex string\n671         \"\"\"\n672         return unit_format.Latex.to_string(self)\n673 \n674     def __bytes__(self):\n675         \"\"\"Return string representation for unit.\"\"\"\n676         return unit_format.Generic.to_string(self).encode(\"unicode_escape\")\n677 \n678     def __str__(self):\n679         \"\"\"Return string representation for unit.\"\"\"\n680         return unit_format.Generic.to_string(self)\n681 \n682     def __repr__(self):\n683         string = unit_format.Generic.to_string(self)\n684 \n685         return f'Unit(\"{string}\")'\n686 \n687     def _get_physical_type_id(self):\n688         \"\"\"\n689         Returns an identifier that uniquely identifies the physical\n690         type of this unit.  It is comprised of the bases and powers of\n691         this unit, without the scale.  Since it is hashable, it is\n692         useful as a dictionary key.\n693         \"\"\"\n694         if self._type_id is None:\n695             unit = self.decompose()\n696             self._type_id = tuple(zip((base.name for base in unit.bases), unit.powers))\n697 \n698         return self._type_id\n699 \n700     @property\n701     def names(self):\n702         \"\"\"\n703         Returns all of the names associated with this unit.\n704         \"\"\"\n705         raise AttributeError(\n706             \"Can not get names from unnamed units. Perhaps you meant to_string()?\"\n707         )\n708 \n709     @property\n710     def name(self):\n711         \"\"\"\n712         Returns the canonical (short) name associated with this unit.\n713         \"\"\"\n714         raise AttributeError(\n715             \"Can not get names from unnamed units. Perhaps you meant to_string()?\"\n716         )\n717 \n718     @property\n719     def aliases(self):\n720         \"\"\"\n721         Returns the alias (long) names for this unit.\n722         \"\"\"\n723         raise AttributeError(\n724             \"Can not get aliases from unnamed units. Perhaps you meant to_string()?\"\n725         )\n726 \n727     @property\n728     def scale(self):\n729         \"\"\"\n730         Return the scale of the unit.\n731         \"\"\"\n732         return 1.0\n733 \n734     @property\n735     def bases(self):\n736         \"\"\"\n737         Return the bases of the unit.\n738         \"\"\"\n739         return [self]\n740 \n741     @property\n742     def powers(self):\n743         \"\"\"\n744         Return the powers of the unit.\n745         \"\"\"\n746         return [1]\n747 \n748     def to_string(self, format=unit_format.Generic, **kwargs):\n749         \"\"\"Output the unit in the given format as a string.\n750 \n751         Parameters\n752         ----------\n753         format : `astropy.units.format.Base` instance or str\n754             The name of a format or a formatter object.  If not\n755             provided, defaults to the generic format.\n756 \n757         **kwargs :\n758             Further options forwarded to the formatter. Currently\n759             recognized is **inline** (:class:`bool`) for the\n760             ``\"latex\"``, ``\"console\"``, and``\"unicode\"`` formats.\n761 \n762         \"\"\"\n763         f = unit_format.get_format(format)\n764         return f.to_string(self, **kwargs)\n765 \n766     def __format__(self, format_spec):\n767         \"\"\"Try to format units using a formatter.\"\"\"\n768         try:\n769             return self.to_string(format=format_spec)\n770         except ValueError:\n771             return format(str(self), format_spec)\n772 \n773     @staticmethod\n774     def _normalize_equivalencies(equivalencies):\n775         \"\"\"Normalizes equivalencies, ensuring each is a 4-tuple.\n776 \n777         The resulting tuple is of the form::\n778 \n779             (from_unit, to_unit, forward_func, backward_func)\n780 \n781         Parameters\n782         ----------\n783         equivalencies : list of equivalency pairs, or None\n784 \n785         Returns\n786         -------\n787         A normalized list, including possible global defaults set by, e.g.,\n788         `set_enabled_equivalencies`, except when `equivalencies`=`None`,\n789         in which case the returned list is always empty.\n790 \n791         Raises\n792         ------\n793         ValueError if an equivalency cannot be interpreted\n794         \"\"\"\n795         normalized = _normalize_equivalencies(equivalencies)\n796         if equivalencies is not None:\n797             normalized += get_current_unit_registry().equivalencies\n798 \n799         return normalized\n800 \n801     def __pow__(self, p):\n802         p = validate_power(p)\n803         return CompositeUnit(1, [self], [p], _error_check=False)\n804 \n805     def __truediv__(self, m):\n806         if isinstance(m, (bytes, str)):\n807             m = Unit(m)\n808 \n809         if isinstance(m, UnitBase):\n810             if m.is_unity():\n811                 return self\n812             return CompositeUnit(1, [self, m], [1, -1], _error_check=False)\n813 \n814         try:\n815             # Cannot handle this as Unit, re-try as Quantity\n816             from .quantity import Quantity\n817 \n818             return Quantity(1, self) / m\n819         except TypeError:\n820             return NotImplemented\n821 \n822     def __rtruediv__(self, m):\n823         if isinstance(m, (bytes, str)):\n824             return Unit(m) / self\n825 \n826         try:\n827             # Cannot handle this as Unit.  Here, m cannot be a Quantity,\n828             # so we make it into one, fasttracking when it does not have a\n829             # unit, for the common case of <array> / <unit>.\n830             from .quantity import Quantity\n831 \n832             if hasattr(m, \"unit\"):\n833                 result = Quantity(m)\n834                 result /= self\n835                 return result\n836             else:\n837                 return Quantity(m, self ** (-1))\n838         except TypeError:\n839             return NotImplemented\n840 \n841     def __mul__(self, m):\n842         if isinstance(m, (bytes, str)):\n843             m = Unit(m)\n844 \n845         if isinstance(m, UnitBase):\n846             if m.is_unity():\n847                 return self\n848             elif self.is_unity():\n849                 return m\n850             return CompositeUnit(1, [self, m], [1, 1], _error_check=False)\n851 \n852         # Cannot handle this as Unit, re-try as Quantity.\n853         try:\n854             from .quantity import Quantity\n855 \n856             return Quantity(1, unit=self) * m\n857         except TypeError:\n858             return NotImplemented\n859 \n860     def __rmul__(self, m):\n861         if isinstance(m, (bytes, str)):\n862             return Unit(m) * self\n863 \n864         # Cannot handle this as Unit.  Here, m cannot be a Quantity,\n865         # so we make it into one, fasttracking when it does not have a unit\n866         # for the common case of <array> * <unit>.\n867         try:\n868             from .quantity import Quantity\n869 \n870             if hasattr(m, \"unit\"):\n871                 result = Quantity(m)\n872                 result *= self\n873                 return result\n874             else:\n875                 return Quantity(m, unit=self)\n876         except TypeError:\n877             return NotImplemented\n878 \n879     def __rlshift__(self, m):\n880         try:\n881             from .quantity import Quantity\n882 \n883             return Quantity(m, self, copy=False, subok=True)\n884         except Exception:\n885             return NotImplemented\n886 \n887     def __rrshift__(self, m):\n888         warnings.warn(\n889             \">> is not implemented. Did you mean to convert \"\n890             f\"to a Quantity with unit {m} using '<<'?\",\n891             AstropyWarning,\n892         )\n893         return NotImplemented\n894 \n895     def __hash__(self):\n896         if self._hash is None:\n897             parts = (\n898                 [str(self.scale)]\n899                 + [x.name for x in self.bases]\n900                 + [str(x) for x in self.powers]\n901             )\n902             self._hash = hash(tuple(parts))\n903         return self._hash\n904 \n905     def __getstate__(self):\n906         # If we get pickled, we should *not* store the memoized members since\n907         # hashes of strings vary between sessions.\n908         state = self.__dict__.copy()\n909         state.pop(\"_hash\", None)\n910         state.pop(\"_type_id\", None)\n911         return state\n912 \n913     def __eq__(self, other):\n914         if self is other:\n915             return True\n916 \n917         try:\n918             other = Unit(other, parse_strict=\"silent\")\n919         except (ValueError, UnitsError, TypeError):\n920             return NotImplemented\n921 \n922         # Other is unit-like, but the test below requires it is a UnitBase\n923         # instance; if it is not, give up (so that other can try).\n924         if not isinstance(other, UnitBase):\n925             return NotImplemented\n926 \n927         try:\n928             return is_effectively_unity(self._to(other))\n929         except UnitsError:\n930             return False\n931 \n932     def __ne__(self, other):\n933         return not (self == other)\n934 \n935     def __le__(self, other):\n936         scale = self._to(Unit(other))\n937         return scale <= 1.0 or is_effectively_unity(scale)\n938 \n939     def __ge__(self, other):\n940         scale = self._to(Unit(other))\n941         return scale >= 1.0 or is_effectively_unity(scale)\n942 \n943     def __lt__(self, other):\n944         return not (self >= other)\n945 \n946     def __gt__(self, other):\n947         return not (self <= other)\n948 \n949     def __neg__(self):\n950         return self * -1.0\n951 \n952     def is_equivalent(self, other, equivalencies=[]):\n953         \"\"\"\n954         Returns `True` if this unit is equivalent to ``other``.\n955 \n956         Parameters\n957         ----------\n958         other : `~astropy.units.Unit`, str, or tuple\n959             The unit to convert to. If a tuple of units is specified, this\n960             method returns true if the unit matches any of those in the tuple.\n961 \n962         equivalencies : list of tuple\n963             A list of equivalence pairs to try if the units are not\n964             directly convertible.  See :ref:`astropy:unit_equivalencies`.\n965             This list is in addition to possible global defaults set by, e.g.,\n966             `set_enabled_equivalencies`.\n967             Use `None` to turn off all equivalencies.\n968 \n969         Returns\n970         -------\n971         bool\n972         \"\"\"\n973         equivalencies = self._normalize_equivalencies(equivalencies)\n974 \n975         if isinstance(other, tuple):\n976             return any(self.is_equivalent(u, equivalencies) for u in other)\n977 \n978         other = Unit(other, parse_strict=\"silent\")\n979 \n980         return self._is_equivalent(other, equivalencies)\n981 \n982     def _is_equivalent(self, other, equivalencies=[]):\n983         \"\"\"Returns `True` if this unit is equivalent to `other`.\n984         See `is_equivalent`, except that a proper Unit object should be\n985         given (i.e., no string) and that the equivalency list should be\n986         normalized using `_normalize_equivalencies`.\n987         \"\"\"\n988         if isinstance(other, UnrecognizedUnit):\n989             return False\n990 \n991         if self._get_physical_type_id() == other._get_physical_type_id():\n992             return True\n993         elif len(equivalencies):\n994             unit = self.decompose()\n995             other = other.decompose()\n996             for a, b, forward, backward in equivalencies:\n997                 if b is None:\n998                     # after canceling, is what's left convertible\n999                     # to dimensionless (according to the equivalency)?\n1000                     try:\n1001                         (other / unit).decompose([a])\n1002                         return True\n1003                     except Exception:\n1004                         pass\n1005                 elif (a._is_equivalent(unit) and b._is_equivalent(other)) or (\n1006                     b._is_equivalent(unit) and a._is_equivalent(other)\n1007                 ):\n1008                     return True\n1009 \n1010         return False\n1011 \n1012     def _apply_equivalencies(self, unit, other, equivalencies):\n1013         \"\"\"\n1014         Internal function (used from `_get_converter`) to apply\n1015         equivalence pairs.\n1016         \"\"\"\n1017 \n1018         def make_converter(scale1, func, scale2):\n1019             def convert(v):\n1020                 return func(_condition_arg(v) / scale1) * scale2\n1021 \n1022             return convert\n1023 \n1024         for funit, tunit, a, b in equivalencies:\n1025             if tunit is None:\n1026                 ratio = other.decompose() / unit.decompose()\n1027                 try:\n1028                     ratio_in_funit = ratio.decompose([funit])\n1029                     return make_converter(ratio_in_funit.scale, a, 1.0)\n1030                 except UnitsError:\n1031                     pass\n1032             else:\n1033                 try:\n1034                     scale1 = funit._to(unit)\n1035                     scale2 = tunit._to(other)\n1036                     return make_converter(scale1, a, scale2)\n1037                 except UnitsError:\n1038                     pass\n1039                 try:\n1040                     scale1 = tunit._to(unit)\n1041                     scale2 = funit._to(other)\n1042                     return make_converter(scale1, b, scale2)\n1043                 except UnitsError:\n1044                     pass\n1045 \n1046         def get_err_str(unit):\n1047             unit_str = unit.to_string(\"unscaled\")\n1048             physical_type = unit.physical_type\n1049             if physical_type != \"unknown\":\n1050                 unit_str = f\"'{unit_str}' ({physical_type})\"\n1051             else:\n1052                 unit_str = f\"'{unit_str}'\"\n1053             return unit_str\n1054 \n1055         unit_str = get_err_str(unit)\n1056         other_str = get_err_str(other)\n1057 \n1058         raise UnitConversionError(f\"{unit_str} and {other_str} are not convertible\")\n1059 \n1060     def _get_converter(self, other, equivalencies=[]):\n1061         \"\"\"Get a converter for values in ``self`` to ``other``.\n1062 \n1063         If no conversion is necessary, returns ``unit_scale_converter``\n1064         (which is used as a check in quantity helpers).\n1065 \n1066         \"\"\"\n1067         # First see if it is just a scaling.\n1068         try:\n1069             scale = self._to(other)\n1070         except UnitsError:\n1071             pass\n1072         else:\n1073             if scale == 1.0:\n1074                 return unit_scale_converter\n1075             else:\n1076                 return lambda val: scale * _condition_arg(val)\n1077 \n1078         # if that doesn't work, maybe we can do it with equivalencies?\n1079         try:\n1080             return self._apply_equivalencies(\n1081                 self, other, self._normalize_equivalencies(equivalencies)\n1082             )\n1083         except UnitsError as exc:\n1084             # Last hope: maybe other knows how to do it?\n1085             # We assume the equivalencies have the unit itself as first item.\n1086             # TODO: maybe better for other to have a `_back_converter` method?\n1087             if hasattr(other, \"equivalencies\"):\n1088                 for funit, tunit, a, b in other.equivalencies:\n1089                     if other is funit:\n1090                         try:\n1091                             converter = self._get_converter(tunit, equivalencies)\n1092                         except Exception:\n1093                             pass\n1094                         else:\n1095                             return lambda v: b(converter(v))\n1096 \n1097             raise exc\n1098 \n1099     def _to(self, other):\n1100         \"\"\"\n1101         Returns the scale to the specified unit.\n1102 \n1103         See `to`, except that a Unit object should be given (i.e., no\n1104         string), and that all defaults are used, i.e., no\n1105         equivalencies and value=1.\n1106         \"\"\"\n1107         # There are many cases where we just want to ensure a Quantity is\n1108         # of a particular unit, without checking whether it's already in\n1109         # a particular unit.  If we're being asked to convert from a unit\n1110         # to itself, we can short-circuit all of this.\n1111         if self is other:\n1112             return 1.0\n1113 \n1114         # Don't presume decomposition is possible; e.g.,\n1115         # conversion to function units is through equivalencies.\n1116         if isinstance(other, UnitBase):\n1117             self_decomposed = self.decompose()\n1118             other_decomposed = other.decompose()\n1119 \n1120             # Check quickly whether equivalent.  This is faster than\n1121             # `is_equivalent`, because it doesn't generate the entire\n1122             # physical type list of both units.  In other words it \"fails\n1123             # fast\".\n1124             if self_decomposed.powers == other_decomposed.powers and all(\n1125                 self_base is other_base\n1126                 for (self_base, other_base) in zip(\n1127                     self_decomposed.bases, other_decomposed.bases\n1128                 )\n1129             ):\n1130                 return self_decomposed.scale / other_decomposed.scale\n1131 \n1132         raise UnitConversionError(f\"'{self!r}' is not a scaled version of '{other!r}'\")\n1133 \n1134     def to(self, other, value=UNITY, equivalencies=[]):\n1135         \"\"\"\n1136         Return the converted values in the specified unit.\n1137 \n1138         Parameters\n1139         ----------\n1140         other : unit-like\n1141             The unit to convert to.\n1142 \n1143         value : int, float, or scalar array-like, optional\n1144             Value(s) in the current unit to be converted to the\n1145             specified unit.  If not provided, defaults to 1.0\n1146 \n1147         equivalencies : list of tuple\n1148             A list of equivalence pairs to try if the units are not\n1149             directly convertible.  See :ref:`astropy:unit_equivalencies`.\n1150             This list is in addition to possible global defaults set by, e.g.,\n1151             `set_enabled_equivalencies`.\n1152             Use `None` to turn off all equivalencies.\n1153 \n1154         Returns\n1155         -------\n1156         values : scalar or array\n1157             Converted value(s). Input value sequences are returned as\n1158             numpy arrays.\n1159 \n1160         Raises\n1161         ------\n1162         UnitsError\n1163             If units are inconsistent\n1164         \"\"\"\n1165         if other is self and value is UNITY:\n1166             return UNITY\n1167         else:\n1168             return self._get_converter(Unit(other), equivalencies)(value)\n1169 \n1170     def in_units(self, other, value=1.0, equivalencies=[]):\n1171         \"\"\"\n1172         Alias for `to` for backward compatibility with pynbody.\n1173         \"\"\"\n1174         return self.to(other, value=value, equivalencies=equivalencies)\n1175 \n1176     def decompose(self, bases=set()):\n1177         \"\"\"\n1178         Return a unit object composed of only irreducible units.\n1179 \n1180         Parameters\n1181         ----------\n1182         bases : sequence of UnitBase, optional\n1183             The bases to decompose into.  When not provided,\n1184             decomposes down to any irreducible units.  When provided,\n1185             the decomposed result will only contain the given units.\n1186             This will raises a `UnitsError` if it's not possible\n1187             to do so.\n1188 \n1189         Returns\n1190         -------\n1191         unit : `~astropy.units.CompositeUnit`\n1192             New object containing only irreducible unit objects.\n1193         \"\"\"\n1194         raise NotImplementedError()\n1195 \n1196     def _compose(\n1197         self, equivalencies=[], namespace=[], max_depth=2, depth=0, cached_results=None\n1198     ):\n1199         def is_final_result(unit):\n1200             # Returns True if this result contains only the expected\n1201             # units\n1202             return all(base in namespace for base in unit.bases)\n1203 \n1204         unit = self.decompose()\n1205         key = hash(unit)\n1206 \n1207         cached = cached_results.get(key)\n1208         if cached is not None:\n1209             if isinstance(cached, Exception):\n1210                 raise cached\n1211             return cached\n1212 \n1213         # Prevent too many levels of recursion\n1214         # And special case for dimensionless unit\n1215         if depth >= max_depth:\n1216             cached_results[key] = [unit]\n1217             return [unit]\n1218 \n1219         # Make a list including all of the equivalent units\n1220         units = [unit]\n1221         for funit, tunit, a, b in equivalencies:\n1222             if tunit is not None:\n1223                 if self._is_equivalent(funit):\n1224                     scale = funit.decompose().scale / unit.scale\n1225                     units.append(Unit(a(1.0 / scale) * tunit).decompose())\n1226                 elif self._is_equivalent(tunit):\n1227                     scale = tunit.decompose().scale / unit.scale\n1228                     units.append(Unit(b(1.0 / scale) * funit).decompose())\n1229             else:\n1230                 if self._is_equivalent(funit):\n1231                     units.append(Unit(unit.scale))\n1232 \n1233         # Store partial results\n1234         partial_results = []\n1235         # Store final results that reduce to a single unit or pair of\n1236         # units\n1237         if len(unit.bases) == 0:\n1238             final_results = [{unit}, set()]\n1239         else:\n1240             final_results = [set(), set()]\n1241 \n1242         for tunit in namespace:\n1243             tunit_decomposed = tunit.decompose()\n1244             for u in units:\n1245                 # If the unit is a base unit, look for an exact match\n1246                 # to one of the bases of the target unit.  If found,\n1247                 # factor by the same power as the target unit's base.\n1248                 # This allows us to factor out fractional powers\n1249                 # without needing to do an exhaustive search.\n1250                 if len(tunit_decomposed.bases) == 1:\n1251                     for base, power in zip(u.bases, u.powers):\n1252                         if tunit_decomposed._is_equivalent(base):\n1253                             tunit = tunit**power\n1254                             tunit_decomposed = tunit_decomposed**power\n1255                             break\n1256 \n1257                 composed = (u / tunit_decomposed).decompose()\n1258                 factored = composed * tunit\n1259                 len_bases = len(composed.bases)\n1260                 if is_final_result(factored) and len_bases <= 1:\n1261                     final_results[len_bases].add(factored)\n1262                 else:\n1263                     partial_results.append((len_bases, composed, tunit))\n1264 \n1265         # Do we have any minimal results?\n1266         for final_result in final_results:\n1267             if len(final_result):\n1268                 results = final_results[0].union(final_results[1])\n1269                 cached_results[key] = results\n1270                 return results\n1271 \n1272         partial_results.sort(key=operator.itemgetter(0))\n1273 \n1274         # ...we have to recurse and try to further compose\n1275         results = []\n1276         for len_bases, composed, tunit in partial_results:\n1277             try:\n1278                 composed_list = composed._compose(\n1279                     equivalencies=equivalencies,\n1280                     namespace=namespace,\n1281                     max_depth=max_depth,\n1282                     depth=depth + 1,\n1283                     cached_results=cached_results,\n1284                 )\n1285             except UnitsError:\n1286                 composed_list = []\n1287             for subcomposed in composed_list:\n1288                 results.append((len(subcomposed.bases), subcomposed, tunit))\n1289 \n1290         if len(results):\n1291             results.sort(key=operator.itemgetter(0))\n1292 \n1293             min_length = results[0][0]\n1294             subresults = set()\n1295             for len_bases, composed, tunit in results:\n1296                 if len_bases > min_length:\n1297                     break\n1298                 else:\n1299                     factored = composed * tunit\n1300                     if is_final_result(factored):\n1301                         subresults.add(factored)\n1302 \n1303             if len(subresults):\n1304                 cached_results[key] = subresults\n1305                 return subresults\n1306 \n1307         if not is_final_result(self):\n1308             result = UnitsError(\n1309                 f\"Cannot represent unit {self} in terms of the given units\"\n1310             )\n1311             cached_results[key] = result\n1312             raise result\n1313 \n1314         cached_results[key] = [self]\n1315         return [self]\n1316 \n1317     def compose(\n1318         self, equivalencies=[], units=None, max_depth=2, include_prefix_units=None\n1319     ):\n1320         \"\"\"\n1321         Return the simplest possible composite unit(s) that represent\n1322         the given unit.  Since there may be multiple equally simple\n1323         compositions of the unit, a list of units is always returned.\n1324 \n1325         Parameters\n1326         ----------\n1327         equivalencies : list of tuple\n1328             A list of equivalence pairs to also list.  See\n1329             :ref:`astropy:unit_equivalencies`.\n1330             This list is in addition to possible global defaults set by, e.g.,\n1331             `set_enabled_equivalencies`.\n1332             Use `None` to turn off all equivalencies.\n1333 \n1334         units : set of `~astropy.units.Unit`, optional\n1335             If not provided, any known units may be used to compose\n1336             into.  Otherwise, ``units`` is a dict, module or sequence\n1337             containing the units to compose into.\n1338 \n1339         max_depth : int, optional\n1340             The maximum recursion depth to use when composing into\n1341             composite units.\n1342 \n1343         include_prefix_units : bool, optional\n1344             When `True`, include prefixed units in the result.\n1345             Default is `True` if a sequence is passed in to ``units``,\n1346             `False` otherwise.\n1347 \n1348         Returns\n1349         -------\n1350         units : list of `CompositeUnit`\n1351             A list of candidate compositions.  These will all be\n1352             equally simple, but it may not be possible to\n1353             automatically determine which of the candidates are\n1354             better.\n1355         \"\"\"\n1356         # if units parameter is specified and is a sequence (list|tuple),\n1357         # include_prefix_units is turned on by default.  Ex: units=[u.kpc]\n1358         if include_prefix_units is None:\n1359             include_prefix_units = isinstance(units, (list, tuple))\n1360 \n1361         # Pre-normalize the equivalencies list\n1362         equivalencies = self._normalize_equivalencies(equivalencies)\n1363 \n1364         # The namespace of units to compose into should be filtered to\n1365         # only include units with bases in common with self, otherwise\n1366         # they can't possibly provide useful results.  Having too many\n1367         # destination units greatly increases the search space.\n1368 \n1369         def has_bases_in_common(a, b):\n1370             if len(a.bases) == 0 and len(b.bases) == 0:\n1371                 return True\n1372             for ab in a.bases:\n1373                 for bb in b.bases:\n1374                     if ab == bb:\n1375                         return True\n1376             return False\n1377 \n1378         def has_bases_in_common_with_equiv(unit, other):\n1379             if has_bases_in_common(unit, other):\n1380                 return True\n1381             for funit, tunit, a, b in equivalencies:\n1382                 if tunit is not None:\n1383                     if unit._is_equivalent(funit):\n1384                         if has_bases_in_common(tunit.decompose(), other):\n1385                             return True\n1386                     elif unit._is_equivalent(tunit):\n1387                         if has_bases_in_common(funit.decompose(), other):\n1388                             return True\n1389                 else:\n1390                     if unit._is_equivalent(funit):\n1391                         if has_bases_in_common(dimensionless_unscaled, other):\n1392                             return True\n1393             return False\n1394 \n1395         def filter_units(units):\n1396             filtered_namespace = set()\n1397             for tunit in units:\n1398                 if (\n1399                     isinstance(tunit, UnitBase)\n1400                     and (include_prefix_units or not isinstance(tunit, PrefixUnit))\n1401                     and has_bases_in_common_with_equiv(decomposed, tunit.decompose())\n1402                 ):\n1403                     filtered_namespace.add(tunit)\n1404             return filtered_namespace\n1405 \n1406         decomposed = self.decompose()\n1407 \n1408         if units is None:\n1409             units = filter_units(self._get_units_with_same_physical_type(equivalencies))\n1410             if len(units) == 0:\n1411                 units = get_current_unit_registry().non_prefix_units\n1412         elif isinstance(units, dict):\n1413             units = set(filter_units(units.values()))\n1414         elif inspect.ismodule(units):\n1415             units = filter_units(vars(units).values())\n1416         else:\n1417             units = filter_units(_flatten_units_collection(units))\n1418 \n1419         def sort_results(results):\n1420             if not len(results):\n1421                 return []\n1422 \n1423             # Sort the results so the simplest ones appear first.\n1424             # Simplest is defined as \"the minimum sum of absolute\n1425             # powers\" (i.e. the fewest bases), and preference should\n1426             # be given to results where the sum of powers is positive\n1427             # and the scale is exactly equal to 1.0\n1428             results = list(results)\n1429             results.sort(key=lambda x: np.abs(x.scale))\n1430             results.sort(key=lambda x: np.sum(np.abs(x.powers)))\n1431             results.sort(key=lambda x: np.sum(x.powers) < 0.0)\n1432             results.sort(key=lambda x: not is_effectively_unity(x.scale))\n1433 \n1434             last_result = results[0]\n1435             filtered = [last_result]\n1436             for result in results[1:]:\n1437                 if str(result) != str(last_result):\n1438                     filtered.append(result)\n1439                 last_result = result\n1440 \n1441             return filtered\n1442 \n1443         return sort_results(\n1444             self._compose(\n1445                 equivalencies=equivalencies,\n1446                 namespace=units,\n1447                 max_depth=max_depth,\n1448                 depth=0,\n1449                 cached_results={},\n1450             )\n1451         )\n1452 \n1453     def to_system(self, system):\n1454         \"\"\"\n1455         Converts this unit into ones belonging to the given system.\n1456         Since more than one result may be possible, a list is always\n1457         returned.\n1458 \n1459         Parameters\n1460         ----------\n1461         system : module\n1462             The module that defines the unit system.  Commonly used\n1463             ones include `astropy.units.si` and `astropy.units.cgs`.\n1464 \n1465             To use your own module it must contain unit objects and a\n1466             sequence member named ``bases`` containing the base units of\n1467             the system.\n1468 \n1469         Returns\n1470         -------\n1471         units : list of `CompositeUnit`\n1472             The list is ranked so that units containing only the base\n1473             units of that system will appear first.\n1474         \"\"\"\n1475         bases = set(system.bases)\n1476 \n1477         def score(compose):\n1478             # In case that compose._bases has no elements we return\n1479             # 'np.inf' as 'score value'.  It does not really matter which\n1480             # number we would return. This case occurs for instance for\n1481             # dimensionless quantities:\n1482             compose_bases = compose.bases\n1483             if len(compose_bases) == 0:\n1484                 return np.inf\n1485             else:\n1486                 sum = 0\n1487                 for base in compose_bases:\n1488                     if base in bases:\n1489                         sum += 1\n1490 \n1491                 return sum / float(len(compose_bases))\n1492 \n1493         x = self.decompose(bases=bases)\n1494         composed = x.compose(units=system)\n1495         composed = sorted(composed, key=score, reverse=True)\n1496         return composed\n1497 \n1498     @lazyproperty\n1499     def si(self):\n1500         \"\"\"\n1501         Returns a copy of the current `Unit` instance in SI units.\n1502         \"\"\"\n1503         from . import si\n1504 \n1505         return self.to_system(si)[0]\n1506 \n1507     @lazyproperty\n1508     def cgs(self):\n1509         \"\"\"\n1510         Returns a copy of the current `Unit` instance with CGS units.\n1511         \"\"\"\n1512         from . import cgs\n1513 \n1514         return self.to_system(cgs)[0]\n1515 \n1516     @property\n1517     def physical_type(self):\n1518         \"\"\"\n1519         Physical type(s) dimensionally compatible with the unit.\n1520 \n1521         Returns\n1522         -------\n1523         `~astropy.units.physical.PhysicalType`\n1524             A representation of the physical type(s) of a unit.\n1525 \n1526         Examples\n1527         --------\n1528         >>> from astropy import units as u\n1529         >>> u.m.physical_type\n1530         PhysicalType('length')\n1531         >>> (u.m ** 2 / u.s).physical_type\n1532         PhysicalType({'diffusivity', 'kinematic viscosity'})\n1533 \n1534         Physical types can be compared to other physical types\n1535         (recommended in packages) or to strings.\n1536 \n1537         >>> area = (u.m ** 2).physical_type\n1538         >>> area == u.m.physical_type ** 2\n1539         True\n1540         >>> area == \"area\"\n1541         True\n1542 \n1543         `~astropy.units.physical.PhysicalType` objects can be used for\n1544         dimensional analysis.\n1545 \n1546         >>> number_density = u.m.physical_type ** -3\n1547         >>> velocity = (u.m / u.s).physical_type\n1548         >>> number_density * velocity\n1549         PhysicalType('particle flux')\n1550         \"\"\"\n1551         from . import physical\n1552 \n1553         return physical.get_physical_type(self)\n1554 \n1555     def _get_units_with_same_physical_type(self, equivalencies=[]):\n1556         \"\"\"\n1557         Return a list of registered units with the same physical type\n1558         as this unit.\n1559 \n1560         This function is used by Quantity to add its built-in\n1561         conversions to equivalent units.\n1562 \n1563         This is a private method, since end users should be encouraged\n1564         to use the more powerful `compose` and `find_equivalent_units`\n1565         methods (which use this under the hood).\n1566 \n1567         Parameters\n1568         ----------\n1569         equivalencies : list of tuple\n1570             A list of equivalence pairs to also pull options from.\n1571             See :ref:`astropy:unit_equivalencies`.  It must already be\n1572             normalized using `_normalize_equivalencies`.\n1573         \"\"\"\n1574         unit_registry = get_current_unit_registry()\n1575         units = set(unit_registry.get_units_with_physical_type(self))\n1576         for funit, tunit, a, b in equivalencies:\n1577             if tunit is not None:\n1578                 if self.is_equivalent(funit) and tunit not in units:\n1579                     units.update(unit_registry.get_units_with_physical_type(tunit))\n1580                 if self._is_equivalent(tunit) and funit not in units:\n1581                     units.update(unit_registry.get_units_with_physical_type(funit))\n1582             else:\n1583                 if self.is_equivalent(funit):\n1584                     units.add(dimensionless_unscaled)\n1585         return units\n1586 \n1587     class EquivalentUnitsList(list):\n1588         \"\"\"\n1589         A class to handle pretty-printing the result of\n1590         `find_equivalent_units`.\n1591         \"\"\"\n1592 \n1593         HEADING_NAMES = (\"Primary name\", \"Unit definition\", \"Aliases\")\n1594         ROW_LEN = 3  # len(HEADING_NAMES), but hard-code since it is constant\n1595         NO_EQUIV_UNITS_MSG = \"There are no equivalent units\"\n1596 \n1597         def __repr__(self):\n1598             if len(self) == 0:\n1599                 return self.NO_EQUIV_UNITS_MSG\n1600             else:\n1601                 lines = self._process_equivalent_units(self)\n1602                 lines.insert(0, self.HEADING_NAMES)\n1603                 widths = [0] * self.ROW_LEN\n1604                 for line in lines:\n1605                     for i, col in enumerate(line):\n1606                         widths[i] = max(widths[i], len(col))\n1607 \n1608                 f = \"  {{0:<{}s}} | {{1:<{}s}} | {{2:<{}s}}\".format(*widths)\n1609                 lines = [f.format(*line) for line in lines]\n1610                 lines = lines[0:1] + [\"[\"] + [f\"{x} ,\" for x in lines[1:]] + [\"]\"]\n1611                 return \"\\n\".join(lines)\n1612 \n1613         def _repr_html_(self):\n1614             \"\"\"\n1615             Outputs a HTML table representation within Jupyter notebooks.\n1616             \"\"\"\n1617             if len(self) == 0:\n1618                 return f\"<p>{self.NO_EQUIV_UNITS_MSG}</p>\"\n1619             else:\n1620                 # HTML tags to use to compose the table in HTML\n1621                 blank_table = '<table style=\"width:50%\">{}</table>'\n1622                 blank_row_container = \"<tr>{}</tr>\"\n1623                 heading_row_content = \"<th>{}</th>\" * self.ROW_LEN\n1624                 data_row_content = \"<td>{}</td>\" * self.ROW_LEN\n1625 \n1626                 # The HTML will be rendered & the table is simple, so don't\n1627                 # bother to include newlines & indentation for the HTML code.\n1628                 heading_row = blank_row_container.format(\n1629                     heading_row_content.format(*self.HEADING_NAMES)\n1630                 )\n1631                 data_rows = self._process_equivalent_units(self)\n1632                 all_rows = heading_row\n1633                 for row in data_rows:\n1634                     html_row = blank_row_container.format(data_row_content.format(*row))\n1635                     all_rows += html_row\n1636                 return blank_table.format(all_rows)\n1637 \n1638         @staticmethod\n1639         def _process_equivalent_units(equiv_units_data):\n1640             \"\"\"\n1641             Extract attributes, and sort, the equivalent units pre-formatting.\n1642             \"\"\"\n1643             processed_equiv_units = []\n1644             for u in equiv_units_data:\n1645                 irred = u.decompose().to_string()\n1646                 if irred == u.name:\n1647                     irred = \"irreducible\"\n1648                 processed_equiv_units.append((u.name, irred, \", \".join(u.aliases)))\n1649             processed_equiv_units.sort()\n1650             return processed_equiv_units\n1651 \n1652     def find_equivalent_units(\n1653         self, equivalencies=[], units=None, include_prefix_units=False\n1654     ):\n1655         \"\"\"\n1656         Return a list of all the units that are the same type as ``self``.\n1657 \n1658         Parameters\n1659         ----------\n1660         equivalencies : list of tuple\n1661             A list of equivalence pairs to also list.  See\n1662             :ref:`astropy:unit_equivalencies`.\n1663             Any list given, including an empty one, supersedes global defaults\n1664             that may be in effect (as set by `set_enabled_equivalencies`)\n1665 \n1666         units : set of `~astropy.units.Unit`, optional\n1667             If not provided, all defined units will be searched for\n1668             equivalencies.  Otherwise, may be a dict, module or\n1669             sequence containing the units to search for equivalencies.\n1670 \n1671         include_prefix_units : bool, optional\n1672             When `True`, include prefixed units in the result.\n1673             Default is `False`.\n1674 \n1675         Returns\n1676         -------\n1677         units : list of `UnitBase`\n1678             A list of unit objects that match ``u``.  A subclass of\n1679             `list` (``EquivalentUnitsList``) is returned that\n1680             pretty-prints the list of units when output.\n1681         \"\"\"\n1682         results = self.compose(\n1683             equivalencies=equivalencies,\n1684             units=units,\n1685             max_depth=1,\n1686             include_prefix_units=include_prefix_units,\n1687         )\n1688         results = {x.bases[0] for x in results if len(x.bases) == 1}\n1689         return self.EquivalentUnitsList(results)\n1690 \n1691     def is_unity(self):\n1692         \"\"\"\n1693         Returns `True` if the unit is unscaled and dimensionless.\n1694         \"\"\"\n1695         return False\n1696 \n1697 \n1698 class NamedUnit(UnitBase):\n1699     \"\"\"\n1700     The base class of units that have a name.\n1701 \n1702     Parameters\n1703     ----------\n1704     st : str, list of str, 2-tuple\n1705         The name of the unit.  If a list of strings, the first element\n1706         is the canonical (short) name, and the rest of the elements\n1707         are aliases.  If a tuple of lists, the first element is a list\n1708         of short names, and the second element is a list of long\n1709         names; all but the first short name are considered \"aliases\".\n1710         Each name *should* be a valid Python identifier to make it\n1711         easy to access, but this is not required.\n1712 \n1713     namespace : dict, optional\n1714         When provided, inject the unit, and all of its aliases, in the\n1715         given namespace dictionary.  If a unit by the same name is\n1716         already in the namespace, a ValueError is raised.\n1717 \n1718     doc : str, optional\n1719         A docstring describing the unit.\n1720 \n1721     format : dict, optional\n1722         A mapping to format-specific representations of this unit.\n1723         For example, for the ``Ohm`` unit, it might be nice to have it\n1724         displayed as ``\\\\Omega`` by the ``latex`` formatter.  In that\n1725         case, `format` argument should be set to::\n1726 \n1727             {'latex': r'\\\\Omega'}\n1728 \n1729     Raises\n1730     ------\n1731     ValueError\n1732         If any of the given unit names are already in the registry.\n1733 \n1734     ValueError\n1735         If any of the given unit names are not valid Python tokens.\n1736     \"\"\"\n1737 \n1738     def __init__(self, st, doc=None, format=None, namespace=None):\n1739         UnitBase.__init__(self)\n1740 \n1741         if isinstance(st, (bytes, str)):\n1742             self._names = [st]\n1743             self._short_names = [st]\n1744             self._long_names = []\n1745         elif isinstance(st, tuple):\n1746             if not len(st) == 2:\n1747                 raise ValueError(\"st must be string, list or 2-tuple\")\n1748             self._names = st[0] + [n for n in st[1] if n not in st[0]]\n1749             if not len(self._names):\n1750                 raise ValueError(\"must provide at least one name\")\n1751             self._short_names = st[0][:]\n1752             self._long_names = st[1][:]\n1753         else:\n1754             if len(st) == 0:\n1755                 raise ValueError(\"st list must have at least one entry\")\n1756             self._names = st[:]\n1757             self._short_names = [st[0]]\n1758             self._long_names = st[1:]\n1759 \n1760         if format is None:\n1761             format = {}\n1762         self._format = format\n1763 \n1764         if doc is None:\n1765             doc = self._generate_doc()\n1766         else:\n1767             doc = textwrap.dedent(doc)\n1768             doc = textwrap.fill(doc)\n1769 \n1770         self.__doc__ = doc\n1771 \n1772         self._inject(namespace)\n1773 \n1774     def _generate_doc(self):\n1775         \"\"\"\n1776         Generate a docstring for the unit if the user didn't supply\n1777         one.  This is only used from the constructor and may be\n1778         overridden in subclasses.\n1779         \"\"\"\n1780         names = self.names\n1781         if len(self.names) > 1:\n1782             return f\"{names[1]} ({names[0]})\"\n1783         else:\n1784             return names[0]\n1785 \n1786     def get_format_name(self, format):\n1787         \"\"\"\n1788         Get a name for this unit that is specific to a particular\n1789         format.\n1790 \n1791         Uses the dictionary passed into the `format` kwarg in the\n1792         constructor.\n1793 \n1794         Parameters\n1795         ----------\n1796         format : str\n1797             The name of the format\n1798 \n1799         Returns\n1800         -------\n1801         name : str\n1802             The name of the unit for the given format.\n1803         \"\"\"\n1804         return self._format.get(format, self.name)\n1805 \n1806     @property\n1807     def names(self):\n1808         \"\"\"\n1809         Returns all of the names associated with this unit.\n1810         \"\"\"\n1811         return self._names\n1812 \n1813     @property\n1814     def name(self):\n1815         \"\"\"\n1816         Returns the canonical (short) name associated with this unit.\n1817         \"\"\"\n1818         return self._names[0]\n1819 \n1820     @property\n1821     def aliases(self):\n1822         \"\"\"\n1823         Returns the alias (long) names for this unit.\n1824         \"\"\"\n1825         return self._names[1:]\n1826 \n1827     @property\n1828     def short_names(self):\n1829         \"\"\"\n1830         Returns all of the short names associated with this unit.\n1831         \"\"\"\n1832         return self._short_names\n1833 \n1834     @property\n1835     def long_names(self):\n1836         \"\"\"\n1837         Returns all of the long names associated with this unit.\n1838         \"\"\"\n1839         return self._long_names\n1840 \n1841     def _inject(self, namespace=None):\n1842         \"\"\"\n1843         Injects the unit, and all of its aliases, in the given\n1844         namespace dictionary.\n1845         \"\"\"\n1846         if namespace is None:\n1847             return\n1848 \n1849         # Loop through all of the names first, to ensure all of them\n1850         # are new, then add them all as a single \"transaction\" below.\n1851         for name in self._names:\n1852             if name in namespace and self != namespace[name]:\n1853                 raise ValueError(\n1854                     f\"Object with name {name!r} already exists in \"\n1855                     f\"given namespace ({namespace[name]!r}).\"\n1856                 )\n1857 \n1858         for name in self._names:\n1859             namespace[name] = self\n1860 \n1861 \n1862 def _recreate_irreducible_unit(cls, names, registered):\n1863     \"\"\"\n1864     This is used to reconstruct units when passed around by\n1865     multiprocessing.\n1866     \"\"\"\n1867     registry = get_current_unit_registry().registry\n1868     if names[0] in registry:\n1869         # If in local registry return that object.\n1870         return registry[names[0]]\n1871     else:\n1872         # otherwise, recreate the unit.\n1873         unit = cls(names)\n1874         if registered:\n1875             # If not in local registry but registered in origin registry,\n1876             # enable unit in local registry.\n1877             get_current_unit_registry().add_enabled_units([unit])\n1878 \n1879         return unit\n1880 \n1881 \n1882 class IrreducibleUnit(NamedUnit):\n1883     \"\"\"\n1884     Irreducible units are the units that all other units are defined\n1885     in terms of.\n1886 \n1887     Examples are meters, seconds, kilograms, amperes, etc.  There is\n1888     only once instance of such a unit per type.\n1889     \"\"\"\n1890 \n1891     def __reduce__(self):\n1892         # When IrreducibleUnit objects are passed to other processes\n1893         # over multiprocessing, they need to be recreated to be the\n1894         # ones already in the subprocesses' namespace, not new\n1895         # objects, or they will be considered \"unconvertible\".\n1896         # Therefore, we have a custom pickler/unpickler that\n1897         # understands how to recreate the Unit on the other side.\n1898         registry = get_current_unit_registry().registry\n1899         return (\n1900             _recreate_irreducible_unit,\n1901             (self.__class__, list(self.names), self.name in registry),\n1902             self.__getstate__(),\n1903         )\n1904 \n1905     @property\n1906     def represents(self):\n1907         \"\"\"The unit that this named unit represents.\n1908 \n1909         For an irreducible unit, that is always itself.\n1910         \"\"\"\n1911         return self\n1912 \n1913     def decompose(self, bases=set()):\n1914         if len(bases) and self not in bases:\n1915             for base in bases:\n1916                 try:\n1917                     scale = self._to(base)\n1918                 except UnitsError:\n1919                     pass\n1920                 else:\n1921                     if is_effectively_unity(scale):\n1922                         return base\n1923                     else:\n1924                         return CompositeUnit(scale, [base], [1], _error_check=False)\n1925 \n1926             raise UnitConversionError(\n1927                 f\"Unit {self} can not be decomposed into the requested bases\"\n1928             )\n1929 \n1930         return self\n1931 \n1932 \n1933 class UnrecognizedUnit(IrreducibleUnit):\n1934     \"\"\"\n1935     A unit that did not parse correctly.  This allows for\n1936     round-tripping it as a string, but no unit operations actually work\n1937     on it.\n1938 \n1939     Parameters\n1940     ----------\n1941     st : str\n1942         The name of the unit.\n1943     \"\"\"\n1944 \n1945     # For UnrecognizedUnits, we want to use \"standard\" Python\n1946     # pickling, not the special case that is used for\n1947     # IrreducibleUnits.\n1948     __reduce__ = object.__reduce__\n1949 \n1950     def __repr__(self):\n1951         return f\"UnrecognizedUnit({str(self)})\"\n1952 \n1953     def __bytes__(self):\n1954         return self.name.encode(\"ascii\", \"replace\")\n1955 \n1956     def __str__(self):\n1957         return self.name\n1958 \n1959     def to_string(self, format=None):\n1960         return self.name\n1961 \n1962     def _unrecognized_operator(self, *args, **kwargs):\n1963         raise ValueError(\n1964             f\"The unit {self.name!r} is unrecognized, so all arithmetic operations \"\n1965             \"with it are invalid.\"\n1966         )\n1967 \n1968     __pow__ = __truediv__ = __rtruediv__ = __mul__ = __rmul__ = _unrecognized_operator\n1969     __lt__ = __gt__ = __le__ = __ge__ = __neg__ = _unrecognized_operator\n1970 \n1971     def __eq__(self, other):\n1972         try:\n1973             other = Unit(other, parse_strict=\"silent\")\n1974         except (ValueError, UnitsError, TypeError):\n1975             return NotImplemented\n1976 \n1977         return isinstance(other, type(self)) and self.name == other.name\n1978 \n1979     def __ne__(self, other):\n1980         return not (self == other)\n1981 \n1982     def is_equivalent(self, other, equivalencies=None):\n1983         self._normalize_equivalencies(equivalencies)\n1984         return self == other\n1985 \n1986     def _get_converter(self, other, equivalencies=None):\n1987         self._normalize_equivalencies(equivalencies)\n1988         raise ValueError(\n1989             f\"The unit {self.name!r} is unrecognized.  It can not be converted \"\n1990             \"to other units.\"\n1991         )\n1992 \n1993     def get_format_name(self, format):\n1994         return self.name\n1995 \n1996     def is_unity(self):\n1997         return False\n1998 \n1999 \n2000 class _UnitMetaClass(type):\n2001     \"\"\"\n2002     This metaclass exists because the Unit constructor should\n2003     sometimes return instances that already exist.  This \"overrides\"\n2004     the constructor before the new instance is actually created, so we\n2005     can return an existing one.\n2006     \"\"\"\n2007 \n2008     def __call__(\n2009         self,\n2010         s=\"\",\n2011         represents=None,\n2012         format=None,\n2013         namespace=None,\n2014         doc=None,\n2015         parse_strict=\"raise\",\n2016     ):\n2017         # Short-circuit if we're already a unit\n2018         if hasattr(s, \"_get_physical_type_id\"):\n2019             return s\n2020 \n2021         # turn possible Quantity input for s or represents into a Unit\n2022         from .quantity import Quantity\n2023 \n2024         if isinstance(represents, Quantity):\n2025             if is_effectively_unity(represents.value):\n2026                 represents = represents.unit\n2027             else:\n2028                 represents = CompositeUnit(\n2029                     represents.value * represents.unit.scale,\n2030                     bases=represents.unit.bases,\n2031                     powers=represents.unit.powers,\n2032                     _error_check=False,\n2033                 )\n2034 \n2035         if isinstance(s, Quantity):\n2036             if is_effectively_unity(s.value):\n2037                 s = s.unit\n2038             else:\n2039                 s = CompositeUnit(\n2040                     s.value * s.unit.scale,\n2041                     bases=s.unit.bases,\n2042                     powers=s.unit.powers,\n2043                     _error_check=False,\n2044                 )\n2045 \n2046         # now decide what we really need to do; define derived Unit?\n2047         if isinstance(represents, UnitBase):\n2048             # This has the effect of calling the real __new__ and\n2049             # __init__ on the Unit class.\n2050             return super().__call__(\n2051                 s, represents, format=format, namespace=namespace, doc=doc\n2052             )\n2053 \n2054         # or interpret a Quantity (now became unit), string or number?\n2055         if isinstance(s, UnitBase):\n2056             return s\n2057 \n2058         elif isinstance(s, (bytes, str)):\n2059             if len(s.strip()) == 0:\n2060                 # Return the NULL unit\n2061                 return dimensionless_unscaled\n2062 \n2063             if format is None:\n2064                 format = unit_format.Generic\n2065 \n2066             f = unit_format.get_format(format)\n2067             if isinstance(s, bytes):\n2068                 s = s.decode(\"ascii\")\n2069 \n2070             try:\n2071                 return f.parse(s)\n2072             except NotImplementedError:\n2073                 raise\n2074             except Exception as e:\n2075                 if parse_strict == \"silent\":\n2076                     pass\n2077                 else:\n2078                     # Deliberately not issubclass here. Subclasses\n2079                     # should use their name.\n2080                     if f is not unit_format.Generic:\n2081                         format_clause = f.name + \" \"\n2082                     else:\n2083                         format_clause = \"\"\n2084                     msg = (\n2085                         f\"'{s}' did not parse as {format_clause}unit: {str(e)} \"\n2086                         \"If this is meant to be a custom unit, \"\n2087                         \"define it with 'u.def_unit'. To have it \"\n2088                         \"recognized inside a file reader or other code, \"\n2089                         \"enable it with 'u.add_enabled_units'. \"\n2090                         \"For details, see \"\n2091                         \"https://docs.astropy.org/en/latest/units/combining_and_defining.html\"\n2092                     )\n2093                     if parse_strict == \"raise\":\n2094                         raise ValueError(msg)\n2095                     elif parse_strict == \"warn\":\n2096                         warnings.warn(msg, UnitsWarning)\n2097                     else:\n2098                         raise ValueError(\n2099                             \"'parse_strict' must be 'warn', 'raise' or 'silent'\"\n2100                         )\n2101                 return UnrecognizedUnit(s)\n2102 \n2103         elif isinstance(s, (int, float, np.floating, np.integer)):\n2104             return CompositeUnit(s, [], [], _error_check=False)\n2105 \n2106         elif isinstance(s, tuple):\n2107             from .structured import StructuredUnit\n2108 \n2109             return StructuredUnit(s)\n2110 \n2111         elif s is None:\n2112             raise TypeError(\"None is not a valid Unit\")\n2113 \n2114         else:\n2115             raise TypeError(f\"{s} can not be converted to a Unit\")\n2116 \n2117 \n2118 class Unit(NamedUnit, metaclass=_UnitMetaClass):\n2119     \"\"\"\n2120     The main unit class.\n2121 \n2122     There are a number of different ways to construct a Unit, but\n2123     always returns a `UnitBase` instance.  If the arguments refer to\n2124     an already-existing unit, that existing unit instance is returned,\n2125     rather than a new one.\n2126 \n2127     - From a string::\n2128 \n2129         Unit(s, format=None, parse_strict='silent')\n2130 \n2131       Construct from a string representing a (possibly compound) unit.\n2132 \n2133       The optional `format` keyword argument specifies the format the\n2134       string is in, by default ``\"generic\"``.  For a description of\n2135       the available formats, see `astropy.units.format`.\n2136 \n2137       The optional ``parse_strict`` keyword controls what happens when an\n2138       unrecognized unit string is passed in.  It may be one of the following:\n2139 \n2140          - ``'raise'``: (default) raise a ValueError exception.\n2141 \n2142          - ``'warn'``: emit a Warning, and return an\n2143            `UnrecognizedUnit` instance.\n2144 \n2145          - ``'silent'``: return an `UnrecognizedUnit` instance.\n2146 \n2147     - From a number::\n2148 \n2149         Unit(number)\n2150 \n2151       Creates a dimensionless unit.\n2152 \n2153     - From a `UnitBase` instance::\n2154 \n2155         Unit(unit)\n2156 \n2157       Returns the given unit unchanged.\n2158 \n2159     - From no arguments::\n2160 \n2161         Unit()\n2162 \n2163       Returns the dimensionless unit.\n2164 \n2165     - The last form, which creates a new `Unit` is described in detail\n2166       below.\n2167 \n2168     See also: https://docs.astropy.org/en/stable/units/\n2169 \n2170     Parameters\n2171     ----------\n2172     st : str or list of str\n2173         The name of the unit.  If a list, the first element is the\n2174         canonical (short) name, and the rest of the elements are\n2175         aliases.\n2176 \n2177     represents : UnitBase instance\n2178         The unit that this named unit represents.\n2179 \n2180     doc : str, optional\n2181         A docstring describing the unit.\n2182 \n2183     format : dict, optional\n2184         A mapping to format-specific representations of this unit.\n2185         For example, for the ``Ohm`` unit, it might be nice to have it\n2186         displayed as ``\\\\Omega`` by the ``latex`` formatter.  In that\n2187         case, `format` argument should be set to::\n2188 \n2189             {'latex': r'\\\\Omega'}\n2190 \n2191     namespace : dict, optional\n2192         When provided, inject the unit (and all of its aliases) into\n2193         the given namespace.\n2194 \n2195     Raises\n2196     ------\n2197     ValueError\n2198         If any of the given unit names are already in the registry.\n2199 \n2200     ValueError\n2201         If any of the given unit names are not valid Python tokens.\n2202     \"\"\"\n2203 \n2204     def __init__(self, st, represents=None, doc=None, format=None, namespace=None):\n2205         represents = Unit(represents)\n2206         self._represents = represents\n2207 \n2208         NamedUnit.__init__(self, st, namespace=namespace, doc=doc, format=format)\n2209 \n2210     @property\n2211     def represents(self):\n2212         \"\"\"The unit that this named unit represents.\"\"\"\n2213         return self._represents\n2214 \n2215     def decompose(self, bases=set()):\n2216         return self._represents.decompose(bases=bases)\n2217 \n2218     def is_unity(self):\n2219         return self._represents.is_unity()\n2220 \n2221     def __hash__(self):\n2222         if self._hash is None:\n2223             self._hash = hash((self.name, self._represents))\n2224         return self._hash\n2225 \n2226     @classmethod\n2227     def _from_physical_type_id(cls, physical_type_id):\n2228         # get string bases and powers from the ID tuple\n2229         bases = [cls(base) for base, _ in physical_type_id]\n2230         powers = [power for _, power in physical_type_id]\n2231 \n2232         if len(physical_type_id) == 1 and powers[0] == 1:\n2233             unit = bases[0]\n2234         else:\n2235             unit = CompositeUnit(1, bases, powers, _error_check=False)\n2236 \n2237         return unit\n2238 \n2239 \n2240 class PrefixUnit(Unit):\n2241     \"\"\"\n2242     A unit that is simply a SI-prefixed version of another unit.\n2243 \n2244     For example, ``mm`` is a `PrefixUnit` of ``.001 * m``.\n2245 \n2246     The constructor is the same as for `Unit`.\n2247     \"\"\"\n2248 \n2249 \n2250 class CompositeUnit(UnitBase):\n2251     \"\"\"\n2252     Create a composite unit using expressions of previously defined\n2253     units.\n2254 \n2255     Direct use of this class is not recommended. Instead use the\n2256     factory function `Unit` and arithmetic operators to compose\n2257     units.\n2258 \n2259     Parameters\n2260     ----------\n2261     scale : number\n2262         A scaling factor for the unit.\n2263 \n2264     bases : sequence of `UnitBase`\n2265         A sequence of units this unit is composed of.\n2266 \n2267     powers : sequence of numbers\n2268         A sequence of powers (in parallel with ``bases``) for each\n2269         of the base units.\n2270     \"\"\"\n2271 \n2272     _decomposed_cache = None\n2273 \n2274     def __init__(\n2275         self,\n2276         scale,\n2277         bases,\n2278         powers,\n2279         decompose=False,\n2280         decompose_bases=set(),\n2281         _error_check=True,\n2282     ):\n2283         # There are many cases internal to astropy.units where we\n2284         # already know that all the bases are Unit objects, and the\n2285         # powers have been validated.  In those cases, we can skip the\n2286         # error checking for performance reasons.  When the private\n2287         # kwarg `_error_check` is False, the error checking is turned\n2288         # off.\n2289         if _error_check:\n2290             for base in bases:\n2291                 if not isinstance(base, UnitBase):\n2292                     raise TypeError(\"bases must be sequence of UnitBase instances\")\n2293             powers = [validate_power(p) for p in powers]\n2294 \n2295         if not decompose and len(bases) == 1 and powers[0] >= 0:\n2296             # Short-cut; with one unit there's nothing to expand and gather,\n2297             # as that has happened already when creating the unit.  But do only\n2298             # positive powers, since for negative powers we need to re-sort.\n2299             unit = bases[0]\n2300             power = powers[0]\n2301             if power == 1:\n2302                 scale *= unit.scale\n2303                 self._bases = unit.bases\n2304                 self._powers = unit.powers\n2305             elif power == 0:\n2306                 self._bases = []\n2307                 self._powers = []\n2308             else:\n2309                 scale *= unit.scale**power\n2310                 self._bases = unit.bases\n2311                 self._powers = [\n2312                     operator.mul(*resolve_fractions(p, power)) for p in unit.powers\n2313                 ]\n2314 \n2315             self._scale = sanitize_scale(scale)\n2316         else:\n2317             # Regular case: use inputs as preliminary scale, bases, and powers,\n2318             # then \"expand and gather\" identical bases, sanitize the scale, &c.\n2319             self._scale = scale\n2320             self._bases = bases\n2321             self._powers = powers\n2322             self._expand_and_gather(decompose=decompose, bases=decompose_bases)\n2323 \n2324     def __repr__(self):\n2325         if len(self._bases):\n2326             return super().__repr__()\n2327         else:\n2328             if self._scale != 1.0:\n2329                 return f\"Unit(dimensionless with a scale of {self._scale})\"\n2330             else:\n2331                 return \"Unit(dimensionless)\"\n2332 \n2333     @property\n2334     def scale(self):\n2335         \"\"\"\n2336         Return the scale of the composite unit.\n2337         \"\"\"\n2338         return self._scale\n2339 \n2340     @property\n2341     def bases(self):\n2342         \"\"\"\n2343         Return the bases of the composite unit.\n2344         \"\"\"\n2345         return self._bases\n2346 \n2347     @property\n2348     def powers(self):\n2349         \"\"\"\n2350         Return the powers of the composite unit.\n2351         \"\"\"\n2352         return self._powers\n2353 \n2354     def _expand_and_gather(self, decompose=False, bases=set()):\n2355         def add_unit(unit, power, scale):\n2356             if bases and unit not in bases:\n2357                 for base in bases:\n2358                     try:\n2359                         scale *= unit._to(base) ** power\n2360                     except UnitsError:\n2361                         pass\n2362                     else:\n2363                         unit = base\n2364                         break\n2365 \n2366             if unit in new_parts:\n2367                 a, b = resolve_fractions(new_parts[unit], power)\n2368                 new_parts[unit] = a + b\n2369             else:\n2370                 new_parts[unit] = power\n2371             return scale\n2372 \n2373         new_parts = {}\n2374         scale = self._scale\n2375 \n2376         for b, p in zip(self._bases, self._powers):\n2377             if decompose and b not in bases:\n2378                 b = b.decompose(bases=bases)\n2379 \n2380             if isinstance(b, CompositeUnit):\n2381                 scale *= b._scale**p\n2382                 for b_sub, p_sub in zip(b._bases, b._powers):\n2383                     a, b = resolve_fractions(p_sub, p)\n2384                     scale = add_unit(b_sub, a * b, scale)\n2385             else:\n2386                 scale = add_unit(b, p, scale)\n2387 \n2388         new_parts = [x for x in new_parts.items() if x[1] != 0]\n2389         new_parts.sort(key=lambda x: (-x[1], getattr(x[0], \"name\", \"\")))\n2390 \n2391         self._bases = [x[0] for x in new_parts]\n2392         self._powers = [x[1] for x in new_parts]\n2393         self._scale = sanitize_scale(scale)\n2394 \n2395     def __copy__(self):\n2396         \"\"\"\n2397         For compatibility with python copy module.\n2398         \"\"\"\n2399         return CompositeUnit(self._scale, self._bases[:], self._powers[:])\n2400 \n2401     def decompose(self, bases=set()):\n2402         if len(bases) == 0 and self._decomposed_cache is not None:\n2403             return self._decomposed_cache\n2404 \n2405         for base in self.bases:\n2406             if not isinstance(base, IrreducibleUnit) or (\n2407                 len(bases) and base not in bases\n2408             ):\n2409                 break\n2410         else:\n2411             if len(bases) == 0:\n2412                 self._decomposed_cache = self\n2413             return self\n2414 \n2415         x = CompositeUnit(\n2416             self.scale, self.bases, self.powers, decompose=True, decompose_bases=bases\n2417         )\n2418         if len(bases) == 0:\n2419             self._decomposed_cache = x\n2420         return x\n2421 \n2422     def is_unity(self):\n2423         unit = self.decompose()\n2424         return len(unit.bases) == 0 and unit.scale == 1.0\n2425 \n2426 \n2427 si_prefixes = [\n2428     ([\"Q\"], [\"quetta\"], 1e30),\n2429     ([\"R\"], [\"ronna\"], 1e27),\n2430     ([\"Y\"], [\"yotta\"], 1e24),\n2431     ([\"Z\"], [\"zetta\"], 1e21),\n2432     ([\"E\"], [\"exa\"], 1e18),\n2433     ([\"P\"], [\"peta\"], 1e15),\n2434     ([\"T\"], [\"tera\"], 1e12),\n2435     ([\"G\"], [\"giga\"], 1e9),\n2436     ([\"M\"], [\"mega\"], 1e6),\n2437     ([\"k\"], [\"kilo\"], 1e3),\n2438     ([\"h\"], [\"hecto\"], 1e2),\n2439     ([\"da\"], [\"deka\", \"deca\"], 1e1),\n2440     ([\"d\"], [\"deci\"], 1e-1),\n2441     ([\"c\"], [\"centi\"], 1e-2),\n2442     ([\"m\"], [\"milli\"], 1e-3),\n2443     ([\"u\"], [\"micro\"], 1e-6),\n2444     ([\"n\"], [\"nano\"], 1e-9),\n2445     ([\"p\"], [\"pico\"], 1e-12),\n2446     ([\"f\"], [\"femto\"], 1e-15),\n2447     ([\"a\"], [\"atto\"], 1e-18),\n2448     ([\"z\"], [\"zepto\"], 1e-21),\n2449     ([\"y\"], [\"yocto\"], 1e-24),\n2450     ([\"r\"], [\"ronto\"], 1e-27),\n2451     ([\"q\"], [\"quecto\"], 1e-30),\n2452 ]\n2453 \n2454 \n2455 binary_prefixes = [\n2456     ([\"Ki\"], [\"kibi\"], 2**10),\n2457     ([\"Mi\"], [\"mebi\"], 2**20),\n2458     ([\"Gi\"], [\"gibi\"], 2**30),\n2459     ([\"Ti\"], [\"tebi\"], 2**40),\n2460     ([\"Pi\"], [\"pebi\"], 2**50),\n2461     ([\"Ei\"], [\"exbi\"], 2**60),\n2462 ]\n2463 \n2464 \n2465 def _add_prefixes(u, excludes=[], namespace=None, prefixes=False):\n2466     \"\"\"\n2467     Set up all of the standard metric prefixes for a unit.  This\n2468     function should not be used directly, but instead use the\n2469     `prefixes` kwarg on `def_unit`.\n2470 \n2471     Parameters\n2472     ----------\n2473     excludes : list of str, optional\n2474         Any prefixes to exclude from creation to avoid namespace\n2475         collisions.\n2476 \n2477     namespace : dict, optional\n2478         When provided, inject the unit (and all of its aliases) into\n2479         the given namespace dictionary.\n2480 \n2481     prefixes : list, optional\n2482         When provided, it is a list of prefix definitions of the form:\n2483 \n2484             (short_names, long_tables, factor)\n2485     \"\"\"\n2486     if prefixes is True:\n2487         prefixes = si_prefixes\n2488     elif prefixes is False:\n2489         prefixes = []\n2490 \n2491     for short, full, factor in prefixes:\n2492         names = []\n2493         format = {}\n2494         for prefix in short:\n2495             if prefix in excludes:\n2496                 continue\n2497 \n2498             for alias in u.short_names:\n2499                 names.append(prefix + alias)\n2500 \n2501                 # This is a hack to use Greek mu as a prefix\n2502                 # for some formatters.\n2503                 if prefix == \"u\":\n2504                     format[\"latex\"] = r\"\\mu \" + u.get_format_name(\"latex\")\n2505                     format[\"unicode\"] = \"\\N{MICRO SIGN}\" + u.get_format_name(\"unicode\")\n2506 \n2507                 for key, val in u._format.items():\n2508                     format.setdefault(key, prefix + val)\n2509 \n2510         for prefix in full:\n2511             if prefix in excludes:\n2512                 continue\n2513 \n2514             for alias in u.long_names:\n2515                 names.append(prefix + alias)\n2516 \n2517         if len(names):\n2518             PrefixUnit(\n2519                 names,\n2520                 CompositeUnit(factor, [u], [1], _error_check=False),\n2521                 namespace=namespace,\n2522                 format=format,\n2523             )\n2524 \n2525 \n2526 def def_unit(\n2527     s,\n2528     represents=None,\n2529     doc=None,\n2530     format=None,\n2531     prefixes=False,\n2532     exclude_prefixes=[],\n2533     namespace=None,\n2534 ):\n2535     \"\"\"\n2536     Factory function for defining new units.\n2537 \n2538     Parameters\n2539     ----------\n2540     s : str or list of str\n2541         The name of the unit.  If a list, the first element is the\n2542         canonical (short) name, and the rest of the elements are\n2543         aliases.\n2544 \n2545     represents : UnitBase instance, optional\n2546         The unit that this named unit represents.  If not provided,\n2547         a new `IrreducibleUnit` is created.\n2548 \n2549     doc : str, optional\n2550         A docstring describing the unit.\n2551 \n2552     format : dict, optional\n2553         A mapping to format-specific representations of this unit.\n2554         For example, for the ``Ohm`` unit, it might be nice to\n2555         have it displayed as ``\\\\Omega`` by the ``latex``\n2556         formatter.  In that case, `format` argument should be set\n2557         to::\n2558 \n2559             {'latex': r'\\\\Omega'}\n2560 \n2561     prefixes : bool or list, optional\n2562         When `True`, generate all of the SI prefixed versions of the\n2563         unit as well.  For example, for a given unit ``m``, will\n2564         generate ``mm``, ``cm``, ``km``, etc.  When a list, it is a list of\n2565         prefix definitions of the form:\n2566 \n2567             (short_names, long_tables, factor)\n2568 \n2569         Default is `False`.  This function always returns the base\n2570         unit object, even if multiple scaled versions of the unit were\n2571         created.\n2572 \n2573     exclude_prefixes : list of str, optional\n2574         If any of the SI prefixes need to be excluded, they may be\n2575         listed here.  For example, ``Pa`` can be interpreted either as\n2576         \"petaannum\" or \"Pascal\".  Therefore, when defining the\n2577         prefixes for ``a``, ``exclude_prefixes`` should be set to\n2578         ``[\"P\"]``.\n2579 \n2580     namespace : dict, optional\n2581         When provided, inject the unit (and all of its aliases and\n2582         prefixes), into the given namespace dictionary.\n2583 \n2584     Returns\n2585     -------\n2586     unit : `~astropy.units.UnitBase`\n2587         The newly-defined unit, or a matching unit that was already\n2588         defined.\n2589     \"\"\"\n2590     if represents is not None:\n2591         result = Unit(s, represents, namespace=namespace, doc=doc, format=format)\n2592     else:\n2593         result = IrreducibleUnit(s, namespace=namespace, doc=doc, format=format)\n2594 \n2595     if prefixes:\n2596         _add_prefixes(\n2597             result, excludes=exclude_prefixes, namespace=namespace, prefixes=prefixes\n2598         )\n2599     return result\n2600 \n2601 \n2602 def _condition_arg(value):\n2603     \"\"\"\n2604     Validate value is acceptable for conversion purposes.\n2605 \n2606     Will convert into an array if not a scalar, and can be converted\n2607     into an array\n2608 \n2609     Parameters\n2610     ----------\n2611     value : int or float value, or sequence of such values\n2612 \n2613     Returns\n2614     -------\n2615     Scalar value or numpy array\n2616 \n2617     Raises\n2618     ------\n2619     ValueError\n2620         If value is not as expected\n2621     \"\"\"\n2622     if isinstance(value, (np.ndarray, float, int, complex, np.void)):\n2623         return value\n2624 \n2625     avalue = np.array(value)\n2626     if avalue.dtype.kind not in [\"i\", \"f\", \"c\"]:\n2627         raise ValueError(\n2628             \"Value not scalar compatible or convertible to \"\n2629             \"an int, float, or complex array\"\n2630         )\n2631     return avalue\n2632 \n2633 \n2634 def unit_scale_converter(val):\n2635     \"\"\"Function that just multiplies the value by unity.\n2636 \n2637     This is a separate function so it can be recognized and\n2638     discarded in unit conversion.\n2639     \"\"\"\n2640     return 1.0 * _condition_arg(val)\n2641 \n2642 \n2643 dimensionless_unscaled = CompositeUnit(1, [], [], _error_check=False)\n2644 # Abbreviation of the above, see #1980\n2645 one = dimensionless_unscaled\n2646 \n2647 # Maintain error in old location for backward compatibility\n2648 # TODO: Is this still needed? Should there be a deprecation warning?\n2649 unit_format.fits.UnitScaleError = UnitScaleError\n",
        "intended_behavior": "The `to_string` method or its variants that are responsible for formatting units in different styles should be adjusted to ensure that there is no extraneous space at the beginning of the string representation for any unit, regardless of the formatting style (including `unicode` and `console`). This might involve checking and possibly modifying the conditions or logic that prepends spaces based on unit scale factors or the presence of certain unit components. Any modification should preserve the method's existing functionality to accurately represent units in their requested format, adjusting only for the leading space inconsistency."
    },
    {
        "rel_file_path": "astropy/units/format/console.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/astropy__astropy/setup_astropy__astropy__5.1/astropy/units/format/console.py",
        "start": 1,
        "end": 102,
        "class_name": null,
        "method_name": null,
        "code": "1 # Licensed under a 3-clause BSD style license - see LICENSE.rst\n2 \n3 \"\"\"\n4 Handles the \"Console\" unit format.\n5 \"\"\"\n6 \n7 \n8 from . import base, core, utils\n9 \n10 \n11 class Console(base.Base):\n12     \"\"\"\n13     Output-only format for to display pretty formatting at the\n14     console.\n15 \n16     For example::\n17 \n18       >>> import astropy.units as u\n19       >>> print(u.Ry.decompose().to_string('console'))  # doctest: +FLOAT_CMP\n20       2.1798721*10^-18m^2 kg s^-2\n21       >>> print(u.Ry.decompose().to_string('console', inline=False))  # doctest: +FLOAT_CMP\n22                        m^2 kg\n23       2.1798721*10^-18 ------\n24                         s^2\n25     \"\"\"\n26 \n27     _times = \"*\"\n28     _line = \"-\"\n29 \n30     @classmethod\n31     def _get_unit_name(cls, unit):\n32         return unit.get_format_name(\"console\")\n33 \n34     @classmethod\n35     def _format_superscript(cls, number):\n36         return f\"^{number}\"\n37 \n38     @classmethod\n39     def _format_unit_list(cls, units):\n40         out = []\n41         for base_, power in units:\n42             if power == 1:\n43                 out.append(cls._get_unit_name(base_))\n44             else:\n45                 out.append(\n46                     cls._get_unit_name(base_)\n47                     + cls._format_superscript(utils.format_power(power))\n48                 )\n49         return \" \".join(out)\n50 \n51     @classmethod\n52     def format_exponential_notation(cls, val):\n53         m, ex = utils.split_mantissa_exponent(val)\n54 \n55         parts = []\n56         if m:\n57             parts.append(m)\n58 \n59         if ex:\n60             parts.append(f\"10{cls._format_superscript(ex)}\")\n61 \n62         return cls._times.join(parts)\n63 \n64     @classmethod\n65     def to_string(cls, unit, inline=True):\n66         if isinstance(unit, core.CompositeUnit):\n67             if unit.scale == 1:\n68                 s = \"\"\n69             else:\n70                 s = cls.format_exponential_notation(unit.scale)\n71 \n72             if len(unit.bases):\n73                 if inline:\n74                     nominator = zip(unit.bases, unit.powers)\n75                     denominator = []\n76                 else:\n77                     nominator, denominator = utils.get_grouped_by_powers(\n78                         unit.bases, unit.powers\n79                     )\n80                 if len(denominator):\n81                     if len(nominator):\n82                         nominator = cls._format_unit_list(nominator)\n83                     else:\n84                         nominator = \"1\"\n85                     denominator = cls._format_unit_list(denominator)\n86                     fraclength = max(len(nominator), len(denominator))\n87                     f = f\"{{0:^{len(s)}s}} {{1:^{fraclength}s}}\"\n88 \n89                     lines = [\n90                         f.format(\"\", nominator),\n91                         f.format(s, cls._line * fraclength),\n92                         f.format(\"\", denominator),\n93                     ]\n94 \n95                     s = \"\\n\".join(lines)\n96                 else:\n97                     nominator = cls._format_unit_list(nominator)\n98                     s += nominator\n99         elif isinstance(unit, core.NamedUnit):\n100             s = cls._get_unit_name(unit)\n101 \n102         return s\n",
        "intended_behavior": "These methods should be verified and possibly corrected to ensure they do not introduce an unintended leading space in their output, especially under conditions where unit scale factors are present or absent. The logic handling the format-specific concatenations and space insertions needs careful inspection to eliminate the inconsistency. As with `core.py`, the aim would be to preserve the integrity and accuracy of the unit representation while aligning with the expected behavior of no leading spaces in all scenarios."
    }
]