[
    {
        "rel_file_path": "sphinx/domains/python.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__3.0/sphinx/domains/python.py",
        "start": 424,
        "end": 443,
        "class_name": "PyObject",
        "method_name": "add_target_and_index",
        "code": "424     def add_target_and_index(self, name_cls: Tuple[str, str], sig: str,\n425                              signode: desc_signature) -> None:\n426         modname = self.options.get('module', self.env.ref_context.get('py:module'))\n427         fullname = (modname + '.' if modname else '') + name_cls[0]\n428         node_id = make_id(self.env, self.state.document, '', fullname)\n429         signode['ids'].append(node_id)\n430 \n431         # Assign old styled node_id(fullname) not to break old hyperlinks (if possible)\n432         # Note: Will removed in Sphinx-5.0  (RemovedInSphinx50Warning)\n433         if node_id != fullname and fullname not in self.state.document.ids:\n434             signode['ids'].append(fullname)\n435 \n436         self.state.document.note_explicit_target(signode)\n437 \n438         domain = cast(PythonDomain, self.env.get_domain('py'))\n439         domain.note_object(fullname, self.objtype, node_id, location=signode)\n440 \n441         indextext = self.get_index_text(modname, name_cls)\n442         if indextext:\n443             self.indexnode['entries'].append(('single', indextext, node_id, '', None))\n",
        "intended_behavior": "This method should provide a way to optionally preserve underscores in generated IDs for compatibility with existing links or documentation practices. This could involve an additional configuration option that controls whether the generated node_id (and thus, the fragment identifier) retains underscores or converts them to dashes. The method must continue to ensure that node_ids are unique and follow best practices for URL-safe characters, keeping in line with web standards."
    },
    {
        "rel_file_path": "sphinx/domains/python.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__3.0/sphinx/domains/python.py",
        "start": 290,
        "end": 501,
        "class_name": "PyObject",
        "method_name": null,
        "code": "290 class PyObject(ObjectDescription):\n291     \"\"\"\n292     Description of a general Python object.\n293 \n294     :cvar allow_nesting: Class is an object that allows for nested namespaces\n295     :vartype allow_nesting: bool\n296     \"\"\"\n297     option_spec = {\n298         'noindex': directives.flag,\n299         'module': directives.unchanged,\n300         'annotation': directives.unchanged,\n301     }\n302 \n303     doc_field_types = [\n304         PyTypedField('parameter', label=_('Parameters'),\n305                      names=('param', 'parameter', 'arg', 'argument',\n306                             'keyword', 'kwarg', 'kwparam'),\n307                      typerolename='class', typenames=('paramtype', 'type'),\n308                      can_collapse=True),\n309         PyTypedField('variable', label=_('Variables'), rolename='obj',\n310                      names=('var', 'ivar', 'cvar'),\n311                      typerolename='class', typenames=('vartype',),\n312                      can_collapse=True),\n313         PyGroupedField('exceptions', label=_('Raises'), rolename='exc',\n314                        names=('raises', 'raise', 'exception', 'except'),\n315                        can_collapse=True),\n316         Field('returnvalue', label=_('Returns'), has_arg=False,\n317               names=('returns', 'return')),\n318         PyField('returntype', label=_('Return type'), has_arg=False,\n319                 names=('rtype',), bodyrolename='class'),\n320     ]\n321 \n322     allow_nesting = False\n323 \n324     def get_signature_prefix(self, sig: str) -> str:\n325         \"\"\"May return a prefix to put before the object name in the\n326         signature.\n327         \"\"\"\n328         return ''\n329 \n330     def needs_arglist(self) -> bool:\n331         \"\"\"May return true if an empty argument list is to be generated even if\n332         the document contains none.\n333         \"\"\"\n334         return False\n335 \n336     def handle_signature(self, sig: str, signode: desc_signature) -> Tuple[str, str]:\n337         \"\"\"Transform a Python signature into RST nodes.\n338 \n339         Return (fully qualified name of the thing, classname if any).\n340 \n341         If inside a class, the current class name is handled intelligently:\n342         * it is stripped from the displayed name if present\n343         * it is added to the full name (return value) if not present\n344         \"\"\"\n345         m = py_sig_re.match(sig)\n346         if m is None:\n347             raise ValueError\n348         prefix, name, arglist, retann = m.groups()\n349 \n350         # determine module and class name (if applicable), as well as full name\n351         modname = self.options.get('module', self.env.ref_context.get('py:module'))\n352         classname = self.env.ref_context.get('py:class')\n353         if classname:\n354             add_module = False\n355             if prefix and (prefix == classname or\n356                            prefix.startswith(classname + \".\")):\n357                 fullname = prefix + name\n358                 # class name is given again in the signature\n359                 prefix = prefix[len(classname):].lstrip('.')\n360             elif prefix:\n361                 # class name is given in the signature, but different\n362                 # (shouldn't happen)\n363                 fullname = classname + '.' + prefix + name\n364             else:\n365                 # class name is not given in the signature\n366                 fullname = classname + '.' + name\n367         else:\n368             add_module = True\n369             if prefix:\n370                 classname = prefix.rstrip('.')\n371                 fullname = prefix + name\n372             else:\n373                 classname = ''\n374                 fullname = name\n375 \n376         signode['module'] = modname\n377         signode['class'] = classname\n378         signode['fullname'] = fullname\n379 \n380         sig_prefix = self.get_signature_prefix(sig)\n381         if sig_prefix:\n382             signode += addnodes.desc_annotation(sig_prefix, sig_prefix)\n383 \n384         if prefix:\n385             signode += addnodes.desc_addname(prefix, prefix)\n386         elif add_module and self.env.config.add_module_names:\n387             if modname and modname != 'exceptions':\n388                 # exceptions are a special case, since they are documented in the\n389                 # 'exceptions' module.\n390                 nodetext = modname + '.'\n391                 signode += addnodes.desc_addname(nodetext, nodetext)\n392 \n393         signode += addnodes.desc_name(name, name)\n394         if arglist:\n395             try:\n396                 signode += _parse_arglist(arglist)\n397             except SyntaxError:\n398                 # fallback to parse arglist original parser.\n399                 # it supports to represent optional arguments (ex. \"func(foo [, bar])\")\n400                 _pseudo_parse_arglist(signode, arglist)\n401             except NotImplementedError as exc:\n402                 logger.warning(\"could not parse arglist (%r): %s\", arglist, exc,\n403                                location=signode)\n404                 _pseudo_parse_arglist(signode, arglist)\n405         else:\n406             if self.needs_arglist():\n407                 # for callables, add an empty parameter list\n408                 signode += addnodes.desc_parameterlist()\n409 \n410         if retann:\n411             children = _parse_annotation(retann)\n412             signode += addnodes.desc_returns(retann, '', *children)\n413 \n414         anno = self.options.get('annotation')\n415         if anno:\n416             signode += addnodes.desc_annotation(' ' + anno, ' ' + anno)\n417 \n418         return fullname, prefix\n419 \n420     def get_index_text(self, modname: str, name: Tuple[str, str]) -> str:\n421         \"\"\"Return the text for the index entry of the object.\"\"\"\n422         raise NotImplementedError('must be implemented in subclasses')\n423 \n424     def add_target_and_index(self, name_cls: Tuple[str, str], sig: str,\n425                              signode: desc_signature) -> None:\n426         modname = self.options.get('module', self.env.ref_context.get('py:module'))\n427         fullname = (modname + '.' if modname else '') + name_cls[0]\n428         node_id = make_id(self.env, self.state.document, '', fullname)\n429         signode['ids'].append(node_id)\n430 \n431         # Assign old styled node_id(fullname) not to break old hyperlinks (if possible)\n432         # Note: Will removed in Sphinx-5.0  (RemovedInSphinx50Warning)\n433         if node_id != fullname and fullname not in self.state.document.ids:\n434             signode['ids'].append(fullname)\n435 \n436         self.state.document.note_explicit_target(signode)\n437 \n438         domain = cast(PythonDomain, self.env.get_domain('py'))\n439         domain.note_object(fullname, self.objtype, node_id, location=signode)\n440 \n441         indextext = self.get_index_text(modname, name_cls)\n442         if indextext:\n443             self.indexnode['entries'].append(('single', indextext, node_id, '', None))\n444 \n445     def before_content(self) -> None:\n446         \"\"\"Handle object nesting before content\n447 \n448         :py:class:`PyObject` represents Python language constructs. For\n449         constructs that are nestable, such as a Python classes, this method will\n450         build up a stack of the nesting heirarchy so that it can be later\n451         de-nested correctly, in :py:meth:`after_content`.\n452 \n453         For constructs that aren't nestable, the stack is bypassed, and instead\n454         only the most recent object is tracked. This object prefix name will be\n455         removed with :py:meth:`after_content`.\n456         \"\"\"\n457         prefix = None\n458         if self.names:\n459             # fullname and name_prefix come from the `handle_signature` method.\n460             # fullname represents the full object name that is constructed using\n461             # object nesting and explicit prefixes. `name_prefix` is the\n462             # explicit prefix given in a signature\n463             (fullname, name_prefix) = self.names[-1]\n464             if self.allow_nesting:\n465                 prefix = fullname\n466             elif name_prefix:\n467                 prefix = name_prefix.strip('.')\n468         if prefix:\n469             self.env.ref_context['py:class'] = prefix\n470             if self.allow_nesting:\n471                 classes = self.env.ref_context.setdefault('py:classes', [])\n472                 classes.append(prefix)\n473         if 'module' in self.options:\n474             modules = self.env.ref_context.setdefault('py:modules', [])\n475             modules.append(self.env.ref_context.get('py:module'))\n476             self.env.ref_context['py:module'] = self.options['module']\n477 \n478     def after_content(self) -> None:\n479         \"\"\"Handle object de-nesting after content\n480 \n481         If this class is a nestable object, removing the last nested class prefix\n482         ends further nesting in the object.\n483 \n484         If this class is not a nestable object, the list of classes should not\n485         be altered as we didn't affect the nesting levels in\n486         :py:meth:`before_content`.\n487         \"\"\"\n488         classes = self.env.ref_context.setdefault('py:classes', [])\n489         if self.allow_nesting:\n490             try:\n491                 classes.pop()\n492             except IndexError:\n493                 pass\n494         self.env.ref_context['py:class'] = (classes[-1] if len(classes) > 0\n495                                             else None)\n496         if 'module' in self.options:\n497             modules = self.env.ref_context.setdefault('py:modules', [])\n498             if modules:\n499                 self.env.ref_context['py:module'] = modules.pop()\n500             else:\n501                 self.env.ref_context.pop('py:module')\n",
        "intended_behavior": "This class provides additional context to the issue."
    },
    {
        "rel_file_path": "sphinx/domains/python.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__3.0/sphinx/domains/python.py",
        "start": 554,
        "end": 566,
        "class_name": "PyFunction",
        "method_name": "add_target_and_index",
        "code": "554     def add_target_and_index(self, name_cls: Tuple[str, str], sig: str,\n555                              signode: desc_signature) -> None:\n556         super().add_target_and_index(name_cls, sig, signode)\n557         modname = self.options.get('module', self.env.ref_context.get('py:module'))\n558         node_id = signode['ids'][0]\n559 \n560         name, cls = name_cls\n561         if modname:\n562             text = _('%s() (in module %s)') % (name, modname)\n563             self.indexnode['entries'].append(('single', text, node_id, '', None))\n564         else:\n565             text = '%s; %s()' % (pairindextypes['builtin'], name)\n566             self.indexnode['entries'].append(('pair', text, node_id, '', None))\n",
        "intended_behavior": "Similar to PyObject's add_target_and_index, for consistency across Python domain objects, this method also needs to support configurable handling of underscores in IDs. The same configuration option used in PyObject could apply here, allowing project-wide control over identifier formatting. This adjustment ensures that function links, which are frequently targeted in external documentation and tutorials, remain stable and predictable after upgrading Sphinx or modifying documentation sources."
    },
    {
        "rel_file_path": "sphinx/domains/python.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__3.0/sphinx/domains/python.py",
        "start": 537,
        "end": 570,
        "class_name": "PyFunction",
        "method_name": null,
        "code": "537 class PyFunction(PyObject):\n538     \"\"\"Description of a function.\"\"\"\n539 \n540     option_spec = PyObject.option_spec.copy()\n541     option_spec.update({\n542         'async': directives.flag,\n543     })\n544 \n545     def get_signature_prefix(self, sig: str) -> str:\n546         if 'async' in self.options:\n547             return 'async '\n548         else:\n549             return ''\n550 \n551     def needs_arglist(self) -> bool:\n552         return True\n553 \n554     def add_target_and_index(self, name_cls: Tuple[str, str], sig: str,\n555                              signode: desc_signature) -> None:\n556         super().add_target_and_index(name_cls, sig, signode)\n557         modname = self.options.get('module', self.env.ref_context.get('py:module'))\n558         node_id = signode['ids'][0]\n559 \n560         name, cls = name_cls\n561         if modname:\n562             text = _('%s() (in module %s)') % (name, modname)\n563             self.indexnode['entries'].append(('single', text, node_id, '', None))\n564         else:\n565             text = '%s; %s()' % (pairindextypes['builtin'], name)\n566             self.indexnode['entries'].append(('pair', text, node_id, '', None))\n567 \n568     def get_index_text(self, modname: str, name_cls: Tuple[str, str]) -> str:\n569         # add index in own add_target_and_index() instead.\n570         return None\n",
        "intended_behavior": "This class provides additional context to the issue."
    }
]