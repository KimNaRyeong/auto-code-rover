[
    {
        "rel_file_path": "sphinx/directives/__init__.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__3.5/sphinx/directives/__init__.py",
        "start": 1,
        "end": 340,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2     sphinx.directives\n3     ~~~~~~~~~~~~~~~~~\n4 \n5     Handlers for additional ReST directives.\n6 \n7     :copyright: Copyright 2007-2021 by the Sphinx team, see AUTHORS.\n8     :license: BSD, see LICENSE for details.\n9 \"\"\"\n10 \n11 import re\n12 from typing import Any, Dict, Generic, List, Tuple, TypeVar, cast\n13 \n14 from docutils import nodes\n15 from docutils.nodes import Node\n16 from docutils.parsers.rst import directives, roles\n17 \n18 from sphinx import addnodes\n19 from sphinx.addnodes import desc_signature\n20 from sphinx.deprecation import (RemovedInSphinx40Warning, RemovedInSphinx50Warning,\n21                                 deprecated_alias)\n22 from sphinx.util import docutils\n23 from sphinx.util.docfields import DocFieldTransformer, Field, TypedField\n24 from sphinx.util.docutils import SphinxDirective\n25 from sphinx.util.typing import DirectiveOption\n26 \n27 if False:\n28     # For type annotation\n29     from sphinx.application import Sphinx\n30 \n31 \n32 # RE to strip backslash escapes\n33 nl_escape_re = re.compile(r'\\\\\\n')\n34 strip_backslash_re = re.compile(r'\\\\(.)')\n35 \n36 T = TypeVar('T')\n37 \n38 \n39 def optional_int(argument: str) -> int:\n40     \"\"\"\n41     Check for an integer argument or None value; raise ``ValueError`` if not.\n42     \"\"\"\n43     if argument is None:\n44         return None\n45     else:\n46         value = int(argument)\n47         if value < 0:\n48             raise ValueError('negative value; must be positive or zero')\n49         return value\n50 \n51 \n52 class ObjectDescription(SphinxDirective, Generic[T]):\n53     \"\"\"\n54     Directive to describe a class, function or similar object.  Not used\n55     directly, but subclassed (in domain-specific directives) to add custom\n56     behavior.\n57     \"\"\"\n58 \n59     has_content = True\n60     required_arguments = 1\n61     optional_arguments = 0\n62     final_argument_whitespace = True\n63     option_spec = {\n64         'noindex': directives.flag,\n65     }  # type: Dict[str, DirectiveOption]\n66 \n67     # types of doc fields that this directive handles, see sphinx.util.docfields\n68     doc_field_types = []    # type: List[Field]\n69     domain = None           # type: str\n70     objtype = None          # type: str\n71     indexnode = None        # type: addnodes.index\n72 \n73     # Warning: this might be removed in future version. Don't touch this from extensions.\n74     _doc_field_type_map = {}  # type: Dict[str, Tuple[Field, bool]]\n75 \n76     def get_field_type_map(self) -> Dict[str, Tuple[Field, bool]]:\n77         if self._doc_field_type_map == {}:\n78             self._doc_field_type_map = {}\n79             for field in self.doc_field_types:\n80                 for name in field.names:\n81                     self._doc_field_type_map[name] = (field, False)\n82 \n83                 if field.is_typed:\n84                     typed_field = cast(TypedField, field)\n85                     for name in typed_field.typenames:\n86                         self._doc_field_type_map[name] = (field, True)\n87 \n88         return self._doc_field_type_map\n89 \n90     def get_signatures(self) -> List[str]:\n91         \"\"\"\n92         Retrieve the signatures to document from the directive arguments.  By\n93         default, signatures are given as arguments, one per line.\n94         \"\"\"\n95         lines = nl_escape_re.sub('', self.arguments[0]).split('\\n')\n96         if self.config.strip_signature_backslash:\n97             # remove backslashes to support (dummy) escapes; helps Vim highlighting\n98             return [strip_backslash_re.sub(r'\\1', line.strip()) for line in lines]\n99         else:\n100             return [line.strip() for line in lines]\n101 \n102     def handle_signature(self, sig: str, signode: desc_signature) -> T:\n103         \"\"\"\n104         Parse the signature *sig* into individual nodes and append them to\n105         *signode*. If ValueError is raised, parsing is aborted and the whole\n106         *sig* is put into a single desc_name node.\n107 \n108         The return value should be a value that identifies the object.  It is\n109         passed to :meth:`add_target_and_index()` unchanged, and otherwise only\n110         used to skip duplicates.\n111         \"\"\"\n112         raise ValueError\n113 \n114     def add_target_and_index(self, name: T, sig: str, signode: desc_signature) -> None:\n115         \"\"\"\n116         Add cross-reference IDs and entries to self.indexnode, if applicable.\n117 \n118         *name* is whatever :meth:`handle_signature()` returned.\n119         \"\"\"\n120         return  # do nothing by default\n121 \n122     def before_content(self) -> None:\n123         \"\"\"\n124         Called before parsing content. Used to set information about the current\n125         directive context on the build environment.\n126         \"\"\"\n127         pass\n128 \n129     def transform_content(self, contentnode: addnodes.desc_content) -> None:\n130         \"\"\"\n131         Called after creating the content through nested parsing,\n132         but before the ``object-description-transform`` event is emitted,\n133         and before the info-fields are transformed.\n134         Can be used to manipulate the content.\n135         \"\"\"\n136         pass\n137 \n138     def after_content(self) -> None:\n139         \"\"\"\n140         Called after parsing content. Used to reset information about the\n141         current directive context on the build environment.\n142         \"\"\"\n143         pass\n144 \n145     def run(self) -> List[Node]:\n146         \"\"\"\n147         Main directive entry function, called by docutils upon encountering the\n148         directive.\n149 \n150         This directive is meant to be quite easily subclassable, so it delegates\n151         to several additional methods.  What it does:\n152 \n153         * find out if called as a domain-specific directive, set self.domain\n154         * create a `desc` node to fit all description inside\n155         * parse standard options, currently `noindex`\n156         * create an index node if needed as self.indexnode\n157         * parse all given signatures (as returned by self.get_signatures())\n158           using self.handle_signature(), which should either return a name\n159           or raise ValueError\n160         * add index entries using self.add_target_and_index()\n161         * parse the content and handle doc fields in it\n162         \"\"\"\n163         if ':' in self.name:\n164             self.domain, self.objtype = self.name.split(':', 1)\n165         else:\n166             self.domain, self.objtype = '', self.name\n167         self.indexnode = addnodes.index(entries=[])\n168 \n169         node = addnodes.desc()\n170         node.document = self.state.document\n171         node['domain'] = self.domain\n172         # 'desctype' is a backwards compatible attribute\n173         node['objtype'] = node['desctype'] = self.objtype\n174         node['noindex'] = noindex = ('noindex' in self.options)\n175         if self.domain:\n176             node['classes'].append(self.domain)\n177 \n178         self.names = []  # type: List[T]\n179         signatures = self.get_signatures()\n180         for i, sig in enumerate(signatures):\n181             # add a signature node for each signature in the current unit\n182             # and add a reference target for it\n183             signode = addnodes.desc_signature(sig, '')\n184             self.set_source_info(signode)\n185             node.append(signode)\n186             try:\n187                 # name can also be a tuple, e.g. (classname, objname);\n188                 # this is strictly domain-specific (i.e. no assumptions may\n189                 # be made in this base class)\n190                 name = self.handle_signature(sig, signode)\n191             except ValueError:\n192                 # signature parsing failed\n193                 signode.clear()\n194                 signode += addnodes.desc_name(sig, sig)\n195                 continue  # we don't want an index entry here\n196             if name not in self.names:\n197                 self.names.append(name)\n198                 if not noindex:\n199                     # only add target and index entry if this is the first\n200                     # description of the object with this name in this desc block\n201                     self.add_target_and_index(name, sig, signode)\n202 \n203         contentnode = addnodes.desc_content()\n204         node.append(contentnode)\n205         if self.names:\n206             # needed for association of version{added,changed} directives\n207             self.env.temp_data['object'] = self.names[0]\n208         self.before_content()\n209         self.state.nested_parse(self.content, self.content_offset, contentnode)\n210         self.transform_content(contentnode)\n211         self.env.app.emit('object-description-transform',\n212                           self.domain, self.objtype, contentnode)\n213         DocFieldTransformer(self).transform_all(contentnode)\n214         self.env.temp_data['object'] = None\n215         self.after_content()\n216         return [self.indexnode, node]\n217 \n218 \n219 class DefaultRole(SphinxDirective):\n220     \"\"\"\n221     Set the default interpreted text role.  Overridden from docutils.\n222     \"\"\"\n223 \n224     optional_arguments = 1\n225     final_argument_whitespace = False\n226 \n227     def run(self) -> List[Node]:\n228         if not self.arguments:\n229             docutils.unregister_role('')\n230             return []\n231         role_name = self.arguments[0]\n232         role, messages = roles.role(role_name, self.state_machine.language,\n233                                     self.lineno, self.state.reporter)\n234         if role:\n235             docutils.register_role('', role)\n236             self.env.temp_data['default_role'] = role_name\n237         else:\n238             literal_block = nodes.literal_block(self.block_text, self.block_text)\n239             reporter = self.state.reporter\n240             error = reporter.error('Unknown interpreted text role \"%s\".' % role_name,\n241                                    literal_block, line=self.lineno)\n242             messages += [error]\n243 \n244         return cast(List[nodes.Node], messages)\n245 \n246 \n247 class DefaultDomain(SphinxDirective):\n248     \"\"\"\n249     Directive to (re-)set the default domain for this source file.\n250     \"\"\"\n251 \n252     has_content = False\n253     required_arguments = 1\n254     optional_arguments = 0\n255     final_argument_whitespace = False\n256     option_spec = {}  # type: Dict\n257 \n258     def run(self) -> List[Node]:\n259         domain_name = self.arguments[0].lower()\n260         # if domain_name not in env.domains:\n261         #     # try searching by label\n262         #     for domain in env.domains.values():\n263         #         if domain.label.lower() == domain_name:\n264         #             domain_name = domain.name\n265         #             break\n266         self.env.temp_data['default_domain'] = self.env.domains.get(domain_name)\n267         return []\n268 \n269 from sphinx.directives.code import CodeBlock, Highlight, LiteralInclude  # noqa\n270 from sphinx.directives.other import (Acks, Author, Centered, Class, HList, Include,  # noqa\n271                                      Only, SeeAlso, TabularColumns, TocTree, VersionChange)\n272 from sphinx.directives.patches import Figure, Meta  # noqa\n273 from sphinx.domains.index import IndexDirective  # noqa\n274 \n275 deprecated_alias('sphinx.directives',\n276                  {\n277                      'Highlight': Highlight,\n278                      'CodeBlock': CodeBlock,\n279                      'LiteralInclude': LiteralInclude,\n280                      'TocTree': TocTree,\n281                      'Author': Author,\n282                      'Index': IndexDirective,\n283                      'VersionChange': VersionChange,\n284                      'SeeAlso': SeeAlso,\n285                      'TabularColumns': TabularColumns,\n286                      'Centered': Centered,\n287                      'Acks': Acks,\n288                      'HList': HList,\n289                      'Only': Only,\n290                      'Include': Include,\n291                      'Class': Class,\n292                      'Figure': Figure,\n293                      'Meta': Meta,\n294                  },\n295                  RemovedInSphinx40Warning,\n296                  {\n297                      'Highlight': 'sphinx.directives.code.Highlight',\n298                      'CodeBlock': 'sphinx.directives.code.CodeBlock',\n299                      'LiteralInclude': 'sphinx.directives.code.LiteralInclude',\n300                      'TocTree': 'sphinx.directives.other.TocTree',\n301                      'Author': 'sphinx.directives.other.Author',\n302                      'Index': 'sphinx.directives.other.IndexDirective',\n303                      'VersionChange': 'sphinx.directives.other.VersionChange',\n304                      'SeeAlso': 'sphinx.directives.other.SeeAlso',\n305                      'TabularColumns': 'sphinx.directives.other.TabularColumns',\n306                      'Centered': 'sphinx.directives.other.Centered',\n307                      'Acks': 'sphinx.directives.other.Acks',\n308                      'HList': 'sphinx.directives.other.HList',\n309                      'Only': 'sphinx.directives.other.Only',\n310                      'Include': 'sphinx.directives.other.Include',\n311                      'Class': 'sphinx.directives.other.Class',\n312                      'Figure': 'sphinx.directives.patches.Figure',\n313                      'Meta': 'sphinx.directives.patches.Meta',\n314                  })\n315 \n316 deprecated_alias('sphinx.directives',\n317                  {\n318                      'DescDirective': ObjectDescription,\n319                  },\n320                  RemovedInSphinx50Warning,\n321                  {\n322                      'DescDirective': 'sphinx.directives.ObjectDescription',\n323                  })\n324 \n325 \n326 def setup(app: \"Sphinx\") -> Dict[str, Any]:\n327     app.add_config_value(\"strip_signature_backslash\", False, 'env')\n328     directives.register_directive('default-role', DefaultRole)\n329     directives.register_directive('default-domain', DefaultDomain)\n330     directives.register_directive('describe', ObjectDescription)\n331     # new, more consistent, name\n332     directives.register_directive('object', ObjectDescription)\n333 \n334     app.add_event('object-description-transform')\n335 \n336     return {\n337         'version': 'builtin',\n338         'parallel_read_safe': True,\n339         'parallel_write_safe': True,\n340     }\n",
        "intended_behavior": "Whenever file paths for downloads or images are processed, the code should apply os.path.normpath() or an equivalent path normalization function to ensure all paths are canonicalized. This would prevent recognizing different relative or absolute notations of the same file path as distinct files."
    },
    {
        "rel_file_path": "sphinx/util/osutil.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__3.5/sphinx/util/osutil.py",
        "start": 1,
        "end": 258,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2     sphinx.util.osutil\n3     ~~~~~~~~~~~~~~~~~~\n4 \n5     Operating system-related utility functions for Sphinx.\n6 \n7     :copyright: Copyright 2007-2021 by the Sphinx team, see AUTHORS.\n8     :license: BSD, see LICENSE for details.\n9 \"\"\"\n10 \n11 import contextlib\n12 import errno\n13 import filecmp\n14 import os\n15 import re\n16 import shutil\n17 import sys\n18 import warnings\n19 from io import StringIO\n20 from os import path\n21 from typing import Any, Generator, Iterator, List, Optional, Tuple\n22 \n23 from sphinx.deprecation import RemovedInSphinx40Warning, RemovedInSphinx50Warning\n24 \n25 try:\n26     # for ALT Linux (#6712)\n27     from sphinx.testing.path import path as Path\n28 except ImportError:\n29     Path = None  # type: ignore\n30 \n31 if False:\n32     # For type annotation\n33     from typing import Type  # for python3.5.1\n34 \n35 # Errnos that we need.\n36 EEXIST = getattr(errno, 'EEXIST', 0)  # RemovedInSphinx40Warning\n37 ENOENT = getattr(errno, 'ENOENT', 0)  # RemovedInSphinx40Warning\n38 EPIPE = getattr(errno, 'EPIPE', 0)    # RemovedInSphinx40Warning\n39 EINVAL = getattr(errno, 'EINVAL', 0)  # RemovedInSphinx40Warning\n40 \n41 # SEP separates path elements in the canonical file names\n42 #\n43 # Define SEP as a manifest constant, not so much because we expect it to change\n44 # in the future as to avoid the suspicion that a stray \"/\" in the code is a\n45 # hangover from more *nix-oriented origins.\n46 SEP = \"/\"\n47 \n48 \n49 def os_path(canonicalpath: str) -> str:\n50     return canonicalpath.replace(SEP, path.sep)\n51 \n52 \n53 def canon_path(nativepath: str) -> str:\n54     \"\"\"Return path in OS-independent form\"\"\"\n55     return nativepath.replace(path.sep, SEP)\n56 \n57 \n58 def relative_uri(base: str, to: str) -> str:\n59     \"\"\"Return a relative URL from ``base`` to ``to``.\"\"\"\n60     if to.startswith(SEP):\n61         return to\n62     b2 = base.split('#')[0].split(SEP)\n63     t2 = to.split('#')[0].split(SEP)\n64     # remove common segments (except the last segment)\n65     for x, y in zip(b2[:-1], t2[:-1]):\n66         if x != y:\n67             break\n68         b2.pop(0)\n69         t2.pop(0)\n70     if b2 == t2:\n71         # Special case: relative_uri('f/index.html','f/index.html')\n72         # returns '', not 'index.html'\n73         return ''\n74     if len(b2) == 1 and t2 == ['']:\n75         # Special case: relative_uri('f/index.html','f/') should\n76         # return './', not ''\n77         return '.' + SEP\n78     return ('..' + SEP) * (len(b2) - 1) + SEP.join(t2)\n79 \n80 \n81 def ensuredir(path: str) -> None:\n82     \"\"\"Ensure that a path exists.\"\"\"\n83     os.makedirs(path, exist_ok=True)\n84 \n85 \n86 def walk(top: str, topdown: bool = True, followlinks: bool = False) -> Iterator[Tuple[str, List[str], List[str]]]:  # NOQA\n87     warnings.warn('sphinx.util.osutil.walk() is deprecated for removal. '\n88                   'Please use os.walk() instead.',\n89                   RemovedInSphinx40Warning, stacklevel=2)\n90     return os.walk(top, topdown=topdown, followlinks=followlinks)\n91 \n92 \n93 def mtimes_of_files(dirnames: List[str], suffix: str) -> Iterator[float]:\n94     for dirname in dirnames:\n95         for root, dirs, files in os.walk(dirname):\n96             for sfile in files:\n97                 if sfile.endswith(suffix):\n98                     try:\n99                         yield path.getmtime(path.join(root, sfile))\n100                     except OSError:\n101                         pass\n102 \n103 \n104 def movefile(source: str, dest: str) -> None:\n105     \"\"\"Move a file, removing the destination if it exists.\"\"\"\n106     warnings.warn('sphinx.util.osutil.movefile() is deprecated for removal. '\n107                   'Please use os.replace() instead.',\n108                   RemovedInSphinx50Warning, stacklevel=2)\n109     if os.path.exists(dest):\n110         try:\n111             os.unlink(dest)\n112         except OSError:\n113             pass\n114     os.rename(source, dest)\n115 \n116 \n117 def copytimes(source: str, dest: str) -> None:\n118     \"\"\"Copy a file's modification times.\"\"\"\n119     st = os.stat(source)\n120     if hasattr(os, 'utime'):\n121         os.utime(dest, (st.st_atime, st.st_mtime))\n122 \n123 \n124 def copyfile(source: str, dest: str) -> None:\n125     \"\"\"Copy a file and its modification times, if possible.\n126 \n127     Note: ``copyfile`` skips copying if the file has not been changed\"\"\"\n128     if not path.exists(dest) or not filecmp.cmp(source, dest):\n129         shutil.copyfile(source, dest)\n130         try:\n131             # don't do full copystat because the source may be read-only\n132             copytimes(source, dest)\n133         except OSError:\n134             pass\n135 \n136 \n137 no_fn_re = re.compile(r'[^a-zA-Z0-9_-]')\n138 project_suffix_re = re.compile(' Documentation$')\n139 \n140 \n141 def make_filename(string: str) -> str:\n142     return no_fn_re.sub('', string) or 'sphinx'\n143 \n144 \n145 def make_filename_from_project(project: str) -> str:\n146     return make_filename(project_suffix_re.sub('', project)).lower()\n147 \n148 \n149 def relpath(path: str, start: str = os.curdir) -> str:\n150     \"\"\"Return a relative filepath to *path* either from the current directory or\n151     from an optional *start* directory.\n152 \n153     This is an alternative of ``os.path.relpath()``.  This returns original path\n154     if *path* and *start* are on different drives (for Windows platform).\n155     \"\"\"\n156     try:\n157         return os.path.relpath(path, start)\n158     except ValueError:\n159         return path\n160 \n161 \n162 safe_relpath = relpath  # for compatibility\n163 fs_encoding = sys.getfilesystemencoding() or sys.getdefaultencoding()\n164 \n165 \n166 def abspath(pathdir: str) -> str:\n167     if Path is not None and isinstance(pathdir, Path):\n168         return pathdir.abspath()\n169     else:\n170         pathdir = path.abspath(pathdir)\n171         if isinstance(pathdir, bytes):\n172             try:\n173                 pathdir = pathdir.decode(fs_encoding)\n174             except UnicodeDecodeError as exc:\n175                 raise UnicodeDecodeError('multibyte filename not supported on '\n176                                          'this filesystem encoding '\n177                                          '(%r)' % fs_encoding) from exc\n178         return pathdir\n179 \n180 \n181 def getcwd() -> str:\n182     warnings.warn('sphinx.util.osutil.getcwd() is deprecated. '\n183                   'Please use os.getcwd() instead.',\n184                   RemovedInSphinx40Warning, stacklevel=2)\n185     return os.getcwd()\n186 \n187 \n188 @contextlib.contextmanager\n189 def cd(target_dir: str) -> Generator[None, None, None]:\n190     cwd = os.getcwd()\n191     try:\n192         os.chdir(target_dir)\n193         yield\n194     finally:\n195         os.chdir(cwd)\n196 \n197 \n198 class FileAvoidWrite:\n199     \"\"\"File-like object that buffers output and only writes if content changed.\n200 \n201     Use this class like when writing to a file to avoid touching the original\n202     file if the content hasn't changed. This is useful in scenarios where file\n203     mtime is used to invalidate caches or trigger new behavior.\n204 \n205     When writing to this file handle, all writes are buffered until the object\n206     is closed.\n207 \n208     Objects can be used as context managers.\n209     \"\"\"\n210     def __init__(self, path: str) -> None:\n211         self._path = path\n212         self._io = None  # type: Optional[StringIO]\n213 \n214     def write(self, data: str) -> None:\n215         if not self._io:\n216             self._io = StringIO()\n217         self._io.write(data)\n218 \n219     def close(self) -> None:\n220         \"\"\"Stop accepting writes and write file, if needed.\"\"\"\n221         if not self._io:\n222             raise Exception('FileAvoidWrite does not support empty files.')\n223 \n224         buf = self.getvalue()\n225         self._io.close()\n226 \n227         try:\n228             with open(self._path, encoding='utf-8') as old_f:\n229                 old_content = old_f.read()\n230                 if old_content == buf:\n231                     return\n232         except OSError:\n233             pass\n234 \n235         with open(self._path, 'w', encoding='utf-8') as f:\n236             f.write(buf)\n237 \n238     def __enter__(self) -> \"FileAvoidWrite\":\n239         return self\n240 \n241     def __exit__(self, exc_type: \"Type[Exception]\", exc_value: Exception, traceback: Any) -> bool:  # NOQA\n242         self.close()\n243         return True\n244 \n245     def __getattr__(self, name: str) -> Any:\n246         # Proxy to _io instance.\n247         if not self._io:\n248             raise Exception('Must write to FileAvoidWrite before other '\n249                             'methods can be used')\n250 \n251         return getattr(self._io, name)\n252 \n253 \n254 def rmtree(path: str) -> None:\n255     if os.path.isdir(path):\n256         shutil.rmtree(path)\n257     else:\n258         os.remove(path)\n",
        "intended_behavior": "Enhance file handling utilities to automatically apply path normalization at the point of file path processing. This ensures that before any file operation (copy, link, etc.) is performed, all file paths are treated uniformly."
    },
    {
        "rel_file_path": "sphinx/util/fileutil.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__3.5/sphinx/util/fileutil.py",
        "start": 1,
        "end": 103,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2     sphinx.util.fileutil\n3     ~~~~~~~~~~~~~~~~~~~~\n4 \n5     File utility functions for Sphinx.\n6 \n7     :copyright: Copyright 2007-2021 by the Sphinx team, see AUTHORS.\n8     :license: BSD, see LICENSE for details.\n9 \"\"\"\n10 \n11 import os\n12 import posixpath\n13 from typing import Callable, Dict\n14 \n15 from docutils.utils import relative_path\n16 \n17 from sphinx.util.osutil import copyfile, ensuredir\n18 from sphinx.util.typing import PathMatcher\n19 \n20 if False:\n21     # For type annotation\n22     from sphinx.util.template import BaseRenderer\n23 \n24 \n25 def copy_asset_file(source: str, destination: str,\n26                     context: Dict = None, renderer: \"BaseRenderer\" = None) -> None:\n27     \"\"\"Copy an asset file to destination.\n28 \n29     On copying, it expands the template variables if context argument is given and\n30     the asset is a template file.\n31 \n32     :param source: The path to source file\n33     :param destination: The path to destination file or directory\n34     :param context: The template variables.  If not given, template files are simply copied\n35     :param renderer: The template engine.  If not given, SphinxRenderer is used by default\n36     \"\"\"\n37     if not os.path.exists(source):\n38         return\n39 \n40     if os.path.isdir(destination):\n41         # Use source filename if destination points a directory\n42         destination = os.path.join(destination, os.path.basename(source))\n43 \n44     if source.lower().endswith('_t') and context is not None:\n45         if renderer is None:\n46             from sphinx.util.template import SphinxRenderer\n47             renderer = SphinxRenderer()\n48 \n49         with open(source, encoding='utf-8') as fsrc:\n50             if destination.lower().endswith('_t'):\n51                 destination = destination[:-2]\n52             with open(destination, 'w', encoding='utf-8') as fdst:\n53                 fdst.write(renderer.render_string(fsrc.read(), context))\n54     else:\n55         copyfile(source, destination)\n56 \n57 \n58 def copy_asset(source: str, destination: str, excluded: PathMatcher = lambda path: False,\n59                context: Dict = None, renderer: \"BaseRenderer\" = None,\n60                onerror: Callable[[str, Exception], None] = None) -> None:\n61     \"\"\"Copy asset files to destination recursively.\n62 \n63     On copying, it expands the template variables if context argument is given and\n64     the asset is a template file.\n65 \n66     :param source: The path to source file or directory\n67     :param destination: The path to destination directory\n68     :param excluded: The matcher to determine the given path should be copied or not\n69     :param context: The template variables.  If not given, template files are simply copied\n70     :param renderer: The template engine.  If not given, SphinxRenderer is used by default\n71     :param onerror: The error handler.\n72     \"\"\"\n73     if not os.path.exists(source):\n74         return\n75 \n76     if renderer is None:\n77         from sphinx.util.template import SphinxRenderer\n78         renderer = SphinxRenderer()\n79 \n80     ensuredir(destination)\n81     if os.path.isfile(source):\n82         copy_asset_file(source, destination, context, renderer)\n83         return\n84 \n85     for root, dirs, files in os.walk(source, followlinks=True):\n86         reldir = relative_path(source, root)\n87         for dir in dirs[:]:\n88             if excluded(posixpath.join(reldir, dir)):\n89                 dirs.remove(dir)\n90             else:\n91                 ensuredir(posixpath.join(destination, reldir, dir))\n92 \n93         for filename in files:\n94             if not excluded(posixpath.join(reldir, filename)):\n95                 try:\n96                     copy_asset_file(posixpath.join(root, filename),\n97                                     posixpath.join(destination, reldir),\n98                                     context, renderer)\n99                 except Exception as exc:\n100                     if onerror:\n101                         onerror(posixpath.join(root, filename), exc)\n102                     else:\n103                         raise\n",
        "intended_behavior": "Enhance file handling utilities to automatically apply path normalization at the point of file path processing. This ensures that before any file operation (copy, link, etc.) is performed, all file paths are treated uniformly."
    }
]