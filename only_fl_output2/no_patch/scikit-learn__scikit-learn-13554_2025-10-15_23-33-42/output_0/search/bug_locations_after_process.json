[
    {
        "rel_file_path": "sklearn/metrics/pairwise.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/scikit-learn__scikit-learn/setup_scikit-learn__scikit-learn__0.21/sklearn/metrics/pairwise.py",
        "start": 165,
        "end": 259,
        "class_name": null,
        "method_name": "euclidean_distances",
        "code": "165 def euclidean_distances(X, Y=None, Y_norm_squared=None, squared=False,\n166                         X_norm_squared=None):\n167     \"\"\"\n168     Considering the rows of X (and Y=X) as vectors, compute the\n169     distance matrix between each pair of vectors.\n170 \n171     For efficiency reasons, the euclidean distance between a pair of row\n172     vector x and y is computed as::\n173 \n174         dist(x, y) = sqrt(dot(x, x) - 2 * dot(x, y) + dot(y, y))\n175 \n176     This formulation has two advantages over other ways of computing distances.\n177     First, it is computationally efficient when dealing with sparse data.\n178     Second, if one argument varies but the other remains unchanged, then\n179     `dot(x, x)` and/or `dot(y, y)` can be pre-computed.\n180 \n181     However, this is not the most precise way of doing this computation, and\n182     the distance matrix returned by this function may not be exactly\n183     symmetric as required by, e.g., ``scipy.spatial.distance`` functions.\n184 \n185     Read more in the :ref:`User Guide <metrics>`.\n186 \n187     Parameters\n188     ----------\n189     X : {array-like, sparse matrix}, shape (n_samples_1, n_features)\n190 \n191     Y : {array-like, sparse matrix}, shape (n_samples_2, n_features)\n192 \n193     Y_norm_squared : array-like, shape (n_samples_2, ), optional\n194         Pre-computed dot-products of vectors in Y (e.g.,\n195         ``(Y**2).sum(axis=1)``)\n196 \n197     squared : boolean, optional\n198         Return squared Euclidean distances.\n199 \n200     X_norm_squared : array-like, shape = [n_samples_1], optional\n201         Pre-computed dot-products of vectors in X (e.g.,\n202         ``(X**2).sum(axis=1)``)\n203 \n204     Returns\n205     -------\n206     distances : {array, sparse matrix}, shape (n_samples_1, n_samples_2)\n207 \n208     Examples\n209     --------\n210     >>> from sklearn.metrics.pairwise import euclidean_distances\n211     >>> X = [[0, 1], [1, 1]]\n212     >>> # distance between rows of X\n213     >>> euclidean_distances(X, X)\n214     array([[0., 1.],\n215            [1., 0.]])\n216     >>> # get distance to origin\n217     >>> euclidean_distances(X, [[0, 0]])\n218     array([[1.        ],\n219            [1.41421356]])\n220 \n221     See also\n222     --------\n223     paired_distances : distances betweens pairs of elements of X and Y.\n224     \"\"\"\n225     X, Y = check_pairwise_arrays(X, Y)\n226 \n227     if X_norm_squared is not None:\n228         XX = check_array(X_norm_squared)\n229         if XX.shape == (1, X.shape[0]):\n230             XX = XX.T\n231         elif XX.shape != (X.shape[0], 1):\n232             raise ValueError(\n233                 \"Incompatible dimensions for X and X_norm_squared\")\n234     else:\n235         XX = row_norms(X, squared=True)[:, np.newaxis]\n236 \n237     if X is Y:  # shortcut in the common case euclidean_distances(X, X)\n238         YY = XX.T\n239     elif Y_norm_squared is not None:\n240         YY = np.atleast_2d(Y_norm_squared)\n241 \n242         if YY.shape != (1, Y.shape[0]):\n243             raise ValueError(\n244                 \"Incompatible dimensions for Y and Y_norm_squared\")\n245     else:\n246         YY = row_norms(Y, squared=True)[np.newaxis, :]\n247 \n248     distances = safe_sparse_dot(X, Y.T, dense_output=True)\n249     distances *= -2\n250     distances += XX\n251     distances += YY\n252     np.maximum(distances, 0, out=distances)\n253 \n254     if X is Y:\n255         # Ensure that distances between vectors and themselves are set to 0.0.\n256         # This may not be the case due to floating point rounding errors.\n257         distances.flat[::distances.shape[0] + 1] = 0.0\n258 \n259     return distances if squared else np.sqrt(distances, out=distances)\n",
        "intended_behavior": "This function must precisely manage the datatype of input arrays throughout the distance computation process. When handling `float32` inputs, the function should either avoid converting these inputs to `float64` or ensure such conversions do not affect the final precision of the output. If intermediate steps require `float64` for accuracy, the final output must be converted back to `float32` in a manner that does not introduce significant precision loss, aligning with the precision obtainable through direct `np.linalg.norm` calculations using `float32`. This would involve scrutinizing and potentially adjusting any arithmetic operations, array initializations, or other operations that could cause unintended datatype conversions or precision loss."
    }
]