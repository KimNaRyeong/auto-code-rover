2025-10-15 20:45:01.501 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-15 20:45:05.585 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=223, output_tokens=12, cost=0.002590
2025-10-15 20:45:25.709 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=403, output_tokens=843, cost=0.029320
2025-10-15 20:45:27.036 | INFO     | registered non reproducing test 0
2025-10-15 20:45:42.387 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1528, output_tokens=688, cost=0.035920
2025-10-15 20:45:43.772 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 20:45:47.002 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=528, output_tokens=92, cost=0.008040
2025-10-15 20:45:47.005 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 20:45:48.768 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=446, output_tokens=36, cost=0.005540
2025-10-15 20:45:48.769 | DEBUG    | Extracted a valid json.
2025-10-15 20:45:48.769 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_method(\"tight_layout\")",
        "search_code(\"figure.autolayout\")"
    ],
    "bug_locations": []
}
2025-10-15 20:45:48.825 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-15 20:45:48.826 | DEBUG    | <Agent search> Analyzing search results.
2025-10-15 20:46:04.356 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=938, output_tokens=562, cost=0.026240
2025-10-15 20:46:04.366 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 20:46:11.327 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1716, output_tokens=307, cost=0.026370
2025-10-15 20:46:11.333 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 20:46:16.197 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=661, output_tokens=190, cost=0.012310
2025-10-15 20:46:16.198 | DEBUG    | Extracted a valid json.
2025-10-15 20:46:16.198 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations":[{"file": "lib/matplotlib/figure.py", "class": "Figure", "method": "tight_layout", "intended_behavior": "The `tight_layout` method within this class should be modified or ensured to evaluate and incorporate `kwargs` effectively even when `figure.autolayout` is set to `True`. The method should offer a means to either temporarily override `autolayout` with the explicit settings provided in the call or ensure that the parameters specified through `kwargs`, such as `pad`, `w_pad`, etc., are respected alongside `autolayout` settings. This might involve a conditional check within `tight_layout` to see if `autolayout` is enabled and merging or prioritizing the `kwargs` accordingly, ensuring `tight_layout`'s custom settings are applied effectively without being ignored due to `autolayout` being enabled."}]
}
2025-10-15 20:46:16.207 | DEBUG    | Bug location extracted successfully: [<file>lib/matplotlib/figure.py</file>
<class>Figure</class>
<method>tight_layout</method>
<code>
3480     def tight_layout(self, *, pad=1.08, h_pad=None, w_pad=None, rect=None):
3481         """
3482         Adjust the padding between and around subplots.
3483 
3484         To exclude an artist on the Axes from the bounding box calculation
3485         that determines the subplot parameters (i.e. legend, or annotation),
3486         set ``a.set_in_layout(False)`` for that artist.
3487 
3488         Parameters
3489         ----------
3490         pad : float, default: 1.08
3491             Padding between the figure edge and the edges of subplots,
3492             as a fraction of the font size.
3493         h_pad, w_pad : float, default: *pad*
3494             Padding (height/width) between edges of adjacent subplots,
3495             as a fraction of the font size.
3496         rect : tuple (left, bottom, right, top), default: (0, 0, 1, 1)
3497             A rectangle in normalized figure coordinates into which the whole
3498             subplots area (including labels) will fit.
3499 
3500         See Also
3501         --------
3502         .Figure.set_layout_engine
3503         .pyplot.tight_layout
3504         """
3505         # note that here we do not permanently set the figures engine to
3506         # tight_layout but rather just perform the layout in place and remove
3507         # any previous engines.
3508         engine = TightLayoutEngine(pad=pad, h_pad=h_pad, w_pad=w_pad,
3509                                    rect=rect)
3510         try:
3511             previous_engine = self.get_layout_engine()
3512             self.set_layout_engine(engine)
3513             engine.execute(self)
3514             if not isinstance(previous_engine, TightLayoutEngine) \
3515                     and previous_engine is not None:
3516                 _api.warn_external('The figure layout has changed to tight')
3517         finally:
3518             self.set_layout_engine(None)

</code><intended_behavior>The `tight_layout` method within this class should be modified or ensured to evaluate and incorporate `kwargs` effectively even when `figure.autolayout` is set to `True`. The method should offer a means to either temporarily override `autolayout` with the explicit settings provided in the call or ensure that the parameters specified through `kwargs`, such as `pad`, `w_pad`, etc., are respected alongside `autolayout` settings. This might involve a conditional check within `tight_layout` to see if `autolayout` is enabled and merging or prioritizing the `kwargs` accordingly, ensuring `tight_layout`'s custom settings are applied effectively without being ignored due to `autolayout` being enabled.</intended_behavior>, <file>lib/matplotlib/figure.py</file>
<class>Figure</class>
<method>None</method>
<code>
2329 class Figure(FigureBase):
2330     """
2331     The top level container for all the plot elements.
2332 
2333     Attributes
2334     ----------
2335     patch
2336         The `.Rectangle` instance representing the figure background patch.
2337 
2338     suppressComposite
2339         For multiple images, the figure will make composite images
2340         depending on the renderer option_image_nocomposite function.  If
2341         *suppressComposite* is a boolean, this will override the renderer.
2342     """
2343     # Remove the self._fig_callbacks properties on figure and subfigure
2344     # after the deprecation expires.
2345     callbacks = _api.deprecated(
2346         "3.6", alternative=("the 'resize_event' signal in "
2347                             "Figure.canvas.callbacks")
2348         )(property(lambda self: self._fig_callbacks))
2349 
2350     def __str__(self):
2351         return "Figure(%gx%g)" % tuple(self.bbox.size)
2352 
2353     def __repr__(self):
2354         return "<{clsname} size {h:g}x{w:g} with {naxes} Axes>".format(
2355             clsname=self.__class__.__name__,
2356             h=self.bbox.size[0], w=self.bbox.size[1],
2357             naxes=len(self.axes),
2358         )
2359 
2360     def __init__(self,
2361                  figsize=None,
2362                  dpi=None,
2363                  *,
2364                  facecolor=None,
2365                  edgecolor=None,
2366                  linewidth=0.0,
2367                  frameon=None,
2368                  subplotpars=None,  # rc figure.subplot.*
2369                  tight_layout=None,  # rc figure.autolayout
2370                  constrained_layout=None,  # rc figure.constrained_layout.use
2371                  layout=None,
2372                  **kwargs
2373                  ):
2374         """
2375         Parameters
2376         ----------
2377         figsize : 2-tuple of floats, default: :rc:`figure.figsize`
2378             Figure dimension ``(width, height)`` in inches.
2379 
2380         dpi : float, default: :rc:`figure.dpi`
2381             Dots per inch.
2382 
2383         facecolor : default: :rc:`figure.facecolor`
2384             The figure patch facecolor.
2385 
2386         edgecolor : default: :rc:`figure.edgecolor`
2387             The figure patch edge color.
2388 
2389         linewidth : float
2390             The linewidth of the frame (i.e. the edge linewidth of the figure
2391             patch).
2392 
2393         frameon : bool, default: :rc:`figure.frameon`
2394             If ``False``, suppress drawing the figure background patch.
2395 
2396         subplotpars : `SubplotParams`
2397             Subplot parameters. If not given, the default subplot
2398             parameters :rc:`figure.subplot.*` are used.
2399 
2400         tight_layout : bool or dict, default: :rc:`figure.autolayout`
2401             Whether to use the tight layout mechanism. See `.set_tight_layout`.
2402 
2403             .. admonition:: Discouraged
2404 
2405                 The use of this parameter is discouraged. Please use
2406                 ``layout='tight'`` instead for the common case of
2407                 ``tight_layout=True`` and use `.set_tight_layout` otherwise.
2408 
2409         constrained_layout : bool, default: :rc:`figure.constrained_layout.use`
2410             This is equal to ``layout='constrained'``.
2411 
2412             .. admonition:: Discouraged
2413 
2414                 The use of this parameter is discouraged. Please use
2415                 ``layout='constrained'`` instead.
2416 
2417         layout : {'constrained', 'compressed', 'tight', 'none', `.LayoutEngine`, \
2418 None}, default: None
2419             The layout mechanism for positioning of plot elements to avoid
2420             overlapping Axes decorations (labels, ticks, etc). Note that
2421             layout managers can have significant performance penalties.
2422 
2423             - 'constrained': The constrained layout solver adjusts axes sizes
2424               to avoid overlapping axes decorations.  Can handle complex plot
2425               layouts and colorbars, and is thus recommended.
2426 
2427               See :ref:`constrainedlayout_guide`
2428               for examples.
2429 
2430             - 'compressed': uses the same algorithm as 'constrained', but
2431               removes extra space between fixed-aspect-ratio Axes.  Best for
2432               simple grids of axes.
2433 
2434             - 'tight': Use the tight layout mechanism. This is a relatively
2435               simple algorithm that adjusts the subplot parameters so that
2436               decorations do not overlap. See `.Figure.set_tight_layout` for
2437               further details.
2438 
2439             - 'none': Do not use a layout engine.
2440 
2441             - A `.LayoutEngine` instance. Builtin layout classes are
2442               `.ConstrainedLayoutEngine` and `.TightLayoutEngine`, more easily
2443               accessible by 'constrained' and 'tight'.  Passing an instance
2444               allows third parties to provide their own layout engine.
2445 
2446             If not given, fall back to using the parameters *tight_layout* and
2447             *constrained_layout*, including their config defaults
2448             :rc:`figure.autolayout` and :rc:`figure.constrained_layout.use`.
2449 
2450         Other Parameters
2451         ----------------
2452         **kwargs : `.Figure` properties, optional
2453 
2454             %(Figure:kwdoc)s
2455         """
2456         super().__init__(**kwargs)
2457         self._layout_engine = None
2458 
2459         if layout is not None:
2460             if (tight_layout is not None):
2461                 _api.warn_external(
2462                     "The Figure parameters 'layout' and 'tight_layout' cannot "
2463                     "be used together. Please use 'layout' only.")
2464             if (constrained_layout is not None):
2465                 _api.warn_external(
2466                     "The Figure parameters 'layout' and 'constrained_layout' "
2467                     "cannot be used together. Please use 'layout' only.")
2468             self.set_layout_engine(layout=layout)
2469         elif tight_layout is not None:
2470             if constrained_layout is not None:
2471                 _api.warn_external(
2472                     "The Figure parameters 'tight_layout' and "
2473                     "'constrained_layout' cannot be used together. Please use "
2474                     "'layout' parameter")
2475             self.set_layout_engine(layout='tight')
2476             if isinstance(tight_layout, dict):
2477                 self.get_layout_engine().set(**tight_layout)
2478         elif constrained_layout is not None:
2479             if isinstance(constrained_layout, dict):
2480                 self.set_layout_engine(layout='constrained')
2481                 self.get_layout_engine().set(**constrained_layout)
2482             elif constrained_layout:
2483                 self.set_layout_engine(layout='constrained')
2484 
2485         else:
2486             # everything is None, so use default:
2487             self.set_layout_engine(layout=layout)
2488 
2489         self._fig_callbacks = cbook.CallbackRegistry(signals=["dpi_changed"])
2490         # Callbacks traditionally associated with the canvas (and exposed with
2491         # a proxy property), but that actually need to be on the figure for
2492         # pickling.
2493         self._canvas_callbacks = cbook.CallbackRegistry(
2494             signals=FigureCanvasBase.events)
2495         connect = self._canvas_callbacks._connect_picklable
2496         self._mouse_key_ids = [
2497             connect('key_press_event', backend_bases._key_handler),
2498             connect('key_release_event', backend_bases._key_handler),
2499             connect('key_release_event', backend_bases._key_handler),
2500             connect('button_press_event', backend_bases._mouse_handler),
2501             connect('button_release_event', backend_bases._mouse_handler),
2502             connect('scroll_event', backend_bases._mouse_handler),
2503             connect('motion_notify_event', backend_bases._mouse_handler),
2504         ]
2505         self._button_pick_id = connect('button_press_event', self.pick)
2506         self._scroll_pick_id = connect('scroll_event', self.pick)
2507 
2508         if figsize is None:
2509             figsize = mpl.rcParams['figure.figsize']
2510         if dpi is None:
2511             dpi = mpl.rcParams['figure.dpi']
2512         if facecolor is None:
2513             facecolor = mpl.rcParams['figure.facecolor']
2514         if edgecolor is None:
2515             edgecolor = mpl.rcParams['figure.edgecolor']
2516         if frameon is None:
2517             frameon = mpl.rcParams['figure.frameon']
2518 
2519         if not np.isfinite(figsize).all() or (np.array(figsize) < 0).any():
2520             raise ValueError('figure size must be positive finite not '
2521                              f'{figsize}')
2522         self.bbox_inches = Bbox.from_bounds(0, 0, *figsize)
2523 
2524         self.dpi_scale_trans = Affine2D().scale(dpi)
2525         # do not use property as it will trigger
2526         self._dpi = dpi
2527         self.bbox = TransformedBbox(self.bbox_inches, self.dpi_scale_trans)
2528         self.figbbox = self.bbox
2529         self.transFigure = BboxTransformTo(self.bbox)
2530         self.transSubfigure = self.transFigure
2531 
2532         self.patch = Rectangle(
2533             xy=(0, 0), width=1, height=1, visible=frameon,
2534             facecolor=facecolor, edgecolor=edgecolor, linewidth=linewidth,
2535             # Don't let the figure patch influence bbox calculation.
2536             in_layout=False)
2537         self._set_artist_props(self.patch)
2538         self.patch.set_antialiased(False)
2539 
2540         FigureCanvasBase(self)  # Set self.canvas.
2541 
2542         if subplotpars is None:
2543             subplotpars = SubplotParams()
2544 
2545         self.subplotpars = subplotpars
2546 
2547         self._axstack = _AxesStack()  # track all figure axes and current axes
2548         self.clear()
2549 
2550     def pick(self, mouseevent):
2551         if not self.canvas.widgetlock.locked():
2552             super().pick(mouseevent)
2553 
2554     def _check_layout_engines_compat(self, old, new):
2555         """
2556         Helper for set_layout engine
2557 
2558         If the figure has used the old engine and added a colorbar then the
2559         value of colorbar_gridspec must be the same on the new engine.
2560         """
2561         if old is None or new is None:
2562             return True
2563         if old.colorbar_gridspec == new.colorbar_gridspec:
2564             return True
2565         # colorbar layout different, so check if any colorbars are on the
2566         # figure...
2567         for ax in self.axes:
2568             if hasattr(ax, '_colorbar'):
2569                 # colorbars list themselves as a colorbar.
2570                 return False
2571         return True
2572 
2573     def set_layout_engine(self, layout=None, **kwargs):
2574         """
2575         Set the layout engine for this figure.
2576 
2577         Parameters
2578         ----------
2579         layout: {'constrained', 'compressed', 'tight', 'none'} or \
2580 `LayoutEngine` or None
2581 
2582             - 'constrained' will use `~.ConstrainedLayoutEngine`
2583             - 'compressed' will also use `~.ConstrainedLayoutEngine`, but with
2584               a correction that attempts to make a good layout for fixed-aspect
2585               ratio Axes.
2586             - 'tight' uses `~.TightLayoutEngine`
2587             - 'none' removes layout engine.
2588 
2589             If `None`, the behavior is controlled by :rc:`figure.autolayout`
2590             (which if `True` behaves as if 'tight' was passed) and
2591             :rc:`figure.constrained_layout.use` (which if `True` behaves as if
2592             'constrained' was passed).  If both are `True`,
2593             :rc:`figure.autolayout` takes priority.
2594 
2595             Users and libraries can define their own layout engines and pass
2596             the instance directly as well.
2597 
2598         kwargs: dict
2599             The keyword arguments are passed to the layout engine to set things
2600             like padding and margin sizes.  Only used if *layout* is a string.
2601 
2602         """
2603         if layout is None:
2604             if mpl.rcParams['figure.autolayout']:
2605                 layout = 'tight'
2606             elif mpl.rcParams['figure.constrained_layout.use']:
2607                 layout = 'constrained'
2608             else:
2609                 self._layout_engine = None
2610                 return
2611         if layout == 'tight':
2612             new_layout_engine = TightLayoutEngine(**kwargs)
2613         elif layout == 'constrained':
2614             new_layout_engine = ConstrainedLayoutEngine(**kwargs)
2615         elif layout == 'compressed':
2616             new_layout_engine = ConstrainedLayoutEngine(compress=True,
2617                                                         **kwargs)
2618         elif layout == 'none':
2619             if self._layout_engine is not None:
2620                 new_layout_engine = PlaceHolderLayoutEngine(
2621                     self._layout_engine.adjust_compatible,
2622                     self._layout_engine.colorbar_gridspec
2623                 )
2624             else:
2625                 new_layout_engine = None
2626         elif isinstance(layout, LayoutEngine):
2627             new_layout_engine = layout
2628         else:
2629             raise ValueError(f"Invalid value for 'layout': {layout!r}")
2630 
2631         if self._check_layout_engines_compat(self._layout_engine,
2632                                              new_layout_engine):
2633             self._layout_engine = new_layout_engine
2634         else:
2635             raise RuntimeError('Colorbar layout of new layout engine not '
2636                                'compatible with old engine, and a colorbar '
2637                                'has been created.  Engine not changed.')
2638 
2639     def get_layout_engine(self):
2640         return self._layout_engine
2641 
2642     # TODO: I'd like to dynamically add the _repr_html_ method
2643     # to the figure in the right context, but then IPython doesn't
2644     # use it, for some reason.
2645 
2646     def _repr_html_(self):
2647         # We can't use "isinstance" here, because then we'd end up importing
2648         # webagg unconditionally.
2649         if 'WebAgg' in type(self.canvas).__name__:
2650             from matplotlib.backends import backend_webagg
2651             return backend_webagg.ipython_inline_display(self)
2652 
2653     def show(self, warn=True):
2654         """
2655         If using a GUI backend with pyplot, display the figure window.
2656 
2657         If the figure was not created using `~.pyplot.figure`, it will lack
2658         a `~.backend_bases.FigureManagerBase`, and this method will raise an
2659         AttributeError.
2660 
2661         .. warning::
2662 
2663             This does not manage an GUI event loop. Consequently, the figure
2664             may only be shown briefly or not shown at all if you or your
2665             environment are not managing an event loop.
2666 
2667             Use cases for `.Figure.show` include running this from a GUI
2668             application (where there is persistently an event loop running) or
2669             from a shell, like IPython, that install an input hook to allow the
2670             interactive shell to accept input while the figure is also being
2671             shown and interactive.  Some, but not all, GUI toolkits will
2672             register an input hook on import.  See :ref:`cp_integration` for
2673             more details.
2674 
2675             If you're in a shell without input hook integration or executing a
2676             python script, you should use `matplotlib.pyplot.show` with
2677             ``block=True`` instead, which takes care of starting and running
2678             the event loop for you.
2679 
2680         Parameters
2681         ----------
2682         warn : bool, default: True
2683             If ``True`` and we are not running headless (i.e. on Linux with an
2684             unset DISPLAY), issue warning when called on a non-GUI backend.
2685 
2686         """
2687         if self.canvas.manager is None:
2688             raise AttributeError(
2689                 "Figure.show works only for figures managed by pyplot, "
2690                 "normally created by pyplot.figure()")
2691         try:
2692             self.canvas.manager.show()
2693         except NonGuiException as exc:
2694             if warn:
2695                 _api.warn_external(str(exc))
2696 
2697     @property
2698     def axes(self):
2699         """
2700         List of Axes in the Figure. You can access and modify the Axes in the
2701         Figure through this list.
2702 
2703         Do not modify the list itself. Instead, use `~Figure.add_axes`,
2704         `~.Figure.add_subplot` or `~.Figure.delaxes` to add or remove an Axes.
2705 
2706         Note: The `.Figure.axes` property and `~.Figure.get_axes` method are
2707         equivalent.
2708         """
2709         return self._axstack.as_list()
2710 
2711     get_axes = axes.fget
2712 
2713     def _get_renderer(self):
2714         if hasattr(self.canvas, 'get_renderer'):
2715             return self.canvas.get_renderer()
2716         else:
2717             return _get_renderer(self)
2718 
2719     def _get_dpi(self):
2720         return self._dpi
2721 
2722     def _set_dpi(self, dpi, forward=True):
2723         """
2724         Parameters
2725         ----------
2726         dpi : float
2727 
2728         forward : bool
2729             Passed on to `~.Figure.set_size_inches`
2730         """
2731         if dpi == self._dpi:
2732             # We don't want to cause undue events in backends.
2733             return
2734         self._dpi = dpi
2735         self.dpi_scale_trans.clear().scale(dpi)
2736         w, h = self.get_size_inches()
2737         self.set_size_inches(w, h, forward=forward)
2738         self._fig_callbacks.process('dpi_changed', self)
2739 
2740     dpi = property(_get_dpi, _set_dpi, doc="The resolution in dots per inch.")
2741 
2742     def get_tight_layout(self):
2743         """Return whether `.tight_layout` is called when drawing."""
2744         return isinstance(self.get_layout_engine(), TightLayoutEngine)
2745 
2746     @_api.deprecated("3.6", alternative="set_layout_engine",
2747                      pending=True)
2748     def set_tight_layout(self, tight):
2749         """
2750         [*Discouraged*] Set whether and how `.tight_layout` is called when
2751         drawing.
2752 
2753         .. admonition:: Discouraged
2754 
2755             This method is discouraged in favor of `~.set_layout_engine`.
2756 
2757         Parameters
2758         ----------
2759         tight : bool or dict with keys "pad", "w_pad", "h_pad", "rect" or None
2760             If a bool, sets whether to call `.tight_layout` upon drawing.
2761             If ``None``, use :rc:`figure.autolayout` instead.
2762             If a dict, pass it as kwargs to `.tight_layout`, overriding the
2763             default paddings.
2764         """
2765         if tight is None:
2766             tight = mpl.rcParams['figure.autolayout']
2767         _tight = 'tight' if bool(tight) else 'none'
2768         _tight_parameters = tight if isinstance(tight, dict) else {}
2769         self.set_layout_engine(_tight, **_tight_parameters)
2770         self.stale = True
2771 
2772     def get_constrained_layout(self):
2773         """
2774         Return whether constrained layout is being used.
2775 
2776         See :ref:`constrainedlayout_guide`.
2777         """
2778         return isinstance(self.get_layout_engine(), ConstrainedLayoutEngine)
2779 
2780     @_api.deprecated("3.6", alternative="set_layout_engine('constrained')",
2781                      pending=True)
2782     def set_constrained_layout(self, constrained):
2783         """
2784         [*Discouraged*] Set whether ``constrained_layout`` is used upon
2785         drawing.
2786 
2787         If None, :rc:`figure.constrained_layout.use` value will be used.
2788 
2789         When providing a dict containing the keys ``w_pad``, ``h_pad``
2790         the default ``constrained_layout`` paddings will be
2791         overridden.  These pads are in inches and default to 3.0/72.0.
2792         ``w_pad`` is the width padding and ``h_pad`` is the height padding.
2793 
2794         .. admonition:: Discouraged
2795 
2796             This method is discouraged in favor of `~.set_layout_engine`.
2797 
2798         Parameters
2799         ----------
2800         constrained : bool or dict or None
2801         """
2802         if constrained is None:
2803             constrained = mpl.rcParams['figure.constrained_layout.use']
2804         _constrained = 'constrained' if bool(constrained) else 'none'
2805         _parameters = constrained if isinstance(constrained, dict) else {}
2806         self.set_layout_engine(_constrained, **_parameters)
2807         self.stale = True
2808 
2809     @_api.deprecated(
2810          "3.6", alternative="figure.get_layout_engine().set()",
2811          pending=True)
2812     def set_constrained_layout_pads(self, **kwargs):
2813         """
2814         Set padding for ``constrained_layout``.
2815 
2816         Tip: The parameters can be passed from a dictionary by using
2817         ``fig.set_constrained_layout(**pad_dict)``.
2818 
2819         See :ref:`constrainedlayout_guide`.
2820 
2821         Parameters
2822         ----------
2823         w_pad : float, default: :rc:`figure.constrained_layout.w_pad`
2824             Width padding in inches.  This is the pad around Axes
2825             and is meant to make sure there is enough room for fonts to
2826             look good.  Defaults to 3 pts = 0.04167 inches
2827 
2828         h_pad : float, default: :rc:`figure.constrained_layout.h_pad`
2829             Height padding in inches. Defaults to 3 pts.
2830 
2831         wspace : float, default: :rc:`figure.constrained_layout.wspace`
2832             Width padding between subplots, expressed as a fraction of the
2833             subplot width.  The total padding ends up being w_pad + wspace.
2834 
2835         hspace : float, default: :rc:`figure.constrained_layout.hspace`
2836             Height padding between subplots, expressed as a fraction of the
2837             subplot width. The total padding ends up being h_pad + hspace.
2838 
2839         """
2840         if isinstance(self.get_layout_engine(), ConstrainedLayoutEngine):
2841             self.get_layout_engine().set(**kwargs)
2842 
2843     @_api.deprecated("3.6", alternative="fig.get_layout_engine().get()",
2844                      pending=True)
2845     def get_constrained_layout_pads(self, relative=False):
2846         """
2847         Get padding for ``constrained_layout``.
2848 
2849         Returns a list of ``w_pad, h_pad`` in inches and
2850         ``wspace`` and ``hspace`` as fractions of the subplot.
2851         All values are None if ``constrained_layout`` is not used.
2852 
2853         See :ref:`constrainedlayout_guide`.
2854 
2855         Parameters
2856         ----------
2857         relative : bool
2858             If `True`, then convert from inches to figure relative.
2859         """
2860         if not isinstance(self.get_layout_engine(), ConstrainedLayoutEngine):
2861             return None, None, None, None
2862         info = self.get_layout_engine().get_info()
2863         w_pad = info['w_pad']
2864         h_pad = info['h_pad']
2865         wspace = info['wspace']
2866         hspace = info['hspace']
2867 
2868         if relative and (w_pad is not None or h_pad is not None):
2869             renderer = self._get_renderer()
2870             dpi = renderer.dpi
2871             w_pad = w_pad * dpi / renderer.width
2872             h_pad = h_pad * dpi / renderer.height
2873 
2874         return w_pad, h_pad, wspace, hspace
2875 
2876     def set_canvas(self, canvas):
2877         """
2878         Set the canvas that contains the figure
2879 
2880         Parameters
2881         ----------
2882         canvas : FigureCanvas
2883         """
2884         self.canvas = canvas
2885 
2886     @_docstring.interpd
2887     def figimage(self, X, xo=0, yo=0, alpha=None, norm=None, cmap=None,
2888                  vmin=None, vmax=None, origin=None, resize=False, **kwargs):
2889         """
2890         Add a non-resampled image to the figure.
2891 
2892         The image is attached to the lower or upper left corner depending on
2893         *origin*.
2894 
2895         Parameters
2896         ----------
2897         X
2898             The image data. This is an array of one of the following shapes:
2899 
2900             - (M, N): an image with scalar data.  Color-mapping is controlled
2901               by *cmap*, *norm*, *vmin*, and *vmax*.
2902             - (M, N, 3): an image with RGB values (0-1 float or 0-255 int).
2903             - (M, N, 4): an image with RGBA values (0-1 float or 0-255 int),
2904               i.e. including transparency.
2905 
2906         xo, yo : int
2907             The *x*/*y* image offset in pixels.
2908 
2909         alpha : None or float
2910             The alpha blending value.
2911 
2912         %(cmap_doc)s
2913 
2914             This parameter is ignored if *X* is RGB(A).
2915 
2916         %(norm_doc)s
2917 
2918             This parameter is ignored if *X* is RGB(A).
2919 
2920         %(vmin_vmax_doc)s
2921 
2922             This parameter is ignored if *X* is RGB(A).
2923 
2924         origin : {'upper', 'lower'}, default: :rc:`image.origin`
2925             Indicates where the [0, 0] index of the array is in the upper left
2926             or lower left corner of the axes.
2927 
2928         resize : bool
2929             If *True*, resize the figure to match the given image size.
2930 
2931         Returns
2932         -------
2933         `matplotlib.image.FigureImage`
2934 
2935         Other Parameters
2936         ----------------
2937         **kwargs
2938             Additional kwargs are `.Artist` kwargs passed on to `.FigureImage`.
2939 
2940         Notes
2941         -----
2942         figimage complements the Axes image (`~matplotlib.axes.Axes.imshow`)
2943         which will be resampled to fit the current Axes.  If you want
2944         a resampled image to fill the entire figure, you can define an
2945         `~matplotlib.axes.Axes` with extent [0, 0, 1, 1].
2946 
2947         Examples
2948         --------
2949         ::
2950 
2951             f = plt.figure()
2952             nx = int(f.get_figwidth() * f.dpi)
2953             ny = int(f.get_figheight() * f.dpi)
2954             data = np.random.random((ny, nx))
2955             f.figimage(data)
2956             plt.show()
2957         """
2958         if resize:
2959             dpi = self.get_dpi()
2960             figsize = [x / dpi for x in (X.shape[1], X.shape[0])]
2961             self.set_size_inches(figsize, forward=True)
2962 
2963         im = mimage.FigureImage(self, cmap=cmap, norm=norm,
2964                                 offsetx=xo, offsety=yo,
2965                                 origin=origin, **kwargs)
2966         im.stale_callback = _stale_figure_callback
2967 
2968         im.set_array(X)
2969         im.set_alpha(alpha)
2970         if norm is None:
2971             im.set_clim(vmin, vmax)
2972         self.images.append(im)
2973         im._remove_method = self.images.remove
2974         self.stale = True
2975         return im
2976 
2977     def set_size_inches(self, w, h=None, forward=True):
2978         """
2979         Set the figure size in inches.
2980 
2981         Call signatures::
2982 
2983              fig.set_size_inches(w, h)  # OR
2984              fig.set_size_inches((w, h))
2985 
2986         Parameters
2987         ----------
2988         w : (float, float) or float
2989             Width and height in inches (if height not specified as a separate
2990             argument) or width.
2991         h : float
2992             Height in inches.
2993         forward : bool, default: True
2994             If ``True``, the canvas size is automatically updated, e.g.,
2995             you can resize the figure window from the shell.
2996 
2997         See Also
2998         --------
2999         matplotlib.figure.Figure.get_size_inches
3000         matplotlib.figure.Figure.set_figwidth
3001         matplotlib.figure.Figure.set_figheight
3002 
3003         Notes
3004         -----
3005         To transform from pixels to inches divide by `Figure.dpi`.
3006         """
3007         if h is None:  # Got called with a single pair as argument.
3008             w, h = w
3009         size = np.array([w, h])
3010         if not np.isfinite(size).all() or (size < 0).any():
3011             raise ValueError(f'figure size must be positive finite not {size}')
3012         self.bbox_inches.p1 = size
3013         if forward:
3014             manager = self.canvas.manager
3015             if manager is not None:
3016                 manager.resize(*(size * self.dpi).astype(int))
3017         self.stale = True
3018 
3019     def get_size_inches(self):
3020         """
3021         Return the current size of the figure in inches.
3022 
3023         Returns
3024         -------
3025         ndarray
3026            The size (width, height) of the figure in inches.
3027 
3028         See Also
3029         --------
3030         matplotlib.figure.Figure.set_size_inches
3031         matplotlib.figure.Figure.get_figwidth
3032         matplotlib.figure.Figure.get_figheight
3033 
3034         Notes
3035         -----
3036         The size in pixels can be obtained by multiplying with `Figure.dpi`.
3037         """
3038         return np.array(self.bbox_inches.p1)
3039 
3040     def get_figwidth(self):
3041         """Return the figure width in inches."""
3042         return self.bbox_inches.width
3043 
3044     def get_figheight(self):
3045         """Return the figure height in inches."""
3046         return self.bbox_inches.height
3047 
3048     def get_dpi(self):
3049         """Return the resolution in dots per inch as a float."""
3050         return self.dpi
3051 
3052     def set_dpi(self, val):
3053         """
3054         Set the resolution of the figure in dots-per-inch.
3055 
3056         Parameters
3057         ----------
3058         val : float
3059         """
3060         self.dpi = val
3061         self.stale = True
3062 
3063     def set_figwidth(self, val, forward=True):
3064         """
3065         Set the width of the figure in inches.
3066 
3067         Parameters
3068         ----------
3069         val : float
3070         forward : bool
3071             See `set_size_inches`.
3072 
3073         See Also
3074         --------
3075         matplotlib.figure.Figure.set_figheight
3076         matplotlib.figure.Figure.set_size_inches
3077         """
3078         self.set_size_inches(val, self.get_figheight(), forward=forward)
3079 
3080     def set_figheight(self, val, forward=True):
3081         """
3082         Set the height of the figure in inches.
3083 
3084         Parameters
3085         ----------
3086         val : float
3087         forward : bool
3088             See `set_size_inches`.
3089 
3090         See Also
3091         --------
3092         matplotlib.figure.Figure.set_figwidth
3093         matplotlib.figure.Figure.set_size_inches
3094         """
3095         self.set_size_inches(self.get_figwidth(), val, forward=forward)
3096 
3097     def clear(self, keep_observers=False):
3098         # docstring inherited
3099         super().clear(keep_observers=keep_observers)
3100         # FigureBase.clear does not clear toolbars, as
3101         # only Figure can have toolbars
3102         toolbar = self.canvas.toolbar
3103         if toolbar is not None:
3104             toolbar.update()
3105 
3106     @_finalize_rasterization
3107     @allow_rasterization
3108     def draw(self, renderer):
3109         # docstring inherited
3110 
3111         # draw the figure bounding box, perhaps none for white figure
3112         if not self.get_visible():
3113             return
3114 
3115         artists = self._get_draw_artists(renderer)
3116         try:
3117             renderer.open_group('figure', gid=self.get_gid())
3118             if self.axes and self.get_layout_engine() is not None:
3119                 try:
3120                     self.get_layout_engine().execute(self)
3121                 except ValueError:
3122                     pass
3123                     # ValueError can occur when resizing a window.
3124 
3125             self.patch.draw(renderer)
3126             mimage._draw_list_compositing_images(
3127                 renderer, self, artists, self.suppressComposite)
3128 
3129             for sfig in self.subfigs:
3130                 sfig.draw(renderer)
3131 
3132             renderer.close_group('figure')
3133         finally:
3134             self.stale = False
3135 
3136         DrawEvent("draw_event", self.canvas, renderer)._process()
3137 
3138     def draw_without_rendering(self):
3139         """
3140         Draw the figure with no output.  Useful to get the final size of
3141         artists that require a draw before their size is known (e.g. text).
3142         """
3143         renderer = _get_renderer(self)
3144         with renderer._draw_disabled():
3145             self.draw(renderer)
3146 
3147     def draw_artist(self, a):
3148         """
3149         Draw `.Artist` *a* only.
3150         """
3151         a.draw(self.canvas.get_renderer())
3152 
3153     def __getstate__(self):
3154         state = super().__getstate__()
3155 
3156         # The canvas cannot currently be pickled, but this has the benefit
3157         # of meaning that a figure can be detached from one canvas, and
3158         # re-attached to another.
3159         state.pop("canvas")
3160 
3161         # discard any changes to the dpi due to pixel ratio changes
3162         state["_dpi"] = state.get('_original_dpi', state['_dpi'])
3163 
3164         # add version information to the state
3165         state['__mpl_version__'] = mpl.__version__
3166 
3167         # check whether the figure manager (if any) is registered with pyplot
3168         from matplotlib import _pylab_helpers
3169         if self.canvas.manager in _pylab_helpers.Gcf.figs.values():
3170             state['_restore_to_pylab'] = True
3171         return state
3172 
3173     def __setstate__(self, state):
3174         version = state.pop('__mpl_version__')
3175         restore_to_pylab = state.pop('_restore_to_pylab', False)
3176 
3177         if version != mpl.__version__:
3178             _api.warn_external(
3179                 f"This figure was saved with matplotlib version {version} and "
3180                 f"is unlikely to function correctly.")
3181 
3182         self.__dict__ = state
3183 
3184         # re-initialise some of the unstored state information
3185         FigureCanvasBase(self)  # Set self.canvas.
3186 
3187         if restore_to_pylab:
3188             # lazy import to avoid circularity
3189             import matplotlib.pyplot as plt
3190             import matplotlib._pylab_helpers as pylab_helpers
3191             allnums = plt.get_fignums()
3192             num = max(allnums) + 1 if allnums else 1
3193             backend = plt._get_backend_mod()
3194             mgr = backend.new_figure_manager_given_figure(num, self)
3195             pylab_helpers.Gcf._set_new_active_manager(mgr)
3196             plt.draw_if_interactive()
3197 
3198         self.stale = True
3199 
3200     def add_axobserver(self, func):
3201         """Whenever the Axes state change, ``func(self)`` will be called."""
3202         # Connect a wrapper lambda and not func itself, to avoid it being
3203         # weakref-collected.
3204         self._axobservers.connect("_axes_change_event", lambda arg: func(arg))
3205 
3206     def savefig(self, fname, *, transparent=None, **kwargs):
3207         """
3208         Save the current figure.
3209 
3210         Call signature::
3211 
3212           savefig(fname, *, dpi='figure', format=None, metadata=None,
3213                   bbox_inches=None, pad_inches=0.1,
3214                   facecolor='auto', edgecolor='auto',
3215                   backend=None, **kwargs
3216                  )
3217 
3218         The available output formats depend on the backend being used.
3219 
3220         Parameters
3221         ----------
3222         fname : str or path-like or binary file-like
3223             A path, or a Python file-like object, or
3224             possibly some backend-dependent object such as
3225             `matplotlib.backends.backend_pdf.PdfPages`.
3226 
3227             If *format* is set, it determines the output format, and the file
3228             is saved as *fname*.  Note that *fname* is used verbatim, and there
3229             is no attempt to make the extension, if any, of *fname* match
3230             *format*, and no extension is appended.
3231 
3232             If *format* is not set, then the format is inferred from the
3233             extension of *fname*, if there is one.  If *format* is not
3234             set and *fname* has no extension, then the file is saved with
3235             :rc:`savefig.format` and the appropriate extension is appended to
3236             *fname*.
3237 
3238         Other Parameters
3239         ----------------
3240         dpi : float or 'figure', default: :rc:`savefig.dpi`
3241             The resolution in dots per inch.  If 'figure', use the figure's
3242             dpi value.
3243 
3244         format : str
3245             The file format, e.g. 'png', 'pdf', 'svg', ... The behavior when
3246             this is unset is documented under *fname*.
3247 
3248         metadata : dict, optional
3249             Key/value pairs to store in the image metadata. The supported keys
3250             and defaults depend on the image format and backend:
3251 
3252             - 'png' with Agg backend: See the parameter ``metadata`` of
3253               `~.FigureCanvasAgg.print_png`.
3254             - 'pdf' with pdf backend: See the parameter ``metadata`` of
3255               `~.backend_pdf.PdfPages`.
3256             - 'svg' with svg backend: See the parameter ``metadata`` of
3257               `~.FigureCanvasSVG.print_svg`.
3258             - 'eps' and 'ps' with PS backend: Only 'Creator' is supported.
3259 
3260             Not supported for 'pgf', 'raw', and 'rgba' as those formats do not support
3261             embedding metadata.
3262             Does not currently support 'jpg', 'tiff', or 'webp', but may include
3263             embedding EXIF metadata in the future.
3264 
3265         bbox_inches : str or `.Bbox`, default: :rc:`savefig.bbox`
3266             Bounding box in inches: only the given portion of the figure is
3267             saved.  If 'tight', try to figure out the tight bbox of the figure.
3268 
3269         pad_inches : float or 'layout', default: :rc:`savefig.pad_inches`
3270             Amount of padding in inches around the figure when bbox_inches is
3271             'tight'. If 'layout' use the padding from the constrained or
3272             compressed layout engine; ignored if one of those engines is not in
3273             use.
3274 
3275         facecolor : color or 'auto', default: :rc:`savefig.facecolor`
3276             The facecolor of the figure.  If 'auto', use the current figure
3277             facecolor.
3278 
3279         edgecolor : color or 'auto', default: :rc:`savefig.edgecolor`
3280             The edgecolor of the figure.  If 'auto', use the current figure
3281             edgecolor.
3282 
3283         backend : str, optional
3284             Use a non-default backend to render the file, e.g. to render a
3285             png file with the "cairo" backend rather than the default "agg",
3286             or a pdf file with the "pgf" backend rather than the default
3287             "pdf".  Note that the default backend is normally sufficient.  See
3288             :ref:`the-builtin-backends` for a list of valid backends for each
3289             file format.  Custom backends can be referenced as "module://...".
3290 
3291         orientation : {'landscape', 'portrait'}
3292             Currently only supported by the postscript backend.
3293 
3294         papertype : str
3295             One of 'letter', 'legal', 'executive', 'ledger', 'a0' through
3296             'a10', 'b0' through 'b10'. Only supported for postscript
3297             output.
3298 
3299         transparent : bool
3300             If *True*, the Axes patches will all be transparent; the
3301             Figure patch will also be transparent unless *facecolor*
3302             and/or *edgecolor* are specified via kwargs.
3303 
3304             If *False* has no effect and the color of the Axes and
3305             Figure patches are unchanged (unless the Figure patch
3306             is specified via the *facecolor* and/or *edgecolor* keyword
3307             arguments in which case those colors are used).
3308 
3309             The transparency of these patches will be restored to their
3310             original values upon exit of this function.
3311 
3312             This is useful, for example, for displaying
3313             a plot on top of a colored background on a web page.
3314 
3315         bbox_extra_artists : list of `~matplotlib.artist.Artist`, optional
3316             A list of extra artists that will be considered when the
3317             tight bbox is calculated.
3318 
3319         pil_kwargs : dict, optional
3320             Additional keyword arguments that are passed to
3321             `PIL.Image.Image.save` when saving the figure.
3322 
3323         """
3324 
3325         kwargs.setdefault('dpi', mpl.rcParams['savefig.dpi'])
3326         if transparent is None:
3327             transparent = mpl.rcParams['savefig.transparent']
3328 
3329         with ExitStack() as stack:
3330             if transparent:
3331                 def _recursively_make_subfig_transparent(exit_stack, subfig):
3332                     exit_stack.enter_context(
3333                         subfig.patch._cm_set(
3334                             facecolor="none", edgecolor="none"))
3335                     for ax in subfig.axes:
3336                         exit_stack.enter_context(
3337                             ax.patch._cm_set(
3338                                 facecolor="none", edgecolor="none"))
3339                     for sub_subfig in subfig.subfigs:
3340                         _recursively_make_subfig_transparent(
3341                             exit_stack, sub_subfig)
3342 
3343                 def _recursively_make_axes_transparent(exit_stack, ax):
3344                     exit_stack.enter_context(
3345                         ax.patch._cm_set(facecolor="none", edgecolor="none"))
3346                     for child_ax in ax.child_axes:
3347                         exit_stack.enter_context(
3348                             child_ax.patch._cm_set(
3349                                 facecolor="none", edgecolor="none"))
3350                     for child_childax in ax.child_axes:
3351                         _recursively_make_axes_transparent(
3352                             exit_stack, child_childax)
3353 
3354                 kwargs.setdefault('facecolor', 'none')
3355                 kwargs.setdefault('edgecolor', 'none')
3356                 # set subfigure to appear transparent in printed image
3357                 for subfig in self.subfigs:
3358                     _recursively_make_subfig_transparent(stack, subfig)
3359                 # set axes to be transparent
3360                 for ax in self.axes:
3361                     _recursively_make_axes_transparent(stack, ax)
3362             self.canvas.print_figure(fname, **kwargs)
3363 
3364     def ginput(self, n=1, timeout=30, show_clicks=True,
3365                mouse_add=MouseButton.LEFT,
3366                mouse_pop=MouseButton.RIGHT,
3367                mouse_stop=MouseButton.MIDDLE):
3368         """
3369         Blocking call to interact with a figure.
3370 
3371         Wait until the user clicks *n* times on the figure, and return the
3372         coordinates of each click in a list.
3373 
3374         There are three possible interactions:
3375 
3376         - Add a point.
3377         - Remove the most recently added point.
3378         - Stop the interaction and return the points added so far.
3379 
3380         The actions are assigned to mouse buttons via the arguments
3381         *mouse_add*, *mouse_pop* and *mouse_stop*.
3382 
3383         Parameters
3384         ----------
3385         n : int, default: 1
3386             Number of mouse clicks to accumulate. If negative, accumulate
3387             clicks until the input is terminated manually.
3388         timeout : float, default: 30 seconds
3389             Number of seconds to wait before timing out. If zero or negative
3390             will never time out.
3391         show_clicks : bool, default: True
3392             If True, show a red cross at the location of each click.
3393         mouse_add : `.MouseButton` or None, default: `.MouseButton.LEFT`
3394             Mouse button used to add points.
3395         mouse_pop : `.MouseButton` or None, default: `.MouseButton.RIGHT`
3396             Mouse button used to remove the most recently added point.
3397         mouse_stop : `.MouseButton` or None, default: `.MouseButton.MIDDLE`
3398             Mouse button used to stop input.
3399 
3400         Returns
3401         -------
3402         list of tuples
3403             A list of the clicked (x, y) coordinates.
3404 
3405         Notes
3406         -----
3407         The keyboard can also be used to select points in case your mouse
3408         does not have one or more of the buttons.  The delete and backspace
3409         keys act like right-clicking (i.e., remove last point), the enter key
3410         terminates input and any other key (not already used by the window
3411         manager) selects a point.
3412         """
3413         clicks = []
3414         marks = []
3415 
3416         def handler(event):
3417             is_button = event.name == "button_press_event"
3418             is_key = event.name == "key_press_event"
3419             # Quit (even if not in infinite mode; this is consistent with
3420             # MATLAB and sometimes quite useful, but will require the user to
3421             # test how many points were actually returned before using data).
3422             if (is_button and event.button == mouse_stop
3423                     or is_key and event.key in ["escape", "enter"]):
3424                 self.canvas.stop_event_loop()
3425             # Pop last click.
3426             elif (is_button and event.button == mouse_pop
3427                   or is_key and event.key in ["backspace", "delete"]):
3428                 if clicks:
3429                     clicks.pop()
3430                     if show_clicks:
3431                         marks.pop().remove()
3432                         self.canvas.draw()
3433             # Add new click.
3434             elif (is_button and event.button == mouse_add
3435                   # On macOS/gtk, some keys return None.
3436                   or is_key and event.key is not None):
3437                 if event.inaxes:
3438                     clicks.append((event.xdata, event.ydata))
3439                     _log.info("input %i: %f, %f",
3440                               len(clicks), event.xdata, event.ydata)
3441                     if show_clicks:
3442                         line = mpl.lines.Line2D([event.xdata], [event.ydata],
3443                                                 marker="+", color="r")
3444                         event.inaxes.add_line(line)
3445                         marks.append(line)
3446                         self.canvas.draw()
3447             if len(clicks) == n and n > 0:
3448                 self.canvas.stop_event_loop()
3449 
3450         _blocking_input.blocking_input_loop(
3451             self, ["button_press_event", "key_press_event"], timeout, handler)
3452 
3453         # Cleanup.
3454         for mark in marks:
3455             mark.remove()
3456         self.canvas.draw()
3457 
3458         return clicks
3459 
3460     def waitforbuttonpress(self, timeout=-1):
3461         """
3462         Blocking call to interact with the figure.
3463 
3464         Wait for user input and return True if a key was pressed, False if a
3465         mouse button was pressed and None if no input was given within
3466         *timeout* seconds.  Negative values deactivate *timeout*.
3467         """
3468         event = None
3469 
3470         def handler(ev):
3471             nonlocal event
3472             event = ev
3473             self.canvas.stop_event_loop()
3474 
3475         _blocking_input.blocking_input_loop(
3476             self, ["button_press_event", "key_press_event"], timeout, handler)
3477 
3478         return None if event is None else event.name == "key_press_event"
3479 
3480     def tight_layout(self, *, pad=1.08, h_pad=None, w_pad=None, rect=None):
3481         """
3482         Adjust the padding between and around subplots.
3483 
3484         To exclude an artist on the Axes from the bounding box calculation
3485         that determines the subplot parameters (i.e. legend, or annotation),
3486         set ``a.set_in_layout(False)`` for that artist.
3487 
3488         Parameters
3489         ----------
3490         pad : float, default: 1.08
3491             Padding between the figure edge and the edges of subplots,
3492             as a fraction of the font size.
3493         h_pad, w_pad : float, default: *pad*
3494             Padding (height/width) between edges of adjacent subplots,
3495             as a fraction of the font size.
3496         rect : tuple (left, bottom, right, top), default: (0, 0, 1, 1)
3497             A rectangle in normalized figure coordinates into which the whole
3498             subplots area (including labels) will fit.
3499 
3500         See Also
3501         --------
3502         .Figure.set_layout_engine
3503         .pyplot.tight_layout
3504         """
3505         # note that here we do not permanently set the figures engine to
3506         # tight_layout but rather just perform the layout in place and remove
3507         # any previous engines.
3508         engine = TightLayoutEngine(pad=pad, h_pad=h_pad, w_pad=w_pad,
3509                                    rect=rect)
3510         try:
3511             previous_engine = self.get_layout_engine()
3512             self.set_layout_engine(engine)
3513             engine.execute(self)
3514             if not isinstance(previous_engine, TightLayoutEngine) \
3515                     and previous_engine is not None:
3516                 _api.warn_external('The figure layout has changed to tight')
3517         finally:
3518             self.set_layout_engine(None)

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>]
2025-10-15 20:46:16.207 | INFO     | Search completed. Bug locations: [<file>lib/matplotlib/figure.py</file>
<class>Figure</class>
<method>tight_layout</method>
<code>
3480     def tight_layout(self, *, pad=1.08, h_pad=None, w_pad=None, rect=None):
3481         """
3482         Adjust the padding between and around subplots.
3483 
3484         To exclude an artist on the Axes from the bounding box calculation
3485         that determines the subplot parameters (i.e. legend, or annotation),
3486         set ``a.set_in_layout(False)`` for that artist.
3487 
3488         Parameters
3489         ----------
3490         pad : float, default: 1.08
3491             Padding between the figure edge and the edges of subplots,
3492             as a fraction of the font size.
3493         h_pad, w_pad : float, default: *pad*
3494             Padding (height/width) between edges of adjacent subplots,
3495             as a fraction of the font size.
3496         rect : tuple (left, bottom, right, top), default: (0, 0, 1, 1)
3497             A rectangle in normalized figure coordinates into which the whole
3498             subplots area (including labels) will fit.
3499 
3500         See Also
3501         --------
3502         .Figure.set_layout_engine
3503         .pyplot.tight_layout
3504         """
3505         # note that here we do not permanently set the figures engine to
3506         # tight_layout but rather just perform the layout in place and remove
3507         # any previous engines.
3508         engine = TightLayoutEngine(pad=pad, h_pad=h_pad, w_pad=w_pad,
3509                                    rect=rect)
3510         try:
3511             previous_engine = self.get_layout_engine()
3512             self.set_layout_engine(engine)
3513             engine.execute(self)
3514             if not isinstance(previous_engine, TightLayoutEngine) \
3515                     and previous_engine is not None:
3516                 _api.warn_external('The figure layout has changed to tight')
3517         finally:
3518             self.set_layout_engine(None)

</code><intended_behavior>The `tight_layout` method within this class should be modified or ensured to evaluate and incorporate `kwargs` effectively even when `figure.autolayout` is set to `True`. The method should offer a means to either temporarily override `autolayout` with the explicit settings provided in the call or ensure that the parameters specified through `kwargs`, such as `pad`, `w_pad`, etc., are respected alongside `autolayout` settings. This might involve a conditional check within `tight_layout` to see if `autolayout` is enabled and merging or prioritizing the `kwargs` accordingly, ensuring `tight_layout`'s custom settings are applied effectively without being ignored due to `autolayout` being enabled.</intended_behavior>, <file>lib/matplotlib/figure.py</file>
<class>Figure</class>
<method>None</method>
<code>
2329 class Figure(FigureBase):
2330     """
2331     The top level container for all the plot elements.
2332 
2333     Attributes
2334     ----------
2335     patch
2336         The `.Rectangle` instance representing the figure background patch.
2337 
2338     suppressComposite
2339         For multiple images, the figure will make composite images
2340         depending on the renderer option_image_nocomposite function.  If
2341         *suppressComposite* is a boolean, this will override the renderer.
2342     """
2343     # Remove the self._fig_callbacks properties on figure and subfigure
2344     # after the deprecation expires.
2345     callbacks = _api.deprecated(
2346         "3.6", alternative=("the 'resize_event' signal in "
2347                             "Figure.canvas.callbacks")
2348         )(property(lambda self: self._fig_callbacks))
2349 
2350     def __str__(self):
2351         return "Figure(%gx%g)" % tuple(self.bbox.size)
2352 
2353     def __repr__(self):
2354         return "<{clsname} size {h:g}x{w:g} with {naxes} Axes>".format(
2355             clsname=self.__class__.__name__,
2356             h=self.bbox.size[0], w=self.bbox.size[1],
2357             naxes=len(self.axes),
2358         )
2359 
2360     def __init__(self,
2361                  figsize=None,
2362                  dpi=None,
2363                  *,
2364                  facecolor=None,
2365                  edgecolor=None,
2366                  linewidth=0.0,
2367                  frameon=None,
2368                  subplotpars=None,  # rc figure.subplot.*
2369                  tight_layout=None,  # rc figure.autolayout
2370                  constrained_layout=None,  # rc figure.constrained_layout.use
2371                  layout=None,
2372                  **kwargs
2373                  ):
2374         """
2375         Parameters
2376         ----------
2377         figsize : 2-tuple of floats, default: :rc:`figure.figsize`
2378             Figure dimension ``(width, height)`` in inches.
2379 
2380         dpi : float, default: :rc:`figure.dpi`
2381             Dots per inch.
2382 
2383         facecolor : default: :rc:`figure.facecolor`
2384             The figure patch facecolor.
2385 
2386         edgecolor : default: :rc:`figure.edgecolor`
2387             The figure patch edge color.
2388 
2389         linewidth : float
2390             The linewidth of the frame (i.e. the edge linewidth of the figure
2391             patch).
2392 
2393         frameon : bool, default: :rc:`figure.frameon`
2394             If ``False``, suppress drawing the figure background patch.
2395 
2396         subplotpars : `SubplotParams`
2397             Subplot parameters. If not given, the default subplot
2398             parameters :rc:`figure.subplot.*` are used.
2399 
2400         tight_layout : bool or dict, default: :rc:`figure.autolayout`
2401             Whether to use the tight layout mechanism. See `.set_tight_layout`.
2402 
2403             .. admonition:: Discouraged
2404 
2405                 The use of this parameter is discouraged. Please use
2406                 ``layout='tight'`` instead for the common case of
2407                 ``tight_layout=True`` and use `.set_tight_layout` otherwise.
2408 
2409         constrained_layout : bool, default: :rc:`figure.constrained_layout.use`
2410             This is equal to ``layout='constrained'``.
2411 
2412             .. admonition:: Discouraged
2413 
2414                 The use of this parameter is discouraged. Please use
2415                 ``layout='constrained'`` instead.
2416 
2417         layout : {'constrained', 'compressed', 'tight', 'none', `.LayoutEngine`, \
2418 None}, default: None
2419             The layout mechanism for positioning of plot elements to avoid
2420             overlapping Axes decorations (labels, ticks, etc). Note that
2421             layout managers can have significant performance penalties.
2422 
2423             - 'constrained': The constrained layout solver adjusts axes sizes
2424               to avoid overlapping axes decorations.  Can handle complex plot
2425               layouts and colorbars, and is thus recommended.
2426 
2427               See :ref:`constrainedlayout_guide`
2428               for examples.
2429 
2430             - 'compressed': uses the same algorithm as 'constrained', but
2431               removes extra space between fixed-aspect-ratio Axes.  Best for
2432               simple grids of axes.
2433 
2434             - 'tight': Use the tight layout mechanism. This is a relatively
2435               simple algorithm that adjusts the subplot parameters so that
2436               decorations do not overlap. See `.Figure.set_tight_layout` for
2437               further details.
2438 
2439             - 'none': Do not use a layout engine.
2440 
2441             - A `.LayoutEngine` instance. Builtin layout classes are
2442               `.ConstrainedLayoutEngine` and `.TightLayoutEngine`, more easily
2443               accessible by 'constrained' and 'tight'.  Passing an instance
2444               allows third parties to provide their own layout engine.
2445 
2446             If not given, fall back to using the parameters *tight_layout* and
2447             *constrained_layout*, including their config defaults
2448             :rc:`figure.autolayout` and :rc:`figure.constrained_layout.use`.
2449 
2450         Other Parameters
2451         ----------------
2452         **kwargs : `.Figure` properties, optional
2453 
2454             %(Figure:kwdoc)s
2455         """
2456         super().__init__(**kwargs)
2457         self._layout_engine = None
2458 
2459         if layout is not None:
2460             if (tight_layout is not None):
2461                 _api.warn_external(
2462                     "The Figure parameters 'layout' and 'tight_layout' cannot "
2463                     "be used together. Please use 'layout' only.")
2464             if (constrained_layout is not None):
2465                 _api.warn_external(
2466                     "The Figure parameters 'layout' and 'constrained_layout' "
2467                     "cannot be used together. Please use 'layout' only.")
2468             self.set_layout_engine(layout=layout)
2469         elif tight_layout is not None:
2470             if constrained_layout is not None:
2471                 _api.warn_external(
2472                     "The Figure parameters 'tight_layout' and "
2473                     "'constrained_layout' cannot be used together. Please use "
2474                     "'layout' parameter")
2475             self.set_layout_engine(layout='tight')
2476             if isinstance(tight_layout, dict):
2477                 self.get_layout_engine().set(**tight_layout)
2478         elif constrained_layout is not None:
2479             if isinstance(constrained_layout, dict):
2480                 self.set_layout_engine(layout='constrained')
2481                 self.get_layout_engine().set(**constrained_layout)
2482             elif constrained_layout:
2483                 self.set_layout_engine(layout='constrained')
2484 
2485         else:
2486             # everything is None, so use default:
2487             self.set_layout_engine(layout=layout)
2488 
2489         self._fig_callbacks = cbook.CallbackRegistry(signals=["dpi_changed"])
2490         # Callbacks traditionally associated with the canvas (and exposed with
2491         # a proxy property), but that actually need to be on the figure for
2492         # pickling.
2493         self._canvas_callbacks = cbook.CallbackRegistry(
2494             signals=FigureCanvasBase.events)
2495         connect = self._canvas_callbacks._connect_picklable
2496         self._mouse_key_ids = [
2497             connect('key_press_event', backend_bases._key_handler),
2498             connect('key_release_event', backend_bases._key_handler),
2499             connect('key_release_event', backend_bases._key_handler),
2500             connect('button_press_event', backend_bases._mouse_handler),
2501             connect('button_release_event', backend_bases._mouse_handler),
2502             connect('scroll_event', backend_bases._mouse_handler),
2503             connect('motion_notify_event', backend_bases._mouse_handler),
2504         ]
2505         self._button_pick_id = connect('button_press_event', self.pick)
2506         self._scroll_pick_id = connect('scroll_event', self.pick)
2507 
2508         if figsize is None:
2509             figsize = mpl.rcParams['figure.figsize']
2510         if dpi is None:
2511             dpi = mpl.rcParams['figure.dpi']
2512         if facecolor is None:
2513             facecolor = mpl.rcParams['figure.facecolor']
2514         if edgecolor is None:
2515             edgecolor = mpl.rcParams['figure.edgecolor']
2516         if frameon is None:
2517             frameon = mpl.rcParams['figure.frameon']
2518 
2519         if not np.isfinite(figsize).all() or (np.array(figsize) < 0).any():
2520             raise ValueError('figure size must be positive finite not '
2521                              f'{figsize}')
2522         self.bbox_inches = Bbox.from_bounds(0, 0, *figsize)
2523 
2524         self.dpi_scale_trans = Affine2D().scale(dpi)
2525         # do not use property as it will trigger
2526         self._dpi = dpi
2527         self.bbox = TransformedBbox(self.bbox_inches, self.dpi_scale_trans)
2528         self.figbbox = self.bbox
2529         self.transFigure = BboxTransformTo(self.bbox)
2530         self.transSubfigure = self.transFigure
2531 
2532         self.patch = Rectangle(
2533             xy=(0, 0), width=1, height=1, visible=frameon,
2534             facecolor=facecolor, edgecolor=edgecolor, linewidth=linewidth,
2535             # Don't let the figure patch influence bbox calculation.
2536             in_layout=False)
2537         self._set_artist_props(self.patch)
2538         self.patch.set_antialiased(False)
2539 
2540         FigureCanvasBase(self)  # Set self.canvas.
2541 
2542         if subplotpars is None:
2543             subplotpars = SubplotParams()
2544 
2545         self.subplotpars = subplotpars
2546 
2547         self._axstack = _AxesStack()  # track all figure axes and current axes
2548         self.clear()
2549 
2550     def pick(self, mouseevent):
2551         if not self.canvas.widgetlock.locked():
2552             super().pick(mouseevent)
2553 
2554     def _check_layout_engines_compat(self, old, new):
2555         """
2556         Helper for set_layout engine
2557 
2558         If the figure has used the old engine and added a colorbar then the
2559         value of colorbar_gridspec must be the same on the new engine.
2560         """
2561         if old is None or new is None:
2562             return True
2563         if old.colorbar_gridspec == new.colorbar_gridspec:
2564             return True
2565         # colorbar layout different, so check if any colorbars are on the
2566         # figure...
2567         for ax in self.axes:
2568             if hasattr(ax, '_colorbar'):
2569                 # colorbars list themselves as a colorbar.
2570                 return False
2571         return True
2572 
2573     def set_layout_engine(self, layout=None, **kwargs):
2574         """
2575         Set the layout engine for this figure.
2576 
2577         Parameters
2578         ----------
2579         layout: {'constrained', 'compressed', 'tight', 'none'} or \
2580 `LayoutEngine` or None
2581 
2582             - 'constrained' will use `~.ConstrainedLayoutEngine`
2583             - 'compressed' will also use `~.ConstrainedLayoutEngine`, but with
2584               a correction that attempts to make a good layout for fixed-aspect
2585               ratio Axes.
2586             - 'tight' uses `~.TightLayoutEngine`
2587             - 'none' removes layout engine.
2588 
2589             If `None`, the behavior is controlled by :rc:`figure.autolayout`
2590             (which if `True` behaves as if 'tight' was passed) and
2591             :rc:`figure.constrained_layout.use` (which if `True` behaves as if
2592             'constrained' was passed).  If both are `True`,
2593             :rc:`figure.autolayout` takes priority.
2594 
2595             Users and libraries can define their own layout engines and pass
2596             the instance directly as well.
2597 
2598         kwargs: dict
2599             The keyword arguments are passed to the layout engine to set things
2600             like padding and margin sizes.  Only used if *layout* is a string.
2601 
2602         """
2603         if layout is None:
2604             if mpl.rcParams['figure.autolayout']:
2605                 layout = 'tight'
2606             elif mpl.rcParams['figure.constrained_layout.use']:
2607                 layout = 'constrained'
2608             else:
2609                 self._layout_engine = None
2610                 return
2611         if layout == 'tight':
2612             new_layout_engine = TightLayoutEngine(**kwargs)
2613         elif layout == 'constrained':
2614             new_layout_engine = ConstrainedLayoutEngine(**kwargs)
2615         elif layout == 'compressed':
2616             new_layout_engine = ConstrainedLayoutEngine(compress=True,
2617                                                         **kwargs)
2618         elif layout == 'none':
2619             if self._layout_engine is not None:
2620                 new_layout_engine = PlaceHolderLayoutEngine(
2621                     self._layout_engine.adjust_compatible,
2622                     self._layout_engine.colorbar_gridspec
2623                 )
2624             else:
2625                 new_layout_engine = None
2626         elif isinstance(layout, LayoutEngine):
2627             new_layout_engine = layout
2628         else:
2629             raise ValueError(f"Invalid value for 'layout': {layout!r}")
2630 
2631         if self._check_layout_engines_compat(self._layout_engine,
2632                                              new_layout_engine):
2633             self._layout_engine = new_layout_engine
2634         else:
2635             raise RuntimeError('Colorbar layout of new layout engine not '
2636                                'compatible with old engine, and a colorbar '
2637                                'has been created.  Engine not changed.')
2638 
2639     def get_layout_engine(self):
2640         return self._layout_engine
2641 
2642     # TODO: I'd like to dynamically add the _repr_html_ method
2643     # to the figure in the right context, but then IPython doesn't
2644     # use it, for some reason.
2645 
2646     def _repr_html_(self):
2647         # We can't use "isinstance" here, because then we'd end up importing
2648         # webagg unconditionally.
2649         if 'WebAgg' in type(self.canvas).__name__:
2650             from matplotlib.backends import backend_webagg
2651             return backend_webagg.ipython_inline_display(self)
2652 
2653     def show(self, warn=True):
2654         """
2655         If using a GUI backend with pyplot, display the figure window.
2656 
2657         If the figure was not created using `~.pyplot.figure`, it will lack
2658         a `~.backend_bases.FigureManagerBase`, and this method will raise an
2659         AttributeError.
2660 
2661         .. warning::
2662 
2663             This does not manage an GUI event loop. Consequently, the figure
2664             may only be shown briefly or not shown at all if you or your
2665             environment are not managing an event loop.
2666 
2667             Use cases for `.Figure.show` include running this from a GUI
2668             application (where there is persistently an event loop running) or
2669             from a shell, like IPython, that install an input hook to allow the
2670             interactive shell to accept input while the figure is also being
2671             shown and interactive.  Some, but not all, GUI toolkits will
2672             register an input hook on import.  See :ref:`cp_integration` for
2673             more details.
2674 
2675             If you're in a shell without input hook integration or executing a
2676             python script, you should use `matplotlib.pyplot.show` with
2677             ``block=True`` instead, which takes care of starting and running
2678             the event loop for you.
2679 
2680         Parameters
2681         ----------
2682         warn : bool, default: True
2683             If ``True`` and we are not running headless (i.e. on Linux with an
2684             unset DISPLAY), issue warning when called on a non-GUI backend.
2685 
2686         """
2687         if self.canvas.manager is None:
2688             raise AttributeError(
2689                 "Figure.show works only for figures managed by pyplot, "
2690                 "normally created by pyplot.figure()")
2691         try:
2692             self.canvas.manager.show()
2693         except NonGuiException as exc:
2694             if warn:
2695                 _api.warn_external(str(exc))
2696 
2697     @property
2698     def axes(self):
2699         """
2700         List of Axes in the Figure. You can access and modify the Axes in the
2701         Figure through this list.
2702 
2703         Do not modify the list itself. Instead, use `~Figure.add_axes`,
2704         `~.Figure.add_subplot` or `~.Figure.delaxes` to add or remove an Axes.
2705 
2706         Note: The `.Figure.axes` property and `~.Figure.get_axes` method are
2707         equivalent.
2708         """
2709         return self._axstack.as_list()
2710 
2711     get_axes = axes.fget
2712 
2713     def _get_renderer(self):
2714         if hasattr(self.canvas, 'get_renderer'):
2715             return self.canvas.get_renderer()
2716         else:
2717             return _get_renderer(self)
2718 
2719     def _get_dpi(self):
2720         return self._dpi
2721 
2722     def _set_dpi(self, dpi, forward=True):
2723         """
2724         Parameters
2725         ----------
2726         dpi : float
2727 
2728         forward : bool
2729             Passed on to `~.Figure.set_size_inches`
2730         """
2731         if dpi == self._dpi:
2732             # We don't want to cause undue events in backends.
2733             return
2734         self._dpi = dpi
2735         self.dpi_scale_trans.clear().scale(dpi)
2736         w, h = self.get_size_inches()
2737         self.set_size_inches(w, h, forward=forward)
2738         self._fig_callbacks.process('dpi_changed', self)
2739 
2740     dpi = property(_get_dpi, _set_dpi, doc="The resolution in dots per inch.")
2741 
2742     def get_tight_layout(self):
2743         """Return whether `.tight_layout` is called when drawing."""
2744         return isinstance(self.get_layout_engine(), TightLayoutEngine)
2745 
2746     @_api.deprecated("3.6", alternative="set_layout_engine",
2747                      pending=True)
2748     def set_tight_layout(self, tight):
2749         """
2750         [*Discouraged*] Set whether and how `.tight_layout` is called when
2751         drawing.
2752 
2753         .. admonition:: Discouraged
2754 
2755             This method is discouraged in favor of `~.set_layout_engine`.
2756 
2757         Parameters
2758         ----------
2759         tight : bool or dict with keys "pad", "w_pad", "h_pad", "rect" or None
2760             If a bool, sets whether to call `.tight_layout` upon drawing.
2761             If ``None``, use :rc:`figure.autolayout` instead.
2762             If a dict, pass it as kwargs to `.tight_layout`, overriding the
2763             default paddings.
2764         """
2765         if tight is None:
2766             tight = mpl.rcParams['figure.autolayout']
2767         _tight = 'tight' if bool(tight) else 'none'
2768         _tight_parameters = tight if isinstance(tight, dict) else {}
2769         self.set_layout_engine(_tight, **_tight_parameters)
2770         self.stale = True
2771 
2772     def get_constrained_layout(self):
2773         """
2774         Return whether constrained layout is being used.
2775 
2776         See :ref:`constrainedlayout_guide`.
2777         """
2778         return isinstance(self.get_layout_engine(), ConstrainedLayoutEngine)
2779 
2780     @_api.deprecated("3.6", alternative="set_layout_engine('constrained')",
2781                      pending=True)
2782     def set_constrained_layout(self, constrained):
2783         """
2784         [*Discouraged*] Set whether ``constrained_layout`` is used upon
2785         drawing.
2786 
2787         If None, :rc:`figure.constrained_layout.use` value will be used.
2788 
2789         When providing a dict containing the keys ``w_pad``, ``h_pad``
2790         the default ``constrained_layout`` paddings will be
2791         overridden.  These pads are in inches and default to 3.0/72.0.
2792         ``w_pad`` is the width padding and ``h_pad`` is the height padding.
2793 
2794         .. admonition:: Discouraged
2795 
2796             This method is discouraged in favor of `~.set_layout_engine`.
2797 
2798         Parameters
2799         ----------
2800         constrained : bool or dict or None
2801         """
2802         if constrained is None:
2803             constrained = mpl.rcParams['figure.constrained_layout.use']
2804         _constrained = 'constrained' if bool(constrained) else 'none'
2805         _parameters = constrained if isinstance(constrained, dict) else {}
2806         self.set_layout_engine(_constrained, **_parameters)
2807         self.stale = True
2808 
2809     @_api.deprecated(
2810          "3.6", alternative="figure.get_layout_engine().set()",
2811          pending=True)
2812     def set_constrained_layout_pads(self, **kwargs):
2813         """
2814         Set padding for ``constrained_layout``.
2815 
2816         Tip: The parameters can be passed from a dictionary by using
2817         ``fig.set_constrained_layout(**pad_dict)``.
2818 
2819         See :ref:`constrainedlayout_guide`.
2820 
2821         Parameters
2822         ----------
2823         w_pad : float, default: :rc:`figure.constrained_layout.w_pad`
2824             Width padding in inches.  This is the pad around Axes
2825             and is meant to make sure there is enough room for fonts to
2826             look good.  Defaults to 3 pts = 0.04167 inches
2827 
2828         h_pad : float, default: :rc:`figure.constrained_layout.h_pad`
2829             Height padding in inches. Defaults to 3 pts.
2830 
2831         wspace : float, default: :rc:`figure.constrained_layout.wspace`
2832             Width padding between subplots, expressed as a fraction of the
2833             subplot width.  The total padding ends up being w_pad + wspace.
2834 
2835         hspace : float, default: :rc:`figure.constrained_layout.hspace`
2836             Height padding between subplots, expressed as a fraction of the
2837             subplot width. The total padding ends up being h_pad + hspace.
2838 
2839         """
2840         if isinstance(self.get_layout_engine(), ConstrainedLayoutEngine):
2841             self.get_layout_engine().set(**kwargs)
2842 
2843     @_api.deprecated("3.6", alternative="fig.get_layout_engine().get()",
2844                      pending=True)
2845     def get_constrained_layout_pads(self, relative=False):
2846         """
2847         Get padding for ``constrained_layout``.
2848 
2849         Returns a list of ``w_pad, h_pad`` in inches and
2850         ``wspace`` and ``hspace`` as fractions of the subplot.
2851         All values are None if ``constrained_layout`` is not used.
2852 
2853         See :ref:`constrainedlayout_guide`.
2854 
2855         Parameters
2856         ----------
2857         relative : bool
2858             If `True`, then convert from inches to figure relative.
2859         """
2860         if not isinstance(self.get_layout_engine(), ConstrainedLayoutEngine):
2861             return None, None, None, None
2862         info = self.get_layout_engine().get_info()
2863         w_pad = info['w_pad']
2864         h_pad = info['h_pad']
2865         wspace = info['wspace']
2866         hspace = info['hspace']
2867 
2868         if relative and (w_pad is not None or h_pad is not None):
2869             renderer = self._get_renderer()
2870             dpi = renderer.dpi
2871             w_pad = w_pad * dpi / renderer.width
2872             h_pad = h_pad * dpi / renderer.height
2873 
2874         return w_pad, h_pad, wspace, hspace
2875 
2876     def set_canvas(self, canvas):
2877         """
2878         Set the canvas that contains the figure
2879 
2880         Parameters
2881         ----------
2882         canvas : FigureCanvas
2883         """
2884         self.canvas = canvas
2885 
2886     @_docstring.interpd
2887     def figimage(self, X, xo=0, yo=0, alpha=None, norm=None, cmap=None,
2888                  vmin=None, vmax=None, origin=None, resize=False, **kwargs):
2889         """
2890         Add a non-resampled image to the figure.
2891 
2892         The image is attached to the lower or upper left corner depending on
2893         *origin*.
2894 
2895         Parameters
2896         ----------
2897         X
2898             The image data. This is an array of one of the following shapes:
2899 
2900             - (M, N): an image with scalar data.  Color-mapping is controlled
2901               by *cmap*, *norm*, *vmin*, and *vmax*.
2902             - (M, N, 3): an image with RGB values (0-1 float or 0-255 int).
2903             - (M, N, 4): an image with RGBA values (0-1 float or 0-255 int),
2904               i.e. including transparency.
2905 
2906         xo, yo : int
2907             The *x*/*y* image offset in pixels.
2908 
2909         alpha : None or float
2910             The alpha blending value.
2911 
2912         %(cmap_doc)s
2913 
2914             This parameter is ignored if *X* is RGB(A).
2915 
2916         %(norm_doc)s
2917 
2918             This parameter is ignored if *X* is RGB(A).
2919 
2920         %(vmin_vmax_doc)s
2921 
2922             This parameter is ignored if *X* is RGB(A).
2923 
2924         origin : {'upper', 'lower'}, default: :rc:`image.origin`
2925             Indicates where the [0, 0] index of the array is in the upper left
2926             or lower left corner of the axes.
2927 
2928         resize : bool
2929             If *True*, resize the figure to match the given image size.
2930 
2931         Returns
2932         -------
2933         `matplotlib.image.FigureImage`
2934 
2935         Other Parameters
2936         ----------------
2937         **kwargs
2938             Additional kwargs are `.Artist` kwargs passed on to `.FigureImage`.
2939 
2940         Notes
2941         -----
2942         figimage complements the Axes image (`~matplotlib.axes.Axes.imshow`)
2943         which will be resampled to fit the current Axes.  If you want
2944         a resampled image to fill the entire figure, you can define an
2945         `~matplotlib.axes.Axes` with extent [0, 0, 1, 1].
2946 
2947         Examples
2948         --------
2949         ::
2950 
2951             f = plt.figure()
2952             nx = int(f.get_figwidth() * f.dpi)
2953             ny = int(f.get_figheight() * f.dpi)
2954             data = np.random.random((ny, nx))
2955             f.figimage(data)
2956             plt.show()
2957         """
2958         if resize:
2959             dpi = self.get_dpi()
2960             figsize = [x / dpi for x in (X.shape[1], X.shape[0])]
2961             self.set_size_inches(figsize, forward=True)
2962 
2963         im = mimage.FigureImage(self, cmap=cmap, norm=norm,
2964                                 offsetx=xo, offsety=yo,
2965                                 origin=origin, **kwargs)
2966         im.stale_callback = _stale_figure_callback
2967 
2968         im.set_array(X)
2969         im.set_alpha(alpha)
2970         if norm is None:
2971             im.set_clim(vmin, vmax)
2972         self.images.append(im)
2973         im._remove_method = self.images.remove
2974         self.stale = True
2975         return im
2976 
2977     def set_size_inches(self, w, h=None, forward=True):
2978         """
2979         Set the figure size in inches.
2980 
2981         Call signatures::
2982 
2983              fig.set_size_inches(w, h)  # OR
2984              fig.set_size_inches((w, h))
2985 
2986         Parameters
2987         ----------
2988         w : (float, float) or float
2989             Width and height in inches (if height not specified as a separate
2990             argument) or width.
2991         h : float
2992             Height in inches.
2993         forward : bool, default: True
2994             If ``True``, the canvas size is automatically updated, e.g.,
2995             you can resize the figure window from the shell.
2996 
2997         See Also
2998         --------
2999         matplotlib.figure.Figure.get_size_inches
3000         matplotlib.figure.Figure.set_figwidth
3001         matplotlib.figure.Figure.set_figheight
3002 
3003         Notes
3004         -----
3005         To transform from pixels to inches divide by `Figure.dpi`.
3006         """
3007         if h is None:  # Got called with a single pair as argument.
3008             w, h = w
3009         size = np.array([w, h])
3010         if not np.isfinite(size).all() or (size < 0).any():
3011             raise ValueError(f'figure size must be positive finite not {size}')
3012         self.bbox_inches.p1 = size
3013         if forward:
3014             manager = self.canvas.manager
3015             if manager is not None:
3016                 manager.resize(*(size * self.dpi).astype(int))
3017         self.stale = True
3018 
3019     def get_size_inches(self):
3020         """
3021         Return the current size of the figure in inches.
3022 
3023         Returns
3024         -------
3025         ndarray
3026            The size (width, height) of the figure in inches.
3027 
3028         See Also
3029         --------
3030         matplotlib.figure.Figure.set_size_inches
3031         matplotlib.figure.Figure.get_figwidth
3032         matplotlib.figure.Figure.get_figheight
3033 
3034         Notes
3035         -----
3036         The size in pixels can be obtained by multiplying with `Figure.dpi`.
3037         """
3038         return np.array(self.bbox_inches.p1)
3039 
3040     def get_figwidth(self):
3041         """Return the figure width in inches."""
3042         return self.bbox_inches.width
3043 
3044     def get_figheight(self):
3045         """Return the figure height in inches."""
3046         return self.bbox_inches.height
3047 
3048     def get_dpi(self):
3049         """Return the resolution in dots per inch as a float."""
3050         return self.dpi
3051 
3052     def set_dpi(self, val):
3053         """
3054         Set the resolution of the figure in dots-per-inch.
3055 
3056         Parameters
3057         ----------
3058         val : float
3059         """
3060         self.dpi = val
3061         self.stale = True
3062 
3063     def set_figwidth(self, val, forward=True):
3064         """
3065         Set the width of the figure in inches.
3066 
3067         Parameters
3068         ----------
3069         val : float
3070         forward : bool
3071             See `set_size_inches`.
3072 
3073         See Also
3074         --------
3075         matplotlib.figure.Figure.set_figheight
3076         matplotlib.figure.Figure.set_size_inches
3077         """
3078         self.set_size_inches(val, self.get_figheight(), forward=forward)
3079 
3080     def set_figheight(self, val, forward=True):
3081         """
3082         Set the height of the figure in inches.
3083 
3084         Parameters
3085         ----------
3086         val : float
3087         forward : bool
3088             See `set_size_inches`.
3089 
3090         See Also
3091         --------
3092         matplotlib.figure.Figure.set_figwidth
3093         matplotlib.figure.Figure.set_size_inches
3094         """
3095         self.set_size_inches(self.get_figwidth(), val, forward=forward)
3096 
3097     def clear(self, keep_observers=False):
3098         # docstring inherited
3099         super().clear(keep_observers=keep_observers)
3100         # FigureBase.clear does not clear toolbars, as
3101         # only Figure can have toolbars
3102         toolbar = self.canvas.toolbar
3103         if toolbar is not None:
3104             toolbar.update()
3105 
3106     @_finalize_rasterization
3107     @allow_rasterization
3108     def draw(self, renderer):
3109         # docstring inherited
3110 
3111         # draw the figure bounding box, perhaps none for white figure
3112         if not self.get_visible():
3113             return
3114 
3115         artists = self._get_draw_artists(renderer)
3116         try:
3117             renderer.open_group('figure', gid=self.get_gid())
3118             if self.axes and self.get_layout_engine() is not None:
3119                 try:
3120                     self.get_layout_engine().execute(self)
3121                 except ValueError:
3122                     pass
3123                     # ValueError can occur when resizing a window.
3124 
3125             self.patch.draw(renderer)
3126             mimage._draw_list_compositing_images(
3127                 renderer, self, artists, self.suppressComposite)
3128 
3129             for sfig in self.subfigs:
3130                 sfig.draw(renderer)
3131 
3132             renderer.close_group('figure')
3133         finally:
3134             self.stale = False
3135 
3136         DrawEvent("draw_event", self.canvas, renderer)._process()
3137 
3138     def draw_without_rendering(self):
3139         """
3140         Draw the figure with no output.  Useful to get the final size of
3141         artists that require a draw before their size is known (e.g. text).
3142         """
3143         renderer = _get_renderer(self)
3144         with renderer._draw_disabled():
3145             self.draw(renderer)
3146 
3147     def draw_artist(self, a):
3148         """
3149         Draw `.Artist` *a* only.
3150         """
3151         a.draw(self.canvas.get_renderer())
3152 
3153     def __getstate__(self):
3154         state = super().__getstate__()
3155 
3156         # The canvas cannot currently be pickled, but this has the benefit
3157         # of meaning that a figure can be detached from one canvas, and
3158         # re-attached to another.
3159         state.pop("canvas")
3160 
3161         # discard any changes to the dpi due to pixel ratio changes
3162         state["_dpi"] = state.get('_original_dpi', state['_dpi'])
3163 
3164         # add version information to the state
3165         state['__mpl_version__'] = mpl.__version__
3166 
3167         # check whether the figure manager (if any) is registered with pyplot
3168         from matplotlib import _pylab_helpers
3169         if self.canvas.manager in _pylab_helpers.Gcf.figs.values():
3170             state['_restore_to_pylab'] = True
3171         return state
3172 
3173     def __setstate__(self, state):
3174         version = state.pop('__mpl_version__')
3175         restore_to_pylab = state.pop('_restore_to_pylab', False)
3176 
3177         if version != mpl.__version__:
3178             _api.warn_external(
3179                 f"This figure was saved with matplotlib version {version} and "
3180                 f"is unlikely to function correctly.")
3181 
3182         self.__dict__ = state
3183 
3184         # re-initialise some of the unstored state information
3185         FigureCanvasBase(self)  # Set self.canvas.
3186 
3187         if restore_to_pylab:
3188             # lazy import to avoid circularity
3189             import matplotlib.pyplot as plt
3190             import matplotlib._pylab_helpers as pylab_helpers
3191             allnums = plt.get_fignums()
3192             num = max(allnums) + 1 if allnums else 1
3193             backend = plt._get_backend_mod()
3194             mgr = backend.new_figure_manager_given_figure(num, self)
3195             pylab_helpers.Gcf._set_new_active_manager(mgr)
3196             plt.draw_if_interactive()
3197 
3198         self.stale = True
3199 
3200     def add_axobserver(self, func):
3201         """Whenever the Axes state change, ``func(self)`` will be called."""
3202         # Connect a wrapper lambda and not func itself, to avoid it being
3203         # weakref-collected.
3204         self._axobservers.connect("_axes_change_event", lambda arg: func(arg))
3205 
3206     def savefig(self, fname, *, transparent=None, **kwargs):
3207         """
3208         Save the current figure.
3209 
3210         Call signature::
3211 
3212           savefig(fname, *, dpi='figure', format=None, metadata=None,
3213                   bbox_inches=None, pad_inches=0.1,
3214                   facecolor='auto', edgecolor='auto',
3215                   backend=None, **kwargs
3216                  )
3217 
3218         The available output formats depend on the backend being used.
3219 
3220         Parameters
3221         ----------
3222         fname : str or path-like or binary file-like
3223             A path, or a Python file-like object, or
3224             possibly some backend-dependent object such as
3225             `matplotlib.backends.backend_pdf.PdfPages`.
3226 
3227             If *format* is set, it determines the output format, and the file
3228             is saved as *fname*.  Note that *fname* is used verbatim, and there
3229             is no attempt to make the extension, if any, of *fname* match
3230             *format*, and no extension is appended.
3231 
3232             If *format* is not set, then the format is inferred from the
3233             extension of *fname*, if there is one.  If *format* is not
3234             set and *fname* has no extension, then the file is saved with
3235             :rc:`savefig.format` and the appropriate extension is appended to
3236             *fname*.
3237 
3238         Other Parameters
3239         ----------------
3240         dpi : float or 'figure', default: :rc:`savefig.dpi`
3241             The resolution in dots per inch.  If 'figure', use the figure's
3242             dpi value.
3243 
3244         format : str
3245             The file format, e.g. 'png', 'pdf', 'svg', ... The behavior when
3246             this is unset is documented under *fname*.
3247 
3248         metadata : dict, optional
3249             Key/value pairs to store in the image metadata. The supported keys
3250             and defaults depend on the image format and backend:
3251 
3252             - 'png' with Agg backend: See the parameter ``metadata`` of
3253               `~.FigureCanvasAgg.print_png`.
3254             - 'pdf' with pdf backend: See the parameter ``metadata`` of
3255               `~.backend_pdf.PdfPages`.
3256             - 'svg' with svg backend: See the parameter ``metadata`` of
3257               `~.FigureCanvasSVG.print_svg`.
3258             - 'eps' and 'ps' with PS backend: Only 'Creator' is supported.
3259 
3260             Not supported for 'pgf', 'raw', and 'rgba' as those formats do not support
3261             embedding metadata.
3262             Does not currently support 'jpg', 'tiff', or 'webp', but may include
3263             embedding EXIF metadata in the future.
3264 
3265         bbox_inches : str or `.Bbox`, default: :rc:`savefig.bbox`
3266             Bounding box in inches: only the given portion of the figure is
3267             saved.  If 'tight', try to figure out the tight bbox of the figure.
3268 
3269         pad_inches : float or 'layout', default: :rc:`savefig.pad_inches`
3270             Amount of padding in inches around the figure when bbox_inches is
3271             'tight'. If 'layout' use the padding from the constrained or
3272             compressed layout engine; ignored if one of those engines is not in
3273             use.
3274 
3275         facecolor : color or 'auto', default: :rc:`savefig.facecolor`
3276             The facecolor of the figure.  If 'auto', use the current figure
3277             facecolor.
3278 
3279         edgecolor : color or 'auto', default: :rc:`savefig.edgecolor`
3280             The edgecolor of the figure.  If 'auto', use the current figure
3281             edgecolor.
3282 
3283         backend : str, optional
3284             Use a non-default backend to render the file, e.g. to render a
3285             png file with the "cairo" backend rather than the default "agg",
3286             or a pdf file with the "pgf" backend rather than the default
3287             "pdf".  Note that the default backend is normally sufficient.  See
3288             :ref:`the-builtin-backends` for a list of valid backends for each
3289             file format.  Custom backends can be referenced as "module://...".
3290 
3291         orientation : {'landscape', 'portrait'}
3292             Currently only supported by the postscript backend.
3293 
3294         papertype : str
3295             One of 'letter', 'legal', 'executive', 'ledger', 'a0' through
3296             'a10', 'b0' through 'b10'. Only supported for postscript
3297             output.
3298 
3299         transparent : bool
3300             If *True*, the Axes patches will all be transparent; the
3301             Figure patch will also be transparent unless *facecolor*
3302             and/or *edgecolor* are specified via kwargs.
3303 
3304             If *False* has no effect and the color of the Axes and
3305             Figure patches are unchanged (unless the Figure patch
3306             is specified via the *facecolor* and/or *edgecolor* keyword
3307             arguments in which case those colors are used).
3308 
3309             The transparency of these patches will be restored to their
3310             original values upon exit of this function.
3311 
3312             This is useful, for example, for displaying
3313             a plot on top of a colored background on a web page.
3314 
3315         bbox_extra_artists : list of `~matplotlib.artist.Artist`, optional
3316             A list of extra artists that will be considered when the
3317             tight bbox is calculated.
3318 
3319         pil_kwargs : dict, optional
3320             Additional keyword arguments that are passed to
3321             `PIL.Image.Image.save` when saving the figure.
3322 
3323         """
3324 
3325         kwargs.setdefault('dpi', mpl.rcParams['savefig.dpi'])
3326         if transparent is None:
3327             transparent = mpl.rcParams['savefig.transparent']
3328 
3329         with ExitStack() as stack:
3330             if transparent:
3331                 def _recursively_make_subfig_transparent(exit_stack, subfig):
3332                     exit_stack.enter_context(
3333                         subfig.patch._cm_set(
3334                             facecolor="none", edgecolor="none"))
3335                     for ax in subfig.axes:
3336                         exit_stack.enter_context(
3337                             ax.patch._cm_set(
3338                                 facecolor="none", edgecolor="none"))
3339                     for sub_subfig in subfig.subfigs:
3340                         _recursively_make_subfig_transparent(
3341                             exit_stack, sub_subfig)
3342 
3343                 def _recursively_make_axes_transparent(exit_stack, ax):
3344                     exit_stack.enter_context(
3345                         ax.patch._cm_set(facecolor="none", edgecolor="none"))
3346                     for child_ax in ax.child_axes:
3347                         exit_stack.enter_context(
3348                             child_ax.patch._cm_set(
3349                                 facecolor="none", edgecolor="none"))
3350                     for child_childax in ax.child_axes:
3351                         _recursively_make_axes_transparent(
3352                             exit_stack, child_childax)
3353 
3354                 kwargs.setdefault('facecolor', 'none')
3355                 kwargs.setdefault('edgecolor', 'none')
3356                 # set subfigure to appear transparent in printed image
3357                 for subfig in self.subfigs:
3358                     _recursively_make_subfig_transparent(stack, subfig)
3359                 # set axes to be transparent
3360                 for ax in self.axes:
3361                     _recursively_make_axes_transparent(stack, ax)
3362             self.canvas.print_figure(fname, **kwargs)
3363 
3364     def ginput(self, n=1, timeout=30, show_clicks=True,
3365                mouse_add=MouseButton.LEFT,
3366                mouse_pop=MouseButton.RIGHT,
3367                mouse_stop=MouseButton.MIDDLE):
3368         """
3369         Blocking call to interact with a figure.
3370 
3371         Wait until the user clicks *n* times on the figure, and return the
3372         coordinates of each click in a list.
3373 
3374         There are three possible interactions:
3375 
3376         - Add a point.
3377         - Remove the most recently added point.
3378         - Stop the interaction and return the points added so far.
3379 
3380         The actions are assigned to mouse buttons via the arguments
3381         *mouse_add*, *mouse_pop* and *mouse_stop*.
3382 
3383         Parameters
3384         ----------
3385         n : int, default: 1
3386             Number of mouse clicks to accumulate. If negative, accumulate
3387             clicks until the input is terminated manually.
3388         timeout : float, default: 30 seconds
3389             Number of seconds to wait before timing out. If zero or negative
3390             will never time out.
3391         show_clicks : bool, default: True
3392             If True, show a red cross at the location of each click.
3393         mouse_add : `.MouseButton` or None, default: `.MouseButton.LEFT`
3394             Mouse button used to add points.
3395         mouse_pop : `.MouseButton` or None, default: `.MouseButton.RIGHT`
3396             Mouse button used to remove the most recently added point.
3397         mouse_stop : `.MouseButton` or None, default: `.MouseButton.MIDDLE`
3398             Mouse button used to stop input.
3399 
3400         Returns
3401         -------
3402         list of tuples
3403             A list of the clicked (x, y) coordinates.
3404 
3405         Notes
3406         -----
3407         The keyboard can also be used to select points in case your mouse
3408         does not have one or more of the buttons.  The delete and backspace
3409         keys act like right-clicking (i.e., remove last point), the enter key
3410         terminates input and any other key (not already used by the window
3411         manager) selects a point.
3412         """
3413         clicks = []
3414         marks = []
3415 
3416         def handler(event):
3417             is_button = event.name == "button_press_event"
3418             is_key = event.name == "key_press_event"
3419             # Quit (even if not in infinite mode; this is consistent with
3420             # MATLAB and sometimes quite useful, but will require the user to
3421             # test how many points were actually returned before using data).
3422             if (is_button and event.button == mouse_stop
3423                     or is_key and event.key in ["escape", "enter"]):
3424                 self.canvas.stop_event_loop()
3425             # Pop last click.
3426             elif (is_button and event.button == mouse_pop
3427                   or is_key and event.key in ["backspace", "delete"]):
3428                 if clicks:
3429                     clicks.pop()
3430                     if show_clicks:
3431                         marks.pop().remove()
3432                         self.canvas.draw()
3433             # Add new click.
3434             elif (is_button and event.button == mouse_add
3435                   # On macOS/gtk, some keys return None.
3436                   or is_key and event.key is not None):
3437                 if event.inaxes:
3438                     clicks.append((event.xdata, event.ydata))
3439                     _log.info("input %i: %f, %f",
3440                               len(clicks), event.xdata, event.ydata)
3441                     if show_clicks:
3442                         line = mpl.lines.Line2D([event.xdata], [event.ydata],
3443                                                 marker="+", color="r")
3444                         event.inaxes.add_line(line)
3445                         marks.append(line)
3446                         self.canvas.draw()
3447             if len(clicks) == n and n > 0:
3448                 self.canvas.stop_event_loop()
3449 
3450         _blocking_input.blocking_input_loop(
3451             self, ["button_press_event", "key_press_event"], timeout, handler)
3452 
3453         # Cleanup.
3454         for mark in marks:
3455             mark.remove()
3456         self.canvas.draw()
3457 
3458         return clicks
3459 
3460     def waitforbuttonpress(self, timeout=-1):
3461         """
3462         Blocking call to interact with the figure.
3463 
3464         Wait for user input and return True if a key was pressed, False if a
3465         mouse button was pressed and None if no input was given within
3466         *timeout* seconds.  Negative values deactivate *timeout*.
3467         """
3468         event = None
3469 
3470         def handler(ev):
3471             nonlocal event
3472             event = ev
3473             self.canvas.stop_event_loop()
3474 
3475         _blocking_input.blocking_input_loop(
3476             self, ["button_press_event", "key_press_event"], timeout, handler)
3477 
3478         return None if event is None else event.name == "key_press_event"
3479 
3480     def tight_layout(self, *, pad=1.08, h_pad=None, w_pad=None, rect=None):
3481         """
3482         Adjust the padding between and around subplots.
3483 
3484         To exclude an artist on the Axes from the bounding box calculation
3485         that determines the subplot parameters (i.e. legend, or annotation),
3486         set ``a.set_in_layout(False)`` for that artist.
3487 
3488         Parameters
3489         ----------
3490         pad : float, default: 1.08
3491             Padding between the figure edge and the edges of subplots,
3492             as a fraction of the font size.
3493         h_pad, w_pad : float, default: *pad*
3494             Padding (height/width) between edges of adjacent subplots,
3495             as a fraction of the font size.
3496         rect : tuple (left, bottom, right, top), default: (0, 0, 1, 1)
3497             A rectangle in normalized figure coordinates into which the whole
3498             subplots area (including labels) will fit.
3499 
3500         See Also
3501         --------
3502         .Figure.set_layout_engine
3503         .pyplot.tight_layout
3504         """
3505         # note that here we do not permanently set the figures engine to
3506         # tight_layout but rather just perform the layout in place and remove
3507         # any previous engines.
3508         engine = TightLayoutEngine(pad=pad, h_pad=h_pad, w_pad=w_pad,
3509                                    rect=rect)
3510         try:
3511             previous_engine = self.get_layout_engine()
3512             self.set_layout_engine(engine)
3513             engine.execute(self)
3514             if not isinstance(previous_engine, TightLayoutEngine) \
3515                     and previous_engine is not None:
3516                 _api.warn_external('The figure layout has changed to tight')
3517         finally:
3518             self.set_layout_engine(None)

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>]
2025-10-15 20:46:16.208 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-15 20:46:16.208 | INFO     | Search-only: skipping patch selection
2025-10-15 20:46:16.310 | INFO     | Task matplotlib__matplotlib-25624 completed successfully.
2025-10-15 20:46:16.311 | INFO     | No patch generated. You can try running ACR again.
