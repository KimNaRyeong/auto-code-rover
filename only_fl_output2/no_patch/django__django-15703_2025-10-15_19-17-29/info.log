2025-10-15 19:17:29.650 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-15 19:17:33.809 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=120, output_tokens=12, cost=0.001560
2025-10-15 19:17:33.810 | INFO     | Test agent decides that the issue statement does not contain reproduction steps; skipping reproducer tracing
2025-10-15 19:17:33.814 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 19:17:50.594 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=429, output_tokens=625, cost=0.023040
2025-10-15 19:17:50.605 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 19:17:52.979 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=979, output_tokens=64, cost=0.011710
2025-10-15 19:17:52.981 | DEBUG    | Extracted a valid json.
2025-10-15 19:17:52.981 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_code(\"index_together =\")",
        "search_code(\"indexes =\")",
        "search_code(\"class Meta:\")",
        "search_method(\"index_together\")",
        "search_method(\"indexes\")"
    ],
    "bug_locations": []
}
2025-10-15 19:17:53.122 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-15 19:17:53.122 | DEBUG    | <Agent search> Analyzing search results.
2025-10-15 19:18:15.373 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1898, output_tokens=920, cost=0.046580
2025-10-15 19:18:15.382 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 19:18:28.759 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3034, output_tokens=505, cost=0.045490
2025-10-15 19:18:28.770 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 19:18:39.284 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=859, output_tokens=423, cost=0.021280
2025-10-15 19:18:39.285 | DEBUG    | Extracted a valid json.
2025-10-15 19:18:39.292 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "django/db/models/options.py",
            "class": "",
            "method": "",
            "intended_behavior": "This file is where Django modelsâ€™ options are parsed and processed. The intended adjustment here is to either extend the current handling of `index_together` to ensure deprecation warnings are presented when it is used, signaling to developers to use `indexes` instead, or to transform `index_together` configurations into `indexes` within the Django ORM framework automatically. It should preserve the ability for Django to interpret model indexes for database schema creation and migrations without losing any existing functionalities or performance benefits."
        },
        {
            "file": "django/db/migrations/autodetector.py",
            "class": "",
            "method": "",
            "intended_behavior": "The automatic migration detection for model changes related to indexing should fully support `indexes` as the primary method for specifying indexes going forward. The intended behavior here is to deprecate the use of `index_together` in the migration autodetector logic by either warning users about its deprecation or automatically converting `index_together` definitions into `indexes`. The autodetection of index changes should continue to function seamlessly, detecting when indexes are added, removed, or altered and generating the appropriate migration files without manual intervention."
        },
        {
            "file": "django/db/backends/sqlite3/schema.py",
            "class": "",
            "method": "",
            "intended_behavior": "The SQLite backend's schema modification and creation logic need to be adjusted to prioritize `indexes` over `index_together`, ensuring that any SQL generated for index management is done through the explicit index objects provided via `indexes`. It should continue to allow Django to manage SQLite3 database schemas effectively, translating model index configurations into the correct SQL statements for index creation, deletion, and alteration, accommodating all features supported by the `indexes` option (such as expressions, conditionals, and name specification)."
        }
    ]
}
2025-10-15 19:18:39.308 | DEBUG    | Bug location extracted successfully: [<file>django/db/models/options.py</file>
<class>None</class>
<method>None</method>
<code>
1 import bisect
2 import copy
3 import inspect
4 from collections import defaultdict
5 
6 from django.apps import apps
7 from django.conf import settings
8 from django.core.exceptions import FieldDoesNotExist, ImproperlyConfigured
9 from django.db import connections
10 from django.db.models import AutoField, Manager, OrderWrt, UniqueConstraint
11 from django.db.models.query_utils import PathInfo
12 from django.utils.datastructures import ImmutableList, OrderedSet
13 from django.utils.functional import cached_property
14 from django.utils.module_loading import import_string
15 from django.utils.text import camel_case_to_spaces, format_lazy
16 from django.utils.translation import override
17 
18 PROXY_PARENTS = object()
19 
20 EMPTY_RELATION_TREE = ()
21 
22 IMMUTABLE_WARNING = (
23     "The return type of '%s' should never be mutated. If you want to manipulate this "
24     "list for your own use, make a copy first."
25 )
26 
27 DEFAULT_NAMES = (
28     "verbose_name",
29     "verbose_name_plural",
30     "db_table",
31     "ordering",
32     "unique_together",
33     "permissions",
34     "get_latest_by",
35     "order_with_respect_to",
36     "app_label",
37     "db_tablespace",
38     "abstract",
39     "managed",
40     "proxy",
41     "swappable",
42     "auto_created",
43     "index_together",
44     "apps",
45     "default_permissions",
46     "select_on_save",
47     "default_related_name",
48     "required_db_features",
49     "required_db_vendor",
50     "base_manager_name",
51     "default_manager_name",
52     "indexes",
53     "constraints",
54 )
55 
56 
57 def normalize_together(option_together):
58     """
59     option_together can be either a tuple of tuples, or a single
60     tuple of two strings. Normalize it to a tuple of tuples, so that
61     calling code can uniformly expect that.
62     """
63     try:
64         if not option_together:
65             return ()
66         if not isinstance(option_together, (tuple, list)):
67             raise TypeError
68         first_element = option_together[0]
69         if not isinstance(first_element, (tuple, list)):
70             option_together = (option_together,)
71         # Normalize everything to tuples
72         return tuple(tuple(ot) for ot in option_together)
73     except TypeError:
74         # If the value of option_together isn't valid, return it
75         # verbatim; this will be picked up by the check framework later.
76         return option_together
77 
78 
79 def make_immutable_fields_list(name, data):
80     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
81 
82 
83 class Options:
84     FORWARD_PROPERTIES = {
85         "fields",
86         "many_to_many",
87         "concrete_fields",
88         "local_concrete_fields",
89         "_forward_fields_map",
90         "managers",
91         "managers_map",
92         "base_manager",
93         "default_manager",
94     }
95     REVERSE_PROPERTIES = {"related_objects", "fields_map", "_relation_tree"}
96 
97     default_apps = apps
98 
99     def __init__(self, meta, app_label=None):
100         self._get_fields_cache = {}
101         self.local_fields = []
102         self.local_many_to_many = []
103         self.private_fields = []
104         self.local_managers = []
105         self.base_manager_name = None
106         self.default_manager_name = None
107         self.model_name = None
108         self.verbose_name = None
109         self.verbose_name_plural = None
110         self.db_table = ""
111         self.ordering = []
112         self._ordering_clash = False
113         self.indexes = []
114         self.constraints = []
115         self.unique_together = []
116         self.index_together = []
117         self.select_on_save = False
118         self.default_permissions = ("add", "change", "delete", "view")
119         self.permissions = []
120         self.object_name = None
121         self.app_label = app_label
122         self.get_latest_by = None
123         self.order_with_respect_to = None
124         self.db_tablespace = settings.DEFAULT_TABLESPACE
125         self.required_db_features = []
126         self.required_db_vendor = None
127         self.meta = meta
128         self.pk = None
129         self.auto_field = None
130         self.abstract = False
131         self.managed = True
132         self.proxy = False
133         # For any class that is a proxy (including automatically created
134         # classes for deferred object loading), proxy_for_model tells us
135         # which class this model is proxying. Note that proxy_for_model
136         # can create a chain of proxy models. For non-proxy models, the
137         # variable is always None.
138         self.proxy_for_model = None
139         # For any non-abstract class, the concrete class is the model
140         # in the end of the proxy_for_model chain. In particular, for
141         # concrete models, the concrete_model is always the class itself.
142         self.concrete_model = None
143         self.swappable = None
144         self.parents = {}
145         self.auto_created = False
146 
147         # List of all lookups defined in ForeignKey 'limit_choices_to' options
148         # from *other* models. Needed for some admin checks. Internal use only.
149         self.related_fkey_lookups = []
150 
151         # A custom app registry to use, if you're making a separate model set.
152         self.apps = self.default_apps
153 
154         self.default_related_name = None
155 
156     @property
157     def label(self):
158         return "%s.%s" % (self.app_label, self.object_name)
159 
160     @property
161     def label_lower(self):
162         return "%s.%s" % (self.app_label, self.model_name)
163 
164     @property
165     def app_config(self):
166         # Don't go through get_app_config to avoid triggering imports.
167         return self.apps.app_configs.get(self.app_label)
168 
169     def contribute_to_class(self, cls, name):
170         from django.db import connection
171         from django.db.backends.utils import truncate_name
172 
173         cls._meta = self
174         self.model = cls
175         # First, construct the default values for these options.
176         self.object_name = cls.__name__
177         self.model_name = self.object_name.lower()
178         self.verbose_name = camel_case_to_spaces(self.object_name)
179 
180         # Store the original user-defined values for each option,
181         # for use when serializing the model definition
182         self.original_attrs = {}
183 
184         # Next, apply any overridden values from 'class Meta'.
185         if self.meta:
186             meta_attrs = self.meta.__dict__.copy()
187             for name in self.meta.__dict__:
188                 # Ignore any private attributes that Django doesn't care about.
189                 # NOTE: We can't modify a dictionary's contents while looping
190                 # over it, so we loop over the *original* dictionary instead.
191                 if name.startswith("_"):
192                     del meta_attrs[name]
193             for attr_name in DEFAULT_NAMES:
194                 if attr_name in meta_attrs:
195                     setattr(self, attr_name, meta_attrs.pop(attr_name))
196                     self.original_attrs[attr_name] = getattr(self, attr_name)
197                 elif hasattr(self.meta, attr_name):
198                     setattr(self, attr_name, getattr(self.meta, attr_name))
199                     self.original_attrs[attr_name] = getattr(self, attr_name)
200 
201             self.unique_together = normalize_together(self.unique_together)
202             self.index_together = normalize_together(self.index_together)
203             # App label/class name interpolation for names of constraints and
204             # indexes.
205             if not getattr(cls._meta, "abstract", False):
206                 for attr_name in {"constraints", "indexes"}:
207                     objs = getattr(self, attr_name, [])
208                     setattr(self, attr_name, self._format_names_with_class(cls, objs))
209 
210             # verbose_name_plural is a special case because it uses a 's'
211             # by default.
212             if self.verbose_name_plural is None:
213                 self.verbose_name_plural = format_lazy("{}s", self.verbose_name)
214 
215             # order_with_respect_and ordering are mutually exclusive.
216             self._ordering_clash = bool(self.ordering and self.order_with_respect_to)
217 
218             # Any leftover attributes must be invalid.
219             if meta_attrs != {}:
220                 raise TypeError(
221                     "'class Meta' got invalid attribute(s): %s" % ",".join(meta_attrs)
222                 )
223         else:
224             self.verbose_name_plural = format_lazy("{}s", self.verbose_name)
225         del self.meta
226 
227         # If the db_table wasn't provided, use the app_label + model_name.
228         if not self.db_table:
229             self.db_table = "%s_%s" % (self.app_label, self.model_name)
230             self.db_table = truncate_name(
231                 self.db_table, connection.ops.max_name_length()
232             )
233 
234     def _format_names_with_class(self, cls, objs):
235         """App label/class name interpolation for object names."""
236         new_objs = []
237         for obj in objs:
238             obj = obj.clone()
239             obj.name = obj.name % {
240                 "app_label": cls._meta.app_label.lower(),
241                 "class": cls.__name__.lower(),
242             }
243             new_objs.append(obj)
244         return new_objs
245 
246     def _get_default_pk_class(self):
247         pk_class_path = getattr(
248             self.app_config,
249             "default_auto_field",
250             settings.DEFAULT_AUTO_FIELD,
251         )
252         if self.app_config and self.app_config._is_default_auto_field_overridden:
253             app_config_class = type(self.app_config)
254             source = (
255                 f"{app_config_class.__module__}."
256                 f"{app_config_class.__qualname__}.default_auto_field"
257             )
258         else:
259             source = "DEFAULT_AUTO_FIELD"
260         if not pk_class_path:
261             raise ImproperlyConfigured(f"{source} must not be empty.")
262         try:
263             pk_class = import_string(pk_class_path)
264         except ImportError as e:
265             msg = (
266                 f"{source} refers to the module '{pk_class_path}' that could "
267                 f"not be imported."
268             )
269             raise ImproperlyConfigured(msg) from e
270         if not issubclass(pk_class, AutoField):
271             raise ValueError(
272                 f"Primary key '{pk_class_path}' referred by {source} must "
273                 f"subclass AutoField."
274             )
275         return pk_class
276 
277     def _prepare(self, model):
278         if self.order_with_respect_to:
279             # The app registry will not be ready at this point, so we cannot
280             # use get_field().
281             query = self.order_with_respect_to
282             try:
283                 self.order_with_respect_to = next(
284                     f
285                     for f in self._get_fields(reverse=False)
286                     if f.name == query or f.attname == query
287                 )
288             except StopIteration:
289                 raise FieldDoesNotExist(
290                     "%s has no field named '%s'" % (self.object_name, query)
291                 )
292 
293             self.ordering = ("_order",)
294             if not any(
295                 isinstance(field, OrderWrt) for field in model._meta.local_fields
296             ):
297                 model.add_to_class("_order", OrderWrt())
298         else:
299             self.order_with_respect_to = None
300 
301         if self.pk is None:
302             if self.parents:
303                 # Promote the first parent link in lieu of adding yet another
304                 # field.
305                 field = next(iter(self.parents.values()))
306                 # Look for a local field with the same name as the
307                 # first parent link. If a local field has already been
308                 # created, use it instead of promoting the parent
309                 already_created = [
310                     fld for fld in self.local_fields if fld.name == field.name
311                 ]
312                 if already_created:
313                     field = already_created[0]
314                 field.primary_key = True
315                 self.setup_pk(field)
316             else:
317                 pk_class = self._get_default_pk_class()
318                 auto = pk_class(verbose_name="ID", primary_key=True, auto_created=True)
319                 model.add_to_class("id", auto)
320 
321     def add_manager(self, manager):
322         self.local_managers.append(manager)
323         self._expire_cache()
324 
325     def add_field(self, field, private=False):
326         # Insert the given field in the order in which it was created, using
327         # the "creation_counter" attribute of the field.
328         # Move many-to-many related fields from self.fields into
329         # self.many_to_many.
330         if private:
331             self.private_fields.append(field)
332         elif field.is_relation and field.many_to_many:
333             bisect.insort(self.local_many_to_many, field)
334         else:
335             bisect.insort(self.local_fields, field)
336             self.setup_pk(field)
337 
338         # If the field being added is a relation to another known field,
339         # expire the cache on this field and the forward cache on the field
340         # being referenced, because there will be new relationships in the
341         # cache. Otherwise, expire the cache of references *to* this field.
342         # The mechanism for getting at the related model is slightly odd -
343         # ideally, we'd just ask for field.related_model. However, related_model
344         # is a cached property, and all the models haven't been loaded yet, so
345         # we need to make sure we don't cache a string reference.
346         if (
347             field.is_relation
348             and hasattr(field.remote_field, "model")
349             and field.remote_field.model
350         ):
351             try:
352                 field.remote_field.model._meta._expire_cache(forward=False)
353             except AttributeError:
354                 pass
355             self._expire_cache()
356         else:
357             self._expire_cache(reverse=False)
358 
359     def setup_pk(self, field):
360         if not self.pk and field.primary_key:
361             self.pk = field
362             field.serialize = False
363 
364     def setup_proxy(self, target):
365         """
366         Do the internal setup so that the current model is a proxy for
367         "target".
368         """
369         self.pk = target._meta.pk
370         self.proxy_for_model = target
371         self.db_table = target._meta.db_table
372 
373     def __repr__(self):
374         return "<Options for %s>" % self.object_name
375 
376     def __str__(self):
377         return self.label_lower
378 
379     def can_migrate(self, connection):
380         """
381         Return True if the model can/should be migrated on the `connection`.
382         `connection` can be either a real connection or a connection alias.
383         """
384         if self.proxy or self.swapped or not self.managed:
385             return False
386         if isinstance(connection, str):
387             connection = connections[connection]
388         if self.required_db_vendor:
389             return self.required_db_vendor == connection.vendor
390         if self.required_db_features:
391             return all(
392                 getattr(connection.features, feat, False)
393                 for feat in self.required_db_features
394             )
395         return True
396 
397     @property
398     def verbose_name_raw(self):
399         """Return the untranslated verbose name."""
400         with override(None):
401             return str(self.verbose_name)
402 
403     @property
404     def swapped(self):
405         """
406         Has this model been swapped out for another? If so, return the model
407         name of the replacement; otherwise, return None.
408 
409         For historical reasons, model name lookups using get_model() are
410         case insensitive, so we make sure we are case insensitive here.
411         """
412         if self.swappable:
413             swapped_for = getattr(settings, self.swappable, None)
414             if swapped_for:
415                 try:
416                     swapped_label, swapped_object = swapped_for.split(".")
417                 except ValueError:
418                     # setting not in the format app_label.model_name
419                     # raising ImproperlyConfigured here causes problems with
420                     # test cleanup code - instead it is raised in get_user_model
421                     # or as part of validation.
422                     return swapped_for
423 
424                 if (
425                     "%s.%s" % (swapped_label, swapped_object.lower())
426                     != self.label_lower
427                 ):
428                     return swapped_for
429         return None
430 
431     @cached_property
432     def managers(self):
433         managers = []
434         seen_managers = set()
435         bases = (b for b in self.model.mro() if hasattr(b, "_meta"))
436         for depth, base in enumerate(bases):
437             for manager in base._meta.local_managers:
438                 if manager.name in seen_managers:
439                     continue
440 
441                 manager = copy.copy(manager)
442                 manager.model = self.model
443                 seen_managers.add(manager.name)
444                 managers.append((depth, manager.creation_counter, manager))
445 
446         return make_immutable_fields_list(
447             "managers",
448             (m[2] for m in sorted(managers)),
449         )
450 
451     @cached_property
452     def managers_map(self):
453         return {manager.name: manager for manager in self.managers}
454 
455     @cached_property
456     def base_manager(self):
457         base_manager_name = self.base_manager_name
458         if not base_manager_name:
459             # Get the first parent's base_manager_name if there's one.
460             for parent in self.model.mro()[1:]:
461                 if hasattr(parent, "_meta"):
462                     if parent._base_manager.name != "_base_manager":
463                         base_manager_name = parent._base_manager.name
464                     break
465 
466         if base_manager_name:
467             try:
468                 return self.managers_map[base_manager_name]
469             except KeyError:
470                 raise ValueError(
471                     "%s has no manager named %r"
472                     % (
473                         self.object_name,
474                         base_manager_name,
475                     )
476                 )
477 
478         manager = Manager()
479         manager.name = "_base_manager"
480         manager.model = self.model
481         manager.auto_created = True
482         return manager
483 
484     @cached_property
485     def default_manager(self):
486         default_manager_name = self.default_manager_name
487         if not default_manager_name and not self.local_managers:
488             # Get the first parent's default_manager_name if there's one.
489             for parent in self.model.mro()[1:]:
490                 if hasattr(parent, "_meta"):
491                     default_manager_name = parent._meta.default_manager_name
492                     break
493 
494         if default_manager_name:
495             try:
496                 return self.managers_map[default_manager_name]
497             except KeyError:
498                 raise ValueError(
499                     "%s has no manager named %r"
500                     % (
501                         self.object_name,
502                         default_manager_name,
503                     )
504                 )
505 
506         if self.managers:
507             return self.managers[0]
508 
509     @cached_property
510     def fields(self):
511         """
512         Return a list of all forward fields on the model and its parents,
513         excluding ManyToManyFields.
514 
515         Private API intended only to be used by Django itself; get_fields()
516         combined with filtering of field properties is the public API for
517         obtaining this field list.
518         """
519         # For legacy reasons, the fields property should only contain forward
520         # fields that are not private or with a m2m cardinality. Therefore we
521         # pass these three filters as filters to the generator.
522         # The third lambda is a longwinded way of checking f.related_model - we don't
523         # use that property directly because related_model is a cached property,
524         # and all the models may not have been loaded yet; we don't want to cache
525         # the string reference to the related_model.
526         def is_not_an_m2m_field(f):
527             return not (f.is_relation and f.many_to_many)
528 
529         def is_not_a_generic_relation(f):
530             return not (f.is_relation and f.one_to_many)
531 
532         def is_not_a_generic_foreign_key(f):
533             return not (
534                 f.is_relation
535                 and f.many_to_one
536                 and not (hasattr(f.remote_field, "model") and f.remote_field.model)
537             )
538 
539         return make_immutable_fields_list(
540             "fields",
541             (
542                 f
543                 for f in self._get_fields(reverse=False)
544                 if is_not_an_m2m_field(f)
545                 and is_not_a_generic_relation(f)
546                 and is_not_a_generic_foreign_key(f)
547             ),
548         )
549 
550     @cached_property
551     def concrete_fields(self):
552         """
553         Return a list of all concrete fields on the model and its parents.
554 
555         Private API intended only to be used by Django itself; get_fields()
556         combined with filtering of field properties is the public API for
557         obtaining this field list.
558         """
559         return make_immutable_fields_list(
560             "concrete_fields", (f for f in self.fields if f.concrete)
561         )
562 
563     @cached_property
564     def local_concrete_fields(self):
565         """
566         Return a list of all concrete fields on the model.
567 
568         Private API intended only to be used by Django itself; get_fields()
569         combined with filtering of field properties is the public API for
570         obtaining this field list.
571         """
572         return make_immutable_fields_list(
573             "local_concrete_fields", (f for f in self.local_fields if f.concrete)
574         )
575 
576     @cached_property
577     def many_to_many(self):
578         """
579         Return a list of all many to many fields on the model and its parents.
580 
581         Private API intended only to be used by Django itself; get_fields()
582         combined with filtering of field properties is the public API for
583         obtaining this list.
584         """
585         return make_immutable_fields_list(
586             "many_to_many",
587             (
588                 f
589                 for f in self._get_fields(reverse=False)
590                 if f.is_relation and f.many_to_many
591             ),
592         )
593 
594     @cached_property
595     def related_objects(self):
596         """
597         Return all related objects pointing to the current model. The related
598         objects can come from a one-to-one, one-to-many, or many-to-many field
599         relation type.
600 
601         Private API intended only to be used by Django itself; get_fields()
602         combined with filtering of field properties is the public API for
603         obtaining this field list.
604         """
605         all_related_fields = self._get_fields(
606             forward=False, reverse=True, include_hidden=True
607         )
608         return make_immutable_fields_list(
609             "related_objects",
610             (
611                 obj
612                 for obj in all_related_fields
613                 if not obj.hidden or obj.field.many_to_many
614             ),
615         )
616 
617     @cached_property
618     def _forward_fields_map(self):
619         res = {}
620         fields = self._get_fields(reverse=False)
621         for field in fields:
622             res[field.name] = field
623             # Due to the way Django's internals work, get_field() should also
624             # be able to fetch a field by attname. In the case of a concrete
625             # field with relation, includes the *_id name too
626             try:
627                 res[field.attname] = field
628             except AttributeError:
629                 pass
630         return res
631 
632     @cached_property
633     def fields_map(self):
634         res = {}
635         fields = self._get_fields(forward=False, include_hidden=True)
636         for field in fields:
637             res[field.name] = field
638             # Due to the way Django's internals work, get_field() should also
639             # be able to fetch a field by attname. In the case of a concrete
640             # field with relation, includes the *_id name too
641             try:
642                 res[field.attname] = field
643             except AttributeError:
644                 pass
645         return res
646 
647     def get_field(self, field_name):
648         """
649         Return a field instance given the name of a forward or reverse field.
650         """
651         try:
652             # In order to avoid premature loading of the relation tree
653             # (expensive) we prefer checking if the field is a forward field.
654             return self._forward_fields_map[field_name]
655         except KeyError:
656             # If the app registry is not ready, reverse fields are
657             # unavailable, therefore we throw a FieldDoesNotExist exception.
658             if not self.apps.models_ready:
659                 raise FieldDoesNotExist(
660                     "%s has no field named '%s'. The app cache isn't ready yet, "
661                     "so if this is an auto-created related field, it won't "
662                     "be available yet." % (self.object_name, field_name)
663                 )
664 
665         try:
666             # Retrieve field instance by name from cached or just-computed
667             # field map.
668             return self.fields_map[field_name]
669         except KeyError:
670             raise FieldDoesNotExist(
671                 "%s has no field named '%s'" % (self.object_name, field_name)
672             )
673 
674     def get_base_chain(self, model):
675         """
676         Return a list of parent classes leading to `model` (ordered from
677         closest to most distant ancestor). This has to handle the case where
678         `model` is a grandparent or even more distant relation.
679         """
680         if not self.parents:
681             return []
682         if model in self.parents:
683             return [model]
684         for parent in self.parents:
685             res = parent._meta.get_base_chain(model)
686             if res:
687                 res.insert(0, parent)
688                 return res
689         return []
690 
691     def get_parent_list(self):
692         """
693         Return all the ancestors of this model as a list ordered by MRO.
694         Useful for determining if something is an ancestor, regardless of lineage.
695         """
696         result = OrderedSet(self.parents)
697         for parent in self.parents:
698             for ancestor in parent._meta.get_parent_list():
699                 result.add(ancestor)
700         return list(result)
701 
702     def get_ancestor_link(self, ancestor):
703         """
704         Return the field on the current model which points to the given
705         "ancestor". This is possible an indirect link (a pointer to a parent
706         model, which points, eventually, to the ancestor). Used when
707         constructing table joins for model inheritance.
708 
709         Return None if the model isn't an ancestor of this one.
710         """
711         if ancestor in self.parents:
712             return self.parents[ancestor]
713         for parent in self.parents:
714             # Tries to get a link field from the immediate parent
715             parent_link = parent._meta.get_ancestor_link(ancestor)
716             if parent_link:
717                 # In case of a proxied model, the first link
718                 # of the chain to the ancestor is that parent
719                 # links
720                 return self.parents[parent] or parent_link
721 
722     def get_path_to_parent(self, parent):
723         """
724         Return a list of PathInfos containing the path from the current
725         model to the parent model, or an empty list if parent is not a
726         parent of the current model.
727         """
728         if self.model is parent:
729             return []
730         # Skip the chain of proxy to the concrete proxied model.
731         proxied_model = self.concrete_model
732         path = []
733         opts = self
734         for int_model in self.get_base_chain(parent):
735             if int_model is proxied_model:
736                 opts = int_model._meta
737             else:
738                 final_field = opts.parents[int_model]
739                 targets = (final_field.remote_field.get_related_field(),)
740                 opts = int_model._meta
741                 path.append(
742                     PathInfo(
743                         from_opts=final_field.model._meta,
744                         to_opts=opts,
745                         target_fields=targets,
746                         join_field=final_field,
747                         m2m=False,
748                         direct=True,
749                         filtered_relation=None,
750                     )
751                 )
752         return path
753 
754     def get_path_from_parent(self, parent):
755         """
756         Return a list of PathInfos containing the path from the parent
757         model to the current model, or an empty list if parent is not a
758         parent of the current model.
759         """
760         if self.model is parent:
761             return []
762         model = self.concrete_model
763         # Get a reversed base chain including both the current and parent
764         # models.
765         chain = model._meta.get_base_chain(parent)
766         chain.reverse()
767         chain.append(model)
768         # Construct a list of the PathInfos between models in chain.
769         path = []
770         for i, ancestor in enumerate(chain[:-1]):
771             child = chain[i + 1]
772             link = child._meta.get_ancestor_link(ancestor)
773             path.extend(link.reverse_path_infos)
774         return path
775 
776     def _populate_directed_relation_graph(self):
777         """
778         This method is used by each model to find its reverse objects. As this
779         method is very expensive and is accessed frequently (it looks up every
780         field in a model, in every app), it is computed on first access and then
781         is set as a property on every model.
782         """
783         related_objects_graph = defaultdict(list)
784 
785         all_models = self.apps.get_models(include_auto_created=True)
786         for model in all_models:
787             opts = model._meta
788             # Abstract model's fields are copied to child models, hence we will
789             # see the fields from the child models.
790             if opts.abstract:
791                 continue
792             fields_with_relations = (
793                 f
794                 for f in opts._get_fields(reverse=False, include_parents=False)
795                 if f.is_relation and f.related_model is not None
796             )
797             for f in fields_with_relations:
798                 if not isinstance(f.remote_field.model, str):
799                     remote_label = f.remote_field.model._meta.concrete_model._meta.label
800                     related_objects_graph[remote_label].append(f)
801 
802         for model in all_models:
803             # Set the relation_tree using the internal __dict__. In this way
804             # we avoid calling the cached property. In attribute lookup,
805             # __dict__ takes precedence over a data descriptor (such as
806             # @cached_property). This means that the _meta._relation_tree is
807             # only called if related_objects is not in __dict__.
808             related_objects = related_objects_graph[
809                 model._meta.concrete_model._meta.label
810             ]
811             model._meta.__dict__["_relation_tree"] = related_objects
812         # It seems it is possible that self is not in all_models, so guard
813         # against that with default for get().
814         return self.__dict__.get("_relation_tree", EMPTY_RELATION_TREE)
815 
816     @cached_property
817     def _relation_tree(self):
818         return self._populate_directed_relation_graph()
819 
820     def _expire_cache(self, forward=True, reverse=True):
821         # This method is usually called by apps.cache_clear(), when the
822         # registry is finalized, or when a new field is added.
823         if forward:
824             for cache_key in self.FORWARD_PROPERTIES:
825                 if cache_key in self.__dict__:
826                     delattr(self, cache_key)
827         if reverse and not self.abstract:
828             for cache_key in self.REVERSE_PROPERTIES:
829                 if cache_key in self.__dict__:
830                     delattr(self, cache_key)
831         self._get_fields_cache = {}
832 
833     def get_fields(self, include_parents=True, include_hidden=False):
834         """
835         Return a list of fields associated to the model. By default, include
836         forward and reverse fields, fields derived from inheritance, but not
837         hidden fields. The returned fields can be changed using the parameters:
838 
839         - include_parents: include fields derived from inheritance
840         - include_hidden:  include fields that have a related_name that
841                            starts with a "+"
842         """
843         if include_parents is False:
844             include_parents = PROXY_PARENTS
845         return self._get_fields(
846             include_parents=include_parents, include_hidden=include_hidden
847         )
848 
849     def _get_fields(
850         self,
851         forward=True,
852         reverse=True,
853         include_parents=True,
854         include_hidden=False,
855         seen_models=None,
856     ):
857         """
858         Internal helper function to return fields of the model.
859         * If forward=True, then fields defined on this model are returned.
860         * If reverse=True, then relations pointing to this model are returned.
861         * If include_hidden=True, then fields with is_hidden=True are returned.
862         * The include_parents argument toggles if fields from parent models
863           should be included. It has three values: True, False, and
864           PROXY_PARENTS. When set to PROXY_PARENTS, the call will return all
865           fields defined for the current model or any of its parents in the
866           parent chain to the model's concrete model.
867         """
868         if include_parents not in (True, False, PROXY_PARENTS):
869             raise TypeError(
870                 "Invalid argument for include_parents: %s" % (include_parents,)
871             )
872         # This helper function is used to allow recursion in ``get_fields()``
873         # implementation and to provide a fast way for Django's internals to
874         # access specific subsets of fields.
875 
876         # We must keep track of which models we have already seen. Otherwise we
877         # could include the same field multiple times from different models.
878         topmost_call = seen_models is None
879         if topmost_call:
880             seen_models = set()
881         seen_models.add(self.model)
882 
883         # Creates a cache key composed of all arguments
884         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
885 
886         try:
887             # In order to avoid list manipulation. Always return a shallow copy
888             # of the results.
889             return self._get_fields_cache[cache_key]
890         except KeyError:
891             pass
892 
893         fields = []
894         # Recursively call _get_fields() on each parent, with the same
895         # options provided in this call.
896         if include_parents is not False:
897             for parent in self.parents:
898                 # In diamond inheritance it is possible that we see the same
899                 # model from two different routes. In that case, avoid adding
900                 # fields from the same parent again.
901                 if parent in seen_models:
902                     continue
903                 if (
904                     parent._meta.concrete_model != self.concrete_model
905                     and include_parents == PROXY_PARENTS
906                 ):
907                     continue
908                 for obj in parent._meta._get_fields(
909                     forward=forward,
910                     reverse=reverse,
911                     include_parents=include_parents,
912                     include_hidden=include_hidden,
913                     seen_models=seen_models,
914                 ):
915                     if (
916                         not getattr(obj, "parent_link", False)
917                         or obj.model == self.concrete_model
918                     ):
919                         fields.append(obj)
920         if reverse and not self.proxy:
921             # Tree is computed once and cached until the app cache is expired.
922             # It is composed of a list of fields pointing to the current model
923             # from other models.
924             all_fields = self._relation_tree
925             for field in all_fields:
926                 # If hidden fields should be included or the relation is not
927                 # intentionally hidden, add to the fields dict.
928                 if include_hidden or not field.remote_field.hidden:
929                     fields.append(field.remote_field)
930 
931         if forward:
932             fields += self.local_fields
933             fields += self.local_many_to_many
934             # Private fields are recopied to each child model, and they get a
935             # different model as field.model in each child. Hence we have to
936             # add the private fields separately from the topmost call. If we
937             # did this recursively similar to local_fields, we would get field
938             # instances with field.model != self.model.
939             if topmost_call:
940                 fields += self.private_fields
941 
942         # In order to avoid list manipulation. Always
943         # return a shallow copy of the results
944         fields = make_immutable_fields_list("get_fields()", fields)
945 
946         # Store result into cache for later access
947         self._get_fields_cache[cache_key] = fields
948         return fields
949 
950     @cached_property
951     def total_unique_constraints(self):
952         """
953         Return a list of total unique constraints. Useful for determining set
954         of fields guaranteed to be unique for all rows.
955         """
956         return [
957             constraint
958             for constraint in self.constraints
959             if (
960                 isinstance(constraint, UniqueConstraint)
961                 and constraint.condition is None
962                 and not constraint.contains_expressions
963             )
964         ]
965 
966     @cached_property
967     def _property_names(self):
968         """Return a set of the names of the properties defined on the model."""
969         names = []
970         for name in dir(self.model):
971             attr = inspect.getattr_static(self.model, name)
972             if isinstance(attr, property):
973                 names.append(name)
974         return frozenset(names)
975 
976     @cached_property
977     def db_returning_fields(self):
978         """
979         Private API intended only to be used by Django itself.
980         Fields to be returned after a database insert.
981         """
982         return [
983             field
984             for field in self._get_fields(
985                 forward=True, reverse=False, include_parents=PROXY_PARENTS
986             )
987             if getattr(field, "db_returning", False)
988         ]

</code><intended_behavior>This file is where Django modelsâ€™ options are parsed and processed. The intended adjustment here is to either extend the current handling of `index_together` to ensure deprecation warnings are presented when it is used, signaling to developers to use `indexes` instead, or to transform `index_together` configurations into `indexes` within the Django ORM framework automatically. It should preserve the ability for Django to interpret model indexes for database schema creation and migrations without losing any existing functionalities or performance benefits.</intended_behavior>, <file>django/db/migrations/autodetector.py</file>
<class>None</class>
<method>None</method>
<code>
1 import functools
2 import re
3 from collections import defaultdict
4 from itertools import chain
5 
6 from django.conf import settings
7 from django.db import models
8 from django.db.migrations import operations
9 from django.db.migrations.migration import Migration
10 from django.db.migrations.operations.models import AlterModelOptions
11 from django.db.migrations.optimizer import MigrationOptimizer
12 from django.db.migrations.questioner import MigrationQuestioner
13 from django.db.migrations.utils import (
14     COMPILED_REGEX_TYPE,
15     RegexObject,
16     resolve_relation,
17 )
18 from django.utils.topological_sort import stable_topological_sort
19 
20 
21 class MigrationAutodetector:
22     """
23     Take a pair of ProjectStates and compare them to see what the first would
24     need doing to make it match the second (the second usually being the
25     project's current state).
26 
27     Note that this naturally operates on entire projects at a time,
28     as it's likely that changes interact (for example, you can't
29     add a ForeignKey without having a migration to add the table it
30     depends on first). A user interface may offer single-app usage
31     if it wishes, with the caveat that it may not always be possible.
32     """
33 
34     def __init__(self, from_state, to_state, questioner=None):
35         self.from_state = from_state
36         self.to_state = to_state
37         self.questioner = questioner or MigrationQuestioner()
38         self.existing_apps = {app for app, model in from_state.models}
39 
40     def changes(self, graph, trim_to_apps=None, convert_apps=None, migration_name=None):
41         """
42         Main entry point to produce a list of applicable changes.
43         Take a graph to base names on and an optional set of apps
44         to try and restrict to (restriction is not guaranteed)
45         """
46         changes = self._detect_changes(convert_apps, graph)
47         changes = self.arrange_for_graph(changes, graph, migration_name)
48         if trim_to_apps:
49             changes = self._trim_to_apps(changes, trim_to_apps)
50         return changes
51 
52     def deep_deconstruct(self, obj):
53         """
54         Recursive deconstruction for a field and its arguments.
55         Used for full comparison for rename/alter; sometimes a single-level
56         deconstruction will not compare correctly.
57         """
58         if isinstance(obj, list):
59             return [self.deep_deconstruct(value) for value in obj]
60         elif isinstance(obj, tuple):
61             return tuple(self.deep_deconstruct(value) for value in obj)
62         elif isinstance(obj, dict):
63             return {key: self.deep_deconstruct(value) for key, value in obj.items()}
64         elif isinstance(obj, functools.partial):
65             return (
66                 obj.func,
67                 self.deep_deconstruct(obj.args),
68                 self.deep_deconstruct(obj.keywords),
69             )
70         elif isinstance(obj, COMPILED_REGEX_TYPE):
71             return RegexObject(obj)
72         elif isinstance(obj, type):
73             # If this is a type that implements 'deconstruct' as an instance method,
74             # avoid treating this as being deconstructible itself - see #22951
75             return obj
76         elif hasattr(obj, "deconstruct"):
77             deconstructed = obj.deconstruct()
78             if isinstance(obj, models.Field):
79                 # we have a field which also returns a name
80                 deconstructed = deconstructed[1:]
81             path, args, kwargs = deconstructed
82             return (
83                 path,
84                 [self.deep_deconstruct(value) for value in args],
85                 {key: self.deep_deconstruct(value) for key, value in kwargs.items()},
86             )
87         else:
88             return obj
89 
90     def only_relation_agnostic_fields(self, fields):
91         """
92         Return a definition of the fields that ignores field names and
93         what related fields actually relate to. Used for detecting renames (as
94         the related fields change during renames).
95         """
96         fields_def = []
97         for name, field in sorted(fields.items()):
98             deconstruction = self.deep_deconstruct(field)
99             if field.remote_field and field.remote_field.model:
100                 deconstruction[2].pop("to", None)
101             fields_def.append(deconstruction)
102         return fields_def
103 
104     def _detect_changes(self, convert_apps=None, graph=None):
105         """
106         Return a dict of migration plans which will achieve the
107         change from from_state to to_state. The dict has app labels
108         as keys and a list of migrations as values.
109 
110         The resulting migrations aren't specially named, but the names
111         do matter for dependencies inside the set.
112 
113         convert_apps is the list of apps to convert to use migrations
114         (i.e. to make initial migrations for, in the usual case)
115 
116         graph is an optional argument that, if provided, can help improve
117         dependency generation and avoid potential circular dependencies.
118         """
119         # The first phase is generating all the operations for each app
120         # and gathering them into a big per-app list.
121         # Then go through that list, order it, and split into migrations to
122         # resolve dependencies caused by M2Ms and FKs.
123         self.generated_operations = {}
124         self.altered_indexes = {}
125         self.altered_constraints = {}
126         self.renamed_fields = {}
127 
128         # Prepare some old/new state and model lists, separating
129         # proxy models and ignoring unmigrated apps.
130         self.old_model_keys = set()
131         self.old_proxy_keys = set()
132         self.old_unmanaged_keys = set()
133         self.new_model_keys = set()
134         self.new_proxy_keys = set()
135         self.new_unmanaged_keys = set()
136         for (app_label, model_name), model_state in self.from_state.models.items():
137             if not model_state.options.get("managed", True):
138                 self.old_unmanaged_keys.add((app_label, model_name))
139             elif app_label not in self.from_state.real_apps:
140                 if model_state.options.get("proxy"):
141                     self.old_proxy_keys.add((app_label, model_name))
142                 else:
143                     self.old_model_keys.add((app_label, model_name))
144 
145         for (app_label, model_name), model_state in self.to_state.models.items():
146             if not model_state.options.get("managed", True):
147                 self.new_unmanaged_keys.add((app_label, model_name))
148             elif app_label not in self.from_state.real_apps or (
149                 convert_apps and app_label in convert_apps
150             ):
151                 if model_state.options.get("proxy"):
152                     self.new_proxy_keys.add((app_label, model_name))
153                 else:
154                     self.new_model_keys.add((app_label, model_name))
155 
156         self.from_state.resolve_fields_and_relations()
157         self.to_state.resolve_fields_and_relations()
158 
159         # Renames have to come first
160         self.generate_renamed_models()
161 
162         # Prepare lists of fields and generate through model map
163         self._prepare_field_lists()
164         self._generate_through_model_map()
165 
166         # Generate non-rename model operations
167         self.generate_deleted_models()
168         self.generate_created_models()
169         self.generate_deleted_proxies()
170         self.generate_created_proxies()
171         self.generate_altered_options()
172         self.generate_altered_managers()
173 
174         # Create the renamed fields and store them in self.renamed_fields.
175         # They are used by create_altered_indexes(), generate_altered_fields(),
176         # generate_removed_altered_index/unique_together(), and
177         # generate_altered_index/unique_together().
178         self.create_renamed_fields()
179         # Create the altered indexes and store them in self.altered_indexes.
180         # This avoids the same computation in generate_removed_indexes()
181         # and generate_added_indexes().
182         self.create_altered_indexes()
183         self.create_altered_constraints()
184         # Generate index removal operations before field is removed
185         self.generate_removed_constraints()
186         self.generate_removed_indexes()
187         # Generate field renaming operations.
188         self.generate_renamed_fields()
189         self.generate_renamed_indexes()
190         # Generate removal of foo together.
191         self.generate_removed_altered_unique_together()
192         self.generate_removed_altered_index_together()
193         # Generate field operations.
194         self.generate_removed_fields()
195         self.generate_added_fields()
196         self.generate_altered_fields()
197         self.generate_altered_order_with_respect_to()
198         self.generate_altered_unique_together()
199         self.generate_altered_index_together()
200         self.generate_added_indexes()
201         self.generate_added_constraints()
202         self.generate_altered_db_table()
203 
204         self._sort_migrations()
205         self._build_migration_list(graph)
206         self._optimize_migrations()
207 
208         return self.migrations
209 
210     def _prepare_field_lists(self):
211         """
212         Prepare field lists and a list of the fields that used through models
213         in the old state so dependencies can be made from the through model
214         deletion to the field that uses it.
215         """
216         self.kept_model_keys = self.old_model_keys & self.new_model_keys
217         self.kept_proxy_keys = self.old_proxy_keys & self.new_proxy_keys
218         self.kept_unmanaged_keys = self.old_unmanaged_keys & self.new_unmanaged_keys
219         self.through_users = {}
220         self.old_field_keys = {
221             (app_label, model_name, field_name)
222             for app_label, model_name in self.kept_model_keys
223             for field_name in self.from_state.models[
224                 app_label, self.renamed_models.get((app_label, model_name), model_name)
225             ].fields
226         }
227         self.new_field_keys = {
228             (app_label, model_name, field_name)
229             for app_label, model_name in self.kept_model_keys
230             for field_name in self.to_state.models[app_label, model_name].fields
231         }
232 
233     def _generate_through_model_map(self):
234         """Through model map generation."""
235         for app_label, model_name in sorted(self.old_model_keys):
236             old_model_name = self.renamed_models.get(
237                 (app_label, model_name), model_name
238             )
239             old_model_state = self.from_state.models[app_label, old_model_name]
240             for field_name, field in old_model_state.fields.items():
241                 if hasattr(field, "remote_field") and getattr(
242                     field.remote_field, "through", None
243                 ):
244                     through_key = resolve_relation(
245                         field.remote_field.through, app_label, model_name
246                     )
247                     self.through_users[through_key] = (
248                         app_label,
249                         old_model_name,
250                         field_name,
251                     )
252 
253     @staticmethod
254     def _resolve_dependency(dependency):
255         """
256         Return the resolved dependency and a boolean denoting whether or not
257         it was swappable.
258         """
259         if dependency[0] != "__setting__":
260             return dependency, False
261         resolved_app_label, resolved_object_name = getattr(
262             settings, dependency[1]
263         ).split(".")
264         return (resolved_app_label, resolved_object_name.lower()) + dependency[2:], True
265 
266     def _build_migration_list(self, graph=None):
267         """
268         Chop the lists of operations up into migrations with dependencies on
269         each other. Do this by going through an app's list of operations until
270         one is found that has an outgoing dependency that isn't in another
271         app's migration yet (hasn't been chopped off its list). Then chop off
272         the operations before it into a migration and move onto the next app.
273         If the loops completes without doing anything, there's a circular
274         dependency (which _should_ be impossible as the operations are
275         all split at this point so they can't depend and be depended on).
276         """
277         self.migrations = {}
278         num_ops = sum(len(x) for x in self.generated_operations.values())
279         chop_mode = False
280         while num_ops:
281             # On every iteration, we step through all the apps and see if there
282             # is a completed set of operations.
283             # If we find that a subset of the operations are complete we can
284             # try to chop it off from the rest and continue, but we only
285             # do this if we've already been through the list once before
286             # without any chopping and nothing has changed.
287             for app_label in sorted(self.generated_operations):
288                 chopped = []
289                 dependencies = set()
290                 for operation in list(self.generated_operations[app_label]):
291                     deps_satisfied = True
292                     operation_dependencies = set()
293                     for dep in operation._auto_deps:
294                         # Temporarily resolve the swappable dependency to
295                         # prevent circular references. While keeping the
296                         # dependency checks on the resolved model, add the
297                         # swappable dependencies.
298                         original_dep = dep
299                         dep, is_swappable_dep = self._resolve_dependency(dep)
300                         if dep[0] != app_label:
301                             # External app dependency. See if it's not yet
302                             # satisfied.
303                             for other_operation in self.generated_operations.get(
304                                 dep[0], []
305                             ):
306                                 if self.check_dependency(other_operation, dep):
307                                     deps_satisfied = False
308                                     break
309                             if not deps_satisfied:
310                                 break
311                             else:
312                                 if is_swappable_dep:
313                                     operation_dependencies.add(
314                                         (original_dep[0], original_dep[1])
315                                     )
316                                 elif dep[0] in self.migrations:
317                                     operation_dependencies.add(
318                                         (dep[0], self.migrations[dep[0]][-1].name)
319                                     )
320                                 else:
321                                     # If we can't find the other app, we add a
322                                     # first/last dependency, but only if we've
323                                     # already been through once and checked
324                                     # everything.
325                                     if chop_mode:
326                                         # If the app already exists, we add a
327                                         # dependency on the last migration, as
328                                         # we don't know which migration
329                                         # contains the target field. If it's
330                                         # not yet migrated or has no
331                                         # migrations, we use __first__.
332                                         if graph and graph.leaf_nodes(dep[0]):
333                                             operation_dependencies.add(
334                                                 graph.leaf_nodes(dep[0])[0]
335                                             )
336                                         else:
337                                             operation_dependencies.add(
338                                                 (dep[0], "__first__")
339                                             )
340                                     else:
341                                         deps_satisfied = False
342                     if deps_satisfied:
343                         chopped.append(operation)
344                         dependencies.update(operation_dependencies)
345                         del self.generated_operations[app_label][0]
346                     else:
347                         break
348                 # Make a migration! Well, only if there's stuff to put in it
349                 if dependencies or chopped:
350                     if not self.generated_operations[app_label] or chop_mode:
351                         subclass = type(
352                             "Migration",
353                             (Migration,),
354                             {"operations": [], "dependencies": []},
355                         )
356                         instance = subclass(
357                             "auto_%i" % (len(self.migrations.get(app_label, [])) + 1),
358                             app_label,
359                         )
360                         instance.dependencies = list(dependencies)
361                         instance.operations = chopped
362                         instance.initial = app_label not in self.existing_apps
363                         self.migrations.setdefault(app_label, []).append(instance)
364                         chop_mode = False
365                     else:
366                         self.generated_operations[app_label] = (
367                             chopped + self.generated_operations[app_label]
368                         )
369             new_num_ops = sum(len(x) for x in self.generated_operations.values())
370             if new_num_ops == num_ops:
371                 if not chop_mode:
372                     chop_mode = True
373                 else:
374                     raise ValueError(
375                         "Cannot resolve operation dependencies: %r"
376                         % self.generated_operations
377                     )
378             num_ops = new_num_ops
379 
380     def _sort_migrations(self):
381         """
382         Reorder to make things possible. Reordering may be needed so FKs work
383         nicely inside the same app.
384         """
385         for app_label, ops in sorted(self.generated_operations.items()):
386             # construct a dependency graph for intra-app dependencies
387             dependency_graph = {op: set() for op in ops}
388             for op in ops:
389                 for dep in op._auto_deps:
390                     # Resolve intra-app dependencies to handle circular
391                     # references involving a swappable model.
392                     dep = self._resolve_dependency(dep)[0]
393                     if dep[0] == app_label:
394                         for op2 in ops:
395                             if self.check_dependency(op2, dep):
396                                 dependency_graph[op].add(op2)
397 
398             # we use a stable sort for deterministic tests & general behavior
399             self.generated_operations[app_label] = stable_topological_sort(
400                 ops, dependency_graph
401             )
402 
403     def _optimize_migrations(self):
404         # Add in internal dependencies among the migrations
405         for app_label, migrations in self.migrations.items():
406             for m1, m2 in zip(migrations, migrations[1:]):
407                 m2.dependencies.append((app_label, m1.name))
408 
409         # De-dupe dependencies
410         for migrations in self.migrations.values():
411             for migration in migrations:
412                 migration.dependencies = list(set(migration.dependencies))
413 
414         # Optimize migrations
415         for app_label, migrations in self.migrations.items():
416             for migration in migrations:
417                 migration.operations = MigrationOptimizer().optimize(
418                     migration.operations, app_label
419                 )
420 
421     def check_dependency(self, operation, dependency):
422         """
423         Return True if the given operation depends on the given dependency,
424         False otherwise.
425         """
426         # Created model
427         if dependency[2] is None and dependency[3] is True:
428             return (
429                 isinstance(operation, operations.CreateModel)
430                 and operation.name_lower == dependency[1].lower()
431             )
432         # Created field
433         elif dependency[2] is not None and dependency[3] is True:
434             return (
435                 isinstance(operation, operations.CreateModel)
436                 and operation.name_lower == dependency[1].lower()
437                 and any(dependency[2] == x for x, y in operation.fields)
438             ) or (
439                 isinstance(operation, operations.AddField)
440                 and operation.model_name_lower == dependency[1].lower()
441                 and operation.name_lower == dependency[2].lower()
442             )
443         # Removed field
444         elif dependency[2] is not None and dependency[3] is False:
445             return (
446                 isinstance(operation, operations.RemoveField)
447                 and operation.model_name_lower == dependency[1].lower()
448                 and operation.name_lower == dependency[2].lower()
449             )
450         # Removed model
451         elif dependency[2] is None and dependency[3] is False:
452             return (
453                 isinstance(operation, operations.DeleteModel)
454                 and operation.name_lower == dependency[1].lower()
455             )
456         # Field being altered
457         elif dependency[2] is not None and dependency[3] == "alter":
458             return (
459                 isinstance(operation, operations.AlterField)
460                 and operation.model_name_lower == dependency[1].lower()
461                 and operation.name_lower == dependency[2].lower()
462             )
463         # order_with_respect_to being unset for a field
464         elif dependency[2] is not None and dependency[3] == "order_wrt_unset":
465             return (
466                 isinstance(operation, operations.AlterOrderWithRespectTo)
467                 and operation.name_lower == dependency[1].lower()
468                 and (operation.order_with_respect_to or "").lower()
469                 != dependency[2].lower()
470             )
471         # Field is removed and part of an index/unique_together
472         elif dependency[2] is not None and dependency[3] == "foo_together_change":
473             return (
474                 isinstance(
475                     operation,
476                     (operations.AlterUniqueTogether, operations.AlterIndexTogether),
477                 )
478                 and operation.name_lower == dependency[1].lower()
479             )
480         # Unknown dependency. Raise an error.
481         else:
482             raise ValueError("Can't handle dependency %r" % (dependency,))
483 
484     def add_operation(self, app_label, operation, dependencies=None, beginning=False):
485         # Dependencies are
486         # (app_label, model_name, field_name, create/delete as True/False)
487         operation._auto_deps = dependencies or []
488         if beginning:
489             self.generated_operations.setdefault(app_label, []).insert(0, operation)
490         else:
491             self.generated_operations.setdefault(app_label, []).append(operation)
492 
493     def swappable_first_key(self, item):
494         """
495         Place potential swappable models first in lists of created models (only
496         real way to solve #22783).
497         """
498         try:
499             model_state = self.to_state.models[item]
500             base_names = {
501                 base if isinstance(base, str) else base.__name__
502                 for base in model_state.bases
503             }
504             string_version = "%s.%s" % (item[0], item[1])
505             if (
506                 model_state.options.get("swappable")
507                 or "AbstractUser" in base_names
508                 or "AbstractBaseUser" in base_names
509                 or settings.AUTH_USER_MODEL.lower() == string_version.lower()
510             ):
511                 return ("___" + item[0], "___" + item[1])
512         except LookupError:
513             pass
514         return item
515 
516     def generate_renamed_models(self):
517         """
518         Find any renamed models, generate the operations for them, and remove
519         the old entry from the model lists. Must be run before other
520         model-level generation.
521         """
522         self.renamed_models = {}
523         self.renamed_models_rel = {}
524         added_models = self.new_model_keys - self.old_model_keys
525         for app_label, model_name in sorted(added_models):
526             model_state = self.to_state.models[app_label, model_name]
527             model_fields_def = self.only_relation_agnostic_fields(model_state.fields)
528 
529             removed_models = self.old_model_keys - self.new_model_keys
530             for rem_app_label, rem_model_name in removed_models:
531                 if rem_app_label == app_label:
532                     rem_model_state = self.from_state.models[
533                         rem_app_label, rem_model_name
534                     ]
535                     rem_model_fields_def = self.only_relation_agnostic_fields(
536                         rem_model_state.fields
537                     )
538                     if model_fields_def == rem_model_fields_def:
539                         if self.questioner.ask_rename_model(
540                             rem_model_state, model_state
541                         ):
542                             dependencies = []
543                             fields = list(model_state.fields.values()) + [
544                                 field.remote_field
545                                 for relations in self.to_state.relations[
546                                     app_label, model_name
547                                 ].values()
548                                 for field in relations.values()
549                             ]
550                             for field in fields:
551                                 if field.is_relation:
552                                     dependencies.extend(
553                                         self._get_dependencies_for_foreign_key(
554                                             app_label,
555                                             model_name,
556                                             field,
557                                             self.to_state,
558                                         )
559                                     )
560                             self.add_operation(
561                                 app_label,
562                                 operations.RenameModel(
563                                     old_name=rem_model_state.name,
564                                     new_name=model_state.name,
565                                 ),
566                                 dependencies=dependencies,
567                             )
568                             self.renamed_models[app_label, model_name] = rem_model_name
569                             renamed_models_rel_key = "%s.%s" % (
570                                 rem_model_state.app_label,
571                                 rem_model_state.name_lower,
572                             )
573                             self.renamed_models_rel[
574                                 renamed_models_rel_key
575                             ] = "%s.%s" % (
576                                 model_state.app_label,
577                                 model_state.name_lower,
578                             )
579                             self.old_model_keys.remove((rem_app_label, rem_model_name))
580                             self.old_model_keys.add((app_label, model_name))
581                             break
582 
583     def generate_created_models(self):
584         """
585         Find all new models (both managed and unmanaged) and make create
586         operations for them as well as separate operations to create any
587         foreign key or M2M relationships (these are optimized later, if
588         possible).
589 
590         Defer any model options that refer to collections of fields that might
591         be deferred (e.g. unique_together, index_together).
592         """
593         old_keys = self.old_model_keys | self.old_unmanaged_keys
594         added_models = self.new_model_keys - old_keys
595         added_unmanaged_models = self.new_unmanaged_keys - old_keys
596         all_added_models = chain(
597             sorted(added_models, key=self.swappable_first_key, reverse=True),
598             sorted(added_unmanaged_models, key=self.swappable_first_key, reverse=True),
599         )
600         for app_label, model_name in all_added_models:
601             model_state = self.to_state.models[app_label, model_name]
602             # Gather related fields
603             related_fields = {}
604             primary_key_rel = None
605             for field_name, field in model_state.fields.items():
606                 if field.remote_field:
607                     if field.remote_field.model:
608                         if field.primary_key:
609                             primary_key_rel = field.remote_field.model
610                         elif not field.remote_field.parent_link:
611                             related_fields[field_name] = field
612                     if getattr(field.remote_field, "through", None):
613                         related_fields[field_name] = field
614 
615             # Are there indexes/unique|index_together to defer?
616             indexes = model_state.options.pop("indexes")
617             constraints = model_state.options.pop("constraints")
618             unique_together = model_state.options.pop("unique_together", None)
619             index_together = model_state.options.pop("index_together", None)
620             order_with_respect_to = model_state.options.pop(
621                 "order_with_respect_to", None
622             )
623             # Depend on the deletion of any possible proxy version of us
624             dependencies = [
625                 (app_label, model_name, None, False),
626             ]
627             # Depend on all bases
628             for base in model_state.bases:
629                 if isinstance(base, str) and "." in base:
630                     base_app_label, base_name = base.split(".", 1)
631                     dependencies.append((base_app_label, base_name, None, True))
632                     # Depend on the removal of base fields if the new model has
633                     # a field with the same name.
634                     old_base_model_state = self.from_state.models.get(
635                         (base_app_label, base_name)
636                     )
637                     new_base_model_state = self.to_state.models.get(
638                         (base_app_label, base_name)
639                     )
640                     if old_base_model_state and new_base_model_state:
641                         removed_base_fields = (
642                             set(old_base_model_state.fields)
643                             .difference(
644                                 new_base_model_state.fields,
645                             )
646                             .intersection(model_state.fields)
647                         )
648                         for removed_base_field in removed_base_fields:
649                             dependencies.append(
650                                 (base_app_label, base_name, removed_base_field, False)
651                             )
652             # Depend on the other end of the primary key if it's a relation
653             if primary_key_rel:
654                 dependencies.append(
655                     resolve_relation(
656                         primary_key_rel,
657                         app_label,
658                         model_name,
659                     )
660                     + (None, True)
661                 )
662             # Generate creation operation
663             self.add_operation(
664                 app_label,
665                 operations.CreateModel(
666                     name=model_state.name,
667                     fields=[
668                         d
669                         for d in model_state.fields.items()
670                         if d[0] not in related_fields
671                     ],
672                     options=model_state.options,
673                     bases=model_state.bases,
674                     managers=model_state.managers,
675                 ),
676                 dependencies=dependencies,
677                 beginning=True,
678             )
679 
680             # Don't add operations which modify the database for unmanaged models
681             if not model_state.options.get("managed", True):
682                 continue
683 
684             # Generate operations for each related field
685             for name, field in sorted(related_fields.items()):
686                 dependencies = self._get_dependencies_for_foreign_key(
687                     app_label,
688                     model_name,
689                     field,
690                     self.to_state,
691                 )
692                 # Depend on our own model being created
693                 dependencies.append((app_label, model_name, None, True))
694                 # Make operation
695                 self.add_operation(
696                     app_label,
697                     operations.AddField(
698                         model_name=model_name,
699                         name=name,
700                         field=field,
701                     ),
702                     dependencies=list(set(dependencies)),
703                 )
704             # Generate other opns
705             if order_with_respect_to:
706                 self.add_operation(
707                     app_label,
708                     operations.AlterOrderWithRespectTo(
709                         name=model_name,
710                         order_with_respect_to=order_with_respect_to,
711                     ),
712                     dependencies=[
713                         (app_label, model_name, order_with_respect_to, True),
714                         (app_label, model_name, None, True),
715                     ],
716                 )
717             related_dependencies = [
718                 (app_label, model_name, name, True) for name in sorted(related_fields)
719             ]
720             related_dependencies.append((app_label, model_name, None, True))
721             for index in indexes:
722                 self.add_operation(
723                     app_label,
724                     operations.AddIndex(
725                         model_name=model_name,
726                         index=index,
727                     ),
728                     dependencies=related_dependencies,
729                 )
730             for constraint in constraints:
731                 self.add_operation(
732                     app_label,
733                     operations.AddConstraint(
734                         model_name=model_name,
735                         constraint=constraint,
736                     ),
737                     dependencies=related_dependencies,
738                 )
739             if unique_together:
740                 self.add_operation(
741                     app_label,
742                     operations.AlterUniqueTogether(
743                         name=model_name,
744                         unique_together=unique_together,
745                     ),
746                     dependencies=related_dependencies,
747                 )
748             if index_together:
749                 self.add_operation(
750                     app_label,
751                     operations.AlterIndexTogether(
752                         name=model_name,
753                         index_together=index_together,
754                     ),
755                     dependencies=related_dependencies,
756                 )
757             # Fix relationships if the model changed from a proxy model to a
758             # concrete model.
759             relations = self.to_state.relations
760             if (app_label, model_name) in self.old_proxy_keys:
761                 for related_model_key, related_fields in relations[
762                     app_label, model_name
763                 ].items():
764                     related_model_state = self.to_state.models[related_model_key]
765                     for related_field_name, related_field in related_fields.items():
766                         self.add_operation(
767                             related_model_state.app_label,
768                             operations.AlterField(
769                                 model_name=related_model_state.name,
770                                 name=related_field_name,
771                                 field=related_field,
772                             ),
773                             dependencies=[(app_label, model_name, None, True)],
774                         )
775 
776     def generate_created_proxies(self):
777         """
778         Make CreateModel statements for proxy models. Use the same statements
779         as that way there's less code duplication, but for proxy models it's
780         safe to skip all the pointless field stuff and chuck out an operation.
781         """
782         added = self.new_proxy_keys - self.old_proxy_keys
783         for app_label, model_name in sorted(added):
784             model_state = self.to_state.models[app_label, model_name]
785             assert model_state.options.get("proxy")
786             # Depend on the deletion of any possible non-proxy version of us
787             dependencies = [
788                 (app_label, model_name, None, False),
789             ]
790             # Depend on all bases
791             for base in model_state.bases:
792                 if isinstance(base, str) and "." in base:
793                     base_app_label, base_name = base.split(".", 1)
794                     dependencies.append((base_app_label, base_name, None, True))
795             # Generate creation operation
796             self.add_operation(
797                 app_label,
798                 operations.CreateModel(
799                     name=model_state.name,
800                     fields=[],
801                     options=model_state.options,
802                     bases=model_state.bases,
803                     managers=model_state.managers,
804                 ),
805                 # Depend on the deletion of any possible non-proxy version of us
806                 dependencies=dependencies,
807             )
808 
809     def generate_deleted_models(self):
810         """
811         Find all deleted models (managed and unmanaged) and make delete
812         operations for them as well as separate operations to delete any
813         foreign key or M2M relationships (these are optimized later, if
814         possible).
815 
816         Also bring forward removal of any model options that refer to
817         collections of fields - the inverse of generate_created_models().
818         """
819         new_keys = self.new_model_keys | self.new_unmanaged_keys
820         deleted_models = self.old_model_keys - new_keys
821         deleted_unmanaged_models = self.old_unmanaged_keys - new_keys
822         all_deleted_models = chain(
823             sorted(deleted_models), sorted(deleted_unmanaged_models)
824         )
825         for app_label, model_name in all_deleted_models:
826             model_state = self.from_state.models[app_label, model_name]
827             # Gather related fields
828             related_fields = {}
829             for field_name, field in model_state.fields.items():
830                 if field.remote_field:
831                     if field.remote_field.model:
832                         related_fields[field_name] = field
833                     if getattr(field.remote_field, "through", None):
834                         related_fields[field_name] = field
835             # Generate option removal first
836             unique_together = model_state.options.pop("unique_together", None)
837             index_together = model_state.options.pop("index_together", None)
838             if unique_together:
839                 self.add_operation(
840                     app_label,
841                     operations.AlterUniqueTogether(
842                         name=model_name,
843                         unique_together=None,
844                     ),
845                 )
846             if index_together:
847                 self.add_operation(
848                     app_label,
849                     operations.AlterIndexTogether(
850                         name=model_name,
851                         index_together=None,
852                     ),
853                 )
854             # Then remove each related field
855             for name in sorted(related_fields):
856                 self.add_operation(
857                     app_label,
858                     operations.RemoveField(
859                         model_name=model_name,
860                         name=name,
861                     ),
862                 )
863             # Finally, remove the model.
864             # This depends on both the removal/alteration of all incoming fields
865             # and the removal of all its own related fields, and if it's
866             # a through model the field that references it.
867             dependencies = []
868             relations = self.from_state.relations
869             for (
870                 related_object_app_label,
871                 object_name,
872             ), relation_related_fields in relations[app_label, model_name].items():
873                 for field_name, field in relation_related_fields.items():
874                     dependencies.append(
875                         (related_object_app_label, object_name, field_name, False),
876                     )
877                     if not field.many_to_many:
878                         dependencies.append(
879                             (
880                                 related_object_app_label,
881                                 object_name,
882                                 field_name,
883                                 "alter",
884                             ),
885                         )
886 
887             for name in sorted(related_fields):
888                 dependencies.append((app_label, model_name, name, False))
889             # We're referenced in another field's through=
890             through_user = self.through_users.get((app_label, model_state.name_lower))
891             if through_user:
892                 dependencies.append(
893                     (through_user[0], through_user[1], through_user[2], False)
894                 )
895             # Finally, make the operation, deduping any dependencies
896             self.add_operation(
897                 app_label,
898                 operations.DeleteModel(
899                     name=model_state.name,
900                 ),
901                 dependencies=list(set(dependencies)),
902             )
903 
904     def generate_deleted_proxies(self):
905         """Make DeleteModel options for proxy models."""
906         deleted = self.old_proxy_keys - self.new_proxy_keys
907         for app_label, model_name in sorted(deleted):
908             model_state = self.from_state.models[app_label, model_name]
909             assert model_state.options.get("proxy")
910             self.add_operation(
911                 app_label,
912                 operations.DeleteModel(
913                     name=model_state.name,
914                 ),
915             )
916 
917     def create_renamed_fields(self):
918         """Work out renamed fields."""
919         self.renamed_operations = []
920         old_field_keys = self.old_field_keys.copy()
921         for app_label, model_name, field_name in sorted(
922             self.new_field_keys - old_field_keys
923         ):
924             old_model_name = self.renamed_models.get(
925                 (app_label, model_name), model_name
926             )
927             old_model_state = self.from_state.models[app_label, old_model_name]
928             new_model_state = self.to_state.models[app_label, model_name]
929             field = new_model_state.get_field(field_name)
930             # Scan to see if this is actually a rename!
931             field_dec = self.deep_deconstruct(field)
932             for rem_app_label, rem_model_name, rem_field_name in sorted(
933                 old_field_keys - self.new_field_keys
934             ):
935                 if rem_app_label == app_label and rem_model_name == model_name:
936                     old_field = old_model_state.get_field(rem_field_name)
937                     old_field_dec = self.deep_deconstruct(old_field)
938                     if (
939                         field.remote_field
940                         and field.remote_field.model
941                         and "to" in old_field_dec[2]
942                     ):
943                         old_rel_to = old_field_dec[2]["to"]
944                         if old_rel_to in self.renamed_models_rel:
945                             old_field_dec[2]["to"] = self.renamed_models_rel[old_rel_to]
946                     old_field.set_attributes_from_name(rem_field_name)
947                     old_db_column = old_field.get_attname_column()[1]
948                     if old_field_dec == field_dec or (
949                         # Was the field renamed and db_column equal to the
950                         # old field's column added?
951                         old_field_dec[0:2] == field_dec[0:2]
952                         and dict(old_field_dec[2], db_column=old_db_column)
953                         == field_dec[2]
954                     ):
955                         if self.questioner.ask_rename(
956                             model_name, rem_field_name, field_name, field
957                         ):
958                             self.renamed_operations.append(
959                                 (
960                                     rem_app_label,
961                                     rem_model_name,
962                                     old_field.db_column,
963                                     rem_field_name,
964                                     app_label,
965                                     model_name,
966                                     field,
967                                     field_name,
968                                 )
969                             )
970                             old_field_keys.remove(
971                                 (rem_app_label, rem_model_name, rem_field_name)
972                             )
973                             old_field_keys.add((app_label, model_name, field_name))
974                             self.renamed_fields[
975                                 app_label, model_name, field_name
976                             ] = rem_field_name
977                             break
978 
979     def generate_renamed_fields(self):
980         """Generate RenameField operations."""
981         for (
982             rem_app_label,
983             rem_model_name,
984             rem_db_column,
985             rem_field_name,
986             app_label,
987             model_name,
988             field,
989             field_name,
990         ) in self.renamed_operations:
991             # A db_column mismatch requires a prior noop AlterField for the
992             # subsequent RenameField to be a noop on attempts at preserving the
993             # old name.
994             if rem_db_column != field.db_column:
995                 altered_field = field.clone()
996                 altered_field.name = rem_field_name
997                 self.add_operation(
998                     app_label,
999                     operations.AlterField(
1000                         model_name=model_name,
1001                         name=rem_field_name,
1002                         field=altered_field,
1003                     ),
1004                 )
1005             self.add_operation(
1006                 app_label,
1007                 operations.RenameField(
1008                     model_name=model_name,
1009                     old_name=rem_field_name,
1010                     new_name=field_name,
1011                 ),
1012             )
1013             self.old_field_keys.remove((rem_app_label, rem_model_name, rem_field_name))
1014             self.old_field_keys.add((app_label, model_name, field_name))
1015 
1016     def generate_added_fields(self):
1017         """Make AddField operations."""
1018         for app_label, model_name, field_name in sorted(
1019             self.new_field_keys - self.old_field_keys
1020         ):
1021             self._generate_added_field(app_label, model_name, field_name)
1022 
1023     def _generate_added_field(self, app_label, model_name, field_name):
1024         field = self.to_state.models[app_label, model_name].get_field(field_name)
1025         # Adding a field always depends at least on its removal.
1026         dependencies = [(app_label, model_name, field_name, False)]
1027         # Fields that are foreignkeys/m2ms depend on stuff.
1028         if field.remote_field and field.remote_field.model:
1029             dependencies.extend(
1030                 self._get_dependencies_for_foreign_key(
1031                     app_label,
1032                     model_name,
1033                     field,
1034                     self.to_state,
1035                 )
1036             )
1037         # You can't just add NOT NULL fields with no default or fields
1038         # which don't allow empty strings as default.
1039         time_fields = (models.DateField, models.DateTimeField, models.TimeField)
1040         preserve_default = (
1041             field.null
1042             or field.has_default()
1043             or field.many_to_many
1044             or (field.blank and field.empty_strings_allowed)
1045             or (isinstance(field, time_fields) and field.auto_now)
1046         )
1047         if not preserve_default:
1048             field = field.clone()
1049             if isinstance(field, time_fields) and field.auto_now_add:
1050                 field.default = self.questioner.ask_auto_now_add_addition(
1051                     field_name, model_name
1052                 )
1053             else:
1054                 field.default = self.questioner.ask_not_null_addition(
1055                     field_name, model_name
1056                 )
1057         if (
1058             field.unique
1059             and field.default is not models.NOT_PROVIDED
1060             and callable(field.default)
1061         ):
1062             self.questioner.ask_unique_callable_default_addition(field_name, model_name)
1063         self.add_operation(
1064             app_label,
1065             operations.AddField(
1066                 model_name=model_name,
1067                 name=field_name,
1068                 field=field,
1069                 preserve_default=preserve_default,
1070             ),
1071             dependencies=dependencies,
1072         )
1073 
1074     def generate_removed_fields(self):
1075         """Make RemoveField operations."""
1076         for app_label, model_name, field_name in sorted(
1077             self.old_field_keys - self.new_field_keys
1078         ):
1079             self._generate_removed_field(app_label, model_name, field_name)
1080 
1081     def _generate_removed_field(self, app_label, model_name, field_name):
1082         self.add_operation(
1083             app_label,
1084             operations.RemoveField(
1085                 model_name=model_name,
1086                 name=field_name,
1087             ),
1088             # We might need to depend on the removal of an
1089             # order_with_respect_to or index/unique_together operation;
1090             # this is safely ignored if there isn't one
1091             dependencies=[
1092                 (app_label, model_name, field_name, "order_wrt_unset"),
1093                 (app_label, model_name, field_name, "foo_together_change"),
1094             ],
1095         )
1096 
1097     def generate_altered_fields(self):
1098         """
1099         Make AlterField operations, or possibly RemovedField/AddField if alter
1100         isn't possible.
1101         """
1102         for app_label, model_name, field_name in sorted(
1103             self.old_field_keys & self.new_field_keys
1104         ):
1105             # Did the field change?
1106             old_model_name = self.renamed_models.get(
1107                 (app_label, model_name), model_name
1108             )
1109             old_field_name = self.renamed_fields.get(
1110                 (app_label, model_name, field_name), field_name
1111             )
1112             old_field = self.from_state.models[app_label, old_model_name].get_field(
1113                 old_field_name
1114             )
1115             new_field = self.to_state.models[app_label, model_name].get_field(
1116                 field_name
1117             )
1118             dependencies = []
1119             # Implement any model renames on relations; these are handled by RenameModel
1120             # so we need to exclude them from the comparison
1121             if hasattr(new_field, "remote_field") and getattr(
1122                 new_field.remote_field, "model", None
1123             ):
1124                 rename_key = resolve_relation(
1125                     new_field.remote_field.model, app_label, model_name
1126                 )
1127                 if rename_key in self.renamed_models:
1128                     new_field.remote_field.model = old_field.remote_field.model
1129                 # Handle ForeignKey which can only have a single to_field.
1130                 remote_field_name = getattr(new_field.remote_field, "field_name", None)
1131                 if remote_field_name:
1132                     to_field_rename_key = rename_key + (remote_field_name,)
1133                     if to_field_rename_key in self.renamed_fields:
1134                         # Repoint both model and field name because to_field
1135                         # inclusion in ForeignKey.deconstruct() is based on
1136                         # both.
1137                         new_field.remote_field.model = old_field.remote_field.model
1138                         new_field.remote_field.field_name = (
1139                             old_field.remote_field.field_name
1140                         )
1141                 # Handle ForeignObjects which can have multiple from_fields/to_fields.
1142                 from_fields = getattr(new_field, "from_fields", None)
1143                 if from_fields:
1144                     from_rename_key = (app_label, model_name)
1145                     new_field.from_fields = tuple(
1146                         [
1147                             self.renamed_fields.get(
1148                                 from_rename_key + (from_field,), from_field
1149                             )
1150                             for from_field in from_fields
1151                         ]
1152                     )
1153                     new_field.to_fields = tuple(
1154                         [
1155                             self.renamed_fields.get(rename_key + (to_field,), to_field)
1156                             for to_field in new_field.to_fields
1157                         ]
1158                     )
1159                 dependencies.extend(
1160                     self._get_dependencies_for_foreign_key(
1161                         app_label,
1162                         model_name,
1163                         new_field,
1164                         self.to_state,
1165                     )
1166                 )
1167             if hasattr(new_field, "remote_field") and getattr(
1168                 new_field.remote_field, "through", None
1169             ):
1170                 rename_key = resolve_relation(
1171                     new_field.remote_field.through, app_label, model_name
1172                 )
1173                 if rename_key in self.renamed_models:
1174                     new_field.remote_field.through = old_field.remote_field.through
1175             old_field_dec = self.deep_deconstruct(old_field)
1176             new_field_dec = self.deep_deconstruct(new_field)
1177             # If the field was confirmed to be renamed it means that only
1178             # db_column was allowed to change which generate_renamed_fields()
1179             # already accounts for by adding an AlterField operation.
1180             if old_field_dec != new_field_dec and old_field_name == field_name:
1181                 both_m2m = old_field.many_to_many and new_field.many_to_many
1182                 neither_m2m = not old_field.many_to_many and not new_field.many_to_many
1183                 if both_m2m or neither_m2m:
1184                     # Either both fields are m2m or neither is
1185                     preserve_default = True
1186                     if (
1187                         old_field.null
1188                         and not new_field.null
1189                         and not new_field.has_default()
1190                         and not new_field.many_to_many
1191                     ):
1192                         field = new_field.clone()
1193                         new_default = self.questioner.ask_not_null_alteration(
1194                             field_name, model_name
1195                         )
1196                         if new_default is not models.NOT_PROVIDED:
1197                             field.default = new_default
1198                             preserve_default = False
1199                     else:
1200                         field = new_field
1201                     self.add_operation(
1202                         app_label,
1203                         operations.AlterField(
1204                             model_name=model_name,
1205                             name=field_name,
1206                             field=field,
1207                             preserve_default=preserve_default,
1208                         ),
1209                         dependencies=dependencies,
1210                     )
1211                 else:
1212                     # We cannot alter between m2m and concrete fields
1213                     self._generate_removed_field(app_label, model_name, field_name)
1214                     self._generate_added_field(app_label, model_name, field_name)
1215 
1216     def create_altered_indexes(self):
1217         option_name = operations.AddIndex.option_name
1218         self.renamed_index_together_values = defaultdict(list)
1219 
1220         for app_label, model_name in sorted(self.kept_model_keys):
1221             old_model_name = self.renamed_models.get(
1222                 (app_label, model_name), model_name
1223             )
1224             old_model_state = self.from_state.models[app_label, old_model_name]
1225             new_model_state = self.to_state.models[app_label, model_name]
1226 
1227             old_indexes = old_model_state.options[option_name]
1228             new_indexes = new_model_state.options[option_name]
1229             added_indexes = [idx for idx in new_indexes if idx not in old_indexes]
1230             removed_indexes = [idx for idx in old_indexes if idx not in new_indexes]
1231             renamed_indexes = []
1232             # Find renamed indexes.
1233             remove_from_added = []
1234             remove_from_removed = []
1235             for new_index in added_indexes:
1236                 new_index_dec = new_index.deconstruct()
1237                 new_index_name = new_index_dec[2].pop("name")
1238                 for old_index in removed_indexes:
1239                     old_index_dec = old_index.deconstruct()
1240                     old_index_name = old_index_dec[2].pop("name")
1241                     # Indexes are the same except for the names.
1242                     if (
1243                         new_index_dec == old_index_dec
1244                         and new_index_name != old_index_name
1245                     ):
1246                         renamed_indexes.append((old_index_name, new_index_name, None))
1247                         remove_from_added.append(new_index)
1248                         remove_from_removed.append(old_index)
1249             # Find index_together changed to indexes.
1250             for (
1251                 old_value,
1252                 new_value,
1253                 index_together_app_label,
1254                 index_together_model_name,
1255                 dependencies,
1256             ) in self._get_altered_foo_together_operations(
1257                 operations.AlterIndexTogether.option_name
1258             ):
1259                 if (
1260                     app_label != index_together_app_label
1261                     or model_name != index_together_model_name
1262                 ):
1263                     continue
1264                 removed_values = old_value.difference(new_value)
1265                 for removed_index_together in removed_values:
1266                     renamed_index_together_indexes = []
1267                     for new_index in added_indexes:
1268                         _, args, kwargs = new_index.deconstruct()
1269                         # Ensure only 'fields' are defined in the Index.
1270                         if (
1271                             not args
1272                             and new_index.fields == list(removed_index_together)
1273                             and set(kwargs) == {"name", "fields"}
1274                         ):
1275                             renamed_index_together_indexes.append(new_index)
1276 
1277                     if len(renamed_index_together_indexes) == 1:
1278                         renamed_index = renamed_index_together_indexes[0]
1279                         remove_from_added.append(renamed_index)
1280                         renamed_indexes.append(
1281                             (None, renamed_index.name, removed_index_together)
1282                         )
1283                         self.renamed_index_together_values[
1284                             index_together_app_label, index_together_model_name
1285                         ].append(removed_index_together)
1286             # Remove renamed indexes from the lists of added and removed
1287             # indexes.
1288             added_indexes = [
1289                 idx for idx in added_indexes if idx not in remove_from_added
1290             ]
1291             removed_indexes = [
1292                 idx for idx in removed_indexes if idx not in remove_from_removed
1293             ]
1294 
1295             self.altered_indexes.update(
1296                 {
1297                     (app_label, model_name): {
1298                         "added_indexes": added_indexes,
1299                         "removed_indexes": removed_indexes,
1300                         "renamed_indexes": renamed_indexes,
1301                     }
1302                 }
1303             )
1304 
1305     def generate_added_indexes(self):
1306         for (app_label, model_name), alt_indexes in self.altered_indexes.items():
1307             for index in alt_indexes["added_indexes"]:
1308                 self.add_operation(
1309                     app_label,
1310                     operations.AddIndex(
1311                         model_name=model_name,
1312                         index=index,
1313                     ),
1314                 )
1315 
1316     def generate_removed_indexes(self):
1317         for (app_label, model_name), alt_indexes in self.altered_indexes.items():
1318             for index in alt_indexes["removed_indexes"]:
1319                 self.add_operation(
1320                     app_label,
1321                     operations.RemoveIndex(
1322                         model_name=model_name,
1323                         name=index.name,
1324                     ),
1325                 )
1326 
1327     def generate_renamed_indexes(self):
1328         for (app_label, model_name), alt_indexes in self.altered_indexes.items():
1329             for old_index_name, new_index_name, old_fields in alt_indexes[
1330                 "renamed_indexes"
1331             ]:
1332                 self.add_operation(
1333                     app_label,
1334                     operations.RenameIndex(
1335                         model_name=model_name,
1336                         new_name=new_index_name,
1337                         old_name=old_index_name,
1338                         old_fields=old_fields,
1339                     ),
1340                 )
1341 
1342     def create_altered_constraints(self):
1343         option_name = operations.AddConstraint.option_name
1344         for app_label, model_name in sorted(self.kept_model_keys):
1345             old_model_name = self.renamed_models.get(
1346                 (app_label, model_name), model_name
1347             )
1348             old_model_state = self.from_state.models[app_label, old_model_name]
1349             new_model_state = self.to_state.models[app_label, model_name]
1350 
1351             old_constraints = old_model_state.options[option_name]
1352             new_constraints = new_model_state.options[option_name]
1353             add_constraints = [c for c in new_constraints if c not in old_constraints]
1354             rem_constraints = [c for c in old_constraints if c not in new_constraints]
1355 
1356             self.altered_constraints.update(
1357                 {
1358                     (app_label, model_name): {
1359                         "added_constraints": add_constraints,
1360                         "removed_constraints": rem_constraints,
1361                     }
1362                 }
1363             )
1364 
1365     def generate_added_constraints(self):
1366         for (
1367             app_label,
1368             model_name,
1369         ), alt_constraints in self.altered_constraints.items():
1370             for constraint in alt_constraints["added_constraints"]:
1371                 self.add_operation(
1372                     app_label,
1373                     operations.AddConstraint(
1374                         model_name=model_name,
1375                         constraint=constraint,
1376                     ),
1377                 )
1378 
1379     def generate_removed_constraints(self):
1380         for (
1381             app_label,
1382             model_name,
1383         ), alt_constraints in self.altered_constraints.items():
1384             for constraint in alt_constraints["removed_constraints"]:
1385                 self.add_operation(
1386                     app_label,
1387                     operations.RemoveConstraint(
1388                         model_name=model_name,
1389                         name=constraint.name,
1390                     ),
1391                 )
1392 
1393     @staticmethod
1394     def _get_dependencies_for_foreign_key(app_label, model_name, field, project_state):
1395         remote_field_model = None
1396         if hasattr(field.remote_field, "model"):
1397             remote_field_model = field.remote_field.model
1398         else:
1399             relations = project_state.relations[app_label, model_name]
1400             for (remote_app_label, remote_model_name), fields in relations.items():
1401                 if any(
1402                     field == related_field.remote_field
1403                     for related_field in fields.values()
1404                 ):
1405                     remote_field_model = f"{remote_app_label}.{remote_model_name}"
1406                     break
1407         # Account for FKs to swappable models
1408         swappable_setting = getattr(field, "swappable_setting", None)
1409         if swappable_setting is not None:
1410             dep_app_label = "__setting__"
1411             dep_object_name = swappable_setting
1412         else:
1413             dep_app_label, dep_object_name = resolve_relation(
1414                 remote_field_model,
1415                 app_label,
1416                 model_name,
1417             )
1418         dependencies = [(dep_app_label, dep_object_name, None, True)]
1419         if getattr(field.remote_field, "through", None):
1420             through_app_label, through_object_name = resolve_relation(
1421                 remote_field_model,
1422                 app_label,
1423                 model_name,
1424             )
1425             dependencies.append((through_app_label, through_object_name, None, True))
1426         return dependencies
1427 
1428     def _get_altered_foo_together_operations(self, option_name):
1429         for app_label, model_name in sorted(self.kept_model_keys):
1430             old_model_name = self.renamed_models.get(
1431                 (app_label, model_name), model_name
1432             )
1433             old_model_state = self.from_state.models[app_label, old_model_name]
1434             new_model_state = self.to_state.models[app_label, model_name]
1435 
1436             # We run the old version through the field renames to account for those
1437             old_value = old_model_state.options.get(option_name)
1438             old_value = (
1439                 {
1440                     tuple(
1441                         self.renamed_fields.get((app_label, model_name, n), n)
1442                         for n in unique
1443                     )
1444                     for unique in old_value
1445                 }
1446                 if old_value
1447                 else set()
1448             )
1449 
1450             new_value = new_model_state.options.get(option_name)
1451             new_value = set(new_value) if new_value else set()
1452 
1453             if old_value != new_value:
1454                 dependencies = []
1455                 for foo_togethers in new_value:
1456                     for field_name in foo_togethers:
1457                         field = new_model_state.get_field(field_name)
1458                         if field.remote_field and field.remote_field.model:
1459                             dependencies.extend(
1460                                 self._get_dependencies_for_foreign_key(
1461                                     app_label,
1462                                     model_name,
1463                                     field,
1464                                     self.to_state,
1465                                 )
1466                             )
1467                 yield (
1468                     old_value,
1469                     new_value,
1470                     app_label,
1471                     model_name,
1472                     dependencies,
1473                 )
1474 
1475     def _generate_removed_altered_foo_together(self, operation):
1476         for (
1477             old_value,
1478             new_value,
1479             app_label,
1480             model_name,
1481             dependencies,
1482         ) in self._get_altered_foo_together_operations(operation.option_name):
1483             if operation == operations.AlterIndexTogether:
1484                 old_value = {
1485                     value
1486                     for value in old_value
1487                     if value
1488                     not in self.renamed_index_together_values[app_label, model_name]
1489                 }
1490             removal_value = new_value.intersection(old_value)
1491             if removal_value or old_value:
1492                 self.add_operation(
1493                     app_label,
1494                     operation(
1495                         name=model_name, **{operation.option_name: removal_value}
1496                     ),
1497                     dependencies=dependencies,
1498                 )
1499 
1500     def generate_removed_altered_unique_together(self):
1501         self._generate_removed_altered_foo_together(operations.AlterUniqueTogether)
1502 
1503     def generate_removed_altered_index_together(self):
1504         self._generate_removed_altered_foo_together(operations.AlterIndexTogether)
1505 
1506     def _generate_altered_foo_together(self, operation):
1507         for (
1508             old_value,
1509             new_value,
1510             app_label,
1511             model_name,
1512             dependencies,
1513         ) in self._get_altered_foo_together_operations(operation.option_name):
1514             removal_value = new_value.intersection(old_value)
1515             if new_value != removal_value:
1516                 self.add_operation(
1517                     app_label,
1518                     operation(name=model_name, **{operation.option_name: new_value}),
1519                     dependencies=dependencies,
1520                 )
1521 
1522     def generate_altered_unique_together(self):
1523         self._generate_altered_foo_together(operations.AlterUniqueTogether)
1524 
1525     def generate_altered_index_together(self):
1526         self._generate_altered_foo_together(operations.AlterIndexTogether)
1527 
1528     def generate_altered_db_table(self):
1529         models_to_check = self.kept_model_keys.union(
1530             self.kept_proxy_keys, self.kept_unmanaged_keys
1531         )
1532         for app_label, model_name in sorted(models_to_check):
1533             old_model_name = self.renamed_models.get(
1534                 (app_label, model_name), model_name
1535             )
1536             old_model_state = self.from_state.models[app_label, old_model_name]
1537             new_model_state = self.to_state.models[app_label, model_name]
1538             old_db_table_name = old_model_state.options.get("db_table")
1539             new_db_table_name = new_model_state.options.get("db_table")
1540             if old_db_table_name != new_db_table_name:
1541                 self.add_operation(
1542                     app_label,
1543                     operations.AlterModelTable(
1544                         name=model_name,
1545                         table=new_db_table_name,
1546                     ),
1547                 )
1548 
1549     def generate_altered_options(self):
1550         """
1551         Work out if any non-schema-affecting options have changed and make an
1552         operation to represent them in state changes (in case Python code in
1553         migrations needs them).
1554         """
1555         models_to_check = self.kept_model_keys.union(
1556             self.kept_proxy_keys,
1557             self.kept_unmanaged_keys,
1558             # unmanaged converted to managed
1559             self.old_unmanaged_keys & self.new_model_keys,
1560             # managed converted to unmanaged
1561             self.old_model_keys & self.new_unmanaged_keys,
1562         )
1563 
1564         for app_label, model_name in sorted(models_to_check):
1565             old_model_name = self.renamed_models.get(
1566                 (app_label, model_name), model_name
1567             )
1568             old_model_state = self.from_state.models[app_label, old_model_name]
1569             new_model_state = self.to_state.models[app_label, model_name]
1570             old_options = {
1571                 key: value
1572                 for key, value in old_model_state.options.items()
1573                 if key in AlterModelOptions.ALTER_OPTION_KEYS
1574             }
1575             new_options = {
1576                 key: value
1577                 for key, value in new_model_state.options.items()
1578                 if key in AlterModelOptions.ALTER_OPTION_KEYS
1579             }
1580             if old_options != new_options:
1581                 self.add_operation(
1582                     app_label,
1583                     operations.AlterModelOptions(
1584                         name=model_name,
1585                         options=new_options,
1586                     ),
1587                 )
1588 
1589     def generate_altered_order_with_respect_to(self):
1590         for app_label, model_name in sorted(self.kept_model_keys):
1591             old_model_name = self.renamed_models.get(
1592                 (app_label, model_name), model_name
1593             )
1594             old_model_state = self.from_state.models[app_label, old_model_name]
1595             new_model_state = self.to_state.models[app_label, model_name]
1596             if old_model_state.options.get(
1597                 "order_with_respect_to"
1598             ) != new_model_state.options.get("order_with_respect_to"):
1599                 # Make sure it comes second if we're adding
1600                 # (removal dependency is part of RemoveField)
1601                 dependencies = []
1602                 if new_model_state.options.get("order_with_respect_to"):
1603                     dependencies.append(
1604                         (
1605                             app_label,
1606                             model_name,
1607                             new_model_state.options["order_with_respect_to"],
1608                             True,
1609                         )
1610                     )
1611                 # Actually generate the operation
1612                 self.add_operation(
1613                     app_label,
1614                     operations.AlterOrderWithRespectTo(
1615                         name=model_name,
1616                         order_with_respect_to=new_model_state.options.get(
1617                             "order_with_respect_to"
1618                         ),
1619                     ),
1620                     dependencies=dependencies,
1621                 )
1622 
1623     def generate_altered_managers(self):
1624         for app_label, model_name in sorted(self.kept_model_keys):
1625             old_model_name = self.renamed_models.get(
1626                 (app_label, model_name), model_name
1627             )
1628             old_model_state = self.from_state.models[app_label, old_model_name]
1629             new_model_state = self.to_state.models[app_label, model_name]
1630             if old_model_state.managers != new_model_state.managers:
1631                 self.add_operation(
1632                     app_label,
1633                     operations.AlterModelManagers(
1634                         name=model_name,
1635                         managers=new_model_state.managers,
1636                     ),
1637                 )
1638 
1639     def arrange_for_graph(self, changes, graph, migration_name=None):
1640         """
1641         Take a result from changes() and a MigrationGraph, and fix the names
1642         and dependencies of the changes so they extend the graph from the leaf
1643         nodes for each app.
1644         """
1645         leaves = graph.leaf_nodes()
1646         name_map = {}
1647         for app_label, migrations in list(changes.items()):
1648             if not migrations:
1649                 continue
1650             # Find the app label's current leaf node
1651             app_leaf = None
1652             for leaf in leaves:
1653                 if leaf[0] == app_label:
1654                     app_leaf = leaf
1655                     break
1656             # Do they want an initial migration for this app?
1657             if app_leaf is None and not self.questioner.ask_initial(app_label):
1658                 # They don't.
1659                 for migration in migrations:
1660                     name_map[(app_label, migration.name)] = (app_label, "__first__")
1661                 del changes[app_label]
1662                 continue
1663             # Work out the next number in the sequence
1664             if app_leaf is None:
1665                 next_number = 1
1666             else:
1667                 next_number = (self.parse_number(app_leaf[1]) or 0) + 1
1668             # Name each migration
1669             for i, migration in enumerate(migrations):
1670                 if i == 0 and app_leaf:
1671                     migration.dependencies.append(app_leaf)
1672                 new_name_parts = ["%04i" % next_number]
1673                 if migration_name:
1674                     new_name_parts.append(migration_name)
1675                 elif i == 0 and not app_leaf:
1676                     new_name_parts.append("initial")
1677                 else:
1678                     new_name_parts.append(migration.suggest_name()[:100])
1679                 new_name = "_".join(new_name_parts)
1680                 name_map[(app_label, migration.name)] = (app_label, new_name)
1681                 next_number += 1
1682                 migration.name = new_name
1683         # Now fix dependencies
1684         for migrations in changes.values():
1685             for migration in migrations:
1686                 migration.dependencies = [
1687                     name_map.get(d, d) for d in migration.dependencies
1688                 ]
1689         return changes
1690 
1691     def _trim_to_apps(self, changes, app_labels):
1692         """
1693         Take changes from arrange_for_graph() and set of app labels, and return
1694         a modified set of changes which trims out as many migrations that are
1695         not in app_labels as possible. Note that some other migrations may
1696         still be present as they may be required dependencies.
1697         """
1698         # Gather other app dependencies in a first pass
1699         app_dependencies = {}
1700         for app_label, migrations in changes.items():
1701             for migration in migrations:
1702                 for dep_app_label, name in migration.dependencies:
1703                     app_dependencies.setdefault(app_label, set()).add(dep_app_label)
1704         required_apps = set(app_labels)
1705         # Keep resolving till there's no change
1706         old_required_apps = None
1707         while old_required_apps != required_apps:
1708             old_required_apps = set(required_apps)
1709             required_apps.update(
1710                 *[app_dependencies.get(app_label, ()) for app_label in required_apps]
1711             )
1712         # Remove all migrations that aren't needed
1713         for app_label in list(changes):
1714             if app_label not in required_apps:
1715                 del changes[app_label]
1716         return changes
1717 
1718     @classmethod
1719     def parse_number(cls, name):
1720         """
1721         Given a migration name, try to extract a number from the beginning of
1722         it. For a squashed migration such as '0001_squashed_0004â€¦', return the
1723         second number. If no number is found, return None.
1724         """
1725         if squashed_match := re.search(r".*_squashed_(\d+)", name):
1726             return int(squashed_match[1])
1727         match = re.match(r"^\d+", name)
1728         if match:
1729             return int(match[0])
1730         return None

</code><intended_behavior>The automatic migration detection for model changes related to indexing should fully support `indexes` as the primary method for specifying indexes going forward. The intended behavior here is to deprecate the use of `index_together` in the migration autodetector logic by either warning users about its deprecation or automatically converting `index_together` definitions into `indexes`. The autodetection of index changes should continue to function seamlessly, detecting when indexes are added, removed, or altered and generating the appropriate migration files without manual intervention.</intended_behavior>, <file>django/db/backends/sqlite3/schema.py</file>
<class>None</class>
<method>None</method>
<code>
1 import copy
2 from decimal import Decimal
3 
4 from django.apps.registry import Apps
5 from django.db import NotSupportedError
6 from django.db.backends.base.schema import BaseDatabaseSchemaEditor
7 from django.db.backends.ddl_references import Statement
8 from django.db.backends.utils import strip_quotes
9 from django.db.models import UniqueConstraint
10 from django.db.transaction import atomic
11 
12 
13 class DatabaseSchemaEditor(BaseDatabaseSchemaEditor):
14 
15     sql_delete_table = "DROP TABLE %(table)s"
16     sql_create_fk = None
17     sql_create_inline_fk = (
18         "REFERENCES %(to_table)s (%(to_column)s) DEFERRABLE INITIALLY DEFERRED"
19     )
20     sql_create_column_inline_fk = sql_create_inline_fk
21     sql_delete_column = "ALTER TABLE %(table)s DROP COLUMN %(column)s"
22     sql_create_unique = "CREATE UNIQUE INDEX %(name)s ON %(table)s (%(columns)s)"
23     sql_delete_unique = "DROP INDEX %(name)s"
24 
25     def __enter__(self):
26         # Some SQLite schema alterations need foreign key constraints to be
27         # disabled. Enforce it here for the duration of the schema edition.
28         if not self.connection.disable_constraint_checking():
29             raise NotSupportedError(
30                 "SQLite schema editor cannot be used while foreign key "
31                 "constraint checks are enabled. Make sure to disable them "
32                 "before entering a transaction.atomic() context because "
33                 "SQLite does not support disabling them in the middle of "
34                 "a multi-statement transaction."
35             )
36         return super().__enter__()
37 
38     def __exit__(self, exc_type, exc_value, traceback):
39         self.connection.check_constraints()
40         super().__exit__(exc_type, exc_value, traceback)
41         self.connection.enable_constraint_checking()
42 
43     def quote_value(self, value):
44         # The backend "mostly works" without this function and there are use
45         # cases for compiling Python without the sqlite3 libraries (e.g.
46         # security hardening).
47         try:
48             import sqlite3
49 
50             value = sqlite3.adapt(value)
51         except ImportError:
52             pass
53         except sqlite3.ProgrammingError:
54             pass
55         # Manual emulation of SQLite parameter quoting
56         if isinstance(value, bool):
57             return str(int(value))
58         elif isinstance(value, (Decimal, float, int)):
59             return str(value)
60         elif isinstance(value, str):
61             return "'%s'" % value.replace("'", "''")
62         elif value is None:
63             return "NULL"
64         elif isinstance(value, (bytes, bytearray, memoryview)):
65             # Bytes are only allowed for BLOB fields, encoded as string
66             # literals containing hexadecimal data and preceded by a single "X"
67             # character.
68             return "X'%s'" % value.hex()
69         else:
70             raise ValueError(
71                 "Cannot quote parameter value %r of type %s" % (value, type(value))
72             )
73 
74     def prepare_default(self, value):
75         return self.quote_value(value)
76 
77     def _is_referenced_by_fk_constraint(
78         self, table_name, column_name=None, ignore_self=False
79     ):
80         """
81         Return whether or not the provided table name is referenced by another
82         one. If `column_name` is specified, only references pointing to that
83         column are considered. If `ignore_self` is True, self-referential
84         constraints are ignored.
85         """
86         with self.connection.cursor() as cursor:
87             for other_table in self.connection.introspection.get_table_list(cursor):
88                 if ignore_self and other_table.name == table_name:
89                     continue
90                 relations = self.connection.introspection.get_relations(
91                     cursor, other_table.name
92                 )
93                 for constraint_column, constraint_table in relations.values():
94                     if constraint_table == table_name and (
95                         column_name is None or constraint_column == column_name
96                     ):
97                         return True
98         return False
99 
100     def alter_db_table(
101         self, model, old_db_table, new_db_table, disable_constraints=True
102     ):
103         if (
104             not self.connection.features.supports_atomic_references_rename
105             and disable_constraints
106             and self._is_referenced_by_fk_constraint(old_db_table)
107         ):
108             if self.connection.in_atomic_block:
109                 raise NotSupportedError(
110                     (
111                         "Renaming the %r table while in a transaction is not "
112                         "supported on SQLite < 3.26 because it would break referential "
113                         "integrity. Try adding `atomic = False` to the Migration class."
114                     )
115                     % old_db_table
116                 )
117             self.connection.enable_constraint_checking()
118             super().alter_db_table(model, old_db_table, new_db_table)
119             self.connection.disable_constraint_checking()
120         else:
121             super().alter_db_table(model, old_db_table, new_db_table)
122 
123     def alter_field(self, model, old_field, new_field, strict=False):
124         if not self._field_should_be_altered(old_field, new_field):
125             return
126         old_field_name = old_field.name
127         table_name = model._meta.db_table
128         _, old_column_name = old_field.get_attname_column()
129         if (
130             new_field.name != old_field_name
131             and not self.connection.features.supports_atomic_references_rename
132             and self._is_referenced_by_fk_constraint(
133                 table_name, old_column_name, ignore_self=True
134             )
135         ):
136             if self.connection.in_atomic_block:
137                 raise NotSupportedError(
138                     (
139                         "Renaming the %r.%r column while in a transaction is not "
140                         "supported on SQLite < 3.26 because it would break referential "
141                         "integrity. Try adding `atomic = False` to the Migration class."
142                     )
143                     % (model._meta.db_table, old_field_name)
144                 )
145             with atomic(self.connection.alias):
146                 super().alter_field(model, old_field, new_field, strict=strict)
147                 # Follow SQLite's documented procedure for performing changes
148                 # that don't affect the on-disk content.
149                 # https://sqlite.org/lang_altertable.html#otheralter
150                 with self.connection.cursor() as cursor:
151                     schema_version = cursor.execute("PRAGMA schema_version").fetchone()[
152                         0
153                     ]
154                     cursor.execute("PRAGMA writable_schema = 1")
155                     references_template = ' REFERENCES "%s" ("%%s") ' % table_name
156                     new_column_name = new_field.get_attname_column()[1]
157                     search = references_template % old_column_name
158                     replacement = references_template % new_column_name
159                     cursor.execute(
160                         "UPDATE sqlite_master SET sql = replace(sql, %s, %s)",
161                         (search, replacement),
162                     )
163                     cursor.execute("PRAGMA schema_version = %d" % (schema_version + 1))
164                     cursor.execute("PRAGMA writable_schema = 0")
165                     # The integrity check will raise an exception and rollback
166                     # the transaction if the sqlite_master updates corrupt the
167                     # database.
168                     cursor.execute("PRAGMA integrity_check")
169             # Perform a VACUUM to refresh the database representation from
170             # the sqlite_master table.
171             with self.connection.cursor() as cursor:
172                 cursor.execute("VACUUM")
173         else:
174             super().alter_field(model, old_field, new_field, strict=strict)
175 
176     def _remake_table(
177         self, model, create_field=None, delete_field=None, alter_field=None
178     ):
179         """
180         Shortcut to transform a model from old_model into new_model
181 
182         This follows the correct procedure to perform non-rename or column
183         addition operations based on SQLite's documentation
184 
185         https://www.sqlite.org/lang_altertable.html#caution
186 
187         The essential steps are:
188           1. Create a table with the updated definition called "new__app_model"
189           2. Copy the data from the existing "app_model" table to the new table
190           3. Drop the "app_model" table
191           4. Rename the "new__app_model" table to "app_model"
192           5. Restore any index of the previous "app_model" table.
193         """
194         # Self-referential fields must be recreated rather than copied from
195         # the old model to ensure their remote_field.field_name doesn't refer
196         # to an altered field.
197         def is_self_referential(f):
198             return f.is_relation and f.remote_field.model is model
199 
200         # Work out the new fields dict / mapping
201         body = {
202             f.name: f.clone() if is_self_referential(f) else f
203             for f in model._meta.local_concrete_fields
204         }
205         # Since mapping might mix column names and default values,
206         # its values must be already quoted.
207         mapping = {
208             f.column: self.quote_name(f.column)
209             for f in model._meta.local_concrete_fields
210         }
211         # This maps field names (not columns) for things like unique_together
212         rename_mapping = {}
213         # If any of the new or altered fields is introducing a new PK,
214         # remove the old one
215         restore_pk_field = None
216         if getattr(create_field, "primary_key", False) or (
217             alter_field and getattr(alter_field[1], "primary_key", False)
218         ):
219             for name, field in list(body.items()):
220                 if field.primary_key and not (
221                     # Do not remove the old primary key when an altered field
222                     # that introduces a primary key is the same field.
223                     alter_field
224                     and name == alter_field[1].name
225                 ):
226                     field.primary_key = False
227                     restore_pk_field = field
228                     if field.auto_created:
229                         del body[name]
230                         del mapping[field.column]
231         # Add in any created fields
232         if create_field:
233             body[create_field.name] = create_field
234             # Choose a default and insert it into the copy map
235             if not create_field.many_to_many and create_field.concrete:
236                 mapping[create_field.column] = self.prepare_default(
237                     self.effective_default(create_field),
238                 )
239         # Add in any altered fields
240         if alter_field:
241             old_field, new_field = alter_field
242             body.pop(old_field.name, None)
243             mapping.pop(old_field.column, None)
244             body[new_field.name] = new_field
245             if old_field.null and not new_field.null:
246                 case_sql = "coalesce(%(col)s, %(default)s)" % {
247                     "col": self.quote_name(old_field.column),
248                     "default": self.prepare_default(self.effective_default(new_field)),
249                 }
250                 mapping[new_field.column] = case_sql
251             else:
252                 mapping[new_field.column] = self.quote_name(old_field.column)
253             rename_mapping[old_field.name] = new_field.name
254         # Remove any deleted fields
255         if delete_field:
256             del body[delete_field.name]
257             del mapping[delete_field.column]
258             # Remove any implicit M2M tables
259             if (
260                 delete_field.many_to_many
261                 and delete_field.remote_field.through._meta.auto_created
262             ):
263                 return self.delete_model(delete_field.remote_field.through)
264         # Work inside a new app registry
265         apps = Apps()
266 
267         # Work out the new value of unique_together, taking renames into
268         # account
269         unique_together = [
270             [rename_mapping.get(n, n) for n in unique]
271             for unique in model._meta.unique_together
272         ]
273 
274         # Work out the new value for index_together, taking renames into
275         # account
276         index_together = [
277             [rename_mapping.get(n, n) for n in index]
278             for index in model._meta.index_together
279         ]
280 
281         indexes = model._meta.indexes
282         if delete_field:
283             indexes = [
284                 index for index in indexes if delete_field.name not in index.fields
285             ]
286 
287         constraints = list(model._meta.constraints)
288 
289         # Provide isolated instances of the fields to the new model body so
290         # that the existing model's internals aren't interfered with when
291         # the dummy model is constructed.
292         body_copy = copy.deepcopy(body)
293 
294         # Construct a new model with the new fields to allow self referential
295         # primary key to resolve to. This model won't ever be materialized as a
296         # table and solely exists for foreign key reference resolution purposes.
297         # This wouldn't be required if the schema editor was operating on model
298         # states instead of rendered models.
299         meta_contents = {
300             "app_label": model._meta.app_label,
301             "db_table": model._meta.db_table,
302             "unique_together": unique_together,
303             "index_together": index_together,
304             "indexes": indexes,
305             "constraints": constraints,
306             "apps": apps,
307         }
308         meta = type("Meta", (), meta_contents)
309         body_copy["Meta"] = meta
310         body_copy["__module__"] = model.__module__
311         type(model._meta.object_name, model.__bases__, body_copy)
312 
313         # Construct a model with a renamed table name.
314         body_copy = copy.deepcopy(body)
315         meta_contents = {
316             "app_label": model._meta.app_label,
317             "db_table": "new__%s" % strip_quotes(model._meta.db_table),
318             "unique_together": unique_together,
319             "index_together": index_together,
320             "indexes": indexes,
321             "constraints": constraints,
322             "apps": apps,
323         }
324         meta = type("Meta", (), meta_contents)
325         body_copy["Meta"] = meta
326         body_copy["__module__"] = model.__module__
327         new_model = type("New%s" % model._meta.object_name, model.__bases__, body_copy)
328 
329         # Create a new table with the updated schema.
330         self.create_model(new_model)
331 
332         # Copy data from the old table into the new table
333         self.execute(
334             "INSERT INTO %s (%s) SELECT %s FROM %s"
335             % (
336                 self.quote_name(new_model._meta.db_table),
337                 ", ".join(self.quote_name(x) for x in mapping),
338                 ", ".join(mapping.values()),
339                 self.quote_name(model._meta.db_table),
340             )
341         )
342 
343         # Delete the old table to make way for the new
344         self.delete_model(model, handle_autom2m=False)
345 
346         # Rename the new table to take way for the old
347         self.alter_db_table(
348             new_model,
349             new_model._meta.db_table,
350             model._meta.db_table,
351             disable_constraints=False,
352         )
353 
354         # Run deferred SQL on correct table
355         for sql in self.deferred_sql:
356             self.execute(sql)
357         self.deferred_sql = []
358         # Fix any PK-removed field
359         if restore_pk_field:
360             restore_pk_field.primary_key = True
361 
362     def delete_model(self, model, handle_autom2m=True):
363         if handle_autom2m:
364             super().delete_model(model)
365         else:
366             # Delete the table (and only that)
367             self.execute(
368                 self.sql_delete_table
369                 % {
370                     "table": self.quote_name(model._meta.db_table),
371                 }
372             )
373             # Remove all deferred statements referencing the deleted table.
374             for sql in list(self.deferred_sql):
375                 if isinstance(sql, Statement) and sql.references_table(
376                     model._meta.db_table
377                 ):
378                     self.deferred_sql.remove(sql)
379 
380     def add_field(self, model, field):
381         """Create a field on a model."""
382         if (
383             # Primary keys and unique fields are not supported in ALTER TABLE
384             # ADD COLUMN.
385             field.primary_key
386             or field.unique
387             or
388             # Fields with default values cannot by handled by ALTER TABLE ADD
389             # COLUMN statement because DROP DEFAULT is not supported in
390             # ALTER TABLE.
391             not field.null
392             or self.effective_default(field) is not None
393         ):
394             self._remake_table(model, create_field=field)
395         else:
396             super().add_field(model, field)
397 
398     def remove_field(self, model, field):
399         """
400         Remove a field from a model. Usually involves deleting a column,
401         but for M2Ms may involve deleting a table.
402         """
403         # M2M fields are a special case
404         if field.many_to_many:
405             # For implicit M2M tables, delete the auto-created table
406             if field.remote_field.through._meta.auto_created:
407                 self.delete_model(field.remote_field.through)
408             # For explicit "through" M2M fields, do nothing
409         elif (
410             self.connection.features.can_alter_table_drop_column
411             # Primary keys, unique fields, and foreign keys are not
412             # supported in ALTER TABLE DROP COLUMN.
413             and not field.primary_key
414             and not field.unique
415             and not (field.remote_field and field.db_constraint)
416         ):
417             super().remove_field(model, field)
418         # For everything else, remake.
419         else:
420             # It might not actually have a column behind it
421             if field.db_parameters(connection=self.connection)["type"] is None:
422                 return
423             self._remake_table(model, delete_field=field)
424 
425     def _alter_field(
426         self,
427         model,
428         old_field,
429         new_field,
430         old_type,
431         new_type,
432         old_db_params,
433         new_db_params,
434         strict=False,
435     ):
436         """Perform a "physical" (non-ManyToMany) field update."""
437         # Use "ALTER TABLE ... RENAME COLUMN" if only the column name
438         # changed and there aren't any constraints.
439         if (
440             self.connection.features.can_alter_table_rename_column
441             and old_field.column != new_field.column
442             and self.column_sql(model, old_field) == self.column_sql(model, new_field)
443             and not (
444                 old_field.remote_field
445                 and old_field.db_constraint
446                 or new_field.remote_field
447                 and new_field.db_constraint
448             )
449         ):
450             return self.execute(
451                 self._rename_field_sql(
452                     model._meta.db_table, old_field, new_field, new_type
453                 )
454             )
455         # Alter by remaking table
456         self._remake_table(model, alter_field=(old_field, new_field))
457         # Rebuild tables with FKs pointing to this field.
458         old_collation = old_db_params.get("collation")
459         new_collation = new_db_params.get("collation")
460         if new_field.unique and (
461             old_type != new_type or old_collation != new_collation
462         ):
463             related_models = set()
464             opts = new_field.model._meta
465             for remote_field in opts.related_objects:
466                 # Ignore self-relationship since the table was already rebuilt.
467                 if remote_field.related_model == model:
468                     continue
469                 if not remote_field.many_to_many:
470                     if remote_field.field_name == new_field.name:
471                         related_models.add(remote_field.related_model)
472                 elif new_field.primary_key and remote_field.through._meta.auto_created:
473                     related_models.add(remote_field.through)
474             if new_field.primary_key:
475                 for many_to_many in opts.many_to_many:
476                     # Ignore self-relationship since the table was already rebuilt.
477                     if many_to_many.related_model == model:
478                         continue
479                     if many_to_many.remote_field.through._meta.auto_created:
480                         related_models.add(many_to_many.remote_field.through)
481             for related_model in related_models:
482                 self._remake_table(related_model)
483 
484     def _alter_many_to_many(self, model, old_field, new_field, strict):
485         """Alter M2Ms to repoint their to= endpoints."""
486         if (
487             old_field.remote_field.through._meta.db_table
488             == new_field.remote_field.through._meta.db_table
489         ):
490             # The field name didn't change, but some options did, so we have to
491             # propagate this altering.
492             self._remake_table(
493                 old_field.remote_field.through,
494                 alter_field=(
495                     # The field that points to the target model is needed, so
496                     # we can tell alter_field to change it - this is
497                     # m2m_reverse_field_name() (as opposed to m2m_field_name(),
498                     # which points to our model).
499                     old_field.remote_field.through._meta.get_field(
500                         old_field.m2m_reverse_field_name()
501                     ),
502                     new_field.remote_field.through._meta.get_field(
503                         new_field.m2m_reverse_field_name()
504                     ),
505                 ),
506             )
507             return
508 
509         # Make a new through table
510         self.create_model(new_field.remote_field.through)
511         # Copy the data across
512         self.execute(
513             "INSERT INTO %s (%s) SELECT %s FROM %s"
514             % (
515                 self.quote_name(new_field.remote_field.through._meta.db_table),
516                 ", ".join(
517                     [
518                         "id",
519                         new_field.m2m_column_name(),
520                         new_field.m2m_reverse_name(),
521                     ]
522                 ),
523                 ", ".join(
524                     [
525                         "id",
526                         old_field.m2m_column_name(),
527                         old_field.m2m_reverse_name(),
528                     ]
529                 ),
530                 self.quote_name(old_field.remote_field.through._meta.db_table),
531             )
532         )
533         # Delete the old through table
534         self.delete_model(old_field.remote_field.through)
535 
536     def add_constraint(self, model, constraint):
537         if isinstance(constraint, UniqueConstraint) and (
538             constraint.condition
539             or constraint.contains_expressions
540             or constraint.include
541             or constraint.deferrable
542         ):
543             super().add_constraint(model, constraint)
544         else:
545             self._remake_table(model)
546 
547     def remove_constraint(self, model, constraint):
548         if isinstance(constraint, UniqueConstraint) and (
549             constraint.condition
550             or constraint.contains_expressions
551             or constraint.include
552             or constraint.deferrable
553         ):
554             super().remove_constraint(model, constraint)
555         else:
556             self._remake_table(model)
557 
558     def _collate_sql(self, collation):
559         return "COLLATE " + collation

</code><intended_behavior>The SQLite backend's schema modification and creation logic need to be adjusted to prioritize `indexes` over `index_together`, ensuring that any SQL generated for index management is done through the explicit index objects provided via `indexes`. It should continue to allow Django to manage SQLite3 database schemas effectively, translating model index configurations into the correct SQL statements for index creation, deletion, and alteration, accommodating all features supported by the `indexes` option (such as expressions, conditionals, and name specification).</intended_behavior>]
2025-10-15 19:18:39.309 | INFO     | Search completed. Bug locations: [<file>django/db/models/options.py</file>
<class>None</class>
<method>None</method>
<code>
1 import bisect
2 import copy
3 import inspect
4 from collections import defaultdict
5 
6 from django.apps import apps
7 from django.conf import settings
8 from django.core.exceptions import FieldDoesNotExist, ImproperlyConfigured
9 from django.db import connections
10 from django.db.models import AutoField, Manager, OrderWrt, UniqueConstraint
11 from django.db.models.query_utils import PathInfo
12 from django.utils.datastructures import ImmutableList, OrderedSet
13 from django.utils.functional import cached_property
14 from django.utils.module_loading import import_string
15 from django.utils.text import camel_case_to_spaces, format_lazy
16 from django.utils.translation import override
17 
18 PROXY_PARENTS = object()
19 
20 EMPTY_RELATION_TREE = ()
21 
22 IMMUTABLE_WARNING = (
23     "The return type of '%s' should never be mutated. If you want to manipulate this "
24     "list for your own use, make a copy first."
25 )
26 
27 DEFAULT_NAMES = (
28     "verbose_name",
29     "verbose_name_plural",
30     "db_table",
31     "ordering",
32     "unique_together",
33     "permissions",
34     "get_latest_by",
35     "order_with_respect_to",
36     "app_label",
37     "db_tablespace",
38     "abstract",
39     "managed",
40     "proxy",
41     "swappable",
42     "auto_created",
43     "index_together",
44     "apps",
45     "default_permissions",
46     "select_on_save",
47     "default_related_name",
48     "required_db_features",
49     "required_db_vendor",
50     "base_manager_name",
51     "default_manager_name",
52     "indexes",
53     "constraints",
54 )
55 
56 
57 def normalize_together(option_together):
58     """
59     option_together can be either a tuple of tuples, or a single
60     tuple of two strings. Normalize it to a tuple of tuples, so that
61     calling code can uniformly expect that.
62     """
63     try:
64         if not option_together:
65             return ()
66         if not isinstance(option_together, (tuple, list)):
67             raise TypeError
68         first_element = option_together[0]
69         if not isinstance(first_element, (tuple, list)):
70             option_together = (option_together,)
71         # Normalize everything to tuples
72         return tuple(tuple(ot) for ot in option_together)
73     except TypeError:
74         # If the value of option_together isn't valid, return it
75         # verbatim; this will be picked up by the check framework later.
76         return option_together
77 
78 
79 def make_immutable_fields_list(name, data):
80     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
81 
82 
83 class Options:
84     FORWARD_PROPERTIES = {
85         "fields",
86         "many_to_many",
87         "concrete_fields",
88         "local_concrete_fields",
89         "_forward_fields_map",
90         "managers",
91         "managers_map",
92         "base_manager",
93         "default_manager",
94     }
95     REVERSE_PROPERTIES = {"related_objects", "fields_map", "_relation_tree"}
96 
97     default_apps = apps
98 
99     def __init__(self, meta, app_label=None):
100         self._get_fields_cache = {}
101         self.local_fields = []
102         self.local_many_to_many = []
103         self.private_fields = []
104         self.local_managers = []
105         self.base_manager_name = None
106         self.default_manager_name = None
107         self.model_name = None
108         self.verbose_name = None
109         self.verbose_name_plural = None
110         self.db_table = ""
111         self.ordering = []
112         self._ordering_clash = False
113         self.indexes = []
114         self.constraints = []
115         self.unique_together = []
116         self.index_together = []
117         self.select_on_save = False
118         self.default_permissions = ("add", "change", "delete", "view")
119         self.permissions = []
120         self.object_name = None
121         self.app_label = app_label
122         self.get_latest_by = None
123         self.order_with_respect_to = None
124         self.db_tablespace = settings.DEFAULT_TABLESPACE
125         self.required_db_features = []
126         self.required_db_vendor = None
127         self.meta = meta
128         self.pk = None
129         self.auto_field = None
130         self.abstract = False
131         self.managed = True
132         self.proxy = False
133         # For any class that is a proxy (including automatically created
134         # classes for deferred object loading), proxy_for_model tells us
135         # which class this model is proxying. Note that proxy_for_model
136         # can create a chain of proxy models. For non-proxy models, the
137         # variable is always None.
138         self.proxy_for_model = None
139         # For any non-abstract class, the concrete class is the model
140         # in the end of the proxy_for_model chain. In particular, for
141         # concrete models, the concrete_model is always the class itself.
142         self.concrete_model = None
143         self.swappable = None
144         self.parents = {}
145         self.auto_created = False
146 
147         # List of all lookups defined in ForeignKey 'limit_choices_to' options
148         # from *other* models. Needed for some admin checks. Internal use only.
149         self.related_fkey_lookups = []
150 
151         # A custom app registry to use, if you're making a separate model set.
152         self.apps = self.default_apps
153 
154         self.default_related_name = None
155 
156     @property
157     def label(self):
158         return "%s.%s" % (self.app_label, self.object_name)
159 
160     @property
161     def label_lower(self):
162         return "%s.%s" % (self.app_label, self.model_name)
163 
164     @property
165     def app_config(self):
166         # Don't go through get_app_config to avoid triggering imports.
167         return self.apps.app_configs.get(self.app_label)
168 
169     def contribute_to_class(self, cls, name):
170         from django.db import connection
171         from django.db.backends.utils import truncate_name
172 
173         cls._meta = self
174         self.model = cls
175         # First, construct the default values for these options.
176         self.object_name = cls.__name__
177         self.model_name = self.object_name.lower()
178         self.verbose_name = camel_case_to_spaces(self.object_name)
179 
180         # Store the original user-defined values for each option,
181         # for use when serializing the model definition
182         self.original_attrs = {}
183 
184         # Next, apply any overridden values from 'class Meta'.
185         if self.meta:
186             meta_attrs = self.meta.__dict__.copy()
187             for name in self.meta.__dict__:
188                 # Ignore any private attributes that Django doesn't care about.
189                 # NOTE: We can't modify a dictionary's contents while looping
190                 # over it, so we loop over the *original* dictionary instead.
191                 if name.startswith("_"):
192                     del meta_attrs[name]
193             for attr_name in DEFAULT_NAMES:
194                 if attr_name in meta_attrs:
195                     setattr(self, attr_name, meta_attrs.pop(attr_name))
196                     self.original_attrs[attr_name] = getattr(self, attr_name)
197                 elif hasattr(self.meta, attr_name):
198                     setattr(self, attr_name, getattr(self.meta, attr_name))
199                     self.original_attrs[attr_name] = getattr(self, attr_name)
200 
201             self.unique_together = normalize_together(self.unique_together)
202             self.index_together = normalize_together(self.index_together)
203             # App label/class name interpolation for names of constraints and
204             # indexes.
205             if not getattr(cls._meta, "abstract", False):
206                 for attr_name in {"constraints", "indexes"}:
207                     objs = getattr(self, attr_name, [])
208                     setattr(self, attr_name, self._format_names_with_class(cls, objs))
209 
210             # verbose_name_plural is a special case because it uses a 's'
211             # by default.
212             if self.verbose_name_plural is None:
213                 self.verbose_name_plural = format_lazy("{}s", self.verbose_name)
214 
215             # order_with_respect_and ordering are mutually exclusive.
216             self._ordering_clash = bool(self.ordering and self.order_with_respect_to)
217 
218             # Any leftover attributes must be invalid.
219             if meta_attrs != {}:
220                 raise TypeError(
221                     "'class Meta' got invalid attribute(s): %s" % ",".join(meta_attrs)
222                 )
223         else:
224             self.verbose_name_plural = format_lazy("{}s", self.verbose_name)
225         del self.meta
226 
227         # If the db_table wasn't provided, use the app_label + model_name.
228         if not self.db_table:
229             self.db_table = "%s_%s" % (self.app_label, self.model_name)
230             self.db_table = truncate_name(
231                 self.db_table, connection.ops.max_name_length()
232             )
233 
234     def _format_names_with_class(self, cls, objs):
235         """App label/class name interpolation for object names."""
236         new_objs = []
237         for obj in objs:
238             obj = obj.clone()
239             obj.name = obj.name % {
240                 "app_label": cls._meta.app_label.lower(),
241                 "class": cls.__name__.lower(),
242             }
243             new_objs.append(obj)
244         return new_objs
245 
246     def _get_default_pk_class(self):
247         pk_class_path = getattr(
248             self.app_config,
249             "default_auto_field",
250             settings.DEFAULT_AUTO_FIELD,
251         )
252         if self.app_config and self.app_config._is_default_auto_field_overridden:
253             app_config_class = type(self.app_config)
254             source = (
255                 f"{app_config_class.__module__}."
256                 f"{app_config_class.__qualname__}.default_auto_field"
257             )
258         else:
259             source = "DEFAULT_AUTO_FIELD"
260         if not pk_class_path:
261             raise ImproperlyConfigured(f"{source} must not be empty.")
262         try:
263             pk_class = import_string(pk_class_path)
264         except ImportError as e:
265             msg = (
266                 f"{source} refers to the module '{pk_class_path}' that could "
267                 f"not be imported."
268             )
269             raise ImproperlyConfigured(msg) from e
270         if not issubclass(pk_class, AutoField):
271             raise ValueError(
272                 f"Primary key '{pk_class_path}' referred by {source} must "
273                 f"subclass AutoField."
274             )
275         return pk_class
276 
277     def _prepare(self, model):
278         if self.order_with_respect_to:
279             # The app registry will not be ready at this point, so we cannot
280             # use get_field().
281             query = self.order_with_respect_to
282             try:
283                 self.order_with_respect_to = next(
284                     f
285                     for f in self._get_fields(reverse=False)
286                     if f.name == query or f.attname == query
287                 )
288             except StopIteration:
289                 raise FieldDoesNotExist(
290                     "%s has no field named '%s'" % (self.object_name, query)
291                 )
292 
293             self.ordering = ("_order",)
294             if not any(
295                 isinstance(field, OrderWrt) for field in model._meta.local_fields
296             ):
297                 model.add_to_class("_order", OrderWrt())
298         else:
299             self.order_with_respect_to = None
300 
301         if self.pk is None:
302             if self.parents:
303                 # Promote the first parent link in lieu of adding yet another
304                 # field.
305                 field = next(iter(self.parents.values()))
306                 # Look for a local field with the same name as the
307                 # first parent link. If a local field has already been
308                 # created, use it instead of promoting the parent
309                 already_created = [
310                     fld for fld in self.local_fields if fld.name == field.name
311                 ]
312                 if already_created:
313                     field = already_created[0]
314                 field.primary_key = True
315                 self.setup_pk(field)
316             else:
317                 pk_class = self._get_default_pk_class()
318                 auto = pk_class(verbose_name="ID", primary_key=True, auto_created=True)
319                 model.add_to_class("id", auto)
320 
321     def add_manager(self, manager):
322         self.local_managers.append(manager)
323         self._expire_cache()
324 
325     def add_field(self, field, private=False):
326         # Insert the given field in the order in which it was created, using
327         # the "creation_counter" attribute of the field.
328         # Move many-to-many related fields from self.fields into
329         # self.many_to_many.
330         if private:
331             self.private_fields.append(field)
332         elif field.is_relation and field.many_to_many:
333             bisect.insort(self.local_many_to_many, field)
334         else:
335             bisect.insort(self.local_fields, field)
336             self.setup_pk(field)
337 
338         # If the field being added is a relation to another known field,
339         # expire the cache on this field and the forward cache on the field
340         # being referenced, because there will be new relationships in the
341         # cache. Otherwise, expire the cache of references *to* this field.
342         # The mechanism for getting at the related model is slightly odd -
343         # ideally, we'd just ask for field.related_model. However, related_model
344         # is a cached property, and all the models haven't been loaded yet, so
345         # we need to make sure we don't cache a string reference.
346         if (
347             field.is_relation
348             and hasattr(field.remote_field, "model")
349             and field.remote_field.model
350         ):
351             try:
352                 field.remote_field.model._meta._expire_cache(forward=False)
353             except AttributeError:
354                 pass
355             self._expire_cache()
356         else:
357             self._expire_cache(reverse=False)
358 
359     def setup_pk(self, field):
360         if not self.pk and field.primary_key:
361             self.pk = field
362             field.serialize = False
363 
364     def setup_proxy(self, target):
365         """
366         Do the internal setup so that the current model is a proxy for
367         "target".
368         """
369         self.pk = target._meta.pk
370         self.proxy_for_model = target
371         self.db_table = target._meta.db_table
372 
373     def __repr__(self):
374         return "<Options for %s>" % self.object_name
375 
376     def __str__(self):
377         return self.label_lower
378 
379     def can_migrate(self, connection):
380         """
381         Return True if the model can/should be migrated on the `connection`.
382         `connection` can be either a real connection or a connection alias.
383         """
384         if self.proxy or self.swapped or not self.managed:
385             return False
386         if isinstance(connection, str):
387             connection = connections[connection]
388         if self.required_db_vendor:
389             return self.required_db_vendor == connection.vendor
390         if self.required_db_features:
391             return all(
392                 getattr(connection.features, feat, False)
393                 for feat in self.required_db_features
394             )
395         return True
396 
397     @property
398     def verbose_name_raw(self):
399         """Return the untranslated verbose name."""
400         with override(None):
401             return str(self.verbose_name)
402 
403     @property
404     def swapped(self):
405         """
406         Has this model been swapped out for another? If so, return the model
407         name of the replacement; otherwise, return None.
408 
409         For historical reasons, model name lookups using get_model() are
410         case insensitive, so we make sure we are case insensitive here.
411         """
412         if self.swappable:
413             swapped_for = getattr(settings, self.swappable, None)
414             if swapped_for:
415                 try:
416                     swapped_label, swapped_object = swapped_for.split(".")
417                 except ValueError:
418                     # setting not in the format app_label.model_name
419                     # raising ImproperlyConfigured here causes problems with
420                     # test cleanup code - instead it is raised in get_user_model
421                     # or as part of validation.
422                     return swapped_for
423 
424                 if (
425                     "%s.%s" % (swapped_label, swapped_object.lower())
426                     != self.label_lower
427                 ):
428                     return swapped_for
429         return None
430 
431     @cached_property
432     def managers(self):
433         managers = []
434         seen_managers = set()
435         bases = (b for b in self.model.mro() if hasattr(b, "_meta"))
436         for depth, base in enumerate(bases):
437             for manager in base._meta.local_managers:
438                 if manager.name in seen_managers:
439                     continue
440 
441                 manager = copy.copy(manager)
442                 manager.model = self.model
443                 seen_managers.add(manager.name)
444                 managers.append((depth, manager.creation_counter, manager))
445 
446         return make_immutable_fields_list(
447             "managers",
448             (m[2] for m in sorted(managers)),
449         )
450 
451     @cached_property
452     def managers_map(self):
453         return {manager.name: manager for manager in self.managers}
454 
455     @cached_property
456     def base_manager(self):
457         base_manager_name = self.base_manager_name
458         if not base_manager_name:
459             # Get the first parent's base_manager_name if there's one.
460             for parent in self.model.mro()[1:]:
461                 if hasattr(parent, "_meta"):
462                     if parent._base_manager.name != "_base_manager":
463                         base_manager_name = parent._base_manager.name
464                     break
465 
466         if base_manager_name:
467             try:
468                 return self.managers_map[base_manager_name]
469             except KeyError:
470                 raise ValueError(
471                     "%s has no manager named %r"
472                     % (
473                         self.object_name,
474                         base_manager_name,
475                     )
476                 )
477 
478         manager = Manager()
479         manager.name = "_base_manager"
480         manager.model = self.model
481         manager.auto_created = True
482         return manager
483 
484     @cached_property
485     def default_manager(self):
486         default_manager_name = self.default_manager_name
487         if not default_manager_name and not self.local_managers:
488             # Get the first parent's default_manager_name if there's one.
489             for parent in self.model.mro()[1:]:
490                 if hasattr(parent, "_meta"):
491                     default_manager_name = parent._meta.default_manager_name
492                     break
493 
494         if default_manager_name:
495             try:
496                 return self.managers_map[default_manager_name]
497             except KeyError:
498                 raise ValueError(
499                     "%s has no manager named %r"
500                     % (
501                         self.object_name,
502                         default_manager_name,
503                     )
504                 )
505 
506         if self.managers:
507             return self.managers[0]
508 
509     @cached_property
510     def fields(self):
511         """
512         Return a list of all forward fields on the model and its parents,
513         excluding ManyToManyFields.
514 
515         Private API intended only to be used by Django itself; get_fields()
516         combined with filtering of field properties is the public API for
517         obtaining this field list.
518         """
519         # For legacy reasons, the fields property should only contain forward
520         # fields that are not private or with a m2m cardinality. Therefore we
521         # pass these three filters as filters to the generator.
522         # The third lambda is a longwinded way of checking f.related_model - we don't
523         # use that property directly because related_model is a cached property,
524         # and all the models may not have been loaded yet; we don't want to cache
525         # the string reference to the related_model.
526         def is_not_an_m2m_field(f):
527             return not (f.is_relation and f.many_to_many)
528 
529         def is_not_a_generic_relation(f):
530             return not (f.is_relation and f.one_to_many)
531 
532         def is_not_a_generic_foreign_key(f):
533             return not (
534                 f.is_relation
535                 and f.many_to_one
536                 and not (hasattr(f.remote_field, "model") and f.remote_field.model)
537             )
538 
539         return make_immutable_fields_list(
540             "fields",
541             (
542                 f
543                 for f in self._get_fields(reverse=False)
544                 if is_not_an_m2m_field(f)
545                 and is_not_a_generic_relation(f)
546                 and is_not_a_generic_foreign_key(f)
547             ),
548         )
549 
550     @cached_property
551     def concrete_fields(self):
552         """
553         Return a list of all concrete fields on the model and its parents.
554 
555         Private API intended only to be used by Django itself; get_fields()
556         combined with filtering of field properties is the public API for
557         obtaining this field list.
558         """
559         return make_immutable_fields_list(
560             "concrete_fields", (f for f in self.fields if f.concrete)
561         )
562 
563     @cached_property
564     def local_concrete_fields(self):
565         """
566         Return a list of all concrete fields on the model.
567 
568         Private API intended only to be used by Django itself; get_fields()
569         combined with filtering of field properties is the public API for
570         obtaining this field list.
571         """
572         return make_immutable_fields_list(
573             "local_concrete_fields", (f for f in self.local_fields if f.concrete)
574         )
575 
576     @cached_property
577     def many_to_many(self):
578         """
579         Return a list of all many to many fields on the model and its parents.
580 
581         Private API intended only to be used by Django itself; get_fields()
582         combined with filtering of field properties is the public API for
583         obtaining this list.
584         """
585         return make_immutable_fields_list(
586             "many_to_many",
587             (
588                 f
589                 for f in self._get_fields(reverse=False)
590                 if f.is_relation and f.many_to_many
591             ),
592         )
593 
594     @cached_property
595     def related_objects(self):
596         """
597         Return all related objects pointing to the current model. The related
598         objects can come from a one-to-one, one-to-many, or many-to-many field
599         relation type.
600 
601         Private API intended only to be used by Django itself; get_fields()
602         combined with filtering of field properties is the public API for
603         obtaining this field list.
604         """
605         all_related_fields = self._get_fields(
606             forward=False, reverse=True, include_hidden=True
607         )
608         return make_immutable_fields_list(
609             "related_objects",
610             (
611                 obj
612                 for obj in all_related_fields
613                 if not obj.hidden or obj.field.many_to_many
614             ),
615         )
616 
617     @cached_property
618     def _forward_fields_map(self):
619         res = {}
620         fields = self._get_fields(reverse=False)
621         for field in fields:
622             res[field.name] = field
623             # Due to the way Django's internals work, get_field() should also
624             # be able to fetch a field by attname. In the case of a concrete
625             # field with relation, includes the *_id name too
626             try:
627                 res[field.attname] = field
628             except AttributeError:
629                 pass
630         return res
631 
632     @cached_property
633     def fields_map(self):
634         res = {}
635         fields = self._get_fields(forward=False, include_hidden=True)
636         for field in fields:
637             res[field.name] = field
638             # Due to the way Django's internals work, get_field() should also
639             # be able to fetch a field by attname. In the case of a concrete
640             # field with relation, includes the *_id name too
641             try:
642                 res[field.attname] = field
643             except AttributeError:
644                 pass
645         return res
646 
647     def get_field(self, field_name):
648         """
649         Return a field instance given the name of a forward or reverse field.
650         """
651         try:
652             # In order to avoid premature loading of the relation tree
653             # (expensive) we prefer checking if the field is a forward field.
654             return self._forward_fields_map[field_name]
655         except KeyError:
656             # If the app registry is not ready, reverse fields are
657             # unavailable, therefore we throw a FieldDoesNotExist exception.
658             if not self.apps.models_ready:
659                 raise FieldDoesNotExist(
660                     "%s has no field named '%s'. The app cache isn't ready yet, "
661                     "so if this is an auto-created related field, it won't "
662                     "be available yet." % (self.object_name, field_name)
663                 )
664 
665         try:
666             # Retrieve field instance by name from cached or just-computed
667             # field map.
668             return self.fields_map[field_name]
669         except KeyError:
670             raise FieldDoesNotExist(
671                 "%s has no field named '%s'" % (self.object_name, field_name)
672             )
673 
674     def get_base_chain(self, model):
675         """
676         Return a list of parent classes leading to `model` (ordered from
677         closest to most distant ancestor). This has to handle the case where
678         `model` is a grandparent or even more distant relation.
679         """
680         if not self.parents:
681             return []
682         if model in self.parents:
683             return [model]
684         for parent in self.parents:
685             res = parent._meta.get_base_chain(model)
686             if res:
687                 res.insert(0, parent)
688                 return res
689         return []
690 
691     def get_parent_list(self):
692         """
693         Return all the ancestors of this model as a list ordered by MRO.
694         Useful for determining if something is an ancestor, regardless of lineage.
695         """
696         result = OrderedSet(self.parents)
697         for parent in self.parents:
698             for ancestor in parent._meta.get_parent_list():
699                 result.add(ancestor)
700         return list(result)
701 
702     def get_ancestor_link(self, ancestor):
703         """
704         Return the field on the current model which points to the given
705         "ancestor". This is possible an indirect link (a pointer to a parent
706         model, which points, eventually, to the ancestor). Used when
707         constructing table joins for model inheritance.
708 
709         Return None if the model isn't an ancestor of this one.
710         """
711         if ancestor in self.parents:
712             return self.parents[ancestor]
713         for parent in self.parents:
714             # Tries to get a link field from the immediate parent
715             parent_link = parent._meta.get_ancestor_link(ancestor)
716             if parent_link:
717                 # In case of a proxied model, the first link
718                 # of the chain to the ancestor is that parent
719                 # links
720                 return self.parents[parent] or parent_link
721 
722     def get_path_to_parent(self, parent):
723         """
724         Return a list of PathInfos containing the path from the current
725         model to the parent model, or an empty list if parent is not a
726         parent of the current model.
727         """
728         if self.model is parent:
729             return []
730         # Skip the chain of proxy to the concrete proxied model.
731         proxied_model = self.concrete_model
732         path = []
733         opts = self
734         for int_model in self.get_base_chain(parent):
735             if int_model is proxied_model:
736                 opts = int_model._meta
737             else:
738                 final_field = opts.parents[int_model]
739                 targets = (final_field.remote_field.get_related_field(),)
740                 opts = int_model._meta
741                 path.append(
742                     PathInfo(
743                         from_opts=final_field.model._meta,
744                         to_opts=opts,
745                         target_fields=targets,
746                         join_field=final_field,
747                         m2m=False,
748                         direct=True,
749                         filtered_relation=None,
750                     )
751                 )
752         return path
753 
754     def get_path_from_parent(self, parent):
755         """
756         Return a list of PathInfos containing the path from the parent
757         model to the current model, or an empty list if parent is not a
758         parent of the current model.
759         """
760         if self.model is parent:
761             return []
762         model = self.concrete_model
763         # Get a reversed base chain including both the current and parent
764         # models.
765         chain = model._meta.get_base_chain(parent)
766         chain.reverse()
767         chain.append(model)
768         # Construct a list of the PathInfos between models in chain.
769         path = []
770         for i, ancestor in enumerate(chain[:-1]):
771             child = chain[i + 1]
772             link = child._meta.get_ancestor_link(ancestor)
773             path.extend(link.reverse_path_infos)
774         return path
775 
776     def _populate_directed_relation_graph(self):
777         """
778         This method is used by each model to find its reverse objects. As this
779         method is very expensive and is accessed frequently (it looks up every
780         field in a model, in every app), it is computed on first access and then
781         is set as a property on every model.
782         """
783         related_objects_graph = defaultdict(list)
784 
785         all_models = self.apps.get_models(include_auto_created=True)
786         for model in all_models:
787             opts = model._meta
788             # Abstract model's fields are copied to child models, hence we will
789             # see the fields from the child models.
790             if opts.abstract:
791                 continue
792             fields_with_relations = (
793                 f
794                 for f in opts._get_fields(reverse=False, include_parents=False)
795                 if f.is_relation and f.related_model is not None
796             )
797             for f in fields_with_relations:
798                 if not isinstance(f.remote_field.model, str):
799                     remote_label = f.remote_field.model._meta.concrete_model._meta.label
800                     related_objects_graph[remote_label].append(f)
801 
802         for model in all_models:
803             # Set the relation_tree using the internal __dict__. In this way
804             # we avoid calling the cached property. In attribute lookup,
805             # __dict__ takes precedence over a data descriptor (such as
806             # @cached_property). This means that the _meta._relation_tree is
807             # only called if related_objects is not in __dict__.
808             related_objects = related_objects_graph[
809                 model._meta.concrete_model._meta.label
810             ]
811             model._meta.__dict__["_relation_tree"] = related_objects
812         # It seems it is possible that self is not in all_models, so guard
813         # against that with default for get().
814         return self.__dict__.get("_relation_tree", EMPTY_RELATION_TREE)
815 
816     @cached_property
817     def _relation_tree(self):
818         return self._populate_directed_relation_graph()
819 
820     def _expire_cache(self, forward=True, reverse=True):
821         # This method is usually called by apps.cache_clear(), when the
822         # registry is finalized, or when a new field is added.
823         if forward:
824             for cache_key in self.FORWARD_PROPERTIES:
825                 if cache_key in self.__dict__:
826                     delattr(self, cache_key)
827         if reverse and not self.abstract:
828             for cache_key in self.REVERSE_PROPERTIES:
829                 if cache_key in self.__dict__:
830                     delattr(self, cache_key)
831         self._get_fields_cache = {}
832 
833     def get_fields(self, include_parents=True, include_hidden=False):
834         """
835         Return a list of fields associated to the model. By default, include
836         forward and reverse fields, fields derived from inheritance, but not
837         hidden fields. The returned fields can be changed using the parameters:
838 
839         - include_parents: include fields derived from inheritance
840         - include_hidden:  include fields that have a related_name that
841                            starts with a "+"
842         """
843         if include_parents is False:
844             include_parents = PROXY_PARENTS
845         return self._get_fields(
846             include_parents=include_parents, include_hidden=include_hidden
847         )
848 
849     def _get_fields(
850         self,
851         forward=True,
852         reverse=True,
853         include_parents=True,
854         include_hidden=False,
855         seen_models=None,
856     ):
857         """
858         Internal helper function to return fields of the model.
859         * If forward=True, then fields defined on this model are returned.
860         * If reverse=True, then relations pointing to this model are returned.
861         * If include_hidden=True, then fields with is_hidden=True are returned.
862         * The include_parents argument toggles if fields from parent models
863           should be included. It has three values: True, False, and
864           PROXY_PARENTS. When set to PROXY_PARENTS, the call will return all
865           fields defined for the current model or any of its parents in the
866           parent chain to the model's concrete model.
867         """
868         if include_parents not in (True, False, PROXY_PARENTS):
869             raise TypeError(
870                 "Invalid argument for include_parents: %s" % (include_parents,)
871             )
872         # This helper function is used to allow recursion in ``get_fields()``
873         # implementation and to provide a fast way for Django's internals to
874         # access specific subsets of fields.
875 
876         # We must keep track of which models we have already seen. Otherwise we
877         # could include the same field multiple times from different models.
878         topmost_call = seen_models is None
879         if topmost_call:
880             seen_models = set()
881         seen_models.add(self.model)
882 
883         # Creates a cache key composed of all arguments
884         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
885 
886         try:
887             # In order to avoid list manipulation. Always return a shallow copy
888             # of the results.
889             return self._get_fields_cache[cache_key]
890         except KeyError:
891             pass
892 
893         fields = []
894         # Recursively call _get_fields() on each parent, with the same
895         # options provided in this call.
896         if include_parents is not False:
897             for parent in self.parents:
898                 # In diamond inheritance it is possible that we see the same
899                 # model from two different routes. In that case, avoid adding
900                 # fields from the same parent again.
901                 if parent in seen_models:
902                     continue
903                 if (
904                     parent._meta.concrete_model != self.concrete_model
905                     and include_parents == PROXY_PARENTS
906                 ):
907                     continue
908                 for obj in parent._meta._get_fields(
909                     forward=forward,
910                     reverse=reverse,
911                     include_parents=include_parents,
912                     include_hidden=include_hidden,
913                     seen_models=seen_models,
914                 ):
915                     if (
916                         not getattr(obj, "parent_link", False)
917                         or obj.model == self.concrete_model
918                     ):
919                         fields.append(obj)
920         if reverse and not self.proxy:
921             # Tree is computed once and cached until the app cache is expired.
922             # It is composed of a list of fields pointing to the current model
923             # from other models.
924             all_fields = self._relation_tree
925             for field in all_fields:
926                 # If hidden fields should be included or the relation is not
927                 # intentionally hidden, add to the fields dict.
928                 if include_hidden or not field.remote_field.hidden:
929                     fields.append(field.remote_field)
930 
931         if forward:
932             fields += self.local_fields
933             fields += self.local_many_to_many
934             # Private fields are recopied to each child model, and they get a
935             # different model as field.model in each child. Hence we have to
936             # add the private fields separately from the topmost call. If we
937             # did this recursively similar to local_fields, we would get field
938             # instances with field.model != self.model.
939             if topmost_call:
940                 fields += self.private_fields
941 
942         # In order to avoid list manipulation. Always
943         # return a shallow copy of the results
944         fields = make_immutable_fields_list("get_fields()", fields)
945 
946         # Store result into cache for later access
947         self._get_fields_cache[cache_key] = fields
948         return fields
949 
950     @cached_property
951     def total_unique_constraints(self):
952         """
953         Return a list of total unique constraints. Useful for determining set
954         of fields guaranteed to be unique for all rows.
955         """
956         return [
957             constraint
958             for constraint in self.constraints
959             if (
960                 isinstance(constraint, UniqueConstraint)
961                 and constraint.condition is None
962                 and not constraint.contains_expressions
963             )
964         ]
965 
966     @cached_property
967     def _property_names(self):
968         """Return a set of the names of the properties defined on the model."""
969         names = []
970         for name in dir(self.model):
971             attr = inspect.getattr_static(self.model, name)
972             if isinstance(attr, property):
973                 names.append(name)
974         return frozenset(names)
975 
976     @cached_property
977     def db_returning_fields(self):
978         """
979         Private API intended only to be used by Django itself.
980         Fields to be returned after a database insert.
981         """
982         return [
983             field
984             for field in self._get_fields(
985                 forward=True, reverse=False, include_parents=PROXY_PARENTS
986             )
987             if getattr(field, "db_returning", False)
988         ]

</code><intended_behavior>This file is where Django modelsâ€™ options are parsed and processed. The intended adjustment here is to either extend the current handling of `index_together` to ensure deprecation warnings are presented when it is used, signaling to developers to use `indexes` instead, or to transform `index_together` configurations into `indexes` within the Django ORM framework automatically. It should preserve the ability for Django to interpret model indexes for database schema creation and migrations without losing any existing functionalities or performance benefits.</intended_behavior>, <file>django/db/migrations/autodetector.py</file>
<class>None</class>
<method>None</method>
<code>
1 import functools
2 import re
3 from collections import defaultdict
4 from itertools import chain
5 
6 from django.conf import settings
7 from django.db import models
8 from django.db.migrations import operations
9 from django.db.migrations.migration import Migration
10 from django.db.migrations.operations.models import AlterModelOptions
11 from django.db.migrations.optimizer import MigrationOptimizer
12 from django.db.migrations.questioner import MigrationQuestioner
13 from django.db.migrations.utils import (
14     COMPILED_REGEX_TYPE,
15     RegexObject,
16     resolve_relation,
17 )
18 from django.utils.topological_sort import stable_topological_sort
19 
20 
21 class MigrationAutodetector:
22     """
23     Take a pair of ProjectStates and compare them to see what the first would
24     need doing to make it match the second (the second usually being the
25     project's current state).
26 
27     Note that this naturally operates on entire projects at a time,
28     as it's likely that changes interact (for example, you can't
29     add a ForeignKey without having a migration to add the table it
30     depends on first). A user interface may offer single-app usage
31     if it wishes, with the caveat that it may not always be possible.
32     """
33 
34     def __init__(self, from_state, to_state, questioner=None):
35         self.from_state = from_state
36         self.to_state = to_state
37         self.questioner = questioner or MigrationQuestioner()
38         self.existing_apps = {app for app, model in from_state.models}
39 
40     def changes(self, graph, trim_to_apps=None, convert_apps=None, migration_name=None):
41         """
42         Main entry point to produce a list of applicable changes.
43         Take a graph to base names on and an optional set of apps
44         to try and restrict to (restriction is not guaranteed)
45         """
46         changes = self._detect_changes(convert_apps, graph)
47         changes = self.arrange_for_graph(changes, graph, migration_name)
48         if trim_to_apps:
49             changes = self._trim_to_apps(changes, trim_to_apps)
50         return changes
51 
52     def deep_deconstruct(self, obj):
53         """
54         Recursive deconstruction for a field and its arguments.
55         Used for full comparison for rename/alter; sometimes a single-level
56         deconstruction will not compare correctly.
57         """
58         if isinstance(obj, list):
59             return [self.deep_deconstruct(value) for value in obj]
60         elif isinstance(obj, tuple):
61             return tuple(self.deep_deconstruct(value) for value in obj)
62         elif isinstance(obj, dict):
63             return {key: self.deep_deconstruct(value) for key, value in obj.items()}
64         elif isinstance(obj, functools.partial):
65             return (
66                 obj.func,
67                 self.deep_deconstruct(obj.args),
68                 self.deep_deconstruct(obj.keywords),
69             )
70         elif isinstance(obj, COMPILED_REGEX_TYPE):
71             return RegexObject(obj)
72         elif isinstance(obj, type):
73             # If this is a type that implements 'deconstruct' as an instance method,
74             # avoid treating this as being deconstructible itself - see #22951
75             return obj
76         elif hasattr(obj, "deconstruct"):
77             deconstructed = obj.deconstruct()
78             if isinstance(obj, models.Field):
79                 # we have a field which also returns a name
80                 deconstructed = deconstructed[1:]
81             path, args, kwargs = deconstructed
82             return (
83                 path,
84                 [self.deep_deconstruct(value) for value in args],
85                 {key: self.deep_deconstruct(value) for key, value in kwargs.items()},
86             )
87         else:
88             return obj
89 
90     def only_relation_agnostic_fields(self, fields):
91         """
92         Return a definition of the fields that ignores field names and
93         what related fields actually relate to. Used for detecting renames (as
94         the related fields change during renames).
95         """
96         fields_def = []
97         for name, field in sorted(fields.items()):
98             deconstruction = self.deep_deconstruct(field)
99             if field.remote_field and field.remote_field.model:
100                 deconstruction[2].pop("to", None)
101             fields_def.append(deconstruction)
102         return fields_def
103 
104     def _detect_changes(self, convert_apps=None, graph=None):
105         """
106         Return a dict of migration plans which will achieve the
107         change from from_state to to_state. The dict has app labels
108         as keys and a list of migrations as values.
109 
110         The resulting migrations aren't specially named, but the names
111         do matter for dependencies inside the set.
112 
113         convert_apps is the list of apps to convert to use migrations
114         (i.e. to make initial migrations for, in the usual case)
115 
116         graph is an optional argument that, if provided, can help improve
117         dependency generation and avoid potential circular dependencies.
118         """
119         # The first phase is generating all the operations for each app
120         # and gathering them into a big per-app list.
121         # Then go through that list, order it, and split into migrations to
122         # resolve dependencies caused by M2Ms and FKs.
123         self.generated_operations = {}
124         self.altered_indexes = {}
125         self.altered_constraints = {}
126         self.renamed_fields = {}
127 
128         # Prepare some old/new state and model lists, separating
129         # proxy models and ignoring unmigrated apps.
130         self.old_model_keys = set()
131         self.old_proxy_keys = set()
132         self.old_unmanaged_keys = set()
133         self.new_model_keys = set()
134         self.new_proxy_keys = set()
135         self.new_unmanaged_keys = set()
136         for (app_label, model_name), model_state in self.from_state.models.items():
137             if not model_state.options.get("managed", True):
138                 self.old_unmanaged_keys.add((app_label, model_name))
139             elif app_label not in self.from_state.real_apps:
140                 if model_state.options.get("proxy"):
141                     self.old_proxy_keys.add((app_label, model_name))
142                 else:
143                     self.old_model_keys.add((app_label, model_name))
144 
145         for (app_label, model_name), model_state in self.to_state.models.items():
146             if not model_state.options.get("managed", True):
147                 self.new_unmanaged_keys.add((app_label, model_name))
148             elif app_label not in self.from_state.real_apps or (
149                 convert_apps and app_label in convert_apps
150             ):
151                 if model_state.options.get("proxy"):
152                     self.new_proxy_keys.add((app_label, model_name))
153                 else:
154                     self.new_model_keys.add((app_label, model_name))
155 
156         self.from_state.resolve_fields_and_relations()
157         self.to_state.resolve_fields_and_relations()
158 
159         # Renames have to come first
160         self.generate_renamed_models()
161 
162         # Prepare lists of fields and generate through model map
163         self._prepare_field_lists()
164         self._generate_through_model_map()
165 
166         # Generate non-rename model operations
167         self.generate_deleted_models()
168         self.generate_created_models()
169         self.generate_deleted_proxies()
170         self.generate_created_proxies()
171         self.generate_altered_options()
172         self.generate_altered_managers()
173 
174         # Create the renamed fields and store them in self.renamed_fields.
175         # They are used by create_altered_indexes(), generate_altered_fields(),
176         # generate_removed_altered_index/unique_together(), and
177         # generate_altered_index/unique_together().
178         self.create_renamed_fields()
179         # Create the altered indexes and store them in self.altered_indexes.
180         # This avoids the same computation in generate_removed_indexes()
181         # and generate_added_indexes().
182         self.create_altered_indexes()
183         self.create_altered_constraints()
184         # Generate index removal operations before field is removed
185         self.generate_removed_constraints()
186         self.generate_removed_indexes()
187         # Generate field renaming operations.
188         self.generate_renamed_fields()
189         self.generate_renamed_indexes()
190         # Generate removal of foo together.
191         self.generate_removed_altered_unique_together()
192         self.generate_removed_altered_index_together()
193         # Generate field operations.
194         self.generate_removed_fields()
195         self.generate_added_fields()
196         self.generate_altered_fields()
197         self.generate_altered_order_with_respect_to()
198         self.generate_altered_unique_together()
199         self.generate_altered_index_together()
200         self.generate_added_indexes()
201         self.generate_added_constraints()
202         self.generate_altered_db_table()
203 
204         self._sort_migrations()
205         self._build_migration_list(graph)
206         self._optimize_migrations()
207 
208         return self.migrations
209 
210     def _prepare_field_lists(self):
211         """
212         Prepare field lists and a list of the fields that used through models
213         in the old state so dependencies can be made from the through model
214         deletion to the field that uses it.
215         """
216         self.kept_model_keys = self.old_model_keys & self.new_model_keys
217         self.kept_proxy_keys = self.old_proxy_keys & self.new_proxy_keys
218         self.kept_unmanaged_keys = self.old_unmanaged_keys & self.new_unmanaged_keys
219         self.through_users = {}
220         self.old_field_keys = {
221             (app_label, model_name, field_name)
222             for app_label, model_name in self.kept_model_keys
223             for field_name in self.from_state.models[
224                 app_label, self.renamed_models.get((app_label, model_name), model_name)
225             ].fields
226         }
227         self.new_field_keys = {
228             (app_label, model_name, field_name)
229             for app_label, model_name in self.kept_model_keys
230             for field_name in self.to_state.models[app_label, model_name].fields
231         }
232 
233     def _generate_through_model_map(self):
234         """Through model map generation."""
235         for app_label, model_name in sorted(self.old_model_keys):
236             old_model_name = self.renamed_models.get(
237                 (app_label, model_name), model_name
238             )
239             old_model_state = self.from_state.models[app_label, old_model_name]
240             for field_name, field in old_model_state.fields.items():
241                 if hasattr(field, "remote_field") and getattr(
242                     field.remote_field, "through", None
243                 ):
244                     through_key = resolve_relation(
245                         field.remote_field.through, app_label, model_name
246                     )
247                     self.through_users[through_key] = (
248                         app_label,
249                         old_model_name,
250                         field_name,
251                     )
252 
253     @staticmethod
254     def _resolve_dependency(dependency):
255         """
256         Return the resolved dependency and a boolean denoting whether or not
257         it was swappable.
258         """
259         if dependency[0] != "__setting__":
260             return dependency, False
261         resolved_app_label, resolved_object_name = getattr(
262             settings, dependency[1]
263         ).split(".")
264         return (resolved_app_label, resolved_object_name.lower()) + dependency[2:], True
265 
266     def _build_migration_list(self, graph=None):
267         """
268         Chop the lists of operations up into migrations with dependencies on
269         each other. Do this by going through an app's list of operations until
270         one is found that has an outgoing dependency that isn't in another
271         app's migration yet (hasn't been chopped off its list). Then chop off
272         the operations before it into a migration and move onto the next app.
273         If the loops completes without doing anything, there's a circular
274         dependency (which _should_ be impossible as the operations are
275         all split at this point so they can't depend and be depended on).
276         """
277         self.migrations = {}
278         num_ops = sum(len(x) for x in self.generated_operations.values())
279         chop_mode = False
280         while num_ops:
281             # On every iteration, we step through all the apps and see if there
282             # is a completed set of operations.
283             # If we find that a subset of the operations are complete we can
284             # try to chop it off from the rest and continue, but we only
285             # do this if we've already been through the list once before
286             # without any chopping and nothing has changed.
287             for app_label in sorted(self.generated_operations):
288                 chopped = []
289                 dependencies = set()
290                 for operation in list(self.generated_operations[app_label]):
291                     deps_satisfied = True
292                     operation_dependencies = set()
293                     for dep in operation._auto_deps:
294                         # Temporarily resolve the swappable dependency to
295                         # prevent circular references. While keeping the
296                         # dependency checks on the resolved model, add the
297                         # swappable dependencies.
298                         original_dep = dep
299                         dep, is_swappable_dep = self._resolve_dependency(dep)
300                         if dep[0] != app_label:
301                             # External app dependency. See if it's not yet
302                             # satisfied.
303                             for other_operation in self.generated_operations.get(
304                                 dep[0], []
305                             ):
306                                 if self.check_dependency(other_operation, dep):
307                                     deps_satisfied = False
308                                     break
309                             if not deps_satisfied:
310                                 break
311                             else:
312                                 if is_swappable_dep:
313                                     operation_dependencies.add(
314                                         (original_dep[0], original_dep[1])
315                                     )
316                                 elif dep[0] in self.migrations:
317                                     operation_dependencies.add(
318                                         (dep[0], self.migrations[dep[0]][-1].name)
319                                     )
320                                 else:
321                                     # If we can't find the other app, we add a
322                                     # first/last dependency, but only if we've
323                                     # already been through once and checked
324                                     # everything.
325                                     if chop_mode:
326                                         # If the app already exists, we add a
327                                         # dependency on the last migration, as
328                                         # we don't know which migration
329                                         # contains the target field. If it's
330                                         # not yet migrated or has no
331                                         # migrations, we use __first__.
332                                         if graph and graph.leaf_nodes(dep[0]):
333                                             operation_dependencies.add(
334                                                 graph.leaf_nodes(dep[0])[0]
335                                             )
336                                         else:
337                                             operation_dependencies.add(
338                                                 (dep[0], "__first__")
339                                             )
340                                     else:
341                                         deps_satisfied = False
342                     if deps_satisfied:
343                         chopped.append(operation)
344                         dependencies.update(operation_dependencies)
345                         del self.generated_operations[app_label][0]
346                     else:
347                         break
348                 # Make a migration! Well, only if there's stuff to put in it
349                 if dependencies or chopped:
350                     if not self.generated_operations[app_label] or chop_mode:
351                         subclass = type(
352                             "Migration",
353                             (Migration,),
354                             {"operations": [], "dependencies": []},
355                         )
356                         instance = subclass(
357                             "auto_%i" % (len(self.migrations.get(app_label, [])) + 1),
358                             app_label,
359                         )
360                         instance.dependencies = list(dependencies)
361                         instance.operations = chopped
362                         instance.initial = app_label not in self.existing_apps
363                         self.migrations.setdefault(app_label, []).append(instance)
364                         chop_mode = False
365                     else:
366                         self.generated_operations[app_label] = (
367                             chopped + self.generated_operations[app_label]
368                         )
369             new_num_ops = sum(len(x) for x in self.generated_operations.values())
370             if new_num_ops == num_ops:
371                 if not chop_mode:
372                     chop_mode = True
373                 else:
374                     raise ValueError(
375                         "Cannot resolve operation dependencies: %r"
376                         % self.generated_operations
377                     )
378             num_ops = new_num_ops
379 
380     def _sort_migrations(self):
381         """
382         Reorder to make things possible. Reordering may be needed so FKs work
383         nicely inside the same app.
384         """
385         for app_label, ops in sorted(self.generated_operations.items()):
386             # construct a dependency graph for intra-app dependencies
387             dependency_graph = {op: set() for op in ops}
388             for op in ops:
389                 for dep in op._auto_deps:
390                     # Resolve intra-app dependencies to handle circular
391                     # references involving a swappable model.
392                     dep = self._resolve_dependency(dep)[0]
393                     if dep[0] == app_label:
394                         for op2 in ops:
395                             if self.check_dependency(op2, dep):
396                                 dependency_graph[op].add(op2)
397 
398             # we use a stable sort for deterministic tests & general behavior
399             self.generated_operations[app_label] = stable_topological_sort(
400                 ops, dependency_graph
401             )
402 
403     def _optimize_migrations(self):
404         # Add in internal dependencies among the migrations
405         for app_label, migrations in self.migrations.items():
406             for m1, m2 in zip(migrations, migrations[1:]):
407                 m2.dependencies.append((app_label, m1.name))
408 
409         # De-dupe dependencies
410         for migrations in self.migrations.values():
411             for migration in migrations:
412                 migration.dependencies = list(set(migration.dependencies))
413 
414         # Optimize migrations
415         for app_label, migrations in self.migrations.items():
416             for migration in migrations:
417                 migration.operations = MigrationOptimizer().optimize(
418                     migration.operations, app_label
419                 )
420 
421     def check_dependency(self, operation, dependency):
422         """
423         Return True if the given operation depends on the given dependency,
424         False otherwise.
425         """
426         # Created model
427         if dependency[2] is None and dependency[3] is True:
428             return (
429                 isinstance(operation, operations.CreateModel)
430                 and operation.name_lower == dependency[1].lower()
431             )
432         # Created field
433         elif dependency[2] is not None and dependency[3] is True:
434             return (
435                 isinstance(operation, operations.CreateModel)
436                 and operation.name_lower == dependency[1].lower()
437                 and any(dependency[2] == x for x, y in operation.fields)
438             ) or (
439                 isinstance(operation, operations.AddField)
440                 and operation.model_name_lower == dependency[1].lower()
441                 and operation.name_lower == dependency[2].lower()
442             )
443         # Removed field
444         elif dependency[2] is not None and dependency[3] is False:
445             return (
446                 isinstance(operation, operations.RemoveField)
447                 and operation.model_name_lower == dependency[1].lower()
448                 and operation.name_lower == dependency[2].lower()
449             )
450         # Removed model
451         elif dependency[2] is None and dependency[3] is False:
452             return (
453                 isinstance(operation, operations.DeleteModel)
454                 and operation.name_lower == dependency[1].lower()
455             )
456         # Field being altered
457         elif dependency[2] is not None and dependency[3] == "alter":
458             return (
459                 isinstance(operation, operations.AlterField)
460                 and operation.model_name_lower == dependency[1].lower()
461                 and operation.name_lower == dependency[2].lower()
462             )
463         # order_with_respect_to being unset for a field
464         elif dependency[2] is not None and dependency[3] == "order_wrt_unset":
465             return (
466                 isinstance(operation, operations.AlterOrderWithRespectTo)
467                 and operation.name_lower == dependency[1].lower()
468                 and (operation.order_with_respect_to or "").lower()
469                 != dependency[2].lower()
470             )
471         # Field is removed and part of an index/unique_together
472         elif dependency[2] is not None and dependency[3] == "foo_together_change":
473             return (
474                 isinstance(
475                     operation,
476                     (operations.AlterUniqueTogether, operations.AlterIndexTogether),
477                 )
478                 and operation.name_lower == dependency[1].lower()
479             )
480         # Unknown dependency. Raise an error.
481         else:
482             raise ValueError("Can't handle dependency %r" % (dependency,))
483 
484     def add_operation(self, app_label, operation, dependencies=None, beginning=False):
485         # Dependencies are
486         # (app_label, model_name, field_name, create/delete as True/False)
487         operation._auto_deps = dependencies or []
488         if beginning:
489             self.generated_operations.setdefault(app_label, []).insert(0, operation)
490         else:
491             self.generated_operations.setdefault(app_label, []).append(operation)
492 
493     def swappable_first_key(self, item):
494         """
495         Place potential swappable models first in lists of created models (only
496         real way to solve #22783).
497         """
498         try:
499             model_state = self.to_state.models[item]
500             base_names = {
501                 base if isinstance(base, str) else base.__name__
502                 for base in model_state.bases
503             }
504             string_version = "%s.%s" % (item[0], item[1])
505             if (
506                 model_state.options.get("swappable")
507                 or "AbstractUser" in base_names
508                 or "AbstractBaseUser" in base_names
509                 or settings.AUTH_USER_MODEL.lower() == string_version.lower()
510             ):
511                 return ("___" + item[0], "___" + item[1])
512         except LookupError:
513             pass
514         return item
515 
516     def generate_renamed_models(self):
517         """
518         Find any renamed models, generate the operations for them, and remove
519         the old entry from the model lists. Must be run before other
520         model-level generation.
521         """
522         self.renamed_models = {}
523         self.renamed_models_rel = {}
524         added_models = self.new_model_keys - self.old_model_keys
525         for app_label, model_name in sorted(added_models):
526             model_state = self.to_state.models[app_label, model_name]
527             model_fields_def = self.only_relation_agnostic_fields(model_state.fields)
528 
529             removed_models = self.old_model_keys - self.new_model_keys
530             for rem_app_label, rem_model_name in removed_models:
531                 if rem_app_label == app_label:
532                     rem_model_state = self.from_state.models[
533                         rem_app_label, rem_model_name
534                     ]
535                     rem_model_fields_def = self.only_relation_agnostic_fields(
536                         rem_model_state.fields
537                     )
538                     if model_fields_def == rem_model_fields_def:
539                         if self.questioner.ask_rename_model(
540                             rem_model_state, model_state
541                         ):
542                             dependencies = []
543                             fields = list(model_state.fields.values()) + [
544                                 field.remote_field
545                                 for relations in self.to_state.relations[
546                                     app_label, model_name
547                                 ].values()
548                                 for field in relations.values()
549                             ]
550                             for field in fields:
551                                 if field.is_relation:
552                                     dependencies.extend(
553                                         self._get_dependencies_for_foreign_key(
554                                             app_label,
555                                             model_name,
556                                             field,
557                                             self.to_state,
558                                         )
559                                     )
560                             self.add_operation(
561                                 app_label,
562                                 operations.RenameModel(
563                                     old_name=rem_model_state.name,
564                                     new_name=model_state.name,
565                                 ),
566                                 dependencies=dependencies,
567                             )
568                             self.renamed_models[app_label, model_name] = rem_model_name
569                             renamed_models_rel_key = "%s.%s" % (
570                                 rem_model_state.app_label,
571                                 rem_model_state.name_lower,
572                             )
573                             self.renamed_models_rel[
574                                 renamed_models_rel_key
575                             ] = "%s.%s" % (
576                                 model_state.app_label,
577                                 model_state.name_lower,
578                             )
579                             self.old_model_keys.remove((rem_app_label, rem_model_name))
580                             self.old_model_keys.add((app_label, model_name))
581                             break
582 
583     def generate_created_models(self):
584         """
585         Find all new models (both managed and unmanaged) and make create
586         operations for them as well as separate operations to create any
587         foreign key or M2M relationships (these are optimized later, if
588         possible).
589 
590         Defer any model options that refer to collections of fields that might
591         be deferred (e.g. unique_together, index_together).
592         """
593         old_keys = self.old_model_keys | self.old_unmanaged_keys
594         added_models = self.new_model_keys - old_keys
595         added_unmanaged_models = self.new_unmanaged_keys - old_keys
596         all_added_models = chain(
597             sorted(added_models, key=self.swappable_first_key, reverse=True),
598             sorted(added_unmanaged_models, key=self.swappable_first_key, reverse=True),
599         )
600         for app_label, model_name in all_added_models:
601             model_state = self.to_state.models[app_label, model_name]
602             # Gather related fields
603             related_fields = {}
604             primary_key_rel = None
605             for field_name, field in model_state.fields.items():
606                 if field.remote_field:
607                     if field.remote_field.model:
608                         if field.primary_key:
609                             primary_key_rel = field.remote_field.model
610                         elif not field.remote_field.parent_link:
611                             related_fields[field_name] = field
612                     if getattr(field.remote_field, "through", None):
613                         related_fields[field_name] = field
614 
615             # Are there indexes/unique|index_together to defer?
616             indexes = model_state.options.pop("indexes")
617             constraints = model_state.options.pop("constraints")
618             unique_together = model_state.options.pop("unique_together", None)
619             index_together = model_state.options.pop("index_together", None)
620             order_with_respect_to = model_state.options.pop(
621                 "order_with_respect_to", None
622             )
623             # Depend on the deletion of any possible proxy version of us
624             dependencies = [
625                 (app_label, model_name, None, False),
626             ]
627             # Depend on all bases
628             for base in model_state.bases:
629                 if isinstance(base, str) and "." in base:
630                     base_app_label, base_name = base.split(".", 1)
631                     dependencies.append((base_app_label, base_name, None, True))
632                     # Depend on the removal of base fields if the new model has
633                     # a field with the same name.
634                     old_base_model_state = self.from_state.models.get(
635                         (base_app_label, base_name)
636                     )
637                     new_base_model_state = self.to_state.models.get(
638                         (base_app_label, base_name)
639                     )
640                     if old_base_model_state and new_base_model_state:
641                         removed_base_fields = (
642                             set(old_base_model_state.fields)
643                             .difference(
644                                 new_base_model_state.fields,
645                             )
646                             .intersection(model_state.fields)
647                         )
648                         for removed_base_field in removed_base_fields:
649                             dependencies.append(
650                                 (base_app_label, base_name, removed_base_field, False)
651                             )
652             # Depend on the other end of the primary key if it's a relation
653             if primary_key_rel:
654                 dependencies.append(
655                     resolve_relation(
656                         primary_key_rel,
657                         app_label,
658                         model_name,
659                     )
660                     + (None, True)
661                 )
662             # Generate creation operation
663             self.add_operation(
664                 app_label,
665                 operations.CreateModel(
666                     name=model_state.name,
667                     fields=[
668                         d
669                         for d in model_state.fields.items()
670                         if d[0] not in related_fields
671                     ],
672                     options=model_state.options,
673                     bases=model_state.bases,
674                     managers=model_state.managers,
675                 ),
676                 dependencies=dependencies,
677                 beginning=True,
678             )
679 
680             # Don't add operations which modify the database for unmanaged models
681             if not model_state.options.get("managed", True):
682                 continue
683 
684             # Generate operations for each related field
685             for name, field in sorted(related_fields.items()):
686                 dependencies = self._get_dependencies_for_foreign_key(
687                     app_label,
688                     model_name,
689                     field,
690                     self.to_state,
691                 )
692                 # Depend on our own model being created
693                 dependencies.append((app_label, model_name, None, True))
694                 # Make operation
695                 self.add_operation(
696                     app_label,
697                     operations.AddField(
698                         model_name=model_name,
699                         name=name,
700                         field=field,
701                     ),
702                     dependencies=list(set(dependencies)),
703                 )
704             # Generate other opns
705             if order_with_respect_to:
706                 self.add_operation(
707                     app_label,
708                     operations.AlterOrderWithRespectTo(
709                         name=model_name,
710                         order_with_respect_to=order_with_respect_to,
711                     ),
712                     dependencies=[
713                         (app_label, model_name, order_with_respect_to, True),
714                         (app_label, model_name, None, True),
715                     ],
716                 )
717             related_dependencies = [
718                 (app_label, model_name, name, True) for name in sorted(related_fields)
719             ]
720             related_dependencies.append((app_label, model_name, None, True))
721             for index in indexes:
722                 self.add_operation(
723                     app_label,
724                     operations.AddIndex(
725                         model_name=model_name,
726                         index=index,
727                     ),
728                     dependencies=related_dependencies,
729                 )
730             for constraint in constraints:
731                 self.add_operation(
732                     app_label,
733                     operations.AddConstraint(
734                         model_name=model_name,
735                         constraint=constraint,
736                     ),
737                     dependencies=related_dependencies,
738                 )
739             if unique_together:
740                 self.add_operation(
741                     app_label,
742                     operations.AlterUniqueTogether(
743                         name=model_name,
744                         unique_together=unique_together,
745                     ),
746                     dependencies=related_dependencies,
747                 )
748             if index_together:
749                 self.add_operation(
750                     app_label,
751                     operations.AlterIndexTogether(
752                         name=model_name,
753                         index_together=index_together,
754                     ),
755                     dependencies=related_dependencies,
756                 )
757             # Fix relationships if the model changed from a proxy model to a
758             # concrete model.
759             relations = self.to_state.relations
760             if (app_label, model_name) in self.old_proxy_keys:
761                 for related_model_key, related_fields in relations[
762                     app_label, model_name
763                 ].items():
764                     related_model_state = self.to_state.models[related_model_key]
765                     for related_field_name, related_field in related_fields.items():
766                         self.add_operation(
767                             related_model_state.app_label,
768                             operations.AlterField(
769                                 model_name=related_model_state.name,
770                                 name=related_field_name,
771                                 field=related_field,
772                             ),
773                             dependencies=[(app_label, model_name, None, True)],
774                         )
775 
776     def generate_created_proxies(self):
777         """
778         Make CreateModel statements for proxy models. Use the same statements
779         as that way there's less code duplication, but for proxy models it's
780         safe to skip all the pointless field stuff and chuck out an operation.
781         """
782         added = self.new_proxy_keys - self.old_proxy_keys
783         for app_label, model_name in sorted(added):
784             model_state = self.to_state.models[app_label, model_name]
785             assert model_state.options.get("proxy")
786             # Depend on the deletion of any possible non-proxy version of us
787             dependencies = [
788                 (app_label, model_name, None, False),
789             ]
790             # Depend on all bases
791             for base in model_state.bases:
792                 if isinstance(base, str) and "." in base:
793                     base_app_label, base_name = base.split(".", 1)
794                     dependencies.append((base_app_label, base_name, None, True))
795             # Generate creation operation
796             self.add_operation(
797                 app_label,
798                 operations.CreateModel(
799                     name=model_state.name,
800                     fields=[],
801                     options=model_state.options,
802                     bases=model_state.bases,
803                     managers=model_state.managers,
804                 ),
805                 # Depend on the deletion of any possible non-proxy version of us
806                 dependencies=dependencies,
807             )
808 
809     def generate_deleted_models(self):
810         """
811         Find all deleted models (managed and unmanaged) and make delete
812         operations for them as well as separate operations to delete any
813         foreign key or M2M relationships (these are optimized later, if
814         possible).
815 
816         Also bring forward removal of any model options that refer to
817         collections of fields - the inverse of generate_created_models().
818         """
819         new_keys = self.new_model_keys | self.new_unmanaged_keys
820         deleted_models = self.old_model_keys - new_keys
821         deleted_unmanaged_models = self.old_unmanaged_keys - new_keys
822         all_deleted_models = chain(
823             sorted(deleted_models), sorted(deleted_unmanaged_models)
824         )
825         for app_label, model_name in all_deleted_models:
826             model_state = self.from_state.models[app_label, model_name]
827             # Gather related fields
828             related_fields = {}
829             for field_name, field in model_state.fields.items():
830                 if field.remote_field:
831                     if field.remote_field.model:
832                         related_fields[field_name] = field
833                     if getattr(field.remote_field, "through", None):
834                         related_fields[field_name] = field
835             # Generate option removal first
836             unique_together = model_state.options.pop("unique_together", None)
837             index_together = model_state.options.pop("index_together", None)
838             if unique_together:
839                 self.add_operation(
840                     app_label,
841                     operations.AlterUniqueTogether(
842                         name=model_name,
843                         unique_together=None,
844                     ),
845                 )
846             if index_together:
847                 self.add_operation(
848                     app_label,
849                     operations.AlterIndexTogether(
850                         name=model_name,
851                         index_together=None,
852                     ),
853                 )
854             # Then remove each related field
855             for name in sorted(related_fields):
856                 self.add_operation(
857                     app_label,
858                     operations.RemoveField(
859                         model_name=model_name,
860                         name=name,
861                     ),
862                 )
863             # Finally, remove the model.
864             # This depends on both the removal/alteration of all incoming fields
865             # and the removal of all its own related fields, and if it's
866             # a through model the field that references it.
867             dependencies = []
868             relations = self.from_state.relations
869             for (
870                 related_object_app_label,
871                 object_name,
872             ), relation_related_fields in relations[app_label, model_name].items():
873                 for field_name, field in relation_related_fields.items():
874                     dependencies.append(
875                         (related_object_app_label, object_name, field_name, False),
876                     )
877                     if not field.many_to_many:
878                         dependencies.append(
879                             (
880                                 related_object_app_label,
881                                 object_name,
882                                 field_name,
883                                 "alter",
884                             ),
885                         )
886 
887             for name in sorted(related_fields):
888                 dependencies.append((app_label, model_name, name, False))
889             # We're referenced in another field's through=
890             through_user = self.through_users.get((app_label, model_state.name_lower))
891             if through_user:
892                 dependencies.append(
893                     (through_user[0], through_user[1], through_user[2], False)
894                 )
895             # Finally, make the operation, deduping any dependencies
896             self.add_operation(
897                 app_label,
898                 operations.DeleteModel(
899                     name=model_state.name,
900                 ),
901                 dependencies=list(set(dependencies)),
902             )
903 
904     def generate_deleted_proxies(self):
905         """Make DeleteModel options for proxy models."""
906         deleted = self.old_proxy_keys - self.new_proxy_keys
907         for app_label, model_name in sorted(deleted):
908             model_state = self.from_state.models[app_label, model_name]
909             assert model_state.options.get("proxy")
910             self.add_operation(
911                 app_label,
912                 operations.DeleteModel(
913                     name=model_state.name,
914                 ),
915             )
916 
917     def create_renamed_fields(self):
918         """Work out renamed fields."""
919         self.renamed_operations = []
920         old_field_keys = self.old_field_keys.copy()
921         for app_label, model_name, field_name in sorted(
922             self.new_field_keys - old_field_keys
923         ):
924             old_model_name = self.renamed_models.get(
925                 (app_label, model_name), model_name
926             )
927             old_model_state = self.from_state.models[app_label, old_model_name]
928             new_model_state = self.to_state.models[app_label, model_name]
929             field = new_model_state.get_field(field_name)
930             # Scan to see if this is actually a rename!
931             field_dec = self.deep_deconstruct(field)
932             for rem_app_label, rem_model_name, rem_field_name in sorted(
933                 old_field_keys - self.new_field_keys
934             ):
935                 if rem_app_label == app_label and rem_model_name == model_name:
936                     old_field = old_model_state.get_field(rem_field_name)
937                     old_field_dec = self.deep_deconstruct(old_field)
938                     if (
939                         field.remote_field
940                         and field.remote_field.model
941                         and "to" in old_field_dec[2]
942                     ):
943                         old_rel_to = old_field_dec[2]["to"]
944                         if old_rel_to in self.renamed_models_rel:
945                             old_field_dec[2]["to"] = self.renamed_models_rel[old_rel_to]
946                     old_field.set_attributes_from_name(rem_field_name)
947                     old_db_column = old_field.get_attname_column()[1]
948                     if old_field_dec == field_dec or (
949                         # Was the field renamed and db_column equal to the
950                         # old field's column added?
951                         old_field_dec[0:2] == field_dec[0:2]
952                         and dict(old_field_dec[2], db_column=old_db_column)
953                         == field_dec[2]
954                     ):
955                         if self.questioner.ask_rename(
956                             model_name, rem_field_name, field_name, field
957                         ):
958                             self.renamed_operations.append(
959                                 (
960                                     rem_app_label,
961                                     rem_model_name,
962                                     old_field.db_column,
963                                     rem_field_name,
964                                     app_label,
965                                     model_name,
966                                     field,
967                                     field_name,
968                                 )
969                             )
970                             old_field_keys.remove(
971                                 (rem_app_label, rem_model_name, rem_field_name)
972                             )
973                             old_field_keys.add((app_label, model_name, field_name))
974                             self.renamed_fields[
975                                 app_label, model_name, field_name
976                             ] = rem_field_name
977                             break
978 
979     def generate_renamed_fields(self):
980         """Generate RenameField operations."""
981         for (
982             rem_app_label,
983             rem_model_name,
984             rem_db_column,
985             rem_field_name,
986             app_label,
987             model_name,
988             field,
989             field_name,
990         ) in self.renamed_operations:
991             # A db_column mismatch requires a prior noop AlterField for the
992             # subsequent RenameField to be a noop on attempts at preserving the
993             # old name.
994             if rem_db_column != field.db_column:
995                 altered_field = field.clone()
996                 altered_field.name = rem_field_name
997                 self.add_operation(
998                     app_label,
999                     operations.AlterField(
1000                         model_name=model_name,
1001                         name=rem_field_name,
1002                         field=altered_field,
1003                     ),
1004                 )
1005             self.add_operation(
1006                 app_label,
1007                 operations.RenameField(
1008                     model_name=model_name,
1009                     old_name=rem_field_name,
1010                     new_name=field_name,
1011                 ),
1012             )
1013             self.old_field_keys.remove((rem_app_label, rem_model_name, rem_field_name))
1014             self.old_field_keys.add((app_label, model_name, field_name))
1015 
1016     def generate_added_fields(self):
1017         """Make AddField operations."""
1018         for app_label, model_name, field_name in sorted(
1019             self.new_field_keys - self.old_field_keys
1020         ):
1021             self._generate_added_field(app_label, model_name, field_name)
1022 
1023     def _generate_added_field(self, app_label, model_name, field_name):
1024         field = self.to_state.models[app_label, model_name].get_field(field_name)
1025         # Adding a field always depends at least on its removal.
1026         dependencies = [(app_label, model_name, field_name, False)]
1027         # Fields that are foreignkeys/m2ms depend on stuff.
1028         if field.remote_field and field.remote_field.model:
1029             dependencies.extend(
1030                 self._get_dependencies_for_foreign_key(
1031                     app_label,
1032                     model_name,
1033                     field,
1034                     self.to_state,
1035                 )
1036             )
1037         # You can't just add NOT NULL fields with no default or fields
1038         # which don't allow empty strings as default.
1039         time_fields = (models.DateField, models.DateTimeField, models.TimeField)
1040         preserve_default = (
1041             field.null
1042             or field.has_default()
1043             or field.many_to_many
1044             or (field.blank and field.empty_strings_allowed)
1045             or (isinstance(field, time_fields) and field.auto_now)
1046         )
1047         if not preserve_default:
1048             field = field.clone()
1049             if isinstance(field, time_fields) and field.auto_now_add:
1050                 field.default = self.questioner.ask_auto_now_add_addition(
1051                     field_name, model_name
1052                 )
1053             else:
1054                 field.default = self.questioner.ask_not_null_addition(
1055                     field_name, model_name
1056                 )
1057         if (
1058             field.unique
1059             and field.default is not models.NOT_PROVIDED
1060             and callable(field.default)
1061         ):
1062             self.questioner.ask_unique_callable_default_addition(field_name, model_name)
1063         self.add_operation(
1064             app_label,
1065             operations.AddField(
1066                 model_name=model_name,
1067                 name=field_name,
1068                 field=field,
1069                 preserve_default=preserve_default,
1070             ),
1071             dependencies=dependencies,
1072         )
1073 
1074     def generate_removed_fields(self):
1075         """Make RemoveField operations."""
1076         for app_label, model_name, field_name in sorted(
1077             self.old_field_keys - self.new_field_keys
1078         ):
1079             self._generate_removed_field(app_label, model_name, field_name)
1080 
1081     def _generate_removed_field(self, app_label, model_name, field_name):
1082         self.add_operation(
1083             app_label,
1084             operations.RemoveField(
1085                 model_name=model_name,
1086                 name=field_name,
1087             ),
1088             # We might need to depend on the removal of an
1089             # order_with_respect_to or index/unique_together operation;
1090             # this is safely ignored if there isn't one
1091             dependencies=[
1092                 (app_label, model_name, field_name, "order_wrt_unset"),
1093                 (app_label, model_name, field_name, "foo_together_change"),
1094             ],
1095         )
1096 
1097     def generate_altered_fields(self):
1098         """
1099         Make AlterField operations, or possibly RemovedField/AddField if alter
1100         isn't possible.
1101         """
1102         for app_label, model_name, field_name in sorted(
1103             self.old_field_keys & self.new_field_keys
1104         ):
1105             # Did the field change?
1106             old_model_name = self.renamed_models.get(
1107                 (app_label, model_name), model_name
1108             )
1109             old_field_name = self.renamed_fields.get(
1110                 (app_label, model_name, field_name), field_name
1111             )
1112             old_field = self.from_state.models[app_label, old_model_name].get_field(
1113                 old_field_name
1114             )
1115             new_field = self.to_state.models[app_label, model_name].get_field(
1116                 field_name
1117             )
1118             dependencies = []
1119             # Implement any model renames on relations; these are handled by RenameModel
1120             # so we need to exclude them from the comparison
1121             if hasattr(new_field, "remote_field") and getattr(
1122                 new_field.remote_field, "model", None
1123             ):
1124                 rename_key = resolve_relation(
1125                     new_field.remote_field.model, app_label, model_name
1126                 )
1127                 if rename_key in self.renamed_models:
1128                     new_field.remote_field.model = old_field.remote_field.model
1129                 # Handle ForeignKey which can only have a single to_field.
1130                 remote_field_name = getattr(new_field.remote_field, "field_name", None)
1131                 if remote_field_name:
1132                     to_field_rename_key = rename_key + (remote_field_name,)
1133                     if to_field_rename_key in self.renamed_fields:
1134                         # Repoint both model and field name because to_field
1135                         # inclusion in ForeignKey.deconstruct() is based on
1136                         # both.
1137                         new_field.remote_field.model = old_field.remote_field.model
1138                         new_field.remote_field.field_name = (
1139                             old_field.remote_field.field_name
1140                         )
1141                 # Handle ForeignObjects which can have multiple from_fields/to_fields.
1142                 from_fields = getattr(new_field, "from_fields", None)
1143                 if from_fields:
1144                     from_rename_key = (app_label, model_name)
1145                     new_field.from_fields = tuple(
1146                         [
1147                             self.renamed_fields.get(
1148                                 from_rename_key + (from_field,), from_field
1149                             )
1150                             for from_field in from_fields
1151                         ]
1152                     )
1153                     new_field.to_fields = tuple(
1154                         [
1155                             self.renamed_fields.get(rename_key + (to_field,), to_field)
1156                             for to_field in new_field.to_fields
1157                         ]
1158                     )
1159                 dependencies.extend(
1160                     self._get_dependencies_for_foreign_key(
1161                         app_label,
1162                         model_name,
1163                         new_field,
1164                         self.to_state,
1165                     )
1166                 )
1167             if hasattr(new_field, "remote_field") and getattr(
1168                 new_field.remote_field, "through", None
1169             ):
1170                 rename_key = resolve_relation(
1171                     new_field.remote_field.through, app_label, model_name
1172                 )
1173                 if rename_key in self.renamed_models:
1174                     new_field.remote_field.through = old_field.remote_field.through
1175             old_field_dec = self.deep_deconstruct(old_field)
1176             new_field_dec = self.deep_deconstruct(new_field)
1177             # If the field was confirmed to be renamed it means that only
1178             # db_column was allowed to change which generate_renamed_fields()
1179             # already accounts for by adding an AlterField operation.
1180             if old_field_dec != new_field_dec and old_field_name == field_name:
1181                 both_m2m = old_field.many_to_many and new_field.many_to_many
1182                 neither_m2m = not old_field.many_to_many and not new_field.many_to_many
1183                 if both_m2m or neither_m2m:
1184                     # Either both fields are m2m or neither is
1185                     preserve_default = True
1186                     if (
1187                         old_field.null
1188                         and not new_field.null
1189                         and not new_field.has_default()
1190                         and not new_field.many_to_many
1191                     ):
1192                         field = new_field.clone()
1193                         new_default = self.questioner.ask_not_null_alteration(
1194                             field_name, model_name
1195                         )
1196                         if new_default is not models.NOT_PROVIDED:
1197                             field.default = new_default
1198                             preserve_default = False
1199                     else:
1200                         field = new_field
1201                     self.add_operation(
1202                         app_label,
1203                         operations.AlterField(
1204                             model_name=model_name,
1205                             name=field_name,
1206                             field=field,
1207                             preserve_default=preserve_default,
1208                         ),
1209                         dependencies=dependencies,
1210                     )
1211                 else:
1212                     # We cannot alter between m2m and concrete fields
1213                     self._generate_removed_field(app_label, model_name, field_name)
1214                     self._generate_added_field(app_label, model_name, field_name)
1215 
1216     def create_altered_indexes(self):
1217         option_name = operations.AddIndex.option_name
1218         self.renamed_index_together_values = defaultdict(list)
1219 
1220         for app_label, model_name in sorted(self.kept_model_keys):
1221             old_model_name = self.renamed_models.get(
1222                 (app_label, model_name), model_name
1223             )
1224             old_model_state = self.from_state.models[app_label, old_model_name]
1225             new_model_state = self.to_state.models[app_label, model_name]
1226 
1227             old_indexes = old_model_state.options[option_name]
1228             new_indexes = new_model_state.options[option_name]
1229             added_indexes = [idx for idx in new_indexes if idx not in old_indexes]
1230             removed_indexes = [idx for idx in old_indexes if idx not in new_indexes]
1231             renamed_indexes = []
1232             # Find renamed indexes.
1233             remove_from_added = []
1234             remove_from_removed = []
1235             for new_index in added_indexes:
1236                 new_index_dec = new_index.deconstruct()
1237                 new_index_name = new_index_dec[2].pop("name")
1238                 for old_index in removed_indexes:
1239                     old_index_dec = old_index.deconstruct()
1240                     old_index_name = old_index_dec[2].pop("name")
1241                     # Indexes are the same except for the names.
1242                     if (
1243                         new_index_dec == old_index_dec
1244                         and new_index_name != old_index_name
1245                     ):
1246                         renamed_indexes.append((old_index_name, new_index_name, None))
1247                         remove_from_added.append(new_index)
1248                         remove_from_removed.append(old_index)
1249             # Find index_together changed to indexes.
1250             for (
1251                 old_value,
1252                 new_value,
1253                 index_together_app_label,
1254                 index_together_model_name,
1255                 dependencies,
1256             ) in self._get_altered_foo_together_operations(
1257                 operations.AlterIndexTogether.option_name
1258             ):
1259                 if (
1260                     app_label != index_together_app_label
1261                     or model_name != index_together_model_name
1262                 ):
1263                     continue
1264                 removed_values = old_value.difference(new_value)
1265                 for removed_index_together in removed_values:
1266                     renamed_index_together_indexes = []
1267                     for new_index in added_indexes:
1268                         _, args, kwargs = new_index.deconstruct()
1269                         # Ensure only 'fields' are defined in the Index.
1270                         if (
1271                             not args
1272                             and new_index.fields == list(removed_index_together)
1273                             and set(kwargs) == {"name", "fields"}
1274                         ):
1275                             renamed_index_together_indexes.append(new_index)
1276 
1277                     if len(renamed_index_together_indexes) == 1:
1278                         renamed_index = renamed_index_together_indexes[0]
1279                         remove_from_added.append(renamed_index)
1280                         renamed_indexes.append(
1281                             (None, renamed_index.name, removed_index_together)
1282                         )
1283                         self.renamed_index_together_values[
1284                             index_together_app_label, index_together_model_name
1285                         ].append(removed_index_together)
1286             # Remove renamed indexes from the lists of added and removed
1287             # indexes.
1288             added_indexes = [
1289                 idx for idx in added_indexes if idx not in remove_from_added
1290             ]
1291             removed_indexes = [
1292                 idx for idx in removed_indexes if idx not in remove_from_removed
1293             ]
1294 
1295             self.altered_indexes.update(
1296                 {
1297                     (app_label, model_name): {
1298                         "added_indexes": added_indexes,
1299                         "removed_indexes": removed_indexes,
1300                         "renamed_indexes": renamed_indexes,
1301                     }
1302                 }
1303             )
1304 
1305     def generate_added_indexes(self):
1306         for (app_label, model_name), alt_indexes in self.altered_indexes.items():
1307             for index in alt_indexes["added_indexes"]:
1308                 self.add_operation(
1309                     app_label,
1310                     operations.AddIndex(
1311                         model_name=model_name,
1312                         index=index,
1313                     ),
1314                 )
1315 
1316     def generate_removed_indexes(self):
1317         for (app_label, model_name), alt_indexes in self.altered_indexes.items():
1318             for index in alt_indexes["removed_indexes"]:
1319                 self.add_operation(
1320                     app_label,
1321                     operations.RemoveIndex(
1322                         model_name=model_name,
1323                         name=index.name,
1324                     ),
1325                 )
1326 
1327     def generate_renamed_indexes(self):
1328         for (app_label, model_name), alt_indexes in self.altered_indexes.items():
1329             for old_index_name, new_index_name, old_fields in alt_indexes[
1330                 "renamed_indexes"
1331             ]:
1332                 self.add_operation(
1333                     app_label,
1334                     operations.RenameIndex(
1335                         model_name=model_name,
1336                         new_name=new_index_name,
1337                         old_name=old_index_name,
1338                         old_fields=old_fields,
1339                     ),
1340                 )
1341 
1342     def create_altered_constraints(self):
1343         option_name = operations.AddConstraint.option_name
1344         for app_label, model_name in sorted(self.kept_model_keys):
1345             old_model_name = self.renamed_models.get(
1346                 (app_label, model_name), model_name
1347             )
1348             old_model_state = self.from_state.models[app_label, old_model_name]
1349             new_model_state = self.to_state.models[app_label, model_name]
1350 
1351             old_constraints = old_model_state.options[option_name]
1352             new_constraints = new_model_state.options[option_name]
1353             add_constraints = [c for c in new_constraints if c not in old_constraints]
1354             rem_constraints = [c for c in old_constraints if c not in new_constraints]
1355 
1356             self.altered_constraints.update(
1357                 {
1358                     (app_label, model_name): {
1359                         "added_constraints": add_constraints,
1360                         "removed_constraints": rem_constraints,
1361                     }
1362                 }
1363             )
1364 
1365     def generate_added_constraints(self):
1366         for (
1367             app_label,
1368             model_name,
1369         ), alt_constraints in self.altered_constraints.items():
1370             for constraint in alt_constraints["added_constraints"]:
1371                 self.add_operation(
1372                     app_label,
1373                     operations.AddConstraint(
1374                         model_name=model_name,
1375                         constraint=constraint,
1376                     ),
1377                 )
1378 
1379     def generate_removed_constraints(self):
1380         for (
1381             app_label,
1382             model_name,
1383         ), alt_constraints in self.altered_constraints.items():
1384             for constraint in alt_constraints["removed_constraints"]:
1385                 self.add_operation(
1386                     app_label,
1387                     operations.RemoveConstraint(
1388                         model_name=model_name,
1389                         name=constraint.name,
1390                     ),
1391                 )
1392 
1393     @staticmethod
1394     def _get_dependencies_for_foreign_key(app_label, model_name, field, project_state):
1395         remote_field_model = None
1396         if hasattr(field.remote_field, "model"):
1397             remote_field_model = field.remote_field.model
1398         else:
1399             relations = project_state.relations[app_label, model_name]
1400             for (remote_app_label, remote_model_name), fields in relations.items():
1401                 if any(
1402                     field == related_field.remote_field
1403                     for related_field in fields.values()
1404                 ):
1405                     remote_field_model = f"{remote_app_label}.{remote_model_name}"
1406                     break
1407         # Account for FKs to swappable models
1408         swappable_setting = getattr(field, "swappable_setting", None)
1409         if swappable_setting is not None:
1410             dep_app_label = "__setting__"
1411             dep_object_name = swappable_setting
1412         else:
1413             dep_app_label, dep_object_name = resolve_relation(
1414                 remote_field_model,
1415                 app_label,
1416                 model_name,
1417             )
1418         dependencies = [(dep_app_label, dep_object_name, None, True)]
1419         if getattr(field.remote_field, "through", None):
1420             through_app_label, through_object_name = resolve_relation(
1421                 remote_field_model,
1422                 app_label,
1423                 model_name,
1424             )
1425             dependencies.append((through_app_label, through_object_name, None, True))
1426         return dependencies
1427 
1428     def _get_altered_foo_together_operations(self, option_name):
1429         for app_label, model_name in sorted(self.kept_model_keys):
1430             old_model_name = self.renamed_models.get(
1431                 (app_label, model_name), model_name
1432             )
1433             old_model_state = self.from_state.models[app_label, old_model_name]
1434             new_model_state = self.to_state.models[app_label, model_name]
1435 
1436             # We run the old version through the field renames to account for those
1437             old_value = old_model_state.options.get(option_name)
1438             old_value = (
1439                 {
1440                     tuple(
1441                         self.renamed_fields.get((app_label, model_name, n), n)
1442                         for n in unique
1443                     )
1444                     for unique in old_value
1445                 }
1446                 if old_value
1447                 else set()
1448             )
1449 
1450             new_value = new_model_state.options.get(option_name)
1451             new_value = set(new_value) if new_value else set()
1452 
1453             if old_value != new_value:
1454                 dependencies = []
1455                 for foo_togethers in new_value:
1456                     for field_name in foo_togethers:
1457                         field = new_model_state.get_field(field_name)
1458                         if field.remote_field and field.remote_field.model:
1459                             dependencies.extend(
1460                                 self._get_dependencies_for_foreign_key(
1461                                     app_label,
1462                                     model_name,
1463                                     field,
1464                                     self.to_state,
1465                                 )
1466                             )
1467                 yield (
1468                     old_value,
1469                     new_value,
1470                     app_label,
1471                     model_name,
1472                     dependencies,
1473                 )
1474 
1475     def _generate_removed_altered_foo_together(self, operation):
1476         for (
1477             old_value,
1478             new_value,
1479             app_label,
1480             model_name,
1481             dependencies,
1482         ) in self._get_altered_foo_together_operations(operation.option_name):
1483             if operation == operations.AlterIndexTogether:
1484                 old_value = {
1485                     value
1486                     for value in old_value
1487                     if value
1488                     not in self.renamed_index_together_values[app_label, model_name]
1489                 }
1490             removal_value = new_value.intersection(old_value)
1491             if removal_value or old_value:
1492                 self.add_operation(
1493                     app_label,
1494                     operation(
1495                         name=model_name, **{operation.option_name: removal_value}
1496                     ),
1497                     dependencies=dependencies,
1498                 )
1499 
1500     def generate_removed_altered_unique_together(self):
1501         self._generate_removed_altered_foo_together(operations.AlterUniqueTogether)
1502 
1503     def generate_removed_altered_index_together(self):
1504         self._generate_removed_altered_foo_together(operations.AlterIndexTogether)
1505 
1506     def _generate_altered_foo_together(self, operation):
1507         for (
1508             old_value,
1509             new_value,
1510             app_label,
1511             model_name,
1512             dependencies,
1513         ) in self._get_altered_foo_together_operations(operation.option_name):
1514             removal_value = new_value.intersection(old_value)
1515             if new_value != removal_value:
1516                 self.add_operation(
1517                     app_label,
1518                     operation(name=model_name, **{operation.option_name: new_value}),
1519                     dependencies=dependencies,
1520                 )
1521 
1522     def generate_altered_unique_together(self):
1523         self._generate_altered_foo_together(operations.AlterUniqueTogether)
1524 
1525     def generate_altered_index_together(self):
1526         self._generate_altered_foo_together(operations.AlterIndexTogether)
1527 
1528     def generate_altered_db_table(self):
1529         models_to_check = self.kept_model_keys.union(
1530             self.kept_proxy_keys, self.kept_unmanaged_keys
1531         )
1532         for app_label, model_name in sorted(models_to_check):
1533             old_model_name = self.renamed_models.get(
1534                 (app_label, model_name), model_name
1535             )
1536             old_model_state = self.from_state.models[app_label, old_model_name]
1537             new_model_state = self.to_state.models[app_label, model_name]
1538             old_db_table_name = old_model_state.options.get("db_table")
1539             new_db_table_name = new_model_state.options.get("db_table")
1540             if old_db_table_name != new_db_table_name:
1541                 self.add_operation(
1542                     app_label,
1543                     operations.AlterModelTable(
1544                         name=model_name,
1545                         table=new_db_table_name,
1546                     ),
1547                 )
1548 
1549     def generate_altered_options(self):
1550         """
1551         Work out if any non-schema-affecting options have changed and make an
1552         operation to represent them in state changes (in case Python code in
1553         migrations needs them).
1554         """
1555         models_to_check = self.kept_model_keys.union(
1556             self.kept_proxy_keys,
1557             self.kept_unmanaged_keys,
1558             # unmanaged converted to managed
1559             self.old_unmanaged_keys & self.new_model_keys,
1560             # managed converted to unmanaged
1561             self.old_model_keys & self.new_unmanaged_keys,
1562         )
1563 
1564         for app_label, model_name in sorted(models_to_check):
1565             old_model_name = self.renamed_models.get(
1566                 (app_label, model_name), model_name
1567             )
1568             old_model_state = self.from_state.models[app_label, old_model_name]
1569             new_model_state = self.to_state.models[app_label, model_name]
1570             old_options = {
1571                 key: value
1572                 for key, value in old_model_state.options.items()
1573                 if key in AlterModelOptions.ALTER_OPTION_KEYS
1574             }
1575             new_options = {
1576                 key: value
1577                 for key, value in new_model_state.options.items()
1578                 if key in AlterModelOptions.ALTER_OPTION_KEYS
1579             }
1580             if old_options != new_options:
1581                 self.add_operation(
1582                     app_label,
1583                     operations.AlterModelOptions(
1584                         name=model_name,
1585                         options=new_options,
1586                     ),
1587                 )
1588 
1589     def generate_altered_order_with_respect_to(self):
1590         for app_label, model_name in sorted(self.kept_model_keys):
1591             old_model_name = self.renamed_models.get(
1592                 (app_label, model_name), model_name
1593             )
1594             old_model_state = self.from_state.models[app_label, old_model_name]
1595             new_model_state = self.to_state.models[app_label, model_name]
1596             if old_model_state.options.get(
1597                 "order_with_respect_to"
1598             ) != new_model_state.options.get("order_with_respect_to"):
1599                 # Make sure it comes second if we're adding
1600                 # (removal dependency is part of RemoveField)
1601                 dependencies = []
1602                 if new_model_state.options.get("order_with_respect_to"):
1603                     dependencies.append(
1604                         (
1605                             app_label,
1606                             model_name,
1607                             new_model_state.options["order_with_respect_to"],
1608                             True,
1609                         )
1610                     )
1611                 # Actually generate the operation
1612                 self.add_operation(
1613                     app_label,
1614                     operations.AlterOrderWithRespectTo(
1615                         name=model_name,
1616                         order_with_respect_to=new_model_state.options.get(
1617                             "order_with_respect_to"
1618                         ),
1619                     ),
1620                     dependencies=dependencies,
1621                 )
1622 
1623     def generate_altered_managers(self):
1624         for app_label, model_name in sorted(self.kept_model_keys):
1625             old_model_name = self.renamed_models.get(
1626                 (app_label, model_name), model_name
1627             )
1628             old_model_state = self.from_state.models[app_label, old_model_name]
1629             new_model_state = self.to_state.models[app_label, model_name]
1630             if old_model_state.managers != new_model_state.managers:
1631                 self.add_operation(
1632                     app_label,
1633                     operations.AlterModelManagers(
1634                         name=model_name,
1635                         managers=new_model_state.managers,
1636                     ),
1637                 )
1638 
1639     def arrange_for_graph(self, changes, graph, migration_name=None):
1640         """
1641         Take a result from changes() and a MigrationGraph, and fix the names
1642         and dependencies of the changes so they extend the graph from the leaf
1643         nodes for each app.
1644         """
1645         leaves = graph.leaf_nodes()
1646         name_map = {}
1647         for app_label, migrations in list(changes.items()):
1648             if not migrations:
1649                 continue
1650             # Find the app label's current leaf node
1651             app_leaf = None
1652             for leaf in leaves:
1653                 if leaf[0] == app_label:
1654                     app_leaf = leaf
1655                     break
1656             # Do they want an initial migration for this app?
1657             if app_leaf is None and not self.questioner.ask_initial(app_label):
1658                 # They don't.
1659                 for migration in migrations:
1660                     name_map[(app_label, migration.name)] = (app_label, "__first__")
1661                 del changes[app_label]
1662                 continue
1663             # Work out the next number in the sequence
1664             if app_leaf is None:
1665                 next_number = 1
1666             else:
1667                 next_number = (self.parse_number(app_leaf[1]) or 0) + 1
1668             # Name each migration
1669             for i, migration in enumerate(migrations):
1670                 if i == 0 and app_leaf:
1671                     migration.dependencies.append(app_leaf)
1672                 new_name_parts = ["%04i" % next_number]
1673                 if migration_name:
1674                     new_name_parts.append(migration_name)
1675                 elif i == 0 and not app_leaf:
1676                     new_name_parts.append("initial")
1677                 else:
1678                     new_name_parts.append(migration.suggest_name()[:100])
1679                 new_name = "_".join(new_name_parts)
1680                 name_map[(app_label, migration.name)] = (app_label, new_name)
1681                 next_number += 1
1682                 migration.name = new_name
1683         # Now fix dependencies
1684         for migrations in changes.values():
1685             for migration in migrations:
1686                 migration.dependencies = [
1687                     name_map.get(d, d) for d in migration.dependencies
1688                 ]
1689         return changes
1690 
1691     def _trim_to_apps(self, changes, app_labels):
1692         """
1693         Take changes from arrange_for_graph() and set of app labels, and return
1694         a modified set of changes which trims out as many migrations that are
1695         not in app_labels as possible. Note that some other migrations may
1696         still be present as they may be required dependencies.
1697         """
1698         # Gather other app dependencies in a first pass
1699         app_dependencies = {}
1700         for app_label, migrations in changes.items():
1701             for migration in migrations:
1702                 for dep_app_label, name in migration.dependencies:
1703                     app_dependencies.setdefault(app_label, set()).add(dep_app_label)
1704         required_apps = set(app_labels)
1705         # Keep resolving till there's no change
1706         old_required_apps = None
1707         while old_required_apps != required_apps:
1708             old_required_apps = set(required_apps)
1709             required_apps.update(
1710                 *[app_dependencies.get(app_label, ()) for app_label in required_apps]
1711             )
1712         # Remove all migrations that aren't needed
1713         for app_label in list(changes):
1714             if app_label not in required_apps:
1715                 del changes[app_label]
1716         return changes
1717 
1718     @classmethod
1719     def parse_number(cls, name):
1720         """
1721         Given a migration name, try to extract a number from the beginning of
1722         it. For a squashed migration such as '0001_squashed_0004â€¦', return the
1723         second number. If no number is found, return None.
1724         """
1725         if squashed_match := re.search(r".*_squashed_(\d+)", name):
1726             return int(squashed_match[1])
1727         match = re.match(r"^\d+", name)
1728         if match:
1729             return int(match[0])
1730         return None

</code><intended_behavior>The automatic migration detection for model changes related to indexing should fully support `indexes` as the primary method for specifying indexes going forward. The intended behavior here is to deprecate the use of `index_together` in the migration autodetector logic by either warning users about its deprecation or automatically converting `index_together` definitions into `indexes`. The autodetection of index changes should continue to function seamlessly, detecting when indexes are added, removed, or altered and generating the appropriate migration files without manual intervention.</intended_behavior>, <file>django/db/backends/sqlite3/schema.py</file>
<class>None</class>
<method>None</method>
<code>
1 import copy
2 from decimal import Decimal
3 
4 from django.apps.registry import Apps
5 from django.db import NotSupportedError
6 from django.db.backends.base.schema import BaseDatabaseSchemaEditor
7 from django.db.backends.ddl_references import Statement
8 from django.db.backends.utils import strip_quotes
9 from django.db.models import UniqueConstraint
10 from django.db.transaction import atomic
11 
12 
13 class DatabaseSchemaEditor(BaseDatabaseSchemaEditor):
14 
15     sql_delete_table = "DROP TABLE %(table)s"
16     sql_create_fk = None
17     sql_create_inline_fk = (
18         "REFERENCES %(to_table)s (%(to_column)s) DEFERRABLE INITIALLY DEFERRED"
19     )
20     sql_create_column_inline_fk = sql_create_inline_fk
21     sql_delete_column = "ALTER TABLE %(table)s DROP COLUMN %(column)s"
22     sql_create_unique = "CREATE UNIQUE INDEX %(name)s ON %(table)s (%(columns)s)"
23     sql_delete_unique = "DROP INDEX %(name)s"
24 
25     def __enter__(self):
26         # Some SQLite schema alterations need foreign key constraints to be
27         # disabled. Enforce it here for the duration of the schema edition.
28         if not self.connection.disable_constraint_checking():
29             raise NotSupportedError(
30                 "SQLite schema editor cannot be used while foreign key "
31                 "constraint checks are enabled. Make sure to disable them "
32                 "before entering a transaction.atomic() context because "
33                 "SQLite does not support disabling them in the middle of "
34                 "a multi-statement transaction."
35             )
36         return super().__enter__()
37 
38     def __exit__(self, exc_type, exc_value, traceback):
39         self.connection.check_constraints()
40         super().__exit__(exc_type, exc_value, traceback)
41         self.connection.enable_constraint_checking()
42 
43     def quote_value(self, value):
44         # The backend "mostly works" without this function and there are use
45         # cases for compiling Python without the sqlite3 libraries (e.g.
46         # security hardening).
47         try:
48             import sqlite3
49 
50             value = sqlite3.adapt(value)
51         except ImportError:
52             pass
53         except sqlite3.ProgrammingError:
54             pass
55         # Manual emulation of SQLite parameter quoting
56         if isinstance(value, bool):
57             return str(int(value))
58         elif isinstance(value, (Decimal, float, int)):
59             return str(value)
60         elif isinstance(value, str):
61             return "'%s'" % value.replace("'", "''")
62         elif value is None:
63             return "NULL"
64         elif isinstance(value, (bytes, bytearray, memoryview)):
65             # Bytes are only allowed for BLOB fields, encoded as string
66             # literals containing hexadecimal data and preceded by a single "X"
67             # character.
68             return "X'%s'" % value.hex()
69         else:
70             raise ValueError(
71                 "Cannot quote parameter value %r of type %s" % (value, type(value))
72             )
73 
74     def prepare_default(self, value):
75         return self.quote_value(value)
76 
77     def _is_referenced_by_fk_constraint(
78         self, table_name, column_name=None, ignore_self=False
79     ):
80         """
81         Return whether or not the provided table name is referenced by another
82         one. If `column_name` is specified, only references pointing to that
83         column are considered. If `ignore_self` is True, self-referential
84         constraints are ignored.
85         """
86         with self.connection.cursor() as cursor:
87             for other_table in self.connection.introspection.get_table_list(cursor):
88                 if ignore_self and other_table.name == table_name:
89                     continue
90                 relations = self.connection.introspection.get_relations(
91                     cursor, other_table.name
92                 )
93                 for constraint_column, constraint_table in relations.values():
94                     if constraint_table == table_name and (
95                         column_name is None or constraint_column == column_name
96                     ):
97                         return True
98         return False
99 
100     def alter_db_table(
101         self, model, old_db_table, new_db_table, disable_constraints=True
102     ):
103         if (
104             not self.connection.features.supports_atomic_references_rename
105             and disable_constraints
106             and self._is_referenced_by_fk_constraint(old_db_table)
107         ):
108             if self.connection.in_atomic_block:
109                 raise NotSupportedError(
110                     (
111                         "Renaming the %r table while in a transaction is not "
112                         "supported on SQLite < 3.26 because it would break referential "
113                         "integrity. Try adding `atomic = False` to the Migration class."
114                     )
115                     % old_db_table
116                 )
117             self.connection.enable_constraint_checking()
118             super().alter_db_table(model, old_db_table, new_db_table)
119             self.connection.disable_constraint_checking()
120         else:
121             super().alter_db_table(model, old_db_table, new_db_table)
122 
123     def alter_field(self, model, old_field, new_field, strict=False):
124         if not self._field_should_be_altered(old_field, new_field):
125             return
126         old_field_name = old_field.name
127         table_name = model._meta.db_table
128         _, old_column_name = old_field.get_attname_column()
129         if (
130             new_field.name != old_field_name
131             and not self.connection.features.supports_atomic_references_rename
132             and self._is_referenced_by_fk_constraint(
133                 table_name, old_column_name, ignore_self=True
134             )
135         ):
136             if self.connection.in_atomic_block:
137                 raise NotSupportedError(
138                     (
139                         "Renaming the %r.%r column while in a transaction is not "
140                         "supported on SQLite < 3.26 because it would break referential "
141                         "integrity. Try adding `atomic = False` to the Migration class."
142                     )
143                     % (model._meta.db_table, old_field_name)
144                 )
145             with atomic(self.connection.alias):
146                 super().alter_field(model, old_field, new_field, strict=strict)
147                 # Follow SQLite's documented procedure for performing changes
148                 # that don't affect the on-disk content.
149                 # https://sqlite.org/lang_altertable.html#otheralter
150                 with self.connection.cursor() as cursor:
151                     schema_version = cursor.execute("PRAGMA schema_version").fetchone()[
152                         0
153                     ]
154                     cursor.execute("PRAGMA writable_schema = 1")
155                     references_template = ' REFERENCES "%s" ("%%s") ' % table_name
156                     new_column_name = new_field.get_attname_column()[1]
157                     search = references_template % old_column_name
158                     replacement = references_template % new_column_name
159                     cursor.execute(
160                         "UPDATE sqlite_master SET sql = replace(sql, %s, %s)",
161                         (search, replacement),
162                     )
163                     cursor.execute("PRAGMA schema_version = %d" % (schema_version + 1))
164                     cursor.execute("PRAGMA writable_schema = 0")
165                     # The integrity check will raise an exception and rollback
166                     # the transaction if the sqlite_master updates corrupt the
167                     # database.
168                     cursor.execute("PRAGMA integrity_check")
169             # Perform a VACUUM to refresh the database representation from
170             # the sqlite_master table.
171             with self.connection.cursor() as cursor:
172                 cursor.execute("VACUUM")
173         else:
174             super().alter_field(model, old_field, new_field, strict=strict)
175 
176     def _remake_table(
177         self, model, create_field=None, delete_field=None, alter_field=None
178     ):
179         """
180         Shortcut to transform a model from old_model into new_model
181 
182         This follows the correct procedure to perform non-rename or column
183         addition operations based on SQLite's documentation
184 
185         https://www.sqlite.org/lang_altertable.html#caution
186 
187         The essential steps are:
188           1. Create a table with the updated definition called "new__app_model"
189           2. Copy the data from the existing "app_model" table to the new table
190           3. Drop the "app_model" table
191           4. Rename the "new__app_model" table to "app_model"
192           5. Restore any index of the previous "app_model" table.
193         """
194         # Self-referential fields must be recreated rather than copied from
195         # the old model to ensure their remote_field.field_name doesn't refer
196         # to an altered field.
197         def is_self_referential(f):
198             return f.is_relation and f.remote_field.model is model
199 
200         # Work out the new fields dict / mapping
201         body = {
202             f.name: f.clone() if is_self_referential(f) else f
203             for f in model._meta.local_concrete_fields
204         }
205         # Since mapping might mix column names and default values,
206         # its values must be already quoted.
207         mapping = {
208             f.column: self.quote_name(f.column)
209             for f in model._meta.local_concrete_fields
210         }
211         # This maps field names (not columns) for things like unique_together
212         rename_mapping = {}
213         # If any of the new or altered fields is introducing a new PK,
214         # remove the old one
215         restore_pk_field = None
216         if getattr(create_field, "primary_key", False) or (
217             alter_field and getattr(alter_field[1], "primary_key", False)
218         ):
219             for name, field in list(body.items()):
220                 if field.primary_key and not (
221                     # Do not remove the old primary key when an altered field
222                     # that introduces a primary key is the same field.
223                     alter_field
224                     and name == alter_field[1].name
225                 ):
226                     field.primary_key = False
227                     restore_pk_field = field
228                     if field.auto_created:
229                         del body[name]
230                         del mapping[field.column]
231         # Add in any created fields
232         if create_field:
233             body[create_field.name] = create_field
234             # Choose a default and insert it into the copy map
235             if not create_field.many_to_many and create_field.concrete:
236                 mapping[create_field.column] = self.prepare_default(
237                     self.effective_default(create_field),
238                 )
239         # Add in any altered fields
240         if alter_field:
241             old_field, new_field = alter_field
242             body.pop(old_field.name, None)
243             mapping.pop(old_field.column, None)
244             body[new_field.name] = new_field
245             if old_field.null and not new_field.null:
246                 case_sql = "coalesce(%(col)s, %(default)s)" % {
247                     "col": self.quote_name(old_field.column),
248                     "default": self.prepare_default(self.effective_default(new_field)),
249                 }
250                 mapping[new_field.column] = case_sql
251             else:
252                 mapping[new_field.column] = self.quote_name(old_field.column)
253             rename_mapping[old_field.name] = new_field.name
254         # Remove any deleted fields
255         if delete_field:
256             del body[delete_field.name]
257             del mapping[delete_field.column]
258             # Remove any implicit M2M tables
259             if (
260                 delete_field.many_to_many
261                 and delete_field.remote_field.through._meta.auto_created
262             ):
263                 return self.delete_model(delete_field.remote_field.through)
264         # Work inside a new app registry
265         apps = Apps()
266 
267         # Work out the new value of unique_together, taking renames into
268         # account
269         unique_together = [
270             [rename_mapping.get(n, n) for n in unique]
271             for unique in model._meta.unique_together
272         ]
273 
274         # Work out the new value for index_together, taking renames into
275         # account
276         index_together = [
277             [rename_mapping.get(n, n) for n in index]
278             for index in model._meta.index_together
279         ]
280 
281         indexes = model._meta.indexes
282         if delete_field:
283             indexes = [
284                 index for index in indexes if delete_field.name not in index.fields
285             ]
286 
287         constraints = list(model._meta.constraints)
288 
289         # Provide isolated instances of the fields to the new model body so
290         # that the existing model's internals aren't interfered with when
291         # the dummy model is constructed.
292         body_copy = copy.deepcopy(body)
293 
294         # Construct a new model with the new fields to allow self referential
295         # primary key to resolve to. This model won't ever be materialized as a
296         # table and solely exists for foreign key reference resolution purposes.
297         # This wouldn't be required if the schema editor was operating on model
298         # states instead of rendered models.
299         meta_contents = {
300             "app_label": model._meta.app_label,
301             "db_table": model._meta.db_table,
302             "unique_together": unique_together,
303             "index_together": index_together,
304             "indexes": indexes,
305             "constraints": constraints,
306             "apps": apps,
307         }
308         meta = type("Meta", (), meta_contents)
309         body_copy["Meta"] = meta
310         body_copy["__module__"] = model.__module__
311         type(model._meta.object_name, model.__bases__, body_copy)
312 
313         # Construct a model with a renamed table name.
314         body_copy = copy.deepcopy(body)
315         meta_contents = {
316             "app_label": model._meta.app_label,
317             "db_table": "new__%s" % strip_quotes(model._meta.db_table),
318             "unique_together": unique_together,
319             "index_together": index_together,
320             "indexes": indexes,
321             "constraints": constraints,
322             "apps": apps,
323         }
324         meta = type("Meta", (), meta_contents)
325         body_copy["Meta"] = meta
326         body_copy["__module__"] = model.__module__
327         new_model = type("New%s" % model._meta.object_name, model.__bases__, body_copy)
328 
329         # Create a new table with the updated schema.
330         self.create_model(new_model)
331 
332         # Copy data from the old table into the new table
333         self.execute(
334             "INSERT INTO %s (%s) SELECT %s FROM %s"
335             % (
336                 self.quote_name(new_model._meta.db_table),
337                 ", ".join(self.quote_name(x) for x in mapping),
338                 ", ".join(mapping.values()),
339                 self.quote_name(model._meta.db_table),
340             )
341         )
342 
343         # Delete the old table to make way for the new
344         self.delete_model(model, handle_autom2m=False)
345 
346         # Rename the new table to take way for the old
347         self.alter_db_table(
348             new_model,
349             new_model._meta.db_table,
350             model._meta.db_table,
351             disable_constraints=False,
352         )
353 
354         # Run deferred SQL on correct table
355         for sql in self.deferred_sql:
356             self.execute(sql)
357         self.deferred_sql = []
358         # Fix any PK-removed field
359         if restore_pk_field:
360             restore_pk_field.primary_key = True
361 
362     def delete_model(self, model, handle_autom2m=True):
363         if handle_autom2m:
364             super().delete_model(model)
365         else:
366             # Delete the table (and only that)
367             self.execute(
368                 self.sql_delete_table
369                 % {
370                     "table": self.quote_name(model._meta.db_table),
371                 }
372             )
373             # Remove all deferred statements referencing the deleted table.
374             for sql in list(self.deferred_sql):
375                 if isinstance(sql, Statement) and sql.references_table(
376                     model._meta.db_table
377                 ):
378                     self.deferred_sql.remove(sql)
379 
380     def add_field(self, model, field):
381         """Create a field on a model."""
382         if (
383             # Primary keys and unique fields are not supported in ALTER TABLE
384             # ADD COLUMN.
385             field.primary_key
386             or field.unique
387             or
388             # Fields with default values cannot by handled by ALTER TABLE ADD
389             # COLUMN statement because DROP DEFAULT is not supported in
390             # ALTER TABLE.
391             not field.null
392             or self.effective_default(field) is not None
393         ):
394             self._remake_table(model, create_field=field)
395         else:
396             super().add_field(model, field)
397 
398     def remove_field(self, model, field):
399         """
400         Remove a field from a model. Usually involves deleting a column,
401         but for M2Ms may involve deleting a table.
402         """
403         # M2M fields are a special case
404         if field.many_to_many:
405             # For implicit M2M tables, delete the auto-created table
406             if field.remote_field.through._meta.auto_created:
407                 self.delete_model(field.remote_field.through)
408             # For explicit "through" M2M fields, do nothing
409         elif (
410             self.connection.features.can_alter_table_drop_column
411             # Primary keys, unique fields, and foreign keys are not
412             # supported in ALTER TABLE DROP COLUMN.
413             and not field.primary_key
414             and not field.unique
415             and not (field.remote_field and field.db_constraint)
416         ):
417             super().remove_field(model, field)
418         # For everything else, remake.
419         else:
420             # It might not actually have a column behind it
421             if field.db_parameters(connection=self.connection)["type"] is None:
422                 return
423             self._remake_table(model, delete_field=field)
424 
425     def _alter_field(
426         self,
427         model,
428         old_field,
429         new_field,
430         old_type,
431         new_type,
432         old_db_params,
433         new_db_params,
434         strict=False,
435     ):
436         """Perform a "physical" (non-ManyToMany) field update."""
437         # Use "ALTER TABLE ... RENAME COLUMN" if only the column name
438         # changed and there aren't any constraints.
439         if (
440             self.connection.features.can_alter_table_rename_column
441             and old_field.column != new_field.column
442             and self.column_sql(model, old_field) == self.column_sql(model, new_field)
443             and not (
444                 old_field.remote_field
445                 and old_field.db_constraint
446                 or new_field.remote_field
447                 and new_field.db_constraint
448             )
449         ):
450             return self.execute(
451                 self._rename_field_sql(
452                     model._meta.db_table, old_field, new_field, new_type
453                 )
454             )
455         # Alter by remaking table
456         self._remake_table(model, alter_field=(old_field, new_field))
457         # Rebuild tables with FKs pointing to this field.
458         old_collation = old_db_params.get("collation")
459         new_collation = new_db_params.get("collation")
460         if new_field.unique and (
461             old_type != new_type or old_collation != new_collation
462         ):
463             related_models = set()
464             opts = new_field.model._meta
465             for remote_field in opts.related_objects:
466                 # Ignore self-relationship since the table was already rebuilt.
467                 if remote_field.related_model == model:
468                     continue
469                 if not remote_field.many_to_many:
470                     if remote_field.field_name == new_field.name:
471                         related_models.add(remote_field.related_model)
472                 elif new_field.primary_key and remote_field.through._meta.auto_created:
473                     related_models.add(remote_field.through)
474             if new_field.primary_key:
475                 for many_to_many in opts.many_to_many:
476                     # Ignore self-relationship since the table was already rebuilt.
477                     if many_to_many.related_model == model:
478                         continue
479                     if many_to_many.remote_field.through._meta.auto_created:
480                         related_models.add(many_to_many.remote_field.through)
481             for related_model in related_models:
482                 self._remake_table(related_model)
483 
484     def _alter_many_to_many(self, model, old_field, new_field, strict):
485         """Alter M2Ms to repoint their to= endpoints."""
486         if (
487             old_field.remote_field.through._meta.db_table
488             == new_field.remote_field.through._meta.db_table
489         ):
490             # The field name didn't change, but some options did, so we have to
491             # propagate this altering.
492             self._remake_table(
493                 old_field.remote_field.through,
494                 alter_field=(
495                     # The field that points to the target model is needed, so
496                     # we can tell alter_field to change it - this is
497                     # m2m_reverse_field_name() (as opposed to m2m_field_name(),
498                     # which points to our model).
499                     old_field.remote_field.through._meta.get_field(
500                         old_field.m2m_reverse_field_name()
501                     ),
502                     new_field.remote_field.through._meta.get_field(
503                         new_field.m2m_reverse_field_name()
504                     ),
505                 ),
506             )
507             return
508 
509         # Make a new through table
510         self.create_model(new_field.remote_field.through)
511         # Copy the data across
512         self.execute(
513             "INSERT INTO %s (%s) SELECT %s FROM %s"
514             % (
515                 self.quote_name(new_field.remote_field.through._meta.db_table),
516                 ", ".join(
517                     [
518                         "id",
519                         new_field.m2m_column_name(),
520                         new_field.m2m_reverse_name(),
521                     ]
522                 ),
523                 ", ".join(
524                     [
525                         "id",
526                         old_field.m2m_column_name(),
527                         old_field.m2m_reverse_name(),
528                     ]
529                 ),
530                 self.quote_name(old_field.remote_field.through._meta.db_table),
531             )
532         )
533         # Delete the old through table
534         self.delete_model(old_field.remote_field.through)
535 
536     def add_constraint(self, model, constraint):
537         if isinstance(constraint, UniqueConstraint) and (
538             constraint.condition
539             or constraint.contains_expressions
540             or constraint.include
541             or constraint.deferrable
542         ):
543             super().add_constraint(model, constraint)
544         else:
545             self._remake_table(model)
546 
547     def remove_constraint(self, model, constraint):
548         if isinstance(constraint, UniqueConstraint) and (
549             constraint.condition
550             or constraint.contains_expressions
551             or constraint.include
552             or constraint.deferrable
553         ):
554             super().remove_constraint(model, constraint)
555         else:
556             self._remake_table(model)
557 
558     def _collate_sql(self, collation):
559         return "COLLATE " + collation

</code><intended_behavior>The SQLite backend's schema modification and creation logic need to be adjusted to prioritize `indexes` over `index_together`, ensuring that any SQL generated for index management is done through the explicit index objects provided via `indexes`. It should continue to allow Django to manage SQLite3 database schemas effectively, translating model index configurations into the correct SQL statements for index creation, deletion, and alteration, accommodating all features supported by the `indexes` option (such as expressions, conditionals, and name specification).</intended_behavior>]
2025-10-15 19:18:39.310 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-15 19:18:39.310 | INFO     | Search-only: skipping patch selection
2025-10-15 19:18:39.466 | INFO     | Task django__django-15703 completed successfully.
2025-10-15 19:18:39.467 | INFO     | No patch generated. You can try running ACR again.
