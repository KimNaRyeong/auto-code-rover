[
    {
        "rel_file_path": "django/utils/functional.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__4.1/django/utils/functional.py",
        "start": 1,
        "end": 453,
        "class_name": null,
        "method_name": null,
        "code": "1 import copy\n2 import itertools\n3 import operator\n4 import warnings\n5 from functools import total_ordering, wraps\n6 \n7 \n8 class cached_property:\n9     \"\"\"\n10     Decorator that converts a method with a single self argument into a\n11     property cached on the instance.\n12 \n13     A cached property can be made out of an existing method:\n14     (e.g. ``url = cached_property(get_absolute_url)``).\n15     \"\"\"\n16 \n17     name = None\n18 \n19     @staticmethod\n20     def func(instance):\n21         raise TypeError(\n22             \"Cannot use cached_property instance without calling \"\n23             \"__set_name__() on it.\"\n24         )\n25 \n26     def __init__(self, func, name=None):\n27         from django.utils.deprecation import RemovedInDjango50Warning\n28 \n29         if name is not None:\n30             warnings.warn(\n31                 \"The name argument is deprecated as it's unnecessary as of \"\n32                 \"Python 3.6.\",\n33                 RemovedInDjango50Warning,\n34                 stacklevel=2,\n35             )\n36         self.real_func = func\n37         self.__doc__ = getattr(func, \"__doc__\")\n38 \n39     def __set_name__(self, owner, name):\n40         if self.name is None:\n41             self.name = name\n42             self.func = self.real_func\n43         elif name != self.name:\n44             raise TypeError(\n45                 \"Cannot assign the same cached_property to two different names \"\n46                 \"(%r and %r).\" % (self.name, name)\n47             )\n48 \n49     def __get__(self, instance, cls=None):\n50         \"\"\"\n51         Call the function and put the return value in instance.__dict__ so that\n52         subsequent attribute access on the instance returns the cached value\n53         instead of calling cached_property.__get__().\n54         \"\"\"\n55         if instance is None:\n56             return self\n57         res = instance.__dict__[self.name] = self.func(instance)\n58         return res\n59 \n60 \n61 class classproperty:\n62     \"\"\"\n63     Decorator that converts a method with a single cls argument into a property\n64     that can be accessed directly from the class.\n65     \"\"\"\n66 \n67     def __init__(self, method=None):\n68         self.fget = method\n69 \n70     def __get__(self, instance, cls=None):\n71         return self.fget(cls)\n72 \n73     def getter(self, method):\n74         self.fget = method\n75         return self\n76 \n77 \n78 class Promise:\n79     \"\"\"\n80     Base class for the proxy class created in the closure of the lazy function.\n81     It's used to recognize promises in code.\n82     \"\"\"\n83 \n84     pass\n85 \n86 \n87 def lazy(func, *resultclasses):\n88     \"\"\"\n89     Turn any callable into a lazy evaluated callable. result classes or types\n90     is required -- at least one is needed so that the automatic forcing of\n91     the lazy evaluation code is triggered. Results are not memoized; the\n92     function is evaluated on every access.\n93     \"\"\"\n94 \n95     @total_ordering\n96     class __proxy__(Promise):\n97         \"\"\"\n98         Encapsulate a function call and act as a proxy for methods that are\n99         called on the result of that function. The function is not evaluated\n100         until one of the methods on the result is called.\n101         \"\"\"\n102 \n103         __prepared = False\n104 \n105         def __init__(self, args, kw):\n106             self.__args = args\n107             self.__kw = kw\n108             if not self.__prepared:\n109                 self.__prepare_class__()\n110             self.__class__.__prepared = True\n111 \n112         def __reduce__(self):\n113             return (\n114                 _lazy_proxy_unpickle,\n115                 (func, self.__args, self.__kw) + resultclasses,\n116             )\n117 \n118         def __repr__(self):\n119             return repr(self.__cast())\n120 \n121         @classmethod\n122         def __prepare_class__(cls):\n123             for resultclass in resultclasses:\n124                 for type_ in resultclass.mro():\n125                     for method_name in type_.__dict__:\n126                         # All __promise__ return the same wrapper method, they\n127                         # look up the correct implementation when called.\n128                         if hasattr(cls, method_name):\n129                             continue\n130                         meth = cls.__promise__(method_name)\n131                         setattr(cls, method_name, meth)\n132             cls._delegate_bytes = bytes in resultclasses\n133             cls._delegate_text = str in resultclasses\n134             if cls._delegate_bytes and cls._delegate_text:\n135                 raise ValueError(\n136                     \"Cannot call lazy() with both bytes and text return types.\"\n137                 )\n138             if cls._delegate_text:\n139                 cls.__str__ = cls.__text_cast\n140             elif cls._delegate_bytes:\n141                 cls.__bytes__ = cls.__bytes_cast\n142 \n143         @classmethod\n144         def __promise__(cls, method_name):\n145             # Builds a wrapper around some magic method\n146             def __wrapper__(self, *args, **kw):\n147                 # Automatically triggers the evaluation of a lazy value and\n148                 # applies the given magic method of the result type.\n149                 res = func(*self.__args, **self.__kw)\n150                 return getattr(res, method_name)(*args, **kw)\n151 \n152             return __wrapper__\n153 \n154         def __text_cast(self):\n155             return func(*self.__args, **self.__kw)\n156 \n157         def __bytes_cast(self):\n158             return bytes(func(*self.__args, **self.__kw))\n159 \n160         def __bytes_cast_encoded(self):\n161             return func(*self.__args, **self.__kw).encode()\n162 \n163         def __cast(self):\n164             if self._delegate_bytes:\n165                 return self.__bytes_cast()\n166             elif self._delegate_text:\n167                 return self.__text_cast()\n168             else:\n169                 return func(*self.__args, **self.__kw)\n170 \n171         def __str__(self):\n172             # object defines __str__(), so __prepare_class__() won't overload\n173             # a __str__() method from the proxied class.\n174             return str(self.__cast())\n175 \n176         def __eq__(self, other):\n177             if isinstance(other, Promise):\n178                 other = other.__cast()\n179             return self.__cast() == other\n180 \n181         def __lt__(self, other):\n182             if isinstance(other, Promise):\n183                 other = other.__cast()\n184             return self.__cast() < other\n185 \n186         def __hash__(self):\n187             return hash(self.__cast())\n188 \n189         def __mod__(self, rhs):\n190             if self._delegate_text:\n191                 return str(self) % rhs\n192             return self.__cast() % rhs\n193 \n194         def __add__(self, other):\n195             return self.__cast() + other\n196 \n197         def __radd__(self, other):\n198             return other + self.__cast()\n199 \n200         def __deepcopy__(self, memo):\n201             # Instances of this class are effectively immutable. It's just a\n202             # collection of functions. So we don't need to do anything\n203             # complicated for copying.\n204             memo[id(self)] = self\n205             return self\n206 \n207     @wraps(func)\n208     def __wrapper__(*args, **kw):\n209         # Creates the proxy object, instead of the actual value.\n210         return __proxy__(args, kw)\n211 \n212     return __wrapper__\n213 \n214 \n215 def _lazy_proxy_unpickle(func, args, kwargs, *resultclasses):\n216     return lazy(func, *resultclasses)(*args, **kwargs)\n217 \n218 \n219 def lazystr(text):\n220     \"\"\"\n221     Shortcut for the common case of a lazy callable that returns str.\n222     \"\"\"\n223     return lazy(str, str)(text)\n224 \n225 \n226 def keep_lazy(*resultclasses):\n227     \"\"\"\n228     A decorator that allows a function to be called with one or more lazy\n229     arguments. If none of the args are lazy, the function is evaluated\n230     immediately, otherwise a __proxy__ is returned that will evaluate the\n231     function when needed.\n232     \"\"\"\n233     if not resultclasses:\n234         raise TypeError(\"You must pass at least one argument to keep_lazy().\")\n235 \n236     def decorator(func):\n237         lazy_func = lazy(func, *resultclasses)\n238 \n239         @wraps(func)\n240         def wrapper(*args, **kwargs):\n241             if any(\n242                 isinstance(arg, Promise)\n243                 for arg in itertools.chain(args, kwargs.values())\n244             ):\n245                 return lazy_func(*args, **kwargs)\n246             return func(*args, **kwargs)\n247 \n248         return wrapper\n249 \n250     return decorator\n251 \n252 \n253 def keep_lazy_text(func):\n254     \"\"\"\n255     A decorator for functions that accept lazy arguments and return text.\n256     \"\"\"\n257     return keep_lazy(str)(func)\n258 \n259 \n260 empty = object()\n261 \n262 \n263 def new_method_proxy(func):\n264     def inner(self, *args):\n265         if self._wrapped is empty:\n266             self._setup()\n267         return func(self._wrapped, *args)\n268 \n269     return inner\n270 \n271 \n272 class LazyObject:\n273     \"\"\"\n274     A wrapper for another class that can be used to delay instantiation of the\n275     wrapped class.\n276 \n277     By subclassing, you have the opportunity to intercept and alter the\n278     instantiation. If you don't need to do that, use SimpleLazyObject.\n279     \"\"\"\n280 \n281     # Avoid infinite recursion when tracing __init__ (#19456).\n282     _wrapped = None\n283 \n284     def __init__(self):\n285         # Note: if a subclass overrides __init__(), it will likely need to\n286         # override __copy__() and __deepcopy__() as well.\n287         self._wrapped = empty\n288 \n289     __getattr__ = new_method_proxy(getattr)\n290 \n291     def __setattr__(self, name, value):\n292         if name == \"_wrapped\":\n293             # Assign to __dict__ to avoid infinite __setattr__ loops.\n294             self.__dict__[\"_wrapped\"] = value\n295         else:\n296             if self._wrapped is empty:\n297                 self._setup()\n298             setattr(self._wrapped, name, value)\n299 \n300     def __delattr__(self, name):\n301         if name == \"_wrapped\":\n302             raise TypeError(\"can't delete _wrapped.\")\n303         if self._wrapped is empty:\n304             self._setup()\n305         delattr(self._wrapped, name)\n306 \n307     def _setup(self):\n308         \"\"\"\n309         Must be implemented by subclasses to initialize the wrapped object.\n310         \"\"\"\n311         raise NotImplementedError(\n312             \"subclasses of LazyObject must provide a _setup() method\"\n313         )\n314 \n315     # Because we have messed with __class__ below, we confuse pickle as to what\n316     # class we are pickling. We're going to have to initialize the wrapped\n317     # object to successfully pickle it, so we might as well just pickle the\n318     # wrapped object since they're supposed to act the same way.\n319     #\n320     # Unfortunately, if we try to simply act like the wrapped object, the ruse\n321     # will break down when pickle gets our id(). Thus we end up with pickle\n322     # thinking, in effect, that we are a distinct object from the wrapped\n323     # object, but with the same __dict__. This can cause problems (see #25389).\n324     #\n325     # So instead, we define our own __reduce__ method and custom unpickler. We\n326     # pickle the wrapped object as the unpickler's argument, so that pickle\n327     # will pickle it normally, and then the unpickler simply returns its\n328     # argument.\n329     def __reduce__(self):\n330         if self._wrapped is empty:\n331             self._setup()\n332         return (unpickle_lazyobject, (self._wrapped,))\n333 \n334     def __copy__(self):\n335         if self._wrapped is empty:\n336             # If uninitialized, copy the wrapper. Use type(self), not\n337             # self.__class__, because the latter is proxied.\n338             return type(self)()\n339         else:\n340             # If initialized, return a copy of the wrapped object.\n341             return copy.copy(self._wrapped)\n342 \n343     def __deepcopy__(self, memo):\n344         if self._wrapped is empty:\n345             # We have to use type(self), not self.__class__, because the\n346             # latter is proxied.\n347             result = type(self)()\n348             memo[id(self)] = result\n349             return result\n350         return copy.deepcopy(self._wrapped, memo)\n351 \n352     __bytes__ = new_method_proxy(bytes)\n353     __str__ = new_method_proxy(str)\n354     __bool__ = new_method_proxy(bool)\n355 \n356     # Introspection support\n357     __dir__ = new_method_proxy(dir)\n358 \n359     # Need to pretend to be the wrapped class, for the sake of objects that\n360     # care about this (especially in equality tests)\n361     __class__ = property(new_method_proxy(operator.attrgetter(\"__class__\")))\n362     __eq__ = new_method_proxy(operator.eq)\n363     __lt__ = new_method_proxy(operator.lt)\n364     __gt__ = new_method_proxy(operator.gt)\n365     __ne__ = new_method_proxy(operator.ne)\n366     __hash__ = new_method_proxy(hash)\n367 \n368     # List/Tuple/Dictionary methods support\n369     __getitem__ = new_method_proxy(operator.getitem)\n370     __setitem__ = new_method_proxy(operator.setitem)\n371     __delitem__ = new_method_proxy(operator.delitem)\n372     __iter__ = new_method_proxy(iter)\n373     __len__ = new_method_proxy(len)\n374     __contains__ = new_method_proxy(operator.contains)\n375 \n376 \n377 def unpickle_lazyobject(wrapped):\n378     \"\"\"\n379     Used to unpickle lazy objects. Just return its argument, which will be the\n380     wrapped object.\n381     \"\"\"\n382     return wrapped\n383 \n384 \n385 class SimpleLazyObject(LazyObject):\n386     \"\"\"\n387     A lazy object initialized from any function.\n388 \n389     Designed for compound objects of unknown type. For builtins or objects of\n390     known type, use django.utils.functional.lazy.\n391     \"\"\"\n392 \n393     def __init__(self, func):\n394         \"\"\"\n395         Pass in a callable that returns the object to be wrapped.\n396 \n397         If copies are made of the resulting SimpleLazyObject, which can happen\n398         in various circumstances within Django, then you must ensure that the\n399         callable can be safely run more than once and will return the same\n400         value.\n401         \"\"\"\n402         self.__dict__[\"_setupfunc\"] = func\n403         super().__init__()\n404 \n405     def _setup(self):\n406         self._wrapped = self._setupfunc()\n407 \n408     # Return a meaningful representation of the lazy object for debugging\n409     # without evaluating the wrapped object.\n410     def __repr__(self):\n411         if self._wrapped is empty:\n412             repr_attr = self._setupfunc\n413         else:\n414             repr_attr = self._wrapped\n415         return \"<%s: %r>\" % (type(self).__name__, repr_attr)\n416 \n417     def __copy__(self):\n418         if self._wrapped is empty:\n419             # If uninitialized, copy the wrapper. Use SimpleLazyObject, not\n420             # self.__class__, because the latter is proxied.\n421             return SimpleLazyObject(self._setupfunc)\n422         else:\n423             # If initialized, return a copy of the wrapped object.\n424             return copy.copy(self._wrapped)\n425 \n426     def __deepcopy__(self, memo):\n427         if self._wrapped is empty:\n428             # We have to use SimpleLazyObject, not self.__class__, because the\n429             # latter is proxied.\n430             result = SimpleLazyObject(self._setupfunc)\n431             memo[id(self)] = result\n432             return result\n433         return copy.deepcopy(self._wrapped, memo)\n434 \n435     __add__ = new_method_proxy(operator.add)\n436 \n437     @new_method_proxy\n438     def __radd__(self, other):\n439         return other + self\n440 \n441 \n442 def partition(predicate, values):\n443     \"\"\"\n444     Split the values into two sets, based on the return value of the function\n445     (True/False). e.g.:\n446 \n447         >>> partition(lambda x: x > 3, range(5))\n448         [0, 1, 2, 3], [4]\n449     \"\"\"\n450     results = ([], [])\n451     for item in values:\n452         results[predicate(item)].append(item)\n453     return results\n",
        "intended_behavior": "The `new_method_proxy` function should be modified to ensure the existence of the method on the wrapped object before attempting to call it. After the `_setup` method is triggered and before executing `return func(self._wrapped, *args)`, an additional check should be introduced to verify that `func` is indeed an attribute or method of `self._wrapped` and is callable. If the check fails, meaning the `func` does not exist on `self._wrapped` or is not callable, `new_method_proxy` should raise a descriptive exception or handle the case gracefully in a way that avoids misleading the user into thinking an operation is supported when it's not. This could involve returning `NotImplementedError`, `AttributeError`, or a custom, informative error message specifying that the method is unsupported by the wrapped object. This modification aims to respond directly to the problem described in the issue: it prevents `TypeError` when accessing methods via `LazyObject` that don't exist on the wrapped object."
    }
]