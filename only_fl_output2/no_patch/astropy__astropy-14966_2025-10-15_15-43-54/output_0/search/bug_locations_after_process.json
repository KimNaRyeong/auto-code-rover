[
    {
        "rel_file_path": "astropy/table/groups.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/astropy__astropy/setup_astropy__astropy__5.2/astropy/table/groups.py",
        "start": 1,
        "end": 427,
        "class_name": null,
        "method_name": null,
        "code": "1 # Licensed under a 3-clause BSD style license - see LICENSE.rst\n2 \n3 import platform\n4 import warnings\n5 \n6 import numpy as np\n7 \n8 from astropy.utils.exceptions import AstropyUserWarning\n9 \n10 from .index import get_index_by_names\n11 \n12 __all__ = [\"TableGroups\", \"ColumnGroups\"]\n13 \n14 \n15 def table_group_by(table, keys):\n16     # index copies are unnecessary and slow down _table_group_by\n17     with table.index_mode(\"discard_on_copy\"):\n18         return _table_group_by(table, keys)\n19 \n20 \n21 def _table_group_by(table, keys):\n22     \"\"\"\n23     Get groups for ``table`` on specified ``keys``.\n24 \n25     Parameters\n26     ----------\n27     table : `Table`\n28         Table to group\n29     keys : str, list of str, `Table`, or Numpy array\n30         Grouping key specifier\n31 \n32     Returns\n33     -------\n34     grouped_table : Table object with groups attr set accordingly\n35     \"\"\"\n36     from .serialize import represent_mixins_as_columns\n37     from .table import Table\n38 \n39     # Pre-convert string to tuple of strings, or Table to the underlying structured array\n40     if isinstance(keys, str):\n41         keys = (keys,)\n42 \n43     if isinstance(keys, (list, tuple)):\n44         for name in keys:\n45             if name not in table.colnames:\n46                 raise ValueError(f\"Table does not have key column {name!r}\")\n47             if table.masked and np.any(table[name].mask):\n48                 raise ValueError(\n49                     f\"Missing values in key column {name!r} are not allowed\"\n50                 )\n51 \n52         # Make a column slice of the table without copying\n53         table_keys = table.__class__([table[key] for key in keys], copy=False)\n54 \n55         # If available get a pre-existing index for these columns\n56         table_index = get_index_by_names(table, keys)\n57         grouped_by_table_cols = True\n58 \n59     elif isinstance(keys, (np.ndarray, Table)):\n60         table_keys = keys\n61         if len(table_keys) != len(table):\n62             raise ValueError(\n63                 \"Input keys array length {} does not match table length {}\".format(\n64                     len(table_keys), len(table)\n65                 )\n66             )\n67         table_index = None\n68         grouped_by_table_cols = False\n69 \n70     else:\n71         raise TypeError(\n72             \"Keys input must be string, list, tuple, Table or numpy array, but got {}\".format(\n73                 type(keys)\n74             )\n75         )\n76 \n77     # If there is not already an available index and table_keys is a Table then ensure\n78     # that all cols (including mixins) are in a form that can sorted with the code below.\n79     if not table_index and isinstance(table_keys, Table):\n80         table_keys = represent_mixins_as_columns(table_keys)\n81 \n82     # Get the argsort index `idx_sort`, accounting for particulars\n83     try:\n84         # take advantage of index internal sort if possible\n85         if table_index is not None:\n86             idx_sort = table_index.sorted_data()\n87         else:\n88             idx_sort = table_keys.argsort(kind=\"mergesort\")\n89         stable_sort = True\n90     except TypeError:\n91         # Some versions (likely 1.6 and earlier) of numpy don't support\n92         # 'mergesort' for all data types.  MacOSX (Darwin) doesn't have a stable\n93         # sort by default, nor does Windows, while Linux does (or appears to).\n94         idx_sort = table_keys.argsort()\n95         stable_sort = platform.system() not in (\"Darwin\", \"Windows\")\n96 \n97     # Finally do the actual sort of table_keys values\n98     table_keys = table_keys[idx_sort]\n99 \n100     # Get all keys\n101     diffs = np.concatenate(([True], table_keys[1:] != table_keys[:-1], [True]))\n102     indices = np.flatnonzero(diffs)\n103 \n104     # If the sort is not stable (preserves original table order) then sort idx_sort in\n105     # place within each group.\n106     if not stable_sort:\n107         for i0, i1 in zip(indices[:-1], indices[1:]):\n108             idx_sort[i0:i1].sort()\n109 \n110     # Make a new table and set the _groups to the appropriate TableGroups object.\n111     # Take the subset of the original keys at the indices values (group boundaries).\n112     out = table.__class__(table[idx_sort])\n113     out_keys = table_keys[indices[:-1]]\n114     if isinstance(out_keys, Table):\n115         out_keys.meta[\"grouped_by_table_cols\"] = grouped_by_table_cols\n116     out._groups = TableGroups(out, indices=indices, keys=out_keys)\n117 \n118     return out\n119 \n120 \n121 def column_group_by(column, keys):\n122     \"\"\"\n123     Get groups for ``column`` on specified ``keys``.\n124 \n125     Parameters\n126     ----------\n127     column : Column object\n128         Column to group\n129     keys : Table or Numpy array of same length as col\n130         Grouping key specifier\n131 \n132     Returns\n133     -------\n134     grouped_column : Column object with groups attr set accordingly\n135     \"\"\"\n136     from .serialize import represent_mixins_as_columns\n137     from .table import Table\n138 \n139     if isinstance(keys, Table):\n140         keys = represent_mixins_as_columns(keys)\n141         keys = keys.as_array()\n142 \n143     if not isinstance(keys, np.ndarray):\n144         raise TypeError(f\"Keys input must be numpy array, but got {type(keys)}\")\n145 \n146     if len(keys) != len(column):\n147         raise ValueError(\n148             \"Input keys array length {} does not match column length {}\".format(\n149                 len(keys), len(column)\n150             )\n151         )\n152 \n153     idx_sort = keys.argsort()\n154     keys = keys[idx_sort]\n155 \n156     # Get all keys\n157     diffs = np.concatenate(([True], keys[1:] != keys[:-1], [True]))\n158     indices = np.flatnonzero(diffs)\n159 \n160     # Make a new column and set the _groups to the appropriate ColumnGroups object.\n161     # Take the subset of the original keys at the indices values (group boundaries).\n162     out = column.__class__(column[idx_sort])\n163     out._groups = ColumnGroups(out, indices=indices, keys=keys[indices[:-1]])\n164 \n165     return out\n166 \n167 \n168 class BaseGroups:\n169     \"\"\"\n170     A class to represent groups within a table of heterogeneous data.\n171 \n172       - ``keys``: key values corresponding to each group\n173       - ``indices``: index values in parent table or column corresponding to group boundaries\n174       - ``aggregate()``: method to create new table by aggregating within groups\n175     \"\"\"\n176 \n177     @property\n178     def parent(self):\n179         return (\n180             self.parent_column if isinstance(self, ColumnGroups) else self.parent_table\n181         )\n182 \n183     def __iter__(self):\n184         self._iter_index = 0\n185         return self\n186 \n187     def next(self):\n188         ii = self._iter_index\n189         if ii < len(self.indices) - 1:\n190             i0, i1 = self.indices[ii], self.indices[ii + 1]\n191             self._iter_index += 1\n192             return self.parent[i0:i1]\n193         else:\n194             raise StopIteration\n195 \n196     __next__ = next\n197 \n198     def __getitem__(self, item):\n199         parent = self.parent\n200 \n201         if isinstance(item, (int, np.integer)):\n202             i0, i1 = self.indices[item], self.indices[item + 1]\n203             out = parent[i0:i1]\n204             out.groups._keys = parent.groups.keys[item]\n205         else:\n206             indices0, indices1 = self.indices[:-1], self.indices[1:]\n207             try:\n208                 i0s, i1s = indices0[item], indices1[item]\n209             except Exception as err:\n210                 raise TypeError(\n211                     \"Index item for groups attribute must be a slice, \"\n212                     \"numpy mask or int array\"\n213                 ) from err\n214             mask = np.zeros(len(parent), dtype=bool)\n215             # Is there a way to vectorize this in numpy?\n216             for i0, i1 in zip(i0s, i1s):\n217                 mask[i0:i1] = True\n218             out = parent[mask]\n219             out.groups._keys = parent.groups.keys[item]\n220             out.groups._indices = np.concatenate([[0], np.cumsum(i1s - i0s)])\n221 \n222         return out\n223 \n224     def __repr__(self):\n225         return f\"<{self.__class__.__name__} indices={self.indices}>\"\n226 \n227     def __len__(self):\n228         return len(self.indices) - 1\n229 \n230 \n231 class ColumnGroups(BaseGroups):\n232     def __init__(self, parent_column, indices=None, keys=None):\n233         self.parent_column = parent_column  # parent Column\n234         self.parent_table = parent_column.info.parent_table\n235         self._indices = indices\n236         self._keys = keys\n237 \n238     @property\n239     def indices(self):\n240         # If the parent column is in a table then use group indices from table\n241         if self.parent_table:\n242             return self.parent_table.groups.indices\n243         else:\n244             if self._indices is None:\n245                 return np.array([0, len(self.parent_column)])\n246             else:\n247                 return self._indices\n248 \n249     @property\n250     def keys(self):\n251         # If the parent column is in a table then use group indices from table\n252         if self.parent_table:\n253             return self.parent_table.groups.keys\n254         else:\n255             return self._keys\n256 \n257     def aggregate(self, func):\n258         from .column import MaskedColumn\n259 \n260         i0s, i1s = self.indices[:-1], self.indices[1:]\n261         par_col = self.parent_column\n262         masked = isinstance(par_col, MaskedColumn)\n263         reduceat = hasattr(func, \"reduceat\")\n264         sum_case = func is np.sum\n265         mean_case = func is np.mean\n266         try:\n267             if not masked and (reduceat or sum_case or mean_case):\n268                 if mean_case:\n269                     vals = np.add.reduceat(par_col, i0s) / np.diff(self.indices)\n270                 else:\n271                     if sum_case:\n272                         func = np.add\n273                     vals = func.reduceat(par_col, i0s)\n274             else:\n275                 vals = np.array([func(par_col[i0:i1]) for i0, i1 in zip(i0s, i1s)])\n276             out = par_col.__class__(vals)\n277         except Exception as err:\n278             raise TypeError(\n279                 \"Cannot aggregate column '{}' with type '{}': {}\".format(\n280                     par_col.info.name, par_col.info.dtype, err\n281                 )\n282             ) from err\n283 \n284         out_info = out.info\n285         for attr in (\"name\", \"unit\", \"format\", \"description\", \"meta\"):\n286             try:\n287                 setattr(out_info, attr, getattr(par_col.info, attr))\n288             except AttributeError:\n289                 pass\n290 \n291         return out\n292 \n293     def filter(self, func):\n294         \"\"\"\n295         Filter groups in the Column based on evaluating function ``func`` on each\n296         group sub-table.\n297 \n298         The function which is passed to this method must accept one argument:\n299 \n300         - ``column`` : `Column` object\n301 \n302         It must then return either `True` or `False`.  As an example, the following\n303         will select all column groups with only positive values::\n304 \n305           def all_positive(column):\n306               if np.any(column < 0):\n307                   return False\n308               return True\n309 \n310         Parameters\n311         ----------\n312         func : function\n313             Filter function\n314 \n315         Returns\n316         -------\n317         out : Column\n318             New column with the aggregated rows.\n319         \"\"\"\n320         mask = np.empty(len(self), dtype=bool)\n321         for i, group_column in enumerate(self):\n322             mask[i] = func(group_column)\n323 \n324         return self[mask]\n325 \n326 \n327 class TableGroups(BaseGroups):\n328     def __init__(self, parent_table, indices=None, keys=None):\n329         self.parent_table = parent_table  # parent Table\n330         self._indices = indices\n331         self._keys = keys\n332 \n333     @property\n334     def key_colnames(self):\n335         \"\"\"\n336         Return the names of columns in the parent table that were used for grouping.\n337         \"\"\"\n338         # If the table was grouped by key columns *in* the table then treat those columns\n339         # differently in aggregation.  In this case keys will be a Table with\n340         # keys.meta['grouped_by_table_cols'] == True.  Keys might not be a Table so we\n341         # need to handle this.\n342         grouped_by_table_cols = getattr(self.keys, \"meta\", {}).get(\n343             \"grouped_by_table_cols\", False\n344         )\n345         return self.keys.colnames if grouped_by_table_cols else ()\n346 \n347     @property\n348     def indices(self):\n349         if self._indices is None:\n350             return np.array([0, len(self.parent_table)])\n351         else:\n352             return self._indices\n353 \n354     def aggregate(self, func):\n355         \"\"\"\n356         Aggregate each group in the Table into a single row by applying the reduction\n357         function ``func`` to group values in each column.\n358 \n359         Parameters\n360         ----------\n361         func : function\n362             Function that reduces an array of values to a single value\n363 \n364         Returns\n365         -------\n366         out : Table\n367             New table with the aggregated rows.\n368         \"\"\"\n369         i0s = self.indices[:-1]\n370         out_cols = []\n371         parent_table = self.parent_table\n372 \n373         for col in parent_table.columns.values():\n374             # For key columns just pick off first in each group since they are identical\n375             if col.info.name in self.key_colnames:\n376                 new_col = col.take(i0s)\n377             else:\n378                 try:\n379                     new_col = col.info.groups.aggregate(func)\n380                 except TypeError as err:\n381                     warnings.warn(str(err), AstropyUserWarning)\n382                     continue\n383 \n384             out_cols.append(new_col)\n385 \n386         return parent_table.__class__(out_cols, meta=parent_table.meta)\n387 \n388     def filter(self, func):\n389         \"\"\"\n390         Filter groups in the Table based on evaluating function ``func`` on each\n391         group sub-table.\n392 \n393         The function which is passed to this method must accept two arguments:\n394 \n395         - ``table`` : `Table` object\n396         - ``key_colnames`` : tuple of column names in ``table`` used as keys for grouping\n397 \n398         It must then return either `True` or `False`.  As an example, the following\n399         will select all table groups with only positive values in the non-key columns::\n400 \n401           def all_positive(table, key_colnames):\n402               colnames = [name for name in table.colnames if name not in key_colnames]\n403               for colname in colnames:\n404                   if np.any(table[colname] < 0):\n405                       return False\n406               return True\n407 \n408         Parameters\n409         ----------\n410         func : function\n411             Filter function\n412 \n413         Returns\n414         -------\n415         out : Table\n416             New table with the aggregated rows.\n417         \"\"\"\n418         mask = np.empty(len(self), dtype=bool)\n419         key_colnames = self.key_colnames\n420         for i, group_table in enumerate(self):\n421             mask[i] = func(group_table, key_colnames)\n422 \n423         return self[mask]\n424 \n425     @property\n426     def keys(self):\n427         return self._keys\n",
        "intended_behavior": "This file is likely to contain the logic for handling the grouping of `QTable` instances, specifically how keys for each group are generated and handled. The intended behavior would be to ensure that when a group key is generated from a column containing quantities (i.e., values with units), the key should retain the unit information. This could potentially be addressed by modifying how keys are extracted from the table columns to include units or by adjusting the representation of the keys in grouped outputs. Preserving existing functionality means ensuring that any modifications do not disrupt the current handling of non-quantity columns and maintain the performance and usability of the grouping feature."
    }
]