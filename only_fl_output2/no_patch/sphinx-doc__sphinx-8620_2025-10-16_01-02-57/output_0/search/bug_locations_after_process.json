[
    {
        "rel_file_path": "sphinx/roles.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__3.5/sphinx/roles.py",
        "start": 1,
        "end": 630,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2     sphinx.roles\n3     ~~~~~~~~~~~~\n4 \n5     Handlers for additional ReST roles.\n6 \n7     :copyright: Copyright 2007-2020 by the Sphinx team, see AUTHORS.\n8     :license: BSD, see LICENSE for details.\n9 \"\"\"\n10 \n11 import re\n12 import warnings\n13 from typing import Any, Dict, List, Tuple\n14 \n15 from docutils import nodes, utils\n16 from docutils.nodes import Element, Node, TextElement, system_message\n17 from docutils.parsers.rst.states import Inliner\n18 \n19 from sphinx import addnodes\n20 from sphinx.deprecation import RemovedInSphinx40Warning\n21 from sphinx.locale import _\n22 from sphinx.util import ws_re\n23 from sphinx.util.docutils import ReferenceRole, SphinxRole\n24 from sphinx.util.nodes import process_index_entry, set_role_source_info, split_explicit_title\n25 from sphinx.util.typing import RoleFunction\n26 \n27 if False:\n28     # For type annotation\n29     from typing import Type  # for python3.5.1\n30 \n31     from sphinx.application import Sphinx\n32     from sphinx.environment import BuildEnvironment\n33 \n34 \n35 generic_docroles = {\n36     'command': addnodes.literal_strong,\n37     'dfn': nodes.emphasis,\n38     'kbd': nodes.literal,\n39     'mailheader': addnodes.literal_emphasis,\n40     'makevar': addnodes.literal_strong,\n41     'manpage': addnodes.manpage,\n42     'mimetype': addnodes.literal_emphasis,\n43     'newsgroup': addnodes.literal_emphasis,\n44     'program': addnodes.literal_strong,  # XXX should be an x-ref\n45     'regexp': nodes.literal,\n46 }\n47 \n48 \n49 # -- generic cross-reference role ----------------------------------------------\n50 \n51 class XRefRole(ReferenceRole):\n52     \"\"\"\n53     A generic cross-referencing role.  To create a callable that can be used as\n54     a role function, create an instance of this class.\n55 \n56     The general features of this role are:\n57 \n58     * Automatic creation of a reference and a content node.\n59     * Optional separation of title and target with `title <target>`.\n60     * The implementation is a class rather than a function to make\n61       customization easier.\n62 \n63     Customization can be done in two ways:\n64 \n65     * Supplying constructor parameters:\n66       * `fix_parens` to normalize parentheses (strip from target, and add to\n67         title if configured)\n68       * `lowercase` to lowercase the target\n69       * `nodeclass` and `innernodeclass` select the node classes for\n70         the reference and the content node\n71 \n72     * Subclassing and overwriting `process_link()` and/or `result_nodes()`.\n73     \"\"\"\n74 \n75     nodeclass = addnodes.pending_xref   # type: Type[Element]\n76     innernodeclass = nodes.literal      # type: Type[TextElement]\n77 \n78     def __init__(self, fix_parens: bool = False, lowercase: bool = False,\n79                  nodeclass: \"Type[Element]\" = None, innernodeclass: \"Type[TextElement]\" = None,\n80                  warn_dangling: bool = False) -> None:\n81         self.fix_parens = fix_parens\n82         self.lowercase = lowercase\n83         self.warn_dangling = warn_dangling\n84         if nodeclass is not None:\n85             self.nodeclass = nodeclass\n86         if innernodeclass is not None:\n87             self.innernodeclass = innernodeclass\n88 \n89         super().__init__()\n90 \n91     def _fix_parens(self, env: \"BuildEnvironment\", has_explicit_title: bool, title: str,\n92                     target: str) -> Tuple[str, str]:\n93         warnings.warn('XRefRole._fix_parens() is deprecated.',\n94                       RemovedInSphinx40Warning, stacklevel=2)\n95         if not has_explicit_title:\n96             if title.endswith('()'):\n97                 # remove parentheses\n98                 title = title[:-2]\n99             if env.config.add_function_parentheses:\n100                 # add them back to all occurrences if configured\n101                 title += '()'\n102         # remove parentheses from the target too\n103         if target.endswith('()'):\n104             target = target[:-2]\n105         return title, target\n106 \n107     def update_title_and_target(self, title: str, target: str) -> Tuple[str, str]:\n108         if not self.has_explicit_title:\n109             if title.endswith('()'):\n110                 # remove parentheses\n111                 title = title[:-2]\n112             if self.config.add_function_parentheses:\n113                 # add them back to all occurrences if configured\n114                 title += '()'\n115         # remove parentheses from the target too\n116         if target.endswith('()'):\n117             target = target[:-2]\n118         return title, target\n119 \n120     def run(self) -> Tuple[List[Node], List[system_message]]:\n121         if ':' not in self.name:\n122             self.refdomain, self.reftype = '', self.name\n123             self.classes = ['xref', self.reftype]\n124         else:\n125             self.refdomain, self.reftype = self.name.split(':', 1)\n126             self.classes = ['xref', self.refdomain, '%s-%s' % (self.refdomain, self.reftype)]\n127 \n128         if self.disabled:\n129             return self.create_non_xref_node()\n130         else:\n131             return self.create_xref_node()\n132 \n133     def create_non_xref_node(self) -> Tuple[List[Node], List[system_message]]:\n134         text = utils.unescape(self.text[1:])\n135         if self.fix_parens:\n136             self.has_explicit_title = False  # treat as implicit\n137             text, target = self.update_title_and_target(text, \"\")\n138 \n139         node = self.innernodeclass(self.rawtext, text, classes=self.classes)\n140         return self.result_nodes(self.inliner.document, self.env, node, is_ref=False)\n141 \n142     def create_xref_node(self) -> Tuple[List[Node], List[system_message]]:\n143         target = self.target\n144         title = self.title\n145         if self.lowercase:\n146             target = target.lower()\n147         if self.fix_parens:\n148             title, target = self.update_title_and_target(title, target)\n149 \n150         # create the reference node\n151         options = {'refdoc': self.env.docname,\n152                    'refdomain': self.refdomain,\n153                    'reftype': self.reftype,\n154                    'refexplicit': self.has_explicit_title,\n155                    'refwarn': self.warn_dangling}\n156         refnode = self.nodeclass(self.rawtext, **options)\n157         self.set_source_info(refnode)\n158 \n159         # determine the target and title for the class\n160         title, target = self.process_link(self.env, refnode, self.has_explicit_title,\n161                                           title, target)\n162         refnode['reftarget'] = target\n163         refnode += self.innernodeclass(self.rawtext, title, classes=self.classes)\n164 \n165         return self.result_nodes(self.inliner.document, self.env, refnode, is_ref=True)\n166 \n167     # methods that can be overwritten\n168 \n169     def process_link(self, env: \"BuildEnvironment\", refnode: Element, has_explicit_title: bool,\n170                      title: str, target: str) -> Tuple[str, str]:\n171         \"\"\"Called after parsing title and target text, and creating the\n172         reference node (given in *refnode*).  This method can alter the\n173         reference node and must return a new (or the same) ``(title, target)``\n174         tuple.\n175         \"\"\"\n176         return title, ws_re.sub(' ', target)\n177 \n178     def result_nodes(self, document: nodes.document, env: \"BuildEnvironment\", node: Element,\n179                      is_ref: bool) -> Tuple[List[Node], List[system_message]]:\n180         \"\"\"Called before returning the finished nodes.  *node* is the reference\n181         node if one was created (*is_ref* is then true), else the content node.\n182         This method can add other nodes and must return a ``(nodes, messages)``\n183         tuple (the usual return value of a role function).\n184         \"\"\"\n185         return [node], []\n186 \n187 \n188 class AnyXRefRole(XRefRole):\n189     def process_link(self, env: \"BuildEnvironment\", refnode: Element, has_explicit_title: bool,\n190                      title: str, target: str) -> Tuple[str, str]:\n191         result = super().process_link(env, refnode, has_explicit_title, title, target)\n192         # add all possible context info (i.e. std:program, py:module etc.)\n193         refnode.attributes.update(env.ref_context)\n194         return result\n195 \n196 \n197 def indexmarkup_role(typ: str, rawtext: str, text: str, lineno: int, inliner: Inliner,\n198                      options: Dict = {}, content: List[str] = []\n199                      ) -> Tuple[List[Node], List[system_message]]:\n200     \"\"\"Role for PEP/RFC references that generate an index entry.\"\"\"\n201     warnings.warn('indexmarkup_role() is deprecated.  Please use PEP or RFC class instead.',\n202                   RemovedInSphinx40Warning, stacklevel=2)\n203     env = inliner.document.settings.env\n204     if not typ:\n205         assert env.temp_data['default_role']\n206         typ = env.temp_data['default_role'].lower()\n207     else:\n208         typ = typ.lower()\n209 \n210     has_explicit_title, title, target = split_explicit_title(text)\n211     title = utils.unescape(title)\n212     target = utils.unescape(target)\n213     targetid = 'index-%s' % env.new_serialno('index')\n214     indexnode = addnodes.index()\n215     targetnode = nodes.target('', '', ids=[targetid])\n216     inliner.document.note_explicit_target(targetnode)\n217     if typ == 'pep':\n218         indexnode['entries'] = [\n219             ('single', _('Python Enhancement Proposals; PEP %s') % target,\n220              targetid, '', None)]\n221         anchor = ''\n222         anchorindex = target.find('#')\n223         if anchorindex > 0:\n224             target, anchor = target[:anchorindex], target[anchorindex:]\n225         if not has_explicit_title:\n226             title = \"PEP \" + utils.unescape(title)\n227         try:\n228             pepnum = int(target)\n229         except ValueError:\n230             msg = inliner.reporter.error('invalid PEP number %s' % target,\n231                                          line=lineno)\n232             prb = inliner.problematic(rawtext, rawtext, msg)\n233             return [prb], [msg]\n234         ref = inliner.document.settings.pep_base_url + 'pep-%04d' % pepnum\n235         sn = nodes.strong(title, title)\n236         rn = nodes.reference('', '', internal=False, refuri=ref + anchor,\n237                              classes=[typ])\n238         rn += sn\n239         return [indexnode, targetnode, rn], []\n240     elif typ == 'rfc':\n241         indexnode['entries'] = [\n242             ('single', 'RFC; RFC %s' % target, targetid, '', None)]\n243         anchor = ''\n244         anchorindex = target.find('#')\n245         if anchorindex > 0:\n246             target, anchor = target[:anchorindex], target[anchorindex:]\n247         if not has_explicit_title:\n248             title = \"RFC \" + utils.unescape(title)\n249         try:\n250             rfcnum = int(target)\n251         except ValueError:\n252             msg = inliner.reporter.error('invalid RFC number %s' % target,\n253                                          line=lineno)\n254             prb = inliner.problematic(rawtext, rawtext, msg)\n255             return [prb], [msg]\n256         ref = inliner.document.settings.rfc_base_url + inliner.rfc_url % rfcnum\n257         sn = nodes.strong(title, title)\n258         rn = nodes.reference('', '', internal=False, refuri=ref + anchor,\n259                              classes=[typ])\n260         rn += sn\n261         return [indexnode, targetnode, rn], []\n262     else:\n263         raise ValueError('unknown role type: %s' % typ)\n264 \n265 \n266 class PEP(ReferenceRole):\n267     def run(self) -> Tuple[List[Node], List[system_message]]:\n268         target_id = 'index-%s' % self.env.new_serialno('index')\n269         entries = [('single', _('Python Enhancement Proposals; PEP %s') % self.target,\n270                     target_id, '', None)]\n271 \n272         index = addnodes.index(entries=entries)\n273         target = nodes.target('', '', ids=[target_id])\n274         self.inliner.document.note_explicit_target(target)\n275 \n276         try:\n277             refuri = self.build_uri()\n278             reference = nodes.reference('', '', internal=False, refuri=refuri, classes=['pep'])\n279             if self.has_explicit_title:\n280                 reference += nodes.strong(self.title, self.title)\n281             else:\n282                 title = \"PEP \" + self.title\n283                 reference += nodes.strong(title, title)\n284         except ValueError:\n285             msg = self.inliner.reporter.error('invalid PEP number %s' % self.target,\n286                                               line=self.lineno)\n287             prb = self.inliner.problematic(self.rawtext, self.rawtext, msg)\n288             return [prb], [msg]\n289 \n290         return [index, target, reference], []\n291 \n292     def build_uri(self) -> str:\n293         base_url = self.inliner.document.settings.pep_base_url\n294         ret = self.target.split('#', 1)\n295         if len(ret) == 2:\n296             return base_url + 'pep-%04d#%s' % (int(ret[0]), ret[1])\n297         else:\n298             return base_url + 'pep-%04d' % int(ret[0])\n299 \n300 \n301 class RFC(ReferenceRole):\n302     def run(self) -> Tuple[List[Node], List[system_message]]:\n303         target_id = 'index-%s' % self.env.new_serialno('index')\n304         entries = [('single', 'RFC; RFC %s' % self.target, target_id, '', None)]\n305 \n306         index = addnodes.index(entries=entries)\n307         target = nodes.target('', '', ids=[target_id])\n308         self.inliner.document.note_explicit_target(target)\n309 \n310         try:\n311             refuri = self.build_uri()\n312             reference = nodes.reference('', '', internal=False, refuri=refuri, classes=['rfc'])\n313             if self.has_explicit_title:\n314                 reference += nodes.strong(self.title, self.title)\n315             else:\n316                 title = \"RFC \" + self.title\n317                 reference += nodes.strong(title, title)\n318         except ValueError:\n319             msg = self.inliner.reporter.error('invalid RFC number %s' % self.target,\n320                                               line=self.lineno)\n321             prb = self.inliner.problematic(self.rawtext, self.rawtext, msg)\n322             return [prb], [msg]\n323 \n324         return [index, target, reference], []\n325 \n326     def build_uri(self) -> str:\n327         base_url = self.inliner.document.settings.rfc_base_url\n328         ret = self.target.split('#', 1)\n329         if len(ret) == 2:\n330             return base_url + self.inliner.rfc_url % int(ret[0]) + '#' + ret[1]\n331         else:\n332             return base_url + self.inliner.rfc_url % int(ret[0])\n333 \n334 \n335 _amp_re = re.compile(r'(?<!&)&(?![&\\s])')\n336 \n337 \n338 def menusel_role(typ: str, rawtext: str, text: str, lineno: int, inliner: Inliner,\n339                  options: Dict = {}, content: List[str] = []\n340                  ) -> Tuple[List[Node], List[system_message]]:\n341     warnings.warn('menusel_role() is deprecated. '\n342                   'Please use MenuSelection or GUILabel class instead.',\n343                   RemovedInSphinx40Warning, stacklevel=2)\n344     env = inliner.document.settings.env\n345     if not typ:\n346         assert env.temp_data['default_role']\n347         typ = env.temp_data['default_role'].lower()\n348     else:\n349         typ = typ.lower()\n350 \n351     text = utils.unescape(text)\n352     if typ == 'menuselection':\n353         text = text.replace('-->', '\\N{TRIANGULAR BULLET}')\n354     spans = _amp_re.split(text)\n355 \n356     node = nodes.inline(rawtext=rawtext)\n357     for i, span in enumerate(spans):\n358         span = span.replace('&&', '&')\n359         if i == 0:\n360             if len(span) > 0:\n361                 textnode = nodes.Text(span)\n362                 node += textnode\n363             continue\n364         accel_node = nodes.inline()\n365         letter_node = nodes.Text(span[0])\n366         accel_node += letter_node\n367         accel_node['classes'].append('accelerator')\n368         node += accel_node\n369         textnode = nodes.Text(span[1:])\n370         node += textnode\n371 \n372     node['classes'].append(typ)\n373     return [node], []\n374 \n375 \n376 class GUILabel(SphinxRole):\n377     amp_re = re.compile(r'(?<!&)&(?![&\\s])')\n378 \n379     def run(self) -> Tuple[List[Node], List[system_message]]:\n380         node = nodes.inline(rawtext=self.rawtext, classes=[self.name])\n381         spans = self.amp_re.split(self.text)\n382         node += nodes.Text(spans.pop(0))\n383         for span in spans:\n384             span = span.replace('&&', '&')\n385 \n386             letter = nodes.Text(span[0])\n387             accelerator = nodes.inline('', '', letter, classes=['accelerator'])\n388             node += accelerator\n389             node += nodes.Text(span[1:])\n390 \n391         return [node], []\n392 \n393 \n394 class MenuSelection(GUILabel):\n395     BULLET_CHARACTER = '\\N{TRIANGULAR BULLET}'\n396 \n397     def run(self) -> Tuple[List[Node], List[system_message]]:\n398         self.text = self.text.replace('-->', self.BULLET_CHARACTER)\n399         return super().run()\n400 \n401 \n402 _litvar_re = re.compile('{([^}]+)}')\n403 parens_re = re.compile(r'(\\\\*{|\\\\*})')\n404 \n405 \n406 def emph_literal_role(typ: str, rawtext: str, text: str, lineno: int, inliner: Inliner,\n407                       options: Dict = {}, content: List[str] = []\n408                       ) -> Tuple[List[Node], List[system_message]]:\n409     warnings.warn('emph_literal_role() is deprecated. '\n410                   'Please use EmphasizedLiteral class instead.',\n411                   RemovedInSphinx40Warning, stacklevel=2)\n412     env = inliner.document.settings.env\n413     if not typ:\n414         assert env.temp_data['default_role']\n415         typ = env.temp_data['default_role'].lower()\n416     else:\n417         typ = typ.lower()\n418 \n419     retnode = nodes.literal(role=typ.lower(), classes=[typ])\n420     parts = list(parens_re.split(utils.unescape(text)))\n421     stack = ['']\n422     for part in parts:\n423         matched = parens_re.match(part)\n424         if matched:\n425             backslashes = len(part) - 1\n426             if backslashes % 2 == 1:    # escaped\n427                 stack[-1] += \"\\\\\" * int((backslashes - 1) / 2) + part[-1]\n428             elif part[-1] == '{':       # rparen\n429                 stack[-1] += \"\\\\\" * int(backslashes / 2)\n430                 if len(stack) >= 2 and stack[-2] == \"{\":\n431                     # nested\n432                     stack[-1] += \"{\"\n433                 else:\n434                     # start emphasis\n435                     stack.append('{')\n436                     stack.append('')\n437             else:                       # lparen\n438                 stack[-1] += \"\\\\\" * int(backslashes / 2)\n439                 if len(stack) == 3 and stack[1] == \"{\" and len(stack[2]) > 0:\n440                     # emphasized word found\n441                     if stack[0]:\n442                         retnode += nodes.Text(stack[0], stack[0])\n443                     retnode += nodes.emphasis(stack[2], stack[2])\n444                     stack = ['']\n445                 else:\n446                     # emphasized word not found; the rparen is not a special symbol\n447                     stack.append('}')\n448                     stack = [''.join(stack)]\n449         else:\n450             stack[-1] += part\n451     if ''.join(stack):\n452         # remaining is treated as Text\n453         text = ''.join(stack)\n454         retnode += nodes.Text(text, text)\n455 \n456     return [retnode], []\n457 \n458 \n459 class EmphasizedLiteral(SphinxRole):\n460     parens_re = re.compile(r'(\\\\\\\\|\\\\{|\\\\}|{|})')\n461 \n462     def run(self) -> Tuple[List[Node], List[system_message]]:\n463         children = self.parse(self.text)\n464         node = nodes.literal(self.rawtext, '', *children,\n465                              role=self.name.lower(), classes=[self.name])\n466 \n467         return [node], []\n468 \n469     def parse(self, text: str) -> List[Node]:\n470         result = []  # type: List[Node]\n471 \n472         stack = ['']\n473         for part in self.parens_re.split(text):\n474             if part == '\\\\\\\\':  # escaped backslash\n475                 stack[-1] += '\\\\'\n476             elif part == '{':\n477                 if len(stack) >= 2 and stack[-2] == \"{\":  # nested\n478                     stack[-1] += \"{\"\n479                 else:\n480                     # start emphasis\n481                     stack.append('{')\n482                     stack.append('')\n483             elif part == '}':\n484                 if len(stack) == 3 and stack[1] == \"{\" and len(stack[2]) > 0:\n485                     # emphasized word found\n486                     if stack[0]:\n487                         result.append(nodes.Text(stack[0], stack[0]))\n488                     result.append(nodes.emphasis(stack[2], stack[2]))\n489                     stack = ['']\n490                 else:\n491                     # emphasized word not found; the rparen is not a special symbol\n492                     stack.append('}')\n493                     stack = [''.join(stack)]\n494             elif part == '\\\\{':  # escaped left-brace\n495                 stack[-1] += '{'\n496             elif part == '\\\\}':  # escaped right-brace\n497                 stack[-1] += '}'\n498             else:  # others (containing escaped braces)\n499                 stack[-1] += part\n500 \n501         if ''.join(stack):\n502             # remaining is treated as Text\n503             text = ''.join(stack)\n504             result.append(nodes.Text(text, text))\n505 \n506         return result\n507 \n508 \n509 _abbr_re = re.compile(r'\\((.*)\\)$', re.S)\n510 \n511 \n512 def abbr_role(typ: str, rawtext: str, text: str, lineno: int, inliner: Inliner,\n513               options: Dict = {}, content: List[str] = []\n514               ) -> Tuple[List[Node], List[system_message]]:\n515     warnings.warn('abbr_role() is deprecated.  Please use Abbrevation class instead.',\n516                   RemovedInSphinx40Warning, stacklevel=2)\n517     text = utils.unescape(text)\n518     m = _abbr_re.search(text)\n519     if m is None:\n520         return [nodes.abbreviation(text, text, **options)], []\n521     abbr = text[:m.start()].strip()\n522     expl = m.group(1)\n523     options = options.copy()\n524     options['explanation'] = expl\n525     return [nodes.abbreviation(abbr, abbr, **options)], []\n526 \n527 \n528 class Abbreviation(SphinxRole):\n529     abbr_re = re.compile(r'\\((.*)\\)$', re.S)\n530 \n531     def run(self) -> Tuple[List[Node], List[system_message]]:\n532         options = self.options.copy()\n533         matched = self.abbr_re.search(self.text)\n534         if matched:\n535             text = self.text[:matched.start()].strip()\n536             options['explanation'] = matched.group(1)\n537         else:\n538             text = self.text\n539 \n540         return [nodes.abbreviation(self.rawtext, text, **options)], []\n541 \n542 \n543 def index_role(typ: str, rawtext: str, text: str, lineno: int, inliner: Inliner,\n544                options: Dict = {}, content: List[str] = []\n545                ) -> Tuple[List[Node], List[system_message]]:\n546     warnings.warn('index_role() is deprecated.  Please use Index class instead.',\n547                   RemovedInSphinx40Warning, stacklevel=2)\n548     # create new reference target\n549     env = inliner.document.settings.env\n550     targetid = 'index-%s' % env.new_serialno('index')\n551     targetnode = nodes.target('', '', ids=[targetid])\n552     # split text and target in role content\n553     has_explicit_title, title, target = split_explicit_title(text)\n554     title = utils.unescape(title)\n555     target = utils.unescape(target)\n556     # if an explicit target is given, we can process it as a full entry\n557     if has_explicit_title:\n558         entries = process_index_entry(target, targetid)\n559     # otherwise we just create a \"single\" entry\n560     else:\n561         # but allow giving main entry\n562         main = ''\n563         if target.startswith('!'):\n564             target = target[1:]\n565             title = title[1:]\n566             main = 'main'\n567         entries = [('single', target, targetid, main, None)]\n568     indexnode = addnodes.index()\n569     indexnode['entries'] = entries\n570     set_role_source_info(inliner, lineno, indexnode)\n571     textnode = nodes.Text(title, title)\n572     return [indexnode, targetnode, textnode], []\n573 \n574 \n575 class Index(ReferenceRole):\n576     def run(self) -> Tuple[List[Node], List[system_message]]:\n577         warnings.warn('Index role is deprecated.', RemovedInSphinx40Warning, stacklevel=2)\n578         target_id = 'index-%s' % self.env.new_serialno('index')\n579         if self.has_explicit_title:\n580             # if an explicit target is given, process it as a full entry\n581             title = self.title\n582             entries = process_index_entry(self.target, target_id)\n583         else:\n584             # otherwise we just create a single entry\n585             if self.target.startswith('!'):\n586                 title = self.title[1:]\n587                 entries = [('single', self.target[1:], target_id, 'main', None)]\n588             else:\n589                 title = self.title\n590                 entries = [('single', self.target, target_id, '', None)]\n591 \n592         index = addnodes.index(entries=entries)\n593         target = nodes.target('', '', ids=[target_id])\n594         text = nodes.Text(title, title)\n595         self.set_source_info(index)\n596         return [index, target, text], []\n597 \n598 \n599 specific_docroles = {\n600     # links to download references\n601     'download': XRefRole(nodeclass=addnodes.download_reference),\n602     # links to anything\n603     'any': AnyXRefRole(warn_dangling=True),\n604 \n605     'pep': PEP(),\n606     'rfc': RFC(),\n607     'guilabel': GUILabel(),\n608     'menuselection': MenuSelection(),\n609     'file': EmphasizedLiteral(),\n610     'samp': EmphasizedLiteral(),\n611     'abbr': Abbreviation(),\n612 }  # type: Dict[str, RoleFunction]\n613 \n614 \n615 def setup(app: \"Sphinx\") -> Dict[str, Any]:\n616     from docutils.parsers.rst import roles\n617 \n618     for rolename, nodeclass in generic_docroles.items():\n619         generic = roles.GenericRole(rolename, nodeclass)\n620         role = roles.CustomRole(rolename, generic, {'classes': [rolename]})\n621         roles.register_local_role(rolename, role)\n622 \n623     for rolename, func in specific_docroles.items():\n624         roles.register_local_role(rolename, func)\n625 \n626     return {\n627         'version': 'builtin',\n628         'parallel_read_safe': True,\n629         'parallel_write_safe': True,\n630     }\n",
        "intended_behavior": "This file likely contains definitions or mechanisms for parsing and handling roles, including the `:kbd:` role. The intended behavior here would be to adjust or extend the handling of the `:kbd:` role to include a mechanism for detecting compound keystrokes and applying a distinct CSS class (e.g., `compound`) to the parent `<kbd>` element in such cases while preserving the styling and functionality for single keystrokes."
    },
    {
        "rel_file_path": "sphinx/builders/html/__init__.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__3.5/sphinx/builders/html/__init__.py",
        "start": 1,
        "end": 1271,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2     sphinx.builders.html\n3     ~~~~~~~~~~~~~~~~~~~~\n4 \n5     Several HTML builders.\n6 \n7     :copyright: Copyright 2007-2020 by the Sphinx team, see AUTHORS.\n8     :license: BSD, see LICENSE for details.\n9 \"\"\"\n10 \n11 import html\n12 import os\n13 import posixpath\n14 import re\n15 import sys\n16 import warnings\n17 from os import path\n18 from typing import IO, Any, Dict, Iterable, Iterator, List, Set, Tuple\n19 from urllib.parse import quote\n20 \n21 from docutils import nodes\n22 from docutils.core import publish_parts\n23 from docutils.frontend import OptionParser\n24 from docutils.io import DocTreeInput, StringOutput\n25 from docutils.nodes import Node\n26 from docutils.utils import relative_path\n27 \n28 from sphinx import __display_version__, package_dir\n29 from sphinx.application import Sphinx\n30 from sphinx.builders import Builder\n31 from sphinx.config import ENUM, Config\n32 from sphinx.deprecation import RemovedInSphinx40Warning\n33 from sphinx.domains import Domain, Index, IndexEntry\n34 from sphinx.environment.adapters.asset import ImageAdapter\n35 from sphinx.environment.adapters.indexentries import IndexEntries\n36 from sphinx.environment.adapters.toctree import TocTree\n37 from sphinx.errors import ConfigError, ThemeError\n38 from sphinx.highlighting import PygmentsBridge\n39 from sphinx.locale import _, __\n40 from sphinx.search import js_index\n41 from sphinx.theming import HTMLThemeFactory\n42 from sphinx.util import logging, md5, progress_message, status_iterator\n43 from sphinx.util.docutils import is_html5_writer_available, new_document\n44 from sphinx.util.fileutil import copy_asset\n45 from sphinx.util.i18n import format_date\n46 from sphinx.util.inventory import InventoryFile\n47 from sphinx.util.matching import DOTFILES, Matcher, patmatch\n48 from sphinx.util.osutil import copyfile, ensuredir, os_path, relative_uri\n49 from sphinx.util.tags import Tags\n50 from sphinx.writers.html import HTMLTranslator, HTMLWriter\n51 \n52 if False:\n53     # For type annotation\n54     from typing import Type  # for python3.5.1\n55 \n56 \n57 # HTML5 Writer is available or not\n58 if is_html5_writer_available():\n59     from sphinx.writers.html5 import HTML5Translator\n60     html5_ready = True\n61 else:\n62     html5_ready = False\n63 \n64 #: the filename for the inventory of objects\n65 INVENTORY_FILENAME = 'objects.inv'\n66 \n67 logger = logging.getLogger(__name__)\n68 return_codes_re = re.compile('[\\r\\n]+')\n69 \n70 \n71 def get_stable_hash(obj: Any) -> str:\n72     \"\"\"\n73     Return a stable hash for a Python data structure.  We can't just use\n74     the md5 of str(obj) since for example dictionary items are enumerated\n75     in unpredictable order due to hash randomization in newer Pythons.\n76     \"\"\"\n77     if isinstance(obj, dict):\n78         return get_stable_hash(list(obj.items()))\n79     elif isinstance(obj, (list, tuple)):\n80         obj = sorted(get_stable_hash(o) for o in obj)\n81     return md5(str(obj).encode()).hexdigest()\n82 \n83 \n84 class Stylesheet(str):\n85     \"\"\"A metadata of stylesheet.\n86 \n87     To keep compatibility with old themes, an instance of stylesheet behaves as\n88     its filename (str).\n89     \"\"\"\n90 \n91     attributes = None   # type: Dict[str, str]\n92     filename = None     # type: str\n93 \n94     def __new__(cls, filename: str, *args: str, **attributes: str) -> \"Stylesheet\":\n95         self = str.__new__(cls, filename)  # type: ignore\n96         self.filename = filename\n97         self.attributes = attributes\n98         self.attributes.setdefault('rel', 'stylesheet')\n99         self.attributes.setdefault('type', 'text/css')\n100         if args:  # old style arguments (rel, title)\n101             self.attributes['rel'] = args[0]\n102             self.attributes['title'] = args[1]\n103 \n104         return self\n105 \n106 \n107 class JavaScript(str):\n108     \"\"\"A metadata of javascript file.\n109 \n110     To keep compatibility with old themes, an instance of javascript behaves as\n111     its filename (str).\n112     \"\"\"\n113 \n114     attributes = None   # type: Dict[str, str]\n115     filename = None     # type: str\n116 \n117     def __new__(cls, filename: str, **attributes: str) -> \"JavaScript\":\n118         self = str.__new__(cls, filename)  # type: ignore\n119         self.filename = filename\n120         self.attributes = attributes\n121 \n122         return self\n123 \n124 \n125 class BuildInfo:\n126     \"\"\"buildinfo file manipulator.\n127 \n128     HTMLBuilder and its family are storing their own envdata to ``.buildinfo``.\n129     This class is a manipulator for the file.\n130     \"\"\"\n131 \n132     @classmethod\n133     def load(cls, f: IO) -> \"BuildInfo\":\n134         try:\n135             lines = f.readlines()\n136             assert lines[0].rstrip() == '# Sphinx build info version 1'\n137             assert lines[2].startswith('config: ')\n138             assert lines[3].startswith('tags: ')\n139 \n140             build_info = BuildInfo()\n141             build_info.config_hash = lines[2].split()[1].strip()\n142             build_info.tags_hash = lines[3].split()[1].strip()\n143             return build_info\n144         except Exception as exc:\n145             raise ValueError(__('build info file is broken: %r') % exc) from exc\n146 \n147     def __init__(self, config: Config = None, tags: Tags = None, config_categories: List[str] = []) -> None:  # NOQA\n148         self.config_hash = ''\n149         self.tags_hash = ''\n150 \n151         if config:\n152             values = {c.name: c.value for c in config.filter(config_categories)}\n153             self.config_hash = get_stable_hash(values)\n154 \n155         if tags:\n156             self.tags_hash = get_stable_hash(sorted(tags))\n157 \n158     def __eq__(self, other: \"BuildInfo\") -> bool:  # type: ignore\n159         return (self.config_hash == other.config_hash and\n160                 self.tags_hash == other.tags_hash)\n161 \n162     def dump(self, f: IO) -> None:\n163         f.write('# Sphinx build info version 1\\n'\n164                 '# This file hashes the configuration used when building these files.'\n165                 ' When it is not found, a full rebuild will be done.\\n'\n166                 'config: %s\\n'\n167                 'tags: %s\\n' %\n168                 (self.config_hash, self.tags_hash))\n169 \n170 \n171 class StandaloneHTMLBuilder(Builder):\n172     \"\"\"\n173     Builds standalone HTML docs.\n174     \"\"\"\n175     name = 'html'\n176     format = 'html'\n177     epilog = __('The HTML pages are in %(outdir)s.')\n178 \n179     copysource = True\n180     allow_parallel = True\n181     out_suffix = '.html'\n182     link_suffix = '.html'  # defaults to matching out_suffix\n183     indexer_format = js_index  # type: Any\n184     indexer_dumps_unicode = True\n185     # create links to original images from images [True/False]\n186     html_scaled_image_link = True\n187     supported_image_types = ['image/svg+xml', 'image/png',\n188                              'image/gif', 'image/jpeg']\n189     supported_remote_images = True\n190     supported_data_uri_images = True\n191     searchindex_filename = 'searchindex.js'\n192     add_permalinks = True\n193     allow_sharp_as_current_path = True\n194     embedded = False  # for things like HTML help or Qt help: suppresses sidebar\n195     search = True  # for things like HTML help and Apple help: suppress search\n196     use_index = False\n197     download_support = True  # enable download role\n198 \n199     imgpath = None          # type: str\n200     domain_indices = []     # type: List[Tuple[str, Type[Index], List[Tuple[str, List[IndexEntry]]], bool]]  # NOQA\n201 \n202     def __init__(self, app: Sphinx) -> None:\n203         super().__init__(app)\n204 \n205         # CSS files\n206         self.css_files = []  # type: List[Dict[str, str]]\n207 \n208         # JS files\n209         self.script_files = []  # type: List[JavaScript]\n210 \n211     def init(self) -> None:\n212         self.build_info = self.create_build_info()\n213         # basename of images directory\n214         self.imagedir = '_images'\n215         # section numbers for headings in the currently visited document\n216         self.secnumbers = {}  # type: Dict[str, Tuple[int, ...]]\n217         # currently written docname\n218         self.current_docname = None  # type: str\n219 \n220         self.init_templates()\n221         self.init_highlighter()\n222         self.init_css_files()\n223         self.init_js_files()\n224 \n225         html_file_suffix = self.get_builder_config('file_suffix', 'html')\n226         if html_file_suffix is not None:\n227             self.out_suffix = html_file_suffix\n228 \n229         html_link_suffix = self.get_builder_config('link_suffix', 'html')\n230         if html_link_suffix is not None:\n231             self.link_suffix = html_link_suffix\n232         else:\n233             self.link_suffix = self.out_suffix\n234 \n235         self.use_index = self.get_builder_config('use_index', 'html')\n236 \n237     def create_build_info(self) -> BuildInfo:\n238         return BuildInfo(self.config, self.tags, ['html'])\n239 \n240     def _get_translations_js(self) -> str:\n241         candidates = [path.join(dir, self.config.language,\n242                                 'LC_MESSAGES', 'sphinx.js')\n243                       for dir in self.config.locale_dirs] + \\\n244                      [path.join(package_dir, 'locale', self.config.language,\n245                                 'LC_MESSAGES', 'sphinx.js'),\n246                       path.join(sys.prefix, 'share/sphinx/locale',\n247                                 self.config.language, 'sphinx.js')]\n248 \n249         for jsfile in candidates:\n250             if path.isfile(jsfile):\n251                 return jsfile\n252         return None\n253 \n254     def get_theme_config(self) -> Tuple[str, Dict]:\n255         return self.config.html_theme, self.config.html_theme_options\n256 \n257     def init_templates(self) -> None:\n258         theme_factory = HTMLThemeFactory(self.app)\n259         themename, themeoptions = self.get_theme_config()\n260         self.theme = theme_factory.create(themename)\n261         self.theme_options = themeoptions.copy()\n262         self.create_template_bridge()\n263         self.templates.init(self, self.theme)\n264 \n265     def init_highlighter(self) -> None:\n266         # determine Pygments style and create the highlighter\n267         if self.config.pygments_style is not None:\n268             style = self.config.pygments_style\n269         elif self.theme:\n270             style = self.theme.get_config('theme', 'pygments_style', 'none')\n271         else:\n272             style = 'sphinx'\n273         self.highlighter = PygmentsBridge('html', style)\n274 \n275         if self.theme:\n276             dark_style = self.theme.get_config('theme', 'pygments_dark_style', None)\n277         else:\n278             dark_style = None\n279 \n280         if dark_style is not None:\n281             self.dark_highlighter = PygmentsBridge('html', dark_style)\n282             self.add_css_file('pygments_dark.css',\n283                               media='(prefers-color-scheme: dark)',\n284                               id='pygments_dark_css')\n285         else:\n286             self.dark_highlighter = None\n287 \n288     def init_css_files(self) -> None:\n289         for filename, attrs in self.app.registry.css_files:\n290             self.add_css_file(filename, **attrs)\n291 \n292         for filename, attrs in self.get_builder_config('css_files', 'html'):\n293             self.add_css_file(filename, **attrs)\n294 \n295     def add_css_file(self, filename: str, **kwargs: str) -> None:\n296         if '://' not in filename:\n297             filename = posixpath.join('_static', filename)\n298 \n299         self.css_files.append(Stylesheet(filename, **kwargs))  # type: ignore\n300 \n301     def init_js_files(self) -> None:\n302         self.add_js_file('jquery.js')\n303         self.add_js_file('underscore.js')\n304         self.add_js_file('doctools.js')\n305 \n306         for filename, attrs in self.app.registry.js_files:\n307             self.add_js_file(filename, **attrs)\n308 \n309         for filename, attrs in self.get_builder_config('js_files', 'html'):\n310             self.add_js_file(filename, **attrs)\n311 \n312         if self.config.language and self._get_translations_js():\n313             self.add_js_file('translations.js')\n314 \n315     def add_js_file(self, filename: str, **kwargs: str) -> None:\n316         if filename and '://' not in filename:\n317             filename = posixpath.join('_static', filename)\n318 \n319         self.script_files.append(JavaScript(filename, **kwargs))\n320 \n321     @property\n322     def default_translator_class(self) -> \"Type[nodes.NodeVisitor]\":  # type: ignore\n323         if not html5_ready or self.config.html4_writer:\n324             return HTMLTranslator\n325         else:\n326             return HTML5Translator\n327 \n328     @property\n329     def math_renderer_name(self) -> str:\n330         name = self.get_builder_config('math_renderer', 'html')\n331         if name is not None:\n332             # use given name\n333             return name\n334         else:\n335             # not given: choose a math_renderer from registered ones as possible\n336             renderers = list(self.app.registry.html_inline_math_renderers)\n337             if len(renderers) == 1:\n338                 # only default math_renderer (mathjax) is registered\n339                 return renderers[0]\n340             elif len(renderers) == 2:\n341                 # default and another math_renderer are registered; prior the another\n342                 renderers.remove('mathjax')\n343                 return renderers[0]\n344             else:\n345                 # many math_renderers are registered. can't choose automatically!\n346                 return None\n347 \n348     def get_outdated_docs(self) -> Iterator[str]:\n349         try:\n350             with open(path.join(self.outdir, '.buildinfo')) as fp:\n351                 buildinfo = BuildInfo.load(fp)\n352 \n353             if self.build_info != buildinfo:\n354                 yield from self.env.found_docs\n355                 return\n356         except ValueError as exc:\n357             logger.warning(__('Failed to read build info file: %r'), exc)\n358         except OSError:\n359             # ignore errors on reading\n360             pass\n361 \n362         if self.templates:\n363             template_mtime = self.templates.newest_template_mtime()\n364         else:\n365             template_mtime = 0\n366         for docname in self.env.found_docs:\n367             if docname not in self.env.all_docs:\n368                 yield docname\n369                 continue\n370             targetname = self.get_outfilename(docname)\n371             try:\n372                 targetmtime = path.getmtime(targetname)\n373             except Exception:\n374                 targetmtime = 0\n375             try:\n376                 srcmtime = max(path.getmtime(self.env.doc2path(docname)),\n377                                template_mtime)\n378                 if srcmtime > targetmtime:\n379                     yield docname\n380             except OSError:\n381                 # source doesn't exist anymore\n382                 pass\n383 \n384     def get_asset_paths(self) -> List[str]:\n385         return self.config.html_extra_path + self.config.html_static_path\n386 \n387     def render_partial(self, node: Node) -> Dict[str, str]:\n388         \"\"\"Utility: Render a lone doctree node.\"\"\"\n389         if node is None:\n390             return {'fragment': ''}\n391         doc = new_document('<partial node>')\n392         doc.append(node)\n393 \n394         writer = HTMLWriter(self)\n395         return publish_parts(reader_name='doctree',\n396                              writer=writer,\n397                              source_class=DocTreeInput,\n398                              settings_overrides={'output_encoding': 'unicode'},\n399                              source=doc)\n400 \n401     def prepare_writing(self, docnames: Set[str]) -> None:\n402         # create the search indexer\n403         self.indexer = None\n404         if self.search:\n405             from sphinx.search import IndexBuilder\n406             lang = self.config.html_search_language or self.config.language\n407             if not lang:\n408                 lang = 'en'\n409             self.indexer = IndexBuilder(self.env, lang,\n410                                         self.config.html_search_options,\n411                                         self.config.html_search_scorer)\n412             self.load_indexer(docnames)\n413 \n414         self.docwriter = HTMLWriter(self)\n415         self.docsettings = OptionParser(\n416             defaults=self.env.settings,\n417             components=(self.docwriter,),\n418             read_config_files=True).get_default_values()  # type: Any\n419         self.docsettings.compact_lists = bool(self.config.html_compact_lists)\n420 \n421         # determine the additional indices to include\n422         self.domain_indices = []\n423         # html_domain_indices can be False/True or a list of index names\n424         indices_config = self.config.html_domain_indices\n425         if indices_config:\n426             for domain_name in sorted(self.env.domains):\n427                 domain = None  # type: Domain\n428                 domain = self.env.domains[domain_name]\n429                 for indexcls in domain.indices:\n430                     indexname = '%s-%s' % (domain.name, indexcls.name)\n431                     if isinstance(indices_config, list):\n432                         if indexname not in indices_config:\n433                             continue\n434                     content, collapse = indexcls(domain).generate()\n435                     if content:\n436                         self.domain_indices.append(\n437                             (indexname, indexcls, content, collapse))\n438 \n439         # format the \"last updated on\" string, only once is enough since it\n440         # typically doesn't include the time of day\n441         lufmt = self.config.html_last_updated_fmt\n442         if lufmt is not None:\n443             self.last_updated = format_date(lufmt or _('%b %d, %Y'),\n444                                             language=self.config.language)\n445         else:\n446             self.last_updated = None\n447 \n448         logo = path.basename(self.config.html_logo) if self.config.html_logo else ''\n449         favicon = path.basename(self.config.html_favicon) if self.config.html_favicon else ''\n450 \n451         if not isinstance(self.config.html_use_opensearch, str):\n452             logger.warning(__('html_use_opensearch config value must now be a string'))\n453 \n454         self.relations = self.env.collect_relations()\n455 \n456         rellinks = []  # type: List[Tuple[str, str, str, str]]\n457         if self.use_index:\n458             rellinks.append(('genindex', _('General Index'), 'I', _('index')))\n459         for indexname, indexcls, content, collapse in self.domain_indices:\n460             # if it has a short name\n461             if indexcls.shortname:\n462                 rellinks.append((indexname, indexcls.localname,\n463                                  '', indexcls.shortname))\n464 \n465         if self.config.html_style is not None:\n466             stylename = self.config.html_style\n467         elif self.theme:\n468             stylename = self.theme.get_config('theme', 'stylesheet')\n469         else:\n470             stylename = 'default.css'\n471 \n472         self.globalcontext = {\n473             'embedded': self.embedded,\n474             'project': self.config.project,\n475             'release': return_codes_re.sub('', self.config.release),\n476             'version': self.config.version,\n477             'last_updated': self.last_updated,\n478             'copyright': self.config.copyright,\n479             'master_doc': self.config.master_doc,\n480             'use_opensearch': self.config.html_use_opensearch,\n481             'docstitle': self.config.html_title,\n482             'shorttitle': self.config.html_short_title,\n483             'show_copyright': self.config.html_show_copyright,\n484             'show_sphinx': self.config.html_show_sphinx,\n485             'has_source': self.config.html_copy_source,\n486             'show_source': self.config.html_show_sourcelink,\n487             'sourcelink_suffix': self.config.html_sourcelink_suffix,\n488             'file_suffix': self.out_suffix,\n489             'link_suffix': self.link_suffix,\n490             'script_files': self.script_files,\n491             'language': self.config.language,\n492             'css_files': self.css_files,\n493             'sphinx_version': __display_version__,\n494             'style': stylename,\n495             'rellinks': rellinks,\n496             'builder': self.name,\n497             'parents': [],\n498             'logo': logo,\n499             'favicon': favicon,\n500             'html5_doctype': html5_ready and not self.config.html4_writer,\n501         }\n502         if self.theme:\n503             self.globalcontext.update(\n504                 ('theme_' + key, val) for (key, val) in\n505                 self.theme.get_options(self.theme_options).items())\n506         self.globalcontext.update(self.config.html_context)\n507 \n508     def get_doc_context(self, docname: str, body: str, metatags: str) -> Dict[str, Any]:\n509         \"\"\"Collect items for the template context of a page.\"\"\"\n510         # find out relations\n511         prev = next = None\n512         parents = []\n513         rellinks = self.globalcontext['rellinks'][:]\n514         related = self.relations.get(docname)\n515         titles = self.env.titles\n516         if related and related[2]:\n517             try:\n518                 next = {\n519                     'link': self.get_relative_uri(docname, related[2]),\n520                     'title': self.render_partial(titles[related[2]])['title']\n521                 }\n522                 rellinks.append((related[2], next['title'], 'N', _('next')))\n523             except KeyError:\n524                 next = None\n525         if related and related[1]:\n526             try:\n527                 prev = {\n528                     'link': self.get_relative_uri(docname, related[1]),\n529                     'title': self.render_partial(titles[related[1]])['title']\n530                 }\n531                 rellinks.append((related[1], prev['title'], 'P', _('previous')))\n532             except KeyError:\n533                 # the relation is (somehow) not in the TOC tree, handle\n534                 # that gracefully\n535                 prev = None\n536         while related and related[0]:\n537             try:\n538                 parents.append(\n539                     {'link': self.get_relative_uri(docname, related[0]),\n540                      'title': self.render_partial(titles[related[0]])['title']})\n541             except KeyError:\n542                 pass\n543             related = self.relations.get(related[0])\n544         if parents:\n545             # remove link to the master file; we have a generic\n546             # \"back to index\" link already\n547             parents.pop()\n548         parents.reverse()\n549 \n550         # title rendered as HTML\n551         title_node = self.env.longtitles.get(docname)\n552         title = self.render_partial(title_node)['title'] if title_node else ''\n553 \n554         # Suffix for the document\n555         source_suffix = self.env.doc2path(docname, False)[len(docname):]\n556 \n557         # the name for the copied source\n558         if self.config.html_copy_source:\n559             sourcename = docname + source_suffix\n560             if source_suffix != self.config.html_sourcelink_suffix:\n561                 sourcename += self.config.html_sourcelink_suffix\n562         else:\n563             sourcename = ''\n564 \n565         # metadata for the document\n566         meta = self.env.metadata.get(docname)\n567 \n568         # local TOC and global TOC tree\n569         self_toc = TocTree(self.env).get_toc_for(docname, self)\n570         toc = self.render_partial(self_toc)['fragment']\n571 \n572         return {\n573             'parents': parents,\n574             'prev': prev,\n575             'next': next,\n576             'title': title,\n577             'meta': meta,\n578             'body': body,\n579             'metatags': metatags,\n580             'rellinks': rellinks,\n581             'sourcename': sourcename,\n582             'toc': toc,\n583             # only display a TOC if there's more than one item to show\n584             'display_toc': (self.env.toc_num_entries[docname] > 1),\n585             'page_source_suffix': source_suffix,\n586         }\n587 \n588     def write_doc(self, docname: str, doctree: nodes.document) -> None:\n589         destination = StringOutput(encoding='utf-8')\n590         doctree.settings = self.docsettings\n591 \n592         self.secnumbers = self.env.toc_secnumbers.get(docname, {})\n593         self.fignumbers = self.env.toc_fignumbers.get(docname, {})\n594         self.imgpath = relative_uri(self.get_target_uri(docname), '_images')\n595         self.dlpath = relative_uri(self.get_target_uri(docname), '_downloads')\n596         self.current_docname = docname\n597         self.docwriter.write(doctree, destination)\n598         self.docwriter.assemble_parts()\n599         body = self.docwriter.parts['fragment']\n600         metatags = self.docwriter.clean_meta\n601 \n602         ctx = self.get_doc_context(docname, body, metatags)\n603         self.handle_page(docname, ctx, event_arg=doctree)\n604 \n605     def write_doc_serialized(self, docname: str, doctree: nodes.document) -> None:\n606         self.imgpath = relative_uri(self.get_target_uri(docname), self.imagedir)\n607         self.post_process_images(doctree)\n608         title_node = self.env.longtitles.get(docname)\n609         title = self.render_partial(title_node)['title'] if title_node else ''\n610         self.index_page(docname, doctree, title)\n611 \n612     def finish(self) -> None:\n613         self.finish_tasks.add_task(self.gen_indices)\n614         self.finish_tasks.add_task(self.gen_pages_from_extensions)\n615         self.finish_tasks.add_task(self.gen_additional_pages)\n616         self.finish_tasks.add_task(self.copy_image_files)\n617         self.finish_tasks.add_task(self.copy_download_files)\n618         self.finish_tasks.add_task(self.copy_static_files)\n619         self.finish_tasks.add_task(self.copy_extra_files)\n620         self.finish_tasks.add_task(self.write_buildinfo)\n621 \n622         # dump the search index\n623         self.handle_finish()\n624 \n625     @progress_message(__('generating indices'))\n626     def gen_indices(self) -> None:\n627         # the global general index\n628         if self.use_index:\n629             self.write_genindex()\n630 \n631         # the global domain-specific indices\n632         self.write_domain_indices()\n633 \n634     def gen_pages_from_extensions(self) -> None:\n635         # pages from extensions\n636         for pagelist in self.events.emit('html-collect-pages'):\n637             for pagename, context, template in pagelist:\n638                 self.handle_page(pagename, context, template)\n639 \n640     @progress_message(__('writing additional pages'))\n641     def gen_additional_pages(self) -> None:\n642         # additional pages from conf.py\n643         for pagename, template in self.config.html_additional_pages.items():\n644             logger.info(pagename + ' ', nonl=True)\n645             self.handle_page(pagename, {}, template)\n646 \n647         # the search page\n648         if self.search:\n649             logger.info('search ', nonl=True)\n650             self.handle_page('search', {}, 'search.html')\n651 \n652         # the opensearch xml file\n653         if self.config.html_use_opensearch and self.search:\n654             logger.info('opensearch ', nonl=True)\n655             fn = path.join(self.outdir, '_static', 'opensearch.xml')\n656             self.handle_page('opensearch', {}, 'opensearch.xml', outfilename=fn)\n657 \n658     def write_genindex(self) -> None:\n659         # the total count of lines for each index letter, used to distribute\n660         # the entries into two columns\n661         genindex = IndexEntries(self.env).create_index(self)\n662         indexcounts = []\n663         for _k, entries in genindex:\n664             indexcounts.append(sum(1 + len(subitems)\n665                                    for _, (_, subitems, _) in entries))\n666 \n667         genindexcontext = {\n668             'genindexentries': genindex,\n669             'genindexcounts': indexcounts,\n670             'split_index': self.config.html_split_index,\n671         }\n672         logger.info('genindex ', nonl=True)\n673 \n674         if self.config.html_split_index:\n675             self.handle_page('genindex', genindexcontext,\n676                              'genindex-split.html')\n677             self.handle_page('genindex-all', genindexcontext,\n678                              'genindex.html')\n679             for (key, entries), count in zip(genindex, indexcounts):\n680                 ctx = {'key': key, 'entries': entries, 'count': count,\n681                        'genindexentries': genindex}\n682                 self.handle_page('genindex-' + key, ctx,\n683                                  'genindex-single.html')\n684         else:\n685             self.handle_page('genindex', genindexcontext, 'genindex.html')\n686 \n687     def write_domain_indices(self) -> None:\n688         for indexname, indexcls, content, collapse in self.domain_indices:\n689             indexcontext = {\n690                 'indextitle': indexcls.localname,\n691                 'content': content,\n692                 'collapse_index': collapse,\n693             }\n694             logger.info(indexname + ' ', nonl=True)\n695             self.handle_page(indexname, indexcontext, 'domainindex.html')\n696 \n697     def copy_image_files(self) -> None:\n698         if self.images:\n699             stringify_func = ImageAdapter(self.app.env).get_original_image_uri\n700             ensuredir(path.join(self.outdir, self.imagedir))\n701             for src in status_iterator(self.images, __('copying images... '), \"brown\",\n702                                        len(self.images), self.app.verbosity,\n703                                        stringify_func=stringify_func):\n704                 dest = self.images[src]\n705                 try:\n706                     copyfile(path.join(self.srcdir, src),\n707                              path.join(self.outdir, self.imagedir, dest))\n708                 except Exception as err:\n709                     logger.warning(__('cannot copy image file %r: %s'),\n710                                    path.join(self.srcdir, src), err)\n711 \n712     def copy_download_files(self) -> None:\n713         def to_relpath(f: str) -> str:\n714             return relative_path(self.srcdir, f)\n715 \n716         # copy downloadable files\n717         if self.env.dlfiles:\n718             ensuredir(path.join(self.outdir, '_downloads'))\n719             for src in status_iterator(self.env.dlfiles, __('copying downloadable files... '),\n720                                        \"brown\", len(self.env.dlfiles), self.app.verbosity,\n721                                        stringify_func=to_relpath):\n722                 try:\n723                     dest = path.join(self.outdir, '_downloads', self.env.dlfiles[src][1])\n724                     ensuredir(path.dirname(dest))\n725                     copyfile(path.join(self.srcdir, src), dest)\n726                 except OSError as err:\n727                     logger.warning(__('cannot copy downloadable file %r: %s'),\n728                                    path.join(self.srcdir, src), err)\n729 \n730     def create_pygments_style_file(self) -> None:\n731         \"\"\"create a style file for pygments.\"\"\"\n732         with open(path.join(self.outdir, '_static', 'pygments.css'), 'w') as f:\n733             f.write(self.highlighter.get_stylesheet())\n734 \n735         if self.dark_highlighter:\n736             with open(path.join(self.outdir, '_static', 'pygments_dark.css'), 'w') as f:\n737                 f.write(self.dark_highlighter.get_stylesheet())\n738 \n739     def copy_translation_js(self) -> None:\n740         \"\"\"Copy a JavaScript file for translations.\"\"\"\n741         if self.config.language is not None:\n742             jsfile = self._get_translations_js()\n743             if jsfile:\n744                 copyfile(jsfile, path.join(self.outdir, '_static', 'translations.js'))\n745 \n746     def copy_stemmer_js(self) -> None:\n747         \"\"\"Copy a JavaScript file for stemmer.\"\"\"\n748         if self.indexer is not None:\n749             jsfile = self.indexer.get_js_stemmer_rawcode()\n750             if jsfile:\n751                 copyfile(jsfile, path.join(self.outdir, '_static', '_stemmer.js'))\n752 \n753     def copy_theme_static_files(self, context: Dict) -> None:\n754         def onerror(filename: str, error: Exception) -> None:\n755             logger.warning(__('Failed to copy a file in html_static_file: %s: %r'),\n756                            filename, error)\n757 \n758         if self.theme:\n759             for entry in self.theme.get_theme_dirs()[::-1]:\n760                 copy_asset(path.join(entry, 'static'),\n761                            path.join(self.outdir, '_static'),\n762                            excluded=DOTFILES, context=context,\n763                            renderer=self.templates, onerror=onerror)\n764 \n765     def copy_html_static_files(self, context: Dict) -> None:\n766         def onerror(filename: str, error: Exception) -> None:\n767             logger.warning(__('Failed to copy a file in html_static_file: %s: %r'),\n768                            filename, error)\n769 \n770         excluded = Matcher(self.config.exclude_patterns + [\"**/.*\"])\n771         for entry in self.config.html_static_path:\n772             copy_asset(path.join(self.confdir, entry),\n773                        path.join(self.outdir, '_static'),\n774                        excluded, context=context, renderer=self.templates, onerror=onerror)\n775 \n776     def copy_html_logo(self) -> None:\n777         if self.config.html_logo:\n778             copy_asset(path.join(self.confdir, self.config.html_logo),\n779                        path.join(self.outdir, '_static'))\n780 \n781     def copy_html_favicon(self) -> None:\n782         if self.config.html_favicon:\n783             copy_asset(path.join(self.confdir, self.config.html_favicon),\n784                        path.join(self.outdir, '_static'))\n785 \n786     def copy_static_files(self) -> None:\n787         try:\n788             with progress_message(__('copying static files')):\n789                 ensuredir(path.join(self.outdir, '_static'))\n790 \n791                 # prepare context for templates\n792                 context = self.globalcontext.copy()\n793                 if self.indexer is not None:\n794                     context.update(self.indexer.context_for_searchtool())\n795 \n796                 self.create_pygments_style_file()\n797                 self.copy_translation_js()\n798                 self.copy_stemmer_js()\n799                 self.copy_theme_static_files(context)\n800                 self.copy_html_static_files(context)\n801                 self.copy_html_logo()\n802                 self.copy_html_favicon()\n803         except OSError as err:\n804             logger.warning(__('cannot copy static file %r'), err)\n805 \n806     def copy_extra_files(self) -> None:\n807         \"\"\"copy html_extra_path files.\"\"\"\n808         try:\n809             with progress_message(__('copying extra files')):\n810                 excluded = Matcher(self.config.exclude_patterns)\n811                 for extra_path in self.config.html_extra_path:\n812                     entry = path.join(self.confdir, extra_path)\n813                     copy_asset(entry, self.outdir, excluded)\n814         except OSError as err:\n815             logger.warning(__('cannot copy extra file %r'), err)\n816 \n817     def write_buildinfo(self) -> None:\n818         try:\n819             with open(path.join(self.outdir, '.buildinfo'), 'w') as fp:\n820                 self.build_info.dump(fp)\n821         except OSError as exc:\n822             logger.warning(__('Failed to write build info file: %r'), exc)\n823 \n824     def cleanup(self) -> None:\n825         # clean up theme stuff\n826         if self.theme:\n827             self.theme.cleanup()\n828 \n829     def post_process_images(self, doctree: Node) -> None:\n830         \"\"\"Pick the best candidate for an image and link down-scaled images to\n831         their high res version.\n832         \"\"\"\n833         Builder.post_process_images(self, doctree)\n834 \n835         if self.config.html_scaled_image_link and self.html_scaled_image_link:\n836             for node in doctree.traverse(nodes.image):\n837                 if not any((key in node) for key in ['scale', 'width', 'height']):\n838                     # resizing options are not given. scaled image link is available\n839                     # only for resized images.\n840                     continue\n841                 elif isinstance(node.parent, nodes.reference):\n842                     # A image having hyperlink target\n843                     continue\n844                 elif 'no-scaled-link' in node['classes']:\n845                     # scaled image link is disabled for this node\n846                     continue\n847 \n848                 uri = node['uri']\n849                 reference = nodes.reference('', '', internal=True)\n850                 if uri in self.images:\n851                     reference['refuri'] = posixpath.join(self.imgpath,\n852                                                          self.images[uri])\n853                 else:\n854                     reference['refuri'] = uri\n855                 node.replace_self(reference)\n856                 reference.append(node)\n857 \n858     def load_indexer(self, docnames: Iterable[str]) -> None:\n859         keep = set(self.env.all_docs) - set(docnames)\n860         try:\n861             searchindexfn = path.join(self.outdir, self.searchindex_filename)\n862             if self.indexer_dumps_unicode:\n863                 with open(searchindexfn, encoding='utf-8') as ft:\n864                     self.indexer.load(ft, self.indexer_format)\n865             else:\n866                 with open(searchindexfn, 'rb') as fb:\n867                     self.indexer.load(fb, self.indexer_format)\n868         except (OSError, ValueError):\n869             if keep:\n870                 logger.warning(__('search index couldn\\'t be loaded, but not all '\n871                                   'documents will be built: the index will be '\n872                                   'incomplete.'))\n873         # delete all entries for files that will be rebuilt\n874         self.indexer.prune(keep)\n875 \n876     def index_page(self, pagename: str, doctree: nodes.document, title: str) -> None:\n877         # only index pages with title\n878         if self.indexer is not None and title:\n879             filename = self.env.doc2path(pagename, base=None)\n880             try:\n881                 metadata = self.env.metadata.get(pagename, {})\n882                 if 'nosearch' in metadata:\n883                     self.indexer.feed(pagename, filename, '', new_document(''))\n884                 else:\n885                     self.indexer.feed(pagename, filename, title, doctree)\n886             except TypeError:\n887                 # fallback for old search-adapters\n888                 self.indexer.feed(pagename, title, doctree)  # type: ignore\n889                 indexer_name = self.indexer.__class__.__name__\n890                 warnings.warn(\n891                     'The %s.feed() method signature is deprecated. Update to '\n892                     '%s.feed(docname, filename, title, doctree).' % (\n893                         indexer_name, indexer_name),\n894                     RemovedInSphinx40Warning, stacklevel=2)\n895 \n896     def _get_local_toctree(self, docname: str, collapse: bool = True, **kwargs: Any) -> str:\n897         if 'includehidden' not in kwargs:\n898             kwargs['includehidden'] = False\n899         if kwargs.get('maxdepth') == '':\n900             kwargs.pop('maxdepth')\n901         return self.render_partial(TocTree(self.env).get_toctree_for(\n902             docname, self, collapse, **kwargs))['fragment']\n903 \n904     def get_outfilename(self, pagename: str) -> str:\n905         return path.join(self.outdir, os_path(pagename) + self.out_suffix)\n906 \n907     def add_sidebars(self, pagename: str, ctx: Dict) -> None:\n908         def has_wildcard(pattern: str) -> bool:\n909             return any(char in pattern for char in '*?[')\n910 \n911         sidebars = None\n912         matched = None\n913         customsidebar = None\n914 \n915         # default sidebars settings for selected theme\n916         if self.theme.name == 'alabaster':\n917             # provide default settings for alabaster (for compatibility)\n918             # Note: this will be removed before Sphinx-2.0\n919             try:\n920                 # get default sidebars settings from alabaster (if defined)\n921                 theme_default_sidebars = self.theme.config.get('theme', 'sidebars')\n922                 if theme_default_sidebars:\n923                     sidebars = [name.strip() for name in theme_default_sidebars.split(',')]\n924             except Exception:\n925                 # fallback to better default settings\n926                 sidebars = ['about.html', 'navigation.html', 'relations.html',\n927                             'searchbox.html', 'donate.html']\n928         else:\n929             theme_default_sidebars = self.theme.get_config('theme', 'sidebars', None)\n930             if theme_default_sidebars:\n931                 sidebars = [name.strip() for name in theme_default_sidebars.split(',')]\n932 \n933         # user sidebar settings\n934         html_sidebars = self.get_builder_config('sidebars', 'html')\n935         for pattern, patsidebars in html_sidebars.items():\n936             if patmatch(pagename, pattern):\n937                 if matched:\n938                     if has_wildcard(pattern):\n939                         # warn if both patterns contain wildcards\n940                         if has_wildcard(matched):\n941                             logger.warning(__('page %s matches two patterns in '\n942                                               'html_sidebars: %r and %r'),\n943                                            pagename, matched, pattern)\n944                         # else the already matched pattern is more specific\n945                         # than the present one, because it contains no wildcard\n946                         continue\n947                 matched = pattern\n948                 sidebars = patsidebars\n949 \n950         if sidebars is None:\n951             # keep defaults\n952             pass\n953 \n954         ctx['sidebars'] = sidebars\n955         ctx['customsidebar'] = customsidebar\n956 \n957     # --------- these are overwritten by the serialization builder\n958 \n959     def get_target_uri(self, docname: str, typ: str = None) -> str:\n960         return quote(docname) + self.link_suffix\n961 \n962     def handle_page(self, pagename: str, addctx: Dict, templatename: str = 'page.html',\n963                     outfilename: str = None, event_arg: Any = None) -> None:\n964         ctx = self.globalcontext.copy()\n965         # current_page_name is backwards compatibility\n966         ctx['pagename'] = ctx['current_page_name'] = pagename\n967         ctx['encoding'] = self.config.html_output_encoding\n968         default_baseuri = self.get_target_uri(pagename)\n969         # in the singlehtml builder, default_baseuri still contains an #anchor\n970         # part, which relative_uri doesn't really like...\n971         default_baseuri = default_baseuri.rsplit('#', 1)[0]\n972 \n973         if self.config.html_baseurl:\n974             ctx['pageurl'] = posixpath.join(self.config.html_baseurl,\n975                                             pagename + self.out_suffix)\n976         else:\n977             ctx['pageurl'] = None\n978 \n979         def pathto(otheruri: str, resource: bool = False, baseuri: str = default_baseuri) -> str:  # NOQA\n980             if resource and '://' in otheruri:\n981                 # allow non-local resources given by scheme\n982                 return otheruri\n983             elif not resource:\n984                 otheruri = self.get_target_uri(otheruri)\n985             uri = relative_uri(baseuri, otheruri) or '#'\n986             if uri == '#' and not self.allow_sharp_as_current_path:\n987                 uri = baseuri\n988             return uri\n989         ctx['pathto'] = pathto\n990 \n991         def css_tag(css: Stylesheet) -> str:\n992             attrs = []\n993             for key in sorted(css.attributes):\n994                 value = css.attributes[key]\n995                 if value is not None:\n996                     attrs.append('%s=\"%s\"' % (key, html.escape(value, True)))\n997             attrs.append('href=\"%s\"' % pathto(css.filename, resource=True))\n998             return '<link %s />' % ' '.join(attrs)\n999         ctx['css_tag'] = css_tag\n1000 \n1001         def hasdoc(name: str) -> bool:\n1002             if name in self.env.all_docs:\n1003                 return True\n1004             elif name == 'search' and self.search:\n1005                 return True\n1006             elif name == 'genindex' and self.get_builder_config('use_index', 'html'):\n1007                 return True\n1008             return False\n1009         ctx['hasdoc'] = hasdoc\n1010 \n1011         ctx['toctree'] = lambda **kwargs: self._get_local_toctree(pagename, **kwargs)\n1012         self.add_sidebars(pagename, ctx)\n1013         ctx.update(addctx)\n1014 \n1015         self.update_page_context(pagename, templatename, ctx, event_arg)\n1016         newtmpl = self.app.emit_firstresult('html-page-context', pagename,\n1017                                             templatename, ctx, event_arg)\n1018         if newtmpl:\n1019             templatename = newtmpl\n1020 \n1021         try:\n1022             output = self.templates.render(templatename, ctx)\n1023         except UnicodeError:\n1024             logger.warning(__(\"a Unicode error occurred when rendering the page %s. \"\n1025                               \"Please make sure all config values that contain \"\n1026                               \"non-ASCII content are Unicode strings.\"), pagename)\n1027             return\n1028         except Exception as exc:\n1029             raise ThemeError(__(\"An error happened in rendering the page %s.\\nReason: %r\") %\n1030                              (pagename, exc)) from exc\n1031 \n1032         if not outfilename:\n1033             outfilename = self.get_outfilename(pagename)\n1034         # outfilename's path is in general different from self.outdir\n1035         ensuredir(path.dirname(outfilename))\n1036         try:\n1037             with open(outfilename, 'w', encoding=ctx['encoding'],\n1038                       errors='xmlcharrefreplace') as f:\n1039                 f.write(output)\n1040         except OSError as err:\n1041             logger.warning(__(\"error writing file %s: %s\"), outfilename, err)\n1042         if self.copysource and ctx.get('sourcename'):\n1043             # copy the source file for the \"show source\" link\n1044             source_name = path.join(self.outdir, '_sources',\n1045                                     os_path(ctx['sourcename']))\n1046             ensuredir(path.dirname(source_name))\n1047             copyfile(self.env.doc2path(pagename), source_name)\n1048 \n1049     def update_page_context(self, pagename: str, templatename: str,\n1050                             ctx: Dict, event_arg: Any) -> None:\n1051         pass\n1052 \n1053     def handle_finish(self) -> None:\n1054         if self.indexer:\n1055             self.finish_tasks.add_task(self.dump_search_index)\n1056         self.finish_tasks.add_task(self.dump_inventory)\n1057 \n1058     @progress_message(__('dumping object inventory'))\n1059     def dump_inventory(self) -> None:\n1060         InventoryFile.dump(path.join(self.outdir, INVENTORY_FILENAME), self.env, self)\n1061 \n1062     def dump_search_index(self) -> None:\n1063         with progress_message(__('dumping search index in %s') % self.indexer.label()):\n1064             self.indexer.prune(self.env.all_docs)\n1065             searchindexfn = path.join(self.outdir, self.searchindex_filename)\n1066             # first write to a temporary file, so that if dumping fails,\n1067             # the existing index won't be overwritten\n1068             if self.indexer_dumps_unicode:\n1069                 with open(searchindexfn + '.tmp', 'w', encoding='utf-8') as ft:\n1070                     self.indexer.dump(ft, self.indexer_format)\n1071             else:\n1072                 with open(searchindexfn + '.tmp', 'wb') as fb:\n1073                     self.indexer.dump(fb, self.indexer_format)\n1074             os.replace(searchindexfn + '.tmp', searchindexfn)\n1075 \n1076 \n1077 def convert_html_css_files(app: Sphinx, config: Config) -> None:\n1078     \"\"\"This converts string styled html_css_files to tuple styled one.\"\"\"\n1079     html_css_files = []  # type: List[Tuple[str, Dict]]\n1080     for entry in config.html_css_files:\n1081         if isinstance(entry, str):\n1082             html_css_files.append((entry, {}))\n1083         else:\n1084             try:\n1085                 filename, attrs = entry\n1086                 html_css_files.append((filename, attrs))\n1087             except Exception:\n1088                 logger.warning(__('invalid css_file: %r, ignored'), entry)\n1089                 continue\n1090 \n1091     config.html_css_files = html_css_files  # type: ignore\n1092 \n1093 \n1094 def convert_html_js_files(app: Sphinx, config: Config) -> None:\n1095     \"\"\"This converts string styled html_js_files to tuple styled one.\"\"\"\n1096     html_js_files = []  # type: List[Tuple[str, Dict]]\n1097     for entry in config.html_js_files:\n1098         if isinstance(entry, str):\n1099             html_js_files.append((entry, {}))\n1100         else:\n1101             try:\n1102                 filename, attrs = entry\n1103                 html_js_files.append((filename, attrs))\n1104             except Exception:\n1105                 logger.warning(__('invalid js_file: %r, ignored'), entry)\n1106                 continue\n1107 \n1108     config.html_js_files = html_js_files  # type: ignore\n1109 \n1110 \n1111 def setup_js_tag_helper(app: Sphinx, pagename: str, templatexname: str,\n1112                         context: Dict, doctree: Node) -> None:\n1113     \"\"\"Set up js_tag() template helper.\n1114 \n1115     .. note:: This set up function is added to keep compatibility with webhelper.\n1116     \"\"\"\n1117     pathto = context.get('pathto')\n1118 \n1119     def js_tag(js: JavaScript) -> str:\n1120         attrs = []\n1121         body = ''\n1122         if isinstance(js, JavaScript):\n1123             for key in sorted(js.attributes):\n1124                 value = js.attributes[key]\n1125                 if value is not None:\n1126                     if key == 'body':\n1127                         body = value\n1128                     else:\n1129                         attrs.append('%s=\"%s\"' % (key, html.escape(value, True)))\n1130             if js.filename:\n1131                 attrs.append('src=\"%s\"' % pathto(js.filename, resource=True))\n1132         else:\n1133             # str value (old styled)\n1134             attrs.append('src=\"%s\"' % pathto(js, resource=True))\n1135         return '<script %s>%s</script>' % (' '.join(attrs), body)\n1136 \n1137     context['js_tag'] = js_tag\n1138 \n1139 \n1140 def validate_math_renderer(app: Sphinx) -> None:\n1141     if app.builder.format != 'html':\n1142         return\n1143 \n1144     name = app.builder.math_renderer_name  # type: ignore\n1145     if name is None:\n1146         raise ConfigError(__('Many math_renderers are registered. '\n1147                              'But no math_renderer is selected.'))\n1148     elif name not in app.registry.html_inline_math_renderers:\n1149         raise ConfigError(__('Unknown math_renderer %r is given.') % name)\n1150 \n1151 \n1152 def validate_html_extra_path(app: Sphinx, config: Config) -> None:\n1153     \"\"\"Check html_extra_paths setting.\"\"\"\n1154     for entry in config.html_extra_path[:]:\n1155         extra_path = path.normpath(path.join(app.confdir, entry))\n1156         if not path.exists(extra_path):\n1157             logger.warning(__('html_extra_path entry %r does not exist'), entry)\n1158             config.html_extra_path.remove(entry)\n1159         elif (path.splitdrive(app.outdir)[0] == path.splitdrive(extra_path)[0] and\n1160               path.commonpath([app.outdir, extra_path]) == app.outdir):\n1161             logger.warning(__('html_extra_path entry %r is placed inside outdir'), entry)\n1162             config.html_extra_path.remove(entry)\n1163 \n1164 \n1165 def validate_html_static_path(app: Sphinx, config: Config) -> None:\n1166     \"\"\"Check html_static_paths setting.\"\"\"\n1167     for entry in config.html_static_path[:]:\n1168         static_path = path.normpath(path.join(app.confdir, entry))\n1169         if not path.exists(static_path):\n1170             logger.warning(__('html_static_path entry %r does not exist'), entry)\n1171             config.html_static_path.remove(entry)\n1172         elif (path.splitdrive(app.outdir)[0] == path.splitdrive(static_path)[0] and\n1173               path.commonpath([app.outdir, static_path]) == app.outdir):\n1174             logger.warning(__('html_static_path entry %r is placed inside outdir'), entry)\n1175             config.html_static_path.remove(entry)\n1176 \n1177 \n1178 def validate_html_logo(app: Sphinx, config: Config) -> None:\n1179     \"\"\"Check html_logo setting.\"\"\"\n1180     if config.html_logo and not path.isfile(path.join(app.confdir, config.html_logo)):\n1181         logger.warning(__('logo file %r does not exist'), config.html_logo)\n1182         config.html_logo = None  # type: ignore\n1183 \n1184 \n1185 def validate_html_favicon(app: Sphinx, config: Config) -> None:\n1186     \"\"\"Check html_favicon setting.\"\"\"\n1187     if config.html_favicon and not path.isfile(path.join(app.confdir, config.html_favicon)):\n1188         logger.warning(__('favicon file %r does not exist'), config.html_favicon)\n1189         config.html_favicon = None  # type: ignore\n1190 \n1191 \n1192 # for compatibility\n1193 import sphinxcontrib.serializinghtml  # NOQA\n1194 \n1195 import sphinx.builders.dirhtml  # NOQA\n1196 import sphinx.builders.singlehtml  # NOQA\n1197 \n1198 \n1199 def setup(app: Sphinx) -> Dict[str, Any]:\n1200     # builders\n1201     app.add_builder(StandaloneHTMLBuilder)\n1202 \n1203     # config values\n1204     app.add_config_value('html_theme', 'alabaster', 'html')\n1205     app.add_config_value('html_theme_path', [], 'html')\n1206     app.add_config_value('html_theme_options', {}, 'html')\n1207     app.add_config_value('html_title',\n1208                          lambda self: _('%s %s documentation') % (self.project, self.release),\n1209                          'html', [str])\n1210     app.add_config_value('html_short_title', lambda self: self.html_title, 'html')\n1211     app.add_config_value('html_style', None, 'html', [str])\n1212     app.add_config_value('html_logo', None, 'html', [str])\n1213     app.add_config_value('html_favicon', None, 'html', [str])\n1214     app.add_config_value('html_css_files', [], 'html')\n1215     app.add_config_value('html_js_files', [], 'html')\n1216     app.add_config_value('html_static_path', [], 'html')\n1217     app.add_config_value('html_extra_path', [], 'html')\n1218     app.add_config_value('html_last_updated_fmt', None, 'html', [str])\n1219     app.add_config_value('html_sidebars', {}, 'html')\n1220     app.add_config_value('html_additional_pages', {}, 'html')\n1221     app.add_config_value('html_domain_indices', True, 'html', [list])\n1222     app.add_config_value('html_add_permalinks', '\u00b6', 'html')\n1223     app.add_config_value('html_use_index', True, 'html')\n1224     app.add_config_value('html_split_index', False, 'html')\n1225     app.add_config_value('html_copy_source', True, 'html')\n1226     app.add_config_value('html_show_sourcelink', True, 'html')\n1227     app.add_config_value('html_sourcelink_suffix', '.txt', 'html')\n1228     app.add_config_value('html_use_opensearch', '', 'html')\n1229     app.add_config_value('html_file_suffix', None, 'html', [str])\n1230     app.add_config_value('html_link_suffix', None, 'html', [str])\n1231     app.add_config_value('html_show_copyright', True, 'html')\n1232     app.add_config_value('html_show_sphinx', True, 'html')\n1233     app.add_config_value('html_context', {}, 'html')\n1234     app.add_config_value('html_output_encoding', 'utf-8', 'html')\n1235     app.add_config_value('html_compact_lists', True, 'html')\n1236     app.add_config_value('html_secnumber_suffix', '. ', 'html')\n1237     app.add_config_value('html_search_language', None, 'html', [str])\n1238     app.add_config_value('html_search_options', {}, 'html')\n1239     app.add_config_value('html_search_scorer', '', None)\n1240     app.add_config_value('html_scaled_image_link', True, 'html')\n1241     app.add_config_value('html_baseurl', '', 'html')\n1242     app.add_config_value('html_codeblock_linenos_style', 'table', 'html',\n1243                          ENUM('table', 'inline'))\n1244     app.add_config_value('html_math_renderer', None, 'env')\n1245     app.add_config_value('html4_writer', False, 'html')\n1246 \n1247     # events\n1248     app.add_event('html-collect-pages')\n1249     app.add_event('html-page-context')\n1250 \n1251     # event handlers\n1252     app.connect('config-inited', convert_html_css_files, priority=800)\n1253     app.connect('config-inited', convert_html_js_files, priority=800)\n1254     app.connect('config-inited', validate_html_extra_path, priority=800)\n1255     app.connect('config-inited', validate_html_static_path, priority=800)\n1256     app.connect('config-inited', validate_html_logo, priority=800)\n1257     app.connect('config-inited', validate_html_favicon, priority=800)\n1258     app.connect('builder-inited', validate_math_renderer)\n1259     app.connect('html-page-context', setup_js_tag_helper)\n1260 \n1261     # load default math renderer\n1262     app.setup_extension('sphinx.ext.mathjax')\n1263 \n1264     # load transforms for HTML builder\n1265     app.setup_extension('sphinx.builders.html.transforms')\n1266 \n1267     return {\n1268         'version': 'builtin',\n1269         'parallel_read_safe': True,\n1270         'parallel_write_safe': True,\n1271     }\n",
        "intended_behavior": "Since this file is part of the HTML builder in Sphinx, it is responsible for converting reStructuredText into HTML. The intended behavior would be to ensure during the HTML generation process that compound keystrokes within the `:kbd:` role are rendered with a parent `<kbd>` element that includes a specific CSS class. This modification should preserve the current functionality for all other elements and roles, ensuring that only the `:kbd:` role handling is augmented to support differentiated styling."
    }
]