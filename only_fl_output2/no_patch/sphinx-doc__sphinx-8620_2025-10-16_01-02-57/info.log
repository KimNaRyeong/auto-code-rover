2025-10-16 01:02:57.962 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-16 01:03:01.266 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=605, output_tokens=12, cost=0.006410
2025-10-16 01:03:12.837 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=785, output_tokens=470, cost=0.021950
2025-10-16 01:03:13.871 | INFO     | registered non reproducing test 0
2025-10-16 01:03:31.954 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1673, output_tokens=696, cost=0.037610
2025-10-16 01:03:32.925 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-16 01:03:44.128 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=901, output_tokens=391, cost=0.020740
2025-10-16 01:03:44.136 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-16 01:03:46.783 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=745, output_tokens=48, cost=0.008890
2025-10-16 01:03:46.784 | DEBUG    | Extracted a valid json.
2025-10-16 01:03:46.784 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_method(\"kbd\")",
        "search_class(\"Role\")",
        "search_class(\"Directive\")",
        "search_class(\"Extension\")"
    ],
    "bug_locations": []
}
2025-10-16 01:03:46.788 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-16 01:03:46.788 | DEBUG    | <Agent search> Analyzing search results.
2025-10-16 01:03:58.158 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1536, output_tokens=495, cost=0.030210
2025-10-16 01:03:58.163 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-16 01:03:59.953 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2247, output_tokens=40, cost=0.023670
2025-10-16 01:03:59.955 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-16 01:04:02.322 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=394, output_tokens=50, cost=0.005440
2025-10-16 01:04:02.323 | DEBUG    | Extracted a valid json.
2025-10-16 01:04:02.323 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_code(\"role\")",
        "search_code(\"directive\")",
        "search_code(\"HTML builder\")",
        "search_code(\"visit_node\")"
    ],
    "bug_locations": []
}
2025-10-16 01:04:02.985 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-16 01:04:02.986 | DEBUG    | <Agent search> Analyzing search results.
2025-10-16 01:04:17.072 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=4073, output_tokens=563, cost=0.057620
2025-10-16 01:04:17.078 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-16 01:04:28.085 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=4852, output_tokens=350, cost=0.059020
2025-10-16 01:04:28.089 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-16 01:04:36.266 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=704, output_tokens=260, cost=0.014840
2025-10-16 01:04:36.266 | DEBUG    | Extracted a valid json.
2025-10-16 01:04:36.267 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "sphinx/roles.py",
            "class": "",
            "method": "",
            "intended_behavior": "This file likely contains definitions or mechanisms for parsing and handling roles, including the `:kbd:` role. The intended behavior here would be to adjust or extend the handling of the `:kbd:` role to include a mechanism for detecting compound keystrokes and applying a distinct CSS class (e.g., `compound`) to the parent `<kbd>` element in such cases while preserving the styling and functionality for single keystrokes."
        },
        {
            "file": "sphinx/builders/html/__init__.py",
            "class": "",
            "method": "",
            "intended_behavior": "Since this file is part of the HTML builder in Sphinx, it is responsible for converting reStructuredText into HTML. The intended behavior would be to ensure during the HTML generation process that compound keystrokes within the `:kbd:` role are rendered with a parent `<kbd>` element that includes a specific CSS class. This modification should preserve the current functionality for all other elements and roles, ensuring that only the `:kbd:` role handling is augmented to support differentiated styling."
        }
    ]
}
2025-10-16 01:04:36.271 | DEBUG    | Bug location extracted successfully: [<file>sphinx/roles.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2     sphinx.roles
3     ~~~~~~~~~~~~
4 
5     Handlers for additional ReST roles.
6 
7     :copyright: Copyright 2007-2020 by the Sphinx team, see AUTHORS.
8     :license: BSD, see LICENSE for details.
9 """
10 
11 import re
12 import warnings
13 from typing import Any, Dict, List, Tuple
14 
15 from docutils import nodes, utils
16 from docutils.nodes import Element, Node, TextElement, system_message
17 from docutils.parsers.rst.states import Inliner
18 
19 from sphinx import addnodes
20 from sphinx.deprecation import RemovedInSphinx40Warning
21 from sphinx.locale import _
22 from sphinx.util import ws_re
23 from sphinx.util.docutils import ReferenceRole, SphinxRole
24 from sphinx.util.nodes import process_index_entry, set_role_source_info, split_explicit_title
25 from sphinx.util.typing import RoleFunction
26 
27 if False:
28     # For type annotation
29     from typing import Type  # for python3.5.1
30 
31     from sphinx.application import Sphinx
32     from sphinx.environment import BuildEnvironment
33 
34 
35 generic_docroles = {
36     'command': addnodes.literal_strong,
37     'dfn': nodes.emphasis,
38     'kbd': nodes.literal,
39     'mailheader': addnodes.literal_emphasis,
40     'makevar': addnodes.literal_strong,
41     'manpage': addnodes.manpage,
42     'mimetype': addnodes.literal_emphasis,
43     'newsgroup': addnodes.literal_emphasis,
44     'program': addnodes.literal_strong,  # XXX should be an x-ref
45     'regexp': nodes.literal,
46 }
47 
48 
49 # -- generic cross-reference role ----------------------------------------------
50 
51 class XRefRole(ReferenceRole):
52     """
53     A generic cross-referencing role.  To create a callable that can be used as
54     a role function, create an instance of this class.
55 
56     The general features of this role are:
57 
58     * Automatic creation of a reference and a content node.
59     * Optional separation of title and target with `title <target>`.
60     * The implementation is a class rather than a function to make
61       customization easier.
62 
63     Customization can be done in two ways:
64 
65     * Supplying constructor parameters:
66       * `fix_parens` to normalize parentheses (strip from target, and add to
67         title if configured)
68       * `lowercase` to lowercase the target
69       * `nodeclass` and `innernodeclass` select the node classes for
70         the reference and the content node
71 
72     * Subclassing and overwriting `process_link()` and/or `result_nodes()`.
73     """
74 
75     nodeclass = addnodes.pending_xref   # type: Type[Element]
76     innernodeclass = nodes.literal      # type: Type[TextElement]
77 
78     def __init__(self, fix_parens: bool = False, lowercase: bool = False,
79                  nodeclass: "Type[Element]" = None, innernodeclass: "Type[TextElement]" = None,
80                  warn_dangling: bool = False) -> None:
81         self.fix_parens = fix_parens
82         self.lowercase = lowercase
83         self.warn_dangling = warn_dangling
84         if nodeclass is not None:
85             self.nodeclass = nodeclass
86         if innernodeclass is not None:
87             self.innernodeclass = innernodeclass
88 
89         super().__init__()
90 
91     def _fix_parens(self, env: "BuildEnvironment", has_explicit_title: bool, title: str,
92                     target: str) -> Tuple[str, str]:
93         warnings.warn('XRefRole._fix_parens() is deprecated.',
94                       RemovedInSphinx40Warning, stacklevel=2)
95         if not has_explicit_title:
96             if title.endswith('()'):
97                 # remove parentheses
98                 title = title[:-2]
99             if env.config.add_function_parentheses:
100                 # add them back to all occurrences if configured
101                 title += '()'
102         # remove parentheses from the target too
103         if target.endswith('()'):
104             target = target[:-2]
105         return title, target
106 
107     def update_title_and_target(self, title: str, target: str) -> Tuple[str, str]:
108         if not self.has_explicit_title:
109             if title.endswith('()'):
110                 # remove parentheses
111                 title = title[:-2]
112             if self.config.add_function_parentheses:
113                 # add them back to all occurrences if configured
114                 title += '()'
115         # remove parentheses from the target too
116         if target.endswith('()'):
117             target = target[:-2]
118         return title, target
119 
120     def run(self) -> Tuple[List[Node], List[system_message]]:
121         if ':' not in self.name:
122             self.refdomain, self.reftype = '', self.name
123             self.classes = ['xref', self.reftype]
124         else:
125             self.refdomain, self.reftype = self.name.split(':', 1)
126             self.classes = ['xref', self.refdomain, '%s-%s' % (self.refdomain, self.reftype)]
127 
128         if self.disabled:
129             return self.create_non_xref_node()
130         else:
131             return self.create_xref_node()
132 
133     def create_non_xref_node(self) -> Tuple[List[Node], List[system_message]]:
134         text = utils.unescape(self.text[1:])
135         if self.fix_parens:
136             self.has_explicit_title = False  # treat as implicit
137             text, target = self.update_title_and_target(text, "")
138 
139         node = self.innernodeclass(self.rawtext, text, classes=self.classes)
140         return self.result_nodes(self.inliner.document, self.env, node, is_ref=False)
141 
142     def create_xref_node(self) -> Tuple[List[Node], List[system_message]]:
143         target = self.target
144         title = self.title
145         if self.lowercase:
146             target = target.lower()
147         if self.fix_parens:
148             title, target = self.update_title_and_target(title, target)
149 
150         # create the reference node
151         options = {'refdoc': self.env.docname,
152                    'refdomain': self.refdomain,
153                    'reftype': self.reftype,
154                    'refexplicit': self.has_explicit_title,
155                    'refwarn': self.warn_dangling}
156         refnode = self.nodeclass(self.rawtext, **options)
157         self.set_source_info(refnode)
158 
159         # determine the target and title for the class
160         title, target = self.process_link(self.env, refnode, self.has_explicit_title,
161                                           title, target)
162         refnode['reftarget'] = target
163         refnode += self.innernodeclass(self.rawtext, title, classes=self.classes)
164 
165         return self.result_nodes(self.inliner.document, self.env, refnode, is_ref=True)
166 
167     # methods that can be overwritten
168 
169     def process_link(self, env: "BuildEnvironment", refnode: Element, has_explicit_title: bool,
170                      title: str, target: str) -> Tuple[str, str]:
171         """Called after parsing title and target text, and creating the
172         reference node (given in *refnode*).  This method can alter the
173         reference node and must return a new (or the same) ``(title, target)``
174         tuple.
175         """
176         return title, ws_re.sub(' ', target)
177 
178     def result_nodes(self, document: nodes.document, env: "BuildEnvironment", node: Element,
179                      is_ref: bool) -> Tuple[List[Node], List[system_message]]:
180         """Called before returning the finished nodes.  *node* is the reference
181         node if one was created (*is_ref* is then true), else the content node.
182         This method can add other nodes and must return a ``(nodes, messages)``
183         tuple (the usual return value of a role function).
184         """
185         return [node], []
186 
187 
188 class AnyXRefRole(XRefRole):
189     def process_link(self, env: "BuildEnvironment", refnode: Element, has_explicit_title: bool,
190                      title: str, target: str) -> Tuple[str, str]:
191         result = super().process_link(env, refnode, has_explicit_title, title, target)
192         # add all possible context info (i.e. std:program, py:module etc.)
193         refnode.attributes.update(env.ref_context)
194         return result
195 
196 
197 def indexmarkup_role(typ: str, rawtext: str, text: str, lineno: int, inliner: Inliner,
198                      options: Dict = {}, content: List[str] = []
199                      ) -> Tuple[List[Node], List[system_message]]:
200     """Role for PEP/RFC references that generate an index entry."""
201     warnings.warn('indexmarkup_role() is deprecated.  Please use PEP or RFC class instead.',
202                   RemovedInSphinx40Warning, stacklevel=2)
203     env = inliner.document.settings.env
204     if not typ:
205         assert env.temp_data['default_role']
206         typ = env.temp_data['default_role'].lower()
207     else:
208         typ = typ.lower()
209 
210     has_explicit_title, title, target = split_explicit_title(text)
211     title = utils.unescape(title)
212     target = utils.unescape(target)
213     targetid = 'index-%s' % env.new_serialno('index')
214     indexnode = addnodes.index()
215     targetnode = nodes.target('', '', ids=[targetid])
216     inliner.document.note_explicit_target(targetnode)
217     if typ == 'pep':
218         indexnode['entries'] = [
219             ('single', _('Python Enhancement Proposals; PEP %s') % target,
220              targetid, '', None)]
221         anchor = ''
222         anchorindex = target.find('#')
223         if anchorindex > 0:
224             target, anchor = target[:anchorindex], target[anchorindex:]
225         if not has_explicit_title:
226             title = "PEP " + utils.unescape(title)
227         try:
228             pepnum = int(target)
229         except ValueError:
230             msg = inliner.reporter.error('invalid PEP number %s' % target,
231                                          line=lineno)
232             prb = inliner.problematic(rawtext, rawtext, msg)
233             return [prb], [msg]
234         ref = inliner.document.settings.pep_base_url + 'pep-%04d' % pepnum
235         sn = nodes.strong(title, title)
236         rn = nodes.reference('', '', internal=False, refuri=ref + anchor,
237                              classes=[typ])
238         rn += sn
239         return [indexnode, targetnode, rn], []
240     elif typ == 'rfc':
241         indexnode['entries'] = [
242             ('single', 'RFC; RFC %s' % target, targetid, '', None)]
243         anchor = ''
244         anchorindex = target.find('#')
245         if anchorindex > 0:
246             target, anchor = target[:anchorindex], target[anchorindex:]
247         if not has_explicit_title:
248             title = "RFC " + utils.unescape(title)
249         try:
250             rfcnum = int(target)
251         except ValueError:
252             msg = inliner.reporter.error('invalid RFC number %s' % target,
253                                          line=lineno)
254             prb = inliner.problematic(rawtext, rawtext, msg)
255             return [prb], [msg]
256         ref = inliner.document.settings.rfc_base_url + inliner.rfc_url % rfcnum
257         sn = nodes.strong(title, title)
258         rn = nodes.reference('', '', internal=False, refuri=ref + anchor,
259                              classes=[typ])
260         rn += sn
261         return [indexnode, targetnode, rn], []
262     else:
263         raise ValueError('unknown role type: %s' % typ)
264 
265 
266 class PEP(ReferenceRole):
267     def run(self) -> Tuple[List[Node], List[system_message]]:
268         target_id = 'index-%s' % self.env.new_serialno('index')
269         entries = [('single', _('Python Enhancement Proposals; PEP %s') % self.target,
270                     target_id, '', None)]
271 
272         index = addnodes.index(entries=entries)
273         target = nodes.target('', '', ids=[target_id])
274         self.inliner.document.note_explicit_target(target)
275 
276         try:
277             refuri = self.build_uri()
278             reference = nodes.reference('', '', internal=False, refuri=refuri, classes=['pep'])
279             if self.has_explicit_title:
280                 reference += nodes.strong(self.title, self.title)
281             else:
282                 title = "PEP " + self.title
283                 reference += nodes.strong(title, title)
284         except ValueError:
285             msg = self.inliner.reporter.error('invalid PEP number %s' % self.target,
286                                               line=self.lineno)
287             prb = self.inliner.problematic(self.rawtext, self.rawtext, msg)
288             return [prb], [msg]
289 
290         return [index, target, reference], []
291 
292     def build_uri(self) -> str:
293         base_url = self.inliner.document.settings.pep_base_url
294         ret = self.target.split('#', 1)
295         if len(ret) == 2:
296             return base_url + 'pep-%04d#%s' % (int(ret[0]), ret[1])
297         else:
298             return base_url + 'pep-%04d' % int(ret[0])
299 
300 
301 class RFC(ReferenceRole):
302     def run(self) -> Tuple[List[Node], List[system_message]]:
303         target_id = 'index-%s' % self.env.new_serialno('index')
304         entries = [('single', 'RFC; RFC %s' % self.target, target_id, '', None)]
305 
306         index = addnodes.index(entries=entries)
307         target = nodes.target('', '', ids=[target_id])
308         self.inliner.document.note_explicit_target(target)
309 
310         try:
311             refuri = self.build_uri()
312             reference = nodes.reference('', '', internal=False, refuri=refuri, classes=['rfc'])
313             if self.has_explicit_title:
314                 reference += nodes.strong(self.title, self.title)
315             else:
316                 title = "RFC " + self.title
317                 reference += nodes.strong(title, title)
318         except ValueError:
319             msg = self.inliner.reporter.error('invalid RFC number %s' % self.target,
320                                               line=self.lineno)
321             prb = self.inliner.problematic(self.rawtext, self.rawtext, msg)
322             return [prb], [msg]
323 
324         return [index, target, reference], []
325 
326     def build_uri(self) -> str:
327         base_url = self.inliner.document.settings.rfc_base_url
328         ret = self.target.split('#', 1)
329         if len(ret) == 2:
330             return base_url + self.inliner.rfc_url % int(ret[0]) + '#' + ret[1]
331         else:
332             return base_url + self.inliner.rfc_url % int(ret[0])
333 
334 
335 _amp_re = re.compile(r'(?<!&)&(?![&\s])')
336 
337 
338 def menusel_role(typ: str, rawtext: str, text: str, lineno: int, inliner: Inliner,
339                  options: Dict = {}, content: List[str] = []
340                  ) -> Tuple[List[Node], List[system_message]]:
341     warnings.warn('menusel_role() is deprecated. '
342                   'Please use MenuSelection or GUILabel class instead.',
343                   RemovedInSphinx40Warning, stacklevel=2)
344     env = inliner.document.settings.env
345     if not typ:
346         assert env.temp_data['default_role']
347         typ = env.temp_data['default_role'].lower()
348     else:
349         typ = typ.lower()
350 
351     text = utils.unescape(text)
352     if typ == 'menuselection':
353         text = text.replace('-->', '\N{TRIANGULAR BULLET}')
354     spans = _amp_re.split(text)
355 
356     node = nodes.inline(rawtext=rawtext)
357     for i, span in enumerate(spans):
358         span = span.replace('&&', '&')
359         if i == 0:
360             if len(span) > 0:
361                 textnode = nodes.Text(span)
362                 node += textnode
363             continue
364         accel_node = nodes.inline()
365         letter_node = nodes.Text(span[0])
366         accel_node += letter_node
367         accel_node['classes'].append('accelerator')
368         node += accel_node
369         textnode = nodes.Text(span[1:])
370         node += textnode
371 
372     node['classes'].append(typ)
373     return [node], []
374 
375 
376 class GUILabel(SphinxRole):
377     amp_re = re.compile(r'(?<!&)&(?![&\s])')
378 
379     def run(self) -> Tuple[List[Node], List[system_message]]:
380         node = nodes.inline(rawtext=self.rawtext, classes=[self.name])
381         spans = self.amp_re.split(self.text)
382         node += nodes.Text(spans.pop(0))
383         for span in spans:
384             span = span.replace('&&', '&')
385 
386             letter = nodes.Text(span[0])
387             accelerator = nodes.inline('', '', letter, classes=['accelerator'])
388             node += accelerator
389             node += nodes.Text(span[1:])
390 
391         return [node], []
392 
393 
394 class MenuSelection(GUILabel):
395     BULLET_CHARACTER = '\N{TRIANGULAR BULLET}'
396 
397     def run(self) -> Tuple[List[Node], List[system_message]]:
398         self.text = self.text.replace('-->', self.BULLET_CHARACTER)
399         return super().run()
400 
401 
402 _litvar_re = re.compile('{([^}]+)}')
403 parens_re = re.compile(r'(\\*{|\\*})')
404 
405 
406 def emph_literal_role(typ: str, rawtext: str, text: str, lineno: int, inliner: Inliner,
407                       options: Dict = {}, content: List[str] = []
408                       ) -> Tuple[List[Node], List[system_message]]:
409     warnings.warn('emph_literal_role() is deprecated. '
410                   'Please use EmphasizedLiteral class instead.',
411                   RemovedInSphinx40Warning, stacklevel=2)
412     env = inliner.document.settings.env
413     if not typ:
414         assert env.temp_data['default_role']
415         typ = env.temp_data['default_role'].lower()
416     else:
417         typ = typ.lower()
418 
419     retnode = nodes.literal(role=typ.lower(), classes=[typ])
420     parts = list(parens_re.split(utils.unescape(text)))
421     stack = ['']
422     for part in parts:
423         matched = parens_re.match(part)
424         if matched:
425             backslashes = len(part) - 1
426             if backslashes % 2 == 1:    # escaped
427                 stack[-1] += "\\" * int((backslashes - 1) / 2) + part[-1]
428             elif part[-1] == '{':       # rparen
429                 stack[-1] += "\\" * int(backslashes / 2)
430                 if len(stack) >= 2 and stack[-2] == "{":
431                     # nested
432                     stack[-1] += "{"
433                 else:
434                     # start emphasis
435                     stack.append('{')
436                     stack.append('')
437             else:                       # lparen
438                 stack[-1] += "\\" * int(backslashes / 2)
439                 if len(stack) == 3 and stack[1] == "{" and len(stack[2]) > 0:
440                     # emphasized word found
441                     if stack[0]:
442                         retnode += nodes.Text(stack[0], stack[0])
443                     retnode += nodes.emphasis(stack[2], stack[2])
444                     stack = ['']
445                 else:
446                     # emphasized word not found; the rparen is not a special symbol
447                     stack.append('}')
448                     stack = [''.join(stack)]
449         else:
450             stack[-1] += part
451     if ''.join(stack):
452         # remaining is treated as Text
453         text = ''.join(stack)
454         retnode += nodes.Text(text, text)
455 
456     return [retnode], []
457 
458 
459 class EmphasizedLiteral(SphinxRole):
460     parens_re = re.compile(r'(\\\\|\\{|\\}|{|})')
461 
462     def run(self) -> Tuple[List[Node], List[system_message]]:
463         children = self.parse(self.text)
464         node = nodes.literal(self.rawtext, '', *children,
465                              role=self.name.lower(), classes=[self.name])
466 
467         return [node], []
468 
469     def parse(self, text: str) -> List[Node]:
470         result = []  # type: List[Node]
471 
472         stack = ['']
473         for part in self.parens_re.split(text):
474             if part == '\\\\':  # escaped backslash
475                 stack[-1] += '\\'
476             elif part == '{':
477                 if len(stack) >= 2 and stack[-2] == "{":  # nested
478                     stack[-1] += "{"
479                 else:
480                     # start emphasis
481                     stack.append('{')
482                     stack.append('')
483             elif part == '}':
484                 if len(stack) == 3 and stack[1] == "{" and len(stack[2]) > 0:
485                     # emphasized word found
486                     if stack[0]:
487                         result.append(nodes.Text(stack[0], stack[0]))
488                     result.append(nodes.emphasis(stack[2], stack[2]))
489                     stack = ['']
490                 else:
491                     # emphasized word not found; the rparen is not a special symbol
492                     stack.append('}')
493                     stack = [''.join(stack)]
494             elif part == '\\{':  # escaped left-brace
495                 stack[-1] += '{'
496             elif part == '\\}':  # escaped right-brace
497                 stack[-1] += '}'
498             else:  # others (containing escaped braces)
499                 stack[-1] += part
500 
501         if ''.join(stack):
502             # remaining is treated as Text
503             text = ''.join(stack)
504             result.append(nodes.Text(text, text))
505 
506         return result
507 
508 
509 _abbr_re = re.compile(r'\((.*)\)$', re.S)
510 
511 
512 def abbr_role(typ: str, rawtext: str, text: str, lineno: int, inliner: Inliner,
513               options: Dict = {}, content: List[str] = []
514               ) -> Tuple[List[Node], List[system_message]]:
515     warnings.warn('abbr_role() is deprecated.  Please use Abbrevation class instead.',
516                   RemovedInSphinx40Warning, stacklevel=2)
517     text = utils.unescape(text)
518     m = _abbr_re.search(text)
519     if m is None:
520         return [nodes.abbreviation(text, text, **options)], []
521     abbr = text[:m.start()].strip()
522     expl = m.group(1)
523     options = options.copy()
524     options['explanation'] = expl
525     return [nodes.abbreviation(abbr, abbr, **options)], []
526 
527 
528 class Abbreviation(SphinxRole):
529     abbr_re = re.compile(r'\((.*)\)$', re.S)
530 
531     def run(self) -> Tuple[List[Node], List[system_message]]:
532         options = self.options.copy()
533         matched = self.abbr_re.search(self.text)
534         if matched:
535             text = self.text[:matched.start()].strip()
536             options['explanation'] = matched.group(1)
537         else:
538             text = self.text
539 
540         return [nodes.abbreviation(self.rawtext, text, **options)], []
541 
542 
543 def index_role(typ: str, rawtext: str, text: str, lineno: int, inliner: Inliner,
544                options: Dict = {}, content: List[str] = []
545                ) -> Tuple[List[Node], List[system_message]]:
546     warnings.warn('index_role() is deprecated.  Please use Index class instead.',
547                   RemovedInSphinx40Warning, stacklevel=2)
548     # create new reference target
549     env = inliner.document.settings.env
550     targetid = 'index-%s' % env.new_serialno('index')
551     targetnode = nodes.target('', '', ids=[targetid])
552     # split text and target in role content
553     has_explicit_title, title, target = split_explicit_title(text)
554     title = utils.unescape(title)
555     target = utils.unescape(target)
556     # if an explicit target is given, we can process it as a full entry
557     if has_explicit_title:
558         entries = process_index_entry(target, targetid)
559     # otherwise we just create a "single" entry
560     else:
561         # but allow giving main entry
562         main = ''
563         if target.startswith('!'):
564             target = target[1:]
565             title = title[1:]
566             main = 'main'
567         entries = [('single', target, targetid, main, None)]
568     indexnode = addnodes.index()
569     indexnode['entries'] = entries
570     set_role_source_info(inliner, lineno, indexnode)
571     textnode = nodes.Text(title, title)
572     return [indexnode, targetnode, textnode], []
573 
574 
575 class Index(ReferenceRole):
576     def run(self) -> Tuple[List[Node], List[system_message]]:
577         warnings.warn('Index role is deprecated.', RemovedInSphinx40Warning, stacklevel=2)
578         target_id = 'index-%s' % self.env.new_serialno('index')
579         if self.has_explicit_title:
580             # if an explicit target is given, process it as a full entry
581             title = self.title
582             entries = process_index_entry(self.target, target_id)
583         else:
584             # otherwise we just create a single entry
585             if self.target.startswith('!'):
586                 title = self.title[1:]
587                 entries = [('single', self.target[1:], target_id, 'main', None)]
588             else:
589                 title = self.title
590                 entries = [('single', self.target, target_id, '', None)]
591 
592         index = addnodes.index(entries=entries)
593         target = nodes.target('', '', ids=[target_id])
594         text = nodes.Text(title, title)
595         self.set_source_info(index)
596         return [index, target, text], []
597 
598 
599 specific_docroles = {
600     # links to download references
601     'download': XRefRole(nodeclass=addnodes.download_reference),
602     # links to anything
603     'any': AnyXRefRole(warn_dangling=True),
604 
605     'pep': PEP(),
606     'rfc': RFC(),
607     'guilabel': GUILabel(),
608     'menuselection': MenuSelection(),
609     'file': EmphasizedLiteral(),
610     'samp': EmphasizedLiteral(),
611     'abbr': Abbreviation(),
612 }  # type: Dict[str, RoleFunction]
613 
614 
615 def setup(app: "Sphinx") -> Dict[str, Any]:
616     from docutils.parsers.rst import roles
617 
618     for rolename, nodeclass in generic_docroles.items():
619         generic = roles.GenericRole(rolename, nodeclass)
620         role = roles.CustomRole(rolename, generic, {'classes': [rolename]})
621         roles.register_local_role(rolename, role)
622 
623     for rolename, func in specific_docroles.items():
624         roles.register_local_role(rolename, func)
625 
626     return {
627         'version': 'builtin',
628         'parallel_read_safe': True,
629         'parallel_write_safe': True,
630     }

</code><intended_behavior>This file likely contains definitions or mechanisms for parsing and handling roles, including the `:kbd:` role. The intended behavior here would be to adjust or extend the handling of the `:kbd:` role to include a mechanism for detecting compound keystrokes and applying a distinct CSS class (e.g., `compound`) to the parent `<kbd>` element in such cases while preserving the styling and functionality for single keystrokes.</intended_behavior>, <file>sphinx/builders/html/__init__.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2     sphinx.builders.html
3     ~~~~~~~~~~~~~~~~~~~~
4 
5     Several HTML builders.
6 
7     :copyright: Copyright 2007-2020 by the Sphinx team, see AUTHORS.
8     :license: BSD, see LICENSE for details.
9 """
10 
11 import html
12 import os
13 import posixpath
14 import re
15 import sys
16 import warnings
17 from os import path
18 from typing import IO, Any, Dict, Iterable, Iterator, List, Set, Tuple
19 from urllib.parse import quote
20 
21 from docutils import nodes
22 from docutils.core import publish_parts
23 from docutils.frontend import OptionParser
24 from docutils.io import DocTreeInput, StringOutput
25 from docutils.nodes import Node
26 from docutils.utils import relative_path
27 
28 from sphinx import __display_version__, package_dir
29 from sphinx.application import Sphinx
30 from sphinx.builders import Builder
31 from sphinx.config import ENUM, Config
32 from sphinx.deprecation import RemovedInSphinx40Warning
33 from sphinx.domains import Domain, Index, IndexEntry
34 from sphinx.environment.adapters.asset import ImageAdapter
35 from sphinx.environment.adapters.indexentries import IndexEntries
36 from sphinx.environment.adapters.toctree import TocTree
37 from sphinx.errors import ConfigError, ThemeError
38 from sphinx.highlighting import PygmentsBridge
39 from sphinx.locale import _, __
40 from sphinx.search import js_index
41 from sphinx.theming import HTMLThemeFactory
42 from sphinx.util import logging, md5, progress_message, status_iterator
43 from sphinx.util.docutils import is_html5_writer_available, new_document
44 from sphinx.util.fileutil import copy_asset
45 from sphinx.util.i18n import format_date
46 from sphinx.util.inventory import InventoryFile
47 from sphinx.util.matching import DOTFILES, Matcher, patmatch
48 from sphinx.util.osutil import copyfile, ensuredir, os_path, relative_uri
49 from sphinx.util.tags import Tags
50 from sphinx.writers.html import HTMLTranslator, HTMLWriter
51 
52 if False:
53     # For type annotation
54     from typing import Type  # for python3.5.1
55 
56 
57 # HTML5 Writer is available or not
58 if is_html5_writer_available():
59     from sphinx.writers.html5 import HTML5Translator
60     html5_ready = True
61 else:
62     html5_ready = False
63 
64 #: the filename for the inventory of objects
65 INVENTORY_FILENAME = 'objects.inv'
66 
67 logger = logging.getLogger(__name__)
68 return_codes_re = re.compile('[\r\n]+')
69 
70 
71 def get_stable_hash(obj: Any) -> str:
72     """
73     Return a stable hash for a Python data structure.  We can't just use
74     the md5 of str(obj) since for example dictionary items are enumerated
75     in unpredictable order due to hash randomization in newer Pythons.
76     """
77     if isinstance(obj, dict):
78         return get_stable_hash(list(obj.items()))
79     elif isinstance(obj, (list, tuple)):
80         obj = sorted(get_stable_hash(o) for o in obj)
81     return md5(str(obj).encode()).hexdigest()
82 
83 
84 class Stylesheet(str):
85     """A metadata of stylesheet.
86 
87     To keep compatibility with old themes, an instance of stylesheet behaves as
88     its filename (str).
89     """
90 
91     attributes = None   # type: Dict[str, str]
92     filename = None     # type: str
93 
94     def __new__(cls, filename: str, *args: str, **attributes: str) -> "Stylesheet":
95         self = str.__new__(cls, filename)  # type: ignore
96         self.filename = filename
97         self.attributes = attributes
98         self.attributes.setdefault('rel', 'stylesheet')
99         self.attributes.setdefault('type', 'text/css')
100         if args:  # old style arguments (rel, title)
101             self.attributes['rel'] = args[0]
102             self.attributes['title'] = args[1]
103 
104         return self
105 
106 
107 class JavaScript(str):
108     """A metadata of javascript file.
109 
110     To keep compatibility with old themes, an instance of javascript behaves as
111     its filename (str).
112     """
113 
114     attributes = None   # type: Dict[str, str]
115     filename = None     # type: str
116 
117     def __new__(cls, filename: str, **attributes: str) -> "JavaScript":
118         self = str.__new__(cls, filename)  # type: ignore
119         self.filename = filename
120         self.attributes = attributes
121 
122         return self
123 
124 
125 class BuildInfo:
126     """buildinfo file manipulator.
127 
128     HTMLBuilder and its family are storing their own envdata to ``.buildinfo``.
129     This class is a manipulator for the file.
130     """
131 
132     @classmethod
133     def load(cls, f: IO) -> "BuildInfo":
134         try:
135             lines = f.readlines()
136             assert lines[0].rstrip() == '# Sphinx build info version 1'
137             assert lines[2].startswith('config: ')
138             assert lines[3].startswith('tags: ')
139 
140             build_info = BuildInfo()
141             build_info.config_hash = lines[2].split()[1].strip()
142             build_info.tags_hash = lines[3].split()[1].strip()
143             return build_info
144         except Exception as exc:
145             raise ValueError(__('build info file is broken: %r') % exc) from exc
146 
147     def __init__(self, config: Config = None, tags: Tags = None, config_categories: List[str] = []) -> None:  # NOQA
148         self.config_hash = ''
149         self.tags_hash = ''
150 
151         if config:
152             values = {c.name: c.value for c in config.filter(config_categories)}
153             self.config_hash = get_stable_hash(values)
154 
155         if tags:
156             self.tags_hash = get_stable_hash(sorted(tags))
157 
158     def __eq__(self, other: "BuildInfo") -> bool:  # type: ignore
159         return (self.config_hash == other.config_hash and
160                 self.tags_hash == other.tags_hash)
161 
162     def dump(self, f: IO) -> None:
163         f.write('# Sphinx build info version 1\n'
164                 '# This file hashes the configuration used when building these files.'
165                 ' When it is not found, a full rebuild will be done.\n'
166                 'config: %s\n'
167                 'tags: %s\n' %
168                 (self.config_hash, self.tags_hash))
169 
170 
171 class StandaloneHTMLBuilder(Builder):
172     """
173     Builds standalone HTML docs.
174     """
175     name = 'html'
176     format = 'html'
177     epilog = __('The HTML pages are in %(outdir)s.')
178 
179     copysource = True
180     allow_parallel = True
181     out_suffix = '.html'
182     link_suffix = '.html'  # defaults to matching out_suffix
183     indexer_format = js_index  # type: Any
184     indexer_dumps_unicode = True
185     # create links to original images from images [True/False]
186     html_scaled_image_link = True
187     supported_image_types = ['image/svg+xml', 'image/png',
188                              'image/gif', 'image/jpeg']
189     supported_remote_images = True
190     supported_data_uri_images = True
191     searchindex_filename = 'searchindex.js'
192     add_permalinks = True
193     allow_sharp_as_current_path = True
194     embedded = False  # for things like HTML help or Qt help: suppresses sidebar
195     search = True  # for things like HTML help and Apple help: suppress search
196     use_index = False
197     download_support = True  # enable download role
198 
199     imgpath = None          # type: str
200     domain_indices = []     # type: List[Tuple[str, Type[Index], List[Tuple[str, List[IndexEntry]]], bool]]  # NOQA
201 
202     def __init__(self, app: Sphinx) -> None:
203         super().__init__(app)
204 
205         # CSS files
206         self.css_files = []  # type: List[Dict[str, str]]
207 
208         # JS files
209         self.script_files = []  # type: List[JavaScript]
210 
211     def init(self) -> None:
212         self.build_info = self.create_build_info()
213         # basename of images directory
214         self.imagedir = '_images'
215         # section numbers for headings in the currently visited document
216         self.secnumbers = {}  # type: Dict[str, Tuple[int, ...]]
217         # currently written docname
218         self.current_docname = None  # type: str
219 
220         self.init_templates()
221         self.init_highlighter()
222         self.init_css_files()
223         self.init_js_files()
224 
225         html_file_suffix = self.get_builder_config('file_suffix', 'html')
226         if html_file_suffix is not None:
227             self.out_suffix = html_file_suffix
228 
229         html_link_suffix = self.get_builder_config('link_suffix', 'html')
230         if html_link_suffix is not None:
231             self.link_suffix = html_link_suffix
232         else:
233             self.link_suffix = self.out_suffix
234 
235         self.use_index = self.get_builder_config('use_index', 'html')
236 
237     def create_build_info(self) -> BuildInfo:
238         return BuildInfo(self.config, self.tags, ['html'])
239 
240     def _get_translations_js(self) -> str:
241         candidates = [path.join(dir, self.config.language,
242                                 'LC_MESSAGES', 'sphinx.js')
243                       for dir in self.config.locale_dirs] + \
244                      [path.join(package_dir, 'locale', self.config.language,
245                                 'LC_MESSAGES', 'sphinx.js'),
246                       path.join(sys.prefix, 'share/sphinx/locale',
247                                 self.config.language, 'sphinx.js')]
248 
249         for jsfile in candidates:
250             if path.isfile(jsfile):
251                 return jsfile
252         return None
253 
254     def get_theme_config(self) -> Tuple[str, Dict]:
255         return self.config.html_theme, self.config.html_theme_options
256 
257     def init_templates(self) -> None:
258         theme_factory = HTMLThemeFactory(self.app)
259         themename, themeoptions = self.get_theme_config()
260         self.theme = theme_factory.create(themename)
261         self.theme_options = themeoptions.copy()
262         self.create_template_bridge()
263         self.templates.init(self, self.theme)
264 
265     def init_highlighter(self) -> None:
266         # determine Pygments style and create the highlighter
267         if self.config.pygments_style is not None:
268             style = self.config.pygments_style
269         elif self.theme:
270             style = self.theme.get_config('theme', 'pygments_style', 'none')
271         else:
272             style = 'sphinx'
273         self.highlighter = PygmentsBridge('html', style)
274 
275         if self.theme:
276             dark_style = self.theme.get_config('theme', 'pygments_dark_style', None)
277         else:
278             dark_style = None
279 
280         if dark_style is not None:
281             self.dark_highlighter = PygmentsBridge('html', dark_style)
282             self.add_css_file('pygments_dark.css',
283                               media='(prefers-color-scheme: dark)',
284                               id='pygments_dark_css')
285         else:
286             self.dark_highlighter = None
287 
288     def init_css_files(self) -> None:
289         for filename, attrs in self.app.registry.css_files:
290             self.add_css_file(filename, **attrs)
291 
292         for filename, attrs in self.get_builder_config('css_files', 'html'):
293             self.add_css_file(filename, **attrs)
294 
295     def add_css_file(self, filename: str, **kwargs: str) -> None:
296         if '://' not in filename:
297             filename = posixpath.join('_static', filename)
298 
299         self.css_files.append(Stylesheet(filename, **kwargs))  # type: ignore
300 
301     def init_js_files(self) -> None:
302         self.add_js_file('jquery.js')
303         self.add_js_file('underscore.js')
304         self.add_js_file('doctools.js')
305 
306         for filename, attrs in self.app.registry.js_files:
307             self.add_js_file(filename, **attrs)
308 
309         for filename, attrs in self.get_builder_config('js_files', 'html'):
310             self.add_js_file(filename, **attrs)
311 
312         if self.config.language and self._get_translations_js():
313             self.add_js_file('translations.js')
314 
315     def add_js_file(self, filename: str, **kwargs: str) -> None:
316         if filename and '://' not in filename:
317             filename = posixpath.join('_static', filename)
318 
319         self.script_files.append(JavaScript(filename, **kwargs))
320 
321     @property
322     def default_translator_class(self) -> "Type[nodes.NodeVisitor]":  # type: ignore
323         if not html5_ready or self.config.html4_writer:
324             return HTMLTranslator
325         else:
326             return HTML5Translator
327 
328     @property
329     def math_renderer_name(self) -> str:
330         name = self.get_builder_config('math_renderer', 'html')
331         if name is not None:
332             # use given name
333             return name
334         else:
335             # not given: choose a math_renderer from registered ones as possible
336             renderers = list(self.app.registry.html_inline_math_renderers)
337             if len(renderers) == 1:
338                 # only default math_renderer (mathjax) is registered
339                 return renderers[0]
340             elif len(renderers) == 2:
341                 # default and another math_renderer are registered; prior the another
342                 renderers.remove('mathjax')
343                 return renderers[0]
344             else:
345                 # many math_renderers are registered. can't choose automatically!
346                 return None
347 
348     def get_outdated_docs(self) -> Iterator[str]:
349         try:
350             with open(path.join(self.outdir, '.buildinfo')) as fp:
351                 buildinfo = BuildInfo.load(fp)
352 
353             if self.build_info != buildinfo:
354                 yield from self.env.found_docs
355                 return
356         except ValueError as exc:
357             logger.warning(__('Failed to read build info file: %r'), exc)
358         except OSError:
359             # ignore errors on reading
360             pass
361 
362         if self.templates:
363             template_mtime = self.templates.newest_template_mtime()
364         else:
365             template_mtime = 0
366         for docname in self.env.found_docs:
367             if docname not in self.env.all_docs:
368                 yield docname
369                 continue
370             targetname = self.get_outfilename(docname)
371             try:
372                 targetmtime = path.getmtime(targetname)
373             except Exception:
374                 targetmtime = 0
375             try:
376                 srcmtime = max(path.getmtime(self.env.doc2path(docname)),
377                                template_mtime)
378                 if srcmtime > targetmtime:
379                     yield docname
380             except OSError:
381                 # source doesn't exist anymore
382                 pass
383 
384     def get_asset_paths(self) -> List[str]:
385         return self.config.html_extra_path + self.config.html_static_path
386 
387     def render_partial(self, node: Node) -> Dict[str, str]:
388         """Utility: Render a lone doctree node."""
389         if node is None:
390             return {'fragment': ''}
391         doc = new_document('<partial node>')
392         doc.append(node)
393 
394         writer = HTMLWriter(self)
395         return publish_parts(reader_name='doctree',
396                              writer=writer,
397                              source_class=DocTreeInput,
398                              settings_overrides={'output_encoding': 'unicode'},
399                              source=doc)
400 
401     def prepare_writing(self, docnames: Set[str]) -> None:
402         # create the search indexer
403         self.indexer = None
404         if self.search:
405             from sphinx.search import IndexBuilder
406             lang = self.config.html_search_language or self.config.language
407             if not lang:
408                 lang = 'en'
409             self.indexer = IndexBuilder(self.env, lang,
410                                         self.config.html_search_options,
411                                         self.config.html_search_scorer)
412             self.load_indexer(docnames)
413 
414         self.docwriter = HTMLWriter(self)
415         self.docsettings = OptionParser(
416             defaults=self.env.settings,
417             components=(self.docwriter,),
418             read_config_files=True).get_default_values()  # type: Any
419         self.docsettings.compact_lists = bool(self.config.html_compact_lists)
420 
421         # determine the additional indices to include
422         self.domain_indices = []
423         # html_domain_indices can be False/True or a list of index names
424         indices_config = self.config.html_domain_indices
425         if indices_config:
426             for domain_name in sorted(self.env.domains):
427                 domain = None  # type: Domain
428                 domain = self.env.domains[domain_name]
429                 for indexcls in domain.indices:
430                     indexname = '%s-%s' % (domain.name, indexcls.name)
431                     if isinstance(indices_config, list):
432                         if indexname not in indices_config:
433                             continue
434                     content, collapse = indexcls(domain).generate()
435                     if content:
436                         self.domain_indices.append(
437                             (indexname, indexcls, content, collapse))
438 
439         # format the "last updated on" string, only once is enough since it
440         # typically doesn't include the time of day
441         lufmt = self.config.html_last_updated_fmt
442         if lufmt is not None:
443             self.last_updated = format_date(lufmt or _('%b %d, %Y'),
444                                             language=self.config.language)
445         else:
446             self.last_updated = None
447 
448         logo = path.basename(self.config.html_logo) if self.config.html_logo else ''
449         favicon = path.basename(self.config.html_favicon) if self.config.html_favicon else ''
450 
451         if not isinstance(self.config.html_use_opensearch, str):
452             logger.warning(__('html_use_opensearch config value must now be a string'))
453 
454         self.relations = self.env.collect_relations()
455 
456         rellinks = []  # type: List[Tuple[str, str, str, str]]
457         if self.use_index:
458             rellinks.append(('genindex', _('General Index'), 'I', _('index')))
459         for indexname, indexcls, content, collapse in self.domain_indices:
460             # if it has a short name
461             if indexcls.shortname:
462                 rellinks.append((indexname, indexcls.localname,
463                                  '', indexcls.shortname))
464 
465         if self.config.html_style is not None:
466             stylename = self.config.html_style
467         elif self.theme:
468             stylename = self.theme.get_config('theme', 'stylesheet')
469         else:
470             stylename = 'default.css'
471 
472         self.globalcontext = {
473             'embedded': self.embedded,
474             'project': self.config.project,
475             'release': return_codes_re.sub('', self.config.release),
476             'version': self.config.version,
477             'last_updated': self.last_updated,
478             'copyright': self.config.copyright,
479             'master_doc': self.config.master_doc,
480             'use_opensearch': self.config.html_use_opensearch,
481             'docstitle': self.config.html_title,
482             'shorttitle': self.config.html_short_title,
483             'show_copyright': self.config.html_show_copyright,
484             'show_sphinx': self.config.html_show_sphinx,
485             'has_source': self.config.html_copy_source,
486             'show_source': self.config.html_show_sourcelink,
487             'sourcelink_suffix': self.config.html_sourcelink_suffix,
488             'file_suffix': self.out_suffix,
489             'link_suffix': self.link_suffix,
490             'script_files': self.script_files,
491             'language': self.config.language,
492             'css_files': self.css_files,
493             'sphinx_version': __display_version__,
494             'style': stylename,
495             'rellinks': rellinks,
496             'builder': self.name,
497             'parents': [],
498             'logo': logo,
499             'favicon': favicon,
500             'html5_doctype': html5_ready and not self.config.html4_writer,
501         }
502         if self.theme:
503             self.globalcontext.update(
504                 ('theme_' + key, val) for (key, val) in
505                 self.theme.get_options(self.theme_options).items())
506         self.globalcontext.update(self.config.html_context)
507 
508     def get_doc_context(self, docname: str, body: str, metatags: str) -> Dict[str, Any]:
509         """Collect items for the template context of a page."""
510         # find out relations
511         prev = next = None
512         parents = []
513         rellinks = self.globalcontext['rellinks'][:]
514         related = self.relations.get(docname)
515         titles = self.env.titles
516         if related and related[2]:
517             try:
518                 next = {
519                     'link': self.get_relative_uri(docname, related[2]),
520                     'title': self.render_partial(titles[related[2]])['title']
521                 }
522                 rellinks.append((related[2], next['title'], 'N', _('next')))
523             except KeyError:
524                 next = None
525         if related and related[1]:
526             try:
527                 prev = {
528                     'link': self.get_relative_uri(docname, related[1]),
529                     'title': self.render_partial(titles[related[1]])['title']
530                 }
531                 rellinks.append((related[1], prev['title'], 'P', _('previous')))
532             except KeyError:
533                 # the relation is (somehow) not in the TOC tree, handle
534                 # that gracefully
535                 prev = None
536         while related and related[0]:
537             try:
538                 parents.append(
539                     {'link': self.get_relative_uri(docname, related[0]),
540                      'title': self.render_partial(titles[related[0]])['title']})
541             except KeyError:
542                 pass
543             related = self.relations.get(related[0])
544         if parents:
545             # remove link to the master file; we have a generic
546             # "back to index" link already
547             parents.pop()
548         parents.reverse()
549 
550         # title rendered as HTML
551         title_node = self.env.longtitles.get(docname)
552         title = self.render_partial(title_node)['title'] if title_node else ''
553 
554         # Suffix for the document
555         source_suffix = self.env.doc2path(docname, False)[len(docname):]
556 
557         # the name for the copied source
558         if self.config.html_copy_source:
559             sourcename = docname + source_suffix
560             if source_suffix != self.config.html_sourcelink_suffix:
561                 sourcename += self.config.html_sourcelink_suffix
562         else:
563             sourcename = ''
564 
565         # metadata for the document
566         meta = self.env.metadata.get(docname)
567 
568         # local TOC and global TOC tree
569         self_toc = TocTree(self.env).get_toc_for(docname, self)
570         toc = self.render_partial(self_toc)['fragment']
571 
572         return {
573             'parents': parents,
574             'prev': prev,
575             'next': next,
576             'title': title,
577             'meta': meta,
578             'body': body,
579             'metatags': metatags,
580             'rellinks': rellinks,
581             'sourcename': sourcename,
582             'toc': toc,
583             # only display a TOC if there's more than one item to show
584             'display_toc': (self.env.toc_num_entries[docname] > 1),
585             'page_source_suffix': source_suffix,
586         }
587 
588     def write_doc(self, docname: str, doctree: nodes.document) -> None:
589         destination = StringOutput(encoding='utf-8')
590         doctree.settings = self.docsettings
591 
592         self.secnumbers = self.env.toc_secnumbers.get(docname, {})
593         self.fignumbers = self.env.toc_fignumbers.get(docname, {})
594         self.imgpath = relative_uri(self.get_target_uri(docname), '_images')
595         self.dlpath = relative_uri(self.get_target_uri(docname), '_downloads')
596         self.current_docname = docname
597         self.docwriter.write(doctree, destination)
598         self.docwriter.assemble_parts()
599         body = self.docwriter.parts['fragment']
600         metatags = self.docwriter.clean_meta
601 
602         ctx = self.get_doc_context(docname, body, metatags)
603         self.handle_page(docname, ctx, event_arg=doctree)
604 
605     def write_doc_serialized(self, docname: str, doctree: nodes.document) -> None:
606         self.imgpath = relative_uri(self.get_target_uri(docname), self.imagedir)
607         self.post_process_images(doctree)
608         title_node = self.env.longtitles.get(docname)
609         title = self.render_partial(title_node)['title'] if title_node else ''
610         self.index_page(docname, doctree, title)
611 
612     def finish(self) -> None:
613         self.finish_tasks.add_task(self.gen_indices)
614         self.finish_tasks.add_task(self.gen_pages_from_extensions)
615         self.finish_tasks.add_task(self.gen_additional_pages)
616         self.finish_tasks.add_task(self.copy_image_files)
617         self.finish_tasks.add_task(self.copy_download_files)
618         self.finish_tasks.add_task(self.copy_static_files)
619         self.finish_tasks.add_task(self.copy_extra_files)
620         self.finish_tasks.add_task(self.write_buildinfo)
621 
622         # dump the search index
623         self.handle_finish()
624 
625     @progress_message(__('generating indices'))
626     def gen_indices(self) -> None:
627         # the global general index
628         if self.use_index:
629             self.write_genindex()
630 
631         # the global domain-specific indices
632         self.write_domain_indices()
633 
634     def gen_pages_from_extensions(self) -> None:
635         # pages from extensions
636         for pagelist in self.events.emit('html-collect-pages'):
637             for pagename, context, template in pagelist:
638                 self.handle_page(pagename, context, template)
639 
640     @progress_message(__('writing additional pages'))
641     def gen_additional_pages(self) -> None:
642         # additional pages from conf.py
643         for pagename, template in self.config.html_additional_pages.items():
644             logger.info(pagename + ' ', nonl=True)
645             self.handle_page(pagename, {}, template)
646 
647         # the search page
648         if self.search:
649             logger.info('search ', nonl=True)
650             self.handle_page('search', {}, 'search.html')
651 
652         # the opensearch xml file
653         if self.config.html_use_opensearch and self.search:
654             logger.info('opensearch ', nonl=True)
655             fn = path.join(self.outdir, '_static', 'opensearch.xml')
656             self.handle_page('opensearch', {}, 'opensearch.xml', outfilename=fn)
657 
658     def write_genindex(self) -> None:
659         # the total count of lines for each index letter, used to distribute
660         # the entries into two columns
661         genindex = IndexEntries(self.env).create_index(self)
662         indexcounts = []
663         for _k, entries in genindex:
664             indexcounts.append(sum(1 + len(subitems)
665                                    for _, (_, subitems, _) in entries))
666 
667         genindexcontext = {
668             'genindexentries': genindex,
669             'genindexcounts': indexcounts,
670             'split_index': self.config.html_split_index,
671         }
672         logger.info('genindex ', nonl=True)
673 
674         if self.config.html_split_index:
675             self.handle_page('genindex', genindexcontext,
676                              'genindex-split.html')
677             self.handle_page('genindex-all', genindexcontext,
678                              'genindex.html')
679             for (key, entries), count in zip(genindex, indexcounts):
680                 ctx = {'key': key, 'entries': entries, 'count': count,
681                        'genindexentries': genindex}
682                 self.handle_page('genindex-' + key, ctx,
683                                  'genindex-single.html')
684         else:
685             self.handle_page('genindex', genindexcontext, 'genindex.html')
686 
687     def write_domain_indices(self) -> None:
688         for indexname, indexcls, content, collapse in self.domain_indices:
689             indexcontext = {
690                 'indextitle': indexcls.localname,
691                 'content': content,
692                 'collapse_index': collapse,
693             }
694             logger.info(indexname + ' ', nonl=True)
695             self.handle_page(indexname, indexcontext, 'domainindex.html')
696 
697     def copy_image_files(self) -> None:
698         if self.images:
699             stringify_func = ImageAdapter(self.app.env).get_original_image_uri
700             ensuredir(path.join(self.outdir, self.imagedir))
701             for src in status_iterator(self.images, __('copying images... '), "brown",
702                                        len(self.images), self.app.verbosity,
703                                        stringify_func=stringify_func):
704                 dest = self.images[src]
705                 try:
706                     copyfile(path.join(self.srcdir, src),
707                              path.join(self.outdir, self.imagedir, dest))
708                 except Exception as err:
709                     logger.warning(__('cannot copy image file %r: %s'),
710                                    path.join(self.srcdir, src), err)
711 
712     def copy_download_files(self) -> None:
713         def to_relpath(f: str) -> str:
714             return relative_path(self.srcdir, f)
715 
716         # copy downloadable files
717         if self.env.dlfiles:
718             ensuredir(path.join(self.outdir, '_downloads'))
719             for src in status_iterator(self.env.dlfiles, __('copying downloadable files... '),
720                                        "brown", len(self.env.dlfiles), self.app.verbosity,
721                                        stringify_func=to_relpath):
722                 try:
723                     dest = path.join(self.outdir, '_downloads', self.env.dlfiles[src][1])
724                     ensuredir(path.dirname(dest))
725                     copyfile(path.join(self.srcdir, src), dest)
726                 except OSError as err:
727                     logger.warning(__('cannot copy downloadable file %r: %s'),
728                                    path.join(self.srcdir, src), err)
729 
730     def create_pygments_style_file(self) -> None:
731         """create a style file for pygments."""
732         with open(path.join(self.outdir, '_static', 'pygments.css'), 'w') as f:
733             f.write(self.highlighter.get_stylesheet())
734 
735         if self.dark_highlighter:
736             with open(path.join(self.outdir, '_static', 'pygments_dark.css'), 'w') as f:
737                 f.write(self.dark_highlighter.get_stylesheet())
738 
739     def copy_translation_js(self) -> None:
740         """Copy a JavaScript file for translations."""
741         if self.config.language is not None:
742             jsfile = self._get_translations_js()
743             if jsfile:
744                 copyfile(jsfile, path.join(self.outdir, '_static', 'translations.js'))
745 
746     def copy_stemmer_js(self) -> None:
747         """Copy a JavaScript file for stemmer."""
748         if self.indexer is not None:
749             jsfile = self.indexer.get_js_stemmer_rawcode()
750             if jsfile:
751                 copyfile(jsfile, path.join(self.outdir, '_static', '_stemmer.js'))
752 
753     def copy_theme_static_files(self, context: Dict) -> None:
754         def onerror(filename: str, error: Exception) -> None:
755             logger.warning(__('Failed to copy a file in html_static_file: %s: %r'),
756                            filename, error)
757 
758         if self.theme:
759             for entry in self.theme.get_theme_dirs()[::-1]:
760                 copy_asset(path.join(entry, 'static'),
761                            path.join(self.outdir, '_static'),
762                            excluded=DOTFILES, context=context,
763                            renderer=self.templates, onerror=onerror)
764 
765     def copy_html_static_files(self, context: Dict) -> None:
766         def onerror(filename: str, error: Exception) -> None:
767             logger.warning(__('Failed to copy a file in html_static_file: %s: %r'),
768                            filename, error)
769 
770         excluded = Matcher(self.config.exclude_patterns + ["**/.*"])
771         for entry in self.config.html_static_path:
772             copy_asset(path.join(self.confdir, entry),
773                        path.join(self.outdir, '_static'),
774                        excluded, context=context, renderer=self.templates, onerror=onerror)
775 
776     def copy_html_logo(self) -> None:
777         if self.config.html_logo:
778             copy_asset(path.join(self.confdir, self.config.html_logo),
779                        path.join(self.outdir, '_static'))
780 
781     def copy_html_favicon(self) -> None:
782         if self.config.html_favicon:
783             copy_asset(path.join(self.confdir, self.config.html_favicon),
784                        path.join(self.outdir, '_static'))
785 
786     def copy_static_files(self) -> None:
787         try:
788             with progress_message(__('copying static files')):
789                 ensuredir(path.join(self.outdir, '_static'))
790 
791                 # prepare context for templates
792                 context = self.globalcontext.copy()
793                 if self.indexer is not None:
794                     context.update(self.indexer.context_for_searchtool())
795 
796                 self.create_pygments_style_file()
797                 self.copy_translation_js()
798                 self.copy_stemmer_js()
799                 self.copy_theme_static_files(context)
800                 self.copy_html_static_files(context)
801                 self.copy_html_logo()
802                 self.copy_html_favicon()
803         except OSError as err:
804             logger.warning(__('cannot copy static file %r'), err)
805 
806     def copy_extra_files(self) -> None:
807         """copy html_extra_path files."""
808         try:
809             with progress_message(__('copying extra files')):
810                 excluded = Matcher(self.config.exclude_patterns)
811                 for extra_path in self.config.html_extra_path:
812                     entry = path.join(self.confdir, extra_path)
813                     copy_asset(entry, self.outdir, excluded)
814         except OSError as err:
815             logger.warning(__('cannot copy extra file %r'), err)
816 
817     def write_buildinfo(self) -> None:
818         try:
819             with open(path.join(self.outdir, '.buildinfo'), 'w') as fp:
820                 self.build_info.dump(fp)
821         except OSError as exc:
822             logger.warning(__('Failed to write build info file: %r'), exc)
823 
824     def cleanup(self) -> None:
825         # clean up theme stuff
826         if self.theme:
827             self.theme.cleanup()
828 
829     def post_process_images(self, doctree: Node) -> None:
830         """Pick the best candidate for an image and link down-scaled images to
831         their high res version.
832         """
833         Builder.post_process_images(self, doctree)
834 
835         if self.config.html_scaled_image_link and self.html_scaled_image_link:
836             for node in doctree.traverse(nodes.image):
837                 if not any((key in node) for key in ['scale', 'width', 'height']):
838                     # resizing options are not given. scaled image link is available
839                     # only for resized images.
840                     continue
841                 elif isinstance(node.parent, nodes.reference):
842                     # A image having hyperlink target
843                     continue
844                 elif 'no-scaled-link' in node['classes']:
845                     # scaled image link is disabled for this node
846                     continue
847 
848                 uri = node['uri']
849                 reference = nodes.reference('', '', internal=True)
850                 if uri in self.images:
851                     reference['refuri'] = posixpath.join(self.imgpath,
852                                                          self.images[uri])
853                 else:
854                     reference['refuri'] = uri
855                 node.replace_self(reference)
856                 reference.append(node)
857 
858     def load_indexer(self, docnames: Iterable[str]) -> None:
859         keep = set(self.env.all_docs) - set(docnames)
860         try:
861             searchindexfn = path.join(self.outdir, self.searchindex_filename)
862             if self.indexer_dumps_unicode:
863                 with open(searchindexfn, encoding='utf-8') as ft:
864                     self.indexer.load(ft, self.indexer_format)
865             else:
866                 with open(searchindexfn, 'rb') as fb:
867                     self.indexer.load(fb, self.indexer_format)
868         except (OSError, ValueError):
869             if keep:
870                 logger.warning(__('search index couldn\'t be loaded, but not all '
871                                   'documents will be built: the index will be '
872                                   'incomplete.'))
873         # delete all entries for files that will be rebuilt
874         self.indexer.prune(keep)
875 
876     def index_page(self, pagename: str, doctree: nodes.document, title: str) -> None:
877         # only index pages with title
878         if self.indexer is not None and title:
879             filename = self.env.doc2path(pagename, base=None)
880             try:
881                 metadata = self.env.metadata.get(pagename, {})
882                 if 'nosearch' in metadata:
883                     self.indexer.feed(pagename, filename, '', new_document(''))
884                 else:
885                     self.indexer.feed(pagename, filename, title, doctree)
886             except TypeError:
887                 # fallback for old search-adapters
888                 self.indexer.feed(pagename, title, doctree)  # type: ignore
889                 indexer_name = self.indexer.__class__.__name__
890                 warnings.warn(
891                     'The %s.feed() method signature is deprecated. Update to '
892                     '%s.feed(docname, filename, title, doctree).' % (
893                         indexer_name, indexer_name),
894                     RemovedInSphinx40Warning, stacklevel=2)
895 
896     def _get_local_toctree(self, docname: str, collapse: bool = True, **kwargs: Any) -> str:
897         if 'includehidden' not in kwargs:
898             kwargs['includehidden'] = False
899         if kwargs.get('maxdepth') == '':
900             kwargs.pop('maxdepth')
901         return self.render_partial(TocTree(self.env).get_toctree_for(
902             docname, self, collapse, **kwargs))['fragment']
903 
904     def get_outfilename(self, pagename: str) -> str:
905         return path.join(self.outdir, os_path(pagename) + self.out_suffix)
906 
907     def add_sidebars(self, pagename: str, ctx: Dict) -> None:
908         def has_wildcard(pattern: str) -> bool:
909             return any(char in pattern for char in '*?[')
910 
911         sidebars = None
912         matched = None
913         customsidebar = None
914 
915         # default sidebars settings for selected theme
916         if self.theme.name == 'alabaster':
917             # provide default settings for alabaster (for compatibility)
918             # Note: this will be removed before Sphinx-2.0
919             try:
920                 # get default sidebars settings from alabaster (if defined)
921                 theme_default_sidebars = self.theme.config.get('theme', 'sidebars')
922                 if theme_default_sidebars:
923                     sidebars = [name.strip() for name in theme_default_sidebars.split(',')]
924             except Exception:
925                 # fallback to better default settings
926                 sidebars = ['about.html', 'navigation.html', 'relations.html',
927                             'searchbox.html', 'donate.html']
928         else:
929             theme_default_sidebars = self.theme.get_config('theme', 'sidebars', None)
930             if theme_default_sidebars:
931                 sidebars = [name.strip() for name in theme_default_sidebars.split(',')]
932 
933         # user sidebar settings
934         html_sidebars = self.get_builder_config('sidebars', 'html')
935         for pattern, patsidebars in html_sidebars.items():
936             if patmatch(pagename, pattern):
937                 if matched:
938                     if has_wildcard(pattern):
939                         # warn if both patterns contain wildcards
940                         if has_wildcard(matched):
941                             logger.warning(__('page %s matches two patterns in '
942                                               'html_sidebars: %r and %r'),
943                                            pagename, matched, pattern)
944                         # else the already matched pattern is more specific
945                         # than the present one, because it contains no wildcard
946                         continue
947                 matched = pattern
948                 sidebars = patsidebars
949 
950         if sidebars is None:
951             # keep defaults
952             pass
953 
954         ctx['sidebars'] = sidebars
955         ctx['customsidebar'] = customsidebar
956 
957     # --------- these are overwritten by the serialization builder
958 
959     def get_target_uri(self, docname: str, typ: str = None) -> str:
960         return quote(docname) + self.link_suffix
961 
962     def handle_page(self, pagename: str, addctx: Dict, templatename: str = 'page.html',
963                     outfilename: str = None, event_arg: Any = None) -> None:
964         ctx = self.globalcontext.copy()
965         # current_page_name is backwards compatibility
966         ctx['pagename'] = ctx['current_page_name'] = pagename
967         ctx['encoding'] = self.config.html_output_encoding
968         default_baseuri = self.get_target_uri(pagename)
969         # in the singlehtml builder, default_baseuri still contains an #anchor
970         # part, which relative_uri doesn't really like...
971         default_baseuri = default_baseuri.rsplit('#', 1)[0]
972 
973         if self.config.html_baseurl:
974             ctx['pageurl'] = posixpath.join(self.config.html_baseurl,
975                                             pagename + self.out_suffix)
976         else:
977             ctx['pageurl'] = None
978 
979         def pathto(otheruri: str, resource: bool = False, baseuri: str = default_baseuri) -> str:  # NOQA
980             if resource and '://' in otheruri:
981                 # allow non-local resources given by scheme
982                 return otheruri
983             elif not resource:
984                 otheruri = self.get_target_uri(otheruri)
985             uri = relative_uri(baseuri, otheruri) or '#'
986             if uri == '#' and not self.allow_sharp_as_current_path:
987                 uri = baseuri
988             return uri
989         ctx['pathto'] = pathto
990 
991         def css_tag(css: Stylesheet) -> str:
992             attrs = []
993             for key in sorted(css.attributes):
994                 value = css.attributes[key]
995                 if value is not None:
996                     attrs.append('%s="%s"' % (key, html.escape(value, True)))
997             attrs.append('href="%s"' % pathto(css.filename, resource=True))
998             return '<link %s />' % ' '.join(attrs)
999         ctx['css_tag'] = css_tag
1000 
1001         def hasdoc(name: str) -> bool:
1002             if name in self.env.all_docs:
1003                 return True
1004             elif name == 'search' and self.search:
1005                 return True
1006             elif name == 'genindex' and self.get_builder_config('use_index', 'html'):
1007                 return True
1008             return False
1009         ctx['hasdoc'] = hasdoc
1010 
1011         ctx['toctree'] = lambda **kwargs: self._get_local_toctree(pagename, **kwargs)
1012         self.add_sidebars(pagename, ctx)
1013         ctx.update(addctx)
1014 
1015         self.update_page_context(pagename, templatename, ctx, event_arg)
1016         newtmpl = self.app.emit_firstresult('html-page-context', pagename,
1017                                             templatename, ctx, event_arg)
1018         if newtmpl:
1019             templatename = newtmpl
1020 
1021         try:
1022             output = self.templates.render(templatename, ctx)
1023         except UnicodeError:
1024             logger.warning(__("a Unicode error occurred when rendering the page %s. "
1025                               "Please make sure all config values that contain "
1026                               "non-ASCII content are Unicode strings."), pagename)
1027             return
1028         except Exception as exc:
1029             raise ThemeError(__("An error happened in rendering the page %s.\nReason: %r") %
1030                              (pagename, exc)) from exc
1031 
1032         if not outfilename:
1033             outfilename = self.get_outfilename(pagename)
1034         # outfilename's path is in general different from self.outdir
1035         ensuredir(path.dirname(outfilename))
1036         try:
1037             with open(outfilename, 'w', encoding=ctx['encoding'],
1038                       errors='xmlcharrefreplace') as f:
1039                 f.write(output)
1040         except OSError as err:
1041             logger.warning(__("error writing file %s: %s"), outfilename, err)
1042         if self.copysource and ctx.get('sourcename'):
1043             # copy the source file for the "show source" link
1044             source_name = path.join(self.outdir, '_sources',
1045                                     os_path(ctx['sourcename']))
1046             ensuredir(path.dirname(source_name))
1047             copyfile(self.env.doc2path(pagename), source_name)
1048 
1049     def update_page_context(self, pagename: str, templatename: str,
1050                             ctx: Dict, event_arg: Any) -> None:
1051         pass
1052 
1053     def handle_finish(self) -> None:
1054         if self.indexer:
1055             self.finish_tasks.add_task(self.dump_search_index)
1056         self.finish_tasks.add_task(self.dump_inventory)
1057 
1058     @progress_message(__('dumping object inventory'))
1059     def dump_inventory(self) -> None:
1060         InventoryFile.dump(path.join(self.outdir, INVENTORY_FILENAME), self.env, self)
1061 
1062     def dump_search_index(self) -> None:
1063         with progress_message(__('dumping search index in %s') % self.indexer.label()):
1064             self.indexer.prune(self.env.all_docs)
1065             searchindexfn = path.join(self.outdir, self.searchindex_filename)
1066             # first write to a temporary file, so that if dumping fails,
1067             # the existing index won't be overwritten
1068             if self.indexer_dumps_unicode:
1069                 with open(searchindexfn + '.tmp', 'w', encoding='utf-8') as ft:
1070                     self.indexer.dump(ft, self.indexer_format)
1071             else:
1072                 with open(searchindexfn + '.tmp', 'wb') as fb:
1073                     self.indexer.dump(fb, self.indexer_format)
1074             os.replace(searchindexfn + '.tmp', searchindexfn)
1075 
1076 
1077 def convert_html_css_files(app: Sphinx, config: Config) -> None:
1078     """This converts string styled html_css_files to tuple styled one."""
1079     html_css_files = []  # type: List[Tuple[str, Dict]]
1080     for entry in config.html_css_files:
1081         if isinstance(entry, str):
1082             html_css_files.append((entry, {}))
1083         else:
1084             try:
1085                 filename, attrs = entry
1086                 html_css_files.append((filename, attrs))
1087             except Exception:
1088                 logger.warning(__('invalid css_file: %r, ignored'), entry)
1089                 continue
1090 
1091     config.html_css_files = html_css_files  # type: ignore
1092 
1093 
1094 def convert_html_js_files(app: Sphinx, config: Config) -> None:
1095     """This converts string styled html_js_files to tuple styled one."""
1096     html_js_files = []  # type: List[Tuple[str, Dict]]
1097     for entry in config.html_js_files:
1098         if isinstance(entry, str):
1099             html_js_files.append((entry, {}))
1100         else:
1101             try:
1102                 filename, attrs = entry
1103                 html_js_files.append((filename, attrs))
1104             except Exception:
1105                 logger.warning(__('invalid js_file: %r, ignored'), entry)
1106                 continue
1107 
1108     config.html_js_files = html_js_files  # type: ignore
1109 
1110 
1111 def setup_js_tag_helper(app: Sphinx, pagename: str, templatexname: str,
1112                         context: Dict, doctree: Node) -> None:
1113     """Set up js_tag() template helper.
1114 
1115     .. note:: This set up function is added to keep compatibility with webhelper.
1116     """
1117     pathto = context.get('pathto')
1118 
1119     def js_tag(js: JavaScript) -> str:
1120         attrs = []
1121         body = ''
1122         if isinstance(js, JavaScript):
1123             for key in sorted(js.attributes):
1124                 value = js.attributes[key]
1125                 if value is not None:
1126                     if key == 'body':
1127                         body = value
1128                     else:
1129                         attrs.append('%s="%s"' % (key, html.escape(value, True)))
1130             if js.filename:
1131                 attrs.append('src="%s"' % pathto(js.filename, resource=True))
1132         else:
1133             # str value (old styled)
1134             attrs.append('src="%s"' % pathto(js, resource=True))
1135         return '<script %s>%s</script>' % (' '.join(attrs), body)
1136 
1137     context['js_tag'] = js_tag
1138 
1139 
1140 def validate_math_renderer(app: Sphinx) -> None:
1141     if app.builder.format != 'html':
1142         return
1143 
1144     name = app.builder.math_renderer_name  # type: ignore
1145     if name is None:
1146         raise ConfigError(__('Many math_renderers are registered. '
1147                              'But no math_renderer is selected.'))
1148     elif name not in app.registry.html_inline_math_renderers:
1149         raise ConfigError(__('Unknown math_renderer %r is given.') % name)
1150 
1151 
1152 def validate_html_extra_path(app: Sphinx, config: Config) -> None:
1153     """Check html_extra_paths setting."""
1154     for entry in config.html_extra_path[:]:
1155         extra_path = path.normpath(path.join(app.confdir, entry))
1156         if not path.exists(extra_path):
1157             logger.warning(__('html_extra_path entry %r does not exist'), entry)
1158             config.html_extra_path.remove(entry)
1159         elif (path.splitdrive(app.outdir)[0] == path.splitdrive(extra_path)[0] and
1160               path.commonpath([app.outdir, extra_path]) == app.outdir):
1161             logger.warning(__('html_extra_path entry %r is placed inside outdir'), entry)
1162             config.html_extra_path.remove(entry)
1163 
1164 
1165 def validate_html_static_path(app: Sphinx, config: Config) -> None:
1166     """Check html_static_paths setting."""
1167     for entry in config.html_static_path[:]:
1168         static_path = path.normpath(path.join(app.confdir, entry))
1169         if not path.exists(static_path):
1170             logger.warning(__('html_static_path entry %r does not exist'), entry)
1171             config.html_static_path.remove(entry)
1172         elif (path.splitdrive(app.outdir)[0] == path.splitdrive(static_path)[0] and
1173               path.commonpath([app.outdir, static_path]) == app.outdir):
1174             logger.warning(__('html_static_path entry %r is placed inside outdir'), entry)
1175             config.html_static_path.remove(entry)
1176 
1177 
1178 def validate_html_logo(app: Sphinx, config: Config) -> None:
1179     """Check html_logo setting."""
1180     if config.html_logo and not path.isfile(path.join(app.confdir, config.html_logo)):
1181         logger.warning(__('logo file %r does not exist'), config.html_logo)
1182         config.html_logo = None  # type: ignore
1183 
1184 
1185 def validate_html_favicon(app: Sphinx, config: Config) -> None:
1186     """Check html_favicon setting."""
1187     if config.html_favicon and not path.isfile(path.join(app.confdir, config.html_favicon)):
1188         logger.warning(__('favicon file %r does not exist'), config.html_favicon)
1189         config.html_favicon = None  # type: ignore
1190 
1191 
1192 # for compatibility
1193 import sphinxcontrib.serializinghtml  # NOQA
1194 
1195 import sphinx.builders.dirhtml  # NOQA
1196 import sphinx.builders.singlehtml  # NOQA
1197 
1198 
1199 def setup(app: Sphinx) -> Dict[str, Any]:
1200     # builders
1201     app.add_builder(StandaloneHTMLBuilder)
1202 
1203     # config values
1204     app.add_config_value('html_theme', 'alabaster', 'html')
1205     app.add_config_value('html_theme_path', [], 'html')
1206     app.add_config_value('html_theme_options', {}, 'html')
1207     app.add_config_value('html_title',
1208                          lambda self: _('%s %s documentation') % (self.project, self.release),
1209                          'html', [str])
1210     app.add_config_value('html_short_title', lambda self: self.html_title, 'html')
1211     app.add_config_value('html_style', None, 'html', [str])
1212     app.add_config_value('html_logo', None, 'html', [str])
1213     app.add_config_value('html_favicon', None, 'html', [str])
1214     app.add_config_value('html_css_files', [], 'html')
1215     app.add_config_value('html_js_files', [], 'html')
1216     app.add_config_value('html_static_path', [], 'html')
1217     app.add_config_value('html_extra_path', [], 'html')
1218     app.add_config_value('html_last_updated_fmt', None, 'html', [str])
1219     app.add_config_value('html_sidebars', {}, 'html')
1220     app.add_config_value('html_additional_pages', {}, 'html')
1221     app.add_config_value('html_domain_indices', True, 'html', [list])
1222     app.add_config_value('html_add_permalinks', '¶', 'html')
1223     app.add_config_value('html_use_index', True, 'html')
1224     app.add_config_value('html_split_index', False, 'html')
1225     app.add_config_value('html_copy_source', True, 'html')
1226     app.add_config_value('html_show_sourcelink', True, 'html')
1227     app.add_config_value('html_sourcelink_suffix', '.txt', 'html')
1228     app.add_config_value('html_use_opensearch', '', 'html')
1229     app.add_config_value('html_file_suffix', None, 'html', [str])
1230     app.add_config_value('html_link_suffix', None, 'html', [str])
1231     app.add_config_value('html_show_copyright', True, 'html')
1232     app.add_config_value('html_show_sphinx', True, 'html')
1233     app.add_config_value('html_context', {}, 'html')
1234     app.add_config_value('html_output_encoding', 'utf-8', 'html')
1235     app.add_config_value('html_compact_lists', True, 'html')
1236     app.add_config_value('html_secnumber_suffix', '. ', 'html')
1237     app.add_config_value('html_search_language', None, 'html', [str])
1238     app.add_config_value('html_search_options', {}, 'html')
1239     app.add_config_value('html_search_scorer', '', None)
1240     app.add_config_value('html_scaled_image_link', True, 'html')
1241     app.add_config_value('html_baseurl', '', 'html')
1242     app.add_config_value('html_codeblock_linenos_style', 'table', 'html',
1243                          ENUM('table', 'inline'))
1244     app.add_config_value('html_math_renderer', None, 'env')
1245     app.add_config_value('html4_writer', False, 'html')
1246 
1247     # events
1248     app.add_event('html-collect-pages')
1249     app.add_event('html-page-context')
1250 
1251     # event handlers
1252     app.connect('config-inited', convert_html_css_files, priority=800)
1253     app.connect('config-inited', convert_html_js_files, priority=800)
1254     app.connect('config-inited', validate_html_extra_path, priority=800)
1255     app.connect('config-inited', validate_html_static_path, priority=800)
1256     app.connect('config-inited', validate_html_logo, priority=800)
1257     app.connect('config-inited', validate_html_favicon, priority=800)
1258     app.connect('builder-inited', validate_math_renderer)
1259     app.connect('html-page-context', setup_js_tag_helper)
1260 
1261     # load default math renderer
1262     app.setup_extension('sphinx.ext.mathjax')
1263 
1264     # load transforms for HTML builder
1265     app.setup_extension('sphinx.builders.html.transforms')
1266 
1267     return {
1268         'version': 'builtin',
1269         'parallel_read_safe': True,
1270         'parallel_write_safe': True,
1271     }

</code><intended_behavior>Since this file is part of the HTML builder in Sphinx, it is responsible for converting reStructuredText into HTML. The intended behavior would be to ensure during the HTML generation process that compound keystrokes within the `:kbd:` role are rendered with a parent `<kbd>` element that includes a specific CSS class. This modification should preserve the current functionality for all other elements and roles, ensuring that only the `:kbd:` role handling is augmented to support differentiated styling.</intended_behavior>]
2025-10-16 01:04:36.271 | INFO     | Search completed. Bug locations: [<file>sphinx/roles.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2     sphinx.roles
3     ~~~~~~~~~~~~
4 
5     Handlers for additional ReST roles.
6 
7     :copyright: Copyright 2007-2020 by the Sphinx team, see AUTHORS.
8     :license: BSD, see LICENSE for details.
9 """
10 
11 import re
12 import warnings
13 from typing import Any, Dict, List, Tuple
14 
15 from docutils import nodes, utils
16 from docutils.nodes import Element, Node, TextElement, system_message
17 from docutils.parsers.rst.states import Inliner
18 
19 from sphinx import addnodes
20 from sphinx.deprecation import RemovedInSphinx40Warning
21 from sphinx.locale import _
22 from sphinx.util import ws_re
23 from sphinx.util.docutils import ReferenceRole, SphinxRole
24 from sphinx.util.nodes import process_index_entry, set_role_source_info, split_explicit_title
25 from sphinx.util.typing import RoleFunction
26 
27 if False:
28     # For type annotation
29     from typing import Type  # for python3.5.1
30 
31     from sphinx.application import Sphinx
32     from sphinx.environment import BuildEnvironment
33 
34 
35 generic_docroles = {
36     'command': addnodes.literal_strong,
37     'dfn': nodes.emphasis,
38     'kbd': nodes.literal,
39     'mailheader': addnodes.literal_emphasis,
40     'makevar': addnodes.literal_strong,
41     'manpage': addnodes.manpage,
42     'mimetype': addnodes.literal_emphasis,
43     'newsgroup': addnodes.literal_emphasis,
44     'program': addnodes.literal_strong,  # XXX should be an x-ref
45     'regexp': nodes.literal,
46 }
47 
48 
49 # -- generic cross-reference role ----------------------------------------------
50 
51 class XRefRole(ReferenceRole):
52     """
53     A generic cross-referencing role.  To create a callable that can be used as
54     a role function, create an instance of this class.
55 
56     The general features of this role are:
57 
58     * Automatic creation of a reference and a content node.
59     * Optional separation of title and target with `title <target>`.
60     * The implementation is a class rather than a function to make
61       customization easier.
62 
63     Customization can be done in two ways:
64 
65     * Supplying constructor parameters:
66       * `fix_parens` to normalize parentheses (strip from target, and add to
67         title if configured)
68       * `lowercase` to lowercase the target
69       * `nodeclass` and `innernodeclass` select the node classes for
70         the reference and the content node
71 
72     * Subclassing and overwriting `process_link()` and/or `result_nodes()`.
73     """
74 
75     nodeclass = addnodes.pending_xref   # type: Type[Element]
76     innernodeclass = nodes.literal      # type: Type[TextElement]
77 
78     def __init__(self, fix_parens: bool = False, lowercase: bool = False,
79                  nodeclass: "Type[Element]" = None, innernodeclass: "Type[TextElement]" = None,
80                  warn_dangling: bool = False) -> None:
81         self.fix_parens = fix_parens
82         self.lowercase = lowercase
83         self.warn_dangling = warn_dangling
84         if nodeclass is not None:
85             self.nodeclass = nodeclass
86         if innernodeclass is not None:
87             self.innernodeclass = innernodeclass
88 
89         super().__init__()
90 
91     def _fix_parens(self, env: "BuildEnvironment", has_explicit_title: bool, title: str,
92                     target: str) -> Tuple[str, str]:
93         warnings.warn('XRefRole._fix_parens() is deprecated.',
94                       RemovedInSphinx40Warning, stacklevel=2)
95         if not has_explicit_title:
96             if title.endswith('()'):
97                 # remove parentheses
98                 title = title[:-2]
99             if env.config.add_function_parentheses:
100                 # add them back to all occurrences if configured
101                 title += '()'
102         # remove parentheses from the target too
103         if target.endswith('()'):
104             target = target[:-2]
105         return title, target
106 
107     def update_title_and_target(self, title: str, target: str) -> Tuple[str, str]:
108         if not self.has_explicit_title:
109             if title.endswith('()'):
110                 # remove parentheses
111                 title = title[:-2]
112             if self.config.add_function_parentheses:
113                 # add them back to all occurrences if configured
114                 title += '()'
115         # remove parentheses from the target too
116         if target.endswith('()'):
117             target = target[:-2]
118         return title, target
119 
120     def run(self) -> Tuple[List[Node], List[system_message]]:
121         if ':' not in self.name:
122             self.refdomain, self.reftype = '', self.name
123             self.classes = ['xref', self.reftype]
124         else:
125             self.refdomain, self.reftype = self.name.split(':', 1)
126             self.classes = ['xref', self.refdomain, '%s-%s' % (self.refdomain, self.reftype)]
127 
128         if self.disabled:
129             return self.create_non_xref_node()
130         else:
131             return self.create_xref_node()
132 
133     def create_non_xref_node(self) -> Tuple[List[Node], List[system_message]]:
134         text = utils.unescape(self.text[1:])
135         if self.fix_parens:
136             self.has_explicit_title = False  # treat as implicit
137             text, target = self.update_title_and_target(text, "")
138 
139         node = self.innernodeclass(self.rawtext, text, classes=self.classes)
140         return self.result_nodes(self.inliner.document, self.env, node, is_ref=False)
141 
142     def create_xref_node(self) -> Tuple[List[Node], List[system_message]]:
143         target = self.target
144         title = self.title
145         if self.lowercase:
146             target = target.lower()
147         if self.fix_parens:
148             title, target = self.update_title_and_target(title, target)
149 
150         # create the reference node
151         options = {'refdoc': self.env.docname,
152                    'refdomain': self.refdomain,
153                    'reftype': self.reftype,
154                    'refexplicit': self.has_explicit_title,
155                    'refwarn': self.warn_dangling}
156         refnode = self.nodeclass(self.rawtext, **options)
157         self.set_source_info(refnode)
158 
159         # determine the target and title for the class
160         title, target = self.process_link(self.env, refnode, self.has_explicit_title,
161                                           title, target)
162         refnode['reftarget'] = target
163         refnode += self.innernodeclass(self.rawtext, title, classes=self.classes)
164 
165         return self.result_nodes(self.inliner.document, self.env, refnode, is_ref=True)
166 
167     # methods that can be overwritten
168 
169     def process_link(self, env: "BuildEnvironment", refnode: Element, has_explicit_title: bool,
170                      title: str, target: str) -> Tuple[str, str]:
171         """Called after parsing title and target text, and creating the
172         reference node (given in *refnode*).  This method can alter the
173         reference node and must return a new (or the same) ``(title, target)``
174         tuple.
175         """
176         return title, ws_re.sub(' ', target)
177 
178     def result_nodes(self, document: nodes.document, env: "BuildEnvironment", node: Element,
179                      is_ref: bool) -> Tuple[List[Node], List[system_message]]:
180         """Called before returning the finished nodes.  *node* is the reference
181         node if one was created (*is_ref* is then true), else the content node.
182         This method can add other nodes and must return a ``(nodes, messages)``
183         tuple (the usual return value of a role function).
184         """
185         return [node], []
186 
187 
188 class AnyXRefRole(XRefRole):
189     def process_link(self, env: "BuildEnvironment", refnode: Element, has_explicit_title: bool,
190                      title: str, target: str) -> Tuple[str, str]:
191         result = super().process_link(env, refnode, has_explicit_title, title, target)
192         # add all possible context info (i.e. std:program, py:module etc.)
193         refnode.attributes.update(env.ref_context)
194         return result
195 
196 
197 def indexmarkup_role(typ: str, rawtext: str, text: str, lineno: int, inliner: Inliner,
198                      options: Dict = {}, content: List[str] = []
199                      ) -> Tuple[List[Node], List[system_message]]:
200     """Role for PEP/RFC references that generate an index entry."""
201     warnings.warn('indexmarkup_role() is deprecated.  Please use PEP or RFC class instead.',
202                   RemovedInSphinx40Warning, stacklevel=2)
203     env = inliner.document.settings.env
204     if not typ:
205         assert env.temp_data['default_role']
206         typ = env.temp_data['default_role'].lower()
207     else:
208         typ = typ.lower()
209 
210     has_explicit_title, title, target = split_explicit_title(text)
211     title = utils.unescape(title)
212     target = utils.unescape(target)
213     targetid = 'index-%s' % env.new_serialno('index')
214     indexnode = addnodes.index()
215     targetnode = nodes.target('', '', ids=[targetid])
216     inliner.document.note_explicit_target(targetnode)
217     if typ == 'pep':
218         indexnode['entries'] = [
219             ('single', _('Python Enhancement Proposals; PEP %s') % target,
220              targetid, '', None)]
221         anchor = ''
222         anchorindex = target.find('#')
223         if anchorindex > 0:
224             target, anchor = target[:anchorindex], target[anchorindex:]
225         if not has_explicit_title:
226             title = "PEP " + utils.unescape(title)
227         try:
228             pepnum = int(target)
229         except ValueError:
230             msg = inliner.reporter.error('invalid PEP number %s' % target,
231                                          line=lineno)
232             prb = inliner.problematic(rawtext, rawtext, msg)
233             return [prb], [msg]
234         ref = inliner.document.settings.pep_base_url + 'pep-%04d' % pepnum
235         sn = nodes.strong(title, title)
236         rn = nodes.reference('', '', internal=False, refuri=ref + anchor,
237                              classes=[typ])
238         rn += sn
239         return [indexnode, targetnode, rn], []
240     elif typ == 'rfc':
241         indexnode['entries'] = [
242             ('single', 'RFC; RFC %s' % target, targetid, '', None)]
243         anchor = ''
244         anchorindex = target.find('#')
245         if anchorindex > 0:
246             target, anchor = target[:anchorindex], target[anchorindex:]
247         if not has_explicit_title:
248             title = "RFC " + utils.unescape(title)
249         try:
250             rfcnum = int(target)
251         except ValueError:
252             msg = inliner.reporter.error('invalid RFC number %s' % target,
253                                          line=lineno)
254             prb = inliner.problematic(rawtext, rawtext, msg)
255             return [prb], [msg]
256         ref = inliner.document.settings.rfc_base_url + inliner.rfc_url % rfcnum
257         sn = nodes.strong(title, title)
258         rn = nodes.reference('', '', internal=False, refuri=ref + anchor,
259                              classes=[typ])
260         rn += sn
261         return [indexnode, targetnode, rn], []
262     else:
263         raise ValueError('unknown role type: %s' % typ)
264 
265 
266 class PEP(ReferenceRole):
267     def run(self) -> Tuple[List[Node], List[system_message]]:
268         target_id = 'index-%s' % self.env.new_serialno('index')
269         entries = [('single', _('Python Enhancement Proposals; PEP %s') % self.target,
270                     target_id, '', None)]
271 
272         index = addnodes.index(entries=entries)
273         target = nodes.target('', '', ids=[target_id])
274         self.inliner.document.note_explicit_target(target)
275 
276         try:
277             refuri = self.build_uri()
278             reference = nodes.reference('', '', internal=False, refuri=refuri, classes=['pep'])
279             if self.has_explicit_title:
280                 reference += nodes.strong(self.title, self.title)
281             else:
282                 title = "PEP " + self.title
283                 reference += nodes.strong(title, title)
284         except ValueError:
285             msg = self.inliner.reporter.error('invalid PEP number %s' % self.target,
286                                               line=self.lineno)
287             prb = self.inliner.problematic(self.rawtext, self.rawtext, msg)
288             return [prb], [msg]
289 
290         return [index, target, reference], []
291 
292     def build_uri(self) -> str:
293         base_url = self.inliner.document.settings.pep_base_url
294         ret = self.target.split('#', 1)
295         if len(ret) == 2:
296             return base_url + 'pep-%04d#%s' % (int(ret[0]), ret[1])
297         else:
298             return base_url + 'pep-%04d' % int(ret[0])
299 
300 
301 class RFC(ReferenceRole):
302     def run(self) -> Tuple[List[Node], List[system_message]]:
303         target_id = 'index-%s' % self.env.new_serialno('index')
304         entries = [('single', 'RFC; RFC %s' % self.target, target_id, '', None)]
305 
306         index = addnodes.index(entries=entries)
307         target = nodes.target('', '', ids=[target_id])
308         self.inliner.document.note_explicit_target(target)
309 
310         try:
311             refuri = self.build_uri()
312             reference = nodes.reference('', '', internal=False, refuri=refuri, classes=['rfc'])
313             if self.has_explicit_title:
314                 reference += nodes.strong(self.title, self.title)
315             else:
316                 title = "RFC " + self.title
317                 reference += nodes.strong(title, title)
318         except ValueError:
319             msg = self.inliner.reporter.error('invalid RFC number %s' % self.target,
320                                               line=self.lineno)
321             prb = self.inliner.problematic(self.rawtext, self.rawtext, msg)
322             return [prb], [msg]
323 
324         return [index, target, reference], []
325 
326     def build_uri(self) -> str:
327         base_url = self.inliner.document.settings.rfc_base_url
328         ret = self.target.split('#', 1)
329         if len(ret) == 2:
330             return base_url + self.inliner.rfc_url % int(ret[0]) + '#' + ret[1]
331         else:
332             return base_url + self.inliner.rfc_url % int(ret[0])
333 
334 
335 _amp_re = re.compile(r'(?<!&)&(?![&\s])')
336 
337 
338 def menusel_role(typ: str, rawtext: str, text: str, lineno: int, inliner: Inliner,
339                  options: Dict = {}, content: List[str] = []
340                  ) -> Tuple[List[Node], List[system_message]]:
341     warnings.warn('menusel_role() is deprecated. '
342                   'Please use MenuSelection or GUILabel class instead.',
343                   RemovedInSphinx40Warning, stacklevel=2)
344     env = inliner.document.settings.env
345     if not typ:
346         assert env.temp_data['default_role']
347         typ = env.temp_data['default_role'].lower()
348     else:
349         typ = typ.lower()
350 
351     text = utils.unescape(text)
352     if typ == 'menuselection':
353         text = text.replace('-->', '\N{TRIANGULAR BULLET}')
354     spans = _amp_re.split(text)
355 
356     node = nodes.inline(rawtext=rawtext)
357     for i, span in enumerate(spans):
358         span = span.replace('&&', '&')
359         if i == 0:
360             if len(span) > 0:
361                 textnode = nodes.Text(span)
362                 node += textnode
363             continue
364         accel_node = nodes.inline()
365         letter_node = nodes.Text(span[0])
366         accel_node += letter_node
367         accel_node['classes'].append('accelerator')
368         node += accel_node
369         textnode = nodes.Text(span[1:])
370         node += textnode
371 
372     node['classes'].append(typ)
373     return [node], []
374 
375 
376 class GUILabel(SphinxRole):
377     amp_re = re.compile(r'(?<!&)&(?![&\s])')
378 
379     def run(self) -> Tuple[List[Node], List[system_message]]:
380         node = nodes.inline(rawtext=self.rawtext, classes=[self.name])
381         spans = self.amp_re.split(self.text)
382         node += nodes.Text(spans.pop(0))
383         for span in spans:
384             span = span.replace('&&', '&')
385 
386             letter = nodes.Text(span[0])
387             accelerator = nodes.inline('', '', letter, classes=['accelerator'])
388             node += accelerator
389             node += nodes.Text(span[1:])
390 
391         return [node], []
392 
393 
394 class MenuSelection(GUILabel):
395     BULLET_CHARACTER = '\N{TRIANGULAR BULLET}'
396 
397     def run(self) -> Tuple[List[Node], List[system_message]]:
398         self.text = self.text.replace('-->', self.BULLET_CHARACTER)
399         return super().run()
400 
401 
402 _litvar_re = re.compile('{([^}]+)}')
403 parens_re = re.compile(r'(\\*{|\\*})')
404 
405 
406 def emph_literal_role(typ: str, rawtext: str, text: str, lineno: int, inliner: Inliner,
407                       options: Dict = {}, content: List[str] = []
408                       ) -> Tuple[List[Node], List[system_message]]:
409     warnings.warn('emph_literal_role() is deprecated. '
410                   'Please use EmphasizedLiteral class instead.',
411                   RemovedInSphinx40Warning, stacklevel=2)
412     env = inliner.document.settings.env
413     if not typ:
414         assert env.temp_data['default_role']
415         typ = env.temp_data['default_role'].lower()
416     else:
417         typ = typ.lower()
418 
419     retnode = nodes.literal(role=typ.lower(), classes=[typ])
420     parts = list(parens_re.split(utils.unescape(text)))
421     stack = ['']
422     for part in parts:
423         matched = parens_re.match(part)
424         if matched:
425             backslashes = len(part) - 1
426             if backslashes % 2 == 1:    # escaped
427                 stack[-1] += "\\" * int((backslashes - 1) / 2) + part[-1]
428             elif part[-1] == '{':       # rparen
429                 stack[-1] += "\\" * int(backslashes / 2)
430                 if len(stack) >= 2 and stack[-2] == "{":
431                     # nested
432                     stack[-1] += "{"
433                 else:
434                     # start emphasis
435                     stack.append('{')
436                     stack.append('')
437             else:                       # lparen
438                 stack[-1] += "\\" * int(backslashes / 2)
439                 if len(stack) == 3 and stack[1] == "{" and len(stack[2]) > 0:
440                     # emphasized word found
441                     if stack[0]:
442                         retnode += nodes.Text(stack[0], stack[0])
443                     retnode += nodes.emphasis(stack[2], stack[2])
444                     stack = ['']
445                 else:
446                     # emphasized word not found; the rparen is not a special symbol
447                     stack.append('}')
448                     stack = [''.join(stack)]
449         else:
450             stack[-1] += part
451     if ''.join(stack):
452         # remaining is treated as Text
453         text = ''.join(stack)
454         retnode += nodes.Text(text, text)
455 
456     return [retnode], []
457 
458 
459 class EmphasizedLiteral(SphinxRole):
460     parens_re = re.compile(r'(\\\\|\\{|\\}|{|})')
461 
462     def run(self) -> Tuple[List[Node], List[system_message]]:
463         children = self.parse(self.text)
464         node = nodes.literal(self.rawtext, '', *children,
465                              role=self.name.lower(), classes=[self.name])
466 
467         return [node], []
468 
469     def parse(self, text: str) -> List[Node]:
470         result = []  # type: List[Node]
471 
472         stack = ['']
473         for part in self.parens_re.split(text):
474             if part == '\\\\':  # escaped backslash
475                 stack[-1] += '\\'
476             elif part == '{':
477                 if len(stack) >= 2 and stack[-2] == "{":  # nested
478                     stack[-1] += "{"
479                 else:
480                     # start emphasis
481                     stack.append('{')
482                     stack.append('')
483             elif part == '}':
484                 if len(stack) == 3 and stack[1] == "{" and len(stack[2]) > 0:
485                     # emphasized word found
486                     if stack[0]:
487                         result.append(nodes.Text(stack[0], stack[0]))
488                     result.append(nodes.emphasis(stack[2], stack[2]))
489                     stack = ['']
490                 else:
491                     # emphasized word not found; the rparen is not a special symbol
492                     stack.append('}')
493                     stack = [''.join(stack)]
494             elif part == '\\{':  # escaped left-brace
495                 stack[-1] += '{'
496             elif part == '\\}':  # escaped right-brace
497                 stack[-1] += '}'
498             else:  # others (containing escaped braces)
499                 stack[-1] += part
500 
501         if ''.join(stack):
502             # remaining is treated as Text
503             text = ''.join(stack)
504             result.append(nodes.Text(text, text))
505 
506         return result
507 
508 
509 _abbr_re = re.compile(r'\((.*)\)$', re.S)
510 
511 
512 def abbr_role(typ: str, rawtext: str, text: str, lineno: int, inliner: Inliner,
513               options: Dict = {}, content: List[str] = []
514               ) -> Tuple[List[Node], List[system_message]]:
515     warnings.warn('abbr_role() is deprecated.  Please use Abbrevation class instead.',
516                   RemovedInSphinx40Warning, stacklevel=2)
517     text = utils.unescape(text)
518     m = _abbr_re.search(text)
519     if m is None:
520         return [nodes.abbreviation(text, text, **options)], []
521     abbr = text[:m.start()].strip()
522     expl = m.group(1)
523     options = options.copy()
524     options['explanation'] = expl
525     return [nodes.abbreviation(abbr, abbr, **options)], []
526 
527 
528 class Abbreviation(SphinxRole):
529     abbr_re = re.compile(r'\((.*)\)$', re.S)
530 
531     def run(self) -> Tuple[List[Node], List[system_message]]:
532         options = self.options.copy()
533         matched = self.abbr_re.search(self.text)
534         if matched:
535             text = self.text[:matched.start()].strip()
536             options['explanation'] = matched.group(1)
537         else:
538             text = self.text
539 
540         return [nodes.abbreviation(self.rawtext, text, **options)], []
541 
542 
543 def index_role(typ: str, rawtext: str, text: str, lineno: int, inliner: Inliner,
544                options: Dict = {}, content: List[str] = []
545                ) -> Tuple[List[Node], List[system_message]]:
546     warnings.warn('index_role() is deprecated.  Please use Index class instead.',
547                   RemovedInSphinx40Warning, stacklevel=2)
548     # create new reference target
549     env = inliner.document.settings.env
550     targetid = 'index-%s' % env.new_serialno('index')
551     targetnode = nodes.target('', '', ids=[targetid])
552     # split text and target in role content
553     has_explicit_title, title, target = split_explicit_title(text)
554     title = utils.unescape(title)
555     target = utils.unescape(target)
556     # if an explicit target is given, we can process it as a full entry
557     if has_explicit_title:
558         entries = process_index_entry(target, targetid)
559     # otherwise we just create a "single" entry
560     else:
561         # but allow giving main entry
562         main = ''
563         if target.startswith('!'):
564             target = target[1:]
565             title = title[1:]
566             main = 'main'
567         entries = [('single', target, targetid, main, None)]
568     indexnode = addnodes.index()
569     indexnode['entries'] = entries
570     set_role_source_info(inliner, lineno, indexnode)
571     textnode = nodes.Text(title, title)
572     return [indexnode, targetnode, textnode], []
573 
574 
575 class Index(ReferenceRole):
576     def run(self) -> Tuple[List[Node], List[system_message]]:
577         warnings.warn('Index role is deprecated.', RemovedInSphinx40Warning, stacklevel=2)
578         target_id = 'index-%s' % self.env.new_serialno('index')
579         if self.has_explicit_title:
580             # if an explicit target is given, process it as a full entry
581             title = self.title
582             entries = process_index_entry(self.target, target_id)
583         else:
584             # otherwise we just create a single entry
585             if self.target.startswith('!'):
586                 title = self.title[1:]
587                 entries = [('single', self.target[1:], target_id, 'main', None)]
588             else:
589                 title = self.title
590                 entries = [('single', self.target, target_id, '', None)]
591 
592         index = addnodes.index(entries=entries)
593         target = nodes.target('', '', ids=[target_id])
594         text = nodes.Text(title, title)
595         self.set_source_info(index)
596         return [index, target, text], []
597 
598 
599 specific_docroles = {
600     # links to download references
601     'download': XRefRole(nodeclass=addnodes.download_reference),
602     # links to anything
603     'any': AnyXRefRole(warn_dangling=True),
604 
605     'pep': PEP(),
606     'rfc': RFC(),
607     'guilabel': GUILabel(),
608     'menuselection': MenuSelection(),
609     'file': EmphasizedLiteral(),
610     'samp': EmphasizedLiteral(),
611     'abbr': Abbreviation(),
612 }  # type: Dict[str, RoleFunction]
613 
614 
615 def setup(app: "Sphinx") -> Dict[str, Any]:
616     from docutils.parsers.rst import roles
617 
618     for rolename, nodeclass in generic_docroles.items():
619         generic = roles.GenericRole(rolename, nodeclass)
620         role = roles.CustomRole(rolename, generic, {'classes': [rolename]})
621         roles.register_local_role(rolename, role)
622 
623     for rolename, func in specific_docroles.items():
624         roles.register_local_role(rolename, func)
625 
626     return {
627         'version': 'builtin',
628         'parallel_read_safe': True,
629         'parallel_write_safe': True,
630     }

</code><intended_behavior>This file likely contains definitions or mechanisms for parsing and handling roles, including the `:kbd:` role. The intended behavior here would be to adjust or extend the handling of the `:kbd:` role to include a mechanism for detecting compound keystrokes and applying a distinct CSS class (e.g., `compound`) to the parent `<kbd>` element in such cases while preserving the styling and functionality for single keystrokes.</intended_behavior>, <file>sphinx/builders/html/__init__.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2     sphinx.builders.html
3     ~~~~~~~~~~~~~~~~~~~~
4 
5     Several HTML builders.
6 
7     :copyright: Copyright 2007-2020 by the Sphinx team, see AUTHORS.
8     :license: BSD, see LICENSE for details.
9 """
10 
11 import html
12 import os
13 import posixpath
14 import re
15 import sys
16 import warnings
17 from os import path
18 from typing import IO, Any, Dict, Iterable, Iterator, List, Set, Tuple
19 from urllib.parse import quote
20 
21 from docutils import nodes
22 from docutils.core import publish_parts
23 from docutils.frontend import OptionParser
24 from docutils.io import DocTreeInput, StringOutput
25 from docutils.nodes import Node
26 from docutils.utils import relative_path
27 
28 from sphinx import __display_version__, package_dir
29 from sphinx.application import Sphinx
30 from sphinx.builders import Builder
31 from sphinx.config import ENUM, Config
32 from sphinx.deprecation import RemovedInSphinx40Warning
33 from sphinx.domains import Domain, Index, IndexEntry
34 from sphinx.environment.adapters.asset import ImageAdapter
35 from sphinx.environment.adapters.indexentries import IndexEntries
36 from sphinx.environment.adapters.toctree import TocTree
37 from sphinx.errors import ConfigError, ThemeError
38 from sphinx.highlighting import PygmentsBridge
39 from sphinx.locale import _, __
40 from sphinx.search import js_index
41 from sphinx.theming import HTMLThemeFactory
42 from sphinx.util import logging, md5, progress_message, status_iterator
43 from sphinx.util.docutils import is_html5_writer_available, new_document
44 from sphinx.util.fileutil import copy_asset
45 from sphinx.util.i18n import format_date
46 from sphinx.util.inventory import InventoryFile
47 from sphinx.util.matching import DOTFILES, Matcher, patmatch
48 from sphinx.util.osutil import copyfile, ensuredir, os_path, relative_uri
49 from sphinx.util.tags import Tags
50 from sphinx.writers.html import HTMLTranslator, HTMLWriter
51 
52 if False:
53     # For type annotation
54     from typing import Type  # for python3.5.1
55 
56 
57 # HTML5 Writer is available or not
58 if is_html5_writer_available():
59     from sphinx.writers.html5 import HTML5Translator
60     html5_ready = True
61 else:
62     html5_ready = False
63 
64 #: the filename for the inventory of objects
65 INVENTORY_FILENAME = 'objects.inv'
66 
67 logger = logging.getLogger(__name__)
68 return_codes_re = re.compile('[\r\n]+')
69 
70 
71 def get_stable_hash(obj: Any) -> str:
72     """
73     Return a stable hash for a Python data structure.  We can't just use
74     the md5 of str(obj) since for example dictionary items are enumerated
75     in unpredictable order due to hash randomization in newer Pythons.
76     """
77     if isinstance(obj, dict):
78         return get_stable_hash(list(obj.items()))
79     elif isinstance(obj, (list, tuple)):
80         obj = sorted(get_stable_hash(o) for o in obj)
81     return md5(str(obj).encode()).hexdigest()
82 
83 
84 class Stylesheet(str):
85     """A metadata of stylesheet.
86 
87     To keep compatibility with old themes, an instance of stylesheet behaves as
88     its filename (str).
89     """
90 
91     attributes = None   # type: Dict[str, str]
92     filename = None     # type: str
93 
94     def __new__(cls, filename: str, *args: str, **attributes: str) -> "Stylesheet":
95         self = str.__new__(cls, filename)  # type: ignore
96         self.filename = filename
97         self.attributes = attributes
98         self.attributes.setdefault('rel', 'stylesheet')
99         self.attributes.setdefault('type', 'text/css')
100         if args:  # old style arguments (rel, title)
101             self.attributes['rel'] = args[0]
102             self.attributes['title'] = args[1]
103 
104         return self
105 
106 
107 class JavaScript(str):
108     """A metadata of javascript file.
109 
110     To keep compatibility with old themes, an instance of javascript behaves as
111     its filename (str).
112     """
113 
114     attributes = None   # type: Dict[str, str]
115     filename = None     # type: str
116 
117     def __new__(cls, filename: str, **attributes: str) -> "JavaScript":
118         self = str.__new__(cls, filename)  # type: ignore
119         self.filename = filename
120         self.attributes = attributes
121 
122         return self
123 
124 
125 class BuildInfo:
126     """buildinfo file manipulator.
127 
128     HTMLBuilder and its family are storing their own envdata to ``.buildinfo``.
129     This class is a manipulator for the file.
130     """
131 
132     @classmethod
133     def load(cls, f: IO) -> "BuildInfo":
134         try:
135             lines = f.readlines()
136             assert lines[0].rstrip() == '# Sphinx build info version 1'
137             assert lines[2].startswith('config: ')
138             assert lines[3].startswith('tags: ')
139 
140             build_info = BuildInfo()
141             build_info.config_hash = lines[2].split()[1].strip()
142             build_info.tags_hash = lines[3].split()[1].strip()
143             return build_info
144         except Exception as exc:
145             raise ValueError(__('build info file is broken: %r') % exc) from exc
146 
147     def __init__(self, config: Config = None, tags: Tags = None, config_categories: List[str] = []) -> None:  # NOQA
148         self.config_hash = ''
149         self.tags_hash = ''
150 
151         if config:
152             values = {c.name: c.value for c in config.filter(config_categories)}
153             self.config_hash = get_stable_hash(values)
154 
155         if tags:
156             self.tags_hash = get_stable_hash(sorted(tags))
157 
158     def __eq__(self, other: "BuildInfo") -> bool:  # type: ignore
159         return (self.config_hash == other.config_hash and
160                 self.tags_hash == other.tags_hash)
161 
162     def dump(self, f: IO) -> None:
163         f.write('# Sphinx build info version 1\n'
164                 '# This file hashes the configuration used when building these files.'
165                 ' When it is not found, a full rebuild will be done.\n'
166                 'config: %s\n'
167                 'tags: %s\n' %
168                 (self.config_hash, self.tags_hash))
169 
170 
171 class StandaloneHTMLBuilder(Builder):
172     """
173     Builds standalone HTML docs.
174     """
175     name = 'html'
176     format = 'html'
177     epilog = __('The HTML pages are in %(outdir)s.')
178 
179     copysource = True
180     allow_parallel = True
181     out_suffix = '.html'
182     link_suffix = '.html'  # defaults to matching out_suffix
183     indexer_format = js_index  # type: Any
184     indexer_dumps_unicode = True
185     # create links to original images from images [True/False]
186     html_scaled_image_link = True
187     supported_image_types = ['image/svg+xml', 'image/png',
188                              'image/gif', 'image/jpeg']
189     supported_remote_images = True
190     supported_data_uri_images = True
191     searchindex_filename = 'searchindex.js'
192     add_permalinks = True
193     allow_sharp_as_current_path = True
194     embedded = False  # for things like HTML help or Qt help: suppresses sidebar
195     search = True  # for things like HTML help and Apple help: suppress search
196     use_index = False
197     download_support = True  # enable download role
198 
199     imgpath = None          # type: str
200     domain_indices = []     # type: List[Tuple[str, Type[Index], List[Tuple[str, List[IndexEntry]]], bool]]  # NOQA
201 
202     def __init__(self, app: Sphinx) -> None:
203         super().__init__(app)
204 
205         # CSS files
206         self.css_files = []  # type: List[Dict[str, str]]
207 
208         # JS files
209         self.script_files = []  # type: List[JavaScript]
210 
211     def init(self) -> None:
212         self.build_info = self.create_build_info()
213         # basename of images directory
214         self.imagedir = '_images'
215         # section numbers for headings in the currently visited document
216         self.secnumbers = {}  # type: Dict[str, Tuple[int, ...]]
217         # currently written docname
218         self.current_docname = None  # type: str
219 
220         self.init_templates()
221         self.init_highlighter()
222         self.init_css_files()
223         self.init_js_files()
224 
225         html_file_suffix = self.get_builder_config('file_suffix', 'html')
226         if html_file_suffix is not None:
227             self.out_suffix = html_file_suffix
228 
229         html_link_suffix = self.get_builder_config('link_suffix', 'html')
230         if html_link_suffix is not None:
231             self.link_suffix = html_link_suffix
232         else:
233             self.link_suffix = self.out_suffix
234 
235         self.use_index = self.get_builder_config('use_index', 'html')
236 
237     def create_build_info(self) -> BuildInfo:
238         return BuildInfo(self.config, self.tags, ['html'])
239 
240     def _get_translations_js(self) -> str:
241         candidates = [path.join(dir, self.config.language,
242                                 'LC_MESSAGES', 'sphinx.js')
243                       for dir in self.config.locale_dirs] + \
244                      [path.join(package_dir, 'locale', self.config.language,
245                                 'LC_MESSAGES', 'sphinx.js'),
246                       path.join(sys.prefix, 'share/sphinx/locale',
247                                 self.config.language, 'sphinx.js')]
248 
249         for jsfile in candidates:
250             if path.isfile(jsfile):
251                 return jsfile
252         return None
253 
254     def get_theme_config(self) -> Tuple[str, Dict]:
255         return self.config.html_theme, self.config.html_theme_options
256 
257     def init_templates(self) -> None:
258         theme_factory = HTMLThemeFactory(self.app)
259         themename, themeoptions = self.get_theme_config()
260         self.theme = theme_factory.create(themename)
261         self.theme_options = themeoptions.copy()
262         self.create_template_bridge()
263         self.templates.init(self, self.theme)
264 
265     def init_highlighter(self) -> None:
266         # determine Pygments style and create the highlighter
267         if self.config.pygments_style is not None:
268             style = self.config.pygments_style
269         elif self.theme:
270             style = self.theme.get_config('theme', 'pygments_style', 'none')
271         else:
272             style = 'sphinx'
273         self.highlighter = PygmentsBridge('html', style)
274 
275         if self.theme:
276             dark_style = self.theme.get_config('theme', 'pygments_dark_style', None)
277         else:
278             dark_style = None
279 
280         if dark_style is not None:
281             self.dark_highlighter = PygmentsBridge('html', dark_style)
282             self.add_css_file('pygments_dark.css',
283                               media='(prefers-color-scheme: dark)',
284                               id='pygments_dark_css')
285         else:
286             self.dark_highlighter = None
287 
288     def init_css_files(self) -> None:
289         for filename, attrs in self.app.registry.css_files:
290             self.add_css_file(filename, **attrs)
291 
292         for filename, attrs in self.get_builder_config('css_files', 'html'):
293             self.add_css_file(filename, **attrs)
294 
295     def add_css_file(self, filename: str, **kwargs: str) -> None:
296         if '://' not in filename:
297             filename = posixpath.join('_static', filename)
298 
299         self.css_files.append(Stylesheet(filename, **kwargs))  # type: ignore
300 
301     def init_js_files(self) -> None:
302         self.add_js_file('jquery.js')
303         self.add_js_file('underscore.js')
304         self.add_js_file('doctools.js')
305 
306         for filename, attrs in self.app.registry.js_files:
307             self.add_js_file(filename, **attrs)
308 
309         for filename, attrs in self.get_builder_config('js_files', 'html'):
310             self.add_js_file(filename, **attrs)
311 
312         if self.config.language and self._get_translations_js():
313             self.add_js_file('translations.js')
314 
315     def add_js_file(self, filename: str, **kwargs: str) -> None:
316         if filename and '://' not in filename:
317             filename = posixpath.join('_static', filename)
318 
319         self.script_files.append(JavaScript(filename, **kwargs))
320 
321     @property
322     def default_translator_class(self) -> "Type[nodes.NodeVisitor]":  # type: ignore
323         if not html5_ready or self.config.html4_writer:
324             return HTMLTranslator
325         else:
326             return HTML5Translator
327 
328     @property
329     def math_renderer_name(self) -> str:
330         name = self.get_builder_config('math_renderer', 'html')
331         if name is not None:
332             # use given name
333             return name
334         else:
335             # not given: choose a math_renderer from registered ones as possible
336             renderers = list(self.app.registry.html_inline_math_renderers)
337             if len(renderers) == 1:
338                 # only default math_renderer (mathjax) is registered
339                 return renderers[0]
340             elif len(renderers) == 2:
341                 # default and another math_renderer are registered; prior the another
342                 renderers.remove('mathjax')
343                 return renderers[0]
344             else:
345                 # many math_renderers are registered. can't choose automatically!
346                 return None
347 
348     def get_outdated_docs(self) -> Iterator[str]:
349         try:
350             with open(path.join(self.outdir, '.buildinfo')) as fp:
351                 buildinfo = BuildInfo.load(fp)
352 
353             if self.build_info != buildinfo:
354                 yield from self.env.found_docs
355                 return
356         except ValueError as exc:
357             logger.warning(__('Failed to read build info file: %r'), exc)
358         except OSError:
359             # ignore errors on reading
360             pass
361 
362         if self.templates:
363             template_mtime = self.templates.newest_template_mtime()
364         else:
365             template_mtime = 0
366         for docname in self.env.found_docs:
367             if docname not in self.env.all_docs:
368                 yield docname
369                 continue
370             targetname = self.get_outfilename(docname)
371             try:
372                 targetmtime = path.getmtime(targetname)
373             except Exception:
374                 targetmtime = 0
375             try:
376                 srcmtime = max(path.getmtime(self.env.doc2path(docname)),
377                                template_mtime)
378                 if srcmtime > targetmtime:
379                     yield docname
380             except OSError:
381                 # source doesn't exist anymore
382                 pass
383 
384     def get_asset_paths(self) -> List[str]:
385         return self.config.html_extra_path + self.config.html_static_path
386 
387     def render_partial(self, node: Node) -> Dict[str, str]:
388         """Utility: Render a lone doctree node."""
389         if node is None:
390             return {'fragment': ''}
391         doc = new_document('<partial node>')
392         doc.append(node)
393 
394         writer = HTMLWriter(self)
395         return publish_parts(reader_name='doctree',
396                              writer=writer,
397                              source_class=DocTreeInput,
398                              settings_overrides={'output_encoding': 'unicode'},
399                              source=doc)
400 
401     def prepare_writing(self, docnames: Set[str]) -> None:
402         # create the search indexer
403         self.indexer = None
404         if self.search:
405             from sphinx.search import IndexBuilder
406             lang = self.config.html_search_language or self.config.language
407             if not lang:
408                 lang = 'en'
409             self.indexer = IndexBuilder(self.env, lang,
410                                         self.config.html_search_options,
411                                         self.config.html_search_scorer)
412             self.load_indexer(docnames)
413 
414         self.docwriter = HTMLWriter(self)
415         self.docsettings = OptionParser(
416             defaults=self.env.settings,
417             components=(self.docwriter,),
418             read_config_files=True).get_default_values()  # type: Any
419         self.docsettings.compact_lists = bool(self.config.html_compact_lists)
420 
421         # determine the additional indices to include
422         self.domain_indices = []
423         # html_domain_indices can be False/True or a list of index names
424         indices_config = self.config.html_domain_indices
425         if indices_config:
426             for domain_name in sorted(self.env.domains):
427                 domain = None  # type: Domain
428                 domain = self.env.domains[domain_name]
429                 for indexcls in domain.indices:
430                     indexname = '%s-%s' % (domain.name, indexcls.name)
431                     if isinstance(indices_config, list):
432                         if indexname not in indices_config:
433                             continue
434                     content, collapse = indexcls(domain).generate()
435                     if content:
436                         self.domain_indices.append(
437                             (indexname, indexcls, content, collapse))
438 
439         # format the "last updated on" string, only once is enough since it
440         # typically doesn't include the time of day
441         lufmt = self.config.html_last_updated_fmt
442         if lufmt is not None:
443             self.last_updated = format_date(lufmt or _('%b %d, %Y'),
444                                             language=self.config.language)
445         else:
446             self.last_updated = None
447 
448         logo = path.basename(self.config.html_logo) if self.config.html_logo else ''
449         favicon = path.basename(self.config.html_favicon) if self.config.html_favicon else ''
450 
451         if not isinstance(self.config.html_use_opensearch, str):
452             logger.warning(__('html_use_opensearch config value must now be a string'))
453 
454         self.relations = self.env.collect_relations()
455 
456         rellinks = []  # type: List[Tuple[str, str, str, str]]
457         if self.use_index:
458             rellinks.append(('genindex', _('General Index'), 'I', _('index')))
459         for indexname, indexcls, content, collapse in self.domain_indices:
460             # if it has a short name
461             if indexcls.shortname:
462                 rellinks.append((indexname, indexcls.localname,
463                                  '', indexcls.shortname))
464 
465         if self.config.html_style is not None:
466             stylename = self.config.html_style
467         elif self.theme:
468             stylename = self.theme.get_config('theme', 'stylesheet')
469         else:
470             stylename = 'default.css'
471 
472         self.globalcontext = {
473             'embedded': self.embedded,
474             'project': self.config.project,
475             'release': return_codes_re.sub('', self.config.release),
476             'version': self.config.version,
477             'last_updated': self.last_updated,
478             'copyright': self.config.copyright,
479             'master_doc': self.config.master_doc,
480             'use_opensearch': self.config.html_use_opensearch,
481             'docstitle': self.config.html_title,
482             'shorttitle': self.config.html_short_title,
483             'show_copyright': self.config.html_show_copyright,
484             'show_sphinx': self.config.html_show_sphinx,
485             'has_source': self.config.html_copy_source,
486             'show_source': self.config.html_show_sourcelink,
487             'sourcelink_suffix': self.config.html_sourcelink_suffix,
488             'file_suffix': self.out_suffix,
489             'link_suffix': self.link_suffix,
490             'script_files': self.script_files,
491             'language': self.config.language,
492             'css_files': self.css_files,
493             'sphinx_version': __display_version__,
494             'style': stylename,
495             'rellinks': rellinks,
496             'builder': self.name,
497             'parents': [],
498             'logo': logo,
499             'favicon': favicon,
500             'html5_doctype': html5_ready and not self.config.html4_writer,
501         }
502         if self.theme:
503             self.globalcontext.update(
504                 ('theme_' + key, val) for (key, val) in
505                 self.theme.get_options(self.theme_options).items())
506         self.globalcontext.update(self.config.html_context)
507 
508     def get_doc_context(self, docname: str, body: str, metatags: str) -> Dict[str, Any]:
509         """Collect items for the template context of a page."""
510         # find out relations
511         prev = next = None
512         parents = []
513         rellinks = self.globalcontext['rellinks'][:]
514         related = self.relations.get(docname)
515         titles = self.env.titles
516         if related and related[2]:
517             try:
518                 next = {
519                     'link': self.get_relative_uri(docname, related[2]),
520                     'title': self.render_partial(titles[related[2]])['title']
521                 }
522                 rellinks.append((related[2], next['title'], 'N', _('next')))
523             except KeyError:
524                 next = None
525         if related and related[1]:
526             try:
527                 prev = {
528                     'link': self.get_relative_uri(docname, related[1]),
529                     'title': self.render_partial(titles[related[1]])['title']
530                 }
531                 rellinks.append((related[1], prev['title'], 'P', _('previous')))
532             except KeyError:
533                 # the relation is (somehow) not in the TOC tree, handle
534                 # that gracefully
535                 prev = None
536         while related and related[0]:
537             try:
538                 parents.append(
539                     {'link': self.get_relative_uri(docname, related[0]),
540                      'title': self.render_partial(titles[related[0]])['title']})
541             except KeyError:
542                 pass
543             related = self.relations.get(related[0])
544         if parents:
545             # remove link to the master file; we have a generic
546             # "back to index" link already
547             parents.pop()
548         parents.reverse()
549 
550         # title rendered as HTML
551         title_node = self.env.longtitles.get(docname)
552         title = self.render_partial(title_node)['title'] if title_node else ''
553 
554         # Suffix for the document
555         source_suffix = self.env.doc2path(docname, False)[len(docname):]
556 
557         # the name for the copied source
558         if self.config.html_copy_source:
559             sourcename = docname + source_suffix
560             if source_suffix != self.config.html_sourcelink_suffix:
561                 sourcename += self.config.html_sourcelink_suffix
562         else:
563             sourcename = ''
564 
565         # metadata for the document
566         meta = self.env.metadata.get(docname)
567 
568         # local TOC and global TOC tree
569         self_toc = TocTree(self.env).get_toc_for(docname, self)
570         toc = self.render_partial(self_toc)['fragment']
571 
572         return {
573             'parents': parents,
574             'prev': prev,
575             'next': next,
576             'title': title,
577             'meta': meta,
578             'body': body,
579             'metatags': metatags,
580             'rellinks': rellinks,
581             'sourcename': sourcename,
582             'toc': toc,
583             # only display a TOC if there's more than one item to show
584             'display_toc': (self.env.toc_num_entries[docname] > 1),
585             'page_source_suffix': source_suffix,
586         }
587 
588     def write_doc(self, docname: str, doctree: nodes.document) -> None:
589         destination = StringOutput(encoding='utf-8')
590         doctree.settings = self.docsettings
591 
592         self.secnumbers = self.env.toc_secnumbers.get(docname, {})
593         self.fignumbers = self.env.toc_fignumbers.get(docname, {})
594         self.imgpath = relative_uri(self.get_target_uri(docname), '_images')
595         self.dlpath = relative_uri(self.get_target_uri(docname), '_downloads')
596         self.current_docname = docname
597         self.docwriter.write(doctree, destination)
598         self.docwriter.assemble_parts()
599         body = self.docwriter.parts['fragment']
600         metatags = self.docwriter.clean_meta
601 
602         ctx = self.get_doc_context(docname, body, metatags)
603         self.handle_page(docname, ctx, event_arg=doctree)
604 
605     def write_doc_serialized(self, docname: str, doctree: nodes.document) -> None:
606         self.imgpath = relative_uri(self.get_target_uri(docname), self.imagedir)
607         self.post_process_images(doctree)
608         title_node = self.env.longtitles.get(docname)
609         title = self.render_partial(title_node)['title'] if title_node else ''
610         self.index_page(docname, doctree, title)
611 
612     def finish(self) -> None:
613         self.finish_tasks.add_task(self.gen_indices)
614         self.finish_tasks.add_task(self.gen_pages_from_extensions)
615         self.finish_tasks.add_task(self.gen_additional_pages)
616         self.finish_tasks.add_task(self.copy_image_files)
617         self.finish_tasks.add_task(self.copy_download_files)
618         self.finish_tasks.add_task(self.copy_static_files)
619         self.finish_tasks.add_task(self.copy_extra_files)
620         self.finish_tasks.add_task(self.write_buildinfo)
621 
622         # dump the search index
623         self.handle_finish()
624 
625     @progress_message(__('generating indices'))
626     def gen_indices(self) -> None:
627         # the global general index
628         if self.use_index:
629             self.write_genindex()
630 
631         # the global domain-specific indices
632         self.write_domain_indices()
633 
634     def gen_pages_from_extensions(self) -> None:
635         # pages from extensions
636         for pagelist in self.events.emit('html-collect-pages'):
637             for pagename, context, template in pagelist:
638                 self.handle_page(pagename, context, template)
639 
640     @progress_message(__('writing additional pages'))
641     def gen_additional_pages(self) -> None:
642         # additional pages from conf.py
643         for pagename, template in self.config.html_additional_pages.items():
644             logger.info(pagename + ' ', nonl=True)
645             self.handle_page(pagename, {}, template)
646 
647         # the search page
648         if self.search:
649             logger.info('search ', nonl=True)
650             self.handle_page('search', {}, 'search.html')
651 
652         # the opensearch xml file
653         if self.config.html_use_opensearch and self.search:
654             logger.info('opensearch ', nonl=True)
655             fn = path.join(self.outdir, '_static', 'opensearch.xml')
656             self.handle_page('opensearch', {}, 'opensearch.xml', outfilename=fn)
657 
658     def write_genindex(self) -> None:
659         # the total count of lines for each index letter, used to distribute
660         # the entries into two columns
661         genindex = IndexEntries(self.env).create_index(self)
662         indexcounts = []
663         for _k, entries in genindex:
664             indexcounts.append(sum(1 + len(subitems)
665                                    for _, (_, subitems, _) in entries))
666 
667         genindexcontext = {
668             'genindexentries': genindex,
669             'genindexcounts': indexcounts,
670             'split_index': self.config.html_split_index,
671         }
672         logger.info('genindex ', nonl=True)
673 
674         if self.config.html_split_index:
675             self.handle_page('genindex', genindexcontext,
676                              'genindex-split.html')
677             self.handle_page('genindex-all', genindexcontext,
678                              'genindex.html')
679             for (key, entries), count in zip(genindex, indexcounts):
680                 ctx = {'key': key, 'entries': entries, 'count': count,
681                        'genindexentries': genindex}
682                 self.handle_page('genindex-' + key, ctx,
683                                  'genindex-single.html')
684         else:
685             self.handle_page('genindex', genindexcontext, 'genindex.html')
686 
687     def write_domain_indices(self) -> None:
688         for indexname, indexcls, content, collapse in self.domain_indices:
689             indexcontext = {
690                 'indextitle': indexcls.localname,
691                 'content': content,
692                 'collapse_index': collapse,
693             }
694             logger.info(indexname + ' ', nonl=True)
695             self.handle_page(indexname, indexcontext, 'domainindex.html')
696 
697     def copy_image_files(self) -> None:
698         if self.images:
699             stringify_func = ImageAdapter(self.app.env).get_original_image_uri
700             ensuredir(path.join(self.outdir, self.imagedir))
701             for src in status_iterator(self.images, __('copying images... '), "brown",
702                                        len(self.images), self.app.verbosity,
703                                        stringify_func=stringify_func):
704                 dest = self.images[src]
705                 try:
706                     copyfile(path.join(self.srcdir, src),
707                              path.join(self.outdir, self.imagedir, dest))
708                 except Exception as err:
709                     logger.warning(__('cannot copy image file %r: %s'),
710                                    path.join(self.srcdir, src), err)
711 
712     def copy_download_files(self) -> None:
713         def to_relpath(f: str) -> str:
714             return relative_path(self.srcdir, f)
715 
716         # copy downloadable files
717         if self.env.dlfiles:
718             ensuredir(path.join(self.outdir, '_downloads'))
719             for src in status_iterator(self.env.dlfiles, __('copying downloadable files... '),
720                                        "brown", len(self.env.dlfiles), self.app.verbosity,
721                                        stringify_func=to_relpath):
722                 try:
723                     dest = path.join(self.outdir, '_downloads', self.env.dlfiles[src][1])
724                     ensuredir(path.dirname(dest))
725                     copyfile(path.join(self.srcdir, src), dest)
726                 except OSError as err:
727                     logger.warning(__('cannot copy downloadable file %r: %s'),
728                                    path.join(self.srcdir, src), err)
729 
730     def create_pygments_style_file(self) -> None:
731         """create a style file for pygments."""
732         with open(path.join(self.outdir, '_static', 'pygments.css'), 'w') as f:
733             f.write(self.highlighter.get_stylesheet())
734 
735         if self.dark_highlighter:
736             with open(path.join(self.outdir, '_static', 'pygments_dark.css'), 'w') as f:
737                 f.write(self.dark_highlighter.get_stylesheet())
738 
739     def copy_translation_js(self) -> None:
740         """Copy a JavaScript file for translations."""
741         if self.config.language is not None:
742             jsfile = self._get_translations_js()
743             if jsfile:
744                 copyfile(jsfile, path.join(self.outdir, '_static', 'translations.js'))
745 
746     def copy_stemmer_js(self) -> None:
747         """Copy a JavaScript file for stemmer."""
748         if self.indexer is not None:
749             jsfile = self.indexer.get_js_stemmer_rawcode()
750             if jsfile:
751                 copyfile(jsfile, path.join(self.outdir, '_static', '_stemmer.js'))
752 
753     def copy_theme_static_files(self, context: Dict) -> None:
754         def onerror(filename: str, error: Exception) -> None:
755             logger.warning(__('Failed to copy a file in html_static_file: %s: %r'),
756                            filename, error)
757 
758         if self.theme:
759             for entry in self.theme.get_theme_dirs()[::-1]:
760                 copy_asset(path.join(entry, 'static'),
761                            path.join(self.outdir, '_static'),
762                            excluded=DOTFILES, context=context,
763                            renderer=self.templates, onerror=onerror)
764 
765     def copy_html_static_files(self, context: Dict) -> None:
766         def onerror(filename: str, error: Exception) -> None:
767             logger.warning(__('Failed to copy a file in html_static_file: %s: %r'),
768                            filename, error)
769 
770         excluded = Matcher(self.config.exclude_patterns + ["**/.*"])
771         for entry in self.config.html_static_path:
772             copy_asset(path.join(self.confdir, entry),
773                        path.join(self.outdir, '_static'),
774                        excluded, context=context, renderer=self.templates, onerror=onerror)
775 
776     def copy_html_logo(self) -> None:
777         if self.config.html_logo:
778             copy_asset(path.join(self.confdir, self.config.html_logo),
779                        path.join(self.outdir, '_static'))
780 
781     def copy_html_favicon(self) -> None:
782         if self.config.html_favicon:
783             copy_asset(path.join(self.confdir, self.config.html_favicon),
784                        path.join(self.outdir, '_static'))
785 
786     def copy_static_files(self) -> None:
787         try:
788             with progress_message(__('copying static files')):
789                 ensuredir(path.join(self.outdir, '_static'))
790 
791                 # prepare context for templates
792                 context = self.globalcontext.copy()
793                 if self.indexer is not None:
794                     context.update(self.indexer.context_for_searchtool())
795 
796                 self.create_pygments_style_file()
797                 self.copy_translation_js()
798                 self.copy_stemmer_js()
799                 self.copy_theme_static_files(context)
800                 self.copy_html_static_files(context)
801                 self.copy_html_logo()
802                 self.copy_html_favicon()
803         except OSError as err:
804             logger.warning(__('cannot copy static file %r'), err)
805 
806     def copy_extra_files(self) -> None:
807         """copy html_extra_path files."""
808         try:
809             with progress_message(__('copying extra files')):
810                 excluded = Matcher(self.config.exclude_patterns)
811                 for extra_path in self.config.html_extra_path:
812                     entry = path.join(self.confdir, extra_path)
813                     copy_asset(entry, self.outdir, excluded)
814         except OSError as err:
815             logger.warning(__('cannot copy extra file %r'), err)
816 
817     def write_buildinfo(self) -> None:
818         try:
819             with open(path.join(self.outdir, '.buildinfo'), 'w') as fp:
820                 self.build_info.dump(fp)
821         except OSError as exc:
822             logger.warning(__('Failed to write build info file: %r'), exc)
823 
824     def cleanup(self) -> None:
825         # clean up theme stuff
826         if self.theme:
827             self.theme.cleanup()
828 
829     def post_process_images(self, doctree: Node) -> None:
830         """Pick the best candidate for an image and link down-scaled images to
831         their high res version.
832         """
833         Builder.post_process_images(self, doctree)
834 
835         if self.config.html_scaled_image_link and self.html_scaled_image_link:
836             for node in doctree.traverse(nodes.image):
837                 if not any((key in node) for key in ['scale', 'width', 'height']):
838                     # resizing options are not given. scaled image link is available
839                     # only for resized images.
840                     continue
841                 elif isinstance(node.parent, nodes.reference):
842                     # A image having hyperlink target
843                     continue
844                 elif 'no-scaled-link' in node['classes']:
845                     # scaled image link is disabled for this node
846                     continue
847 
848                 uri = node['uri']
849                 reference = nodes.reference('', '', internal=True)
850                 if uri in self.images:
851                     reference['refuri'] = posixpath.join(self.imgpath,
852                                                          self.images[uri])
853                 else:
854                     reference['refuri'] = uri
855                 node.replace_self(reference)
856                 reference.append(node)
857 
858     def load_indexer(self, docnames: Iterable[str]) -> None:
859         keep = set(self.env.all_docs) - set(docnames)
860         try:
861             searchindexfn = path.join(self.outdir, self.searchindex_filename)
862             if self.indexer_dumps_unicode:
863                 with open(searchindexfn, encoding='utf-8') as ft:
864                     self.indexer.load(ft, self.indexer_format)
865             else:
866                 with open(searchindexfn, 'rb') as fb:
867                     self.indexer.load(fb, self.indexer_format)
868         except (OSError, ValueError):
869             if keep:
870                 logger.warning(__('search index couldn\'t be loaded, but not all '
871                                   'documents will be built: the index will be '
872                                   'incomplete.'))
873         # delete all entries for files that will be rebuilt
874         self.indexer.prune(keep)
875 
876     def index_page(self, pagename: str, doctree: nodes.document, title: str) -> None:
877         # only index pages with title
878         if self.indexer is not None and title:
879             filename = self.env.doc2path(pagename, base=None)
880             try:
881                 metadata = self.env.metadata.get(pagename, {})
882                 if 'nosearch' in metadata:
883                     self.indexer.feed(pagename, filename, '', new_document(''))
884                 else:
885                     self.indexer.feed(pagename, filename, title, doctree)
886             except TypeError:
887                 # fallback for old search-adapters
888                 self.indexer.feed(pagename, title, doctree)  # type: ignore
889                 indexer_name = self.indexer.__class__.__name__
890                 warnings.warn(
891                     'The %s.feed() method signature is deprecated. Update to '
892                     '%s.feed(docname, filename, title, doctree).' % (
893                         indexer_name, indexer_name),
894                     RemovedInSphinx40Warning, stacklevel=2)
895 
896     def _get_local_toctree(self, docname: str, collapse: bool = True, **kwargs: Any) -> str:
897         if 'includehidden' not in kwargs:
898             kwargs['includehidden'] = False
899         if kwargs.get('maxdepth') == '':
900             kwargs.pop('maxdepth')
901         return self.render_partial(TocTree(self.env).get_toctree_for(
902             docname, self, collapse, **kwargs))['fragment']
903 
904     def get_outfilename(self, pagename: str) -> str:
905         return path.join(self.outdir, os_path(pagename) + self.out_suffix)
906 
907     def add_sidebars(self, pagename: str, ctx: Dict) -> None:
908         def has_wildcard(pattern: str) -> bool:
909             return any(char in pattern for char in '*?[')
910 
911         sidebars = None
912         matched = None
913         customsidebar = None
914 
915         # default sidebars settings for selected theme
916         if self.theme.name == 'alabaster':
917             # provide default settings for alabaster (for compatibility)
918             # Note: this will be removed before Sphinx-2.0
919             try:
920                 # get default sidebars settings from alabaster (if defined)
921                 theme_default_sidebars = self.theme.config.get('theme', 'sidebars')
922                 if theme_default_sidebars:
923                     sidebars = [name.strip() for name in theme_default_sidebars.split(',')]
924             except Exception:
925                 # fallback to better default settings
926                 sidebars = ['about.html', 'navigation.html', 'relations.html',
927                             'searchbox.html', 'donate.html']
928         else:
929             theme_default_sidebars = self.theme.get_config('theme', 'sidebars', None)
930             if theme_default_sidebars:
931                 sidebars = [name.strip() for name in theme_default_sidebars.split(',')]
932 
933         # user sidebar settings
934         html_sidebars = self.get_builder_config('sidebars', 'html')
935         for pattern, patsidebars in html_sidebars.items():
936             if patmatch(pagename, pattern):
937                 if matched:
938                     if has_wildcard(pattern):
939                         # warn if both patterns contain wildcards
940                         if has_wildcard(matched):
941                             logger.warning(__('page %s matches two patterns in '
942                                               'html_sidebars: %r and %r'),
943                                            pagename, matched, pattern)
944                         # else the already matched pattern is more specific
945                         # than the present one, because it contains no wildcard
946                         continue
947                 matched = pattern
948                 sidebars = patsidebars
949 
950         if sidebars is None:
951             # keep defaults
952             pass
953 
954         ctx['sidebars'] = sidebars
955         ctx['customsidebar'] = customsidebar
956 
957     # --------- these are overwritten by the serialization builder
958 
959     def get_target_uri(self, docname: str, typ: str = None) -> str:
960         return quote(docname) + self.link_suffix
961 
962     def handle_page(self, pagename: str, addctx: Dict, templatename: str = 'page.html',
963                     outfilename: str = None, event_arg: Any = None) -> None:
964         ctx = self.globalcontext.copy()
965         # current_page_name is backwards compatibility
966         ctx['pagename'] = ctx['current_page_name'] = pagename
967         ctx['encoding'] = self.config.html_output_encoding
968         default_baseuri = self.get_target_uri(pagename)
969         # in the singlehtml builder, default_baseuri still contains an #anchor
970         # part, which relative_uri doesn't really like...
971         default_baseuri = default_baseuri.rsplit('#', 1)[0]
972 
973         if self.config.html_baseurl:
974             ctx['pageurl'] = posixpath.join(self.config.html_baseurl,
975                                             pagename + self.out_suffix)
976         else:
977             ctx['pageurl'] = None
978 
979         def pathto(otheruri: str, resource: bool = False, baseuri: str = default_baseuri) -> str:  # NOQA
980             if resource and '://' in otheruri:
981                 # allow non-local resources given by scheme
982                 return otheruri
983             elif not resource:
984                 otheruri = self.get_target_uri(otheruri)
985             uri = relative_uri(baseuri, otheruri) or '#'
986             if uri == '#' and not self.allow_sharp_as_current_path:
987                 uri = baseuri
988             return uri
989         ctx['pathto'] = pathto
990 
991         def css_tag(css: Stylesheet) -> str:
992             attrs = []
993             for key in sorted(css.attributes):
994                 value = css.attributes[key]
995                 if value is not None:
996                     attrs.append('%s="%s"' % (key, html.escape(value, True)))
997             attrs.append('href="%s"' % pathto(css.filename, resource=True))
998             return '<link %s />' % ' '.join(attrs)
999         ctx['css_tag'] = css_tag
1000 
1001         def hasdoc(name: str) -> bool:
1002             if name in self.env.all_docs:
1003                 return True
1004             elif name == 'search' and self.search:
1005                 return True
1006             elif name == 'genindex' and self.get_builder_config('use_index', 'html'):
1007                 return True
1008             return False
1009         ctx['hasdoc'] = hasdoc
1010 
1011         ctx['toctree'] = lambda **kwargs: self._get_local_toctree(pagename, **kwargs)
1012         self.add_sidebars(pagename, ctx)
1013         ctx.update(addctx)
1014 
1015         self.update_page_context(pagename, templatename, ctx, event_arg)
1016         newtmpl = self.app.emit_firstresult('html-page-context', pagename,
1017                                             templatename, ctx, event_arg)
1018         if newtmpl:
1019             templatename = newtmpl
1020 
1021         try:
1022             output = self.templates.render(templatename, ctx)
1023         except UnicodeError:
1024             logger.warning(__("a Unicode error occurred when rendering the page %s. "
1025                               "Please make sure all config values that contain "
1026                               "non-ASCII content are Unicode strings."), pagename)
1027             return
1028         except Exception as exc:
1029             raise ThemeError(__("An error happened in rendering the page %s.\nReason: %r") %
1030                              (pagename, exc)) from exc
1031 
1032         if not outfilename:
1033             outfilename = self.get_outfilename(pagename)
1034         # outfilename's path is in general different from self.outdir
1035         ensuredir(path.dirname(outfilename))
1036         try:
1037             with open(outfilename, 'w', encoding=ctx['encoding'],
1038                       errors='xmlcharrefreplace') as f:
1039                 f.write(output)
1040         except OSError as err:
1041             logger.warning(__("error writing file %s: %s"), outfilename, err)
1042         if self.copysource and ctx.get('sourcename'):
1043             # copy the source file for the "show source" link
1044             source_name = path.join(self.outdir, '_sources',
1045                                     os_path(ctx['sourcename']))
1046             ensuredir(path.dirname(source_name))
1047             copyfile(self.env.doc2path(pagename), source_name)
1048 
1049     def update_page_context(self, pagename: str, templatename: str,
1050                             ctx: Dict, event_arg: Any) -> None:
1051         pass
1052 
1053     def handle_finish(self) -> None:
1054         if self.indexer:
1055             self.finish_tasks.add_task(self.dump_search_index)
1056         self.finish_tasks.add_task(self.dump_inventory)
1057 
1058     @progress_message(__('dumping object inventory'))
1059     def dump_inventory(self) -> None:
1060         InventoryFile.dump(path.join(self.outdir, INVENTORY_FILENAME), self.env, self)
1061 
1062     def dump_search_index(self) -> None:
1063         with progress_message(__('dumping search index in %s') % self.indexer.label()):
1064             self.indexer.prune(self.env.all_docs)
1065             searchindexfn = path.join(self.outdir, self.searchindex_filename)
1066             # first write to a temporary file, so that if dumping fails,
1067             # the existing index won't be overwritten
1068             if self.indexer_dumps_unicode:
1069                 with open(searchindexfn + '.tmp', 'w', encoding='utf-8') as ft:
1070                     self.indexer.dump(ft, self.indexer_format)
1071             else:
1072                 with open(searchindexfn + '.tmp', 'wb') as fb:
1073                     self.indexer.dump(fb, self.indexer_format)
1074             os.replace(searchindexfn + '.tmp', searchindexfn)
1075 
1076 
1077 def convert_html_css_files(app: Sphinx, config: Config) -> None:
1078     """This converts string styled html_css_files to tuple styled one."""
1079     html_css_files = []  # type: List[Tuple[str, Dict]]
1080     for entry in config.html_css_files:
1081         if isinstance(entry, str):
1082             html_css_files.append((entry, {}))
1083         else:
1084             try:
1085                 filename, attrs = entry
1086                 html_css_files.append((filename, attrs))
1087             except Exception:
1088                 logger.warning(__('invalid css_file: %r, ignored'), entry)
1089                 continue
1090 
1091     config.html_css_files = html_css_files  # type: ignore
1092 
1093 
1094 def convert_html_js_files(app: Sphinx, config: Config) -> None:
1095     """This converts string styled html_js_files to tuple styled one."""
1096     html_js_files = []  # type: List[Tuple[str, Dict]]
1097     for entry in config.html_js_files:
1098         if isinstance(entry, str):
1099             html_js_files.append((entry, {}))
1100         else:
1101             try:
1102                 filename, attrs = entry
1103                 html_js_files.append((filename, attrs))
1104             except Exception:
1105                 logger.warning(__('invalid js_file: %r, ignored'), entry)
1106                 continue
1107 
1108     config.html_js_files = html_js_files  # type: ignore
1109 
1110 
1111 def setup_js_tag_helper(app: Sphinx, pagename: str, templatexname: str,
1112                         context: Dict, doctree: Node) -> None:
1113     """Set up js_tag() template helper.
1114 
1115     .. note:: This set up function is added to keep compatibility with webhelper.
1116     """
1117     pathto = context.get('pathto')
1118 
1119     def js_tag(js: JavaScript) -> str:
1120         attrs = []
1121         body = ''
1122         if isinstance(js, JavaScript):
1123             for key in sorted(js.attributes):
1124                 value = js.attributes[key]
1125                 if value is not None:
1126                     if key == 'body':
1127                         body = value
1128                     else:
1129                         attrs.append('%s="%s"' % (key, html.escape(value, True)))
1130             if js.filename:
1131                 attrs.append('src="%s"' % pathto(js.filename, resource=True))
1132         else:
1133             # str value (old styled)
1134             attrs.append('src="%s"' % pathto(js, resource=True))
1135         return '<script %s>%s</script>' % (' '.join(attrs), body)
1136 
1137     context['js_tag'] = js_tag
1138 
1139 
1140 def validate_math_renderer(app: Sphinx) -> None:
1141     if app.builder.format != 'html':
1142         return
1143 
1144     name = app.builder.math_renderer_name  # type: ignore
1145     if name is None:
1146         raise ConfigError(__('Many math_renderers are registered. '
1147                              'But no math_renderer is selected.'))
1148     elif name not in app.registry.html_inline_math_renderers:
1149         raise ConfigError(__('Unknown math_renderer %r is given.') % name)
1150 
1151 
1152 def validate_html_extra_path(app: Sphinx, config: Config) -> None:
1153     """Check html_extra_paths setting."""
1154     for entry in config.html_extra_path[:]:
1155         extra_path = path.normpath(path.join(app.confdir, entry))
1156         if not path.exists(extra_path):
1157             logger.warning(__('html_extra_path entry %r does not exist'), entry)
1158             config.html_extra_path.remove(entry)
1159         elif (path.splitdrive(app.outdir)[0] == path.splitdrive(extra_path)[0] and
1160               path.commonpath([app.outdir, extra_path]) == app.outdir):
1161             logger.warning(__('html_extra_path entry %r is placed inside outdir'), entry)
1162             config.html_extra_path.remove(entry)
1163 
1164 
1165 def validate_html_static_path(app: Sphinx, config: Config) -> None:
1166     """Check html_static_paths setting."""
1167     for entry in config.html_static_path[:]:
1168         static_path = path.normpath(path.join(app.confdir, entry))
1169         if not path.exists(static_path):
1170             logger.warning(__('html_static_path entry %r does not exist'), entry)
1171             config.html_static_path.remove(entry)
1172         elif (path.splitdrive(app.outdir)[0] == path.splitdrive(static_path)[0] and
1173               path.commonpath([app.outdir, static_path]) == app.outdir):
1174             logger.warning(__('html_static_path entry %r is placed inside outdir'), entry)
1175             config.html_static_path.remove(entry)
1176 
1177 
1178 def validate_html_logo(app: Sphinx, config: Config) -> None:
1179     """Check html_logo setting."""
1180     if config.html_logo and not path.isfile(path.join(app.confdir, config.html_logo)):
1181         logger.warning(__('logo file %r does not exist'), config.html_logo)
1182         config.html_logo = None  # type: ignore
1183 
1184 
1185 def validate_html_favicon(app: Sphinx, config: Config) -> None:
1186     """Check html_favicon setting."""
1187     if config.html_favicon and not path.isfile(path.join(app.confdir, config.html_favicon)):
1188         logger.warning(__('favicon file %r does not exist'), config.html_favicon)
1189         config.html_favicon = None  # type: ignore
1190 
1191 
1192 # for compatibility
1193 import sphinxcontrib.serializinghtml  # NOQA
1194 
1195 import sphinx.builders.dirhtml  # NOQA
1196 import sphinx.builders.singlehtml  # NOQA
1197 
1198 
1199 def setup(app: Sphinx) -> Dict[str, Any]:
1200     # builders
1201     app.add_builder(StandaloneHTMLBuilder)
1202 
1203     # config values
1204     app.add_config_value('html_theme', 'alabaster', 'html')
1205     app.add_config_value('html_theme_path', [], 'html')
1206     app.add_config_value('html_theme_options', {}, 'html')
1207     app.add_config_value('html_title',
1208                          lambda self: _('%s %s documentation') % (self.project, self.release),
1209                          'html', [str])
1210     app.add_config_value('html_short_title', lambda self: self.html_title, 'html')
1211     app.add_config_value('html_style', None, 'html', [str])
1212     app.add_config_value('html_logo', None, 'html', [str])
1213     app.add_config_value('html_favicon', None, 'html', [str])
1214     app.add_config_value('html_css_files', [], 'html')
1215     app.add_config_value('html_js_files', [], 'html')
1216     app.add_config_value('html_static_path', [], 'html')
1217     app.add_config_value('html_extra_path', [], 'html')
1218     app.add_config_value('html_last_updated_fmt', None, 'html', [str])
1219     app.add_config_value('html_sidebars', {}, 'html')
1220     app.add_config_value('html_additional_pages', {}, 'html')
1221     app.add_config_value('html_domain_indices', True, 'html', [list])
1222     app.add_config_value('html_add_permalinks', '¶', 'html')
1223     app.add_config_value('html_use_index', True, 'html')
1224     app.add_config_value('html_split_index', False, 'html')
1225     app.add_config_value('html_copy_source', True, 'html')
1226     app.add_config_value('html_show_sourcelink', True, 'html')
1227     app.add_config_value('html_sourcelink_suffix', '.txt', 'html')
1228     app.add_config_value('html_use_opensearch', '', 'html')
1229     app.add_config_value('html_file_suffix', None, 'html', [str])
1230     app.add_config_value('html_link_suffix', None, 'html', [str])
1231     app.add_config_value('html_show_copyright', True, 'html')
1232     app.add_config_value('html_show_sphinx', True, 'html')
1233     app.add_config_value('html_context', {}, 'html')
1234     app.add_config_value('html_output_encoding', 'utf-8', 'html')
1235     app.add_config_value('html_compact_lists', True, 'html')
1236     app.add_config_value('html_secnumber_suffix', '. ', 'html')
1237     app.add_config_value('html_search_language', None, 'html', [str])
1238     app.add_config_value('html_search_options', {}, 'html')
1239     app.add_config_value('html_search_scorer', '', None)
1240     app.add_config_value('html_scaled_image_link', True, 'html')
1241     app.add_config_value('html_baseurl', '', 'html')
1242     app.add_config_value('html_codeblock_linenos_style', 'table', 'html',
1243                          ENUM('table', 'inline'))
1244     app.add_config_value('html_math_renderer', None, 'env')
1245     app.add_config_value('html4_writer', False, 'html')
1246 
1247     # events
1248     app.add_event('html-collect-pages')
1249     app.add_event('html-page-context')
1250 
1251     # event handlers
1252     app.connect('config-inited', convert_html_css_files, priority=800)
1253     app.connect('config-inited', convert_html_js_files, priority=800)
1254     app.connect('config-inited', validate_html_extra_path, priority=800)
1255     app.connect('config-inited', validate_html_static_path, priority=800)
1256     app.connect('config-inited', validate_html_logo, priority=800)
1257     app.connect('config-inited', validate_html_favicon, priority=800)
1258     app.connect('builder-inited', validate_math_renderer)
1259     app.connect('html-page-context', setup_js_tag_helper)
1260 
1261     # load default math renderer
1262     app.setup_extension('sphinx.ext.mathjax')
1263 
1264     # load transforms for HTML builder
1265     app.setup_extension('sphinx.builders.html.transforms')
1266 
1267     return {
1268         'version': 'builtin',
1269         'parallel_read_safe': True,
1270         'parallel_write_safe': True,
1271     }

</code><intended_behavior>Since this file is part of the HTML builder in Sphinx, it is responsible for converting reStructuredText into HTML. The intended behavior would be to ensure during the HTML generation process that compound keystrokes within the `:kbd:` role are rendered with a parent `<kbd>` element that includes a specific CSS class. This modification should preserve the current functionality for all other elements and roles, ensuring that only the `:kbd:` role handling is augmented to support differentiated styling.</intended_behavior>]
2025-10-16 01:04:36.271 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-16 01:04:36.271 | INFO     | Search-only: skipping patch selection
2025-10-16 01:04:36.372 | INFO     | Task sphinx-doc__sphinx-8620 completed successfully.
2025-10-16 01:04:36.373 | INFO     | No patch generated. You can try running ACR again.
