2025-10-15 17:42:56.119 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-15 17:42:59.425 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=231, output_tokens=12, cost=0.002670
2025-10-15 17:42:59.426 | INFO     | Test agent decides that the issue statement does not contain reproduction steps; skipping reproducer tracing
2025-10-15 17:42:59.430 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 17:43:09.714 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=531, output_tokens=363, cost=0.016200
2025-10-15 17:43:09.721 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 17:43:14.250 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=717, output_tokens=80, cost=0.009570
2025-10-15 17:43:14.252 | DEBUG    | Extracted a valid json.
2025-10-15 17:43:14.252 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_class(\"Vulnerability\")",
        "search_class(\"AppVersion\")",
        "search_method(\"AlterField\")",
        "search_code(\"ManyToManyField\")",
        "search_method(\"save\")",
        "search_code(\"post_save\")",
        "search_code(\"pre_save\")"
    ],
    "bug_locations": []
}
2025-10-15 17:43:14.415 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-15 17:43:14.415 | DEBUG    | <Agent search> Analyzing search results.
2025-10-15 17:43:42.217 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2026, output_tokens=876, cost=0.046540
2025-10-15 17:43:42.226 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 17:43:59.376 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3118, output_tokens=356, cost=0.041860
2025-10-15 17:43:59.382 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 17:44:07.734 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=710, output_tokens=172, cost=0.012260
2025-10-15 17:44:07.735 | DEBUG    | Extracted a valid json.
2025-10-15 17:44:07.736 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations":[
        {
            "file": "django/db/models/fields/related.py", 
            "class": "ManyToManyField", 
            "method": "", 
            "intended_behavior": "Modify or extend the implementation to ensure that when a model having a ManyToManyField is altered, the alteration cascades the changes appropriately to related fields in the intermediary join table."
        }, 
        {
            "file": "django/db/migrations/autodetector.py", 
            "class": "", 
            "method": "", 
            "intended_behavior": "Ensure the migration autodetector is capable of detecting changes in fields of a model and the implications on related fields, specifically in ManyToManyField relationships, possibly altering related database table schemas."
        }
    ]
}
2025-10-15 17:44:07.748 | DEBUG    | Bug location extracted successfully: [<file>django/db/models/fields/related.py</file>
<class>ManyToManyField</class>
<method>None</method>
<code>
1120 class ManyToManyField(RelatedField):
1121     """
1122     Provide a many-to-many relation by using an intermediary model that
1123     holds two ForeignKey fields pointed at the two sides of the relation.
1124 
1125     Unless a ``through`` model was provided, ManyToManyField will use the
1126     create_many_to_many_intermediary_model factory to automatically generate
1127     the intermediary model.
1128     """
1129 
1130     # Field flags
1131     many_to_many = True
1132     many_to_one = False
1133     one_to_many = False
1134     one_to_one = False
1135 
1136     rel_class = ManyToManyRel
1137 
1138     description = _("Many-to-many relationship")
1139 
1140     def __init__(self, to, related_name=None, related_query_name=None,
1141                  limit_choices_to=None, symmetrical=None, through=None,
1142                  through_fields=None, db_constraint=True, db_table=None,
1143                  swappable=True, **kwargs):
1144         try:
1145             to._meta
1146         except AttributeError:
1147             assert isinstance(to, str), (
1148                 "%s(%r) is invalid. First parameter to ManyToManyField must be "
1149                 "either a model, a model name, or the string %r" %
1150                 (self.__class__.__name__, to, RECURSIVE_RELATIONSHIP_CONSTANT)
1151             )
1152 
1153         if symmetrical is None:
1154             symmetrical = (to == RECURSIVE_RELATIONSHIP_CONSTANT)
1155 
1156         if through is not None:
1157             assert db_table is None, (
1158                 "Cannot specify a db_table if an intermediary model is used."
1159             )
1160 
1161         kwargs['rel'] = self.rel_class(
1162             self, to,
1163             related_name=related_name,
1164             related_query_name=related_query_name,
1165             limit_choices_to=limit_choices_to,
1166             symmetrical=symmetrical,
1167             through=through,
1168             through_fields=through_fields,
1169             db_constraint=db_constraint,
1170         )
1171         self.has_null_arg = 'null' in kwargs
1172 
1173         super().__init__(**kwargs)
1174 
1175         self.db_table = db_table
1176         self.swappable = swappable
1177 
1178     def check(self, **kwargs):
1179         return [
1180             *super().check(**kwargs),
1181             *self._check_unique(**kwargs),
1182             *self._check_relationship_model(**kwargs),
1183             *self._check_ignored_options(**kwargs),
1184             *self._check_table_uniqueness(**kwargs),
1185         ]
1186 
1187     def _check_unique(self, **kwargs):
1188         if self.unique:
1189             return [
1190                 checks.Error(
1191                     'ManyToManyFields cannot be unique.',
1192                     obj=self,
1193                     id='fields.E330',
1194                 )
1195             ]
1196         return []
1197 
1198     def _check_ignored_options(self, **kwargs):
1199         warnings = []
1200 
1201         if self.has_null_arg:
1202             warnings.append(
1203                 checks.Warning(
1204                     'null has no effect on ManyToManyField.',
1205                     obj=self,
1206                     id='fields.W340',
1207                 )
1208             )
1209 
1210         if self._validators:
1211             warnings.append(
1212                 checks.Warning(
1213                     'ManyToManyField does not support validators.',
1214                     obj=self,
1215                     id='fields.W341',
1216                 )
1217             )
1218         if (self.remote_field.limit_choices_to and self.remote_field.through and
1219                 not self.remote_field.through._meta.auto_created):
1220             warnings.append(
1221                 checks.Warning(
1222                     'limit_choices_to has no effect on ManyToManyField '
1223                     'with a through model.',
1224                     obj=self,
1225                     id='fields.W343',
1226                 )
1227             )
1228 
1229         return warnings
1230 
1231     def _check_relationship_model(self, from_model=None, **kwargs):
1232         if hasattr(self.remote_field.through, '_meta'):
1233             qualified_model_name = "%s.%s" % (
1234                 self.remote_field.through._meta.app_label, self.remote_field.through.__name__)
1235         else:
1236             qualified_model_name = self.remote_field.through
1237 
1238         errors = []
1239 
1240         if self.remote_field.through not in self.opts.apps.get_models(include_auto_created=True):
1241             # The relationship model is not installed.
1242             errors.append(
1243                 checks.Error(
1244                     "Field specifies a many-to-many relation through model "
1245                     "'%s', which has not been installed." % qualified_model_name,
1246                     obj=self,
1247                     id='fields.E331',
1248                 )
1249             )
1250 
1251         else:
1252             assert from_model is not None, (
1253                 "ManyToManyField with intermediate "
1254                 "tables cannot be checked if you don't pass the model "
1255                 "where the field is attached to."
1256             )
1257             # Set some useful local variables
1258             to_model = resolve_relation(from_model, self.remote_field.model)
1259             from_model_name = from_model._meta.object_name
1260             if isinstance(to_model, str):
1261                 to_model_name = to_model
1262             else:
1263                 to_model_name = to_model._meta.object_name
1264             relationship_model_name = self.remote_field.through._meta.object_name
1265             self_referential = from_model == to_model
1266             # Count foreign keys in intermediate model
1267             if self_referential:
1268                 seen_self = sum(
1269                     from_model == getattr(field.remote_field, 'model', None)
1270                     for field in self.remote_field.through._meta.fields
1271                 )
1272 
1273                 if seen_self > 2 and not self.remote_field.through_fields:
1274                     errors.append(
1275                         checks.Error(
1276                             "The model is used as an intermediate model by "
1277                             "'%s', but it has more than two foreign keys "
1278                             "to '%s', which is ambiguous. You must specify "
1279                             "which two foreign keys Django should use via the "
1280                             "through_fields keyword argument." % (self, from_model_name),
1281                             hint="Use through_fields to specify which two foreign keys Django should use.",
1282                             obj=self.remote_field.through,
1283                             id='fields.E333',
1284                         )
1285                     )
1286 
1287             else:
1288                 # Count foreign keys in relationship model
1289                 seen_from = sum(
1290                     from_model == getattr(field.remote_field, 'model', None)
1291                     for field in self.remote_field.through._meta.fields
1292                 )
1293                 seen_to = sum(
1294                     to_model == getattr(field.remote_field, 'model', None)
1295                     for field in self.remote_field.through._meta.fields
1296                 )
1297 
1298                 if seen_from > 1 and not self.remote_field.through_fields:
1299                     errors.append(
1300                         checks.Error(
1301                             ("The model is used as an intermediate model by "
1302                              "'%s', but it has more than one foreign key "
1303                              "from '%s', which is ambiguous. You must specify "
1304                              "which foreign key Django should use via the "
1305                              "through_fields keyword argument.") % (self, from_model_name),
1306                             hint=(
1307                                 'If you want to create a recursive relationship, '
1308                                 'use ManyToManyField("%s", through="%s").'
1309                             ) % (
1310                                 RECURSIVE_RELATIONSHIP_CONSTANT,
1311                                 relationship_model_name,
1312                             ),
1313                             obj=self,
1314                             id='fields.E334',
1315                         )
1316                     )
1317 
1318                 if seen_to > 1 and not self.remote_field.through_fields:
1319                     errors.append(
1320                         checks.Error(
1321                             "The model is used as an intermediate model by "
1322                             "'%s', but it has more than one foreign key "
1323                             "to '%s', which is ambiguous. You must specify "
1324                             "which foreign key Django should use via the "
1325                             "through_fields keyword argument." % (self, to_model_name),
1326                             hint=(
1327                                 'If you want to create a recursive relationship, '
1328                                 'use ManyToManyField("%s", through="%s").'
1329                             ) % (
1330                                 RECURSIVE_RELATIONSHIP_CONSTANT,
1331                                 relationship_model_name,
1332                             ),
1333                             obj=self,
1334                             id='fields.E335',
1335                         )
1336                     )
1337 
1338                 if seen_from == 0 or seen_to == 0:
1339                     errors.append(
1340                         checks.Error(
1341                             "The model is used as an intermediate model by "
1342                             "'%s', but it does not have a foreign key to '%s' or '%s'." % (
1343                                 self, from_model_name, to_model_name
1344                             ),
1345                             obj=self.remote_field.through,
1346                             id='fields.E336',
1347                         )
1348                     )
1349 
1350         # Validate `through_fields`.
1351         if self.remote_field.through_fields is not None:
1352             # Validate that we're given an iterable of at least two items
1353             # and that none of them is "falsy".
1354             if not (len(self.remote_field.through_fields) >= 2 and
1355                     self.remote_field.through_fields[0] and self.remote_field.through_fields[1]):
1356                 errors.append(
1357                     checks.Error(
1358                         "Field specifies 'through_fields' but does not provide "
1359                         "the names of the two link fields that should be used "
1360                         "for the relation through model '%s'." % qualified_model_name,
1361                         hint="Make sure you specify 'through_fields' as through_fields=('field1', 'field2')",
1362                         obj=self,
1363                         id='fields.E337',
1364                     )
1365                 )
1366 
1367             # Validate the given through fields -- they should be actual
1368             # fields on the through model, and also be foreign keys to the
1369             # expected models.
1370             else:
1371                 assert from_model is not None, (
1372                     "ManyToManyField with intermediate "
1373                     "tables cannot be checked if you don't pass the model "
1374                     "where the field is attached to."
1375                 )
1376 
1377                 source, through, target = from_model, self.remote_field.through, self.remote_field.model
1378                 source_field_name, target_field_name = self.remote_field.through_fields[:2]
1379 
1380                 for field_name, related_model in ((source_field_name, source),
1381                                                   (target_field_name, target)):
1382 
1383                     possible_field_names = []
1384                     for f in through._meta.fields:
1385                         if hasattr(f, 'remote_field') and getattr(f.remote_field, 'model', None) == related_model:
1386                             possible_field_names.append(f.name)
1387                     if possible_field_names:
1388                         hint = "Did you mean one of the following foreign keys to '%s': %s?" % (
1389                             related_model._meta.object_name,
1390                             ', '.join(possible_field_names),
1391                         )
1392                     else:
1393                         hint = None
1394 
1395                     try:
1396                         field = through._meta.get_field(field_name)
1397                     except exceptions.FieldDoesNotExist:
1398                         errors.append(
1399                             checks.Error(
1400                                 "The intermediary model '%s' has no field '%s'."
1401                                 % (qualified_model_name, field_name),
1402                                 hint=hint,
1403                                 obj=self,
1404                                 id='fields.E338',
1405                             )
1406                         )
1407                     else:
1408                         if not (hasattr(field, 'remote_field') and
1409                                 getattr(field.remote_field, 'model', None) == related_model):
1410                             errors.append(
1411                                 checks.Error(
1412                                     "'%s.%s' is not a foreign key to '%s'." % (
1413                                         through._meta.object_name, field_name,
1414                                         related_model._meta.object_name,
1415                                     ),
1416                                     hint=hint,
1417                                     obj=self,
1418                                     id='fields.E339',
1419                                 )
1420                             )
1421 
1422         return errors
1423 
1424     def _check_table_uniqueness(self, **kwargs):
1425         if isinstance(self.remote_field.through, str) or not self.remote_field.through._meta.managed:
1426             return []
1427         registered_tables = {
1428             model._meta.db_table: model
1429             for model in self.opts.apps.get_models(include_auto_created=True)
1430             if model != self.remote_field.through and model._meta.managed
1431         }
1432         m2m_db_table = self.m2m_db_table()
1433         model = registered_tables.get(m2m_db_table)
1434         # The second condition allows multiple m2m relations on a model if
1435         # some point to a through model that proxies another through model.
1436         if model and model._meta.concrete_model != self.remote_field.through._meta.concrete_model:
1437             if model._meta.auto_created:
1438                 def _get_field_name(model):
1439                     for field in model._meta.auto_created._meta.many_to_many:
1440                         if field.remote_field.through is model:
1441                             return field.name
1442                 opts = model._meta.auto_created._meta
1443                 clashing_obj = '%s.%s' % (opts.label, _get_field_name(model))
1444             else:
1445                 clashing_obj = model._meta.label
1446             if settings.DATABASE_ROUTERS:
1447                 error_class, error_id = checks.Warning, 'fields.W344'
1448                 error_hint = (
1449                     'You have configured settings.DATABASE_ROUTERS. Verify '
1450                     'that the table of %r is correctly routed to a separate '
1451                     'database.' % clashing_obj
1452                 )
1453             else:
1454                 error_class, error_id = checks.Error, 'fields.E340'
1455                 error_hint = None
1456             return [
1457                 error_class(
1458                     "The field's intermediary table '%s' clashes with the "
1459                     "table name of '%s'." % (m2m_db_table, clashing_obj),
1460                     obj=self,
1461                     hint=error_hint,
1462                     id=error_id,
1463                 )
1464             ]
1465         return []
1466 
1467     def deconstruct(self):
1468         name, path, args, kwargs = super().deconstruct()
1469         # Handle the simpler arguments.
1470         if self.db_table is not None:
1471             kwargs['db_table'] = self.db_table
1472         if self.remote_field.db_constraint is not True:
1473             kwargs['db_constraint'] = self.remote_field.db_constraint
1474         # Rel needs more work.
1475         if isinstance(self.remote_field.model, str):
1476             kwargs['to'] = self.remote_field.model
1477         else:
1478             kwargs['to'] = "%s.%s" % (
1479                 self.remote_field.model._meta.app_label,
1480                 self.remote_field.model._meta.object_name,
1481             )
1482         if getattr(self.remote_field, 'through', None) is not None:
1483             if isinstance(self.remote_field.through, str):
1484                 kwargs['through'] = self.remote_field.through
1485             elif not self.remote_field.through._meta.auto_created:
1486                 kwargs['through'] = "%s.%s" % (
1487                     self.remote_field.through._meta.app_label,
1488                     self.remote_field.through._meta.object_name,
1489                 )
1490         # If swappable is True, then see if we're actually pointing to the target
1491         # of a swap.
1492         swappable_setting = self.swappable_setting
1493         if swappable_setting is not None:
1494             # If it's already a settings reference, error.
1495             if hasattr(kwargs['to'], "setting_name"):
1496                 if kwargs['to'].setting_name != swappable_setting:
1497                     raise ValueError(
1498                         "Cannot deconstruct a ManyToManyField pointing to a "
1499                         "model that is swapped in place of more than one model "
1500                         "(%s and %s)" % (kwargs['to'].setting_name, swappable_setting)
1501                     )
1502 
1503             kwargs['to'] = SettingsReference(
1504                 kwargs['to'],
1505                 swappable_setting,
1506             )
1507         return name, path, args, kwargs
1508 
1509     def _get_path_info(self, direct=False, filtered_relation=None):
1510         """Called by both direct and indirect m2m traversal."""
1511         int_model = self.remote_field.through
1512         linkfield1 = int_model._meta.get_field(self.m2m_field_name())
1513         linkfield2 = int_model._meta.get_field(self.m2m_reverse_field_name())
1514         if direct:
1515             join1infos = linkfield1.get_reverse_path_info()
1516             join2infos = linkfield2.get_path_info(filtered_relation)
1517         else:
1518             join1infos = linkfield2.get_reverse_path_info()
1519             join2infos = linkfield1.get_path_info(filtered_relation)
1520 
1521         # Get join infos between the last model of join 1 and the first model
1522         # of join 2. Assume the only reason these may differ is due to model
1523         # inheritance.
1524         join1_final = join1infos[-1].to_opts
1525         join2_initial = join2infos[0].from_opts
1526         if join1_final is join2_initial:
1527             intermediate_infos = []
1528         elif issubclass(join1_final.model, join2_initial.model):
1529             intermediate_infos = join1_final.get_path_to_parent(join2_initial.model)
1530         else:
1531             intermediate_infos = join2_initial.get_path_from_parent(join1_final.model)
1532 
1533         return [*join1infos, *intermediate_infos, *join2infos]
1534 
1535     def get_path_info(self, filtered_relation=None):
1536         return self._get_path_info(direct=True, filtered_relation=filtered_relation)
1537 
1538     def get_reverse_path_info(self, filtered_relation=None):
1539         return self._get_path_info(direct=False, filtered_relation=filtered_relation)
1540 
1541     def _get_m2m_db_table(self, opts):
1542         """
1543         Function that can be curried to provide the m2m table name for this
1544         relation.
1545         """
1546         if self.remote_field.through is not None:
1547             return self.remote_field.through._meta.db_table
1548         elif self.db_table:
1549             return self.db_table
1550         else:
1551             m2m_table_name = '%s_%s' % (utils.strip_quotes(opts.db_table), self.name)
1552             return utils.truncate_name(m2m_table_name, connection.ops.max_name_length())
1553 
1554     def _get_m2m_attr(self, related, attr):
1555         """
1556         Function that can be curried to provide the source accessor or DB
1557         column name for the m2m table.
1558         """
1559         cache_attr = '_m2m_%s_cache' % attr
1560         if hasattr(self, cache_attr):
1561             return getattr(self, cache_attr)
1562         if self.remote_field.through_fields is not None:
1563             link_field_name = self.remote_field.through_fields[0]
1564         else:
1565             link_field_name = None
1566         for f in self.remote_field.through._meta.fields:
1567             if (f.is_relation and f.remote_field.model == related.related_model and
1568                     (link_field_name is None or link_field_name == f.name)):
1569                 setattr(self, cache_attr, getattr(f, attr))
1570                 return getattr(self, cache_attr)
1571 
1572     def _get_m2m_reverse_attr(self, related, attr):
1573         """
1574         Function that can be curried to provide the related accessor or DB
1575         column name for the m2m table.
1576         """
1577         cache_attr = '_m2m_reverse_%s_cache' % attr
1578         if hasattr(self, cache_attr):
1579             return getattr(self, cache_attr)
1580         found = False
1581         if self.remote_field.through_fields is not None:
1582             link_field_name = self.remote_field.through_fields[1]
1583         else:
1584             link_field_name = None
1585         for f in self.remote_field.through._meta.fields:
1586             if f.is_relation and f.remote_field.model == related.model:
1587                 if link_field_name is None and related.related_model == related.model:
1588                     # If this is an m2m-intermediate to self,
1589                     # the first foreign key you find will be
1590                     # the source column. Keep searching for
1591                     # the second foreign key.
1592                     if found:
1593                         setattr(self, cache_attr, getattr(f, attr))
1594                         break
1595                     else:
1596                         found = True
1597                 elif link_field_name is None or link_field_name == f.name:
1598                     setattr(self, cache_attr, getattr(f, attr))
1599                     break
1600         return getattr(self, cache_attr)
1601 
1602     def contribute_to_class(self, cls, name, **kwargs):
1603         # To support multiple relations to self, it's useful to have a non-None
1604         # related name on symmetrical relations for internal reasons. The
1605         # concept doesn't make a lot of sense externally ("you want me to
1606         # specify *what* on my non-reversible relation?!"), so we set it up
1607         # automatically. The funky name reduces the chance of an accidental
1608         # clash.
1609         if self.remote_field.symmetrical and (
1610             self.remote_field.model == RECURSIVE_RELATIONSHIP_CONSTANT or
1611             self.remote_field.model == cls._meta.object_name
1612         ):
1613             self.remote_field.related_name = "%s_rel_+" % name
1614         elif self.remote_field.is_hidden():
1615             # If the backwards relation is disabled, replace the original
1616             # related_name with one generated from the m2m field name. Django
1617             # still uses backwards relations internally and we need to avoid
1618             # clashes between multiple m2m fields with related_name == '+'.
1619             self.remote_field.related_name = "_%s_%s_+" % (cls.__name__.lower(), name)
1620 
1621         super().contribute_to_class(cls, name, **kwargs)
1622 
1623         # The intermediate m2m model is not auto created if:
1624         #  1) There is a manually specified intermediate, or
1625         #  2) The class owning the m2m field is abstract.
1626         #  3) The class owning the m2m field has been swapped out.
1627         if not cls._meta.abstract:
1628             if self.remote_field.through:
1629                 def resolve_through_model(_, model, field):
1630                     field.remote_field.through = model
1631                 lazy_related_operation(resolve_through_model, cls, self.remote_field.through, field=self)
1632             elif not cls._meta.swapped:
1633                 self.remote_field.through = create_many_to_many_intermediary_model(self, cls)
1634 
1635         # Add the descriptor for the m2m relation.
1636         setattr(cls, self.name, ManyToManyDescriptor(self.remote_field, reverse=False))
1637 
1638         # Set up the accessor for the m2m table name for the relation.
1639         self.m2m_db_table = partial(self._get_m2m_db_table, cls._meta)
1640 
1641     def contribute_to_related_class(self, cls, related):
1642         # Internal M2Ms (i.e., those with a related name ending with '+')
1643         # and swapped models don't get a related descriptor.
1644         if not self.remote_field.is_hidden() and not related.related_model._meta.swapped:
1645             setattr(cls, related.get_accessor_name(), ManyToManyDescriptor(self.remote_field, reverse=True))
1646 
1647         # Set up the accessors for the column names on the m2m table.
1648         self.m2m_column_name = partial(self._get_m2m_attr, related, 'column')
1649         self.m2m_reverse_name = partial(self._get_m2m_reverse_attr, related, 'column')
1650 
1651         self.m2m_field_name = partial(self._get_m2m_attr, related, 'name')
1652         self.m2m_reverse_field_name = partial(self._get_m2m_reverse_attr, related, 'name')
1653 
1654         get_m2m_rel = partial(self._get_m2m_attr, related, 'remote_field')
1655         self.m2m_target_field_name = lambda: get_m2m_rel().field_name
1656         get_m2m_reverse_rel = partial(self._get_m2m_reverse_attr, related, 'remote_field')
1657         self.m2m_reverse_target_field_name = lambda: get_m2m_reverse_rel().field_name
1658 
1659     def set_attributes_from_rel(self):
1660         pass
1661 
1662     def value_from_object(self, obj):
1663         return [] if obj.pk is None else list(getattr(obj, self.attname).all())
1664 
1665     def save_form_data(self, instance, data):
1666         getattr(instance, self.attname).set(data)
1667 
1668     def formfield(self, *, using=None, **kwargs):
1669         defaults = {
1670             'form_class': forms.ModelMultipleChoiceField,
1671             'queryset': self.remote_field.model._default_manager.using(using),
1672             **kwargs,
1673         }
1674         # If initial is passed in, it's a list of related objects, but the
1675         # MultipleChoiceField takes a list of IDs.
1676         if defaults.get('initial') is not None:
1677             initial = defaults['initial']
1678             if callable(initial):
1679                 initial = initial()
1680             defaults['initial'] = [i.pk for i in initial]
1681         return super().formfield(**defaults)
1682 
1683     def db_check(self, connection):
1684         return None
1685 
1686     def db_type(self, connection):
1687         # A ManyToManyField is not represented by a single column,
1688         # so return None.
1689         return None
1690 
1691     def db_parameters(self, connection):
1692         return {"type": None, "check": None}

</code><intended_behavior>Modify or extend the implementation to ensure that when a model having a ManyToManyField is altered, the alteration cascades the changes appropriately to related fields in the intermediary join table.</intended_behavior>, <file>django/db/migrations/autodetector.py</file>
<class>None</class>
<method>None</method>
<code>
1 import functools
2 import re
3 from itertools import chain
4 
5 from django.conf import settings
6 from django.db import models
7 from django.db.migrations import operations
8 from django.db.migrations.migration import Migration
9 from django.db.migrations.operations.models import AlterModelOptions
10 from django.db.migrations.optimizer import MigrationOptimizer
11 from django.db.migrations.questioner import MigrationQuestioner
12 from django.db.migrations.utils import (
13     COMPILED_REGEX_TYPE, RegexObject, get_migration_name_timestamp,
14 )
15 from django.utils.topological_sort import stable_topological_sort
16 
17 
18 class MigrationAutodetector:
19     """
20     Take a pair of ProjectStates and compare them to see what the first would
21     need doing to make it match the second (the second usually being the
22     project's current state).
23 
24     Note that this naturally operates on entire projects at a time,
25     as it's likely that changes interact (for example, you can't
26     add a ForeignKey without having a migration to add the table it
27     depends on first). A user interface may offer single-app usage
28     if it wishes, with the caveat that it may not always be possible.
29     """
30 
31     def __init__(self, from_state, to_state, questioner=None):
32         self.from_state = from_state
33         self.to_state = to_state
34         self.questioner = questioner or MigrationQuestioner()
35         self.existing_apps = {app for app, model in from_state.models}
36 
37     def changes(self, graph, trim_to_apps=None, convert_apps=None, migration_name=None):
38         """
39         Main entry point to produce a list of applicable changes.
40         Take a graph to base names on and an optional set of apps
41         to try and restrict to (restriction is not guaranteed)
42         """
43         changes = self._detect_changes(convert_apps, graph)
44         changes = self.arrange_for_graph(changes, graph, migration_name)
45         if trim_to_apps:
46             changes = self._trim_to_apps(changes, trim_to_apps)
47         return changes
48 
49     def deep_deconstruct(self, obj):
50         """
51         Recursive deconstruction for a field and its arguments.
52         Used for full comparison for rename/alter; sometimes a single-level
53         deconstruction will not compare correctly.
54         """
55         if isinstance(obj, list):
56             return [self.deep_deconstruct(value) for value in obj]
57         elif isinstance(obj, tuple):
58             return tuple(self.deep_deconstruct(value) for value in obj)
59         elif isinstance(obj, dict):
60             return {
61                 key: self.deep_deconstruct(value)
62                 for key, value in obj.items()
63             }
64         elif isinstance(obj, functools.partial):
65             return (obj.func, self.deep_deconstruct(obj.args), self.deep_deconstruct(obj.keywords))
66         elif isinstance(obj, COMPILED_REGEX_TYPE):
67             return RegexObject(obj)
68         elif isinstance(obj, type):
69             # If this is a type that implements 'deconstruct' as an instance method,
70             # avoid treating this as being deconstructible itself - see #22951
71             return obj
72         elif hasattr(obj, 'deconstruct'):
73             deconstructed = obj.deconstruct()
74             if isinstance(obj, models.Field):
75                 # we have a field which also returns a name
76                 deconstructed = deconstructed[1:]
77             path, args, kwargs = deconstructed
78             return (
79                 path,
80                 [self.deep_deconstruct(value) for value in args],
81                 {
82                     key: self.deep_deconstruct(value)
83                     for key, value in kwargs.items()
84                 },
85             )
86         else:
87             return obj
88 
89     def only_relation_agnostic_fields(self, fields):
90         """
91         Return a definition of the fields that ignores field names and
92         what related fields actually relate to. Used for detecting renames (as,
93         of course, the related fields change during renames).
94         """
95         fields_def = []
96         for name, field in sorted(fields):
97             deconstruction = self.deep_deconstruct(field)
98             if field.remote_field and field.remote_field.model:
99                 del deconstruction[2]['to']
100             fields_def.append(deconstruction)
101         return fields_def
102 
103     def _detect_changes(self, convert_apps=None, graph=None):
104         """
105         Return a dict of migration plans which will achieve the
106         change from from_state to to_state. The dict has app labels
107         as keys and a list of migrations as values.
108 
109         The resulting migrations aren't specially named, but the names
110         do matter for dependencies inside the set.
111 
112         convert_apps is the list of apps to convert to use migrations
113         (i.e. to make initial migrations for, in the usual case)
114 
115         graph is an optional argument that, if provided, can help improve
116         dependency generation and avoid potential circular dependencies.
117         """
118         # The first phase is generating all the operations for each app
119         # and gathering them into a big per-app list.
120         # Then go through that list, order it, and split into migrations to
121         # resolve dependencies caused by M2Ms and FKs.
122         self.generated_operations = {}
123         self.altered_indexes = {}
124         self.altered_constraints = {}
125 
126         # Prepare some old/new state and model lists, separating
127         # proxy models and ignoring unmigrated apps.
128         self.old_apps = self.from_state.concrete_apps
129         self.new_apps = self.to_state.apps
130         self.old_model_keys = set()
131         self.old_proxy_keys = set()
132         self.old_unmanaged_keys = set()
133         self.new_model_keys = set()
134         self.new_proxy_keys = set()
135         self.new_unmanaged_keys = set()
136         for al, mn in self.from_state.models:
137             model = self.old_apps.get_model(al, mn)
138             if not model._meta.managed:
139                 self.old_unmanaged_keys.add((al, mn))
140             elif al not in self.from_state.real_apps:
141                 if model._meta.proxy:
142                     self.old_proxy_keys.add((al, mn))
143                 else:
144                     self.old_model_keys.add((al, mn))
145 
146         for al, mn in self.to_state.models:
147             model = self.new_apps.get_model(al, mn)
148             if not model._meta.managed:
149                 self.new_unmanaged_keys.add((al, mn))
150             elif (
151                 al not in self.from_state.real_apps or
152                 (convert_apps and al in convert_apps)
153             ):
154                 if model._meta.proxy:
155                     self.new_proxy_keys.add((al, mn))
156                 else:
157                     self.new_model_keys.add((al, mn))
158 
159         # Renames have to come first
160         self.generate_renamed_models()
161 
162         # Prepare lists of fields and generate through model map
163         self._prepare_field_lists()
164         self._generate_through_model_map()
165 
166         # Generate non-rename model operations
167         self.generate_deleted_models()
168         self.generate_created_models()
169         self.generate_deleted_proxies()
170         self.generate_created_proxies()
171         self.generate_altered_options()
172         self.generate_altered_managers()
173 
174         # Create the altered indexes and store them in self.altered_indexes.
175         # This avoids the same computation in generate_removed_indexes()
176         # and generate_added_indexes().
177         self.create_altered_indexes()
178         self.create_altered_constraints()
179         # Generate index removal operations before field is removed
180         self.generate_removed_constraints()
181         self.generate_removed_indexes()
182         # Generate field operations
183         self.generate_renamed_fields()
184         self.generate_removed_fields()
185         self.generate_added_fields()
186         self.generate_altered_fields()
187         self.generate_altered_unique_together()
188         self.generate_altered_index_together()
189         self.generate_added_indexes()
190         self.generate_added_constraints()
191         self.generate_altered_db_table()
192         self.generate_altered_order_with_respect_to()
193 
194         self._sort_migrations()
195         self._build_migration_list(graph)
196         self._optimize_migrations()
197 
198         return self.migrations
199 
200     def _prepare_field_lists(self):
201         """
202         Prepare field lists and a list of the fields that used through models
203         in the old state so dependencies can be made from the through model
204         deletion to the field that uses it.
205         """
206         self.kept_model_keys = self.old_model_keys & self.new_model_keys
207         self.kept_proxy_keys = self.old_proxy_keys & self.new_proxy_keys
208         self.kept_unmanaged_keys = self.old_unmanaged_keys & self.new_unmanaged_keys
209         self.through_users = {}
210         self.old_field_keys = {
211             (app_label, model_name, x)
212             for app_label, model_name in self.kept_model_keys
213             for x, y in self.from_state.models[
214                 app_label,
215                 self.renamed_models.get((app_label, model_name), model_name)
216             ].fields
217         }
218         self.new_field_keys = {
219             (app_label, model_name, x)
220             for app_label, model_name in self.kept_model_keys
221             for x, y in self.to_state.models[app_label, model_name].fields
222         }
223 
224     def _generate_through_model_map(self):
225         """Through model map generation."""
226         for app_label, model_name in sorted(self.old_model_keys):
227             old_model_name = self.renamed_models.get((app_label, model_name), model_name)
228             old_model_state = self.from_state.models[app_label, old_model_name]
229             for field_name, field in old_model_state.fields:
230                 old_field = self.old_apps.get_model(app_label, old_model_name)._meta.get_field(field_name)
231                 if (hasattr(old_field, "remote_field") and getattr(old_field.remote_field, "through", None) and
232                         not old_field.remote_field.through._meta.auto_created):
233                     through_key = (
234                         old_field.remote_field.through._meta.app_label,
235                         old_field.remote_field.through._meta.model_name,
236                     )
237                     self.through_users[through_key] = (app_label, old_model_name, field_name)
238 
239     @staticmethod
240     def _resolve_dependency(dependency):
241         """
242         Return the resolved dependency and a boolean denoting whether or not
243         it was swappable.
244         """
245         if dependency[0] != '__setting__':
246             return dependency, False
247         resolved_app_label, resolved_object_name = getattr(settings, dependency[1]).split('.')
248         return (resolved_app_label, resolved_object_name.lower()) + dependency[2:], True
249 
250     def _build_migration_list(self, graph=None):
251         """
252         Chop the lists of operations up into migrations with dependencies on
253         each other. Do this by going through an app's list of operations until
254         one is found that has an outgoing dependency that isn't in another
255         app's migration yet (hasn't been chopped off its list). Then chop off
256         the operations before it into a migration and move onto the next app.
257         If the loops completes without doing anything, there's a circular
258         dependency (which _should_ be impossible as the operations are
259         all split at this point so they can't depend and be depended on).
260         """
261         self.migrations = {}
262         num_ops = sum(len(x) for x in self.generated_operations.values())
263         chop_mode = False
264         while num_ops:
265             # On every iteration, we step through all the apps and see if there
266             # is a completed set of operations.
267             # If we find that a subset of the operations are complete we can
268             # try to chop it off from the rest and continue, but we only
269             # do this if we've already been through the list once before
270             # without any chopping and nothing has changed.
271             for app_label in sorted(self.generated_operations):
272                 chopped = []
273                 dependencies = set()
274                 for operation in list(self.generated_operations[app_label]):
275                     deps_satisfied = True
276                     operation_dependencies = set()
277                     for dep in operation._auto_deps:
278                         # Temporarily resolve the swappable dependency to
279                         # prevent circular references. While keeping the
280                         # dependency checks on the resolved model, add the
281                         # swappable dependencies.
282                         original_dep = dep
283                         dep, is_swappable_dep = self._resolve_dependency(dep)
284                         if dep[0] != app_label:
285                             # External app dependency. See if it's not yet
286                             # satisfied.
287                             for other_operation in self.generated_operations.get(dep[0], []):
288                                 if self.check_dependency(other_operation, dep):
289                                     deps_satisfied = False
290                                     break
291                             if not deps_satisfied:
292                                 break
293                             else:
294                                 if is_swappable_dep:
295                                     operation_dependencies.add((original_dep[0], original_dep[1]))
296                                 elif dep[0] in self.migrations:
297                                     operation_dependencies.add((dep[0], self.migrations[dep[0]][-1].name))
298                                 else:
299                                     # If we can't find the other app, we add a first/last dependency,
300                                     # but only if we've already been through once and checked everything
301                                     if chop_mode:
302                                         # If the app already exists, we add a dependency on the last migration,
303                                         # as we don't know which migration contains the target field.
304                                         # If it's not yet migrated or has no migrations, we use __first__
305                                         if graph and graph.leaf_nodes(dep[0]):
306                                             operation_dependencies.add(graph.leaf_nodes(dep[0])[0])
307                                         else:
308                                             operation_dependencies.add((dep[0], "__first__"))
309                                     else:
310                                         deps_satisfied = False
311                     if deps_satisfied:
312                         chopped.append(operation)
313                         dependencies.update(operation_dependencies)
314                         del self.generated_operations[app_label][0]
315                     else:
316                         break
317                 # Make a migration! Well, only if there's stuff to put in it
318                 if dependencies or chopped:
319                     if not self.generated_operations[app_label] or chop_mode:
320                         subclass = type("Migration", (Migration,), {"operations": [], "dependencies": []})
321                         instance = subclass("auto_%i" % (len(self.migrations.get(app_label, [])) + 1), app_label)
322                         instance.dependencies = list(dependencies)
323                         instance.operations = chopped
324                         instance.initial = app_label not in self.existing_apps
325                         self.migrations.setdefault(app_label, []).append(instance)
326                         chop_mode = False
327                     else:
328                         self.generated_operations[app_label] = chopped + self.generated_operations[app_label]
329             new_num_ops = sum(len(x) for x in self.generated_operations.values())
330             if new_num_ops == num_ops:
331                 if not chop_mode:
332                     chop_mode = True
333                 else:
334                     raise ValueError("Cannot resolve operation dependencies: %r" % self.generated_operations)
335             num_ops = new_num_ops
336 
337     def _sort_migrations(self):
338         """
339         Reorder to make things possible. Reordering may be needed so FKs work
340         nicely inside the same app.
341         """
342         for app_label, ops in sorted(self.generated_operations.items()):
343             # construct a dependency graph for intra-app dependencies
344             dependency_graph = {op: set() for op in ops}
345             for op in ops:
346                 for dep in op._auto_deps:
347                     # Resolve intra-app dependencies to handle circular
348                     # references involving a swappable model.
349                     dep = self._resolve_dependency(dep)[0]
350                     if dep[0] == app_label:
351                         for op2 in ops:
352                             if self.check_dependency(op2, dep):
353                                 dependency_graph[op].add(op2)
354 
355             # we use a stable sort for deterministic tests & general behavior
356             self.generated_operations[app_label] = stable_topological_sort(ops, dependency_graph)
357 
358     def _optimize_migrations(self):
359         # Add in internal dependencies among the migrations
360         for app_label, migrations in self.migrations.items():
361             for m1, m2 in zip(migrations, migrations[1:]):
362                 m2.dependencies.append((app_label, m1.name))
363 
364         # De-dupe dependencies
365         for migrations in self.migrations.values():
366             for migration in migrations:
367                 migration.dependencies = list(set(migration.dependencies))
368 
369         # Optimize migrations
370         for app_label, migrations in self.migrations.items():
371             for migration in migrations:
372                 migration.operations = MigrationOptimizer().optimize(migration.operations, app_label)
373 
374     def check_dependency(self, operation, dependency):
375         """
376         Return True if the given operation depends on the given dependency,
377         False otherwise.
378         """
379         # Created model
380         if dependency[2] is None and dependency[3] is True:
381             return (
382                 isinstance(operation, operations.CreateModel) and
383                 operation.name_lower == dependency[1].lower()
384             )
385         # Created field
386         elif dependency[2] is not None and dependency[3] is True:
387             return (
388                 (
389                     isinstance(operation, operations.CreateModel) and
390                     operation.name_lower == dependency[1].lower() and
391                     any(dependency[2] == x for x, y in operation.fields)
392                 ) or
393                 (
394                     isinstance(operation, operations.AddField) and
395                     operation.model_name_lower == dependency[1].lower() and
396                     operation.name_lower == dependency[2].lower()
397                 )
398             )
399         # Removed field
400         elif dependency[2] is not None and dependency[3] is False:
401             return (
402                 isinstance(operation, operations.RemoveField) and
403                 operation.model_name_lower == dependency[1].lower() and
404                 operation.name_lower == dependency[2].lower()
405             )
406         # Removed model
407         elif dependency[2] is None and dependency[3] is False:
408             return (
409                 isinstance(operation, operations.DeleteModel) and
410                 operation.name_lower == dependency[1].lower()
411             )
412         # Field being altered
413         elif dependency[2] is not None and dependency[3] == "alter":
414             return (
415                 isinstance(operation, operations.AlterField) and
416                 operation.model_name_lower == dependency[1].lower() and
417                 operation.name_lower == dependency[2].lower()
418             )
419         # order_with_respect_to being unset for a field
420         elif dependency[2] is not None and dependency[3] == "order_wrt_unset":
421             return (
422                 isinstance(operation, operations.AlterOrderWithRespectTo) and
423                 operation.name_lower == dependency[1].lower() and
424                 (operation.order_with_respect_to or "").lower() != dependency[2].lower()
425             )
426         # Field is removed and part of an index/unique_together
427         elif dependency[2] is not None and dependency[3] == "foo_together_change":
428             return (
429                 isinstance(operation, (operations.AlterUniqueTogether,
430                                        operations.AlterIndexTogether)) and
431                 operation.name_lower == dependency[1].lower()
432             )
433         # Unknown dependency. Raise an error.
434         else:
435             raise ValueError("Can't handle dependency %r" % (dependency,))
436 
437     def add_operation(self, app_label, operation, dependencies=None, beginning=False):
438         # Dependencies are (app_label, model_name, field_name, create/delete as True/False)
439         operation._auto_deps = dependencies or []
440         if beginning:
441             self.generated_operations.setdefault(app_label, []).insert(0, operation)
442         else:
443             self.generated_operations.setdefault(app_label, []).append(operation)
444 
445     def swappable_first_key(self, item):
446         """
447         Place potential swappable models first in lists of created models (only
448         real way to solve #22783).
449         """
450         try:
451             model = self.new_apps.get_model(item[0], item[1])
452             base_names = [base.__name__ for base in model.__bases__]
453             string_version = "%s.%s" % (item[0], item[1])
454             if (
455                 model._meta.swappable or
456                 "AbstractUser" in base_names or
457                 "AbstractBaseUser" in base_names or
458                 settings.AUTH_USER_MODEL.lower() == string_version.lower()
459             ):
460                 return ("___" + item[0], "___" + item[1])
461         except LookupError:
462             pass
463         return item
464 
465     def generate_renamed_models(self):
466         """
467         Find any renamed models, generate the operations for them, and remove
468         the old entry from the model lists. Must be run before other
469         model-level generation.
470         """
471         self.renamed_models = {}
472         self.renamed_models_rel = {}
473         added_models = self.new_model_keys - self.old_model_keys
474         for app_label, model_name in sorted(added_models):
475             model_state = self.to_state.models[app_label, model_name]
476             model_fields_def = self.only_relation_agnostic_fields(model_state.fields)
477 
478             removed_models = self.old_model_keys - self.new_model_keys
479             for rem_app_label, rem_model_name in removed_models:
480                 if rem_app_label == app_label:
481                     rem_model_state = self.from_state.models[rem_app_label, rem_model_name]
482                     rem_model_fields_def = self.only_relation_agnostic_fields(rem_model_state.fields)
483                     if model_fields_def == rem_model_fields_def:
484                         if self.questioner.ask_rename_model(rem_model_state, model_state):
485                             model_opts = self.new_apps.get_model(app_label, model_name)._meta
486                             dependencies = []
487                             for field in model_opts.get_fields():
488                                 if field.is_relation:
489                                     dependencies.extend(self._get_dependencies_for_foreign_key(field))
490                             self.add_operation(
491                                 app_label,
492                                 operations.RenameModel(
493                                     old_name=rem_model_state.name,
494                                     new_name=model_state.name,
495                                 ),
496                                 dependencies=dependencies,
497                             )
498                             self.renamed_models[app_label, model_name] = rem_model_name
499                             renamed_models_rel_key = '%s.%s' % (
500                                 rem_model_state.app_label,
501                                 rem_model_state.name_lower,
502                             )
503                             self.renamed_models_rel[renamed_models_rel_key] = '%s.%s' % (
504                                 model_state.app_label,
505                                 model_state.name_lower,
506                             )
507                             self.old_model_keys.remove((rem_app_label, rem_model_name))
508                             self.old_model_keys.add((app_label, model_name))
509                             break
510 
511     def generate_created_models(self):
512         """
513         Find all new models (both managed and unmanaged) and make create
514         operations for them as well as separate operations to create any
515         foreign key or M2M relationships (these are optimized later, if
516         possible).
517 
518         Defer any model options that refer to collections of fields that might
519         be deferred (e.g. unique_together, index_together).
520         """
521         old_keys = self.old_model_keys | self.old_unmanaged_keys
522         added_models = self.new_model_keys - old_keys
523         added_unmanaged_models = self.new_unmanaged_keys - old_keys
524         all_added_models = chain(
525             sorted(added_models, key=self.swappable_first_key, reverse=True),
526             sorted(added_unmanaged_models, key=self.swappable_first_key, reverse=True)
527         )
528         for app_label, model_name in all_added_models:
529             model_state = self.to_state.models[app_label, model_name]
530             model_opts = self.new_apps.get_model(app_label, model_name)._meta
531             # Gather related fields
532             related_fields = {}
533             primary_key_rel = None
534             for field in model_opts.local_fields:
535                 if field.remote_field:
536                     if field.remote_field.model:
537                         if field.primary_key:
538                             primary_key_rel = field.remote_field.model
539                         elif not field.remote_field.parent_link:
540                             related_fields[field.name] = field
541                     # through will be none on M2Ms on swapped-out models;
542                     # we can treat lack of through as auto_created=True, though.
543                     if (getattr(field.remote_field, "through", None) and
544                             not field.remote_field.through._meta.auto_created):
545                         related_fields[field.name] = field
546             for field in model_opts.local_many_to_many:
547                 if field.remote_field.model:
548                     related_fields[field.name] = field
549                 if getattr(field.remote_field, "through", None) and not field.remote_field.through._meta.auto_created:
550                     related_fields[field.name] = field
551             # Are there indexes/unique|index_together to defer?
552             indexes = model_state.options.pop('indexes')
553             constraints = model_state.options.pop('constraints')
554             unique_together = model_state.options.pop('unique_together', None)
555             index_together = model_state.options.pop('index_together', None)
556             order_with_respect_to = model_state.options.pop('order_with_respect_to', None)
557             # Depend on the deletion of any possible proxy version of us
558             dependencies = [
559                 (app_label, model_name, None, False),
560             ]
561             # Depend on all bases
562             for base in model_state.bases:
563                 if isinstance(base, str) and "." in base:
564                     base_app_label, base_name = base.split(".", 1)
565                     dependencies.append((base_app_label, base_name, None, True))
566             # Depend on the other end of the primary key if it's a relation
567             if primary_key_rel:
568                 dependencies.append((
569                     primary_key_rel._meta.app_label,
570                     primary_key_rel._meta.object_name,
571                     None,
572                     True
573                 ))
574             # Generate creation operation
575             self.add_operation(
576                 app_label,
577                 operations.CreateModel(
578                     name=model_state.name,
579                     fields=[d for d in model_state.fields if d[0] not in related_fields],
580                     options=model_state.options,
581                     bases=model_state.bases,
582                     managers=model_state.managers,
583                 ),
584                 dependencies=dependencies,
585                 beginning=True,
586             )
587 
588             # Don't add operations which modify the database for unmanaged models
589             if not model_opts.managed:
590                 continue
591 
592             # Generate operations for each related field
593             for name, field in sorted(related_fields.items()):
594                 dependencies = self._get_dependencies_for_foreign_key(field)
595                 # Depend on our own model being created
596                 dependencies.append((app_label, model_name, None, True))
597                 # Make operation
598                 self.add_operation(
599                     app_label,
600                     operations.AddField(
601                         model_name=model_name,
602                         name=name,
603                         field=field,
604                     ),
605                     dependencies=list(set(dependencies)),
606                 )
607             # Generate other opns
608             related_dependencies = [
609                 (app_label, model_name, name, True)
610                 for name in sorted(related_fields)
611             ]
612             related_dependencies.append((app_label, model_name, None, True))
613             for index in indexes:
614                 self.add_operation(
615                     app_label,
616                     operations.AddIndex(
617                         model_name=model_name,
618                         index=index,
619                     ),
620                     dependencies=related_dependencies,
621                 )
622             for constraint in constraints:
623                 self.add_operation(
624                     app_label,
625                     operations.AddConstraint(
626                         model_name=model_name,
627                         constraint=constraint,
628                     ),
629                     dependencies=related_dependencies,
630                 )
631             if unique_together:
632                 self.add_operation(
633                     app_label,
634                     operations.AlterUniqueTogether(
635                         name=model_name,
636                         unique_together=unique_together,
637                     ),
638                     dependencies=related_dependencies
639                 )
640             if index_together:
641                 self.add_operation(
642                     app_label,
643                     operations.AlterIndexTogether(
644                         name=model_name,
645                         index_together=index_together,
646                     ),
647                     dependencies=related_dependencies
648                 )
649             if order_with_respect_to:
650                 self.add_operation(
651                     app_label,
652                     operations.AlterOrderWithRespectTo(
653                         name=model_name,
654                         order_with_respect_to=order_with_respect_to,
655                     ),
656                     dependencies=[
657                         (app_label, model_name, order_with_respect_to, True),
658                         (app_label, model_name, None, True),
659                     ]
660                 )
661 
662             # Fix relationships if the model changed from a proxy model to a
663             # concrete model.
664             if (app_label, model_name) in self.old_proxy_keys:
665                 for related_object in model_opts.related_objects:
666                     self.add_operation(
667                         related_object.related_model._meta.app_label,
668                         operations.AlterField(
669                             model_name=related_object.related_model._meta.object_name,
670                             name=related_object.field.name,
671                             field=related_object.field,
672                         ),
673                         dependencies=[(app_label, model_name, None, True)],
674                     )
675 
676     def generate_created_proxies(self):
677         """
678         Make CreateModel statements for proxy models. Use the same statements
679         as that way there's less code duplication, but of course for proxy
680         models it's safe to skip all the pointless field stuff and just chuck
681         out an operation.
682         """
683         added = self.new_proxy_keys - self.old_proxy_keys
684         for app_label, model_name in sorted(added):
685             model_state = self.to_state.models[app_label, model_name]
686             assert model_state.options.get("proxy")
687             # Depend on the deletion of any possible non-proxy version of us
688             dependencies = [
689                 (app_label, model_name, None, False),
690             ]
691             # Depend on all bases
692             for base in model_state.bases:
693                 if isinstance(base, str) and "." in base:
694                     base_app_label, base_name = base.split(".", 1)
695                     dependencies.append((base_app_label, base_name, None, True))
696             # Generate creation operation
697             self.add_operation(
698                 app_label,
699                 operations.CreateModel(
700                     name=model_state.name,
701                     fields=[],
702                     options=model_state.options,
703                     bases=model_state.bases,
704                     managers=model_state.managers,
705                 ),
706                 # Depend on the deletion of any possible non-proxy version of us
707                 dependencies=dependencies,
708             )
709 
710     def generate_deleted_models(self):
711         """
712         Find all deleted models (managed and unmanaged) and make delete
713         operations for them as well as separate operations to delete any
714         foreign key or M2M relationships (these are optimized later, if
715         possible).
716 
717         Also bring forward removal of any model options that refer to
718         collections of fields - the inverse of generate_created_models().
719         """
720         new_keys = self.new_model_keys | self.new_unmanaged_keys
721         deleted_models = self.old_model_keys - new_keys
722         deleted_unmanaged_models = self.old_unmanaged_keys - new_keys
723         all_deleted_models = chain(sorted(deleted_models), sorted(deleted_unmanaged_models))
724         for app_label, model_name in all_deleted_models:
725             model_state = self.from_state.models[app_label, model_name]
726             model = self.old_apps.get_model(app_label, model_name)
727             # Gather related fields
728             related_fields = {}
729             for field in model._meta.local_fields:
730                 if field.remote_field:
731                     if field.remote_field.model:
732                         related_fields[field.name] = field
733                     # through will be none on M2Ms on swapped-out models;
734                     # we can treat lack of through as auto_created=True, though.
735                     if (getattr(field.remote_field, "through", None) and
736                             not field.remote_field.through._meta.auto_created):
737                         related_fields[field.name] = field
738             for field in model._meta.local_many_to_many:
739                 if field.remote_field.model:
740                     related_fields[field.name] = field
741                 if getattr(field.remote_field, "through", None) and not field.remote_field.through._meta.auto_created:
742                     related_fields[field.name] = field
743             # Generate option removal first
744             unique_together = model_state.options.pop('unique_together', None)
745             index_together = model_state.options.pop('index_together', None)
746             if unique_together:
747                 self.add_operation(
748                     app_label,
749                     operations.AlterUniqueTogether(
750                         name=model_name,
751                         unique_together=None,
752                     )
753                 )
754             if index_together:
755                 self.add_operation(
756                     app_label,
757                     operations.AlterIndexTogether(
758                         name=model_name,
759                         index_together=None,
760                     )
761                 )
762             # Then remove each related field
763             for name in sorted(related_fields):
764                 self.add_operation(
765                     app_label,
766                     operations.RemoveField(
767                         model_name=model_name,
768                         name=name,
769                     )
770                 )
771             # Finally, remove the model.
772             # This depends on both the removal/alteration of all incoming fields
773             # and the removal of all its own related fields, and if it's
774             # a through model the field that references it.
775             dependencies = []
776             for related_object in model._meta.related_objects:
777                 related_object_app_label = related_object.related_model._meta.app_label
778                 object_name = related_object.related_model._meta.object_name
779                 field_name = related_object.field.name
780                 dependencies.append((related_object_app_label, object_name, field_name, False))
781                 if not related_object.many_to_many:
782                     dependencies.append((related_object_app_label, object_name, field_name, "alter"))
783 
784             for name in sorted(related_fields):
785                 dependencies.append((app_label, model_name, name, False))
786             # We're referenced in another field's through=
787             through_user = self.through_users.get((app_label, model_state.name_lower))
788             if through_user:
789                 dependencies.append((through_user[0], through_user[1], through_user[2], False))
790             # Finally, make the operation, deduping any dependencies
791             self.add_operation(
792                 app_label,
793                 operations.DeleteModel(
794                     name=model_state.name,
795                 ),
796                 dependencies=list(set(dependencies)),
797             )
798 
799     def generate_deleted_proxies(self):
800         """Make DeleteModel options for proxy models."""
801         deleted = self.old_proxy_keys - self.new_proxy_keys
802         for app_label, model_name in sorted(deleted):
803             model_state = self.from_state.models[app_label, model_name]
804             assert model_state.options.get("proxy")
805             self.add_operation(
806                 app_label,
807                 operations.DeleteModel(
808                     name=model_state.name,
809                 ),
810             )
811 
812     def generate_renamed_fields(self):
813         """Work out renamed fields."""
814         self.renamed_fields = {}
815         for app_label, model_name, field_name in sorted(self.new_field_keys - self.old_field_keys):
816             old_model_name = self.renamed_models.get((app_label, model_name), model_name)
817             old_model_state = self.from_state.models[app_label, old_model_name]
818             field = self.new_apps.get_model(app_label, model_name)._meta.get_field(field_name)
819             # Scan to see if this is actually a rename!
820             field_dec = self.deep_deconstruct(field)
821             for rem_app_label, rem_model_name, rem_field_name in sorted(self.old_field_keys - self.new_field_keys):
822                 if rem_app_label == app_label and rem_model_name == model_name:
823                     old_field = old_model_state.get_field_by_name(rem_field_name)
824                     old_field_dec = self.deep_deconstruct(old_field)
825                     if field.remote_field and field.remote_field.model and 'to' in old_field_dec[2]:
826                         old_rel_to = old_field_dec[2]['to']
827                         if old_rel_to in self.renamed_models_rel:
828                             old_field_dec[2]['to'] = self.renamed_models_rel[old_rel_to]
829                     old_field.set_attributes_from_name(rem_field_name)
830                     old_db_column = old_field.get_attname_column()[1]
831                     if (old_field_dec == field_dec or (
832                             # Was the field renamed and db_column equal to the
833                             # old field's column added?
834                             old_field_dec[0:2] == field_dec[0:2] and
835                             dict(old_field_dec[2], db_column=old_db_column) == field_dec[2])):
836                         if self.questioner.ask_rename(model_name, rem_field_name, field_name, field):
837                             self.add_operation(
838                                 app_label,
839                                 operations.RenameField(
840                                     model_name=model_name,
841                                     old_name=rem_field_name,
842                                     new_name=field_name,
843                                 )
844                             )
845                             self.old_field_keys.remove((rem_app_label, rem_model_name, rem_field_name))
846                             self.old_field_keys.add((app_label, model_name, field_name))
847                             self.renamed_fields[app_label, model_name, field_name] = rem_field_name
848                             break
849 
850     def generate_added_fields(self):
851         """Make AddField operations."""
852         for app_label, model_name, field_name in sorted(self.new_field_keys - self.old_field_keys):
853             self._generate_added_field(app_label, model_name, field_name)
854 
855     def _generate_added_field(self, app_label, model_name, field_name):
856         field = self.new_apps.get_model(app_label, model_name)._meta.get_field(field_name)
857         # Fields that are foreignkeys/m2ms depend on stuff
858         dependencies = []
859         if field.remote_field and field.remote_field.model:
860             dependencies.extend(self._get_dependencies_for_foreign_key(field))
861         # You can't just add NOT NULL fields with no default or fields
862         # which don't allow empty strings as default.
863         time_fields = (models.DateField, models.DateTimeField, models.TimeField)
864         preserve_default = (
865             field.null or field.has_default() or field.many_to_many or
866             (field.blank and field.empty_strings_allowed) or
867             (isinstance(field, time_fields) and field.auto_now)
868         )
869         if not preserve_default:
870             field = field.clone()
871             if isinstance(field, time_fields) and field.auto_now_add:
872                 field.default = self.questioner.ask_auto_now_add_addition(field_name, model_name)
873             else:
874                 field.default = self.questioner.ask_not_null_addition(field_name, model_name)
875         self.add_operation(
876             app_label,
877             operations.AddField(
878                 model_name=model_name,
879                 name=field_name,
880                 field=field,
881                 preserve_default=preserve_default,
882             ),
883             dependencies=dependencies,
884         )
885 
886     def generate_removed_fields(self):
887         """Make RemoveField operations."""
888         for app_label, model_name, field_name in sorted(self.old_field_keys - self.new_field_keys):
889             self._generate_removed_field(app_label, model_name, field_name)
890 
891     def _generate_removed_field(self, app_label, model_name, field_name):
892         self.add_operation(
893             app_label,
894             operations.RemoveField(
895                 model_name=model_name,
896                 name=field_name,
897             ),
898             # We might need to depend on the removal of an
899             # order_with_respect_to or index/unique_together operation;
900             # this is safely ignored if there isn't one
901             dependencies=[
902                 (app_label, model_name, field_name, "order_wrt_unset"),
903                 (app_label, model_name, field_name, "foo_together_change"),
904             ],
905         )
906 
907     def generate_altered_fields(self):
908         """
909         Make AlterField operations, or possibly RemovedField/AddField if alter
910         isn's possible.
911         """
912         for app_label, model_name, field_name in sorted(self.old_field_keys & self.new_field_keys):
913             # Did the field change?
914             old_model_name = self.renamed_models.get((app_label, model_name), model_name)
915             old_field_name = self.renamed_fields.get((app_label, model_name, field_name), field_name)
916             old_field = self.old_apps.get_model(app_label, old_model_name)._meta.get_field(old_field_name)
917             new_field = self.new_apps.get_model(app_label, model_name)._meta.get_field(field_name)
918             dependencies = []
919             # Implement any model renames on relations; these are handled by RenameModel
920             # so we need to exclude them from the comparison
921             if hasattr(new_field, "remote_field") and getattr(new_field.remote_field, "model", None):
922                 rename_key = (
923                     new_field.remote_field.model._meta.app_label,
924                     new_field.remote_field.model._meta.model_name,
925                 )
926                 if rename_key in self.renamed_models:
927                     new_field.remote_field.model = old_field.remote_field.model
928                 # Handle ForeignKey which can only have a single to_field.
929                 remote_field_name = getattr(new_field.remote_field, 'field_name', None)
930                 if remote_field_name:
931                     to_field_rename_key = rename_key + (remote_field_name,)
932                     if to_field_rename_key in self.renamed_fields:
933                         # Repoint both model and field name because to_field
934                         # inclusion in ForeignKey.deconstruct() is based on
935                         # both.
936                         new_field.remote_field.model = old_field.remote_field.model
937                         new_field.remote_field.field_name = old_field.remote_field.field_name
938                 # Handle ForeignObjects which can have multiple from_fields/to_fields.
939                 from_fields = getattr(new_field, 'from_fields', None)
940                 if from_fields:
941                     from_rename_key = (app_label, model_name)
942                     new_field.from_fields = tuple([
943                         self.renamed_fields.get(from_rename_key + (from_field,), from_field)
944                         for from_field in from_fields
945                     ])
946                     new_field.to_fields = tuple([
947                         self.renamed_fields.get(rename_key + (to_field,), to_field)
948                         for to_field in new_field.to_fields
949                     ])
950                 dependencies.extend(self._get_dependencies_for_foreign_key(new_field))
951             if hasattr(new_field, "remote_field") and getattr(new_field.remote_field, "through", None):
952                 rename_key = (
953                     new_field.remote_field.through._meta.app_label,
954                     new_field.remote_field.through._meta.model_name,
955                 )
956                 if rename_key in self.renamed_models:
957                     new_field.remote_field.through = old_field.remote_field.through
958             old_field_dec = self.deep_deconstruct(old_field)
959             new_field_dec = self.deep_deconstruct(new_field)
960             if old_field_dec != new_field_dec:
961                 both_m2m = old_field.many_to_many and new_field.many_to_many
962                 neither_m2m = not old_field.many_to_many and not new_field.many_to_many
963                 if both_m2m or neither_m2m:
964                     # Either both fields are m2m or neither is
965                     preserve_default = True
966                     if (old_field.null and not new_field.null and not new_field.has_default() and
967                             not new_field.many_to_many):
968                         field = new_field.clone()
969                         new_default = self.questioner.ask_not_null_alteration(field_name, model_name)
970                         if new_default is not models.NOT_PROVIDED:
971                             field.default = new_default
972                             preserve_default = False
973                     else:
974                         field = new_field
975                     self.add_operation(
976                         app_label,
977                         operations.AlterField(
978                             model_name=model_name,
979                             name=field_name,
980                             field=field,
981                             preserve_default=preserve_default,
982                         ),
983                         dependencies=dependencies,
984                     )
985                 else:
986                     # We cannot alter between m2m and concrete fields
987                     self._generate_removed_field(app_label, model_name, field_name)
988                     self._generate_added_field(app_label, model_name, field_name)
989 
990     def create_altered_indexes(self):
991         option_name = operations.AddIndex.option_name
992         for app_label, model_name in sorted(self.kept_model_keys):
993             old_model_name = self.renamed_models.get((app_label, model_name), model_name)
994             old_model_state = self.from_state.models[app_label, old_model_name]
995             new_model_state = self.to_state.models[app_label, model_name]
996 
997             old_indexes = old_model_state.options[option_name]
998             new_indexes = new_model_state.options[option_name]
999             add_idx = [idx for idx in new_indexes if idx not in old_indexes]
1000             rem_idx = [idx for idx in old_indexes if idx not in new_indexes]
1001 
1002             self.altered_indexes.update({
1003                 (app_label, model_name): {
1004                     'added_indexes': add_idx, 'removed_indexes': rem_idx,
1005                 }
1006             })
1007 
1008     def generate_added_indexes(self):
1009         for (app_label, model_name), alt_indexes in self.altered_indexes.items():
1010             for index in alt_indexes['added_indexes']:
1011                 self.add_operation(
1012                     app_label,
1013                     operations.AddIndex(
1014                         model_name=model_name,
1015                         index=index,
1016                     )
1017                 )
1018 
1019     def generate_removed_indexes(self):
1020         for (app_label, model_name), alt_indexes in self.altered_indexes.items():
1021             for index in alt_indexes['removed_indexes']:
1022                 self.add_operation(
1023                     app_label,
1024                     operations.RemoveIndex(
1025                         model_name=model_name,
1026                         name=index.name,
1027                     )
1028                 )
1029 
1030     def create_altered_constraints(self):
1031         option_name = operations.AddConstraint.option_name
1032         for app_label, model_name in sorted(self.kept_model_keys):
1033             old_model_name = self.renamed_models.get((app_label, model_name), model_name)
1034             old_model_state = self.from_state.models[app_label, old_model_name]
1035             new_model_state = self.to_state.models[app_label, model_name]
1036 
1037             old_constraints = old_model_state.options[option_name]
1038             new_constraints = new_model_state.options[option_name]
1039             add_constraints = [c for c in new_constraints if c not in old_constraints]
1040             rem_constraints = [c for c in old_constraints if c not in new_constraints]
1041 
1042             self.altered_constraints.update({
1043                 (app_label, model_name): {
1044                     'added_constraints': add_constraints, 'removed_constraints': rem_constraints,
1045                 }
1046             })
1047 
1048     def generate_added_constraints(self):
1049         for (app_label, model_name), alt_constraints in self.altered_constraints.items():
1050             for constraint in alt_constraints['added_constraints']:
1051                 self.add_operation(
1052                     app_label,
1053                     operations.AddConstraint(
1054                         model_name=model_name,
1055                         constraint=constraint,
1056                     )
1057                 )
1058 
1059     def generate_removed_constraints(self):
1060         for (app_label, model_name), alt_constraints in self.altered_constraints.items():
1061             for constraint in alt_constraints['removed_constraints']:
1062                 self.add_operation(
1063                     app_label,
1064                     operations.RemoveConstraint(
1065                         model_name=model_name,
1066                         name=constraint.name,
1067                     )
1068                 )
1069 
1070     def _get_dependencies_for_foreign_key(self, field):
1071         # Account for FKs to swappable models
1072         swappable_setting = getattr(field, 'swappable_setting', None)
1073         if swappable_setting is not None:
1074             dep_app_label = "__setting__"
1075             dep_object_name = swappable_setting
1076         else:
1077             dep_app_label = field.remote_field.model._meta.app_label
1078             dep_object_name = field.remote_field.model._meta.object_name
1079         dependencies = [(dep_app_label, dep_object_name, None, True)]
1080         if getattr(field.remote_field, "through", None) and not field.remote_field.through._meta.auto_created:
1081             dependencies.append((
1082                 field.remote_field.through._meta.app_label,
1083                 field.remote_field.through._meta.object_name,
1084                 None,
1085                 True,
1086             ))
1087         return dependencies
1088 
1089     def _generate_altered_foo_together(self, operation):
1090         option_name = operation.option_name
1091         for app_label, model_name in sorted(self.kept_model_keys):
1092             old_model_name = self.renamed_models.get((app_label, model_name), model_name)
1093             old_model_state = self.from_state.models[app_label, old_model_name]
1094             new_model_state = self.to_state.models[app_label, model_name]
1095 
1096             # We run the old version through the field renames to account for those
1097             old_value = old_model_state.options.get(option_name)
1098             old_value = {
1099                 tuple(
1100                     self.renamed_fields.get((app_label, model_name, n), n)
1101                     for n in unique
1102                 )
1103                 for unique in old_value
1104             } if old_value else set()
1105 
1106             new_value = new_model_state.options.get(option_name)
1107             new_value = set(new_value) if new_value else set()
1108 
1109             if old_value != new_value:
1110                 dependencies = []
1111                 for foo_togethers in new_value:
1112                     for field_name in foo_togethers:
1113                         field = self.new_apps.get_model(app_label, model_name)._meta.get_field(field_name)
1114                         if field.remote_field and field.remote_field.model:
1115                             dependencies.extend(self._get_dependencies_for_foreign_key(field))
1116 
1117                 self.add_operation(
1118                     app_label,
1119                     operation(
1120                         name=model_name,
1121                         **{option_name: new_value}
1122                     ),
1123                     dependencies=dependencies,
1124                 )
1125 
1126     def generate_altered_unique_together(self):
1127         self._generate_altered_foo_together(operations.AlterUniqueTogether)
1128 
1129     def generate_altered_index_together(self):
1130         self._generate_altered_foo_together(operations.AlterIndexTogether)
1131 
1132     def generate_altered_db_table(self):
1133         models_to_check = self.kept_model_keys.union(self.kept_proxy_keys, self.kept_unmanaged_keys)
1134         for app_label, model_name in sorted(models_to_check):
1135             old_model_name = self.renamed_models.get((app_label, model_name), model_name)
1136             old_model_state = self.from_state.models[app_label, old_model_name]
1137             new_model_state = self.to_state.models[app_label, model_name]
1138             old_db_table_name = old_model_state.options.get('db_table')
1139             new_db_table_name = new_model_state.options.get('db_table')
1140             if old_db_table_name != new_db_table_name:
1141                 self.add_operation(
1142                     app_label,
1143                     operations.AlterModelTable(
1144                         name=model_name,
1145                         table=new_db_table_name,
1146                     )
1147                 )
1148 
1149     def generate_altered_options(self):
1150         """
1151         Work out if any non-schema-affecting options have changed and make an
1152         operation to represent them in state changes (in case Python code in
1153         migrations needs them).
1154         """
1155         models_to_check = self.kept_model_keys.union(
1156             self.kept_proxy_keys,
1157             self.kept_unmanaged_keys,
1158             # unmanaged converted to managed
1159             self.old_unmanaged_keys & self.new_model_keys,
1160             # managed converted to unmanaged
1161             self.old_model_keys & self.new_unmanaged_keys,
1162         )
1163 
1164         for app_label, model_name in sorted(models_to_check):
1165             old_model_name = self.renamed_models.get((app_label, model_name), model_name)
1166             old_model_state = self.from_state.models[app_label, old_model_name]
1167             new_model_state = self.to_state.models[app_label, model_name]
1168             old_options = {
1169                 key: value for key, value in old_model_state.options.items()
1170                 if key in AlterModelOptions.ALTER_OPTION_KEYS
1171             }
1172             new_options = {
1173                 key: value for key, value in new_model_state.options.items()
1174                 if key in AlterModelOptions.ALTER_OPTION_KEYS
1175             }
1176             if old_options != new_options:
1177                 self.add_operation(
1178                     app_label,
1179                     operations.AlterModelOptions(
1180                         name=model_name,
1181                         options=new_options,
1182                     )
1183                 )
1184 
1185     def generate_altered_order_with_respect_to(self):
1186         for app_label, model_name in sorted(self.kept_model_keys):
1187             old_model_name = self.renamed_models.get((app_label, model_name), model_name)
1188             old_model_state = self.from_state.models[app_label, old_model_name]
1189             new_model_state = self.to_state.models[app_label, model_name]
1190             if (old_model_state.options.get("order_with_respect_to") !=
1191                     new_model_state.options.get("order_with_respect_to")):
1192                 # Make sure it comes second if we're adding
1193                 # (removal dependency is part of RemoveField)
1194                 dependencies = []
1195                 if new_model_state.options.get("order_with_respect_to"):
1196                     dependencies.append((
1197                         app_label,
1198                         model_name,
1199                         new_model_state.options["order_with_respect_to"],
1200                         True,
1201                     ))
1202                 # Actually generate the operation
1203                 self.add_operation(
1204                     app_label,
1205                     operations.AlterOrderWithRespectTo(
1206                         name=model_name,
1207                         order_with_respect_to=new_model_state.options.get('order_with_respect_to'),
1208                     ),
1209                     dependencies=dependencies,
1210                 )
1211 
1212     def generate_altered_managers(self):
1213         for app_label, model_name in sorted(self.kept_model_keys):
1214             old_model_name = self.renamed_models.get((app_label, model_name), model_name)
1215             old_model_state = self.from_state.models[app_label, old_model_name]
1216             new_model_state = self.to_state.models[app_label, model_name]
1217             if old_model_state.managers != new_model_state.managers:
1218                 self.add_operation(
1219                     app_label,
1220                     operations.AlterModelManagers(
1221                         name=model_name,
1222                         managers=new_model_state.managers,
1223                     )
1224                 )
1225 
1226     def arrange_for_graph(self, changes, graph, migration_name=None):
1227         """
1228         Take a result from changes() and a MigrationGraph, and fix the names
1229         and dependencies of the changes so they extend the graph from the leaf
1230         nodes for each app.
1231         """
1232         leaves = graph.leaf_nodes()
1233         name_map = {}
1234         for app_label, migrations in list(changes.items()):
1235             if not migrations:
1236                 continue
1237             # Find the app label's current leaf node
1238             app_leaf = None
1239             for leaf in leaves:
1240                 if leaf[0] == app_label:
1241                     app_leaf = leaf
1242                     break
1243             # Do they want an initial migration for this app?
1244             if app_leaf is None and not self.questioner.ask_initial(app_label):
1245                 # They don't.
1246                 for migration in migrations:
1247                     name_map[(app_label, migration.name)] = (app_label, "__first__")
1248                 del changes[app_label]
1249                 continue
1250             # Work out the next number in the sequence
1251             if app_leaf is None:
1252                 next_number = 1
1253             else:
1254                 next_number = (self.parse_number(app_leaf[1]) or 0) + 1
1255             # Name each migration
1256             for i, migration in enumerate(migrations):
1257                 if i == 0 and app_leaf:
1258                     migration.dependencies.append(app_leaf)
1259                 if i == 0 and not app_leaf:
1260                     new_name = "0001_%s" % migration_name if migration_name else "0001_initial"
1261                 else:
1262                     new_name = "%04i_%s" % (
1263                         next_number,
1264                         migration_name or self.suggest_name(migration.operations)[:100],
1265                     )
1266                 name_map[(app_label, migration.name)] = (app_label, new_name)
1267                 next_number += 1
1268                 migration.name = new_name
1269         # Now fix dependencies
1270         for migrations in changes.values():
1271             for migration in migrations:
1272                 migration.dependencies = [name_map.get(d, d) for d in migration.dependencies]
1273         return changes
1274 
1275     def _trim_to_apps(self, changes, app_labels):
1276         """
1277         Take changes from arrange_for_graph() and set of app labels, and return
1278         a modified set of changes which trims out as many migrations that are
1279         not in app_labels as possible. Note that some other migrations may
1280         still be present as they may be required dependencies.
1281         """
1282         # Gather other app dependencies in a first pass
1283         app_dependencies = {}
1284         for app_label, migrations in changes.items():
1285             for migration in migrations:
1286                 for dep_app_label, name in migration.dependencies:
1287                     app_dependencies.setdefault(app_label, set()).add(dep_app_label)
1288         required_apps = set(app_labels)
1289         # Keep resolving till there's no change
1290         old_required_apps = None
1291         while old_required_apps != required_apps:
1292             old_required_apps = set(required_apps)
1293             required_apps.update(*[app_dependencies.get(app_label, ()) for app_label in required_apps])
1294         # Remove all migrations that aren't needed
1295         for app_label in list(changes):
1296             if app_label not in required_apps:
1297                 del changes[app_label]
1298         return changes
1299 
1300     @classmethod
1301     def suggest_name(cls, ops):
1302         """
1303         Given a set of operations, suggest a name for the migration they might
1304         represent. Names are not guaranteed to be unique, but put some effort
1305         into the fallback name to avoid VCS conflicts if possible.
1306         """
1307         if len(ops) == 1:
1308             if isinstance(ops[0], operations.CreateModel):
1309                 return ops[0].name_lower
1310             elif isinstance(ops[0], operations.DeleteModel):
1311                 return "delete_%s" % ops[0].name_lower
1312             elif isinstance(ops[0], operations.AddField):
1313                 return "%s_%s" % (ops[0].model_name_lower, ops[0].name_lower)
1314             elif isinstance(ops[0], operations.RemoveField):
1315                 return "remove_%s_%s" % (ops[0].model_name_lower, ops[0].name_lower)
1316         elif ops:
1317             if all(isinstance(o, operations.CreateModel) for o in ops):
1318                 return "_".join(sorted(o.name_lower for o in ops))
1319         return "auto_%s" % get_migration_name_timestamp()
1320 
1321     @classmethod
1322     def parse_number(cls, name):
1323         """
1324         Given a migration name, try to extract a number from the beginning of
1325         it. If no number is found, return None.
1326         """
1327         match = re.match(r'^\d+', name)
1328         if match:
1329             return int(match.group())
1330         return None

</code><intended_behavior>Ensure the migration autodetector is capable of detecting changes in fields of a model and the implications on related fields, specifically in ManyToManyField relationships, possibly altering related database table schemas.</intended_behavior>]
2025-10-15 17:44:07.749 | INFO     | Search completed. Bug locations: [<file>django/db/models/fields/related.py</file>
<class>ManyToManyField</class>
<method>None</method>
<code>
1120 class ManyToManyField(RelatedField):
1121     """
1122     Provide a many-to-many relation by using an intermediary model that
1123     holds two ForeignKey fields pointed at the two sides of the relation.
1124 
1125     Unless a ``through`` model was provided, ManyToManyField will use the
1126     create_many_to_many_intermediary_model factory to automatically generate
1127     the intermediary model.
1128     """
1129 
1130     # Field flags
1131     many_to_many = True
1132     many_to_one = False
1133     one_to_many = False
1134     one_to_one = False
1135 
1136     rel_class = ManyToManyRel
1137 
1138     description = _("Many-to-many relationship")
1139 
1140     def __init__(self, to, related_name=None, related_query_name=None,
1141                  limit_choices_to=None, symmetrical=None, through=None,
1142                  through_fields=None, db_constraint=True, db_table=None,
1143                  swappable=True, **kwargs):
1144         try:
1145             to._meta
1146         except AttributeError:
1147             assert isinstance(to, str), (
1148                 "%s(%r) is invalid. First parameter to ManyToManyField must be "
1149                 "either a model, a model name, or the string %r" %
1150                 (self.__class__.__name__, to, RECURSIVE_RELATIONSHIP_CONSTANT)
1151             )
1152 
1153         if symmetrical is None:
1154             symmetrical = (to == RECURSIVE_RELATIONSHIP_CONSTANT)
1155 
1156         if through is not None:
1157             assert db_table is None, (
1158                 "Cannot specify a db_table if an intermediary model is used."
1159             )
1160 
1161         kwargs['rel'] = self.rel_class(
1162             self, to,
1163             related_name=related_name,
1164             related_query_name=related_query_name,
1165             limit_choices_to=limit_choices_to,
1166             symmetrical=symmetrical,
1167             through=through,
1168             through_fields=through_fields,
1169             db_constraint=db_constraint,
1170         )
1171         self.has_null_arg = 'null' in kwargs
1172 
1173         super().__init__(**kwargs)
1174 
1175         self.db_table = db_table
1176         self.swappable = swappable
1177 
1178     def check(self, **kwargs):
1179         return [
1180             *super().check(**kwargs),
1181             *self._check_unique(**kwargs),
1182             *self._check_relationship_model(**kwargs),
1183             *self._check_ignored_options(**kwargs),
1184             *self._check_table_uniqueness(**kwargs),
1185         ]
1186 
1187     def _check_unique(self, **kwargs):
1188         if self.unique:
1189             return [
1190                 checks.Error(
1191                     'ManyToManyFields cannot be unique.',
1192                     obj=self,
1193                     id='fields.E330',
1194                 )
1195             ]
1196         return []
1197 
1198     def _check_ignored_options(self, **kwargs):
1199         warnings = []
1200 
1201         if self.has_null_arg:
1202             warnings.append(
1203                 checks.Warning(
1204                     'null has no effect on ManyToManyField.',
1205                     obj=self,
1206                     id='fields.W340',
1207                 )
1208             )
1209 
1210         if self._validators:
1211             warnings.append(
1212                 checks.Warning(
1213                     'ManyToManyField does not support validators.',
1214                     obj=self,
1215                     id='fields.W341',
1216                 )
1217             )
1218         if (self.remote_field.limit_choices_to and self.remote_field.through and
1219                 not self.remote_field.through._meta.auto_created):
1220             warnings.append(
1221                 checks.Warning(
1222                     'limit_choices_to has no effect on ManyToManyField '
1223                     'with a through model.',
1224                     obj=self,
1225                     id='fields.W343',
1226                 )
1227             )
1228 
1229         return warnings
1230 
1231     def _check_relationship_model(self, from_model=None, **kwargs):
1232         if hasattr(self.remote_field.through, '_meta'):
1233             qualified_model_name = "%s.%s" % (
1234                 self.remote_field.through._meta.app_label, self.remote_field.through.__name__)
1235         else:
1236             qualified_model_name = self.remote_field.through
1237 
1238         errors = []
1239 
1240         if self.remote_field.through not in self.opts.apps.get_models(include_auto_created=True):
1241             # The relationship model is not installed.
1242             errors.append(
1243                 checks.Error(
1244                     "Field specifies a many-to-many relation through model "
1245                     "'%s', which has not been installed." % qualified_model_name,
1246                     obj=self,
1247                     id='fields.E331',
1248                 )
1249             )
1250 
1251         else:
1252             assert from_model is not None, (
1253                 "ManyToManyField with intermediate "
1254                 "tables cannot be checked if you don't pass the model "
1255                 "where the field is attached to."
1256             )
1257             # Set some useful local variables
1258             to_model = resolve_relation(from_model, self.remote_field.model)
1259             from_model_name = from_model._meta.object_name
1260             if isinstance(to_model, str):
1261                 to_model_name = to_model
1262             else:
1263                 to_model_name = to_model._meta.object_name
1264             relationship_model_name = self.remote_field.through._meta.object_name
1265             self_referential = from_model == to_model
1266             # Count foreign keys in intermediate model
1267             if self_referential:
1268                 seen_self = sum(
1269                     from_model == getattr(field.remote_field, 'model', None)
1270                     for field in self.remote_field.through._meta.fields
1271                 )
1272 
1273                 if seen_self > 2 and not self.remote_field.through_fields:
1274                     errors.append(
1275                         checks.Error(
1276                             "The model is used as an intermediate model by "
1277                             "'%s', but it has more than two foreign keys "
1278                             "to '%s', which is ambiguous. You must specify "
1279                             "which two foreign keys Django should use via the "
1280                             "through_fields keyword argument." % (self, from_model_name),
1281                             hint="Use through_fields to specify which two foreign keys Django should use.",
1282                             obj=self.remote_field.through,
1283                             id='fields.E333',
1284                         )
1285                     )
1286 
1287             else:
1288                 # Count foreign keys in relationship model
1289                 seen_from = sum(
1290                     from_model == getattr(field.remote_field, 'model', None)
1291                     for field in self.remote_field.through._meta.fields
1292                 )
1293                 seen_to = sum(
1294                     to_model == getattr(field.remote_field, 'model', None)
1295                     for field in self.remote_field.through._meta.fields
1296                 )
1297 
1298                 if seen_from > 1 and not self.remote_field.through_fields:
1299                     errors.append(
1300                         checks.Error(
1301                             ("The model is used as an intermediate model by "
1302                              "'%s', but it has more than one foreign key "
1303                              "from '%s', which is ambiguous. You must specify "
1304                              "which foreign key Django should use via the "
1305                              "through_fields keyword argument.") % (self, from_model_name),
1306                             hint=(
1307                                 'If you want to create a recursive relationship, '
1308                                 'use ManyToManyField("%s", through="%s").'
1309                             ) % (
1310                                 RECURSIVE_RELATIONSHIP_CONSTANT,
1311                                 relationship_model_name,
1312                             ),
1313                             obj=self,
1314                             id='fields.E334',
1315                         )
1316                     )
1317 
1318                 if seen_to > 1 and not self.remote_field.through_fields:
1319                     errors.append(
1320                         checks.Error(
1321                             "The model is used as an intermediate model by "
1322                             "'%s', but it has more than one foreign key "
1323                             "to '%s', which is ambiguous. You must specify "
1324                             "which foreign key Django should use via the "
1325                             "through_fields keyword argument." % (self, to_model_name),
1326                             hint=(
1327                                 'If you want to create a recursive relationship, '
1328                                 'use ManyToManyField("%s", through="%s").'
1329                             ) % (
1330                                 RECURSIVE_RELATIONSHIP_CONSTANT,
1331                                 relationship_model_name,
1332                             ),
1333                             obj=self,
1334                             id='fields.E335',
1335                         )
1336                     )
1337 
1338                 if seen_from == 0 or seen_to == 0:
1339                     errors.append(
1340                         checks.Error(
1341                             "The model is used as an intermediate model by "
1342                             "'%s', but it does not have a foreign key to '%s' or '%s'." % (
1343                                 self, from_model_name, to_model_name
1344                             ),
1345                             obj=self.remote_field.through,
1346                             id='fields.E336',
1347                         )
1348                     )
1349 
1350         # Validate `through_fields`.
1351         if self.remote_field.through_fields is not None:
1352             # Validate that we're given an iterable of at least two items
1353             # and that none of them is "falsy".
1354             if not (len(self.remote_field.through_fields) >= 2 and
1355                     self.remote_field.through_fields[0] and self.remote_field.through_fields[1]):
1356                 errors.append(
1357                     checks.Error(
1358                         "Field specifies 'through_fields' but does not provide "
1359                         "the names of the two link fields that should be used "
1360                         "for the relation through model '%s'." % qualified_model_name,
1361                         hint="Make sure you specify 'through_fields' as through_fields=('field1', 'field2')",
1362                         obj=self,
1363                         id='fields.E337',
1364                     )
1365                 )
1366 
1367             # Validate the given through fields -- they should be actual
1368             # fields on the through model, and also be foreign keys to the
1369             # expected models.
1370             else:
1371                 assert from_model is not None, (
1372                     "ManyToManyField with intermediate "
1373                     "tables cannot be checked if you don't pass the model "
1374                     "where the field is attached to."
1375                 )
1376 
1377                 source, through, target = from_model, self.remote_field.through, self.remote_field.model
1378                 source_field_name, target_field_name = self.remote_field.through_fields[:2]
1379 
1380                 for field_name, related_model in ((source_field_name, source),
1381                                                   (target_field_name, target)):
1382 
1383                     possible_field_names = []
1384                     for f in through._meta.fields:
1385                         if hasattr(f, 'remote_field') and getattr(f.remote_field, 'model', None) == related_model:
1386                             possible_field_names.append(f.name)
1387                     if possible_field_names:
1388                         hint = "Did you mean one of the following foreign keys to '%s': %s?" % (
1389                             related_model._meta.object_name,
1390                             ', '.join(possible_field_names),
1391                         )
1392                     else:
1393                         hint = None
1394 
1395                     try:
1396                         field = through._meta.get_field(field_name)
1397                     except exceptions.FieldDoesNotExist:
1398                         errors.append(
1399                             checks.Error(
1400                                 "The intermediary model '%s' has no field '%s'."
1401                                 % (qualified_model_name, field_name),
1402                                 hint=hint,
1403                                 obj=self,
1404                                 id='fields.E338',
1405                             )
1406                         )
1407                     else:
1408                         if not (hasattr(field, 'remote_field') and
1409                                 getattr(field.remote_field, 'model', None) == related_model):
1410                             errors.append(
1411                                 checks.Error(
1412                                     "'%s.%s' is not a foreign key to '%s'." % (
1413                                         through._meta.object_name, field_name,
1414                                         related_model._meta.object_name,
1415                                     ),
1416                                     hint=hint,
1417                                     obj=self,
1418                                     id='fields.E339',
1419                                 )
1420                             )
1421 
1422         return errors
1423 
1424     def _check_table_uniqueness(self, **kwargs):
1425         if isinstance(self.remote_field.through, str) or not self.remote_field.through._meta.managed:
1426             return []
1427         registered_tables = {
1428             model._meta.db_table: model
1429             for model in self.opts.apps.get_models(include_auto_created=True)
1430             if model != self.remote_field.through and model._meta.managed
1431         }
1432         m2m_db_table = self.m2m_db_table()
1433         model = registered_tables.get(m2m_db_table)
1434         # The second condition allows multiple m2m relations on a model if
1435         # some point to a through model that proxies another through model.
1436         if model and model._meta.concrete_model != self.remote_field.through._meta.concrete_model:
1437             if model._meta.auto_created:
1438                 def _get_field_name(model):
1439                     for field in model._meta.auto_created._meta.many_to_many:
1440                         if field.remote_field.through is model:
1441                             return field.name
1442                 opts = model._meta.auto_created._meta
1443                 clashing_obj = '%s.%s' % (opts.label, _get_field_name(model))
1444             else:
1445                 clashing_obj = model._meta.label
1446             if settings.DATABASE_ROUTERS:
1447                 error_class, error_id = checks.Warning, 'fields.W344'
1448                 error_hint = (
1449                     'You have configured settings.DATABASE_ROUTERS. Verify '
1450                     'that the table of %r is correctly routed to a separate '
1451                     'database.' % clashing_obj
1452                 )
1453             else:
1454                 error_class, error_id = checks.Error, 'fields.E340'
1455                 error_hint = None
1456             return [
1457                 error_class(
1458                     "The field's intermediary table '%s' clashes with the "
1459                     "table name of '%s'." % (m2m_db_table, clashing_obj),
1460                     obj=self,
1461                     hint=error_hint,
1462                     id=error_id,
1463                 )
1464             ]
1465         return []
1466 
1467     def deconstruct(self):
1468         name, path, args, kwargs = super().deconstruct()
1469         # Handle the simpler arguments.
1470         if self.db_table is not None:
1471             kwargs['db_table'] = self.db_table
1472         if self.remote_field.db_constraint is not True:
1473             kwargs['db_constraint'] = self.remote_field.db_constraint
1474         # Rel needs more work.
1475         if isinstance(self.remote_field.model, str):
1476             kwargs['to'] = self.remote_field.model
1477         else:
1478             kwargs['to'] = "%s.%s" % (
1479                 self.remote_field.model._meta.app_label,
1480                 self.remote_field.model._meta.object_name,
1481             )
1482         if getattr(self.remote_field, 'through', None) is not None:
1483             if isinstance(self.remote_field.through, str):
1484                 kwargs['through'] = self.remote_field.through
1485             elif not self.remote_field.through._meta.auto_created:
1486                 kwargs['through'] = "%s.%s" % (
1487                     self.remote_field.through._meta.app_label,
1488                     self.remote_field.through._meta.object_name,
1489                 )
1490         # If swappable is True, then see if we're actually pointing to the target
1491         # of a swap.
1492         swappable_setting = self.swappable_setting
1493         if swappable_setting is not None:
1494             # If it's already a settings reference, error.
1495             if hasattr(kwargs['to'], "setting_name"):
1496                 if kwargs['to'].setting_name != swappable_setting:
1497                     raise ValueError(
1498                         "Cannot deconstruct a ManyToManyField pointing to a "
1499                         "model that is swapped in place of more than one model "
1500                         "(%s and %s)" % (kwargs['to'].setting_name, swappable_setting)
1501                     )
1502 
1503             kwargs['to'] = SettingsReference(
1504                 kwargs['to'],
1505                 swappable_setting,
1506             )
1507         return name, path, args, kwargs
1508 
1509     def _get_path_info(self, direct=False, filtered_relation=None):
1510         """Called by both direct and indirect m2m traversal."""
1511         int_model = self.remote_field.through
1512         linkfield1 = int_model._meta.get_field(self.m2m_field_name())
1513         linkfield2 = int_model._meta.get_field(self.m2m_reverse_field_name())
1514         if direct:
1515             join1infos = linkfield1.get_reverse_path_info()
1516             join2infos = linkfield2.get_path_info(filtered_relation)
1517         else:
1518             join1infos = linkfield2.get_reverse_path_info()
1519             join2infos = linkfield1.get_path_info(filtered_relation)
1520 
1521         # Get join infos between the last model of join 1 and the first model
1522         # of join 2. Assume the only reason these may differ is due to model
1523         # inheritance.
1524         join1_final = join1infos[-1].to_opts
1525         join2_initial = join2infos[0].from_opts
1526         if join1_final is join2_initial:
1527             intermediate_infos = []
1528         elif issubclass(join1_final.model, join2_initial.model):
1529             intermediate_infos = join1_final.get_path_to_parent(join2_initial.model)
1530         else:
1531             intermediate_infos = join2_initial.get_path_from_parent(join1_final.model)
1532 
1533         return [*join1infos, *intermediate_infos, *join2infos]
1534 
1535     def get_path_info(self, filtered_relation=None):
1536         return self._get_path_info(direct=True, filtered_relation=filtered_relation)
1537 
1538     def get_reverse_path_info(self, filtered_relation=None):
1539         return self._get_path_info(direct=False, filtered_relation=filtered_relation)
1540 
1541     def _get_m2m_db_table(self, opts):
1542         """
1543         Function that can be curried to provide the m2m table name for this
1544         relation.
1545         """
1546         if self.remote_field.through is not None:
1547             return self.remote_field.through._meta.db_table
1548         elif self.db_table:
1549             return self.db_table
1550         else:
1551             m2m_table_name = '%s_%s' % (utils.strip_quotes(opts.db_table), self.name)
1552             return utils.truncate_name(m2m_table_name, connection.ops.max_name_length())
1553 
1554     def _get_m2m_attr(self, related, attr):
1555         """
1556         Function that can be curried to provide the source accessor or DB
1557         column name for the m2m table.
1558         """
1559         cache_attr = '_m2m_%s_cache' % attr
1560         if hasattr(self, cache_attr):
1561             return getattr(self, cache_attr)
1562         if self.remote_field.through_fields is not None:
1563             link_field_name = self.remote_field.through_fields[0]
1564         else:
1565             link_field_name = None
1566         for f in self.remote_field.through._meta.fields:
1567             if (f.is_relation and f.remote_field.model == related.related_model and
1568                     (link_field_name is None or link_field_name == f.name)):
1569                 setattr(self, cache_attr, getattr(f, attr))
1570                 return getattr(self, cache_attr)
1571 
1572     def _get_m2m_reverse_attr(self, related, attr):
1573         """
1574         Function that can be curried to provide the related accessor or DB
1575         column name for the m2m table.
1576         """
1577         cache_attr = '_m2m_reverse_%s_cache' % attr
1578         if hasattr(self, cache_attr):
1579             return getattr(self, cache_attr)
1580         found = False
1581         if self.remote_field.through_fields is not None:
1582             link_field_name = self.remote_field.through_fields[1]
1583         else:
1584             link_field_name = None
1585         for f in self.remote_field.through._meta.fields:
1586             if f.is_relation and f.remote_field.model == related.model:
1587                 if link_field_name is None and related.related_model == related.model:
1588                     # If this is an m2m-intermediate to self,
1589                     # the first foreign key you find will be
1590                     # the source column. Keep searching for
1591                     # the second foreign key.
1592                     if found:
1593                         setattr(self, cache_attr, getattr(f, attr))
1594                         break
1595                     else:
1596                         found = True
1597                 elif link_field_name is None or link_field_name == f.name:
1598                     setattr(self, cache_attr, getattr(f, attr))
1599                     break
1600         return getattr(self, cache_attr)
1601 
1602     def contribute_to_class(self, cls, name, **kwargs):
1603         # To support multiple relations to self, it's useful to have a non-None
1604         # related name on symmetrical relations for internal reasons. The
1605         # concept doesn't make a lot of sense externally ("you want me to
1606         # specify *what* on my non-reversible relation?!"), so we set it up
1607         # automatically. The funky name reduces the chance of an accidental
1608         # clash.
1609         if self.remote_field.symmetrical and (
1610             self.remote_field.model == RECURSIVE_RELATIONSHIP_CONSTANT or
1611             self.remote_field.model == cls._meta.object_name
1612         ):
1613             self.remote_field.related_name = "%s_rel_+" % name
1614         elif self.remote_field.is_hidden():
1615             # If the backwards relation is disabled, replace the original
1616             # related_name with one generated from the m2m field name. Django
1617             # still uses backwards relations internally and we need to avoid
1618             # clashes between multiple m2m fields with related_name == '+'.
1619             self.remote_field.related_name = "_%s_%s_+" % (cls.__name__.lower(), name)
1620 
1621         super().contribute_to_class(cls, name, **kwargs)
1622 
1623         # The intermediate m2m model is not auto created if:
1624         #  1) There is a manually specified intermediate, or
1625         #  2) The class owning the m2m field is abstract.
1626         #  3) The class owning the m2m field has been swapped out.
1627         if not cls._meta.abstract:
1628             if self.remote_field.through:
1629                 def resolve_through_model(_, model, field):
1630                     field.remote_field.through = model
1631                 lazy_related_operation(resolve_through_model, cls, self.remote_field.through, field=self)
1632             elif not cls._meta.swapped:
1633                 self.remote_field.through = create_many_to_many_intermediary_model(self, cls)
1634 
1635         # Add the descriptor for the m2m relation.
1636         setattr(cls, self.name, ManyToManyDescriptor(self.remote_field, reverse=False))
1637 
1638         # Set up the accessor for the m2m table name for the relation.
1639         self.m2m_db_table = partial(self._get_m2m_db_table, cls._meta)
1640 
1641     def contribute_to_related_class(self, cls, related):
1642         # Internal M2Ms (i.e., those with a related name ending with '+')
1643         # and swapped models don't get a related descriptor.
1644         if not self.remote_field.is_hidden() and not related.related_model._meta.swapped:
1645             setattr(cls, related.get_accessor_name(), ManyToManyDescriptor(self.remote_field, reverse=True))
1646 
1647         # Set up the accessors for the column names on the m2m table.
1648         self.m2m_column_name = partial(self._get_m2m_attr, related, 'column')
1649         self.m2m_reverse_name = partial(self._get_m2m_reverse_attr, related, 'column')
1650 
1651         self.m2m_field_name = partial(self._get_m2m_attr, related, 'name')
1652         self.m2m_reverse_field_name = partial(self._get_m2m_reverse_attr, related, 'name')
1653 
1654         get_m2m_rel = partial(self._get_m2m_attr, related, 'remote_field')
1655         self.m2m_target_field_name = lambda: get_m2m_rel().field_name
1656         get_m2m_reverse_rel = partial(self._get_m2m_reverse_attr, related, 'remote_field')
1657         self.m2m_reverse_target_field_name = lambda: get_m2m_reverse_rel().field_name
1658 
1659     def set_attributes_from_rel(self):
1660         pass
1661 
1662     def value_from_object(self, obj):
1663         return [] if obj.pk is None else list(getattr(obj, self.attname).all())
1664 
1665     def save_form_data(self, instance, data):
1666         getattr(instance, self.attname).set(data)
1667 
1668     def formfield(self, *, using=None, **kwargs):
1669         defaults = {
1670             'form_class': forms.ModelMultipleChoiceField,
1671             'queryset': self.remote_field.model._default_manager.using(using),
1672             **kwargs,
1673         }
1674         # If initial is passed in, it's a list of related objects, but the
1675         # MultipleChoiceField takes a list of IDs.
1676         if defaults.get('initial') is not None:
1677             initial = defaults['initial']
1678             if callable(initial):
1679                 initial = initial()
1680             defaults['initial'] = [i.pk for i in initial]
1681         return super().formfield(**defaults)
1682 
1683     def db_check(self, connection):
1684         return None
1685 
1686     def db_type(self, connection):
1687         # A ManyToManyField is not represented by a single column,
1688         # so return None.
1689         return None
1690 
1691     def db_parameters(self, connection):
1692         return {"type": None, "check": None}

</code><intended_behavior>Modify or extend the implementation to ensure that when a model having a ManyToManyField is altered, the alteration cascades the changes appropriately to related fields in the intermediary join table.</intended_behavior>, <file>django/db/migrations/autodetector.py</file>
<class>None</class>
<method>None</method>
<code>
1 import functools
2 import re
3 from itertools import chain
4 
5 from django.conf import settings
6 from django.db import models
7 from django.db.migrations import operations
8 from django.db.migrations.migration import Migration
9 from django.db.migrations.operations.models import AlterModelOptions
10 from django.db.migrations.optimizer import MigrationOptimizer
11 from django.db.migrations.questioner import MigrationQuestioner
12 from django.db.migrations.utils import (
13     COMPILED_REGEX_TYPE, RegexObject, get_migration_name_timestamp,
14 )
15 from django.utils.topological_sort import stable_topological_sort
16 
17 
18 class MigrationAutodetector:
19     """
20     Take a pair of ProjectStates and compare them to see what the first would
21     need doing to make it match the second (the second usually being the
22     project's current state).
23 
24     Note that this naturally operates on entire projects at a time,
25     as it's likely that changes interact (for example, you can't
26     add a ForeignKey without having a migration to add the table it
27     depends on first). A user interface may offer single-app usage
28     if it wishes, with the caveat that it may not always be possible.
29     """
30 
31     def __init__(self, from_state, to_state, questioner=None):
32         self.from_state = from_state
33         self.to_state = to_state
34         self.questioner = questioner or MigrationQuestioner()
35         self.existing_apps = {app for app, model in from_state.models}
36 
37     def changes(self, graph, trim_to_apps=None, convert_apps=None, migration_name=None):
38         """
39         Main entry point to produce a list of applicable changes.
40         Take a graph to base names on and an optional set of apps
41         to try and restrict to (restriction is not guaranteed)
42         """
43         changes = self._detect_changes(convert_apps, graph)
44         changes = self.arrange_for_graph(changes, graph, migration_name)
45         if trim_to_apps:
46             changes = self._trim_to_apps(changes, trim_to_apps)
47         return changes
48 
49     def deep_deconstruct(self, obj):
50         """
51         Recursive deconstruction for a field and its arguments.
52         Used for full comparison for rename/alter; sometimes a single-level
53         deconstruction will not compare correctly.
54         """
55         if isinstance(obj, list):
56             return [self.deep_deconstruct(value) for value in obj]
57         elif isinstance(obj, tuple):
58             return tuple(self.deep_deconstruct(value) for value in obj)
59         elif isinstance(obj, dict):
60             return {
61                 key: self.deep_deconstruct(value)
62                 for key, value in obj.items()
63             }
64         elif isinstance(obj, functools.partial):
65             return (obj.func, self.deep_deconstruct(obj.args), self.deep_deconstruct(obj.keywords))
66         elif isinstance(obj, COMPILED_REGEX_TYPE):
67             return RegexObject(obj)
68         elif isinstance(obj, type):
69             # If this is a type that implements 'deconstruct' as an instance method,
70             # avoid treating this as being deconstructible itself - see #22951
71             return obj
72         elif hasattr(obj, 'deconstruct'):
73             deconstructed = obj.deconstruct()
74             if isinstance(obj, models.Field):
75                 # we have a field which also returns a name
76                 deconstructed = deconstructed[1:]
77             path, args, kwargs = deconstructed
78             return (
79                 path,
80                 [self.deep_deconstruct(value) for value in args],
81                 {
82                     key: self.deep_deconstruct(value)
83                     for key, value in kwargs.items()
84                 },
85             )
86         else:
87             return obj
88 
89     def only_relation_agnostic_fields(self, fields):
90         """
91         Return a definition of the fields that ignores field names and
92         what related fields actually relate to. Used for detecting renames (as,
93         of course, the related fields change during renames).
94         """
95         fields_def = []
96         for name, field in sorted(fields):
97             deconstruction = self.deep_deconstruct(field)
98             if field.remote_field and field.remote_field.model:
99                 del deconstruction[2]['to']
100             fields_def.append(deconstruction)
101         return fields_def
102 
103     def _detect_changes(self, convert_apps=None, graph=None):
104         """
105         Return a dict of migration plans which will achieve the
106         change from from_state to to_state. The dict has app labels
107         as keys and a list of migrations as values.
108 
109         The resulting migrations aren't specially named, but the names
110         do matter for dependencies inside the set.
111 
112         convert_apps is the list of apps to convert to use migrations
113         (i.e. to make initial migrations for, in the usual case)
114 
115         graph is an optional argument that, if provided, can help improve
116         dependency generation and avoid potential circular dependencies.
117         """
118         # The first phase is generating all the operations for each app
119         # and gathering them into a big per-app list.
120         # Then go through that list, order it, and split into migrations to
121         # resolve dependencies caused by M2Ms and FKs.
122         self.generated_operations = {}
123         self.altered_indexes = {}
124         self.altered_constraints = {}
125 
126         # Prepare some old/new state and model lists, separating
127         # proxy models and ignoring unmigrated apps.
128         self.old_apps = self.from_state.concrete_apps
129         self.new_apps = self.to_state.apps
130         self.old_model_keys = set()
131         self.old_proxy_keys = set()
132         self.old_unmanaged_keys = set()
133         self.new_model_keys = set()
134         self.new_proxy_keys = set()
135         self.new_unmanaged_keys = set()
136         for al, mn in self.from_state.models:
137             model = self.old_apps.get_model(al, mn)
138             if not model._meta.managed:
139                 self.old_unmanaged_keys.add((al, mn))
140             elif al not in self.from_state.real_apps:
141                 if model._meta.proxy:
142                     self.old_proxy_keys.add((al, mn))
143                 else:
144                     self.old_model_keys.add((al, mn))
145 
146         for al, mn in self.to_state.models:
147             model = self.new_apps.get_model(al, mn)
148             if not model._meta.managed:
149                 self.new_unmanaged_keys.add((al, mn))
150             elif (
151                 al not in self.from_state.real_apps or
152                 (convert_apps and al in convert_apps)
153             ):
154                 if model._meta.proxy:
155                     self.new_proxy_keys.add((al, mn))
156                 else:
157                     self.new_model_keys.add((al, mn))
158 
159         # Renames have to come first
160         self.generate_renamed_models()
161 
162         # Prepare lists of fields and generate through model map
163         self._prepare_field_lists()
164         self._generate_through_model_map()
165 
166         # Generate non-rename model operations
167         self.generate_deleted_models()
168         self.generate_created_models()
169         self.generate_deleted_proxies()
170         self.generate_created_proxies()
171         self.generate_altered_options()
172         self.generate_altered_managers()
173 
174         # Create the altered indexes and store them in self.altered_indexes.
175         # This avoids the same computation in generate_removed_indexes()
176         # and generate_added_indexes().
177         self.create_altered_indexes()
178         self.create_altered_constraints()
179         # Generate index removal operations before field is removed
180         self.generate_removed_constraints()
181         self.generate_removed_indexes()
182         # Generate field operations
183         self.generate_renamed_fields()
184         self.generate_removed_fields()
185         self.generate_added_fields()
186         self.generate_altered_fields()
187         self.generate_altered_unique_together()
188         self.generate_altered_index_together()
189         self.generate_added_indexes()
190         self.generate_added_constraints()
191         self.generate_altered_db_table()
192         self.generate_altered_order_with_respect_to()
193 
194         self._sort_migrations()
195         self._build_migration_list(graph)
196         self._optimize_migrations()
197 
198         return self.migrations
199 
200     def _prepare_field_lists(self):
201         """
202         Prepare field lists and a list of the fields that used through models
203         in the old state so dependencies can be made from the through model
204         deletion to the field that uses it.
205         """
206         self.kept_model_keys = self.old_model_keys & self.new_model_keys
207         self.kept_proxy_keys = self.old_proxy_keys & self.new_proxy_keys
208         self.kept_unmanaged_keys = self.old_unmanaged_keys & self.new_unmanaged_keys
209         self.through_users = {}
210         self.old_field_keys = {
211             (app_label, model_name, x)
212             for app_label, model_name in self.kept_model_keys
213             for x, y in self.from_state.models[
214                 app_label,
215                 self.renamed_models.get((app_label, model_name), model_name)
216             ].fields
217         }
218         self.new_field_keys = {
219             (app_label, model_name, x)
220             for app_label, model_name in self.kept_model_keys
221             for x, y in self.to_state.models[app_label, model_name].fields
222         }
223 
224     def _generate_through_model_map(self):
225         """Through model map generation."""
226         for app_label, model_name in sorted(self.old_model_keys):
227             old_model_name = self.renamed_models.get((app_label, model_name), model_name)
228             old_model_state = self.from_state.models[app_label, old_model_name]
229             for field_name, field in old_model_state.fields:
230                 old_field = self.old_apps.get_model(app_label, old_model_name)._meta.get_field(field_name)
231                 if (hasattr(old_field, "remote_field") and getattr(old_field.remote_field, "through", None) and
232                         not old_field.remote_field.through._meta.auto_created):
233                     through_key = (
234                         old_field.remote_field.through._meta.app_label,
235                         old_field.remote_field.through._meta.model_name,
236                     )
237                     self.through_users[through_key] = (app_label, old_model_name, field_name)
238 
239     @staticmethod
240     def _resolve_dependency(dependency):
241         """
242         Return the resolved dependency and a boolean denoting whether or not
243         it was swappable.
244         """
245         if dependency[0] != '__setting__':
246             return dependency, False
247         resolved_app_label, resolved_object_name = getattr(settings, dependency[1]).split('.')
248         return (resolved_app_label, resolved_object_name.lower()) + dependency[2:], True
249 
250     def _build_migration_list(self, graph=None):
251         """
252         Chop the lists of operations up into migrations with dependencies on
253         each other. Do this by going through an app's list of operations until
254         one is found that has an outgoing dependency that isn't in another
255         app's migration yet (hasn't been chopped off its list). Then chop off
256         the operations before it into a migration and move onto the next app.
257         If the loops completes without doing anything, there's a circular
258         dependency (which _should_ be impossible as the operations are
259         all split at this point so they can't depend and be depended on).
260         """
261         self.migrations = {}
262         num_ops = sum(len(x) for x in self.generated_operations.values())
263         chop_mode = False
264         while num_ops:
265             # On every iteration, we step through all the apps and see if there
266             # is a completed set of operations.
267             # If we find that a subset of the operations are complete we can
268             # try to chop it off from the rest and continue, but we only
269             # do this if we've already been through the list once before
270             # without any chopping and nothing has changed.
271             for app_label in sorted(self.generated_operations):
272                 chopped = []
273                 dependencies = set()
274                 for operation in list(self.generated_operations[app_label]):
275                     deps_satisfied = True
276                     operation_dependencies = set()
277                     for dep in operation._auto_deps:
278                         # Temporarily resolve the swappable dependency to
279                         # prevent circular references. While keeping the
280                         # dependency checks on the resolved model, add the
281                         # swappable dependencies.
282                         original_dep = dep
283                         dep, is_swappable_dep = self._resolve_dependency(dep)
284                         if dep[0] != app_label:
285                             # External app dependency. See if it's not yet
286                             # satisfied.
287                             for other_operation in self.generated_operations.get(dep[0], []):
288                                 if self.check_dependency(other_operation, dep):
289                                     deps_satisfied = False
290                                     break
291                             if not deps_satisfied:
292                                 break
293                             else:
294                                 if is_swappable_dep:
295                                     operation_dependencies.add((original_dep[0], original_dep[1]))
296                                 elif dep[0] in self.migrations:
297                                     operation_dependencies.add((dep[0], self.migrations[dep[0]][-1].name))
298                                 else:
299                                     # If we can't find the other app, we add a first/last dependency,
300                                     # but only if we've already been through once and checked everything
301                                     if chop_mode:
302                                         # If the app already exists, we add a dependency on the last migration,
303                                         # as we don't know which migration contains the target field.
304                                         # If it's not yet migrated or has no migrations, we use __first__
305                                         if graph and graph.leaf_nodes(dep[0]):
306                                             operation_dependencies.add(graph.leaf_nodes(dep[0])[0])
307                                         else:
308                                             operation_dependencies.add((dep[0], "__first__"))
309                                     else:
310                                         deps_satisfied = False
311                     if deps_satisfied:
312                         chopped.append(operation)
313                         dependencies.update(operation_dependencies)
314                         del self.generated_operations[app_label][0]
315                     else:
316                         break
317                 # Make a migration! Well, only if there's stuff to put in it
318                 if dependencies or chopped:
319                     if not self.generated_operations[app_label] or chop_mode:
320                         subclass = type("Migration", (Migration,), {"operations": [], "dependencies": []})
321                         instance = subclass("auto_%i" % (len(self.migrations.get(app_label, [])) + 1), app_label)
322                         instance.dependencies = list(dependencies)
323                         instance.operations = chopped
324                         instance.initial = app_label not in self.existing_apps
325                         self.migrations.setdefault(app_label, []).append(instance)
326                         chop_mode = False
327                     else:
328                         self.generated_operations[app_label] = chopped + self.generated_operations[app_label]
329             new_num_ops = sum(len(x) for x in self.generated_operations.values())
330             if new_num_ops == num_ops:
331                 if not chop_mode:
332                     chop_mode = True
333                 else:
334                     raise ValueError("Cannot resolve operation dependencies: %r" % self.generated_operations)
335             num_ops = new_num_ops
336 
337     def _sort_migrations(self):
338         """
339         Reorder to make things possible. Reordering may be needed so FKs work
340         nicely inside the same app.
341         """
342         for app_label, ops in sorted(self.generated_operations.items()):
343             # construct a dependency graph for intra-app dependencies
344             dependency_graph = {op: set() for op in ops}
345             for op in ops:
346                 for dep in op._auto_deps:
347                     # Resolve intra-app dependencies to handle circular
348                     # references involving a swappable model.
349                     dep = self._resolve_dependency(dep)[0]
350                     if dep[0] == app_label:
351                         for op2 in ops:
352                             if self.check_dependency(op2, dep):
353                                 dependency_graph[op].add(op2)
354 
355             # we use a stable sort for deterministic tests & general behavior
356             self.generated_operations[app_label] = stable_topological_sort(ops, dependency_graph)
357 
358     def _optimize_migrations(self):
359         # Add in internal dependencies among the migrations
360         for app_label, migrations in self.migrations.items():
361             for m1, m2 in zip(migrations, migrations[1:]):
362                 m2.dependencies.append((app_label, m1.name))
363 
364         # De-dupe dependencies
365         for migrations in self.migrations.values():
366             for migration in migrations:
367                 migration.dependencies = list(set(migration.dependencies))
368 
369         # Optimize migrations
370         for app_label, migrations in self.migrations.items():
371             for migration in migrations:
372                 migration.operations = MigrationOptimizer().optimize(migration.operations, app_label)
373 
374     def check_dependency(self, operation, dependency):
375         """
376         Return True if the given operation depends on the given dependency,
377         False otherwise.
378         """
379         # Created model
380         if dependency[2] is None and dependency[3] is True:
381             return (
382                 isinstance(operation, operations.CreateModel) and
383                 operation.name_lower == dependency[1].lower()
384             )
385         # Created field
386         elif dependency[2] is not None and dependency[3] is True:
387             return (
388                 (
389                     isinstance(operation, operations.CreateModel) and
390                     operation.name_lower == dependency[1].lower() and
391                     any(dependency[2] == x for x, y in operation.fields)
392                 ) or
393                 (
394                     isinstance(operation, operations.AddField) and
395                     operation.model_name_lower == dependency[1].lower() and
396                     operation.name_lower == dependency[2].lower()
397                 )
398             )
399         # Removed field
400         elif dependency[2] is not None and dependency[3] is False:
401             return (
402                 isinstance(operation, operations.RemoveField) and
403                 operation.model_name_lower == dependency[1].lower() and
404                 operation.name_lower == dependency[2].lower()
405             )
406         # Removed model
407         elif dependency[2] is None and dependency[3] is False:
408             return (
409                 isinstance(operation, operations.DeleteModel) and
410                 operation.name_lower == dependency[1].lower()
411             )
412         # Field being altered
413         elif dependency[2] is not None and dependency[3] == "alter":
414             return (
415                 isinstance(operation, operations.AlterField) and
416                 operation.model_name_lower == dependency[1].lower() and
417                 operation.name_lower == dependency[2].lower()
418             )
419         # order_with_respect_to being unset for a field
420         elif dependency[2] is not None and dependency[3] == "order_wrt_unset":
421             return (
422                 isinstance(operation, operations.AlterOrderWithRespectTo) and
423                 operation.name_lower == dependency[1].lower() and
424                 (operation.order_with_respect_to or "").lower() != dependency[2].lower()
425             )
426         # Field is removed and part of an index/unique_together
427         elif dependency[2] is not None and dependency[3] == "foo_together_change":
428             return (
429                 isinstance(operation, (operations.AlterUniqueTogether,
430                                        operations.AlterIndexTogether)) and
431                 operation.name_lower == dependency[1].lower()
432             )
433         # Unknown dependency. Raise an error.
434         else:
435             raise ValueError("Can't handle dependency %r" % (dependency,))
436 
437     def add_operation(self, app_label, operation, dependencies=None, beginning=False):
438         # Dependencies are (app_label, model_name, field_name, create/delete as True/False)
439         operation._auto_deps = dependencies or []
440         if beginning:
441             self.generated_operations.setdefault(app_label, []).insert(0, operation)
442         else:
443             self.generated_operations.setdefault(app_label, []).append(operation)
444 
445     def swappable_first_key(self, item):
446         """
447         Place potential swappable models first in lists of created models (only
448         real way to solve #22783).
449         """
450         try:
451             model = self.new_apps.get_model(item[0], item[1])
452             base_names = [base.__name__ for base in model.__bases__]
453             string_version = "%s.%s" % (item[0], item[1])
454             if (
455                 model._meta.swappable or
456                 "AbstractUser" in base_names or
457                 "AbstractBaseUser" in base_names or
458                 settings.AUTH_USER_MODEL.lower() == string_version.lower()
459             ):
460                 return ("___" + item[0], "___" + item[1])
461         except LookupError:
462             pass
463         return item
464 
465     def generate_renamed_models(self):
466         """
467         Find any renamed models, generate the operations for them, and remove
468         the old entry from the model lists. Must be run before other
469         model-level generation.
470         """
471         self.renamed_models = {}
472         self.renamed_models_rel = {}
473         added_models = self.new_model_keys - self.old_model_keys
474         for app_label, model_name in sorted(added_models):
475             model_state = self.to_state.models[app_label, model_name]
476             model_fields_def = self.only_relation_agnostic_fields(model_state.fields)
477 
478             removed_models = self.old_model_keys - self.new_model_keys
479             for rem_app_label, rem_model_name in removed_models:
480                 if rem_app_label == app_label:
481                     rem_model_state = self.from_state.models[rem_app_label, rem_model_name]
482                     rem_model_fields_def = self.only_relation_agnostic_fields(rem_model_state.fields)
483                     if model_fields_def == rem_model_fields_def:
484                         if self.questioner.ask_rename_model(rem_model_state, model_state):
485                             model_opts = self.new_apps.get_model(app_label, model_name)._meta
486                             dependencies = []
487                             for field in model_opts.get_fields():
488                                 if field.is_relation:
489                                     dependencies.extend(self._get_dependencies_for_foreign_key(field))
490                             self.add_operation(
491                                 app_label,
492                                 operations.RenameModel(
493                                     old_name=rem_model_state.name,
494                                     new_name=model_state.name,
495                                 ),
496                                 dependencies=dependencies,
497                             )
498                             self.renamed_models[app_label, model_name] = rem_model_name
499                             renamed_models_rel_key = '%s.%s' % (
500                                 rem_model_state.app_label,
501                                 rem_model_state.name_lower,
502                             )
503                             self.renamed_models_rel[renamed_models_rel_key] = '%s.%s' % (
504                                 model_state.app_label,
505                                 model_state.name_lower,
506                             )
507                             self.old_model_keys.remove((rem_app_label, rem_model_name))
508                             self.old_model_keys.add((app_label, model_name))
509                             break
510 
511     def generate_created_models(self):
512         """
513         Find all new models (both managed and unmanaged) and make create
514         operations for them as well as separate operations to create any
515         foreign key or M2M relationships (these are optimized later, if
516         possible).
517 
518         Defer any model options that refer to collections of fields that might
519         be deferred (e.g. unique_together, index_together).
520         """
521         old_keys = self.old_model_keys | self.old_unmanaged_keys
522         added_models = self.new_model_keys - old_keys
523         added_unmanaged_models = self.new_unmanaged_keys - old_keys
524         all_added_models = chain(
525             sorted(added_models, key=self.swappable_first_key, reverse=True),
526             sorted(added_unmanaged_models, key=self.swappable_first_key, reverse=True)
527         )
528         for app_label, model_name in all_added_models:
529             model_state = self.to_state.models[app_label, model_name]
530             model_opts = self.new_apps.get_model(app_label, model_name)._meta
531             # Gather related fields
532             related_fields = {}
533             primary_key_rel = None
534             for field in model_opts.local_fields:
535                 if field.remote_field:
536                     if field.remote_field.model:
537                         if field.primary_key:
538                             primary_key_rel = field.remote_field.model
539                         elif not field.remote_field.parent_link:
540                             related_fields[field.name] = field
541                     # through will be none on M2Ms on swapped-out models;
542                     # we can treat lack of through as auto_created=True, though.
543                     if (getattr(field.remote_field, "through", None) and
544                             not field.remote_field.through._meta.auto_created):
545                         related_fields[field.name] = field
546             for field in model_opts.local_many_to_many:
547                 if field.remote_field.model:
548                     related_fields[field.name] = field
549                 if getattr(field.remote_field, "through", None) and not field.remote_field.through._meta.auto_created:
550                     related_fields[field.name] = field
551             # Are there indexes/unique|index_together to defer?
552             indexes = model_state.options.pop('indexes')
553             constraints = model_state.options.pop('constraints')
554             unique_together = model_state.options.pop('unique_together', None)
555             index_together = model_state.options.pop('index_together', None)
556             order_with_respect_to = model_state.options.pop('order_with_respect_to', None)
557             # Depend on the deletion of any possible proxy version of us
558             dependencies = [
559                 (app_label, model_name, None, False),
560             ]
561             # Depend on all bases
562             for base in model_state.bases:
563                 if isinstance(base, str) and "." in base:
564                     base_app_label, base_name = base.split(".", 1)
565                     dependencies.append((base_app_label, base_name, None, True))
566             # Depend on the other end of the primary key if it's a relation
567             if primary_key_rel:
568                 dependencies.append((
569                     primary_key_rel._meta.app_label,
570                     primary_key_rel._meta.object_name,
571                     None,
572                     True
573                 ))
574             # Generate creation operation
575             self.add_operation(
576                 app_label,
577                 operations.CreateModel(
578                     name=model_state.name,
579                     fields=[d for d in model_state.fields if d[0] not in related_fields],
580                     options=model_state.options,
581                     bases=model_state.bases,
582                     managers=model_state.managers,
583                 ),
584                 dependencies=dependencies,
585                 beginning=True,
586             )
587 
588             # Don't add operations which modify the database for unmanaged models
589             if not model_opts.managed:
590                 continue
591 
592             # Generate operations for each related field
593             for name, field in sorted(related_fields.items()):
594                 dependencies = self._get_dependencies_for_foreign_key(field)
595                 # Depend on our own model being created
596                 dependencies.append((app_label, model_name, None, True))
597                 # Make operation
598                 self.add_operation(
599                     app_label,
600                     operations.AddField(
601                         model_name=model_name,
602                         name=name,
603                         field=field,
604                     ),
605                     dependencies=list(set(dependencies)),
606                 )
607             # Generate other opns
608             related_dependencies = [
609                 (app_label, model_name, name, True)
610                 for name in sorted(related_fields)
611             ]
612             related_dependencies.append((app_label, model_name, None, True))
613             for index in indexes:
614                 self.add_operation(
615                     app_label,
616                     operations.AddIndex(
617                         model_name=model_name,
618                         index=index,
619                     ),
620                     dependencies=related_dependencies,
621                 )
622             for constraint in constraints:
623                 self.add_operation(
624                     app_label,
625                     operations.AddConstraint(
626                         model_name=model_name,
627                         constraint=constraint,
628                     ),
629                     dependencies=related_dependencies,
630                 )
631             if unique_together:
632                 self.add_operation(
633                     app_label,
634                     operations.AlterUniqueTogether(
635                         name=model_name,
636                         unique_together=unique_together,
637                     ),
638                     dependencies=related_dependencies
639                 )
640             if index_together:
641                 self.add_operation(
642                     app_label,
643                     operations.AlterIndexTogether(
644                         name=model_name,
645                         index_together=index_together,
646                     ),
647                     dependencies=related_dependencies
648                 )
649             if order_with_respect_to:
650                 self.add_operation(
651                     app_label,
652                     operations.AlterOrderWithRespectTo(
653                         name=model_name,
654                         order_with_respect_to=order_with_respect_to,
655                     ),
656                     dependencies=[
657                         (app_label, model_name, order_with_respect_to, True),
658                         (app_label, model_name, None, True),
659                     ]
660                 )
661 
662             # Fix relationships if the model changed from a proxy model to a
663             # concrete model.
664             if (app_label, model_name) in self.old_proxy_keys:
665                 for related_object in model_opts.related_objects:
666                     self.add_operation(
667                         related_object.related_model._meta.app_label,
668                         operations.AlterField(
669                             model_name=related_object.related_model._meta.object_name,
670                             name=related_object.field.name,
671                             field=related_object.field,
672                         ),
673                         dependencies=[(app_label, model_name, None, True)],
674                     )
675 
676     def generate_created_proxies(self):
677         """
678         Make CreateModel statements for proxy models. Use the same statements
679         as that way there's less code duplication, but of course for proxy
680         models it's safe to skip all the pointless field stuff and just chuck
681         out an operation.
682         """
683         added = self.new_proxy_keys - self.old_proxy_keys
684         for app_label, model_name in sorted(added):
685             model_state = self.to_state.models[app_label, model_name]
686             assert model_state.options.get("proxy")
687             # Depend on the deletion of any possible non-proxy version of us
688             dependencies = [
689                 (app_label, model_name, None, False),
690             ]
691             # Depend on all bases
692             for base in model_state.bases:
693                 if isinstance(base, str) and "." in base:
694                     base_app_label, base_name = base.split(".", 1)
695                     dependencies.append((base_app_label, base_name, None, True))
696             # Generate creation operation
697             self.add_operation(
698                 app_label,
699                 operations.CreateModel(
700                     name=model_state.name,
701                     fields=[],
702                     options=model_state.options,
703                     bases=model_state.bases,
704                     managers=model_state.managers,
705                 ),
706                 # Depend on the deletion of any possible non-proxy version of us
707                 dependencies=dependencies,
708             )
709 
710     def generate_deleted_models(self):
711         """
712         Find all deleted models (managed and unmanaged) and make delete
713         operations for them as well as separate operations to delete any
714         foreign key or M2M relationships (these are optimized later, if
715         possible).
716 
717         Also bring forward removal of any model options that refer to
718         collections of fields - the inverse of generate_created_models().
719         """
720         new_keys = self.new_model_keys | self.new_unmanaged_keys
721         deleted_models = self.old_model_keys - new_keys
722         deleted_unmanaged_models = self.old_unmanaged_keys - new_keys
723         all_deleted_models = chain(sorted(deleted_models), sorted(deleted_unmanaged_models))
724         for app_label, model_name in all_deleted_models:
725             model_state = self.from_state.models[app_label, model_name]
726             model = self.old_apps.get_model(app_label, model_name)
727             # Gather related fields
728             related_fields = {}
729             for field in model._meta.local_fields:
730                 if field.remote_field:
731                     if field.remote_field.model:
732                         related_fields[field.name] = field
733                     # through will be none on M2Ms on swapped-out models;
734                     # we can treat lack of through as auto_created=True, though.
735                     if (getattr(field.remote_field, "through", None) and
736                             not field.remote_field.through._meta.auto_created):
737                         related_fields[field.name] = field
738             for field in model._meta.local_many_to_many:
739                 if field.remote_field.model:
740                     related_fields[field.name] = field
741                 if getattr(field.remote_field, "through", None) and not field.remote_field.through._meta.auto_created:
742                     related_fields[field.name] = field
743             # Generate option removal first
744             unique_together = model_state.options.pop('unique_together', None)
745             index_together = model_state.options.pop('index_together', None)
746             if unique_together:
747                 self.add_operation(
748                     app_label,
749                     operations.AlterUniqueTogether(
750                         name=model_name,
751                         unique_together=None,
752                     )
753                 )
754             if index_together:
755                 self.add_operation(
756                     app_label,
757                     operations.AlterIndexTogether(
758                         name=model_name,
759                         index_together=None,
760                     )
761                 )
762             # Then remove each related field
763             for name in sorted(related_fields):
764                 self.add_operation(
765                     app_label,
766                     operations.RemoveField(
767                         model_name=model_name,
768                         name=name,
769                     )
770                 )
771             # Finally, remove the model.
772             # This depends on both the removal/alteration of all incoming fields
773             # and the removal of all its own related fields, and if it's
774             # a through model the field that references it.
775             dependencies = []
776             for related_object in model._meta.related_objects:
777                 related_object_app_label = related_object.related_model._meta.app_label
778                 object_name = related_object.related_model._meta.object_name
779                 field_name = related_object.field.name
780                 dependencies.append((related_object_app_label, object_name, field_name, False))
781                 if not related_object.many_to_many:
782                     dependencies.append((related_object_app_label, object_name, field_name, "alter"))
783 
784             for name in sorted(related_fields):
785                 dependencies.append((app_label, model_name, name, False))
786             # We're referenced in another field's through=
787             through_user = self.through_users.get((app_label, model_state.name_lower))
788             if through_user:
789                 dependencies.append((through_user[0], through_user[1], through_user[2], False))
790             # Finally, make the operation, deduping any dependencies
791             self.add_operation(
792                 app_label,
793                 operations.DeleteModel(
794                     name=model_state.name,
795                 ),
796                 dependencies=list(set(dependencies)),
797             )
798 
799     def generate_deleted_proxies(self):
800         """Make DeleteModel options for proxy models."""
801         deleted = self.old_proxy_keys - self.new_proxy_keys
802         for app_label, model_name in sorted(deleted):
803             model_state = self.from_state.models[app_label, model_name]
804             assert model_state.options.get("proxy")
805             self.add_operation(
806                 app_label,
807                 operations.DeleteModel(
808                     name=model_state.name,
809                 ),
810             )
811 
812     def generate_renamed_fields(self):
813         """Work out renamed fields."""
814         self.renamed_fields = {}
815         for app_label, model_name, field_name in sorted(self.new_field_keys - self.old_field_keys):
816             old_model_name = self.renamed_models.get((app_label, model_name), model_name)
817             old_model_state = self.from_state.models[app_label, old_model_name]
818             field = self.new_apps.get_model(app_label, model_name)._meta.get_field(field_name)
819             # Scan to see if this is actually a rename!
820             field_dec = self.deep_deconstruct(field)
821             for rem_app_label, rem_model_name, rem_field_name in sorted(self.old_field_keys - self.new_field_keys):
822                 if rem_app_label == app_label and rem_model_name == model_name:
823                     old_field = old_model_state.get_field_by_name(rem_field_name)
824                     old_field_dec = self.deep_deconstruct(old_field)
825                     if field.remote_field and field.remote_field.model and 'to' in old_field_dec[2]:
826                         old_rel_to = old_field_dec[2]['to']
827                         if old_rel_to in self.renamed_models_rel:
828                             old_field_dec[2]['to'] = self.renamed_models_rel[old_rel_to]
829                     old_field.set_attributes_from_name(rem_field_name)
830                     old_db_column = old_field.get_attname_column()[1]
831                     if (old_field_dec == field_dec or (
832                             # Was the field renamed and db_column equal to the
833                             # old field's column added?
834                             old_field_dec[0:2] == field_dec[0:2] and
835                             dict(old_field_dec[2], db_column=old_db_column) == field_dec[2])):
836                         if self.questioner.ask_rename(model_name, rem_field_name, field_name, field):
837                             self.add_operation(
838                                 app_label,
839                                 operations.RenameField(
840                                     model_name=model_name,
841                                     old_name=rem_field_name,
842                                     new_name=field_name,
843                                 )
844                             )
845                             self.old_field_keys.remove((rem_app_label, rem_model_name, rem_field_name))
846                             self.old_field_keys.add((app_label, model_name, field_name))
847                             self.renamed_fields[app_label, model_name, field_name] = rem_field_name
848                             break
849 
850     def generate_added_fields(self):
851         """Make AddField operations."""
852         for app_label, model_name, field_name in sorted(self.new_field_keys - self.old_field_keys):
853             self._generate_added_field(app_label, model_name, field_name)
854 
855     def _generate_added_field(self, app_label, model_name, field_name):
856         field = self.new_apps.get_model(app_label, model_name)._meta.get_field(field_name)
857         # Fields that are foreignkeys/m2ms depend on stuff
858         dependencies = []
859         if field.remote_field and field.remote_field.model:
860             dependencies.extend(self._get_dependencies_for_foreign_key(field))
861         # You can't just add NOT NULL fields with no default or fields
862         # which don't allow empty strings as default.
863         time_fields = (models.DateField, models.DateTimeField, models.TimeField)
864         preserve_default = (
865             field.null or field.has_default() or field.many_to_many or
866             (field.blank and field.empty_strings_allowed) or
867             (isinstance(field, time_fields) and field.auto_now)
868         )
869         if not preserve_default:
870             field = field.clone()
871             if isinstance(field, time_fields) and field.auto_now_add:
872                 field.default = self.questioner.ask_auto_now_add_addition(field_name, model_name)
873             else:
874                 field.default = self.questioner.ask_not_null_addition(field_name, model_name)
875         self.add_operation(
876             app_label,
877             operations.AddField(
878                 model_name=model_name,
879                 name=field_name,
880                 field=field,
881                 preserve_default=preserve_default,
882             ),
883             dependencies=dependencies,
884         )
885 
886     def generate_removed_fields(self):
887         """Make RemoveField operations."""
888         for app_label, model_name, field_name in sorted(self.old_field_keys - self.new_field_keys):
889             self._generate_removed_field(app_label, model_name, field_name)
890 
891     def _generate_removed_field(self, app_label, model_name, field_name):
892         self.add_operation(
893             app_label,
894             operations.RemoveField(
895                 model_name=model_name,
896                 name=field_name,
897             ),
898             # We might need to depend on the removal of an
899             # order_with_respect_to or index/unique_together operation;
900             # this is safely ignored if there isn't one
901             dependencies=[
902                 (app_label, model_name, field_name, "order_wrt_unset"),
903                 (app_label, model_name, field_name, "foo_together_change"),
904             ],
905         )
906 
907     def generate_altered_fields(self):
908         """
909         Make AlterField operations, or possibly RemovedField/AddField if alter
910         isn's possible.
911         """
912         for app_label, model_name, field_name in sorted(self.old_field_keys & self.new_field_keys):
913             # Did the field change?
914             old_model_name = self.renamed_models.get((app_label, model_name), model_name)
915             old_field_name = self.renamed_fields.get((app_label, model_name, field_name), field_name)
916             old_field = self.old_apps.get_model(app_label, old_model_name)._meta.get_field(old_field_name)
917             new_field = self.new_apps.get_model(app_label, model_name)._meta.get_field(field_name)
918             dependencies = []
919             # Implement any model renames on relations; these are handled by RenameModel
920             # so we need to exclude them from the comparison
921             if hasattr(new_field, "remote_field") and getattr(new_field.remote_field, "model", None):
922                 rename_key = (
923                     new_field.remote_field.model._meta.app_label,
924                     new_field.remote_field.model._meta.model_name,
925                 )
926                 if rename_key in self.renamed_models:
927                     new_field.remote_field.model = old_field.remote_field.model
928                 # Handle ForeignKey which can only have a single to_field.
929                 remote_field_name = getattr(new_field.remote_field, 'field_name', None)
930                 if remote_field_name:
931                     to_field_rename_key = rename_key + (remote_field_name,)
932                     if to_field_rename_key in self.renamed_fields:
933                         # Repoint both model and field name because to_field
934                         # inclusion in ForeignKey.deconstruct() is based on
935                         # both.
936                         new_field.remote_field.model = old_field.remote_field.model
937                         new_field.remote_field.field_name = old_field.remote_field.field_name
938                 # Handle ForeignObjects which can have multiple from_fields/to_fields.
939                 from_fields = getattr(new_field, 'from_fields', None)
940                 if from_fields:
941                     from_rename_key = (app_label, model_name)
942                     new_field.from_fields = tuple([
943                         self.renamed_fields.get(from_rename_key + (from_field,), from_field)
944                         for from_field in from_fields
945                     ])
946                     new_field.to_fields = tuple([
947                         self.renamed_fields.get(rename_key + (to_field,), to_field)
948                         for to_field in new_field.to_fields
949                     ])
950                 dependencies.extend(self._get_dependencies_for_foreign_key(new_field))
951             if hasattr(new_field, "remote_field") and getattr(new_field.remote_field, "through", None):
952                 rename_key = (
953                     new_field.remote_field.through._meta.app_label,
954                     new_field.remote_field.through._meta.model_name,
955                 )
956                 if rename_key in self.renamed_models:
957                     new_field.remote_field.through = old_field.remote_field.through
958             old_field_dec = self.deep_deconstruct(old_field)
959             new_field_dec = self.deep_deconstruct(new_field)
960             if old_field_dec != new_field_dec:
961                 both_m2m = old_field.many_to_many and new_field.many_to_many
962                 neither_m2m = not old_field.many_to_many and not new_field.many_to_many
963                 if both_m2m or neither_m2m:
964                     # Either both fields are m2m or neither is
965                     preserve_default = True
966                     if (old_field.null and not new_field.null and not new_field.has_default() and
967                             not new_field.many_to_many):
968                         field = new_field.clone()
969                         new_default = self.questioner.ask_not_null_alteration(field_name, model_name)
970                         if new_default is not models.NOT_PROVIDED:
971                             field.default = new_default
972                             preserve_default = False
973                     else:
974                         field = new_field
975                     self.add_operation(
976                         app_label,
977                         operations.AlterField(
978                             model_name=model_name,
979                             name=field_name,
980                             field=field,
981                             preserve_default=preserve_default,
982                         ),
983                         dependencies=dependencies,
984                     )
985                 else:
986                     # We cannot alter between m2m and concrete fields
987                     self._generate_removed_field(app_label, model_name, field_name)
988                     self._generate_added_field(app_label, model_name, field_name)
989 
990     def create_altered_indexes(self):
991         option_name = operations.AddIndex.option_name
992         for app_label, model_name in sorted(self.kept_model_keys):
993             old_model_name = self.renamed_models.get((app_label, model_name), model_name)
994             old_model_state = self.from_state.models[app_label, old_model_name]
995             new_model_state = self.to_state.models[app_label, model_name]
996 
997             old_indexes = old_model_state.options[option_name]
998             new_indexes = new_model_state.options[option_name]
999             add_idx = [idx for idx in new_indexes if idx not in old_indexes]
1000             rem_idx = [idx for idx in old_indexes if idx not in new_indexes]
1001 
1002             self.altered_indexes.update({
1003                 (app_label, model_name): {
1004                     'added_indexes': add_idx, 'removed_indexes': rem_idx,
1005                 }
1006             })
1007 
1008     def generate_added_indexes(self):
1009         for (app_label, model_name), alt_indexes in self.altered_indexes.items():
1010             for index in alt_indexes['added_indexes']:
1011                 self.add_operation(
1012                     app_label,
1013                     operations.AddIndex(
1014                         model_name=model_name,
1015                         index=index,
1016                     )
1017                 )
1018 
1019     def generate_removed_indexes(self):
1020         for (app_label, model_name), alt_indexes in self.altered_indexes.items():
1021             for index in alt_indexes['removed_indexes']:
1022                 self.add_operation(
1023                     app_label,
1024                     operations.RemoveIndex(
1025                         model_name=model_name,
1026                         name=index.name,
1027                     )
1028                 )
1029 
1030     def create_altered_constraints(self):
1031         option_name = operations.AddConstraint.option_name
1032         for app_label, model_name in sorted(self.kept_model_keys):
1033             old_model_name = self.renamed_models.get((app_label, model_name), model_name)
1034             old_model_state = self.from_state.models[app_label, old_model_name]
1035             new_model_state = self.to_state.models[app_label, model_name]
1036 
1037             old_constraints = old_model_state.options[option_name]
1038             new_constraints = new_model_state.options[option_name]
1039             add_constraints = [c for c in new_constraints if c not in old_constraints]
1040             rem_constraints = [c for c in old_constraints if c not in new_constraints]
1041 
1042             self.altered_constraints.update({
1043                 (app_label, model_name): {
1044                     'added_constraints': add_constraints, 'removed_constraints': rem_constraints,
1045                 }
1046             })
1047 
1048     def generate_added_constraints(self):
1049         for (app_label, model_name), alt_constraints in self.altered_constraints.items():
1050             for constraint in alt_constraints['added_constraints']:
1051                 self.add_operation(
1052                     app_label,
1053                     operations.AddConstraint(
1054                         model_name=model_name,
1055                         constraint=constraint,
1056                     )
1057                 )
1058 
1059     def generate_removed_constraints(self):
1060         for (app_label, model_name), alt_constraints in self.altered_constraints.items():
1061             for constraint in alt_constraints['removed_constraints']:
1062                 self.add_operation(
1063                     app_label,
1064                     operations.RemoveConstraint(
1065                         model_name=model_name,
1066                         name=constraint.name,
1067                     )
1068                 )
1069 
1070     def _get_dependencies_for_foreign_key(self, field):
1071         # Account for FKs to swappable models
1072         swappable_setting = getattr(field, 'swappable_setting', None)
1073         if swappable_setting is not None:
1074             dep_app_label = "__setting__"
1075             dep_object_name = swappable_setting
1076         else:
1077             dep_app_label = field.remote_field.model._meta.app_label
1078             dep_object_name = field.remote_field.model._meta.object_name
1079         dependencies = [(dep_app_label, dep_object_name, None, True)]
1080         if getattr(field.remote_field, "through", None) and not field.remote_field.through._meta.auto_created:
1081             dependencies.append((
1082                 field.remote_field.through._meta.app_label,
1083                 field.remote_field.through._meta.object_name,
1084                 None,
1085                 True,
1086             ))
1087         return dependencies
1088 
1089     def _generate_altered_foo_together(self, operation):
1090         option_name = operation.option_name
1091         for app_label, model_name in sorted(self.kept_model_keys):
1092             old_model_name = self.renamed_models.get((app_label, model_name), model_name)
1093             old_model_state = self.from_state.models[app_label, old_model_name]
1094             new_model_state = self.to_state.models[app_label, model_name]
1095 
1096             # We run the old version through the field renames to account for those
1097             old_value = old_model_state.options.get(option_name)
1098             old_value = {
1099                 tuple(
1100                     self.renamed_fields.get((app_label, model_name, n), n)
1101                     for n in unique
1102                 )
1103                 for unique in old_value
1104             } if old_value else set()
1105 
1106             new_value = new_model_state.options.get(option_name)
1107             new_value = set(new_value) if new_value else set()
1108 
1109             if old_value != new_value:
1110                 dependencies = []
1111                 for foo_togethers in new_value:
1112                     for field_name in foo_togethers:
1113                         field = self.new_apps.get_model(app_label, model_name)._meta.get_field(field_name)
1114                         if field.remote_field and field.remote_field.model:
1115                             dependencies.extend(self._get_dependencies_for_foreign_key(field))
1116 
1117                 self.add_operation(
1118                     app_label,
1119                     operation(
1120                         name=model_name,
1121                         **{option_name: new_value}
1122                     ),
1123                     dependencies=dependencies,
1124                 )
1125 
1126     def generate_altered_unique_together(self):
1127         self._generate_altered_foo_together(operations.AlterUniqueTogether)
1128 
1129     def generate_altered_index_together(self):
1130         self._generate_altered_foo_together(operations.AlterIndexTogether)
1131 
1132     def generate_altered_db_table(self):
1133         models_to_check = self.kept_model_keys.union(self.kept_proxy_keys, self.kept_unmanaged_keys)
1134         for app_label, model_name in sorted(models_to_check):
1135             old_model_name = self.renamed_models.get((app_label, model_name), model_name)
1136             old_model_state = self.from_state.models[app_label, old_model_name]
1137             new_model_state = self.to_state.models[app_label, model_name]
1138             old_db_table_name = old_model_state.options.get('db_table')
1139             new_db_table_name = new_model_state.options.get('db_table')
1140             if old_db_table_name != new_db_table_name:
1141                 self.add_operation(
1142                     app_label,
1143                     operations.AlterModelTable(
1144                         name=model_name,
1145                         table=new_db_table_name,
1146                     )
1147                 )
1148 
1149     def generate_altered_options(self):
1150         """
1151         Work out if any non-schema-affecting options have changed and make an
1152         operation to represent them in state changes (in case Python code in
1153         migrations needs them).
1154         """
1155         models_to_check = self.kept_model_keys.union(
1156             self.kept_proxy_keys,
1157             self.kept_unmanaged_keys,
1158             # unmanaged converted to managed
1159             self.old_unmanaged_keys & self.new_model_keys,
1160             # managed converted to unmanaged
1161             self.old_model_keys & self.new_unmanaged_keys,
1162         )
1163 
1164         for app_label, model_name in sorted(models_to_check):
1165             old_model_name = self.renamed_models.get((app_label, model_name), model_name)
1166             old_model_state = self.from_state.models[app_label, old_model_name]
1167             new_model_state = self.to_state.models[app_label, model_name]
1168             old_options = {
1169                 key: value for key, value in old_model_state.options.items()
1170                 if key in AlterModelOptions.ALTER_OPTION_KEYS
1171             }
1172             new_options = {
1173                 key: value for key, value in new_model_state.options.items()
1174                 if key in AlterModelOptions.ALTER_OPTION_KEYS
1175             }
1176             if old_options != new_options:
1177                 self.add_operation(
1178                     app_label,
1179                     operations.AlterModelOptions(
1180                         name=model_name,
1181                         options=new_options,
1182                     )
1183                 )
1184 
1185     def generate_altered_order_with_respect_to(self):
1186         for app_label, model_name in sorted(self.kept_model_keys):
1187             old_model_name = self.renamed_models.get((app_label, model_name), model_name)
1188             old_model_state = self.from_state.models[app_label, old_model_name]
1189             new_model_state = self.to_state.models[app_label, model_name]
1190             if (old_model_state.options.get("order_with_respect_to") !=
1191                     new_model_state.options.get("order_with_respect_to")):
1192                 # Make sure it comes second if we're adding
1193                 # (removal dependency is part of RemoveField)
1194                 dependencies = []
1195                 if new_model_state.options.get("order_with_respect_to"):
1196                     dependencies.append((
1197                         app_label,
1198                         model_name,
1199                         new_model_state.options["order_with_respect_to"],
1200                         True,
1201                     ))
1202                 # Actually generate the operation
1203                 self.add_operation(
1204                     app_label,
1205                     operations.AlterOrderWithRespectTo(
1206                         name=model_name,
1207                         order_with_respect_to=new_model_state.options.get('order_with_respect_to'),
1208                     ),
1209                     dependencies=dependencies,
1210                 )
1211 
1212     def generate_altered_managers(self):
1213         for app_label, model_name in sorted(self.kept_model_keys):
1214             old_model_name = self.renamed_models.get((app_label, model_name), model_name)
1215             old_model_state = self.from_state.models[app_label, old_model_name]
1216             new_model_state = self.to_state.models[app_label, model_name]
1217             if old_model_state.managers != new_model_state.managers:
1218                 self.add_operation(
1219                     app_label,
1220                     operations.AlterModelManagers(
1221                         name=model_name,
1222                         managers=new_model_state.managers,
1223                     )
1224                 )
1225 
1226     def arrange_for_graph(self, changes, graph, migration_name=None):
1227         """
1228         Take a result from changes() and a MigrationGraph, and fix the names
1229         and dependencies of the changes so they extend the graph from the leaf
1230         nodes for each app.
1231         """
1232         leaves = graph.leaf_nodes()
1233         name_map = {}
1234         for app_label, migrations in list(changes.items()):
1235             if not migrations:
1236                 continue
1237             # Find the app label's current leaf node
1238             app_leaf = None
1239             for leaf in leaves:
1240                 if leaf[0] == app_label:
1241                     app_leaf = leaf
1242                     break
1243             # Do they want an initial migration for this app?
1244             if app_leaf is None and not self.questioner.ask_initial(app_label):
1245                 # They don't.
1246                 for migration in migrations:
1247                     name_map[(app_label, migration.name)] = (app_label, "__first__")
1248                 del changes[app_label]
1249                 continue
1250             # Work out the next number in the sequence
1251             if app_leaf is None:
1252                 next_number = 1
1253             else:
1254                 next_number = (self.parse_number(app_leaf[1]) or 0) + 1
1255             # Name each migration
1256             for i, migration in enumerate(migrations):
1257                 if i == 0 and app_leaf:
1258                     migration.dependencies.append(app_leaf)
1259                 if i == 0 and not app_leaf:
1260                     new_name = "0001_%s" % migration_name if migration_name else "0001_initial"
1261                 else:
1262                     new_name = "%04i_%s" % (
1263                         next_number,
1264                         migration_name or self.suggest_name(migration.operations)[:100],
1265                     )
1266                 name_map[(app_label, migration.name)] = (app_label, new_name)
1267                 next_number += 1
1268                 migration.name = new_name
1269         # Now fix dependencies
1270         for migrations in changes.values():
1271             for migration in migrations:
1272                 migration.dependencies = [name_map.get(d, d) for d in migration.dependencies]
1273         return changes
1274 
1275     def _trim_to_apps(self, changes, app_labels):
1276         """
1277         Take changes from arrange_for_graph() and set of app labels, and return
1278         a modified set of changes which trims out as many migrations that are
1279         not in app_labels as possible. Note that some other migrations may
1280         still be present as they may be required dependencies.
1281         """
1282         # Gather other app dependencies in a first pass
1283         app_dependencies = {}
1284         for app_label, migrations in changes.items():
1285             for migration in migrations:
1286                 for dep_app_label, name in migration.dependencies:
1287                     app_dependencies.setdefault(app_label, set()).add(dep_app_label)
1288         required_apps = set(app_labels)
1289         # Keep resolving till there's no change
1290         old_required_apps = None
1291         while old_required_apps != required_apps:
1292             old_required_apps = set(required_apps)
1293             required_apps.update(*[app_dependencies.get(app_label, ()) for app_label in required_apps])
1294         # Remove all migrations that aren't needed
1295         for app_label in list(changes):
1296             if app_label not in required_apps:
1297                 del changes[app_label]
1298         return changes
1299 
1300     @classmethod
1301     def suggest_name(cls, ops):
1302         """
1303         Given a set of operations, suggest a name for the migration they might
1304         represent. Names are not guaranteed to be unique, but put some effort
1305         into the fallback name to avoid VCS conflicts if possible.
1306         """
1307         if len(ops) == 1:
1308             if isinstance(ops[0], operations.CreateModel):
1309                 return ops[0].name_lower
1310             elif isinstance(ops[0], operations.DeleteModel):
1311                 return "delete_%s" % ops[0].name_lower
1312             elif isinstance(ops[0], operations.AddField):
1313                 return "%s_%s" % (ops[0].model_name_lower, ops[0].name_lower)
1314             elif isinstance(ops[0], operations.RemoveField):
1315                 return "remove_%s_%s" % (ops[0].model_name_lower, ops[0].name_lower)
1316         elif ops:
1317             if all(isinstance(o, operations.CreateModel) for o in ops):
1318                 return "_".join(sorted(o.name_lower for o in ops))
1319         return "auto_%s" % get_migration_name_timestamp()
1320 
1321     @classmethod
1322     def parse_number(cls, name):
1323         """
1324         Given a migration name, try to extract a number from the beginning of
1325         it. If no number is found, return None.
1326         """
1327         match = re.match(r'^\d+', name)
1328         if match:
1329             return int(match.group())
1330         return None

</code><intended_behavior>Ensure the migration autodetector is capable of detecting changes in fields of a model and the implications on related fields, specifically in ManyToManyField relationships, possibly altering related database table schemas.</intended_behavior>]
2025-10-15 17:44:07.749 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-15 17:44:07.750 | INFO     | Search-only: skipping patch selection
2025-10-15 17:44:07.882 | INFO     | Task django__django-12734 completed successfully.
2025-10-15 17:44:07.882 | INFO     | No patch generated. You can try running ACR again.
