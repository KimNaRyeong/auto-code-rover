[
    {
        "rel_file_path": "django/db/models/fields/related.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.1/django/db/models/fields/related.py",
        "start": 1120,
        "end": 1692,
        "class_name": "ManyToManyField",
        "method_name": null,
        "code": "1120 class ManyToManyField(RelatedField):\n1121     \"\"\"\n1122     Provide a many-to-many relation by using an intermediary model that\n1123     holds two ForeignKey fields pointed at the two sides of the relation.\n1124 \n1125     Unless a ``through`` model was provided, ManyToManyField will use the\n1126     create_many_to_many_intermediary_model factory to automatically generate\n1127     the intermediary model.\n1128     \"\"\"\n1129 \n1130     # Field flags\n1131     many_to_many = True\n1132     many_to_one = False\n1133     one_to_many = False\n1134     one_to_one = False\n1135 \n1136     rel_class = ManyToManyRel\n1137 \n1138     description = _(\"Many-to-many relationship\")\n1139 \n1140     def __init__(self, to, related_name=None, related_query_name=None,\n1141                  limit_choices_to=None, symmetrical=None, through=None,\n1142                  through_fields=None, db_constraint=True, db_table=None,\n1143                  swappable=True, **kwargs):\n1144         try:\n1145             to._meta\n1146         except AttributeError:\n1147             assert isinstance(to, str), (\n1148                 \"%s(%r) is invalid. First parameter to ManyToManyField must be \"\n1149                 \"either a model, a model name, or the string %r\" %\n1150                 (self.__class__.__name__, to, RECURSIVE_RELATIONSHIP_CONSTANT)\n1151             )\n1152 \n1153         if symmetrical is None:\n1154             symmetrical = (to == RECURSIVE_RELATIONSHIP_CONSTANT)\n1155 \n1156         if through is not None:\n1157             assert db_table is None, (\n1158                 \"Cannot specify a db_table if an intermediary model is used.\"\n1159             )\n1160 \n1161         kwargs['rel'] = self.rel_class(\n1162             self, to,\n1163             related_name=related_name,\n1164             related_query_name=related_query_name,\n1165             limit_choices_to=limit_choices_to,\n1166             symmetrical=symmetrical,\n1167             through=through,\n1168             through_fields=through_fields,\n1169             db_constraint=db_constraint,\n1170         )\n1171         self.has_null_arg = 'null' in kwargs\n1172 \n1173         super().__init__(**kwargs)\n1174 \n1175         self.db_table = db_table\n1176         self.swappable = swappable\n1177 \n1178     def check(self, **kwargs):\n1179         return [\n1180             *super().check(**kwargs),\n1181             *self._check_unique(**kwargs),\n1182             *self._check_relationship_model(**kwargs),\n1183             *self._check_ignored_options(**kwargs),\n1184             *self._check_table_uniqueness(**kwargs),\n1185         ]\n1186 \n1187     def _check_unique(self, **kwargs):\n1188         if self.unique:\n1189             return [\n1190                 checks.Error(\n1191                     'ManyToManyFields cannot be unique.',\n1192                     obj=self,\n1193                     id='fields.E330',\n1194                 )\n1195             ]\n1196         return []\n1197 \n1198     def _check_ignored_options(self, **kwargs):\n1199         warnings = []\n1200 \n1201         if self.has_null_arg:\n1202             warnings.append(\n1203                 checks.Warning(\n1204                     'null has no effect on ManyToManyField.',\n1205                     obj=self,\n1206                     id='fields.W340',\n1207                 )\n1208             )\n1209 \n1210         if self._validators:\n1211             warnings.append(\n1212                 checks.Warning(\n1213                     'ManyToManyField does not support validators.',\n1214                     obj=self,\n1215                     id='fields.W341',\n1216                 )\n1217             )\n1218         if (self.remote_field.limit_choices_to and self.remote_field.through and\n1219                 not self.remote_field.through._meta.auto_created):\n1220             warnings.append(\n1221                 checks.Warning(\n1222                     'limit_choices_to has no effect on ManyToManyField '\n1223                     'with a through model.',\n1224                     obj=self,\n1225                     id='fields.W343',\n1226                 )\n1227             )\n1228 \n1229         return warnings\n1230 \n1231     def _check_relationship_model(self, from_model=None, **kwargs):\n1232         if hasattr(self.remote_field.through, '_meta'):\n1233             qualified_model_name = \"%s.%s\" % (\n1234                 self.remote_field.through._meta.app_label, self.remote_field.through.__name__)\n1235         else:\n1236             qualified_model_name = self.remote_field.through\n1237 \n1238         errors = []\n1239 \n1240         if self.remote_field.through not in self.opts.apps.get_models(include_auto_created=True):\n1241             # The relationship model is not installed.\n1242             errors.append(\n1243                 checks.Error(\n1244                     \"Field specifies a many-to-many relation through model \"\n1245                     \"'%s', which has not been installed.\" % qualified_model_name,\n1246                     obj=self,\n1247                     id='fields.E331',\n1248                 )\n1249             )\n1250 \n1251         else:\n1252             assert from_model is not None, (\n1253                 \"ManyToManyField with intermediate \"\n1254                 \"tables cannot be checked if you don't pass the model \"\n1255                 \"where the field is attached to.\"\n1256             )\n1257             # Set some useful local variables\n1258             to_model = resolve_relation(from_model, self.remote_field.model)\n1259             from_model_name = from_model._meta.object_name\n1260             if isinstance(to_model, str):\n1261                 to_model_name = to_model\n1262             else:\n1263                 to_model_name = to_model._meta.object_name\n1264             relationship_model_name = self.remote_field.through._meta.object_name\n1265             self_referential = from_model == to_model\n1266             # Count foreign keys in intermediate model\n1267             if self_referential:\n1268                 seen_self = sum(\n1269                     from_model == getattr(field.remote_field, 'model', None)\n1270                     for field in self.remote_field.through._meta.fields\n1271                 )\n1272 \n1273                 if seen_self > 2 and not self.remote_field.through_fields:\n1274                     errors.append(\n1275                         checks.Error(\n1276                             \"The model is used as an intermediate model by \"\n1277                             \"'%s', but it has more than two foreign keys \"\n1278                             \"to '%s', which is ambiguous. You must specify \"\n1279                             \"which two foreign keys Django should use via the \"\n1280                             \"through_fields keyword argument.\" % (self, from_model_name),\n1281                             hint=\"Use through_fields to specify which two foreign keys Django should use.\",\n1282                             obj=self.remote_field.through,\n1283                             id='fields.E333',\n1284                         )\n1285                     )\n1286 \n1287             else:\n1288                 # Count foreign keys in relationship model\n1289                 seen_from = sum(\n1290                     from_model == getattr(field.remote_field, 'model', None)\n1291                     for field in self.remote_field.through._meta.fields\n1292                 )\n1293                 seen_to = sum(\n1294                     to_model == getattr(field.remote_field, 'model', None)\n1295                     for field in self.remote_field.through._meta.fields\n1296                 )\n1297 \n1298                 if seen_from > 1 and not self.remote_field.through_fields:\n1299                     errors.append(\n1300                         checks.Error(\n1301                             (\"The model is used as an intermediate model by \"\n1302                              \"'%s', but it has more than one foreign key \"\n1303                              \"from '%s', which is ambiguous. You must specify \"\n1304                              \"which foreign key Django should use via the \"\n1305                              \"through_fields keyword argument.\") % (self, from_model_name),\n1306                             hint=(\n1307                                 'If you want to create a recursive relationship, '\n1308                                 'use ManyToManyField(\"%s\", through=\"%s\").'\n1309                             ) % (\n1310                                 RECURSIVE_RELATIONSHIP_CONSTANT,\n1311                                 relationship_model_name,\n1312                             ),\n1313                             obj=self,\n1314                             id='fields.E334',\n1315                         )\n1316                     )\n1317 \n1318                 if seen_to > 1 and not self.remote_field.through_fields:\n1319                     errors.append(\n1320                         checks.Error(\n1321                             \"The model is used as an intermediate model by \"\n1322                             \"'%s', but it has more than one foreign key \"\n1323                             \"to '%s', which is ambiguous. You must specify \"\n1324                             \"which foreign key Django should use via the \"\n1325                             \"through_fields keyword argument.\" % (self, to_model_name),\n1326                             hint=(\n1327                                 'If you want to create a recursive relationship, '\n1328                                 'use ManyToManyField(\"%s\", through=\"%s\").'\n1329                             ) % (\n1330                                 RECURSIVE_RELATIONSHIP_CONSTANT,\n1331                                 relationship_model_name,\n1332                             ),\n1333                             obj=self,\n1334                             id='fields.E335',\n1335                         )\n1336                     )\n1337 \n1338                 if seen_from == 0 or seen_to == 0:\n1339                     errors.append(\n1340                         checks.Error(\n1341                             \"The model is used as an intermediate model by \"\n1342                             \"'%s', but it does not have a foreign key to '%s' or '%s'.\" % (\n1343                                 self, from_model_name, to_model_name\n1344                             ),\n1345                             obj=self.remote_field.through,\n1346                             id='fields.E336',\n1347                         )\n1348                     )\n1349 \n1350         # Validate `through_fields`.\n1351         if self.remote_field.through_fields is not None:\n1352             # Validate that we're given an iterable of at least two items\n1353             # and that none of them is \"falsy\".\n1354             if not (len(self.remote_field.through_fields) >= 2 and\n1355                     self.remote_field.through_fields[0] and self.remote_field.through_fields[1]):\n1356                 errors.append(\n1357                     checks.Error(\n1358                         \"Field specifies 'through_fields' but does not provide \"\n1359                         \"the names of the two link fields that should be used \"\n1360                         \"for the relation through model '%s'.\" % qualified_model_name,\n1361                         hint=\"Make sure you specify 'through_fields' as through_fields=('field1', 'field2')\",\n1362                         obj=self,\n1363                         id='fields.E337',\n1364                     )\n1365                 )\n1366 \n1367             # Validate the given through fields -- they should be actual\n1368             # fields on the through model, and also be foreign keys to the\n1369             # expected models.\n1370             else:\n1371                 assert from_model is not None, (\n1372                     \"ManyToManyField with intermediate \"\n1373                     \"tables cannot be checked if you don't pass the model \"\n1374                     \"where the field is attached to.\"\n1375                 )\n1376 \n1377                 source, through, target = from_model, self.remote_field.through, self.remote_field.model\n1378                 source_field_name, target_field_name = self.remote_field.through_fields[:2]\n1379 \n1380                 for field_name, related_model in ((source_field_name, source),\n1381                                                   (target_field_name, target)):\n1382 \n1383                     possible_field_names = []\n1384                     for f in through._meta.fields:\n1385                         if hasattr(f, 'remote_field') and getattr(f.remote_field, 'model', None) == related_model:\n1386                             possible_field_names.append(f.name)\n1387                     if possible_field_names:\n1388                         hint = \"Did you mean one of the following foreign keys to '%s': %s?\" % (\n1389                             related_model._meta.object_name,\n1390                             ', '.join(possible_field_names),\n1391                         )\n1392                     else:\n1393                         hint = None\n1394 \n1395                     try:\n1396                         field = through._meta.get_field(field_name)\n1397                     except exceptions.FieldDoesNotExist:\n1398                         errors.append(\n1399                             checks.Error(\n1400                                 \"The intermediary model '%s' has no field '%s'.\"\n1401                                 % (qualified_model_name, field_name),\n1402                                 hint=hint,\n1403                                 obj=self,\n1404                                 id='fields.E338',\n1405                             )\n1406                         )\n1407                     else:\n1408                         if not (hasattr(field, 'remote_field') and\n1409                                 getattr(field.remote_field, 'model', None) == related_model):\n1410                             errors.append(\n1411                                 checks.Error(\n1412                                     \"'%s.%s' is not a foreign key to '%s'.\" % (\n1413                                         through._meta.object_name, field_name,\n1414                                         related_model._meta.object_name,\n1415                                     ),\n1416                                     hint=hint,\n1417                                     obj=self,\n1418                                     id='fields.E339',\n1419                                 )\n1420                             )\n1421 \n1422         return errors\n1423 \n1424     def _check_table_uniqueness(self, **kwargs):\n1425         if isinstance(self.remote_field.through, str) or not self.remote_field.through._meta.managed:\n1426             return []\n1427         registered_tables = {\n1428             model._meta.db_table: model\n1429             for model in self.opts.apps.get_models(include_auto_created=True)\n1430             if model != self.remote_field.through and model._meta.managed\n1431         }\n1432         m2m_db_table = self.m2m_db_table()\n1433         model = registered_tables.get(m2m_db_table)\n1434         # The second condition allows multiple m2m relations on a model if\n1435         # some point to a through model that proxies another through model.\n1436         if model and model._meta.concrete_model != self.remote_field.through._meta.concrete_model:\n1437             if model._meta.auto_created:\n1438                 def _get_field_name(model):\n1439                     for field in model._meta.auto_created._meta.many_to_many:\n1440                         if field.remote_field.through is model:\n1441                             return field.name\n1442                 opts = model._meta.auto_created._meta\n1443                 clashing_obj = '%s.%s' % (opts.label, _get_field_name(model))\n1444             else:\n1445                 clashing_obj = model._meta.label\n1446             if settings.DATABASE_ROUTERS:\n1447                 error_class, error_id = checks.Warning, 'fields.W344'\n1448                 error_hint = (\n1449                     'You have configured settings.DATABASE_ROUTERS. Verify '\n1450                     'that the table of %r is correctly routed to a separate '\n1451                     'database.' % clashing_obj\n1452                 )\n1453             else:\n1454                 error_class, error_id = checks.Error, 'fields.E340'\n1455                 error_hint = None\n1456             return [\n1457                 error_class(\n1458                     \"The field's intermediary table '%s' clashes with the \"\n1459                     \"table name of '%s'.\" % (m2m_db_table, clashing_obj),\n1460                     obj=self,\n1461                     hint=error_hint,\n1462                     id=error_id,\n1463                 )\n1464             ]\n1465         return []\n1466 \n1467     def deconstruct(self):\n1468         name, path, args, kwargs = super().deconstruct()\n1469         # Handle the simpler arguments.\n1470         if self.db_table is not None:\n1471             kwargs['db_table'] = self.db_table\n1472         if self.remote_field.db_constraint is not True:\n1473             kwargs['db_constraint'] = self.remote_field.db_constraint\n1474         # Rel needs more work.\n1475         if isinstance(self.remote_field.model, str):\n1476             kwargs['to'] = self.remote_field.model\n1477         else:\n1478             kwargs['to'] = \"%s.%s\" % (\n1479                 self.remote_field.model._meta.app_label,\n1480                 self.remote_field.model._meta.object_name,\n1481             )\n1482         if getattr(self.remote_field, 'through', None) is not None:\n1483             if isinstance(self.remote_field.through, str):\n1484                 kwargs['through'] = self.remote_field.through\n1485             elif not self.remote_field.through._meta.auto_created:\n1486                 kwargs['through'] = \"%s.%s\" % (\n1487                     self.remote_field.through._meta.app_label,\n1488                     self.remote_field.through._meta.object_name,\n1489                 )\n1490         # If swappable is True, then see if we're actually pointing to the target\n1491         # of a swap.\n1492         swappable_setting = self.swappable_setting\n1493         if swappable_setting is not None:\n1494             # If it's already a settings reference, error.\n1495             if hasattr(kwargs['to'], \"setting_name\"):\n1496                 if kwargs['to'].setting_name != swappable_setting:\n1497                     raise ValueError(\n1498                         \"Cannot deconstruct a ManyToManyField pointing to a \"\n1499                         \"model that is swapped in place of more than one model \"\n1500                         \"(%s and %s)\" % (kwargs['to'].setting_name, swappable_setting)\n1501                     )\n1502 \n1503             kwargs['to'] = SettingsReference(\n1504                 kwargs['to'],\n1505                 swappable_setting,\n1506             )\n1507         return name, path, args, kwargs\n1508 \n1509     def _get_path_info(self, direct=False, filtered_relation=None):\n1510         \"\"\"Called by both direct and indirect m2m traversal.\"\"\"\n1511         int_model = self.remote_field.through\n1512         linkfield1 = int_model._meta.get_field(self.m2m_field_name())\n1513         linkfield2 = int_model._meta.get_field(self.m2m_reverse_field_name())\n1514         if direct:\n1515             join1infos = linkfield1.get_reverse_path_info()\n1516             join2infos = linkfield2.get_path_info(filtered_relation)\n1517         else:\n1518             join1infos = linkfield2.get_reverse_path_info()\n1519             join2infos = linkfield1.get_path_info(filtered_relation)\n1520 \n1521         # Get join infos between the last model of join 1 and the first model\n1522         # of join 2. Assume the only reason these may differ is due to model\n1523         # inheritance.\n1524         join1_final = join1infos[-1].to_opts\n1525         join2_initial = join2infos[0].from_opts\n1526         if join1_final is join2_initial:\n1527             intermediate_infos = []\n1528         elif issubclass(join1_final.model, join2_initial.model):\n1529             intermediate_infos = join1_final.get_path_to_parent(join2_initial.model)\n1530         else:\n1531             intermediate_infos = join2_initial.get_path_from_parent(join1_final.model)\n1532 \n1533         return [*join1infos, *intermediate_infos, *join2infos]\n1534 \n1535     def get_path_info(self, filtered_relation=None):\n1536         return self._get_path_info(direct=True, filtered_relation=filtered_relation)\n1537 \n1538     def get_reverse_path_info(self, filtered_relation=None):\n1539         return self._get_path_info(direct=False, filtered_relation=filtered_relation)\n1540 \n1541     def _get_m2m_db_table(self, opts):\n1542         \"\"\"\n1543         Function that can be curried to provide the m2m table name for this\n1544         relation.\n1545         \"\"\"\n1546         if self.remote_field.through is not None:\n1547             return self.remote_field.through._meta.db_table\n1548         elif self.db_table:\n1549             return self.db_table\n1550         else:\n1551             m2m_table_name = '%s_%s' % (utils.strip_quotes(opts.db_table), self.name)\n1552             return utils.truncate_name(m2m_table_name, connection.ops.max_name_length())\n1553 \n1554     def _get_m2m_attr(self, related, attr):\n1555         \"\"\"\n1556         Function that can be curried to provide the source accessor or DB\n1557         column name for the m2m table.\n1558         \"\"\"\n1559         cache_attr = '_m2m_%s_cache' % attr\n1560         if hasattr(self, cache_attr):\n1561             return getattr(self, cache_attr)\n1562         if self.remote_field.through_fields is not None:\n1563             link_field_name = self.remote_field.through_fields[0]\n1564         else:\n1565             link_field_name = None\n1566         for f in self.remote_field.through._meta.fields:\n1567             if (f.is_relation and f.remote_field.model == related.related_model and\n1568                     (link_field_name is None or link_field_name == f.name)):\n1569                 setattr(self, cache_attr, getattr(f, attr))\n1570                 return getattr(self, cache_attr)\n1571 \n1572     def _get_m2m_reverse_attr(self, related, attr):\n1573         \"\"\"\n1574         Function that can be curried to provide the related accessor or DB\n1575         column name for the m2m table.\n1576         \"\"\"\n1577         cache_attr = '_m2m_reverse_%s_cache' % attr\n1578         if hasattr(self, cache_attr):\n1579             return getattr(self, cache_attr)\n1580         found = False\n1581         if self.remote_field.through_fields is not None:\n1582             link_field_name = self.remote_field.through_fields[1]\n1583         else:\n1584             link_field_name = None\n1585         for f in self.remote_field.through._meta.fields:\n1586             if f.is_relation and f.remote_field.model == related.model:\n1587                 if link_field_name is None and related.related_model == related.model:\n1588                     # If this is an m2m-intermediate to self,\n1589                     # the first foreign key you find will be\n1590                     # the source column. Keep searching for\n1591                     # the second foreign key.\n1592                     if found:\n1593                         setattr(self, cache_attr, getattr(f, attr))\n1594                         break\n1595                     else:\n1596                         found = True\n1597                 elif link_field_name is None or link_field_name == f.name:\n1598                     setattr(self, cache_attr, getattr(f, attr))\n1599                     break\n1600         return getattr(self, cache_attr)\n1601 \n1602     def contribute_to_class(self, cls, name, **kwargs):\n1603         # To support multiple relations to self, it's useful to have a non-None\n1604         # related name on symmetrical relations for internal reasons. The\n1605         # concept doesn't make a lot of sense externally (\"you want me to\n1606         # specify *what* on my non-reversible relation?!\"), so we set it up\n1607         # automatically. The funky name reduces the chance of an accidental\n1608         # clash.\n1609         if self.remote_field.symmetrical and (\n1610             self.remote_field.model == RECURSIVE_RELATIONSHIP_CONSTANT or\n1611             self.remote_field.model == cls._meta.object_name\n1612         ):\n1613             self.remote_field.related_name = \"%s_rel_+\" % name\n1614         elif self.remote_field.is_hidden():\n1615             # If the backwards relation is disabled, replace the original\n1616             # related_name with one generated from the m2m field name. Django\n1617             # still uses backwards relations internally and we need to avoid\n1618             # clashes between multiple m2m fields with related_name == '+'.\n1619             self.remote_field.related_name = \"_%s_%s_+\" % (cls.__name__.lower(), name)\n1620 \n1621         super().contribute_to_class(cls, name, **kwargs)\n1622 \n1623         # The intermediate m2m model is not auto created if:\n1624         #  1) There is a manually specified intermediate, or\n1625         #  2) The class owning the m2m field is abstract.\n1626         #  3) The class owning the m2m field has been swapped out.\n1627         if not cls._meta.abstract:\n1628             if self.remote_field.through:\n1629                 def resolve_through_model(_, model, field):\n1630                     field.remote_field.through = model\n1631                 lazy_related_operation(resolve_through_model, cls, self.remote_field.through, field=self)\n1632             elif not cls._meta.swapped:\n1633                 self.remote_field.through = create_many_to_many_intermediary_model(self, cls)\n1634 \n1635         # Add the descriptor for the m2m relation.\n1636         setattr(cls, self.name, ManyToManyDescriptor(self.remote_field, reverse=False))\n1637 \n1638         # Set up the accessor for the m2m table name for the relation.\n1639         self.m2m_db_table = partial(self._get_m2m_db_table, cls._meta)\n1640 \n1641     def contribute_to_related_class(self, cls, related):\n1642         # Internal M2Ms (i.e., those with a related name ending with '+')\n1643         # and swapped models don't get a related descriptor.\n1644         if not self.remote_field.is_hidden() and not related.related_model._meta.swapped:\n1645             setattr(cls, related.get_accessor_name(), ManyToManyDescriptor(self.remote_field, reverse=True))\n1646 \n1647         # Set up the accessors for the column names on the m2m table.\n1648         self.m2m_column_name = partial(self._get_m2m_attr, related, 'column')\n1649         self.m2m_reverse_name = partial(self._get_m2m_reverse_attr, related, 'column')\n1650 \n1651         self.m2m_field_name = partial(self._get_m2m_attr, related, 'name')\n1652         self.m2m_reverse_field_name = partial(self._get_m2m_reverse_attr, related, 'name')\n1653 \n1654         get_m2m_rel = partial(self._get_m2m_attr, related, 'remote_field')\n1655         self.m2m_target_field_name = lambda: get_m2m_rel().field_name\n1656         get_m2m_reverse_rel = partial(self._get_m2m_reverse_attr, related, 'remote_field')\n1657         self.m2m_reverse_target_field_name = lambda: get_m2m_reverse_rel().field_name\n1658 \n1659     def set_attributes_from_rel(self):\n1660         pass\n1661 \n1662     def value_from_object(self, obj):\n1663         return [] if obj.pk is None else list(getattr(obj, self.attname).all())\n1664 \n1665     def save_form_data(self, instance, data):\n1666         getattr(instance, self.attname).set(data)\n1667 \n1668     def formfield(self, *, using=None, **kwargs):\n1669         defaults = {\n1670             'form_class': forms.ModelMultipleChoiceField,\n1671             'queryset': self.remote_field.model._default_manager.using(using),\n1672             **kwargs,\n1673         }\n1674         # If initial is passed in, it's a list of related objects, but the\n1675         # MultipleChoiceField takes a list of IDs.\n1676         if defaults.get('initial') is not None:\n1677             initial = defaults['initial']\n1678             if callable(initial):\n1679                 initial = initial()\n1680             defaults['initial'] = [i.pk for i in initial]\n1681         return super().formfield(**defaults)\n1682 \n1683     def db_check(self, connection):\n1684         return None\n1685 \n1686     def db_type(self, connection):\n1687         # A ManyToManyField is not represented by a single column,\n1688         # so return None.\n1689         return None\n1690 \n1691     def db_parameters(self, connection):\n1692         return {\"type\": None, \"check\": None}\n",
        "intended_behavior": "Modify or extend the implementation to ensure that when a model having a ManyToManyField is altered, the alteration cascades the changes appropriately to related fields in the intermediary join table."
    },
    {
        "rel_file_path": "django/db/migrations/autodetector.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.1/django/db/migrations/autodetector.py",
        "start": 1,
        "end": 1330,
        "class_name": null,
        "method_name": null,
        "code": "1 import functools\n2 import re\n3 from itertools import chain\n4 \n5 from django.conf import settings\n6 from django.db import models\n7 from django.db.migrations import operations\n8 from django.db.migrations.migration import Migration\n9 from django.db.migrations.operations.models import AlterModelOptions\n10 from django.db.migrations.optimizer import MigrationOptimizer\n11 from django.db.migrations.questioner import MigrationQuestioner\n12 from django.db.migrations.utils import (\n13     COMPILED_REGEX_TYPE, RegexObject, get_migration_name_timestamp,\n14 )\n15 from django.utils.topological_sort import stable_topological_sort\n16 \n17 \n18 class MigrationAutodetector:\n19     \"\"\"\n20     Take a pair of ProjectStates and compare them to see what the first would\n21     need doing to make it match the second (the second usually being the\n22     project's current state).\n23 \n24     Note that this naturally operates on entire projects at a time,\n25     as it's likely that changes interact (for example, you can't\n26     add a ForeignKey without having a migration to add the table it\n27     depends on first). A user interface may offer single-app usage\n28     if it wishes, with the caveat that it may not always be possible.\n29     \"\"\"\n30 \n31     def __init__(self, from_state, to_state, questioner=None):\n32         self.from_state = from_state\n33         self.to_state = to_state\n34         self.questioner = questioner or MigrationQuestioner()\n35         self.existing_apps = {app for app, model in from_state.models}\n36 \n37     def changes(self, graph, trim_to_apps=None, convert_apps=None, migration_name=None):\n38         \"\"\"\n39         Main entry point to produce a list of applicable changes.\n40         Take a graph to base names on and an optional set of apps\n41         to try and restrict to (restriction is not guaranteed)\n42         \"\"\"\n43         changes = self._detect_changes(convert_apps, graph)\n44         changes = self.arrange_for_graph(changes, graph, migration_name)\n45         if trim_to_apps:\n46             changes = self._trim_to_apps(changes, trim_to_apps)\n47         return changes\n48 \n49     def deep_deconstruct(self, obj):\n50         \"\"\"\n51         Recursive deconstruction for a field and its arguments.\n52         Used for full comparison for rename/alter; sometimes a single-level\n53         deconstruction will not compare correctly.\n54         \"\"\"\n55         if isinstance(obj, list):\n56             return [self.deep_deconstruct(value) for value in obj]\n57         elif isinstance(obj, tuple):\n58             return tuple(self.deep_deconstruct(value) for value in obj)\n59         elif isinstance(obj, dict):\n60             return {\n61                 key: self.deep_deconstruct(value)\n62                 for key, value in obj.items()\n63             }\n64         elif isinstance(obj, functools.partial):\n65             return (obj.func, self.deep_deconstruct(obj.args), self.deep_deconstruct(obj.keywords))\n66         elif isinstance(obj, COMPILED_REGEX_TYPE):\n67             return RegexObject(obj)\n68         elif isinstance(obj, type):\n69             # If this is a type that implements 'deconstruct' as an instance method,\n70             # avoid treating this as being deconstructible itself - see #22951\n71             return obj\n72         elif hasattr(obj, 'deconstruct'):\n73             deconstructed = obj.deconstruct()\n74             if isinstance(obj, models.Field):\n75                 # we have a field which also returns a name\n76                 deconstructed = deconstructed[1:]\n77             path, args, kwargs = deconstructed\n78             return (\n79                 path,\n80                 [self.deep_deconstruct(value) for value in args],\n81                 {\n82                     key: self.deep_deconstruct(value)\n83                     for key, value in kwargs.items()\n84                 },\n85             )\n86         else:\n87             return obj\n88 \n89     def only_relation_agnostic_fields(self, fields):\n90         \"\"\"\n91         Return a definition of the fields that ignores field names and\n92         what related fields actually relate to. Used for detecting renames (as,\n93         of course, the related fields change during renames).\n94         \"\"\"\n95         fields_def = []\n96         for name, field in sorted(fields):\n97             deconstruction = self.deep_deconstruct(field)\n98             if field.remote_field and field.remote_field.model:\n99                 del deconstruction[2]['to']\n100             fields_def.append(deconstruction)\n101         return fields_def\n102 \n103     def _detect_changes(self, convert_apps=None, graph=None):\n104         \"\"\"\n105         Return a dict of migration plans which will achieve the\n106         change from from_state to to_state. The dict has app labels\n107         as keys and a list of migrations as values.\n108 \n109         The resulting migrations aren't specially named, but the names\n110         do matter for dependencies inside the set.\n111 \n112         convert_apps is the list of apps to convert to use migrations\n113         (i.e. to make initial migrations for, in the usual case)\n114 \n115         graph is an optional argument that, if provided, can help improve\n116         dependency generation and avoid potential circular dependencies.\n117         \"\"\"\n118         # The first phase is generating all the operations for each app\n119         # and gathering them into a big per-app list.\n120         # Then go through that list, order it, and split into migrations to\n121         # resolve dependencies caused by M2Ms and FKs.\n122         self.generated_operations = {}\n123         self.altered_indexes = {}\n124         self.altered_constraints = {}\n125 \n126         # Prepare some old/new state and model lists, separating\n127         # proxy models and ignoring unmigrated apps.\n128         self.old_apps = self.from_state.concrete_apps\n129         self.new_apps = self.to_state.apps\n130         self.old_model_keys = set()\n131         self.old_proxy_keys = set()\n132         self.old_unmanaged_keys = set()\n133         self.new_model_keys = set()\n134         self.new_proxy_keys = set()\n135         self.new_unmanaged_keys = set()\n136         for al, mn in self.from_state.models:\n137             model = self.old_apps.get_model(al, mn)\n138             if not model._meta.managed:\n139                 self.old_unmanaged_keys.add((al, mn))\n140             elif al not in self.from_state.real_apps:\n141                 if model._meta.proxy:\n142                     self.old_proxy_keys.add((al, mn))\n143                 else:\n144                     self.old_model_keys.add((al, mn))\n145 \n146         for al, mn in self.to_state.models:\n147             model = self.new_apps.get_model(al, mn)\n148             if not model._meta.managed:\n149                 self.new_unmanaged_keys.add((al, mn))\n150             elif (\n151                 al not in self.from_state.real_apps or\n152                 (convert_apps and al in convert_apps)\n153             ):\n154                 if model._meta.proxy:\n155                     self.new_proxy_keys.add((al, mn))\n156                 else:\n157                     self.new_model_keys.add((al, mn))\n158 \n159         # Renames have to come first\n160         self.generate_renamed_models()\n161 \n162         # Prepare lists of fields and generate through model map\n163         self._prepare_field_lists()\n164         self._generate_through_model_map()\n165 \n166         # Generate non-rename model operations\n167         self.generate_deleted_models()\n168         self.generate_created_models()\n169         self.generate_deleted_proxies()\n170         self.generate_created_proxies()\n171         self.generate_altered_options()\n172         self.generate_altered_managers()\n173 \n174         # Create the altered indexes and store them in self.altered_indexes.\n175         # This avoids the same computation in generate_removed_indexes()\n176         # and generate_added_indexes().\n177         self.create_altered_indexes()\n178         self.create_altered_constraints()\n179         # Generate index removal operations before field is removed\n180         self.generate_removed_constraints()\n181         self.generate_removed_indexes()\n182         # Generate field operations\n183         self.generate_renamed_fields()\n184         self.generate_removed_fields()\n185         self.generate_added_fields()\n186         self.generate_altered_fields()\n187         self.generate_altered_unique_together()\n188         self.generate_altered_index_together()\n189         self.generate_added_indexes()\n190         self.generate_added_constraints()\n191         self.generate_altered_db_table()\n192         self.generate_altered_order_with_respect_to()\n193 \n194         self._sort_migrations()\n195         self._build_migration_list(graph)\n196         self._optimize_migrations()\n197 \n198         return self.migrations\n199 \n200     def _prepare_field_lists(self):\n201         \"\"\"\n202         Prepare field lists and a list of the fields that used through models\n203         in the old state so dependencies can be made from the through model\n204         deletion to the field that uses it.\n205         \"\"\"\n206         self.kept_model_keys = self.old_model_keys & self.new_model_keys\n207         self.kept_proxy_keys = self.old_proxy_keys & self.new_proxy_keys\n208         self.kept_unmanaged_keys = self.old_unmanaged_keys & self.new_unmanaged_keys\n209         self.through_users = {}\n210         self.old_field_keys = {\n211             (app_label, model_name, x)\n212             for app_label, model_name in self.kept_model_keys\n213             for x, y in self.from_state.models[\n214                 app_label,\n215                 self.renamed_models.get((app_label, model_name), model_name)\n216             ].fields\n217         }\n218         self.new_field_keys = {\n219             (app_label, model_name, x)\n220             for app_label, model_name in self.kept_model_keys\n221             for x, y in self.to_state.models[app_label, model_name].fields\n222         }\n223 \n224     def _generate_through_model_map(self):\n225         \"\"\"Through model map generation.\"\"\"\n226         for app_label, model_name in sorted(self.old_model_keys):\n227             old_model_name = self.renamed_models.get((app_label, model_name), model_name)\n228             old_model_state = self.from_state.models[app_label, old_model_name]\n229             for field_name, field in old_model_state.fields:\n230                 old_field = self.old_apps.get_model(app_label, old_model_name)._meta.get_field(field_name)\n231                 if (hasattr(old_field, \"remote_field\") and getattr(old_field.remote_field, \"through\", None) and\n232                         not old_field.remote_field.through._meta.auto_created):\n233                     through_key = (\n234                         old_field.remote_field.through._meta.app_label,\n235                         old_field.remote_field.through._meta.model_name,\n236                     )\n237                     self.through_users[through_key] = (app_label, old_model_name, field_name)\n238 \n239     @staticmethod\n240     def _resolve_dependency(dependency):\n241         \"\"\"\n242         Return the resolved dependency and a boolean denoting whether or not\n243         it was swappable.\n244         \"\"\"\n245         if dependency[0] != '__setting__':\n246             return dependency, False\n247         resolved_app_label, resolved_object_name = getattr(settings, dependency[1]).split('.')\n248         return (resolved_app_label, resolved_object_name.lower()) + dependency[2:], True\n249 \n250     def _build_migration_list(self, graph=None):\n251         \"\"\"\n252         Chop the lists of operations up into migrations with dependencies on\n253         each other. Do this by going through an app's list of operations until\n254         one is found that has an outgoing dependency that isn't in another\n255         app's migration yet (hasn't been chopped off its list). Then chop off\n256         the operations before it into a migration and move onto the next app.\n257         If the loops completes without doing anything, there's a circular\n258         dependency (which _should_ be impossible as the operations are\n259         all split at this point so they can't depend and be depended on).\n260         \"\"\"\n261         self.migrations = {}\n262         num_ops = sum(len(x) for x in self.generated_operations.values())\n263         chop_mode = False\n264         while num_ops:\n265             # On every iteration, we step through all the apps and see if there\n266             # is a completed set of operations.\n267             # If we find that a subset of the operations are complete we can\n268             # try to chop it off from the rest and continue, but we only\n269             # do this if we've already been through the list once before\n270             # without any chopping and nothing has changed.\n271             for app_label in sorted(self.generated_operations):\n272                 chopped = []\n273                 dependencies = set()\n274                 for operation in list(self.generated_operations[app_label]):\n275                     deps_satisfied = True\n276                     operation_dependencies = set()\n277                     for dep in operation._auto_deps:\n278                         # Temporarily resolve the swappable dependency to\n279                         # prevent circular references. While keeping the\n280                         # dependency checks on the resolved model, add the\n281                         # swappable dependencies.\n282                         original_dep = dep\n283                         dep, is_swappable_dep = self._resolve_dependency(dep)\n284                         if dep[0] != app_label:\n285                             # External app dependency. See if it's not yet\n286                             # satisfied.\n287                             for other_operation in self.generated_operations.get(dep[0], []):\n288                                 if self.check_dependency(other_operation, dep):\n289                                     deps_satisfied = False\n290                                     break\n291                             if not deps_satisfied:\n292                                 break\n293                             else:\n294                                 if is_swappable_dep:\n295                                     operation_dependencies.add((original_dep[0], original_dep[1]))\n296                                 elif dep[0] in self.migrations:\n297                                     operation_dependencies.add((dep[0], self.migrations[dep[0]][-1].name))\n298                                 else:\n299                                     # If we can't find the other app, we add a first/last dependency,\n300                                     # but only if we've already been through once and checked everything\n301                                     if chop_mode:\n302                                         # If the app already exists, we add a dependency on the last migration,\n303                                         # as we don't know which migration contains the target field.\n304                                         # If it's not yet migrated or has no migrations, we use __first__\n305                                         if graph and graph.leaf_nodes(dep[0]):\n306                                             operation_dependencies.add(graph.leaf_nodes(dep[0])[0])\n307                                         else:\n308                                             operation_dependencies.add((dep[0], \"__first__\"))\n309                                     else:\n310                                         deps_satisfied = False\n311                     if deps_satisfied:\n312                         chopped.append(operation)\n313                         dependencies.update(operation_dependencies)\n314                         del self.generated_operations[app_label][0]\n315                     else:\n316                         break\n317                 # Make a migration! Well, only if there's stuff to put in it\n318                 if dependencies or chopped:\n319                     if not self.generated_operations[app_label] or chop_mode:\n320                         subclass = type(\"Migration\", (Migration,), {\"operations\": [], \"dependencies\": []})\n321                         instance = subclass(\"auto_%i\" % (len(self.migrations.get(app_label, [])) + 1), app_label)\n322                         instance.dependencies = list(dependencies)\n323                         instance.operations = chopped\n324                         instance.initial = app_label not in self.existing_apps\n325                         self.migrations.setdefault(app_label, []).append(instance)\n326                         chop_mode = False\n327                     else:\n328                         self.generated_operations[app_label] = chopped + self.generated_operations[app_label]\n329             new_num_ops = sum(len(x) for x in self.generated_operations.values())\n330             if new_num_ops == num_ops:\n331                 if not chop_mode:\n332                     chop_mode = True\n333                 else:\n334                     raise ValueError(\"Cannot resolve operation dependencies: %r\" % self.generated_operations)\n335             num_ops = new_num_ops\n336 \n337     def _sort_migrations(self):\n338         \"\"\"\n339         Reorder to make things possible. Reordering may be needed so FKs work\n340         nicely inside the same app.\n341         \"\"\"\n342         for app_label, ops in sorted(self.generated_operations.items()):\n343             # construct a dependency graph for intra-app dependencies\n344             dependency_graph = {op: set() for op in ops}\n345             for op in ops:\n346                 for dep in op._auto_deps:\n347                     # Resolve intra-app dependencies to handle circular\n348                     # references involving a swappable model.\n349                     dep = self._resolve_dependency(dep)[0]\n350                     if dep[0] == app_label:\n351                         for op2 in ops:\n352                             if self.check_dependency(op2, dep):\n353                                 dependency_graph[op].add(op2)\n354 \n355             # we use a stable sort for deterministic tests & general behavior\n356             self.generated_operations[app_label] = stable_topological_sort(ops, dependency_graph)\n357 \n358     def _optimize_migrations(self):\n359         # Add in internal dependencies among the migrations\n360         for app_label, migrations in self.migrations.items():\n361             for m1, m2 in zip(migrations, migrations[1:]):\n362                 m2.dependencies.append((app_label, m1.name))\n363 \n364         # De-dupe dependencies\n365         for migrations in self.migrations.values():\n366             for migration in migrations:\n367                 migration.dependencies = list(set(migration.dependencies))\n368 \n369         # Optimize migrations\n370         for app_label, migrations in self.migrations.items():\n371             for migration in migrations:\n372                 migration.operations = MigrationOptimizer().optimize(migration.operations, app_label)\n373 \n374     def check_dependency(self, operation, dependency):\n375         \"\"\"\n376         Return True if the given operation depends on the given dependency,\n377         False otherwise.\n378         \"\"\"\n379         # Created model\n380         if dependency[2] is None and dependency[3] is True:\n381             return (\n382                 isinstance(operation, operations.CreateModel) and\n383                 operation.name_lower == dependency[1].lower()\n384             )\n385         # Created field\n386         elif dependency[2] is not None and dependency[3] is True:\n387             return (\n388                 (\n389                     isinstance(operation, operations.CreateModel) and\n390                     operation.name_lower == dependency[1].lower() and\n391                     any(dependency[2] == x for x, y in operation.fields)\n392                 ) or\n393                 (\n394                     isinstance(operation, operations.AddField) and\n395                     operation.model_name_lower == dependency[1].lower() and\n396                     operation.name_lower == dependency[2].lower()\n397                 )\n398             )\n399         # Removed field\n400         elif dependency[2] is not None and dependency[3] is False:\n401             return (\n402                 isinstance(operation, operations.RemoveField) and\n403                 operation.model_name_lower == dependency[1].lower() and\n404                 operation.name_lower == dependency[2].lower()\n405             )\n406         # Removed model\n407         elif dependency[2] is None and dependency[3] is False:\n408             return (\n409                 isinstance(operation, operations.DeleteModel) and\n410                 operation.name_lower == dependency[1].lower()\n411             )\n412         # Field being altered\n413         elif dependency[2] is not None and dependency[3] == \"alter\":\n414             return (\n415                 isinstance(operation, operations.AlterField) and\n416                 operation.model_name_lower == dependency[1].lower() and\n417                 operation.name_lower == dependency[2].lower()\n418             )\n419         # order_with_respect_to being unset for a field\n420         elif dependency[2] is not None and dependency[3] == \"order_wrt_unset\":\n421             return (\n422                 isinstance(operation, operations.AlterOrderWithRespectTo) and\n423                 operation.name_lower == dependency[1].lower() and\n424                 (operation.order_with_respect_to or \"\").lower() != dependency[2].lower()\n425             )\n426         # Field is removed and part of an index/unique_together\n427         elif dependency[2] is not None and dependency[3] == \"foo_together_change\":\n428             return (\n429                 isinstance(operation, (operations.AlterUniqueTogether,\n430                                        operations.AlterIndexTogether)) and\n431                 operation.name_lower == dependency[1].lower()\n432             )\n433         # Unknown dependency. Raise an error.\n434         else:\n435             raise ValueError(\"Can't handle dependency %r\" % (dependency,))\n436 \n437     def add_operation(self, app_label, operation, dependencies=None, beginning=False):\n438         # Dependencies are (app_label, model_name, field_name, create/delete as True/False)\n439         operation._auto_deps = dependencies or []\n440         if beginning:\n441             self.generated_operations.setdefault(app_label, []).insert(0, operation)\n442         else:\n443             self.generated_operations.setdefault(app_label, []).append(operation)\n444 \n445     def swappable_first_key(self, item):\n446         \"\"\"\n447         Place potential swappable models first in lists of created models (only\n448         real way to solve #22783).\n449         \"\"\"\n450         try:\n451             model = self.new_apps.get_model(item[0], item[1])\n452             base_names = [base.__name__ for base in model.__bases__]\n453             string_version = \"%s.%s\" % (item[0], item[1])\n454             if (\n455                 model._meta.swappable or\n456                 \"AbstractUser\" in base_names or\n457                 \"AbstractBaseUser\" in base_names or\n458                 settings.AUTH_USER_MODEL.lower() == string_version.lower()\n459             ):\n460                 return (\"___\" + item[0], \"___\" + item[1])\n461         except LookupError:\n462             pass\n463         return item\n464 \n465     def generate_renamed_models(self):\n466         \"\"\"\n467         Find any renamed models, generate the operations for them, and remove\n468         the old entry from the model lists. Must be run before other\n469         model-level generation.\n470         \"\"\"\n471         self.renamed_models = {}\n472         self.renamed_models_rel = {}\n473         added_models = self.new_model_keys - self.old_model_keys\n474         for app_label, model_name in sorted(added_models):\n475             model_state = self.to_state.models[app_label, model_name]\n476             model_fields_def = self.only_relation_agnostic_fields(model_state.fields)\n477 \n478             removed_models = self.old_model_keys - self.new_model_keys\n479             for rem_app_label, rem_model_name in removed_models:\n480                 if rem_app_label == app_label:\n481                     rem_model_state = self.from_state.models[rem_app_label, rem_model_name]\n482                     rem_model_fields_def = self.only_relation_agnostic_fields(rem_model_state.fields)\n483                     if model_fields_def == rem_model_fields_def:\n484                         if self.questioner.ask_rename_model(rem_model_state, model_state):\n485                             model_opts = self.new_apps.get_model(app_label, model_name)._meta\n486                             dependencies = []\n487                             for field in model_opts.get_fields():\n488                                 if field.is_relation:\n489                                     dependencies.extend(self._get_dependencies_for_foreign_key(field))\n490                             self.add_operation(\n491                                 app_label,\n492                                 operations.RenameModel(\n493                                     old_name=rem_model_state.name,\n494                                     new_name=model_state.name,\n495                                 ),\n496                                 dependencies=dependencies,\n497                             )\n498                             self.renamed_models[app_label, model_name] = rem_model_name\n499                             renamed_models_rel_key = '%s.%s' % (\n500                                 rem_model_state.app_label,\n501                                 rem_model_state.name_lower,\n502                             )\n503                             self.renamed_models_rel[renamed_models_rel_key] = '%s.%s' % (\n504                                 model_state.app_label,\n505                                 model_state.name_lower,\n506                             )\n507                             self.old_model_keys.remove((rem_app_label, rem_model_name))\n508                             self.old_model_keys.add((app_label, model_name))\n509                             break\n510 \n511     def generate_created_models(self):\n512         \"\"\"\n513         Find all new models (both managed and unmanaged) and make create\n514         operations for them as well as separate operations to create any\n515         foreign key or M2M relationships (these are optimized later, if\n516         possible).\n517 \n518         Defer any model options that refer to collections of fields that might\n519         be deferred (e.g. unique_together, index_together).\n520         \"\"\"\n521         old_keys = self.old_model_keys | self.old_unmanaged_keys\n522         added_models = self.new_model_keys - old_keys\n523         added_unmanaged_models = self.new_unmanaged_keys - old_keys\n524         all_added_models = chain(\n525             sorted(added_models, key=self.swappable_first_key, reverse=True),\n526             sorted(added_unmanaged_models, key=self.swappable_first_key, reverse=True)\n527         )\n528         for app_label, model_name in all_added_models:\n529             model_state = self.to_state.models[app_label, model_name]\n530             model_opts = self.new_apps.get_model(app_label, model_name)._meta\n531             # Gather related fields\n532             related_fields = {}\n533             primary_key_rel = None\n534             for field in model_opts.local_fields:\n535                 if field.remote_field:\n536                     if field.remote_field.model:\n537                         if field.primary_key:\n538                             primary_key_rel = field.remote_field.model\n539                         elif not field.remote_field.parent_link:\n540                             related_fields[field.name] = field\n541                     # through will be none on M2Ms on swapped-out models;\n542                     # we can treat lack of through as auto_created=True, though.\n543                     if (getattr(field.remote_field, \"through\", None) and\n544                             not field.remote_field.through._meta.auto_created):\n545                         related_fields[field.name] = field\n546             for field in model_opts.local_many_to_many:\n547                 if field.remote_field.model:\n548                     related_fields[field.name] = field\n549                 if getattr(field.remote_field, \"through\", None) and not field.remote_field.through._meta.auto_created:\n550                     related_fields[field.name] = field\n551             # Are there indexes/unique|index_together to defer?\n552             indexes = model_state.options.pop('indexes')\n553             constraints = model_state.options.pop('constraints')\n554             unique_together = model_state.options.pop('unique_together', None)\n555             index_together = model_state.options.pop('index_together', None)\n556             order_with_respect_to = model_state.options.pop('order_with_respect_to', None)\n557             # Depend on the deletion of any possible proxy version of us\n558             dependencies = [\n559                 (app_label, model_name, None, False),\n560             ]\n561             # Depend on all bases\n562             for base in model_state.bases:\n563                 if isinstance(base, str) and \".\" in base:\n564                     base_app_label, base_name = base.split(\".\", 1)\n565                     dependencies.append((base_app_label, base_name, None, True))\n566             # Depend on the other end of the primary key if it's a relation\n567             if primary_key_rel:\n568                 dependencies.append((\n569                     primary_key_rel._meta.app_label,\n570                     primary_key_rel._meta.object_name,\n571                     None,\n572                     True\n573                 ))\n574             # Generate creation operation\n575             self.add_operation(\n576                 app_label,\n577                 operations.CreateModel(\n578                     name=model_state.name,\n579                     fields=[d for d in model_state.fields if d[0] not in related_fields],\n580                     options=model_state.options,\n581                     bases=model_state.bases,\n582                     managers=model_state.managers,\n583                 ),\n584                 dependencies=dependencies,\n585                 beginning=True,\n586             )\n587 \n588             # Don't add operations which modify the database for unmanaged models\n589             if not model_opts.managed:\n590                 continue\n591 \n592             # Generate operations for each related field\n593             for name, field in sorted(related_fields.items()):\n594                 dependencies = self._get_dependencies_for_foreign_key(field)\n595                 # Depend on our own model being created\n596                 dependencies.append((app_label, model_name, None, True))\n597                 # Make operation\n598                 self.add_operation(\n599                     app_label,\n600                     operations.AddField(\n601                         model_name=model_name,\n602                         name=name,\n603                         field=field,\n604                     ),\n605                     dependencies=list(set(dependencies)),\n606                 )\n607             # Generate other opns\n608             related_dependencies = [\n609                 (app_label, model_name, name, True)\n610                 for name in sorted(related_fields)\n611             ]\n612             related_dependencies.append((app_label, model_name, None, True))\n613             for index in indexes:\n614                 self.add_operation(\n615                     app_label,\n616                     operations.AddIndex(\n617                         model_name=model_name,\n618                         index=index,\n619                     ),\n620                     dependencies=related_dependencies,\n621                 )\n622             for constraint in constraints:\n623                 self.add_operation(\n624                     app_label,\n625                     operations.AddConstraint(\n626                         model_name=model_name,\n627                         constraint=constraint,\n628                     ),\n629                     dependencies=related_dependencies,\n630                 )\n631             if unique_together:\n632                 self.add_operation(\n633                     app_label,\n634                     operations.AlterUniqueTogether(\n635                         name=model_name,\n636                         unique_together=unique_together,\n637                     ),\n638                     dependencies=related_dependencies\n639                 )\n640             if index_together:\n641                 self.add_operation(\n642                     app_label,\n643                     operations.AlterIndexTogether(\n644                         name=model_name,\n645                         index_together=index_together,\n646                     ),\n647                     dependencies=related_dependencies\n648                 )\n649             if order_with_respect_to:\n650                 self.add_operation(\n651                     app_label,\n652                     operations.AlterOrderWithRespectTo(\n653                         name=model_name,\n654                         order_with_respect_to=order_with_respect_to,\n655                     ),\n656                     dependencies=[\n657                         (app_label, model_name, order_with_respect_to, True),\n658                         (app_label, model_name, None, True),\n659                     ]\n660                 )\n661 \n662             # Fix relationships if the model changed from a proxy model to a\n663             # concrete model.\n664             if (app_label, model_name) in self.old_proxy_keys:\n665                 for related_object in model_opts.related_objects:\n666                     self.add_operation(\n667                         related_object.related_model._meta.app_label,\n668                         operations.AlterField(\n669                             model_name=related_object.related_model._meta.object_name,\n670                             name=related_object.field.name,\n671                             field=related_object.field,\n672                         ),\n673                         dependencies=[(app_label, model_name, None, True)],\n674                     )\n675 \n676     def generate_created_proxies(self):\n677         \"\"\"\n678         Make CreateModel statements for proxy models. Use the same statements\n679         as that way there's less code duplication, but of course for proxy\n680         models it's safe to skip all the pointless field stuff and just chuck\n681         out an operation.\n682         \"\"\"\n683         added = self.new_proxy_keys - self.old_proxy_keys\n684         for app_label, model_name in sorted(added):\n685             model_state = self.to_state.models[app_label, model_name]\n686             assert model_state.options.get(\"proxy\")\n687             # Depend on the deletion of any possible non-proxy version of us\n688             dependencies = [\n689                 (app_label, model_name, None, False),\n690             ]\n691             # Depend on all bases\n692             for base in model_state.bases:\n693                 if isinstance(base, str) and \".\" in base:\n694                     base_app_label, base_name = base.split(\".\", 1)\n695                     dependencies.append((base_app_label, base_name, None, True))\n696             # Generate creation operation\n697             self.add_operation(\n698                 app_label,\n699                 operations.CreateModel(\n700                     name=model_state.name,\n701                     fields=[],\n702                     options=model_state.options,\n703                     bases=model_state.bases,\n704                     managers=model_state.managers,\n705                 ),\n706                 # Depend on the deletion of any possible non-proxy version of us\n707                 dependencies=dependencies,\n708             )\n709 \n710     def generate_deleted_models(self):\n711         \"\"\"\n712         Find all deleted models (managed and unmanaged) and make delete\n713         operations for them as well as separate operations to delete any\n714         foreign key or M2M relationships (these are optimized later, if\n715         possible).\n716 \n717         Also bring forward removal of any model options that refer to\n718         collections of fields - the inverse of generate_created_models().\n719         \"\"\"\n720         new_keys = self.new_model_keys | self.new_unmanaged_keys\n721         deleted_models = self.old_model_keys - new_keys\n722         deleted_unmanaged_models = self.old_unmanaged_keys - new_keys\n723         all_deleted_models = chain(sorted(deleted_models), sorted(deleted_unmanaged_models))\n724         for app_label, model_name in all_deleted_models:\n725             model_state = self.from_state.models[app_label, model_name]\n726             model = self.old_apps.get_model(app_label, model_name)\n727             # Gather related fields\n728             related_fields = {}\n729             for field in model._meta.local_fields:\n730                 if field.remote_field:\n731                     if field.remote_field.model:\n732                         related_fields[field.name] = field\n733                     # through will be none on M2Ms on swapped-out models;\n734                     # we can treat lack of through as auto_created=True, though.\n735                     if (getattr(field.remote_field, \"through\", None) and\n736                             not field.remote_field.through._meta.auto_created):\n737                         related_fields[field.name] = field\n738             for field in model._meta.local_many_to_many:\n739                 if field.remote_field.model:\n740                     related_fields[field.name] = field\n741                 if getattr(field.remote_field, \"through\", None) and not field.remote_field.through._meta.auto_created:\n742                     related_fields[field.name] = field\n743             # Generate option removal first\n744             unique_together = model_state.options.pop('unique_together', None)\n745             index_together = model_state.options.pop('index_together', None)\n746             if unique_together:\n747                 self.add_operation(\n748                     app_label,\n749                     operations.AlterUniqueTogether(\n750                         name=model_name,\n751                         unique_together=None,\n752                     )\n753                 )\n754             if index_together:\n755                 self.add_operation(\n756                     app_label,\n757                     operations.AlterIndexTogether(\n758                         name=model_name,\n759                         index_together=None,\n760                     )\n761                 )\n762             # Then remove each related field\n763             for name in sorted(related_fields):\n764                 self.add_operation(\n765                     app_label,\n766                     operations.RemoveField(\n767                         model_name=model_name,\n768                         name=name,\n769                     )\n770                 )\n771             # Finally, remove the model.\n772             # This depends on both the removal/alteration of all incoming fields\n773             # and the removal of all its own related fields, and if it's\n774             # a through model the field that references it.\n775             dependencies = []\n776             for related_object in model._meta.related_objects:\n777                 related_object_app_label = related_object.related_model._meta.app_label\n778                 object_name = related_object.related_model._meta.object_name\n779                 field_name = related_object.field.name\n780                 dependencies.append((related_object_app_label, object_name, field_name, False))\n781                 if not related_object.many_to_many:\n782                     dependencies.append((related_object_app_label, object_name, field_name, \"alter\"))\n783 \n784             for name in sorted(related_fields):\n785                 dependencies.append((app_label, model_name, name, False))\n786             # We're referenced in another field's through=\n787             through_user = self.through_users.get((app_label, model_state.name_lower))\n788             if through_user:\n789                 dependencies.append((through_user[0], through_user[1], through_user[2], False))\n790             # Finally, make the operation, deduping any dependencies\n791             self.add_operation(\n792                 app_label,\n793                 operations.DeleteModel(\n794                     name=model_state.name,\n795                 ),\n796                 dependencies=list(set(dependencies)),\n797             )\n798 \n799     def generate_deleted_proxies(self):\n800         \"\"\"Make DeleteModel options for proxy models.\"\"\"\n801         deleted = self.old_proxy_keys - self.new_proxy_keys\n802         for app_label, model_name in sorted(deleted):\n803             model_state = self.from_state.models[app_label, model_name]\n804             assert model_state.options.get(\"proxy\")\n805             self.add_operation(\n806                 app_label,\n807                 operations.DeleteModel(\n808                     name=model_state.name,\n809                 ),\n810             )\n811 \n812     def generate_renamed_fields(self):\n813         \"\"\"Work out renamed fields.\"\"\"\n814         self.renamed_fields = {}\n815         for app_label, model_name, field_name in sorted(self.new_field_keys - self.old_field_keys):\n816             old_model_name = self.renamed_models.get((app_label, model_name), model_name)\n817             old_model_state = self.from_state.models[app_label, old_model_name]\n818             field = self.new_apps.get_model(app_label, model_name)._meta.get_field(field_name)\n819             # Scan to see if this is actually a rename!\n820             field_dec = self.deep_deconstruct(field)\n821             for rem_app_label, rem_model_name, rem_field_name in sorted(self.old_field_keys - self.new_field_keys):\n822                 if rem_app_label == app_label and rem_model_name == model_name:\n823                     old_field = old_model_state.get_field_by_name(rem_field_name)\n824                     old_field_dec = self.deep_deconstruct(old_field)\n825                     if field.remote_field and field.remote_field.model and 'to' in old_field_dec[2]:\n826                         old_rel_to = old_field_dec[2]['to']\n827                         if old_rel_to in self.renamed_models_rel:\n828                             old_field_dec[2]['to'] = self.renamed_models_rel[old_rel_to]\n829                     old_field.set_attributes_from_name(rem_field_name)\n830                     old_db_column = old_field.get_attname_column()[1]\n831                     if (old_field_dec == field_dec or (\n832                             # Was the field renamed and db_column equal to the\n833                             # old field's column added?\n834                             old_field_dec[0:2] == field_dec[0:2] and\n835                             dict(old_field_dec[2], db_column=old_db_column) == field_dec[2])):\n836                         if self.questioner.ask_rename(model_name, rem_field_name, field_name, field):\n837                             self.add_operation(\n838                                 app_label,\n839                                 operations.RenameField(\n840                                     model_name=model_name,\n841                                     old_name=rem_field_name,\n842                                     new_name=field_name,\n843                                 )\n844                             )\n845                             self.old_field_keys.remove((rem_app_label, rem_model_name, rem_field_name))\n846                             self.old_field_keys.add((app_label, model_name, field_name))\n847                             self.renamed_fields[app_label, model_name, field_name] = rem_field_name\n848                             break\n849 \n850     def generate_added_fields(self):\n851         \"\"\"Make AddField operations.\"\"\"\n852         for app_label, model_name, field_name in sorted(self.new_field_keys - self.old_field_keys):\n853             self._generate_added_field(app_label, model_name, field_name)\n854 \n855     def _generate_added_field(self, app_label, model_name, field_name):\n856         field = self.new_apps.get_model(app_label, model_name)._meta.get_field(field_name)\n857         # Fields that are foreignkeys/m2ms depend on stuff\n858         dependencies = []\n859         if field.remote_field and field.remote_field.model:\n860             dependencies.extend(self._get_dependencies_for_foreign_key(field))\n861         # You can't just add NOT NULL fields with no default or fields\n862         # which don't allow empty strings as default.\n863         time_fields = (models.DateField, models.DateTimeField, models.TimeField)\n864         preserve_default = (\n865             field.null or field.has_default() or field.many_to_many or\n866             (field.blank and field.empty_strings_allowed) or\n867             (isinstance(field, time_fields) and field.auto_now)\n868         )\n869         if not preserve_default:\n870             field = field.clone()\n871             if isinstance(field, time_fields) and field.auto_now_add:\n872                 field.default = self.questioner.ask_auto_now_add_addition(field_name, model_name)\n873             else:\n874                 field.default = self.questioner.ask_not_null_addition(field_name, model_name)\n875         self.add_operation(\n876             app_label,\n877             operations.AddField(\n878                 model_name=model_name,\n879                 name=field_name,\n880                 field=field,\n881                 preserve_default=preserve_default,\n882             ),\n883             dependencies=dependencies,\n884         )\n885 \n886     def generate_removed_fields(self):\n887         \"\"\"Make RemoveField operations.\"\"\"\n888         for app_label, model_name, field_name in sorted(self.old_field_keys - self.new_field_keys):\n889             self._generate_removed_field(app_label, model_name, field_name)\n890 \n891     def _generate_removed_field(self, app_label, model_name, field_name):\n892         self.add_operation(\n893             app_label,\n894             operations.RemoveField(\n895                 model_name=model_name,\n896                 name=field_name,\n897             ),\n898             # We might need to depend on the removal of an\n899             # order_with_respect_to or index/unique_together operation;\n900             # this is safely ignored if there isn't one\n901             dependencies=[\n902                 (app_label, model_name, field_name, \"order_wrt_unset\"),\n903                 (app_label, model_name, field_name, \"foo_together_change\"),\n904             ],\n905         )\n906 \n907     def generate_altered_fields(self):\n908         \"\"\"\n909         Make AlterField operations, or possibly RemovedField/AddField if alter\n910         isn's possible.\n911         \"\"\"\n912         for app_label, model_name, field_name in sorted(self.old_field_keys & self.new_field_keys):\n913             # Did the field change?\n914             old_model_name = self.renamed_models.get((app_label, model_name), model_name)\n915             old_field_name = self.renamed_fields.get((app_label, model_name, field_name), field_name)\n916             old_field = self.old_apps.get_model(app_label, old_model_name)._meta.get_field(old_field_name)\n917             new_field = self.new_apps.get_model(app_label, model_name)._meta.get_field(field_name)\n918             dependencies = []\n919             # Implement any model renames on relations; these are handled by RenameModel\n920             # so we need to exclude them from the comparison\n921             if hasattr(new_field, \"remote_field\") and getattr(new_field.remote_field, \"model\", None):\n922                 rename_key = (\n923                     new_field.remote_field.model._meta.app_label,\n924                     new_field.remote_field.model._meta.model_name,\n925                 )\n926                 if rename_key in self.renamed_models:\n927                     new_field.remote_field.model = old_field.remote_field.model\n928                 # Handle ForeignKey which can only have a single to_field.\n929                 remote_field_name = getattr(new_field.remote_field, 'field_name', None)\n930                 if remote_field_name:\n931                     to_field_rename_key = rename_key + (remote_field_name,)\n932                     if to_field_rename_key in self.renamed_fields:\n933                         # Repoint both model and field name because to_field\n934                         # inclusion in ForeignKey.deconstruct() is based on\n935                         # both.\n936                         new_field.remote_field.model = old_field.remote_field.model\n937                         new_field.remote_field.field_name = old_field.remote_field.field_name\n938                 # Handle ForeignObjects which can have multiple from_fields/to_fields.\n939                 from_fields = getattr(new_field, 'from_fields', None)\n940                 if from_fields:\n941                     from_rename_key = (app_label, model_name)\n942                     new_field.from_fields = tuple([\n943                         self.renamed_fields.get(from_rename_key + (from_field,), from_field)\n944                         for from_field in from_fields\n945                     ])\n946                     new_field.to_fields = tuple([\n947                         self.renamed_fields.get(rename_key + (to_field,), to_field)\n948                         for to_field in new_field.to_fields\n949                     ])\n950                 dependencies.extend(self._get_dependencies_for_foreign_key(new_field))\n951             if hasattr(new_field, \"remote_field\") and getattr(new_field.remote_field, \"through\", None):\n952                 rename_key = (\n953                     new_field.remote_field.through._meta.app_label,\n954                     new_field.remote_field.through._meta.model_name,\n955                 )\n956                 if rename_key in self.renamed_models:\n957                     new_field.remote_field.through = old_field.remote_field.through\n958             old_field_dec = self.deep_deconstruct(old_field)\n959             new_field_dec = self.deep_deconstruct(new_field)\n960             if old_field_dec != new_field_dec:\n961                 both_m2m = old_field.many_to_many and new_field.many_to_many\n962                 neither_m2m = not old_field.many_to_many and not new_field.many_to_many\n963                 if both_m2m or neither_m2m:\n964                     # Either both fields are m2m or neither is\n965                     preserve_default = True\n966                     if (old_field.null and not new_field.null and not new_field.has_default() and\n967                             not new_field.many_to_many):\n968                         field = new_field.clone()\n969                         new_default = self.questioner.ask_not_null_alteration(field_name, model_name)\n970                         if new_default is not models.NOT_PROVIDED:\n971                             field.default = new_default\n972                             preserve_default = False\n973                     else:\n974                         field = new_field\n975                     self.add_operation(\n976                         app_label,\n977                         operations.AlterField(\n978                             model_name=model_name,\n979                             name=field_name,\n980                             field=field,\n981                             preserve_default=preserve_default,\n982                         ),\n983                         dependencies=dependencies,\n984                     )\n985                 else:\n986                     # We cannot alter between m2m and concrete fields\n987                     self._generate_removed_field(app_label, model_name, field_name)\n988                     self._generate_added_field(app_label, model_name, field_name)\n989 \n990     def create_altered_indexes(self):\n991         option_name = operations.AddIndex.option_name\n992         for app_label, model_name in sorted(self.kept_model_keys):\n993             old_model_name = self.renamed_models.get((app_label, model_name), model_name)\n994             old_model_state = self.from_state.models[app_label, old_model_name]\n995             new_model_state = self.to_state.models[app_label, model_name]\n996 \n997             old_indexes = old_model_state.options[option_name]\n998             new_indexes = new_model_state.options[option_name]\n999             add_idx = [idx for idx in new_indexes if idx not in old_indexes]\n1000             rem_idx = [idx for idx in old_indexes if idx not in new_indexes]\n1001 \n1002             self.altered_indexes.update({\n1003                 (app_label, model_name): {\n1004                     'added_indexes': add_idx, 'removed_indexes': rem_idx,\n1005                 }\n1006             })\n1007 \n1008     def generate_added_indexes(self):\n1009         for (app_label, model_name), alt_indexes in self.altered_indexes.items():\n1010             for index in alt_indexes['added_indexes']:\n1011                 self.add_operation(\n1012                     app_label,\n1013                     operations.AddIndex(\n1014                         model_name=model_name,\n1015                         index=index,\n1016                     )\n1017                 )\n1018 \n1019     def generate_removed_indexes(self):\n1020         for (app_label, model_name), alt_indexes in self.altered_indexes.items():\n1021             for index in alt_indexes['removed_indexes']:\n1022                 self.add_operation(\n1023                     app_label,\n1024                     operations.RemoveIndex(\n1025                         model_name=model_name,\n1026                         name=index.name,\n1027                     )\n1028                 )\n1029 \n1030     def create_altered_constraints(self):\n1031         option_name = operations.AddConstraint.option_name\n1032         for app_label, model_name in sorted(self.kept_model_keys):\n1033             old_model_name = self.renamed_models.get((app_label, model_name), model_name)\n1034             old_model_state = self.from_state.models[app_label, old_model_name]\n1035             new_model_state = self.to_state.models[app_label, model_name]\n1036 \n1037             old_constraints = old_model_state.options[option_name]\n1038             new_constraints = new_model_state.options[option_name]\n1039             add_constraints = [c for c in new_constraints if c not in old_constraints]\n1040             rem_constraints = [c for c in old_constraints if c not in new_constraints]\n1041 \n1042             self.altered_constraints.update({\n1043                 (app_label, model_name): {\n1044                     'added_constraints': add_constraints, 'removed_constraints': rem_constraints,\n1045                 }\n1046             })\n1047 \n1048     def generate_added_constraints(self):\n1049         for (app_label, model_name), alt_constraints in self.altered_constraints.items():\n1050             for constraint in alt_constraints['added_constraints']:\n1051                 self.add_operation(\n1052                     app_label,\n1053                     operations.AddConstraint(\n1054                         model_name=model_name,\n1055                         constraint=constraint,\n1056                     )\n1057                 )\n1058 \n1059     def generate_removed_constraints(self):\n1060         for (app_label, model_name), alt_constraints in self.altered_constraints.items():\n1061             for constraint in alt_constraints['removed_constraints']:\n1062                 self.add_operation(\n1063                     app_label,\n1064                     operations.RemoveConstraint(\n1065                         model_name=model_name,\n1066                         name=constraint.name,\n1067                     )\n1068                 )\n1069 \n1070     def _get_dependencies_for_foreign_key(self, field):\n1071         # Account for FKs to swappable models\n1072         swappable_setting = getattr(field, 'swappable_setting', None)\n1073         if swappable_setting is not None:\n1074             dep_app_label = \"__setting__\"\n1075             dep_object_name = swappable_setting\n1076         else:\n1077             dep_app_label = field.remote_field.model._meta.app_label\n1078             dep_object_name = field.remote_field.model._meta.object_name\n1079         dependencies = [(dep_app_label, dep_object_name, None, True)]\n1080         if getattr(field.remote_field, \"through\", None) and not field.remote_field.through._meta.auto_created:\n1081             dependencies.append((\n1082                 field.remote_field.through._meta.app_label,\n1083                 field.remote_field.through._meta.object_name,\n1084                 None,\n1085                 True,\n1086             ))\n1087         return dependencies\n1088 \n1089     def _generate_altered_foo_together(self, operation):\n1090         option_name = operation.option_name\n1091         for app_label, model_name in sorted(self.kept_model_keys):\n1092             old_model_name = self.renamed_models.get((app_label, model_name), model_name)\n1093             old_model_state = self.from_state.models[app_label, old_model_name]\n1094             new_model_state = self.to_state.models[app_label, model_name]\n1095 \n1096             # We run the old version through the field renames to account for those\n1097             old_value = old_model_state.options.get(option_name)\n1098             old_value = {\n1099                 tuple(\n1100                     self.renamed_fields.get((app_label, model_name, n), n)\n1101                     for n in unique\n1102                 )\n1103                 for unique in old_value\n1104             } if old_value else set()\n1105 \n1106             new_value = new_model_state.options.get(option_name)\n1107             new_value = set(new_value) if new_value else set()\n1108 \n1109             if old_value != new_value:\n1110                 dependencies = []\n1111                 for foo_togethers in new_value:\n1112                     for field_name in foo_togethers:\n1113                         field = self.new_apps.get_model(app_label, model_name)._meta.get_field(field_name)\n1114                         if field.remote_field and field.remote_field.model:\n1115                             dependencies.extend(self._get_dependencies_for_foreign_key(field))\n1116 \n1117                 self.add_operation(\n1118                     app_label,\n1119                     operation(\n1120                         name=model_name,\n1121                         **{option_name: new_value}\n1122                     ),\n1123                     dependencies=dependencies,\n1124                 )\n1125 \n1126     def generate_altered_unique_together(self):\n1127         self._generate_altered_foo_together(operations.AlterUniqueTogether)\n1128 \n1129     def generate_altered_index_together(self):\n1130         self._generate_altered_foo_together(operations.AlterIndexTogether)\n1131 \n1132     def generate_altered_db_table(self):\n1133         models_to_check = self.kept_model_keys.union(self.kept_proxy_keys, self.kept_unmanaged_keys)\n1134         for app_label, model_name in sorted(models_to_check):\n1135             old_model_name = self.renamed_models.get((app_label, model_name), model_name)\n1136             old_model_state = self.from_state.models[app_label, old_model_name]\n1137             new_model_state = self.to_state.models[app_label, model_name]\n1138             old_db_table_name = old_model_state.options.get('db_table')\n1139             new_db_table_name = new_model_state.options.get('db_table')\n1140             if old_db_table_name != new_db_table_name:\n1141                 self.add_operation(\n1142                     app_label,\n1143                     operations.AlterModelTable(\n1144                         name=model_name,\n1145                         table=new_db_table_name,\n1146                     )\n1147                 )\n1148 \n1149     def generate_altered_options(self):\n1150         \"\"\"\n1151         Work out if any non-schema-affecting options have changed and make an\n1152         operation to represent them in state changes (in case Python code in\n1153         migrations needs them).\n1154         \"\"\"\n1155         models_to_check = self.kept_model_keys.union(\n1156             self.kept_proxy_keys,\n1157             self.kept_unmanaged_keys,\n1158             # unmanaged converted to managed\n1159             self.old_unmanaged_keys & self.new_model_keys,\n1160             # managed converted to unmanaged\n1161             self.old_model_keys & self.new_unmanaged_keys,\n1162         )\n1163 \n1164         for app_label, model_name in sorted(models_to_check):\n1165             old_model_name = self.renamed_models.get((app_label, model_name), model_name)\n1166             old_model_state = self.from_state.models[app_label, old_model_name]\n1167             new_model_state = self.to_state.models[app_label, model_name]\n1168             old_options = {\n1169                 key: value for key, value in old_model_state.options.items()\n1170                 if key in AlterModelOptions.ALTER_OPTION_KEYS\n1171             }\n1172             new_options = {\n1173                 key: value for key, value in new_model_state.options.items()\n1174                 if key in AlterModelOptions.ALTER_OPTION_KEYS\n1175             }\n1176             if old_options != new_options:\n1177                 self.add_operation(\n1178                     app_label,\n1179                     operations.AlterModelOptions(\n1180                         name=model_name,\n1181                         options=new_options,\n1182                     )\n1183                 )\n1184 \n1185     def generate_altered_order_with_respect_to(self):\n1186         for app_label, model_name in sorted(self.kept_model_keys):\n1187             old_model_name = self.renamed_models.get((app_label, model_name), model_name)\n1188             old_model_state = self.from_state.models[app_label, old_model_name]\n1189             new_model_state = self.to_state.models[app_label, model_name]\n1190             if (old_model_state.options.get(\"order_with_respect_to\") !=\n1191                     new_model_state.options.get(\"order_with_respect_to\")):\n1192                 # Make sure it comes second if we're adding\n1193                 # (removal dependency is part of RemoveField)\n1194                 dependencies = []\n1195                 if new_model_state.options.get(\"order_with_respect_to\"):\n1196                     dependencies.append((\n1197                         app_label,\n1198                         model_name,\n1199                         new_model_state.options[\"order_with_respect_to\"],\n1200                         True,\n1201                     ))\n1202                 # Actually generate the operation\n1203                 self.add_operation(\n1204                     app_label,\n1205                     operations.AlterOrderWithRespectTo(\n1206                         name=model_name,\n1207                         order_with_respect_to=new_model_state.options.get('order_with_respect_to'),\n1208                     ),\n1209                     dependencies=dependencies,\n1210                 )\n1211 \n1212     def generate_altered_managers(self):\n1213         for app_label, model_name in sorted(self.kept_model_keys):\n1214             old_model_name = self.renamed_models.get((app_label, model_name), model_name)\n1215             old_model_state = self.from_state.models[app_label, old_model_name]\n1216             new_model_state = self.to_state.models[app_label, model_name]\n1217             if old_model_state.managers != new_model_state.managers:\n1218                 self.add_operation(\n1219                     app_label,\n1220                     operations.AlterModelManagers(\n1221                         name=model_name,\n1222                         managers=new_model_state.managers,\n1223                     )\n1224                 )\n1225 \n1226     def arrange_for_graph(self, changes, graph, migration_name=None):\n1227         \"\"\"\n1228         Take a result from changes() and a MigrationGraph, and fix the names\n1229         and dependencies of the changes so they extend the graph from the leaf\n1230         nodes for each app.\n1231         \"\"\"\n1232         leaves = graph.leaf_nodes()\n1233         name_map = {}\n1234         for app_label, migrations in list(changes.items()):\n1235             if not migrations:\n1236                 continue\n1237             # Find the app label's current leaf node\n1238             app_leaf = None\n1239             for leaf in leaves:\n1240                 if leaf[0] == app_label:\n1241                     app_leaf = leaf\n1242                     break\n1243             # Do they want an initial migration for this app?\n1244             if app_leaf is None and not self.questioner.ask_initial(app_label):\n1245                 # They don't.\n1246                 for migration in migrations:\n1247                     name_map[(app_label, migration.name)] = (app_label, \"__first__\")\n1248                 del changes[app_label]\n1249                 continue\n1250             # Work out the next number in the sequence\n1251             if app_leaf is None:\n1252                 next_number = 1\n1253             else:\n1254                 next_number = (self.parse_number(app_leaf[1]) or 0) + 1\n1255             # Name each migration\n1256             for i, migration in enumerate(migrations):\n1257                 if i == 0 and app_leaf:\n1258                     migration.dependencies.append(app_leaf)\n1259                 if i == 0 and not app_leaf:\n1260                     new_name = \"0001_%s\" % migration_name if migration_name else \"0001_initial\"\n1261                 else:\n1262                     new_name = \"%04i_%s\" % (\n1263                         next_number,\n1264                         migration_name or self.suggest_name(migration.operations)[:100],\n1265                     )\n1266                 name_map[(app_label, migration.name)] = (app_label, new_name)\n1267                 next_number += 1\n1268                 migration.name = new_name\n1269         # Now fix dependencies\n1270         for migrations in changes.values():\n1271             for migration in migrations:\n1272                 migration.dependencies = [name_map.get(d, d) for d in migration.dependencies]\n1273         return changes\n1274 \n1275     def _trim_to_apps(self, changes, app_labels):\n1276         \"\"\"\n1277         Take changes from arrange_for_graph() and set of app labels, and return\n1278         a modified set of changes which trims out as many migrations that are\n1279         not in app_labels as possible. Note that some other migrations may\n1280         still be present as they may be required dependencies.\n1281         \"\"\"\n1282         # Gather other app dependencies in a first pass\n1283         app_dependencies = {}\n1284         for app_label, migrations in changes.items():\n1285             for migration in migrations:\n1286                 for dep_app_label, name in migration.dependencies:\n1287                     app_dependencies.setdefault(app_label, set()).add(dep_app_label)\n1288         required_apps = set(app_labels)\n1289         # Keep resolving till there's no change\n1290         old_required_apps = None\n1291         while old_required_apps != required_apps:\n1292             old_required_apps = set(required_apps)\n1293             required_apps.update(*[app_dependencies.get(app_label, ()) for app_label in required_apps])\n1294         # Remove all migrations that aren't needed\n1295         for app_label in list(changes):\n1296             if app_label not in required_apps:\n1297                 del changes[app_label]\n1298         return changes\n1299 \n1300     @classmethod\n1301     def suggest_name(cls, ops):\n1302         \"\"\"\n1303         Given a set of operations, suggest a name for the migration they might\n1304         represent. Names are not guaranteed to be unique, but put some effort\n1305         into the fallback name to avoid VCS conflicts if possible.\n1306         \"\"\"\n1307         if len(ops) == 1:\n1308             if isinstance(ops[0], operations.CreateModel):\n1309                 return ops[0].name_lower\n1310             elif isinstance(ops[0], operations.DeleteModel):\n1311                 return \"delete_%s\" % ops[0].name_lower\n1312             elif isinstance(ops[0], operations.AddField):\n1313                 return \"%s_%s\" % (ops[0].model_name_lower, ops[0].name_lower)\n1314             elif isinstance(ops[0], operations.RemoveField):\n1315                 return \"remove_%s_%s\" % (ops[0].model_name_lower, ops[0].name_lower)\n1316         elif ops:\n1317             if all(isinstance(o, operations.CreateModel) for o in ops):\n1318                 return \"_\".join(sorted(o.name_lower for o in ops))\n1319         return \"auto_%s\" % get_migration_name_timestamp()\n1320 \n1321     @classmethod\n1322     def parse_number(cls, name):\n1323         \"\"\"\n1324         Given a migration name, try to extract a number from the beginning of\n1325         it. If no number is found, return None.\n1326         \"\"\"\n1327         match = re.match(r'^\\d+', name)\n1328         if match:\n1329             return int(match.group())\n1330         return None\n",
        "intended_behavior": "Ensure the migration autodetector is capable of detecting changes in fields of a model and the implications on related fields, specifically in ManyToManyField relationships, possibly altering related database table schemas."
    }
]