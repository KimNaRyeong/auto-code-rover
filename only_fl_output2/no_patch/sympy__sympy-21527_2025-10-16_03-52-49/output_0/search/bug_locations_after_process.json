[
    {
        "rel_file_path": "sympy/solvers/solveset.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sympy__sympy/setup_sympy__sympy__1.9/sympy/solvers/solveset.py",
        "start": 2586,
        "end": 2837,
        "class_name": null,
        "method_name": "linsolve",
        "code": "2586 def linsolve(system, *symbols):\n2587     r\"\"\"\n2588     Solve system of N linear equations with M variables; both\n2589     underdetermined and overdetermined systems are supported.\n2590     The possible number of solutions is zero, one or infinite.\n2591     Zero solutions throws a ValueError, whereas infinite\n2592     solutions are represented parametrically in terms of the given\n2593     symbols. For unique solution a FiniteSet of ordered tuples\n2594     is returned.\n2595 \n2596     All Standard input formats are supported:\n2597     For the given set of Equations, the respective input types\n2598     are given below:\n2599 \n2600     .. math:: 3x + 2y -   z = 1\n2601     .. math:: 2x - 2y + 4z = -2\n2602     .. math:: 2x -   y + 2z = 0\n2603 \n2604     * Augmented Matrix Form, `system` given below:\n2605 \n2606     ::\n2607 \n2608               [3   2  -1  1]\n2609      system = [2  -2   4 -2]\n2610               [2  -1   2  0]\n2611 \n2612     * List Of Equations Form\n2613 \n2614     `system  =  [3x + 2y - z - 1, 2x - 2y + 4z + 2, 2x - y + 2z]`\n2615 \n2616     * Input A & b Matrix Form (from Ax = b) are given as below:\n2617 \n2618     ::\n2619 \n2620          [3   2  -1 ]         [  1 ]\n2621      A = [2  -2   4 ]    b =  [ -2 ]\n2622          [2  -1   2 ]         [  0 ]\n2623 \n2624     `system = (A, b)`\n2625 \n2626     Symbols can always be passed but are actually only needed\n2627     when 1) a system of equations is being passed and 2) the\n2628     system is passed as an underdetermined matrix and one wants\n2629     to control the name of the free variables in the result.\n2630     An error is raised if no symbols are used for case 1, but if\n2631     no symbols are provided for case 2, internally generated symbols\n2632     will be provided. When providing symbols for case 2, there should\n2633     be at least as many symbols are there are columns in matrix A.\n2634 \n2635     The algorithm used here is Gauss-Jordan elimination, which\n2636     results, after elimination, in a row echelon form matrix.\n2637 \n2638     Returns\n2639     =======\n2640 \n2641     A FiniteSet containing an ordered tuple of values for the\n2642     unknowns for which the `system` has a solution. (Wrapping\n2643     the tuple in FiniteSet is used to maintain a consistent\n2644     output format throughout solveset.)\n2645 \n2646     Returns EmptySet, if the linear system is inconsistent.\n2647 \n2648     Raises\n2649     ======\n2650 \n2651     ValueError\n2652         The input is not valid.\n2653         The symbols are not given.\n2654 \n2655     Examples\n2656     ========\n2657 \n2658     >>> from sympy import Matrix, linsolve, symbols\n2659     >>> x, y, z = symbols(\"x, y, z\")\n2660     >>> A = Matrix([[1, 2, 3], [4, 5, 6], [7, 8, 10]])\n2661     >>> b = Matrix([3, 6, 9])\n2662     >>> A\n2663     Matrix([\n2664     [1, 2,  3],\n2665     [4, 5,  6],\n2666     [7, 8, 10]])\n2667     >>> b\n2668     Matrix([\n2669     [3],\n2670     [6],\n2671     [9]])\n2672     >>> linsolve((A, b), [x, y, z])\n2673     FiniteSet((-1, 2, 0))\n2674 \n2675     * Parametric Solution: In case the system is underdetermined, the\n2676       function will return a parametric solution in terms of the given\n2677       symbols. Those that are free will be returned unchanged. e.g. in\n2678       the system below, `z` is returned as the solution for variable z;\n2679       it can take on any value.\n2680 \n2681     >>> A = Matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n2682     >>> b = Matrix([3, 6, 9])\n2683     >>> linsolve((A, b), x, y, z)\n2684     FiniteSet((z - 1, 2 - 2*z, z))\n2685 \n2686     If no symbols are given, internally generated symbols will be used.\n2687     The `tau0` in the 3rd position indicates (as before) that the 3rd\n2688     variable -- whatever it's named -- can take on any value:\n2689 \n2690     >>> linsolve((A, b))\n2691     FiniteSet((tau0 - 1, 2 - 2*tau0, tau0))\n2692 \n2693     * List of Equations as input\n2694 \n2695     >>> Eqns = [3*x + 2*y - z - 1, 2*x - 2*y + 4*z + 2, - x + y/2 - z]\n2696     >>> linsolve(Eqns, x, y, z)\n2697     FiniteSet((1, -2, -2))\n2698 \n2699     * Augmented Matrix as input\n2700 \n2701     >>> aug = Matrix([[2, 1, 3, 1], [2, 6, 8, 3], [6, 8, 18, 5]])\n2702     >>> aug\n2703     Matrix([\n2704     [2, 1,  3, 1],\n2705     [2, 6,  8, 3],\n2706     [6, 8, 18, 5]])\n2707     >>> linsolve(aug, x, y, z)\n2708     FiniteSet((3/10, 2/5, 0))\n2709 \n2710     * Solve for symbolic coefficients\n2711 \n2712     >>> a, b, c, d, e, f = symbols('a, b, c, d, e, f')\n2713     >>> eqns = [a*x + b*y - c, d*x + e*y - f]\n2714     >>> linsolve(eqns, x, y)\n2715     FiniteSet(((-b*f + c*e)/(a*e - b*d), (a*f - c*d)/(a*e - b*d)))\n2716 \n2717     * A degenerate system returns solution as set of given\n2718       symbols.\n2719 \n2720     >>> system = Matrix(([0, 0, 0], [0, 0, 0], [0, 0, 0]))\n2721     >>> linsolve(system, x, y)\n2722     FiniteSet((x, y))\n2723 \n2724     * For an empty system linsolve returns empty set\n2725 \n2726     >>> linsolve([], x)\n2727     EmptySet\n2728 \n2729     * An error is raised if, after expansion, any nonlinearity\n2730       is detected:\n2731 \n2732     >>> linsolve([x*(1/x - 1), (y - 1)**2 - y**2 + 1], x, y)\n2733     FiniteSet((1, 1))\n2734     >>> linsolve([x**2 - 1], x)\n2735     Traceback (most recent call last):\n2736     ...\n2737     NonlinearError:\n2738     nonlinear term encountered: x**2\n2739     \"\"\"\n2740     if not system:\n2741         return S.EmptySet\n2742 \n2743     # If second argument is an iterable\n2744     if symbols and hasattr(symbols[0], '__iter__'):\n2745         symbols = symbols[0]\n2746     sym_gen = isinstance(symbols, GeneratorType)\n2747 \n2748     b = None  # if we don't get b the input was bad\n2749     syms_needed_msg = None\n2750 \n2751     # unpack system\n2752 \n2753     if hasattr(system, '__iter__'):\n2754 \n2755         # 1). (A, b)\n2756         if len(system) == 2 and isinstance(system[0], MatrixBase):\n2757             A, b = system\n2758 \n2759         # 2). (eq1, eq2, ...)\n2760         if not isinstance(system[0], MatrixBase):\n2761             if sym_gen or not symbols:\n2762                 raise ValueError(filldedent('''\n2763                     When passing a system of equations, the explicit\n2764                     symbols for which a solution is being sought must\n2765                     be given as a sequence, too.\n2766                 '''))\n2767 \n2768             #\n2769             # Pass to the sparse solver implemented in polys. It is important\n2770             # that we do not attempt to convert the equations to a matrix\n2771             # because that would be very inefficient for large sparse systems\n2772             # of equations.\n2773             #\n2774             eqs = system\n2775             eqs = [sympify(eq) for eq in eqs]\n2776             try:\n2777                 sol = _linsolve(eqs, symbols)\n2778             except PolyNonlinearError as exc:\n2779                 # e.g. cos(x) contains an element of the set of generators\n2780                 raise NonlinearError(str(exc))\n2781 \n2782             if sol is None:\n2783                 return S.EmptySet\n2784 \n2785             sol = FiniteSet(Tuple(*(sol.get(sym, sym) for sym in symbols)))\n2786             return sol\n2787 \n2788     elif isinstance(system, MatrixBase) and not (\n2789             symbols and not isinstance(symbols, GeneratorType) and\n2790             isinstance(symbols[0], MatrixBase)):\n2791         # 3). A augmented with b\n2792         A, b = system[:, :-1], system[:, -1:]\n2793 \n2794     if b is None:\n2795         raise ValueError(\"Invalid arguments\")\n2796 \n2797     syms_needed_msg  = syms_needed_msg or 'columns of A'\n2798 \n2799     if sym_gen:\n2800         symbols = [next(symbols) for i in range(A.cols)]\n2801         if any(set(symbols) & (A.free_symbols | b.free_symbols)):\n2802             raise ValueError(filldedent('''\n2803                 At least one of the symbols provided\n2804                 already appears in the system to be solved.\n2805                 One way to avoid this is to use Dummy symbols in\n2806                 the generator, e.g. numbered_symbols('%s', cls=Dummy)\n2807             ''' % symbols[0].name.rstrip('1234567890')))\n2808 \n2809     if not symbols:\n2810         symbols = [Dummy() for _ in range(A.cols)]\n2811         name = _uniquely_named_symbol('tau', (A, b),\n2812             compare=lambda i: str(i).rstrip('1234567890')).name\n2813         gen  = numbered_symbols(name)\n2814     else:\n2815         gen = None\n2816 \n2817     # This is just a wrapper for solve_lin_sys\n2818     eqs = []\n2819     rows = A.tolist()\n2820     for rowi, bi in zip(rows, b):\n2821         terms = [elem * sym for elem, sym in zip(rowi, symbols) if elem]\n2822         terms.append(-bi)\n2823         eqs.append(Add(*terms))\n2824 \n2825     eqs, ring = sympy_eqs_to_ring(eqs, symbols)\n2826     sol = solve_lin_sys(eqs, ring, _raw=False)\n2827     if sol is None:\n2828         return S.EmptySet\n2829     #sol = {sym:val for sym, val in sol.items() if sym != val}\n2830     sol = FiniteSet(Tuple(*(sol.get(sym, sym) for sym in symbols)))\n2831 \n2832     if gen is not None:\n2833         solsym = sol.free_symbols\n2834         rep = {sym: next(gen) for sym in symbols if sym in solsym}\n2835         sol = sol.subs(rep)\n2836 \n2837     return sol\n",
        "intended_behavior": "The `linsolve` method should more robustly handle floating-point coefficients close in value, ensuring consistent solutions across mathematically equivalent or very close systems of equations. Specifically, it should include a preprocessing step to detect if the equations involve floating-point coefficients that are close in value and, if so, apply an appropriate strategy to handle them consistently\u2014perhaps by using a symbolic or rational representation internally for greater numerical stability in solutions. This change must preserve `linsolve`'s existing functionality for all other cases while ensuring that the method returns consistent results for systems with slightly different floating-point coefficients."
    },
    {
        "rel_file_path": "sympy/core/numbers.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sympy__sympy/setup_sympy__sympy__1.9/sympy/core/numbers.py",
        "start": 1,
        "end": 4059,
        "class_name": null,
        "method_name": null,
        "code": "1 import numbers\n2 import decimal\n3 import fractions\n4 import math\n5 import re as regex\n6 import sys\n7 \n8 from .containers import Tuple\n9 from .sympify import (SympifyError, converter, sympify, _convert_numpy_types, _sympify,\n10                       _is_numpy_instance)\n11 from .singleton import S, Singleton\n12 from .expr import Expr, AtomicExpr\n13 from .evalf import pure_complex\n14 from .decorators import _sympifyit\n15 from .cache import cacheit, clear_cache\n16 from .logic import fuzzy_not\n17 from sympy.core.compatibility import (as_int, HAS_GMPY, SYMPY_INTS,\n18     gmpy)\n19 from sympy.core.cache import lru_cache\n20 from .kind import NumberKind\n21 from sympy.multipledispatch import dispatch\n22 import mpmath\n23 import mpmath.libmp as mlib\n24 from mpmath.libmp import bitcount\n25 from mpmath.libmp.backend import MPZ\n26 from mpmath.libmp import mpf_pow, mpf_pi, mpf_e, phi_fixed\n27 from mpmath.ctx_mp import mpnumeric\n28 from mpmath.libmp.libmpf import (\n29     finf as _mpf_inf, fninf as _mpf_ninf,\n30     fnan as _mpf_nan, fzero, _normalize as mpf_normalize,\n31     prec_to_dps)\n32 from sympy.utilities.misc import debug, filldedent\n33 from .parameters import global_parameters\n34 \n35 from sympy.utilities.exceptions import SymPyDeprecationWarning\n36 \n37 rnd = mlib.round_nearest\n38 \n39 _LOG2 = math.log(2)\n40 \n41 \n42 def comp(z1, z2, tol=None):\n43     \"\"\"Return a bool indicating whether the error between z1 and z2\n44     is <= tol.\n45 \n46     Examples\n47     ========\n48 \n49     If ``tol`` is None then True will be returned if\n50     ``abs(z1 - z2)*10**p <= 5`` where ``p`` is minimum value of the\n51     decimal precision of each value.\n52 \n53     >>> from sympy.core.numbers import comp, pi\n54     >>> pi4 = pi.n(4); pi4\n55     3.142\n56     >>> comp(_, 3.142)\n57     True\n58     >>> comp(pi4, 3.141)\n59     False\n60     >>> comp(pi4, 3.143)\n61     False\n62 \n63     A comparison of strings will be made\n64     if ``z1`` is a Number and ``z2`` is a string or ``tol`` is ''.\n65 \n66     >>> comp(pi4, 3.1415)\n67     True\n68     >>> comp(pi4, 3.1415, '')\n69     False\n70 \n71     When ``tol`` is provided and ``z2`` is non-zero and\n72     ``|z1| > 1`` the error is normalized by ``|z1|``:\n73 \n74     >>> abs(pi4 - 3.14)/pi4\n75     0.000509791731426756\n76     >>> comp(pi4, 3.14, .001)  # difference less than 0.1%\n77     True\n78     >>> comp(pi4, 3.14, .0005)  # difference less than 0.1%\n79     False\n80 \n81     When ``|z1| <= 1`` the absolute error is used:\n82 \n83     >>> 1/pi4\n84     0.3183\n85     >>> abs(1/pi4 - 0.3183)/(1/pi4)\n86     3.07371499106316e-5\n87     >>> abs(1/pi4 - 0.3183)\n88     9.78393554684764e-6\n89     >>> comp(1/pi4, 0.3183, 1e-5)\n90     True\n91 \n92     To see if the absolute error between ``z1`` and ``z2`` is less\n93     than or equal to ``tol``, call this as ``comp(z1 - z2, 0, tol)``\n94     or ``comp(z1 - z2, tol=tol)``:\n95 \n96     >>> abs(pi4 - 3.14)\n97     0.00160156249999988\n98     >>> comp(pi4 - 3.14, 0, .002)\n99     True\n100     >>> comp(pi4 - 3.14, 0, .001)\n101     False\n102     \"\"\"\n103     if type(z2) is str:\n104         if not pure_complex(z1, or_real=True):\n105             raise ValueError('when z2 is a str z1 must be a Number')\n106         return str(z1) == z2\n107     if not z1:\n108         z1, z2 = z2, z1\n109     if not z1:\n110         return True\n111     if not tol:\n112         a, b = z1, z2\n113         if tol == '':\n114             return str(a) == str(b)\n115         if tol is None:\n116             a, b = sympify(a), sympify(b)\n117             if not all(i.is_number for i in (a, b)):\n118                 raise ValueError('expecting 2 numbers')\n119             fa = a.atoms(Float)\n120             fb = b.atoms(Float)\n121             if not fa and not fb:\n122                 # no floats -- compare exactly\n123                 return a == b\n124             # get a to be pure_complex\n125             for do in range(2):\n126                 ca = pure_complex(a, or_real=True)\n127                 if not ca:\n128                     if fa:\n129                         a = a.n(prec_to_dps(min([i._prec for i in fa])))\n130                         ca = pure_complex(a, or_real=True)\n131                         break\n132                     else:\n133                         fa, fb = fb, fa\n134                         a, b = b, a\n135             cb = pure_complex(b)\n136             if not cb and fb:\n137                 b = b.n(prec_to_dps(min([i._prec for i in fb])))\n138                 cb = pure_complex(b, or_real=True)\n139             if ca and cb and (ca[1] or cb[1]):\n140                 return all(comp(i, j) for i, j in zip(ca, cb))\n141             tol = 10**prec_to_dps(min(a._prec, getattr(b, '_prec', a._prec)))\n142             return int(abs(a - b)*tol) <= 5\n143     diff = abs(z1 - z2)\n144     az1 = abs(z1)\n145     if z2 and az1 > 1:\n146         return diff/az1 <= tol\n147     else:\n148         return diff <= tol\n149 \n150 \n151 def mpf_norm(mpf, prec):\n152     \"\"\"Return the mpf tuple normalized appropriately for the indicated\n153     precision after doing a check to see if zero should be returned or\n154     not when the mantissa is 0. ``mpf_normlize`` always assumes that this\n155     is zero, but it may not be since the mantissa for mpf's values \"+inf\",\n156     \"-inf\" and \"nan\" have a mantissa of zero, too.\n157 \n158     Note: this is not intended to validate a given mpf tuple, so sending\n159     mpf tuples that were not created by mpmath may produce bad results. This\n160     is only a wrapper to ``mpf_normalize`` which provides the check for non-\n161     zero mpfs that have a 0 for the mantissa.\n162     \"\"\"\n163     sign, man, expt, bc = mpf\n164     if not man:\n165         # hack for mpf_normalize which does not do this;\n166         # it assumes that if man is zero the result is 0\n167         # (see issue 6639)\n168         if not bc:\n169             return fzero\n170         else:\n171             # don't change anything; this should already\n172             # be a well formed mpf tuple\n173             return mpf\n174 \n175     # Necessary if mpmath is using the gmpy backend\n176     from mpmath.libmp.backend import MPZ\n177     rv = mpf_normalize(sign, MPZ(man), expt, bc, prec, rnd)\n178     return rv\n179 \n180 # TODO: we should use the warnings module\n181 _errdict = {\"divide\": False}\n182 \n183 \n184 def seterr(divide=False):\n185     \"\"\"\n186     Should sympy raise an exception on 0/0 or return a nan?\n187 \n188     divide == True .... raise an exception\n189     divide == False ... return nan\n190     \"\"\"\n191     if _errdict[\"divide\"] != divide:\n192         clear_cache()\n193         _errdict[\"divide\"] = divide\n194 \n195 \n196 def _as_integer_ratio(p):\n197     neg_pow, man, expt, bc = getattr(p, '_mpf_', mpmath.mpf(p)._mpf_)\n198     p = [1, -1][neg_pow % 2]*man\n199     if expt < 0:\n200         q = 2**-expt\n201     else:\n202         q = 1\n203         p *= 2**expt\n204     return int(p), int(q)\n205 \n206 \n207 def _decimal_to_Rational_prec(dec):\n208     \"\"\"Convert an ordinary decimal instance to a Rational.\"\"\"\n209     if not dec.is_finite():\n210         raise TypeError(\"dec must be finite, got %s.\" % dec)\n211     s, d, e = dec.as_tuple()\n212     prec = len(d)\n213     if e >= 0:  # it's an integer\n214         rv = Integer(int(dec))\n215     else:\n216         s = (-1)**s\n217         d = sum([di*10**i for i, di in enumerate(reversed(d))])\n218         rv = Rational(s*d, 10**-e)\n219     return rv, prec\n220 \n221 \n222 _floatpat = regex.compile(r\"[-+]?((\\d*\\.\\d+)|(\\d+\\.?))\")\n223 def _literal_float(f):\n224     \"\"\"Return True if n starts like a floating point number.\"\"\"\n225     return bool(_floatpat.match(f))\n226 \n227 # (a,b) -> gcd(a,b)\n228 \n229 # TODO caching with decorator, but not to degrade performance\n230 \n231 @lru_cache(1024)\n232 def igcd(*args):\n233     \"\"\"Computes nonnegative integer greatest common divisor.\n234 \n235     Explanation\n236     ===========\n237 \n238     The algorithm is based on the well known Euclid's algorithm. To\n239     improve speed, igcd() has its own caching mechanism implemented.\n240 \n241     Examples\n242     ========\n243 \n244     >>> from sympy.core.numbers import igcd\n245     >>> igcd(2, 4)\n246     2\n247     >>> igcd(5, 10, 15)\n248     5\n249 \n250     \"\"\"\n251     if len(args) < 2:\n252         raise TypeError(\n253             'igcd() takes at least 2 arguments (%s given)' % len(args))\n254     args_temp = [abs(as_int(i)) for i in args]\n255     if 1 in args_temp:\n256         return 1\n257     a = args_temp.pop()\n258     if HAS_GMPY: # Using gmpy if present to speed up.\n259         for b in args_temp:\n260             a = gmpy.gcd(a, b) if b else a\n261         return as_int(a)\n262     for b in args_temp:\n263         a = math.gcd(a, b)\n264     return a\n265 \n266 \n267 igcd2 = math.gcd\n268 \n269 \n270 def igcd_lehmer(a, b):\n271     \"\"\"Computes greatest common divisor of two integers.\n272 \n273     Explanation\n274     ===========\n275 \n276     Euclid's algorithm for the computation of the greatest\n277     common divisor  gcd(a, b)  of two (positive) integers\n278     a and b is based on the division identity\n279         a = q*b + r,\n280     where the quotient  q  and the remainder  r  are integers\n281     and  0 <= r < b. Then each common divisor of  a  and  b\n282     divides  r, and it follows that  gcd(a, b) == gcd(b, r).\n283     The algorithm works by constructing the sequence\n284     r0, r1, r2, ..., where  r0 = a, r1 = b,  and each  rn\n285     is the remainder from the division of the two preceding\n286     elements.\n287 \n288     In Python, q = a // b  and  r = a % b  are obtained by the\n289     floor division and the remainder operations, respectively.\n290     These are the most expensive arithmetic operations, especially\n291     for large  a  and  b.\n292 \n293     Lehmer's algorithm is based on the observation that the quotients\n294     qn = r(n-1) // rn  are in general small integers even\n295     when  a  and  b  are very large. Hence the quotients can be\n296     usually determined from a relatively small number of most\n297     significant bits.\n298 \n299     The efficiency of the algorithm is further enhanced by not\n300     computing each long remainder in Euclid's sequence. The remainders\n301     are linear combinations of  a  and  b  with integer coefficients\n302     derived from the quotients. The coefficients can be computed\n303     as far as the quotients can be determined from the chosen\n304     most significant parts of  a  and  b. Only then a new pair of\n305     consecutive remainders is computed and the algorithm starts\n306     anew with this pair.\n307 \n308     References\n309     ==========\n310 \n311     .. [1] https://en.wikipedia.org/wiki/Lehmer%27s_GCD_algorithm\n312 \n313     \"\"\"\n314     a, b = abs(as_int(a)), abs(as_int(b))\n315     if a < b:\n316         a, b = b, a\n317 \n318     # The algorithm works by using one or two digit division\n319     # whenever possible. The outer loop will replace the\n320     # pair (a, b) with a pair of shorter consecutive elements\n321     # of the Euclidean gcd sequence until a and b\n322     # fit into two Python (long) int digits.\n323     nbits = 2*sys.int_info.bits_per_digit\n324 \n325     while a.bit_length() > nbits and b != 0:\n326         # Quotients are mostly small integers that can\n327         # be determined from most significant bits.\n328         n = a.bit_length() - nbits\n329         x, y = int(a >> n), int(b >> n)  # most significant bits\n330 \n331         # Elements of the Euclidean gcd sequence are linear\n332         # combinations of a and b with integer coefficients.\n333         # Compute the coefficients of consecutive pairs\n334         #     a' = A*a + B*b, b' = C*a + D*b\n335         # using small integer arithmetic as far as possible.\n336         A, B, C, D = 1, 0, 0, 1  # initial values\n337 \n338         while True:\n339             # The coefficients alternate in sign while looping.\n340             # The inner loop combines two steps to keep track\n341             # of the signs.\n342 \n343             # At this point we have\n344             #   A > 0, B <= 0, C <= 0, D > 0,\n345             #   x' = x + B <= x < x\" = x + A,\n346             #   y' = y + C <= y < y\" = y + D,\n347             # and\n348             #   x'*N <= a' < x\"*N, y'*N <= b' < y\"*N,\n349             # where N = 2**n.\n350 \n351             # Now, if y' > 0, and x\"//y' and x'//y\" agree,\n352             # then their common value is equal to  q = a'//b'.\n353             # In addition,\n354             #   x'%y\" = x' - q*y\" < x\" - q*y' = x\"%y',\n355             # and\n356             #   (x'%y\")*N < a'%b' < (x\"%y')*N.\n357 \n358             # On the other hand, we also have  x//y == q,\n359             # and therefore\n360             #   x'%y\" = x + B - q*(y + D) = x%y + B',\n361             #   x\"%y' = x + A - q*(y + C) = x%y + A',\n362             # where\n363             #    B' = B - q*D < 0, A' = A - q*C > 0.\n364 \n365             if y + C <= 0:\n366                 break\n367             q = (x + A) // (y + C)\n368 \n369             # Now  x'//y\" <= q, and equality holds if\n370             #   x' - q*y\" = (x - q*y) + (B - q*D) >= 0.\n371             # This is a minor optimization to avoid division.\n372             x_qy, B_qD = x - q*y, B - q*D\n373             if x_qy + B_qD < 0:\n374                 break\n375 \n376             # Next step in the Euclidean sequence.\n377             x, y = y, x_qy\n378             A, B, C, D = C, D, A - q*C, B_qD\n379 \n380             # At this point the signs of the coefficients\n381             # change and their roles are interchanged.\n382             #   A <= 0, B > 0, C > 0, D < 0,\n383             #   x' = x + A <= x < x\" = x + B,\n384             #   y' = y + D < y < y\" = y + C.\n385 \n386             if y + D <= 0:\n387                 break\n388             q = (x + B) // (y + D)\n389             x_qy, A_qC = x - q*y, A - q*C\n390             if x_qy + A_qC < 0:\n391                 break\n392 \n393             x, y = y, x_qy\n394             A, B, C, D = C, D, A_qC, B - q*D\n395             # Now the conditions on top of the loop\n396             # are again satisfied.\n397             #   A > 0, B < 0, C < 0, D > 0.\n398 \n399         if B == 0:\n400             # This can only happen when y == 0 in the beginning\n401             # and the inner loop does nothing.\n402             # Long division is forced.\n403             a, b = b, a % b\n404             continue\n405 \n406         # Compute new long arguments using the coefficients.\n407         a, b = A*a + B*b, C*a + D*b\n408 \n409     # Small divisors. Finish with the standard algorithm.\n410     while b:\n411         a, b = b, a % b\n412 \n413     return a\n414 \n415 \n416 def ilcm(*args):\n417     \"\"\"Computes integer least common multiple.\n418 \n419     Examples\n420     ========\n421 \n422     >>> from sympy.core.numbers import ilcm\n423     >>> ilcm(5, 10)\n424     10\n425     >>> ilcm(7, 3)\n426     21\n427     >>> ilcm(5, 10, 15)\n428     30\n429 \n430     \"\"\"\n431     if len(args) < 2:\n432         raise TypeError(\n433             'ilcm() takes at least 2 arguments (%s given)' % len(args))\n434     if 0 in args:\n435         return 0\n436     a = args[0]\n437     for b in args[1:]:\n438         a = a // igcd(a, b) * b # since gcd(a,b) | a\n439     return a\n440 \n441 \n442 def igcdex(a, b):\n443     \"\"\"Returns x, y, g such that g = x*a + y*b = gcd(a, b).\n444 \n445     Examples\n446     ========\n447 \n448     >>> from sympy.core.numbers import igcdex\n449     >>> igcdex(2, 3)\n450     (-1, 1, 1)\n451     >>> igcdex(10, 12)\n452     (-1, 1, 2)\n453 \n454     >>> x, y, g = igcdex(100, 2004)\n455     >>> x, y, g\n456     (-20, 1, 4)\n457     >>> x*100 + y*2004\n458     4\n459 \n460     \"\"\"\n461     if (not a) and (not b):\n462         return (0, 1, 0)\n463 \n464     if not a:\n465         return (0, b//abs(b), abs(b))\n466     if not b:\n467         return (a//abs(a), 0, abs(a))\n468 \n469     if a < 0:\n470         a, x_sign = -a, -1\n471     else:\n472         x_sign = 1\n473 \n474     if b < 0:\n475         b, y_sign = -b, -1\n476     else:\n477         y_sign = 1\n478 \n479     x, y, r, s = 1, 0, 0, 1\n480 \n481     while b:\n482         (c, q) = (a % b, a // b)\n483         (a, b, r, s, x, y) = (b, c, x - q*r, y - q*s, r, s)\n484 \n485     return (x*x_sign, y*y_sign, a)\n486 \n487 \n488 def mod_inverse(a, m):\n489     \"\"\"\n490     Return the number c such that, (a * c) = 1 (mod m)\n491     where c has the same sign as m. If no such value exists,\n492     a ValueError is raised.\n493 \n494     Examples\n495     ========\n496 \n497     >>> from sympy import S\n498     >>> from sympy.core.numbers import mod_inverse\n499 \n500     Suppose we wish to find multiplicative inverse x of\n501     3 modulo 11. This is the same as finding x such\n502     that 3 * x = 1 (mod 11). One value of x that satisfies\n503     this congruence is 4. Because 3 * 4 = 12 and 12 = 1 (mod 11).\n504     This is the value returned by mod_inverse:\n505 \n506     >>> mod_inverse(3, 11)\n507     4\n508     >>> mod_inverse(-3, 11)\n509     7\n510 \n511     When there is a common factor between the numerators of\n512     ``a`` and ``m`` the inverse does not exist:\n513 \n514     >>> mod_inverse(2, 4)\n515     Traceback (most recent call last):\n516     ...\n517     ValueError: inverse of 2 mod 4 does not exist\n518 \n519     >>> mod_inverse(S(2)/7, S(5)/2)\n520     7/2\n521 \n522     References\n523     ==========\n524 \n525     .. [1] https://en.wikipedia.org/wiki/Modular_multiplicative_inverse\n526     .. [2] https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm\n527     \"\"\"\n528     c = None\n529     try:\n530         a, m = as_int(a), as_int(m)\n531         if m != 1 and m != -1:\n532             x, y, g = igcdex(a, m)\n533             if g == 1:\n534                 c = x % m\n535     except ValueError:\n536         a, m = sympify(a), sympify(m)\n537         if not (a.is_number and m.is_number):\n538             raise TypeError(filldedent('''\n539                 Expected numbers for arguments; symbolic `mod_inverse`\n540                 is not implemented\n541                 but symbolic expressions can be handled with the\n542                 similar function,\n543                 sympy.polys.polytools.invert'''))\n544         big = (m > 1)\n545         if not (big is S.true or big is S.false):\n546             raise ValueError('m > 1 did not evaluate; try to simplify %s' % m)\n547         elif big:\n548             c = 1/a\n549     if c is None:\n550         raise ValueError('inverse of %s (mod %s) does not exist' % (a, m))\n551     return c\n552 \n553 \n554 class Number(AtomicExpr):\n555     \"\"\"Represents atomic numbers in SymPy.\n556 \n557     Explanation\n558     ===========\n559 \n560     Floating point numbers are represented by the Float class.\n561     Rational numbers (of any size) are represented by the Rational class.\n562     Integer numbers (of any size) are represented by the Integer class.\n563     Float and Rational are subclasses of Number; Integer is a subclass\n564     of Rational.\n565 \n566     For example, ``2/3`` is represented as ``Rational(2, 3)`` which is\n567     a different object from the floating point number obtained with\n568     Python division ``2/3``. Even for numbers that are exactly\n569     represented in binary, there is a difference between how two forms,\n570     such as ``Rational(1, 2)`` and ``Float(0.5)``, are used in SymPy.\n571     The rational form is to be preferred in symbolic computations.\n572 \n573     Other kinds of numbers, such as algebraic numbers ``sqrt(2)`` or\n574     complex numbers ``3 + 4*I``, are not instances of Number class as\n575     they are not atomic.\n576 \n577     See Also\n578     ========\n579 \n580     Float, Integer, Rational\n581     \"\"\"\n582     is_commutative = True\n583     is_number = True\n584     is_Number = True\n585 \n586     __slots__ = ()\n587 \n588     # Used to make max(x._prec, y._prec) return x._prec when only x is a float\n589     _prec = -1\n590 \n591     kind = NumberKind\n592 \n593     def __new__(cls, *obj):\n594         if len(obj) == 1:\n595             obj = obj[0]\n596 \n597         if isinstance(obj, Number):\n598             return obj\n599         if isinstance(obj, SYMPY_INTS):\n600             return Integer(obj)\n601         if isinstance(obj, tuple) and len(obj) == 2:\n602             return Rational(*obj)\n603         if isinstance(obj, (float, mpmath.mpf, decimal.Decimal)):\n604             return Float(obj)\n605         if isinstance(obj, str):\n606             _obj = obj.lower()  # float('INF') == float('inf')\n607             if _obj == 'nan':\n608                 return S.NaN\n609             elif _obj == 'inf':\n610                 return S.Infinity\n611             elif _obj == '+inf':\n612                 return S.Infinity\n613             elif _obj == '-inf':\n614                 return S.NegativeInfinity\n615             val = sympify(obj)\n616             if isinstance(val, Number):\n617                 return val\n618             else:\n619                 raise ValueError('String \"%s\" does not denote a Number' % obj)\n620         msg = \"expected str|int|long|float|Decimal|Number object but got %r\"\n621         raise TypeError(msg % type(obj).__name__)\n622 \n623     def invert(self, other, *gens, **args):\n624         from sympy.polys.polytools import invert\n625         if getattr(other, 'is_number', True):\n626             return mod_inverse(self, other)\n627         return invert(self, other, *gens, **args)\n628 \n629     def __divmod__(self, other):\n630         from .containers import Tuple\n631         from sympy.functions.elementary.complexes import sign\n632 \n633         try:\n634             other = Number(other)\n635             if self.is_infinite or S.NaN in (self, other):\n636                 return (S.NaN, S.NaN)\n637         except TypeError:\n638             return NotImplemented\n639         if not other:\n640             raise ZeroDivisionError('modulo by zero')\n641         if self.is_Integer and other.is_Integer:\n642             return Tuple(*divmod(self.p, other.p))\n643         elif isinstance(other, Float):\n644             rat = self/Rational(other)\n645         else:\n646             rat = self/other\n647         if other.is_finite:\n648             w = int(rat) if rat >= 0 else int(rat) - 1\n649             r = self - other*w\n650         else:\n651             w = 0 if not self or (sign(self) == sign(other)) else -1\n652             r = other if w else self\n653         return Tuple(w, r)\n654 \n655     def __rdivmod__(self, other):\n656         try:\n657             other = Number(other)\n658         except TypeError:\n659             return NotImplemented\n660         return divmod(other, self)\n661 \n662     def _as_mpf_val(self, prec):\n663         \"\"\"Evaluation of mpf tuple accurate to at least prec bits.\"\"\"\n664         raise NotImplementedError('%s needs ._as_mpf_val() method' %\n665             (self.__class__.__name__))\n666 \n667     def _eval_evalf(self, prec):\n668         return Float._new(self._as_mpf_val(prec), prec)\n669 \n670     def _as_mpf_op(self, prec):\n671         prec = max(prec, self._prec)\n672         return self._as_mpf_val(prec), prec\n673 \n674     def __float__(self):\n675         return mlib.to_float(self._as_mpf_val(53))\n676 \n677     def floor(self):\n678         raise NotImplementedError('%s needs .floor() method' %\n679             (self.__class__.__name__))\n680 \n681     def ceiling(self):\n682         raise NotImplementedError('%s needs .ceiling() method' %\n683             (self.__class__.__name__))\n684 \n685     def __floor__(self):\n686         return self.floor()\n687 \n688     def __ceil__(self):\n689         return self.ceiling()\n690 \n691     def _eval_conjugate(self):\n692         return self\n693 \n694     def _eval_order(self, *symbols):\n695         from sympy import Order\n696         # Order(5, x, y) -> Order(1,x,y)\n697         return Order(S.One, *symbols)\n698 \n699     def _eval_subs(self, old, new):\n700         if old == -self:\n701             return -new\n702         return self  # there is no other possibility\n703 \n704     def _eval_is_finite(self):\n705         return True\n706 \n707     @classmethod\n708     def class_key(cls):\n709         return 1, 0, 'Number'\n710 \n711     @cacheit\n712     def sort_key(self, order=None):\n713         return self.class_key(), (0, ()), (), self\n714 \n715     @_sympifyit('other', NotImplemented)\n716     def __add__(self, other):\n717         if isinstance(other, Number) and global_parameters.evaluate:\n718             if other is S.NaN:\n719                 return S.NaN\n720             elif other is S.Infinity:\n721                 return S.Infinity\n722             elif other is S.NegativeInfinity:\n723                 return S.NegativeInfinity\n724         return AtomicExpr.__add__(self, other)\n725 \n726     @_sympifyit('other', NotImplemented)\n727     def __sub__(self, other):\n728         if isinstance(other, Number) and global_parameters.evaluate:\n729             if other is S.NaN:\n730                 return S.NaN\n731             elif other is S.Infinity:\n732                 return S.NegativeInfinity\n733             elif other is S.NegativeInfinity:\n734                 return S.Infinity\n735         return AtomicExpr.__sub__(self, other)\n736 \n737     @_sympifyit('other', NotImplemented)\n738     def __mul__(self, other):\n739         if isinstance(other, Number) and global_parameters.evaluate:\n740             if other is S.NaN:\n741                 return S.NaN\n742             elif other is S.Infinity:\n743                 if self.is_zero:\n744                     return S.NaN\n745                 elif self.is_positive:\n746                     return S.Infinity\n747                 else:\n748                     return S.NegativeInfinity\n749             elif other is S.NegativeInfinity:\n750                 if self.is_zero:\n751                     return S.NaN\n752                 elif self.is_positive:\n753                     return S.NegativeInfinity\n754                 else:\n755                     return S.Infinity\n756         elif isinstance(other, Tuple):\n757             return NotImplemented\n758         return AtomicExpr.__mul__(self, other)\n759 \n760     @_sympifyit('other', NotImplemented)\n761     def __truediv__(self, other):\n762         if isinstance(other, Number) and global_parameters.evaluate:\n763             if other is S.NaN:\n764                 return S.NaN\n765             elif other is S.Infinity or other is S.NegativeInfinity:\n766                 return S.Zero\n767         return AtomicExpr.__truediv__(self, other)\n768 \n769     def __eq__(self, other):\n770         raise NotImplementedError('%s needs .__eq__() method' %\n771             (self.__class__.__name__))\n772 \n773     def __ne__(self, other):\n774         raise NotImplementedError('%s needs .__ne__() method' %\n775             (self.__class__.__name__))\n776 \n777     def __lt__(self, other):\n778         try:\n779             other = _sympify(other)\n780         except SympifyError:\n781             raise TypeError(\"Invalid comparison %s < %s\" % (self, other))\n782         raise NotImplementedError('%s needs .__lt__() method' %\n783             (self.__class__.__name__))\n784 \n785     def __le__(self, other):\n786         try:\n787             other = _sympify(other)\n788         except SympifyError:\n789             raise TypeError(\"Invalid comparison %s <= %s\" % (self, other))\n790         raise NotImplementedError('%s needs .__le__() method' %\n791             (self.__class__.__name__))\n792 \n793     def __gt__(self, other):\n794         try:\n795             other = _sympify(other)\n796         except SympifyError:\n797             raise TypeError(\"Invalid comparison %s > %s\" % (self, other))\n798         return _sympify(other).__lt__(self)\n799 \n800     def __ge__(self, other):\n801         try:\n802             other = _sympify(other)\n803         except SympifyError:\n804             raise TypeError(\"Invalid comparison %s >= %s\" % (self, other))\n805         return _sympify(other).__le__(self)\n806 \n807     def __hash__(self):\n808         return super().__hash__()\n809 \n810     def is_constant(self, *wrt, **flags):\n811         return True\n812 \n813     def as_coeff_mul(self, *deps, rational=True, **kwargs):\n814         # a -> c*t\n815         if self.is_Rational or not rational:\n816             return self, tuple()\n817         elif self.is_negative:\n818             return S.NegativeOne, (-self,)\n819         return S.One, (self,)\n820 \n821     def as_coeff_add(self, *deps):\n822         # a -> c + t\n823         if self.is_Rational:\n824             return self, tuple()\n825         return S.Zero, (self,)\n826 \n827     def as_coeff_Mul(self, rational=False):\n828         \"\"\"Efficiently extract the coefficient of a product. \"\"\"\n829         if rational and not self.is_Rational:\n830             return S.One, self\n831         return (self, S.One) if self else (S.One, self)\n832 \n833     def as_coeff_Add(self, rational=False):\n834         \"\"\"Efficiently extract the coefficient of a summation. \"\"\"\n835         if not rational:\n836             return self, S.Zero\n837         return S.Zero, self\n838 \n839     def gcd(self, other):\n840         \"\"\"Compute GCD of `self` and `other`. \"\"\"\n841         from sympy.polys import gcd\n842         return gcd(self, other)\n843 \n844     def lcm(self, other):\n845         \"\"\"Compute LCM of `self` and `other`. \"\"\"\n846         from sympy.polys import lcm\n847         return lcm(self, other)\n848 \n849     def cofactors(self, other):\n850         \"\"\"Compute GCD and cofactors of `self` and `other`. \"\"\"\n851         from sympy.polys import cofactors\n852         return cofactors(self, other)\n853 \n854 \n855 class Float(Number):\n856     \"\"\"Represent a floating-point number of arbitrary precision.\n857 \n858     Examples\n859     ========\n860 \n861     >>> from sympy import Float\n862     >>> Float(3.5)\n863     3.50000000000000\n864     >>> Float(3)\n865     3.00000000000000\n866 \n867     Creating Floats from strings (and Python ``int`` and ``long``\n868     types) will give a minimum precision of 15 digits, but the\n869     precision will automatically increase to capture all digits\n870     entered.\n871 \n872     >>> Float(1)\n873     1.00000000000000\n874     >>> Float(10**20)\n875     100000000000000000000.\n876     >>> Float('1e20')\n877     100000000000000000000.\n878 \n879     However, *floating-point* numbers (Python ``float`` types) retain\n880     only 15 digits of precision:\n881 \n882     >>> Float(1e20)\n883     1.00000000000000e+20\n884     >>> Float(1.23456789123456789)\n885     1.23456789123457\n886 \n887     It may be preferable to enter high-precision decimal numbers\n888     as strings:\n889 \n890     >>> Float('1.23456789123456789')\n891     1.23456789123456789\n892 \n893     The desired number of digits can also be specified:\n894 \n895     >>> Float('1e-3', 3)\n896     0.00100\n897     >>> Float(100, 4)\n898     100.0\n899 \n900     Float can automatically count significant figures if a null string\n901     is sent for the precision; spaces or underscores are also allowed. (Auto-\n902     counting is only allowed for strings, ints and longs).\n903 \n904     >>> Float('123 456 789.123_456', '')\n905     123456789.123456\n906     >>> Float('12e-3', '')\n907     0.012\n908     >>> Float(3, '')\n909     3.\n910 \n911     If a number is written in scientific notation, only the digits before the\n912     exponent are considered significant if a decimal appears, otherwise the\n913     \"e\" signifies only how to move the decimal:\n914 \n915     >>> Float('60.e2', '')  # 2 digits significant\n916     6.0e+3\n917     >>> Float('60e2', '')  # 4 digits significant\n918     6000.\n919     >>> Float('600e-2', '')  # 3 digits significant\n920     6.00\n921 \n922     Notes\n923     =====\n924 \n925     Floats are inexact by their nature unless their value is a binary-exact\n926     value.\n927 \n928     >>> approx, exact = Float(.1, 1), Float(.125, 1)\n929 \n930     For calculation purposes, evalf needs to be able to change the precision\n931     but this will not increase the accuracy of the inexact value. The\n932     following is the most accurate 5-digit approximation of a value of 0.1\n933     that had only 1 digit of precision:\n934 \n935     >>> approx.evalf(5)\n936     0.099609\n937 \n938     By contrast, 0.125 is exact in binary (as it is in base 10) and so it\n939     can be passed to Float or evalf to obtain an arbitrary precision with\n940     matching accuracy:\n941 \n942     >>> Float(exact, 5)\n943     0.12500\n944     >>> exact.evalf(20)\n945     0.12500000000000000000\n946 \n947     Trying to make a high-precision Float from a float is not disallowed,\n948     but one must keep in mind that the *underlying float* (not the apparent\n949     decimal value) is being obtained with high precision. For example, 0.3\n950     does not have a finite binary representation. The closest rational is\n951     the fraction 5404319552844595/2**54. So if you try to obtain a Float of\n952     0.3 to 20 digits of precision you will not see the same thing as 0.3\n953     followed by 19 zeros:\n954 \n955     >>> Float(0.3, 20)\n956     0.29999999999999998890\n957 \n958     If you want a 20-digit value of the decimal 0.3 (not the floating point\n959     approximation of 0.3) you should send the 0.3 as a string. The underlying\n960     representation is still binary but a higher precision than Python's float\n961     is used:\n962 \n963     >>> Float('0.3', 20)\n964     0.30000000000000000000\n965 \n966     Although you can increase the precision of an existing Float using Float\n967     it will not increase the accuracy -- the underlying value is not changed:\n968 \n969     >>> def show(f): # binary rep of Float\n970     ...     from sympy import Mul, Pow\n971     ...     s, m, e, b = f._mpf_\n972     ...     v = Mul(int(m), Pow(2, int(e), evaluate=False), evaluate=False)\n973     ...     print('%s at prec=%s' % (v, f._prec))\n974     ...\n975     >>> t = Float('0.3', 3)\n976     >>> show(t)\n977     4915/2**14 at prec=13\n978     >>> show(Float(t, 20)) # higher prec, not higher accuracy\n979     4915/2**14 at prec=70\n980     >>> show(Float(t, 2)) # lower prec\n981     307/2**10 at prec=10\n982 \n983     The same thing happens when evalf is used on a Float:\n984 \n985     >>> show(t.evalf(20))\n986     4915/2**14 at prec=70\n987     >>> show(t.evalf(2))\n988     307/2**10 at prec=10\n989 \n990     Finally, Floats can be instantiated with an mpf tuple (n, c, p) to\n991     produce the number (-1)**n*c*2**p:\n992 \n993     >>> n, c, p = 1, 5, 0\n994     >>> (-1)**n*c*2**p\n995     -5\n996     >>> Float((1, 5, 0))\n997     -5.00000000000000\n998 \n999     An actual mpf tuple also contains the number of bits in c as the last\n1000     element of the tuple:\n1001 \n1002     >>> _._mpf_\n1003     (1, 5, 0, 3)\n1004 \n1005     This is not needed for instantiation and is not the same thing as the\n1006     precision. The mpf tuple and the precision are two separate quantities\n1007     that Float tracks.\n1008 \n1009     In SymPy, a Float is a number that can be computed with arbitrary\n1010     precision. Although floating point 'inf' and 'nan' are not such\n1011     numbers, Float can create these numbers:\n1012 \n1013     >>> Float('-inf')\n1014     -oo\n1015     >>> _.is_Float\n1016     False\n1017     \"\"\"\n1018     __slots__ = ('_mpf_', '_prec')\n1019 \n1020     # A Float represents many real numbers,\n1021     # both rational and irrational.\n1022     is_rational = None\n1023     is_irrational = None\n1024     is_number = True\n1025 \n1026     is_real = True\n1027     is_extended_real = True\n1028 \n1029     is_Float = True\n1030 \n1031     def __new__(cls, num, dps=None, prec=None, precision=None):\n1032         if prec is not None:\n1033             SymPyDeprecationWarning(\n1034                             feature=\"Using 'prec=XX' to denote decimal precision\",\n1035                             useinstead=\"'dps=XX' for decimal precision and 'precision=XX' \"\\\n1036                                               \"for binary precision\",\n1037                             issue=12820,\n1038                             deprecated_since_version=\"1.1\").warn()\n1039             dps = prec\n1040         del prec  # avoid using this deprecated kwarg\n1041 \n1042         if dps is not None and precision is not None:\n1043             raise ValueError('Both decimal and binary precision supplied. '\n1044                              'Supply only one. ')\n1045 \n1046         if isinstance(num, str):\n1047             # Float accepts spaces as digit separators\n1048             num = num.replace(' ', '').lower()\n1049             # in Py 3.6\n1050             # underscores are allowed. In anticipation of that, we ignore\n1051             # legally placed underscores\n1052             if '_' in num:\n1053                 parts = num.split('_')\n1054                 if not (all(parts) and\n1055                         all(parts[i][-1].isdigit()\n1056                             for i in range(0, len(parts), 2)) and\n1057                         all(parts[i][0].isdigit()\n1058                             for i in range(1, len(parts), 2))):\n1059                     # copy Py 3.6 error\n1060                     raise ValueError(\"could not convert string to float: '%s'\" % num)\n1061                 num = ''.join(parts)\n1062             if num.startswith('.') and len(num) > 1:\n1063                 num = '0' + num\n1064             elif num.startswith('-.') and len(num) > 2:\n1065                 num = '-0.' + num[2:]\n1066             elif num in ('inf', '+inf'):\n1067                 return S.Infinity\n1068             elif num == '-inf':\n1069                 return S.NegativeInfinity\n1070         elif isinstance(num, float) and num == 0:\n1071             num = '0'\n1072         elif isinstance(num, float) and num == float('inf'):\n1073             return S.Infinity\n1074         elif isinstance(num, float) and num == float('-inf'):\n1075             return S.NegativeInfinity\n1076         elif isinstance(num, float) and num == float('nan'):\n1077             return S.NaN\n1078         elif isinstance(num, (SYMPY_INTS, Integer)):\n1079             num = str(num)\n1080         elif num is S.Infinity:\n1081             return num\n1082         elif num is S.NegativeInfinity:\n1083             return num\n1084         elif num is S.NaN:\n1085             return num\n1086         elif _is_numpy_instance(num):  # support for numpy datatypes\n1087             num = _convert_numpy_types(num)\n1088         elif isinstance(num, mpmath.mpf):\n1089             if precision is None:\n1090                 if dps is None:\n1091                     precision = num.context.prec\n1092             num = num._mpf_\n1093 \n1094         if dps is None and precision is None:\n1095             dps = 15\n1096             if isinstance(num, Float):\n1097                 return num\n1098             if isinstance(num, str) and _literal_float(num):\n1099                 try:\n1100                     Num = decimal.Decimal(num)\n1101                 except decimal.InvalidOperation:\n1102                     pass\n1103                 else:\n1104                     isint = '.' not in num\n1105                     num, dps = _decimal_to_Rational_prec(Num)\n1106                     if num.is_Integer and isint:\n1107                         dps = max(dps, len(str(num).lstrip('-')))\n1108                     dps = max(15, dps)\n1109                     precision = mlib.libmpf.dps_to_prec(dps)\n1110         elif precision == '' and dps is None or precision is None and dps == '':\n1111             if not isinstance(num, str):\n1112                 raise ValueError('The null string can only be used when '\n1113                 'the number to Float is passed as a string or an integer.')\n1114             ok = None\n1115             if _literal_float(num):\n1116                 try:\n1117                     Num = decimal.Decimal(num)\n1118                 except decimal.InvalidOperation:\n1119                     pass\n1120                 else:\n1121                     isint = '.' not in num\n1122                     num, dps = _decimal_to_Rational_prec(Num)\n1123                     if num.is_Integer and isint:\n1124                         dps = max(dps, len(str(num).lstrip('-')))\n1125                         precision = mlib.libmpf.dps_to_prec(dps)\n1126                     ok = True\n1127             if ok is None:\n1128                 raise ValueError('string-float not recognized: %s' % num)\n1129 \n1130         # decimal precision(dps) is set and maybe binary precision(precision)\n1131         # as well.From here on binary precision is used to compute the Float.\n1132         # Hence, if supplied use binary precision else translate from decimal\n1133         # precision.\n1134 \n1135         if precision is None or precision == '':\n1136             precision = mlib.libmpf.dps_to_prec(dps)\n1137 \n1138         precision = int(precision)\n1139 \n1140         if isinstance(num, float):\n1141             _mpf_ = mlib.from_float(num, precision, rnd)\n1142         elif isinstance(num, str):\n1143             _mpf_ = mlib.from_str(num, precision, rnd)\n1144         elif isinstance(num, decimal.Decimal):\n1145             if num.is_finite():\n1146                 _mpf_ = mlib.from_str(str(num), precision, rnd)\n1147             elif num.is_nan():\n1148                 return S.NaN\n1149             elif num.is_infinite():\n1150                 if num > 0:\n1151                     return S.Infinity\n1152                 return S.NegativeInfinity\n1153             else:\n1154                 raise ValueError(\"unexpected decimal value %s\" % str(num))\n1155         elif isinstance(num, tuple) and len(num) in (3, 4):\n1156             if type(num[1]) is str:\n1157                 # it's a hexadecimal (coming from a pickled object)\n1158                 # assume that it is in standard form\n1159                 num = list(num)\n1160                 # If we're loading an object pickled in Python 2 into\n1161                 # Python 3, we may need to strip a tailing 'L' because\n1162                 # of a shim for int on Python 3, see issue #13470.\n1163                 if num[1].endswith('L'):\n1164                     num[1] = num[1][:-1]\n1165                 num[1] = MPZ(num[1], 16)\n1166                 _mpf_ = tuple(num)\n1167             else:\n1168                 if len(num) == 4:\n1169                     # handle normalization hack\n1170                     return Float._new(num, precision)\n1171                 else:\n1172                     if not all((\n1173                             num[0] in (0, 1),\n1174                             num[1] >= 0,\n1175                             all(type(i) in (int, int) for i in num)\n1176                             )):\n1177                         raise ValueError('malformed mpf: %s' % (num,))\n1178                     # don't compute number or else it may\n1179                     # over/underflow\n1180                     return Float._new(\n1181                         (num[0], num[1], num[2], bitcount(num[1])),\n1182                         precision)\n1183         else:\n1184             try:\n1185                 _mpf_ = num._as_mpf_val(precision)\n1186             except (NotImplementedError, AttributeError):\n1187                 _mpf_ = mpmath.mpf(num, prec=precision)._mpf_\n1188 \n1189         return cls._new(_mpf_, precision, zero=False)\n1190 \n1191     @classmethod\n1192     def _new(cls, _mpf_, _prec, zero=True):\n1193         # special cases\n1194         if zero and _mpf_ == fzero:\n1195             return S.Zero  # Float(0) -> 0.0; Float._new((0,0,0,0)) -> 0\n1196         elif _mpf_ == _mpf_nan:\n1197             return S.NaN\n1198         elif _mpf_ == _mpf_inf:\n1199             return S.Infinity\n1200         elif _mpf_ == _mpf_ninf:\n1201             return S.NegativeInfinity\n1202 \n1203         obj = Expr.__new__(cls)\n1204         obj._mpf_ = mpf_norm(_mpf_, _prec)\n1205         obj._prec = _prec\n1206         return obj\n1207 \n1208     # mpz can't be pickled\n1209     def __getnewargs_ex__(self):\n1210         return ((mlib.to_pickable(self._mpf_),), {'precision': self._prec})\n1211 \n1212     def _hashable_content(self):\n1213         return (self._mpf_, self._prec)\n1214 \n1215     def floor(self):\n1216         return Integer(int(mlib.to_int(\n1217             mlib.mpf_floor(self._mpf_, self._prec))))\n1218 \n1219     def ceiling(self):\n1220         return Integer(int(mlib.to_int(\n1221             mlib.mpf_ceil(self._mpf_, self._prec))))\n1222 \n1223     def __floor__(self):\n1224         return self.floor()\n1225 \n1226     def __ceil__(self):\n1227         return self.ceiling()\n1228 \n1229     @property\n1230     def num(self):\n1231         return mpmath.mpf(self._mpf_)\n1232 \n1233     def _as_mpf_val(self, prec):\n1234         rv = mpf_norm(self._mpf_, prec)\n1235         if rv != self._mpf_ and self._prec == prec:\n1236             debug(self._mpf_, rv)\n1237         return rv\n1238 \n1239     def _as_mpf_op(self, prec):\n1240         return self._mpf_, max(prec, self._prec)\n1241 \n1242     def _eval_is_finite(self):\n1243         if self._mpf_ in (_mpf_inf, _mpf_ninf):\n1244             return False\n1245         return True\n1246 \n1247     def _eval_is_infinite(self):\n1248         if self._mpf_ in (_mpf_inf, _mpf_ninf):\n1249             return True\n1250         return False\n1251 \n1252     def _eval_is_integer(self):\n1253         return self._mpf_ == fzero\n1254 \n1255     def _eval_is_negative(self):\n1256         if self._mpf_ == _mpf_ninf or self._mpf_ == _mpf_inf:\n1257             return False\n1258         return self.num < 0\n1259 \n1260     def _eval_is_positive(self):\n1261         if self._mpf_ == _mpf_ninf or self._mpf_ == _mpf_inf:\n1262             return False\n1263         return self.num > 0\n1264 \n1265     def _eval_is_extended_negative(self):\n1266         if self._mpf_ == _mpf_ninf:\n1267             return True\n1268         if self._mpf_ == _mpf_inf:\n1269             return False\n1270         return self.num < 0\n1271 \n1272     def _eval_is_extended_positive(self):\n1273         if self._mpf_ == _mpf_inf:\n1274             return True\n1275         if self._mpf_ == _mpf_ninf:\n1276             return False\n1277         return self.num > 0\n1278 \n1279     def _eval_is_zero(self):\n1280         return self._mpf_ == fzero\n1281 \n1282     def __bool__(self):\n1283         return self._mpf_ != fzero\n1284 \n1285     def __neg__(self):\n1286         return Float._new(mlib.mpf_neg(self._mpf_), self._prec)\n1287 \n1288     @_sympifyit('other', NotImplemented)\n1289     def __add__(self, other):\n1290         if isinstance(other, Number) and global_parameters.evaluate:\n1291             rhs, prec = other._as_mpf_op(self._prec)\n1292             return Float._new(mlib.mpf_add(self._mpf_, rhs, prec, rnd), prec)\n1293         return Number.__add__(self, other)\n1294 \n1295     @_sympifyit('other', NotImplemented)\n1296     def __sub__(self, other):\n1297         if isinstance(other, Number) and global_parameters.evaluate:\n1298             rhs, prec = other._as_mpf_op(self._prec)\n1299             return Float._new(mlib.mpf_sub(self._mpf_, rhs, prec, rnd), prec)\n1300         return Number.__sub__(self, other)\n1301 \n1302     @_sympifyit('other', NotImplemented)\n1303     def __mul__(self, other):\n1304         if isinstance(other, Number) and global_parameters.evaluate:\n1305             rhs, prec = other._as_mpf_op(self._prec)\n1306             return Float._new(mlib.mpf_mul(self._mpf_, rhs, prec, rnd), prec)\n1307         return Number.__mul__(self, other)\n1308 \n1309     @_sympifyit('other', NotImplemented)\n1310     def __truediv__(self, other):\n1311         if isinstance(other, Number) and other != 0 and global_parameters.evaluate:\n1312             rhs, prec = other._as_mpf_op(self._prec)\n1313             return Float._new(mlib.mpf_div(self._mpf_, rhs, prec, rnd), prec)\n1314         return Number.__truediv__(self, other)\n1315 \n1316     @_sympifyit('other', NotImplemented)\n1317     def __mod__(self, other):\n1318         if isinstance(other, Rational) and other.q != 1 and global_parameters.evaluate:\n1319             # calculate mod with Rationals, *then* round the result\n1320             return Float(Rational.__mod__(Rational(self), other),\n1321                          precision=self._prec)\n1322         if isinstance(other, Float) and global_parameters.evaluate:\n1323             r = self/other\n1324             if r == int(r):\n1325                 return Float(0, precision=max(self._prec, other._prec))\n1326         if isinstance(other, Number) and global_parameters.evaluate:\n1327             rhs, prec = other._as_mpf_op(self._prec)\n1328             return Float._new(mlib.mpf_mod(self._mpf_, rhs, prec, rnd), prec)\n1329         return Number.__mod__(self, other)\n1330 \n1331     @_sympifyit('other', NotImplemented)\n1332     def __rmod__(self, other):\n1333         if isinstance(other, Float) and global_parameters.evaluate:\n1334             return other.__mod__(self)\n1335         if isinstance(other, Number) and global_parameters.evaluate:\n1336             rhs, prec = other._as_mpf_op(self._prec)\n1337             return Float._new(mlib.mpf_mod(rhs, self._mpf_, prec, rnd), prec)\n1338         return Number.__rmod__(self, other)\n1339 \n1340     def _eval_power(self, expt):\n1341         \"\"\"\n1342         expt is symbolic object but not equal to 0, 1\n1343 \n1344         (-p)**r -> exp(r*log(-p)) -> exp(r*(log(p) + I*Pi)) ->\n1345                   -> p**r*(sin(Pi*r) + cos(Pi*r)*I)\n1346         \"\"\"\n1347         if self == 0:\n1348             if expt.is_positive:\n1349                 return S.Zero\n1350             if expt.is_negative:\n1351                 return S.Infinity\n1352         if isinstance(expt, Number):\n1353             if isinstance(expt, Integer):\n1354                 prec = self._prec\n1355                 return Float._new(\n1356                     mlib.mpf_pow_int(self._mpf_, expt.p, prec, rnd), prec)\n1357             elif isinstance(expt, Rational) and \\\n1358                     expt.p == 1 and expt.q % 2 and self.is_negative:\n1359                 return Pow(S.NegativeOne, expt, evaluate=False)*(\n1360                     -self)._eval_power(expt)\n1361             expt, prec = expt._as_mpf_op(self._prec)\n1362             mpfself = self._mpf_\n1363             try:\n1364                 y = mpf_pow(mpfself, expt, prec, rnd)\n1365                 return Float._new(y, prec)\n1366             except mlib.ComplexResult:\n1367                 re, im = mlib.mpc_pow(\n1368                     (mpfself, fzero), (expt, fzero), prec, rnd)\n1369                 return Float._new(re, prec) + \\\n1370                     Float._new(im, prec)*S.ImaginaryUnit\n1371 \n1372     def __abs__(self):\n1373         return Float._new(mlib.mpf_abs(self._mpf_), self._prec)\n1374 \n1375     def __int__(self):\n1376         if self._mpf_ == fzero:\n1377             return 0\n1378         return int(mlib.to_int(self._mpf_))  # uses round_fast = round_down\n1379 \n1380     def __eq__(self, other):\n1381         from sympy.logic.boolalg import Boolean\n1382         try:\n1383             other = _sympify(other)\n1384         except SympifyError:\n1385             return NotImplemented\n1386         if isinstance(other, Boolean):\n1387             return False\n1388         if other.is_NumberSymbol:\n1389             if other.is_irrational:\n1390                 return False\n1391             return other.__eq__(self)\n1392         if other.is_Float:\n1393             # comparison is exact\n1394             # so Float(.1, 3) != Float(.1, 33)\n1395             return self._mpf_ == other._mpf_\n1396         if other.is_Rational:\n1397             return other.__eq__(self)\n1398         if other.is_Number:\n1399             # numbers should compare at the same precision;\n1400             # all _as_mpf_val routines should be sure to abide\n1401             # by the request to change the prec if necessary; if\n1402             # they don't, the equality test will fail since it compares\n1403             # the mpf tuples\n1404             ompf = other._as_mpf_val(self._prec)\n1405             return bool(mlib.mpf_eq(self._mpf_, ompf))\n1406         if not self:\n1407             return not other\n1408         return False    # Float != non-Number\n1409 \n1410     def __ne__(self, other):\n1411         return not self == other\n1412 \n1413     def _Frel(self, other, op):\n1414         from sympy.core.numbers import prec_to_dps\n1415         try:\n1416             other = _sympify(other)\n1417         except SympifyError:\n1418             return NotImplemented\n1419         if other.is_Rational:\n1420             # test self*other.q <?> other.p without losing precision\n1421             '''\n1422             >>> f = Float(.1,2)\n1423             >>> i = 1234567890\n1424             >>> (f*i)._mpf_\n1425             (0, 471, 18, 9)\n1426             >>> mlib.mpf_mul(f._mpf_, mlib.from_int(i))\n1427             (0, 505555550955, -12, 39)\n1428             '''\n1429             smpf = mlib.mpf_mul(self._mpf_, mlib.from_int(other.q))\n1430             ompf = mlib.from_int(other.p)\n1431             return _sympify(bool(op(smpf, ompf)))\n1432         elif other.is_Float:\n1433             return _sympify(bool(\n1434                         op(self._mpf_, other._mpf_)))\n1435         elif other.is_comparable and other not in (\n1436                 S.Infinity, S.NegativeInfinity):\n1437             other = other.evalf(prec_to_dps(self._prec))\n1438             if other._prec > 1:\n1439                 if other.is_Number:\n1440                     return _sympify(bool(\n1441                         op(self._mpf_, other._as_mpf_val(self._prec))))\n1442 \n1443     def __gt__(self, other):\n1444         if isinstance(other, NumberSymbol):\n1445             return other.__lt__(self)\n1446         rv = self._Frel(other, mlib.mpf_gt)\n1447         if rv is None:\n1448             return Expr.__gt__(self, other)\n1449         return rv\n1450 \n1451     def __ge__(self, other):\n1452         if isinstance(other, NumberSymbol):\n1453             return other.__le__(self)\n1454         rv = self._Frel(other, mlib.mpf_ge)\n1455         if rv is None:\n1456             return Expr.__ge__(self, other)\n1457         return rv\n1458 \n1459     def __lt__(self, other):\n1460         if isinstance(other, NumberSymbol):\n1461             return other.__gt__(self)\n1462         rv = self._Frel(other, mlib.mpf_lt)\n1463         if rv is None:\n1464             return Expr.__lt__(self, other)\n1465         return rv\n1466 \n1467     def __le__(self, other):\n1468         if isinstance(other, NumberSymbol):\n1469             return other.__ge__(self)\n1470         rv = self._Frel(other, mlib.mpf_le)\n1471         if rv is None:\n1472             return Expr.__le__(self, other)\n1473         return rv\n1474 \n1475     def __hash__(self):\n1476         return super().__hash__()\n1477 \n1478     def epsilon_eq(self, other, epsilon=\"1e-15\"):\n1479         return abs(self - other) < Float(epsilon)\n1480 \n1481     def _sage_(self):\n1482         import sage.all as sage\n1483         return sage.RealNumber(str(self))\n1484 \n1485     def __format__(self, format_spec):\n1486         return format(decimal.Decimal(str(self)), format_spec)\n1487 \n1488 \n1489 # Add sympify converters\n1490 converter[float] = converter[decimal.Decimal] = Float\n1491 \n1492 # this is here to work nicely in Sage\n1493 RealNumber = Float\n1494 \n1495 \n1496 class Rational(Number):\n1497     \"\"\"Represents rational numbers (p/q) of any size.\n1498 \n1499     Examples\n1500     ========\n1501 \n1502     >>> from sympy import Rational, nsimplify, S, pi\n1503     >>> Rational(1, 2)\n1504     1/2\n1505 \n1506     Rational is unprejudiced in accepting input. If a float is passed, the\n1507     underlying value of the binary representation will be returned:\n1508 \n1509     >>> Rational(.5)\n1510     1/2\n1511     >>> Rational(.2)\n1512     3602879701896397/18014398509481984\n1513 \n1514     If the simpler representation of the float is desired then consider\n1515     limiting the denominator to the desired value or convert the float to\n1516     a string (which is roughly equivalent to limiting the denominator to\n1517     10**12):\n1518 \n1519     >>> Rational(str(.2))\n1520     1/5\n1521     >>> Rational(.2).limit_denominator(10**12)\n1522     1/5\n1523 \n1524     An arbitrarily precise Rational is obtained when a string literal is\n1525     passed:\n1526 \n1527     >>> Rational(\"1.23\")\n1528     123/100\n1529     >>> Rational('1e-2')\n1530     1/100\n1531     >>> Rational(\".1\")\n1532     1/10\n1533     >>> Rational('1e-2/3.2')\n1534     1/320\n1535 \n1536     The conversion of other types of strings can be handled by\n1537     the sympify() function, and conversion of floats to expressions\n1538     or simple fractions can be handled with nsimplify:\n1539 \n1540     >>> S('.[3]')  # repeating digits in brackets\n1541     1/3\n1542     >>> S('3**2/10')  # general expressions\n1543     9/10\n1544     >>> nsimplify(.3)  # numbers that have a simple form\n1545     3/10\n1546 \n1547     But if the input does not reduce to a literal Rational, an error will\n1548     be raised:\n1549 \n1550     >>> Rational(pi)\n1551     Traceback (most recent call last):\n1552     ...\n1553     TypeError: invalid input: pi\n1554 \n1555 \n1556     Low-level\n1557     ---------\n1558 \n1559     Access numerator and denominator as .p and .q:\n1560 \n1561     >>> r = Rational(3, 4)\n1562     >>> r\n1563     3/4\n1564     >>> r.p\n1565     3\n1566     >>> r.q\n1567     4\n1568 \n1569     Note that p and q return integers (not SymPy Integers) so some care\n1570     is needed when using them in expressions:\n1571 \n1572     >>> r.p/r.q\n1573     0.75\n1574 \n1575     See Also\n1576     ========\n1577     sympy.core.sympify.sympify, sympy.simplify.simplify.nsimplify\n1578     \"\"\"\n1579     is_real = True\n1580     is_integer = False\n1581     is_rational = True\n1582     is_number = True\n1583 \n1584     __slots__ = ('p', 'q')\n1585 \n1586     is_Rational = True\n1587 \n1588     @cacheit\n1589     def __new__(cls, p, q=None, gcd=None):\n1590         if q is None:\n1591             if isinstance(p, Rational):\n1592                 return p\n1593 \n1594             if isinstance(p, SYMPY_INTS):\n1595                 pass\n1596             else:\n1597                 if isinstance(p, (float, Float)):\n1598                     return Rational(*_as_integer_ratio(p))\n1599 \n1600                 if not isinstance(p, str):\n1601                     try:\n1602                         p = sympify(p)\n1603                     except (SympifyError, SyntaxError):\n1604                         pass  # error will raise below\n1605                 else:\n1606                     if p.count('/') > 1:\n1607                         raise TypeError('invalid input: %s' % p)\n1608                     p = p.replace(' ', '')\n1609                     pq = p.rsplit('/', 1)\n1610                     if len(pq) == 2:\n1611                         p, q = pq\n1612                         fp = fractions.Fraction(p)\n1613                         fq = fractions.Fraction(q)\n1614                         p = fp/fq\n1615                     try:\n1616                         p = fractions.Fraction(p)\n1617                     except ValueError:\n1618                         pass  # error will raise below\n1619                     else:\n1620                         return Rational(p.numerator, p.denominator, 1)\n1621 \n1622                 if not isinstance(p, Rational):\n1623                     raise TypeError('invalid input: %s' % p)\n1624 \n1625             q = 1\n1626             gcd = 1\n1627         else:\n1628             p = Rational(p)\n1629             q = Rational(q)\n1630 \n1631         if isinstance(q, Rational):\n1632             p *= q.q\n1633             q = q.p\n1634         if isinstance(p, Rational):\n1635             q *= p.q\n1636             p = p.p\n1637 \n1638         # p and q are now integers\n1639         if q == 0:\n1640             if p == 0:\n1641                 if _errdict[\"divide\"]:\n1642                     raise ValueError(\"Indeterminate 0/0\")\n1643                 else:\n1644                     return S.NaN\n1645             return S.ComplexInfinity\n1646         if q < 0:\n1647             q = -q\n1648             p = -p\n1649         if not gcd:\n1650             gcd = igcd(abs(p), q)\n1651         if gcd > 1:\n1652             p //= gcd\n1653             q //= gcd\n1654         if q == 1:\n1655             return Integer(p)\n1656         if p == 1 and q == 2:\n1657             return S.Half\n1658         obj = Expr.__new__(cls)\n1659         obj.p = p\n1660         obj.q = q\n1661         return obj\n1662 \n1663     def limit_denominator(self, max_denominator=1000000):\n1664         \"\"\"Closest Rational to self with denominator at most max_denominator.\n1665 \n1666         Examples\n1667         ========\n1668 \n1669         >>> from sympy import Rational\n1670         >>> Rational('3.141592653589793').limit_denominator(10)\n1671         22/7\n1672         >>> Rational('3.141592653589793').limit_denominator(100)\n1673         311/99\n1674 \n1675         \"\"\"\n1676         f = fractions.Fraction(self.p, self.q)\n1677         return Rational(f.limit_denominator(fractions.Fraction(int(max_denominator))))\n1678 \n1679     def __getnewargs__(self):\n1680         return (self.p, self.q)\n1681 \n1682     def _hashable_content(self):\n1683         return (self.p, self.q)\n1684 \n1685     def _eval_is_positive(self):\n1686         return self.p > 0\n1687 \n1688     def _eval_is_zero(self):\n1689         return self.p == 0\n1690 \n1691     def __neg__(self):\n1692         return Rational(-self.p, self.q)\n1693 \n1694     @_sympifyit('other', NotImplemented)\n1695     def __add__(self, other):\n1696         if global_parameters.evaluate:\n1697             if isinstance(other, Integer):\n1698                 return Rational(self.p + self.q*other.p, self.q, 1)\n1699             elif isinstance(other, Rational):\n1700                 #TODO: this can probably be optimized more\n1701                 return Rational(self.p*other.q + self.q*other.p, self.q*other.q)\n1702             elif isinstance(other, Float):\n1703                 return other + self\n1704             else:\n1705                 return Number.__add__(self, other)\n1706         return Number.__add__(self, other)\n1707     __radd__ = __add__\n1708 \n1709     @_sympifyit('other', NotImplemented)\n1710     def __sub__(self, other):\n1711         if global_parameters.evaluate:\n1712             if isinstance(other, Integer):\n1713                 return Rational(self.p - self.q*other.p, self.q, 1)\n1714             elif isinstance(other, Rational):\n1715                 return Rational(self.p*other.q - self.q*other.p, self.q*other.q)\n1716             elif isinstance(other, Float):\n1717                 return -other + self\n1718             else:\n1719                 return Number.__sub__(self, other)\n1720         return Number.__sub__(self, other)\n1721     @_sympifyit('other', NotImplemented)\n1722     def __rsub__(self, other):\n1723         if global_parameters.evaluate:\n1724             if isinstance(other, Integer):\n1725                 return Rational(self.q*other.p - self.p, self.q, 1)\n1726             elif isinstance(other, Rational):\n1727                 return Rational(self.q*other.p - self.p*other.q, self.q*other.q)\n1728             elif isinstance(other, Float):\n1729                 return -self + other\n1730             else:\n1731                 return Number.__rsub__(self, other)\n1732         return Number.__rsub__(self, other)\n1733     @_sympifyit('other', NotImplemented)\n1734     def __mul__(self, other):\n1735         if global_parameters.evaluate:\n1736             if isinstance(other, Integer):\n1737                 return Rational(self.p*other.p, self.q, igcd(other.p, self.q))\n1738             elif isinstance(other, Rational):\n1739                 return Rational(self.p*other.p, self.q*other.q, igcd(self.p, other.q)*igcd(self.q, other.p))\n1740             elif isinstance(other, Float):\n1741                 return other*self\n1742             else:\n1743                 return Number.__mul__(self, other)\n1744         return Number.__mul__(self, other)\n1745     __rmul__ = __mul__\n1746 \n1747     @_sympifyit('other', NotImplemented)\n1748     def __truediv__(self, other):\n1749         if global_parameters.evaluate:\n1750             if isinstance(other, Integer):\n1751                 if self.p and other.p == S.Zero:\n1752                     return S.ComplexInfinity\n1753                 else:\n1754                     return Rational(self.p, self.q*other.p, igcd(self.p, other.p))\n1755             elif isinstance(other, Rational):\n1756                 return Rational(self.p*other.q, self.q*other.p, igcd(self.p, other.p)*igcd(self.q, other.q))\n1757             elif isinstance(other, Float):\n1758                 return self*(1/other)\n1759             else:\n1760                 return Number.__truediv__(self, other)\n1761         return Number.__truediv__(self, other)\n1762     @_sympifyit('other', NotImplemented)\n1763     def __rtruediv__(self, other):\n1764         if global_parameters.evaluate:\n1765             if isinstance(other, Integer):\n1766                 return Rational(other.p*self.q, self.p, igcd(self.p, other.p))\n1767             elif isinstance(other, Rational):\n1768                 return Rational(other.p*self.q, other.q*self.p, igcd(self.p, other.p)*igcd(self.q, other.q))\n1769             elif isinstance(other, Float):\n1770                 return other*(1/self)\n1771             else:\n1772                 return Number.__rtruediv__(self, other)\n1773         return Number.__rtruediv__(self, other)\n1774 \n1775     @_sympifyit('other', NotImplemented)\n1776     def __mod__(self, other):\n1777         if global_parameters.evaluate:\n1778             if isinstance(other, Rational):\n1779                 n = (self.p*other.q) // (other.p*self.q)\n1780                 return Rational(self.p*other.q - n*other.p*self.q, self.q*other.q)\n1781             if isinstance(other, Float):\n1782                 # calculate mod with Rationals, *then* round the answer\n1783                 return Float(self.__mod__(Rational(other)),\n1784                              precision=other._prec)\n1785             return Number.__mod__(self, other)\n1786         return Number.__mod__(self, other)\n1787 \n1788     @_sympifyit('other', NotImplemented)\n1789     def __rmod__(self, other):\n1790         if isinstance(other, Rational):\n1791             return Rational.__mod__(other, self)\n1792         return Number.__rmod__(self, other)\n1793 \n1794     def _eval_power(self, expt):\n1795         if isinstance(expt, Number):\n1796             if isinstance(expt, Float):\n1797                 return self._eval_evalf(expt._prec)**expt\n1798             if expt.is_extended_negative:\n1799                 # (3/4)**-2 -> (4/3)**2\n1800                 ne = -expt\n1801                 if (ne is S.One):\n1802                     return Rational(self.q, self.p)\n1803                 if self.is_negative:\n1804                     return S.NegativeOne**expt*Rational(self.q, -self.p)**ne\n1805                 else:\n1806                     return Rational(self.q, self.p)**ne\n1807             if expt is S.Infinity:  # -oo already caught by test for negative\n1808                 if self.p > self.q:\n1809                     # (3/2)**oo -> oo\n1810                     return S.Infinity\n1811                 if self.p < -self.q:\n1812                     # (-3/2)**oo -> oo + I*oo\n1813                     return S.Infinity + S.Infinity*S.ImaginaryUnit\n1814                 return S.Zero\n1815             if isinstance(expt, Integer):\n1816                 # (4/3)**2 -> 4**2 / 3**2\n1817                 return Rational(self.p**expt.p, self.q**expt.p, 1)\n1818             if isinstance(expt, Rational):\n1819                 if self.p != 1:\n1820                     # (4/3)**(5/6) -> 4**(5/6)*3**(-5/6)\n1821                     return Integer(self.p)**expt*Integer(self.q)**(-expt)\n1822                 # as the above caught negative self.p, now self is positive\n1823                 return Integer(self.q)**Rational(\n1824                 expt.p*(expt.q - 1), expt.q) / \\\n1825                     Integer(self.q)**Integer(expt.p)\n1826 \n1827         if self.is_extended_negative and expt.is_even:\n1828             return (-self)**expt\n1829 \n1830         return\n1831 \n1832     def _as_mpf_val(self, prec):\n1833         return mlib.from_rational(self.p, self.q, prec, rnd)\n1834 \n1835     def _mpmath_(self, prec, rnd):\n1836         return mpmath.make_mpf(mlib.from_rational(self.p, self.q, prec, rnd))\n1837 \n1838     def __abs__(self):\n1839         return Rational(abs(self.p), self.q)\n1840 \n1841     def __int__(self):\n1842         p, q = self.p, self.q\n1843         if p < 0:\n1844             return -int(-p//q)\n1845         return int(p//q)\n1846 \n1847     def floor(self):\n1848         return Integer(self.p // self.q)\n1849 \n1850     def ceiling(self):\n1851         return -Integer(-self.p // self.q)\n1852 \n1853     def __floor__(self):\n1854         return self.floor()\n1855 \n1856     def __ceil__(self):\n1857         return self.ceiling()\n1858 \n1859     def __eq__(self, other):\n1860         from sympy.core.power import integer_log\n1861         try:\n1862             other = _sympify(other)\n1863         except SympifyError:\n1864             return NotImplemented\n1865         if not isinstance(other, Number):\n1866             # S(0) == S.false is False\n1867             # S(0) == False is True\n1868             return False\n1869         if not self:\n1870             return not other\n1871         if other.is_NumberSymbol:\n1872             if other.is_irrational:\n1873                 return False\n1874             return other.__eq__(self)\n1875         if other.is_Rational:\n1876             # a Rational is always in reduced form so will never be 2/4\n1877             # so we can just check equivalence of args\n1878             return self.p == other.p and self.q == other.q\n1879         if other.is_Float:\n1880             # all Floats have a denominator that is a power of 2\n1881             # so if self doesn't, it can't be equal to other\n1882             if self.q & (self.q - 1):\n1883                 return False\n1884             s, m, t = other._mpf_[:3]\n1885             if s:\n1886                 m = -m\n1887             if not t:\n1888                 # other is an odd integer\n1889                 if not self.is_Integer or self.is_even:\n1890                     return False\n1891                 return m == self.p\n1892             if t > 0:\n1893                 # other is an even integer\n1894                 if not self.is_Integer:\n1895                     return False\n1896                 # does m*2**t == self.p\n1897                 return self.p and not self.p % m and \\\n1898                     integer_log(self.p//m, 2) == (t, True)\n1899             # does non-integer s*m/2**-t = p/q?\n1900             if self.is_Integer:\n1901                 return False\n1902             return m == self.p and integer_log(self.q, 2) == (-t, True)\n1903         return False\n1904 \n1905     def __ne__(self, other):\n1906         return not self == other\n1907 \n1908     def _Rrel(self, other, attr):\n1909         # if you want self < other, pass self, other, __gt__\n1910         try:\n1911             other = _sympify(other)\n1912         except SympifyError:\n1913             return NotImplemented\n1914         if other.is_Number:\n1915             op = None\n1916             s, o = self, other\n1917             if other.is_NumberSymbol:\n1918                 op = getattr(o, attr)\n1919             elif other.is_Float:\n1920                 op = getattr(o, attr)\n1921             elif other.is_Rational:\n1922                 s, o = Integer(s.p*o.q), Integer(s.q*o.p)\n1923                 op = getattr(o, attr)\n1924             if op:\n1925                 return op(s)\n1926             if o.is_number and o.is_extended_real:\n1927                 return Integer(s.p), s.q*o\n1928 \n1929     def __gt__(self, other):\n1930         rv = self._Rrel(other, '__lt__')\n1931         if rv is None:\n1932             rv = self, other\n1933         elif not type(rv) is tuple:\n1934             return rv\n1935         return Expr.__gt__(*rv)\n1936 \n1937     def __ge__(self, other):\n1938         rv = self._Rrel(other, '__le__')\n1939         if rv is None:\n1940             rv = self, other\n1941         elif not type(rv) is tuple:\n1942             return rv\n1943         return Expr.__ge__(*rv)\n1944 \n1945     def __lt__(self, other):\n1946         rv = self._Rrel(other, '__gt__')\n1947         if rv is None:\n1948             rv = self, other\n1949         elif not type(rv) is tuple:\n1950             return rv\n1951         return Expr.__lt__(*rv)\n1952 \n1953     def __le__(self, other):\n1954         rv = self._Rrel(other, '__ge__')\n1955         if rv is None:\n1956             rv = self, other\n1957         elif not type(rv) is tuple:\n1958             return rv\n1959         return Expr.__le__(*rv)\n1960 \n1961     def __hash__(self):\n1962         return super().__hash__()\n1963 \n1964     def factors(self, limit=None, use_trial=True, use_rho=False,\n1965                 use_pm1=False, verbose=False, visual=False):\n1966         \"\"\"A wrapper to factorint which return factors of self that are\n1967         smaller than limit (or cheap to compute). Special methods of\n1968         factoring are disabled by default so that only trial division is used.\n1969         \"\"\"\n1970         from sympy.ntheory import factorrat\n1971 \n1972         return factorrat(self, limit=limit, use_trial=use_trial,\n1973                       use_rho=use_rho, use_pm1=use_pm1,\n1974                       verbose=verbose).copy()\n1975 \n1976     @property\n1977     def numerator(self):\n1978         return self.p\n1979 \n1980     @property\n1981     def denominator(self):\n1982         return self.q\n1983 \n1984     @_sympifyit('other', NotImplemented)\n1985     def gcd(self, other):\n1986         if isinstance(other, Rational):\n1987             if other == S.Zero:\n1988                 return other\n1989             return Rational(\n1990                 Integer(igcd(self.p, other.p)),\n1991                 Integer(ilcm(self.q, other.q)))\n1992         return Number.gcd(self, other)\n1993 \n1994     @_sympifyit('other', NotImplemented)\n1995     def lcm(self, other):\n1996         if isinstance(other, Rational):\n1997             return Rational(\n1998                 self.p // igcd(self.p, other.p) * other.p,\n1999                 igcd(self.q, other.q))\n2000         return Number.lcm(self, other)\n2001 \n2002     def as_numer_denom(self):\n2003         return Integer(self.p), Integer(self.q)\n2004 \n2005     def _sage_(self):\n2006         import sage.all as sage\n2007         return sage.Integer(self.p)/sage.Integer(self.q)\n2008 \n2009     def as_content_primitive(self, radical=False, clear=True):\n2010         \"\"\"Return the tuple (R, self/R) where R is the positive Rational\n2011         extracted from self.\n2012 \n2013         Examples\n2014         ========\n2015 \n2016         >>> from sympy import S\n2017         >>> (S(-3)/2).as_content_primitive()\n2018         (3/2, -1)\n2019 \n2020         See docstring of Expr.as_content_primitive for more examples.\n2021         \"\"\"\n2022 \n2023         if self:\n2024             if self.is_positive:\n2025                 return self, S.One\n2026             return -self, S.NegativeOne\n2027         return S.One, self\n2028 \n2029     def as_coeff_Mul(self, rational=False):\n2030         \"\"\"Efficiently extract the coefficient of a product. \"\"\"\n2031         return self, S.One\n2032 \n2033     def as_coeff_Add(self, rational=False):\n2034         \"\"\"Efficiently extract the coefficient of a summation. \"\"\"\n2035         return self, S.Zero\n2036 \n2037 \n2038 class Integer(Rational):\n2039     \"\"\"Represents integer numbers of any size.\n2040 \n2041     Examples\n2042     ========\n2043 \n2044     >>> from sympy import Integer\n2045     >>> Integer(3)\n2046     3\n2047 \n2048     If a float or a rational is passed to Integer, the fractional part\n2049     will be discarded; the effect is of rounding toward zero.\n2050 \n2051     >>> Integer(3.8)\n2052     3\n2053     >>> Integer(-3.8)\n2054     -3\n2055 \n2056     A string is acceptable input if it can be parsed as an integer:\n2057 \n2058     >>> Integer(\"9\" * 20)\n2059     99999999999999999999\n2060 \n2061     It is rarely needed to explicitly instantiate an Integer, because\n2062     Python integers are automatically converted to Integer when they\n2063     are used in SymPy expressions.\n2064     \"\"\"\n2065     q = 1\n2066     is_integer = True\n2067     is_number = True\n2068 \n2069     is_Integer = True\n2070 \n2071     __slots__ = ('p',)\n2072 \n2073     def _as_mpf_val(self, prec):\n2074         return mlib.from_int(self.p, prec, rnd)\n2075 \n2076     def _mpmath_(self, prec, rnd):\n2077         return mpmath.make_mpf(self._as_mpf_val(prec))\n2078 \n2079     @cacheit\n2080     def __new__(cls, i):\n2081         if isinstance(i, str):\n2082             i = i.replace(' ', '')\n2083         # whereas we cannot, in general, make a Rational from an\n2084         # arbitrary expression, we can make an Integer unambiguously\n2085         # (except when a non-integer expression happens to round to\n2086         # an integer). So we proceed by taking int() of the input and\n2087         # let the int routines determine whether the expression can\n2088         # be made into an int or whether an error should be raised.\n2089         try:\n2090             ival = int(i)\n2091         except TypeError:\n2092             raise TypeError(\n2093                 \"Argument of Integer should be of numeric type, got %s.\" % i)\n2094         # We only work with well-behaved integer types. This converts, for\n2095         # example, numpy.int32 instances.\n2096         if ival == 1:\n2097             return S.One\n2098         if ival == -1:\n2099             return S.NegativeOne\n2100         if ival == 0:\n2101             return S.Zero\n2102         obj = Expr.__new__(cls)\n2103         obj.p = ival\n2104         return obj\n2105 \n2106     def __getnewargs__(self):\n2107         return (self.p,)\n2108 \n2109     # Arithmetic operations are here for efficiency\n2110     def __int__(self):\n2111         return self.p\n2112 \n2113     def floor(self):\n2114         return Integer(self.p)\n2115 \n2116     def ceiling(self):\n2117         return Integer(self.p)\n2118 \n2119     def __floor__(self):\n2120         return self.floor()\n2121 \n2122     def __ceil__(self):\n2123         return self.ceiling()\n2124 \n2125     def __neg__(self):\n2126         return Integer(-self.p)\n2127 \n2128     def __abs__(self):\n2129         if self.p >= 0:\n2130             return self\n2131         else:\n2132             return Integer(-self.p)\n2133 \n2134     def __divmod__(self, other):\n2135         from .containers import Tuple\n2136         if isinstance(other, Integer) and global_parameters.evaluate:\n2137             return Tuple(*(divmod(self.p, other.p)))\n2138         else:\n2139             return Number.__divmod__(self, other)\n2140 \n2141     def __rdivmod__(self, other):\n2142         from .containers import Tuple\n2143         if isinstance(other, int) and global_parameters.evaluate:\n2144             return Tuple(*(divmod(other, self.p)))\n2145         else:\n2146             try:\n2147                 other = Number(other)\n2148             except TypeError:\n2149                 msg = \"unsupported operand type(s) for divmod(): '%s' and '%s'\"\n2150                 oname = type(other).__name__\n2151                 sname = type(self).__name__\n2152                 raise TypeError(msg % (oname, sname))\n2153             return Number.__divmod__(other, self)\n2154 \n2155     # TODO make it decorator + bytecodehacks?\n2156     def __add__(self, other):\n2157         if global_parameters.evaluate:\n2158             if isinstance(other, int):\n2159                 return Integer(self.p + other)\n2160             elif isinstance(other, Integer):\n2161                 return Integer(self.p + other.p)\n2162             elif isinstance(other, Rational):\n2163                 return Rational(self.p*other.q + other.p, other.q, 1)\n2164             return Rational.__add__(self, other)\n2165         else:\n2166             return Add(self, other)\n2167 \n2168     def __radd__(self, other):\n2169         if global_parameters.evaluate:\n2170             if isinstance(other, int):\n2171                 return Integer(other + self.p)\n2172             elif isinstance(other, Rational):\n2173                 return Rational(other.p + self.p*other.q, other.q, 1)\n2174             return Rational.__radd__(self, other)\n2175         return Rational.__radd__(self, other)\n2176 \n2177     def __sub__(self, other):\n2178         if global_parameters.evaluate:\n2179             if isinstance(other, int):\n2180                 return Integer(self.p - other)\n2181             elif isinstance(other, Integer):\n2182                 return Integer(self.p - other.p)\n2183             elif isinstance(other, Rational):\n2184                 return Rational(self.p*other.q - other.p, other.q, 1)\n2185             return Rational.__sub__(self, other)\n2186         return Rational.__sub__(self, other)\n2187 \n2188     def __rsub__(self, other):\n2189         if global_parameters.evaluate:\n2190             if isinstance(other, int):\n2191                 return Integer(other - self.p)\n2192             elif isinstance(other, Rational):\n2193                 return Rational(other.p - self.p*other.q, other.q, 1)\n2194             return Rational.__rsub__(self, other)\n2195         return Rational.__rsub__(self, other)\n2196 \n2197     def __mul__(self, other):\n2198         if global_parameters.evaluate:\n2199             if isinstance(other, int):\n2200                 return Integer(self.p*other)\n2201             elif isinstance(other, Integer):\n2202                 return Integer(self.p*other.p)\n2203             elif isinstance(other, Rational):\n2204                 return Rational(self.p*other.p, other.q, igcd(self.p, other.q))\n2205             return Rational.__mul__(self, other)\n2206         return Rational.__mul__(self, other)\n2207 \n2208     def __rmul__(self, other):\n2209         if global_parameters.evaluate:\n2210             if isinstance(other, int):\n2211                 return Integer(other*self.p)\n2212             elif isinstance(other, Rational):\n2213                 return Rational(other.p*self.p, other.q, igcd(self.p, other.q))\n2214             return Rational.__rmul__(self, other)\n2215         return Rational.__rmul__(self, other)\n2216 \n2217     def __mod__(self, other):\n2218         if global_parameters.evaluate:\n2219             if isinstance(other, int):\n2220                 return Integer(self.p % other)\n2221             elif isinstance(other, Integer):\n2222                 return Integer(self.p % other.p)\n2223             return Rational.__mod__(self, other)\n2224         return Rational.__mod__(self, other)\n2225 \n2226     def __rmod__(self, other):\n2227         if global_parameters.evaluate:\n2228             if isinstance(other, int):\n2229                 return Integer(other % self.p)\n2230             elif isinstance(other, Integer):\n2231                 return Integer(other.p % self.p)\n2232             return Rational.__rmod__(self, other)\n2233         return Rational.__rmod__(self, other)\n2234 \n2235     def __eq__(self, other):\n2236         if isinstance(other, int):\n2237             return (self.p == other)\n2238         elif isinstance(other, Integer):\n2239             return (self.p == other.p)\n2240         return Rational.__eq__(self, other)\n2241 \n2242     def __ne__(self, other):\n2243         return not self == other\n2244 \n2245     def __gt__(self, other):\n2246         try:\n2247             other = _sympify(other)\n2248         except SympifyError:\n2249             return NotImplemented\n2250         if other.is_Integer:\n2251             return _sympify(self.p > other.p)\n2252         return Rational.__gt__(self, other)\n2253 \n2254     def __lt__(self, other):\n2255         try:\n2256             other = _sympify(other)\n2257         except SympifyError:\n2258             return NotImplemented\n2259         if other.is_Integer:\n2260             return _sympify(self.p < other.p)\n2261         return Rational.__lt__(self, other)\n2262 \n2263     def __ge__(self, other):\n2264         try:\n2265             other = _sympify(other)\n2266         except SympifyError:\n2267             return NotImplemented\n2268         if other.is_Integer:\n2269             return _sympify(self.p >= other.p)\n2270         return Rational.__ge__(self, other)\n2271 \n2272     def __le__(self, other):\n2273         try:\n2274             other = _sympify(other)\n2275         except SympifyError:\n2276             return NotImplemented\n2277         if other.is_Integer:\n2278             return _sympify(self.p <= other.p)\n2279         return Rational.__le__(self, other)\n2280 \n2281     def __hash__(self):\n2282         return hash(self.p)\n2283 \n2284     def __index__(self):\n2285         return self.p\n2286 \n2287     ########################################\n2288 \n2289     def _eval_is_odd(self):\n2290         return bool(self.p % 2)\n2291 \n2292     def _eval_power(self, expt):\n2293         \"\"\"\n2294         Tries to do some simplifications on self**expt\n2295 \n2296         Returns None if no further simplifications can be done.\n2297 \n2298         Explanation\n2299         ===========\n2300 \n2301         When exponent is a fraction (so we have for example a square root),\n2302         we try to find a simpler representation by factoring the argument\n2303         up to factors of 2**15, e.g.\n2304 \n2305           - sqrt(4) becomes 2\n2306           - sqrt(-4) becomes 2*I\n2307           - (2**(3+7)*3**(6+7))**Rational(1,7) becomes 6*18**(3/7)\n2308 \n2309         Further simplification would require a special call to factorint on\n2310         the argument which is not done here for sake of speed.\n2311 \n2312         \"\"\"\n2313         from sympy.ntheory.factor_ import perfect_power\n2314 \n2315         if expt is S.Infinity:\n2316             if self.p > S.One:\n2317                 return S.Infinity\n2318             # cases -1, 0, 1 are done in their respective classes\n2319             return S.Infinity + S.ImaginaryUnit*S.Infinity\n2320         if expt is S.NegativeInfinity:\n2321             return Rational(1, self)**S.Infinity\n2322         if not isinstance(expt, Number):\n2323             # simplify when expt is even\n2324             # (-2)**k --> 2**k\n2325             if self.is_negative and expt.is_even:\n2326                 return (-self)**expt\n2327         if isinstance(expt, Float):\n2328             # Rational knows how to exponentiate by a Float\n2329             return super()._eval_power(expt)\n2330         if not isinstance(expt, Rational):\n2331             return\n2332         if expt is S.Half and self.is_negative:\n2333             # we extract I for this special case since everyone is doing so\n2334             return S.ImaginaryUnit*Pow(-self, expt)\n2335         if expt.is_negative:\n2336             # invert base and change sign on exponent\n2337             ne = -expt\n2338             if self.is_negative:\n2339                     return S.NegativeOne**expt*Rational(1, -self)**ne\n2340             else:\n2341                 return Rational(1, self.p)**ne\n2342         # see if base is a perfect root, sqrt(4) --> 2\n2343         x, xexact = integer_nthroot(abs(self.p), expt.q)\n2344         if xexact:\n2345             # if it's a perfect root we've finished\n2346             result = Integer(x**abs(expt.p))\n2347             if self.is_negative:\n2348                 result *= S.NegativeOne**expt\n2349             return result\n2350 \n2351         # The following is an algorithm where we collect perfect roots\n2352         # from the factors of base.\n2353 \n2354         # if it's not an nth root, it still might be a perfect power\n2355         b_pos = int(abs(self.p))\n2356         p = perfect_power(b_pos)\n2357         if p is not False:\n2358             dict = {p[0]: p[1]}\n2359         else:\n2360             dict = Integer(b_pos).factors(limit=2**15)\n2361 \n2362         # now process the dict of factors\n2363         out_int = 1  # integer part\n2364         out_rad = 1  # extracted radicals\n2365         sqr_int = 1\n2366         sqr_gcd = 0\n2367         sqr_dict = {}\n2368         for prime, exponent in dict.items():\n2369             exponent *= expt.p\n2370             # remove multiples of expt.q: (2**12)**(1/10) -> 2*(2**2)**(1/10)\n2371             div_e, div_m = divmod(exponent, expt.q)\n2372             if div_e > 0:\n2373                 out_int *= prime**div_e\n2374             if div_m > 0:\n2375                 # see if the reduced exponent shares a gcd with e.q\n2376                 # (2**2)**(1/10) -> 2**(1/5)\n2377                 g = igcd(div_m, expt.q)\n2378                 if g != 1:\n2379                     out_rad *= Pow(prime, Rational(div_m//g, expt.q//g))\n2380                 else:\n2381                     sqr_dict[prime] = div_m\n2382         # identify gcd of remaining powers\n2383         for p, ex in sqr_dict.items():\n2384             if sqr_gcd == 0:\n2385                 sqr_gcd = ex\n2386             else:\n2387                 sqr_gcd = igcd(sqr_gcd, ex)\n2388                 if sqr_gcd == 1:\n2389                     break\n2390         for k, v in sqr_dict.items():\n2391             sqr_int *= k**(v//sqr_gcd)\n2392         if sqr_int == b_pos and out_int == 1 and out_rad == 1:\n2393             result = None\n2394         else:\n2395             result = out_int*out_rad*Pow(sqr_int, Rational(sqr_gcd, expt.q))\n2396             if self.is_negative:\n2397                 result *= Pow(S.NegativeOne, expt)\n2398         return result\n2399 \n2400     def _eval_is_prime(self):\n2401         from sympy.ntheory import isprime\n2402 \n2403         return isprime(self)\n2404 \n2405     def _eval_is_composite(self):\n2406         if self > 1:\n2407             return fuzzy_not(self.is_prime)\n2408         else:\n2409             return False\n2410 \n2411     def as_numer_denom(self):\n2412         return self, S.One\n2413 \n2414     @_sympifyit('other', NotImplemented)\n2415     def __floordiv__(self, other):\n2416         if not isinstance(other, Expr):\n2417             return NotImplemented\n2418         if isinstance(other, Integer):\n2419             return Integer(self.p // other)\n2420         return Integer(divmod(self, other)[0])\n2421 \n2422     def __rfloordiv__(self, other):\n2423         return Integer(Integer(other).p // self.p)\n2424 \n2425 # Add sympify converters\n2426 converter[int] = Integer\n2427 \n2428 \n2429 class AlgebraicNumber(Expr):\n2430     \"\"\"Class for representing algebraic numbers in SymPy. \"\"\"\n2431 \n2432     __slots__ = ('rep', 'root', 'alias', 'minpoly')\n2433 \n2434     is_AlgebraicNumber = True\n2435     is_algebraic = True\n2436     is_number = True\n2437 \n2438 \n2439     kind = NumberKind\n2440 \n2441     # Optional alias symbol is not free.\n2442     # Actually, alias should be a Str, but some methods\n2443     # expect that it be an instance of Expr.\n2444     free_symbols = set()\n2445 \n2446     def __new__(cls, expr, coeffs=None, alias=None, **args):\n2447         \"\"\"Construct a new algebraic number. \"\"\"\n2448         from sympy import Poly\n2449         from sympy.polys.polyclasses import ANP, DMP\n2450         from sympy.polys.numberfields import minimal_polynomial\n2451         from sympy.core.symbol import Symbol\n2452 \n2453         expr = sympify(expr)\n2454 \n2455         if isinstance(expr, (tuple, Tuple)):\n2456             minpoly, root = expr\n2457 \n2458             if not minpoly.is_Poly:\n2459                 minpoly = Poly(minpoly)\n2460         elif expr.is_AlgebraicNumber:\n2461             minpoly, root = expr.minpoly, expr.root\n2462         else:\n2463             minpoly, root = minimal_polynomial(\n2464                 expr, args.get('gen'), polys=True), expr\n2465 \n2466         dom = minpoly.get_domain()\n2467 \n2468         if coeffs is not None:\n2469             if not isinstance(coeffs, ANP):\n2470                 rep = DMP.from_sympy_list(sympify(coeffs), 0, dom)\n2471                 scoeffs = Tuple(*coeffs)\n2472             else:\n2473                 rep = DMP.from_list(coeffs.to_list(), 0, dom)\n2474                 scoeffs = Tuple(*coeffs.to_list())\n2475 \n2476             if rep.degree() >= minpoly.degree():\n2477                 rep = rep.rem(minpoly.rep)\n2478 \n2479         else:\n2480             rep = DMP.from_list([1, 0], 0, dom)\n2481             scoeffs = Tuple(1, 0)\n2482 \n2483         sargs = (root, scoeffs)\n2484 \n2485         if alias is not None:\n2486             if not isinstance(alias, Symbol):\n2487                 alias = Symbol(alias)\n2488             sargs = sargs + (alias,)\n2489 \n2490         obj = Expr.__new__(cls, *sargs)\n2491 \n2492         obj.rep = rep\n2493         obj.root = root\n2494         obj.alias = alias\n2495         obj.minpoly = minpoly\n2496 \n2497         return obj\n2498 \n2499     def __hash__(self):\n2500         return super().__hash__()\n2501 \n2502     def _eval_evalf(self, prec):\n2503         return self.as_expr()._evalf(prec)\n2504 \n2505     @property\n2506     def is_aliased(self):\n2507         \"\"\"Returns ``True`` if ``alias`` was set. \"\"\"\n2508         return self.alias is not None\n2509 \n2510     def as_poly(self, x=None):\n2511         \"\"\"Create a Poly instance from ``self``. \"\"\"\n2512         from sympy import Dummy, Poly, PurePoly\n2513         if x is not None:\n2514             return Poly.new(self.rep, x)\n2515         else:\n2516             if self.alias is not None:\n2517                 return Poly.new(self.rep, self.alias)\n2518             else:\n2519                 return PurePoly.new(self.rep, Dummy('x'))\n2520 \n2521     def as_expr(self, x=None):\n2522         \"\"\"Create a Basic expression from ``self``. \"\"\"\n2523         return self.as_poly(x or self.root).as_expr().expand()\n2524 \n2525     def coeffs(self):\n2526         \"\"\"Returns all SymPy coefficients of an algebraic number. \"\"\"\n2527         return [ self.rep.dom.to_sympy(c) for c in self.rep.all_coeffs() ]\n2528 \n2529     def native_coeffs(self):\n2530         \"\"\"Returns all native coefficients of an algebraic number. \"\"\"\n2531         return self.rep.all_coeffs()\n2532 \n2533     def to_algebraic_integer(self):\n2534         \"\"\"Convert ``self`` to an algebraic integer. \"\"\"\n2535         from sympy import Poly\n2536         f = self.minpoly\n2537 \n2538         if f.LC() == 1:\n2539             return self\n2540 \n2541         coeff = f.LC()**(f.degree() - 1)\n2542         poly = f.compose(Poly(f.gen/f.LC()))\n2543 \n2544         minpoly = poly*coeff\n2545         root = f.LC()*self.root\n2546 \n2547         return AlgebraicNumber((minpoly, root), self.coeffs())\n2548 \n2549     def _eval_simplify(self, **kwargs):\n2550         from sympy.polys import CRootOf, minpoly\n2551         measure, ratio = kwargs['measure'], kwargs['ratio']\n2552         for r in [r for r in self.minpoly.all_roots() if r.func != CRootOf]:\n2553             if minpoly(self.root - r).is_Symbol:\n2554                 # use the matching root if it's simpler\n2555                 if measure(r) < ratio*measure(self.root):\n2556                     return AlgebraicNumber(r)\n2557         return self\n2558 \n2559 \n2560 class RationalConstant(Rational):\n2561     \"\"\"\n2562     Abstract base class for rationals with specific behaviors\n2563 \n2564     Derived classes must define class attributes p and q and should probably all\n2565     be singletons.\n2566     \"\"\"\n2567     __slots__ = ()\n2568 \n2569     def __new__(cls):\n2570         return AtomicExpr.__new__(cls)\n2571 \n2572 \n2573 class IntegerConstant(Integer):\n2574     __slots__ = ()\n2575 \n2576     def __new__(cls):\n2577         return AtomicExpr.__new__(cls)\n2578 \n2579 \n2580 class Zero(IntegerConstant, metaclass=Singleton):\n2581     \"\"\"The number zero.\n2582 \n2583     Zero is a singleton, and can be accessed by ``S.Zero``\n2584 \n2585     Examples\n2586     ========\n2587 \n2588     >>> from sympy import S, Integer\n2589     >>> Integer(0) is S.Zero\n2590     True\n2591     >>> 1/S.Zero\n2592     zoo\n2593 \n2594     References\n2595     ==========\n2596 \n2597     .. [1] https://en.wikipedia.org/wiki/Zero\n2598     \"\"\"\n2599 \n2600     p = 0\n2601     q = 1\n2602     is_positive = False\n2603     is_negative = False\n2604     is_zero = True\n2605     is_number = True\n2606     is_comparable = True\n2607 \n2608     __slots__ = ()\n2609 \n2610     def __getnewargs__(self):\n2611         return ()\n2612 \n2613     @staticmethod\n2614     def __abs__():\n2615         return S.Zero\n2616 \n2617     @staticmethod\n2618     def __neg__():\n2619         return S.Zero\n2620 \n2621     def _eval_power(self, expt):\n2622         if expt.is_positive:\n2623             return self\n2624         if expt.is_negative:\n2625             return S.ComplexInfinity\n2626         if expt.is_extended_real is False:\n2627             return S.NaN\n2628         # infinities are already handled with pos and neg\n2629         # tests above; now throw away leading numbers on Mul\n2630         # exponent\n2631         coeff, terms = expt.as_coeff_Mul()\n2632         if coeff.is_negative:\n2633             return S.ComplexInfinity**terms\n2634         if coeff is not S.One:  # there is a Number to discard\n2635             return self**terms\n2636 \n2637     def _eval_order(self, *symbols):\n2638         # Order(0,x) -> 0\n2639         return self\n2640 \n2641     def __bool__(self):\n2642         return False\n2643 \n2644     def as_coeff_Mul(self, rational=False):  # XXX this routine should be deleted\n2645         \"\"\"Efficiently extract the coefficient of a summation. \"\"\"\n2646         return S.One, self\n2647 \n2648 \n2649 class One(IntegerConstant, metaclass=Singleton):\n2650     \"\"\"The number one.\n2651 \n2652     One is a singleton, and can be accessed by ``S.One``.\n2653 \n2654     Examples\n2655     ========\n2656 \n2657     >>> from sympy import S, Integer\n2658     >>> Integer(1) is S.One\n2659     True\n2660 \n2661     References\n2662     ==========\n2663 \n2664     .. [1] https://en.wikipedia.org/wiki/1_%28number%29\n2665     \"\"\"\n2666     is_number = True\n2667     is_positive = True\n2668 \n2669     p = 1\n2670     q = 1\n2671 \n2672     __slots__ = ()\n2673 \n2674     def __getnewargs__(self):\n2675         return ()\n2676 \n2677     @staticmethod\n2678     def __abs__():\n2679         return S.One\n2680 \n2681     @staticmethod\n2682     def __neg__():\n2683         return S.NegativeOne\n2684 \n2685     def _eval_power(self, expt):\n2686         return self\n2687 \n2688     def _eval_order(self, *symbols):\n2689         return\n2690 \n2691     @staticmethod\n2692     def factors(limit=None, use_trial=True, use_rho=False, use_pm1=False,\n2693                 verbose=False, visual=False):\n2694         if visual:\n2695             return S.One\n2696         else:\n2697             return {}\n2698 \n2699 \n2700 class NegativeOne(IntegerConstant, metaclass=Singleton):\n2701     \"\"\"The number negative one.\n2702 \n2703     NegativeOne is a singleton, and can be accessed by ``S.NegativeOne``.\n2704 \n2705     Examples\n2706     ========\n2707 \n2708     >>> from sympy import S, Integer\n2709     >>> Integer(-1) is S.NegativeOne\n2710     True\n2711 \n2712     See Also\n2713     ========\n2714 \n2715     One\n2716 \n2717     References\n2718     ==========\n2719 \n2720     .. [1] https://en.wikipedia.org/wiki/%E2%88%921_%28number%29\n2721 \n2722     \"\"\"\n2723     is_number = True\n2724 \n2725     p = -1\n2726     q = 1\n2727 \n2728     __slots__ = ()\n2729 \n2730     def __getnewargs__(self):\n2731         return ()\n2732 \n2733     @staticmethod\n2734     def __abs__():\n2735         return S.One\n2736 \n2737     @staticmethod\n2738     def __neg__():\n2739         return S.One\n2740 \n2741     def _eval_power(self, expt):\n2742         if expt.is_odd:\n2743             return S.NegativeOne\n2744         if expt.is_even:\n2745             return S.One\n2746         if isinstance(expt, Number):\n2747             if isinstance(expt, Float):\n2748                 return Float(-1.0)**expt\n2749             if expt is S.NaN:\n2750                 return S.NaN\n2751             if expt is S.Infinity or expt is S.NegativeInfinity:\n2752                 return S.NaN\n2753             if expt is S.Half:\n2754                 return S.ImaginaryUnit\n2755             if isinstance(expt, Rational):\n2756                 if expt.q == 2:\n2757                     return S.ImaginaryUnit**Integer(expt.p)\n2758                 i, r = divmod(expt.p, expt.q)\n2759                 if i:\n2760                     return self**i*self**Rational(r, expt.q)\n2761         return\n2762 \n2763 \n2764 class Half(RationalConstant, metaclass=Singleton):\n2765     \"\"\"The rational number 1/2.\n2766 \n2767     Half is a singleton, and can be accessed by ``S.Half``.\n2768 \n2769     Examples\n2770     ========\n2771 \n2772     >>> from sympy import S, Rational\n2773     >>> Rational(1, 2) is S.Half\n2774     True\n2775 \n2776     References\n2777     ==========\n2778 \n2779     .. [1] https://en.wikipedia.org/wiki/One_half\n2780     \"\"\"\n2781     is_number = True\n2782 \n2783     p = 1\n2784     q = 2\n2785 \n2786     __slots__ = ()\n2787 \n2788     def __getnewargs__(self):\n2789         return ()\n2790 \n2791     @staticmethod\n2792     def __abs__():\n2793         return S.Half\n2794 \n2795 \n2796 class Infinity(Number, metaclass=Singleton):\n2797     r\"\"\"Positive infinite quantity.\n2798 \n2799     Explanation\n2800     ===========\n2801 \n2802     In real analysis the symbol `\\infty` denotes an unbounded\n2803     limit: `x\\to\\infty` means that `x` grows without bound.\n2804 \n2805     Infinity is often used not only to define a limit but as a value\n2806     in the affinely extended real number system.  Points labeled `+\\infty`\n2807     and `-\\infty` can be added to the topological space of the real numbers,\n2808     producing the two-point compactification of the real numbers.  Adding\n2809     algebraic properties to this gives us the extended real numbers.\n2810 \n2811     Infinity is a singleton, and can be accessed by ``S.Infinity``,\n2812     or can be imported as ``oo``.\n2813 \n2814     Examples\n2815     ========\n2816 \n2817     >>> from sympy import oo, exp, limit, Symbol\n2818     >>> 1 + oo\n2819     oo\n2820     >>> 42/oo\n2821     0\n2822     >>> x = Symbol('x')\n2823     >>> limit(exp(x), x, oo)\n2824     oo\n2825 \n2826     See Also\n2827     ========\n2828 \n2829     NegativeInfinity, NaN\n2830 \n2831     References\n2832     ==========\n2833 \n2834     .. [1] https://en.wikipedia.org/wiki/Infinity\n2835     \"\"\"\n2836 \n2837     is_commutative = True\n2838     is_number = True\n2839     is_complex = False\n2840     is_extended_real = True\n2841     is_infinite = True\n2842     is_comparable = True\n2843     is_extended_positive = True\n2844     is_prime = False\n2845 \n2846     __slots__ = ()\n2847 \n2848     def __new__(cls):\n2849         return AtomicExpr.__new__(cls)\n2850 \n2851     def _latex(self, printer):\n2852         return r\"\\infty\"\n2853 \n2854     def _eval_subs(self, old, new):\n2855         if self == old:\n2856             return new\n2857 \n2858     def _eval_evalf(self, prec=None):\n2859         return Float('inf')\n2860 \n2861     def evalf(self, prec=None, **options):\n2862         return self._eval_evalf(prec)\n2863 \n2864     @_sympifyit('other', NotImplemented)\n2865     def __add__(self, other):\n2866         if isinstance(other, Number) and global_parameters.evaluate:\n2867             if other is S.NegativeInfinity or other is S.NaN:\n2868                 return S.NaN\n2869             return self\n2870         return Number.__add__(self, other)\n2871     __radd__ = __add__\n2872 \n2873     @_sympifyit('other', NotImplemented)\n2874     def __sub__(self, other):\n2875         if isinstance(other, Number) and global_parameters.evaluate:\n2876             if other is S.Infinity or other is S.NaN:\n2877                 return S.NaN\n2878             return self\n2879         return Number.__sub__(self, other)\n2880 \n2881     @_sympifyit('other', NotImplemented)\n2882     def __rsub__(self, other):\n2883         return (-self).__add__(other)\n2884 \n2885     @_sympifyit('other', NotImplemented)\n2886     def __mul__(self, other):\n2887         if isinstance(other, Number) and global_parameters.evaluate:\n2888             if other.is_zero or other is S.NaN:\n2889                 return S.NaN\n2890             if other.is_extended_positive:\n2891                 return self\n2892             return S.NegativeInfinity\n2893         return Number.__mul__(self, other)\n2894     __rmul__ = __mul__\n2895 \n2896     @_sympifyit('other', NotImplemented)\n2897     def __truediv__(self, other):\n2898         if isinstance(other, Number) and global_parameters.evaluate:\n2899             if other is S.Infinity or \\\n2900                 other is S.NegativeInfinity or \\\n2901                     other is S.NaN:\n2902                 return S.NaN\n2903             if other.is_extended_nonnegative:\n2904                 return self\n2905             return S.NegativeInfinity\n2906         return Number.__truediv__(self, other)\n2907 \n2908     def __abs__(self):\n2909         return S.Infinity\n2910 \n2911     def __neg__(self):\n2912         return S.NegativeInfinity\n2913 \n2914     def _eval_power(self, expt):\n2915         \"\"\"\n2916         ``expt`` is symbolic object but not equal to 0 or 1.\n2917 \n2918         ================ ======= ==============================\n2919         Expression       Result  Notes\n2920         ================ ======= ==============================\n2921         ``oo ** nan``    ``nan``\n2922         ``oo ** -p``     ``0``   ``p`` is number, ``oo``\n2923         ================ ======= ==============================\n2924 \n2925         See Also\n2926         ========\n2927         Pow\n2928         NaN\n2929         NegativeInfinity\n2930 \n2931         \"\"\"\n2932         from sympy.functions import re\n2933 \n2934         if expt.is_extended_positive:\n2935             return S.Infinity\n2936         if expt.is_extended_negative:\n2937             return S.Zero\n2938         if expt is S.NaN:\n2939             return S.NaN\n2940         if expt is S.ComplexInfinity:\n2941             return S.NaN\n2942         if expt.is_extended_real is False and expt.is_number:\n2943             expt_real = re(expt)\n2944             if expt_real.is_positive:\n2945                 return S.ComplexInfinity\n2946             if expt_real.is_negative:\n2947                 return S.Zero\n2948             if expt_real.is_zero:\n2949                 return S.NaN\n2950 \n2951             return self**expt.evalf()\n2952 \n2953     def _as_mpf_val(self, prec):\n2954         return mlib.finf\n2955 \n2956     def _sage_(self):\n2957         import sage.all as sage\n2958         return sage.oo\n2959 \n2960     def __hash__(self):\n2961         return super().__hash__()\n2962 \n2963     def __eq__(self, other):\n2964         return other is S.Infinity or other == float('inf')\n2965 \n2966     def __ne__(self, other):\n2967         return other is not S.Infinity and other != float('inf')\n2968 \n2969     __gt__ = Expr.__gt__\n2970     __ge__ = Expr.__ge__\n2971     __lt__ = Expr.__lt__\n2972     __le__ = Expr.__le__\n2973 \n2974     @_sympifyit('other', NotImplemented)\n2975     def __mod__(self, other):\n2976         if not isinstance(other, Expr):\n2977             return NotImplemented\n2978         return S.NaN\n2979 \n2980     __rmod__ = __mod__\n2981 \n2982     def floor(self):\n2983         return self\n2984 \n2985     def ceiling(self):\n2986         return self\n2987 \n2988 oo = S.Infinity\n2989 \n2990 \n2991 class NegativeInfinity(Number, metaclass=Singleton):\n2992     \"\"\"Negative infinite quantity.\n2993 \n2994     NegativeInfinity is a singleton, and can be accessed\n2995     by ``S.NegativeInfinity``.\n2996 \n2997     See Also\n2998     ========\n2999 \n3000     Infinity\n3001     \"\"\"\n3002 \n3003     is_extended_real = True\n3004     is_complex = False\n3005     is_commutative = True\n3006     is_infinite = True\n3007     is_comparable = True\n3008     is_extended_negative = True\n3009     is_number = True\n3010     is_prime = False\n3011 \n3012     __slots__ = ()\n3013 \n3014     def __new__(cls):\n3015         return AtomicExpr.__new__(cls)\n3016 \n3017     def _latex(self, printer):\n3018         return r\"-\\infty\"\n3019 \n3020     def _eval_subs(self, old, new):\n3021         if self == old:\n3022             return new\n3023 \n3024     def _eval_evalf(self, prec=None):\n3025         return Float('-inf')\n3026 \n3027     def evalf(self, prec=None, **options):\n3028         return self._eval_evalf(prec)\n3029 \n3030     @_sympifyit('other', NotImplemented)\n3031     def __add__(self, other):\n3032         if isinstance(other, Number) and global_parameters.evaluate:\n3033             if other is S.Infinity or other is S.NaN:\n3034                 return S.NaN\n3035             return self\n3036         return Number.__add__(self, other)\n3037     __radd__ = __add__\n3038 \n3039     @_sympifyit('other', NotImplemented)\n3040     def __sub__(self, other):\n3041         if isinstance(other, Number) and global_parameters.evaluate:\n3042             if other is S.NegativeInfinity or other is S.NaN:\n3043                 return S.NaN\n3044             return self\n3045         return Number.__sub__(self, other)\n3046 \n3047     @_sympifyit('other', NotImplemented)\n3048     def __rsub__(self, other):\n3049         return (-self).__add__(other)\n3050 \n3051     @_sympifyit('other', NotImplemented)\n3052     def __mul__(self, other):\n3053         if isinstance(other, Number) and global_parameters.evaluate:\n3054             if other.is_zero or other is S.NaN:\n3055                 return S.NaN\n3056             if other.is_extended_positive:\n3057                 return self\n3058             return S.Infinity\n3059         return Number.__mul__(self, other)\n3060     __rmul__ = __mul__\n3061 \n3062     @_sympifyit('other', NotImplemented)\n3063     def __truediv__(self, other):\n3064         if isinstance(other, Number) and global_parameters.evaluate:\n3065             if other is S.Infinity or \\\n3066                 other is S.NegativeInfinity or \\\n3067                     other is S.NaN:\n3068                 return S.NaN\n3069             if other.is_extended_nonnegative:\n3070                 return self\n3071             return S.Infinity\n3072         return Number.__truediv__(self, other)\n3073 \n3074     def __abs__(self):\n3075         return S.Infinity\n3076 \n3077     def __neg__(self):\n3078         return S.Infinity\n3079 \n3080     def _eval_power(self, expt):\n3081         \"\"\"\n3082         ``expt`` is symbolic object but not equal to 0 or 1.\n3083 \n3084         ================ ======= ==============================\n3085         Expression       Result  Notes\n3086         ================ ======= ==============================\n3087         ``(-oo) ** nan`` ``nan``\n3088         ``(-oo) ** oo``  ``nan``\n3089         ``(-oo) ** -oo`` ``nan``\n3090         ``(-oo) ** e``   ``oo``  ``e`` is positive even integer\n3091         ``(-oo) ** o``   ``-oo`` ``o`` is positive odd integer\n3092         ================ ======= ==============================\n3093 \n3094         See Also\n3095         ========\n3096 \n3097         Infinity\n3098         Pow\n3099         NaN\n3100 \n3101         \"\"\"\n3102         if expt.is_number:\n3103             if expt is S.NaN or \\\n3104                 expt is S.Infinity or \\\n3105                     expt is S.NegativeInfinity:\n3106                 return S.NaN\n3107 \n3108             if isinstance(expt, Integer) and expt.is_extended_positive:\n3109                 if expt.is_odd:\n3110                     return S.NegativeInfinity\n3111                 else:\n3112                     return S.Infinity\n3113 \n3114             return S.NegativeOne**expt*S.Infinity**expt\n3115 \n3116     def _as_mpf_val(self, prec):\n3117         return mlib.fninf\n3118 \n3119     def _sage_(self):\n3120         import sage.all as sage\n3121         return -(sage.oo)\n3122 \n3123     def __hash__(self):\n3124         return super().__hash__()\n3125 \n3126     def __eq__(self, other):\n3127         return other is S.NegativeInfinity or other == float('-inf')\n3128 \n3129     def __ne__(self, other):\n3130         return other is not S.NegativeInfinity and other != float('-inf')\n3131 \n3132     __gt__ = Expr.__gt__\n3133     __ge__ = Expr.__ge__\n3134     __lt__ = Expr.__lt__\n3135     __le__ = Expr.__le__\n3136 \n3137     @_sympifyit('other', NotImplemented)\n3138     def __mod__(self, other):\n3139         if not isinstance(other, Expr):\n3140             return NotImplemented\n3141         return S.NaN\n3142 \n3143     __rmod__ = __mod__\n3144 \n3145     def floor(self):\n3146         return self\n3147 \n3148     def ceiling(self):\n3149         return self\n3150 \n3151     def as_powers_dict(self):\n3152         return {S.NegativeOne: 1, S.Infinity: 1}\n3153 \n3154 \n3155 class NaN(Number, metaclass=Singleton):\n3156     \"\"\"\n3157     Not a Number.\n3158 \n3159     Explanation\n3160     ===========\n3161 \n3162     This serves as a place holder for numeric values that are indeterminate.\n3163     Most operations on NaN, produce another NaN.  Most indeterminate forms,\n3164     such as ``0/0`` or ``oo - oo` produce NaN.  Two exceptions are ``0**0``\n3165     and ``oo**0``, which all produce ``1`` (this is consistent with Python's\n3166     float).\n3167 \n3168     NaN is loosely related to floating point nan, which is defined in the\n3169     IEEE 754 floating point standard, and corresponds to the Python\n3170     ``float('nan')``.  Differences are noted below.\n3171 \n3172     NaN is mathematically not equal to anything else, even NaN itself.  This\n3173     explains the initially counter-intuitive results with ``Eq`` and ``==`` in\n3174     the examples below.\n3175 \n3176     NaN is not comparable so inequalities raise a TypeError.  This is in\n3177     contrast with floating point nan where all inequalities are false.\n3178 \n3179     NaN is a singleton, and can be accessed by ``S.NaN``, or can be imported\n3180     as ``nan``.\n3181 \n3182     Examples\n3183     ========\n3184 \n3185     >>> from sympy import nan, S, oo, Eq\n3186     >>> nan is S.NaN\n3187     True\n3188     >>> oo - oo\n3189     nan\n3190     >>> nan + 1\n3191     nan\n3192     >>> Eq(nan, nan)   # mathematical equality\n3193     False\n3194     >>> nan == nan     # structural equality\n3195     True\n3196 \n3197     References\n3198     ==========\n3199 \n3200     .. [1] https://en.wikipedia.org/wiki/NaN\n3201 \n3202     \"\"\"\n3203     is_commutative = True\n3204     is_extended_real = None\n3205     is_real = None\n3206     is_rational = None\n3207     is_algebraic = None\n3208     is_transcendental = None\n3209     is_integer = None\n3210     is_comparable = False\n3211     is_finite = None\n3212     is_zero = None\n3213     is_prime = None\n3214     is_positive = None\n3215     is_negative = None\n3216     is_number = True\n3217 \n3218     __slots__ = ()\n3219 \n3220     def __new__(cls):\n3221         return AtomicExpr.__new__(cls)\n3222 \n3223     def _latex(self, printer):\n3224         return r\"\\text{NaN}\"\n3225 \n3226     def __neg__(self):\n3227         return self\n3228 \n3229     @_sympifyit('other', NotImplemented)\n3230     def __add__(self, other):\n3231         return self\n3232 \n3233     @_sympifyit('other', NotImplemented)\n3234     def __sub__(self, other):\n3235         return self\n3236 \n3237     @_sympifyit('other', NotImplemented)\n3238     def __mul__(self, other):\n3239         return self\n3240 \n3241     @_sympifyit('other', NotImplemented)\n3242     def __truediv__(self, other):\n3243         return self\n3244 \n3245     def floor(self):\n3246         return self\n3247 \n3248     def ceiling(self):\n3249         return self\n3250 \n3251     def _as_mpf_val(self, prec):\n3252         return _mpf_nan\n3253 \n3254     def _sage_(self):\n3255         import sage.all as sage\n3256         return sage.NaN\n3257 \n3258     def __hash__(self):\n3259         return super().__hash__()\n3260 \n3261     def __eq__(self, other):\n3262         # NaN is structurally equal to another NaN\n3263         return other is S.NaN\n3264 \n3265     def __ne__(self, other):\n3266         return other is not S.NaN\n3267 \n3268     # Expr will _sympify and raise TypeError\n3269     __gt__ = Expr.__gt__\n3270     __ge__ = Expr.__ge__\n3271     __lt__ = Expr.__lt__\n3272     __le__ = Expr.__le__\n3273 \n3274 nan = S.NaN\n3275 \n3276 @dispatch(NaN, Expr) # type:ignore\n3277 def _eval_is_eq(a, b): # noqa:F811\n3278     return False\n3279 \n3280 \n3281 class ComplexInfinity(AtomicExpr, metaclass=Singleton):\n3282     r\"\"\"Complex infinity.\n3283 \n3284     Explanation\n3285     ===========\n3286 \n3287     In complex analysis the symbol `\\tilde\\infty`, called \"complex\n3288     infinity\", represents a quantity with infinite magnitude, but\n3289     undetermined complex phase.\n3290 \n3291     ComplexInfinity is a singleton, and can be accessed by\n3292     ``S.ComplexInfinity``, or can be imported as ``zoo``.\n3293 \n3294     Examples\n3295     ========\n3296 \n3297     >>> from sympy import zoo\n3298     >>> zoo + 42\n3299     zoo\n3300     >>> 42/zoo\n3301     0\n3302     >>> zoo + zoo\n3303     nan\n3304     >>> zoo*zoo\n3305     zoo\n3306 \n3307     See Also\n3308     ========\n3309 \n3310     Infinity\n3311     \"\"\"\n3312 \n3313     is_commutative = True\n3314     is_infinite = True\n3315     is_number = True\n3316     is_prime = False\n3317     is_complex = False\n3318     is_extended_real = False\n3319 \n3320     kind = NumberKind\n3321 \n3322     __slots__ = ()\n3323 \n3324     def __new__(cls):\n3325         return AtomicExpr.__new__(cls)\n3326 \n3327     def _latex(self, printer):\n3328         return r\"\\tilde{\\infty}\"\n3329 \n3330     @staticmethod\n3331     def __abs__():\n3332         return S.Infinity\n3333 \n3334     def floor(self):\n3335         return self\n3336 \n3337     def ceiling(self):\n3338         return self\n3339 \n3340     @staticmethod\n3341     def __neg__():\n3342         return S.ComplexInfinity\n3343 \n3344     def _eval_power(self, expt):\n3345         if expt is S.ComplexInfinity:\n3346             return S.NaN\n3347 \n3348         if isinstance(expt, Number):\n3349             if expt.is_zero:\n3350                 return S.NaN\n3351             else:\n3352                 if expt.is_positive:\n3353                     return S.ComplexInfinity\n3354                 else:\n3355                     return S.Zero\n3356 \n3357     def _sage_(self):\n3358         import sage.all as sage\n3359         return sage.UnsignedInfinityRing.gen()\n3360 \n3361 \n3362 zoo = S.ComplexInfinity\n3363 \n3364 \n3365 class NumberSymbol(AtomicExpr):\n3366 \n3367     is_commutative = True\n3368     is_finite = True\n3369     is_number = True\n3370 \n3371     __slots__ = ()\n3372 \n3373     is_NumberSymbol = True\n3374 \n3375     kind = NumberKind\n3376 \n3377     def __new__(cls):\n3378         return AtomicExpr.__new__(cls)\n3379 \n3380     def approximation(self, number_cls):\n3381         \"\"\" Return an interval with number_cls endpoints\n3382         that contains the value of NumberSymbol.\n3383         If not implemented, then return None.\n3384         \"\"\"\n3385 \n3386     def _eval_evalf(self, prec):\n3387         return Float._new(self._as_mpf_val(prec), prec)\n3388 \n3389     def __eq__(self, other):\n3390         try:\n3391             other = _sympify(other)\n3392         except SympifyError:\n3393             return NotImplemented\n3394         if self is other:\n3395             return True\n3396         if other.is_Number and self.is_irrational:\n3397             return False\n3398 \n3399         return False    # NumberSymbol != non-(Number|self)\n3400 \n3401     def __ne__(self, other):\n3402         return not self == other\n3403 \n3404     def __le__(self, other):\n3405         if self is other:\n3406             return S.true\n3407         return Expr.__le__(self, other)\n3408 \n3409     def __ge__(self, other):\n3410         if self is other:\n3411             return S.true\n3412         return Expr.__ge__(self, other)\n3413 \n3414     def __int__(self):\n3415         # subclass with appropriate return value\n3416         raise NotImplementedError\n3417 \n3418     def __hash__(self):\n3419         return super().__hash__()\n3420 \n3421 class Exp1(NumberSymbol, metaclass=Singleton):\n3422     r\"\"\"The `e` constant.\n3423 \n3424     Explanation\n3425     ===========\n3426 \n3427     The transcendental number `e = 2.718281828\\ldots` is the base of the\n3428     natural logarithm and of the exponential function, `e = \\exp(1)`.\n3429     Sometimes called Euler's number or Napier's constant.\n3430 \n3431     Exp1 is a singleton, and can be accessed by ``S.Exp1``,\n3432     or can be imported as ``E``.\n3433 \n3434     Examples\n3435     ========\n3436 \n3437     >>> from sympy import exp, log, E\n3438     >>> E is exp(1)\n3439     True\n3440     >>> log(E)\n3441     1\n3442 \n3443     References\n3444     ==========\n3445 \n3446     .. [1] https://en.wikipedia.org/wiki/E_%28mathematical_constant%29\n3447     \"\"\"\n3448 \n3449     is_real = True\n3450     is_positive = True\n3451     is_negative = False  # XXX Forces is_negative/is_nonnegative\n3452     is_irrational = True\n3453     is_number = True\n3454     is_algebraic = False\n3455     is_transcendental = True\n3456 \n3457     __slots__ = ()\n3458 \n3459     def _latex(self, printer):\n3460         return r\"e\"\n3461 \n3462     @staticmethod\n3463     def __abs__():\n3464         return S.Exp1\n3465 \n3466     def __int__(self):\n3467         return 2\n3468 \n3469     def _as_mpf_val(self, prec):\n3470         return mpf_e(prec)\n3471 \n3472     def approximation_interval(self, number_cls):\n3473         if issubclass(number_cls, Integer):\n3474             return (Integer(2), Integer(3))\n3475         elif issubclass(number_cls, Rational):\n3476             pass\n3477 \n3478     def _eval_power(self, expt):\n3479         from sympy import exp\n3480         if global_parameters.exp_is_pow:\n3481             return self._eval_power_exp_is_pow(expt)\n3482         else:\n3483             return exp(expt)\n3484 \n3485     def _eval_power_exp_is_pow(self, arg):\n3486         from ..functions.elementary.exponential import log\n3487         from . import Add, Mul, Pow\n3488         if arg.is_Number:\n3489             if arg is oo:\n3490                 return oo\n3491             elif arg == -oo:\n3492                 return S.Zero\n3493         elif isinstance(arg, log):\n3494             return arg.args[0]\n3495 \n3496         # don't autoexpand Pow or Mul (see the issue 3351):\n3497         elif not arg.is_Add:\n3498             Ioo = I*oo\n3499             if arg in [Ioo, -Ioo]:\n3500                 return nan\n3501 \n3502             coeff = arg.coeff(pi*I)\n3503             if coeff:\n3504                 if (2*coeff).is_integer:\n3505                     if coeff.is_even:\n3506                         return S.One\n3507                     elif coeff.is_odd:\n3508                         return S.NegativeOne\n3509                     elif (coeff + S.Half).is_even:\n3510                         return -I\n3511                     elif (coeff + S.Half).is_odd:\n3512                         return I\n3513                 elif coeff.is_Rational:\n3514                     ncoeff = coeff % 2 # restrict to [0, 2pi)\n3515                     if ncoeff > 1: # restrict to (-pi, pi]\n3516                         ncoeff -= 2\n3517                     if ncoeff != coeff:\n3518                         return S.Exp1**(ncoeff*S.Pi*S.ImaginaryUnit)\n3519 \n3520             # Warning: code in risch.py will be very sensitive to changes\n3521             # in this (see DifferentialExtension).\n3522 \n3523             # look for a single log factor\n3524 \n3525             coeff, terms = arg.as_coeff_Mul()\n3526 \n3527             # but it can't be multiplied by oo\n3528             if coeff in (oo, -oo):\n3529                 return\n3530 \n3531             coeffs, log_term = [coeff], None\n3532             for term in Mul.make_args(terms):\n3533                 if isinstance(term, log):\n3534                     if log_term is None:\n3535                         log_term = term.args[0]\n3536                     else:\n3537                         return\n3538                 elif term.is_comparable:\n3539                     coeffs.append(term)\n3540                 else:\n3541                     return\n3542 \n3543             return log_term**Mul(*coeffs) if log_term else None\n3544         elif arg.is_Add:\n3545             out = []\n3546             add = []\n3547             argchanged = False\n3548             for a in arg.args:\n3549                 if a is S.One:\n3550                     add.append(a)\n3551                     continue\n3552                 newa = self**a\n3553                 if isinstance(newa, Pow) and newa.base is self:\n3554                     if newa.exp != a:\n3555                         add.append(newa.exp)\n3556                         argchanged = True\n3557                     else:\n3558                         add.append(a)\n3559                 else:\n3560                     out.append(newa)\n3561             if out or argchanged:\n3562                 return Mul(*out)*Pow(self, Add(*add), evaluate=False)\n3563         elif arg.is_Matrix:\n3564             return arg.exp()\n3565 \n3566     def _eval_rewrite_as_sin(self, **kwargs):\n3567         from sympy import sin\n3568         I = S.ImaginaryUnit\n3569         return sin(I + S.Pi/2) - I*sin(I)\n3570 \n3571     def _eval_rewrite_as_cos(self, **kwargs):\n3572         from sympy import cos\n3573         I = S.ImaginaryUnit\n3574         return cos(I) + I*cos(I + S.Pi/2)\n3575 \n3576     def _sage_(self):\n3577         import sage.all as sage\n3578         return sage.e\n3579 E = S.Exp1\n3580 \n3581 \n3582 class Pi(NumberSymbol, metaclass=Singleton):\n3583     r\"\"\"The `\\pi` constant.\n3584 \n3585     Explanation\n3586     ===========\n3587 \n3588     The transcendental number `\\pi = 3.141592654\\ldots` represents the ratio\n3589     of a circle's circumference to its diameter, the area of the unit circle,\n3590     the half-period of trigonometric functions, and many other things\n3591     in mathematics.\n3592 \n3593     Pi is a singleton, and can be accessed by ``S.Pi``, or can\n3594     be imported as ``pi``.\n3595 \n3596     Examples\n3597     ========\n3598 \n3599     >>> from sympy import S, pi, oo, sin, exp, integrate, Symbol\n3600     >>> S.Pi\n3601     pi\n3602     >>> pi > 3\n3603     True\n3604     >>> pi.is_irrational\n3605     True\n3606     >>> x = Symbol('x')\n3607     >>> sin(x + 2*pi)\n3608     sin(x)\n3609     >>> integrate(exp(-x**2), (x, -oo, oo))\n3610     sqrt(pi)\n3611 \n3612     References\n3613     ==========\n3614 \n3615     .. [1] https://en.wikipedia.org/wiki/Pi\n3616     \"\"\"\n3617 \n3618     is_real = True\n3619     is_positive = True\n3620     is_negative = False\n3621     is_irrational = True\n3622     is_number = True\n3623     is_algebraic = False\n3624     is_transcendental = True\n3625 \n3626     __slots__ = ()\n3627 \n3628     def _latex(self, printer):\n3629         return r\"\\pi\"\n3630 \n3631     @staticmethod\n3632     def __abs__():\n3633         return S.Pi\n3634 \n3635     def __int__(self):\n3636         return 3\n3637 \n3638     def _as_mpf_val(self, prec):\n3639         return mpf_pi(prec)\n3640 \n3641     def approximation_interval(self, number_cls):\n3642         if issubclass(number_cls, Integer):\n3643             return (Integer(3), Integer(4))\n3644         elif issubclass(number_cls, Rational):\n3645             return (Rational(223, 71), Rational(22, 7))\n3646 \n3647     def _sage_(self):\n3648         import sage.all as sage\n3649         return sage.pi\n3650 pi = S.Pi\n3651 \n3652 \n3653 class GoldenRatio(NumberSymbol, metaclass=Singleton):\n3654     r\"\"\"The golden ratio, `\\phi`.\n3655 \n3656     Explanation\n3657     ===========\n3658 \n3659     `\\phi = \\frac{1 + \\sqrt{5}}{2}` is algebraic number.  Two quantities\n3660     are in the golden ratio if their ratio is the same as the ratio of\n3661     their sum to the larger of the two quantities, i.e. their maximum.\n3662 \n3663     GoldenRatio is a singleton, and can be accessed by ``S.GoldenRatio``.\n3664 \n3665     Examples\n3666     ========\n3667 \n3668     >>> from sympy import S\n3669     >>> S.GoldenRatio > 1\n3670     True\n3671     >>> S.GoldenRatio.expand(func=True)\n3672     1/2 + sqrt(5)/2\n3673     >>> S.GoldenRatio.is_irrational\n3674     True\n3675 \n3676     References\n3677     ==========\n3678 \n3679     .. [1] https://en.wikipedia.org/wiki/Golden_ratio\n3680     \"\"\"\n3681 \n3682     is_real = True\n3683     is_positive = True\n3684     is_negative = False\n3685     is_irrational = True\n3686     is_number = True\n3687     is_algebraic = True\n3688     is_transcendental = False\n3689 \n3690     __slots__ = ()\n3691 \n3692     def _latex(self, printer):\n3693         return r\"\\phi\"\n3694 \n3695     def __int__(self):\n3696         return 1\n3697 \n3698     def _as_mpf_val(self, prec):\n3699          # XXX track down why this has to be increased\n3700         rv = mlib.from_man_exp(phi_fixed(prec + 10), -prec - 10)\n3701         return mpf_norm(rv, prec)\n3702 \n3703     def _eval_expand_func(self, **hints):\n3704         from sympy import sqrt\n3705         return S.Half + S.Half*sqrt(5)\n3706 \n3707     def approximation_interval(self, number_cls):\n3708         if issubclass(number_cls, Integer):\n3709             return (S.One, Rational(2))\n3710         elif issubclass(number_cls, Rational):\n3711             pass\n3712 \n3713     def _sage_(self):\n3714         import sage.all as sage\n3715         return sage.golden_ratio\n3716 \n3717     _eval_rewrite_as_sqrt = _eval_expand_func\n3718 \n3719 \n3720 class TribonacciConstant(NumberSymbol, metaclass=Singleton):\n3721     r\"\"\"The tribonacci constant.\n3722 \n3723     Explanation\n3724     ===========\n3725 \n3726     The tribonacci numbers are like the Fibonacci numbers, but instead\n3727     of starting with two predetermined terms, the sequence starts with\n3728     three predetermined terms and each term afterwards is the sum of the\n3729     preceding three terms.\n3730 \n3731     The tribonacci constant is the ratio toward which adjacent tribonacci\n3732     numbers tend. It is a root of the polynomial `x^3 - x^2 - x - 1 = 0`,\n3733     and also satisfies the equation `x + x^{-3} = 2`.\n3734 \n3735     TribonacciConstant is a singleton, and can be accessed\n3736     by ``S.TribonacciConstant``.\n3737 \n3738     Examples\n3739     ========\n3740 \n3741     >>> from sympy import S\n3742     >>> S.TribonacciConstant > 1\n3743     True\n3744     >>> S.TribonacciConstant.expand(func=True)\n3745     1/3 + (19 - 3*sqrt(33))**(1/3)/3 + (3*sqrt(33) + 19)**(1/3)/3\n3746     >>> S.TribonacciConstant.is_irrational\n3747     True\n3748     >>> S.TribonacciConstant.n(20)\n3749     1.8392867552141611326\n3750 \n3751     References\n3752     ==========\n3753 \n3754     .. [1] https://en.wikipedia.org/wiki/Generalizations_of_Fibonacci_numbers#Tribonacci_numbers\n3755     \"\"\"\n3756 \n3757     is_real = True\n3758     is_positive = True\n3759     is_negative = False\n3760     is_irrational = True\n3761     is_number = True\n3762     is_algebraic = True\n3763     is_transcendental = False\n3764 \n3765     __slots__ = ()\n3766 \n3767     def _latex(self, printer):\n3768         return r\"\\text{TribonacciConstant}\"\n3769 \n3770     def __int__(self):\n3771         return 2\n3772 \n3773     def _eval_evalf(self, prec):\n3774         rv = self._eval_expand_func(function=True)._eval_evalf(prec + 4)\n3775         return Float(rv, precision=prec)\n3776 \n3777     def _eval_expand_func(self, **hints):\n3778         from sympy import sqrt, cbrt\n3779         return (1 + cbrt(19 - 3*sqrt(33)) + cbrt(19 + 3*sqrt(33))) / 3\n3780 \n3781     def approximation_interval(self, number_cls):\n3782         if issubclass(number_cls, Integer):\n3783             return (S.One, Rational(2))\n3784         elif issubclass(number_cls, Rational):\n3785             pass\n3786 \n3787     _eval_rewrite_as_sqrt = _eval_expand_func\n3788 \n3789 \n3790 class EulerGamma(NumberSymbol, metaclass=Singleton):\n3791     r\"\"\"The Euler-Mascheroni constant.\n3792 \n3793     Explanation\n3794     ===========\n3795 \n3796     `\\gamma = 0.5772157\\ldots` (also called Euler's constant) is a mathematical\n3797     constant recurring in analysis and number theory.  It is defined as the\n3798     limiting difference between the harmonic series and the\n3799     natural logarithm:\n3800 \n3801     .. math:: \\gamma = \\lim\\limits_{n\\to\\infty}\n3802               \\left(\\sum\\limits_{k=1}^n\\frac{1}{k} - \\ln n\\right)\n3803 \n3804     EulerGamma is a singleton, and can be accessed by ``S.EulerGamma``.\n3805 \n3806     Examples\n3807     ========\n3808 \n3809     >>> from sympy import S\n3810     >>> S.EulerGamma.is_irrational\n3811     >>> S.EulerGamma > 0\n3812     True\n3813     >>> S.EulerGamma > 1\n3814     False\n3815 \n3816     References\n3817     ==========\n3818 \n3819     .. [1] https://en.wikipedia.org/wiki/Euler%E2%80%93Mascheroni_constant\n3820     \"\"\"\n3821 \n3822     is_real = True\n3823     is_positive = True\n3824     is_negative = False\n3825     is_irrational = None\n3826     is_number = True\n3827 \n3828     __slots__ = ()\n3829 \n3830     def _latex(self, printer):\n3831         return r\"\\gamma\"\n3832 \n3833     def __int__(self):\n3834         return 0\n3835 \n3836     def _as_mpf_val(self, prec):\n3837          # XXX track down why this has to be increased\n3838         v = mlib.libhyper.euler_fixed(prec + 10)\n3839         rv = mlib.from_man_exp(v, -prec - 10)\n3840         return mpf_norm(rv, prec)\n3841 \n3842     def approximation_interval(self, number_cls):\n3843         if issubclass(number_cls, Integer):\n3844             return (S.Zero, S.One)\n3845         elif issubclass(number_cls, Rational):\n3846             return (S.Half, Rational(3, 5))\n3847 \n3848     def _sage_(self):\n3849         import sage.all as sage\n3850         return sage.euler_gamma\n3851 \n3852 \n3853 class Catalan(NumberSymbol, metaclass=Singleton):\n3854     r\"\"\"Catalan's constant.\n3855 \n3856     Explanation\n3857     ===========\n3858 \n3859     `K = 0.91596559\\ldots` is given by the infinite series\n3860 \n3861     .. math:: K = \\sum_{k=0}^{\\infty} \\frac{(-1)^k}{(2k+1)^2}\n3862 \n3863     Catalan is a singleton, and can be accessed by ``S.Catalan``.\n3864 \n3865     Examples\n3866     ========\n3867 \n3868     >>> from sympy import S\n3869     >>> S.Catalan.is_irrational\n3870     >>> S.Catalan > 0\n3871     True\n3872     >>> S.Catalan > 1\n3873     False\n3874 \n3875     References\n3876     ==========\n3877 \n3878     .. [1] https://en.wikipedia.org/wiki/Catalan%27s_constant\n3879     \"\"\"\n3880 \n3881     is_real = True\n3882     is_positive = True\n3883     is_negative = False\n3884     is_irrational = None\n3885     is_number = True\n3886 \n3887     __slots__ = ()\n3888 \n3889     def __int__(self):\n3890         return 0\n3891 \n3892     def _as_mpf_val(self, prec):\n3893         # XXX track down why this has to be increased\n3894         v = mlib.catalan_fixed(prec + 10)\n3895         rv = mlib.from_man_exp(v, -prec - 10)\n3896         return mpf_norm(rv, prec)\n3897 \n3898     def approximation_interval(self, number_cls):\n3899         if issubclass(number_cls, Integer):\n3900             return (S.Zero, S.One)\n3901         elif issubclass(number_cls, Rational):\n3902             return (Rational(9, 10), S.One)\n3903 \n3904     def _eval_rewrite_as_Sum(self, k_sym=None, symbols=None):\n3905         from sympy import Sum, Dummy\n3906         if (k_sym is not None) or (symbols is not None):\n3907             return self\n3908         k = Dummy('k', integer=True, nonnegative=True)\n3909         return Sum((-1)**k / (2*k+1)**2, (k, 0, S.Infinity))\n3910 \n3911     def _sage_(self):\n3912         import sage.all as sage\n3913         return sage.catalan\n3914 \n3915 \n3916 class ImaginaryUnit(AtomicExpr, metaclass=Singleton):\n3917     r\"\"\"The imaginary unit, `i = \\sqrt{-1}`.\n3918 \n3919     I is a singleton, and can be accessed by ``S.I``, or can be\n3920     imported as ``I``.\n3921 \n3922     Examples\n3923     ========\n3924 \n3925     >>> from sympy import I, sqrt\n3926     >>> sqrt(-1)\n3927     I\n3928     >>> I*I\n3929     -1\n3930     >>> 1/I\n3931     -I\n3932 \n3933     References\n3934     ==========\n3935 \n3936     .. [1] https://en.wikipedia.org/wiki/Imaginary_unit\n3937     \"\"\"\n3938 \n3939     is_commutative = True\n3940     is_imaginary = True\n3941     is_finite = True\n3942     is_number = True\n3943     is_algebraic = True\n3944     is_transcendental = False\n3945 \n3946     kind = NumberKind\n3947 \n3948     __slots__ = ()\n3949 \n3950     def _latex(self, printer):\n3951         return printer._settings['imaginary_unit_latex']\n3952 \n3953     @staticmethod\n3954     def __abs__():\n3955         return S.One\n3956 \n3957     def _eval_evalf(self, prec):\n3958         return self\n3959 \n3960     def _eval_conjugate(self):\n3961         return -S.ImaginaryUnit\n3962 \n3963     def _eval_power(self, expt):\n3964         \"\"\"\n3965         b is I = sqrt(-1)\n3966         e is symbolic object but not equal to 0, 1\n3967 \n3968         I**r -> (-1)**(r/2) -> exp(r/2*Pi*I) -> sin(Pi*r/2) + cos(Pi*r/2)*I, r is decimal\n3969         I**0 mod 4 -> 1\n3970         I**1 mod 4 -> I\n3971         I**2 mod 4 -> -1\n3972         I**3 mod 4 -> -I\n3973         \"\"\"\n3974 \n3975         if isinstance(expt, Integer):\n3976             expt = expt % 4\n3977             if expt == 0:\n3978                 return S.One\n3979             elif expt == 1:\n3980                 return S.ImaginaryUnit\n3981             elif expt == 2:\n3982                 return S.NegativeOne\n3983             elif expt == 3:\n3984                 return -S.ImaginaryUnit\n3985         if isinstance(expt, Rational):\n3986             i, r = divmod(expt, 2)\n3987             rv = Pow(S.ImaginaryUnit, r, evaluate=False)\n3988             if i % 2:\n3989                 return Mul(S.NegativeOne, rv, evaluate=False)\n3990             return rv\n3991 \n3992     def as_base_exp(self):\n3993         return S.NegativeOne, S.Half\n3994 \n3995     def _sage_(self):\n3996         import sage.all as sage\n3997         return sage.I\n3998 \n3999     @property\n4000     def _mpc_(self):\n4001         return (Float(0)._mpf_, Float(1)._mpf_)\n4002 \n4003 I = S.ImaginaryUnit\n4004 \n4005 @dispatch(Tuple, Number) # type:ignore\n4006 def _eval_is_eq(self, other): # noqa: F811\n4007     return False\n4008 \n4009 def sympify_fractions(f):\n4010     return Rational(f.numerator, f.denominator, 1)\n4011 \n4012 converter[fractions.Fraction] = sympify_fractions\n4013 \n4014 if HAS_GMPY:\n4015     def sympify_mpz(x):\n4016         return Integer(int(x))\n4017 \n4018     # XXX: The sympify_mpq function here was never used because it is\n4019     # overridden by the other sympify_mpq function below. Maybe it should just\n4020     # be removed or maybe it should be used for something...\n4021     def sympify_mpq(x):\n4022         return Rational(int(x.numerator), int(x.denominator))\n4023 \n4024     converter[type(gmpy.mpz(1))] = sympify_mpz\n4025     converter[type(gmpy.mpq(1, 2))] = sympify_mpq\n4026 \n4027 \n4028 def sympify_mpmath_mpq(x):\n4029     p, q = x._mpq_\n4030     return Rational(p, q, 1)\n4031 \n4032 converter[type(mpmath.rational.mpq(1, 2))] = sympify_mpmath_mpq\n4033 \n4034 \n4035 def sympify_mpmath(x):\n4036     return Expr._from_mpmath(x, x.context.prec)\n4037 \n4038 converter[mpnumeric] = sympify_mpmath\n4039 \n4040 \n4041 def sympify_complex(a):\n4042     real, imag = list(map(sympify, (a.real, a.imag)))\n4043     return real + S.ImaginaryUnit*imag\n4044 \n4045 converter[complex] = sympify_complex\n4046 \n4047 from .power import Pow, integer_nthroot\n4048 from .mul import Mul\n4049 Mul.identity = One()\n4050 from .add import Add\n4051 Add.identity = Zero()\n4052 \n4053 def _register_classes():\n4054     numbers.Number.register(Number)\n4055     numbers.Real.register(Float)\n4056     numbers.Rational.register(Rational)\n4057     numbers.Rational.register(Integer)\n4058 \n4059 _register_classes()\n",
        "intended_behavior": "Enhance the precision handling or representation of `Float` objects when used in symbolic equations, especially within the context of linear solvers like `linsolve`. The goal is to minimize the impact of floating-point arithmetic issues (like rounding errors) that may lead to inconsistencies in equation solving outcomes. This may involve implementing a check or conversion mechanism that ensures numerical precision is maintained or enhanced when floating-point numbers are part of a symbolic equation, without undermining the performance or general usability of the library."
    }
]