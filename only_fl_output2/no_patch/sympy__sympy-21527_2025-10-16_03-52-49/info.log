2025-10-16 03:52:49.629 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-16 03:53:00.671 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=276, output_tokens=12, cost=0.003120
2025-10-16 03:53:12.059 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=456, output_tokens=493, cost=0.019350
2025-10-16 03:53:13.671 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-16 03:53:22.155 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=585, output_tokens=390, cost=0.017550
2025-10-16 03:53:22.163 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-16 03:53:24.619 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=744, output_tokens=68, cost=0.009480
2025-10-16 03:53:24.620 | DEBUG    | Extracted a valid json.
2025-10-16 03:53:24.620 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_method(\"linsolve\")",
        "search_class(\"Eq\")",
        "search_class(\"Symbol\")",
        "search_code(\"Float\")",
        "search_method(\"simplify\")",
        "search_method(\"Nsimplify\")"
    ],
    "bug_locations": []
}
2025-10-16 03:53:28.476 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-16 03:53:28.477 | DEBUG    | <Agent search> Analyzing search results.
2025-10-16 03:53:53.104 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=6985, output_tokens=917, cost=0.097360
2025-10-16 03:53:53.113 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-16 03:54:01.821 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=8118, output_tokens=360, cost=0.091980
2025-10-16 03:54:01.829 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-16 03:54:09.065 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=714, output_tokens=308, cost=0.016380
2025-10-16 03:54:09.066 | DEBUG    | Extracted a valid json.
2025-10-16 03:54:09.066 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "sympy/solvers/solveset.py",
            "class": "",
            "method": "linsolve",
            "intended_behavior": "The `linsolve` method should more robustly handle floating-point coefficients close in value, ensuring consistent solutions across mathematically equivalent or very close systems of equations. Specifically, it should include a preprocessing step to detect if the equations involve floating-point coefficients that are close in value and, if so, apply an appropriate strategy to handle them consistentlyâ€”perhaps by using a symbolic or rational representation internally for greater numerical stability in solutions. This change must preserve `linsolve`'s existing functionality for all other cases while ensuring that the method returns consistent results for systems with slightly different floating-point coefficients."
        },
        {
            "file": "sympy/core/numbers.py",
            "class": "",
            "method": "",
            "intended_behavior": "Enhance the precision handling or representation of `Float` objects when used in symbolic equations, especially within the context of linear solvers like `linsolve`. The goal is to minimize the impact of floating-point arithmetic issues (like rounding errors) that may lead to inconsistencies in equation solving outcomes. This may involve implementing a check or conversion mechanism that ensures numerical precision is maintained or enhanced when floating-point numbers are part of a symbolic equation, without undermining the performance or general usability of the library."
        }
    ]
}
2025-10-16 03:54:09.079 | DEBUG    | Bug location extracted successfully: [<file>sympy/solvers/solveset.py</file>
<class>None</class>
<method>linsolve</method>
<code>
2586 def linsolve(system, *symbols):
2587     r"""
2588     Solve system of N linear equations with M variables; both
2589     underdetermined and overdetermined systems are supported.
2590     The possible number of solutions is zero, one or infinite.
2591     Zero solutions throws a ValueError, whereas infinite
2592     solutions are represented parametrically in terms of the given
2593     symbols. For unique solution a FiniteSet of ordered tuples
2594     is returned.
2595 
2596     All Standard input formats are supported:
2597     For the given set of Equations, the respective input types
2598     are given below:
2599 
2600     .. math:: 3x + 2y -   z = 1
2601     .. math:: 2x - 2y + 4z = -2
2602     .. math:: 2x -   y + 2z = 0
2603 
2604     * Augmented Matrix Form, `system` given below:
2605 
2606     ::
2607 
2608               [3   2  -1  1]
2609      system = [2  -2   4 -2]
2610               [2  -1   2  0]
2611 
2612     * List Of Equations Form
2613 
2614     `system  =  [3x + 2y - z - 1, 2x - 2y + 4z + 2, 2x - y + 2z]`
2615 
2616     * Input A & b Matrix Form (from Ax = b) are given as below:
2617 
2618     ::
2619 
2620          [3   2  -1 ]         [  1 ]
2621      A = [2  -2   4 ]    b =  [ -2 ]
2622          [2  -1   2 ]         [  0 ]
2623 
2624     `system = (A, b)`
2625 
2626     Symbols can always be passed but are actually only needed
2627     when 1) a system of equations is being passed and 2) the
2628     system is passed as an underdetermined matrix and one wants
2629     to control the name of the free variables in the result.
2630     An error is raised if no symbols are used for case 1, but if
2631     no symbols are provided for case 2, internally generated symbols
2632     will be provided. When providing symbols for case 2, there should
2633     be at least as many symbols are there are columns in matrix A.
2634 
2635     The algorithm used here is Gauss-Jordan elimination, which
2636     results, after elimination, in a row echelon form matrix.
2637 
2638     Returns
2639     =======
2640 
2641     A FiniteSet containing an ordered tuple of values for the
2642     unknowns for which the `system` has a solution. (Wrapping
2643     the tuple in FiniteSet is used to maintain a consistent
2644     output format throughout solveset.)
2645 
2646     Returns EmptySet, if the linear system is inconsistent.
2647 
2648     Raises
2649     ======
2650 
2651     ValueError
2652         The input is not valid.
2653         The symbols are not given.
2654 
2655     Examples
2656     ========
2657 
2658     >>> from sympy import Matrix, linsolve, symbols
2659     >>> x, y, z = symbols("x, y, z")
2660     >>> A = Matrix([[1, 2, 3], [4, 5, 6], [7, 8, 10]])
2661     >>> b = Matrix([3, 6, 9])
2662     >>> A
2663     Matrix([
2664     [1, 2,  3],
2665     [4, 5,  6],
2666     [7, 8, 10]])
2667     >>> b
2668     Matrix([
2669     [3],
2670     [6],
2671     [9]])
2672     >>> linsolve((A, b), [x, y, z])
2673     FiniteSet((-1, 2, 0))
2674 
2675     * Parametric Solution: In case the system is underdetermined, the
2676       function will return a parametric solution in terms of the given
2677       symbols. Those that are free will be returned unchanged. e.g. in
2678       the system below, `z` is returned as the solution for variable z;
2679       it can take on any value.
2680 
2681     >>> A = Matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
2682     >>> b = Matrix([3, 6, 9])
2683     >>> linsolve((A, b), x, y, z)
2684     FiniteSet((z - 1, 2 - 2*z, z))
2685 
2686     If no symbols are given, internally generated symbols will be used.
2687     The `tau0` in the 3rd position indicates (as before) that the 3rd
2688     variable -- whatever it's named -- can take on any value:
2689 
2690     >>> linsolve((A, b))
2691     FiniteSet((tau0 - 1, 2 - 2*tau0, tau0))
2692 
2693     * List of Equations as input
2694 
2695     >>> Eqns = [3*x + 2*y - z - 1, 2*x - 2*y + 4*z + 2, - x + y/2 - z]
2696     >>> linsolve(Eqns, x, y, z)
2697     FiniteSet((1, -2, -2))
2698 
2699     * Augmented Matrix as input
2700 
2701     >>> aug = Matrix([[2, 1, 3, 1], [2, 6, 8, 3], [6, 8, 18, 5]])
2702     >>> aug
2703     Matrix([
2704     [2, 1,  3, 1],
2705     [2, 6,  8, 3],
2706     [6, 8, 18, 5]])
2707     >>> linsolve(aug, x, y, z)
2708     FiniteSet((3/10, 2/5, 0))
2709 
2710     * Solve for symbolic coefficients
2711 
2712     >>> a, b, c, d, e, f = symbols('a, b, c, d, e, f')
2713     >>> eqns = [a*x + b*y - c, d*x + e*y - f]
2714     >>> linsolve(eqns, x, y)
2715     FiniteSet(((-b*f + c*e)/(a*e - b*d), (a*f - c*d)/(a*e - b*d)))
2716 
2717     * A degenerate system returns solution as set of given
2718       symbols.
2719 
2720     >>> system = Matrix(([0, 0, 0], [0, 0, 0], [0, 0, 0]))
2721     >>> linsolve(system, x, y)
2722     FiniteSet((x, y))
2723 
2724     * For an empty system linsolve returns empty set
2725 
2726     >>> linsolve([], x)
2727     EmptySet
2728 
2729     * An error is raised if, after expansion, any nonlinearity
2730       is detected:
2731 
2732     >>> linsolve([x*(1/x - 1), (y - 1)**2 - y**2 + 1], x, y)
2733     FiniteSet((1, 1))
2734     >>> linsolve([x**2 - 1], x)
2735     Traceback (most recent call last):
2736     ...
2737     NonlinearError:
2738     nonlinear term encountered: x**2
2739     """
2740     if not system:
2741         return S.EmptySet
2742 
2743     # If second argument is an iterable
2744     if symbols and hasattr(symbols[0], '__iter__'):
2745         symbols = symbols[0]
2746     sym_gen = isinstance(symbols, GeneratorType)
2747 
2748     b = None  # if we don't get b the input was bad
2749     syms_needed_msg = None
2750 
2751     # unpack system
2752 
2753     if hasattr(system, '__iter__'):
2754 
2755         # 1). (A, b)
2756         if len(system) == 2 and isinstance(system[0], MatrixBase):
2757             A, b = system
2758 
2759         # 2). (eq1, eq2, ...)
2760         if not isinstance(system[0], MatrixBase):
2761             if sym_gen or not symbols:
2762                 raise ValueError(filldedent('''
2763                     When passing a system of equations, the explicit
2764                     symbols for which a solution is being sought must
2765                     be given as a sequence, too.
2766                 '''))
2767 
2768             #
2769             # Pass to the sparse solver implemented in polys. It is important
2770             # that we do not attempt to convert the equations to a matrix
2771             # because that would be very inefficient for large sparse systems
2772             # of equations.
2773             #
2774             eqs = system
2775             eqs = [sympify(eq) for eq in eqs]
2776             try:
2777                 sol = _linsolve(eqs, symbols)
2778             except PolyNonlinearError as exc:
2779                 # e.g. cos(x) contains an element of the set of generators
2780                 raise NonlinearError(str(exc))
2781 
2782             if sol is None:
2783                 return S.EmptySet
2784 
2785             sol = FiniteSet(Tuple(*(sol.get(sym, sym) for sym in symbols)))
2786             return sol
2787 
2788     elif isinstance(system, MatrixBase) and not (
2789             symbols and not isinstance(symbols, GeneratorType) and
2790             isinstance(symbols[0], MatrixBase)):
2791         # 3). A augmented with b
2792         A, b = system[:, :-1], system[:, -1:]
2793 
2794     if b is None:
2795         raise ValueError("Invalid arguments")
2796 
2797     syms_needed_msg  = syms_needed_msg or 'columns of A'
2798 
2799     if sym_gen:
2800         symbols = [next(symbols) for i in range(A.cols)]
2801         if any(set(symbols) & (A.free_symbols | b.free_symbols)):
2802             raise ValueError(filldedent('''
2803                 At least one of the symbols provided
2804                 already appears in the system to be solved.
2805                 One way to avoid this is to use Dummy symbols in
2806                 the generator, e.g. numbered_symbols('%s', cls=Dummy)
2807             ''' % symbols[0].name.rstrip('1234567890')))
2808 
2809     if not symbols:
2810         symbols = [Dummy() for _ in range(A.cols)]
2811         name = _uniquely_named_symbol('tau', (A, b),
2812             compare=lambda i: str(i).rstrip('1234567890')).name
2813         gen  = numbered_symbols(name)
2814     else:
2815         gen = None
2816 
2817     # This is just a wrapper for solve_lin_sys
2818     eqs = []
2819     rows = A.tolist()
2820     for rowi, bi in zip(rows, b):
2821         terms = [elem * sym for elem, sym in zip(rowi, symbols) if elem]
2822         terms.append(-bi)
2823         eqs.append(Add(*terms))
2824 
2825     eqs, ring = sympy_eqs_to_ring(eqs, symbols)
2826     sol = solve_lin_sys(eqs, ring, _raw=False)
2827     if sol is None:
2828         return S.EmptySet
2829     #sol = {sym:val for sym, val in sol.items() if sym != val}
2830     sol = FiniteSet(Tuple(*(sol.get(sym, sym) for sym in symbols)))
2831 
2832     if gen is not None:
2833         solsym = sol.free_symbols
2834         rep = {sym: next(gen) for sym in symbols if sym in solsym}
2835         sol = sol.subs(rep)
2836 
2837     return sol

</code><intended_behavior>The `linsolve` method should more robustly handle floating-point coefficients close in value, ensuring consistent solutions across mathematically equivalent or very close systems of equations. Specifically, it should include a preprocessing step to detect if the equations involve floating-point coefficients that are close in value and, if so, apply an appropriate strategy to handle them consistentlyâ€”perhaps by using a symbolic or rational representation internally for greater numerical stability in solutions. This change must preserve `linsolve`'s existing functionality for all other cases while ensuring that the method returns consistent results for systems with slightly different floating-point coefficients.</intended_behavior>, <file>sympy/core/numbers.py</file>
<class>None</class>
<method>None</method>
<code>
1 import numbers
2 import decimal
3 import fractions
4 import math
5 import re as regex
6 import sys
7 
8 from .containers import Tuple
9 from .sympify import (SympifyError, converter, sympify, _convert_numpy_types, _sympify,
10                       _is_numpy_instance)
11 from .singleton import S, Singleton
12 from .expr import Expr, AtomicExpr
13 from .evalf import pure_complex
14 from .decorators import _sympifyit
15 from .cache import cacheit, clear_cache
16 from .logic import fuzzy_not
17 from sympy.core.compatibility import (as_int, HAS_GMPY, SYMPY_INTS,
18     gmpy)
19 from sympy.core.cache import lru_cache
20 from .kind import NumberKind
21 from sympy.multipledispatch import dispatch
22 import mpmath
23 import mpmath.libmp as mlib
24 from mpmath.libmp import bitcount
25 from mpmath.libmp.backend import MPZ
26 from mpmath.libmp import mpf_pow, mpf_pi, mpf_e, phi_fixed
27 from mpmath.ctx_mp import mpnumeric
28 from mpmath.libmp.libmpf import (
29     finf as _mpf_inf, fninf as _mpf_ninf,
30     fnan as _mpf_nan, fzero, _normalize as mpf_normalize,
31     prec_to_dps)
32 from sympy.utilities.misc import debug, filldedent
33 from .parameters import global_parameters
34 
35 from sympy.utilities.exceptions import SymPyDeprecationWarning
36 
37 rnd = mlib.round_nearest
38 
39 _LOG2 = math.log(2)
40 
41 
42 def comp(z1, z2, tol=None):
43     """Return a bool indicating whether the error between z1 and z2
44     is <= tol.
45 
46     Examples
47     ========
48 
49     If ``tol`` is None then True will be returned if
50     ``abs(z1 - z2)*10**p <= 5`` where ``p`` is minimum value of the
51     decimal precision of each value.
52 
53     >>> from sympy.core.numbers import comp, pi
54     >>> pi4 = pi.n(4); pi4
55     3.142
56     >>> comp(_, 3.142)
57     True
58     >>> comp(pi4, 3.141)
59     False
60     >>> comp(pi4, 3.143)
61     False
62 
63     A comparison of strings will be made
64     if ``z1`` is a Number and ``z2`` is a string or ``tol`` is ''.
65 
66     >>> comp(pi4, 3.1415)
67     True
68     >>> comp(pi4, 3.1415, '')
69     False
70 
71     When ``tol`` is provided and ``z2`` is non-zero and
72     ``|z1| > 1`` the error is normalized by ``|z1|``:
73 
74     >>> abs(pi4 - 3.14)/pi4
75     0.000509791731426756
76     >>> comp(pi4, 3.14, .001)  # difference less than 0.1%
77     True
78     >>> comp(pi4, 3.14, .0005)  # difference less than 0.1%
79     False
80 
81     When ``|z1| <= 1`` the absolute error is used:
82 
83     >>> 1/pi4
84     0.3183
85     >>> abs(1/pi4 - 0.3183)/(1/pi4)
86     3.07371499106316e-5
87     >>> abs(1/pi4 - 0.3183)
88     9.78393554684764e-6
89     >>> comp(1/pi4, 0.3183, 1e-5)
90     True
91 
92     To see if the absolute error between ``z1`` and ``z2`` is less
93     than or equal to ``tol``, call this as ``comp(z1 - z2, 0, tol)``
94     or ``comp(z1 - z2, tol=tol)``:
95 
96     >>> abs(pi4 - 3.14)
97     0.00160156249999988
98     >>> comp(pi4 - 3.14, 0, .002)
99     True
100     >>> comp(pi4 - 3.14, 0, .001)
101     False
102     """
103     if type(z2) is str:
104         if not pure_complex(z1, or_real=True):
105             raise ValueError('when z2 is a str z1 must be a Number')
106         return str(z1) == z2
107     if not z1:
108         z1, z2 = z2, z1
109     if not z1:
110         return True
111     if not tol:
112         a, b = z1, z2
113         if tol == '':
114             return str(a) == str(b)
115         if tol is None:
116             a, b = sympify(a), sympify(b)
117             if not all(i.is_number for i in (a, b)):
118                 raise ValueError('expecting 2 numbers')
119             fa = a.atoms(Float)
120             fb = b.atoms(Float)
121             if not fa and not fb:
122                 # no floats -- compare exactly
123                 return a == b
124             # get a to be pure_complex
125             for do in range(2):
126                 ca = pure_complex(a, or_real=True)
127                 if not ca:
128                     if fa:
129                         a = a.n(prec_to_dps(min([i._prec for i in fa])))
130                         ca = pure_complex(a, or_real=True)
131                         break
132                     else:
133                         fa, fb = fb, fa
134                         a, b = b, a
135             cb = pure_complex(b)
136             if not cb and fb:
137                 b = b.n(prec_to_dps(min([i._prec for i in fb])))
138                 cb = pure_complex(b, or_real=True)
139             if ca and cb and (ca[1] or cb[1]):
140                 return all(comp(i, j) for i, j in zip(ca, cb))
141             tol = 10**prec_to_dps(min(a._prec, getattr(b, '_prec', a._prec)))
142             return int(abs(a - b)*tol) <= 5
143     diff = abs(z1 - z2)
144     az1 = abs(z1)
145     if z2 and az1 > 1:
146         return diff/az1 <= tol
147     else:
148         return diff <= tol
149 
150 
151 def mpf_norm(mpf, prec):
152     """Return the mpf tuple normalized appropriately for the indicated
153     precision after doing a check to see if zero should be returned or
154     not when the mantissa is 0. ``mpf_normlize`` always assumes that this
155     is zero, but it may not be since the mantissa for mpf's values "+inf",
156     "-inf" and "nan" have a mantissa of zero, too.
157 
158     Note: this is not intended to validate a given mpf tuple, so sending
159     mpf tuples that were not created by mpmath may produce bad results. This
160     is only a wrapper to ``mpf_normalize`` which provides the check for non-
161     zero mpfs that have a 0 for the mantissa.
162     """
163     sign, man, expt, bc = mpf
164     if not man:
165         # hack for mpf_normalize which does not do this;
166         # it assumes that if man is zero the result is 0
167         # (see issue 6639)
168         if not bc:
169             return fzero
170         else:
171             # don't change anything; this should already
172             # be a well formed mpf tuple
173             return mpf
174 
175     # Necessary if mpmath is using the gmpy backend
176     from mpmath.libmp.backend import MPZ
177     rv = mpf_normalize(sign, MPZ(man), expt, bc, prec, rnd)
178     return rv
179 
180 # TODO: we should use the warnings module
181 _errdict = {"divide": False}
182 
183 
184 def seterr(divide=False):
185     """
186     Should sympy raise an exception on 0/0 or return a nan?
187 
188     divide == True .... raise an exception
189     divide == False ... return nan
190     """
191     if _errdict["divide"] != divide:
192         clear_cache()
193         _errdict["divide"] = divide
194 
195 
196 def _as_integer_ratio(p):
197     neg_pow, man, expt, bc = getattr(p, '_mpf_', mpmath.mpf(p)._mpf_)
198     p = [1, -1][neg_pow % 2]*man
199     if expt < 0:
200         q = 2**-expt
201     else:
202         q = 1
203         p *= 2**expt
204     return int(p), int(q)
205 
206 
207 def _decimal_to_Rational_prec(dec):
208     """Convert an ordinary decimal instance to a Rational."""
209     if not dec.is_finite():
210         raise TypeError("dec must be finite, got %s." % dec)
211     s, d, e = dec.as_tuple()
212     prec = len(d)
213     if e >= 0:  # it's an integer
214         rv = Integer(int(dec))
215     else:
216         s = (-1)**s
217         d = sum([di*10**i for i, di in enumerate(reversed(d))])
218         rv = Rational(s*d, 10**-e)
219     return rv, prec
220 
221 
222 _floatpat = regex.compile(r"[-+]?((\d*\.\d+)|(\d+\.?))")
223 def _literal_float(f):
224     """Return True if n starts like a floating point number."""
225     return bool(_floatpat.match(f))
226 
227 # (a,b) -> gcd(a,b)
228 
229 # TODO caching with decorator, but not to degrade performance
230 
231 @lru_cache(1024)
232 def igcd(*args):
233     """Computes nonnegative integer greatest common divisor.
234 
235     Explanation
236     ===========
237 
238     The algorithm is based on the well known Euclid's algorithm. To
239     improve speed, igcd() has its own caching mechanism implemented.
240 
241     Examples
242     ========
243 
244     >>> from sympy.core.numbers import igcd
245     >>> igcd(2, 4)
246     2
247     >>> igcd(5, 10, 15)
248     5
249 
250     """
251     if len(args) < 2:
252         raise TypeError(
253             'igcd() takes at least 2 arguments (%s given)' % len(args))
254     args_temp = [abs(as_int(i)) for i in args]
255     if 1 in args_temp:
256         return 1
257     a = args_temp.pop()
258     if HAS_GMPY: # Using gmpy if present to speed up.
259         for b in args_temp:
260             a = gmpy.gcd(a, b) if b else a
261         return as_int(a)
262     for b in args_temp:
263         a = math.gcd(a, b)
264     return a
265 
266 
267 igcd2 = math.gcd
268 
269 
270 def igcd_lehmer(a, b):
271     """Computes greatest common divisor of two integers.
272 
273     Explanation
274     ===========
275 
276     Euclid's algorithm for the computation of the greatest
277     common divisor  gcd(a, b)  of two (positive) integers
278     a and b is based on the division identity
279         a = q*b + r,
280     where the quotient  q  and the remainder  r  are integers
281     and  0 <= r < b. Then each common divisor of  a  and  b
282     divides  r, and it follows that  gcd(a, b) == gcd(b, r).
283     The algorithm works by constructing the sequence
284     r0, r1, r2, ..., where  r0 = a, r1 = b,  and each  rn
285     is the remainder from the division of the two preceding
286     elements.
287 
288     In Python, q = a // b  and  r = a % b  are obtained by the
289     floor division and the remainder operations, respectively.
290     These are the most expensive arithmetic operations, especially
291     for large  a  and  b.
292 
293     Lehmer's algorithm is based on the observation that the quotients
294     qn = r(n-1) // rn  are in general small integers even
295     when  a  and  b  are very large. Hence the quotients can be
296     usually determined from a relatively small number of most
297     significant bits.
298 
299     The efficiency of the algorithm is further enhanced by not
300     computing each long remainder in Euclid's sequence. The remainders
301     are linear combinations of  a  and  b  with integer coefficients
302     derived from the quotients. The coefficients can be computed
303     as far as the quotients can be determined from the chosen
304     most significant parts of  a  and  b. Only then a new pair of
305     consecutive remainders is computed and the algorithm starts
306     anew with this pair.
307 
308     References
309     ==========
310 
311     .. [1] https://en.wikipedia.org/wiki/Lehmer%27s_GCD_algorithm
312 
313     """
314     a, b = abs(as_int(a)), abs(as_int(b))
315     if a < b:
316         a, b = b, a
317 
318     # The algorithm works by using one or two digit division
319     # whenever possible. The outer loop will replace the
320     # pair (a, b) with a pair of shorter consecutive elements
321     # of the Euclidean gcd sequence until a and b
322     # fit into two Python (long) int digits.
323     nbits = 2*sys.int_info.bits_per_digit
324 
325     while a.bit_length() > nbits and b != 0:
326         # Quotients are mostly small integers that can
327         # be determined from most significant bits.
328         n = a.bit_length() - nbits
329         x, y = int(a >> n), int(b >> n)  # most significant bits
330 
331         # Elements of the Euclidean gcd sequence are linear
332         # combinations of a and b with integer coefficients.
333         # Compute the coefficients of consecutive pairs
334         #     a' = A*a + B*b, b' = C*a + D*b
335         # using small integer arithmetic as far as possible.
336         A, B, C, D = 1, 0, 0, 1  # initial values
337 
338         while True:
339             # The coefficients alternate in sign while looping.
340             # The inner loop combines two steps to keep track
341             # of the signs.
342 
343             # At this point we have
344             #   A > 0, B <= 0, C <= 0, D > 0,
345             #   x' = x + B <= x < x" = x + A,
346             #   y' = y + C <= y < y" = y + D,
347             # and
348             #   x'*N <= a' < x"*N, y'*N <= b' < y"*N,
349             # where N = 2**n.
350 
351             # Now, if y' > 0, and x"//y' and x'//y" agree,
352             # then their common value is equal to  q = a'//b'.
353             # In addition,
354             #   x'%y" = x' - q*y" < x" - q*y' = x"%y',
355             # and
356             #   (x'%y")*N < a'%b' < (x"%y')*N.
357 
358             # On the other hand, we also have  x//y == q,
359             # and therefore
360             #   x'%y" = x + B - q*(y + D) = x%y + B',
361             #   x"%y' = x + A - q*(y + C) = x%y + A',
362             # where
363             #    B' = B - q*D < 0, A' = A - q*C > 0.
364 
365             if y + C <= 0:
366                 break
367             q = (x + A) // (y + C)
368 
369             # Now  x'//y" <= q, and equality holds if
370             #   x' - q*y" = (x - q*y) + (B - q*D) >= 0.
371             # This is a minor optimization to avoid division.
372             x_qy, B_qD = x - q*y, B - q*D
373             if x_qy + B_qD < 0:
374                 break
375 
376             # Next step in the Euclidean sequence.
377             x, y = y, x_qy
378             A, B, C, D = C, D, A - q*C, B_qD
379 
380             # At this point the signs of the coefficients
381             # change and their roles are interchanged.
382             #   A <= 0, B > 0, C > 0, D < 0,
383             #   x' = x + A <= x < x" = x + B,
384             #   y' = y + D < y < y" = y + C.
385 
386             if y + D <= 0:
387                 break
388             q = (x + B) // (y + D)
389             x_qy, A_qC = x - q*y, A - q*C
390             if x_qy + A_qC < 0:
391                 break
392 
393             x, y = y, x_qy
394             A, B, C, D = C, D, A_qC, B - q*D
395             # Now the conditions on top of the loop
396             # are again satisfied.
397             #   A > 0, B < 0, C < 0, D > 0.
398 
399         if B == 0:
400             # This can only happen when y == 0 in the beginning
401             # and the inner loop does nothing.
402             # Long division is forced.
403             a, b = b, a % b
404             continue
405 
406         # Compute new long arguments using the coefficients.
407         a, b = A*a + B*b, C*a + D*b
408 
409     # Small divisors. Finish with the standard algorithm.
410     while b:
411         a, b = b, a % b
412 
413     return a
414 
415 
416 def ilcm(*args):
417     """Computes integer least common multiple.
418 
419     Examples
420     ========
421 
422     >>> from sympy.core.numbers import ilcm
423     >>> ilcm(5, 10)
424     10
425     >>> ilcm(7, 3)
426     21
427     >>> ilcm(5, 10, 15)
428     30
429 
430     """
431     if len(args) < 2:
432         raise TypeError(
433             'ilcm() takes at least 2 arguments (%s given)' % len(args))
434     if 0 in args:
435         return 0
436     a = args[0]
437     for b in args[1:]:
438         a = a // igcd(a, b) * b # since gcd(a,b) | a
439     return a
440 
441 
442 def igcdex(a, b):
443     """Returns x, y, g such that g = x*a + y*b = gcd(a, b).
444 
445     Examples
446     ========
447 
448     >>> from sympy.core.numbers import igcdex
449     >>> igcdex(2, 3)
450     (-1, 1, 1)
451     >>> igcdex(10, 12)
452     (-1, 1, 2)
453 
454     >>> x, y, g = igcdex(100, 2004)
455     >>> x, y, g
456     (-20, 1, 4)
457     >>> x*100 + y*2004
458     4
459 
460     """
461     if (not a) and (not b):
462         return (0, 1, 0)
463 
464     if not a:
465         return (0, b//abs(b), abs(b))
466     if not b:
467         return (a//abs(a), 0, abs(a))
468 
469     if a < 0:
470         a, x_sign = -a, -1
471     else:
472         x_sign = 1
473 
474     if b < 0:
475         b, y_sign = -b, -1
476     else:
477         y_sign = 1
478 
479     x, y, r, s = 1, 0, 0, 1
480 
481     while b:
482         (c, q) = (a % b, a // b)
483         (a, b, r, s, x, y) = (b, c, x - q*r, y - q*s, r, s)
484 
485     return (x*x_sign, y*y_sign, a)
486 
487 
488 def mod_inverse(a, m):
489     """
490     Return the number c such that, (a * c) = 1 (mod m)
491     where c has the same sign as m. If no such value exists,
492     a ValueError is raised.
493 
494     Examples
495     ========
496 
497     >>> from sympy import S
498     >>> from sympy.core.numbers import mod_inverse
499 
500     Suppose we wish to find multiplicative inverse x of
501     3 modulo 11. This is the same as finding x such
502     that 3 * x = 1 (mod 11). One value of x that satisfies
503     this congruence is 4. Because 3 * 4 = 12 and 12 = 1 (mod 11).
504     This is the value returned by mod_inverse:
505 
506     >>> mod_inverse(3, 11)
507     4
508     >>> mod_inverse(-3, 11)
509     7
510 
511     When there is a common factor between the numerators of
512     ``a`` and ``m`` the inverse does not exist:
513 
514     >>> mod_inverse(2, 4)
515     Traceback (most recent call last):
516     ...
517     ValueError: inverse of 2 mod 4 does not exist
518 
519     >>> mod_inverse(S(2)/7, S(5)/2)
520     7/2
521 
522     References
523     ==========
524 
525     .. [1] https://en.wikipedia.org/wiki/Modular_multiplicative_inverse
526     .. [2] https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm
527     """
528     c = None
529     try:
530         a, m = as_int(a), as_int(m)
531         if m != 1 and m != -1:
532             x, y, g = igcdex(a, m)
533             if g == 1:
534                 c = x % m
535     except ValueError:
536         a, m = sympify(a), sympify(m)
537         if not (a.is_number and m.is_number):
538             raise TypeError(filldedent('''
539                 Expected numbers for arguments; symbolic `mod_inverse`
540                 is not implemented
541                 but symbolic expressions can be handled with the
542                 similar function,
543                 sympy.polys.polytools.invert'''))
544         big = (m > 1)
545         if not (big is S.true or big is S.false):
546             raise ValueError('m > 1 did not evaluate; try to simplify %s' % m)
547         elif big:
548             c = 1/a
549     if c is None:
550         raise ValueError('inverse of %s (mod %s) does not exist' % (a, m))
551     return c
552 
553 
554 class Number(AtomicExpr):
555     """Represents atomic numbers in SymPy.
556 
557     Explanation
558     ===========
559 
560     Floating point numbers are represented by the Float class.
561     Rational numbers (of any size) are represented by the Rational class.
562     Integer numbers (of any size) are represented by the Integer class.
563     Float and Rational are subclasses of Number; Integer is a subclass
564     of Rational.
565 
566     For example, ``2/3`` is represented as ``Rational(2, 3)`` which is
567     a different object from the floating point number obtained with
568     Python division ``2/3``. Even for numbers that are exactly
569     represented in binary, there is a difference between how two forms,
570     such as ``Rational(1, 2)`` and ``Float(0.5)``, are used in SymPy.
571     The rational form is to be preferred in symbolic computations.
572 
573     Other kinds of numbers, such as algebraic numbers ``sqrt(2)`` or
574     complex numbers ``3 + 4*I``, are not instances of Number class as
575     they are not atomic.
576 
577     See Also
578     ========
579 
580     Float, Integer, Rational
581     """
582     is_commutative = True
583     is_number = True
584     is_Number = True
585 
586     __slots__ = ()
587 
588     # Used to make max(x._prec, y._prec) return x._prec when only x is a float
589     _prec = -1
590 
591     kind = NumberKind
592 
593     def __new__(cls, *obj):
594         if len(obj) == 1:
595             obj = obj[0]
596 
597         if isinstance(obj, Number):
598             return obj
599         if isinstance(obj, SYMPY_INTS):
600             return Integer(obj)
601         if isinstance(obj, tuple) and len(obj) == 2:
602             return Rational(*obj)
603         if isinstance(obj, (float, mpmath.mpf, decimal.Decimal)):
604             return Float(obj)
605         if isinstance(obj, str):
606             _obj = obj.lower()  # float('INF') == float('inf')
607             if _obj == 'nan':
608                 return S.NaN
609             elif _obj == 'inf':
610                 return S.Infinity
611             elif _obj == '+inf':
612                 return S.Infinity
613             elif _obj == '-inf':
614                 return S.NegativeInfinity
615             val = sympify(obj)
616             if isinstance(val, Number):
617                 return val
618             else:
619                 raise ValueError('String "%s" does not denote a Number' % obj)
620         msg = "expected str|int|long|float|Decimal|Number object but got %r"
621         raise TypeError(msg % type(obj).__name__)
622 
623     def invert(self, other, *gens, **args):
624         from sympy.polys.polytools import invert
625         if getattr(other, 'is_number', True):
626             return mod_inverse(self, other)
627         return invert(self, other, *gens, **args)
628 
629     def __divmod__(self, other):
630         from .containers import Tuple
631         from sympy.functions.elementary.complexes import sign
632 
633         try:
634             other = Number(other)
635             if self.is_infinite or S.NaN in (self, other):
636                 return (S.NaN, S.NaN)
637         except TypeError:
638             return NotImplemented
639         if not other:
640             raise ZeroDivisionError('modulo by zero')
641         if self.is_Integer and other.is_Integer:
642             return Tuple(*divmod(self.p, other.p))
643         elif isinstance(other, Float):
644             rat = self/Rational(other)
645         else:
646             rat = self/other
647         if other.is_finite:
648             w = int(rat) if rat >= 0 else int(rat) - 1
649             r = self - other*w
650         else:
651             w = 0 if not self or (sign(self) == sign(other)) else -1
652             r = other if w else self
653         return Tuple(w, r)
654 
655     def __rdivmod__(self, other):
656         try:
657             other = Number(other)
658         except TypeError:
659             return NotImplemented
660         return divmod(other, self)
661 
662     def _as_mpf_val(self, prec):
663         """Evaluation of mpf tuple accurate to at least prec bits."""
664         raise NotImplementedError('%s needs ._as_mpf_val() method' %
665             (self.__class__.__name__))
666 
667     def _eval_evalf(self, prec):
668         return Float._new(self._as_mpf_val(prec), prec)
669 
670     def _as_mpf_op(self, prec):
671         prec = max(prec, self._prec)
672         return self._as_mpf_val(prec), prec
673 
674     def __float__(self):
675         return mlib.to_float(self._as_mpf_val(53))
676 
677     def floor(self):
678         raise NotImplementedError('%s needs .floor() method' %
679             (self.__class__.__name__))
680 
681     def ceiling(self):
682         raise NotImplementedError('%s needs .ceiling() method' %
683             (self.__class__.__name__))
684 
685     def __floor__(self):
686         return self.floor()
687 
688     def __ceil__(self):
689         return self.ceiling()
690 
691     def _eval_conjugate(self):
692         return self
693 
694     def _eval_order(self, *symbols):
695         from sympy import Order
696         # Order(5, x, y) -> Order(1,x,y)
697         return Order(S.One, *symbols)
698 
699     def _eval_subs(self, old, new):
700         if old == -self:
701             return -new
702         return self  # there is no other possibility
703 
704     def _eval_is_finite(self):
705         return True
706 
707     @classmethod
708     def class_key(cls):
709         return 1, 0, 'Number'
710 
711     @cacheit
712     def sort_key(self, order=None):
713         return self.class_key(), (0, ()), (), self
714 
715     @_sympifyit('other', NotImplemented)
716     def __add__(self, other):
717         if isinstance(other, Number) and global_parameters.evaluate:
718             if other is S.NaN:
719                 return S.NaN
720             elif other is S.Infinity:
721                 return S.Infinity
722             elif other is S.NegativeInfinity:
723                 return S.NegativeInfinity
724         return AtomicExpr.__add__(self, other)
725 
726     @_sympifyit('other', NotImplemented)
727     def __sub__(self, other):
728         if isinstance(other, Number) and global_parameters.evaluate:
729             if other is S.NaN:
730                 return S.NaN
731             elif other is S.Infinity:
732                 return S.NegativeInfinity
733             elif other is S.NegativeInfinity:
734                 return S.Infinity
735         return AtomicExpr.__sub__(self, other)
736 
737     @_sympifyit('other', NotImplemented)
738     def __mul__(self, other):
739         if isinstance(other, Number) and global_parameters.evaluate:
740             if other is S.NaN:
741                 return S.NaN
742             elif other is S.Infinity:
743                 if self.is_zero:
744                     return S.NaN
745                 elif self.is_positive:
746                     return S.Infinity
747                 else:
748                     return S.NegativeInfinity
749             elif other is S.NegativeInfinity:
750                 if self.is_zero:
751                     return S.NaN
752                 elif self.is_positive:
753                     return S.NegativeInfinity
754                 else:
755                     return S.Infinity
756         elif isinstance(other, Tuple):
757             return NotImplemented
758         return AtomicExpr.__mul__(self, other)
759 
760     @_sympifyit('other', NotImplemented)
761     def __truediv__(self, other):
762         if isinstance(other, Number) and global_parameters.evaluate:
763             if other is S.NaN:
764                 return S.NaN
765             elif other is S.Infinity or other is S.NegativeInfinity:
766                 return S.Zero
767         return AtomicExpr.__truediv__(self, other)
768 
769     def __eq__(self, other):
770         raise NotImplementedError('%s needs .__eq__() method' %
771             (self.__class__.__name__))
772 
773     def __ne__(self, other):
774         raise NotImplementedError('%s needs .__ne__() method' %
775             (self.__class__.__name__))
776 
777     def __lt__(self, other):
778         try:
779             other = _sympify(other)
780         except SympifyError:
781             raise TypeError("Invalid comparison %s < %s" % (self, other))
782         raise NotImplementedError('%s needs .__lt__() method' %
783             (self.__class__.__name__))
784 
785     def __le__(self, other):
786         try:
787             other = _sympify(other)
788         except SympifyError:
789             raise TypeError("Invalid comparison %s <= %s" % (self, other))
790         raise NotImplementedError('%s needs .__le__() method' %
791             (self.__class__.__name__))
792 
793     def __gt__(self, other):
794         try:
795             other = _sympify(other)
796         except SympifyError:
797             raise TypeError("Invalid comparison %s > %s" % (self, other))
798         return _sympify(other).__lt__(self)
799 
800     def __ge__(self, other):
801         try:
802             other = _sympify(other)
803         except SympifyError:
804             raise TypeError("Invalid comparison %s >= %s" % (self, other))
805         return _sympify(other).__le__(self)
806 
807     def __hash__(self):
808         return super().__hash__()
809 
810     def is_constant(self, *wrt, **flags):
811         return True
812 
813     def as_coeff_mul(self, *deps, rational=True, **kwargs):
814         # a -> c*t
815         if self.is_Rational or not rational:
816             return self, tuple()
817         elif self.is_negative:
818             return S.NegativeOne, (-self,)
819         return S.One, (self,)
820 
821     def as_coeff_add(self, *deps):
822         # a -> c + t
823         if self.is_Rational:
824             return self, tuple()
825         return S.Zero, (self,)
826 
827     def as_coeff_Mul(self, rational=False):
828         """Efficiently extract the coefficient of a product. """
829         if rational and not self.is_Rational:
830             return S.One, self
831         return (self, S.One) if self else (S.One, self)
832 
833     def as_coeff_Add(self, rational=False):
834         """Efficiently extract the coefficient of a summation. """
835         if not rational:
836             return self, S.Zero
837         return S.Zero, self
838 
839     def gcd(self, other):
840         """Compute GCD of `self` and `other`. """
841         from sympy.polys import gcd
842         return gcd(self, other)
843 
844     def lcm(self, other):
845         """Compute LCM of `self` and `other`. """
846         from sympy.polys import lcm
847         return lcm(self, other)
848 
849     def cofactors(self, other):
850         """Compute GCD and cofactors of `self` and `other`. """
851         from sympy.polys import cofactors
852         return cofactors(self, other)
853 
854 
855 class Float(Number):
856     """Represent a floating-point number of arbitrary precision.
857 
858     Examples
859     ========
860 
861     >>> from sympy import Float
862     >>> Float(3.5)
863     3.50000000000000
864     >>> Float(3)
865     3.00000000000000
866 
867     Creating Floats from strings (and Python ``int`` and ``long``
868     types) will give a minimum precision of 15 digits, but the
869     precision will automatically increase to capture all digits
870     entered.
871 
872     >>> Float(1)
873     1.00000000000000
874     >>> Float(10**20)
875     100000000000000000000.
876     >>> Float('1e20')
877     100000000000000000000.
878 
879     However, *floating-point* numbers (Python ``float`` types) retain
880     only 15 digits of precision:
881 
882     >>> Float(1e20)
883     1.00000000000000e+20
884     >>> Float(1.23456789123456789)
885     1.23456789123457
886 
887     It may be preferable to enter high-precision decimal numbers
888     as strings:
889 
890     >>> Float('1.23456789123456789')
891     1.23456789123456789
892 
893     The desired number of digits can also be specified:
894 
895     >>> Float('1e-3', 3)
896     0.00100
897     >>> Float(100, 4)
898     100.0
899 
900     Float can automatically count significant figures if a null string
901     is sent for the precision; spaces or underscores are also allowed. (Auto-
902     counting is only allowed for strings, ints and longs).
903 
904     >>> Float('123 456 789.123_456', '')
905     123456789.123456
906     >>> Float('12e-3', '')
907     0.012
908     >>> Float(3, '')
909     3.
910 
911     If a number is written in scientific notation, only the digits before the
912     exponent are considered significant if a decimal appears, otherwise the
913     "e" signifies only how to move the decimal:
914 
915     >>> Float('60.e2', '')  # 2 digits significant
916     6.0e+3
917     >>> Float('60e2', '')  # 4 digits significant
918     6000.
919     >>> Float('600e-2', '')  # 3 digits significant
920     6.00
921 
922     Notes
923     =====
924 
925     Floats are inexact by their nature unless their value is a binary-exact
926     value.
927 
928     >>> approx, exact = Float(.1, 1), Float(.125, 1)
929 
930     For calculation purposes, evalf needs to be able to change the precision
931     but this will not increase the accuracy of the inexact value. The
932     following is the most accurate 5-digit approximation of a value of 0.1
933     that had only 1 digit of precision:
934 
935     >>> approx.evalf(5)
936     0.099609
937 
938     By contrast, 0.125 is exact in binary (as it is in base 10) and so it
939     can be passed to Float or evalf to obtain an arbitrary precision with
940     matching accuracy:
941 
942     >>> Float(exact, 5)
943     0.12500
944     >>> exact.evalf(20)
945     0.12500000000000000000
946 
947     Trying to make a high-precision Float from a float is not disallowed,
948     but one must keep in mind that the *underlying float* (not the apparent
949     decimal value) is being obtained with high precision. For example, 0.3
950     does not have a finite binary representation. The closest rational is
951     the fraction 5404319552844595/2**54. So if you try to obtain a Float of
952     0.3 to 20 digits of precision you will not see the same thing as 0.3
953     followed by 19 zeros:
954 
955     >>> Float(0.3, 20)
956     0.29999999999999998890
957 
958     If you want a 20-digit value of the decimal 0.3 (not the floating point
959     approximation of 0.3) you should send the 0.3 as a string. The underlying
960     representation is still binary but a higher precision than Python's float
961     is used:
962 
963     >>> Float('0.3', 20)
964     0.30000000000000000000
965 
966     Although you can increase the precision of an existing Float using Float
967     it will not increase the accuracy -- the underlying value is not changed:
968 
969     >>> def show(f): # binary rep of Float
970     ...     from sympy import Mul, Pow
971     ...     s, m, e, b = f._mpf_
972     ...     v = Mul(int(m), Pow(2, int(e), evaluate=False), evaluate=False)
973     ...     print('%s at prec=%s' % (v, f._prec))
974     ...
975     >>> t = Float('0.3', 3)
976     >>> show(t)
977     4915/2**14 at prec=13
978     >>> show(Float(t, 20)) # higher prec, not higher accuracy
979     4915/2**14 at prec=70
980     >>> show(Float(t, 2)) # lower prec
981     307/2**10 at prec=10
982 
983     The same thing happens when evalf is used on a Float:
984 
985     >>> show(t.evalf(20))
986     4915/2**14 at prec=70
987     >>> show(t.evalf(2))
988     307/2**10 at prec=10
989 
990     Finally, Floats can be instantiated with an mpf tuple (n, c, p) to
991     produce the number (-1)**n*c*2**p:
992 
993     >>> n, c, p = 1, 5, 0
994     >>> (-1)**n*c*2**p
995     -5
996     >>> Float((1, 5, 0))
997     -5.00000000000000
998 
999     An actual mpf tuple also contains the number of bits in c as the last
1000     element of the tuple:
1001 
1002     >>> _._mpf_
1003     (1, 5, 0, 3)
1004 
1005     This is not needed for instantiation and is not the same thing as the
1006     precision. The mpf tuple and the precision are two separate quantities
1007     that Float tracks.
1008 
1009     In SymPy, a Float is a number that can be computed with arbitrary
1010     precision. Although floating point 'inf' and 'nan' are not such
1011     numbers, Float can create these numbers:
1012 
1013     >>> Float('-inf')
1014     -oo
1015     >>> _.is_Float
1016     False
1017     """
1018     __slots__ = ('_mpf_', '_prec')
1019 
1020     # A Float represents many real numbers,
1021     # both rational and irrational.
1022     is_rational = None
1023     is_irrational = None
1024     is_number = True
1025 
1026     is_real = True
1027     is_extended_real = True
1028 
1029     is_Float = True
1030 
1031     def __new__(cls, num, dps=None, prec=None, precision=None):
1032         if prec is not None:
1033             SymPyDeprecationWarning(
1034                             feature="Using 'prec=XX' to denote decimal precision",
1035                             useinstead="'dps=XX' for decimal precision and 'precision=XX' "\
1036                                               "for binary precision",
1037                             issue=12820,
1038                             deprecated_since_version="1.1").warn()
1039             dps = prec
1040         del prec  # avoid using this deprecated kwarg
1041 
1042         if dps is not None and precision is not None:
1043             raise ValueError('Both decimal and binary precision supplied. '
1044                              'Supply only one. ')
1045 
1046         if isinstance(num, str):
1047             # Float accepts spaces as digit separators
1048             num = num.replace(' ', '').lower()
1049             # in Py 3.6
1050             # underscores are allowed. In anticipation of that, we ignore
1051             # legally placed underscores
1052             if '_' in num:
1053                 parts = num.split('_')
1054                 if not (all(parts) and
1055                         all(parts[i][-1].isdigit()
1056                             for i in range(0, len(parts), 2)) and
1057                         all(parts[i][0].isdigit()
1058                             for i in range(1, len(parts), 2))):
1059                     # copy Py 3.6 error
1060                     raise ValueError("could not convert string to float: '%s'" % num)
1061                 num = ''.join(parts)
1062             if num.startswith('.') and len(num) > 1:
1063                 num = '0' + num
1064             elif num.startswith('-.') and len(num) > 2:
1065                 num = '-0.' + num[2:]
1066             elif num in ('inf', '+inf'):
1067                 return S.Infinity
1068             elif num == '-inf':
1069                 return S.NegativeInfinity
1070         elif isinstance(num, float) and num == 0:
1071             num = '0'
1072         elif isinstance(num, float) and num == float('inf'):
1073             return S.Infinity
1074         elif isinstance(num, float) and num == float('-inf'):
1075             return S.NegativeInfinity
1076         elif isinstance(num, float) and num == float('nan'):
1077             return S.NaN
1078         elif isinstance(num, (SYMPY_INTS, Integer)):
1079             num = str(num)
1080         elif num is S.Infinity:
1081             return num
1082         elif num is S.NegativeInfinity:
1083             return num
1084         elif num is S.NaN:
1085             return num
1086         elif _is_numpy_instance(num):  # support for numpy datatypes
1087             num = _convert_numpy_types(num)
1088         elif isinstance(num, mpmath.mpf):
1089             if precision is None:
1090                 if dps is None:
1091                     precision = num.context.prec
1092             num = num._mpf_
1093 
1094         if dps is None and precision is None:
1095             dps = 15
1096             if isinstance(num, Float):
1097                 return num
1098             if isinstance(num, str) and _literal_float(num):
1099                 try:
1100                     Num = decimal.Decimal(num)
1101                 except decimal.InvalidOperation:
1102                     pass
1103                 else:
1104                     isint = '.' not in num
1105                     num, dps = _decimal_to_Rational_prec(Num)
1106                     if num.is_Integer and isint:
1107                         dps = max(dps, len(str(num).lstrip('-')))
1108                     dps = max(15, dps)
1109                     precision = mlib.libmpf.dps_to_prec(dps)
1110         elif precision == '' and dps is None or precision is None and dps == '':
1111             if not isinstance(num, str):
1112                 raise ValueError('The null string can only be used when '
1113                 'the number to Float is passed as a string or an integer.')
1114             ok = None
1115             if _literal_float(num):
1116                 try:
1117                     Num = decimal.Decimal(num)
1118                 except decimal.InvalidOperation:
1119                     pass
1120                 else:
1121                     isint = '.' not in num
1122                     num, dps = _decimal_to_Rational_prec(Num)
1123                     if num.is_Integer and isint:
1124                         dps = max(dps, len(str(num).lstrip('-')))
1125                         precision = mlib.libmpf.dps_to_prec(dps)
1126                     ok = True
1127             if ok is None:
1128                 raise ValueError('string-float not recognized: %s' % num)
1129 
1130         # decimal precision(dps) is set and maybe binary precision(precision)
1131         # as well.From here on binary precision is used to compute the Float.
1132         # Hence, if supplied use binary precision else translate from decimal
1133         # precision.
1134 
1135         if precision is None or precision == '':
1136             precision = mlib.libmpf.dps_to_prec(dps)
1137 
1138         precision = int(precision)
1139 
1140         if isinstance(num, float):
1141             _mpf_ = mlib.from_float(num, precision, rnd)
1142         elif isinstance(num, str):
1143             _mpf_ = mlib.from_str(num, precision, rnd)
1144         elif isinstance(num, decimal.Decimal):
1145             if num.is_finite():
1146                 _mpf_ = mlib.from_str(str(num), precision, rnd)
1147             elif num.is_nan():
1148                 return S.NaN
1149             elif num.is_infinite():
1150                 if num > 0:
1151                     return S.Infinity
1152                 return S.NegativeInfinity
1153             else:
1154                 raise ValueError("unexpected decimal value %s" % str(num))
1155         elif isinstance(num, tuple) and len(num) in (3, 4):
1156             if type(num[1]) is str:
1157                 # it's a hexadecimal (coming from a pickled object)
1158                 # assume that it is in standard form
1159                 num = list(num)
1160                 # If we're loading an object pickled in Python 2 into
1161                 # Python 3, we may need to strip a tailing 'L' because
1162                 # of a shim for int on Python 3, see issue #13470.
1163                 if num[1].endswith('L'):
1164                     num[1] = num[1][:-1]
1165                 num[1] = MPZ(num[1], 16)
1166                 _mpf_ = tuple(num)
1167             else:
1168                 if len(num) == 4:
1169                     # handle normalization hack
1170                     return Float._new(num, precision)
1171                 else:
1172                     if not all((
1173                             num[0] in (0, 1),
1174                             num[1] >= 0,
1175                             all(type(i) in (int, int) for i in num)
1176                             )):
1177                         raise ValueError('malformed mpf: %s' % (num,))
1178                     # don't compute number or else it may
1179                     # over/underflow
1180                     return Float._new(
1181                         (num[0], num[1], num[2], bitcount(num[1])),
1182                         precision)
1183         else:
1184             try:
1185                 _mpf_ = num._as_mpf_val(precision)
1186             except (NotImplementedError, AttributeError):
1187                 _mpf_ = mpmath.mpf(num, prec=precision)._mpf_
1188 
1189         return cls._new(_mpf_, precision, zero=False)
1190 
1191     @classmethod
1192     def _new(cls, _mpf_, _prec, zero=True):
1193         # special cases
1194         if zero and _mpf_ == fzero:
1195             return S.Zero  # Float(0) -> 0.0; Float._new((0,0,0,0)) -> 0
1196         elif _mpf_ == _mpf_nan:
1197             return S.NaN
1198         elif _mpf_ == _mpf_inf:
1199             return S.Infinity
1200         elif _mpf_ == _mpf_ninf:
1201             return S.NegativeInfinity
1202 
1203         obj = Expr.__new__(cls)
1204         obj._mpf_ = mpf_norm(_mpf_, _prec)
1205         obj._prec = _prec
1206         return obj
1207 
1208     # mpz can't be pickled
1209     def __getnewargs_ex__(self):
1210         return ((mlib.to_pickable(self._mpf_),), {'precision': self._prec})
1211 
1212     def _hashable_content(self):
1213         return (self._mpf_, self._prec)
1214 
1215     def floor(self):
1216         return Integer(int(mlib.to_int(
1217             mlib.mpf_floor(self._mpf_, self._prec))))
1218 
1219     def ceiling(self):
1220         return Integer(int(mlib.to_int(
1221             mlib.mpf_ceil(self._mpf_, self._prec))))
1222 
1223     def __floor__(self):
1224         return self.floor()
1225 
1226     def __ceil__(self):
1227         return self.ceiling()
1228 
1229     @property
1230     def num(self):
1231         return mpmath.mpf(self._mpf_)
1232 
1233     def _as_mpf_val(self, prec):
1234         rv = mpf_norm(self._mpf_, prec)
1235         if rv != self._mpf_ and self._prec == prec:
1236             debug(self._mpf_, rv)
1237         return rv
1238 
1239     def _as_mpf_op(self, prec):
1240         return self._mpf_, max(prec, self._prec)
1241 
1242     def _eval_is_finite(self):
1243         if self._mpf_ in (_mpf_inf, _mpf_ninf):
1244             return False
1245         return True
1246 
1247     def _eval_is_infinite(self):
1248         if self._mpf_ in (_mpf_inf, _mpf_ninf):
1249             return True
1250         return False
1251 
1252     def _eval_is_integer(self):
1253         return self._mpf_ == fzero
1254 
1255     def _eval_is_negative(self):
1256         if self._mpf_ == _mpf_ninf or self._mpf_ == _mpf_inf:
1257             return False
1258         return self.num < 0
1259 
1260     def _eval_is_positive(self):
1261         if self._mpf_ == _mpf_ninf or self._mpf_ == _mpf_inf:
1262             return False
1263         return self.num > 0
1264 
1265     def _eval_is_extended_negative(self):
1266         if self._mpf_ == _mpf_ninf:
1267             return True
1268         if self._mpf_ == _mpf_inf:
1269             return False
1270         return self.num < 0
1271 
1272     def _eval_is_extended_positive(self):
1273         if self._mpf_ == _mpf_inf:
1274             return True
1275         if self._mpf_ == _mpf_ninf:
1276             return False
1277         return self.num > 0
1278 
1279     def _eval_is_zero(self):
1280         return self._mpf_ == fzero
1281 
1282     def __bool__(self):
1283         return self._mpf_ != fzero
1284 
1285     def __neg__(self):
1286         return Float._new(mlib.mpf_neg(self._mpf_), self._prec)
1287 
1288     @_sympifyit('other', NotImplemented)
1289     def __add__(self, other):
1290         if isinstance(other, Number) and global_parameters.evaluate:
1291             rhs, prec = other._as_mpf_op(self._prec)
1292             return Float._new(mlib.mpf_add(self._mpf_, rhs, prec, rnd), prec)
1293         return Number.__add__(self, other)
1294 
1295     @_sympifyit('other', NotImplemented)
1296     def __sub__(self, other):
1297         if isinstance(other, Number) and global_parameters.evaluate:
1298             rhs, prec = other._as_mpf_op(self._prec)
1299             return Float._new(mlib.mpf_sub(self._mpf_, rhs, prec, rnd), prec)
1300         return Number.__sub__(self, other)
1301 
1302     @_sympifyit('other', NotImplemented)
1303     def __mul__(self, other):
1304         if isinstance(other, Number) and global_parameters.evaluate:
1305             rhs, prec = other._as_mpf_op(self._prec)
1306             return Float._new(mlib.mpf_mul(self._mpf_, rhs, prec, rnd), prec)
1307         return Number.__mul__(self, other)
1308 
1309     @_sympifyit('other', NotImplemented)
1310     def __truediv__(self, other):
1311         if isinstance(other, Number) and other != 0 and global_parameters.evaluate:
1312             rhs, prec = other._as_mpf_op(self._prec)
1313             return Float._new(mlib.mpf_div(self._mpf_, rhs, prec, rnd), prec)
1314         return Number.__truediv__(self, other)
1315 
1316     @_sympifyit('other', NotImplemented)
1317     def __mod__(self, other):
1318         if isinstance(other, Rational) and other.q != 1 and global_parameters.evaluate:
1319             # calculate mod with Rationals, *then* round the result
1320             return Float(Rational.__mod__(Rational(self), other),
1321                          precision=self._prec)
1322         if isinstance(other, Float) and global_parameters.evaluate:
1323             r = self/other
1324             if r == int(r):
1325                 return Float(0, precision=max(self._prec, other._prec))
1326         if isinstance(other, Number) and global_parameters.evaluate:
1327             rhs, prec = other._as_mpf_op(self._prec)
1328             return Float._new(mlib.mpf_mod(self._mpf_, rhs, prec, rnd), prec)
1329         return Number.__mod__(self, other)
1330 
1331     @_sympifyit('other', NotImplemented)
1332     def __rmod__(self, other):
1333         if isinstance(other, Float) and global_parameters.evaluate:
1334             return other.__mod__(self)
1335         if isinstance(other, Number) and global_parameters.evaluate:
1336             rhs, prec = other._as_mpf_op(self._prec)
1337             return Float._new(mlib.mpf_mod(rhs, self._mpf_, prec, rnd), prec)
1338         return Number.__rmod__(self, other)
1339 
1340     def _eval_power(self, expt):
1341         """
1342         expt is symbolic object but not equal to 0, 1
1343 
1344         (-p)**r -> exp(r*log(-p)) -> exp(r*(log(p) + I*Pi)) ->
1345                   -> p**r*(sin(Pi*r) + cos(Pi*r)*I)
1346         """
1347         if self == 0:
1348             if expt.is_positive:
1349                 return S.Zero
1350             if expt.is_negative:
1351                 return S.Infinity
1352         if isinstance(expt, Number):
1353             if isinstance(expt, Integer):
1354                 prec = self._prec
1355                 return Float._new(
1356                     mlib.mpf_pow_int(self._mpf_, expt.p, prec, rnd), prec)
1357             elif isinstance(expt, Rational) and \
1358                     expt.p == 1 and expt.q % 2 and self.is_negative:
1359                 return Pow(S.NegativeOne, expt, evaluate=False)*(
1360                     -self)._eval_power(expt)
1361             expt, prec = expt._as_mpf_op(self._prec)
1362             mpfself = self._mpf_
1363             try:
1364                 y = mpf_pow(mpfself, expt, prec, rnd)
1365                 return Float._new(y, prec)
1366             except mlib.ComplexResult:
1367                 re, im = mlib.mpc_pow(
1368                     (mpfself, fzero), (expt, fzero), prec, rnd)
1369                 return Float._new(re, prec) + \
1370                     Float._new(im, prec)*S.ImaginaryUnit
1371 
1372     def __abs__(self):
1373         return Float._new(mlib.mpf_abs(self._mpf_), self._prec)
1374 
1375     def __int__(self):
1376         if self._mpf_ == fzero:
1377             return 0
1378         return int(mlib.to_int(self._mpf_))  # uses round_fast = round_down
1379 
1380     def __eq__(self, other):
1381         from sympy.logic.boolalg import Boolean
1382         try:
1383             other = _sympify(other)
1384         except SympifyError:
1385             return NotImplemented
1386         if isinstance(other, Boolean):
1387             return False
1388         if other.is_NumberSymbol:
1389             if other.is_irrational:
1390                 return False
1391             return other.__eq__(self)
1392         if other.is_Float:
1393             # comparison is exact
1394             # so Float(.1, 3) != Float(.1, 33)
1395             return self._mpf_ == other._mpf_
1396         if other.is_Rational:
1397             return other.__eq__(self)
1398         if other.is_Number:
1399             # numbers should compare at the same precision;
1400             # all _as_mpf_val routines should be sure to abide
1401             # by the request to change the prec if necessary; if
1402             # they don't, the equality test will fail since it compares
1403             # the mpf tuples
1404             ompf = other._as_mpf_val(self._prec)
1405             return bool(mlib.mpf_eq(self._mpf_, ompf))
1406         if not self:
1407             return not other
1408         return False    # Float != non-Number
1409 
1410     def __ne__(self, other):
1411         return not self == other
1412 
1413     def _Frel(self, other, op):
1414         from sympy.core.numbers import prec_to_dps
1415         try:
1416             other = _sympify(other)
1417         except SympifyError:
1418             return NotImplemented
1419         if other.is_Rational:
1420             # test self*other.q <?> other.p without losing precision
1421             '''
1422             >>> f = Float(.1,2)
1423             >>> i = 1234567890
1424             >>> (f*i)._mpf_
1425             (0, 471, 18, 9)
1426             >>> mlib.mpf_mul(f._mpf_, mlib.from_int(i))
1427             (0, 505555550955, -12, 39)
1428             '''
1429             smpf = mlib.mpf_mul(self._mpf_, mlib.from_int(other.q))
1430             ompf = mlib.from_int(other.p)
1431             return _sympify(bool(op(smpf, ompf)))
1432         elif other.is_Float:
1433             return _sympify(bool(
1434                         op(self._mpf_, other._mpf_)))
1435         elif other.is_comparable and other not in (
1436                 S.Infinity, S.NegativeInfinity):
1437             other = other.evalf(prec_to_dps(self._prec))
1438             if other._prec > 1:
1439                 if other.is_Number:
1440                     return _sympify(bool(
1441                         op(self._mpf_, other._as_mpf_val(self._prec))))
1442 
1443     def __gt__(self, other):
1444         if isinstance(other, NumberSymbol):
1445             return other.__lt__(self)
1446         rv = self._Frel(other, mlib.mpf_gt)
1447         if rv is None:
1448             return Expr.__gt__(self, other)
1449         return rv
1450 
1451     def __ge__(self, other):
1452         if isinstance(other, NumberSymbol):
1453             return other.__le__(self)
1454         rv = self._Frel(other, mlib.mpf_ge)
1455         if rv is None:
1456             return Expr.__ge__(self, other)
1457         return rv
1458 
1459     def __lt__(self, other):
1460         if isinstance(other, NumberSymbol):
1461             return other.__gt__(self)
1462         rv = self._Frel(other, mlib.mpf_lt)
1463         if rv is None:
1464             return Expr.__lt__(self, other)
1465         return rv
1466 
1467     def __le__(self, other):
1468         if isinstance(other, NumberSymbol):
1469             return other.__ge__(self)
1470         rv = self._Frel(other, mlib.mpf_le)
1471         if rv is None:
1472             return Expr.__le__(self, other)
1473         return rv
1474 
1475     def __hash__(self):
1476         return super().__hash__()
1477 
1478     def epsilon_eq(self, other, epsilon="1e-15"):
1479         return abs(self - other) < Float(epsilon)
1480 
1481     def _sage_(self):
1482         import sage.all as sage
1483         return sage.RealNumber(str(self))
1484 
1485     def __format__(self, format_spec):
1486         return format(decimal.Decimal(str(self)), format_spec)
1487 
1488 
1489 # Add sympify converters
1490 converter[float] = converter[decimal.Decimal] = Float
1491 
1492 # this is here to work nicely in Sage
1493 RealNumber = Float
1494 
1495 
1496 class Rational(Number):
1497     """Represents rational numbers (p/q) of any size.
1498 
1499     Examples
1500     ========
1501 
1502     >>> from sympy import Rational, nsimplify, S, pi
1503     >>> Rational(1, 2)
1504     1/2
1505 
1506     Rational is unprejudiced in accepting input. If a float is passed, the
1507     underlying value of the binary representation will be returned:
1508 
1509     >>> Rational(.5)
1510     1/2
1511     >>> Rational(.2)
1512     3602879701896397/18014398509481984
1513 
1514     If the simpler representation of the float is desired then consider
1515     limiting the denominator to the desired value or convert the float to
1516     a string (which is roughly equivalent to limiting the denominator to
1517     10**12):
1518 
1519     >>> Rational(str(.2))
1520     1/5
1521     >>> Rational(.2).limit_denominator(10**12)
1522     1/5
1523 
1524     An arbitrarily precise Rational is obtained when a string literal is
1525     passed:
1526 
1527     >>> Rational("1.23")
1528     123/100
1529     >>> Rational('1e-2')
1530     1/100
1531     >>> Rational(".1")
1532     1/10
1533     >>> Rational('1e-2/3.2')
1534     1/320
1535 
1536     The conversion of other types of strings can be handled by
1537     the sympify() function, and conversion of floats to expressions
1538     or simple fractions can be handled with nsimplify:
1539 
1540     >>> S('.[3]')  # repeating digits in brackets
1541     1/3
1542     >>> S('3**2/10')  # general expressions
1543     9/10
1544     >>> nsimplify(.3)  # numbers that have a simple form
1545     3/10
1546 
1547     But if the input does not reduce to a literal Rational, an error will
1548     be raised:
1549 
1550     >>> Rational(pi)
1551     Traceback (most recent call last):
1552     ...
1553     TypeError: invalid input: pi
1554 
1555 
1556     Low-level
1557     ---------
1558 
1559     Access numerator and denominator as .p and .q:
1560 
1561     >>> r = Rational(3, 4)
1562     >>> r
1563     3/4
1564     >>> r.p
1565     3
1566     >>> r.q
1567     4
1568 
1569     Note that p and q return integers (not SymPy Integers) so some care
1570     is needed when using them in expressions:
1571 
1572     >>> r.p/r.q
1573     0.75
1574 
1575     See Also
1576     ========
1577     sympy.core.sympify.sympify, sympy.simplify.simplify.nsimplify
1578     """
1579     is_real = True
1580     is_integer = False
1581     is_rational = True
1582     is_number = True
1583 
1584     __slots__ = ('p', 'q')
1585 
1586     is_Rational = True
1587 
1588     @cacheit
1589     def __new__(cls, p, q=None, gcd=None):
1590         if q is None:
1591             if isinstance(p, Rational):
1592                 return p
1593 
1594             if isinstance(p, SYMPY_INTS):
1595                 pass
1596             else:
1597                 if isinstance(p, (float, Float)):
1598                     return Rational(*_as_integer_ratio(p))
1599 
1600                 if not isinstance(p, str):
1601                     try:
1602                         p = sympify(p)
1603                     except (SympifyError, SyntaxError):
1604                         pass  # error will raise below
1605                 else:
1606                     if p.count('/') > 1:
1607                         raise TypeError('invalid input: %s' % p)
1608                     p = p.replace(' ', '')
1609                     pq = p.rsplit('/', 1)
1610                     if len(pq) == 2:
1611                         p, q = pq
1612                         fp = fractions.Fraction(p)
1613                         fq = fractions.Fraction(q)
1614                         p = fp/fq
1615                     try:
1616                         p = fractions.Fraction(p)
1617                     except ValueError:
1618                         pass  # error will raise below
1619                     else:
1620                         return Rational(p.numerator, p.denominator, 1)
1621 
1622                 if not isinstance(p, Rational):
1623                     raise TypeError('invalid input: %s' % p)
1624 
1625             q = 1
1626             gcd = 1
1627         else:
1628             p = Rational(p)
1629             q = Rational(q)
1630 
1631         if isinstance(q, Rational):
1632             p *= q.q
1633             q = q.p
1634         if isinstance(p, Rational):
1635             q *= p.q
1636             p = p.p
1637 
1638         # p and q are now integers
1639         if q == 0:
1640             if p == 0:
1641                 if _errdict["divide"]:
1642                     raise ValueError("Indeterminate 0/0")
1643                 else:
1644                     return S.NaN
1645             return S.ComplexInfinity
1646         if q < 0:
1647             q = -q
1648             p = -p
1649         if not gcd:
1650             gcd = igcd(abs(p), q)
1651         if gcd > 1:
1652             p //= gcd
1653             q //= gcd
1654         if q == 1:
1655             return Integer(p)
1656         if p == 1 and q == 2:
1657             return S.Half
1658         obj = Expr.__new__(cls)
1659         obj.p = p
1660         obj.q = q
1661         return obj
1662 
1663     def limit_denominator(self, max_denominator=1000000):
1664         """Closest Rational to self with denominator at most max_denominator.
1665 
1666         Examples
1667         ========
1668 
1669         >>> from sympy import Rational
1670         >>> Rational('3.141592653589793').limit_denominator(10)
1671         22/7
1672         >>> Rational('3.141592653589793').limit_denominator(100)
1673         311/99
1674 
1675         """
1676         f = fractions.Fraction(self.p, self.q)
1677         return Rational(f.limit_denominator(fractions.Fraction(int(max_denominator))))
1678 
1679     def __getnewargs__(self):
1680         return (self.p, self.q)
1681 
1682     def _hashable_content(self):
1683         return (self.p, self.q)
1684 
1685     def _eval_is_positive(self):
1686         return self.p > 0
1687 
1688     def _eval_is_zero(self):
1689         return self.p == 0
1690 
1691     def __neg__(self):
1692         return Rational(-self.p, self.q)
1693 
1694     @_sympifyit('other', NotImplemented)
1695     def __add__(self, other):
1696         if global_parameters.evaluate:
1697             if isinstance(other, Integer):
1698                 return Rational(self.p + self.q*other.p, self.q, 1)
1699             elif isinstance(other, Rational):
1700                 #TODO: this can probably be optimized more
1701                 return Rational(self.p*other.q + self.q*other.p, self.q*other.q)
1702             elif isinstance(other, Float):
1703                 return other + self
1704             else:
1705                 return Number.__add__(self, other)
1706         return Number.__add__(self, other)
1707     __radd__ = __add__
1708 
1709     @_sympifyit('other', NotImplemented)
1710     def __sub__(self, other):
1711         if global_parameters.evaluate:
1712             if isinstance(other, Integer):
1713                 return Rational(self.p - self.q*other.p, self.q, 1)
1714             elif isinstance(other, Rational):
1715                 return Rational(self.p*other.q - self.q*other.p, self.q*other.q)
1716             elif isinstance(other, Float):
1717                 return -other + self
1718             else:
1719                 return Number.__sub__(self, other)
1720         return Number.__sub__(self, other)
1721     @_sympifyit('other', NotImplemented)
1722     def __rsub__(self, other):
1723         if global_parameters.evaluate:
1724             if isinstance(other, Integer):
1725                 return Rational(self.q*other.p - self.p, self.q, 1)
1726             elif isinstance(other, Rational):
1727                 return Rational(self.q*other.p - self.p*other.q, self.q*other.q)
1728             elif isinstance(other, Float):
1729                 return -self + other
1730             else:
1731                 return Number.__rsub__(self, other)
1732         return Number.__rsub__(self, other)
1733     @_sympifyit('other', NotImplemented)
1734     def __mul__(self, other):
1735         if global_parameters.evaluate:
1736             if isinstance(other, Integer):
1737                 return Rational(self.p*other.p, self.q, igcd(other.p, self.q))
1738             elif isinstance(other, Rational):
1739                 return Rational(self.p*other.p, self.q*other.q, igcd(self.p, other.q)*igcd(self.q, other.p))
1740             elif isinstance(other, Float):
1741                 return other*self
1742             else:
1743                 return Number.__mul__(self, other)
1744         return Number.__mul__(self, other)
1745     __rmul__ = __mul__
1746 
1747     @_sympifyit('other', NotImplemented)
1748     def __truediv__(self, other):
1749         if global_parameters.evaluate:
1750             if isinstance(other, Integer):
1751                 if self.p and other.p == S.Zero:
1752                     return S.ComplexInfinity
1753                 else:
1754                     return Rational(self.p, self.q*other.p, igcd(self.p, other.p))
1755             elif isinstance(other, Rational):
1756                 return Rational(self.p*other.q, self.q*other.p, igcd(self.p, other.p)*igcd(self.q, other.q))
1757             elif isinstance(other, Float):
1758                 return self*(1/other)
1759             else:
1760                 return Number.__truediv__(self, other)
1761         return Number.__truediv__(self, other)
1762     @_sympifyit('other', NotImplemented)
1763     def __rtruediv__(self, other):
1764         if global_parameters.evaluate:
1765             if isinstance(other, Integer):
1766                 return Rational(other.p*self.q, self.p, igcd(self.p, other.p))
1767             elif isinstance(other, Rational):
1768                 return Rational(other.p*self.q, other.q*self.p, igcd(self.p, other.p)*igcd(self.q, other.q))
1769             elif isinstance(other, Float):
1770                 return other*(1/self)
1771             else:
1772                 return Number.__rtruediv__(self, other)
1773         return Number.__rtruediv__(self, other)
1774 
1775     @_sympifyit('other', NotImplemented)
1776     def __mod__(self, other):
1777         if global_parameters.evaluate:
1778             if isinstance(other, Rational):
1779                 n = (self.p*other.q) // (other.p*self.q)
1780                 return Rational(self.p*other.q - n*other.p*self.q, self.q*other.q)
1781             if isinstance(other, Float):
1782                 # calculate mod with Rationals, *then* round the answer
1783                 return Float(self.__mod__(Rational(other)),
1784                              precision=other._prec)
1785             return Number.__mod__(self, other)
1786         return Number.__mod__(self, other)
1787 
1788     @_sympifyit('other', NotImplemented)
1789     def __rmod__(self, other):
1790         if isinstance(other, Rational):
1791             return Rational.__mod__(other, self)
1792         return Number.__rmod__(self, other)
1793 
1794     def _eval_power(self, expt):
1795         if isinstance(expt, Number):
1796             if isinstance(expt, Float):
1797                 return self._eval_evalf(expt._prec)**expt
1798             if expt.is_extended_negative:
1799                 # (3/4)**-2 -> (4/3)**2
1800                 ne = -expt
1801                 if (ne is S.One):
1802                     return Rational(self.q, self.p)
1803                 if self.is_negative:
1804                     return S.NegativeOne**expt*Rational(self.q, -self.p)**ne
1805                 else:
1806                     return Rational(self.q, self.p)**ne
1807             if expt is S.Infinity:  # -oo already caught by test for negative
1808                 if self.p > self.q:
1809                     # (3/2)**oo -> oo
1810                     return S.Infinity
1811                 if self.p < -self.q:
1812                     # (-3/2)**oo -> oo + I*oo
1813                     return S.Infinity + S.Infinity*S.ImaginaryUnit
1814                 return S.Zero
1815             if isinstance(expt, Integer):
1816                 # (4/3)**2 -> 4**2 / 3**2
1817                 return Rational(self.p**expt.p, self.q**expt.p, 1)
1818             if isinstance(expt, Rational):
1819                 if self.p != 1:
1820                     # (4/3)**(5/6) -> 4**(5/6)*3**(-5/6)
1821                     return Integer(self.p)**expt*Integer(self.q)**(-expt)
1822                 # as the above caught negative self.p, now self is positive
1823                 return Integer(self.q)**Rational(
1824                 expt.p*(expt.q - 1), expt.q) / \
1825                     Integer(self.q)**Integer(expt.p)
1826 
1827         if self.is_extended_negative and expt.is_even:
1828             return (-self)**expt
1829 
1830         return
1831 
1832     def _as_mpf_val(self, prec):
1833         return mlib.from_rational(self.p, self.q, prec, rnd)
1834 
1835     def _mpmath_(self, prec, rnd):
1836         return mpmath.make_mpf(mlib.from_rational(self.p, self.q, prec, rnd))
1837 
1838     def __abs__(self):
1839         return Rational(abs(self.p), self.q)
1840 
1841     def __int__(self):
1842         p, q = self.p, self.q
1843         if p < 0:
1844             return -int(-p//q)
1845         return int(p//q)
1846 
1847     def floor(self):
1848         return Integer(self.p // self.q)
1849 
1850     def ceiling(self):
1851         return -Integer(-self.p // self.q)
1852 
1853     def __floor__(self):
1854         return self.floor()
1855 
1856     def __ceil__(self):
1857         return self.ceiling()
1858 
1859     def __eq__(self, other):
1860         from sympy.core.power import integer_log
1861         try:
1862             other = _sympify(other)
1863         except SympifyError:
1864             return NotImplemented
1865         if not isinstance(other, Number):
1866             # S(0) == S.false is False
1867             # S(0) == False is True
1868             return False
1869         if not self:
1870             return not other
1871         if other.is_NumberSymbol:
1872             if other.is_irrational:
1873                 return False
1874             return other.__eq__(self)
1875         if other.is_Rational:
1876             # a Rational is always in reduced form so will never be 2/4
1877             # so we can just check equivalence of args
1878             return self.p == other.p and self.q == other.q
1879         if other.is_Float:
1880             # all Floats have a denominator that is a power of 2
1881             # so if self doesn't, it can't be equal to other
1882             if self.q & (self.q - 1):
1883                 return False
1884             s, m, t = other._mpf_[:3]
1885             if s:
1886                 m = -m
1887             if not t:
1888                 # other is an odd integer
1889                 if not self.is_Integer or self.is_even:
1890                     return False
1891                 return m == self.p
1892             if t > 0:
1893                 # other is an even integer
1894                 if not self.is_Integer:
1895                     return False
1896                 # does m*2**t == self.p
1897                 return self.p and not self.p % m and \
1898                     integer_log(self.p//m, 2) == (t, True)
1899             # does non-integer s*m/2**-t = p/q?
1900             if self.is_Integer:
1901                 return False
1902             return m == self.p and integer_log(self.q, 2) == (-t, True)
1903         return False
1904 
1905     def __ne__(self, other):
1906         return not self == other
1907 
1908     def _Rrel(self, other, attr):
1909         # if you want self < other, pass self, other, __gt__
1910         try:
1911             other = _sympify(other)
1912         except SympifyError:
1913             return NotImplemented
1914         if other.is_Number:
1915             op = None
1916             s, o = self, other
1917             if other.is_NumberSymbol:
1918                 op = getattr(o, attr)
1919             elif other.is_Float:
1920                 op = getattr(o, attr)
1921             elif other.is_Rational:
1922                 s, o = Integer(s.p*o.q), Integer(s.q*o.p)
1923                 op = getattr(o, attr)
1924             if op:
1925                 return op(s)
1926             if o.is_number and o.is_extended_real:
1927                 return Integer(s.p), s.q*o
1928 
1929     def __gt__(self, other):
1930         rv = self._Rrel(other, '__lt__')
1931         if rv is None:
1932             rv = self, other
1933         elif not type(rv) is tuple:
1934             return rv
1935         return Expr.__gt__(*rv)
1936 
1937     def __ge__(self, other):
1938         rv = self._Rrel(other, '__le__')
1939         if rv is None:
1940             rv = self, other
1941         elif not type(rv) is tuple:
1942             return rv
1943         return Expr.__ge__(*rv)
1944 
1945     def __lt__(self, other):
1946         rv = self._Rrel(other, '__gt__')
1947         if rv is None:
1948             rv = self, other
1949         elif not type(rv) is tuple:
1950             return rv
1951         return Expr.__lt__(*rv)
1952 
1953     def __le__(self, other):
1954         rv = self._Rrel(other, '__ge__')
1955         if rv is None:
1956             rv = self, other
1957         elif not type(rv) is tuple:
1958             return rv
1959         return Expr.__le__(*rv)
1960 
1961     def __hash__(self):
1962         return super().__hash__()
1963 
1964     def factors(self, limit=None, use_trial=True, use_rho=False,
1965                 use_pm1=False, verbose=False, visual=False):
1966         """A wrapper to factorint which return factors of self that are
1967         smaller than limit (or cheap to compute). Special methods of
1968         factoring are disabled by default so that only trial division is used.
1969         """
1970         from sympy.ntheory import factorrat
1971 
1972         return factorrat(self, limit=limit, use_trial=use_trial,
1973                       use_rho=use_rho, use_pm1=use_pm1,
1974                       verbose=verbose).copy()
1975 
1976     @property
1977     def numerator(self):
1978         return self.p
1979 
1980     @property
1981     def denominator(self):
1982         return self.q
1983 
1984     @_sympifyit('other', NotImplemented)
1985     def gcd(self, other):
1986         if isinstance(other, Rational):
1987             if other == S.Zero:
1988                 return other
1989             return Rational(
1990                 Integer(igcd(self.p, other.p)),
1991                 Integer(ilcm(self.q, other.q)))
1992         return Number.gcd(self, other)
1993 
1994     @_sympifyit('other', NotImplemented)
1995     def lcm(self, other):
1996         if isinstance(other, Rational):
1997             return Rational(
1998                 self.p // igcd(self.p, other.p) * other.p,
1999                 igcd(self.q, other.q))
2000         return Number.lcm(self, other)
2001 
2002     def as_numer_denom(self):
2003         return Integer(self.p), Integer(self.q)
2004 
2005     def _sage_(self):
2006         import sage.all as sage
2007         return sage.Integer(self.p)/sage.Integer(self.q)
2008 
2009     def as_content_primitive(self, radical=False, clear=True):
2010         """Return the tuple (R, self/R) where R is the positive Rational
2011         extracted from self.
2012 
2013         Examples
2014         ========
2015 
2016         >>> from sympy import S
2017         >>> (S(-3)/2).as_content_primitive()
2018         (3/2, -1)
2019 
2020         See docstring of Expr.as_content_primitive for more examples.
2021         """
2022 
2023         if self:
2024             if self.is_positive:
2025                 return self, S.One
2026             return -self, S.NegativeOne
2027         return S.One, self
2028 
2029     def as_coeff_Mul(self, rational=False):
2030         """Efficiently extract the coefficient of a product. """
2031         return self, S.One
2032 
2033     def as_coeff_Add(self, rational=False):
2034         """Efficiently extract the coefficient of a summation. """
2035         return self, S.Zero
2036 
2037 
2038 class Integer(Rational):
2039     """Represents integer numbers of any size.
2040 
2041     Examples
2042     ========
2043 
2044     >>> from sympy import Integer
2045     >>> Integer(3)
2046     3
2047 
2048     If a float or a rational is passed to Integer, the fractional part
2049     will be discarded; the effect is of rounding toward zero.
2050 
2051     >>> Integer(3.8)
2052     3
2053     >>> Integer(-3.8)
2054     -3
2055 
2056     A string is acceptable input if it can be parsed as an integer:
2057 
2058     >>> Integer("9" * 20)
2059     99999999999999999999
2060 
2061     It is rarely needed to explicitly instantiate an Integer, because
2062     Python integers are automatically converted to Integer when they
2063     are used in SymPy expressions.
2064     """
2065     q = 1
2066     is_integer = True
2067     is_number = True
2068 
2069     is_Integer = True
2070 
2071     __slots__ = ('p',)
2072 
2073     def _as_mpf_val(self, prec):
2074         return mlib.from_int(self.p, prec, rnd)
2075 
2076     def _mpmath_(self, prec, rnd):
2077         return mpmath.make_mpf(self._as_mpf_val(prec))
2078 
2079     @cacheit
2080     def __new__(cls, i):
2081         if isinstance(i, str):
2082             i = i.replace(' ', '')
2083         # whereas we cannot, in general, make a Rational from an
2084         # arbitrary expression, we can make an Integer unambiguously
2085         # (except when a non-integer expression happens to round to
2086         # an integer). So we proceed by taking int() of the input and
2087         # let the int routines determine whether the expression can
2088         # be made into an int or whether an error should be raised.
2089         try:
2090             ival = int(i)
2091         except TypeError:
2092             raise TypeError(
2093                 "Argument of Integer should be of numeric type, got %s." % i)
2094         # We only work with well-behaved integer types. This converts, for
2095         # example, numpy.int32 instances.
2096         if ival == 1:
2097             return S.One
2098         if ival == -1:
2099             return S.NegativeOne
2100         if ival == 0:
2101             return S.Zero
2102         obj = Expr.__new__(cls)
2103         obj.p = ival
2104         return obj
2105 
2106     def __getnewargs__(self):
2107         return (self.p,)
2108 
2109     # Arithmetic operations are here for efficiency
2110     def __int__(self):
2111         return self.p
2112 
2113     def floor(self):
2114         return Integer(self.p)
2115 
2116     def ceiling(self):
2117         return Integer(self.p)
2118 
2119     def __floor__(self):
2120         return self.floor()
2121 
2122     def __ceil__(self):
2123         return self.ceiling()
2124 
2125     def __neg__(self):
2126         return Integer(-self.p)
2127 
2128     def __abs__(self):
2129         if self.p >= 0:
2130             return self
2131         else:
2132             return Integer(-self.p)
2133 
2134     def __divmod__(self, other):
2135         from .containers import Tuple
2136         if isinstance(other, Integer) and global_parameters.evaluate:
2137             return Tuple(*(divmod(self.p, other.p)))
2138         else:
2139             return Number.__divmod__(self, other)
2140 
2141     def __rdivmod__(self, other):
2142         from .containers import Tuple
2143         if isinstance(other, int) and global_parameters.evaluate:
2144             return Tuple(*(divmod(other, self.p)))
2145         else:
2146             try:
2147                 other = Number(other)
2148             except TypeError:
2149                 msg = "unsupported operand type(s) for divmod(): '%s' and '%s'"
2150                 oname = type(other).__name__
2151                 sname = type(self).__name__
2152                 raise TypeError(msg % (oname, sname))
2153             return Number.__divmod__(other, self)
2154 
2155     # TODO make it decorator + bytecodehacks?
2156     def __add__(self, other):
2157         if global_parameters.evaluate:
2158             if isinstance(other, int):
2159                 return Integer(self.p + other)
2160             elif isinstance(other, Integer):
2161                 return Integer(self.p + other.p)
2162             elif isinstance(other, Rational):
2163                 return Rational(self.p*other.q + other.p, other.q, 1)
2164             return Rational.__add__(self, other)
2165         else:
2166             return Add(self, other)
2167 
2168     def __radd__(self, other):
2169         if global_parameters.evaluate:
2170             if isinstance(other, int):
2171                 return Integer(other + self.p)
2172             elif isinstance(other, Rational):
2173                 return Rational(other.p + self.p*other.q, other.q, 1)
2174             return Rational.__radd__(self, other)
2175         return Rational.__radd__(self, other)
2176 
2177     def __sub__(self, other):
2178         if global_parameters.evaluate:
2179             if isinstance(other, int):
2180                 return Integer(self.p - other)
2181             elif isinstance(other, Integer):
2182                 return Integer(self.p - other.p)
2183             elif isinstance(other, Rational):
2184                 return Rational(self.p*other.q - other.p, other.q, 1)
2185             return Rational.__sub__(self, other)
2186         return Rational.__sub__(self, other)
2187 
2188     def __rsub__(self, other):
2189         if global_parameters.evaluate:
2190             if isinstance(other, int):
2191                 return Integer(other - self.p)
2192             elif isinstance(other, Rational):
2193                 return Rational(other.p - self.p*other.q, other.q, 1)
2194             return Rational.__rsub__(self, other)
2195         return Rational.__rsub__(self, other)
2196 
2197     def __mul__(self, other):
2198         if global_parameters.evaluate:
2199             if isinstance(other, int):
2200                 return Integer(self.p*other)
2201             elif isinstance(other, Integer):
2202                 return Integer(self.p*other.p)
2203             elif isinstance(other, Rational):
2204                 return Rational(self.p*other.p, other.q, igcd(self.p, other.q))
2205             return Rational.__mul__(self, other)
2206         return Rational.__mul__(self, other)
2207 
2208     def __rmul__(self, other):
2209         if global_parameters.evaluate:
2210             if isinstance(other, int):
2211                 return Integer(other*self.p)
2212             elif isinstance(other, Rational):
2213                 return Rational(other.p*self.p, other.q, igcd(self.p, other.q))
2214             return Rational.__rmul__(self, other)
2215         return Rational.__rmul__(self, other)
2216 
2217     def __mod__(self, other):
2218         if global_parameters.evaluate:
2219             if isinstance(other, int):
2220                 return Integer(self.p % other)
2221             elif isinstance(other, Integer):
2222                 return Integer(self.p % other.p)
2223             return Rational.__mod__(self, other)
2224         return Rational.__mod__(self, other)
2225 
2226     def __rmod__(self, other):
2227         if global_parameters.evaluate:
2228             if isinstance(other, int):
2229                 return Integer(other % self.p)
2230             elif isinstance(other, Integer):
2231                 return Integer(other.p % self.p)
2232             return Rational.__rmod__(self, other)
2233         return Rational.__rmod__(self, other)
2234 
2235     def __eq__(self, other):
2236         if isinstance(other, int):
2237             return (self.p == other)
2238         elif isinstance(other, Integer):
2239             return (self.p == other.p)
2240         return Rational.__eq__(self, other)
2241 
2242     def __ne__(self, other):
2243         return not self == other
2244 
2245     def __gt__(self, other):
2246         try:
2247             other = _sympify(other)
2248         except SympifyError:
2249             return NotImplemented
2250         if other.is_Integer:
2251             return _sympify(self.p > other.p)
2252         return Rational.__gt__(self, other)
2253 
2254     def __lt__(self, other):
2255         try:
2256             other = _sympify(other)
2257         except SympifyError:
2258             return NotImplemented
2259         if other.is_Integer:
2260             return _sympify(self.p < other.p)
2261         return Rational.__lt__(self, other)
2262 
2263     def __ge__(self, other):
2264         try:
2265             other = _sympify(other)
2266         except SympifyError:
2267             return NotImplemented
2268         if other.is_Integer:
2269             return _sympify(self.p >= other.p)
2270         return Rational.__ge__(self, other)
2271 
2272     def __le__(self, other):
2273         try:
2274             other = _sympify(other)
2275         except SympifyError:
2276             return NotImplemented
2277         if other.is_Integer:
2278             return _sympify(self.p <= other.p)
2279         return Rational.__le__(self, other)
2280 
2281     def __hash__(self):
2282         return hash(self.p)
2283 
2284     def __index__(self):
2285         return self.p
2286 
2287     ########################################
2288 
2289     def _eval_is_odd(self):
2290         return bool(self.p % 2)
2291 
2292     def _eval_power(self, expt):
2293         """
2294         Tries to do some simplifications on self**expt
2295 
2296         Returns None if no further simplifications can be done.
2297 
2298         Explanation
2299         ===========
2300 
2301         When exponent is a fraction (so we have for example a square root),
2302         we try to find a simpler representation by factoring the argument
2303         up to factors of 2**15, e.g.
2304 
2305           - sqrt(4) becomes 2
2306           - sqrt(-4) becomes 2*I
2307           - (2**(3+7)*3**(6+7))**Rational(1,7) becomes 6*18**(3/7)
2308 
2309         Further simplification would require a special call to factorint on
2310         the argument which is not done here for sake of speed.
2311 
2312         """
2313         from sympy.ntheory.factor_ import perfect_power
2314 
2315         if expt is S.Infinity:
2316             if self.p > S.One:
2317                 return S.Infinity
2318             # cases -1, 0, 1 are done in their respective classes
2319             return S.Infinity + S.ImaginaryUnit*S.Infinity
2320         if expt is S.NegativeInfinity:
2321             return Rational(1, self)**S.Infinity
2322         if not isinstance(expt, Number):
2323             # simplify when expt is even
2324             # (-2)**k --> 2**k
2325             if self.is_negative and expt.is_even:
2326                 return (-self)**expt
2327         if isinstance(expt, Float):
2328             # Rational knows how to exponentiate by a Float
2329             return super()._eval_power(expt)
2330         if not isinstance(expt, Rational):
2331             return
2332         if expt is S.Half and self.is_negative:
2333             # we extract I for this special case since everyone is doing so
2334             return S.ImaginaryUnit*Pow(-self, expt)
2335         if expt.is_negative:
2336             # invert base and change sign on exponent
2337             ne = -expt
2338             if self.is_negative:
2339                     return S.NegativeOne**expt*Rational(1, -self)**ne
2340             else:
2341                 return Rational(1, self.p)**ne
2342         # see if base is a perfect root, sqrt(4) --> 2
2343         x, xexact = integer_nthroot(abs(self.p), expt.q)
2344         if xexact:
2345             # if it's a perfect root we've finished
2346             result = Integer(x**abs(expt.p))
2347             if self.is_negative:
2348                 result *= S.NegativeOne**expt
2349             return result
2350 
2351         # The following is an algorithm where we collect perfect roots
2352         # from the factors of base.
2353 
2354         # if it's not an nth root, it still might be a perfect power
2355         b_pos = int(abs(self.p))
2356         p = perfect_power(b_pos)
2357         if p is not False:
2358             dict = {p[0]: p[1]}
2359         else:
2360             dict = Integer(b_pos).factors(limit=2**15)
2361 
2362         # now process the dict of factors
2363         out_int = 1  # integer part
2364         out_rad = 1  # extracted radicals
2365         sqr_int = 1
2366         sqr_gcd = 0
2367         sqr_dict = {}
2368         for prime, exponent in dict.items():
2369             exponent *= expt.p
2370             # remove multiples of expt.q: (2**12)**(1/10) -> 2*(2**2)**(1/10)
2371             div_e, div_m = divmod(exponent, expt.q)
2372             if div_e > 0:
2373                 out_int *= prime**div_e
2374             if div_m > 0:
2375                 # see if the reduced exponent shares a gcd with e.q
2376                 # (2**2)**(1/10) -> 2**(1/5)
2377                 g = igcd(div_m, expt.q)
2378                 if g != 1:
2379                     out_rad *= Pow(prime, Rational(div_m//g, expt.q//g))
2380                 else:
2381                     sqr_dict[prime] = div_m
2382         # identify gcd of remaining powers
2383         for p, ex in sqr_dict.items():
2384             if sqr_gcd == 0:
2385                 sqr_gcd = ex
2386             else:
2387                 sqr_gcd = igcd(sqr_gcd, ex)
2388                 if sqr_gcd == 1:
2389                     break
2390         for k, v in sqr_dict.items():
2391             sqr_int *= k**(v//sqr_gcd)
2392         if sqr_int == b_pos and out_int == 1 and out_rad == 1:
2393             result = None
2394         else:
2395             result = out_int*out_rad*Pow(sqr_int, Rational(sqr_gcd, expt.q))
2396             if self.is_negative:
2397                 result *= Pow(S.NegativeOne, expt)
2398         return result
2399 
2400     def _eval_is_prime(self):
2401         from sympy.ntheory import isprime
2402 
2403         return isprime(self)
2404 
2405     def _eval_is_composite(self):
2406         if self > 1:
2407             return fuzzy_not(self.is_prime)
2408         else:
2409             return False
2410 
2411     def as_numer_denom(self):
2412         return self, S.One
2413 
2414     @_sympifyit('other', NotImplemented)
2415     def __floordiv__(self, other):
2416         if not isinstance(other, Expr):
2417             return NotImplemented
2418         if isinstance(other, Integer):
2419             return Integer(self.p // other)
2420         return Integer(divmod(self, other)[0])
2421 
2422     def __rfloordiv__(self, other):
2423         return Integer(Integer(other).p // self.p)
2424 
2425 # Add sympify converters
2426 converter[int] = Integer
2427 
2428 
2429 class AlgebraicNumber(Expr):
2430     """Class for representing algebraic numbers in SymPy. """
2431 
2432     __slots__ = ('rep', 'root', 'alias', 'minpoly')
2433 
2434     is_AlgebraicNumber = True
2435     is_algebraic = True
2436     is_number = True
2437 
2438 
2439     kind = NumberKind
2440 
2441     # Optional alias symbol is not free.
2442     # Actually, alias should be a Str, but some methods
2443     # expect that it be an instance of Expr.
2444     free_symbols = set()
2445 
2446     def __new__(cls, expr, coeffs=None, alias=None, **args):
2447         """Construct a new algebraic number. """
2448         from sympy import Poly
2449         from sympy.polys.polyclasses import ANP, DMP
2450         from sympy.polys.numberfields import minimal_polynomial
2451         from sympy.core.symbol import Symbol
2452 
2453         expr = sympify(expr)
2454 
2455         if isinstance(expr, (tuple, Tuple)):
2456             minpoly, root = expr
2457 
2458             if not minpoly.is_Poly:
2459                 minpoly = Poly(minpoly)
2460         elif expr.is_AlgebraicNumber:
2461             minpoly, root = expr.minpoly, expr.root
2462         else:
2463             minpoly, root = minimal_polynomial(
2464                 expr, args.get('gen'), polys=True), expr
2465 
2466         dom = minpoly.get_domain()
2467 
2468         if coeffs is not None:
2469             if not isinstance(coeffs, ANP):
2470                 rep = DMP.from_sympy_list(sympify(coeffs), 0, dom)
2471                 scoeffs = Tuple(*coeffs)
2472             else:
2473                 rep = DMP.from_list(coeffs.to_list(), 0, dom)
2474                 scoeffs = Tuple(*coeffs.to_list())
2475 
2476             if rep.degree() >= minpoly.degree():
2477                 rep = rep.rem(minpoly.rep)
2478 
2479         else:
2480             rep = DMP.from_list([1, 0], 0, dom)
2481             scoeffs = Tuple(1, 0)
2482 
2483         sargs = (root, scoeffs)
2484 
2485         if alias is not None:
2486             if not isinstance(alias, Symbol):
2487                 alias = Symbol(alias)
2488             sargs = sargs + (alias,)
2489 
2490         obj = Expr.__new__(cls, *sargs)
2491 
2492         obj.rep = rep
2493         obj.root = root
2494         obj.alias = alias
2495         obj.minpoly = minpoly
2496 
2497         return obj
2498 
2499     def __hash__(self):
2500         return super().__hash__()
2501 
2502     def _eval_evalf(self, prec):
2503         return self.as_expr()._evalf(prec)
2504 
2505     @property
2506     def is_aliased(self):
2507         """Returns ``True`` if ``alias`` was set. """
2508         return self.alias is not None
2509 
2510     def as_poly(self, x=None):
2511         """Create a Poly instance from ``self``. """
2512         from sympy import Dummy, Poly, PurePoly
2513         if x is not None:
2514             return Poly.new(self.rep, x)
2515         else:
2516             if self.alias is not None:
2517                 return Poly.new(self.rep, self.alias)
2518             else:
2519                 return PurePoly.new(self.rep, Dummy('x'))
2520 
2521     def as_expr(self, x=None):
2522         """Create a Basic expression from ``self``. """
2523         return self.as_poly(x or self.root).as_expr().expand()
2524 
2525     def coeffs(self):
2526         """Returns all SymPy coefficients of an algebraic number. """
2527         return [ self.rep.dom.to_sympy(c) for c in self.rep.all_coeffs() ]
2528 
2529     def native_coeffs(self):
2530         """Returns all native coefficients of an algebraic number. """
2531         return self.rep.all_coeffs()
2532 
2533     def to_algebraic_integer(self):
2534         """Convert ``self`` to an algebraic integer. """
2535         from sympy import Poly
2536         f = self.minpoly
2537 
2538         if f.LC() == 1:
2539             return self
2540 
2541         coeff = f.LC()**(f.degree() - 1)
2542         poly = f.compose(Poly(f.gen/f.LC()))
2543 
2544         minpoly = poly*coeff
2545         root = f.LC()*self.root
2546 
2547         return AlgebraicNumber((minpoly, root), self.coeffs())
2548 
2549     def _eval_simplify(self, **kwargs):
2550         from sympy.polys import CRootOf, minpoly
2551         measure, ratio = kwargs['measure'], kwargs['ratio']
2552         for r in [r for r in self.minpoly.all_roots() if r.func != CRootOf]:
2553             if minpoly(self.root - r).is_Symbol:
2554                 # use the matching root if it's simpler
2555                 if measure(r) < ratio*measure(self.root):
2556                     return AlgebraicNumber(r)
2557         return self
2558 
2559 
2560 class RationalConstant(Rational):
2561     """
2562     Abstract base class for rationals with specific behaviors
2563 
2564     Derived classes must define class attributes p and q and should probably all
2565     be singletons.
2566     """
2567     __slots__ = ()
2568 
2569     def __new__(cls):
2570         return AtomicExpr.__new__(cls)
2571 
2572 
2573 class IntegerConstant(Integer):
2574     __slots__ = ()
2575 
2576     def __new__(cls):
2577         return AtomicExpr.__new__(cls)
2578 
2579 
2580 class Zero(IntegerConstant, metaclass=Singleton):
2581     """The number zero.
2582 
2583     Zero is a singleton, and can be accessed by ``S.Zero``
2584 
2585     Examples
2586     ========
2587 
2588     >>> from sympy import S, Integer
2589     >>> Integer(0) is S.Zero
2590     True
2591     >>> 1/S.Zero
2592     zoo
2593 
2594     References
2595     ==========
2596 
2597     .. [1] https://en.wikipedia.org/wiki/Zero
2598     """
2599 
2600     p = 0
2601     q = 1
2602     is_positive = False
2603     is_negative = False
2604     is_zero = True
2605     is_number = True
2606     is_comparable = True
2607 
2608     __slots__ = ()
2609 
2610     def __getnewargs__(self):
2611         return ()
2612 
2613     @staticmethod
2614     def __abs__():
2615         return S.Zero
2616 
2617     @staticmethod
2618     def __neg__():
2619         return S.Zero
2620 
2621     def _eval_power(self, expt):
2622         if expt.is_positive:
2623             return self
2624         if expt.is_negative:
2625             return S.ComplexInfinity
2626         if expt.is_extended_real is False:
2627             return S.NaN
2628         # infinities are already handled with pos and neg
2629         # tests above; now throw away leading numbers on Mul
2630         # exponent
2631         coeff, terms = expt.as_coeff_Mul()
2632         if coeff.is_negative:
2633             return S.ComplexInfinity**terms
2634         if coeff is not S.One:  # there is a Number to discard
2635             return self**terms
2636 
2637     def _eval_order(self, *symbols):
2638         # Order(0,x) -> 0
2639         return self
2640 
2641     def __bool__(self):
2642         return False
2643 
2644     def as_coeff_Mul(self, rational=False):  # XXX this routine should be deleted
2645         """Efficiently extract the coefficient of a summation. """
2646         return S.One, self
2647 
2648 
2649 class One(IntegerConstant, metaclass=Singleton):
2650     """The number one.
2651 
2652     One is a singleton, and can be accessed by ``S.One``.
2653 
2654     Examples
2655     ========
2656 
2657     >>> from sympy import S, Integer
2658     >>> Integer(1) is S.One
2659     True
2660 
2661     References
2662     ==========
2663 
2664     .. [1] https://en.wikipedia.org/wiki/1_%28number%29
2665     """
2666     is_number = True
2667     is_positive = True
2668 
2669     p = 1
2670     q = 1
2671 
2672     __slots__ = ()
2673 
2674     def __getnewargs__(self):
2675         return ()
2676 
2677     @staticmethod
2678     def __abs__():
2679         return S.One
2680 
2681     @staticmethod
2682     def __neg__():
2683         return S.NegativeOne
2684 
2685     def _eval_power(self, expt):
2686         return self
2687 
2688     def _eval_order(self, *symbols):
2689         return
2690 
2691     @staticmethod
2692     def factors(limit=None, use_trial=True, use_rho=False, use_pm1=False,
2693                 verbose=False, visual=False):
2694         if visual:
2695             return S.One
2696         else:
2697             return {}
2698 
2699 
2700 class NegativeOne(IntegerConstant, metaclass=Singleton):
2701     """The number negative one.
2702 
2703     NegativeOne is a singleton, and can be accessed by ``S.NegativeOne``.
2704 
2705     Examples
2706     ========
2707 
2708     >>> from sympy import S, Integer
2709     >>> Integer(-1) is S.NegativeOne
2710     True
2711 
2712     See Also
2713     ========
2714 
2715     One
2716 
2717     References
2718     ==========
2719 
2720     .. [1] https://en.wikipedia.org/wiki/%E2%88%921_%28number%29
2721 
2722     """
2723     is_number = True
2724 
2725     p = -1
2726     q = 1
2727 
2728     __slots__ = ()
2729 
2730     def __getnewargs__(self):
2731         return ()
2732 
2733     @staticmethod
2734     def __abs__():
2735         return S.One
2736 
2737     @staticmethod
2738     def __neg__():
2739         return S.One
2740 
2741     def _eval_power(self, expt):
2742         if expt.is_odd:
2743             return S.NegativeOne
2744         if expt.is_even:
2745             return S.One
2746         if isinstance(expt, Number):
2747             if isinstance(expt, Float):
2748                 return Float(-1.0)**expt
2749             if expt is S.NaN:
2750                 return S.NaN
2751             if expt is S.Infinity or expt is S.NegativeInfinity:
2752                 return S.NaN
2753             if expt is S.Half:
2754                 return S.ImaginaryUnit
2755             if isinstance(expt, Rational):
2756                 if expt.q == 2:
2757                     return S.ImaginaryUnit**Integer(expt.p)
2758                 i, r = divmod(expt.p, expt.q)
2759                 if i:
2760                     return self**i*self**Rational(r, expt.q)
2761         return
2762 
2763 
2764 class Half(RationalConstant, metaclass=Singleton):
2765     """The rational number 1/2.
2766 
2767     Half is a singleton, and can be accessed by ``S.Half``.
2768 
2769     Examples
2770     ========
2771 
2772     >>> from sympy import S, Rational
2773     >>> Rational(1, 2) is S.Half
2774     True
2775 
2776     References
2777     ==========
2778 
2779     .. [1] https://en.wikipedia.org/wiki/One_half
2780     """
2781     is_number = True
2782 
2783     p = 1
2784     q = 2
2785 
2786     __slots__ = ()
2787 
2788     def __getnewargs__(self):
2789         return ()
2790 
2791     @staticmethod
2792     def __abs__():
2793         return S.Half
2794 
2795 
2796 class Infinity(Number, metaclass=Singleton):
2797     r"""Positive infinite quantity.
2798 
2799     Explanation
2800     ===========
2801 
2802     In real analysis the symbol `\infty` denotes an unbounded
2803     limit: `x\to\infty` means that `x` grows without bound.
2804 
2805     Infinity is often used not only to define a limit but as a value
2806     in the affinely extended real number system.  Points labeled `+\infty`
2807     and `-\infty` can be added to the topological space of the real numbers,
2808     producing the two-point compactification of the real numbers.  Adding
2809     algebraic properties to this gives us the extended real numbers.
2810 
2811     Infinity is a singleton, and can be accessed by ``S.Infinity``,
2812     or can be imported as ``oo``.
2813 
2814     Examples
2815     ========
2816 
2817     >>> from sympy import oo, exp, limit, Symbol
2818     >>> 1 + oo
2819     oo
2820     >>> 42/oo
2821     0
2822     >>> x = Symbol('x')
2823     >>> limit(exp(x), x, oo)
2824     oo
2825 
2826     See Also
2827     ========
2828 
2829     NegativeInfinity, NaN
2830 
2831     References
2832     ==========
2833 
2834     .. [1] https://en.wikipedia.org/wiki/Infinity
2835     """
2836 
2837     is_commutative = True
2838     is_number = True
2839     is_complex = False
2840     is_extended_real = True
2841     is_infinite = True
2842     is_comparable = True
2843     is_extended_positive = True
2844     is_prime = False
2845 
2846     __slots__ = ()
2847 
2848     def __new__(cls):
2849         return AtomicExpr.__new__(cls)
2850 
2851     def _latex(self, printer):
2852         return r"\infty"
2853 
2854     def _eval_subs(self, old, new):
2855         if self == old:
2856             return new
2857 
2858     def _eval_evalf(self, prec=None):
2859         return Float('inf')
2860 
2861     def evalf(self, prec=None, **options):
2862         return self._eval_evalf(prec)
2863 
2864     @_sympifyit('other', NotImplemented)
2865     def __add__(self, other):
2866         if isinstance(other, Number) and global_parameters.evaluate:
2867             if other is S.NegativeInfinity or other is S.NaN:
2868                 return S.NaN
2869             return self
2870         return Number.__add__(self, other)
2871     __radd__ = __add__
2872 
2873     @_sympifyit('other', NotImplemented)
2874     def __sub__(self, other):
2875         if isinstance(other, Number) and global_parameters.evaluate:
2876             if other is S.Infinity or other is S.NaN:
2877                 return S.NaN
2878             return self
2879         return Number.__sub__(self, other)
2880 
2881     @_sympifyit('other', NotImplemented)
2882     def __rsub__(self, other):
2883         return (-self).__add__(other)
2884 
2885     @_sympifyit('other', NotImplemented)
2886     def __mul__(self, other):
2887         if isinstance(other, Number) and global_parameters.evaluate:
2888             if other.is_zero or other is S.NaN:
2889                 return S.NaN
2890             if other.is_extended_positive:
2891                 return self
2892             return S.NegativeInfinity
2893         return Number.__mul__(self, other)
2894     __rmul__ = __mul__
2895 
2896     @_sympifyit('other', NotImplemented)
2897     def __truediv__(self, other):
2898         if isinstance(other, Number) and global_parameters.evaluate:
2899             if other is S.Infinity or \
2900                 other is S.NegativeInfinity or \
2901                     other is S.NaN:
2902                 return S.NaN
2903             if other.is_extended_nonnegative:
2904                 return self
2905             return S.NegativeInfinity
2906         return Number.__truediv__(self, other)
2907 
2908     def __abs__(self):
2909         return S.Infinity
2910 
2911     def __neg__(self):
2912         return S.NegativeInfinity
2913 
2914     def _eval_power(self, expt):
2915         """
2916         ``expt`` is symbolic object but not equal to 0 or 1.
2917 
2918         ================ ======= ==============================
2919         Expression       Result  Notes
2920         ================ ======= ==============================
2921         ``oo ** nan``    ``nan``
2922         ``oo ** -p``     ``0``   ``p`` is number, ``oo``
2923         ================ ======= ==============================
2924 
2925         See Also
2926         ========
2927         Pow
2928         NaN
2929         NegativeInfinity
2930 
2931         """
2932         from sympy.functions import re
2933 
2934         if expt.is_extended_positive:
2935             return S.Infinity
2936         if expt.is_extended_negative:
2937             return S.Zero
2938         if expt is S.NaN:
2939             return S.NaN
2940         if expt is S.ComplexInfinity:
2941             return S.NaN
2942         if expt.is_extended_real is False and expt.is_number:
2943             expt_real = re(expt)
2944             if expt_real.is_positive:
2945                 return S.ComplexInfinity
2946             if expt_real.is_negative:
2947                 return S.Zero
2948             if expt_real.is_zero:
2949                 return S.NaN
2950 
2951             return self**expt.evalf()
2952 
2953     def _as_mpf_val(self, prec):
2954         return mlib.finf
2955 
2956     def _sage_(self):
2957         import sage.all as sage
2958         return sage.oo
2959 
2960     def __hash__(self):
2961         return super().__hash__()
2962 
2963     def __eq__(self, other):
2964         return other is S.Infinity or other == float('inf')
2965 
2966     def __ne__(self, other):
2967         return other is not S.Infinity and other != float('inf')
2968 
2969     __gt__ = Expr.__gt__
2970     __ge__ = Expr.__ge__
2971     __lt__ = Expr.__lt__
2972     __le__ = Expr.__le__
2973 
2974     @_sympifyit('other', NotImplemented)
2975     def __mod__(self, other):
2976         if not isinstance(other, Expr):
2977             return NotImplemented
2978         return S.NaN
2979 
2980     __rmod__ = __mod__
2981 
2982     def floor(self):
2983         return self
2984 
2985     def ceiling(self):
2986         return self
2987 
2988 oo = S.Infinity
2989 
2990 
2991 class NegativeInfinity(Number, metaclass=Singleton):
2992     """Negative infinite quantity.
2993 
2994     NegativeInfinity is a singleton, and can be accessed
2995     by ``S.NegativeInfinity``.
2996 
2997     See Also
2998     ========
2999 
3000     Infinity
3001     """
3002 
3003     is_extended_real = True
3004     is_complex = False
3005     is_commutative = True
3006     is_infinite = True
3007     is_comparable = True
3008     is_extended_negative = True
3009     is_number = True
3010     is_prime = False
3011 
3012     __slots__ = ()
3013 
3014     def __new__(cls):
3015         return AtomicExpr.__new__(cls)
3016 
3017     def _latex(self, printer):
3018         return r"-\infty"
3019 
3020     def _eval_subs(self, old, new):
3021         if self == old:
3022             return new
3023 
3024     def _eval_evalf(self, prec=None):
3025         return Float('-inf')
3026 
3027     def evalf(self, prec=None, **options):
3028         return self._eval_evalf(prec)
3029 
3030     @_sympifyit('other', NotImplemented)
3031     def __add__(self, other):
3032         if isinstance(other, Number) and global_parameters.evaluate:
3033             if other is S.Infinity or other is S.NaN:
3034                 return S.NaN
3035             return self
3036         return Number.__add__(self, other)
3037     __radd__ = __add__
3038 
3039     @_sympifyit('other', NotImplemented)
3040     def __sub__(self, other):
3041         if isinstance(other, Number) and global_parameters.evaluate:
3042             if other is S.NegativeInfinity or other is S.NaN:
3043                 return S.NaN
3044             return self
3045         return Number.__sub__(self, other)
3046 
3047     @_sympifyit('other', NotImplemented)
3048     def __rsub__(self, other):
3049         return (-self).__add__(other)
3050 
3051     @_sympifyit('other', NotImplemented)
3052     def __mul__(self, other):
3053         if isinstance(other, Number) and global_parameters.evaluate:
3054             if other.is_zero or other is S.NaN:
3055                 return S.NaN
3056             if other.is_extended_positive:
3057                 return self
3058             return S.Infinity
3059         return Number.__mul__(self, other)
3060     __rmul__ = __mul__
3061 
3062     @_sympifyit('other', NotImplemented)
3063     def __truediv__(self, other):
3064         if isinstance(other, Number) and global_parameters.evaluate:
3065             if other is S.Infinity or \
3066                 other is S.NegativeInfinity or \
3067                     other is S.NaN:
3068                 return S.NaN
3069             if other.is_extended_nonnegative:
3070                 return self
3071             return S.Infinity
3072         return Number.__truediv__(self, other)
3073 
3074     def __abs__(self):
3075         return S.Infinity
3076 
3077     def __neg__(self):
3078         return S.Infinity
3079 
3080     def _eval_power(self, expt):
3081         """
3082         ``expt`` is symbolic object but not equal to 0 or 1.
3083 
3084         ================ ======= ==============================
3085         Expression       Result  Notes
3086         ================ ======= ==============================
3087         ``(-oo) ** nan`` ``nan``
3088         ``(-oo) ** oo``  ``nan``
3089         ``(-oo) ** -oo`` ``nan``
3090         ``(-oo) ** e``   ``oo``  ``e`` is positive even integer
3091         ``(-oo) ** o``   ``-oo`` ``o`` is positive odd integer
3092         ================ ======= ==============================
3093 
3094         See Also
3095         ========
3096 
3097         Infinity
3098         Pow
3099         NaN
3100 
3101         """
3102         if expt.is_number:
3103             if expt is S.NaN or \
3104                 expt is S.Infinity or \
3105                     expt is S.NegativeInfinity:
3106                 return S.NaN
3107 
3108             if isinstance(expt, Integer) and expt.is_extended_positive:
3109                 if expt.is_odd:
3110                     return S.NegativeInfinity
3111                 else:
3112                     return S.Infinity
3113 
3114             return S.NegativeOne**expt*S.Infinity**expt
3115 
3116     def _as_mpf_val(self, prec):
3117         return mlib.fninf
3118 
3119     def _sage_(self):
3120         import sage.all as sage
3121         return -(sage.oo)
3122 
3123     def __hash__(self):
3124         return super().__hash__()
3125 
3126     def __eq__(self, other):
3127         return other is S.NegativeInfinity or other == float('-inf')
3128 
3129     def __ne__(self, other):
3130         return other is not S.NegativeInfinity and other != float('-inf')
3131 
3132     __gt__ = Expr.__gt__
3133     __ge__ = Expr.__ge__
3134     __lt__ = Expr.__lt__
3135     __le__ = Expr.__le__
3136 
3137     @_sympifyit('other', NotImplemented)
3138     def __mod__(self, other):
3139         if not isinstance(other, Expr):
3140             return NotImplemented
3141         return S.NaN
3142 
3143     __rmod__ = __mod__
3144 
3145     def floor(self):
3146         return self
3147 
3148     def ceiling(self):
3149         return self
3150 
3151     def as_powers_dict(self):
3152         return {S.NegativeOne: 1, S.Infinity: 1}
3153 
3154 
3155 class NaN(Number, metaclass=Singleton):
3156     """
3157     Not a Number.
3158 
3159     Explanation
3160     ===========
3161 
3162     This serves as a place holder for numeric values that are indeterminate.
3163     Most operations on NaN, produce another NaN.  Most indeterminate forms,
3164     such as ``0/0`` or ``oo - oo` produce NaN.  Two exceptions are ``0**0``
3165     and ``oo**0``, which all produce ``1`` (this is consistent with Python's
3166     float).
3167 
3168     NaN is loosely related to floating point nan, which is defined in the
3169     IEEE 754 floating point standard, and corresponds to the Python
3170     ``float('nan')``.  Differences are noted below.
3171 
3172     NaN is mathematically not equal to anything else, even NaN itself.  This
3173     explains the initially counter-intuitive results with ``Eq`` and ``==`` in
3174     the examples below.
3175 
3176     NaN is not comparable so inequalities raise a TypeError.  This is in
3177     contrast with floating point nan where all inequalities are false.
3178 
3179     NaN is a singleton, and can be accessed by ``S.NaN``, or can be imported
3180     as ``nan``.
3181 
3182     Examples
3183     ========
3184 
3185     >>> from sympy import nan, S, oo, Eq
3186     >>> nan is S.NaN
3187     True
3188     >>> oo - oo
3189     nan
3190     >>> nan + 1
3191     nan
3192     >>> Eq(nan, nan)   # mathematical equality
3193     False
3194     >>> nan == nan     # structural equality
3195     True
3196 
3197     References
3198     ==========
3199 
3200     .. [1] https://en.wikipedia.org/wiki/NaN
3201 
3202     """
3203     is_commutative = True
3204     is_extended_real = None
3205     is_real = None
3206     is_rational = None
3207     is_algebraic = None
3208     is_transcendental = None
3209     is_integer = None
3210     is_comparable = False
3211     is_finite = None
3212     is_zero = None
3213     is_prime = None
3214     is_positive = None
3215     is_negative = None
3216     is_number = True
3217 
3218     __slots__ = ()
3219 
3220     def __new__(cls):
3221         return AtomicExpr.__new__(cls)
3222 
3223     def _latex(self, printer):
3224         return r"\text{NaN}"
3225 
3226     def __neg__(self):
3227         return self
3228 
3229     @_sympifyit('other', NotImplemented)
3230     def __add__(self, other):
3231         return self
3232 
3233     @_sympifyit('other', NotImplemented)
3234     def __sub__(self, other):
3235         return self
3236 
3237     @_sympifyit('other', NotImplemented)
3238     def __mul__(self, other):
3239         return self
3240 
3241     @_sympifyit('other', NotImplemented)
3242     def __truediv__(self, other):
3243         return self
3244 
3245     def floor(self):
3246         return self
3247 
3248     def ceiling(self):
3249         return self
3250 
3251     def _as_mpf_val(self, prec):
3252         return _mpf_nan
3253 
3254     def _sage_(self):
3255         import sage.all as sage
3256         return sage.NaN
3257 
3258     def __hash__(self):
3259         return super().__hash__()
3260 
3261     def __eq__(self, other):
3262         # NaN is structurally equal to another NaN
3263         return other is S.NaN
3264 
3265     def __ne__(self, other):
3266         return other is not S.NaN
3267 
3268     # Expr will _sympify and raise TypeError
3269     __gt__ = Expr.__gt__
3270     __ge__ = Expr.__ge__
3271     __lt__ = Expr.__lt__
3272     __le__ = Expr.__le__
3273 
3274 nan = S.NaN
3275 
3276 @dispatch(NaN, Expr) # type:ignore
3277 def _eval_is_eq(a, b): # noqa:F811
3278     return False
3279 
3280 
3281 class ComplexInfinity(AtomicExpr, metaclass=Singleton):
3282     r"""Complex infinity.
3283 
3284     Explanation
3285     ===========
3286 
3287     In complex analysis the symbol `\tilde\infty`, called "complex
3288     infinity", represents a quantity with infinite magnitude, but
3289     undetermined complex phase.
3290 
3291     ComplexInfinity is a singleton, and can be accessed by
3292     ``S.ComplexInfinity``, or can be imported as ``zoo``.
3293 
3294     Examples
3295     ========
3296 
3297     >>> from sympy import zoo
3298     >>> zoo + 42
3299     zoo
3300     >>> 42/zoo
3301     0
3302     >>> zoo + zoo
3303     nan
3304     >>> zoo*zoo
3305     zoo
3306 
3307     See Also
3308     ========
3309 
3310     Infinity
3311     """
3312 
3313     is_commutative = True
3314     is_infinite = True
3315     is_number = True
3316     is_prime = False
3317     is_complex = False
3318     is_extended_real = False
3319 
3320     kind = NumberKind
3321 
3322     __slots__ = ()
3323 
3324     def __new__(cls):
3325         return AtomicExpr.__new__(cls)
3326 
3327     def _latex(self, printer):
3328         return r"\tilde{\infty}"
3329 
3330     @staticmethod
3331     def __abs__():
3332         return S.Infinity
3333 
3334     def floor(self):
3335         return self
3336 
3337     def ceiling(self):
3338         return self
3339 
3340     @staticmethod
3341     def __neg__():
3342         return S.ComplexInfinity
3343 
3344     def _eval_power(self, expt):
3345         if expt is S.ComplexInfinity:
3346             return S.NaN
3347 
3348         if isinstance(expt, Number):
3349             if expt.is_zero:
3350                 return S.NaN
3351             else:
3352                 if expt.is_positive:
3353                     return S.ComplexInfinity
3354                 else:
3355                     return S.Zero
3356 
3357     def _sage_(self):
3358         import sage.all as sage
3359         return sage.UnsignedInfinityRing.gen()
3360 
3361 
3362 zoo = S.ComplexInfinity
3363 
3364 
3365 class NumberSymbol(AtomicExpr):
3366 
3367     is_commutative = True
3368     is_finite = True
3369     is_number = True
3370 
3371     __slots__ = ()
3372 
3373     is_NumberSymbol = True
3374 
3375     kind = NumberKind
3376 
3377     def __new__(cls):
3378         return AtomicExpr.__new__(cls)
3379 
3380     def approximation(self, number_cls):
3381         """ Return an interval with number_cls endpoints
3382         that contains the value of NumberSymbol.
3383         If not implemented, then return None.
3384         """
3385 
3386     def _eval_evalf(self, prec):
3387         return Float._new(self._as_mpf_val(prec), prec)
3388 
3389     def __eq__(self, other):
3390         try:
3391             other = _sympify(other)
3392         except SympifyError:
3393             return NotImplemented
3394         if self is other:
3395             return True
3396         if other.is_Number and self.is_irrational:
3397             return False
3398 
3399         return False    # NumberSymbol != non-(Number|self)
3400 
3401     def __ne__(self, other):
3402         return not self == other
3403 
3404     def __le__(self, other):
3405         if self is other:
3406             return S.true
3407         return Expr.__le__(self, other)
3408 
3409     def __ge__(self, other):
3410         if self is other:
3411             return S.true
3412         return Expr.__ge__(self, other)
3413 
3414     def __int__(self):
3415         # subclass with appropriate return value
3416         raise NotImplementedError
3417 
3418     def __hash__(self):
3419         return super().__hash__()
3420 
3421 class Exp1(NumberSymbol, metaclass=Singleton):
3422     r"""The `e` constant.
3423 
3424     Explanation
3425     ===========
3426 
3427     The transcendental number `e = 2.718281828\ldots` is the base of the
3428     natural logarithm and of the exponential function, `e = \exp(1)`.
3429     Sometimes called Euler's number or Napier's constant.
3430 
3431     Exp1 is a singleton, and can be accessed by ``S.Exp1``,
3432     or can be imported as ``E``.
3433 
3434     Examples
3435     ========
3436 
3437     >>> from sympy import exp, log, E
3438     >>> E is exp(1)
3439     True
3440     >>> log(E)
3441     1
3442 
3443     References
3444     ==========
3445 
3446     .. [1] https://en.wikipedia.org/wiki/E_%28mathematical_constant%29
3447     """
3448 
3449     is_real = True
3450     is_positive = True
3451     is_negative = False  # XXX Forces is_negative/is_nonnegative
3452     is_irrational = True
3453     is_number = True
3454     is_algebraic = False
3455     is_transcendental = True
3456 
3457     __slots__ = ()
3458 
3459     def _latex(self, printer):
3460         return r"e"
3461 
3462     @staticmethod
3463     def __abs__():
3464         return S.Exp1
3465 
3466     def __int__(self):
3467         return 2
3468 
3469     def _as_mpf_val(self, prec):
3470         return mpf_e(prec)
3471 
3472     def approximation_interval(self, number_cls):
3473         if issubclass(number_cls, Integer):
3474             return (Integer(2), Integer(3))
3475         elif issubclass(number_cls, Rational):
3476             pass
3477 
3478     def _eval_power(self, expt):
3479         from sympy import exp
3480         if global_parameters.exp_is_pow:
3481             return self._eval_power_exp_is_pow(expt)
3482         else:
3483             return exp(expt)
3484 
3485     def _eval_power_exp_is_pow(self, arg):
3486         from ..functions.elementary.exponential import log
3487         from . import Add, Mul, Pow
3488         if arg.is_Number:
3489             if arg is oo:
3490                 return oo
3491             elif arg == -oo:
3492                 return S.Zero
3493         elif isinstance(arg, log):
3494             return arg.args[0]
3495 
3496         # don't autoexpand Pow or Mul (see the issue 3351):
3497         elif not arg.is_Add:
3498             Ioo = I*oo
3499             if arg in [Ioo, -Ioo]:
3500                 return nan
3501 
3502             coeff = arg.coeff(pi*I)
3503             if coeff:
3504                 if (2*coeff).is_integer:
3505                     if coeff.is_even:
3506                         return S.One
3507                     elif coeff.is_odd:
3508                         return S.NegativeOne
3509                     elif (coeff + S.Half).is_even:
3510                         return -I
3511                     elif (coeff + S.Half).is_odd:
3512                         return I
3513                 elif coeff.is_Rational:
3514                     ncoeff = coeff % 2 # restrict to [0, 2pi)
3515                     if ncoeff > 1: # restrict to (-pi, pi]
3516                         ncoeff -= 2
3517                     if ncoeff != coeff:
3518                         return S.Exp1**(ncoeff*S.Pi*S.ImaginaryUnit)
3519 
3520             # Warning: code in risch.py will be very sensitive to changes
3521             # in this (see DifferentialExtension).
3522 
3523             # look for a single log factor
3524 
3525             coeff, terms = arg.as_coeff_Mul()
3526 
3527             # but it can't be multiplied by oo
3528             if coeff in (oo, -oo):
3529                 return
3530 
3531             coeffs, log_term = [coeff], None
3532             for term in Mul.make_args(terms):
3533                 if isinstance(term, log):
3534                     if log_term is None:
3535                         log_term = term.args[0]
3536                     else:
3537                         return
3538                 elif term.is_comparable:
3539                     coeffs.append(term)
3540                 else:
3541                     return
3542 
3543             return log_term**Mul(*coeffs) if log_term else None
3544         elif arg.is_Add:
3545             out = []
3546             add = []
3547             argchanged = False
3548             for a in arg.args:
3549                 if a is S.One:
3550                     add.append(a)
3551                     continue
3552                 newa = self**a
3553                 if isinstance(newa, Pow) and newa.base is self:
3554                     if newa.exp != a:
3555                         add.append(newa.exp)
3556                         argchanged = True
3557                     else:
3558                         add.append(a)
3559                 else:
3560                     out.append(newa)
3561             if out or argchanged:
3562                 return Mul(*out)*Pow(self, Add(*add), evaluate=False)
3563         elif arg.is_Matrix:
3564             return arg.exp()
3565 
3566     def _eval_rewrite_as_sin(self, **kwargs):
3567         from sympy import sin
3568         I = S.ImaginaryUnit
3569         return sin(I + S.Pi/2) - I*sin(I)
3570 
3571     def _eval_rewrite_as_cos(self, **kwargs):
3572         from sympy import cos
3573         I = S.ImaginaryUnit
3574         return cos(I) + I*cos(I + S.Pi/2)
3575 
3576     def _sage_(self):
3577         import sage.all as sage
3578         return sage.e
3579 E = S.Exp1
3580 
3581 
3582 class Pi(NumberSymbol, metaclass=Singleton):
3583     r"""The `\pi` constant.
3584 
3585     Explanation
3586     ===========
3587 
3588     The transcendental number `\pi = 3.141592654\ldots` represents the ratio
3589     of a circle's circumference to its diameter, the area of the unit circle,
3590     the half-period of trigonometric functions, and many other things
3591     in mathematics.
3592 
3593     Pi is a singleton, and can be accessed by ``S.Pi``, or can
3594     be imported as ``pi``.
3595 
3596     Examples
3597     ========
3598 
3599     >>> from sympy import S, pi, oo, sin, exp, integrate, Symbol
3600     >>> S.Pi
3601     pi
3602     >>> pi > 3
3603     True
3604     >>> pi.is_irrational
3605     True
3606     >>> x = Symbol('x')
3607     >>> sin(x + 2*pi)
3608     sin(x)
3609     >>> integrate(exp(-x**2), (x, -oo, oo))
3610     sqrt(pi)
3611 
3612     References
3613     ==========
3614 
3615     .. [1] https://en.wikipedia.org/wiki/Pi
3616     """
3617 
3618     is_real = True
3619     is_positive = True
3620     is_negative = False
3621     is_irrational = True
3622     is_number = True
3623     is_algebraic = False
3624     is_transcendental = True
3625 
3626     __slots__ = ()
3627 
3628     def _latex(self, printer):
3629         return r"\pi"
3630 
3631     @staticmethod
3632     def __abs__():
3633         return S.Pi
3634 
3635     def __int__(self):
3636         return 3
3637 
3638     def _as_mpf_val(self, prec):
3639         return mpf_pi(prec)
3640 
3641     def approximation_interval(self, number_cls):
3642         if issubclass(number_cls, Integer):
3643             return (Integer(3), Integer(4))
3644         elif issubclass(number_cls, Rational):
3645             return (Rational(223, 71), Rational(22, 7))
3646 
3647     def _sage_(self):
3648         import sage.all as sage
3649         return sage.pi
3650 pi = S.Pi
3651 
3652 
3653 class GoldenRatio(NumberSymbol, metaclass=Singleton):
3654     r"""The golden ratio, `\phi`.
3655 
3656     Explanation
3657     ===========
3658 
3659     `\phi = \frac{1 + \sqrt{5}}{2}` is algebraic number.  Two quantities
3660     are in the golden ratio if their ratio is the same as the ratio of
3661     their sum to the larger of the two quantities, i.e. their maximum.
3662 
3663     GoldenRatio is a singleton, and can be accessed by ``S.GoldenRatio``.
3664 
3665     Examples
3666     ========
3667 
3668     >>> from sympy import S
3669     >>> S.GoldenRatio > 1
3670     True
3671     >>> S.GoldenRatio.expand(func=True)
3672     1/2 + sqrt(5)/2
3673     >>> S.GoldenRatio.is_irrational
3674     True
3675 
3676     References
3677     ==========
3678 
3679     .. [1] https://en.wikipedia.org/wiki/Golden_ratio
3680     """
3681 
3682     is_real = True
3683     is_positive = True
3684     is_negative = False
3685     is_irrational = True
3686     is_number = True
3687     is_algebraic = True
3688     is_transcendental = False
3689 
3690     __slots__ = ()
3691 
3692     def _latex(self, printer):
3693         return r"\phi"
3694 
3695     def __int__(self):
3696         return 1
3697 
3698     def _as_mpf_val(self, prec):
3699          # XXX track down why this has to be increased
3700         rv = mlib.from_man_exp(phi_fixed(prec + 10), -prec - 10)
3701         return mpf_norm(rv, prec)
3702 
3703     def _eval_expand_func(self, **hints):
3704         from sympy import sqrt
3705         return S.Half + S.Half*sqrt(5)
3706 
3707     def approximation_interval(self, number_cls):
3708         if issubclass(number_cls, Integer):
3709             return (S.One, Rational(2))
3710         elif issubclass(number_cls, Rational):
3711             pass
3712 
3713     def _sage_(self):
3714         import sage.all as sage
3715         return sage.golden_ratio
3716 
3717     _eval_rewrite_as_sqrt = _eval_expand_func
3718 
3719 
3720 class TribonacciConstant(NumberSymbol, metaclass=Singleton):
3721     r"""The tribonacci constant.
3722 
3723     Explanation
3724     ===========
3725 
3726     The tribonacci numbers are like the Fibonacci numbers, but instead
3727     of starting with two predetermined terms, the sequence starts with
3728     three predetermined terms and each term afterwards is the sum of the
3729     preceding three terms.
3730 
3731     The tribonacci constant is the ratio toward which adjacent tribonacci
3732     numbers tend. It is a root of the polynomial `x^3 - x^2 - x - 1 = 0`,
3733     and also satisfies the equation `x + x^{-3} = 2`.
3734 
3735     TribonacciConstant is a singleton, and can be accessed
3736     by ``S.TribonacciConstant``.
3737 
3738     Examples
3739     ========
3740 
3741     >>> from sympy import S
3742     >>> S.TribonacciConstant > 1
3743     True
3744     >>> S.TribonacciConstant.expand(func=True)
3745     1/3 + (19 - 3*sqrt(33))**(1/3)/3 + (3*sqrt(33) + 19)**(1/3)/3
3746     >>> S.TribonacciConstant.is_irrational
3747     True
3748     >>> S.TribonacciConstant.n(20)
3749     1.8392867552141611326
3750 
3751     References
3752     ==========
3753 
3754     .. [1] https://en.wikipedia.org/wiki/Generalizations_of_Fibonacci_numbers#Tribonacci_numbers
3755     """
3756 
3757     is_real = True
3758     is_positive = True
3759     is_negative = False
3760     is_irrational = True
3761     is_number = True
3762     is_algebraic = True
3763     is_transcendental = False
3764 
3765     __slots__ = ()
3766 
3767     def _latex(self, printer):
3768         return r"\text{TribonacciConstant}"
3769 
3770     def __int__(self):
3771         return 2
3772 
3773     def _eval_evalf(self, prec):
3774         rv = self._eval_expand_func(function=True)._eval_evalf(prec + 4)
3775         return Float(rv, precision=prec)
3776 
3777     def _eval_expand_func(self, **hints):
3778         from sympy import sqrt, cbrt
3779         return (1 + cbrt(19 - 3*sqrt(33)) + cbrt(19 + 3*sqrt(33))) / 3
3780 
3781     def approximation_interval(self, number_cls):
3782         if issubclass(number_cls, Integer):
3783             return (S.One, Rational(2))
3784         elif issubclass(number_cls, Rational):
3785             pass
3786 
3787     _eval_rewrite_as_sqrt = _eval_expand_func
3788 
3789 
3790 class EulerGamma(NumberSymbol, metaclass=Singleton):
3791     r"""The Euler-Mascheroni constant.
3792 
3793     Explanation
3794     ===========
3795 
3796     `\gamma = 0.5772157\ldots` (also called Euler's constant) is a mathematical
3797     constant recurring in analysis and number theory.  It is defined as the
3798     limiting difference between the harmonic series and the
3799     natural logarithm:
3800 
3801     .. math:: \gamma = \lim\limits_{n\to\infty}
3802               \left(\sum\limits_{k=1}^n\frac{1}{k} - \ln n\right)
3803 
3804     EulerGamma is a singleton, and can be accessed by ``S.EulerGamma``.
3805 
3806     Examples
3807     ========
3808 
3809     >>> from sympy import S
3810     >>> S.EulerGamma.is_irrational
3811     >>> S.EulerGamma > 0
3812     True
3813     >>> S.EulerGamma > 1
3814     False
3815 
3816     References
3817     ==========
3818 
3819     .. [1] https://en.wikipedia.org/wiki/Euler%E2%80%93Mascheroni_constant
3820     """
3821 
3822     is_real = True
3823     is_positive = True
3824     is_negative = False
3825     is_irrational = None
3826     is_number = True
3827 
3828     __slots__ = ()
3829 
3830     def _latex(self, printer):
3831         return r"\gamma"
3832 
3833     def __int__(self):
3834         return 0
3835 
3836     def _as_mpf_val(self, prec):
3837          # XXX track down why this has to be increased
3838         v = mlib.libhyper.euler_fixed(prec + 10)
3839         rv = mlib.from_man_exp(v, -prec - 10)
3840         return mpf_norm(rv, prec)
3841 
3842     def approximation_interval(self, number_cls):
3843         if issubclass(number_cls, Integer):
3844             return (S.Zero, S.One)
3845         elif issubclass(number_cls, Rational):
3846             return (S.Half, Rational(3, 5))
3847 
3848     def _sage_(self):
3849         import sage.all as sage
3850         return sage.euler_gamma
3851 
3852 
3853 class Catalan(NumberSymbol, metaclass=Singleton):
3854     r"""Catalan's constant.
3855 
3856     Explanation
3857     ===========
3858 
3859     `K = 0.91596559\ldots` is given by the infinite series
3860 
3861     .. math:: K = \sum_{k=0}^{\infty} \frac{(-1)^k}{(2k+1)^2}
3862 
3863     Catalan is a singleton, and can be accessed by ``S.Catalan``.
3864 
3865     Examples
3866     ========
3867 
3868     >>> from sympy import S
3869     >>> S.Catalan.is_irrational
3870     >>> S.Catalan > 0
3871     True
3872     >>> S.Catalan > 1
3873     False
3874 
3875     References
3876     ==========
3877 
3878     .. [1] https://en.wikipedia.org/wiki/Catalan%27s_constant
3879     """
3880 
3881     is_real = True
3882     is_positive = True
3883     is_negative = False
3884     is_irrational = None
3885     is_number = True
3886 
3887     __slots__ = ()
3888 
3889     def __int__(self):
3890         return 0
3891 
3892     def _as_mpf_val(self, prec):
3893         # XXX track down why this has to be increased
3894         v = mlib.catalan_fixed(prec + 10)
3895         rv = mlib.from_man_exp(v, -prec - 10)
3896         return mpf_norm(rv, prec)
3897 
3898     def approximation_interval(self, number_cls):
3899         if issubclass(number_cls, Integer):
3900             return (S.Zero, S.One)
3901         elif issubclass(number_cls, Rational):
3902             return (Rational(9, 10), S.One)
3903 
3904     def _eval_rewrite_as_Sum(self, k_sym=None, symbols=None):
3905         from sympy import Sum, Dummy
3906         if (k_sym is not None) or (symbols is not None):
3907             return self
3908         k = Dummy('k', integer=True, nonnegative=True)
3909         return Sum((-1)**k / (2*k+1)**2, (k, 0, S.Infinity))
3910 
3911     def _sage_(self):
3912         import sage.all as sage
3913         return sage.catalan
3914 
3915 
3916 class ImaginaryUnit(AtomicExpr, metaclass=Singleton):
3917     r"""The imaginary unit, `i = \sqrt{-1}`.
3918 
3919     I is a singleton, and can be accessed by ``S.I``, or can be
3920     imported as ``I``.
3921 
3922     Examples
3923     ========
3924 
3925     >>> from sympy import I, sqrt
3926     >>> sqrt(-1)
3927     I
3928     >>> I*I
3929     -1
3930     >>> 1/I
3931     -I
3932 
3933     References
3934     ==========
3935 
3936     .. [1] https://en.wikipedia.org/wiki/Imaginary_unit
3937     """
3938 
3939     is_commutative = True
3940     is_imaginary = True
3941     is_finite = True
3942     is_number = True
3943     is_algebraic = True
3944     is_transcendental = False
3945 
3946     kind = NumberKind
3947 
3948     __slots__ = ()
3949 
3950     def _latex(self, printer):
3951         return printer._settings['imaginary_unit_latex']
3952 
3953     @staticmethod
3954     def __abs__():
3955         return S.One
3956 
3957     def _eval_evalf(self, prec):
3958         return self
3959 
3960     def _eval_conjugate(self):
3961         return -S.ImaginaryUnit
3962 
3963     def _eval_power(self, expt):
3964         """
3965         b is I = sqrt(-1)
3966         e is symbolic object but not equal to 0, 1
3967 
3968         I**r -> (-1)**(r/2) -> exp(r/2*Pi*I) -> sin(Pi*r/2) + cos(Pi*r/2)*I, r is decimal
3969         I**0 mod 4 -> 1
3970         I**1 mod 4 -> I
3971         I**2 mod 4 -> -1
3972         I**3 mod 4 -> -I
3973         """
3974 
3975         if isinstance(expt, Integer):
3976             expt = expt % 4
3977             if expt == 0:
3978                 return S.One
3979             elif expt == 1:
3980                 return S.ImaginaryUnit
3981             elif expt == 2:
3982                 return S.NegativeOne
3983             elif expt == 3:
3984                 return -S.ImaginaryUnit
3985         if isinstance(expt, Rational):
3986             i, r = divmod(expt, 2)
3987             rv = Pow(S.ImaginaryUnit, r, evaluate=False)
3988             if i % 2:
3989                 return Mul(S.NegativeOne, rv, evaluate=False)
3990             return rv
3991 
3992     def as_base_exp(self):
3993         return S.NegativeOne, S.Half
3994 
3995     def _sage_(self):
3996         import sage.all as sage
3997         return sage.I
3998 
3999     @property
4000     def _mpc_(self):
4001         return (Float(0)._mpf_, Float(1)._mpf_)
4002 
4003 I = S.ImaginaryUnit
4004 
4005 @dispatch(Tuple, Number) # type:ignore
4006 def _eval_is_eq(self, other): # noqa: F811
4007     return False
4008 
4009 def sympify_fractions(f):
4010     return Rational(f.numerator, f.denominator, 1)
4011 
4012 converter[fractions.Fraction] = sympify_fractions
4013 
4014 if HAS_GMPY:
4015     def sympify_mpz(x):
4016         return Integer(int(x))
4017 
4018     # XXX: The sympify_mpq function here was never used because it is
4019     # overridden by the other sympify_mpq function below. Maybe it should just
4020     # be removed or maybe it should be used for something...
4021     def sympify_mpq(x):
4022         return Rational(int(x.numerator), int(x.denominator))
4023 
4024     converter[type(gmpy.mpz(1))] = sympify_mpz
4025     converter[type(gmpy.mpq(1, 2))] = sympify_mpq
4026 
4027 
4028 def sympify_mpmath_mpq(x):
4029     p, q = x._mpq_
4030     return Rational(p, q, 1)
4031 
4032 converter[type(mpmath.rational.mpq(1, 2))] = sympify_mpmath_mpq
4033 
4034 
4035 def sympify_mpmath(x):
4036     return Expr._from_mpmath(x, x.context.prec)
4037 
4038 converter[mpnumeric] = sympify_mpmath
4039 
4040 
4041 def sympify_complex(a):
4042     real, imag = list(map(sympify, (a.real, a.imag)))
4043     return real + S.ImaginaryUnit*imag
4044 
4045 converter[complex] = sympify_complex
4046 
4047 from .power import Pow, integer_nthroot
4048 from .mul import Mul
4049 Mul.identity = One()
4050 from .add import Add
4051 Add.identity = Zero()
4052 
4053 def _register_classes():
4054     numbers.Number.register(Number)
4055     numbers.Real.register(Float)
4056     numbers.Rational.register(Rational)
4057     numbers.Rational.register(Integer)
4058 
4059 _register_classes()

</code><intended_behavior>Enhance the precision handling or representation of `Float` objects when used in symbolic equations, especially within the context of linear solvers like `linsolve`. The goal is to minimize the impact of floating-point arithmetic issues (like rounding errors) that may lead to inconsistencies in equation solving outcomes. This may involve implementing a check or conversion mechanism that ensures numerical precision is maintained or enhanced when floating-point numbers are part of a symbolic equation, without undermining the performance or general usability of the library.</intended_behavior>]
2025-10-16 03:54:09.079 | INFO     | Search completed. Bug locations: [<file>sympy/solvers/solveset.py</file>
<class>None</class>
<method>linsolve</method>
<code>
2586 def linsolve(system, *symbols):
2587     r"""
2588     Solve system of N linear equations with M variables; both
2589     underdetermined and overdetermined systems are supported.
2590     The possible number of solutions is zero, one or infinite.
2591     Zero solutions throws a ValueError, whereas infinite
2592     solutions are represented parametrically in terms of the given
2593     symbols. For unique solution a FiniteSet of ordered tuples
2594     is returned.
2595 
2596     All Standard input formats are supported:
2597     For the given set of Equations, the respective input types
2598     are given below:
2599 
2600     .. math:: 3x + 2y -   z = 1
2601     .. math:: 2x - 2y + 4z = -2
2602     .. math:: 2x -   y + 2z = 0
2603 
2604     * Augmented Matrix Form, `system` given below:
2605 
2606     ::
2607 
2608               [3   2  -1  1]
2609      system = [2  -2   4 -2]
2610               [2  -1   2  0]
2611 
2612     * List Of Equations Form
2613 
2614     `system  =  [3x + 2y - z - 1, 2x - 2y + 4z + 2, 2x - y + 2z]`
2615 
2616     * Input A & b Matrix Form (from Ax = b) are given as below:
2617 
2618     ::
2619 
2620          [3   2  -1 ]         [  1 ]
2621      A = [2  -2   4 ]    b =  [ -2 ]
2622          [2  -1   2 ]         [  0 ]
2623 
2624     `system = (A, b)`
2625 
2626     Symbols can always be passed but are actually only needed
2627     when 1) a system of equations is being passed and 2) the
2628     system is passed as an underdetermined matrix and one wants
2629     to control the name of the free variables in the result.
2630     An error is raised if no symbols are used for case 1, but if
2631     no symbols are provided for case 2, internally generated symbols
2632     will be provided. When providing symbols for case 2, there should
2633     be at least as many symbols are there are columns in matrix A.
2634 
2635     The algorithm used here is Gauss-Jordan elimination, which
2636     results, after elimination, in a row echelon form matrix.
2637 
2638     Returns
2639     =======
2640 
2641     A FiniteSet containing an ordered tuple of values for the
2642     unknowns for which the `system` has a solution. (Wrapping
2643     the tuple in FiniteSet is used to maintain a consistent
2644     output format throughout solveset.)
2645 
2646     Returns EmptySet, if the linear system is inconsistent.
2647 
2648     Raises
2649     ======
2650 
2651     ValueError
2652         The input is not valid.
2653         The symbols are not given.
2654 
2655     Examples
2656     ========
2657 
2658     >>> from sympy import Matrix, linsolve, symbols
2659     >>> x, y, z = symbols("x, y, z")
2660     >>> A = Matrix([[1, 2, 3], [4, 5, 6], [7, 8, 10]])
2661     >>> b = Matrix([3, 6, 9])
2662     >>> A
2663     Matrix([
2664     [1, 2,  3],
2665     [4, 5,  6],
2666     [7, 8, 10]])
2667     >>> b
2668     Matrix([
2669     [3],
2670     [6],
2671     [9]])
2672     >>> linsolve((A, b), [x, y, z])
2673     FiniteSet((-1, 2, 0))
2674 
2675     * Parametric Solution: In case the system is underdetermined, the
2676       function will return a parametric solution in terms of the given
2677       symbols. Those that are free will be returned unchanged. e.g. in
2678       the system below, `z` is returned as the solution for variable z;
2679       it can take on any value.
2680 
2681     >>> A = Matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
2682     >>> b = Matrix([3, 6, 9])
2683     >>> linsolve((A, b), x, y, z)
2684     FiniteSet((z - 1, 2 - 2*z, z))
2685 
2686     If no symbols are given, internally generated symbols will be used.
2687     The `tau0` in the 3rd position indicates (as before) that the 3rd
2688     variable -- whatever it's named -- can take on any value:
2689 
2690     >>> linsolve((A, b))
2691     FiniteSet((tau0 - 1, 2 - 2*tau0, tau0))
2692 
2693     * List of Equations as input
2694 
2695     >>> Eqns = [3*x + 2*y - z - 1, 2*x - 2*y + 4*z + 2, - x + y/2 - z]
2696     >>> linsolve(Eqns, x, y, z)
2697     FiniteSet((1, -2, -2))
2698 
2699     * Augmented Matrix as input
2700 
2701     >>> aug = Matrix([[2, 1, 3, 1], [2, 6, 8, 3], [6, 8, 18, 5]])
2702     >>> aug
2703     Matrix([
2704     [2, 1,  3, 1],
2705     [2, 6,  8, 3],
2706     [6, 8, 18, 5]])
2707     >>> linsolve(aug, x, y, z)
2708     FiniteSet((3/10, 2/5, 0))
2709 
2710     * Solve for symbolic coefficients
2711 
2712     >>> a, b, c, d, e, f = symbols('a, b, c, d, e, f')
2713     >>> eqns = [a*x + b*y - c, d*x + e*y - f]
2714     >>> linsolve(eqns, x, y)
2715     FiniteSet(((-b*f + c*e)/(a*e - b*d), (a*f - c*d)/(a*e - b*d)))
2716 
2717     * A degenerate system returns solution as set of given
2718       symbols.
2719 
2720     >>> system = Matrix(([0, 0, 0], [0, 0, 0], [0, 0, 0]))
2721     >>> linsolve(system, x, y)
2722     FiniteSet((x, y))
2723 
2724     * For an empty system linsolve returns empty set
2725 
2726     >>> linsolve([], x)
2727     EmptySet
2728 
2729     * An error is raised if, after expansion, any nonlinearity
2730       is detected:
2731 
2732     >>> linsolve([x*(1/x - 1), (y - 1)**2 - y**2 + 1], x, y)
2733     FiniteSet((1, 1))
2734     >>> linsolve([x**2 - 1], x)
2735     Traceback (most recent call last):
2736     ...
2737     NonlinearError:
2738     nonlinear term encountered: x**2
2739     """
2740     if not system:
2741         return S.EmptySet
2742 
2743     # If second argument is an iterable
2744     if symbols and hasattr(symbols[0], '__iter__'):
2745         symbols = symbols[0]
2746     sym_gen = isinstance(symbols, GeneratorType)
2747 
2748     b = None  # if we don't get b the input was bad
2749     syms_needed_msg = None
2750 
2751     # unpack system
2752 
2753     if hasattr(system, '__iter__'):
2754 
2755         # 1). (A, b)
2756         if len(system) == 2 and isinstance(system[0], MatrixBase):
2757             A, b = system
2758 
2759         # 2). (eq1, eq2, ...)
2760         if not isinstance(system[0], MatrixBase):
2761             if sym_gen or not symbols:
2762                 raise ValueError(filldedent('''
2763                     When passing a system of equations, the explicit
2764                     symbols for which a solution is being sought must
2765                     be given as a sequence, too.
2766                 '''))
2767 
2768             #
2769             # Pass to the sparse solver implemented in polys. It is important
2770             # that we do not attempt to convert the equations to a matrix
2771             # because that would be very inefficient for large sparse systems
2772             # of equations.
2773             #
2774             eqs = system
2775             eqs = [sympify(eq) for eq in eqs]
2776             try:
2777                 sol = _linsolve(eqs, symbols)
2778             except PolyNonlinearError as exc:
2779                 # e.g. cos(x) contains an element of the set of generators
2780                 raise NonlinearError(str(exc))
2781 
2782             if sol is None:
2783                 return S.EmptySet
2784 
2785             sol = FiniteSet(Tuple(*(sol.get(sym, sym) for sym in symbols)))
2786             return sol
2787 
2788     elif isinstance(system, MatrixBase) and not (
2789             symbols and not isinstance(symbols, GeneratorType) and
2790             isinstance(symbols[0], MatrixBase)):
2791         # 3). A augmented with b
2792         A, b = system[:, :-1], system[:, -1:]
2793 
2794     if b is None:
2795         raise ValueError("Invalid arguments")
2796 
2797     syms_needed_msg  = syms_needed_msg or 'columns of A'
2798 
2799     if sym_gen:
2800         symbols = [next(symbols) for i in range(A.cols)]
2801         if any(set(symbols) & (A.free_symbols | b.free_symbols)):
2802             raise ValueError(filldedent('''
2803                 At least one of the symbols provided
2804                 already appears in the system to be solved.
2805                 One way to avoid this is to use Dummy symbols in
2806                 the generator, e.g. numbered_symbols('%s', cls=Dummy)
2807             ''' % symbols[0].name.rstrip('1234567890')))
2808 
2809     if not symbols:
2810         symbols = [Dummy() for _ in range(A.cols)]
2811         name = _uniquely_named_symbol('tau', (A, b),
2812             compare=lambda i: str(i).rstrip('1234567890')).name
2813         gen  = numbered_symbols(name)
2814     else:
2815         gen = None
2816 
2817     # This is just a wrapper for solve_lin_sys
2818     eqs = []
2819     rows = A.tolist()
2820     for rowi, bi in zip(rows, b):
2821         terms = [elem * sym for elem, sym in zip(rowi, symbols) if elem]
2822         terms.append(-bi)
2823         eqs.append(Add(*terms))
2824 
2825     eqs, ring = sympy_eqs_to_ring(eqs, symbols)
2826     sol = solve_lin_sys(eqs, ring, _raw=False)
2827     if sol is None:
2828         return S.EmptySet
2829     #sol = {sym:val for sym, val in sol.items() if sym != val}
2830     sol = FiniteSet(Tuple(*(sol.get(sym, sym) for sym in symbols)))
2831 
2832     if gen is not None:
2833         solsym = sol.free_symbols
2834         rep = {sym: next(gen) for sym in symbols if sym in solsym}
2835         sol = sol.subs(rep)
2836 
2837     return sol

</code><intended_behavior>The `linsolve` method should more robustly handle floating-point coefficients close in value, ensuring consistent solutions across mathematically equivalent or very close systems of equations. Specifically, it should include a preprocessing step to detect if the equations involve floating-point coefficients that are close in value and, if so, apply an appropriate strategy to handle them consistentlyâ€”perhaps by using a symbolic or rational representation internally for greater numerical stability in solutions. This change must preserve `linsolve`'s existing functionality for all other cases while ensuring that the method returns consistent results for systems with slightly different floating-point coefficients.</intended_behavior>, <file>sympy/core/numbers.py</file>
<class>None</class>
<method>None</method>
<code>
1 import numbers
2 import decimal
3 import fractions
4 import math
5 import re as regex
6 import sys
7 
8 from .containers import Tuple
9 from .sympify import (SympifyError, converter, sympify, _convert_numpy_types, _sympify,
10                       _is_numpy_instance)
11 from .singleton import S, Singleton
12 from .expr import Expr, AtomicExpr
13 from .evalf import pure_complex
14 from .decorators import _sympifyit
15 from .cache import cacheit, clear_cache
16 from .logic import fuzzy_not
17 from sympy.core.compatibility import (as_int, HAS_GMPY, SYMPY_INTS,
18     gmpy)
19 from sympy.core.cache import lru_cache
20 from .kind import NumberKind
21 from sympy.multipledispatch import dispatch
22 import mpmath
23 import mpmath.libmp as mlib
24 from mpmath.libmp import bitcount
25 from mpmath.libmp.backend import MPZ
26 from mpmath.libmp import mpf_pow, mpf_pi, mpf_e, phi_fixed
27 from mpmath.ctx_mp import mpnumeric
28 from mpmath.libmp.libmpf import (
29     finf as _mpf_inf, fninf as _mpf_ninf,
30     fnan as _mpf_nan, fzero, _normalize as mpf_normalize,
31     prec_to_dps)
32 from sympy.utilities.misc import debug, filldedent
33 from .parameters import global_parameters
34 
35 from sympy.utilities.exceptions import SymPyDeprecationWarning
36 
37 rnd = mlib.round_nearest
38 
39 _LOG2 = math.log(2)
40 
41 
42 def comp(z1, z2, tol=None):
43     """Return a bool indicating whether the error between z1 and z2
44     is <= tol.
45 
46     Examples
47     ========
48 
49     If ``tol`` is None then True will be returned if
50     ``abs(z1 - z2)*10**p <= 5`` where ``p`` is minimum value of the
51     decimal precision of each value.
52 
53     >>> from sympy.core.numbers import comp, pi
54     >>> pi4 = pi.n(4); pi4
55     3.142
56     >>> comp(_, 3.142)
57     True
58     >>> comp(pi4, 3.141)
59     False
60     >>> comp(pi4, 3.143)
61     False
62 
63     A comparison of strings will be made
64     if ``z1`` is a Number and ``z2`` is a string or ``tol`` is ''.
65 
66     >>> comp(pi4, 3.1415)
67     True
68     >>> comp(pi4, 3.1415, '')
69     False
70 
71     When ``tol`` is provided and ``z2`` is non-zero and
72     ``|z1| > 1`` the error is normalized by ``|z1|``:
73 
74     >>> abs(pi4 - 3.14)/pi4
75     0.000509791731426756
76     >>> comp(pi4, 3.14, .001)  # difference less than 0.1%
77     True
78     >>> comp(pi4, 3.14, .0005)  # difference less than 0.1%
79     False
80 
81     When ``|z1| <= 1`` the absolute error is used:
82 
83     >>> 1/pi4
84     0.3183
85     >>> abs(1/pi4 - 0.3183)/(1/pi4)
86     3.07371499106316e-5
87     >>> abs(1/pi4 - 0.3183)
88     9.78393554684764e-6
89     >>> comp(1/pi4, 0.3183, 1e-5)
90     True
91 
92     To see if the absolute error between ``z1`` and ``z2`` is less
93     than or equal to ``tol``, call this as ``comp(z1 - z2, 0, tol)``
94     or ``comp(z1 - z2, tol=tol)``:
95 
96     >>> abs(pi4 - 3.14)
97     0.00160156249999988
98     >>> comp(pi4 - 3.14, 0, .002)
99     True
100     >>> comp(pi4 - 3.14, 0, .001)
101     False
102     """
103     if type(z2) is str:
104         if not pure_complex(z1, or_real=True):
105             raise ValueError('when z2 is a str z1 must be a Number')
106         return str(z1) == z2
107     if not z1:
108         z1, z2 = z2, z1
109     if not z1:
110         return True
111     if not tol:
112         a, b = z1, z2
113         if tol == '':
114             return str(a) == str(b)
115         if tol is None:
116             a, b = sympify(a), sympify(b)
117             if not all(i.is_number for i in (a, b)):
118                 raise ValueError('expecting 2 numbers')
119             fa = a.atoms(Float)
120             fb = b.atoms(Float)
121             if not fa and not fb:
122                 # no floats -- compare exactly
123                 return a == b
124             # get a to be pure_complex
125             for do in range(2):
126                 ca = pure_complex(a, or_real=True)
127                 if not ca:
128                     if fa:
129                         a = a.n(prec_to_dps(min([i._prec for i in fa])))
130                         ca = pure_complex(a, or_real=True)
131                         break
132                     else:
133                         fa, fb = fb, fa
134                         a, b = b, a
135             cb = pure_complex(b)
136             if not cb and fb:
137                 b = b.n(prec_to_dps(min([i._prec for i in fb])))
138                 cb = pure_complex(b, or_real=True)
139             if ca and cb and (ca[1] or cb[1]):
140                 return all(comp(i, j) for i, j in zip(ca, cb))
141             tol = 10**prec_to_dps(min(a._prec, getattr(b, '_prec', a._prec)))
142             return int(abs(a - b)*tol) <= 5
143     diff = abs(z1 - z2)
144     az1 = abs(z1)
145     if z2 and az1 > 1:
146         return diff/az1 <= tol
147     else:
148         return diff <= tol
149 
150 
151 def mpf_norm(mpf, prec):
152     """Return the mpf tuple normalized appropriately for the indicated
153     precision after doing a check to see if zero should be returned or
154     not when the mantissa is 0. ``mpf_normlize`` always assumes that this
155     is zero, but it may not be since the mantissa for mpf's values "+inf",
156     "-inf" and "nan" have a mantissa of zero, too.
157 
158     Note: this is not intended to validate a given mpf tuple, so sending
159     mpf tuples that were not created by mpmath may produce bad results. This
160     is only a wrapper to ``mpf_normalize`` which provides the check for non-
161     zero mpfs that have a 0 for the mantissa.
162     """
163     sign, man, expt, bc = mpf
164     if not man:
165         # hack for mpf_normalize which does not do this;
166         # it assumes that if man is zero the result is 0
167         # (see issue 6639)
168         if not bc:
169             return fzero
170         else:
171             # don't change anything; this should already
172             # be a well formed mpf tuple
173             return mpf
174 
175     # Necessary if mpmath is using the gmpy backend
176     from mpmath.libmp.backend import MPZ
177     rv = mpf_normalize(sign, MPZ(man), expt, bc, prec, rnd)
178     return rv
179 
180 # TODO: we should use the warnings module
181 _errdict = {"divide": False}
182 
183 
184 def seterr(divide=False):
185     """
186     Should sympy raise an exception on 0/0 or return a nan?
187 
188     divide == True .... raise an exception
189     divide == False ... return nan
190     """
191     if _errdict["divide"] != divide:
192         clear_cache()
193         _errdict["divide"] = divide
194 
195 
196 def _as_integer_ratio(p):
197     neg_pow, man, expt, bc = getattr(p, '_mpf_', mpmath.mpf(p)._mpf_)
198     p = [1, -1][neg_pow % 2]*man
199     if expt < 0:
200         q = 2**-expt
201     else:
202         q = 1
203         p *= 2**expt
204     return int(p), int(q)
205 
206 
207 def _decimal_to_Rational_prec(dec):
208     """Convert an ordinary decimal instance to a Rational."""
209     if not dec.is_finite():
210         raise TypeError("dec must be finite, got %s." % dec)
211     s, d, e = dec.as_tuple()
212     prec = len(d)
213     if e >= 0:  # it's an integer
214         rv = Integer(int(dec))
215     else:
216         s = (-1)**s
217         d = sum([di*10**i for i, di in enumerate(reversed(d))])
218         rv = Rational(s*d, 10**-e)
219     return rv, prec
220 
221 
222 _floatpat = regex.compile(r"[-+]?((\d*\.\d+)|(\d+\.?))")
223 def _literal_float(f):
224     """Return True if n starts like a floating point number."""
225     return bool(_floatpat.match(f))
226 
227 # (a,b) -> gcd(a,b)
228 
229 # TODO caching with decorator, but not to degrade performance
230 
231 @lru_cache(1024)
232 def igcd(*args):
233     """Computes nonnegative integer greatest common divisor.
234 
235     Explanation
236     ===========
237 
238     The algorithm is based on the well known Euclid's algorithm. To
239     improve speed, igcd() has its own caching mechanism implemented.
240 
241     Examples
242     ========
243 
244     >>> from sympy.core.numbers import igcd
245     >>> igcd(2, 4)
246     2
247     >>> igcd(5, 10, 15)
248     5
249 
250     """
251     if len(args) < 2:
252         raise TypeError(
253             'igcd() takes at least 2 arguments (%s given)' % len(args))
254     args_temp = [abs(as_int(i)) for i in args]
255     if 1 in args_temp:
256         return 1
257     a = args_temp.pop()
258     if HAS_GMPY: # Using gmpy if present to speed up.
259         for b in args_temp:
260             a = gmpy.gcd(a, b) if b else a
261         return as_int(a)
262     for b in args_temp:
263         a = math.gcd(a, b)
264     return a
265 
266 
267 igcd2 = math.gcd
268 
269 
270 def igcd_lehmer(a, b):
271     """Computes greatest common divisor of two integers.
272 
273     Explanation
274     ===========
275 
276     Euclid's algorithm for the computation of the greatest
277     common divisor  gcd(a, b)  of two (positive) integers
278     a and b is based on the division identity
279         a = q*b + r,
280     where the quotient  q  and the remainder  r  are integers
281     and  0 <= r < b. Then each common divisor of  a  and  b
282     divides  r, and it follows that  gcd(a, b) == gcd(b, r).
283     The algorithm works by constructing the sequence
284     r0, r1, r2, ..., where  r0 = a, r1 = b,  and each  rn
285     is the remainder from the division of the two preceding
286     elements.
287 
288     In Python, q = a // b  and  r = a % b  are obtained by the
289     floor division and the remainder operations, respectively.
290     These are the most expensive arithmetic operations, especially
291     for large  a  and  b.
292 
293     Lehmer's algorithm is based on the observation that the quotients
294     qn = r(n-1) // rn  are in general small integers even
295     when  a  and  b  are very large. Hence the quotients can be
296     usually determined from a relatively small number of most
297     significant bits.
298 
299     The efficiency of the algorithm is further enhanced by not
300     computing each long remainder in Euclid's sequence. The remainders
301     are linear combinations of  a  and  b  with integer coefficients
302     derived from the quotients. The coefficients can be computed
303     as far as the quotients can be determined from the chosen
304     most significant parts of  a  and  b. Only then a new pair of
305     consecutive remainders is computed and the algorithm starts
306     anew with this pair.
307 
308     References
309     ==========
310 
311     .. [1] https://en.wikipedia.org/wiki/Lehmer%27s_GCD_algorithm
312 
313     """
314     a, b = abs(as_int(a)), abs(as_int(b))
315     if a < b:
316         a, b = b, a
317 
318     # The algorithm works by using one or two digit division
319     # whenever possible. The outer loop will replace the
320     # pair (a, b) with a pair of shorter consecutive elements
321     # of the Euclidean gcd sequence until a and b
322     # fit into two Python (long) int digits.
323     nbits = 2*sys.int_info.bits_per_digit
324 
325     while a.bit_length() > nbits and b != 0:
326         # Quotients are mostly small integers that can
327         # be determined from most significant bits.
328         n = a.bit_length() - nbits
329         x, y = int(a >> n), int(b >> n)  # most significant bits
330 
331         # Elements of the Euclidean gcd sequence are linear
332         # combinations of a and b with integer coefficients.
333         # Compute the coefficients of consecutive pairs
334         #     a' = A*a + B*b, b' = C*a + D*b
335         # using small integer arithmetic as far as possible.
336         A, B, C, D = 1, 0, 0, 1  # initial values
337 
338         while True:
339             # The coefficients alternate in sign while looping.
340             # The inner loop combines two steps to keep track
341             # of the signs.
342 
343             # At this point we have
344             #   A > 0, B <= 0, C <= 0, D > 0,
345             #   x' = x + B <= x < x" = x + A,
346             #   y' = y + C <= y < y" = y + D,
347             # and
348             #   x'*N <= a' < x"*N, y'*N <= b' < y"*N,
349             # where N = 2**n.
350 
351             # Now, if y' > 0, and x"//y' and x'//y" agree,
352             # then their common value is equal to  q = a'//b'.
353             # In addition,
354             #   x'%y" = x' - q*y" < x" - q*y' = x"%y',
355             # and
356             #   (x'%y")*N < a'%b' < (x"%y')*N.
357 
358             # On the other hand, we also have  x//y == q,
359             # and therefore
360             #   x'%y" = x + B - q*(y + D) = x%y + B',
361             #   x"%y' = x + A - q*(y + C) = x%y + A',
362             # where
363             #    B' = B - q*D < 0, A' = A - q*C > 0.
364 
365             if y + C <= 0:
366                 break
367             q = (x + A) // (y + C)
368 
369             # Now  x'//y" <= q, and equality holds if
370             #   x' - q*y" = (x - q*y) + (B - q*D) >= 0.
371             # This is a minor optimization to avoid division.
372             x_qy, B_qD = x - q*y, B - q*D
373             if x_qy + B_qD < 0:
374                 break
375 
376             # Next step in the Euclidean sequence.
377             x, y = y, x_qy
378             A, B, C, D = C, D, A - q*C, B_qD
379 
380             # At this point the signs of the coefficients
381             # change and their roles are interchanged.
382             #   A <= 0, B > 0, C > 0, D < 0,
383             #   x' = x + A <= x < x" = x + B,
384             #   y' = y + D < y < y" = y + C.
385 
386             if y + D <= 0:
387                 break
388             q = (x + B) // (y + D)
389             x_qy, A_qC = x - q*y, A - q*C
390             if x_qy + A_qC < 0:
391                 break
392 
393             x, y = y, x_qy
394             A, B, C, D = C, D, A_qC, B - q*D
395             # Now the conditions on top of the loop
396             # are again satisfied.
397             #   A > 0, B < 0, C < 0, D > 0.
398 
399         if B == 0:
400             # This can only happen when y == 0 in the beginning
401             # and the inner loop does nothing.
402             # Long division is forced.
403             a, b = b, a % b
404             continue
405 
406         # Compute new long arguments using the coefficients.
407         a, b = A*a + B*b, C*a + D*b
408 
409     # Small divisors. Finish with the standard algorithm.
410     while b:
411         a, b = b, a % b
412 
413     return a
414 
415 
416 def ilcm(*args):
417     """Computes integer least common multiple.
418 
419     Examples
420     ========
421 
422     >>> from sympy.core.numbers import ilcm
423     >>> ilcm(5, 10)
424     10
425     >>> ilcm(7, 3)
426     21
427     >>> ilcm(5, 10, 15)
428     30
429 
430     """
431     if len(args) < 2:
432         raise TypeError(
433             'ilcm() takes at least 2 arguments (%s given)' % len(args))
434     if 0 in args:
435         return 0
436     a = args[0]
437     for b in args[1:]:
438         a = a // igcd(a, b) * b # since gcd(a,b) | a
439     return a
440 
441 
442 def igcdex(a, b):
443     """Returns x, y, g such that g = x*a + y*b = gcd(a, b).
444 
445     Examples
446     ========
447 
448     >>> from sympy.core.numbers import igcdex
449     >>> igcdex(2, 3)
450     (-1, 1, 1)
451     >>> igcdex(10, 12)
452     (-1, 1, 2)
453 
454     >>> x, y, g = igcdex(100, 2004)
455     >>> x, y, g
456     (-20, 1, 4)
457     >>> x*100 + y*2004
458     4
459 
460     """
461     if (not a) and (not b):
462         return (0, 1, 0)
463 
464     if not a:
465         return (0, b//abs(b), abs(b))
466     if not b:
467         return (a//abs(a), 0, abs(a))
468 
469     if a < 0:
470         a, x_sign = -a, -1
471     else:
472         x_sign = 1
473 
474     if b < 0:
475         b, y_sign = -b, -1
476     else:
477         y_sign = 1
478 
479     x, y, r, s = 1, 0, 0, 1
480 
481     while b:
482         (c, q) = (a % b, a // b)
483         (a, b, r, s, x, y) = (b, c, x - q*r, y - q*s, r, s)
484 
485     return (x*x_sign, y*y_sign, a)
486 
487 
488 def mod_inverse(a, m):
489     """
490     Return the number c such that, (a * c) = 1 (mod m)
491     where c has the same sign as m. If no such value exists,
492     a ValueError is raised.
493 
494     Examples
495     ========
496 
497     >>> from sympy import S
498     >>> from sympy.core.numbers import mod_inverse
499 
500     Suppose we wish to find multiplicative inverse x of
501     3 modulo 11. This is the same as finding x such
502     that 3 * x = 1 (mod 11). One value of x that satisfies
503     this congruence is 4. Because 3 * 4 = 12 and 12 = 1 (mod 11).
504     This is the value returned by mod_inverse:
505 
506     >>> mod_inverse(3, 11)
507     4
508     >>> mod_inverse(-3, 11)
509     7
510 
511     When there is a common factor between the numerators of
512     ``a`` and ``m`` the inverse does not exist:
513 
514     >>> mod_inverse(2, 4)
515     Traceback (most recent call last):
516     ...
517     ValueError: inverse of 2 mod 4 does not exist
518 
519     >>> mod_inverse(S(2)/7, S(5)/2)
520     7/2
521 
522     References
523     ==========
524 
525     .. [1] https://en.wikipedia.org/wiki/Modular_multiplicative_inverse
526     .. [2] https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm
527     """
528     c = None
529     try:
530         a, m = as_int(a), as_int(m)
531         if m != 1 and m != -1:
532             x, y, g = igcdex(a, m)
533             if g == 1:
534                 c = x % m
535     except ValueError:
536         a, m = sympify(a), sympify(m)
537         if not (a.is_number and m.is_number):
538             raise TypeError(filldedent('''
539                 Expected numbers for arguments; symbolic `mod_inverse`
540                 is not implemented
541                 but symbolic expressions can be handled with the
542                 similar function,
543                 sympy.polys.polytools.invert'''))
544         big = (m > 1)
545         if not (big is S.true or big is S.false):
546             raise ValueError('m > 1 did not evaluate; try to simplify %s' % m)
547         elif big:
548             c = 1/a
549     if c is None:
550         raise ValueError('inverse of %s (mod %s) does not exist' % (a, m))
551     return c
552 
553 
554 class Number(AtomicExpr):
555     """Represents atomic numbers in SymPy.
556 
557     Explanation
558     ===========
559 
560     Floating point numbers are represented by the Float class.
561     Rational numbers (of any size) are represented by the Rational class.
562     Integer numbers (of any size) are represented by the Integer class.
563     Float and Rational are subclasses of Number; Integer is a subclass
564     of Rational.
565 
566     For example, ``2/3`` is represented as ``Rational(2, 3)`` which is
567     a different object from the floating point number obtained with
568     Python division ``2/3``. Even for numbers that are exactly
569     represented in binary, there is a difference between how two forms,
570     such as ``Rational(1, 2)`` and ``Float(0.5)``, are used in SymPy.
571     The rational form is to be preferred in symbolic computations.
572 
573     Other kinds of numbers, such as algebraic numbers ``sqrt(2)`` or
574     complex numbers ``3 + 4*I``, are not instances of Number class as
575     they are not atomic.
576 
577     See Also
578     ========
579 
580     Float, Integer, Rational
581     """
582     is_commutative = True
583     is_number = True
584     is_Number = True
585 
586     __slots__ = ()
587 
588     # Used to make max(x._prec, y._prec) return x._prec when only x is a float
589     _prec = -1
590 
591     kind = NumberKind
592 
593     def __new__(cls, *obj):
594         if len(obj) == 1:
595             obj = obj[0]
596 
597         if isinstance(obj, Number):
598             return obj
599         if isinstance(obj, SYMPY_INTS):
600             return Integer(obj)
601         if isinstance(obj, tuple) and len(obj) == 2:
602             return Rational(*obj)
603         if isinstance(obj, (float, mpmath.mpf, decimal.Decimal)):
604             return Float(obj)
605         if isinstance(obj, str):
606             _obj = obj.lower()  # float('INF') == float('inf')
607             if _obj == 'nan':
608                 return S.NaN
609             elif _obj == 'inf':
610                 return S.Infinity
611             elif _obj == '+inf':
612                 return S.Infinity
613             elif _obj == '-inf':
614                 return S.NegativeInfinity
615             val = sympify(obj)
616             if isinstance(val, Number):
617                 return val
618             else:
619                 raise ValueError('String "%s" does not denote a Number' % obj)
620         msg = "expected str|int|long|float|Decimal|Number object but got %r"
621         raise TypeError(msg % type(obj).__name__)
622 
623     def invert(self, other, *gens, **args):
624         from sympy.polys.polytools import invert
625         if getattr(other, 'is_number', True):
626             return mod_inverse(self, other)
627         return invert(self, other, *gens, **args)
628 
629     def __divmod__(self, other):
630         from .containers import Tuple
631         from sympy.functions.elementary.complexes import sign
632 
633         try:
634             other = Number(other)
635             if self.is_infinite or S.NaN in (self, other):
636                 return (S.NaN, S.NaN)
637         except TypeError:
638             return NotImplemented
639         if not other:
640             raise ZeroDivisionError('modulo by zero')
641         if self.is_Integer and other.is_Integer:
642             return Tuple(*divmod(self.p, other.p))
643         elif isinstance(other, Float):
644             rat = self/Rational(other)
645         else:
646             rat = self/other
647         if other.is_finite:
648             w = int(rat) if rat >= 0 else int(rat) - 1
649             r = self - other*w
650         else:
651             w = 0 if not self or (sign(self) == sign(other)) else -1
652             r = other if w else self
653         return Tuple(w, r)
654 
655     def __rdivmod__(self, other):
656         try:
657             other = Number(other)
658         except TypeError:
659             return NotImplemented
660         return divmod(other, self)
661 
662     def _as_mpf_val(self, prec):
663         """Evaluation of mpf tuple accurate to at least prec bits."""
664         raise NotImplementedError('%s needs ._as_mpf_val() method' %
665             (self.__class__.__name__))
666 
667     def _eval_evalf(self, prec):
668         return Float._new(self._as_mpf_val(prec), prec)
669 
670     def _as_mpf_op(self, prec):
671         prec = max(prec, self._prec)
672         return self._as_mpf_val(prec), prec
673 
674     def __float__(self):
675         return mlib.to_float(self._as_mpf_val(53))
676 
677     def floor(self):
678         raise NotImplementedError('%s needs .floor() method' %
679             (self.__class__.__name__))
680 
681     def ceiling(self):
682         raise NotImplementedError('%s needs .ceiling() method' %
683             (self.__class__.__name__))
684 
685     def __floor__(self):
686         return self.floor()
687 
688     def __ceil__(self):
689         return self.ceiling()
690 
691     def _eval_conjugate(self):
692         return self
693 
694     def _eval_order(self, *symbols):
695         from sympy import Order
696         # Order(5, x, y) -> Order(1,x,y)
697         return Order(S.One, *symbols)
698 
699     def _eval_subs(self, old, new):
700         if old == -self:
701             return -new
702         return self  # there is no other possibility
703 
704     def _eval_is_finite(self):
705         return True
706 
707     @classmethod
708     def class_key(cls):
709         return 1, 0, 'Number'
710 
711     @cacheit
712     def sort_key(self, order=None):
713         return self.class_key(), (0, ()), (), self
714 
715     @_sympifyit('other', NotImplemented)
716     def __add__(self, other):
717         if isinstance(other, Number) and global_parameters.evaluate:
718             if other is S.NaN:
719                 return S.NaN
720             elif other is S.Infinity:
721                 return S.Infinity
722             elif other is S.NegativeInfinity:
723                 return S.NegativeInfinity
724         return AtomicExpr.__add__(self, other)
725 
726     @_sympifyit('other', NotImplemented)
727     def __sub__(self, other):
728         if isinstance(other, Number) and global_parameters.evaluate:
729             if other is S.NaN:
730                 return S.NaN
731             elif other is S.Infinity:
732                 return S.NegativeInfinity
733             elif other is S.NegativeInfinity:
734                 return S.Infinity
735         return AtomicExpr.__sub__(self, other)
736 
737     @_sympifyit('other', NotImplemented)
738     def __mul__(self, other):
739         if isinstance(other, Number) and global_parameters.evaluate:
740             if other is S.NaN:
741                 return S.NaN
742             elif other is S.Infinity:
743                 if self.is_zero:
744                     return S.NaN
745                 elif self.is_positive:
746                     return S.Infinity
747                 else:
748                     return S.NegativeInfinity
749             elif other is S.NegativeInfinity:
750                 if self.is_zero:
751                     return S.NaN
752                 elif self.is_positive:
753                     return S.NegativeInfinity
754                 else:
755                     return S.Infinity
756         elif isinstance(other, Tuple):
757             return NotImplemented
758         return AtomicExpr.__mul__(self, other)
759 
760     @_sympifyit('other', NotImplemented)
761     def __truediv__(self, other):
762         if isinstance(other, Number) and global_parameters.evaluate:
763             if other is S.NaN:
764                 return S.NaN
765             elif other is S.Infinity or other is S.NegativeInfinity:
766                 return S.Zero
767         return AtomicExpr.__truediv__(self, other)
768 
769     def __eq__(self, other):
770         raise NotImplementedError('%s needs .__eq__() method' %
771             (self.__class__.__name__))
772 
773     def __ne__(self, other):
774         raise NotImplementedError('%s needs .__ne__() method' %
775             (self.__class__.__name__))
776 
777     def __lt__(self, other):
778         try:
779             other = _sympify(other)
780         except SympifyError:
781             raise TypeError("Invalid comparison %s < %s" % (self, other))
782         raise NotImplementedError('%s needs .__lt__() method' %
783             (self.__class__.__name__))
784 
785     def __le__(self, other):
786         try:
787             other = _sympify(other)
788         except SympifyError:
789             raise TypeError("Invalid comparison %s <= %s" % (self, other))
790         raise NotImplementedError('%s needs .__le__() method' %
791             (self.__class__.__name__))
792 
793     def __gt__(self, other):
794         try:
795             other = _sympify(other)
796         except SympifyError:
797             raise TypeError("Invalid comparison %s > %s" % (self, other))
798         return _sympify(other).__lt__(self)
799 
800     def __ge__(self, other):
801         try:
802             other = _sympify(other)
803         except SympifyError:
804             raise TypeError("Invalid comparison %s >= %s" % (self, other))
805         return _sympify(other).__le__(self)
806 
807     def __hash__(self):
808         return super().__hash__()
809 
810     def is_constant(self, *wrt, **flags):
811         return True
812 
813     def as_coeff_mul(self, *deps, rational=True, **kwargs):
814         # a -> c*t
815         if self.is_Rational or not rational:
816             return self, tuple()
817         elif self.is_negative:
818             return S.NegativeOne, (-self,)
819         return S.One, (self,)
820 
821     def as_coeff_add(self, *deps):
822         # a -> c + t
823         if self.is_Rational:
824             return self, tuple()
825         return S.Zero, (self,)
826 
827     def as_coeff_Mul(self, rational=False):
828         """Efficiently extract the coefficient of a product. """
829         if rational and not self.is_Rational:
830             return S.One, self
831         return (self, S.One) if self else (S.One, self)
832 
833     def as_coeff_Add(self, rational=False):
834         """Efficiently extract the coefficient of a summation. """
835         if not rational:
836             return self, S.Zero
837         return S.Zero, self
838 
839     def gcd(self, other):
840         """Compute GCD of `self` and `other`. """
841         from sympy.polys import gcd
842         return gcd(self, other)
843 
844     def lcm(self, other):
845         """Compute LCM of `self` and `other`. """
846         from sympy.polys import lcm
847         return lcm(self, other)
848 
849     def cofactors(self, other):
850         """Compute GCD and cofactors of `self` and `other`. """
851         from sympy.polys import cofactors
852         return cofactors(self, other)
853 
854 
855 class Float(Number):
856     """Represent a floating-point number of arbitrary precision.
857 
858     Examples
859     ========
860 
861     >>> from sympy import Float
862     >>> Float(3.5)
863     3.50000000000000
864     >>> Float(3)
865     3.00000000000000
866 
867     Creating Floats from strings (and Python ``int`` and ``long``
868     types) will give a minimum precision of 15 digits, but the
869     precision will automatically increase to capture all digits
870     entered.
871 
872     >>> Float(1)
873     1.00000000000000
874     >>> Float(10**20)
875     100000000000000000000.
876     >>> Float('1e20')
877     100000000000000000000.
878 
879     However, *floating-point* numbers (Python ``float`` types) retain
880     only 15 digits of precision:
881 
882     >>> Float(1e20)
883     1.00000000000000e+20
884     >>> Float(1.23456789123456789)
885     1.23456789123457
886 
887     It may be preferable to enter high-precision decimal numbers
888     as strings:
889 
890     >>> Float('1.23456789123456789')
891     1.23456789123456789
892 
893     The desired number of digits can also be specified:
894 
895     >>> Float('1e-3', 3)
896     0.00100
897     >>> Float(100, 4)
898     100.0
899 
900     Float can automatically count significant figures if a null string
901     is sent for the precision; spaces or underscores are also allowed. (Auto-
902     counting is only allowed for strings, ints and longs).
903 
904     >>> Float('123 456 789.123_456', '')
905     123456789.123456
906     >>> Float('12e-3', '')
907     0.012
908     >>> Float(3, '')
909     3.
910 
911     If a number is written in scientific notation, only the digits before the
912     exponent are considered significant if a decimal appears, otherwise the
913     "e" signifies only how to move the decimal:
914 
915     >>> Float('60.e2', '')  # 2 digits significant
916     6.0e+3
917     >>> Float('60e2', '')  # 4 digits significant
918     6000.
919     >>> Float('600e-2', '')  # 3 digits significant
920     6.00
921 
922     Notes
923     =====
924 
925     Floats are inexact by their nature unless their value is a binary-exact
926     value.
927 
928     >>> approx, exact = Float(.1, 1), Float(.125, 1)
929 
930     For calculation purposes, evalf needs to be able to change the precision
931     but this will not increase the accuracy of the inexact value. The
932     following is the most accurate 5-digit approximation of a value of 0.1
933     that had only 1 digit of precision:
934 
935     >>> approx.evalf(5)
936     0.099609
937 
938     By contrast, 0.125 is exact in binary (as it is in base 10) and so it
939     can be passed to Float or evalf to obtain an arbitrary precision with
940     matching accuracy:
941 
942     >>> Float(exact, 5)
943     0.12500
944     >>> exact.evalf(20)
945     0.12500000000000000000
946 
947     Trying to make a high-precision Float from a float is not disallowed,
948     but one must keep in mind that the *underlying float* (not the apparent
949     decimal value) is being obtained with high precision. For example, 0.3
950     does not have a finite binary representation. The closest rational is
951     the fraction 5404319552844595/2**54. So if you try to obtain a Float of
952     0.3 to 20 digits of precision you will not see the same thing as 0.3
953     followed by 19 zeros:
954 
955     >>> Float(0.3, 20)
956     0.29999999999999998890
957 
958     If you want a 20-digit value of the decimal 0.3 (not the floating point
959     approximation of 0.3) you should send the 0.3 as a string. The underlying
960     representation is still binary but a higher precision than Python's float
961     is used:
962 
963     >>> Float('0.3', 20)
964     0.30000000000000000000
965 
966     Although you can increase the precision of an existing Float using Float
967     it will not increase the accuracy -- the underlying value is not changed:
968 
969     >>> def show(f): # binary rep of Float
970     ...     from sympy import Mul, Pow
971     ...     s, m, e, b = f._mpf_
972     ...     v = Mul(int(m), Pow(2, int(e), evaluate=False), evaluate=False)
973     ...     print('%s at prec=%s' % (v, f._prec))
974     ...
975     >>> t = Float('0.3', 3)
976     >>> show(t)
977     4915/2**14 at prec=13
978     >>> show(Float(t, 20)) # higher prec, not higher accuracy
979     4915/2**14 at prec=70
980     >>> show(Float(t, 2)) # lower prec
981     307/2**10 at prec=10
982 
983     The same thing happens when evalf is used on a Float:
984 
985     >>> show(t.evalf(20))
986     4915/2**14 at prec=70
987     >>> show(t.evalf(2))
988     307/2**10 at prec=10
989 
990     Finally, Floats can be instantiated with an mpf tuple (n, c, p) to
991     produce the number (-1)**n*c*2**p:
992 
993     >>> n, c, p = 1, 5, 0
994     >>> (-1)**n*c*2**p
995     -5
996     >>> Float((1, 5, 0))
997     -5.00000000000000
998 
999     An actual mpf tuple also contains the number of bits in c as the last
1000     element of the tuple:
1001 
1002     >>> _._mpf_
1003     (1, 5, 0, 3)
1004 
1005     This is not needed for instantiation and is not the same thing as the
1006     precision. The mpf tuple and the precision are two separate quantities
1007     that Float tracks.
1008 
1009     In SymPy, a Float is a number that can be computed with arbitrary
1010     precision. Although floating point 'inf' and 'nan' are not such
1011     numbers, Float can create these numbers:
1012 
1013     >>> Float('-inf')
1014     -oo
1015     >>> _.is_Float
1016     False
1017     """
1018     __slots__ = ('_mpf_', '_prec')
1019 
1020     # A Float represents many real numbers,
1021     # both rational and irrational.
1022     is_rational = None
1023     is_irrational = None
1024     is_number = True
1025 
1026     is_real = True
1027     is_extended_real = True
1028 
1029     is_Float = True
1030 
1031     def __new__(cls, num, dps=None, prec=None, precision=None):
1032         if prec is not None:
1033             SymPyDeprecationWarning(
1034                             feature="Using 'prec=XX' to denote decimal precision",
1035                             useinstead="'dps=XX' for decimal precision and 'precision=XX' "\
1036                                               "for binary precision",
1037                             issue=12820,
1038                             deprecated_since_version="1.1").warn()
1039             dps = prec
1040         del prec  # avoid using this deprecated kwarg
1041 
1042         if dps is not None and precision is not None:
1043             raise ValueError('Both decimal and binary precision supplied. '
1044                              'Supply only one. ')
1045 
1046         if isinstance(num, str):
1047             # Float accepts spaces as digit separators
1048             num = num.replace(' ', '').lower()
1049             # in Py 3.6
1050             # underscores are allowed. In anticipation of that, we ignore
1051             # legally placed underscores
1052             if '_' in num:
1053                 parts = num.split('_')
1054                 if not (all(parts) and
1055                         all(parts[i][-1].isdigit()
1056                             for i in range(0, len(parts), 2)) and
1057                         all(parts[i][0].isdigit()
1058                             for i in range(1, len(parts), 2))):
1059                     # copy Py 3.6 error
1060                     raise ValueError("could not convert string to float: '%s'" % num)
1061                 num = ''.join(parts)
1062             if num.startswith('.') and len(num) > 1:
1063                 num = '0' + num
1064             elif num.startswith('-.') and len(num) > 2:
1065                 num = '-0.' + num[2:]
1066             elif num in ('inf', '+inf'):
1067                 return S.Infinity
1068             elif num == '-inf':
1069                 return S.NegativeInfinity
1070         elif isinstance(num, float) and num == 0:
1071             num = '0'
1072         elif isinstance(num, float) and num == float('inf'):
1073             return S.Infinity
1074         elif isinstance(num, float) and num == float('-inf'):
1075             return S.NegativeInfinity
1076         elif isinstance(num, float) and num == float('nan'):
1077             return S.NaN
1078         elif isinstance(num, (SYMPY_INTS, Integer)):
1079             num = str(num)
1080         elif num is S.Infinity:
1081             return num
1082         elif num is S.NegativeInfinity:
1083             return num
1084         elif num is S.NaN:
1085             return num
1086         elif _is_numpy_instance(num):  # support for numpy datatypes
1087             num = _convert_numpy_types(num)
1088         elif isinstance(num, mpmath.mpf):
1089             if precision is None:
1090                 if dps is None:
1091                     precision = num.context.prec
1092             num = num._mpf_
1093 
1094         if dps is None and precision is None:
1095             dps = 15
1096             if isinstance(num, Float):
1097                 return num
1098             if isinstance(num, str) and _literal_float(num):
1099                 try:
1100                     Num = decimal.Decimal(num)
1101                 except decimal.InvalidOperation:
1102                     pass
1103                 else:
1104                     isint = '.' not in num
1105                     num, dps = _decimal_to_Rational_prec(Num)
1106                     if num.is_Integer and isint:
1107                         dps = max(dps, len(str(num).lstrip('-')))
1108                     dps = max(15, dps)
1109                     precision = mlib.libmpf.dps_to_prec(dps)
1110         elif precision == '' and dps is None or precision is None and dps == '':
1111             if not isinstance(num, str):
1112                 raise ValueError('The null string can only be used when '
1113                 'the number to Float is passed as a string or an integer.')
1114             ok = None
1115             if _literal_float(num):
1116                 try:
1117                     Num = decimal.Decimal(num)
1118                 except decimal.InvalidOperation:
1119                     pass
1120                 else:
1121                     isint = '.' not in num
1122                     num, dps = _decimal_to_Rational_prec(Num)
1123                     if num.is_Integer and isint:
1124                         dps = max(dps, len(str(num).lstrip('-')))
1125                         precision = mlib.libmpf.dps_to_prec(dps)
1126                     ok = True
1127             if ok is None:
1128                 raise ValueError('string-float not recognized: %s' % num)
1129 
1130         # decimal precision(dps) is set and maybe binary precision(precision)
1131         # as well.From here on binary precision is used to compute the Float.
1132         # Hence, if supplied use binary precision else translate from decimal
1133         # precision.
1134 
1135         if precision is None or precision == '':
1136             precision = mlib.libmpf.dps_to_prec(dps)
1137 
1138         precision = int(precision)
1139 
1140         if isinstance(num, float):
1141             _mpf_ = mlib.from_float(num, precision, rnd)
1142         elif isinstance(num, str):
1143             _mpf_ = mlib.from_str(num, precision, rnd)
1144         elif isinstance(num, decimal.Decimal):
1145             if num.is_finite():
1146                 _mpf_ = mlib.from_str(str(num), precision, rnd)
1147             elif num.is_nan():
1148                 return S.NaN
1149             elif num.is_infinite():
1150                 if num > 0:
1151                     return S.Infinity
1152                 return S.NegativeInfinity
1153             else:
1154                 raise ValueError("unexpected decimal value %s" % str(num))
1155         elif isinstance(num, tuple) and len(num) in (3, 4):
1156             if type(num[1]) is str:
1157                 # it's a hexadecimal (coming from a pickled object)
1158                 # assume that it is in standard form
1159                 num = list(num)
1160                 # If we're loading an object pickled in Python 2 into
1161                 # Python 3, we may need to strip a tailing 'L' because
1162                 # of a shim for int on Python 3, see issue #13470.
1163                 if num[1].endswith('L'):
1164                     num[1] = num[1][:-1]
1165                 num[1] = MPZ(num[1], 16)
1166                 _mpf_ = tuple(num)
1167             else:
1168                 if len(num) == 4:
1169                     # handle normalization hack
1170                     return Float._new(num, precision)
1171                 else:
1172                     if not all((
1173                             num[0] in (0, 1),
1174                             num[1] >= 0,
1175                             all(type(i) in (int, int) for i in num)
1176                             )):
1177                         raise ValueError('malformed mpf: %s' % (num,))
1178                     # don't compute number or else it may
1179                     # over/underflow
1180                     return Float._new(
1181                         (num[0], num[1], num[2], bitcount(num[1])),
1182                         precision)
1183         else:
1184             try:
1185                 _mpf_ = num._as_mpf_val(precision)
1186             except (NotImplementedError, AttributeError):
1187                 _mpf_ = mpmath.mpf(num, prec=precision)._mpf_
1188 
1189         return cls._new(_mpf_, precision, zero=False)
1190 
1191     @classmethod
1192     def _new(cls, _mpf_, _prec, zero=True):
1193         # special cases
1194         if zero and _mpf_ == fzero:
1195             return S.Zero  # Float(0) -> 0.0; Float._new((0,0,0,0)) -> 0
1196         elif _mpf_ == _mpf_nan:
1197             return S.NaN
1198         elif _mpf_ == _mpf_inf:
1199             return S.Infinity
1200         elif _mpf_ == _mpf_ninf:
1201             return S.NegativeInfinity
1202 
1203         obj = Expr.__new__(cls)
1204         obj._mpf_ = mpf_norm(_mpf_, _prec)
1205         obj._prec = _prec
1206         return obj
1207 
1208     # mpz can't be pickled
1209     def __getnewargs_ex__(self):
1210         return ((mlib.to_pickable(self._mpf_),), {'precision': self._prec})
1211 
1212     def _hashable_content(self):
1213         return (self._mpf_, self._prec)
1214 
1215     def floor(self):
1216         return Integer(int(mlib.to_int(
1217             mlib.mpf_floor(self._mpf_, self._prec))))
1218 
1219     def ceiling(self):
1220         return Integer(int(mlib.to_int(
1221             mlib.mpf_ceil(self._mpf_, self._prec))))
1222 
1223     def __floor__(self):
1224         return self.floor()
1225 
1226     def __ceil__(self):
1227         return self.ceiling()
1228 
1229     @property
1230     def num(self):
1231         return mpmath.mpf(self._mpf_)
1232 
1233     def _as_mpf_val(self, prec):
1234         rv = mpf_norm(self._mpf_, prec)
1235         if rv != self._mpf_ and self._prec == prec:
1236             debug(self._mpf_, rv)
1237         return rv
1238 
1239     def _as_mpf_op(self, prec):
1240         return self._mpf_, max(prec, self._prec)
1241 
1242     def _eval_is_finite(self):
1243         if self._mpf_ in (_mpf_inf, _mpf_ninf):
1244             return False
1245         return True
1246 
1247     def _eval_is_infinite(self):
1248         if self._mpf_ in (_mpf_inf, _mpf_ninf):
1249             return True
1250         return False
1251 
1252     def _eval_is_integer(self):
1253         return self._mpf_ == fzero
1254 
1255     def _eval_is_negative(self):
1256         if self._mpf_ == _mpf_ninf or self._mpf_ == _mpf_inf:
1257             return False
1258         return self.num < 0
1259 
1260     def _eval_is_positive(self):
1261         if self._mpf_ == _mpf_ninf or self._mpf_ == _mpf_inf:
1262             return False
1263         return self.num > 0
1264 
1265     def _eval_is_extended_negative(self):
1266         if self._mpf_ == _mpf_ninf:
1267             return True
1268         if self._mpf_ == _mpf_inf:
1269             return False
1270         return self.num < 0
1271 
1272     def _eval_is_extended_positive(self):
1273         if self._mpf_ == _mpf_inf:
1274             return True
1275         if self._mpf_ == _mpf_ninf:
1276             return False
1277         return self.num > 0
1278 
1279     def _eval_is_zero(self):
1280         return self._mpf_ == fzero
1281 
1282     def __bool__(self):
1283         return self._mpf_ != fzero
1284 
1285     def __neg__(self):
1286         return Float._new(mlib.mpf_neg(self._mpf_), self._prec)
1287 
1288     @_sympifyit('other', NotImplemented)
1289     def __add__(self, other):
1290         if isinstance(other, Number) and global_parameters.evaluate:
1291             rhs, prec = other._as_mpf_op(self._prec)
1292             return Float._new(mlib.mpf_add(self._mpf_, rhs, prec, rnd), prec)
1293         return Number.__add__(self, other)
1294 
1295     @_sympifyit('other', NotImplemented)
1296     def __sub__(self, other):
1297         if isinstance(other, Number) and global_parameters.evaluate:
1298             rhs, prec = other._as_mpf_op(self._prec)
1299             return Float._new(mlib.mpf_sub(self._mpf_, rhs, prec, rnd), prec)
1300         return Number.__sub__(self, other)
1301 
1302     @_sympifyit('other', NotImplemented)
1303     def __mul__(self, other):
1304         if isinstance(other, Number) and global_parameters.evaluate:
1305             rhs, prec = other._as_mpf_op(self._prec)
1306             return Float._new(mlib.mpf_mul(self._mpf_, rhs, prec, rnd), prec)
1307         return Number.__mul__(self, other)
1308 
1309     @_sympifyit('other', NotImplemented)
1310     def __truediv__(self, other):
1311         if isinstance(other, Number) and other != 0 and global_parameters.evaluate:
1312             rhs, prec = other._as_mpf_op(self._prec)
1313             return Float._new(mlib.mpf_div(self._mpf_, rhs, prec, rnd), prec)
1314         return Number.__truediv__(self, other)
1315 
1316     @_sympifyit('other', NotImplemented)
1317     def __mod__(self, other):
1318         if isinstance(other, Rational) and other.q != 1 and global_parameters.evaluate:
1319             # calculate mod with Rationals, *then* round the result
1320             return Float(Rational.__mod__(Rational(self), other),
1321                          precision=self._prec)
1322         if isinstance(other, Float) and global_parameters.evaluate:
1323             r = self/other
1324             if r == int(r):
1325                 return Float(0, precision=max(self._prec, other._prec))
1326         if isinstance(other, Number) and global_parameters.evaluate:
1327             rhs, prec = other._as_mpf_op(self._prec)
1328             return Float._new(mlib.mpf_mod(self._mpf_, rhs, prec, rnd), prec)
1329         return Number.__mod__(self, other)
1330 
1331     @_sympifyit('other', NotImplemented)
1332     def __rmod__(self, other):
1333         if isinstance(other, Float) and global_parameters.evaluate:
1334             return other.__mod__(self)
1335         if isinstance(other, Number) and global_parameters.evaluate:
1336             rhs, prec = other._as_mpf_op(self._prec)
1337             return Float._new(mlib.mpf_mod(rhs, self._mpf_, prec, rnd), prec)
1338         return Number.__rmod__(self, other)
1339 
1340     def _eval_power(self, expt):
1341         """
1342         expt is symbolic object but not equal to 0, 1
1343 
1344         (-p)**r -> exp(r*log(-p)) -> exp(r*(log(p) + I*Pi)) ->
1345                   -> p**r*(sin(Pi*r) + cos(Pi*r)*I)
1346         """
1347         if self == 0:
1348             if expt.is_positive:
1349                 return S.Zero
1350             if expt.is_negative:
1351                 return S.Infinity
1352         if isinstance(expt, Number):
1353             if isinstance(expt, Integer):
1354                 prec = self._prec
1355                 return Float._new(
1356                     mlib.mpf_pow_int(self._mpf_, expt.p, prec, rnd), prec)
1357             elif isinstance(expt, Rational) and \
1358                     expt.p == 1 and expt.q % 2 and self.is_negative:
1359                 return Pow(S.NegativeOne, expt, evaluate=False)*(
1360                     -self)._eval_power(expt)
1361             expt, prec = expt._as_mpf_op(self._prec)
1362             mpfself = self._mpf_
1363             try:
1364                 y = mpf_pow(mpfself, expt, prec, rnd)
1365                 return Float._new(y, prec)
1366             except mlib.ComplexResult:
1367                 re, im = mlib.mpc_pow(
1368                     (mpfself, fzero), (expt, fzero), prec, rnd)
1369                 return Float._new(re, prec) + \
1370                     Float._new(im, prec)*S.ImaginaryUnit
1371 
1372     def __abs__(self):
1373         return Float._new(mlib.mpf_abs(self._mpf_), self._prec)
1374 
1375     def __int__(self):
1376         if self._mpf_ == fzero:
1377             return 0
1378         return int(mlib.to_int(self._mpf_))  # uses round_fast = round_down
1379 
1380     def __eq__(self, other):
1381         from sympy.logic.boolalg import Boolean
1382         try:
1383             other = _sympify(other)
1384         except SympifyError:
1385             return NotImplemented
1386         if isinstance(other, Boolean):
1387             return False
1388         if other.is_NumberSymbol:
1389             if other.is_irrational:
1390                 return False
1391             return other.__eq__(self)
1392         if other.is_Float:
1393             # comparison is exact
1394             # so Float(.1, 3) != Float(.1, 33)
1395             return self._mpf_ == other._mpf_
1396         if other.is_Rational:
1397             return other.__eq__(self)
1398         if other.is_Number:
1399             # numbers should compare at the same precision;
1400             # all _as_mpf_val routines should be sure to abide
1401             # by the request to change the prec if necessary; if
1402             # they don't, the equality test will fail since it compares
1403             # the mpf tuples
1404             ompf = other._as_mpf_val(self._prec)
1405             return bool(mlib.mpf_eq(self._mpf_, ompf))
1406         if not self:
1407             return not other
1408         return False    # Float != non-Number
1409 
1410     def __ne__(self, other):
1411         return not self == other
1412 
1413     def _Frel(self, other, op):
1414         from sympy.core.numbers import prec_to_dps
1415         try:
1416             other = _sympify(other)
1417         except SympifyError:
1418             return NotImplemented
1419         if other.is_Rational:
1420             # test self*other.q <?> other.p without losing precision
1421             '''
1422             >>> f = Float(.1,2)
1423             >>> i = 1234567890
1424             >>> (f*i)._mpf_
1425             (0, 471, 18, 9)
1426             >>> mlib.mpf_mul(f._mpf_, mlib.from_int(i))
1427             (0, 505555550955, -12, 39)
1428             '''
1429             smpf = mlib.mpf_mul(self._mpf_, mlib.from_int(other.q))
1430             ompf = mlib.from_int(other.p)
1431             return _sympify(bool(op(smpf, ompf)))
1432         elif other.is_Float:
1433             return _sympify(bool(
1434                         op(self._mpf_, other._mpf_)))
1435         elif other.is_comparable and other not in (
1436                 S.Infinity, S.NegativeInfinity):
1437             other = other.evalf(prec_to_dps(self._prec))
1438             if other._prec > 1:
1439                 if other.is_Number:
1440                     return _sympify(bool(
1441                         op(self._mpf_, other._as_mpf_val(self._prec))))
1442 
1443     def __gt__(self, other):
1444         if isinstance(other, NumberSymbol):
1445             return other.__lt__(self)
1446         rv = self._Frel(other, mlib.mpf_gt)
1447         if rv is None:
1448             return Expr.__gt__(self, other)
1449         return rv
1450 
1451     def __ge__(self, other):
1452         if isinstance(other, NumberSymbol):
1453             return other.__le__(self)
1454         rv = self._Frel(other, mlib.mpf_ge)
1455         if rv is None:
1456             return Expr.__ge__(self, other)
1457         return rv
1458 
1459     def __lt__(self, other):
1460         if isinstance(other, NumberSymbol):
1461             return other.__gt__(self)
1462         rv = self._Frel(other, mlib.mpf_lt)
1463         if rv is None:
1464             return Expr.__lt__(self, other)
1465         return rv
1466 
1467     def __le__(self, other):
1468         if isinstance(other, NumberSymbol):
1469             return other.__ge__(self)
1470         rv = self._Frel(other, mlib.mpf_le)
1471         if rv is None:
1472             return Expr.__le__(self, other)
1473         return rv
1474 
1475     def __hash__(self):
1476         return super().__hash__()
1477 
1478     def epsilon_eq(self, other, epsilon="1e-15"):
1479         return abs(self - other) < Float(epsilon)
1480 
1481     def _sage_(self):
1482         import sage.all as sage
1483         return sage.RealNumber(str(self))
1484 
1485     def __format__(self, format_spec):
1486         return format(decimal.Decimal(str(self)), format_spec)
1487 
1488 
1489 # Add sympify converters
1490 converter[float] = converter[decimal.Decimal] = Float
1491 
1492 # this is here to work nicely in Sage
1493 RealNumber = Float
1494 
1495 
1496 class Rational(Number):
1497     """Represents rational numbers (p/q) of any size.
1498 
1499     Examples
1500     ========
1501 
1502     >>> from sympy import Rational, nsimplify, S, pi
1503     >>> Rational(1, 2)
1504     1/2
1505 
1506     Rational is unprejudiced in accepting input. If a float is passed, the
1507     underlying value of the binary representation will be returned:
1508 
1509     >>> Rational(.5)
1510     1/2
1511     >>> Rational(.2)
1512     3602879701896397/18014398509481984
1513 
1514     If the simpler representation of the float is desired then consider
1515     limiting the denominator to the desired value or convert the float to
1516     a string (which is roughly equivalent to limiting the denominator to
1517     10**12):
1518 
1519     >>> Rational(str(.2))
1520     1/5
1521     >>> Rational(.2).limit_denominator(10**12)
1522     1/5
1523 
1524     An arbitrarily precise Rational is obtained when a string literal is
1525     passed:
1526 
1527     >>> Rational("1.23")
1528     123/100
1529     >>> Rational('1e-2')
1530     1/100
1531     >>> Rational(".1")
1532     1/10
1533     >>> Rational('1e-2/3.2')
1534     1/320
1535 
1536     The conversion of other types of strings can be handled by
1537     the sympify() function, and conversion of floats to expressions
1538     or simple fractions can be handled with nsimplify:
1539 
1540     >>> S('.[3]')  # repeating digits in brackets
1541     1/3
1542     >>> S('3**2/10')  # general expressions
1543     9/10
1544     >>> nsimplify(.3)  # numbers that have a simple form
1545     3/10
1546 
1547     But if the input does not reduce to a literal Rational, an error will
1548     be raised:
1549 
1550     >>> Rational(pi)
1551     Traceback (most recent call last):
1552     ...
1553     TypeError: invalid input: pi
1554 
1555 
1556     Low-level
1557     ---------
1558 
1559     Access numerator and denominator as .p and .q:
1560 
1561     >>> r = Rational(3, 4)
1562     >>> r
1563     3/4
1564     >>> r.p
1565     3
1566     >>> r.q
1567     4
1568 
1569     Note that p and q return integers (not SymPy Integers) so some care
1570     is needed when using them in expressions:
1571 
1572     >>> r.p/r.q
1573     0.75
1574 
1575     See Also
1576     ========
1577     sympy.core.sympify.sympify, sympy.simplify.simplify.nsimplify
1578     """
1579     is_real = True
1580     is_integer = False
1581     is_rational = True
1582     is_number = True
1583 
1584     __slots__ = ('p', 'q')
1585 
1586     is_Rational = True
1587 
1588     @cacheit
1589     def __new__(cls, p, q=None, gcd=None):
1590         if q is None:
1591             if isinstance(p, Rational):
1592                 return p
1593 
1594             if isinstance(p, SYMPY_INTS):
1595                 pass
1596             else:
1597                 if isinstance(p, (float, Float)):
1598                     return Rational(*_as_integer_ratio(p))
1599 
1600                 if not isinstance(p, str):
1601                     try:
1602                         p = sympify(p)
1603                     except (SympifyError, SyntaxError):
1604                         pass  # error will raise below
1605                 else:
1606                     if p.count('/') > 1:
1607                         raise TypeError('invalid input: %s' % p)
1608                     p = p.replace(' ', '')
1609                     pq = p.rsplit('/', 1)
1610                     if len(pq) == 2:
1611                         p, q = pq
1612                         fp = fractions.Fraction(p)
1613                         fq = fractions.Fraction(q)
1614                         p = fp/fq
1615                     try:
1616                         p = fractions.Fraction(p)
1617                     except ValueError:
1618                         pass  # error will raise below
1619                     else:
1620                         return Rational(p.numerator, p.denominator, 1)
1621 
1622                 if not isinstance(p, Rational):
1623                     raise TypeError('invalid input: %s' % p)
1624 
1625             q = 1
1626             gcd = 1
1627         else:
1628             p = Rational(p)
1629             q = Rational(q)
1630 
1631         if isinstance(q, Rational):
1632             p *= q.q
1633             q = q.p
1634         if isinstance(p, Rational):
1635             q *= p.q
1636             p = p.p
1637 
1638         # p and q are now integers
1639         if q == 0:
1640             if p == 0:
1641                 if _errdict["divide"]:
1642                     raise ValueError("Indeterminate 0/0")
1643                 else:
1644                     return S.NaN
1645             return S.ComplexInfinity
1646         if q < 0:
1647             q = -q
1648             p = -p
1649         if not gcd:
1650             gcd = igcd(abs(p), q)
1651         if gcd > 1:
1652             p //= gcd
1653             q //= gcd
1654         if q == 1:
1655             return Integer(p)
1656         if p == 1 and q == 2:
1657             return S.Half
1658         obj = Expr.__new__(cls)
1659         obj.p = p
1660         obj.q = q
1661         return obj
1662 
1663     def limit_denominator(self, max_denominator=1000000):
1664         """Closest Rational to self with denominator at most max_denominator.
1665 
1666         Examples
1667         ========
1668 
1669         >>> from sympy import Rational
1670         >>> Rational('3.141592653589793').limit_denominator(10)
1671         22/7
1672         >>> Rational('3.141592653589793').limit_denominator(100)
1673         311/99
1674 
1675         """
1676         f = fractions.Fraction(self.p, self.q)
1677         return Rational(f.limit_denominator(fractions.Fraction(int(max_denominator))))
1678 
1679     def __getnewargs__(self):
1680         return (self.p, self.q)
1681 
1682     def _hashable_content(self):
1683         return (self.p, self.q)
1684 
1685     def _eval_is_positive(self):
1686         return self.p > 0
1687 
1688     def _eval_is_zero(self):
1689         return self.p == 0
1690 
1691     def __neg__(self):
1692         return Rational(-self.p, self.q)
1693 
1694     @_sympifyit('other', NotImplemented)
1695     def __add__(self, other):
1696         if global_parameters.evaluate:
1697             if isinstance(other, Integer):
1698                 return Rational(self.p + self.q*other.p, self.q, 1)
1699             elif isinstance(other, Rational):
1700                 #TODO: this can probably be optimized more
1701                 return Rational(self.p*other.q + self.q*other.p, self.q*other.q)
1702             elif isinstance(other, Float):
1703                 return other + self
1704             else:
1705                 return Number.__add__(self, other)
1706         return Number.__add__(self, other)
1707     __radd__ = __add__
1708 
1709     @_sympifyit('other', NotImplemented)
1710     def __sub__(self, other):
1711         if global_parameters.evaluate:
1712             if isinstance(other, Integer):
1713                 return Rational(self.p - self.q*other.p, self.q, 1)
1714             elif isinstance(other, Rational):
1715                 return Rational(self.p*other.q - self.q*other.p, self.q*other.q)
1716             elif isinstance(other, Float):
1717                 return -other + self
1718             else:
1719                 return Number.__sub__(self, other)
1720         return Number.__sub__(self, other)
1721     @_sympifyit('other', NotImplemented)
1722     def __rsub__(self, other):
1723         if global_parameters.evaluate:
1724             if isinstance(other, Integer):
1725                 return Rational(self.q*other.p - self.p, self.q, 1)
1726             elif isinstance(other, Rational):
1727                 return Rational(self.q*other.p - self.p*other.q, self.q*other.q)
1728             elif isinstance(other, Float):
1729                 return -self + other
1730             else:
1731                 return Number.__rsub__(self, other)
1732         return Number.__rsub__(self, other)
1733     @_sympifyit('other', NotImplemented)
1734     def __mul__(self, other):
1735         if global_parameters.evaluate:
1736             if isinstance(other, Integer):
1737                 return Rational(self.p*other.p, self.q, igcd(other.p, self.q))
1738             elif isinstance(other, Rational):
1739                 return Rational(self.p*other.p, self.q*other.q, igcd(self.p, other.q)*igcd(self.q, other.p))
1740             elif isinstance(other, Float):
1741                 return other*self
1742             else:
1743                 return Number.__mul__(self, other)
1744         return Number.__mul__(self, other)
1745     __rmul__ = __mul__
1746 
1747     @_sympifyit('other', NotImplemented)
1748     def __truediv__(self, other):
1749         if global_parameters.evaluate:
1750             if isinstance(other, Integer):
1751                 if self.p and other.p == S.Zero:
1752                     return S.ComplexInfinity
1753                 else:
1754                     return Rational(self.p, self.q*other.p, igcd(self.p, other.p))
1755             elif isinstance(other, Rational):
1756                 return Rational(self.p*other.q, self.q*other.p, igcd(self.p, other.p)*igcd(self.q, other.q))
1757             elif isinstance(other, Float):
1758                 return self*(1/other)
1759             else:
1760                 return Number.__truediv__(self, other)
1761         return Number.__truediv__(self, other)
1762     @_sympifyit('other', NotImplemented)
1763     def __rtruediv__(self, other):
1764         if global_parameters.evaluate:
1765             if isinstance(other, Integer):
1766                 return Rational(other.p*self.q, self.p, igcd(self.p, other.p))
1767             elif isinstance(other, Rational):
1768                 return Rational(other.p*self.q, other.q*self.p, igcd(self.p, other.p)*igcd(self.q, other.q))
1769             elif isinstance(other, Float):
1770                 return other*(1/self)
1771             else:
1772                 return Number.__rtruediv__(self, other)
1773         return Number.__rtruediv__(self, other)
1774 
1775     @_sympifyit('other', NotImplemented)
1776     def __mod__(self, other):
1777         if global_parameters.evaluate:
1778             if isinstance(other, Rational):
1779                 n = (self.p*other.q) // (other.p*self.q)
1780                 return Rational(self.p*other.q - n*other.p*self.q, self.q*other.q)
1781             if isinstance(other, Float):
1782                 # calculate mod with Rationals, *then* round the answer
1783                 return Float(self.__mod__(Rational(other)),
1784                              precision=other._prec)
1785             return Number.__mod__(self, other)
1786         return Number.__mod__(self, other)
1787 
1788     @_sympifyit('other', NotImplemented)
1789     def __rmod__(self, other):
1790         if isinstance(other, Rational):
1791             return Rational.__mod__(other, self)
1792         return Number.__rmod__(self, other)
1793 
1794     def _eval_power(self, expt):
1795         if isinstance(expt, Number):
1796             if isinstance(expt, Float):
1797                 return self._eval_evalf(expt._prec)**expt
1798             if expt.is_extended_negative:
1799                 # (3/4)**-2 -> (4/3)**2
1800                 ne = -expt
1801                 if (ne is S.One):
1802                     return Rational(self.q, self.p)
1803                 if self.is_negative:
1804                     return S.NegativeOne**expt*Rational(self.q, -self.p)**ne
1805                 else:
1806                     return Rational(self.q, self.p)**ne
1807             if expt is S.Infinity:  # -oo already caught by test for negative
1808                 if self.p > self.q:
1809                     # (3/2)**oo -> oo
1810                     return S.Infinity
1811                 if self.p < -self.q:
1812                     # (-3/2)**oo -> oo + I*oo
1813                     return S.Infinity + S.Infinity*S.ImaginaryUnit
1814                 return S.Zero
1815             if isinstance(expt, Integer):
1816                 # (4/3)**2 -> 4**2 / 3**2
1817                 return Rational(self.p**expt.p, self.q**expt.p, 1)
1818             if isinstance(expt, Rational):
1819                 if self.p != 1:
1820                     # (4/3)**(5/6) -> 4**(5/6)*3**(-5/6)
1821                     return Integer(self.p)**expt*Integer(self.q)**(-expt)
1822                 # as the above caught negative self.p, now self is positive
1823                 return Integer(self.q)**Rational(
1824                 expt.p*(expt.q - 1), expt.q) / \
1825                     Integer(self.q)**Integer(expt.p)
1826 
1827         if self.is_extended_negative and expt.is_even:
1828             return (-self)**expt
1829 
1830         return
1831 
1832     def _as_mpf_val(self, prec):
1833         return mlib.from_rational(self.p, self.q, prec, rnd)
1834 
1835     def _mpmath_(self, prec, rnd):
1836         return mpmath.make_mpf(mlib.from_rational(self.p, self.q, prec, rnd))
1837 
1838     def __abs__(self):
1839         return Rational(abs(self.p), self.q)
1840 
1841     def __int__(self):
1842         p, q = self.p, self.q
1843         if p < 0:
1844             return -int(-p//q)
1845         return int(p//q)
1846 
1847     def floor(self):
1848         return Integer(self.p // self.q)
1849 
1850     def ceiling(self):
1851         return -Integer(-self.p // self.q)
1852 
1853     def __floor__(self):
1854         return self.floor()
1855 
1856     def __ceil__(self):
1857         return self.ceiling()
1858 
1859     def __eq__(self, other):
1860         from sympy.core.power import integer_log
1861         try:
1862             other = _sympify(other)
1863         except SympifyError:
1864             return NotImplemented
1865         if not isinstance(other, Number):
1866             # S(0) == S.false is False
1867             # S(0) == False is True
1868             return False
1869         if not self:
1870             return not other
1871         if other.is_NumberSymbol:
1872             if other.is_irrational:
1873                 return False
1874             return other.__eq__(self)
1875         if other.is_Rational:
1876             # a Rational is always in reduced form so will never be 2/4
1877             # so we can just check equivalence of args
1878             return self.p == other.p and self.q == other.q
1879         if other.is_Float:
1880             # all Floats have a denominator that is a power of 2
1881             # so if self doesn't, it can't be equal to other
1882             if self.q & (self.q - 1):
1883                 return False
1884             s, m, t = other._mpf_[:3]
1885             if s:
1886                 m = -m
1887             if not t:
1888                 # other is an odd integer
1889                 if not self.is_Integer or self.is_even:
1890                     return False
1891                 return m == self.p
1892             if t > 0:
1893                 # other is an even integer
1894                 if not self.is_Integer:
1895                     return False
1896                 # does m*2**t == self.p
1897                 return self.p and not self.p % m and \
1898                     integer_log(self.p//m, 2) == (t, True)
1899             # does non-integer s*m/2**-t = p/q?
1900             if self.is_Integer:
1901                 return False
1902             return m == self.p and integer_log(self.q, 2) == (-t, True)
1903         return False
1904 
1905     def __ne__(self, other):
1906         return not self == other
1907 
1908     def _Rrel(self, other, attr):
1909         # if you want self < other, pass self, other, __gt__
1910         try:
1911             other = _sympify(other)
1912         except SympifyError:
1913             return NotImplemented
1914         if other.is_Number:
1915             op = None
1916             s, o = self, other
1917             if other.is_NumberSymbol:
1918                 op = getattr(o, attr)
1919             elif other.is_Float:
1920                 op = getattr(o, attr)
1921             elif other.is_Rational:
1922                 s, o = Integer(s.p*o.q), Integer(s.q*o.p)
1923                 op = getattr(o, attr)
1924             if op:
1925                 return op(s)
1926             if o.is_number and o.is_extended_real:
1927                 return Integer(s.p), s.q*o
1928 
1929     def __gt__(self, other):
1930         rv = self._Rrel(other, '__lt__')
1931         if rv is None:
1932             rv = self, other
1933         elif not type(rv) is tuple:
1934             return rv
1935         return Expr.__gt__(*rv)
1936 
1937     def __ge__(self, other):
1938         rv = self._Rrel(other, '__le__')
1939         if rv is None:
1940             rv = self, other
1941         elif not type(rv) is tuple:
1942             return rv
1943         return Expr.__ge__(*rv)
1944 
1945     def __lt__(self, other):
1946         rv = self._Rrel(other, '__gt__')
1947         if rv is None:
1948             rv = self, other
1949         elif not type(rv) is tuple:
1950             return rv
1951         return Expr.__lt__(*rv)
1952 
1953     def __le__(self, other):
1954         rv = self._Rrel(other, '__ge__')
1955         if rv is None:
1956             rv = self, other
1957         elif not type(rv) is tuple:
1958             return rv
1959         return Expr.__le__(*rv)
1960 
1961     def __hash__(self):
1962         return super().__hash__()
1963 
1964     def factors(self, limit=None, use_trial=True, use_rho=False,
1965                 use_pm1=False, verbose=False, visual=False):
1966         """A wrapper to factorint which return factors of self that are
1967         smaller than limit (or cheap to compute). Special methods of
1968         factoring are disabled by default so that only trial division is used.
1969         """
1970         from sympy.ntheory import factorrat
1971 
1972         return factorrat(self, limit=limit, use_trial=use_trial,
1973                       use_rho=use_rho, use_pm1=use_pm1,
1974                       verbose=verbose).copy()
1975 
1976     @property
1977     def numerator(self):
1978         return self.p
1979 
1980     @property
1981     def denominator(self):
1982         return self.q
1983 
1984     @_sympifyit('other', NotImplemented)
1985     def gcd(self, other):
1986         if isinstance(other, Rational):
1987             if other == S.Zero:
1988                 return other
1989             return Rational(
1990                 Integer(igcd(self.p, other.p)),
1991                 Integer(ilcm(self.q, other.q)))
1992         return Number.gcd(self, other)
1993 
1994     @_sympifyit('other', NotImplemented)
1995     def lcm(self, other):
1996         if isinstance(other, Rational):
1997             return Rational(
1998                 self.p // igcd(self.p, other.p) * other.p,
1999                 igcd(self.q, other.q))
2000         return Number.lcm(self, other)
2001 
2002     def as_numer_denom(self):
2003         return Integer(self.p), Integer(self.q)
2004 
2005     def _sage_(self):
2006         import sage.all as sage
2007         return sage.Integer(self.p)/sage.Integer(self.q)
2008 
2009     def as_content_primitive(self, radical=False, clear=True):
2010         """Return the tuple (R, self/R) where R is the positive Rational
2011         extracted from self.
2012 
2013         Examples
2014         ========
2015 
2016         >>> from sympy import S
2017         >>> (S(-3)/2).as_content_primitive()
2018         (3/2, -1)
2019 
2020         See docstring of Expr.as_content_primitive for more examples.
2021         """
2022 
2023         if self:
2024             if self.is_positive:
2025                 return self, S.One
2026             return -self, S.NegativeOne
2027         return S.One, self
2028 
2029     def as_coeff_Mul(self, rational=False):
2030         """Efficiently extract the coefficient of a product. """
2031         return self, S.One
2032 
2033     def as_coeff_Add(self, rational=False):
2034         """Efficiently extract the coefficient of a summation. """
2035         return self, S.Zero
2036 
2037 
2038 class Integer(Rational):
2039     """Represents integer numbers of any size.
2040 
2041     Examples
2042     ========
2043 
2044     >>> from sympy import Integer
2045     >>> Integer(3)
2046     3
2047 
2048     If a float or a rational is passed to Integer, the fractional part
2049     will be discarded; the effect is of rounding toward zero.
2050 
2051     >>> Integer(3.8)
2052     3
2053     >>> Integer(-3.8)
2054     -3
2055 
2056     A string is acceptable input if it can be parsed as an integer:
2057 
2058     >>> Integer("9" * 20)
2059     99999999999999999999
2060 
2061     It is rarely needed to explicitly instantiate an Integer, because
2062     Python integers are automatically converted to Integer when they
2063     are used in SymPy expressions.
2064     """
2065     q = 1
2066     is_integer = True
2067     is_number = True
2068 
2069     is_Integer = True
2070 
2071     __slots__ = ('p',)
2072 
2073     def _as_mpf_val(self, prec):
2074         return mlib.from_int(self.p, prec, rnd)
2075 
2076     def _mpmath_(self, prec, rnd):
2077         return mpmath.make_mpf(self._as_mpf_val(prec))
2078 
2079     @cacheit
2080     def __new__(cls, i):
2081         if isinstance(i, str):
2082             i = i.replace(' ', '')
2083         # whereas we cannot, in general, make a Rational from an
2084         # arbitrary expression, we can make an Integer unambiguously
2085         # (except when a non-integer expression happens to round to
2086         # an integer). So we proceed by taking int() of the input and
2087         # let the int routines determine whether the expression can
2088         # be made into an int or whether an error should be raised.
2089         try:
2090             ival = int(i)
2091         except TypeError:
2092             raise TypeError(
2093                 "Argument of Integer should be of numeric type, got %s." % i)
2094         # We only work with well-behaved integer types. This converts, for
2095         # example, numpy.int32 instances.
2096         if ival == 1:
2097             return S.One
2098         if ival == -1:
2099             return S.NegativeOne
2100         if ival == 0:
2101             return S.Zero
2102         obj = Expr.__new__(cls)
2103         obj.p = ival
2104         return obj
2105 
2106     def __getnewargs__(self):
2107         return (self.p,)
2108 
2109     # Arithmetic operations are here for efficiency
2110     def __int__(self):
2111         return self.p
2112 
2113     def floor(self):
2114         return Integer(self.p)
2115 
2116     def ceiling(self):
2117         return Integer(self.p)
2118 
2119     def __floor__(self):
2120         return self.floor()
2121 
2122     def __ceil__(self):
2123         return self.ceiling()
2124 
2125     def __neg__(self):
2126         return Integer(-self.p)
2127 
2128     def __abs__(self):
2129         if self.p >= 0:
2130             return self
2131         else:
2132             return Integer(-self.p)
2133 
2134     def __divmod__(self, other):
2135         from .containers import Tuple
2136         if isinstance(other, Integer) and global_parameters.evaluate:
2137             return Tuple(*(divmod(self.p, other.p)))
2138         else:
2139             return Number.__divmod__(self, other)
2140 
2141     def __rdivmod__(self, other):
2142         from .containers import Tuple
2143         if isinstance(other, int) and global_parameters.evaluate:
2144             return Tuple(*(divmod(other, self.p)))
2145         else:
2146             try:
2147                 other = Number(other)
2148             except TypeError:
2149                 msg = "unsupported operand type(s) for divmod(): '%s' and '%s'"
2150                 oname = type(other).__name__
2151                 sname = type(self).__name__
2152                 raise TypeError(msg % (oname, sname))
2153             return Number.__divmod__(other, self)
2154 
2155     # TODO make it decorator + bytecodehacks?
2156     def __add__(self, other):
2157         if global_parameters.evaluate:
2158             if isinstance(other, int):
2159                 return Integer(self.p + other)
2160             elif isinstance(other, Integer):
2161                 return Integer(self.p + other.p)
2162             elif isinstance(other, Rational):
2163                 return Rational(self.p*other.q + other.p, other.q, 1)
2164             return Rational.__add__(self, other)
2165         else:
2166             return Add(self, other)
2167 
2168     def __radd__(self, other):
2169         if global_parameters.evaluate:
2170             if isinstance(other, int):
2171                 return Integer(other + self.p)
2172             elif isinstance(other, Rational):
2173                 return Rational(other.p + self.p*other.q, other.q, 1)
2174             return Rational.__radd__(self, other)
2175         return Rational.__radd__(self, other)
2176 
2177     def __sub__(self, other):
2178         if global_parameters.evaluate:
2179             if isinstance(other, int):
2180                 return Integer(self.p - other)
2181             elif isinstance(other, Integer):
2182                 return Integer(self.p - other.p)
2183             elif isinstance(other, Rational):
2184                 return Rational(self.p*other.q - other.p, other.q, 1)
2185             return Rational.__sub__(self, other)
2186         return Rational.__sub__(self, other)
2187 
2188     def __rsub__(self, other):
2189         if global_parameters.evaluate:
2190             if isinstance(other, int):
2191                 return Integer(other - self.p)
2192             elif isinstance(other, Rational):
2193                 return Rational(other.p - self.p*other.q, other.q, 1)
2194             return Rational.__rsub__(self, other)
2195         return Rational.__rsub__(self, other)
2196 
2197     def __mul__(self, other):
2198         if global_parameters.evaluate:
2199             if isinstance(other, int):
2200                 return Integer(self.p*other)
2201             elif isinstance(other, Integer):
2202                 return Integer(self.p*other.p)
2203             elif isinstance(other, Rational):
2204                 return Rational(self.p*other.p, other.q, igcd(self.p, other.q))
2205             return Rational.__mul__(self, other)
2206         return Rational.__mul__(self, other)
2207 
2208     def __rmul__(self, other):
2209         if global_parameters.evaluate:
2210             if isinstance(other, int):
2211                 return Integer(other*self.p)
2212             elif isinstance(other, Rational):
2213                 return Rational(other.p*self.p, other.q, igcd(self.p, other.q))
2214             return Rational.__rmul__(self, other)
2215         return Rational.__rmul__(self, other)
2216 
2217     def __mod__(self, other):
2218         if global_parameters.evaluate:
2219             if isinstance(other, int):
2220                 return Integer(self.p % other)
2221             elif isinstance(other, Integer):
2222                 return Integer(self.p % other.p)
2223             return Rational.__mod__(self, other)
2224         return Rational.__mod__(self, other)
2225 
2226     def __rmod__(self, other):
2227         if global_parameters.evaluate:
2228             if isinstance(other, int):
2229                 return Integer(other % self.p)
2230             elif isinstance(other, Integer):
2231                 return Integer(other.p % self.p)
2232             return Rational.__rmod__(self, other)
2233         return Rational.__rmod__(self, other)
2234 
2235     def __eq__(self, other):
2236         if isinstance(other, int):
2237             return (self.p == other)
2238         elif isinstance(other, Integer):
2239             return (self.p == other.p)
2240         return Rational.__eq__(self, other)
2241 
2242     def __ne__(self, other):
2243         return not self == other
2244 
2245     def __gt__(self, other):
2246         try:
2247             other = _sympify(other)
2248         except SympifyError:
2249             return NotImplemented
2250         if other.is_Integer:
2251             return _sympify(self.p > other.p)
2252         return Rational.__gt__(self, other)
2253 
2254     def __lt__(self, other):
2255         try:
2256             other = _sympify(other)
2257         except SympifyError:
2258             return NotImplemented
2259         if other.is_Integer:
2260             return _sympify(self.p < other.p)
2261         return Rational.__lt__(self, other)
2262 
2263     def __ge__(self, other):
2264         try:
2265             other = _sympify(other)
2266         except SympifyError:
2267             return NotImplemented
2268         if other.is_Integer:
2269             return _sympify(self.p >= other.p)
2270         return Rational.__ge__(self, other)
2271 
2272     def __le__(self, other):
2273         try:
2274             other = _sympify(other)
2275         except SympifyError:
2276             return NotImplemented
2277         if other.is_Integer:
2278             return _sympify(self.p <= other.p)
2279         return Rational.__le__(self, other)
2280 
2281     def __hash__(self):
2282         return hash(self.p)
2283 
2284     def __index__(self):
2285         return self.p
2286 
2287     ########################################
2288 
2289     def _eval_is_odd(self):
2290         return bool(self.p % 2)
2291 
2292     def _eval_power(self, expt):
2293         """
2294         Tries to do some simplifications on self**expt
2295 
2296         Returns None if no further simplifications can be done.
2297 
2298         Explanation
2299         ===========
2300 
2301         When exponent is a fraction (so we have for example a square root),
2302         we try to find a simpler representation by factoring the argument
2303         up to factors of 2**15, e.g.
2304 
2305           - sqrt(4) becomes 2
2306           - sqrt(-4) becomes 2*I
2307           - (2**(3+7)*3**(6+7))**Rational(1,7) becomes 6*18**(3/7)
2308 
2309         Further simplification would require a special call to factorint on
2310         the argument which is not done here for sake of speed.
2311 
2312         """
2313         from sympy.ntheory.factor_ import perfect_power
2314 
2315         if expt is S.Infinity:
2316             if self.p > S.One:
2317                 return S.Infinity
2318             # cases -1, 0, 1 are done in their respective classes
2319             return S.Infinity + S.ImaginaryUnit*S.Infinity
2320         if expt is S.NegativeInfinity:
2321             return Rational(1, self)**S.Infinity
2322         if not isinstance(expt, Number):
2323             # simplify when expt is even
2324             # (-2)**k --> 2**k
2325             if self.is_negative and expt.is_even:
2326                 return (-self)**expt
2327         if isinstance(expt, Float):
2328             # Rational knows how to exponentiate by a Float
2329             return super()._eval_power(expt)
2330         if not isinstance(expt, Rational):
2331             return
2332         if expt is S.Half and self.is_negative:
2333             # we extract I for this special case since everyone is doing so
2334             return S.ImaginaryUnit*Pow(-self, expt)
2335         if expt.is_negative:
2336             # invert base and change sign on exponent
2337             ne = -expt
2338             if self.is_negative:
2339                     return S.NegativeOne**expt*Rational(1, -self)**ne
2340             else:
2341                 return Rational(1, self.p)**ne
2342         # see if base is a perfect root, sqrt(4) --> 2
2343         x, xexact = integer_nthroot(abs(self.p), expt.q)
2344         if xexact:
2345             # if it's a perfect root we've finished
2346             result = Integer(x**abs(expt.p))
2347             if self.is_negative:
2348                 result *= S.NegativeOne**expt
2349             return result
2350 
2351         # The following is an algorithm where we collect perfect roots
2352         # from the factors of base.
2353 
2354         # if it's not an nth root, it still might be a perfect power
2355         b_pos = int(abs(self.p))
2356         p = perfect_power(b_pos)
2357         if p is not False:
2358             dict = {p[0]: p[1]}
2359         else:
2360             dict = Integer(b_pos).factors(limit=2**15)
2361 
2362         # now process the dict of factors
2363         out_int = 1  # integer part
2364         out_rad = 1  # extracted radicals
2365         sqr_int = 1
2366         sqr_gcd = 0
2367         sqr_dict = {}
2368         for prime, exponent in dict.items():
2369             exponent *= expt.p
2370             # remove multiples of expt.q: (2**12)**(1/10) -> 2*(2**2)**(1/10)
2371             div_e, div_m = divmod(exponent, expt.q)
2372             if div_e > 0:
2373                 out_int *= prime**div_e
2374             if div_m > 0:
2375                 # see if the reduced exponent shares a gcd with e.q
2376                 # (2**2)**(1/10) -> 2**(1/5)
2377                 g = igcd(div_m, expt.q)
2378                 if g != 1:
2379                     out_rad *= Pow(prime, Rational(div_m//g, expt.q//g))
2380                 else:
2381                     sqr_dict[prime] = div_m
2382         # identify gcd of remaining powers
2383         for p, ex in sqr_dict.items():
2384             if sqr_gcd == 0:
2385                 sqr_gcd = ex
2386             else:
2387                 sqr_gcd = igcd(sqr_gcd, ex)
2388                 if sqr_gcd == 1:
2389                     break
2390         for k, v in sqr_dict.items():
2391             sqr_int *= k**(v//sqr_gcd)
2392         if sqr_int == b_pos and out_int == 1 and out_rad == 1:
2393             result = None
2394         else:
2395             result = out_int*out_rad*Pow(sqr_int, Rational(sqr_gcd, expt.q))
2396             if self.is_negative:
2397                 result *= Pow(S.NegativeOne, expt)
2398         return result
2399 
2400     def _eval_is_prime(self):
2401         from sympy.ntheory import isprime
2402 
2403         return isprime(self)
2404 
2405     def _eval_is_composite(self):
2406         if self > 1:
2407             return fuzzy_not(self.is_prime)
2408         else:
2409             return False
2410 
2411     def as_numer_denom(self):
2412         return self, S.One
2413 
2414     @_sympifyit('other', NotImplemented)
2415     def __floordiv__(self, other):
2416         if not isinstance(other, Expr):
2417             return NotImplemented
2418         if isinstance(other, Integer):
2419             return Integer(self.p // other)
2420         return Integer(divmod(self, other)[0])
2421 
2422     def __rfloordiv__(self, other):
2423         return Integer(Integer(other).p // self.p)
2424 
2425 # Add sympify converters
2426 converter[int] = Integer
2427 
2428 
2429 class AlgebraicNumber(Expr):
2430     """Class for representing algebraic numbers in SymPy. """
2431 
2432     __slots__ = ('rep', 'root', 'alias', 'minpoly')
2433 
2434     is_AlgebraicNumber = True
2435     is_algebraic = True
2436     is_number = True
2437 
2438 
2439     kind = NumberKind
2440 
2441     # Optional alias symbol is not free.
2442     # Actually, alias should be a Str, but some methods
2443     # expect that it be an instance of Expr.
2444     free_symbols = set()
2445 
2446     def __new__(cls, expr, coeffs=None, alias=None, **args):
2447         """Construct a new algebraic number. """
2448         from sympy import Poly
2449         from sympy.polys.polyclasses import ANP, DMP
2450         from sympy.polys.numberfields import minimal_polynomial
2451         from sympy.core.symbol import Symbol
2452 
2453         expr = sympify(expr)
2454 
2455         if isinstance(expr, (tuple, Tuple)):
2456             minpoly, root = expr
2457 
2458             if not minpoly.is_Poly:
2459                 minpoly = Poly(minpoly)
2460         elif expr.is_AlgebraicNumber:
2461             minpoly, root = expr.minpoly, expr.root
2462         else:
2463             minpoly, root = minimal_polynomial(
2464                 expr, args.get('gen'), polys=True), expr
2465 
2466         dom = minpoly.get_domain()
2467 
2468         if coeffs is not None:
2469             if not isinstance(coeffs, ANP):
2470                 rep = DMP.from_sympy_list(sympify(coeffs), 0, dom)
2471                 scoeffs = Tuple(*coeffs)
2472             else:
2473                 rep = DMP.from_list(coeffs.to_list(), 0, dom)
2474                 scoeffs = Tuple(*coeffs.to_list())
2475 
2476             if rep.degree() >= minpoly.degree():
2477                 rep = rep.rem(minpoly.rep)
2478 
2479         else:
2480             rep = DMP.from_list([1, 0], 0, dom)
2481             scoeffs = Tuple(1, 0)
2482 
2483         sargs = (root, scoeffs)
2484 
2485         if alias is not None:
2486             if not isinstance(alias, Symbol):
2487                 alias = Symbol(alias)
2488             sargs = sargs + (alias,)
2489 
2490         obj = Expr.__new__(cls, *sargs)
2491 
2492         obj.rep = rep
2493         obj.root = root
2494         obj.alias = alias
2495         obj.minpoly = minpoly
2496 
2497         return obj
2498 
2499     def __hash__(self):
2500         return super().__hash__()
2501 
2502     def _eval_evalf(self, prec):
2503         return self.as_expr()._evalf(prec)
2504 
2505     @property
2506     def is_aliased(self):
2507         """Returns ``True`` if ``alias`` was set. """
2508         return self.alias is not None
2509 
2510     def as_poly(self, x=None):
2511         """Create a Poly instance from ``self``. """
2512         from sympy import Dummy, Poly, PurePoly
2513         if x is not None:
2514             return Poly.new(self.rep, x)
2515         else:
2516             if self.alias is not None:
2517                 return Poly.new(self.rep, self.alias)
2518             else:
2519                 return PurePoly.new(self.rep, Dummy('x'))
2520 
2521     def as_expr(self, x=None):
2522         """Create a Basic expression from ``self``. """
2523         return self.as_poly(x or self.root).as_expr().expand()
2524 
2525     def coeffs(self):
2526         """Returns all SymPy coefficients of an algebraic number. """
2527         return [ self.rep.dom.to_sympy(c) for c in self.rep.all_coeffs() ]
2528 
2529     def native_coeffs(self):
2530         """Returns all native coefficients of an algebraic number. """
2531         return self.rep.all_coeffs()
2532 
2533     def to_algebraic_integer(self):
2534         """Convert ``self`` to an algebraic integer. """
2535         from sympy import Poly
2536         f = self.minpoly
2537 
2538         if f.LC() == 1:
2539             return self
2540 
2541         coeff = f.LC()**(f.degree() - 1)
2542         poly = f.compose(Poly(f.gen/f.LC()))
2543 
2544         minpoly = poly*coeff
2545         root = f.LC()*self.root
2546 
2547         return AlgebraicNumber((minpoly, root), self.coeffs())
2548 
2549     def _eval_simplify(self, **kwargs):
2550         from sympy.polys import CRootOf, minpoly
2551         measure, ratio = kwargs['measure'], kwargs['ratio']
2552         for r in [r for r in self.minpoly.all_roots() if r.func != CRootOf]:
2553             if minpoly(self.root - r).is_Symbol:
2554                 # use the matching root if it's simpler
2555                 if measure(r) < ratio*measure(self.root):
2556                     return AlgebraicNumber(r)
2557         return self
2558 
2559 
2560 class RationalConstant(Rational):
2561     """
2562     Abstract base class for rationals with specific behaviors
2563 
2564     Derived classes must define class attributes p and q and should probably all
2565     be singletons.
2566     """
2567     __slots__ = ()
2568 
2569     def __new__(cls):
2570         return AtomicExpr.__new__(cls)
2571 
2572 
2573 class IntegerConstant(Integer):
2574     __slots__ = ()
2575 
2576     def __new__(cls):
2577         return AtomicExpr.__new__(cls)
2578 
2579 
2580 class Zero(IntegerConstant, metaclass=Singleton):
2581     """The number zero.
2582 
2583     Zero is a singleton, and can be accessed by ``S.Zero``
2584 
2585     Examples
2586     ========
2587 
2588     >>> from sympy import S, Integer
2589     >>> Integer(0) is S.Zero
2590     True
2591     >>> 1/S.Zero
2592     zoo
2593 
2594     References
2595     ==========
2596 
2597     .. [1] https://en.wikipedia.org/wiki/Zero
2598     """
2599 
2600     p = 0
2601     q = 1
2602     is_positive = False
2603     is_negative = False
2604     is_zero = True
2605     is_number = True
2606     is_comparable = True
2607 
2608     __slots__ = ()
2609 
2610     def __getnewargs__(self):
2611         return ()
2612 
2613     @staticmethod
2614     def __abs__():
2615         return S.Zero
2616 
2617     @staticmethod
2618     def __neg__():
2619         return S.Zero
2620 
2621     def _eval_power(self, expt):
2622         if expt.is_positive:
2623             return self
2624         if expt.is_negative:
2625             return S.ComplexInfinity
2626         if expt.is_extended_real is False:
2627             return S.NaN
2628         # infinities are already handled with pos and neg
2629         # tests above; now throw away leading numbers on Mul
2630         # exponent
2631         coeff, terms = expt.as_coeff_Mul()
2632         if coeff.is_negative:
2633             return S.ComplexInfinity**terms
2634         if coeff is not S.One:  # there is a Number to discard
2635             return self**terms
2636 
2637     def _eval_order(self, *symbols):
2638         # Order(0,x) -> 0
2639         return self
2640 
2641     def __bool__(self):
2642         return False
2643 
2644     def as_coeff_Mul(self, rational=False):  # XXX this routine should be deleted
2645         """Efficiently extract the coefficient of a summation. """
2646         return S.One, self
2647 
2648 
2649 class One(IntegerConstant, metaclass=Singleton):
2650     """The number one.
2651 
2652     One is a singleton, and can be accessed by ``S.One``.
2653 
2654     Examples
2655     ========
2656 
2657     >>> from sympy import S, Integer
2658     >>> Integer(1) is S.One
2659     True
2660 
2661     References
2662     ==========
2663 
2664     .. [1] https://en.wikipedia.org/wiki/1_%28number%29
2665     """
2666     is_number = True
2667     is_positive = True
2668 
2669     p = 1
2670     q = 1
2671 
2672     __slots__ = ()
2673 
2674     def __getnewargs__(self):
2675         return ()
2676 
2677     @staticmethod
2678     def __abs__():
2679         return S.One
2680 
2681     @staticmethod
2682     def __neg__():
2683         return S.NegativeOne
2684 
2685     def _eval_power(self, expt):
2686         return self
2687 
2688     def _eval_order(self, *symbols):
2689         return
2690 
2691     @staticmethod
2692     def factors(limit=None, use_trial=True, use_rho=False, use_pm1=False,
2693                 verbose=False, visual=False):
2694         if visual:
2695             return S.One
2696         else:
2697             return {}
2698 
2699 
2700 class NegativeOne(IntegerConstant, metaclass=Singleton):
2701     """The number negative one.
2702 
2703     NegativeOne is a singleton, and can be accessed by ``S.NegativeOne``.
2704 
2705     Examples
2706     ========
2707 
2708     >>> from sympy import S, Integer
2709     >>> Integer(-1) is S.NegativeOne
2710     True
2711 
2712     See Also
2713     ========
2714 
2715     One
2716 
2717     References
2718     ==========
2719 
2720     .. [1] https://en.wikipedia.org/wiki/%E2%88%921_%28number%29
2721 
2722     """
2723     is_number = True
2724 
2725     p = -1
2726     q = 1
2727 
2728     __slots__ = ()
2729 
2730     def __getnewargs__(self):
2731         return ()
2732 
2733     @staticmethod
2734     def __abs__():
2735         return S.One
2736 
2737     @staticmethod
2738     def __neg__():
2739         return S.One
2740 
2741     def _eval_power(self, expt):
2742         if expt.is_odd:
2743             return S.NegativeOne
2744         if expt.is_even:
2745             return S.One
2746         if isinstance(expt, Number):
2747             if isinstance(expt, Float):
2748                 return Float(-1.0)**expt
2749             if expt is S.NaN:
2750                 return S.NaN
2751             if expt is S.Infinity or expt is S.NegativeInfinity:
2752                 return S.NaN
2753             if expt is S.Half:
2754                 return S.ImaginaryUnit
2755             if isinstance(expt, Rational):
2756                 if expt.q == 2:
2757                     return S.ImaginaryUnit**Integer(expt.p)
2758                 i, r = divmod(expt.p, expt.q)
2759                 if i:
2760                     return self**i*self**Rational(r, expt.q)
2761         return
2762 
2763 
2764 class Half(RationalConstant, metaclass=Singleton):
2765     """The rational number 1/2.
2766 
2767     Half is a singleton, and can be accessed by ``S.Half``.
2768 
2769     Examples
2770     ========
2771 
2772     >>> from sympy import S, Rational
2773     >>> Rational(1, 2) is S.Half
2774     True
2775 
2776     References
2777     ==========
2778 
2779     .. [1] https://en.wikipedia.org/wiki/One_half
2780     """
2781     is_number = True
2782 
2783     p = 1
2784     q = 2
2785 
2786     __slots__ = ()
2787 
2788     def __getnewargs__(self):
2789         return ()
2790 
2791     @staticmethod
2792     def __abs__():
2793         return S.Half
2794 
2795 
2796 class Infinity(Number, metaclass=Singleton):
2797     r"""Positive infinite quantity.
2798 
2799     Explanation
2800     ===========
2801 
2802     In real analysis the symbol `\infty` denotes an unbounded
2803     limit: `x\to\infty` means that `x` grows without bound.
2804 
2805     Infinity is often used not only to define a limit but as a value
2806     in the affinely extended real number system.  Points labeled `+\infty`
2807     and `-\infty` can be added to the topological space of the real numbers,
2808     producing the two-point compactification of the real numbers.  Adding
2809     algebraic properties to this gives us the extended real numbers.
2810 
2811     Infinity is a singleton, and can be accessed by ``S.Infinity``,
2812     or can be imported as ``oo``.
2813 
2814     Examples
2815     ========
2816 
2817     >>> from sympy import oo, exp, limit, Symbol
2818     >>> 1 + oo
2819     oo
2820     >>> 42/oo
2821     0
2822     >>> x = Symbol('x')
2823     >>> limit(exp(x), x, oo)
2824     oo
2825 
2826     See Also
2827     ========
2828 
2829     NegativeInfinity, NaN
2830 
2831     References
2832     ==========
2833 
2834     .. [1] https://en.wikipedia.org/wiki/Infinity
2835     """
2836 
2837     is_commutative = True
2838     is_number = True
2839     is_complex = False
2840     is_extended_real = True
2841     is_infinite = True
2842     is_comparable = True
2843     is_extended_positive = True
2844     is_prime = False
2845 
2846     __slots__ = ()
2847 
2848     def __new__(cls):
2849         return AtomicExpr.__new__(cls)
2850 
2851     def _latex(self, printer):
2852         return r"\infty"
2853 
2854     def _eval_subs(self, old, new):
2855         if self == old:
2856             return new
2857 
2858     def _eval_evalf(self, prec=None):
2859         return Float('inf')
2860 
2861     def evalf(self, prec=None, **options):
2862         return self._eval_evalf(prec)
2863 
2864     @_sympifyit('other', NotImplemented)
2865     def __add__(self, other):
2866         if isinstance(other, Number) and global_parameters.evaluate:
2867             if other is S.NegativeInfinity or other is S.NaN:
2868                 return S.NaN
2869             return self
2870         return Number.__add__(self, other)
2871     __radd__ = __add__
2872 
2873     @_sympifyit('other', NotImplemented)
2874     def __sub__(self, other):
2875         if isinstance(other, Number) and global_parameters.evaluate:
2876             if other is S.Infinity or other is S.NaN:
2877                 return S.NaN
2878             return self
2879         return Number.__sub__(self, other)
2880 
2881     @_sympifyit('other', NotImplemented)
2882     def __rsub__(self, other):
2883         return (-self).__add__(other)
2884 
2885     @_sympifyit('other', NotImplemented)
2886     def __mul__(self, other):
2887         if isinstance(other, Number) and global_parameters.evaluate:
2888             if other.is_zero or other is S.NaN:
2889                 return S.NaN
2890             if other.is_extended_positive:
2891                 return self
2892             return S.NegativeInfinity
2893         return Number.__mul__(self, other)
2894     __rmul__ = __mul__
2895 
2896     @_sympifyit('other', NotImplemented)
2897     def __truediv__(self, other):
2898         if isinstance(other, Number) and global_parameters.evaluate:
2899             if other is S.Infinity or \
2900                 other is S.NegativeInfinity or \
2901                     other is S.NaN:
2902                 return S.NaN
2903             if other.is_extended_nonnegative:
2904                 return self
2905             return S.NegativeInfinity
2906         return Number.__truediv__(self, other)
2907 
2908     def __abs__(self):
2909         return S.Infinity
2910 
2911     def __neg__(self):
2912         return S.NegativeInfinity
2913 
2914     def _eval_power(self, expt):
2915         """
2916         ``expt`` is symbolic object but not equal to 0 or 1.
2917 
2918         ================ ======= ==============================
2919         Expression       Result  Notes
2920         ================ ======= ==============================
2921         ``oo ** nan``    ``nan``
2922         ``oo ** -p``     ``0``   ``p`` is number, ``oo``
2923         ================ ======= ==============================
2924 
2925         See Also
2926         ========
2927         Pow
2928         NaN
2929         NegativeInfinity
2930 
2931         """
2932         from sympy.functions import re
2933 
2934         if expt.is_extended_positive:
2935             return S.Infinity
2936         if expt.is_extended_negative:
2937             return S.Zero
2938         if expt is S.NaN:
2939             return S.NaN
2940         if expt is S.ComplexInfinity:
2941             return S.NaN
2942         if expt.is_extended_real is False and expt.is_number:
2943             expt_real = re(expt)
2944             if expt_real.is_positive:
2945                 return S.ComplexInfinity
2946             if expt_real.is_negative:
2947                 return S.Zero
2948             if expt_real.is_zero:
2949                 return S.NaN
2950 
2951             return self**expt.evalf()
2952 
2953     def _as_mpf_val(self, prec):
2954         return mlib.finf
2955 
2956     def _sage_(self):
2957         import sage.all as sage
2958         return sage.oo
2959 
2960     def __hash__(self):
2961         return super().__hash__()
2962 
2963     def __eq__(self, other):
2964         return other is S.Infinity or other == float('inf')
2965 
2966     def __ne__(self, other):
2967         return other is not S.Infinity and other != float('inf')
2968 
2969     __gt__ = Expr.__gt__
2970     __ge__ = Expr.__ge__
2971     __lt__ = Expr.__lt__
2972     __le__ = Expr.__le__
2973 
2974     @_sympifyit('other', NotImplemented)
2975     def __mod__(self, other):
2976         if not isinstance(other, Expr):
2977             return NotImplemented
2978         return S.NaN
2979 
2980     __rmod__ = __mod__
2981 
2982     def floor(self):
2983         return self
2984 
2985     def ceiling(self):
2986         return self
2987 
2988 oo = S.Infinity
2989 
2990 
2991 class NegativeInfinity(Number, metaclass=Singleton):
2992     """Negative infinite quantity.
2993 
2994     NegativeInfinity is a singleton, and can be accessed
2995     by ``S.NegativeInfinity``.
2996 
2997     See Also
2998     ========
2999 
3000     Infinity
3001     """
3002 
3003     is_extended_real = True
3004     is_complex = False
3005     is_commutative = True
3006     is_infinite = True
3007     is_comparable = True
3008     is_extended_negative = True
3009     is_number = True
3010     is_prime = False
3011 
3012     __slots__ = ()
3013 
3014     def __new__(cls):
3015         return AtomicExpr.__new__(cls)
3016 
3017     def _latex(self, printer):
3018         return r"-\infty"
3019 
3020     def _eval_subs(self, old, new):
3021         if self == old:
3022             return new
3023 
3024     def _eval_evalf(self, prec=None):
3025         return Float('-inf')
3026 
3027     def evalf(self, prec=None, **options):
3028         return self._eval_evalf(prec)
3029 
3030     @_sympifyit('other', NotImplemented)
3031     def __add__(self, other):
3032         if isinstance(other, Number) and global_parameters.evaluate:
3033             if other is S.Infinity or other is S.NaN:
3034                 return S.NaN
3035             return self
3036         return Number.__add__(self, other)
3037     __radd__ = __add__
3038 
3039     @_sympifyit('other', NotImplemented)
3040     def __sub__(self, other):
3041         if isinstance(other, Number) and global_parameters.evaluate:
3042             if other is S.NegativeInfinity or other is S.NaN:
3043                 return S.NaN
3044             return self
3045         return Number.__sub__(self, other)
3046 
3047     @_sympifyit('other', NotImplemented)
3048     def __rsub__(self, other):
3049         return (-self).__add__(other)
3050 
3051     @_sympifyit('other', NotImplemented)
3052     def __mul__(self, other):
3053         if isinstance(other, Number) and global_parameters.evaluate:
3054             if other.is_zero or other is S.NaN:
3055                 return S.NaN
3056             if other.is_extended_positive:
3057                 return self
3058             return S.Infinity
3059         return Number.__mul__(self, other)
3060     __rmul__ = __mul__
3061 
3062     @_sympifyit('other', NotImplemented)
3063     def __truediv__(self, other):
3064         if isinstance(other, Number) and global_parameters.evaluate:
3065             if other is S.Infinity or \
3066                 other is S.NegativeInfinity or \
3067                     other is S.NaN:
3068                 return S.NaN
3069             if other.is_extended_nonnegative:
3070                 return self
3071             return S.Infinity
3072         return Number.__truediv__(self, other)
3073 
3074     def __abs__(self):
3075         return S.Infinity
3076 
3077     def __neg__(self):
3078         return S.Infinity
3079 
3080     def _eval_power(self, expt):
3081         """
3082         ``expt`` is symbolic object but not equal to 0 or 1.
3083 
3084         ================ ======= ==============================
3085         Expression       Result  Notes
3086         ================ ======= ==============================
3087         ``(-oo) ** nan`` ``nan``
3088         ``(-oo) ** oo``  ``nan``
3089         ``(-oo) ** -oo`` ``nan``
3090         ``(-oo) ** e``   ``oo``  ``e`` is positive even integer
3091         ``(-oo) ** o``   ``-oo`` ``o`` is positive odd integer
3092         ================ ======= ==============================
3093 
3094         See Also
3095         ========
3096 
3097         Infinity
3098         Pow
3099         NaN
3100 
3101         """
3102         if expt.is_number:
3103             if expt is S.NaN or \
3104                 expt is S.Infinity or \
3105                     expt is S.NegativeInfinity:
3106                 return S.NaN
3107 
3108             if isinstance(expt, Integer) and expt.is_extended_positive:
3109                 if expt.is_odd:
3110                     return S.NegativeInfinity
3111                 else:
3112                     return S.Infinity
3113 
3114             return S.NegativeOne**expt*S.Infinity**expt
3115 
3116     def _as_mpf_val(self, prec):
3117         return mlib.fninf
3118 
3119     def _sage_(self):
3120         import sage.all as sage
3121         return -(sage.oo)
3122 
3123     def __hash__(self):
3124         return super().__hash__()
3125 
3126     def __eq__(self, other):
3127         return other is S.NegativeInfinity or other == float('-inf')
3128 
3129     def __ne__(self, other):
3130         return other is not S.NegativeInfinity and other != float('-inf')
3131 
3132     __gt__ = Expr.__gt__
3133     __ge__ = Expr.__ge__
3134     __lt__ = Expr.__lt__
3135     __le__ = Expr.__le__
3136 
3137     @_sympifyit('other', NotImplemented)
3138     def __mod__(self, other):
3139         if not isinstance(other, Expr):
3140             return NotImplemented
3141         return S.NaN
3142 
3143     __rmod__ = __mod__
3144 
3145     def floor(self):
3146         return self
3147 
3148     def ceiling(self):
3149         return self
3150 
3151     def as_powers_dict(self):
3152         return {S.NegativeOne: 1, S.Infinity: 1}
3153 
3154 
3155 class NaN(Number, metaclass=Singleton):
3156     """
3157     Not a Number.
3158 
3159     Explanation
3160     ===========
3161 
3162     This serves as a place holder for numeric values that are indeterminate.
3163     Most operations on NaN, produce another NaN.  Most indeterminate forms,
3164     such as ``0/0`` or ``oo - oo` produce NaN.  Two exceptions are ``0**0``
3165     and ``oo**0``, which all produce ``1`` (this is consistent with Python's
3166     float).
3167 
3168     NaN is loosely related to floating point nan, which is defined in the
3169     IEEE 754 floating point standard, and corresponds to the Python
3170     ``float('nan')``.  Differences are noted below.
3171 
3172     NaN is mathematically not equal to anything else, even NaN itself.  This
3173     explains the initially counter-intuitive results with ``Eq`` and ``==`` in
3174     the examples below.
3175 
3176     NaN is not comparable so inequalities raise a TypeError.  This is in
3177     contrast with floating point nan where all inequalities are false.
3178 
3179     NaN is a singleton, and can be accessed by ``S.NaN``, or can be imported
3180     as ``nan``.
3181 
3182     Examples
3183     ========
3184 
3185     >>> from sympy import nan, S, oo, Eq
3186     >>> nan is S.NaN
3187     True
3188     >>> oo - oo
3189     nan
3190     >>> nan + 1
3191     nan
3192     >>> Eq(nan, nan)   # mathematical equality
3193     False
3194     >>> nan == nan     # structural equality
3195     True
3196 
3197     References
3198     ==========
3199 
3200     .. [1] https://en.wikipedia.org/wiki/NaN
3201 
3202     """
3203     is_commutative = True
3204     is_extended_real = None
3205     is_real = None
3206     is_rational = None
3207     is_algebraic = None
3208     is_transcendental = None
3209     is_integer = None
3210     is_comparable = False
3211     is_finite = None
3212     is_zero = None
3213     is_prime = None
3214     is_positive = None
3215     is_negative = None
3216     is_number = True
3217 
3218     __slots__ = ()
3219 
3220     def __new__(cls):
3221         return AtomicExpr.__new__(cls)
3222 
3223     def _latex(self, printer):
3224         return r"\text{NaN}"
3225 
3226     def __neg__(self):
3227         return self
3228 
3229     @_sympifyit('other', NotImplemented)
3230     def __add__(self, other):
3231         return self
3232 
3233     @_sympifyit('other', NotImplemented)
3234     def __sub__(self, other):
3235         return self
3236 
3237     @_sympifyit('other', NotImplemented)
3238     def __mul__(self, other):
3239         return self
3240 
3241     @_sympifyit('other', NotImplemented)
3242     def __truediv__(self, other):
3243         return self
3244 
3245     def floor(self):
3246         return self
3247 
3248     def ceiling(self):
3249         return self
3250 
3251     def _as_mpf_val(self, prec):
3252         return _mpf_nan
3253 
3254     def _sage_(self):
3255         import sage.all as sage
3256         return sage.NaN
3257 
3258     def __hash__(self):
3259         return super().__hash__()
3260 
3261     def __eq__(self, other):
3262         # NaN is structurally equal to another NaN
3263         return other is S.NaN
3264 
3265     def __ne__(self, other):
3266         return other is not S.NaN
3267 
3268     # Expr will _sympify and raise TypeError
3269     __gt__ = Expr.__gt__
3270     __ge__ = Expr.__ge__
3271     __lt__ = Expr.__lt__
3272     __le__ = Expr.__le__
3273 
3274 nan = S.NaN
3275 
3276 @dispatch(NaN, Expr) # type:ignore
3277 def _eval_is_eq(a, b): # noqa:F811
3278     return False
3279 
3280 
3281 class ComplexInfinity(AtomicExpr, metaclass=Singleton):
3282     r"""Complex infinity.
3283 
3284     Explanation
3285     ===========
3286 
3287     In complex analysis the symbol `\tilde\infty`, called "complex
3288     infinity", represents a quantity with infinite magnitude, but
3289     undetermined complex phase.
3290 
3291     ComplexInfinity is a singleton, and can be accessed by
3292     ``S.ComplexInfinity``, or can be imported as ``zoo``.
3293 
3294     Examples
3295     ========
3296 
3297     >>> from sympy import zoo
3298     >>> zoo + 42
3299     zoo
3300     >>> 42/zoo
3301     0
3302     >>> zoo + zoo
3303     nan
3304     >>> zoo*zoo
3305     zoo
3306 
3307     See Also
3308     ========
3309 
3310     Infinity
3311     """
3312 
3313     is_commutative = True
3314     is_infinite = True
3315     is_number = True
3316     is_prime = False
3317     is_complex = False
3318     is_extended_real = False
3319 
3320     kind = NumberKind
3321 
3322     __slots__ = ()
3323 
3324     def __new__(cls):
3325         return AtomicExpr.__new__(cls)
3326 
3327     def _latex(self, printer):
3328         return r"\tilde{\infty}"
3329 
3330     @staticmethod
3331     def __abs__():
3332         return S.Infinity
3333 
3334     def floor(self):
3335         return self
3336 
3337     def ceiling(self):
3338         return self
3339 
3340     @staticmethod
3341     def __neg__():
3342         return S.ComplexInfinity
3343 
3344     def _eval_power(self, expt):
3345         if expt is S.ComplexInfinity:
3346             return S.NaN
3347 
3348         if isinstance(expt, Number):
3349             if expt.is_zero:
3350                 return S.NaN
3351             else:
3352                 if expt.is_positive:
3353                     return S.ComplexInfinity
3354                 else:
3355                     return S.Zero
3356 
3357     def _sage_(self):
3358         import sage.all as sage
3359         return sage.UnsignedInfinityRing.gen()
3360 
3361 
3362 zoo = S.ComplexInfinity
3363 
3364 
3365 class NumberSymbol(AtomicExpr):
3366 
3367     is_commutative = True
3368     is_finite = True
3369     is_number = True
3370 
3371     __slots__ = ()
3372 
3373     is_NumberSymbol = True
3374 
3375     kind = NumberKind
3376 
3377     def __new__(cls):
3378         return AtomicExpr.__new__(cls)
3379 
3380     def approximation(self, number_cls):
3381         """ Return an interval with number_cls endpoints
3382         that contains the value of NumberSymbol.
3383         If not implemented, then return None.
3384         """
3385 
3386     def _eval_evalf(self, prec):
3387         return Float._new(self._as_mpf_val(prec), prec)
3388 
3389     def __eq__(self, other):
3390         try:
3391             other = _sympify(other)
3392         except SympifyError:
3393             return NotImplemented
3394         if self is other:
3395             return True
3396         if other.is_Number and self.is_irrational:
3397             return False
3398 
3399         return False    # NumberSymbol != non-(Number|self)
3400 
3401     def __ne__(self, other):
3402         return not self == other
3403 
3404     def __le__(self, other):
3405         if self is other:
3406             return S.true
3407         return Expr.__le__(self, other)
3408 
3409     def __ge__(self, other):
3410         if self is other:
3411             return S.true
3412         return Expr.__ge__(self, other)
3413 
3414     def __int__(self):
3415         # subclass with appropriate return value
3416         raise NotImplementedError
3417 
3418     def __hash__(self):
3419         return super().__hash__()
3420 
3421 class Exp1(NumberSymbol, metaclass=Singleton):
3422     r"""The `e` constant.
3423 
3424     Explanation
3425     ===========
3426 
3427     The transcendental number `e = 2.718281828\ldots` is the base of the
3428     natural logarithm and of the exponential function, `e = \exp(1)`.
3429     Sometimes called Euler's number or Napier's constant.
3430 
3431     Exp1 is a singleton, and can be accessed by ``S.Exp1``,
3432     or can be imported as ``E``.
3433 
3434     Examples
3435     ========
3436 
3437     >>> from sympy import exp, log, E
3438     >>> E is exp(1)
3439     True
3440     >>> log(E)
3441     1
3442 
3443     References
3444     ==========
3445 
3446     .. [1] https://en.wikipedia.org/wiki/E_%28mathematical_constant%29
3447     """
3448 
3449     is_real = True
3450     is_positive = True
3451     is_negative = False  # XXX Forces is_negative/is_nonnegative
3452     is_irrational = True
3453     is_number = True
3454     is_algebraic = False
3455     is_transcendental = True
3456 
3457     __slots__ = ()
3458 
3459     def _latex(self, printer):
3460         return r"e"
3461 
3462     @staticmethod
3463     def __abs__():
3464         return S.Exp1
3465 
3466     def __int__(self):
3467         return 2
3468 
3469     def _as_mpf_val(self, prec):
3470         return mpf_e(prec)
3471 
3472     def approximation_interval(self, number_cls):
3473         if issubclass(number_cls, Integer):
3474             return (Integer(2), Integer(3))
3475         elif issubclass(number_cls, Rational):
3476             pass
3477 
3478     def _eval_power(self, expt):
3479         from sympy import exp
3480         if global_parameters.exp_is_pow:
3481             return self._eval_power_exp_is_pow(expt)
3482         else:
3483             return exp(expt)
3484 
3485     def _eval_power_exp_is_pow(self, arg):
3486         from ..functions.elementary.exponential import log
3487         from . import Add, Mul, Pow
3488         if arg.is_Number:
3489             if arg is oo:
3490                 return oo
3491             elif arg == -oo:
3492                 return S.Zero
3493         elif isinstance(arg, log):
3494             return arg.args[0]
3495 
3496         # don't autoexpand Pow or Mul (see the issue 3351):
3497         elif not arg.is_Add:
3498             Ioo = I*oo
3499             if arg in [Ioo, -Ioo]:
3500                 return nan
3501 
3502             coeff = arg.coeff(pi*I)
3503             if coeff:
3504                 if (2*coeff).is_integer:
3505                     if coeff.is_even:
3506                         return S.One
3507                     elif coeff.is_odd:
3508                         return S.NegativeOne
3509                     elif (coeff + S.Half).is_even:
3510                         return -I
3511                     elif (coeff + S.Half).is_odd:
3512                         return I
3513                 elif coeff.is_Rational:
3514                     ncoeff = coeff % 2 # restrict to [0, 2pi)
3515                     if ncoeff > 1: # restrict to (-pi, pi]
3516                         ncoeff -= 2
3517                     if ncoeff != coeff:
3518                         return S.Exp1**(ncoeff*S.Pi*S.ImaginaryUnit)
3519 
3520             # Warning: code in risch.py will be very sensitive to changes
3521             # in this (see DifferentialExtension).
3522 
3523             # look for a single log factor
3524 
3525             coeff, terms = arg.as_coeff_Mul()
3526 
3527             # but it can't be multiplied by oo
3528             if coeff in (oo, -oo):
3529                 return
3530 
3531             coeffs, log_term = [coeff], None
3532             for term in Mul.make_args(terms):
3533                 if isinstance(term, log):
3534                     if log_term is None:
3535                         log_term = term.args[0]
3536                     else:
3537                         return
3538                 elif term.is_comparable:
3539                     coeffs.append(term)
3540                 else:
3541                     return
3542 
3543             return log_term**Mul(*coeffs) if log_term else None
3544         elif arg.is_Add:
3545             out = []
3546             add = []
3547             argchanged = False
3548             for a in arg.args:
3549                 if a is S.One:
3550                     add.append(a)
3551                     continue
3552                 newa = self**a
3553                 if isinstance(newa, Pow) and newa.base is self:
3554                     if newa.exp != a:
3555                         add.append(newa.exp)
3556                         argchanged = True
3557                     else:
3558                         add.append(a)
3559                 else:
3560                     out.append(newa)
3561             if out or argchanged:
3562                 return Mul(*out)*Pow(self, Add(*add), evaluate=False)
3563         elif arg.is_Matrix:
3564             return arg.exp()
3565 
3566     def _eval_rewrite_as_sin(self, **kwargs):
3567         from sympy import sin
3568         I = S.ImaginaryUnit
3569         return sin(I + S.Pi/2) - I*sin(I)
3570 
3571     def _eval_rewrite_as_cos(self, **kwargs):
3572         from sympy import cos
3573         I = S.ImaginaryUnit
3574         return cos(I) + I*cos(I + S.Pi/2)
3575 
3576     def _sage_(self):
3577         import sage.all as sage
3578         return sage.e
3579 E = S.Exp1
3580 
3581 
3582 class Pi(NumberSymbol, metaclass=Singleton):
3583     r"""The `\pi` constant.
3584 
3585     Explanation
3586     ===========
3587 
3588     The transcendental number `\pi = 3.141592654\ldots` represents the ratio
3589     of a circle's circumference to its diameter, the area of the unit circle,
3590     the half-period of trigonometric functions, and many other things
3591     in mathematics.
3592 
3593     Pi is a singleton, and can be accessed by ``S.Pi``, or can
3594     be imported as ``pi``.
3595 
3596     Examples
3597     ========
3598 
3599     >>> from sympy import S, pi, oo, sin, exp, integrate, Symbol
3600     >>> S.Pi
3601     pi
3602     >>> pi > 3
3603     True
3604     >>> pi.is_irrational
3605     True
3606     >>> x = Symbol('x')
3607     >>> sin(x + 2*pi)
3608     sin(x)
3609     >>> integrate(exp(-x**2), (x, -oo, oo))
3610     sqrt(pi)
3611 
3612     References
3613     ==========
3614 
3615     .. [1] https://en.wikipedia.org/wiki/Pi
3616     """
3617 
3618     is_real = True
3619     is_positive = True
3620     is_negative = False
3621     is_irrational = True
3622     is_number = True
3623     is_algebraic = False
3624     is_transcendental = True
3625 
3626     __slots__ = ()
3627 
3628     def _latex(self, printer):
3629         return r"\pi"
3630 
3631     @staticmethod
3632     def __abs__():
3633         return S.Pi
3634 
3635     def __int__(self):
3636         return 3
3637 
3638     def _as_mpf_val(self, prec):
3639         return mpf_pi(prec)
3640 
3641     def approximation_interval(self, number_cls):
3642         if issubclass(number_cls, Integer):
3643             return (Integer(3), Integer(4))
3644         elif issubclass(number_cls, Rational):
3645             return (Rational(223, 71), Rational(22, 7))
3646 
3647     def _sage_(self):
3648         import sage.all as sage
3649         return sage.pi
3650 pi = S.Pi
3651 
3652 
3653 class GoldenRatio(NumberSymbol, metaclass=Singleton):
3654     r"""The golden ratio, `\phi`.
3655 
3656     Explanation
3657     ===========
3658 
3659     `\phi = \frac{1 + \sqrt{5}}{2}` is algebraic number.  Two quantities
3660     are in the golden ratio if their ratio is the same as the ratio of
3661     their sum to the larger of the two quantities, i.e. their maximum.
3662 
3663     GoldenRatio is a singleton, and can be accessed by ``S.GoldenRatio``.
3664 
3665     Examples
3666     ========
3667 
3668     >>> from sympy import S
3669     >>> S.GoldenRatio > 1
3670     True
3671     >>> S.GoldenRatio.expand(func=True)
3672     1/2 + sqrt(5)/2
3673     >>> S.GoldenRatio.is_irrational
3674     True
3675 
3676     References
3677     ==========
3678 
3679     .. [1] https://en.wikipedia.org/wiki/Golden_ratio
3680     """
3681 
3682     is_real = True
3683     is_positive = True
3684     is_negative = False
3685     is_irrational = True
3686     is_number = True
3687     is_algebraic = True
3688     is_transcendental = False
3689 
3690     __slots__ = ()
3691 
3692     def _latex(self, printer):
3693         return r"\phi"
3694 
3695     def __int__(self):
3696         return 1
3697 
3698     def _as_mpf_val(self, prec):
3699          # XXX track down why this has to be increased
3700         rv = mlib.from_man_exp(phi_fixed(prec + 10), -prec - 10)
3701         return mpf_norm(rv, prec)
3702 
3703     def _eval_expand_func(self, **hints):
3704         from sympy import sqrt
3705         return S.Half + S.Half*sqrt(5)
3706 
3707     def approximation_interval(self, number_cls):
3708         if issubclass(number_cls, Integer):
3709             return (S.One, Rational(2))
3710         elif issubclass(number_cls, Rational):
3711             pass
3712 
3713     def _sage_(self):
3714         import sage.all as sage
3715         return sage.golden_ratio
3716 
3717     _eval_rewrite_as_sqrt = _eval_expand_func
3718 
3719 
3720 class TribonacciConstant(NumberSymbol, metaclass=Singleton):
3721     r"""The tribonacci constant.
3722 
3723     Explanation
3724     ===========
3725 
3726     The tribonacci numbers are like the Fibonacci numbers, but instead
3727     of starting with two predetermined terms, the sequence starts with
3728     three predetermined terms and each term afterwards is the sum of the
3729     preceding three terms.
3730 
3731     The tribonacci constant is the ratio toward which adjacent tribonacci
3732     numbers tend. It is a root of the polynomial `x^3 - x^2 - x - 1 = 0`,
3733     and also satisfies the equation `x + x^{-3} = 2`.
3734 
3735     TribonacciConstant is a singleton, and can be accessed
3736     by ``S.TribonacciConstant``.
3737 
3738     Examples
3739     ========
3740 
3741     >>> from sympy import S
3742     >>> S.TribonacciConstant > 1
3743     True
3744     >>> S.TribonacciConstant.expand(func=True)
3745     1/3 + (19 - 3*sqrt(33))**(1/3)/3 + (3*sqrt(33) + 19)**(1/3)/3
3746     >>> S.TribonacciConstant.is_irrational
3747     True
3748     >>> S.TribonacciConstant.n(20)
3749     1.8392867552141611326
3750 
3751     References
3752     ==========
3753 
3754     .. [1] https://en.wikipedia.org/wiki/Generalizations_of_Fibonacci_numbers#Tribonacci_numbers
3755     """
3756 
3757     is_real = True
3758     is_positive = True
3759     is_negative = False
3760     is_irrational = True
3761     is_number = True
3762     is_algebraic = True
3763     is_transcendental = False
3764 
3765     __slots__ = ()
3766 
3767     def _latex(self, printer):
3768         return r"\text{TribonacciConstant}"
3769 
3770     def __int__(self):
3771         return 2
3772 
3773     def _eval_evalf(self, prec):
3774         rv = self._eval_expand_func(function=True)._eval_evalf(prec + 4)
3775         return Float(rv, precision=prec)
3776 
3777     def _eval_expand_func(self, **hints):
3778         from sympy import sqrt, cbrt
3779         return (1 + cbrt(19 - 3*sqrt(33)) + cbrt(19 + 3*sqrt(33))) / 3
3780 
3781     def approximation_interval(self, number_cls):
3782         if issubclass(number_cls, Integer):
3783             return (S.One, Rational(2))
3784         elif issubclass(number_cls, Rational):
3785             pass
3786 
3787     _eval_rewrite_as_sqrt = _eval_expand_func
3788 
3789 
3790 class EulerGamma(NumberSymbol, metaclass=Singleton):
3791     r"""The Euler-Mascheroni constant.
3792 
3793     Explanation
3794     ===========
3795 
3796     `\gamma = 0.5772157\ldots` (also called Euler's constant) is a mathematical
3797     constant recurring in analysis and number theory.  It is defined as the
3798     limiting difference between the harmonic series and the
3799     natural logarithm:
3800 
3801     .. math:: \gamma = \lim\limits_{n\to\infty}
3802               \left(\sum\limits_{k=1}^n\frac{1}{k} - \ln n\right)
3803 
3804     EulerGamma is a singleton, and can be accessed by ``S.EulerGamma``.
3805 
3806     Examples
3807     ========
3808 
3809     >>> from sympy import S
3810     >>> S.EulerGamma.is_irrational
3811     >>> S.EulerGamma > 0
3812     True
3813     >>> S.EulerGamma > 1
3814     False
3815 
3816     References
3817     ==========
3818 
3819     .. [1] https://en.wikipedia.org/wiki/Euler%E2%80%93Mascheroni_constant
3820     """
3821 
3822     is_real = True
3823     is_positive = True
3824     is_negative = False
3825     is_irrational = None
3826     is_number = True
3827 
3828     __slots__ = ()
3829 
3830     def _latex(self, printer):
3831         return r"\gamma"
3832 
3833     def __int__(self):
3834         return 0
3835 
3836     def _as_mpf_val(self, prec):
3837          # XXX track down why this has to be increased
3838         v = mlib.libhyper.euler_fixed(prec + 10)
3839         rv = mlib.from_man_exp(v, -prec - 10)
3840         return mpf_norm(rv, prec)
3841 
3842     def approximation_interval(self, number_cls):
3843         if issubclass(number_cls, Integer):
3844             return (S.Zero, S.One)
3845         elif issubclass(number_cls, Rational):
3846             return (S.Half, Rational(3, 5))
3847 
3848     def _sage_(self):
3849         import sage.all as sage
3850         return sage.euler_gamma
3851 
3852 
3853 class Catalan(NumberSymbol, metaclass=Singleton):
3854     r"""Catalan's constant.
3855 
3856     Explanation
3857     ===========
3858 
3859     `K = 0.91596559\ldots` is given by the infinite series
3860 
3861     .. math:: K = \sum_{k=0}^{\infty} \frac{(-1)^k}{(2k+1)^2}
3862 
3863     Catalan is a singleton, and can be accessed by ``S.Catalan``.
3864 
3865     Examples
3866     ========
3867 
3868     >>> from sympy import S
3869     >>> S.Catalan.is_irrational
3870     >>> S.Catalan > 0
3871     True
3872     >>> S.Catalan > 1
3873     False
3874 
3875     References
3876     ==========
3877 
3878     .. [1] https://en.wikipedia.org/wiki/Catalan%27s_constant
3879     """
3880 
3881     is_real = True
3882     is_positive = True
3883     is_negative = False
3884     is_irrational = None
3885     is_number = True
3886 
3887     __slots__ = ()
3888 
3889     def __int__(self):
3890         return 0
3891 
3892     def _as_mpf_val(self, prec):
3893         # XXX track down why this has to be increased
3894         v = mlib.catalan_fixed(prec + 10)
3895         rv = mlib.from_man_exp(v, -prec - 10)
3896         return mpf_norm(rv, prec)
3897 
3898     def approximation_interval(self, number_cls):
3899         if issubclass(number_cls, Integer):
3900             return (S.Zero, S.One)
3901         elif issubclass(number_cls, Rational):
3902             return (Rational(9, 10), S.One)
3903 
3904     def _eval_rewrite_as_Sum(self, k_sym=None, symbols=None):
3905         from sympy import Sum, Dummy
3906         if (k_sym is not None) or (symbols is not None):
3907             return self
3908         k = Dummy('k', integer=True, nonnegative=True)
3909         return Sum((-1)**k / (2*k+1)**2, (k, 0, S.Infinity))
3910 
3911     def _sage_(self):
3912         import sage.all as sage
3913         return sage.catalan
3914 
3915 
3916 class ImaginaryUnit(AtomicExpr, metaclass=Singleton):
3917     r"""The imaginary unit, `i = \sqrt{-1}`.
3918 
3919     I is a singleton, and can be accessed by ``S.I``, or can be
3920     imported as ``I``.
3921 
3922     Examples
3923     ========
3924 
3925     >>> from sympy import I, sqrt
3926     >>> sqrt(-1)
3927     I
3928     >>> I*I
3929     -1
3930     >>> 1/I
3931     -I
3932 
3933     References
3934     ==========
3935 
3936     .. [1] https://en.wikipedia.org/wiki/Imaginary_unit
3937     """
3938 
3939     is_commutative = True
3940     is_imaginary = True
3941     is_finite = True
3942     is_number = True
3943     is_algebraic = True
3944     is_transcendental = False
3945 
3946     kind = NumberKind
3947 
3948     __slots__ = ()
3949 
3950     def _latex(self, printer):
3951         return printer._settings['imaginary_unit_latex']
3952 
3953     @staticmethod
3954     def __abs__():
3955         return S.One
3956 
3957     def _eval_evalf(self, prec):
3958         return self
3959 
3960     def _eval_conjugate(self):
3961         return -S.ImaginaryUnit
3962 
3963     def _eval_power(self, expt):
3964         """
3965         b is I = sqrt(-1)
3966         e is symbolic object but not equal to 0, 1
3967 
3968         I**r -> (-1)**(r/2) -> exp(r/2*Pi*I) -> sin(Pi*r/2) + cos(Pi*r/2)*I, r is decimal
3969         I**0 mod 4 -> 1
3970         I**1 mod 4 -> I
3971         I**2 mod 4 -> -1
3972         I**3 mod 4 -> -I
3973         """
3974 
3975         if isinstance(expt, Integer):
3976             expt = expt % 4
3977             if expt == 0:
3978                 return S.One
3979             elif expt == 1:
3980                 return S.ImaginaryUnit
3981             elif expt == 2:
3982                 return S.NegativeOne
3983             elif expt == 3:
3984                 return -S.ImaginaryUnit
3985         if isinstance(expt, Rational):
3986             i, r = divmod(expt, 2)
3987             rv = Pow(S.ImaginaryUnit, r, evaluate=False)
3988             if i % 2:
3989                 return Mul(S.NegativeOne, rv, evaluate=False)
3990             return rv
3991 
3992     def as_base_exp(self):
3993         return S.NegativeOne, S.Half
3994 
3995     def _sage_(self):
3996         import sage.all as sage
3997         return sage.I
3998 
3999     @property
4000     def _mpc_(self):
4001         return (Float(0)._mpf_, Float(1)._mpf_)
4002 
4003 I = S.ImaginaryUnit
4004 
4005 @dispatch(Tuple, Number) # type:ignore
4006 def _eval_is_eq(self, other): # noqa: F811
4007     return False
4008 
4009 def sympify_fractions(f):
4010     return Rational(f.numerator, f.denominator, 1)
4011 
4012 converter[fractions.Fraction] = sympify_fractions
4013 
4014 if HAS_GMPY:
4015     def sympify_mpz(x):
4016         return Integer(int(x))
4017 
4018     # XXX: The sympify_mpq function here was never used because it is
4019     # overridden by the other sympify_mpq function below. Maybe it should just
4020     # be removed or maybe it should be used for something...
4021     def sympify_mpq(x):
4022         return Rational(int(x.numerator), int(x.denominator))
4023 
4024     converter[type(gmpy.mpz(1))] = sympify_mpz
4025     converter[type(gmpy.mpq(1, 2))] = sympify_mpq
4026 
4027 
4028 def sympify_mpmath_mpq(x):
4029     p, q = x._mpq_
4030     return Rational(p, q, 1)
4031 
4032 converter[type(mpmath.rational.mpq(1, 2))] = sympify_mpmath_mpq
4033 
4034 
4035 def sympify_mpmath(x):
4036     return Expr._from_mpmath(x, x.context.prec)
4037 
4038 converter[mpnumeric] = sympify_mpmath
4039 
4040 
4041 def sympify_complex(a):
4042     real, imag = list(map(sympify, (a.real, a.imag)))
4043     return real + S.ImaginaryUnit*imag
4044 
4045 converter[complex] = sympify_complex
4046 
4047 from .power import Pow, integer_nthroot
4048 from .mul import Mul
4049 Mul.identity = One()
4050 from .add import Add
4051 Add.identity = Zero()
4052 
4053 def _register_classes():
4054     numbers.Number.register(Number)
4055     numbers.Real.register(Float)
4056     numbers.Rational.register(Rational)
4057     numbers.Rational.register(Integer)
4058 
4059 _register_classes()

</code><intended_behavior>Enhance the precision handling or representation of `Float` objects when used in symbolic equations, especially within the context of linear solvers like `linsolve`. The goal is to minimize the impact of floating-point arithmetic issues (like rounding errors) that may lead to inconsistencies in equation solving outcomes. This may involve implementing a check or conversion mechanism that ensures numerical precision is maintained or enhanced when floating-point numbers are part of a symbolic equation, without undermining the performance or general usability of the library.</intended_behavior>]
2025-10-16 03:54:09.080 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-16 03:54:09.080 | INFO     | Search-only: skipping patch selection
2025-10-16 03:54:09.206 | INFO     | Task sympy__sympy-21527 completed successfully.
2025-10-16 03:54:09.207 | INFO     | No patch generated. You can try running ACR again.
