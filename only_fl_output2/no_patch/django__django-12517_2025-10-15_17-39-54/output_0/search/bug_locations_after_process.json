[
    {
        "rel_file_path": "django/core/servers/basehttp.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.1/django/core/servers/basehttp.py",
        "start": 122,
        "end": 197,
        "class_name": "WSGIRequestHandler",
        "method_name": null,
        "code": "122 class WSGIRequestHandler(simple_server.WSGIRequestHandler):\n123     protocol_version = 'HTTP/1.1'\n124 \n125     def address_string(self):\n126         # Short-circuit parent method to not call socket.getfqdn\n127         return self.client_address[0]\n128 \n129     def log_message(self, format, *args):\n130         extra = {\n131             'request': self.request,\n132             'server_time': self.log_date_time_string(),\n133         }\n134         if args[1][0] == '4':\n135             # 0x16 = Handshake, 0x03 = SSL 3.0 or TLS 1.x\n136             if args[0].startswith('\\x16\\x03'):\n137                 extra['status_code'] = 500\n138                 logger.error(\n139                     \"You're accessing the development server over HTTPS, but \"\n140                     \"it only supports HTTP.\\n\", extra=extra,\n141                 )\n142                 return\n143 \n144         if args[1].isdigit() and len(args[1]) == 3:\n145             status_code = int(args[1])\n146             extra['status_code'] = status_code\n147 \n148             if status_code >= 500:\n149                 level = logger.error\n150             elif status_code >= 400:\n151                 level = logger.warning\n152             else:\n153                 level = logger.info\n154         else:\n155             level = logger.info\n156 \n157         level(format, *args, extra=extra)\n158 \n159     def get_environ(self):\n160         # Strip all headers with underscores in the name before constructing\n161         # the WSGI environ. This prevents header-spoofing based on ambiguity\n162         # between underscores and dashes both normalized to underscores in WSGI\n163         # env vars. Nginx and Apache 2.4+ both do this as well.\n164         for k in self.headers:\n165             if '_' in k:\n166                 del self.headers[k]\n167 \n168         return super().get_environ()\n169 \n170     def handle(self):\n171         self.close_connection = True\n172         self.handle_one_request()\n173         while not self.close_connection:\n174             self.handle_one_request()\n175         try:\n176             self.connection.shutdown(socket.SHUT_WR)\n177         except (AttributeError, OSError):\n178             pass\n179 \n180     def handle_one_request(self):\n181         \"\"\"Copy of WSGIRequestHandler.handle() but with different ServerHandler\"\"\"\n182         self.raw_requestline = self.rfile.readline(65537)\n183         if len(self.raw_requestline) > 65536:\n184             self.requestline = ''\n185             self.request_version = ''\n186             self.command = ''\n187             self.send_error(414)\n188             return\n189 \n190         if not self.parse_request():  # An error code has been sent, just exit\n191             return\n192 \n193         handler = ServerHandler(\n194             self.rfile, self.wfile, self.get_stderr(), self.get_environ()\n195         )\n196         handler.request_handler = self      # backpointer for logging & connection closing\n197         handler.run(self.server.get_app())\n",
        "intended_behavior": "The intended behavior here should ensure the datetime logging is consistent across different components of the Django server, particularly between WSGIRequestHandler and WSGIServer. To resolve the issue, WSGIRequestHandler may need a method or an adjustment to ensure it formats the datetime in a consistent and configurable manner, similar to or in sync with WSGIServer's logging mechanism. This could involve defining a standard format for datetime that can be used across the server's logging system or ensuring that the logging formatter used across these classes adheres to a configurable format specified either in Django settings or within the logging configuration itself."
    },
    {
        "rel_file_path": "django/core/servers/basehttp.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.1/django/core/servers/basehttp.py",
        "start": 58,
        "end": 73,
        "class_name": "WSGIServer",
        "method_name": null,
        "code": "58 class WSGIServer(simple_server.WSGIServer):\n59     \"\"\"BaseHTTPServer that implements the Python WSGI protocol\"\"\"\n60 \n61     request_queue_size = 10\n62 \n63     def __init__(self, *args, ipv6=False, allow_reuse_address=True, **kwargs):\n64         if ipv6:\n65             self.address_family = socket.AF_INET6\n66         self.allow_reuse_address = allow_reuse_address\n67         super().__init__(*args, **kwargs)\n68 \n69     def handle_error(self, request, client_address):\n70         if is_broken_pipe_error():\n71             logger.info(\"- Broken pipe from %s\\n\", client_address)\n72         else:\n73             super().handle_error(request, client_address)\n",
        "intended_behavior": "Given that no specific method is identified as problematic, the intended behavior in WSGIServer would align with ensuring consistency in logging datetime formats, as mentioned. While WSGIServer might not directly exhibit the inconsistency issue, ensuring it uses a consistent, configurable datetime format for logging purposes, that matches or is easily aligned with WSGIRequestHandler, would be vital. This could mean adjusting how WSGIServer logs messages to use a standard, possibly overridden via settings, datetime format for its log entries."
    }
]