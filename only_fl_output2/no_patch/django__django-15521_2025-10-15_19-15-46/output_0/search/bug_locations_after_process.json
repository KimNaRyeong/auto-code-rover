[
    {
        "rel_file_path": "django/core/management/commands/makemessages.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__4.2/django/core/management/commands/makemessages.py",
        "start": 1,
        "end": 752,
        "class_name": null,
        "method_name": null,
        "code": "1 import glob\n2 import os\n3 import re\n4 import sys\n5 from functools import total_ordering\n6 from itertools import dropwhile\n7 from pathlib import Path\n8 \n9 import django\n10 from django.conf import settings\n11 from django.core.exceptions import ImproperlyConfigured\n12 from django.core.files.temp import NamedTemporaryFile\n13 from django.core.management.base import BaseCommand, CommandError\n14 from django.core.management.utils import (\n15     find_command,\n16     handle_extensions,\n17     is_ignored_path,\n18     popen_wrapper,\n19 )\n20 from django.utils.encoding import DEFAULT_LOCALE_ENCODING\n21 from django.utils.functional import cached_property\n22 from django.utils.jslex import prepare_js_for_gettext\n23 from django.utils.regex_helper import _lazy_re_compile\n24 from django.utils.text import get_text_list\n25 from django.utils.translation import templatize\n26 \n27 plural_forms_re = _lazy_re_compile(\n28     r'^(?P<value>\"Plural-Forms.+?\\\\n\")\\s*$', re.MULTILINE | re.DOTALL\n29 )\n30 STATUS_OK = 0\n31 NO_LOCALE_DIR = object()\n32 \n33 \n34 def check_programs(*programs):\n35     for program in programs:\n36         if find_command(program) is None:\n37             raise CommandError(\n38                 \"Can't find %s. Make sure you have GNU gettext tools 0.15 or \"\n39                 \"newer installed.\" % program\n40             )\n41 \n42 \n43 @total_ordering\n44 class TranslatableFile:\n45     def __init__(self, dirpath, file_name, locale_dir):\n46         self.file = file_name\n47         self.dirpath = dirpath\n48         self.locale_dir = locale_dir\n49 \n50     def __repr__(self):\n51         return \"<%s: %s>\" % (\n52             self.__class__.__name__,\n53             os.sep.join([self.dirpath, self.file]),\n54         )\n55 \n56     def __eq__(self, other):\n57         return self.path == other.path\n58 \n59     def __lt__(self, other):\n60         return self.path < other.path\n61 \n62     @property\n63     def path(self):\n64         return os.path.join(self.dirpath, self.file)\n65 \n66 \n67 class BuildFile:\n68     \"\"\"\n69     Represent the state of a translatable file during the build process.\n70     \"\"\"\n71 \n72     def __init__(self, command, domain, translatable):\n73         self.command = command\n74         self.domain = domain\n75         self.translatable = translatable\n76 \n77     @cached_property\n78     def is_templatized(self):\n79         if self.domain == \"djangojs\":\n80             return self.command.gettext_version < (0, 18, 3)\n81         elif self.domain == \"django\":\n82             file_ext = os.path.splitext(self.translatable.file)[1]\n83             return file_ext != \".py\"\n84         return False\n85 \n86     @cached_property\n87     def path(self):\n88         return self.translatable.path\n89 \n90     @cached_property\n91     def work_path(self):\n92         \"\"\"\n93         Path to a file which is being fed into GNU gettext pipeline. This may\n94         be either a translatable or its preprocessed version.\n95         \"\"\"\n96         if not self.is_templatized:\n97             return self.path\n98         extension = {\n99             \"djangojs\": \"c\",\n100             \"django\": \"py\",\n101         }.get(self.domain)\n102         filename = \"%s.%s\" % (self.translatable.file, extension)\n103         return os.path.join(self.translatable.dirpath, filename)\n104 \n105     def preprocess(self):\n106         \"\"\"\n107         Preprocess (if necessary) a translatable file before passing it to\n108         xgettext GNU gettext utility.\n109         \"\"\"\n110         if not self.is_templatized:\n111             return\n112 \n113         with open(self.path, encoding=\"utf-8\") as fp:\n114             src_data = fp.read()\n115 \n116         if self.domain == \"djangojs\":\n117             content = prepare_js_for_gettext(src_data)\n118         elif self.domain == \"django\":\n119             content = templatize(src_data, origin=self.path[2:])\n120 \n121         with open(self.work_path, \"w\", encoding=\"utf-8\") as fp:\n122             fp.write(content)\n123 \n124     def postprocess_messages(self, msgs):\n125         \"\"\"\n126         Postprocess messages generated by xgettext GNU gettext utility.\n127 \n128         Transform paths as if these messages were generated from original\n129         translatable files rather than from preprocessed versions.\n130         \"\"\"\n131         if not self.is_templatized:\n132             return msgs\n133 \n134         # Remove '.py' suffix\n135         if os.name == \"nt\":\n136             # Preserve '.\\' prefix on Windows to respect gettext behavior\n137             old_path = self.work_path\n138             new_path = self.path\n139         else:\n140             old_path = self.work_path[2:]\n141             new_path = self.path[2:]\n142 \n143         return re.sub(\n144             r\"^(#: .*)(\" + re.escape(old_path) + r\")\",\n145             lambda match: match[0].replace(old_path, new_path),\n146             msgs,\n147             flags=re.MULTILINE,\n148         )\n149 \n150     def cleanup(self):\n151         \"\"\"\n152         Remove a preprocessed copy of a translatable file (if any).\n153         \"\"\"\n154         if self.is_templatized:\n155             # This check is needed for the case of a symlinked file and its\n156             # source being processed inside a single group (locale dir);\n157             # removing either of those two removes both.\n158             if os.path.exists(self.work_path):\n159                 os.unlink(self.work_path)\n160 \n161 \n162 def normalize_eols(raw_contents):\n163     \"\"\"\n164     Take a block of raw text that will be passed through str.splitlines() to\n165     get universal newlines treatment.\n166 \n167     Return the resulting block of text with normalized `\\n` EOL sequences ready\n168     to be written to disk using current platform's native EOLs.\n169     \"\"\"\n170     lines_list = raw_contents.splitlines()\n171     # Ensure last line has its EOL\n172     if lines_list and lines_list[-1]:\n173         lines_list.append(\"\")\n174     return \"\\n\".join(lines_list)\n175 \n176 \n177 def write_pot_file(potfile, msgs):\n178     \"\"\"\n179     Write the `potfile` with the `msgs` contents, making sure its format is\n180     valid.\n181     \"\"\"\n182     pot_lines = msgs.splitlines()\n183     if os.path.exists(potfile):\n184         # Strip the header\n185         lines = dropwhile(len, pot_lines)\n186     else:\n187         lines = []\n188         found, header_read = False, False\n189         for line in pot_lines:\n190             if not found and not header_read:\n191                 if \"charset=CHARSET\" in line:\n192                     found = True\n193                     line = line.replace(\"charset=CHARSET\", \"charset=UTF-8\")\n194             if not line and not found:\n195                 header_read = True\n196             lines.append(line)\n197     msgs = \"\\n\".join(lines)\n198     # Force newlines of POT files to '\\n' to work around\n199     # https://savannah.gnu.org/bugs/index.php?52395\n200     with open(potfile, \"a\", encoding=\"utf-8\", newline=\"\\n\") as fp:\n201         fp.write(msgs)\n202 \n203 \n204 class Command(BaseCommand):\n205     help = (\n206         \"Runs over the entire source tree of the current directory and pulls out all \"\n207         \"strings marked for translation. It creates (or updates) a message file in the \"\n208         \"conf/locale (in the django tree) or locale (for projects and applications) \"\n209         \"directory.\\n\\nYou must run this command with one of either the --locale, \"\n210         \"--exclude, or --all options.\"\n211     )\n212 \n213     translatable_file_class = TranslatableFile\n214     build_file_class = BuildFile\n215 \n216     requires_system_checks = []\n217 \n218     msgmerge_options = [\"-q\", \"--backup=none\", \"--previous\", \"--update\"]\n219     msguniq_options = [\"--to-code=utf-8\"]\n220     msgattrib_options = [\"--no-obsolete\"]\n221     xgettext_options = [\"--from-code=UTF-8\", \"--add-comments=Translators\"]\n222 \n223     def add_arguments(self, parser):\n224         parser.add_argument(\n225             \"--locale\",\n226             \"-l\",\n227             default=[],\n228             action=\"append\",\n229             help=(\n230                 \"Creates or updates the message files for the given locale(s) (e.g. \"\n231                 \"pt_BR). Can be used multiple times.\"\n232             ),\n233         )\n234         parser.add_argument(\n235             \"--exclude\",\n236             \"-x\",\n237             default=[],\n238             action=\"append\",\n239             help=\"Locales to exclude. Default is none. Can be used multiple times.\",\n240         )\n241         parser.add_argument(\n242             \"--domain\",\n243             \"-d\",\n244             default=\"django\",\n245             help='The domain of the message files (default: \"django\").',\n246         )\n247         parser.add_argument(\n248             \"--all\",\n249             \"-a\",\n250             action=\"store_true\",\n251             help=\"Updates the message files for all existing locales.\",\n252         )\n253         parser.add_argument(\n254             \"--extension\",\n255             \"-e\",\n256             dest=\"extensions\",\n257             action=\"append\",\n258             help='The file extension(s) to examine (default: \"html,txt,py\", or \"js\" '\n259             'if the domain is \"djangojs\"). Separate multiple extensions with '\n260             \"commas, or use -e multiple times.\",\n261         )\n262         parser.add_argument(\n263             \"--symlinks\",\n264             \"-s\",\n265             action=\"store_true\",\n266             help=\"Follows symlinks to directories when examining source code \"\n267             \"and templates for translation strings.\",\n268         )\n269         parser.add_argument(\n270             \"--ignore\",\n271             \"-i\",\n272             action=\"append\",\n273             dest=\"ignore_patterns\",\n274             default=[],\n275             metavar=\"PATTERN\",\n276             help=\"Ignore files or directories matching this glob-style pattern. \"\n277             \"Use multiple times to ignore more.\",\n278         )\n279         parser.add_argument(\n280             \"--no-default-ignore\",\n281             action=\"store_false\",\n282             dest=\"use_default_ignore_patterns\",\n283             help=(\n284                 \"Don't ignore the common glob-style patterns 'CVS', '.*', '*~' and \"\n285                 \"'*.pyc'.\"\n286             ),\n287         )\n288         parser.add_argument(\n289             \"--no-wrap\",\n290             action=\"store_true\",\n291             help=\"Don't break long message lines into several lines.\",\n292         )\n293         parser.add_argument(\n294             \"--no-location\",\n295             action=\"store_true\",\n296             help=\"Don't write '#: filename:line' lines.\",\n297         )\n298         parser.add_argument(\n299             \"--add-location\",\n300             choices=(\"full\", \"file\", \"never\"),\n301             const=\"full\",\n302             nargs=\"?\",\n303             help=(\n304                 \"Controls '#: filename:line' lines. If the option is 'full' \"\n305                 \"(the default if not given), the lines  include both file name \"\n306                 \"and line number. If it's 'file', the line number is omitted. If \"\n307                 \"it's 'never', the lines are suppressed (same as --no-location). \"\n308                 \"--add-location requires gettext 0.19 or newer.\"\n309             ),\n310         )\n311         parser.add_argument(\n312             \"--no-obsolete\",\n313             action=\"store_true\",\n314             help=\"Remove obsolete message strings.\",\n315         )\n316         parser.add_argument(\n317             \"--keep-pot\",\n318             action=\"store_true\",\n319             help=\"Keep .pot file after making messages. Useful when debugging.\",\n320         )\n321 \n322     def handle(self, *args, **options):\n323         locale = options[\"locale\"]\n324         exclude = options[\"exclude\"]\n325         self.domain = options[\"domain\"]\n326         self.verbosity = options[\"verbosity\"]\n327         process_all = options[\"all\"]\n328         extensions = options[\"extensions\"]\n329         self.symlinks = options[\"symlinks\"]\n330 \n331         ignore_patterns = options[\"ignore_patterns\"]\n332         if options[\"use_default_ignore_patterns\"]:\n333             ignore_patterns += [\"CVS\", \".*\", \"*~\", \"*.pyc\"]\n334         self.ignore_patterns = list(set(ignore_patterns))\n335 \n336         # Avoid messing with mutable class variables\n337         if options[\"no_wrap\"]:\n338             self.msgmerge_options = self.msgmerge_options[:] + [\"--no-wrap\"]\n339             self.msguniq_options = self.msguniq_options[:] + [\"--no-wrap\"]\n340             self.msgattrib_options = self.msgattrib_options[:] + [\"--no-wrap\"]\n341             self.xgettext_options = self.xgettext_options[:] + [\"--no-wrap\"]\n342         if options[\"no_location\"]:\n343             self.msgmerge_options = self.msgmerge_options[:] + [\"--no-location\"]\n344             self.msguniq_options = self.msguniq_options[:] + [\"--no-location\"]\n345             self.msgattrib_options = self.msgattrib_options[:] + [\"--no-location\"]\n346             self.xgettext_options = self.xgettext_options[:] + [\"--no-location\"]\n347         if options[\"add_location\"]:\n348             if self.gettext_version < (0, 19):\n349                 raise CommandError(\n350                     \"The --add-location option requires gettext 0.19 or later. \"\n351                     \"You have %s.\" % \".\".join(str(x) for x in self.gettext_version)\n352                 )\n353             arg_add_location = \"--add-location=%s\" % options[\"add_location\"]\n354             self.msgmerge_options = self.msgmerge_options[:] + [arg_add_location]\n355             self.msguniq_options = self.msguniq_options[:] + [arg_add_location]\n356             self.msgattrib_options = self.msgattrib_options[:] + [arg_add_location]\n357             self.xgettext_options = self.xgettext_options[:] + [arg_add_location]\n358 \n359         self.no_obsolete = options[\"no_obsolete\"]\n360         self.keep_pot = options[\"keep_pot\"]\n361 \n362         if self.domain not in (\"django\", \"djangojs\"):\n363             raise CommandError(\n364                 \"currently makemessages only supports domains \"\n365                 \"'django' and 'djangojs'\"\n366             )\n367         if self.domain == \"djangojs\":\n368             exts = extensions or [\"js\"]\n369         else:\n370             exts = extensions or [\"html\", \"txt\", \"py\"]\n371         self.extensions = handle_extensions(exts)\n372 \n373         if (not locale and not exclude and not process_all) or self.domain is None:\n374             raise CommandError(\n375                 \"Type '%s help %s' for usage information.\"\n376                 % (os.path.basename(sys.argv[0]), sys.argv[1])\n377             )\n378 \n379         if self.verbosity > 1:\n380             self.stdout.write(\n381                 \"examining files with the extensions: %s\"\n382                 % get_text_list(list(self.extensions), \"and\")\n383             )\n384 \n385         self.invoked_for_django = False\n386         self.locale_paths = []\n387         self.default_locale_path = None\n388         if os.path.isdir(os.path.join(\"conf\", \"locale\")):\n389             self.locale_paths = [os.path.abspath(os.path.join(\"conf\", \"locale\"))]\n390             self.default_locale_path = self.locale_paths[0]\n391             self.invoked_for_django = True\n392         else:\n393             if self.settings_available:\n394                 self.locale_paths.extend(settings.LOCALE_PATHS)\n395             # Allow to run makemessages inside an app dir\n396             if os.path.isdir(\"locale\"):\n397                 self.locale_paths.append(os.path.abspath(\"locale\"))\n398             if self.locale_paths:\n399                 self.default_locale_path = self.locale_paths[0]\n400                 os.makedirs(self.default_locale_path, exist_ok=True)\n401 \n402         # Build locale list\n403         looks_like_locale = re.compile(r\"[a-z]{2}\")\n404         locale_dirs = filter(\n405             os.path.isdir, glob.glob(\"%s/*\" % self.default_locale_path)\n406         )\n407         all_locales = [\n408             lang_code\n409             for lang_code in map(os.path.basename, locale_dirs)\n410             if looks_like_locale.match(lang_code)\n411         ]\n412 \n413         # Account for excluded locales\n414         if process_all:\n415             locales = all_locales\n416         else:\n417             locales = locale or all_locales\n418             locales = set(locales).difference(exclude)\n419 \n420         if locales:\n421             check_programs(\"msguniq\", \"msgmerge\", \"msgattrib\")\n422 \n423         check_programs(\"xgettext\")\n424 \n425         try:\n426             potfiles = self.build_potfiles()\n427 \n428             # Build po files for each selected locale\n429             for locale in locales:\n430                 if \"-\" in locale:\n431                     self.stdout.write(\n432                         \"invalid locale %s, did you mean %s?\"\n433                         % (\n434                             locale,\n435                             locale.replace(\"-\", \"_\"),\n436                         ),\n437                     )\n438                     continue\n439                 if self.verbosity > 0:\n440                     self.stdout.write(\"processing locale %s\" % locale)\n441                 for potfile in potfiles:\n442                     self.write_po_file(potfile, locale)\n443         finally:\n444             if not self.keep_pot:\n445                 self.remove_potfiles()\n446 \n447     @cached_property\n448     def gettext_version(self):\n449         # Gettext tools will output system-encoded bytestrings instead of UTF-8,\n450         # when looking up the version. It's especially a problem on Windows.\n451         out, err, status = popen_wrapper(\n452             [\"xgettext\", \"--version\"],\n453             stdout_encoding=DEFAULT_LOCALE_ENCODING,\n454         )\n455         m = re.search(r\"(\\d+)\\.(\\d+)\\.?(\\d+)?\", out)\n456         if m:\n457             return tuple(int(d) for d in m.groups() if d is not None)\n458         else:\n459             raise CommandError(\"Unable to get gettext version. Is it installed?\")\n460 \n461     @cached_property\n462     def settings_available(self):\n463         try:\n464             settings.LOCALE_PATHS\n465         except ImproperlyConfigured:\n466             if self.verbosity > 1:\n467                 self.stderr.write(\"Running without configured settings.\")\n468             return False\n469         return True\n470 \n471     def build_potfiles(self):\n472         \"\"\"\n473         Build pot files and apply msguniq to them.\n474         \"\"\"\n475         file_list = self.find_files(\".\")\n476         self.remove_potfiles()\n477         self.process_files(file_list)\n478         potfiles = []\n479         for path in self.locale_paths:\n480             potfile = os.path.join(path, \"%s.pot\" % self.domain)\n481             if not os.path.exists(potfile):\n482                 continue\n483             args = [\"msguniq\"] + self.msguniq_options + [potfile]\n484             msgs, errors, status = popen_wrapper(args)\n485             if errors:\n486                 if status != STATUS_OK:\n487                     raise CommandError(\n488                         \"errors happened while running msguniq\\n%s\" % errors\n489                     )\n490                 elif self.verbosity > 0:\n491                     self.stdout.write(errors)\n492             msgs = normalize_eols(msgs)\n493             with open(potfile, \"w\", encoding=\"utf-8\") as fp:\n494                 fp.write(msgs)\n495             potfiles.append(potfile)\n496         return potfiles\n497 \n498     def remove_potfiles(self):\n499         for path in self.locale_paths:\n500             pot_path = os.path.join(path, \"%s.pot\" % self.domain)\n501             if os.path.exists(pot_path):\n502                 os.unlink(pot_path)\n503 \n504     def find_files(self, root):\n505         \"\"\"\n506         Get all files in the given root. Also check that there is a matching\n507         locale dir for each file.\n508         \"\"\"\n509         all_files = []\n510         ignored_roots = []\n511         if self.settings_available:\n512             ignored_roots = [\n513                 os.path.normpath(p)\n514                 for p in (settings.MEDIA_ROOT, settings.STATIC_ROOT)\n515                 if p\n516             ]\n517         for dirpath, dirnames, filenames in os.walk(\n518             root, topdown=True, followlinks=self.symlinks\n519         ):\n520             for dirname in dirnames[:]:\n521                 if (\n522                     is_ignored_path(\n523                         os.path.normpath(os.path.join(dirpath, dirname)),\n524                         self.ignore_patterns,\n525                     )\n526                     or os.path.join(os.path.abspath(dirpath), dirname) in ignored_roots\n527                 ):\n528                     dirnames.remove(dirname)\n529                     if self.verbosity > 1:\n530                         self.stdout.write(\"ignoring directory %s\" % dirname)\n531                 elif dirname == \"locale\":\n532                     dirnames.remove(dirname)\n533                     self.locale_paths.insert(\n534                         0, os.path.join(os.path.abspath(dirpath), dirname)\n535                     )\n536             for filename in filenames:\n537                 file_path = os.path.normpath(os.path.join(dirpath, filename))\n538                 file_ext = os.path.splitext(filename)[1]\n539                 if file_ext not in self.extensions or is_ignored_path(\n540                     file_path, self.ignore_patterns\n541                 ):\n542                     if self.verbosity > 1:\n543                         self.stdout.write(\n544                             \"ignoring file %s in %s\" % (filename, dirpath)\n545                         )\n546                 else:\n547                     locale_dir = None\n548                     for path in self.locale_paths:\n549                         if os.path.abspath(dirpath).startswith(os.path.dirname(path)):\n550                             locale_dir = path\n551                             break\n552                     locale_dir = locale_dir or self.default_locale_path or NO_LOCALE_DIR\n553                     all_files.append(\n554                         self.translatable_file_class(dirpath, filename, locale_dir)\n555                     )\n556         return sorted(all_files)\n557 \n558     def process_files(self, file_list):\n559         \"\"\"\n560         Group translatable files by locale directory and run pot file build\n561         process for each group.\n562         \"\"\"\n563         file_groups = {}\n564         for translatable in file_list:\n565             file_group = file_groups.setdefault(translatable.locale_dir, [])\n566             file_group.append(translatable)\n567         for locale_dir, files in file_groups.items():\n568             self.process_locale_dir(locale_dir, files)\n569 \n570     def process_locale_dir(self, locale_dir, files):\n571         \"\"\"\n572         Extract translatable literals from the specified files, creating or\n573         updating the POT file for a given locale directory.\n574 \n575         Use the xgettext GNU gettext utility.\n576         \"\"\"\n577         build_files = []\n578         for translatable in files:\n579             if self.verbosity > 1:\n580                 self.stdout.write(\n581                     \"processing file %s in %s\"\n582                     % (translatable.file, translatable.dirpath)\n583                 )\n584             if self.domain not in (\"djangojs\", \"django\"):\n585                 continue\n586             build_file = self.build_file_class(self, self.domain, translatable)\n587             try:\n588                 build_file.preprocess()\n589             except UnicodeDecodeError as e:\n590                 self.stdout.write(\n591                     \"UnicodeDecodeError: skipped file %s in %s (reason: %s)\"\n592                     % (\n593                         translatable.file,\n594                         translatable.dirpath,\n595                         e,\n596                     )\n597                 )\n598                 continue\n599             except BaseException:\n600                 # Cleanup before exit.\n601                 for build_file in build_files:\n602                     build_file.cleanup()\n603                 raise\n604             build_files.append(build_file)\n605 \n606         if self.domain == \"djangojs\":\n607             is_templatized = build_file.is_templatized\n608             args = [\n609                 \"xgettext\",\n610                 \"-d\",\n611                 self.domain,\n612                 \"--language=%s\" % (\"C\" if is_templatized else \"JavaScript\",),\n613                 \"--keyword=gettext_noop\",\n614                 \"--keyword=gettext_lazy\",\n615                 \"--keyword=ngettext_lazy:1,2\",\n616                 \"--keyword=pgettext:1c,2\",\n617                 \"--keyword=npgettext:1c,2,3\",\n618                 \"--output=-\",\n619             ]\n620         elif self.domain == \"django\":\n621             args = [\n622                 \"xgettext\",\n623                 \"-d\",\n624                 self.domain,\n625                 \"--language=Python\",\n626                 \"--keyword=gettext_noop\",\n627                 \"--keyword=gettext_lazy\",\n628                 \"--keyword=ngettext_lazy:1,2\",\n629                 \"--keyword=pgettext:1c,2\",\n630                 \"--keyword=npgettext:1c,2,3\",\n631                 \"--keyword=pgettext_lazy:1c,2\",\n632                 \"--keyword=npgettext_lazy:1c,2,3\",\n633                 \"--output=-\",\n634             ]\n635         else:\n636             return\n637 \n638         input_files = [bf.work_path for bf in build_files]\n639         with NamedTemporaryFile(mode=\"w+\") as input_files_list:\n640             input_files_list.write(\"\\n\".join(input_files))\n641             input_files_list.flush()\n642             args.extend([\"--files-from\", input_files_list.name])\n643             args.extend(self.xgettext_options)\n644             msgs, errors, status = popen_wrapper(args)\n645 \n646         if errors:\n647             if status != STATUS_OK:\n648                 for build_file in build_files:\n649                     build_file.cleanup()\n650                 raise CommandError(\n651                     \"errors happened while running xgettext on %s\\n%s\"\n652                     % (\"\\n\".join(input_files), errors)\n653                 )\n654             elif self.verbosity > 0:\n655                 # Print warnings\n656                 self.stdout.write(errors)\n657 \n658         if msgs:\n659             if locale_dir is NO_LOCALE_DIR:\n660                 for build_file in build_files:\n661                     build_file.cleanup()\n662                 file_path = os.path.normpath(build_files[0].path)\n663                 raise CommandError(\n664                     \"Unable to find a locale path to store translations for \"\n665                     \"file %s. Make sure the 'locale' directory exists in an \"\n666                     \"app or LOCALE_PATHS setting is set.\" % file_path\n667                 )\n668             for build_file in build_files:\n669                 msgs = build_file.postprocess_messages(msgs)\n670             potfile = os.path.join(locale_dir, \"%s.pot\" % self.domain)\n671             write_pot_file(potfile, msgs)\n672 \n673         for build_file in build_files:\n674             build_file.cleanup()\n675 \n676     def write_po_file(self, potfile, locale):\n677         \"\"\"\n678         Create or update the PO file for self.domain and `locale`.\n679         Use contents of the existing `potfile`.\n680 \n681         Use msgmerge and msgattrib GNU gettext utilities.\n682         \"\"\"\n683         basedir = os.path.join(os.path.dirname(potfile), locale, \"LC_MESSAGES\")\n684         os.makedirs(basedir, exist_ok=True)\n685         pofile = os.path.join(basedir, \"%s.po\" % self.domain)\n686 \n687         if os.path.exists(pofile):\n688             args = [\"msgmerge\"] + self.msgmerge_options + [pofile, potfile]\n689             _, errors, status = popen_wrapper(args)\n690             if errors:\n691                 if status != STATUS_OK:\n692                     raise CommandError(\n693                         \"errors happened while running msgmerge\\n%s\" % errors\n694                     )\n695                 elif self.verbosity > 0:\n696                     self.stdout.write(errors)\n697             msgs = Path(pofile).read_text(encoding=\"utf-8\")\n698         else:\n699             with open(potfile, encoding=\"utf-8\") as fp:\n700                 msgs = fp.read()\n701             if not self.invoked_for_django:\n702                 msgs = self.copy_plural_forms(msgs, locale)\n703         msgs = normalize_eols(msgs)\n704         msgs = msgs.replace(\n705             \"#. #-#-#-#-#  %s.pot (PACKAGE VERSION)  #-#-#-#-#\\n\" % self.domain, \"\"\n706         )\n707         with open(pofile, \"w\", encoding=\"utf-8\") as fp:\n708             fp.write(msgs)\n709 \n710         if self.no_obsolete:\n711             args = [\"msgattrib\"] + self.msgattrib_options + [\"-o\", pofile, pofile]\n712             msgs, errors, status = popen_wrapper(args)\n713             if errors:\n714                 if status != STATUS_OK:\n715                     raise CommandError(\n716                         \"errors happened while running msgattrib\\n%s\" % errors\n717                     )\n718                 elif self.verbosity > 0:\n719                     self.stdout.write(errors)\n720 \n721     def copy_plural_forms(self, msgs, locale):\n722         \"\"\"\n723         Copy plural forms header contents from a Django catalog of locale to\n724         the msgs string, inserting it at the right place. msgs should be the\n725         contents of a newly created .po file.\n726         \"\"\"\n727         django_dir = os.path.normpath(os.path.join(os.path.dirname(django.__file__)))\n728         if self.domain == \"djangojs\":\n729             domains = (\"djangojs\", \"django\")\n730         else:\n731             domains = (\"django\",)\n732         for domain in domains:\n733             django_po = os.path.join(\n734                 django_dir, \"conf\", \"locale\", locale, \"LC_MESSAGES\", \"%s.po\" % domain\n735             )\n736             if os.path.exists(django_po):\n737                 with open(django_po, encoding=\"utf-8\") as fp:\n738                     m = plural_forms_re.search(fp.read())\n739                 if m:\n740                     plural_form_line = m[\"value\"]\n741                     if self.verbosity > 1:\n742                         self.stdout.write(\"copying plural forms: %s\" % plural_form_line)\n743                     lines = []\n744                     found = False\n745                     for line in msgs.splitlines():\n746                         if not found and (not line or plural_forms_re.search(line)):\n747                             line = plural_form_line\n748                             found = True\n749                         lines.append(line)\n750                     msgs = \"\\n\".join(lines)\n751                     break\n752         return msgs\n",
        "intended_behavior": "The code here should correctly parse and validate extended locale formats, like nl-nl-x-informal, converting them into the expected directory structure format (nl_NL-x-informal) without triggering a validation error."
    },
    {
        "rel_file_path": "django/utils/translation/__init__.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__4.2/django/utils/translation/__init__.py",
        "start": 1,
        "end": 301,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2 Internationalization support.\n3 \"\"\"\n4 from contextlib import ContextDecorator\n5 from decimal import ROUND_UP, Decimal\n6 \n7 from django.utils.autoreload import autoreload_started, file_changed\n8 from django.utils.functional import lazy\n9 from django.utils.regex_helper import _lazy_re_compile\n10 \n11 __all__ = [\n12     \"activate\",\n13     \"deactivate\",\n14     \"override\",\n15     \"deactivate_all\",\n16     \"get_language\",\n17     \"get_language_from_request\",\n18     \"get_language_info\",\n19     \"get_language_bidi\",\n20     \"check_for_language\",\n21     \"to_language\",\n22     \"to_locale\",\n23     \"templatize\",\n24     \"gettext\",\n25     \"gettext_lazy\",\n26     \"gettext_noop\",\n27     \"ngettext\",\n28     \"ngettext_lazy\",\n29     \"pgettext\",\n30     \"pgettext_lazy\",\n31     \"npgettext\",\n32     \"npgettext_lazy\",\n33 ]\n34 \n35 \n36 class TranslatorCommentWarning(SyntaxWarning):\n37     pass\n38 \n39 \n40 # Here be dragons, so a short explanation of the logic won't hurt:\n41 # We are trying to solve two problems: (1) access settings, in particular\n42 # settings.USE_I18N, as late as possible, so that modules can be imported\n43 # without having to first configure Django, and (2) if some other code creates\n44 # a reference to one of these functions, don't break that reference when we\n45 # replace the functions with their real counterparts (once we do access the\n46 # settings).\n47 \n48 \n49 class Trans:\n50     \"\"\"\n51     The purpose of this class is to store the actual translation function upon\n52     receiving the first call to that function. After this is done, changes to\n53     USE_I18N will have no effect to which function is served upon request. If\n54     your tests rely on changing USE_I18N, you can delete all the functions\n55     from _trans.__dict__.\n56 \n57     Note that storing the function with setattr will have a noticeable\n58     performance effect, as access to the function goes the normal path,\n59     instead of using __getattr__.\n60     \"\"\"\n61 \n62     def __getattr__(self, real_name):\n63         from django.conf import settings\n64 \n65         if settings.USE_I18N:\n66             from django.utils.translation import trans_real as trans\n67             from django.utils.translation.reloader import (\n68                 translation_file_changed,\n69                 watch_for_translation_changes,\n70             )\n71 \n72             autoreload_started.connect(\n73                 watch_for_translation_changes, dispatch_uid=\"translation_file_changed\"\n74             )\n75             file_changed.connect(\n76                 translation_file_changed, dispatch_uid=\"translation_file_changed\"\n77             )\n78         else:\n79             from django.utils.translation import trans_null as trans\n80         setattr(self, real_name, getattr(trans, real_name))\n81         return getattr(trans, real_name)\n82 \n83 \n84 _trans = Trans()\n85 \n86 # The Trans class is no more needed, so remove it from the namespace.\n87 del Trans\n88 \n89 \n90 def gettext_noop(message):\n91     return _trans.gettext_noop(message)\n92 \n93 \n94 def gettext(message):\n95     return _trans.gettext(message)\n96 \n97 \n98 def ngettext(singular, plural, number):\n99     return _trans.ngettext(singular, plural, number)\n100 \n101 \n102 def pgettext(context, message):\n103     return _trans.pgettext(context, message)\n104 \n105 \n106 def npgettext(context, singular, plural, number):\n107     return _trans.npgettext(context, singular, plural, number)\n108 \n109 \n110 gettext_lazy = lazy(gettext, str)\n111 pgettext_lazy = lazy(pgettext, str)\n112 \n113 \n114 def lazy_number(func, resultclass, number=None, **kwargs):\n115     if isinstance(number, int):\n116         kwargs[\"number\"] = number\n117         proxy = lazy(func, resultclass)(**kwargs)\n118     else:\n119         original_kwargs = kwargs.copy()\n120 \n121         class NumberAwareString(resultclass):\n122             def __bool__(self):\n123                 return bool(kwargs[\"singular\"])\n124 \n125             def _get_number_value(self, values):\n126                 try:\n127                     return values[number]\n128                 except KeyError:\n129                     raise KeyError(\n130                         \"Your dictionary lacks key '%s'. Please provide \"\n131                         \"it, because it is required to determine whether \"\n132                         \"string is singular or plural.\" % number\n133                     )\n134 \n135             def _translate(self, number_value):\n136                 kwargs[\"number\"] = number_value\n137                 return func(**kwargs)\n138 \n139             def format(self, *args, **kwargs):\n140                 number_value = (\n141                     self._get_number_value(kwargs) if kwargs and number else args[0]\n142                 )\n143                 return self._translate(number_value).format(*args, **kwargs)\n144 \n145             def __mod__(self, rhs):\n146                 if isinstance(rhs, dict) and number:\n147                     number_value = self._get_number_value(rhs)\n148                 else:\n149                     number_value = rhs\n150                 translated = self._translate(number_value)\n151                 try:\n152                     translated = translated % rhs\n153                 except TypeError:\n154                     # String doesn't contain a placeholder for the number.\n155                     pass\n156                 return translated\n157 \n158         proxy = lazy(lambda **kwargs: NumberAwareString(), NumberAwareString)(**kwargs)\n159         proxy.__reduce__ = lambda: (\n160             _lazy_number_unpickle,\n161             (func, resultclass, number, original_kwargs),\n162         )\n163     return proxy\n164 \n165 \n166 def _lazy_number_unpickle(func, resultclass, number, kwargs):\n167     return lazy_number(func, resultclass, number=number, **kwargs)\n168 \n169 \n170 def ngettext_lazy(singular, plural, number=None):\n171     return lazy_number(ngettext, str, singular=singular, plural=plural, number=number)\n172 \n173 \n174 def npgettext_lazy(context, singular, plural, number=None):\n175     return lazy_number(\n176         npgettext, str, context=context, singular=singular, plural=plural, number=number\n177     )\n178 \n179 \n180 def activate(language):\n181     return _trans.activate(language)\n182 \n183 \n184 def deactivate():\n185     return _trans.deactivate()\n186 \n187 \n188 class override(ContextDecorator):\n189     def __init__(self, language, deactivate=False):\n190         self.language = language\n191         self.deactivate = deactivate\n192 \n193     def __enter__(self):\n194         self.old_language = get_language()\n195         if self.language is not None:\n196             activate(self.language)\n197         else:\n198             deactivate_all()\n199 \n200     def __exit__(self, exc_type, exc_value, traceback):\n201         if self.old_language is None:\n202             deactivate_all()\n203         elif self.deactivate:\n204             deactivate()\n205         else:\n206             activate(self.old_language)\n207 \n208 \n209 def get_language():\n210     return _trans.get_language()\n211 \n212 \n213 def get_language_bidi():\n214     return _trans.get_language_bidi()\n215 \n216 \n217 def check_for_language(lang_code):\n218     return _trans.check_for_language(lang_code)\n219 \n220 \n221 def to_language(locale):\n222     \"\"\"Turn a locale name (en_US) into a language name (en-us).\"\"\"\n223     p = locale.find(\"_\")\n224     if p >= 0:\n225         return locale[:p].lower() + \"-\" + locale[p + 1 :].lower()\n226     else:\n227         return locale.lower()\n228 \n229 \n230 def to_locale(language):\n231     \"\"\"Turn a language name (en-us) into a locale name (en_US).\"\"\"\n232     lang, _, country = language.lower().partition(\"-\")\n233     if not country:\n234         return language[:3].lower() + language[3:]\n235     # A language with > 2 characters after the dash only has its first\n236     # character after the dash capitalized; e.g. sr-latn becomes sr_Latn.\n237     # A language with 2 characters after the dash has both characters\n238     # capitalized; e.g. en-us becomes en_US.\n239     country, _, tail = country.partition(\"-\")\n240     country = country.title() if len(country) > 2 else country.upper()\n241     if tail:\n242         country += \"-\" + tail\n243     return lang + \"_\" + country\n244 \n245 \n246 def get_language_from_request(request, check_path=False):\n247     return _trans.get_language_from_request(request, check_path)\n248 \n249 \n250 def get_language_from_path(path):\n251     return _trans.get_language_from_path(path)\n252 \n253 \n254 def get_supported_language_variant(lang_code, *, strict=False):\n255     return _trans.get_supported_language_variant(lang_code, strict)\n256 \n257 \n258 def templatize(src, **kwargs):\n259     from .template import templatize\n260 \n261     return templatize(src, **kwargs)\n262 \n263 \n264 def deactivate_all():\n265     return _trans.deactivate_all()\n266 \n267 \n268 def get_language_info(lang_code):\n269     from django.conf.locale import LANG_INFO\n270 \n271     try:\n272         lang_info = LANG_INFO[lang_code]\n273         if \"fallback\" in lang_info and \"name\" not in lang_info:\n274             info = get_language_info(lang_info[\"fallback\"][0])\n275         else:\n276             info = lang_info\n277     except KeyError:\n278         if \"-\" not in lang_code:\n279             raise KeyError(\"Unknown language code %s.\" % lang_code)\n280         generic_lang_code = lang_code.split(\"-\")[0]\n281         try:\n282             info = LANG_INFO[generic_lang_code]\n283         except KeyError:\n284             raise KeyError(\n285                 \"Unknown language code %s and %s.\" % (lang_code, generic_lang_code)\n286             )\n287 \n288     if info:\n289         info[\"name_translated\"] = gettext_lazy(info[\"name\"])\n290     return info\n291 \n292 \n293 trim_whitespace_re = _lazy_re_compile(r\"\\s*\\n\\s*\")\n294 \n295 \n296 def trim_whitespace(s):\n297     return trim_whitespace_re.sub(\" \", s.strip())\n298 \n299 \n300 def round_away_from_one(value):\n301     return int(Decimal(value - 1).quantize(Decimal(\"0\"), rounding=ROUND_UP)) + 1\n",
        "intended_behavior": "Ensure that the method responsible for converting locale names from the command line input into formats used internally, accurately reflects the handling of standard and extended (custom) locale formats."
    }
]