[
    {
        "rel_file_path": "sympy/parsing/mathematica.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sympy__sympy/setup_sympy__sympy__1.4/sympy/parsing/mathematica.py",
        "start": 1,
        "end": 419,
        "class_name": null,
        "method_name": null,
        "code": "1 from __future__ import print_function, division\n2 \n3 from itertools import product\n4 import re\n5 from sympy import sympify\n6 \n7 \n8 def mathematica(s, additional_translations=None):\n9     '''Users can add their own translation dictionary\n10     # Example\n11     In [1]: mathematica('Log3[9]', {'Log3[x]':'log(x,3)'})\n12     Out[1]: 2\n13     In [2]: mathematica('F[7,5,3]', {'F[*x]':'Max(*x)*Min(*x)'})\n14     Out[2]: 21\n15     variable-length argument needs '*' character '''\n16 \n17     parser = MathematicaParser(additional_translations)\n18     return sympify(parser.parse(s))\n19 \n20 \n21 def _deco(cls):\n22     cls._initialize_class()\n23     return cls\n24 \n25 \n26 @_deco\n27 class MathematicaParser(object):\n28     '''An instance of this class converts a string of a basic Mathematica\n29     expression to SymPy style. Output is string type.'''\n30 \n31     # left: Mathematica, right: SymPy\n32     CORRESPONDENCES = {\n33         'Sqrt[x]': 'sqrt(x)',\n34         'Exp[x]': 'exp(x)',\n35         'Log[x]': 'log(x)',\n36         'Log[x,y]': 'log(y,x)',\n37         'Log2[x]': 'log(x,2)',\n38         'Log10[x]': 'log(x,10)',\n39         'Mod[x,y]': 'Mod(x,y)',\n40         'Max[*x]': 'Max(*x)',\n41         'Min[*x]': 'Min(*x)',\n42     }\n43 \n44     # trigonometric, e.t.c.\n45     for arc, tri, h in product(('', 'Arc'), (\n46             'Sin', 'Cos', 'Tan', 'Cot', 'Sec', 'Csc'), ('', 'h')):\n47         fm = arc + tri + h + '[x]'\n48         if arc:  # arc func\n49             fs = 'a' + tri.lower() + h + '(x)'\n50         else:    # non-arc func\n51             fs = tri.lower() + h + '(x)'\n52         CORRESPONDENCES.update({fm: fs})\n53 \n54     REPLACEMENTS = {\n55         ' ': '',\n56         '^': '**',\n57         '{': '[',\n58         '}': ']',\n59     }\n60 \n61     RULES = {\n62         # a single whitespace to '*'\n63         'whitespace': (\n64             re.compile(r'''\n65                 (?<=[a-zA-Z\\d])     # a letter or a number\n66                 \\                   # a whitespace\n67                 (?=[a-zA-Z\\d])      # a letter or a number\n68                 ''', re.VERBOSE),\n69             '*'),\n70 \n71         # add omitted '*' character\n72         'add*_1': (\n73             re.compile(r'''\n74                 (?<=[])\\d])         # ], ) or a number\n75                                     # ''\n76                 (?=[(a-zA-Z])       # ( or a single letter\n77                 ''', re.VERBOSE),\n78             '*'),\n79 \n80         # add omitted '*' character (variable letter preceding)\n81         'add*_2': (\n82             re.compile(r'''\n83                 (?<=[a-zA-Z])       # a letter\n84                 \\(                  # ( as a character\n85                 (?=.)               # any characters\n86                 ''', re.VERBOSE),\n87             '*('),\n88 \n89         # convert 'Pi' to 'pi'\n90         'Pi': (\n91             re.compile(r'''\n92                 (?:\n93                 \\A|(?<=[^a-zA-Z])\n94                 )\n95                 Pi                  # 'Pi' is 3.14159... in Mathematica\n96                 (?=[^a-zA-Z])\n97                 ''', re.VERBOSE),\n98             'pi'),\n99     }\n100 \n101     # Mathematica function name pattern\n102     FM_PATTERN = re.compile(r'''\n103                 (?:\n104                 \\A|(?<=[^a-zA-Z])   # at the top or a non-letter\n105                 )\n106                 [A-Z][a-zA-Z\\d]*    # Function\n107                 (?=\\[)              # [ as a character\n108                 ''', re.VERBOSE)\n109 \n110     # list or matrix pattern (for future usage)\n111     ARG_MTRX_PATTERN = re.compile(r'''\n112                 \\{.*\\}\n113                 ''', re.VERBOSE)\n114 \n115     # regex string for function argument pattern\n116     ARGS_PATTERN_TEMPLATE = r'''\n117                 (?:\n118                 \\A|(?<=[^a-zA-Z])\n119                 )\n120                 {arguments}         # model argument like x, y,...\n121                 (?=[^a-zA-Z])\n122                 '''\n123 \n124     # will contain transformed CORRESPONDENCES dictionary\n125     TRANSLATIONS = {}\n126 \n127     # cache for a raw users' translation dictionary\n128     cache_original = {}\n129 \n130     # cache for a compiled users' translation dictionary\n131     cache_compiled = {}\n132 \n133     @classmethod\n134     def _initialize_class(cls):\n135         # get a transformed CORRESPONDENCES dictionary\n136         d = cls._compile_dictionary(cls.CORRESPONDENCES)\n137         cls.TRANSLATIONS.update(d)\n138 \n139     def __init__(self, additional_translations=None):\n140         self.translations = {}\n141 \n142         # update with TRANSLATIONS (class constant)\n143         self.translations.update(self.TRANSLATIONS)\n144 \n145         if additional_translations is None:\n146             additional_translations = {}\n147 \n148         # check the latest added translations\n149         if self.__class__.cache_original != additional_translations:\n150             if not isinstance(additional_translations, dict):\n151                 raise ValueError('The argument must be dict type')\n152 \n153             # get a transformed additional_translations dictionary\n154             d = self._compile_dictionary(additional_translations)\n155 \n156             # update cache\n157             self.__class__.cache_original = additional_translations\n158             self.__class__.cache_compiled = d\n159 \n160         # merge user's own translations\n161         self.translations.update(self.__class__.cache_compiled)\n162 \n163     @classmethod\n164     def _compile_dictionary(cls, dic):\n165         # for return\n166         d = {}\n167 \n168         for fm, fs in dic.items():\n169             # check function form\n170             cls._check_input(fm)\n171             cls._check_input(fs)\n172 \n173             # uncover '*' hiding behind a whitespace\n174             fm = cls._apply_rules(fm, 'whitespace')\n175             fs = cls._apply_rules(fs, 'whitespace')\n176 \n177             # remove whitespace(s)\n178             fm = cls._replace(fm, ' ')\n179             fs = cls._replace(fs, ' ')\n180 \n181             # search Mathematica function name\n182             m = cls.FM_PATTERN.search(fm)\n183 \n184             # if no-hit\n185             if m is None:\n186                 err = \"'{f}' function form is invalid.\".format(f=fm)\n187                 raise ValueError(err)\n188 \n189             # get Mathematica function name like 'Log'\n190             fm_name = m.group()\n191 \n192             # get arguments of Mathematica function\n193             args, end = cls._get_args(m)\n194 \n195             # function side check. (e.g.) '2*Func[x]' is invalid.\n196             if m.start() != 0 or end != len(fm):\n197                 err = \"'{f}' function form is invalid.\".format(f=fm)\n198                 raise ValueError(err)\n199 \n200             # check the last argument's 1st character\n201             if args[-1][0] == '*':\n202                 key_arg = '*'\n203             else:\n204                 key_arg = len(args)\n205 \n206             key = (fm_name, key_arg)\n207 \n208             # convert '*x' to '\\\\*x' for regex\n209             re_args = [x if x[0] != '*' else '\\\\' + x for x in args]\n210 \n211             # for regex. Example: (?:(x|y|z))\n212             xyz = '(?:(' + '|'.join(re_args) + '))'\n213 \n214             # string for regex compile\n215             patStr = cls.ARGS_PATTERN_TEMPLATE.format(arguments=xyz)\n216 \n217             pat = re.compile(patStr, re.VERBOSE)\n218 \n219             # update dictionary\n220             d[key] = {}\n221             d[key]['fs'] = fs  # SymPy function template\n222             d[key]['args'] = args  # args are ['x', 'y'] for example\n223             d[key]['pat'] = pat\n224 \n225         return d\n226 \n227     def _convert_function(self, s):\n228         '''Parse Mathematica function to SymPy one'''\n229 \n230         # compiled regex object\n231         pat = self.FM_PATTERN\n232 \n233         scanned = ''                # converted string\n234         cur = 0                     # position cursor\n235         while True:\n236             m = pat.search(s)\n237 \n238             if m is None:\n239                 # append the rest of string\n240                 scanned += s\n241                 break\n242 \n243             # get Mathematica function name\n244             fm = m.group()\n245 \n246             # get arguments, and the end position of fm function\n247             args, end = self._get_args(m)\n248 \n249             # the start position of fm function\n250             bgn = m.start()\n251 \n252             # convert Mathematica function to SymPy one\n253             s = self._convert_one_function(s, fm, args, bgn, end)\n254 \n255             # update cursor\n256             cur = bgn\n257 \n258             # append converted part\n259             scanned += s[:cur]\n260 \n261             # shrink s\n262             s = s[cur:]\n263 \n264         return scanned\n265 \n266     def _convert_one_function(self, s, fm, args, bgn, end):\n267         # no variable-length argument\n268         if (fm, len(args)) in self.translations:\n269             key = (fm, len(args))\n270 \n271             # x, y,... model arguments\n272             x_args = self.translations[key]['args']\n273 \n274             # make CORRESPONDENCES between model arguments and actual ones\n275             d = {k: v for k, v in zip(x_args, args)}\n276 \n277         # with variable-length argument\n278         elif (fm, '*') in self.translations:\n279             key = (fm, '*')\n280 \n281             # x, y,..*args (model arguments)\n282             x_args = self.translations[key]['args']\n283 \n284             # make CORRESPONDENCES between model arguments and actual ones\n285             d = {}\n286             for i, x in enumerate(x_args):\n287                 if x[0] == '*':\n288                     d[x] = ','.join(args[i:])\n289                     break\n290                 d[x] = args[i]\n291 \n292         # out of self.translations\n293         else:\n294             err = \"'{f}' is out of the whitelist.\".format(f=fm)\n295             raise ValueError(err)\n296 \n297         # template string of converted function\n298         template = self.translations[key]['fs']\n299 \n300         # regex pattern for x_args\n301         pat = self.translations[key]['pat']\n302 \n303         scanned = ''\n304         cur = 0\n305         while True:\n306             m = pat.search(template)\n307 \n308             if m is None:\n309                 scanned += template\n310                 break\n311 \n312             # get model argument\n313             x = m.group()\n314 \n315             # get a start position of the model argument\n316             xbgn = m.start()\n317 \n318             # add the corresponding actual argument\n319             scanned += template[:xbgn] + d[x]\n320 \n321             # update cursor to the end of the model argument\n322             cur = m.end()\n323 \n324             # shrink template\n325             template = template[cur:]\n326 \n327         # update to swapped string\n328         s = s[:bgn] + scanned + s[end:]\n329 \n330         return s\n331 \n332     @classmethod\n333     def _get_args(cls, m):\n334         '''Get arguments of a Mathematica function'''\n335 \n336         s = m.string                # whole string\n337         anc = m.end() + 1           # pointing the first letter of arguments\n338         square, curly = [], []      # stack for brakets\n339         args = []\n340 \n341         # current cursor\n342         cur = anc\n343         for i, c in enumerate(s[anc:], anc):\n344             # extract one argument\n345             if c == ',' and (not square) and (not curly):\n346                 args.append(s[cur:i])       # add an argument\n347                 cur = i + 1                 # move cursor\n348 \n349             # handle list or matrix (for future usage)\n350             if c == '{':\n351                 curly.append(c)\n352             elif c == '}':\n353                 curly.pop()\n354 \n355             # seek corresponding ']' with skipping irrevant ones\n356             if c == '[':\n357                 square.append(c)\n358             elif c == ']':\n359                 if square:\n360                     square.pop()\n361                 else:   # empty stack\n362                     args.append(s[cur:i])\n363                     break\n364 \n365         # the next position to ']' bracket (the function end)\n366         func_end = i + 1\n367 \n368         return args, func_end\n369 \n370     @classmethod\n371     def _replace(cls, s, bef):\n372         aft = cls.REPLACEMENTS[bef]\n373         s = s.replace(bef, aft)\n374         return s\n375 \n376     @classmethod\n377     def _apply_rules(cls, s, bef):\n378         pat, aft = cls.RULES[bef]\n379         return pat.sub(aft, s)\n380 \n381     @classmethod\n382     def _check_input(cls, s):\n383         for bracket in (('[', ']'), ('{', '}'), ('(', ')')):\n384             if s.count(bracket[0]) != s.count(bracket[1]):\n385                 err = \"'{f}' function form is invalid.\".format(f=s)\n386                 raise ValueError(err)\n387 \n388         if '{' in s:\n389             err = \"Currently list is not supported.\".format(f=s)\n390             raise ValueError(err)\n391 \n392     def parse(self, s):\n393         # input check\n394         self._check_input(s)\n395 \n396         # uncover '*' hiding behind a whitespace\n397         s = self._apply_rules(s, 'whitespace')\n398 \n399         # remove whitespace(s)\n400         s = self._replace(s, ' ')\n401 \n402         # add omitted '*' character\n403         s = self._apply_rules(s, 'add*_1')\n404         s = self._apply_rules(s, 'add*_2')\n405 \n406         # translate function\n407         s = self._convert_function(s)\n408 \n409         # '^' to '**'\n410         s = self._replace(s, '^')\n411 \n412         # 'Pi' to 'pi'\n413         s = self._apply_rules(s, 'Pi')\n414 \n415         # '{', '}' to '[', ']', respectively\n416 #        s = cls._replace(s, '{')   # currently list is not taken into account\n417 #        s = cls._replace(s, '}')\n418 \n419         return s\n",
        "intended_behavior": "This file is crucial for parsing Mathematica expressions into SymPy representations. To resolve the issue, it should be ensured this module can correctly parse and translate Mathematica matrices and arrays into SymPy's equivalent representations. If necessary, new handling routines or enhancements should be added specifically targeting the representation of matrices and arrays from Mathematica, including how they are represented in textual or printed form. This might involve adding new methods or enhancing existing ones to parse Mathematica syntax for arrays and matrices, ensuring they are converted into appropriate SymPy objects that can be printed correctly."
    },
    {
        "rel_file_path": "sympy/printing/latex.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sympy__sympy/setup_sympy__sympy__1.4/sympy/printing/latex.py",
        "start": 1,
        "end": 2503,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2 A Printer which converts an expression into its LaTeX equivalent.\n3 \"\"\"\n4 \n5 from __future__ import print_function, division\n6 \n7 import itertools\n8 \n9 from sympy.core import S, Add, Symbol, Mod\n10 from sympy.core.alphabets import greeks\n11 from sympy.core.containers import Tuple\n12 from sympy.core.function import _coeff_isneg, AppliedUndef, Derivative\n13 from sympy.core.operations import AssocOp\n14 from sympy.core.sympify import SympifyError\n15 from sympy.logic.boolalg import true\n16 \n17 ## sympy.printing imports\n18 from sympy.printing.precedence import precedence_traditional\n19 from sympy.printing.printer import Printer\n20 from sympy.printing.conventions import split_super_sub, requires_partial\n21 from sympy.printing.precedence import precedence, PRECEDENCE\n22 \n23 import mpmath.libmp as mlib\n24 from mpmath.libmp import prec_to_dps\n25 \n26 from sympy.core.compatibility import default_sort_key, range\n27 from sympy.utilities.iterables import has_variety\n28 \n29 import re\n30 \n31 # Hand-picked functions which can be used directly in both LaTeX and MathJax\n32 # Complete list at https://docs.mathjax.org/en/latest/tex.html#supported-latex-commands\n33 # This variable only contains those functions which sympy uses.\n34 accepted_latex_functions = ['arcsin', 'arccos', 'arctan', 'sin', 'cos', 'tan',\n35                     'sinh', 'cosh', 'tanh', 'sqrt', 'ln', 'log', 'sec', 'csc',\n36                     'cot', 'coth', 're', 'im', 'frac', 'root', 'arg',\n37                     ]\n38 \n39 tex_greek_dictionary = {\n40     'Alpha': 'A',\n41     'Beta': 'B',\n42     'Gamma': r'\\Gamma',\n43     'Delta': r'\\Delta',\n44     'Epsilon': 'E',\n45     'Zeta': 'Z',\n46     'Eta': 'H',\n47     'Theta': r'\\Theta',\n48     'Iota': 'I',\n49     'Kappa': 'K',\n50     'Lambda': r'\\Lambda',\n51     'Mu': 'M',\n52     'Nu': 'N',\n53     'Xi': r'\\Xi',\n54     'omicron': 'o',\n55     'Omicron': 'O',\n56     'Pi': r'\\Pi',\n57     'Rho': 'P',\n58     'Sigma': r'\\Sigma',\n59     'Tau': 'T',\n60     'Upsilon': r'\\Upsilon',\n61     'Phi': r'\\Phi',\n62     'Chi': 'X',\n63     'Psi': r'\\Psi',\n64     'Omega': r'\\Omega',\n65     'lamda': r'\\lambda',\n66     'Lamda': r'\\Lambda',\n67     'khi': r'\\chi',\n68     'Khi': r'X',\n69     'varepsilon': r'\\varepsilon',\n70     'varkappa': r'\\varkappa',\n71     'varphi': r'\\varphi',\n72     'varpi': r'\\varpi',\n73     'varrho': r'\\varrho',\n74     'varsigma': r'\\varsigma',\n75     'vartheta': r'\\vartheta',\n76 }\n77 \n78 other_symbols = set(['aleph', 'beth', 'daleth', 'gimel', 'ell', 'eth', 'hbar',\n79                      'hslash', 'mho', 'wp', ])\n80 \n81 # Variable name modifiers\n82 modifier_dict = {\n83     # Accents\n84     'mathring': lambda s: r'\\mathring{'+s+r'}',\n85     'ddddot': lambda s: r'\\ddddot{'+s+r'}',\n86     'dddot': lambda s: r'\\dddot{'+s+r'}',\n87     'ddot': lambda s: r'\\ddot{'+s+r'}',\n88     'dot': lambda s: r'\\dot{'+s+r'}',\n89     'check': lambda s: r'\\check{'+s+r'}',\n90     'breve': lambda s: r'\\breve{'+s+r'}',\n91     'acute': lambda s: r'\\acute{'+s+r'}',\n92     'grave': lambda s: r'\\grave{'+s+r'}',\n93     'tilde': lambda s: r'\\tilde{'+s+r'}',\n94     'hat': lambda s: r'\\hat{'+s+r'}',\n95     'bar': lambda s: r'\\bar{'+s+r'}',\n96     'vec': lambda s: r'\\vec{'+s+r'}',\n97     'prime': lambda s: \"{\"+s+\"}'\",\n98     'prm': lambda s: \"{\"+s+\"}'\",\n99     # Faces\n100     'bold': lambda s: r'\\boldsymbol{'+s+r'}',\n101     'bm': lambda s: r'\\boldsymbol{'+s+r'}',\n102     'cal': lambda s: r'\\mathcal{'+s+r'}',\n103     'scr': lambda s: r'\\mathscr{'+s+r'}',\n104     'frak': lambda s: r'\\mathfrak{'+s+r'}',\n105     # Brackets\n106     'norm': lambda s: r'\\left\\|{'+s+r'}\\right\\|',\n107     'avg': lambda s: r'\\left\\langle{'+s+r'}\\right\\rangle',\n108     'abs': lambda s: r'\\left|{'+s+r'}\\right|',\n109     'mag': lambda s: r'\\left|{'+s+r'}\\right|',\n110 }\n111 \n112 greek_letters_set = frozenset(greeks)\n113 \n114 _between_two_numbers_p = (\n115     re.compile(r'[0-9][} ]*$'),  # search\n116     re.compile(r'[{ ]*[-+0-9]'),  # match\n117 )\n118 \n119 \n120 class LatexPrinter(Printer):\n121     printmethod = \"_latex\"\n122 \n123     _default_settings = {\n124         \"fold_frac_powers\": False,\n125         \"fold_func_brackets\": False,\n126         \"fold_short_frac\": None,\n127         \"inv_trig_style\": \"abbreviated\",\n128         \"itex\": False,\n129         \"ln_notation\": False,\n130         \"long_frac_ratio\": None,\n131         \"mat_delim\": \"[\",\n132         \"mat_str\": None,\n133         \"mode\": \"plain\",\n134         \"mul_symbol\": None,\n135         \"order\": None,\n136         \"symbol_names\": {},\n137         \"root_notation\": True,\n138         \"mat_symbol_style\": \"plain\",\n139         \"imaginary_unit\": \"i\",\n140     }\n141 \n142     def __init__(self, settings=None):\n143         Printer.__init__(self, settings)\n144 \n145         if 'mode' in self._settings:\n146             valid_modes = ['inline', 'plain', 'equation',\n147                            'equation*']\n148             if self._settings['mode'] not in valid_modes:\n149                 raise ValueError(\"'mode' must be one of 'inline', 'plain', \"\n150                     \"'equation' or 'equation*'\")\n151 \n152         if self._settings['fold_short_frac'] is None and \\\n153                 self._settings['mode'] == 'inline':\n154             self._settings['fold_short_frac'] = True\n155 \n156         mul_symbol_table = {\n157             None: r\" \",\n158             \"ldot\": r\" \\,.\\, \",\n159             \"dot\": r\" \\cdot \",\n160             \"times\": r\" \\times \"\n161         }\n162         try:\n163             self._settings['mul_symbol_latex'] = \\\n164                 mul_symbol_table[self._settings['mul_symbol']]\n165         except KeyError:\n166             self._settings['mul_symbol_latex'] = \\\n167                 self._settings['mul_symbol']\n168         try:\n169             self._settings['mul_symbol_latex_numbers'] = \\\n170                 mul_symbol_table[self._settings['mul_symbol'] or 'dot']\n171         except KeyError:\n172             if (self._settings['mul_symbol'].strip() in\n173                     ['', ' ', '\\\\', '\\\\,', '\\\\:', '\\\\;', '\\\\quad']):\n174                 self._settings['mul_symbol_latex_numbers'] = \\\n175                     mul_symbol_table['dot']\n176             else:\n177                 self._settings['mul_symbol_latex_numbers'] = \\\n178                     self._settings['mul_symbol']\n179 \n180         self._delim_dict = {'(': ')', '[': ']'}\n181 \n182         imaginary_unit_table = {\n183             None: r\"i\",\n184             \"i\": r\"i\",\n185             \"ri\": r\"\\mathrm{i}\",\n186             \"ti\": r\"\\text{i}\",\n187             \"j\": r\"j\",\n188             \"rj\": r\"\\mathrm{j}\",\n189             \"tj\": r\"\\text{j}\",\n190         }\n191         try:\n192             self._settings['imaginary_unit_latex'] = \\\n193                 imaginary_unit_table[self._settings['imaginary_unit']]\n194         except KeyError:\n195             self._settings['imaginary_unit_latex'] = \\\n196                 self._settings['imaginary_unit']\n197 \n198     def parenthesize(self, item, level, strict=False):\n199         prec_val = precedence_traditional(item)\n200         if (prec_val < level) or ((not strict) and prec_val <= level):\n201             return r\"\\left(%s\\right)\" % self._print(item)\n202         else:\n203             return self._print(item)\n204 \n205     def doprint(self, expr):\n206         tex = Printer.doprint(self, expr)\n207 \n208         if self._settings['mode'] == 'plain':\n209             return tex\n210         elif self._settings['mode'] == 'inline':\n211             return r\"$%s$\" % tex\n212         elif self._settings['itex']:\n213             return r\"$$%s$$\" % tex\n214         else:\n215             env_str = self._settings['mode']\n216             return r\"\\begin{%s}%s\\end{%s}\" % (env_str, tex, env_str)\n217 \n218     def _needs_brackets(self, expr):\n219         \"\"\"\n220         Returns True if the expression needs to be wrapped in brackets when\n221         printed, False otherwise. For example: a + b => True; a => False;\n222         10 => False; -10 => True.\n223         \"\"\"\n224         return not ((expr.is_Integer and expr.is_nonnegative)\n225                     or (expr.is_Atom and (expr is not S.NegativeOne\n226                                           and expr.is_Rational is False)))\n227 \n228     def _needs_function_brackets(self, expr):\n229         \"\"\"\n230         Returns True if the expression needs to be wrapped in brackets when\n231         passed as an argument to a function, False otherwise. This is a more\n232         liberal version of _needs_brackets, in that many expressions which need\n233         to be wrapped in brackets when added/subtracted/raised to a power do\n234         not need them when passed to a function. Such an example is a*b.\n235         \"\"\"\n236         if not self._needs_brackets(expr):\n237             return False\n238         else:\n239             # Muls of the form a*b*c... can be folded\n240             if expr.is_Mul and not self._mul_is_clean(expr):\n241                 return True\n242             # Pows which don't need brackets can be folded\n243             elif expr.is_Pow and not self._pow_is_clean(expr):\n244                 return True\n245             # Add and Function always need brackets\n246             elif expr.is_Add or expr.is_Function:\n247                 return True\n248             else:\n249                 return False\n250 \n251     def _needs_mul_brackets(self, expr, first=False, last=False):\n252         \"\"\"\n253         Returns True if the expression needs to be wrapped in brackets when\n254         printed as part of a Mul, False otherwise. This is True for Add,\n255         but also for some container objects that would not need brackets\n256         when appearing last in a Mul, e.g. an Integral. ``last=True``\n257         specifies that this expr is the last to appear in a Mul.\n258         ``first=True`` specifies that this expr is the first to appear in a Mul.\n259         \"\"\"\n260         from sympy import Integral, Product, Sum\n261 \n262         if expr.is_Mul:\n263             if not first and _coeff_isneg(expr):\n264                 return True\n265         elif precedence_traditional(expr) < PRECEDENCE[\"Mul\"]:\n266             return True\n267         elif expr.is_Relational:\n268             return True\n269         if expr.is_Piecewise:\n270             return True\n271         if any([expr.has(x) for x in (Mod,)]):\n272             return True\n273         if (not last and\n274             any([expr.has(x) for x in (Integral, Product, Sum)])):\n275             return True\n276 \n277         return False\n278 \n279 \n280     def _needs_add_brackets(self, expr):\n281         \"\"\"\n282         Returns True if the expression needs to be wrapped in brackets when\n283         printed as part of an Add, False otherwise.  This is False for most\n284         things.\n285         \"\"\"\n286         if expr.is_Relational:\n287             return True\n288         if any([expr.has(x) for x in (Mod,)]):\n289             return True\n290         if expr.is_Add:\n291             return True\n292         return False\n293 \n294 \n295     def _mul_is_clean(self, expr):\n296         for arg in expr.args:\n297             if arg.is_Function:\n298                 return False\n299         return True\n300 \n301     def _pow_is_clean(self, expr):\n302         return not self._needs_brackets(expr.base)\n303 \n304     def _do_exponent(self, expr, exp):\n305         if exp is not None:\n306             return r\"\\left(%s\\right)^{%s}\" % (expr, exp)\n307         else:\n308             return expr\n309 \n310     def _print_Basic(self, expr):\n311         l = [self._print(o) for o in expr.args]\n312         return self._deal_with_super_sub(expr.__class__.__name__) + r\"\\left(%s\\right)\" % \", \".join(l)\n313 \n314     def _print_bool(self, e):\n315         return r\"\\mathrm{%s}\" % e\n316 \n317     _print_BooleanTrue = _print_bool\n318     _print_BooleanFalse = _print_bool\n319 \n320     def _print_NoneType(self, e):\n321         return r\"\\mathrm{%s}\" % e\n322 \n323     def _print_Add(self, expr, order=None):\n324         if self.order == 'none':\n325             terms = list(expr.args)\n326         else:\n327             terms = self._as_ordered_terms(expr, order=order)\n328 \n329         tex = \"\"\n330         for i, term in enumerate(terms):\n331             if i == 0:\n332                 pass\n333             elif _coeff_isneg(term):\n334                 tex += \" - \"\n335                 term = -term\n336             else:\n337                 tex += \" + \"\n338             term_tex = self._print(term)\n339             if self._needs_add_brackets(term):\n340                 term_tex = r\"\\left(%s\\right)\" % term_tex\n341             tex += term_tex\n342 \n343         return tex\n344 \n345     def _print_Cycle(self, expr):\n346         from sympy.combinatorics.permutations import Permutation\n347         if expr.size == 0:\n348             return r\"\\left( \\right)\"\n349         expr = Permutation(expr)\n350         expr_perm = expr.cyclic_form\n351         siz = expr.size\n352         if expr.array_form[-1] == siz - 1:\n353             expr_perm = expr_perm + [[siz - 1]]\n354         term_tex = ''\n355         for i in expr_perm:\n356             term_tex += str(i).replace(',', r\"\\;\")\n357         term_tex = term_tex.replace('[', r\"\\left( \")\n358         term_tex = term_tex.replace(']', r\"\\right)\")\n359         return term_tex\n360 \n361     _print_Permutation = _print_Cycle\n362 \n363     def _print_Float(self, expr):\n364         # Based off of that in StrPrinter\n365         dps = prec_to_dps(expr._prec)\n366         str_real = mlib.to_str(expr._mpf_, dps, strip_zeros=True)\n367 \n368         # Must always have a mul symbol (as 2.5 10^{20} just looks odd)\n369         # thus we use the number separator\n370         separator = self._settings['mul_symbol_latex_numbers']\n371 \n372         if 'e' in str_real:\n373             (mant, exp) = str_real.split('e')\n374 \n375             if exp[0] == '+':\n376                 exp = exp[1:]\n377 \n378             return r\"%s%s10^{%s}\" % (mant, separator, exp)\n379         elif str_real == \"+inf\":\n380             return r\"\\infty\"\n381         elif str_real == \"-inf\":\n382             return r\"- \\infty\"\n383         else:\n384             return str_real\n385 \n386     def _print_Cross(self, expr):\n387         vec1 = expr._expr1\n388         vec2 = expr._expr2\n389         return r\"%s \\times %s\" % (self.parenthesize(vec1, PRECEDENCE['Mul']),\n390                                   self.parenthesize(vec2, PRECEDENCE['Mul']))\n391 \n392     def _print_Curl(self, expr):\n393         vec = expr._expr\n394         return r\"\\nabla\\times %s\" % self.parenthesize(vec, PRECEDENCE['Mul'])\n395 \n396     def _print_Divergence(self, expr):\n397         vec = expr._expr\n398         return r\"\\nabla\\cdot %s\" % self.parenthesize(vec, PRECEDENCE['Mul'])\n399 \n400     def _print_Dot(self, expr):\n401         vec1 = expr._expr1\n402         vec2 = expr._expr2\n403         return r\"%s \\cdot %s\" % (self.parenthesize(vec1, PRECEDENCE['Mul']),\n404                                   self.parenthesize(vec2, PRECEDENCE['Mul']))\n405 \n406     def _print_Gradient(self, expr):\n407         func = expr._expr\n408         return r\"\\nabla\\cdot %s\" % self.parenthesize(func, PRECEDENCE['Mul'])\n409 \n410     def _print_Mul(self, expr):\n411         from sympy.core.power import Pow\n412         from sympy.physics.units import Quantity\n413         include_parens = False\n414         if _coeff_isneg(expr):\n415             expr = -expr\n416             tex = \"- \"\n417             if expr.is_Add:\n418                 tex += \"(\"\n419                 include_parens = True\n420         else:\n421             tex = \"\"\n422 \n423         from sympy.simplify import fraction\n424         numer, denom = fraction(expr, exact=True)\n425         separator = self._settings['mul_symbol_latex']\n426         numbersep = self._settings['mul_symbol_latex_numbers']\n427 \n428         def convert(expr):\n429             if not expr.is_Mul:\n430                 return str(self._print(expr))\n431             else:\n432                 _tex = last_term_tex = \"\"\n433 \n434                 if self.order not in ('old', 'none'):\n435                     args = expr.as_ordered_factors()\n436                 else:\n437                     args = list(expr.args)\n438 \n439                 # If quantities are present append them at the back\n440                 args = sorted(args, key=lambda x: isinstance(x, Quantity) or\n441                              (isinstance(x, Pow) and isinstance(x.base, Quantity)))\n442 \n443                 for i, term in enumerate(args):\n444                     term_tex = self._print(term)\n445 \n446                     if self._needs_mul_brackets(term, first=(i == 0),\n447                                                 last=(i == len(args) - 1)):\n448                         term_tex = r\"\\left(%s\\right)\" % term_tex\n449 \n450                     if _between_two_numbers_p[0].search(last_term_tex) and \\\n451                             _between_two_numbers_p[1].match(term_tex):\n452                         # between two numbers\n453                         _tex += numbersep\n454                     elif _tex:\n455                         _tex += separator\n456 \n457                     _tex += term_tex\n458                     last_term_tex = term_tex\n459                 return _tex\n460 \n461         if denom is S.One and Pow(1, -1, evaluate=False) not in expr.args:\n462             # use the original expression here, since fraction() may have\n463             # altered it when producing numer and denom\n464             tex += convert(expr)\n465 \n466         else:\n467             snumer = convert(numer)\n468             sdenom = convert(denom)\n469             ldenom = len(sdenom.split())\n470             ratio = self._settings['long_frac_ratio']\n471             if self._settings['fold_short_frac'] \\\n472                    and ldenom <= 2 and not \"^\" in sdenom:\n473                 # handle short fractions\n474                 if self._needs_mul_brackets(numer, last=False):\n475                     tex += r\"\\left(%s\\right) / %s\" % (snumer, sdenom)\n476                 else:\n477                     tex += r\"%s / %s\" % (snumer, sdenom)\n478             elif ratio is not None and \\\n479                     len(snumer.split()) > ratio*ldenom:\n480                 # handle long fractions\n481                 if self._needs_mul_brackets(numer, last=True):\n482                     tex += r\"\\frac{1}{%s}%s\\left(%s\\right)\" \\\n483                         % (sdenom, separator, snumer)\n484                 elif numer.is_Mul:\n485                     # split a long numerator\n486                     a = S.One\n487                     b = S.One\n488                     for x in numer.args:\n489                         if self._needs_mul_brackets(x, last=False) or \\\n490                                 len(convert(a*x).split()) > ratio*ldenom or \\\n491                                 (b.is_commutative is x.is_commutative is False):\n492                             b *= x\n493                         else:\n494                             a *= x\n495                     if self._needs_mul_brackets(b, last=True):\n496                         tex += r\"\\frac{%s}{%s}%s\\left(%s\\right)\" \\\n497                             % (convert(a), sdenom, separator, convert(b))\n498                     else:\n499                         tex += r\"\\frac{%s}{%s}%s%s\" \\\n500                             % (convert(a), sdenom, separator, convert(b))\n501                 else:\n502                     tex += r\"\\frac{1}{%s}%s%s\" % (sdenom, separator, snumer)\n503             else:\n504                 tex += r\"\\frac{%s}{%s}\" % (snumer, sdenom)\n505 \n506         if include_parens:\n507             tex += \")\"\n508         return tex\n509 \n510     def _print_Pow(self, expr):\n511         # Treat x**Rational(1,n) as special case\n512         if expr.exp.is_Rational and abs(expr.exp.p) == 1 and expr.exp.q != 1 and self._settings['root_notation']:\n513             base = self._print(expr.base)\n514             expq = expr.exp.q\n515 \n516             if expq == 2:\n517                 tex = r\"\\sqrt{%s}\" % base\n518             elif self._settings['itex']:\n519                 tex = r\"\\root{%d}{%s}\" % (expq, base)\n520             else:\n521                 tex = r\"\\sqrt[%d]{%s}\" % (expq, base)\n522 \n523             if expr.exp.is_negative:\n524                 return r\"\\frac{1}{%s}\" % tex\n525             else:\n526                 return tex\n527         elif self._settings['fold_frac_powers'] \\\n528             and expr.exp.is_Rational \\\n529                 and expr.exp.q != 1:\n530             base, p, q = self.parenthesize(expr.base, PRECEDENCE['Pow']), expr.exp.p, expr.exp.q\n531             # issue #12886: add parentheses for superscripts raised to powers\n532             if '^' in base and expr.base.is_Symbol:\n533                 base = r\"\\left(%s\\right)\" % base\n534             if expr.base.is_Function:\n535                 return self._print(expr.base, exp=\"%s/%s\" % (p, q))\n536             return r\"%s^{%s/%s}\" % (base, p, q)\n537         elif expr.exp.is_Rational and expr.exp.is_negative and expr.base.is_commutative:\n538             # special case for 1^(-x), issue 9216\n539             if expr.base == 1:\n540                 return r\"%s^{%s}\" % (expr.base, expr.exp)\n541             # things like 1/x\n542             return self._print_Mul(expr)\n543         else:\n544             if expr.base.is_Function:\n545                 return self._print(expr.base, exp=self._print(expr.exp))\n546             else:\n547                 tex = r\"%s^{%s}\"\n548                 exp = self._print(expr.exp)\n549                 # issue #12886: add parentheses around superscripts raised to powers\n550                 base = self.parenthesize(expr.base, PRECEDENCE['Pow'])\n551                 if '^' in base and expr.base.is_Symbol:\n552                     base = r\"\\left(%s\\right)\" % base\n553                 elif isinstance(expr.base, Derivative\n554                         ) and base.startswith(r'\\left('\n555                         ) and re.match(r'\\\\left\\(\\\\d?d?dot', base\n556                         ) and base.endswith(r'\\right)'):\n557                     # don't use parentheses around dotted derivative\n558                     base = base[6: -7]  # remove outermost added parens\n559 \n560                 return tex % (base, exp)\n561 \n562     def _print_UnevaluatedExpr(self, expr):\n563         return self._print(expr.args[0])\n564 \n565     def _print_Sum(self, expr):\n566         if len(expr.limits) == 1:\n567             tex = r\"\\sum_{%s=%s}^{%s} \" % \\\n568                 tuple([ self._print(i) for i in expr.limits[0] ])\n569         else:\n570             def _format_ineq(l):\n571                 return r\"%s \\leq %s \\leq %s\" % \\\n572                     tuple([self._print(s) for s in (l[1], l[0], l[2])])\n573 \n574             tex = r\"\\sum_{\\substack{%s}} \" % \\\n575                 str.join('\\\\\\\\', [ _format_ineq(l) for l in expr.limits ])\n576 \n577         if isinstance(expr.function, Add):\n578             tex += r\"\\left(%s\\right)\" % self._print(expr.function)\n579         else:\n580             tex += self._print(expr.function)\n581 \n582         return tex\n583 \n584     def _print_Product(self, expr):\n585         if len(expr.limits) == 1:\n586             tex = r\"\\prod_{%s=%s}^{%s} \" % \\\n587                 tuple([ self._print(i) for i in expr.limits[0] ])\n588         else:\n589             def _format_ineq(l):\n590                 return r\"%s \\leq %s \\leq %s\" % \\\n591                     tuple([self._print(s) for s in (l[1], l[0], l[2])])\n592 \n593             tex = r\"\\prod_{\\substack{%s}} \" % \\\n594                 str.join('\\\\\\\\', [ _format_ineq(l) for l in expr.limits ])\n595 \n596         if isinstance(expr.function, Add):\n597             tex += r\"\\left(%s\\right)\" % self._print(expr.function)\n598         else:\n599             tex += self._print(expr.function)\n600 \n601         return tex\n602 \n603     def _print_BasisDependent(self, expr):\n604         from sympy.vector import Vector\n605 \n606         o1 = []\n607         if expr == expr.zero:\n608             return expr.zero._latex_form\n609         if isinstance(expr, Vector):\n610             items = expr.separate().items()\n611         else:\n612             items = [(0, expr)]\n613 \n614         for system, vect in items:\n615             inneritems = list(vect.components.items())\n616             inneritems.sort(key = lambda x:x[0].__str__())\n617             for k, v in inneritems:\n618                 if v == 1:\n619                     o1.append(' + ' + k._latex_form)\n620                 elif v == -1:\n621                     o1.append(' - ' + k._latex_form)\n622                 else:\n623                     arg_str = '(' + LatexPrinter().doprint(v) + ')'\n624                     o1.append(' + ' + arg_str + k._latex_form)\n625 \n626         outstr = (''.join(o1))\n627         if outstr[1] != '-':\n628             outstr = outstr[3:]\n629         else:\n630             outstr = outstr[1:]\n631         return outstr\n632 \n633     def _print_Indexed(self, expr):\n634         tex_base = self._print(expr.base)\n635         tex = '{'+tex_base+'}'+'_{%s}' % ','.join(\n636             map(self._print, expr.indices))\n637         return tex\n638 \n639     def _print_IndexedBase(self, expr):\n640         return self._print(expr.label)\n641 \n642     def _print_Derivative(self, expr):\n643         if requires_partial(expr):\n644             diff_symbol = r'\\partial'\n645         else:\n646             diff_symbol = r'd'\n647 \n648         tex = \"\"\n649         dim = 0\n650         for x, num in reversed(expr.variable_count):\n651             dim += num\n652             if num == 1:\n653                 tex += r\"%s %s\" % (diff_symbol, self._print(x))\n654             else:\n655                 tex += r\"%s %s^{%s}\" % (diff_symbol, self._print(x), num)\n656 \n657         if dim == 1:\n658             tex = r\"\\frac{%s}{%s}\" % (diff_symbol, tex)\n659         else:\n660             tex = r\"\\frac{%s^{%s}}{%s}\" % (diff_symbol, dim, tex)\n661 \n662         return r\"%s %s\" % (tex, self.parenthesize(expr.expr, PRECEDENCE[\"Mul\"], strict=True))\n663 \n664     def _print_Subs(self, subs):\n665         expr, old, new = subs.args\n666         latex_expr = self._print(expr)\n667         latex_old = (self._print(e) for e in old)\n668         latex_new = (self._print(e) for e in new)\n669         latex_subs = r'\\\\ '.join(\n670             e[0] + '=' + e[1] for e in zip(latex_old, latex_new))\n671         return r'\\left. %s \\right|_{\\substack{ %s }}' % (latex_expr, latex_subs)\n672 \n673     def _print_Integral(self, expr):\n674         tex, symbols = \"\", []\n675 \n676         # Only up to \\iiiint exists\n677         if len(expr.limits) <= 4 and all(len(lim) == 1 for lim in expr.limits):\n678             # Use len(expr.limits)-1 so that syntax highlighters don't think\n679             # \\\" is an escaped quote\n680             tex = r\"\\i\" + \"i\"*(len(expr.limits) - 1) + \"nt\"\n681             symbols = [r\"\\, d%s\" % self._print(symbol[0])\n682                        for symbol in expr.limits]\n683 \n684         else:\n685             for lim in reversed(expr.limits):\n686                 symbol = lim[0]\n687                 tex += r\"\\int\"\n688 \n689                 if len(lim) > 1:\n690                     if self._settings['mode'] != 'inline' \\\n691                             and not self._settings['itex']:\n692                         tex += r\"\\limits\"\n693 \n694                     if len(lim) == 3:\n695                         tex += \"_{%s}^{%s}\" % (self._print(lim[1]),\n696                                                self._print(lim[2]))\n697                     if len(lim) == 2:\n698                         tex += \"^{%s}\" % (self._print(lim[1]))\n699 \n700                 symbols.insert(0, r\"\\, d%s\" % self._print(symbol))\n701 \n702         return r\"%s %s%s\" % (tex,\n703             self.parenthesize(expr.function, PRECEDENCE[\"Mul\"], strict=True), \"\".join(symbols))\n704 \n705     def _print_Limit(self, expr):\n706         e, z, z0, dir = expr.args\n707 \n708         tex = r\"\\lim_{%s \\to \" % self._print(z)\n709         if str(dir) == '+-' or z0 in (S.Infinity, S.NegativeInfinity):\n710             tex += r\"%s}\" % self._print(z0)\n711         else:\n712             tex += r\"%s^%s}\" % (self._print(z0), self._print(dir))\n713 \n714         if isinstance(e, AssocOp):\n715             return r\"%s\\left(%s\\right)\" % (tex, self._print(e))\n716         else:\n717             return r\"%s %s\" % (tex, self._print(e))\n718 \n719     def _hprint_Function(self, func):\n720         r'''\n721         Logic to decide how to render a function to latex\n722           - if it is a recognized latex name, use the appropriate latex command\n723           - if it is a single letter, just use that letter\n724           - if it is a longer name, then put \\operatorname{} around it and be\n725             mindful of undercores in the name\n726         '''\n727         func = self._deal_with_super_sub(func)\n728         if func in accepted_latex_functions:\n729             name = r\"\\%s\" % func\n730         elif len(func) == 1 or func.startswith('\\\\'):\n731             name = func\n732         else:\n733             name = r\"\\operatorname{%s}\" % func\n734         return name\n735 \n736     def _print_Function(self, expr, exp=None):\n737         r'''\n738         Render functions to LaTeX, handling functions that LaTeX knows about\n739         e.g., sin, cos, ... by using the proper LaTeX command (\\sin, \\cos, ...).\n740         For single-letter function names, render them as regular LaTeX math\n741         symbols. For multi-letter function names that LaTeX does not know\n742         about, (e.g., Li, sech) use \\operatorname{} so that the function name\n743         is rendered in Roman font and LaTeX handles spacing properly.\n744 \n745         expr is the expression involving the function\n746         exp is an exponent\n747         '''\n748         func = expr.func.__name__\n749         if hasattr(self, '_print_' + func) and \\\n750             not isinstance(expr, AppliedUndef):\n751             return getattr(self, '_print_' + func)(expr, exp)\n752         else:\n753             args = [ str(self._print(arg)) for arg in expr.args ]\n754             # How inverse trig functions should be displayed, formats are:\n755             # abbreviated: asin, full: arcsin, power: sin^-1\n756             inv_trig_style = self._settings['inv_trig_style']\n757             # If we are dealing with a power-style inverse trig function\n758             inv_trig_power_case = False\n759             # If it is applicable to fold the argument brackets\n760             can_fold_brackets = self._settings['fold_func_brackets'] and \\\n761                 len(args) == 1 and \\\n762                 not self._needs_function_brackets(expr.args[0])\n763 \n764             inv_trig_table = [\"asin\", \"acos\", \"atan\", \"acsc\", \"asec\", \"acot\"]\n765 \n766             # If the function is an inverse trig function, handle the style\n767             if func in inv_trig_table:\n768                 if inv_trig_style == \"abbreviated\":\n769                     pass\n770                 elif inv_trig_style == \"full\":\n771                     func = \"arc\" + func[1:]\n772                 elif inv_trig_style == \"power\":\n773                     func = func[1:]\n774                     inv_trig_power_case = True\n775 \n776                     # Can never fold brackets if we're raised to a power\n777                     if exp is not None:\n778                         can_fold_brackets = False\n779 \n780             if inv_trig_power_case:\n781                 if func in accepted_latex_functions:\n782                     name = r\"\\%s^{-1}\" % func\n783                 else:\n784                     name = r\"\\operatorname{%s}^{-1}\" % func\n785             elif exp is not None:\n786                 name = r'%s^{%s}' % (self._hprint_Function(func), exp)\n787             else:\n788                 name = self._hprint_Function(func)\n789 \n790             if can_fold_brackets:\n791                 if func in accepted_latex_functions:\n792                     # Wrap argument safely to avoid parse-time conflicts\n793                     # with the function name itself\n794                     name += r\" {%s}\"\n795                 else:\n796                     name += r\"%s\"\n797             else:\n798                 name += r\"{\\left(%s \\right)}\"\n799 \n800             if inv_trig_power_case and exp is not None:\n801                 name += r\"^{%s}\" % exp\n802 \n803             return name % \",\".join(args)\n804 \n805     def _print_UndefinedFunction(self, expr):\n806         return self._hprint_Function(str(expr))\n807 \n808     @property\n809     def _special_function_classes(self):\n810         from sympy.functions.special.tensor_functions import KroneckerDelta\n811         from sympy.functions.special.gamma_functions import gamma, lowergamma\n812         from sympy.functions.special.beta_functions import beta\n813         from sympy.functions.special.delta_functions import DiracDelta\n814         from sympy.functions.special.error_functions import Chi\n815         return {KroneckerDelta: r'\\delta',\n816                 gamma:  r'\\Gamma',\n817                 lowergamma: r'\\gamma',\n818                 beta: r'\\operatorname{B}',\n819                 DiracDelta: r'\\delta',\n820                 Chi: r'\\operatorname{Chi}'}\n821 \n822     def _print_FunctionClass(self, expr):\n823         for cls in self._special_function_classes:\n824             if issubclass(expr, cls) and expr.__name__ == cls.__name__:\n825                 return self._special_function_classes[cls]\n826         return self._hprint_Function(str(expr))\n827 \n828     def _print_Lambda(self, expr):\n829         symbols, expr = expr.args\n830 \n831         if len(symbols) == 1:\n832             symbols = self._print(symbols[0])\n833         else:\n834             symbols = self._print(tuple(symbols))\n835 \n836         tex = r\"\\left( %s \\mapsto %s \\right)\" % (symbols, self._print(expr))\n837 \n838         return tex\n839 \n840     def _hprint_variadic_function(self, expr, exp=None):\n841         args = sorted(expr.args, key=default_sort_key)\n842         texargs = [r\"%s\" % self._print(symbol) for symbol in args]\n843         tex = r\"\\%s\\left(%s\\right)\" % (self._print((str(expr.func)).lower()), \", \".join(texargs))\n844         if exp is not None:\n845             return r\"%s^{%s}\" % (tex, exp)\n846         else:\n847             return tex\n848 \n849     _print_Min = _print_Max = _hprint_variadic_function\n850 \n851     def _print_floor(self, expr, exp=None):\n852         tex = r\"\\left\\lfloor{%s}\\right\\rfloor\" % self._print(expr.args[0])\n853 \n854         if exp is not None:\n855             return r\"%s^{%s}\" % (tex, exp)\n856         else:\n857             return tex\n858 \n859     def _print_ceiling(self, expr, exp=None):\n860         tex = r\"\\left\\lceil{%s}\\right\\rceil\" % self._print(expr.args[0])\n861 \n862         if exp is not None:\n863             return r\"%s^{%s}\" % (tex, exp)\n864         else:\n865             return tex\n866 \n867     def _print_log(self, expr, exp=None):\n868         if not self._settings[\"ln_notation\"]:\n869             tex = r\"\\log{\\left(%s \\right)}\" % self._print(expr.args[0])\n870         else:\n871             tex = r\"\\ln{\\left(%s \\right)}\" % self._print(expr.args[0])\n872 \n873         if exp is not None:\n874             return r\"%s^{%s}\" % (tex, exp)\n875         else:\n876             return tex\n877 \n878     def _print_Abs(self, expr, exp=None):\n879         tex = r\"\\left|{%s}\\right|\" % self._print(expr.args[0])\n880 \n881         if exp is not None:\n882             return r\"%s^{%s}\" % (tex, exp)\n883         else:\n884             return tex\n885     _print_Determinant = _print_Abs\n886 \n887     def _print_re(self, expr, exp=None):\n888         tex = r\"\\Re{%s}\" % self.parenthesize(expr.args[0], PRECEDENCE['Atom'])\n889 \n890         return self._do_exponent(tex, exp)\n891 \n892     def _print_im(self, expr, exp=None):\n893         tex = r\"\\Im{%s}\" % self.parenthesize(expr.args[0], PRECEDENCE['Func'])\n894 \n895         return self._do_exponent(tex, exp)\n896 \n897     def _print_Not(self, e):\n898         from sympy import Equivalent, Implies\n899         if isinstance(e.args[0], Equivalent):\n900             return self._print_Equivalent(e.args[0], r\"\\not\\Leftrightarrow\")\n901         if isinstance(e.args[0], Implies):\n902             return self._print_Implies(e.args[0], r\"\\not\\Rightarrow\")\n903         if (e.args[0].is_Boolean):\n904             return r\"\\neg (%s)\" % self._print(e.args[0])\n905         else:\n906             return r\"\\neg %s\" % self._print(e.args[0])\n907 \n908     def _print_LogOp(self, args, char):\n909         arg = args[0]\n910         if arg.is_Boolean and not arg.is_Not:\n911             tex = r\"\\left(%s\\right)\" % self._print(arg)\n912         else:\n913             tex = r\"%s\" % self._print(arg)\n914 \n915         for arg in args[1:]:\n916             if arg.is_Boolean and not arg.is_Not:\n917                 tex += r\" %s \\left(%s\\right)\" % (char, self._print(arg))\n918             else:\n919                 tex += r\" %s %s\" % (char, self._print(arg))\n920 \n921         return tex\n922 \n923     def _print_And(self, e):\n924         args = sorted(e.args, key=default_sort_key)\n925         return self._print_LogOp(args, r\"\\wedge\")\n926 \n927     def _print_Or(self, e):\n928         args = sorted(e.args, key=default_sort_key)\n929         return self._print_LogOp(args, r\"\\vee\")\n930 \n931     def _print_Xor(self, e):\n932         args = sorted(e.args, key=default_sort_key)\n933         return self._print_LogOp(args, r\"\\veebar\")\n934 \n935     def _print_Implies(self, e, altchar=None):\n936         return self._print_LogOp(e.args, altchar or r\"\\Rightarrow\")\n937 \n938     def _print_Equivalent(self, e, altchar=None):\n939         args = sorted(e.args, key=default_sort_key)\n940         return self._print_LogOp(args, altchar or r\"\\Leftrightarrow\")\n941 \n942     def _print_conjugate(self, expr, exp=None):\n943         tex = r\"\\overline{%s}\" % self._print(expr.args[0])\n944 \n945         if exp is not None:\n946             return r\"%s^{%s}\" % (tex, exp)\n947         else:\n948             return tex\n949 \n950     def _print_polar_lift(self, expr, exp=None):\n951         func = r\"\\operatorname{polar\\_lift}\"\n952         arg = r\"{\\left(%s \\right)}\" % self._print(expr.args[0])\n953 \n954         if exp is not None:\n955             return r\"%s^{%s}%s\" % (func, exp, arg)\n956         else:\n957             return r\"%s%s\" % (func, arg)\n958 \n959     def _print_ExpBase(self, expr, exp=None):\n960         # TODO should exp_polar be printed differently?\n961         #      what about exp_polar(0), exp_polar(1)?\n962         tex = r\"e^{%s}\" % self._print(expr.args[0])\n963         return self._do_exponent(tex, exp)\n964 \n965     def _print_elliptic_k(self, expr, exp=None):\n966         tex = r\"\\left(%s\\right)\" % self._print(expr.args[0])\n967         if exp is not None:\n968             return r\"K^{%s}%s\" % (exp, tex)\n969         else:\n970             return r\"K%s\" % tex\n971 \n972     def _print_elliptic_f(self, expr, exp=None):\n973         tex = r\"\\left(%s\\middle| %s\\right)\" % \\\n974             (self._print(expr.args[0]), self._print(expr.args[1]))\n975         if exp is not None:\n976             return r\"F^{%s}%s\" % (exp, tex)\n977         else:\n978             return r\"F%s\" % tex\n979 \n980     def _print_elliptic_e(self, expr, exp=None):\n981         if len(expr.args) == 2:\n982             tex = r\"\\left(%s\\middle| %s\\right)\" % \\\n983                 (self._print(expr.args[0]), self._print(expr.args[1]))\n984         else:\n985             tex = r\"\\left(%s\\right)\" % self._print(expr.args[0])\n986         if exp is not None:\n987             return r\"E^{%s}%s\" % (exp, tex)\n988         else:\n989             return r\"E%s\" % tex\n990 \n991     def _print_elliptic_pi(self, expr, exp=None):\n992         if len(expr.args) == 3:\n993             tex = r\"\\left(%s; %s\\middle| %s\\right)\" % \\\n994                 (self._print(expr.args[0]), self._print(expr.args[1]), \\\n995                  self._print(expr.args[2]))\n996         else:\n997             tex = r\"\\left(%s\\middle| %s\\right)\" % \\\n998                 (self._print(expr.args[0]), self._print(expr.args[1]))\n999         if exp is not None:\n1000             return r\"\\Pi^{%s}%s\" % (exp, tex)\n1001         else:\n1002             return r\"\\Pi%s\" % tex\n1003 \n1004     def _print_beta(self, expr, exp=None):\n1005         tex = r\"\\left(%s, %s\\right)\" % (self._print(expr.args[0]),\n1006                                         self._print(expr.args[1]))\n1007 \n1008         if exp is not None:\n1009             return r\"\\operatorname{B}^{%s}%s\" % (exp, tex)\n1010         else:\n1011             return r\"\\operatorname{B}%s\" % tex\n1012 \n1013     def _print_uppergamma(self, expr, exp=None):\n1014         tex = r\"\\left(%s, %s\\right)\" % (self._print(expr.args[0]),\n1015                                         self._print(expr.args[1]))\n1016 \n1017         if exp is not None:\n1018             return r\"\\Gamma^{%s}%s\" % (exp, tex)\n1019         else:\n1020             return r\"\\Gamma%s\" % tex\n1021 \n1022     def _print_lowergamma(self, expr, exp=None):\n1023         tex = r\"\\left(%s, %s\\right)\" % (self._print(expr.args[0]),\n1024                                         self._print(expr.args[1]))\n1025 \n1026         if exp is not None:\n1027             return r\"\\gamma^{%s}%s\" % (exp, tex)\n1028         else:\n1029             return r\"\\gamma%s\" % tex\n1030 \n1031     def _hprint_one_arg_func(self, expr, exp=None):\n1032         tex = r\"\\left(%s\\right)\" % self._print(expr.args[0])\n1033 \n1034         if exp is not None:\n1035             return r\"%s^{%s}%s\" % (self._print(expr.func), exp, tex)\n1036         else:\n1037             return r\"%s%s\" % (self._print(expr.func), tex)\n1038 \n1039     _print_gamma = _hprint_one_arg_func\n1040 \n1041     def _print_Chi(self, expr, exp=None):\n1042         tex = r\"\\left(%s\\right)\" % self._print(expr.args[0])\n1043 \n1044         if exp is not None:\n1045             return r\"\\operatorname{Chi}^{%s}%s\" % (exp, tex)\n1046         else:\n1047             return r\"\\operatorname{Chi}%s\" % tex\n1048 \n1049     def _print_expint(self, expr, exp=None):\n1050         tex = r\"\\left(%s\\right)\" % self._print(expr.args[1])\n1051         nu = self._print(expr.args[0])\n1052 \n1053         if exp is not None:\n1054             return r\"\\operatorname{E}_{%s}^{%s}%s\" % (nu, exp, tex)\n1055         else:\n1056             return r\"\\operatorname{E}_{%s}%s\" % (nu, tex)\n1057 \n1058     def _print_fresnels(self, expr, exp=None):\n1059         tex = r\"\\left(%s\\right)\" % self._print(expr.args[0])\n1060 \n1061         if exp is not None:\n1062             return r\"S^{%s}%s\" % (exp, tex)\n1063         else:\n1064             return r\"S%s\" % tex\n1065 \n1066     def _print_fresnelc(self, expr, exp=None):\n1067         tex = r\"\\left(%s\\right)\" % self._print(expr.args[0])\n1068 \n1069         if exp is not None:\n1070             return r\"C^{%s}%s\" % (exp, tex)\n1071         else:\n1072             return r\"C%s\" % tex\n1073 \n1074     def _print_subfactorial(self, expr, exp=None):\n1075         tex = r\"!%s\" % self.parenthesize(expr.args[0], PRECEDENCE[\"Func\"])\n1076 \n1077         if exp is not None:\n1078             return r\"\\left(%s\\right)^{%s}\" % (tex, exp)\n1079         else:\n1080             return tex\n1081 \n1082     def _print_factorial(self, expr, exp=None):\n1083         tex = r\"%s!\" % self.parenthesize(expr.args[0], PRECEDENCE[\"Func\"])\n1084 \n1085         if exp is not None:\n1086             return r\"%s^{%s}\" % (tex, exp)\n1087         else:\n1088             return tex\n1089 \n1090     def _print_factorial2(self, expr, exp=None):\n1091         tex = r\"%s!!\" % self.parenthesize(expr.args[0], PRECEDENCE[\"Func\"])\n1092 \n1093         if exp is not None:\n1094             return r\"%s^{%s}\" % (tex, exp)\n1095         else:\n1096             return tex\n1097 \n1098     def _print_binomial(self, expr, exp=None):\n1099         tex = r\"{\\binom{%s}{%s}}\" % (self._print(expr.args[0]),\n1100                                      self._print(expr.args[1]))\n1101 \n1102         if exp is not None:\n1103             return r\"%s^{%s}\" % (tex, exp)\n1104         else:\n1105             return tex\n1106 \n1107     def _print_RisingFactorial(self, expr, exp=None):\n1108         n, k = expr.args\n1109         base = r\"%s\" % self.parenthesize(n, PRECEDENCE['Func'])\n1110 \n1111         tex = r\"{%s}^{\\left(%s\\right)}\" % (base, self._print(k))\n1112 \n1113         return self._do_exponent(tex, exp)\n1114 \n1115     def _print_FallingFactorial(self, expr, exp=None):\n1116         n, k = expr.args\n1117         sub = r\"%s\" % self.parenthesize(k, PRECEDENCE['Func'])\n1118 \n1119         tex = r\"{\\left(%s\\right)}_{%s}\" % (self._print(n), sub)\n1120 \n1121         return self._do_exponent(tex, exp)\n1122 \n1123     def _hprint_BesselBase(self, expr, exp, sym):\n1124         tex = r\"%s\" % (sym)\n1125 \n1126         need_exp = False\n1127         if exp is not None:\n1128             if tex.find('^') == -1:\n1129                 tex = r\"%s^{%s}\" % (tex, self._print(exp))\n1130             else:\n1131                 need_exp = True\n1132 \n1133         tex = r\"%s_{%s}\\left(%s\\right)\" % (tex, self._print(expr.order),\n1134                                            self._print(expr.argument))\n1135 \n1136         if need_exp:\n1137             tex = self._do_exponent(tex, exp)\n1138         return tex\n1139 \n1140     def _hprint_vec(self, vec):\n1141         if not vec:\n1142             return \"\"\n1143         s = \"\"\n1144         for i in vec[:-1]:\n1145             s += \"%s, \" % self._print(i)\n1146         s += self._print(vec[-1])\n1147         return s\n1148 \n1149     def _print_besselj(self, expr, exp=None):\n1150         return self._hprint_BesselBase(expr, exp, 'J')\n1151 \n1152     def _print_besseli(self, expr, exp=None):\n1153         return self._hprint_BesselBase(expr, exp, 'I')\n1154 \n1155     def _print_besselk(self, expr, exp=None):\n1156         return self._hprint_BesselBase(expr, exp, 'K')\n1157 \n1158     def _print_bessely(self, expr, exp=None):\n1159         return self._hprint_BesselBase(expr, exp, 'Y')\n1160 \n1161     def _print_yn(self, expr, exp=None):\n1162         return self._hprint_BesselBase(expr, exp, 'y')\n1163 \n1164     def _print_jn(self, expr, exp=None):\n1165         return self._hprint_BesselBase(expr, exp, 'j')\n1166 \n1167     def _print_hankel1(self, expr, exp=None):\n1168         return self._hprint_BesselBase(expr, exp, 'H^{(1)}')\n1169 \n1170     def _print_hankel2(self, expr, exp=None):\n1171         return self._hprint_BesselBase(expr, exp, 'H^{(2)}')\n1172 \n1173     def _print_hn1(self, expr, exp=None):\n1174         return self._hprint_BesselBase(expr, exp, 'h^{(1)}')\n1175 \n1176     def _print_hn2(self, expr, exp=None):\n1177         return self._hprint_BesselBase(expr, exp, 'h^{(2)}')\n1178 \n1179     def _hprint_airy(self, expr, exp=None, notation=\"\"):\n1180         tex = r\"\\left(%s\\right)\" % self._print(expr.args[0])\n1181 \n1182         if exp is not None:\n1183             return r\"%s^{%s}%s\" % (notation, exp, tex)\n1184         else:\n1185             return r\"%s%s\" % (notation, tex)\n1186 \n1187     def _hprint_airy_prime(self, expr, exp=None, notation=\"\"):\n1188         tex = r\"\\left(%s\\right)\" % self._print(expr.args[0])\n1189 \n1190         if exp is not None:\n1191             return r\"{%s^\\prime}^{%s}%s\" % (notation, exp, tex)\n1192         else:\n1193             return r\"%s^\\prime%s\" % (notation, tex)\n1194 \n1195     def _print_airyai(self, expr, exp=None):\n1196         return self._hprint_airy(expr, exp, 'Ai')\n1197 \n1198     def _print_airybi(self, expr, exp=None):\n1199         return self._hprint_airy(expr, exp, 'Bi')\n1200 \n1201     def _print_airyaiprime(self, expr, exp=None):\n1202         return self._hprint_airy_prime(expr, exp, 'Ai')\n1203 \n1204     def _print_airybiprime(self, expr, exp=None):\n1205         return self._hprint_airy_prime(expr, exp, 'Bi')\n1206 \n1207     def _print_hyper(self, expr, exp=None):\n1208         tex = r\"{{}_{%s}F_{%s}\\left(\\begin{matrix} %s \\\\ %s \\end{matrix}\" \\\n1209               r\"\\middle| {%s} \\right)}\" % \\\n1210             (self._print(len(expr.ap)), self._print(len(expr.bq)),\n1211               self._hprint_vec(expr.ap), self._hprint_vec(expr.bq),\n1212               self._print(expr.argument))\n1213 \n1214         if exp is not None:\n1215             tex = r\"{%s}^{%s}\" % (tex, self._print(exp))\n1216         return tex\n1217 \n1218     def _print_meijerg(self, expr, exp=None):\n1219         tex = r\"{G_{%s, %s}^{%s, %s}\\left(\\begin{matrix} %s & %s \\\\\" \\\n1220               r\"%s & %s \\end{matrix} \\middle| {%s} \\right)}\" % \\\n1221             (self._print(len(expr.ap)), self._print(len(expr.bq)),\n1222               self._print(len(expr.bm)), self._print(len(expr.an)),\n1223               self._hprint_vec(expr.an), self._hprint_vec(expr.aother),\n1224               self._hprint_vec(expr.bm), self._hprint_vec(expr.bother),\n1225               self._print(expr.argument))\n1226 \n1227         if exp is not None:\n1228             tex = r\"{%s}^{%s}\" % (tex, self._print(exp))\n1229         return tex\n1230 \n1231     def _print_dirichlet_eta(self, expr, exp=None):\n1232         tex = r\"\\left(%s\\right)\" % self._print(expr.args[0])\n1233         if exp is not None:\n1234             return r\"\\eta^{%s}%s\" % (self._print(exp), tex)\n1235         return r\"\\eta%s\" % tex\n1236 \n1237     def _print_zeta(self, expr, exp=None):\n1238         if len(expr.args) == 2:\n1239             tex = r\"\\left(%s, %s\\right)\" % tuple(map(self._print, expr.args))\n1240         else:\n1241             tex = r\"\\left(%s\\right)\" % self._print(expr.args[0])\n1242         if exp is not None:\n1243             return r\"\\zeta^{%s}%s\" % (self._print(exp), tex)\n1244         return r\"\\zeta%s\" % tex\n1245 \n1246     def _print_lerchphi(self, expr, exp=None):\n1247         tex = r\"\\left(%s, %s, %s\\right)\" % tuple(map(self._print, expr.args))\n1248         if exp is None:\n1249             return r\"\\Phi%s\" % tex\n1250         return r\"\\Phi^{%s}%s\" % (self._print(exp), tex)\n1251 \n1252     def _print_polylog(self, expr, exp=None):\n1253         s, z = map(self._print, expr.args)\n1254         tex = r\"\\left(%s\\right)\" % z\n1255         if exp is None:\n1256             return r\"\\operatorname{Li}_{%s}%s\" % (s, tex)\n1257         return r\"\\operatorname{Li}_{%s}^{%s}%s\" % (s, self._print(exp), tex)\n1258 \n1259     def _print_jacobi(self, expr, exp=None):\n1260         n, a, b, x = map(self._print, expr.args)\n1261         tex = r\"P_{%s}^{\\left(%s,%s\\right)}\\left(%s\\right)\" % (n, a, b, x)\n1262         if exp is not None:\n1263             tex = r\"\\left(\" + tex + r\"\\right)^{%s}\" % (self._print(exp))\n1264         return tex\n1265 \n1266     def _print_gegenbauer(self, expr, exp=None):\n1267         n, a, x = map(self._print, expr.args)\n1268         tex = r\"C_{%s}^{\\left(%s\\right)}\\left(%s\\right)\" % (n, a, x)\n1269         if exp is not None:\n1270             tex = r\"\\left(\" + tex + r\"\\right)^{%s}\" % (self._print(exp))\n1271         return tex\n1272 \n1273     def _print_chebyshevt(self, expr, exp=None):\n1274         n, x = map(self._print, expr.args)\n1275         tex = r\"T_{%s}\\left(%s\\right)\" % (n, x)\n1276         if exp is not None:\n1277             tex = r\"\\left(\" + tex + r\"\\right)^{%s}\" % (self._print(exp))\n1278         return tex\n1279 \n1280     def _print_chebyshevu(self, expr, exp=None):\n1281         n, x = map(self._print, expr.args)\n1282         tex = r\"U_{%s}\\left(%s\\right)\" % (n, x)\n1283         if exp is not None:\n1284             tex = r\"\\left(\" + tex + r\"\\right)^{%s}\" % (self._print(exp))\n1285         return tex\n1286 \n1287     def _print_legendre(self, expr, exp=None):\n1288         n, x = map(self._print, expr.args)\n1289         tex = r\"P_{%s}\\left(%s\\right)\" % (n, x)\n1290         if exp is not None:\n1291             tex = r\"\\left(\" + tex + r\"\\right)^{%s}\" % (self._print(exp))\n1292         return tex\n1293 \n1294     def _print_assoc_legendre(self, expr, exp=None):\n1295         n, a, x = map(self._print, expr.args)\n1296         tex = r\"P_{%s}^{\\left(%s\\right)}\\left(%s\\right)\" % (n, a, x)\n1297         if exp is not None:\n1298             tex = r\"\\left(\" + tex + r\"\\right)^{%s}\" % (self._print(exp))\n1299         return tex\n1300 \n1301     def _print_hermite(self, expr, exp=None):\n1302         n, x = map(self._print, expr.args)\n1303         tex = r\"H_{%s}\\left(%s\\right)\" % (n, x)\n1304         if exp is not None:\n1305             tex = r\"\\left(\" + tex + r\"\\right)^{%s}\" % (self._print(exp))\n1306         return tex\n1307 \n1308     def _print_laguerre(self, expr, exp=None):\n1309         n, x = map(self._print, expr.args)\n1310         tex = r\"L_{%s}\\left(%s\\right)\" % (n, x)\n1311         if exp is not None:\n1312             tex = r\"\\left(\" + tex + r\"\\right)^{%s}\" % (self._print(exp))\n1313         return tex\n1314 \n1315     def _print_assoc_laguerre(self, expr, exp=None):\n1316         n, a, x = map(self._print, expr.args)\n1317         tex = r\"L_{%s}^{\\left(%s\\right)}\\left(%s\\right)\" % (n, a, x)\n1318         if exp is not None:\n1319             tex = r\"\\left(\" + tex + r\"\\right)^{%s}\" % (self._print(exp))\n1320         return tex\n1321 \n1322     def _print_Ynm(self, expr, exp=None):\n1323         n, m, theta, phi = map(self._print, expr.args)\n1324         tex = r\"Y_{%s}^{%s}\\left(%s,%s\\right)\" % (n, m, theta, phi)\n1325         if exp is not None:\n1326             tex = r\"\\left(\" + tex + r\"\\right)^{%s}\" % (self._print(exp))\n1327         return tex\n1328 \n1329     def _print_Znm(self, expr, exp=None):\n1330         n, m, theta, phi = map(self._print, expr.args)\n1331         tex = r\"Z_{%s}^{%s}\\left(%s,%s\\right)\" % (n, m, theta, phi)\n1332         if exp is not None:\n1333             tex = r\"\\left(\" + tex + r\"\\right)^{%s}\" % (self._print(exp))\n1334         return tex\n1335 \n1336     def _print_Rational(self, expr):\n1337         if expr.q != 1:\n1338             sign = \"\"\n1339             p = expr.p\n1340             if expr.p < 0:\n1341                 sign = \"- \"\n1342                 p = -p\n1343             if self._settings['fold_short_frac']:\n1344                 return r\"%s%d / %d\" % (sign, p, expr.q)\n1345             return r\"%s\\frac{%d}{%d}\" % (sign, p, expr.q)\n1346         else:\n1347             return self._print(expr.p)\n1348 \n1349     def _print_Order(self, expr):\n1350         s = self._print(expr.expr)\n1351         if expr.point and any(p != S.Zero for p in expr.point) or \\\n1352            len(expr.variables) > 1:\n1353             s += '; '\n1354             if len(expr.variables) > 1:\n1355                 s += self._print(expr.variables)\n1356             elif expr.variables:\n1357                 s += self._print(expr.variables[0])\n1358             s += r'\\rightarrow '\n1359             if len(expr.point) > 1:\n1360                 s += self._print(expr.point)\n1361             else:\n1362                 s += self._print(expr.point[0])\n1363         return r\"O\\left(%s\\right)\" % s\n1364 \n1365     def _print_Symbol(self, expr, style='plain'):\n1366         if expr in self._settings['symbol_names']:\n1367             return self._settings['symbol_names'][expr]\n1368 \n1369         result = self._deal_with_super_sub(expr.name) if \\\n1370             '\\\\' not in expr.name else expr.name\n1371 \n1372         if style == 'bold':\n1373             result = r\"\\mathbf{{{}}}\".format(result)\n1374 \n1375         return result\n1376 \n1377     _print_RandomSymbol = _print_Symbol\n1378 \n1379     def _print_MatrixSymbol(self, expr):\n1380         return self._print_Symbol(expr, style=self._settings['mat_symbol_style'])\n1381 \n1382     def _deal_with_super_sub(self, string):\n1383         if '{' in string:\n1384             return string\n1385 \n1386         name, supers, subs = split_super_sub(string)\n1387 \n1388         name = translate(name)\n1389         supers = [translate(sup) for sup in supers]\n1390         subs = [translate(sub) for sub in subs]\n1391 \n1392         # glue all items together:\n1393         if supers:\n1394             name += \"^{%s}\" % \" \".join(supers)\n1395         if subs:\n1396             name += \"_{%s}\" % \" \".join(subs)\n1397 \n1398         return name\n1399 \n1400     def _print_Relational(self, expr):\n1401         if self._settings['itex']:\n1402             gt = r\"\\gt\"\n1403             lt = r\"\\lt\"\n1404         else:\n1405             gt = \">\"\n1406             lt = \"<\"\n1407 \n1408         charmap = {\n1409             \"==\": \"=\",\n1410             \">\": gt,\n1411             \"<\": lt,\n1412             \">=\": r\"\\geq\",\n1413             \"<=\": r\"\\leq\",\n1414             \"!=\": r\"\\neq\",\n1415         }\n1416 \n1417         return \"%s %s %s\" % (self._print(expr.lhs),\n1418             charmap[expr.rel_op], self._print(expr.rhs))\n1419 \n1420     def _print_Piecewise(self, expr):\n1421         ecpairs = [r\"%s & \\text{for}\\: %s\" % (self._print(e), self._print(c))\n1422                    for e, c in expr.args[:-1]]\n1423         if expr.args[-1].cond == true:\n1424             ecpairs.append(r\"%s & \\text{otherwise}\" %\n1425                            self._print(expr.args[-1].expr))\n1426         else:\n1427             ecpairs.append(r\"%s & \\text{for}\\: %s\" %\n1428                            (self._print(expr.args[-1].expr),\n1429                             self._print(expr.args[-1].cond)))\n1430         tex = r\"\\begin{cases} %s \\end{cases}\"\n1431         return tex % r\" \\\\\".join(ecpairs)\n1432 \n1433     def _print_MatrixBase(self, expr):\n1434         lines = []\n1435 \n1436         for line in range(expr.rows):  # horrible, should be 'rows'\n1437             lines.append(\" & \".join([ self._print(i) for i in expr[line, :] ]))\n1438 \n1439         mat_str = self._settings['mat_str']\n1440         if mat_str is None:\n1441             if self._settings['mode'] == 'inline':\n1442                 mat_str = 'smallmatrix'\n1443             else:\n1444                 if (expr.cols <= 10) is True:\n1445                     mat_str = 'matrix'\n1446                 else:\n1447                     mat_str = 'array'\n1448 \n1449         out_str = r'\\begin{%MATSTR%}%s\\end{%MATSTR%}'\n1450         out_str = out_str.replace('%MATSTR%', mat_str)\n1451         if mat_str == 'array':\n1452             out_str = out_str.replace('%s', '{' + 'c'*expr.cols + '}%s')\n1453         if self._settings['mat_delim']:\n1454             left_delim = self._settings['mat_delim']\n1455             right_delim = self._delim_dict[left_delim]\n1456             out_str = r'\\left' + left_delim + out_str + \\\n1457                       r'\\right' + right_delim\n1458         return out_str % r\"\\\\\".join(lines)\n1459     _print_ImmutableMatrix = _print_ImmutableDenseMatrix \\\n1460                            = _print_Matrix \\\n1461                            = _print_MatrixBase\n1462 \n1463     def _print_MatrixElement(self, expr):\n1464         return self.parenthesize(expr.parent, PRECEDENCE[\"Atom\"], strict=True) \\\n1465             + '_{%s, %s}' % (\n1466             self._print(expr.i),\n1467             self._print(expr.j)\n1468         )\n1469 \n1470     def _print_MatrixSlice(self, expr):\n1471         def latexslice(x):\n1472             x = list(x)\n1473             if x[2] == 1:\n1474                 del x[2]\n1475             if x[1] == x[0] + 1:\n1476                 del x[1]\n1477             if x[0] == 0:\n1478                 x[0] = ''\n1479             return ':'.join(map(self._print, x))\n1480         return (self._print(expr.parent) + r'\\left[' +\n1481                 latexslice(expr.rowslice) + ', ' +\n1482                 latexslice(expr.colslice) + r'\\right]')\n1483 \n1484     def _print_BlockMatrix(self, expr):\n1485         return self._print(expr.blocks)\n1486 \n1487     def _print_Transpose(self, expr):\n1488         mat = expr.arg\n1489         from sympy.matrices import MatrixSymbol\n1490         if not isinstance(mat, MatrixSymbol):\n1491             return r\"\\left(%s\\right)^T\" % self._print(mat)\n1492         else:\n1493             return \"%s^T\" % self._print(mat)\n1494 \n1495     def _print_Trace(self, expr):\n1496         mat = expr.arg\n1497         return r\"\\mathrm{tr}\\left(%s \\right)\" % self._print(mat)\n1498 \n1499     def _print_Adjoint(self, expr):\n1500         mat = expr.arg\n1501         from sympy.matrices import MatrixSymbol\n1502         if not isinstance(mat, MatrixSymbol):\n1503             return r\"\\left(%s\\right)^\\dagger\" % self._print(mat)\n1504         else:\n1505             return r\"%s^\\dagger\" % self._print(mat)\n1506 \n1507     def _print_MatMul(self, expr):\n1508         from sympy import MatMul, Mul\n1509 \n1510         parens = lambda x: self.parenthesize(x, precedence_traditional(expr), False)\n1511 \n1512         args = expr.args\n1513         if isinstance(args[0], Mul):\n1514             args = args[0].as_ordered_factors() + list(args[1:])\n1515         else:\n1516             args = list(args)\n1517 \n1518         if isinstance(expr, MatMul) and _coeff_isneg(expr):\n1519             if args[0] == -1:\n1520                 args = args[1:]\n1521             else:\n1522                 args[0] = -args[0]\n1523             return '- ' + ' '.join(map(parens, args))\n1524         else:\n1525             return ' '.join(map(parens, args))\n1526 \n1527     def _print_Mod(self, expr, exp=None):\n1528         if exp is not None:\n1529             return r'\\left(%s\\bmod{%s}\\right)^{%s}' % (self.parenthesize(expr.args[0],\n1530                     PRECEDENCE['Mul'], strict=True), self._print(expr.args[1]), self._print(exp))\n1531         return r'%s\\bmod{%s}' % (self.parenthesize(expr.args[0],\n1532                 PRECEDENCE['Mul'], strict=True), self._print(expr.args[1]))\n1533 \n1534     def _print_HadamardProduct(self, expr):\n1535         from sympy import Add, MatAdd, MatMul\n1536 \n1537         def parens(x):\n1538             if isinstance(x, (Add, MatAdd, MatMul)):\n1539                 return r\"\\left(%s\\right)\" % self._print(x)\n1540             return self._print(x)\n1541         return r' \\circ '.join(map(parens, expr.args))\n1542 \n1543     def _print_KroneckerProduct(self, expr):\n1544         from sympy import Add, MatAdd, MatMul\n1545 \n1546         def parens(x):\n1547             if isinstance(x, (Add, MatAdd, MatMul)):\n1548                 return r\"\\left(%s\\right)\" % self._print(x)\n1549             return self._print(x)\n1550         return r' \\otimes '.join(map(parens, expr.args))\n1551 \n1552     def _print_MatPow(self, expr):\n1553         base, exp = expr.base, expr.exp\n1554         from sympy.matrices import MatrixSymbol\n1555         if not isinstance(base, MatrixSymbol):\n1556             return r\"\\left(%s\\right)^{%s}\" % (self._print(base), self._print(exp))\n1557         else:\n1558             return \"%s^{%s}\" % (self._print(base), self._print(exp))\n1559 \n1560     def _print_ZeroMatrix(self, Z):\n1561         return r\"\\mathbb{0}\"\n1562 \n1563     def _print_Identity(self, I):\n1564         return r\"\\mathbb{I}\"\n1565 \n1566     def _print_NDimArray(self, expr):\n1567 \n1568         if expr.rank() == 0:\n1569             return self._print(expr[()])\n1570 \n1571         mat_str = self._settings['mat_str']\n1572         if mat_str is None:\n1573             if self._settings['mode'] == 'inline':\n1574                 mat_str = 'smallmatrix'\n1575             else:\n1576                 if (expr.rank() == 0) or (expr.shape[-1] <= 10):\n1577                     mat_str = 'matrix'\n1578                 else:\n1579                     mat_str = 'array'\n1580         block_str = r'\\begin{%MATSTR%}%s\\end{%MATSTR%}'\n1581         block_str = block_str.replace('%MATSTR%', mat_str)\n1582         if self._settings['mat_delim']:\n1583             left_delim = self._settings['mat_delim']\n1584             right_delim = self._delim_dict[left_delim]\n1585             block_str = r'\\left' + left_delim + block_str + \\\n1586                       r'\\right' + right_delim\n1587 \n1588         if expr.rank() == 0:\n1589             return block_str % \"\"\n1590 \n1591         level_str = [[]] + [[] for i in range(expr.rank())]\n1592         shape_ranges = [list(range(i)) for i in expr.shape]\n1593         for outer_i in itertools.product(*shape_ranges):\n1594             level_str[-1].append(self._print(expr[outer_i]))\n1595             even = True\n1596             for back_outer_i in range(expr.rank()-1, -1, -1):\n1597                 if len(level_str[back_outer_i+1]) < expr.shape[back_outer_i]:\n1598                     break\n1599                 if even:\n1600                     level_str[back_outer_i].append(r\" & \".join(level_str[back_outer_i+1]))\n1601                 else:\n1602                     level_str[back_outer_i].append(block_str % (r\"\\\\\".join(level_str[back_outer_i+1])))\n1603                     if len(level_str[back_outer_i+1]) == 1:\n1604                         level_str[back_outer_i][-1] = r\"\\left[\" + level_str[back_outer_i][-1] + r\"\\right]\"\n1605                 even = not even\n1606                 level_str[back_outer_i+1] = []\n1607 \n1608         out_str = level_str[0][0]\n1609 \n1610         if expr.rank() % 2 == 1:\n1611             out_str = block_str % out_str\n1612 \n1613         return out_str\n1614 \n1615     _print_ImmutableDenseNDimArray = _print_NDimArray\n1616     _print_ImmutableSparseNDimArray = _print_NDimArray\n1617     _print_MutableDenseNDimArray = _print_NDimArray\n1618     _print_MutableSparseNDimArray = _print_NDimArray\n1619 \n1620     def _printer_tensor_indices(self, name, indices, index_map={}):\n1621         out_str = self._print(name)\n1622         last_valence = None\n1623         prev_map = None\n1624         for index in indices:\n1625             new_valence = index.is_up\n1626             if ((index in index_map) or prev_map) and last_valence == new_valence:\n1627                 out_str += \",\"\n1628             if last_valence != new_valence:\n1629                 if last_valence is not None:\n1630                     out_str += \"}\"\n1631                 if index.is_up:\n1632                     out_str += \"{}^{\"\n1633                 else:\n1634                     out_str += \"{}_{\"\n1635             out_str += self._print(index.args[0])\n1636             if index in index_map:\n1637                 out_str += \"=\"\n1638                 out_str += self._print(index_map[index])\n1639                 prev_map = True\n1640             else:\n1641                 prev_map = False\n1642             last_valence = new_valence\n1643         if last_valence is not None:\n1644             out_str += \"}\"\n1645         return out_str\n1646 \n1647     def _print_Tensor(self, expr):\n1648         name = expr.args[0].args[0]\n1649         indices = expr.get_indices()\n1650         return self._printer_tensor_indices(name, indices)\n1651 \n1652     def _print_TensorElement(self, expr):\n1653         name = expr.expr.args[0].args[0]\n1654         indices = expr.expr.get_indices()\n1655         index_map = expr.index_map\n1656         return self._printer_tensor_indices(name, indices, index_map)\n1657 \n1658     def _print_TensMul(self, expr):\n1659         # prints expressions like \"A(a)\", \"3*A(a)\", \"(1+x)*A(a)\"\n1660         sign, args = expr._get_args_for_traditional_printer()\n1661         return sign + \"\".join(\n1662             [self.parenthesize(arg, precedence(expr)) for arg in args]\n1663         )\n1664 \n1665     def _print_TensAdd(self, expr):\n1666         a = []\n1667         args = expr.args\n1668         for x in args:\n1669             a.append(self.parenthesize(x, precedence(expr)))\n1670         a.sort()\n1671         s = ' + '.join(a)\n1672         s = s.replace('+ -', '- ')\n1673         return s\n1674 \n1675     def _print_TensorIndex(self, expr):\n1676         return \"{}%s{%s}\" % (\n1677             \"^\" if expr.is_up else \"_\",\n1678             self._print(expr.args[0])\n1679         )\n1680         return self._print(expr.args[0])\n1681 \n1682     def _print_tuple(self, expr):\n1683         return r\"\\left( %s\\right)\" % \\\n1684             r\", \\  \".join([ self._print(i) for i in expr ])\n1685 \n1686     def _print_TensorProduct(self, expr):\n1687         elements = [self._print(a) for a in expr.args]\n1688         return r' \\otimes '.join(elements)\n1689 \n1690     def _print_WedgeProduct(self, expr):\n1691         elements = [self._print(a) for a in expr.args]\n1692         return r' \\wedge '.join(elements)\n1693 \n1694     def _print_Tuple(self, expr):\n1695         return self._print_tuple(expr)\n1696 \n1697     def _print_list(self, expr):\n1698         return r\"\\left[ %s\\right]\" % \\\n1699             r\", \\  \".join([ self._print(i) for i in expr ])\n1700 \n1701     def _print_dict(self, d):\n1702         keys = sorted(d.keys(), key=default_sort_key)\n1703         items = []\n1704 \n1705         for key in keys:\n1706             val = d[key]\n1707             items.append(\"%s : %s\" % (self._print(key), self._print(val)))\n1708 \n1709         return r\"\\left\\{ %s\\right\\}\" % r\", \\  \".join(items)\n1710 \n1711     def _print_Dict(self, expr):\n1712         return self._print_dict(expr)\n1713 \n1714     def _print_DiracDelta(self, expr, exp=None):\n1715         if len(expr.args) == 1 or expr.args[1] == 0:\n1716             tex = r\"\\delta\\left(%s\\right)\" % self._print(expr.args[0])\n1717         else:\n1718             tex = r\"\\delta^{\\left( %s \\right)}\\left( %s \\right)\" % (\n1719                 self._print(expr.args[1]), self._print(expr.args[0]))\n1720         if exp:\n1721             tex = r\"\\left(%s\\right)^{%s}\" % (tex, exp)\n1722         return tex\n1723 \n1724     def _print_SingularityFunction(self, expr):\n1725         shift = self._print(expr.args[0] - expr.args[1])\n1726         power = self._print(expr.args[2])\n1727         tex = r\"{\\left\\langle %s \\right\\rangle}^{%s}\" % (shift, power)\n1728         return tex\n1729 \n1730     def _print_Heaviside(self, expr, exp=None):\n1731         tex = r\"\\theta\\left(%s\\right)\" % self._print(expr.args[0])\n1732         if exp:\n1733             tex = r\"\\left(%s\\right)^{%s}\" % (tex, exp)\n1734         return tex\n1735 \n1736     def _print_KroneckerDelta(self, expr, exp=None):\n1737         i = self._print(expr.args[0])\n1738         j = self._print(expr.args[1])\n1739         if expr.args[0].is_Atom and expr.args[1].is_Atom:\n1740             tex = r'\\delta_{%s %s}' % (i, j)\n1741         else:\n1742             tex = r'\\delta_{%s, %s}' % (i, j)\n1743         if exp is not None:\n1744             tex = r'\\left(%s\\right)^{%s}' % (tex, exp)\n1745         return tex\n1746 \n1747     def _print_LeviCivita(self, expr, exp=None):\n1748         indices = map(self._print, expr.args)\n1749         if all(x.is_Atom for x in expr.args):\n1750             tex = r'\\varepsilon_{%s}' % \" \".join(indices)\n1751         else:\n1752             tex = r'\\varepsilon_{%s}' % \", \".join(indices)\n1753         if exp:\n1754             tex = r'\\left(%s\\right)^{%s}' % (tex, exp)\n1755         return tex\n1756 \n1757     def _print_ProductSet(self, p):\n1758         if len(p.sets) > 1 and not has_variety(p.sets):\n1759             return self._print(p.sets[0]) + \"^{%d}\" % len(p.sets)\n1760         else:\n1761             return r\" \\times \".join(self._print(set) for set in p.sets)\n1762 \n1763     def _print_RandomDomain(self, d):\n1764         if hasattr(d, 'as_boolean'):\n1765             return 'Domain: ' + self._print(d.as_boolean())\n1766         elif hasattr(d, 'set'):\n1767             return ('Domain: ' + self._print(d.symbols) + ' in ' +\n1768                     self._print(d.set))\n1769         elif hasattr(d, 'symbols'):\n1770             return 'Domain on ' + self._print(d.symbols)\n1771         else:\n1772             return self._print(None)\n1773 \n1774     def _print_FiniteSet(self, s):\n1775         items = sorted(s.args, key=default_sort_key)\n1776         return self._print_set(items)\n1777 \n1778     def _print_set(self, s):\n1779         items = sorted(s, key=default_sort_key)\n1780         items = \", \".join(map(self._print, items))\n1781         return r\"\\left\\{%s\\right\\}\" % items\n1782 \n1783     _print_frozenset = _print_set\n1784 \n1785     def _print_Range(self, s):\n1786         dots = r'\\ldots'\n1787 \n1788         if s.start.is_infinite:\n1789             printset = s.start, dots, s[-1] - s.step, s[-1]\n1790         elif s.stop.is_infinite or len(s) > 4:\n1791             it = iter(s)\n1792             printset = next(it), next(it), dots, s[-1]\n1793         else:\n1794             printset = tuple(s)\n1795 \n1796         return (r\"\\left\\{\"\n1797               + r\", \".join(self._print(el) for el in printset)\n1798               + r\"\\right\\}\")\n1799 \n1800     def _print_SeqFormula(self, s):\n1801         if len(s.start.free_symbols) > 0 or len(s.stop.free_symbols) > 0:\n1802             return r\"\\left\\{%s\\right\\}_{%s=%s}^{%s}\" % (\n1803                 self._print(s.formula),\n1804                 self._print(s.variables[0]),\n1805                 self._print(s.start),\n1806                 self._print(s.stop)\n1807             )\n1808         if s.start is S.NegativeInfinity:\n1809             stop = s.stop\n1810             printset = (r'\\ldots', s.coeff(stop - 3), s.coeff(stop - 2),\n1811                 s.coeff(stop - 1), s.coeff(stop))\n1812         elif s.stop is S.Infinity or s.length > 4:\n1813             printset = s[:4]\n1814             printset.append(r'\\ldots')\n1815         else:\n1816             printset = tuple(s)\n1817 \n1818         return (r\"\\left[\"\n1819               + r\", \".join(self._print(el) for el in printset)\n1820               + r\"\\right]\")\n1821 \n1822     _print_SeqPer = _print_SeqFormula\n1823     _print_SeqAdd = _print_SeqFormula\n1824     _print_SeqMul = _print_SeqFormula\n1825 \n1826     def _print_Interval(self, i):\n1827         if i.start == i.end:\n1828             return r\"\\left\\{%s\\right\\}\" % self._print(i.start)\n1829 \n1830         else:\n1831             if i.left_open:\n1832                 left = '('\n1833             else:\n1834                 left = '['\n1835 \n1836             if i.right_open:\n1837                 right = ')'\n1838             else:\n1839                 right = ']'\n1840 \n1841             return r\"\\left%s%s, %s\\right%s\" % \\\n1842                    (left, self._print(i.start), self._print(i.end), right)\n1843 \n1844     def _print_AccumulationBounds(self, i):\n1845         return r\"\\left\\langle %s, %s\\right\\rangle\" % \\\n1846                 (self._print(i.min), self._print(i.max))\n1847 \n1848     def _print_Union(self, u):\n1849         return r\" \\cup \".join([self._print(i) for i in u.args])\n1850 \n1851     def _print_Complement(self, u):\n1852         return r\" \\setminus \".join([self._print(i) for i in u.args])\n1853 \n1854     def _print_Intersection(self, u):\n1855         return r\" \\cap \".join([self._print(i) for i in u.args])\n1856 \n1857     def _print_SymmetricDifference(self, u):\n1858         return r\" \\triangle \".join([self._print(i) for i in u.args])\n1859 \n1860     def _print_EmptySet(self, e):\n1861         return r\"\\emptyset\"\n1862 \n1863     def _print_Naturals(self, n):\n1864         return r\"\\mathbb{N}\"\n1865 \n1866     def _print_Naturals0(self, n):\n1867         return r\"\\mathbb{N}_0\"\n1868 \n1869     def _print_Integers(self, i):\n1870         return r\"\\mathbb{Z}\"\n1871 \n1872     def _print_Reals(self, i):\n1873         return r\"\\mathbb{R}\"\n1874 \n1875     def _print_Complexes(self, i):\n1876         return r\"\\mathbb{C}\"\n1877 \n1878     def _print_ImageSet(self, s):\n1879         sets = s.args[1:]\n1880         varsets = [r\"%s \\in %s\" % (self._print(var), self._print(setv))\n1881             for var, setv in zip(s.lamda.variables, sets)]\n1882         return r\"\\left\\{%s\\; |\\; %s\\right\\}\" % (\n1883             self._print(s.lamda.expr),\n1884             ', '.join(varsets))\n1885 \n1886     def _print_ConditionSet(self, s):\n1887         vars_print = ', '.join([self._print(var) for var in Tuple(s.sym)])\n1888         if s.base_set is S.UniversalSet:\n1889             return r\"\\left\\{%s \\mid %s \\right\\}\" % (\n1890             vars_print,\n1891             self._print(s.condition.as_expr()))\n1892 \n1893         return r\"\\left\\{%s \\mid %s \\in %s \\wedge %s \\right\\}\" % (\n1894             vars_print,\n1895             vars_print,\n1896             self._print(s.base_set),\n1897             self._print(s.condition))\n1898 \n1899     def _print_ComplexRegion(self, s):\n1900         vars_print = ', '.join([self._print(var) for var in s.variables])\n1901         return r\"\\left\\{%s\\; |\\; %s \\in %s \\right\\}\" % (\n1902             self._print(s.expr),\n1903             vars_print,\n1904             self._print(s.sets))\n1905 \n1906     def _print_Contains(self, e):\n1907         return r\"%s \\in %s\" % tuple(self._print(a) for a in e.args)\n1908 \n1909     def _print_FourierSeries(self, s):\n1910         return self._print_Add(s.truncate()) + self._print(r' + \\ldots')\n1911 \n1912     def _print_FormalPowerSeries(self, s):\n1913         return self._print_Add(s.infinite)\n1914 \n1915     def _print_FiniteField(self, expr):\n1916         return r\"\\mathbb{F}_{%s}\" % expr.mod\n1917 \n1918     def _print_IntegerRing(self, expr):\n1919         return r\"\\mathbb{Z}\"\n1920 \n1921     def _print_RationalField(self, expr):\n1922         return r\"\\mathbb{Q}\"\n1923 \n1924     def _print_RealField(self, expr):\n1925         return r\"\\mathbb{R}\"\n1926 \n1927     def _print_ComplexField(self, expr):\n1928         return r\"\\mathbb{C}\"\n1929 \n1930     def _print_PolynomialRing(self, expr):\n1931         domain = self._print(expr.domain)\n1932         symbols = \", \".join(map(self._print, expr.symbols))\n1933         return r\"%s\\left[%s\\right]\" % (domain, symbols)\n1934 \n1935     def _print_FractionField(self, expr):\n1936         domain = self._print(expr.domain)\n1937         symbols = \", \".join(map(self._print, expr.symbols))\n1938         return r\"%s\\left(%s\\right)\" % (domain, symbols)\n1939 \n1940     def _print_PolynomialRingBase(self, expr):\n1941         domain = self._print(expr.domain)\n1942         symbols = \", \".join(map(self._print, expr.symbols))\n1943         inv = \"\"\n1944         if not expr.is_Poly:\n1945             inv = r\"S_<^{-1}\"\n1946         return r\"%s%s\\left[%s\\right]\" % (inv, domain, symbols)\n1947 \n1948     def _print_Poly(self, poly):\n1949         cls = poly.__class__.__name__\n1950         terms = []\n1951         for monom, coeff in poly.terms():\n1952             s_monom = ''\n1953             for i, exp in enumerate(monom):\n1954                 if exp > 0:\n1955                     if exp == 1:\n1956                         s_monom += self._print(poly.gens[i])\n1957                     else:\n1958                         s_monom += self._print(pow(poly.gens[i], exp))\n1959 \n1960             if coeff.is_Add:\n1961                 if s_monom:\n1962                     s_coeff = r\"\\left(%s\\right)\" % self._print(coeff)\n1963                 else:\n1964                     s_coeff = self._print(coeff)\n1965             else:\n1966                 if s_monom:\n1967                     if coeff is S.One:\n1968                         terms.extend(['+', s_monom])\n1969                         continue\n1970 \n1971                     if coeff is S.NegativeOne:\n1972                         terms.extend(['-', s_monom])\n1973                         continue\n1974 \n1975                 s_coeff = self._print(coeff)\n1976 \n1977             if not s_monom:\n1978                 s_term = s_coeff\n1979             else:\n1980                 s_term = s_coeff + \" \" + s_monom\n1981 \n1982             if s_term.startswith('-'):\n1983                 terms.extend(['-', s_term[1:]])\n1984             else:\n1985                 terms.extend(['+', s_term])\n1986 \n1987         if terms[0] in ['-', '+']:\n1988             modifier = terms.pop(0)\n1989 \n1990             if modifier == '-':\n1991                 terms[0] = '-' + terms[0]\n1992 \n1993         expr = ' '.join(terms)\n1994         gens = list(map(self._print, poly.gens))\n1995         domain = \"domain=%s\" % self._print(poly.get_domain())\n1996 \n1997         args = \", \".join([expr] + gens + [domain])\n1998         if cls in accepted_latex_functions:\n1999             tex = r\"\\%s {\\left(%s \\right)}\" % (cls, args)\n2000         else:\n2001             tex = r\"\\operatorname{%s}{\\left( %s \\right)}\" % (cls, args)\n2002 \n2003         return tex\n2004 \n2005     def _print_ComplexRootOf(self, root):\n2006         cls = root.__class__.__name__\n2007         if cls == \"ComplexRootOf\":\n2008             cls = \"CRootOf\"\n2009         expr = self._print(root.expr)\n2010         index = root.index\n2011         if cls in accepted_latex_functions:\n2012             return r\"\\%s {\\left(%s, %d\\right)}\" % (cls, expr, index)\n2013         else:\n2014             return r\"\\operatorname{%s} {\\left(%s, %d\\right)}\" % (cls, expr, index)\n2015 \n2016     def _print_RootSum(self, expr):\n2017         cls = expr.__class__.__name__\n2018         args = [self._print(expr.expr)]\n2019 \n2020         if expr.fun is not S.IdentityFunction:\n2021             args.append(self._print(expr.fun))\n2022 \n2023         if cls in accepted_latex_functions:\n2024             return r\"\\%s {\\left(%s\\right)}\" % (cls, \", \".join(args))\n2025         else:\n2026             return r\"\\operatorname{%s} {\\left(%s\\right)}\" % (cls, \", \".join(args))\n2027 \n2028     def _print_PolyElement(self, poly):\n2029         mul_symbol = self._settings['mul_symbol_latex']\n2030         return poly.str(self, PRECEDENCE, \"{%s}^{%d}\", mul_symbol)\n2031 \n2032     def _print_FracElement(self, frac):\n2033         if frac.denom == 1:\n2034             return self._print(frac.numer)\n2035         else:\n2036             numer = self._print(frac.numer)\n2037             denom = self._print(frac.denom)\n2038             return r\"\\frac{%s}{%s}\" % (numer, denom)\n2039 \n2040     def _print_euler(self, expr, exp=None):\n2041         m, x = (expr.args[0], None) if len(expr.args) == 1 else expr.args\n2042         tex = r\"E_{%s}\" % self._print(m)\n2043         if exp is not None:\n2044             tex = r\"%s^{%s}\" % (tex, self._print(exp))\n2045         if x is not None:\n2046             tex = r\"%s\\left(%s\\right)\" % (tex, self._print(x))\n2047         return tex\n2048 \n2049     def _print_catalan(self, expr, exp=None):\n2050         tex = r\"C_{%s}\" % self._print(expr.args[0])\n2051         if exp is not None:\n2052             tex = r\"%s^{%s}\" % (tex, self._print(exp))\n2053         return tex\n2054 \n2055     def _print_MellinTransform(self, expr):\n2056         return r\"\\mathcal{M}_{%s}\\left[%s\\right]\\left(%s\\right)\" % (self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))\n2057 \n2058     def _print_InverseMellinTransform(self, expr):\n2059         return r\"\\mathcal{M}^{-1}_{%s}\\left[%s\\right]\\left(%s\\right)\" % (self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))\n2060 \n2061     def _print_LaplaceTransform(self, expr):\n2062         return r\"\\mathcal{L}_{%s}\\left[%s\\right]\\left(%s\\right)\" % (self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))\n2063 \n2064     def _print_InverseLaplaceTransform(self, expr):\n2065         return r\"\\mathcal{L}^{-1}_{%s}\\left[%s\\right]\\left(%s\\right)\" % (self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))\n2066 \n2067     def _print_FourierTransform(self, expr):\n2068         return r\"\\mathcal{F}_{%s}\\left[%s\\right]\\left(%s\\right)\" % (self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))\n2069 \n2070     def _print_InverseFourierTransform(self, expr):\n2071         return r\"\\mathcal{F}^{-1}_{%s}\\left[%s\\right]\\left(%s\\right)\" % (self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))\n2072 \n2073     def _print_SineTransform(self, expr):\n2074         return r\"\\mathcal{SIN}_{%s}\\left[%s\\right]\\left(%s\\right)\" % (self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))\n2075 \n2076     def _print_InverseSineTransform(self, expr):\n2077         return r\"\\mathcal{SIN}^{-1}_{%s}\\left[%s\\right]\\left(%s\\right)\" % (self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))\n2078 \n2079     def _print_CosineTransform(self, expr):\n2080         return r\"\\mathcal{COS}_{%s}\\left[%s\\right]\\left(%s\\right)\" % (self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))\n2081 \n2082     def _print_InverseCosineTransform(self, expr):\n2083         return r\"\\mathcal{COS}^{-1}_{%s}\\left[%s\\right]\\left(%s\\right)\" % (self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))\n2084 \n2085     def _print_DMP(self, p):\n2086         try:\n2087             if p.ring is not None:\n2088                 # TODO incorporate order\n2089                 return self._print(p.ring.to_sympy(p))\n2090         except SympifyError:\n2091             pass\n2092         return self._print(repr(p))\n2093 \n2094     def _print_DMF(self, p):\n2095         return self._print_DMP(p)\n2096 \n2097     def _print_Object(self, object):\n2098         return self._print(Symbol(object.name))\n2099 \n2100     def _print_Morphism(self, morphism):\n2101         domain = self._print(morphism.domain)\n2102         codomain = self._print(morphism.codomain)\n2103         return \"%s\\\\rightarrow %s\" % (domain, codomain)\n2104 \n2105     def _print_NamedMorphism(self, morphism):\n2106         pretty_name = self._print(Symbol(morphism.name))\n2107         pretty_morphism = self._print_Morphism(morphism)\n2108         return \"%s:%s\" % (pretty_name, pretty_morphism)\n2109 \n2110     def _print_IdentityMorphism(self, morphism):\n2111         from sympy.categories import NamedMorphism\n2112         return self._print_NamedMorphism(NamedMorphism(\n2113             morphism.domain, morphism.codomain, \"id\"))\n2114 \n2115     def _print_CompositeMorphism(self, morphism):\n2116         # All components of the morphism have names and it is thus\n2117         # possible to build the name of the composite.\n2118         component_names_list = [self._print(Symbol(component.name)) for\n2119                                 component in morphism.components]\n2120         component_names_list.reverse()\n2121         component_names = \"\\\\circ \".join(component_names_list) + \":\"\n2122 \n2123         pretty_morphism = self._print_Morphism(morphism)\n2124         return component_names + pretty_morphism\n2125 \n2126     def _print_Category(self, morphism):\n2127         return \"\\\\mathbf{%s}\" % self._print(Symbol(morphism.name))\n2128 \n2129     def _print_Diagram(self, diagram):\n2130         if not diagram.premises:\n2131             # This is an empty diagram.\n2132             return self._print(S.EmptySet)\n2133 \n2134         latex_result = self._print(diagram.premises)\n2135         if diagram.conclusions:\n2136             latex_result += \"\\\\Longrightarrow %s\" % \\\n2137                             self._print(diagram.conclusions)\n2138 \n2139         return latex_result\n2140 \n2141     def _print_DiagramGrid(self, grid):\n2142         latex_result = \"\\\\begin{array}{%s}\\n\" % (\"c\" * grid.width)\n2143 \n2144         for i in range(grid.height):\n2145             for j in range(grid.width):\n2146                 if grid[i, j]:\n2147                     latex_result += latex(grid[i, j])\n2148                 latex_result += \" \"\n2149                 if j != grid.width - 1:\n2150                     latex_result += \"& \"\n2151 \n2152             if i != grid.height - 1:\n2153                 latex_result += \"\\\\\\\\\"\n2154             latex_result += \"\\n\"\n2155 \n2156         latex_result += \"\\\\end{array}\\n\"\n2157         return latex_result\n2158 \n2159     def _print_FreeModule(self, M):\n2160         return '{%s}^{%s}' % (self._print(M.ring), self._print(M.rank))\n2161 \n2162     def _print_FreeModuleElement(self, m):\n2163         # Print as row vector for convenience, for now.\n2164         return r\"\\left[ %s \\right]\" % \",\".join(\n2165             '{' + self._print(x) + '}' for x in m)\n2166 \n2167     def _print_SubModule(self, m):\n2168         return r\"\\left\\langle %s \\right\\rangle\" % \",\".join(\n2169             '{' + self._print(x) + '}' for x in m.gens)\n2170 \n2171     def _print_ModuleImplementedIdeal(self, m):\n2172         return r\"\\left\\langle %s \\right\\rangle\" % \",\".join(\n2173             '{' + self._print(x) + '}' for [x] in m._module.gens)\n2174 \n2175     def _print_Quaternion(self, expr):\n2176         # TODO: This expression is potentially confusing,\n2177         # shall we print it as `Quaternion( ... )`?\n2178         s = [self.parenthesize(i, PRECEDENCE[\"Mul\"], strict=True) for i in expr.args]\n2179         a = [s[0]] + [i+\" \"+j for i, j in zip(s[1:], \"ijk\")]\n2180         return \" + \".join(a)\n2181 \n2182     def _print_QuotientRing(self, R):\n2183         # TODO nicer fractions for few generators...\n2184         return r\"\\frac{%s}{%s}\" % (self._print(R.ring), self._print(R.base_ideal))\n2185 \n2186     def _print_QuotientRingElement(self, x):\n2187         return r\"{%s} + {%s}\" % (self._print(x.data), self._print(x.ring.base_ideal))\n2188 \n2189     def _print_QuotientModuleElement(self, m):\n2190         return r\"{%s} + {%s}\" % (self._print(m.data),\n2191                                  self._print(m.module.killed_module))\n2192 \n2193     def _print_QuotientModule(self, M):\n2194         # TODO nicer fractions for few generators...\n2195         return r\"\\frac{%s}{%s}\" % (self._print(M.base),\n2196                                    self._print(M.killed_module))\n2197 \n2198     def _print_MatrixHomomorphism(self, h):\n2199         return r\"{%s} : {%s} \\to {%s}\" % (self._print(h._sympy_matrix()),\n2200             self._print(h.domain), self._print(h.codomain))\n2201 \n2202     def _print_BaseScalarField(self, field):\n2203         string = field._coord_sys._names[field._index]\n2204         return r'\\boldsymbol{\\mathrm{%s}}' % self._print(Symbol(string))\n2205 \n2206     def _print_BaseVectorField(self, field):\n2207         string = field._coord_sys._names[field._index]\n2208         return r'\\partial_{%s}' % self._print(Symbol(string))\n2209 \n2210     def _print_Differential(self, diff):\n2211         field = diff._form_field\n2212         if hasattr(field, '_coord_sys'):\n2213             string = field._coord_sys._names[field._index]\n2214             return r'\\mathrm{d}%s' % self._print(Symbol(string))\n2215         else:\n2216             return 'd(%s)' % self._print(field)\n2217             string = self._print(field)\n2218             return r'\\mathrm{d}\\left(%s\\right)' % string\n2219 \n2220     def _print_Tr(self, p):\n2221         #Todo: Handle indices\n2222         contents = self._print(p.args[0])\n2223         return r'\\mbox{Tr}\\left(%s\\right)' % (contents)\n2224 \n2225     def _print_totient(self, expr, exp=None):\n2226         if exp is not None:\n2227             return r'\\left(\\phi\\left(%s\\right)\\right)^{%s}' % (self._print(expr.args[0]),\n2228                     self._print(exp))\n2229         return r'\\phi\\left(%s\\right)' % self._print(expr.args[0])\n2230 \n2231     def _print_reduced_totient(self, expr, exp=None):\n2232         if exp is not None:\n2233             return r'\\left(\\lambda\\left(%s\\right)\\right)^{%s}' % (self._print(expr.args[0]),\n2234                     self._print(exp))\n2235         return r'\\lambda\\left(%s\\right)' % self._print(expr.args[0])\n2236 \n2237     def _print_divisor_sigma(self, expr, exp=None):\n2238         if len(expr.args) == 2:\n2239             tex = r\"_%s\\left(%s\\right)\" % tuple(map(self._print,\n2240                                                 (expr.args[1], expr.args[0])))\n2241         else:\n2242             tex = r\"\\left(%s\\right)\" % self._print(expr.args[0])\n2243         if exp is not None:\n2244             return r\"\\sigma^{%s}%s\" % (self._print(exp), tex)\n2245         return r\"\\sigma%s\" % tex\n2246 \n2247     def _print_udivisor_sigma(self, expr, exp=None):\n2248         if len(expr.args) == 2:\n2249             tex = r\"_%s\\left(%s\\right)\" % tuple(map(self._print,\n2250                                                 (expr.args[1], expr.args[0])))\n2251         else:\n2252             tex = r\"\\left(%s\\right)\" % self._print(expr.args[0])\n2253         if exp is not None:\n2254             return r\"\\sigma^*^{%s}%s\" % (self._print(exp), tex)\n2255         return r\"\\sigma^*%s\" % tex\n2256 \n2257     def _print_primenu(self, expr, exp=None):\n2258         if exp is not None:\n2259             return r'\\left(\\nu\\left(%s\\right)\\right)^{%s}' % (self._print(expr.args[0]),\n2260                     self._print(exp))\n2261         return r'\\nu\\left(%s\\right)' % self._print(expr.args[0])\n2262 \n2263     def _print_primeomega(self, expr, exp=None):\n2264         if exp is not None:\n2265             return r'\\left(\\Omega\\left(%s\\right)\\right)^{%s}' % (self._print(expr.args[0]),\n2266                     self._print(exp))\n2267         return r'\\Omega\\left(%s\\right)' % self._print(expr.args[0])\n2268 \n2269 \n2270 def translate(s):\n2271     r'''\n2272     Check for a modifier ending the string.  If present, convert the\n2273     modifier to latex and translate the rest recursively.\n2274 \n2275     Given a description of a Greek letter or other special character,\n2276     return the appropriate latex.\n2277 \n2278     Let everything else pass as given.\n2279 \n2280     >>> from sympy.printing.latex import translate\n2281     >>> translate('alphahatdotprime')\n2282     \"{\\\\dot{\\\\hat{\\\\alpha}}}'\"\n2283     '''\n2284     # Process the rest\n2285     tex = tex_greek_dictionary.get(s)\n2286     if tex:\n2287         return tex\n2288     elif s.lower() in greek_letters_set:\n2289         return \"\\\\\" + s.lower()\n2290     elif s in other_symbols:\n2291         return \"\\\\\" + s\n2292     else:\n2293         # Process modifiers, if any, and recurse\n2294         for key in sorted(modifier_dict.keys(), key=lambda k:len(k), reverse=True):\n2295             if s.lower().endswith(key) and len(s) > len(key):\n2296                 return modifier_dict[key](translate(s[:-len(key)]))\n2297         return s\n2298 \n2299 \n2300 def latex(expr, fold_frac_powers=False, fold_func_brackets=False,\n2301     fold_short_frac=None, inv_trig_style=\"abbreviated\",\n2302     itex=False, ln_notation=False, long_frac_ratio=None,\n2303     mat_delim=\"[\", mat_str=None, mode=\"plain\", mul_symbol=None,\n2304     order=None, symbol_names=None, root_notation=True,\n2305     mat_symbol_style=\"plain\", imaginary_unit=\"i\"):\n2306     r\"\"\"Convert the given expression to LaTeX string representation.\n2307 \n2308     Parameters\n2309     ==========\n2310     fold_frac_powers : boolean, optional\n2311         Emit ``^{p/q}`` instead of ``^{\\frac{p}{q}}`` for fractional powers.\n2312     fold_func_brackets : boolean, optional\n2313         Fold function brackets where applicable.\n2314     fold_short_frac : boolean, optional\n2315         Emit ``p / q`` instead of ``\\frac{p}{q}`` when the denominator is\n2316         simple enough (at most two terms and no powers). The default value is\n2317         ``True`` for inline mode, ``False`` otherwise.\n2318     inv_trig_style : string, optional\n2319         How inverse trig functions should be displayed. Can be one of\n2320         ``abbreviated``, ``full``, or ``power``. Defaults to ``abbreviated``.\n2321     itex : boolean, optional\n2322         Specifies if itex-specific syntax is used, including emitting\n2323         ``$$...$$``.\n2324     ln_notation : boolean, optional\n2325         If set to ``True``, ``\\ln`` is used instead of default ``\\log``.\n2326     long_frac_ratio : float or None, optional\n2327         The allowed ratio of the width of the numerator to the width of the\n2328         denominator before the printer breaks off long fractions. If ``None``\n2329         (the default value), long fractions are not broken up.\n2330     mat_delim : string, optional\n2331         The delimiter to wrap around matrices. Can be one of ``[``, ``(``, or\n2332         the empty string. Defaults to ``[``.\n2333     mat_str : string, optional\n2334         Which matrix environment string to emit. ``smallmatrix``, ``matrix``,\n2335         ``array``, etc. Defaults to ``smallmatrix`` for inline mode, ``matrix``\n2336         for matrices of no more than 10 columns, and ``array`` otherwise.\n2337     mode: string, optional\n2338         Specifies how the generated code will be delimited. ``mode`` can be one\n2339         of ``plain``, ``inline``, ``equation`` or ``equation*``.  If ``mode``\n2340         is set to ``plain``, then the resulting code will not be delimited at\n2341         all (this is the default). If ``mode`` is set to ``inline`` then inline\n2342         LaTeX ``$...$`` will be used. If ``mode`` is set to ``equation`` or\n2343         ``equation*``, the resulting code will be enclosed in the ``equation``\n2344         or ``equation*`` environment (remember to import ``amsmath`` for\n2345         ``equation*``), unless the ``itex`` option is set. In the latter case,\n2346         the ``$$...$$`` syntax is used.\n2347     mul_symbol : string or None, optional\n2348         The symbol to use for multiplication. Can be one of ``None``, ``ldot``,\n2349         ``dot``, or ``times``.\n2350     order: string, optional\n2351         Any of the supported monomial orderings (currently ``lex``, ``grlex``,\n2352         or ``grevlex``), ``old``, and ``none``. This parameter does nothing for\n2353         Mul objects. Setting order to ``old`` uses the compatibility ordering\n2354         for Add defined in Printer. For very large expressions, set the\n2355         ``order`` keyword to ``none`` if speed is a concern.\n2356     symbol_names : dictionary of strings mapped to symbols, optional\n2357         Dictionary of symbols and the custom strings they should be emitted as.\n2358     root_notation : boolean, optional\n2359         If set to ``False``, exponents of the form 1/n are printed in fractonal form.\n2360         Default is ``True``, to print exponent in root form.\n2361     mat_symbol_style : string, optional\n2362         Can be either ``plain`` (default) or ``bold``. If set to ``bold``,\n2363         a MatrixSymbol A will be printed as ``\\mathbf{A}``, otherwise as ``A``.\n2364     imaginary_unit : string, optional\n2365         String to use for the imaginary unit. Defined options are \"i\" (default)\n2366         and \"j\". Adding \"b\" or \"t\" in front gives ``\\mathrm`` or ``\\text``, so\n2367         \"bi\" leads to ``\\mathrm{i}`` which gives `\\mathrm{i}`.\n2368 \n2369     Notes\n2370     =====\n2371 \n2372     Not using a print statement for printing, results in double backslashes for\n2373     latex commands since that's the way Python escapes backslashes in strings.\n2374 \n2375     >>> from sympy import latex, Rational\n2376     >>> from sympy.abc import tau\n2377     >>> latex((2*tau)**Rational(7,2))\n2378     '8 \\\\sqrt{2} \\\\tau^{\\\\frac{7}{2}}'\n2379     >>> print(latex((2*tau)**Rational(7,2)))\n2380     8 \\sqrt{2} \\tau^{\\frac{7}{2}}\n2381 \n2382     Examples\n2383     ========\n2384 \n2385     >>> from sympy import latex, pi, sin, asin, Integral, Matrix, Rational, log\n2386     >>> from sympy.abc import x, y, mu, r, tau\n2387 \n2388     Basic usage:\n2389 \n2390     >>> print(latex((2*tau)**Rational(7,2)))\n2391     8 \\sqrt{2} \\tau^{\\frac{7}{2}}\n2392 \n2393     ``mode`` and ``itex`` options:\n2394 \n2395     >>> print(latex((2*mu)**Rational(7,2), mode='plain'))\n2396     8 \\sqrt{2} \\mu^{\\frac{7}{2}}\n2397     >>> print(latex((2*tau)**Rational(7,2), mode='inline'))\n2398     $8 \\sqrt{2} \\tau^{7 / 2}$\n2399     >>> print(latex((2*mu)**Rational(7,2), mode='equation*'))\n2400     \\begin{equation*}8 \\sqrt{2} \\mu^{\\frac{7}{2}}\\end{equation*}\n2401     >>> print(latex((2*mu)**Rational(7,2), mode='equation'))\n2402     \\begin{equation}8 \\sqrt{2} \\mu^{\\frac{7}{2}}\\end{equation}\n2403     >>> print(latex((2*mu)**Rational(7,2), mode='equation', itex=True))\n2404     $$8 \\sqrt{2} \\mu^{\\frac{7}{2}}$$\n2405     >>> print(latex((2*mu)**Rational(7,2), mode='plain'))\n2406     8 \\sqrt{2} \\mu^{\\frac{7}{2}}\n2407     >>> print(latex((2*tau)**Rational(7,2), mode='inline'))\n2408     $8 \\sqrt{2} \\tau^{7 / 2}$\n2409     >>> print(latex((2*mu)**Rational(7,2), mode='equation*'))\n2410     \\begin{equation*}8 \\sqrt{2} \\mu^{\\frac{7}{2}}\\end{equation*}\n2411     >>> print(latex((2*mu)**Rational(7,2), mode='equation'))\n2412     \\begin{equation}8 \\sqrt{2} \\mu^{\\frac{7}{2}}\\end{equation}\n2413     >>> print(latex((2*mu)**Rational(7,2), mode='equation', itex=True))\n2414     $$8 \\sqrt{2} \\mu^{\\frac{7}{2}}$$\n2415 \n2416     Fraction options:\n2417 \n2418     >>> print(latex((2*tau)**Rational(7,2), fold_frac_powers=True))\n2419     8 \\sqrt{2} \\tau^{7/2}\n2420     >>> print(latex((2*tau)**sin(Rational(7,2))))\n2421     \\left(2 \\tau\\right)^{\\sin{\\left(\\frac{7}{2} \\right)}}\n2422     >>> print(latex((2*tau)**sin(Rational(7,2)), fold_func_brackets=True))\n2423     \\left(2 \\tau\\right)^{\\sin {\\frac{7}{2}}}\n2424     >>> print(latex(3*x**2/y))\n2425     \\frac{3 x^{2}}{y}\n2426     >>> print(latex(3*x**2/y, fold_short_frac=True))\n2427     3 x^{2} / y\n2428     >>> print(latex(Integral(r, r)/2/pi, long_frac_ratio=2))\n2429     \\frac{\\int r\\, dr}{2 \\pi}\n2430     >>> print(latex(Integral(r, r)/2/pi, long_frac_ratio=0))\n2431     \\frac{1}{2 \\pi} \\int r\\, dr\n2432 \n2433     Multiplication options:\n2434 \n2435     >>> print(latex((2*tau)**sin(Rational(7,2)), mul_symbol=\"times\"))\n2436     \\left(2 \\times \\tau\\right)^{\\sin{\\left(\\frac{7}{2} \\right)}}\n2437 \n2438     Trig options:\n2439 \n2440     >>> print(latex(asin(Rational(7,2))))\n2441     \\operatorname{asin}{\\left(\\frac{7}{2} \\right)}\n2442     >>> print(latex(asin(Rational(7,2)), inv_trig_style=\"full\"))\n2443     \\arcsin{\\left(\\frac{7}{2} \\right)}\n2444     >>> print(latex(asin(Rational(7,2)), inv_trig_style=\"power\"))\n2445     \\sin^{-1}{\\left(\\frac{7}{2} \\right)}\n2446 \n2447     Matrix options:\n2448 \n2449     >>> print(latex(Matrix(2, 1, [x, y])))\n2450     \\left[\\begin{matrix}x\\\\y\\end{matrix}\\right]\n2451     >>> print(latex(Matrix(2, 1, [x, y]), mat_str = \"array\"))\n2452     \\left[\\begin{array}{c}x\\\\y\\end{array}\\right]\n2453     >>> print(latex(Matrix(2, 1, [x, y]), mat_delim=\"(\"))\n2454     \\left(\\begin{matrix}x\\\\y\\end{matrix}\\right)\n2455 \n2456     Custom printing of symbols:\n2457 \n2458     >>> print(latex(x**2, symbol_names={x: 'x_i'}))\n2459     x_i^{2}\n2460 \n2461     Logarithms:\n2462 \n2463     >>> print(latex(log(10)))\n2464     \\log{\\left(10 \\right)}\n2465     >>> print(latex(log(10), ln_notation=True))\n2466     \\ln{\\left(10 \\right)}\n2467 \n2468     ``latex()`` also supports the builtin container types list, tuple, and\n2469     dictionary.\n2470 \n2471     >>> print(latex([2/x, y], mode='inline'))\n2472     $\\left[ 2 / x, \\  y\\right]$\n2473 \n2474     \"\"\"\n2475     if symbol_names is None:\n2476         symbol_names = {}\n2477 \n2478     settings = {\n2479         'fold_frac_powers' : fold_frac_powers,\n2480         'fold_func_brackets' : fold_func_brackets,\n2481         'fold_short_frac' : fold_short_frac,\n2482         'inv_trig_style' : inv_trig_style,\n2483         'itex' : itex,\n2484         'ln_notation' : ln_notation,\n2485         'long_frac_ratio' : long_frac_ratio,\n2486         'mat_delim' : mat_delim,\n2487         'mat_str' : mat_str,\n2488         'mode' : mode,\n2489         'mul_symbol' : mul_symbol,\n2490         'order' : order,\n2491         'symbol_names' : symbol_names,\n2492         'root_notation' : root_notation,\n2493         'mat_symbol_style' : mat_symbol_style,\n2494         'imaginary_unit' : imaginary_unit,\n2495     }\n2496 \n2497     return LatexPrinter(settings).doprint(expr)\n2498 \n2499 \n2500 def print_latex(expr, **settings):\n2501     \"\"\"Prints LaTeX representation of the given expression. Takes the same\n2502     settings as ``latex()``.\"\"\"\n2503     print(latex(expr, **settings))\n",
        "intended_behavior": "Given that LaTeX printing is a significant part of SymPy's output capabilities, ensuring that this module can handle and correctly print the SymPy representations of Mathematica matrices and arrays is essential. This might involve modifying or extending the LaTeX printer to detect when a matrix or array (possibly parsed from Mathematica syntax) is being printed and applying the correct formatting so that the output resembles or is compatible with Mathematica's own representation, or more generally, is mathematically accurate. If necessary, specific case handling for arrays and matrices originating from Mathematica syntax might be added to preserve the fidelity of the original expressions."
    }
]