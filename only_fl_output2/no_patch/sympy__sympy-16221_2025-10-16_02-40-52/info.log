2025-10-16 02:40:52.882 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-16 02:41:01.186 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=119, output_tokens=12, cost=0.001550
2025-10-16 02:41:01.187 | INFO     | Test agent decides that the issue statement does not contain reproduction steps; skipping reproducer tracing
2025-10-16 02:41:01.191 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-16 02:41:09.883 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=428, output_tokens=304, cost=0.013400
2025-10-16 02:41:09.887 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-16 02:41:13.026 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=658, output_tokens=58, cost=0.008320
2025-10-16 02:41:13.028 | DEBUG    | Extracted a valid json.
2025-10-16 02:41:13.028 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_class(\"Print\")",
        "search_method(\"print\")",
        "search_code(\"matrix\")",
        "search_code(\"array\")",
        "search_code(\"Mathematica\")"
    ],
    "bug_locations": []
}
2025-10-16 02:41:21.911 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-16 02:41:21.912 | DEBUG    | <Agent search> Analyzing search results.
2025-10-16 02:41:41.284 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=6561, output_tokens=742, cost=0.087870
2025-10-16 02:41:41.291 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-16 02:41:50.489 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=7519, output_tokens=335, cost=0.085240
2025-10-16 02:41:50.496 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-16 02:41:59.435 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=689, output_tokens=319, cost=0.016460
2025-10-16 02:41:59.436 | DEBUG    | Extracted a valid json.
2025-10-16 02:41:59.436 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "sympy/parsing/mathematica.py",
            "class": "",
            "method": "",
            "intended_behavior": "This file is crucial for parsing Mathematica expressions into SymPy representations. To resolve the issue, it should be ensured this module can correctly parse and translate Mathematica matrices and arrays into SymPy's equivalent representations. If necessary, new handling routines or enhancements should be added specifically targeting the representation of matrices and arrays from Mathematica, including how they are represented in textual or printed form. This might involve adding new methods or enhancing existing ones to parse Mathematica syntax for arrays and matrices, ensuring they are converted into appropriate SymPy objects that can be printed correctly."
        },
        {
            "file": "sympy/printing/latex.py",
            "class": "",
            "method": "",
            "intended_behavior": "Given that LaTeX printing is a significant part of SymPy's output capabilities, ensuring that this module can handle and correctly print the SymPy representations of Mathematica matrices and arrays is essential. This might involve modifying or extending the LaTeX printer to detect when a matrix or array (possibly parsed from Mathematica syntax) is being printed and applying the correct formatting so that the output resembles or is compatible with Mathematica's own representation, or more generally, is mathematically accurate. If necessary, specific case handling for arrays and matrices originating from Mathematica syntax might be added to preserve the fidelity of the original expressions."
        }
    ]
}
2025-10-16 02:41:59.446 | DEBUG    | Bug location extracted successfully: [<file>sympy/parsing/mathematica.py</file>
<class>None</class>
<method>None</method>
<code>
1 from __future__ import print_function, division
2 
3 from itertools import product
4 import re
5 from sympy import sympify
6 
7 
8 def mathematica(s, additional_translations=None):
9     '''Users can add their own translation dictionary
10     # Example
11     In [1]: mathematica('Log3[9]', {'Log3[x]':'log(x,3)'})
12     Out[1]: 2
13     In [2]: mathematica('F[7,5,3]', {'F[*x]':'Max(*x)*Min(*x)'})
14     Out[2]: 21
15     variable-length argument needs '*' character '''
16 
17     parser = MathematicaParser(additional_translations)
18     return sympify(parser.parse(s))
19 
20 
21 def _deco(cls):
22     cls._initialize_class()
23     return cls
24 
25 
26 @_deco
27 class MathematicaParser(object):
28     '''An instance of this class converts a string of a basic Mathematica
29     expression to SymPy style. Output is string type.'''
30 
31     # left: Mathematica, right: SymPy
32     CORRESPONDENCES = {
33         'Sqrt[x]': 'sqrt(x)',
34         'Exp[x]': 'exp(x)',
35         'Log[x]': 'log(x)',
36         'Log[x,y]': 'log(y,x)',
37         'Log2[x]': 'log(x,2)',
38         'Log10[x]': 'log(x,10)',
39         'Mod[x,y]': 'Mod(x,y)',
40         'Max[*x]': 'Max(*x)',
41         'Min[*x]': 'Min(*x)',
42     }
43 
44     # trigonometric, e.t.c.
45     for arc, tri, h in product(('', 'Arc'), (
46             'Sin', 'Cos', 'Tan', 'Cot', 'Sec', 'Csc'), ('', 'h')):
47         fm = arc + tri + h + '[x]'
48         if arc:  # arc func
49             fs = 'a' + tri.lower() + h + '(x)'
50         else:    # non-arc func
51             fs = tri.lower() + h + '(x)'
52         CORRESPONDENCES.update({fm: fs})
53 
54     REPLACEMENTS = {
55         ' ': '',
56         '^': '**',
57         '{': '[',
58         '}': ']',
59     }
60 
61     RULES = {
62         # a single whitespace to '*'
63         'whitespace': (
64             re.compile(r'''
65                 (?<=[a-zA-Z\d])     # a letter or a number
66                 \                   # a whitespace
67                 (?=[a-zA-Z\d])      # a letter or a number
68                 ''', re.VERBOSE),
69             '*'),
70 
71         # add omitted '*' character
72         'add*_1': (
73             re.compile(r'''
74                 (?<=[])\d])         # ], ) or a number
75                                     # ''
76                 (?=[(a-zA-Z])       # ( or a single letter
77                 ''', re.VERBOSE),
78             '*'),
79 
80         # add omitted '*' character (variable letter preceding)
81         'add*_2': (
82             re.compile(r'''
83                 (?<=[a-zA-Z])       # a letter
84                 \(                  # ( as a character
85                 (?=.)               # any characters
86                 ''', re.VERBOSE),
87             '*('),
88 
89         # convert 'Pi' to 'pi'
90         'Pi': (
91             re.compile(r'''
92                 (?:
93                 \A|(?<=[^a-zA-Z])
94                 )
95                 Pi                  # 'Pi' is 3.14159... in Mathematica
96                 (?=[^a-zA-Z])
97                 ''', re.VERBOSE),
98             'pi'),
99     }
100 
101     # Mathematica function name pattern
102     FM_PATTERN = re.compile(r'''
103                 (?:
104                 \A|(?<=[^a-zA-Z])   # at the top or a non-letter
105                 )
106                 [A-Z][a-zA-Z\d]*    # Function
107                 (?=\[)              # [ as a character
108                 ''', re.VERBOSE)
109 
110     # list or matrix pattern (for future usage)
111     ARG_MTRX_PATTERN = re.compile(r'''
112                 \{.*\}
113                 ''', re.VERBOSE)
114 
115     # regex string for function argument pattern
116     ARGS_PATTERN_TEMPLATE = r'''
117                 (?:
118                 \A|(?<=[^a-zA-Z])
119                 )
120                 {arguments}         # model argument like x, y,...
121                 (?=[^a-zA-Z])
122                 '''
123 
124     # will contain transformed CORRESPONDENCES dictionary
125     TRANSLATIONS = {}
126 
127     # cache for a raw users' translation dictionary
128     cache_original = {}
129 
130     # cache for a compiled users' translation dictionary
131     cache_compiled = {}
132 
133     @classmethod
134     def _initialize_class(cls):
135         # get a transformed CORRESPONDENCES dictionary
136         d = cls._compile_dictionary(cls.CORRESPONDENCES)
137         cls.TRANSLATIONS.update(d)
138 
139     def __init__(self, additional_translations=None):
140         self.translations = {}
141 
142         # update with TRANSLATIONS (class constant)
143         self.translations.update(self.TRANSLATIONS)
144 
145         if additional_translations is None:
146             additional_translations = {}
147 
148         # check the latest added translations
149         if self.__class__.cache_original != additional_translations:
150             if not isinstance(additional_translations, dict):
151                 raise ValueError('The argument must be dict type')
152 
153             # get a transformed additional_translations dictionary
154             d = self._compile_dictionary(additional_translations)
155 
156             # update cache
157             self.__class__.cache_original = additional_translations
158             self.__class__.cache_compiled = d
159 
160         # merge user's own translations
161         self.translations.update(self.__class__.cache_compiled)
162 
163     @classmethod
164     def _compile_dictionary(cls, dic):
165         # for return
166         d = {}
167 
168         for fm, fs in dic.items():
169             # check function form
170             cls._check_input(fm)
171             cls._check_input(fs)
172 
173             # uncover '*' hiding behind a whitespace
174             fm = cls._apply_rules(fm, 'whitespace')
175             fs = cls._apply_rules(fs, 'whitespace')
176 
177             # remove whitespace(s)
178             fm = cls._replace(fm, ' ')
179             fs = cls._replace(fs, ' ')
180 
181             # search Mathematica function name
182             m = cls.FM_PATTERN.search(fm)
183 
184             # if no-hit
185             if m is None:
186                 err = "'{f}' function form is invalid.".format(f=fm)
187                 raise ValueError(err)
188 
189             # get Mathematica function name like 'Log'
190             fm_name = m.group()
191 
192             # get arguments of Mathematica function
193             args, end = cls._get_args(m)
194 
195             # function side check. (e.g.) '2*Func[x]' is invalid.
196             if m.start() != 0 or end != len(fm):
197                 err = "'{f}' function form is invalid.".format(f=fm)
198                 raise ValueError(err)
199 
200             # check the last argument's 1st character
201             if args[-1][0] == '*':
202                 key_arg = '*'
203             else:
204                 key_arg = len(args)
205 
206             key = (fm_name, key_arg)
207 
208             # convert '*x' to '\\*x' for regex
209             re_args = [x if x[0] != '*' else '\\' + x for x in args]
210 
211             # for regex. Example: (?:(x|y|z))
212             xyz = '(?:(' + '|'.join(re_args) + '))'
213 
214             # string for regex compile
215             patStr = cls.ARGS_PATTERN_TEMPLATE.format(arguments=xyz)
216 
217             pat = re.compile(patStr, re.VERBOSE)
218 
219             # update dictionary
220             d[key] = {}
221             d[key]['fs'] = fs  # SymPy function template
222             d[key]['args'] = args  # args are ['x', 'y'] for example
223             d[key]['pat'] = pat
224 
225         return d
226 
227     def _convert_function(self, s):
228         '''Parse Mathematica function to SymPy one'''
229 
230         # compiled regex object
231         pat = self.FM_PATTERN
232 
233         scanned = ''                # converted string
234         cur = 0                     # position cursor
235         while True:
236             m = pat.search(s)
237 
238             if m is None:
239                 # append the rest of string
240                 scanned += s
241                 break
242 
243             # get Mathematica function name
244             fm = m.group()
245 
246             # get arguments, and the end position of fm function
247             args, end = self._get_args(m)
248 
249             # the start position of fm function
250             bgn = m.start()
251 
252             # convert Mathematica function to SymPy one
253             s = self._convert_one_function(s, fm, args, bgn, end)
254 
255             # update cursor
256             cur = bgn
257 
258             # append converted part
259             scanned += s[:cur]
260 
261             # shrink s
262             s = s[cur:]
263 
264         return scanned
265 
266     def _convert_one_function(self, s, fm, args, bgn, end):
267         # no variable-length argument
268         if (fm, len(args)) in self.translations:
269             key = (fm, len(args))
270 
271             # x, y,... model arguments
272             x_args = self.translations[key]['args']
273 
274             # make CORRESPONDENCES between model arguments and actual ones
275             d = {k: v for k, v in zip(x_args, args)}
276 
277         # with variable-length argument
278         elif (fm, '*') in self.translations:
279             key = (fm, '*')
280 
281             # x, y,..*args (model arguments)
282             x_args = self.translations[key]['args']
283 
284             # make CORRESPONDENCES between model arguments and actual ones
285             d = {}
286             for i, x in enumerate(x_args):
287                 if x[0] == '*':
288                     d[x] = ','.join(args[i:])
289                     break
290                 d[x] = args[i]
291 
292         # out of self.translations
293         else:
294             err = "'{f}' is out of the whitelist.".format(f=fm)
295             raise ValueError(err)
296 
297         # template string of converted function
298         template = self.translations[key]['fs']
299 
300         # regex pattern for x_args
301         pat = self.translations[key]['pat']
302 
303         scanned = ''
304         cur = 0
305         while True:
306             m = pat.search(template)
307 
308             if m is None:
309                 scanned += template
310                 break
311 
312             # get model argument
313             x = m.group()
314 
315             # get a start position of the model argument
316             xbgn = m.start()
317 
318             # add the corresponding actual argument
319             scanned += template[:xbgn] + d[x]
320 
321             # update cursor to the end of the model argument
322             cur = m.end()
323 
324             # shrink template
325             template = template[cur:]
326 
327         # update to swapped string
328         s = s[:bgn] + scanned + s[end:]
329 
330         return s
331 
332     @classmethod
333     def _get_args(cls, m):
334         '''Get arguments of a Mathematica function'''
335 
336         s = m.string                # whole string
337         anc = m.end() + 1           # pointing the first letter of arguments
338         square, curly = [], []      # stack for brakets
339         args = []
340 
341         # current cursor
342         cur = anc
343         for i, c in enumerate(s[anc:], anc):
344             # extract one argument
345             if c == ',' and (not square) and (not curly):
346                 args.append(s[cur:i])       # add an argument
347                 cur = i + 1                 # move cursor
348 
349             # handle list or matrix (for future usage)
350             if c == '{':
351                 curly.append(c)
352             elif c == '}':
353                 curly.pop()
354 
355             # seek corresponding ']' with skipping irrevant ones
356             if c == '[':
357                 square.append(c)
358             elif c == ']':
359                 if square:
360                     square.pop()
361                 else:   # empty stack
362                     args.append(s[cur:i])
363                     break
364 
365         # the next position to ']' bracket (the function end)
366         func_end = i + 1
367 
368         return args, func_end
369 
370     @classmethod
371     def _replace(cls, s, bef):
372         aft = cls.REPLACEMENTS[bef]
373         s = s.replace(bef, aft)
374         return s
375 
376     @classmethod
377     def _apply_rules(cls, s, bef):
378         pat, aft = cls.RULES[bef]
379         return pat.sub(aft, s)
380 
381     @classmethod
382     def _check_input(cls, s):
383         for bracket in (('[', ']'), ('{', '}'), ('(', ')')):
384             if s.count(bracket[0]) != s.count(bracket[1]):
385                 err = "'{f}' function form is invalid.".format(f=s)
386                 raise ValueError(err)
387 
388         if '{' in s:
389             err = "Currently list is not supported.".format(f=s)
390             raise ValueError(err)
391 
392     def parse(self, s):
393         # input check
394         self._check_input(s)
395 
396         # uncover '*' hiding behind a whitespace
397         s = self._apply_rules(s, 'whitespace')
398 
399         # remove whitespace(s)
400         s = self._replace(s, ' ')
401 
402         # add omitted '*' character
403         s = self._apply_rules(s, 'add*_1')
404         s = self._apply_rules(s, 'add*_2')
405 
406         # translate function
407         s = self._convert_function(s)
408 
409         # '^' to '**'
410         s = self._replace(s, '^')
411 
412         # 'Pi' to 'pi'
413         s = self._apply_rules(s, 'Pi')
414 
415         # '{', '}' to '[', ']', respectively
416 #        s = cls._replace(s, '{')   # currently list is not taken into account
417 #        s = cls._replace(s, '}')
418 
419         return s

</code><intended_behavior>This file is crucial for parsing Mathematica expressions into SymPy representations. To resolve the issue, it should be ensured this module can correctly parse and translate Mathematica matrices and arrays into SymPy's equivalent representations. If necessary, new handling routines or enhancements should be added specifically targeting the representation of matrices and arrays from Mathematica, including how they are represented in textual or printed form. This might involve adding new methods or enhancing existing ones to parse Mathematica syntax for arrays and matrices, ensuring they are converted into appropriate SymPy objects that can be printed correctly.</intended_behavior>, <file>sympy/printing/latex.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2 A Printer which converts an expression into its LaTeX equivalent.
3 """
4 
5 from __future__ import print_function, division
6 
7 import itertools
8 
9 from sympy.core import S, Add, Symbol, Mod
10 from sympy.core.alphabets import greeks
11 from sympy.core.containers import Tuple
12 from sympy.core.function import _coeff_isneg, AppliedUndef, Derivative
13 from sympy.core.operations import AssocOp
14 from sympy.core.sympify import SympifyError
15 from sympy.logic.boolalg import true
16 
17 ## sympy.printing imports
18 from sympy.printing.precedence import precedence_traditional
19 from sympy.printing.printer import Printer
20 from sympy.printing.conventions import split_super_sub, requires_partial
21 from sympy.printing.precedence import precedence, PRECEDENCE
22 
23 import mpmath.libmp as mlib
24 from mpmath.libmp import prec_to_dps
25 
26 from sympy.core.compatibility import default_sort_key, range
27 from sympy.utilities.iterables import has_variety
28 
29 import re
30 
31 # Hand-picked functions which can be used directly in both LaTeX and MathJax
32 # Complete list at https://docs.mathjax.org/en/latest/tex.html#supported-latex-commands
33 # This variable only contains those functions which sympy uses.
34 accepted_latex_functions = ['arcsin', 'arccos', 'arctan', 'sin', 'cos', 'tan',
35                     'sinh', 'cosh', 'tanh', 'sqrt', 'ln', 'log', 'sec', 'csc',
36                     'cot', 'coth', 're', 'im', 'frac', 'root', 'arg',
37                     ]
38 
39 tex_greek_dictionary = {
40     'Alpha': 'A',
41     'Beta': 'B',
42     'Gamma': r'\Gamma',
43     'Delta': r'\Delta',
44     'Epsilon': 'E',
45     'Zeta': 'Z',
46     'Eta': 'H',
47     'Theta': r'\Theta',
48     'Iota': 'I',
49     'Kappa': 'K',
50     'Lambda': r'\Lambda',
51     'Mu': 'M',
52     'Nu': 'N',
53     'Xi': r'\Xi',
54     'omicron': 'o',
55     'Omicron': 'O',
56     'Pi': r'\Pi',
57     'Rho': 'P',
58     'Sigma': r'\Sigma',
59     'Tau': 'T',
60     'Upsilon': r'\Upsilon',
61     'Phi': r'\Phi',
62     'Chi': 'X',
63     'Psi': r'\Psi',
64     'Omega': r'\Omega',
65     'lamda': r'\lambda',
66     'Lamda': r'\Lambda',
67     'khi': r'\chi',
68     'Khi': r'X',
69     'varepsilon': r'\varepsilon',
70     'varkappa': r'\varkappa',
71     'varphi': r'\varphi',
72     'varpi': r'\varpi',
73     'varrho': r'\varrho',
74     'varsigma': r'\varsigma',
75     'vartheta': r'\vartheta',
76 }
77 
78 other_symbols = set(['aleph', 'beth', 'daleth', 'gimel', 'ell', 'eth', 'hbar',
79                      'hslash', 'mho', 'wp', ])
80 
81 # Variable name modifiers
82 modifier_dict = {
83     # Accents
84     'mathring': lambda s: r'\mathring{'+s+r'}',
85     'ddddot': lambda s: r'\ddddot{'+s+r'}',
86     'dddot': lambda s: r'\dddot{'+s+r'}',
87     'ddot': lambda s: r'\ddot{'+s+r'}',
88     'dot': lambda s: r'\dot{'+s+r'}',
89     'check': lambda s: r'\check{'+s+r'}',
90     'breve': lambda s: r'\breve{'+s+r'}',
91     'acute': lambda s: r'\acute{'+s+r'}',
92     'grave': lambda s: r'\grave{'+s+r'}',
93     'tilde': lambda s: r'\tilde{'+s+r'}',
94     'hat': lambda s: r'\hat{'+s+r'}',
95     'bar': lambda s: r'\bar{'+s+r'}',
96     'vec': lambda s: r'\vec{'+s+r'}',
97     'prime': lambda s: "{"+s+"}'",
98     'prm': lambda s: "{"+s+"}'",
99     # Faces
100     'bold': lambda s: r'\boldsymbol{'+s+r'}',
101     'bm': lambda s: r'\boldsymbol{'+s+r'}',
102     'cal': lambda s: r'\mathcal{'+s+r'}',
103     'scr': lambda s: r'\mathscr{'+s+r'}',
104     'frak': lambda s: r'\mathfrak{'+s+r'}',
105     # Brackets
106     'norm': lambda s: r'\left\|{'+s+r'}\right\|',
107     'avg': lambda s: r'\left\langle{'+s+r'}\right\rangle',
108     'abs': lambda s: r'\left|{'+s+r'}\right|',
109     'mag': lambda s: r'\left|{'+s+r'}\right|',
110 }
111 
112 greek_letters_set = frozenset(greeks)
113 
114 _between_two_numbers_p = (
115     re.compile(r'[0-9][} ]*$'),  # search
116     re.compile(r'[{ ]*[-+0-9]'),  # match
117 )
118 
119 
120 class LatexPrinter(Printer):
121     printmethod = "_latex"
122 
123     _default_settings = {
124         "fold_frac_powers": False,
125         "fold_func_brackets": False,
126         "fold_short_frac": None,
127         "inv_trig_style": "abbreviated",
128         "itex": False,
129         "ln_notation": False,
130         "long_frac_ratio": None,
131         "mat_delim": "[",
132         "mat_str": None,
133         "mode": "plain",
134         "mul_symbol": None,
135         "order": None,
136         "symbol_names": {},
137         "root_notation": True,
138         "mat_symbol_style": "plain",
139         "imaginary_unit": "i",
140     }
141 
142     def __init__(self, settings=None):
143         Printer.__init__(self, settings)
144 
145         if 'mode' in self._settings:
146             valid_modes = ['inline', 'plain', 'equation',
147                            'equation*']
148             if self._settings['mode'] not in valid_modes:
149                 raise ValueError("'mode' must be one of 'inline', 'plain', "
150                     "'equation' or 'equation*'")
151 
152         if self._settings['fold_short_frac'] is None and \
153                 self._settings['mode'] == 'inline':
154             self._settings['fold_short_frac'] = True
155 
156         mul_symbol_table = {
157             None: r" ",
158             "ldot": r" \,.\, ",
159             "dot": r" \cdot ",
160             "times": r" \times "
161         }
162         try:
163             self._settings['mul_symbol_latex'] = \
164                 mul_symbol_table[self._settings['mul_symbol']]
165         except KeyError:
166             self._settings['mul_symbol_latex'] = \
167                 self._settings['mul_symbol']
168         try:
169             self._settings['mul_symbol_latex_numbers'] = \
170                 mul_symbol_table[self._settings['mul_symbol'] or 'dot']
171         except KeyError:
172             if (self._settings['mul_symbol'].strip() in
173                     ['', ' ', '\\', '\\,', '\\:', '\\;', '\\quad']):
174                 self._settings['mul_symbol_latex_numbers'] = \
175                     mul_symbol_table['dot']
176             else:
177                 self._settings['mul_symbol_latex_numbers'] = \
178                     self._settings['mul_symbol']
179 
180         self._delim_dict = {'(': ')', '[': ']'}
181 
182         imaginary_unit_table = {
183             None: r"i",
184             "i": r"i",
185             "ri": r"\mathrm{i}",
186             "ti": r"\text{i}",
187             "j": r"j",
188             "rj": r"\mathrm{j}",
189             "tj": r"\text{j}",
190         }
191         try:
192             self._settings['imaginary_unit_latex'] = \
193                 imaginary_unit_table[self._settings['imaginary_unit']]
194         except KeyError:
195             self._settings['imaginary_unit_latex'] = \
196                 self._settings['imaginary_unit']
197 
198     def parenthesize(self, item, level, strict=False):
199         prec_val = precedence_traditional(item)
200         if (prec_val < level) or ((not strict) and prec_val <= level):
201             return r"\left(%s\right)" % self._print(item)
202         else:
203             return self._print(item)
204 
205     def doprint(self, expr):
206         tex = Printer.doprint(self, expr)
207 
208         if self._settings['mode'] == 'plain':
209             return tex
210         elif self._settings['mode'] == 'inline':
211             return r"$%s$" % tex
212         elif self._settings['itex']:
213             return r"$$%s$$" % tex
214         else:
215             env_str = self._settings['mode']
216             return r"\begin{%s}%s\end{%s}" % (env_str, tex, env_str)
217 
218     def _needs_brackets(self, expr):
219         """
220         Returns True if the expression needs to be wrapped in brackets when
221         printed, False otherwise. For example: a + b => True; a => False;
222         10 => False; -10 => True.
223         """
224         return not ((expr.is_Integer and expr.is_nonnegative)
225                     or (expr.is_Atom and (expr is not S.NegativeOne
226                                           and expr.is_Rational is False)))
227 
228     def _needs_function_brackets(self, expr):
229         """
230         Returns True if the expression needs to be wrapped in brackets when
231         passed as an argument to a function, False otherwise. This is a more
232         liberal version of _needs_brackets, in that many expressions which need
233         to be wrapped in brackets when added/subtracted/raised to a power do
234         not need them when passed to a function. Such an example is a*b.
235         """
236         if not self._needs_brackets(expr):
237             return False
238         else:
239             # Muls of the form a*b*c... can be folded
240             if expr.is_Mul and not self._mul_is_clean(expr):
241                 return True
242             # Pows which don't need brackets can be folded
243             elif expr.is_Pow and not self._pow_is_clean(expr):
244                 return True
245             # Add and Function always need brackets
246             elif expr.is_Add or expr.is_Function:
247                 return True
248             else:
249                 return False
250 
251     def _needs_mul_brackets(self, expr, first=False, last=False):
252         """
253         Returns True if the expression needs to be wrapped in brackets when
254         printed as part of a Mul, False otherwise. This is True for Add,
255         but also for some container objects that would not need brackets
256         when appearing last in a Mul, e.g. an Integral. ``last=True``
257         specifies that this expr is the last to appear in a Mul.
258         ``first=True`` specifies that this expr is the first to appear in a Mul.
259         """
260         from sympy import Integral, Product, Sum
261 
262         if expr.is_Mul:
263             if not first and _coeff_isneg(expr):
264                 return True
265         elif precedence_traditional(expr) < PRECEDENCE["Mul"]:
266             return True
267         elif expr.is_Relational:
268             return True
269         if expr.is_Piecewise:
270             return True
271         if any([expr.has(x) for x in (Mod,)]):
272             return True
273         if (not last and
274             any([expr.has(x) for x in (Integral, Product, Sum)])):
275             return True
276 
277         return False
278 
279 
280     def _needs_add_brackets(self, expr):
281         """
282         Returns True if the expression needs to be wrapped in brackets when
283         printed as part of an Add, False otherwise.  This is False for most
284         things.
285         """
286         if expr.is_Relational:
287             return True
288         if any([expr.has(x) for x in (Mod,)]):
289             return True
290         if expr.is_Add:
291             return True
292         return False
293 
294 
295     def _mul_is_clean(self, expr):
296         for arg in expr.args:
297             if arg.is_Function:
298                 return False
299         return True
300 
301     def _pow_is_clean(self, expr):
302         return not self._needs_brackets(expr.base)
303 
304     def _do_exponent(self, expr, exp):
305         if exp is not None:
306             return r"\left(%s\right)^{%s}" % (expr, exp)
307         else:
308             return expr
309 
310     def _print_Basic(self, expr):
311         l = [self._print(o) for o in expr.args]
312         return self._deal_with_super_sub(expr.__class__.__name__) + r"\left(%s\right)" % ", ".join(l)
313 
314     def _print_bool(self, e):
315         return r"\mathrm{%s}" % e
316 
317     _print_BooleanTrue = _print_bool
318     _print_BooleanFalse = _print_bool
319 
320     def _print_NoneType(self, e):
321         return r"\mathrm{%s}" % e
322 
323     def _print_Add(self, expr, order=None):
324         if self.order == 'none':
325             terms = list(expr.args)
326         else:
327             terms = self._as_ordered_terms(expr, order=order)
328 
329         tex = ""
330         for i, term in enumerate(terms):
331             if i == 0:
332                 pass
333             elif _coeff_isneg(term):
334                 tex += " - "
335                 term = -term
336             else:
337                 tex += " + "
338             term_tex = self._print(term)
339             if self._needs_add_brackets(term):
340                 term_tex = r"\left(%s\right)" % term_tex
341             tex += term_tex
342 
343         return tex
344 
345     def _print_Cycle(self, expr):
346         from sympy.combinatorics.permutations import Permutation
347         if expr.size == 0:
348             return r"\left( \right)"
349         expr = Permutation(expr)
350         expr_perm = expr.cyclic_form
351         siz = expr.size
352         if expr.array_form[-1] == siz - 1:
353             expr_perm = expr_perm + [[siz - 1]]
354         term_tex = ''
355         for i in expr_perm:
356             term_tex += str(i).replace(',', r"\;")
357         term_tex = term_tex.replace('[', r"\left( ")
358         term_tex = term_tex.replace(']', r"\right)")
359         return term_tex
360 
361     _print_Permutation = _print_Cycle
362 
363     def _print_Float(self, expr):
364         # Based off of that in StrPrinter
365         dps = prec_to_dps(expr._prec)
366         str_real = mlib.to_str(expr._mpf_, dps, strip_zeros=True)
367 
368         # Must always have a mul symbol (as 2.5 10^{20} just looks odd)
369         # thus we use the number separator
370         separator = self._settings['mul_symbol_latex_numbers']
371 
372         if 'e' in str_real:
373             (mant, exp) = str_real.split('e')
374 
375             if exp[0] == '+':
376                 exp = exp[1:]
377 
378             return r"%s%s10^{%s}" % (mant, separator, exp)
379         elif str_real == "+inf":
380             return r"\infty"
381         elif str_real == "-inf":
382             return r"- \infty"
383         else:
384             return str_real
385 
386     def _print_Cross(self, expr):
387         vec1 = expr._expr1
388         vec2 = expr._expr2
389         return r"%s \times %s" % (self.parenthesize(vec1, PRECEDENCE['Mul']),
390                                   self.parenthesize(vec2, PRECEDENCE['Mul']))
391 
392     def _print_Curl(self, expr):
393         vec = expr._expr
394         return r"\nabla\times %s" % self.parenthesize(vec, PRECEDENCE['Mul'])
395 
396     def _print_Divergence(self, expr):
397         vec = expr._expr
398         return r"\nabla\cdot %s" % self.parenthesize(vec, PRECEDENCE['Mul'])
399 
400     def _print_Dot(self, expr):
401         vec1 = expr._expr1
402         vec2 = expr._expr2
403         return r"%s \cdot %s" % (self.parenthesize(vec1, PRECEDENCE['Mul']),
404                                   self.parenthesize(vec2, PRECEDENCE['Mul']))
405 
406     def _print_Gradient(self, expr):
407         func = expr._expr
408         return r"\nabla\cdot %s" % self.parenthesize(func, PRECEDENCE['Mul'])
409 
410     def _print_Mul(self, expr):
411         from sympy.core.power import Pow
412         from sympy.physics.units import Quantity
413         include_parens = False
414         if _coeff_isneg(expr):
415             expr = -expr
416             tex = "- "
417             if expr.is_Add:
418                 tex += "("
419                 include_parens = True
420         else:
421             tex = ""
422 
423         from sympy.simplify import fraction
424         numer, denom = fraction(expr, exact=True)
425         separator = self._settings['mul_symbol_latex']
426         numbersep = self._settings['mul_symbol_latex_numbers']
427 
428         def convert(expr):
429             if not expr.is_Mul:
430                 return str(self._print(expr))
431             else:
432                 _tex = last_term_tex = ""
433 
434                 if self.order not in ('old', 'none'):
435                     args = expr.as_ordered_factors()
436                 else:
437                     args = list(expr.args)
438 
439                 # If quantities are present append them at the back
440                 args = sorted(args, key=lambda x: isinstance(x, Quantity) or
441                              (isinstance(x, Pow) and isinstance(x.base, Quantity)))
442 
443                 for i, term in enumerate(args):
444                     term_tex = self._print(term)
445 
446                     if self._needs_mul_brackets(term, first=(i == 0),
447                                                 last=(i == len(args) - 1)):
448                         term_tex = r"\left(%s\right)" % term_tex
449 
450                     if _between_two_numbers_p[0].search(last_term_tex) and \
451                             _between_two_numbers_p[1].match(term_tex):
452                         # between two numbers
453                         _tex += numbersep
454                     elif _tex:
455                         _tex += separator
456 
457                     _tex += term_tex
458                     last_term_tex = term_tex
459                 return _tex
460 
461         if denom is S.One and Pow(1, -1, evaluate=False) not in expr.args:
462             # use the original expression here, since fraction() may have
463             # altered it when producing numer and denom
464             tex += convert(expr)
465 
466         else:
467             snumer = convert(numer)
468             sdenom = convert(denom)
469             ldenom = len(sdenom.split())
470             ratio = self._settings['long_frac_ratio']
471             if self._settings['fold_short_frac'] \
472                    and ldenom <= 2 and not "^" in sdenom:
473                 # handle short fractions
474                 if self._needs_mul_brackets(numer, last=False):
475                     tex += r"\left(%s\right) / %s" % (snumer, sdenom)
476                 else:
477                     tex += r"%s / %s" % (snumer, sdenom)
478             elif ratio is not None and \
479                     len(snumer.split()) > ratio*ldenom:
480                 # handle long fractions
481                 if self._needs_mul_brackets(numer, last=True):
482                     tex += r"\frac{1}{%s}%s\left(%s\right)" \
483                         % (sdenom, separator, snumer)
484                 elif numer.is_Mul:
485                     # split a long numerator
486                     a = S.One
487                     b = S.One
488                     for x in numer.args:
489                         if self._needs_mul_brackets(x, last=False) or \
490                                 len(convert(a*x).split()) > ratio*ldenom or \
491                                 (b.is_commutative is x.is_commutative is False):
492                             b *= x
493                         else:
494                             a *= x
495                     if self._needs_mul_brackets(b, last=True):
496                         tex += r"\frac{%s}{%s}%s\left(%s\right)" \
497                             % (convert(a), sdenom, separator, convert(b))
498                     else:
499                         tex += r"\frac{%s}{%s}%s%s" \
500                             % (convert(a), sdenom, separator, convert(b))
501                 else:
502                     tex += r"\frac{1}{%s}%s%s" % (sdenom, separator, snumer)
503             else:
504                 tex += r"\frac{%s}{%s}" % (snumer, sdenom)
505 
506         if include_parens:
507             tex += ")"
508         return tex
509 
510     def _print_Pow(self, expr):
511         # Treat x**Rational(1,n) as special case
512         if expr.exp.is_Rational and abs(expr.exp.p) == 1 and expr.exp.q != 1 and self._settings['root_notation']:
513             base = self._print(expr.base)
514             expq = expr.exp.q
515 
516             if expq == 2:
517                 tex = r"\sqrt{%s}" % base
518             elif self._settings['itex']:
519                 tex = r"\root{%d}{%s}" % (expq, base)
520             else:
521                 tex = r"\sqrt[%d]{%s}" % (expq, base)
522 
523             if expr.exp.is_negative:
524                 return r"\frac{1}{%s}" % tex
525             else:
526                 return tex
527         elif self._settings['fold_frac_powers'] \
528             and expr.exp.is_Rational \
529                 and expr.exp.q != 1:
530             base, p, q = self.parenthesize(expr.base, PRECEDENCE['Pow']), expr.exp.p, expr.exp.q
531             # issue #12886: add parentheses for superscripts raised to powers
532             if '^' in base and expr.base.is_Symbol:
533                 base = r"\left(%s\right)" % base
534             if expr.base.is_Function:
535                 return self._print(expr.base, exp="%s/%s" % (p, q))
536             return r"%s^{%s/%s}" % (base, p, q)
537         elif expr.exp.is_Rational and expr.exp.is_negative and expr.base.is_commutative:
538             # special case for 1^(-x), issue 9216
539             if expr.base == 1:
540                 return r"%s^{%s}" % (expr.base, expr.exp)
541             # things like 1/x
542             return self._print_Mul(expr)
543         else:
544             if expr.base.is_Function:
545                 return self._print(expr.base, exp=self._print(expr.exp))
546             else:
547                 tex = r"%s^{%s}"
548                 exp = self._print(expr.exp)
549                 # issue #12886: add parentheses around superscripts raised to powers
550                 base = self.parenthesize(expr.base, PRECEDENCE['Pow'])
551                 if '^' in base and expr.base.is_Symbol:
552                     base = r"\left(%s\right)" % base
553                 elif isinstance(expr.base, Derivative
554                         ) and base.startswith(r'\left('
555                         ) and re.match(r'\\left\(\\d?d?dot', base
556                         ) and base.endswith(r'\right)'):
557                     # don't use parentheses around dotted derivative
558                     base = base[6: -7]  # remove outermost added parens
559 
560                 return tex % (base, exp)
561 
562     def _print_UnevaluatedExpr(self, expr):
563         return self._print(expr.args[0])
564 
565     def _print_Sum(self, expr):
566         if len(expr.limits) == 1:
567             tex = r"\sum_{%s=%s}^{%s} " % \
568                 tuple([ self._print(i) for i in expr.limits[0] ])
569         else:
570             def _format_ineq(l):
571                 return r"%s \leq %s \leq %s" % \
572                     tuple([self._print(s) for s in (l[1], l[0], l[2])])
573 
574             tex = r"\sum_{\substack{%s}} " % \
575                 str.join('\\\\', [ _format_ineq(l) for l in expr.limits ])
576 
577         if isinstance(expr.function, Add):
578             tex += r"\left(%s\right)" % self._print(expr.function)
579         else:
580             tex += self._print(expr.function)
581 
582         return tex
583 
584     def _print_Product(self, expr):
585         if len(expr.limits) == 1:
586             tex = r"\prod_{%s=%s}^{%s} " % \
587                 tuple([ self._print(i) for i in expr.limits[0] ])
588         else:
589             def _format_ineq(l):
590                 return r"%s \leq %s \leq %s" % \
591                     tuple([self._print(s) for s in (l[1], l[0], l[2])])
592 
593             tex = r"\prod_{\substack{%s}} " % \
594                 str.join('\\\\', [ _format_ineq(l) for l in expr.limits ])
595 
596         if isinstance(expr.function, Add):
597             tex += r"\left(%s\right)" % self._print(expr.function)
598         else:
599             tex += self._print(expr.function)
600 
601         return tex
602 
603     def _print_BasisDependent(self, expr):
604         from sympy.vector import Vector
605 
606         o1 = []
607         if expr == expr.zero:
608             return expr.zero._latex_form
609         if isinstance(expr, Vector):
610             items = expr.separate().items()
611         else:
612             items = [(0, expr)]
613 
614         for system, vect in items:
615             inneritems = list(vect.components.items())
616             inneritems.sort(key = lambda x:x[0].__str__())
617             for k, v in inneritems:
618                 if v == 1:
619                     o1.append(' + ' + k._latex_form)
620                 elif v == -1:
621                     o1.append(' - ' + k._latex_form)
622                 else:
623                     arg_str = '(' + LatexPrinter().doprint(v) + ')'
624                     o1.append(' + ' + arg_str + k._latex_form)
625 
626         outstr = (''.join(o1))
627         if outstr[1] != '-':
628             outstr = outstr[3:]
629         else:
630             outstr = outstr[1:]
631         return outstr
632 
633     def _print_Indexed(self, expr):
634         tex_base = self._print(expr.base)
635         tex = '{'+tex_base+'}'+'_{%s}' % ','.join(
636             map(self._print, expr.indices))
637         return tex
638 
639     def _print_IndexedBase(self, expr):
640         return self._print(expr.label)
641 
642     def _print_Derivative(self, expr):
643         if requires_partial(expr):
644             diff_symbol = r'\partial'
645         else:
646             diff_symbol = r'd'
647 
648         tex = ""
649         dim = 0
650         for x, num in reversed(expr.variable_count):
651             dim += num
652             if num == 1:
653                 tex += r"%s %s" % (diff_symbol, self._print(x))
654             else:
655                 tex += r"%s %s^{%s}" % (diff_symbol, self._print(x), num)
656 
657         if dim == 1:
658             tex = r"\frac{%s}{%s}" % (diff_symbol, tex)
659         else:
660             tex = r"\frac{%s^{%s}}{%s}" % (diff_symbol, dim, tex)
661 
662         return r"%s %s" % (tex, self.parenthesize(expr.expr, PRECEDENCE["Mul"], strict=True))
663 
664     def _print_Subs(self, subs):
665         expr, old, new = subs.args
666         latex_expr = self._print(expr)
667         latex_old = (self._print(e) for e in old)
668         latex_new = (self._print(e) for e in new)
669         latex_subs = r'\\ '.join(
670             e[0] + '=' + e[1] for e in zip(latex_old, latex_new))
671         return r'\left. %s \right|_{\substack{ %s }}' % (latex_expr, latex_subs)
672 
673     def _print_Integral(self, expr):
674         tex, symbols = "", []
675 
676         # Only up to \iiiint exists
677         if len(expr.limits) <= 4 and all(len(lim) == 1 for lim in expr.limits):
678             # Use len(expr.limits)-1 so that syntax highlighters don't think
679             # \" is an escaped quote
680             tex = r"\i" + "i"*(len(expr.limits) - 1) + "nt"
681             symbols = [r"\, d%s" % self._print(symbol[0])
682                        for symbol in expr.limits]
683 
684         else:
685             for lim in reversed(expr.limits):
686                 symbol = lim[0]
687                 tex += r"\int"
688 
689                 if len(lim) > 1:
690                     if self._settings['mode'] != 'inline' \
691                             and not self._settings['itex']:
692                         tex += r"\limits"
693 
694                     if len(lim) == 3:
695                         tex += "_{%s}^{%s}" % (self._print(lim[1]),
696                                                self._print(lim[2]))
697                     if len(lim) == 2:
698                         tex += "^{%s}" % (self._print(lim[1]))
699 
700                 symbols.insert(0, r"\, d%s" % self._print(symbol))
701 
702         return r"%s %s%s" % (tex,
703             self.parenthesize(expr.function, PRECEDENCE["Mul"], strict=True), "".join(symbols))
704 
705     def _print_Limit(self, expr):
706         e, z, z0, dir = expr.args
707 
708         tex = r"\lim_{%s \to " % self._print(z)
709         if str(dir) == '+-' or z0 in (S.Infinity, S.NegativeInfinity):
710             tex += r"%s}" % self._print(z0)
711         else:
712             tex += r"%s^%s}" % (self._print(z0), self._print(dir))
713 
714         if isinstance(e, AssocOp):
715             return r"%s\left(%s\right)" % (tex, self._print(e))
716         else:
717             return r"%s %s" % (tex, self._print(e))
718 
719     def _hprint_Function(self, func):
720         r'''
721         Logic to decide how to render a function to latex
722           - if it is a recognized latex name, use the appropriate latex command
723           - if it is a single letter, just use that letter
724           - if it is a longer name, then put \operatorname{} around it and be
725             mindful of undercores in the name
726         '''
727         func = self._deal_with_super_sub(func)
728         if func in accepted_latex_functions:
729             name = r"\%s" % func
730         elif len(func) == 1 or func.startswith('\\'):
731             name = func
732         else:
733             name = r"\operatorname{%s}" % func
734         return name
735 
736     def _print_Function(self, expr, exp=None):
737         r'''
738         Render functions to LaTeX, handling functions that LaTeX knows about
739         e.g., sin, cos, ... by using the proper LaTeX command (\sin, \cos, ...).
740         For single-letter function names, render them as regular LaTeX math
741         symbols. For multi-letter function names that LaTeX does not know
742         about, (e.g., Li, sech) use \operatorname{} so that the function name
743         is rendered in Roman font and LaTeX handles spacing properly.
744 
745         expr is the expression involving the function
746         exp is an exponent
747         '''
748         func = expr.func.__name__
749         if hasattr(self, '_print_' + func) and \
750             not isinstance(expr, AppliedUndef):
751             return getattr(self, '_print_' + func)(expr, exp)
752         else:
753             args = [ str(self._print(arg)) for arg in expr.args ]
754             # How inverse trig functions should be displayed, formats are:
755             # abbreviated: asin, full: arcsin, power: sin^-1
756             inv_trig_style = self._settings['inv_trig_style']
757             # If we are dealing with a power-style inverse trig function
758             inv_trig_power_case = False
759             # If it is applicable to fold the argument brackets
760             can_fold_brackets = self._settings['fold_func_brackets'] and \
761                 len(args) == 1 and \
762                 not self._needs_function_brackets(expr.args[0])
763 
764             inv_trig_table = ["asin", "acos", "atan", "acsc", "asec", "acot"]
765 
766             # If the function is an inverse trig function, handle the style
767             if func in inv_trig_table:
768                 if inv_trig_style == "abbreviated":
769                     pass
770                 elif inv_trig_style == "full":
771                     func = "arc" + func[1:]
772                 elif inv_trig_style == "power":
773                     func = func[1:]
774                     inv_trig_power_case = True
775 
776                     # Can never fold brackets if we're raised to a power
777                     if exp is not None:
778                         can_fold_brackets = False
779 
780             if inv_trig_power_case:
781                 if func in accepted_latex_functions:
782                     name = r"\%s^{-1}" % func
783                 else:
784                     name = r"\operatorname{%s}^{-1}" % func
785             elif exp is not None:
786                 name = r'%s^{%s}' % (self._hprint_Function(func), exp)
787             else:
788                 name = self._hprint_Function(func)
789 
790             if can_fold_brackets:
791                 if func in accepted_latex_functions:
792                     # Wrap argument safely to avoid parse-time conflicts
793                     # with the function name itself
794                     name += r" {%s}"
795                 else:
796                     name += r"%s"
797             else:
798                 name += r"{\left(%s \right)}"
799 
800             if inv_trig_power_case and exp is not None:
801                 name += r"^{%s}" % exp
802 
803             return name % ",".join(args)
804 
805     def _print_UndefinedFunction(self, expr):
806         return self._hprint_Function(str(expr))
807 
808     @property
809     def _special_function_classes(self):
810         from sympy.functions.special.tensor_functions import KroneckerDelta
811         from sympy.functions.special.gamma_functions import gamma, lowergamma
812         from sympy.functions.special.beta_functions import beta
813         from sympy.functions.special.delta_functions import DiracDelta
814         from sympy.functions.special.error_functions import Chi
815         return {KroneckerDelta: r'\delta',
816                 gamma:  r'\Gamma',
817                 lowergamma: r'\gamma',
818                 beta: r'\operatorname{B}',
819                 DiracDelta: r'\delta',
820                 Chi: r'\operatorname{Chi}'}
821 
822     def _print_FunctionClass(self, expr):
823         for cls in self._special_function_classes:
824             if issubclass(expr, cls) and expr.__name__ == cls.__name__:
825                 return self._special_function_classes[cls]
826         return self._hprint_Function(str(expr))
827 
828     def _print_Lambda(self, expr):
829         symbols, expr = expr.args
830 
831         if len(symbols) == 1:
832             symbols = self._print(symbols[0])
833         else:
834             symbols = self._print(tuple(symbols))
835 
836         tex = r"\left( %s \mapsto %s \right)" % (symbols, self._print(expr))
837 
838         return tex
839 
840     def _hprint_variadic_function(self, expr, exp=None):
841         args = sorted(expr.args, key=default_sort_key)
842         texargs = [r"%s" % self._print(symbol) for symbol in args]
843         tex = r"\%s\left(%s\right)" % (self._print((str(expr.func)).lower()), ", ".join(texargs))
844         if exp is not None:
845             return r"%s^{%s}" % (tex, exp)
846         else:
847             return tex
848 
849     _print_Min = _print_Max = _hprint_variadic_function
850 
851     def _print_floor(self, expr, exp=None):
852         tex = r"\left\lfloor{%s}\right\rfloor" % self._print(expr.args[0])
853 
854         if exp is not None:
855             return r"%s^{%s}" % (tex, exp)
856         else:
857             return tex
858 
859     def _print_ceiling(self, expr, exp=None):
860         tex = r"\left\lceil{%s}\right\rceil" % self._print(expr.args[0])
861 
862         if exp is not None:
863             return r"%s^{%s}" % (tex, exp)
864         else:
865             return tex
866 
867     def _print_log(self, expr, exp=None):
868         if not self._settings["ln_notation"]:
869             tex = r"\log{\left(%s \right)}" % self._print(expr.args[0])
870         else:
871             tex = r"\ln{\left(%s \right)}" % self._print(expr.args[0])
872 
873         if exp is not None:
874             return r"%s^{%s}" % (tex, exp)
875         else:
876             return tex
877 
878     def _print_Abs(self, expr, exp=None):
879         tex = r"\left|{%s}\right|" % self._print(expr.args[0])
880 
881         if exp is not None:
882             return r"%s^{%s}" % (tex, exp)
883         else:
884             return tex
885     _print_Determinant = _print_Abs
886 
887     def _print_re(self, expr, exp=None):
888         tex = r"\Re{%s}" % self.parenthesize(expr.args[0], PRECEDENCE['Atom'])
889 
890         return self._do_exponent(tex, exp)
891 
892     def _print_im(self, expr, exp=None):
893         tex = r"\Im{%s}" % self.parenthesize(expr.args[0], PRECEDENCE['Func'])
894 
895         return self._do_exponent(tex, exp)
896 
897     def _print_Not(self, e):
898         from sympy import Equivalent, Implies
899         if isinstance(e.args[0], Equivalent):
900             return self._print_Equivalent(e.args[0], r"\not\Leftrightarrow")
901         if isinstance(e.args[0], Implies):
902             return self._print_Implies(e.args[0], r"\not\Rightarrow")
903         if (e.args[0].is_Boolean):
904             return r"\neg (%s)" % self._print(e.args[0])
905         else:
906             return r"\neg %s" % self._print(e.args[0])
907 
908     def _print_LogOp(self, args, char):
909         arg = args[0]
910         if arg.is_Boolean and not arg.is_Not:
911             tex = r"\left(%s\right)" % self._print(arg)
912         else:
913             tex = r"%s" % self._print(arg)
914 
915         for arg in args[1:]:
916             if arg.is_Boolean and not arg.is_Not:
917                 tex += r" %s \left(%s\right)" % (char, self._print(arg))
918             else:
919                 tex += r" %s %s" % (char, self._print(arg))
920 
921         return tex
922 
923     def _print_And(self, e):
924         args = sorted(e.args, key=default_sort_key)
925         return self._print_LogOp(args, r"\wedge")
926 
927     def _print_Or(self, e):
928         args = sorted(e.args, key=default_sort_key)
929         return self._print_LogOp(args, r"\vee")
930 
931     def _print_Xor(self, e):
932         args = sorted(e.args, key=default_sort_key)
933         return self._print_LogOp(args, r"\veebar")
934 
935     def _print_Implies(self, e, altchar=None):
936         return self._print_LogOp(e.args, altchar or r"\Rightarrow")
937 
938     def _print_Equivalent(self, e, altchar=None):
939         args = sorted(e.args, key=default_sort_key)
940         return self._print_LogOp(args, altchar or r"\Leftrightarrow")
941 
942     def _print_conjugate(self, expr, exp=None):
943         tex = r"\overline{%s}" % self._print(expr.args[0])
944 
945         if exp is not None:
946             return r"%s^{%s}" % (tex, exp)
947         else:
948             return tex
949 
950     def _print_polar_lift(self, expr, exp=None):
951         func = r"\operatorname{polar\_lift}"
952         arg = r"{\left(%s \right)}" % self._print(expr.args[0])
953 
954         if exp is not None:
955             return r"%s^{%s}%s" % (func, exp, arg)
956         else:
957             return r"%s%s" % (func, arg)
958 
959     def _print_ExpBase(self, expr, exp=None):
960         # TODO should exp_polar be printed differently?
961         #      what about exp_polar(0), exp_polar(1)?
962         tex = r"e^{%s}" % self._print(expr.args[0])
963         return self._do_exponent(tex, exp)
964 
965     def _print_elliptic_k(self, expr, exp=None):
966         tex = r"\left(%s\right)" % self._print(expr.args[0])
967         if exp is not None:
968             return r"K^{%s}%s" % (exp, tex)
969         else:
970             return r"K%s" % tex
971 
972     def _print_elliptic_f(self, expr, exp=None):
973         tex = r"\left(%s\middle| %s\right)" % \
974             (self._print(expr.args[0]), self._print(expr.args[1]))
975         if exp is not None:
976             return r"F^{%s}%s" % (exp, tex)
977         else:
978             return r"F%s" % tex
979 
980     def _print_elliptic_e(self, expr, exp=None):
981         if len(expr.args) == 2:
982             tex = r"\left(%s\middle| %s\right)" % \
983                 (self._print(expr.args[0]), self._print(expr.args[1]))
984         else:
985             tex = r"\left(%s\right)" % self._print(expr.args[0])
986         if exp is not None:
987             return r"E^{%s}%s" % (exp, tex)
988         else:
989             return r"E%s" % tex
990 
991     def _print_elliptic_pi(self, expr, exp=None):
992         if len(expr.args) == 3:
993             tex = r"\left(%s; %s\middle| %s\right)" % \
994                 (self._print(expr.args[0]), self._print(expr.args[1]), \
995                  self._print(expr.args[2]))
996         else:
997             tex = r"\left(%s\middle| %s\right)" % \
998                 (self._print(expr.args[0]), self._print(expr.args[1]))
999         if exp is not None:
1000             return r"\Pi^{%s}%s" % (exp, tex)
1001         else:
1002             return r"\Pi%s" % tex
1003 
1004     def _print_beta(self, expr, exp=None):
1005         tex = r"\left(%s, %s\right)" % (self._print(expr.args[0]),
1006                                         self._print(expr.args[1]))
1007 
1008         if exp is not None:
1009             return r"\operatorname{B}^{%s}%s" % (exp, tex)
1010         else:
1011             return r"\operatorname{B}%s" % tex
1012 
1013     def _print_uppergamma(self, expr, exp=None):
1014         tex = r"\left(%s, %s\right)" % (self._print(expr.args[0]),
1015                                         self._print(expr.args[1]))
1016 
1017         if exp is not None:
1018             return r"\Gamma^{%s}%s" % (exp, tex)
1019         else:
1020             return r"\Gamma%s" % tex
1021 
1022     def _print_lowergamma(self, expr, exp=None):
1023         tex = r"\left(%s, %s\right)" % (self._print(expr.args[0]),
1024                                         self._print(expr.args[1]))
1025 
1026         if exp is not None:
1027             return r"\gamma^{%s}%s" % (exp, tex)
1028         else:
1029             return r"\gamma%s" % tex
1030 
1031     def _hprint_one_arg_func(self, expr, exp=None):
1032         tex = r"\left(%s\right)" % self._print(expr.args[0])
1033 
1034         if exp is not None:
1035             return r"%s^{%s}%s" % (self._print(expr.func), exp, tex)
1036         else:
1037             return r"%s%s" % (self._print(expr.func), tex)
1038 
1039     _print_gamma = _hprint_one_arg_func
1040 
1041     def _print_Chi(self, expr, exp=None):
1042         tex = r"\left(%s\right)" % self._print(expr.args[0])
1043 
1044         if exp is not None:
1045             return r"\operatorname{Chi}^{%s}%s" % (exp, tex)
1046         else:
1047             return r"\operatorname{Chi}%s" % tex
1048 
1049     def _print_expint(self, expr, exp=None):
1050         tex = r"\left(%s\right)" % self._print(expr.args[1])
1051         nu = self._print(expr.args[0])
1052 
1053         if exp is not None:
1054             return r"\operatorname{E}_{%s}^{%s}%s" % (nu, exp, tex)
1055         else:
1056             return r"\operatorname{E}_{%s}%s" % (nu, tex)
1057 
1058     def _print_fresnels(self, expr, exp=None):
1059         tex = r"\left(%s\right)" % self._print(expr.args[0])
1060 
1061         if exp is not None:
1062             return r"S^{%s}%s" % (exp, tex)
1063         else:
1064             return r"S%s" % tex
1065 
1066     def _print_fresnelc(self, expr, exp=None):
1067         tex = r"\left(%s\right)" % self._print(expr.args[0])
1068 
1069         if exp is not None:
1070             return r"C^{%s}%s" % (exp, tex)
1071         else:
1072             return r"C%s" % tex
1073 
1074     def _print_subfactorial(self, expr, exp=None):
1075         tex = r"!%s" % self.parenthesize(expr.args[0], PRECEDENCE["Func"])
1076 
1077         if exp is not None:
1078             return r"\left(%s\right)^{%s}" % (tex, exp)
1079         else:
1080             return tex
1081 
1082     def _print_factorial(self, expr, exp=None):
1083         tex = r"%s!" % self.parenthesize(expr.args[0], PRECEDENCE["Func"])
1084 
1085         if exp is not None:
1086             return r"%s^{%s}" % (tex, exp)
1087         else:
1088             return tex
1089 
1090     def _print_factorial2(self, expr, exp=None):
1091         tex = r"%s!!" % self.parenthesize(expr.args[0], PRECEDENCE["Func"])
1092 
1093         if exp is not None:
1094             return r"%s^{%s}" % (tex, exp)
1095         else:
1096             return tex
1097 
1098     def _print_binomial(self, expr, exp=None):
1099         tex = r"{\binom{%s}{%s}}" % (self._print(expr.args[0]),
1100                                      self._print(expr.args[1]))
1101 
1102         if exp is not None:
1103             return r"%s^{%s}" % (tex, exp)
1104         else:
1105             return tex
1106 
1107     def _print_RisingFactorial(self, expr, exp=None):
1108         n, k = expr.args
1109         base = r"%s" % self.parenthesize(n, PRECEDENCE['Func'])
1110 
1111         tex = r"{%s}^{\left(%s\right)}" % (base, self._print(k))
1112 
1113         return self._do_exponent(tex, exp)
1114 
1115     def _print_FallingFactorial(self, expr, exp=None):
1116         n, k = expr.args
1117         sub = r"%s" % self.parenthesize(k, PRECEDENCE['Func'])
1118 
1119         tex = r"{\left(%s\right)}_{%s}" % (self._print(n), sub)
1120 
1121         return self._do_exponent(tex, exp)
1122 
1123     def _hprint_BesselBase(self, expr, exp, sym):
1124         tex = r"%s" % (sym)
1125 
1126         need_exp = False
1127         if exp is not None:
1128             if tex.find('^') == -1:
1129                 tex = r"%s^{%s}" % (tex, self._print(exp))
1130             else:
1131                 need_exp = True
1132 
1133         tex = r"%s_{%s}\left(%s\right)" % (tex, self._print(expr.order),
1134                                            self._print(expr.argument))
1135 
1136         if need_exp:
1137             tex = self._do_exponent(tex, exp)
1138         return tex
1139 
1140     def _hprint_vec(self, vec):
1141         if not vec:
1142             return ""
1143         s = ""
1144         for i in vec[:-1]:
1145             s += "%s, " % self._print(i)
1146         s += self._print(vec[-1])
1147         return s
1148 
1149     def _print_besselj(self, expr, exp=None):
1150         return self._hprint_BesselBase(expr, exp, 'J')
1151 
1152     def _print_besseli(self, expr, exp=None):
1153         return self._hprint_BesselBase(expr, exp, 'I')
1154 
1155     def _print_besselk(self, expr, exp=None):
1156         return self._hprint_BesselBase(expr, exp, 'K')
1157 
1158     def _print_bessely(self, expr, exp=None):
1159         return self._hprint_BesselBase(expr, exp, 'Y')
1160 
1161     def _print_yn(self, expr, exp=None):
1162         return self._hprint_BesselBase(expr, exp, 'y')
1163 
1164     def _print_jn(self, expr, exp=None):
1165         return self._hprint_BesselBase(expr, exp, 'j')
1166 
1167     def _print_hankel1(self, expr, exp=None):
1168         return self._hprint_BesselBase(expr, exp, 'H^{(1)}')
1169 
1170     def _print_hankel2(self, expr, exp=None):
1171         return self._hprint_BesselBase(expr, exp, 'H^{(2)}')
1172 
1173     def _print_hn1(self, expr, exp=None):
1174         return self._hprint_BesselBase(expr, exp, 'h^{(1)}')
1175 
1176     def _print_hn2(self, expr, exp=None):
1177         return self._hprint_BesselBase(expr, exp, 'h^{(2)}')
1178 
1179     def _hprint_airy(self, expr, exp=None, notation=""):
1180         tex = r"\left(%s\right)" % self._print(expr.args[0])
1181 
1182         if exp is not None:
1183             return r"%s^{%s}%s" % (notation, exp, tex)
1184         else:
1185             return r"%s%s" % (notation, tex)
1186 
1187     def _hprint_airy_prime(self, expr, exp=None, notation=""):
1188         tex = r"\left(%s\right)" % self._print(expr.args[0])
1189 
1190         if exp is not None:
1191             return r"{%s^\prime}^{%s}%s" % (notation, exp, tex)
1192         else:
1193             return r"%s^\prime%s" % (notation, tex)
1194 
1195     def _print_airyai(self, expr, exp=None):
1196         return self._hprint_airy(expr, exp, 'Ai')
1197 
1198     def _print_airybi(self, expr, exp=None):
1199         return self._hprint_airy(expr, exp, 'Bi')
1200 
1201     def _print_airyaiprime(self, expr, exp=None):
1202         return self._hprint_airy_prime(expr, exp, 'Ai')
1203 
1204     def _print_airybiprime(self, expr, exp=None):
1205         return self._hprint_airy_prime(expr, exp, 'Bi')
1206 
1207     def _print_hyper(self, expr, exp=None):
1208         tex = r"{{}_{%s}F_{%s}\left(\begin{matrix} %s \\ %s \end{matrix}" \
1209               r"\middle| {%s} \right)}" % \
1210             (self._print(len(expr.ap)), self._print(len(expr.bq)),
1211               self._hprint_vec(expr.ap), self._hprint_vec(expr.bq),
1212               self._print(expr.argument))
1213 
1214         if exp is not None:
1215             tex = r"{%s}^{%s}" % (tex, self._print(exp))
1216         return tex
1217 
1218     def _print_meijerg(self, expr, exp=None):
1219         tex = r"{G_{%s, %s}^{%s, %s}\left(\begin{matrix} %s & %s \\" \
1220               r"%s & %s \end{matrix} \middle| {%s} \right)}" % \
1221             (self._print(len(expr.ap)), self._print(len(expr.bq)),
1222               self._print(len(expr.bm)), self._print(len(expr.an)),
1223               self._hprint_vec(expr.an), self._hprint_vec(expr.aother),
1224               self._hprint_vec(expr.bm), self._hprint_vec(expr.bother),
1225               self._print(expr.argument))
1226 
1227         if exp is not None:
1228             tex = r"{%s}^{%s}" % (tex, self._print(exp))
1229         return tex
1230 
1231     def _print_dirichlet_eta(self, expr, exp=None):
1232         tex = r"\left(%s\right)" % self._print(expr.args[0])
1233         if exp is not None:
1234             return r"\eta^{%s}%s" % (self._print(exp), tex)
1235         return r"\eta%s" % tex
1236 
1237     def _print_zeta(self, expr, exp=None):
1238         if len(expr.args) == 2:
1239             tex = r"\left(%s, %s\right)" % tuple(map(self._print, expr.args))
1240         else:
1241             tex = r"\left(%s\right)" % self._print(expr.args[0])
1242         if exp is not None:
1243             return r"\zeta^{%s}%s" % (self._print(exp), tex)
1244         return r"\zeta%s" % tex
1245 
1246     def _print_lerchphi(self, expr, exp=None):
1247         tex = r"\left(%s, %s, %s\right)" % tuple(map(self._print, expr.args))
1248         if exp is None:
1249             return r"\Phi%s" % tex
1250         return r"\Phi^{%s}%s" % (self._print(exp), tex)
1251 
1252     def _print_polylog(self, expr, exp=None):
1253         s, z = map(self._print, expr.args)
1254         tex = r"\left(%s\right)" % z
1255         if exp is None:
1256             return r"\operatorname{Li}_{%s}%s" % (s, tex)
1257         return r"\operatorname{Li}_{%s}^{%s}%s" % (s, self._print(exp), tex)
1258 
1259     def _print_jacobi(self, expr, exp=None):
1260         n, a, b, x = map(self._print, expr.args)
1261         tex = r"P_{%s}^{\left(%s,%s\right)}\left(%s\right)" % (n, a, b, x)
1262         if exp is not None:
1263             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1264         return tex
1265 
1266     def _print_gegenbauer(self, expr, exp=None):
1267         n, a, x = map(self._print, expr.args)
1268         tex = r"C_{%s}^{\left(%s\right)}\left(%s\right)" % (n, a, x)
1269         if exp is not None:
1270             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1271         return tex
1272 
1273     def _print_chebyshevt(self, expr, exp=None):
1274         n, x = map(self._print, expr.args)
1275         tex = r"T_{%s}\left(%s\right)" % (n, x)
1276         if exp is not None:
1277             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1278         return tex
1279 
1280     def _print_chebyshevu(self, expr, exp=None):
1281         n, x = map(self._print, expr.args)
1282         tex = r"U_{%s}\left(%s\right)" % (n, x)
1283         if exp is not None:
1284             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1285         return tex
1286 
1287     def _print_legendre(self, expr, exp=None):
1288         n, x = map(self._print, expr.args)
1289         tex = r"P_{%s}\left(%s\right)" % (n, x)
1290         if exp is not None:
1291             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1292         return tex
1293 
1294     def _print_assoc_legendre(self, expr, exp=None):
1295         n, a, x = map(self._print, expr.args)
1296         tex = r"P_{%s}^{\left(%s\right)}\left(%s\right)" % (n, a, x)
1297         if exp is not None:
1298             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1299         return tex
1300 
1301     def _print_hermite(self, expr, exp=None):
1302         n, x = map(self._print, expr.args)
1303         tex = r"H_{%s}\left(%s\right)" % (n, x)
1304         if exp is not None:
1305             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1306         return tex
1307 
1308     def _print_laguerre(self, expr, exp=None):
1309         n, x = map(self._print, expr.args)
1310         tex = r"L_{%s}\left(%s\right)" % (n, x)
1311         if exp is not None:
1312             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1313         return tex
1314 
1315     def _print_assoc_laguerre(self, expr, exp=None):
1316         n, a, x = map(self._print, expr.args)
1317         tex = r"L_{%s}^{\left(%s\right)}\left(%s\right)" % (n, a, x)
1318         if exp is not None:
1319             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1320         return tex
1321 
1322     def _print_Ynm(self, expr, exp=None):
1323         n, m, theta, phi = map(self._print, expr.args)
1324         tex = r"Y_{%s}^{%s}\left(%s,%s\right)" % (n, m, theta, phi)
1325         if exp is not None:
1326             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1327         return tex
1328 
1329     def _print_Znm(self, expr, exp=None):
1330         n, m, theta, phi = map(self._print, expr.args)
1331         tex = r"Z_{%s}^{%s}\left(%s,%s\right)" % (n, m, theta, phi)
1332         if exp is not None:
1333             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1334         return tex
1335 
1336     def _print_Rational(self, expr):
1337         if expr.q != 1:
1338             sign = ""
1339             p = expr.p
1340             if expr.p < 0:
1341                 sign = "- "
1342                 p = -p
1343             if self._settings['fold_short_frac']:
1344                 return r"%s%d / %d" % (sign, p, expr.q)
1345             return r"%s\frac{%d}{%d}" % (sign, p, expr.q)
1346         else:
1347             return self._print(expr.p)
1348 
1349     def _print_Order(self, expr):
1350         s = self._print(expr.expr)
1351         if expr.point and any(p != S.Zero for p in expr.point) or \
1352            len(expr.variables) > 1:
1353             s += '; '
1354             if len(expr.variables) > 1:
1355                 s += self._print(expr.variables)
1356             elif expr.variables:
1357                 s += self._print(expr.variables[0])
1358             s += r'\rightarrow '
1359             if len(expr.point) > 1:
1360                 s += self._print(expr.point)
1361             else:
1362                 s += self._print(expr.point[0])
1363         return r"O\left(%s\right)" % s
1364 
1365     def _print_Symbol(self, expr, style='plain'):
1366         if expr in self._settings['symbol_names']:
1367             return self._settings['symbol_names'][expr]
1368 
1369         result = self._deal_with_super_sub(expr.name) if \
1370             '\\' not in expr.name else expr.name
1371 
1372         if style == 'bold':
1373             result = r"\mathbf{{{}}}".format(result)
1374 
1375         return result
1376 
1377     _print_RandomSymbol = _print_Symbol
1378 
1379     def _print_MatrixSymbol(self, expr):
1380         return self._print_Symbol(expr, style=self._settings['mat_symbol_style'])
1381 
1382     def _deal_with_super_sub(self, string):
1383         if '{' in string:
1384             return string
1385 
1386         name, supers, subs = split_super_sub(string)
1387 
1388         name = translate(name)
1389         supers = [translate(sup) for sup in supers]
1390         subs = [translate(sub) for sub in subs]
1391 
1392         # glue all items together:
1393         if supers:
1394             name += "^{%s}" % " ".join(supers)
1395         if subs:
1396             name += "_{%s}" % " ".join(subs)
1397 
1398         return name
1399 
1400     def _print_Relational(self, expr):
1401         if self._settings['itex']:
1402             gt = r"\gt"
1403             lt = r"\lt"
1404         else:
1405             gt = ">"
1406             lt = "<"
1407 
1408         charmap = {
1409             "==": "=",
1410             ">": gt,
1411             "<": lt,
1412             ">=": r"\geq",
1413             "<=": r"\leq",
1414             "!=": r"\neq",
1415         }
1416 
1417         return "%s %s %s" % (self._print(expr.lhs),
1418             charmap[expr.rel_op], self._print(expr.rhs))
1419 
1420     def _print_Piecewise(self, expr):
1421         ecpairs = [r"%s & \text{for}\: %s" % (self._print(e), self._print(c))
1422                    for e, c in expr.args[:-1]]
1423         if expr.args[-1].cond == true:
1424             ecpairs.append(r"%s & \text{otherwise}" %
1425                            self._print(expr.args[-1].expr))
1426         else:
1427             ecpairs.append(r"%s & \text{for}\: %s" %
1428                            (self._print(expr.args[-1].expr),
1429                             self._print(expr.args[-1].cond)))
1430         tex = r"\begin{cases} %s \end{cases}"
1431         return tex % r" \\".join(ecpairs)
1432 
1433     def _print_MatrixBase(self, expr):
1434         lines = []
1435 
1436         for line in range(expr.rows):  # horrible, should be 'rows'
1437             lines.append(" & ".join([ self._print(i) for i in expr[line, :] ]))
1438 
1439         mat_str = self._settings['mat_str']
1440         if mat_str is None:
1441             if self._settings['mode'] == 'inline':
1442                 mat_str = 'smallmatrix'
1443             else:
1444                 if (expr.cols <= 10) is True:
1445                     mat_str = 'matrix'
1446                 else:
1447                     mat_str = 'array'
1448 
1449         out_str = r'\begin{%MATSTR%}%s\end{%MATSTR%}'
1450         out_str = out_str.replace('%MATSTR%', mat_str)
1451         if mat_str == 'array':
1452             out_str = out_str.replace('%s', '{' + 'c'*expr.cols + '}%s')
1453         if self._settings['mat_delim']:
1454             left_delim = self._settings['mat_delim']
1455             right_delim = self._delim_dict[left_delim]
1456             out_str = r'\left' + left_delim + out_str + \
1457                       r'\right' + right_delim
1458         return out_str % r"\\".join(lines)
1459     _print_ImmutableMatrix = _print_ImmutableDenseMatrix \
1460                            = _print_Matrix \
1461                            = _print_MatrixBase
1462 
1463     def _print_MatrixElement(self, expr):
1464         return self.parenthesize(expr.parent, PRECEDENCE["Atom"], strict=True) \
1465             + '_{%s, %s}' % (
1466             self._print(expr.i),
1467             self._print(expr.j)
1468         )
1469 
1470     def _print_MatrixSlice(self, expr):
1471         def latexslice(x):
1472             x = list(x)
1473             if x[2] == 1:
1474                 del x[2]
1475             if x[1] == x[0] + 1:
1476                 del x[1]
1477             if x[0] == 0:
1478                 x[0] = ''
1479             return ':'.join(map(self._print, x))
1480         return (self._print(expr.parent) + r'\left[' +
1481                 latexslice(expr.rowslice) + ', ' +
1482                 latexslice(expr.colslice) + r'\right]')
1483 
1484     def _print_BlockMatrix(self, expr):
1485         return self._print(expr.blocks)
1486 
1487     def _print_Transpose(self, expr):
1488         mat = expr.arg
1489         from sympy.matrices import MatrixSymbol
1490         if not isinstance(mat, MatrixSymbol):
1491             return r"\left(%s\right)^T" % self._print(mat)
1492         else:
1493             return "%s^T" % self._print(mat)
1494 
1495     def _print_Trace(self, expr):
1496         mat = expr.arg
1497         return r"\mathrm{tr}\left(%s \right)" % self._print(mat)
1498 
1499     def _print_Adjoint(self, expr):
1500         mat = expr.arg
1501         from sympy.matrices import MatrixSymbol
1502         if not isinstance(mat, MatrixSymbol):
1503             return r"\left(%s\right)^\dagger" % self._print(mat)
1504         else:
1505             return r"%s^\dagger" % self._print(mat)
1506 
1507     def _print_MatMul(self, expr):
1508         from sympy import MatMul, Mul
1509 
1510         parens = lambda x: self.parenthesize(x, precedence_traditional(expr), False)
1511 
1512         args = expr.args
1513         if isinstance(args[0], Mul):
1514             args = args[0].as_ordered_factors() + list(args[1:])
1515         else:
1516             args = list(args)
1517 
1518         if isinstance(expr, MatMul) and _coeff_isneg(expr):
1519             if args[0] == -1:
1520                 args = args[1:]
1521             else:
1522                 args[0] = -args[0]
1523             return '- ' + ' '.join(map(parens, args))
1524         else:
1525             return ' '.join(map(parens, args))
1526 
1527     def _print_Mod(self, expr, exp=None):
1528         if exp is not None:
1529             return r'\left(%s\bmod{%s}\right)^{%s}' % (self.parenthesize(expr.args[0],
1530                     PRECEDENCE['Mul'], strict=True), self._print(expr.args[1]), self._print(exp))
1531         return r'%s\bmod{%s}' % (self.parenthesize(expr.args[0],
1532                 PRECEDENCE['Mul'], strict=True), self._print(expr.args[1]))
1533 
1534     def _print_HadamardProduct(self, expr):
1535         from sympy import Add, MatAdd, MatMul
1536 
1537         def parens(x):
1538             if isinstance(x, (Add, MatAdd, MatMul)):
1539                 return r"\left(%s\right)" % self._print(x)
1540             return self._print(x)
1541         return r' \circ '.join(map(parens, expr.args))
1542 
1543     def _print_KroneckerProduct(self, expr):
1544         from sympy import Add, MatAdd, MatMul
1545 
1546         def parens(x):
1547             if isinstance(x, (Add, MatAdd, MatMul)):
1548                 return r"\left(%s\right)" % self._print(x)
1549             return self._print(x)
1550         return r' \otimes '.join(map(parens, expr.args))
1551 
1552     def _print_MatPow(self, expr):
1553         base, exp = expr.base, expr.exp
1554         from sympy.matrices import MatrixSymbol
1555         if not isinstance(base, MatrixSymbol):
1556             return r"\left(%s\right)^{%s}" % (self._print(base), self._print(exp))
1557         else:
1558             return "%s^{%s}" % (self._print(base), self._print(exp))
1559 
1560     def _print_ZeroMatrix(self, Z):
1561         return r"\mathbb{0}"
1562 
1563     def _print_Identity(self, I):
1564         return r"\mathbb{I}"
1565 
1566     def _print_NDimArray(self, expr):
1567 
1568         if expr.rank() == 0:
1569             return self._print(expr[()])
1570 
1571         mat_str = self._settings['mat_str']
1572         if mat_str is None:
1573             if self._settings['mode'] == 'inline':
1574                 mat_str = 'smallmatrix'
1575             else:
1576                 if (expr.rank() == 0) or (expr.shape[-1] <= 10):
1577                     mat_str = 'matrix'
1578                 else:
1579                     mat_str = 'array'
1580         block_str = r'\begin{%MATSTR%}%s\end{%MATSTR%}'
1581         block_str = block_str.replace('%MATSTR%', mat_str)
1582         if self._settings['mat_delim']:
1583             left_delim = self._settings['mat_delim']
1584             right_delim = self._delim_dict[left_delim]
1585             block_str = r'\left' + left_delim + block_str + \
1586                       r'\right' + right_delim
1587 
1588         if expr.rank() == 0:
1589             return block_str % ""
1590 
1591         level_str = [[]] + [[] for i in range(expr.rank())]
1592         shape_ranges = [list(range(i)) for i in expr.shape]
1593         for outer_i in itertools.product(*shape_ranges):
1594             level_str[-1].append(self._print(expr[outer_i]))
1595             even = True
1596             for back_outer_i in range(expr.rank()-1, -1, -1):
1597                 if len(level_str[back_outer_i+1]) < expr.shape[back_outer_i]:
1598                     break
1599                 if even:
1600                     level_str[back_outer_i].append(r" & ".join(level_str[back_outer_i+1]))
1601                 else:
1602                     level_str[back_outer_i].append(block_str % (r"\\".join(level_str[back_outer_i+1])))
1603                     if len(level_str[back_outer_i+1]) == 1:
1604                         level_str[back_outer_i][-1] = r"\left[" + level_str[back_outer_i][-1] + r"\right]"
1605                 even = not even
1606                 level_str[back_outer_i+1] = []
1607 
1608         out_str = level_str[0][0]
1609 
1610         if expr.rank() % 2 == 1:
1611             out_str = block_str % out_str
1612 
1613         return out_str
1614 
1615     _print_ImmutableDenseNDimArray = _print_NDimArray
1616     _print_ImmutableSparseNDimArray = _print_NDimArray
1617     _print_MutableDenseNDimArray = _print_NDimArray
1618     _print_MutableSparseNDimArray = _print_NDimArray
1619 
1620     def _printer_tensor_indices(self, name, indices, index_map={}):
1621         out_str = self._print(name)
1622         last_valence = None
1623         prev_map = None
1624         for index in indices:
1625             new_valence = index.is_up
1626             if ((index in index_map) or prev_map) and last_valence == new_valence:
1627                 out_str += ","
1628             if last_valence != new_valence:
1629                 if last_valence is not None:
1630                     out_str += "}"
1631                 if index.is_up:
1632                     out_str += "{}^{"
1633                 else:
1634                     out_str += "{}_{"
1635             out_str += self._print(index.args[0])
1636             if index in index_map:
1637                 out_str += "="
1638                 out_str += self._print(index_map[index])
1639                 prev_map = True
1640             else:
1641                 prev_map = False
1642             last_valence = new_valence
1643         if last_valence is not None:
1644             out_str += "}"
1645         return out_str
1646 
1647     def _print_Tensor(self, expr):
1648         name = expr.args[0].args[0]
1649         indices = expr.get_indices()
1650         return self._printer_tensor_indices(name, indices)
1651 
1652     def _print_TensorElement(self, expr):
1653         name = expr.expr.args[0].args[0]
1654         indices = expr.expr.get_indices()
1655         index_map = expr.index_map
1656         return self._printer_tensor_indices(name, indices, index_map)
1657 
1658     def _print_TensMul(self, expr):
1659         # prints expressions like "A(a)", "3*A(a)", "(1+x)*A(a)"
1660         sign, args = expr._get_args_for_traditional_printer()
1661         return sign + "".join(
1662             [self.parenthesize(arg, precedence(expr)) for arg in args]
1663         )
1664 
1665     def _print_TensAdd(self, expr):
1666         a = []
1667         args = expr.args
1668         for x in args:
1669             a.append(self.parenthesize(x, precedence(expr)))
1670         a.sort()
1671         s = ' + '.join(a)
1672         s = s.replace('+ -', '- ')
1673         return s
1674 
1675     def _print_TensorIndex(self, expr):
1676         return "{}%s{%s}" % (
1677             "^" if expr.is_up else "_",
1678             self._print(expr.args[0])
1679         )
1680         return self._print(expr.args[0])
1681 
1682     def _print_tuple(self, expr):
1683         return r"\left( %s\right)" % \
1684             r", \  ".join([ self._print(i) for i in expr ])
1685 
1686     def _print_TensorProduct(self, expr):
1687         elements = [self._print(a) for a in expr.args]
1688         return r' \otimes '.join(elements)
1689 
1690     def _print_WedgeProduct(self, expr):
1691         elements = [self._print(a) for a in expr.args]
1692         return r' \wedge '.join(elements)
1693 
1694     def _print_Tuple(self, expr):
1695         return self._print_tuple(expr)
1696 
1697     def _print_list(self, expr):
1698         return r"\left[ %s\right]" % \
1699             r", \  ".join([ self._print(i) for i in expr ])
1700 
1701     def _print_dict(self, d):
1702         keys = sorted(d.keys(), key=default_sort_key)
1703         items = []
1704 
1705         for key in keys:
1706             val = d[key]
1707             items.append("%s : %s" % (self._print(key), self._print(val)))
1708 
1709         return r"\left\{ %s\right\}" % r", \  ".join(items)
1710 
1711     def _print_Dict(self, expr):
1712         return self._print_dict(expr)
1713 
1714     def _print_DiracDelta(self, expr, exp=None):
1715         if len(expr.args) == 1 or expr.args[1] == 0:
1716             tex = r"\delta\left(%s\right)" % self._print(expr.args[0])
1717         else:
1718             tex = r"\delta^{\left( %s \right)}\left( %s \right)" % (
1719                 self._print(expr.args[1]), self._print(expr.args[0]))
1720         if exp:
1721             tex = r"\left(%s\right)^{%s}" % (tex, exp)
1722         return tex
1723 
1724     def _print_SingularityFunction(self, expr):
1725         shift = self._print(expr.args[0] - expr.args[1])
1726         power = self._print(expr.args[2])
1727         tex = r"{\left\langle %s \right\rangle}^{%s}" % (shift, power)
1728         return tex
1729 
1730     def _print_Heaviside(self, expr, exp=None):
1731         tex = r"\theta\left(%s\right)" % self._print(expr.args[0])
1732         if exp:
1733             tex = r"\left(%s\right)^{%s}" % (tex, exp)
1734         return tex
1735 
1736     def _print_KroneckerDelta(self, expr, exp=None):
1737         i = self._print(expr.args[0])
1738         j = self._print(expr.args[1])
1739         if expr.args[0].is_Atom and expr.args[1].is_Atom:
1740             tex = r'\delta_{%s %s}' % (i, j)
1741         else:
1742             tex = r'\delta_{%s, %s}' % (i, j)
1743         if exp is not None:
1744             tex = r'\left(%s\right)^{%s}' % (tex, exp)
1745         return tex
1746 
1747     def _print_LeviCivita(self, expr, exp=None):
1748         indices = map(self._print, expr.args)
1749         if all(x.is_Atom for x in expr.args):
1750             tex = r'\varepsilon_{%s}' % " ".join(indices)
1751         else:
1752             tex = r'\varepsilon_{%s}' % ", ".join(indices)
1753         if exp:
1754             tex = r'\left(%s\right)^{%s}' % (tex, exp)
1755         return tex
1756 
1757     def _print_ProductSet(self, p):
1758         if len(p.sets) > 1 and not has_variety(p.sets):
1759             return self._print(p.sets[0]) + "^{%d}" % len(p.sets)
1760         else:
1761             return r" \times ".join(self._print(set) for set in p.sets)
1762 
1763     def _print_RandomDomain(self, d):
1764         if hasattr(d, 'as_boolean'):
1765             return 'Domain: ' + self._print(d.as_boolean())
1766         elif hasattr(d, 'set'):
1767             return ('Domain: ' + self._print(d.symbols) + ' in ' +
1768                     self._print(d.set))
1769         elif hasattr(d, 'symbols'):
1770             return 'Domain on ' + self._print(d.symbols)
1771         else:
1772             return self._print(None)
1773 
1774     def _print_FiniteSet(self, s):
1775         items = sorted(s.args, key=default_sort_key)
1776         return self._print_set(items)
1777 
1778     def _print_set(self, s):
1779         items = sorted(s, key=default_sort_key)
1780         items = ", ".join(map(self._print, items))
1781         return r"\left\{%s\right\}" % items
1782 
1783     _print_frozenset = _print_set
1784 
1785     def _print_Range(self, s):
1786         dots = r'\ldots'
1787 
1788         if s.start.is_infinite:
1789             printset = s.start, dots, s[-1] - s.step, s[-1]
1790         elif s.stop.is_infinite or len(s) > 4:
1791             it = iter(s)
1792             printset = next(it), next(it), dots, s[-1]
1793         else:
1794             printset = tuple(s)
1795 
1796         return (r"\left\{"
1797               + r", ".join(self._print(el) for el in printset)
1798               + r"\right\}")
1799 
1800     def _print_SeqFormula(self, s):
1801         if len(s.start.free_symbols) > 0 or len(s.stop.free_symbols) > 0:
1802             return r"\left\{%s\right\}_{%s=%s}^{%s}" % (
1803                 self._print(s.formula),
1804                 self._print(s.variables[0]),
1805                 self._print(s.start),
1806                 self._print(s.stop)
1807             )
1808         if s.start is S.NegativeInfinity:
1809             stop = s.stop
1810             printset = (r'\ldots', s.coeff(stop - 3), s.coeff(stop - 2),
1811                 s.coeff(stop - 1), s.coeff(stop))
1812         elif s.stop is S.Infinity or s.length > 4:
1813             printset = s[:4]
1814             printset.append(r'\ldots')
1815         else:
1816             printset = tuple(s)
1817 
1818         return (r"\left["
1819               + r", ".join(self._print(el) for el in printset)
1820               + r"\right]")
1821 
1822     _print_SeqPer = _print_SeqFormula
1823     _print_SeqAdd = _print_SeqFormula
1824     _print_SeqMul = _print_SeqFormula
1825 
1826     def _print_Interval(self, i):
1827         if i.start == i.end:
1828             return r"\left\{%s\right\}" % self._print(i.start)
1829 
1830         else:
1831             if i.left_open:
1832                 left = '('
1833             else:
1834                 left = '['
1835 
1836             if i.right_open:
1837                 right = ')'
1838             else:
1839                 right = ']'
1840 
1841             return r"\left%s%s, %s\right%s" % \
1842                    (left, self._print(i.start), self._print(i.end), right)
1843 
1844     def _print_AccumulationBounds(self, i):
1845         return r"\left\langle %s, %s\right\rangle" % \
1846                 (self._print(i.min), self._print(i.max))
1847 
1848     def _print_Union(self, u):
1849         return r" \cup ".join([self._print(i) for i in u.args])
1850 
1851     def _print_Complement(self, u):
1852         return r" \setminus ".join([self._print(i) for i in u.args])
1853 
1854     def _print_Intersection(self, u):
1855         return r" \cap ".join([self._print(i) for i in u.args])
1856 
1857     def _print_SymmetricDifference(self, u):
1858         return r" \triangle ".join([self._print(i) for i in u.args])
1859 
1860     def _print_EmptySet(self, e):
1861         return r"\emptyset"
1862 
1863     def _print_Naturals(self, n):
1864         return r"\mathbb{N}"
1865 
1866     def _print_Naturals0(self, n):
1867         return r"\mathbb{N}_0"
1868 
1869     def _print_Integers(self, i):
1870         return r"\mathbb{Z}"
1871 
1872     def _print_Reals(self, i):
1873         return r"\mathbb{R}"
1874 
1875     def _print_Complexes(self, i):
1876         return r"\mathbb{C}"
1877 
1878     def _print_ImageSet(self, s):
1879         sets = s.args[1:]
1880         varsets = [r"%s \in %s" % (self._print(var), self._print(setv))
1881             for var, setv in zip(s.lamda.variables, sets)]
1882         return r"\left\{%s\; |\; %s\right\}" % (
1883             self._print(s.lamda.expr),
1884             ', '.join(varsets))
1885 
1886     def _print_ConditionSet(self, s):
1887         vars_print = ', '.join([self._print(var) for var in Tuple(s.sym)])
1888         if s.base_set is S.UniversalSet:
1889             return r"\left\{%s \mid %s \right\}" % (
1890             vars_print,
1891             self._print(s.condition.as_expr()))
1892 
1893         return r"\left\{%s \mid %s \in %s \wedge %s \right\}" % (
1894             vars_print,
1895             vars_print,
1896             self._print(s.base_set),
1897             self._print(s.condition))
1898 
1899     def _print_ComplexRegion(self, s):
1900         vars_print = ', '.join([self._print(var) for var in s.variables])
1901         return r"\left\{%s\; |\; %s \in %s \right\}" % (
1902             self._print(s.expr),
1903             vars_print,
1904             self._print(s.sets))
1905 
1906     def _print_Contains(self, e):
1907         return r"%s \in %s" % tuple(self._print(a) for a in e.args)
1908 
1909     def _print_FourierSeries(self, s):
1910         return self._print_Add(s.truncate()) + self._print(r' + \ldots')
1911 
1912     def _print_FormalPowerSeries(self, s):
1913         return self._print_Add(s.infinite)
1914 
1915     def _print_FiniteField(self, expr):
1916         return r"\mathbb{F}_{%s}" % expr.mod
1917 
1918     def _print_IntegerRing(self, expr):
1919         return r"\mathbb{Z}"
1920 
1921     def _print_RationalField(self, expr):
1922         return r"\mathbb{Q}"
1923 
1924     def _print_RealField(self, expr):
1925         return r"\mathbb{R}"
1926 
1927     def _print_ComplexField(self, expr):
1928         return r"\mathbb{C}"
1929 
1930     def _print_PolynomialRing(self, expr):
1931         domain = self._print(expr.domain)
1932         symbols = ", ".join(map(self._print, expr.symbols))
1933         return r"%s\left[%s\right]" % (domain, symbols)
1934 
1935     def _print_FractionField(self, expr):
1936         domain = self._print(expr.domain)
1937         symbols = ", ".join(map(self._print, expr.symbols))
1938         return r"%s\left(%s\right)" % (domain, symbols)
1939 
1940     def _print_PolynomialRingBase(self, expr):
1941         domain = self._print(expr.domain)
1942         symbols = ", ".join(map(self._print, expr.symbols))
1943         inv = ""
1944         if not expr.is_Poly:
1945             inv = r"S_<^{-1}"
1946         return r"%s%s\left[%s\right]" % (inv, domain, symbols)
1947 
1948     def _print_Poly(self, poly):
1949         cls = poly.__class__.__name__
1950         terms = []
1951         for monom, coeff in poly.terms():
1952             s_monom = ''
1953             for i, exp in enumerate(monom):
1954                 if exp > 0:
1955                     if exp == 1:
1956                         s_monom += self._print(poly.gens[i])
1957                     else:
1958                         s_monom += self._print(pow(poly.gens[i], exp))
1959 
1960             if coeff.is_Add:
1961                 if s_monom:
1962                     s_coeff = r"\left(%s\right)" % self._print(coeff)
1963                 else:
1964                     s_coeff = self._print(coeff)
1965             else:
1966                 if s_monom:
1967                     if coeff is S.One:
1968                         terms.extend(['+', s_monom])
1969                         continue
1970 
1971                     if coeff is S.NegativeOne:
1972                         terms.extend(['-', s_monom])
1973                         continue
1974 
1975                 s_coeff = self._print(coeff)
1976 
1977             if not s_monom:
1978                 s_term = s_coeff
1979             else:
1980                 s_term = s_coeff + " " + s_monom
1981 
1982             if s_term.startswith('-'):
1983                 terms.extend(['-', s_term[1:]])
1984             else:
1985                 terms.extend(['+', s_term])
1986 
1987         if terms[0] in ['-', '+']:
1988             modifier = terms.pop(0)
1989 
1990             if modifier == '-':
1991                 terms[0] = '-' + terms[0]
1992 
1993         expr = ' '.join(terms)
1994         gens = list(map(self._print, poly.gens))
1995         domain = "domain=%s" % self._print(poly.get_domain())
1996 
1997         args = ", ".join([expr] + gens + [domain])
1998         if cls in accepted_latex_functions:
1999             tex = r"\%s {\left(%s \right)}" % (cls, args)
2000         else:
2001             tex = r"\operatorname{%s}{\left( %s \right)}" % (cls, args)
2002 
2003         return tex
2004 
2005     def _print_ComplexRootOf(self, root):
2006         cls = root.__class__.__name__
2007         if cls == "ComplexRootOf":
2008             cls = "CRootOf"
2009         expr = self._print(root.expr)
2010         index = root.index
2011         if cls in accepted_latex_functions:
2012             return r"\%s {\left(%s, %d\right)}" % (cls, expr, index)
2013         else:
2014             return r"\operatorname{%s} {\left(%s, %d\right)}" % (cls, expr, index)
2015 
2016     def _print_RootSum(self, expr):
2017         cls = expr.__class__.__name__
2018         args = [self._print(expr.expr)]
2019 
2020         if expr.fun is not S.IdentityFunction:
2021             args.append(self._print(expr.fun))
2022 
2023         if cls in accepted_latex_functions:
2024             return r"\%s {\left(%s\right)}" % (cls, ", ".join(args))
2025         else:
2026             return r"\operatorname{%s} {\left(%s\right)}" % (cls, ", ".join(args))
2027 
2028     def _print_PolyElement(self, poly):
2029         mul_symbol = self._settings['mul_symbol_latex']
2030         return poly.str(self, PRECEDENCE, "{%s}^{%d}", mul_symbol)
2031 
2032     def _print_FracElement(self, frac):
2033         if frac.denom == 1:
2034             return self._print(frac.numer)
2035         else:
2036             numer = self._print(frac.numer)
2037             denom = self._print(frac.denom)
2038             return r"\frac{%s}{%s}" % (numer, denom)
2039 
2040     def _print_euler(self, expr, exp=None):
2041         m, x = (expr.args[0], None) if len(expr.args) == 1 else expr.args
2042         tex = r"E_{%s}" % self._print(m)
2043         if exp is not None:
2044             tex = r"%s^{%s}" % (tex, self._print(exp))
2045         if x is not None:
2046             tex = r"%s\left(%s\right)" % (tex, self._print(x))
2047         return tex
2048 
2049     def _print_catalan(self, expr, exp=None):
2050         tex = r"C_{%s}" % self._print(expr.args[0])
2051         if exp is not None:
2052             tex = r"%s^{%s}" % (tex, self._print(exp))
2053         return tex
2054 
2055     def _print_MellinTransform(self, expr):
2056         return r"\mathcal{M}_{%s}\left[%s\right]\left(%s\right)" % (self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))
2057 
2058     def _print_InverseMellinTransform(self, expr):
2059         return r"\mathcal{M}^{-1}_{%s}\left[%s\right]\left(%s\right)" % (self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))
2060 
2061     def _print_LaplaceTransform(self, expr):
2062         return r"\mathcal{L}_{%s}\left[%s\right]\left(%s\right)" % (self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))
2063 
2064     def _print_InverseLaplaceTransform(self, expr):
2065         return r"\mathcal{L}^{-1}_{%s}\left[%s\right]\left(%s\right)" % (self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))
2066 
2067     def _print_FourierTransform(self, expr):
2068         return r"\mathcal{F}_{%s}\left[%s\right]\left(%s\right)" % (self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))
2069 
2070     def _print_InverseFourierTransform(self, expr):
2071         return r"\mathcal{F}^{-1}_{%s}\left[%s\right]\left(%s\right)" % (self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))
2072 
2073     def _print_SineTransform(self, expr):
2074         return r"\mathcal{SIN}_{%s}\left[%s\right]\left(%s\right)" % (self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))
2075 
2076     def _print_InverseSineTransform(self, expr):
2077         return r"\mathcal{SIN}^{-1}_{%s}\left[%s\right]\left(%s\right)" % (self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))
2078 
2079     def _print_CosineTransform(self, expr):
2080         return r"\mathcal{COS}_{%s}\left[%s\right]\left(%s\right)" % (self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))
2081 
2082     def _print_InverseCosineTransform(self, expr):
2083         return r"\mathcal{COS}^{-1}_{%s}\left[%s\right]\left(%s\right)" % (self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))
2084 
2085     def _print_DMP(self, p):
2086         try:
2087             if p.ring is not None:
2088                 # TODO incorporate order
2089                 return self._print(p.ring.to_sympy(p))
2090         except SympifyError:
2091             pass
2092         return self._print(repr(p))
2093 
2094     def _print_DMF(self, p):
2095         return self._print_DMP(p)
2096 
2097     def _print_Object(self, object):
2098         return self._print(Symbol(object.name))
2099 
2100     def _print_Morphism(self, morphism):
2101         domain = self._print(morphism.domain)
2102         codomain = self._print(morphism.codomain)
2103         return "%s\\rightarrow %s" % (domain, codomain)
2104 
2105     def _print_NamedMorphism(self, morphism):
2106         pretty_name = self._print(Symbol(morphism.name))
2107         pretty_morphism = self._print_Morphism(morphism)
2108         return "%s:%s" % (pretty_name, pretty_morphism)
2109 
2110     def _print_IdentityMorphism(self, morphism):
2111         from sympy.categories import NamedMorphism
2112         return self._print_NamedMorphism(NamedMorphism(
2113             morphism.domain, morphism.codomain, "id"))
2114 
2115     def _print_CompositeMorphism(self, morphism):
2116         # All components of the morphism have names and it is thus
2117         # possible to build the name of the composite.
2118         component_names_list = [self._print(Symbol(component.name)) for
2119                                 component in morphism.components]
2120         component_names_list.reverse()
2121         component_names = "\\circ ".join(component_names_list) + ":"
2122 
2123         pretty_morphism = self._print_Morphism(morphism)
2124         return component_names + pretty_morphism
2125 
2126     def _print_Category(self, morphism):
2127         return "\\mathbf{%s}" % self._print(Symbol(morphism.name))
2128 
2129     def _print_Diagram(self, diagram):
2130         if not diagram.premises:
2131             # This is an empty diagram.
2132             return self._print(S.EmptySet)
2133 
2134         latex_result = self._print(diagram.premises)
2135         if diagram.conclusions:
2136             latex_result += "\\Longrightarrow %s" % \
2137                             self._print(diagram.conclusions)
2138 
2139         return latex_result
2140 
2141     def _print_DiagramGrid(self, grid):
2142         latex_result = "\\begin{array}{%s}\n" % ("c" * grid.width)
2143 
2144         for i in range(grid.height):
2145             for j in range(grid.width):
2146                 if grid[i, j]:
2147                     latex_result += latex(grid[i, j])
2148                 latex_result += " "
2149                 if j != grid.width - 1:
2150                     latex_result += "& "
2151 
2152             if i != grid.height - 1:
2153                 latex_result += "\\\\"
2154             latex_result += "\n"
2155 
2156         latex_result += "\\end{array}\n"
2157         return latex_result
2158 
2159     def _print_FreeModule(self, M):
2160         return '{%s}^{%s}' % (self._print(M.ring), self._print(M.rank))
2161 
2162     def _print_FreeModuleElement(self, m):
2163         # Print as row vector for convenience, for now.
2164         return r"\left[ %s \right]" % ",".join(
2165             '{' + self._print(x) + '}' for x in m)
2166 
2167     def _print_SubModule(self, m):
2168         return r"\left\langle %s \right\rangle" % ",".join(
2169             '{' + self._print(x) + '}' for x in m.gens)
2170 
2171     def _print_ModuleImplementedIdeal(self, m):
2172         return r"\left\langle %s \right\rangle" % ",".join(
2173             '{' + self._print(x) + '}' for [x] in m._module.gens)
2174 
2175     def _print_Quaternion(self, expr):
2176         # TODO: This expression is potentially confusing,
2177         # shall we print it as `Quaternion( ... )`?
2178         s = [self.parenthesize(i, PRECEDENCE["Mul"], strict=True) for i in expr.args]
2179         a = [s[0]] + [i+" "+j for i, j in zip(s[1:], "ijk")]
2180         return " + ".join(a)
2181 
2182     def _print_QuotientRing(self, R):
2183         # TODO nicer fractions for few generators...
2184         return r"\frac{%s}{%s}" % (self._print(R.ring), self._print(R.base_ideal))
2185 
2186     def _print_QuotientRingElement(self, x):
2187         return r"{%s} + {%s}" % (self._print(x.data), self._print(x.ring.base_ideal))
2188 
2189     def _print_QuotientModuleElement(self, m):
2190         return r"{%s} + {%s}" % (self._print(m.data),
2191                                  self._print(m.module.killed_module))
2192 
2193     def _print_QuotientModule(self, M):
2194         # TODO nicer fractions for few generators...
2195         return r"\frac{%s}{%s}" % (self._print(M.base),
2196                                    self._print(M.killed_module))
2197 
2198     def _print_MatrixHomomorphism(self, h):
2199         return r"{%s} : {%s} \to {%s}" % (self._print(h._sympy_matrix()),
2200             self._print(h.domain), self._print(h.codomain))
2201 
2202     def _print_BaseScalarField(self, field):
2203         string = field._coord_sys._names[field._index]
2204         return r'\boldsymbol{\mathrm{%s}}' % self._print(Symbol(string))
2205 
2206     def _print_BaseVectorField(self, field):
2207         string = field._coord_sys._names[field._index]
2208         return r'\partial_{%s}' % self._print(Symbol(string))
2209 
2210     def _print_Differential(self, diff):
2211         field = diff._form_field
2212         if hasattr(field, '_coord_sys'):
2213             string = field._coord_sys._names[field._index]
2214             return r'\mathrm{d}%s' % self._print(Symbol(string))
2215         else:
2216             return 'd(%s)' % self._print(field)
2217             string = self._print(field)
2218             return r'\mathrm{d}\left(%s\right)' % string
2219 
2220     def _print_Tr(self, p):
2221         #Todo: Handle indices
2222         contents = self._print(p.args[0])
2223         return r'\mbox{Tr}\left(%s\right)' % (contents)
2224 
2225     def _print_totient(self, expr, exp=None):
2226         if exp is not None:
2227             return r'\left(\phi\left(%s\right)\right)^{%s}' % (self._print(expr.args[0]),
2228                     self._print(exp))
2229         return r'\phi\left(%s\right)' % self._print(expr.args[0])
2230 
2231     def _print_reduced_totient(self, expr, exp=None):
2232         if exp is not None:
2233             return r'\left(\lambda\left(%s\right)\right)^{%s}' % (self._print(expr.args[0]),
2234                     self._print(exp))
2235         return r'\lambda\left(%s\right)' % self._print(expr.args[0])
2236 
2237     def _print_divisor_sigma(self, expr, exp=None):
2238         if len(expr.args) == 2:
2239             tex = r"_%s\left(%s\right)" % tuple(map(self._print,
2240                                                 (expr.args[1], expr.args[0])))
2241         else:
2242             tex = r"\left(%s\right)" % self._print(expr.args[0])
2243         if exp is not None:
2244             return r"\sigma^{%s}%s" % (self._print(exp), tex)
2245         return r"\sigma%s" % tex
2246 
2247     def _print_udivisor_sigma(self, expr, exp=None):
2248         if len(expr.args) == 2:
2249             tex = r"_%s\left(%s\right)" % tuple(map(self._print,
2250                                                 (expr.args[1], expr.args[0])))
2251         else:
2252             tex = r"\left(%s\right)" % self._print(expr.args[0])
2253         if exp is not None:
2254             return r"\sigma^*^{%s}%s" % (self._print(exp), tex)
2255         return r"\sigma^*%s" % tex
2256 
2257     def _print_primenu(self, expr, exp=None):
2258         if exp is not None:
2259             return r'\left(\nu\left(%s\right)\right)^{%s}' % (self._print(expr.args[0]),
2260                     self._print(exp))
2261         return r'\nu\left(%s\right)' % self._print(expr.args[0])
2262 
2263     def _print_primeomega(self, expr, exp=None):
2264         if exp is not None:
2265             return r'\left(\Omega\left(%s\right)\right)^{%s}' % (self._print(expr.args[0]),
2266                     self._print(exp))
2267         return r'\Omega\left(%s\right)' % self._print(expr.args[0])
2268 
2269 
2270 def translate(s):
2271     r'''
2272     Check for a modifier ending the string.  If present, convert the
2273     modifier to latex and translate the rest recursively.
2274 
2275     Given a description of a Greek letter or other special character,
2276     return the appropriate latex.
2277 
2278     Let everything else pass as given.
2279 
2280     >>> from sympy.printing.latex import translate
2281     >>> translate('alphahatdotprime')
2282     "{\\dot{\\hat{\\alpha}}}'"
2283     '''
2284     # Process the rest
2285     tex = tex_greek_dictionary.get(s)
2286     if tex:
2287         return tex
2288     elif s.lower() in greek_letters_set:
2289         return "\\" + s.lower()
2290     elif s in other_symbols:
2291         return "\\" + s
2292     else:
2293         # Process modifiers, if any, and recurse
2294         for key in sorted(modifier_dict.keys(), key=lambda k:len(k), reverse=True):
2295             if s.lower().endswith(key) and len(s) > len(key):
2296                 return modifier_dict[key](translate(s[:-len(key)]))
2297         return s
2298 
2299 
2300 def latex(expr, fold_frac_powers=False, fold_func_brackets=False,
2301     fold_short_frac=None, inv_trig_style="abbreviated",
2302     itex=False, ln_notation=False, long_frac_ratio=None,
2303     mat_delim="[", mat_str=None, mode="plain", mul_symbol=None,
2304     order=None, symbol_names=None, root_notation=True,
2305     mat_symbol_style="plain", imaginary_unit="i"):
2306     r"""Convert the given expression to LaTeX string representation.
2307 
2308     Parameters
2309     ==========
2310     fold_frac_powers : boolean, optional
2311         Emit ``^{p/q}`` instead of ``^{\frac{p}{q}}`` for fractional powers.
2312     fold_func_brackets : boolean, optional
2313         Fold function brackets where applicable.
2314     fold_short_frac : boolean, optional
2315         Emit ``p / q`` instead of ``\frac{p}{q}`` when the denominator is
2316         simple enough (at most two terms and no powers). The default value is
2317         ``True`` for inline mode, ``False`` otherwise.
2318     inv_trig_style : string, optional
2319         How inverse trig functions should be displayed. Can be one of
2320         ``abbreviated``, ``full``, or ``power``. Defaults to ``abbreviated``.
2321     itex : boolean, optional
2322         Specifies if itex-specific syntax is used, including emitting
2323         ``$$...$$``.
2324     ln_notation : boolean, optional
2325         If set to ``True``, ``\ln`` is used instead of default ``\log``.
2326     long_frac_ratio : float or None, optional
2327         The allowed ratio of the width of the numerator to the width of the
2328         denominator before the printer breaks off long fractions. If ``None``
2329         (the default value), long fractions are not broken up.
2330     mat_delim : string, optional
2331         The delimiter to wrap around matrices. Can be one of ``[``, ``(``, or
2332         the empty string. Defaults to ``[``.
2333     mat_str : string, optional
2334         Which matrix environment string to emit. ``smallmatrix``, ``matrix``,
2335         ``array``, etc. Defaults to ``smallmatrix`` for inline mode, ``matrix``
2336         for matrices of no more than 10 columns, and ``array`` otherwise.
2337     mode: string, optional
2338         Specifies how the generated code will be delimited. ``mode`` can be one
2339         of ``plain``, ``inline``, ``equation`` or ``equation*``.  If ``mode``
2340         is set to ``plain``, then the resulting code will not be delimited at
2341         all (this is the default). If ``mode`` is set to ``inline`` then inline
2342         LaTeX ``$...$`` will be used. If ``mode`` is set to ``equation`` or
2343         ``equation*``, the resulting code will be enclosed in the ``equation``
2344         or ``equation*`` environment (remember to import ``amsmath`` for
2345         ``equation*``), unless the ``itex`` option is set. In the latter case,
2346         the ``$$...$$`` syntax is used.
2347     mul_symbol : string or None, optional
2348         The symbol to use for multiplication. Can be one of ``None``, ``ldot``,
2349         ``dot``, or ``times``.
2350     order: string, optional
2351         Any of the supported monomial orderings (currently ``lex``, ``grlex``,
2352         or ``grevlex``), ``old``, and ``none``. This parameter does nothing for
2353         Mul objects. Setting order to ``old`` uses the compatibility ordering
2354         for Add defined in Printer. For very large expressions, set the
2355         ``order`` keyword to ``none`` if speed is a concern.
2356     symbol_names : dictionary of strings mapped to symbols, optional
2357         Dictionary of symbols and the custom strings they should be emitted as.
2358     root_notation : boolean, optional
2359         If set to ``False``, exponents of the form 1/n are printed in fractonal form.
2360         Default is ``True``, to print exponent in root form.
2361     mat_symbol_style : string, optional
2362         Can be either ``plain`` (default) or ``bold``. If set to ``bold``,
2363         a MatrixSymbol A will be printed as ``\mathbf{A}``, otherwise as ``A``.
2364     imaginary_unit : string, optional
2365         String to use for the imaginary unit. Defined options are "i" (default)
2366         and "j". Adding "b" or "t" in front gives ``\mathrm`` or ``\text``, so
2367         "bi" leads to ``\mathrm{i}`` which gives `\mathrm{i}`.
2368 
2369     Notes
2370     =====
2371 
2372     Not using a print statement for printing, results in double backslashes for
2373     latex commands since that's the way Python escapes backslashes in strings.
2374 
2375     >>> from sympy import latex, Rational
2376     >>> from sympy.abc import tau
2377     >>> latex((2*tau)**Rational(7,2))
2378     '8 \\sqrt{2} \\tau^{\\frac{7}{2}}'
2379     >>> print(latex((2*tau)**Rational(7,2)))
2380     8 \sqrt{2} \tau^{\frac{7}{2}}
2381 
2382     Examples
2383     ========
2384 
2385     >>> from sympy import latex, pi, sin, asin, Integral, Matrix, Rational, log
2386     >>> from sympy.abc import x, y, mu, r, tau
2387 
2388     Basic usage:
2389 
2390     >>> print(latex((2*tau)**Rational(7,2)))
2391     8 \sqrt{2} \tau^{\frac{7}{2}}
2392 
2393     ``mode`` and ``itex`` options:
2394 
2395     >>> print(latex((2*mu)**Rational(7,2), mode='plain'))
2396     8 \sqrt{2} \mu^{\frac{7}{2}}
2397     >>> print(latex((2*tau)**Rational(7,2), mode='inline'))
2398     $8 \sqrt{2} \tau^{7 / 2}$
2399     >>> print(latex((2*mu)**Rational(7,2), mode='equation*'))
2400     \begin{equation*}8 \sqrt{2} \mu^{\frac{7}{2}}\end{equation*}
2401     >>> print(latex((2*mu)**Rational(7,2), mode='equation'))
2402     \begin{equation}8 \sqrt{2} \mu^{\frac{7}{2}}\end{equation}
2403     >>> print(latex((2*mu)**Rational(7,2), mode='equation', itex=True))
2404     $$8 \sqrt{2} \mu^{\frac{7}{2}}$$
2405     >>> print(latex((2*mu)**Rational(7,2), mode='plain'))
2406     8 \sqrt{2} \mu^{\frac{7}{2}}
2407     >>> print(latex((2*tau)**Rational(7,2), mode='inline'))
2408     $8 \sqrt{2} \tau^{7 / 2}$
2409     >>> print(latex((2*mu)**Rational(7,2), mode='equation*'))
2410     \begin{equation*}8 \sqrt{2} \mu^{\frac{7}{2}}\end{equation*}
2411     >>> print(latex((2*mu)**Rational(7,2), mode='equation'))
2412     \begin{equation}8 \sqrt{2} \mu^{\frac{7}{2}}\end{equation}
2413     >>> print(latex((2*mu)**Rational(7,2), mode='equation', itex=True))
2414     $$8 \sqrt{2} \mu^{\frac{7}{2}}$$
2415 
2416     Fraction options:
2417 
2418     >>> print(latex((2*tau)**Rational(7,2), fold_frac_powers=True))
2419     8 \sqrt{2} \tau^{7/2}
2420     >>> print(latex((2*tau)**sin(Rational(7,2))))
2421     \left(2 \tau\right)^{\sin{\left(\frac{7}{2} \right)}}
2422     >>> print(latex((2*tau)**sin(Rational(7,2)), fold_func_brackets=True))
2423     \left(2 \tau\right)^{\sin {\frac{7}{2}}}
2424     >>> print(latex(3*x**2/y))
2425     \frac{3 x^{2}}{y}
2426     >>> print(latex(3*x**2/y, fold_short_frac=True))
2427     3 x^{2} / y
2428     >>> print(latex(Integral(r, r)/2/pi, long_frac_ratio=2))
2429     \frac{\int r\, dr}{2 \pi}
2430     >>> print(latex(Integral(r, r)/2/pi, long_frac_ratio=0))
2431     \frac{1}{2 \pi} \int r\, dr
2432 
2433     Multiplication options:
2434 
2435     >>> print(latex((2*tau)**sin(Rational(7,2)), mul_symbol="times"))
2436     \left(2 \times \tau\right)^{\sin{\left(\frac{7}{2} \right)}}
2437 
2438     Trig options:
2439 
2440     >>> print(latex(asin(Rational(7,2))))
2441     \operatorname{asin}{\left(\frac{7}{2} \right)}
2442     >>> print(latex(asin(Rational(7,2)), inv_trig_style="full"))
2443     \arcsin{\left(\frac{7}{2} \right)}
2444     >>> print(latex(asin(Rational(7,2)), inv_trig_style="power"))
2445     \sin^{-1}{\left(\frac{7}{2} \right)}
2446 
2447     Matrix options:
2448 
2449     >>> print(latex(Matrix(2, 1, [x, y])))
2450     \left[\begin{matrix}x\\y\end{matrix}\right]
2451     >>> print(latex(Matrix(2, 1, [x, y]), mat_str = "array"))
2452     \left[\begin{array}{c}x\\y\end{array}\right]
2453     >>> print(latex(Matrix(2, 1, [x, y]), mat_delim="("))
2454     \left(\begin{matrix}x\\y\end{matrix}\right)
2455 
2456     Custom printing of symbols:
2457 
2458     >>> print(latex(x**2, symbol_names={x: 'x_i'}))
2459     x_i^{2}
2460 
2461     Logarithms:
2462 
2463     >>> print(latex(log(10)))
2464     \log{\left(10 \right)}
2465     >>> print(latex(log(10), ln_notation=True))
2466     \ln{\left(10 \right)}
2467 
2468     ``latex()`` also supports the builtin container types list, tuple, and
2469     dictionary.
2470 
2471     >>> print(latex([2/x, y], mode='inline'))
2472     $\left[ 2 / x, \  y\right]$
2473 
2474     """
2475     if symbol_names is None:
2476         symbol_names = {}
2477 
2478     settings = {
2479         'fold_frac_powers' : fold_frac_powers,
2480         'fold_func_brackets' : fold_func_brackets,
2481         'fold_short_frac' : fold_short_frac,
2482         'inv_trig_style' : inv_trig_style,
2483         'itex' : itex,
2484         'ln_notation' : ln_notation,
2485         'long_frac_ratio' : long_frac_ratio,
2486         'mat_delim' : mat_delim,
2487         'mat_str' : mat_str,
2488         'mode' : mode,
2489         'mul_symbol' : mul_symbol,
2490         'order' : order,
2491         'symbol_names' : symbol_names,
2492         'root_notation' : root_notation,
2493         'mat_symbol_style' : mat_symbol_style,
2494         'imaginary_unit' : imaginary_unit,
2495     }
2496 
2497     return LatexPrinter(settings).doprint(expr)
2498 
2499 
2500 def print_latex(expr, **settings):
2501     """Prints LaTeX representation of the given expression. Takes the same
2502     settings as ``latex()``."""
2503     print(latex(expr, **settings))

</code><intended_behavior>Given that LaTeX printing is a significant part of SymPy's output capabilities, ensuring that this module can handle and correctly print the SymPy representations of Mathematica matrices and arrays is essential. This might involve modifying or extending the LaTeX printer to detect when a matrix or array (possibly parsed from Mathematica syntax) is being printed and applying the correct formatting so that the output resembles or is compatible with Mathematica's own representation, or more generally, is mathematically accurate. If necessary, specific case handling for arrays and matrices originating from Mathematica syntax might be added to preserve the fidelity of the original expressions.</intended_behavior>]
2025-10-16 02:41:59.446 | INFO     | Search completed. Bug locations: [<file>sympy/parsing/mathematica.py</file>
<class>None</class>
<method>None</method>
<code>
1 from __future__ import print_function, division
2 
3 from itertools import product
4 import re
5 from sympy import sympify
6 
7 
8 def mathematica(s, additional_translations=None):
9     '''Users can add their own translation dictionary
10     # Example
11     In [1]: mathematica('Log3[9]', {'Log3[x]':'log(x,3)'})
12     Out[1]: 2
13     In [2]: mathematica('F[7,5,3]', {'F[*x]':'Max(*x)*Min(*x)'})
14     Out[2]: 21
15     variable-length argument needs '*' character '''
16 
17     parser = MathematicaParser(additional_translations)
18     return sympify(parser.parse(s))
19 
20 
21 def _deco(cls):
22     cls._initialize_class()
23     return cls
24 
25 
26 @_deco
27 class MathematicaParser(object):
28     '''An instance of this class converts a string of a basic Mathematica
29     expression to SymPy style. Output is string type.'''
30 
31     # left: Mathematica, right: SymPy
32     CORRESPONDENCES = {
33         'Sqrt[x]': 'sqrt(x)',
34         'Exp[x]': 'exp(x)',
35         'Log[x]': 'log(x)',
36         'Log[x,y]': 'log(y,x)',
37         'Log2[x]': 'log(x,2)',
38         'Log10[x]': 'log(x,10)',
39         'Mod[x,y]': 'Mod(x,y)',
40         'Max[*x]': 'Max(*x)',
41         'Min[*x]': 'Min(*x)',
42     }
43 
44     # trigonometric, e.t.c.
45     for arc, tri, h in product(('', 'Arc'), (
46             'Sin', 'Cos', 'Tan', 'Cot', 'Sec', 'Csc'), ('', 'h')):
47         fm = arc + tri + h + '[x]'
48         if arc:  # arc func
49             fs = 'a' + tri.lower() + h + '(x)'
50         else:    # non-arc func
51             fs = tri.lower() + h + '(x)'
52         CORRESPONDENCES.update({fm: fs})
53 
54     REPLACEMENTS = {
55         ' ': '',
56         '^': '**',
57         '{': '[',
58         '}': ']',
59     }
60 
61     RULES = {
62         # a single whitespace to '*'
63         'whitespace': (
64             re.compile(r'''
65                 (?<=[a-zA-Z\d])     # a letter or a number
66                 \                   # a whitespace
67                 (?=[a-zA-Z\d])      # a letter or a number
68                 ''', re.VERBOSE),
69             '*'),
70 
71         # add omitted '*' character
72         'add*_1': (
73             re.compile(r'''
74                 (?<=[])\d])         # ], ) or a number
75                                     # ''
76                 (?=[(a-zA-Z])       # ( or a single letter
77                 ''', re.VERBOSE),
78             '*'),
79 
80         # add omitted '*' character (variable letter preceding)
81         'add*_2': (
82             re.compile(r'''
83                 (?<=[a-zA-Z])       # a letter
84                 \(                  # ( as a character
85                 (?=.)               # any characters
86                 ''', re.VERBOSE),
87             '*('),
88 
89         # convert 'Pi' to 'pi'
90         'Pi': (
91             re.compile(r'''
92                 (?:
93                 \A|(?<=[^a-zA-Z])
94                 )
95                 Pi                  # 'Pi' is 3.14159... in Mathematica
96                 (?=[^a-zA-Z])
97                 ''', re.VERBOSE),
98             'pi'),
99     }
100 
101     # Mathematica function name pattern
102     FM_PATTERN = re.compile(r'''
103                 (?:
104                 \A|(?<=[^a-zA-Z])   # at the top or a non-letter
105                 )
106                 [A-Z][a-zA-Z\d]*    # Function
107                 (?=\[)              # [ as a character
108                 ''', re.VERBOSE)
109 
110     # list or matrix pattern (for future usage)
111     ARG_MTRX_PATTERN = re.compile(r'''
112                 \{.*\}
113                 ''', re.VERBOSE)
114 
115     # regex string for function argument pattern
116     ARGS_PATTERN_TEMPLATE = r'''
117                 (?:
118                 \A|(?<=[^a-zA-Z])
119                 )
120                 {arguments}         # model argument like x, y,...
121                 (?=[^a-zA-Z])
122                 '''
123 
124     # will contain transformed CORRESPONDENCES dictionary
125     TRANSLATIONS = {}
126 
127     # cache for a raw users' translation dictionary
128     cache_original = {}
129 
130     # cache for a compiled users' translation dictionary
131     cache_compiled = {}
132 
133     @classmethod
134     def _initialize_class(cls):
135         # get a transformed CORRESPONDENCES dictionary
136         d = cls._compile_dictionary(cls.CORRESPONDENCES)
137         cls.TRANSLATIONS.update(d)
138 
139     def __init__(self, additional_translations=None):
140         self.translations = {}
141 
142         # update with TRANSLATIONS (class constant)
143         self.translations.update(self.TRANSLATIONS)
144 
145         if additional_translations is None:
146             additional_translations = {}
147 
148         # check the latest added translations
149         if self.__class__.cache_original != additional_translations:
150             if not isinstance(additional_translations, dict):
151                 raise ValueError('The argument must be dict type')
152 
153             # get a transformed additional_translations dictionary
154             d = self._compile_dictionary(additional_translations)
155 
156             # update cache
157             self.__class__.cache_original = additional_translations
158             self.__class__.cache_compiled = d
159 
160         # merge user's own translations
161         self.translations.update(self.__class__.cache_compiled)
162 
163     @classmethod
164     def _compile_dictionary(cls, dic):
165         # for return
166         d = {}
167 
168         for fm, fs in dic.items():
169             # check function form
170             cls._check_input(fm)
171             cls._check_input(fs)
172 
173             # uncover '*' hiding behind a whitespace
174             fm = cls._apply_rules(fm, 'whitespace')
175             fs = cls._apply_rules(fs, 'whitespace')
176 
177             # remove whitespace(s)
178             fm = cls._replace(fm, ' ')
179             fs = cls._replace(fs, ' ')
180 
181             # search Mathematica function name
182             m = cls.FM_PATTERN.search(fm)
183 
184             # if no-hit
185             if m is None:
186                 err = "'{f}' function form is invalid.".format(f=fm)
187                 raise ValueError(err)
188 
189             # get Mathematica function name like 'Log'
190             fm_name = m.group()
191 
192             # get arguments of Mathematica function
193             args, end = cls._get_args(m)
194 
195             # function side check. (e.g.) '2*Func[x]' is invalid.
196             if m.start() != 0 or end != len(fm):
197                 err = "'{f}' function form is invalid.".format(f=fm)
198                 raise ValueError(err)
199 
200             # check the last argument's 1st character
201             if args[-1][0] == '*':
202                 key_arg = '*'
203             else:
204                 key_arg = len(args)
205 
206             key = (fm_name, key_arg)
207 
208             # convert '*x' to '\\*x' for regex
209             re_args = [x if x[0] != '*' else '\\' + x for x in args]
210 
211             # for regex. Example: (?:(x|y|z))
212             xyz = '(?:(' + '|'.join(re_args) + '))'
213 
214             # string for regex compile
215             patStr = cls.ARGS_PATTERN_TEMPLATE.format(arguments=xyz)
216 
217             pat = re.compile(patStr, re.VERBOSE)
218 
219             # update dictionary
220             d[key] = {}
221             d[key]['fs'] = fs  # SymPy function template
222             d[key]['args'] = args  # args are ['x', 'y'] for example
223             d[key]['pat'] = pat
224 
225         return d
226 
227     def _convert_function(self, s):
228         '''Parse Mathematica function to SymPy one'''
229 
230         # compiled regex object
231         pat = self.FM_PATTERN
232 
233         scanned = ''                # converted string
234         cur = 0                     # position cursor
235         while True:
236             m = pat.search(s)
237 
238             if m is None:
239                 # append the rest of string
240                 scanned += s
241                 break
242 
243             # get Mathematica function name
244             fm = m.group()
245 
246             # get arguments, and the end position of fm function
247             args, end = self._get_args(m)
248 
249             # the start position of fm function
250             bgn = m.start()
251 
252             # convert Mathematica function to SymPy one
253             s = self._convert_one_function(s, fm, args, bgn, end)
254 
255             # update cursor
256             cur = bgn
257 
258             # append converted part
259             scanned += s[:cur]
260 
261             # shrink s
262             s = s[cur:]
263 
264         return scanned
265 
266     def _convert_one_function(self, s, fm, args, bgn, end):
267         # no variable-length argument
268         if (fm, len(args)) in self.translations:
269             key = (fm, len(args))
270 
271             # x, y,... model arguments
272             x_args = self.translations[key]['args']
273 
274             # make CORRESPONDENCES between model arguments and actual ones
275             d = {k: v for k, v in zip(x_args, args)}
276 
277         # with variable-length argument
278         elif (fm, '*') in self.translations:
279             key = (fm, '*')
280 
281             # x, y,..*args (model arguments)
282             x_args = self.translations[key]['args']
283 
284             # make CORRESPONDENCES between model arguments and actual ones
285             d = {}
286             for i, x in enumerate(x_args):
287                 if x[0] == '*':
288                     d[x] = ','.join(args[i:])
289                     break
290                 d[x] = args[i]
291 
292         # out of self.translations
293         else:
294             err = "'{f}' is out of the whitelist.".format(f=fm)
295             raise ValueError(err)
296 
297         # template string of converted function
298         template = self.translations[key]['fs']
299 
300         # regex pattern for x_args
301         pat = self.translations[key]['pat']
302 
303         scanned = ''
304         cur = 0
305         while True:
306             m = pat.search(template)
307 
308             if m is None:
309                 scanned += template
310                 break
311 
312             # get model argument
313             x = m.group()
314 
315             # get a start position of the model argument
316             xbgn = m.start()
317 
318             # add the corresponding actual argument
319             scanned += template[:xbgn] + d[x]
320 
321             # update cursor to the end of the model argument
322             cur = m.end()
323 
324             # shrink template
325             template = template[cur:]
326 
327         # update to swapped string
328         s = s[:bgn] + scanned + s[end:]
329 
330         return s
331 
332     @classmethod
333     def _get_args(cls, m):
334         '''Get arguments of a Mathematica function'''
335 
336         s = m.string                # whole string
337         anc = m.end() + 1           # pointing the first letter of arguments
338         square, curly = [], []      # stack for brakets
339         args = []
340 
341         # current cursor
342         cur = anc
343         for i, c in enumerate(s[anc:], anc):
344             # extract one argument
345             if c == ',' and (not square) and (not curly):
346                 args.append(s[cur:i])       # add an argument
347                 cur = i + 1                 # move cursor
348 
349             # handle list or matrix (for future usage)
350             if c == '{':
351                 curly.append(c)
352             elif c == '}':
353                 curly.pop()
354 
355             # seek corresponding ']' with skipping irrevant ones
356             if c == '[':
357                 square.append(c)
358             elif c == ']':
359                 if square:
360                     square.pop()
361                 else:   # empty stack
362                     args.append(s[cur:i])
363                     break
364 
365         # the next position to ']' bracket (the function end)
366         func_end = i + 1
367 
368         return args, func_end
369 
370     @classmethod
371     def _replace(cls, s, bef):
372         aft = cls.REPLACEMENTS[bef]
373         s = s.replace(bef, aft)
374         return s
375 
376     @classmethod
377     def _apply_rules(cls, s, bef):
378         pat, aft = cls.RULES[bef]
379         return pat.sub(aft, s)
380 
381     @classmethod
382     def _check_input(cls, s):
383         for bracket in (('[', ']'), ('{', '}'), ('(', ')')):
384             if s.count(bracket[0]) != s.count(bracket[1]):
385                 err = "'{f}' function form is invalid.".format(f=s)
386                 raise ValueError(err)
387 
388         if '{' in s:
389             err = "Currently list is not supported.".format(f=s)
390             raise ValueError(err)
391 
392     def parse(self, s):
393         # input check
394         self._check_input(s)
395 
396         # uncover '*' hiding behind a whitespace
397         s = self._apply_rules(s, 'whitespace')
398 
399         # remove whitespace(s)
400         s = self._replace(s, ' ')
401 
402         # add omitted '*' character
403         s = self._apply_rules(s, 'add*_1')
404         s = self._apply_rules(s, 'add*_2')
405 
406         # translate function
407         s = self._convert_function(s)
408 
409         # '^' to '**'
410         s = self._replace(s, '^')
411 
412         # 'Pi' to 'pi'
413         s = self._apply_rules(s, 'Pi')
414 
415         # '{', '}' to '[', ']', respectively
416 #        s = cls._replace(s, '{')   # currently list is not taken into account
417 #        s = cls._replace(s, '}')
418 
419         return s

</code><intended_behavior>This file is crucial for parsing Mathematica expressions into SymPy representations. To resolve the issue, it should be ensured this module can correctly parse and translate Mathematica matrices and arrays into SymPy's equivalent representations. If necessary, new handling routines or enhancements should be added specifically targeting the representation of matrices and arrays from Mathematica, including how they are represented in textual or printed form. This might involve adding new methods or enhancing existing ones to parse Mathematica syntax for arrays and matrices, ensuring they are converted into appropriate SymPy objects that can be printed correctly.</intended_behavior>, <file>sympy/printing/latex.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2 A Printer which converts an expression into its LaTeX equivalent.
3 """
4 
5 from __future__ import print_function, division
6 
7 import itertools
8 
9 from sympy.core import S, Add, Symbol, Mod
10 from sympy.core.alphabets import greeks
11 from sympy.core.containers import Tuple
12 from sympy.core.function import _coeff_isneg, AppliedUndef, Derivative
13 from sympy.core.operations import AssocOp
14 from sympy.core.sympify import SympifyError
15 from sympy.logic.boolalg import true
16 
17 ## sympy.printing imports
18 from sympy.printing.precedence import precedence_traditional
19 from sympy.printing.printer import Printer
20 from sympy.printing.conventions import split_super_sub, requires_partial
21 from sympy.printing.precedence import precedence, PRECEDENCE
22 
23 import mpmath.libmp as mlib
24 from mpmath.libmp import prec_to_dps
25 
26 from sympy.core.compatibility import default_sort_key, range
27 from sympy.utilities.iterables import has_variety
28 
29 import re
30 
31 # Hand-picked functions which can be used directly in both LaTeX and MathJax
32 # Complete list at https://docs.mathjax.org/en/latest/tex.html#supported-latex-commands
33 # This variable only contains those functions which sympy uses.
34 accepted_latex_functions = ['arcsin', 'arccos', 'arctan', 'sin', 'cos', 'tan',
35                     'sinh', 'cosh', 'tanh', 'sqrt', 'ln', 'log', 'sec', 'csc',
36                     'cot', 'coth', 're', 'im', 'frac', 'root', 'arg',
37                     ]
38 
39 tex_greek_dictionary = {
40     'Alpha': 'A',
41     'Beta': 'B',
42     'Gamma': r'\Gamma',
43     'Delta': r'\Delta',
44     'Epsilon': 'E',
45     'Zeta': 'Z',
46     'Eta': 'H',
47     'Theta': r'\Theta',
48     'Iota': 'I',
49     'Kappa': 'K',
50     'Lambda': r'\Lambda',
51     'Mu': 'M',
52     'Nu': 'N',
53     'Xi': r'\Xi',
54     'omicron': 'o',
55     'Omicron': 'O',
56     'Pi': r'\Pi',
57     'Rho': 'P',
58     'Sigma': r'\Sigma',
59     'Tau': 'T',
60     'Upsilon': r'\Upsilon',
61     'Phi': r'\Phi',
62     'Chi': 'X',
63     'Psi': r'\Psi',
64     'Omega': r'\Omega',
65     'lamda': r'\lambda',
66     'Lamda': r'\Lambda',
67     'khi': r'\chi',
68     'Khi': r'X',
69     'varepsilon': r'\varepsilon',
70     'varkappa': r'\varkappa',
71     'varphi': r'\varphi',
72     'varpi': r'\varpi',
73     'varrho': r'\varrho',
74     'varsigma': r'\varsigma',
75     'vartheta': r'\vartheta',
76 }
77 
78 other_symbols = set(['aleph', 'beth', 'daleth', 'gimel', 'ell', 'eth', 'hbar',
79                      'hslash', 'mho', 'wp', ])
80 
81 # Variable name modifiers
82 modifier_dict = {
83     # Accents
84     'mathring': lambda s: r'\mathring{'+s+r'}',
85     'ddddot': lambda s: r'\ddddot{'+s+r'}',
86     'dddot': lambda s: r'\dddot{'+s+r'}',
87     'ddot': lambda s: r'\ddot{'+s+r'}',
88     'dot': lambda s: r'\dot{'+s+r'}',
89     'check': lambda s: r'\check{'+s+r'}',
90     'breve': lambda s: r'\breve{'+s+r'}',
91     'acute': lambda s: r'\acute{'+s+r'}',
92     'grave': lambda s: r'\grave{'+s+r'}',
93     'tilde': lambda s: r'\tilde{'+s+r'}',
94     'hat': lambda s: r'\hat{'+s+r'}',
95     'bar': lambda s: r'\bar{'+s+r'}',
96     'vec': lambda s: r'\vec{'+s+r'}',
97     'prime': lambda s: "{"+s+"}'",
98     'prm': lambda s: "{"+s+"}'",
99     # Faces
100     'bold': lambda s: r'\boldsymbol{'+s+r'}',
101     'bm': lambda s: r'\boldsymbol{'+s+r'}',
102     'cal': lambda s: r'\mathcal{'+s+r'}',
103     'scr': lambda s: r'\mathscr{'+s+r'}',
104     'frak': lambda s: r'\mathfrak{'+s+r'}',
105     # Brackets
106     'norm': lambda s: r'\left\|{'+s+r'}\right\|',
107     'avg': lambda s: r'\left\langle{'+s+r'}\right\rangle',
108     'abs': lambda s: r'\left|{'+s+r'}\right|',
109     'mag': lambda s: r'\left|{'+s+r'}\right|',
110 }
111 
112 greek_letters_set = frozenset(greeks)
113 
114 _between_two_numbers_p = (
115     re.compile(r'[0-9][} ]*$'),  # search
116     re.compile(r'[{ ]*[-+0-9]'),  # match
117 )
118 
119 
120 class LatexPrinter(Printer):
121     printmethod = "_latex"
122 
123     _default_settings = {
124         "fold_frac_powers": False,
125         "fold_func_brackets": False,
126         "fold_short_frac": None,
127         "inv_trig_style": "abbreviated",
128         "itex": False,
129         "ln_notation": False,
130         "long_frac_ratio": None,
131         "mat_delim": "[",
132         "mat_str": None,
133         "mode": "plain",
134         "mul_symbol": None,
135         "order": None,
136         "symbol_names": {},
137         "root_notation": True,
138         "mat_symbol_style": "plain",
139         "imaginary_unit": "i",
140     }
141 
142     def __init__(self, settings=None):
143         Printer.__init__(self, settings)
144 
145         if 'mode' in self._settings:
146             valid_modes = ['inline', 'plain', 'equation',
147                            'equation*']
148             if self._settings['mode'] not in valid_modes:
149                 raise ValueError("'mode' must be one of 'inline', 'plain', "
150                     "'equation' or 'equation*'")
151 
152         if self._settings['fold_short_frac'] is None and \
153                 self._settings['mode'] == 'inline':
154             self._settings['fold_short_frac'] = True
155 
156         mul_symbol_table = {
157             None: r" ",
158             "ldot": r" \,.\, ",
159             "dot": r" \cdot ",
160             "times": r" \times "
161         }
162         try:
163             self._settings['mul_symbol_latex'] = \
164                 mul_symbol_table[self._settings['mul_symbol']]
165         except KeyError:
166             self._settings['mul_symbol_latex'] = \
167                 self._settings['mul_symbol']
168         try:
169             self._settings['mul_symbol_latex_numbers'] = \
170                 mul_symbol_table[self._settings['mul_symbol'] or 'dot']
171         except KeyError:
172             if (self._settings['mul_symbol'].strip() in
173                     ['', ' ', '\\', '\\,', '\\:', '\\;', '\\quad']):
174                 self._settings['mul_symbol_latex_numbers'] = \
175                     mul_symbol_table['dot']
176             else:
177                 self._settings['mul_symbol_latex_numbers'] = \
178                     self._settings['mul_symbol']
179 
180         self._delim_dict = {'(': ')', '[': ']'}
181 
182         imaginary_unit_table = {
183             None: r"i",
184             "i": r"i",
185             "ri": r"\mathrm{i}",
186             "ti": r"\text{i}",
187             "j": r"j",
188             "rj": r"\mathrm{j}",
189             "tj": r"\text{j}",
190         }
191         try:
192             self._settings['imaginary_unit_latex'] = \
193                 imaginary_unit_table[self._settings['imaginary_unit']]
194         except KeyError:
195             self._settings['imaginary_unit_latex'] = \
196                 self._settings['imaginary_unit']
197 
198     def parenthesize(self, item, level, strict=False):
199         prec_val = precedence_traditional(item)
200         if (prec_val < level) or ((not strict) and prec_val <= level):
201             return r"\left(%s\right)" % self._print(item)
202         else:
203             return self._print(item)
204 
205     def doprint(self, expr):
206         tex = Printer.doprint(self, expr)
207 
208         if self._settings['mode'] == 'plain':
209             return tex
210         elif self._settings['mode'] == 'inline':
211             return r"$%s$" % tex
212         elif self._settings['itex']:
213             return r"$$%s$$" % tex
214         else:
215             env_str = self._settings['mode']
216             return r"\begin{%s}%s\end{%s}" % (env_str, tex, env_str)
217 
218     def _needs_brackets(self, expr):
219         """
220         Returns True if the expression needs to be wrapped in brackets when
221         printed, False otherwise. For example: a + b => True; a => False;
222         10 => False; -10 => True.
223         """
224         return not ((expr.is_Integer and expr.is_nonnegative)
225                     or (expr.is_Atom and (expr is not S.NegativeOne
226                                           and expr.is_Rational is False)))
227 
228     def _needs_function_brackets(self, expr):
229         """
230         Returns True if the expression needs to be wrapped in brackets when
231         passed as an argument to a function, False otherwise. This is a more
232         liberal version of _needs_brackets, in that many expressions which need
233         to be wrapped in brackets when added/subtracted/raised to a power do
234         not need them when passed to a function. Such an example is a*b.
235         """
236         if not self._needs_brackets(expr):
237             return False
238         else:
239             # Muls of the form a*b*c... can be folded
240             if expr.is_Mul and not self._mul_is_clean(expr):
241                 return True
242             # Pows which don't need brackets can be folded
243             elif expr.is_Pow and not self._pow_is_clean(expr):
244                 return True
245             # Add and Function always need brackets
246             elif expr.is_Add or expr.is_Function:
247                 return True
248             else:
249                 return False
250 
251     def _needs_mul_brackets(self, expr, first=False, last=False):
252         """
253         Returns True if the expression needs to be wrapped in brackets when
254         printed as part of a Mul, False otherwise. This is True for Add,
255         but also for some container objects that would not need brackets
256         when appearing last in a Mul, e.g. an Integral. ``last=True``
257         specifies that this expr is the last to appear in a Mul.
258         ``first=True`` specifies that this expr is the first to appear in a Mul.
259         """
260         from sympy import Integral, Product, Sum
261 
262         if expr.is_Mul:
263             if not first and _coeff_isneg(expr):
264                 return True
265         elif precedence_traditional(expr) < PRECEDENCE["Mul"]:
266             return True
267         elif expr.is_Relational:
268             return True
269         if expr.is_Piecewise:
270             return True
271         if any([expr.has(x) for x in (Mod,)]):
272             return True
273         if (not last and
274             any([expr.has(x) for x in (Integral, Product, Sum)])):
275             return True
276 
277         return False
278 
279 
280     def _needs_add_brackets(self, expr):
281         """
282         Returns True if the expression needs to be wrapped in brackets when
283         printed as part of an Add, False otherwise.  This is False for most
284         things.
285         """
286         if expr.is_Relational:
287             return True
288         if any([expr.has(x) for x in (Mod,)]):
289             return True
290         if expr.is_Add:
291             return True
292         return False
293 
294 
295     def _mul_is_clean(self, expr):
296         for arg in expr.args:
297             if arg.is_Function:
298                 return False
299         return True
300 
301     def _pow_is_clean(self, expr):
302         return not self._needs_brackets(expr.base)
303 
304     def _do_exponent(self, expr, exp):
305         if exp is not None:
306             return r"\left(%s\right)^{%s}" % (expr, exp)
307         else:
308             return expr
309 
310     def _print_Basic(self, expr):
311         l = [self._print(o) for o in expr.args]
312         return self._deal_with_super_sub(expr.__class__.__name__) + r"\left(%s\right)" % ", ".join(l)
313 
314     def _print_bool(self, e):
315         return r"\mathrm{%s}" % e
316 
317     _print_BooleanTrue = _print_bool
318     _print_BooleanFalse = _print_bool
319 
320     def _print_NoneType(self, e):
321         return r"\mathrm{%s}" % e
322 
323     def _print_Add(self, expr, order=None):
324         if self.order == 'none':
325             terms = list(expr.args)
326         else:
327             terms = self._as_ordered_terms(expr, order=order)
328 
329         tex = ""
330         for i, term in enumerate(terms):
331             if i == 0:
332                 pass
333             elif _coeff_isneg(term):
334                 tex += " - "
335                 term = -term
336             else:
337                 tex += " + "
338             term_tex = self._print(term)
339             if self._needs_add_brackets(term):
340                 term_tex = r"\left(%s\right)" % term_tex
341             tex += term_tex
342 
343         return tex
344 
345     def _print_Cycle(self, expr):
346         from sympy.combinatorics.permutations import Permutation
347         if expr.size == 0:
348             return r"\left( \right)"
349         expr = Permutation(expr)
350         expr_perm = expr.cyclic_form
351         siz = expr.size
352         if expr.array_form[-1] == siz - 1:
353             expr_perm = expr_perm + [[siz - 1]]
354         term_tex = ''
355         for i in expr_perm:
356             term_tex += str(i).replace(',', r"\;")
357         term_tex = term_tex.replace('[', r"\left( ")
358         term_tex = term_tex.replace(']', r"\right)")
359         return term_tex
360 
361     _print_Permutation = _print_Cycle
362 
363     def _print_Float(self, expr):
364         # Based off of that in StrPrinter
365         dps = prec_to_dps(expr._prec)
366         str_real = mlib.to_str(expr._mpf_, dps, strip_zeros=True)
367 
368         # Must always have a mul symbol (as 2.5 10^{20} just looks odd)
369         # thus we use the number separator
370         separator = self._settings['mul_symbol_latex_numbers']
371 
372         if 'e' in str_real:
373             (mant, exp) = str_real.split('e')
374 
375             if exp[0] == '+':
376                 exp = exp[1:]
377 
378             return r"%s%s10^{%s}" % (mant, separator, exp)
379         elif str_real == "+inf":
380             return r"\infty"
381         elif str_real == "-inf":
382             return r"- \infty"
383         else:
384             return str_real
385 
386     def _print_Cross(self, expr):
387         vec1 = expr._expr1
388         vec2 = expr._expr2
389         return r"%s \times %s" % (self.parenthesize(vec1, PRECEDENCE['Mul']),
390                                   self.parenthesize(vec2, PRECEDENCE['Mul']))
391 
392     def _print_Curl(self, expr):
393         vec = expr._expr
394         return r"\nabla\times %s" % self.parenthesize(vec, PRECEDENCE['Mul'])
395 
396     def _print_Divergence(self, expr):
397         vec = expr._expr
398         return r"\nabla\cdot %s" % self.parenthesize(vec, PRECEDENCE['Mul'])
399 
400     def _print_Dot(self, expr):
401         vec1 = expr._expr1
402         vec2 = expr._expr2
403         return r"%s \cdot %s" % (self.parenthesize(vec1, PRECEDENCE['Mul']),
404                                   self.parenthesize(vec2, PRECEDENCE['Mul']))
405 
406     def _print_Gradient(self, expr):
407         func = expr._expr
408         return r"\nabla\cdot %s" % self.parenthesize(func, PRECEDENCE['Mul'])
409 
410     def _print_Mul(self, expr):
411         from sympy.core.power import Pow
412         from sympy.physics.units import Quantity
413         include_parens = False
414         if _coeff_isneg(expr):
415             expr = -expr
416             tex = "- "
417             if expr.is_Add:
418                 tex += "("
419                 include_parens = True
420         else:
421             tex = ""
422 
423         from sympy.simplify import fraction
424         numer, denom = fraction(expr, exact=True)
425         separator = self._settings['mul_symbol_latex']
426         numbersep = self._settings['mul_symbol_latex_numbers']
427 
428         def convert(expr):
429             if not expr.is_Mul:
430                 return str(self._print(expr))
431             else:
432                 _tex = last_term_tex = ""
433 
434                 if self.order not in ('old', 'none'):
435                     args = expr.as_ordered_factors()
436                 else:
437                     args = list(expr.args)
438 
439                 # If quantities are present append them at the back
440                 args = sorted(args, key=lambda x: isinstance(x, Quantity) or
441                              (isinstance(x, Pow) and isinstance(x.base, Quantity)))
442 
443                 for i, term in enumerate(args):
444                     term_tex = self._print(term)
445 
446                     if self._needs_mul_brackets(term, first=(i == 0),
447                                                 last=(i == len(args) - 1)):
448                         term_tex = r"\left(%s\right)" % term_tex
449 
450                     if _between_two_numbers_p[0].search(last_term_tex) and \
451                             _between_two_numbers_p[1].match(term_tex):
452                         # between two numbers
453                         _tex += numbersep
454                     elif _tex:
455                         _tex += separator
456 
457                     _tex += term_tex
458                     last_term_tex = term_tex
459                 return _tex
460 
461         if denom is S.One and Pow(1, -1, evaluate=False) not in expr.args:
462             # use the original expression here, since fraction() may have
463             # altered it when producing numer and denom
464             tex += convert(expr)
465 
466         else:
467             snumer = convert(numer)
468             sdenom = convert(denom)
469             ldenom = len(sdenom.split())
470             ratio = self._settings['long_frac_ratio']
471             if self._settings['fold_short_frac'] \
472                    and ldenom <= 2 and not "^" in sdenom:
473                 # handle short fractions
474                 if self._needs_mul_brackets(numer, last=False):
475                     tex += r"\left(%s\right) / %s" % (snumer, sdenom)
476                 else:
477                     tex += r"%s / %s" % (snumer, sdenom)
478             elif ratio is not None and \
479                     len(snumer.split()) > ratio*ldenom:
480                 # handle long fractions
481                 if self._needs_mul_brackets(numer, last=True):
482                     tex += r"\frac{1}{%s}%s\left(%s\right)" \
483                         % (sdenom, separator, snumer)
484                 elif numer.is_Mul:
485                     # split a long numerator
486                     a = S.One
487                     b = S.One
488                     for x in numer.args:
489                         if self._needs_mul_brackets(x, last=False) or \
490                                 len(convert(a*x).split()) > ratio*ldenom or \
491                                 (b.is_commutative is x.is_commutative is False):
492                             b *= x
493                         else:
494                             a *= x
495                     if self._needs_mul_brackets(b, last=True):
496                         tex += r"\frac{%s}{%s}%s\left(%s\right)" \
497                             % (convert(a), sdenom, separator, convert(b))
498                     else:
499                         tex += r"\frac{%s}{%s}%s%s" \
500                             % (convert(a), sdenom, separator, convert(b))
501                 else:
502                     tex += r"\frac{1}{%s}%s%s" % (sdenom, separator, snumer)
503             else:
504                 tex += r"\frac{%s}{%s}" % (snumer, sdenom)
505 
506         if include_parens:
507             tex += ")"
508         return tex
509 
510     def _print_Pow(self, expr):
511         # Treat x**Rational(1,n) as special case
512         if expr.exp.is_Rational and abs(expr.exp.p) == 1 and expr.exp.q != 1 and self._settings['root_notation']:
513             base = self._print(expr.base)
514             expq = expr.exp.q
515 
516             if expq == 2:
517                 tex = r"\sqrt{%s}" % base
518             elif self._settings['itex']:
519                 tex = r"\root{%d}{%s}" % (expq, base)
520             else:
521                 tex = r"\sqrt[%d]{%s}" % (expq, base)
522 
523             if expr.exp.is_negative:
524                 return r"\frac{1}{%s}" % tex
525             else:
526                 return tex
527         elif self._settings['fold_frac_powers'] \
528             and expr.exp.is_Rational \
529                 and expr.exp.q != 1:
530             base, p, q = self.parenthesize(expr.base, PRECEDENCE['Pow']), expr.exp.p, expr.exp.q
531             # issue #12886: add parentheses for superscripts raised to powers
532             if '^' in base and expr.base.is_Symbol:
533                 base = r"\left(%s\right)" % base
534             if expr.base.is_Function:
535                 return self._print(expr.base, exp="%s/%s" % (p, q))
536             return r"%s^{%s/%s}" % (base, p, q)
537         elif expr.exp.is_Rational and expr.exp.is_negative and expr.base.is_commutative:
538             # special case for 1^(-x), issue 9216
539             if expr.base == 1:
540                 return r"%s^{%s}" % (expr.base, expr.exp)
541             # things like 1/x
542             return self._print_Mul(expr)
543         else:
544             if expr.base.is_Function:
545                 return self._print(expr.base, exp=self._print(expr.exp))
546             else:
547                 tex = r"%s^{%s}"
548                 exp = self._print(expr.exp)
549                 # issue #12886: add parentheses around superscripts raised to powers
550                 base = self.parenthesize(expr.base, PRECEDENCE['Pow'])
551                 if '^' in base and expr.base.is_Symbol:
552                     base = r"\left(%s\right)" % base
553                 elif isinstance(expr.base, Derivative
554                         ) and base.startswith(r'\left('
555                         ) and re.match(r'\\left\(\\d?d?dot', base
556                         ) and base.endswith(r'\right)'):
557                     # don't use parentheses around dotted derivative
558                     base = base[6: -7]  # remove outermost added parens
559 
560                 return tex % (base, exp)
561 
562     def _print_UnevaluatedExpr(self, expr):
563         return self._print(expr.args[0])
564 
565     def _print_Sum(self, expr):
566         if len(expr.limits) == 1:
567             tex = r"\sum_{%s=%s}^{%s} " % \
568                 tuple([ self._print(i) for i in expr.limits[0] ])
569         else:
570             def _format_ineq(l):
571                 return r"%s \leq %s \leq %s" % \
572                     tuple([self._print(s) for s in (l[1], l[0], l[2])])
573 
574             tex = r"\sum_{\substack{%s}} " % \
575                 str.join('\\\\', [ _format_ineq(l) for l in expr.limits ])
576 
577         if isinstance(expr.function, Add):
578             tex += r"\left(%s\right)" % self._print(expr.function)
579         else:
580             tex += self._print(expr.function)
581 
582         return tex
583 
584     def _print_Product(self, expr):
585         if len(expr.limits) == 1:
586             tex = r"\prod_{%s=%s}^{%s} " % \
587                 tuple([ self._print(i) for i in expr.limits[0] ])
588         else:
589             def _format_ineq(l):
590                 return r"%s \leq %s \leq %s" % \
591                     tuple([self._print(s) for s in (l[1], l[0], l[2])])
592 
593             tex = r"\prod_{\substack{%s}} " % \
594                 str.join('\\\\', [ _format_ineq(l) for l in expr.limits ])
595 
596         if isinstance(expr.function, Add):
597             tex += r"\left(%s\right)" % self._print(expr.function)
598         else:
599             tex += self._print(expr.function)
600 
601         return tex
602 
603     def _print_BasisDependent(self, expr):
604         from sympy.vector import Vector
605 
606         o1 = []
607         if expr == expr.zero:
608             return expr.zero._latex_form
609         if isinstance(expr, Vector):
610             items = expr.separate().items()
611         else:
612             items = [(0, expr)]
613 
614         for system, vect in items:
615             inneritems = list(vect.components.items())
616             inneritems.sort(key = lambda x:x[0].__str__())
617             for k, v in inneritems:
618                 if v == 1:
619                     o1.append(' + ' + k._latex_form)
620                 elif v == -1:
621                     o1.append(' - ' + k._latex_form)
622                 else:
623                     arg_str = '(' + LatexPrinter().doprint(v) + ')'
624                     o1.append(' + ' + arg_str + k._latex_form)
625 
626         outstr = (''.join(o1))
627         if outstr[1] != '-':
628             outstr = outstr[3:]
629         else:
630             outstr = outstr[1:]
631         return outstr
632 
633     def _print_Indexed(self, expr):
634         tex_base = self._print(expr.base)
635         tex = '{'+tex_base+'}'+'_{%s}' % ','.join(
636             map(self._print, expr.indices))
637         return tex
638 
639     def _print_IndexedBase(self, expr):
640         return self._print(expr.label)
641 
642     def _print_Derivative(self, expr):
643         if requires_partial(expr):
644             diff_symbol = r'\partial'
645         else:
646             diff_symbol = r'd'
647 
648         tex = ""
649         dim = 0
650         for x, num in reversed(expr.variable_count):
651             dim += num
652             if num == 1:
653                 tex += r"%s %s" % (diff_symbol, self._print(x))
654             else:
655                 tex += r"%s %s^{%s}" % (diff_symbol, self._print(x), num)
656 
657         if dim == 1:
658             tex = r"\frac{%s}{%s}" % (diff_symbol, tex)
659         else:
660             tex = r"\frac{%s^{%s}}{%s}" % (diff_symbol, dim, tex)
661 
662         return r"%s %s" % (tex, self.parenthesize(expr.expr, PRECEDENCE["Mul"], strict=True))
663 
664     def _print_Subs(self, subs):
665         expr, old, new = subs.args
666         latex_expr = self._print(expr)
667         latex_old = (self._print(e) for e in old)
668         latex_new = (self._print(e) for e in new)
669         latex_subs = r'\\ '.join(
670             e[0] + '=' + e[1] for e in zip(latex_old, latex_new))
671         return r'\left. %s \right|_{\substack{ %s }}' % (latex_expr, latex_subs)
672 
673     def _print_Integral(self, expr):
674         tex, symbols = "", []
675 
676         # Only up to \iiiint exists
677         if len(expr.limits) <= 4 and all(len(lim) == 1 for lim in expr.limits):
678             # Use len(expr.limits)-1 so that syntax highlighters don't think
679             # \" is an escaped quote
680             tex = r"\i" + "i"*(len(expr.limits) - 1) + "nt"
681             symbols = [r"\, d%s" % self._print(symbol[0])
682                        for symbol in expr.limits]
683 
684         else:
685             for lim in reversed(expr.limits):
686                 symbol = lim[0]
687                 tex += r"\int"
688 
689                 if len(lim) > 1:
690                     if self._settings['mode'] != 'inline' \
691                             and not self._settings['itex']:
692                         tex += r"\limits"
693 
694                     if len(lim) == 3:
695                         tex += "_{%s}^{%s}" % (self._print(lim[1]),
696                                                self._print(lim[2]))
697                     if len(lim) == 2:
698                         tex += "^{%s}" % (self._print(lim[1]))
699 
700                 symbols.insert(0, r"\, d%s" % self._print(symbol))
701 
702         return r"%s %s%s" % (tex,
703             self.parenthesize(expr.function, PRECEDENCE["Mul"], strict=True), "".join(symbols))
704 
705     def _print_Limit(self, expr):
706         e, z, z0, dir = expr.args
707 
708         tex = r"\lim_{%s \to " % self._print(z)
709         if str(dir) == '+-' or z0 in (S.Infinity, S.NegativeInfinity):
710             tex += r"%s}" % self._print(z0)
711         else:
712             tex += r"%s^%s}" % (self._print(z0), self._print(dir))
713 
714         if isinstance(e, AssocOp):
715             return r"%s\left(%s\right)" % (tex, self._print(e))
716         else:
717             return r"%s %s" % (tex, self._print(e))
718 
719     def _hprint_Function(self, func):
720         r'''
721         Logic to decide how to render a function to latex
722           - if it is a recognized latex name, use the appropriate latex command
723           - if it is a single letter, just use that letter
724           - if it is a longer name, then put \operatorname{} around it and be
725             mindful of undercores in the name
726         '''
727         func = self._deal_with_super_sub(func)
728         if func in accepted_latex_functions:
729             name = r"\%s" % func
730         elif len(func) == 1 or func.startswith('\\'):
731             name = func
732         else:
733             name = r"\operatorname{%s}" % func
734         return name
735 
736     def _print_Function(self, expr, exp=None):
737         r'''
738         Render functions to LaTeX, handling functions that LaTeX knows about
739         e.g., sin, cos, ... by using the proper LaTeX command (\sin, \cos, ...).
740         For single-letter function names, render them as regular LaTeX math
741         symbols. For multi-letter function names that LaTeX does not know
742         about, (e.g., Li, sech) use \operatorname{} so that the function name
743         is rendered in Roman font and LaTeX handles spacing properly.
744 
745         expr is the expression involving the function
746         exp is an exponent
747         '''
748         func = expr.func.__name__
749         if hasattr(self, '_print_' + func) and \
750             not isinstance(expr, AppliedUndef):
751             return getattr(self, '_print_' + func)(expr, exp)
752         else:
753             args = [ str(self._print(arg)) for arg in expr.args ]
754             # How inverse trig functions should be displayed, formats are:
755             # abbreviated: asin, full: arcsin, power: sin^-1
756             inv_trig_style = self._settings['inv_trig_style']
757             # If we are dealing with a power-style inverse trig function
758             inv_trig_power_case = False
759             # If it is applicable to fold the argument brackets
760             can_fold_brackets = self._settings['fold_func_brackets'] and \
761                 len(args) == 1 and \
762                 not self._needs_function_brackets(expr.args[0])
763 
764             inv_trig_table = ["asin", "acos", "atan", "acsc", "asec", "acot"]
765 
766             # If the function is an inverse trig function, handle the style
767             if func in inv_trig_table:
768                 if inv_trig_style == "abbreviated":
769                     pass
770                 elif inv_trig_style == "full":
771                     func = "arc" + func[1:]
772                 elif inv_trig_style == "power":
773                     func = func[1:]
774                     inv_trig_power_case = True
775 
776                     # Can never fold brackets if we're raised to a power
777                     if exp is not None:
778                         can_fold_brackets = False
779 
780             if inv_trig_power_case:
781                 if func in accepted_latex_functions:
782                     name = r"\%s^{-1}" % func
783                 else:
784                     name = r"\operatorname{%s}^{-1}" % func
785             elif exp is not None:
786                 name = r'%s^{%s}' % (self._hprint_Function(func), exp)
787             else:
788                 name = self._hprint_Function(func)
789 
790             if can_fold_brackets:
791                 if func in accepted_latex_functions:
792                     # Wrap argument safely to avoid parse-time conflicts
793                     # with the function name itself
794                     name += r" {%s}"
795                 else:
796                     name += r"%s"
797             else:
798                 name += r"{\left(%s \right)}"
799 
800             if inv_trig_power_case and exp is not None:
801                 name += r"^{%s}" % exp
802 
803             return name % ",".join(args)
804 
805     def _print_UndefinedFunction(self, expr):
806         return self._hprint_Function(str(expr))
807 
808     @property
809     def _special_function_classes(self):
810         from sympy.functions.special.tensor_functions import KroneckerDelta
811         from sympy.functions.special.gamma_functions import gamma, lowergamma
812         from sympy.functions.special.beta_functions import beta
813         from sympy.functions.special.delta_functions import DiracDelta
814         from sympy.functions.special.error_functions import Chi
815         return {KroneckerDelta: r'\delta',
816                 gamma:  r'\Gamma',
817                 lowergamma: r'\gamma',
818                 beta: r'\operatorname{B}',
819                 DiracDelta: r'\delta',
820                 Chi: r'\operatorname{Chi}'}
821 
822     def _print_FunctionClass(self, expr):
823         for cls in self._special_function_classes:
824             if issubclass(expr, cls) and expr.__name__ == cls.__name__:
825                 return self._special_function_classes[cls]
826         return self._hprint_Function(str(expr))
827 
828     def _print_Lambda(self, expr):
829         symbols, expr = expr.args
830 
831         if len(symbols) == 1:
832             symbols = self._print(symbols[0])
833         else:
834             symbols = self._print(tuple(symbols))
835 
836         tex = r"\left( %s \mapsto %s \right)" % (symbols, self._print(expr))
837 
838         return tex
839 
840     def _hprint_variadic_function(self, expr, exp=None):
841         args = sorted(expr.args, key=default_sort_key)
842         texargs = [r"%s" % self._print(symbol) for symbol in args]
843         tex = r"\%s\left(%s\right)" % (self._print((str(expr.func)).lower()), ", ".join(texargs))
844         if exp is not None:
845             return r"%s^{%s}" % (tex, exp)
846         else:
847             return tex
848 
849     _print_Min = _print_Max = _hprint_variadic_function
850 
851     def _print_floor(self, expr, exp=None):
852         tex = r"\left\lfloor{%s}\right\rfloor" % self._print(expr.args[0])
853 
854         if exp is not None:
855             return r"%s^{%s}" % (tex, exp)
856         else:
857             return tex
858 
859     def _print_ceiling(self, expr, exp=None):
860         tex = r"\left\lceil{%s}\right\rceil" % self._print(expr.args[0])
861 
862         if exp is not None:
863             return r"%s^{%s}" % (tex, exp)
864         else:
865             return tex
866 
867     def _print_log(self, expr, exp=None):
868         if not self._settings["ln_notation"]:
869             tex = r"\log{\left(%s \right)}" % self._print(expr.args[0])
870         else:
871             tex = r"\ln{\left(%s \right)}" % self._print(expr.args[0])
872 
873         if exp is not None:
874             return r"%s^{%s}" % (tex, exp)
875         else:
876             return tex
877 
878     def _print_Abs(self, expr, exp=None):
879         tex = r"\left|{%s}\right|" % self._print(expr.args[0])
880 
881         if exp is not None:
882             return r"%s^{%s}" % (tex, exp)
883         else:
884             return tex
885     _print_Determinant = _print_Abs
886 
887     def _print_re(self, expr, exp=None):
888         tex = r"\Re{%s}" % self.parenthesize(expr.args[0], PRECEDENCE['Atom'])
889 
890         return self._do_exponent(tex, exp)
891 
892     def _print_im(self, expr, exp=None):
893         tex = r"\Im{%s}" % self.parenthesize(expr.args[0], PRECEDENCE['Func'])
894 
895         return self._do_exponent(tex, exp)
896 
897     def _print_Not(self, e):
898         from sympy import Equivalent, Implies
899         if isinstance(e.args[0], Equivalent):
900             return self._print_Equivalent(e.args[0], r"\not\Leftrightarrow")
901         if isinstance(e.args[0], Implies):
902             return self._print_Implies(e.args[0], r"\not\Rightarrow")
903         if (e.args[0].is_Boolean):
904             return r"\neg (%s)" % self._print(e.args[0])
905         else:
906             return r"\neg %s" % self._print(e.args[0])
907 
908     def _print_LogOp(self, args, char):
909         arg = args[0]
910         if arg.is_Boolean and not arg.is_Not:
911             tex = r"\left(%s\right)" % self._print(arg)
912         else:
913             tex = r"%s" % self._print(arg)
914 
915         for arg in args[1:]:
916             if arg.is_Boolean and not arg.is_Not:
917                 tex += r" %s \left(%s\right)" % (char, self._print(arg))
918             else:
919                 tex += r" %s %s" % (char, self._print(arg))
920 
921         return tex
922 
923     def _print_And(self, e):
924         args = sorted(e.args, key=default_sort_key)
925         return self._print_LogOp(args, r"\wedge")
926 
927     def _print_Or(self, e):
928         args = sorted(e.args, key=default_sort_key)
929         return self._print_LogOp(args, r"\vee")
930 
931     def _print_Xor(self, e):
932         args = sorted(e.args, key=default_sort_key)
933         return self._print_LogOp(args, r"\veebar")
934 
935     def _print_Implies(self, e, altchar=None):
936         return self._print_LogOp(e.args, altchar or r"\Rightarrow")
937 
938     def _print_Equivalent(self, e, altchar=None):
939         args = sorted(e.args, key=default_sort_key)
940         return self._print_LogOp(args, altchar or r"\Leftrightarrow")
941 
942     def _print_conjugate(self, expr, exp=None):
943         tex = r"\overline{%s}" % self._print(expr.args[0])
944 
945         if exp is not None:
946             return r"%s^{%s}" % (tex, exp)
947         else:
948             return tex
949 
950     def _print_polar_lift(self, expr, exp=None):
951         func = r"\operatorname{polar\_lift}"
952         arg = r"{\left(%s \right)}" % self._print(expr.args[0])
953 
954         if exp is not None:
955             return r"%s^{%s}%s" % (func, exp, arg)
956         else:
957             return r"%s%s" % (func, arg)
958 
959     def _print_ExpBase(self, expr, exp=None):
960         # TODO should exp_polar be printed differently?
961         #      what about exp_polar(0), exp_polar(1)?
962         tex = r"e^{%s}" % self._print(expr.args[0])
963         return self._do_exponent(tex, exp)
964 
965     def _print_elliptic_k(self, expr, exp=None):
966         tex = r"\left(%s\right)" % self._print(expr.args[0])
967         if exp is not None:
968             return r"K^{%s}%s" % (exp, tex)
969         else:
970             return r"K%s" % tex
971 
972     def _print_elliptic_f(self, expr, exp=None):
973         tex = r"\left(%s\middle| %s\right)" % \
974             (self._print(expr.args[0]), self._print(expr.args[1]))
975         if exp is not None:
976             return r"F^{%s}%s" % (exp, tex)
977         else:
978             return r"F%s" % tex
979 
980     def _print_elliptic_e(self, expr, exp=None):
981         if len(expr.args) == 2:
982             tex = r"\left(%s\middle| %s\right)" % \
983                 (self._print(expr.args[0]), self._print(expr.args[1]))
984         else:
985             tex = r"\left(%s\right)" % self._print(expr.args[0])
986         if exp is not None:
987             return r"E^{%s}%s" % (exp, tex)
988         else:
989             return r"E%s" % tex
990 
991     def _print_elliptic_pi(self, expr, exp=None):
992         if len(expr.args) == 3:
993             tex = r"\left(%s; %s\middle| %s\right)" % \
994                 (self._print(expr.args[0]), self._print(expr.args[1]), \
995                  self._print(expr.args[2]))
996         else:
997             tex = r"\left(%s\middle| %s\right)" % \
998                 (self._print(expr.args[0]), self._print(expr.args[1]))
999         if exp is not None:
1000             return r"\Pi^{%s}%s" % (exp, tex)
1001         else:
1002             return r"\Pi%s" % tex
1003 
1004     def _print_beta(self, expr, exp=None):
1005         tex = r"\left(%s, %s\right)" % (self._print(expr.args[0]),
1006                                         self._print(expr.args[1]))
1007 
1008         if exp is not None:
1009             return r"\operatorname{B}^{%s}%s" % (exp, tex)
1010         else:
1011             return r"\operatorname{B}%s" % tex
1012 
1013     def _print_uppergamma(self, expr, exp=None):
1014         tex = r"\left(%s, %s\right)" % (self._print(expr.args[0]),
1015                                         self._print(expr.args[1]))
1016 
1017         if exp is not None:
1018             return r"\Gamma^{%s}%s" % (exp, tex)
1019         else:
1020             return r"\Gamma%s" % tex
1021 
1022     def _print_lowergamma(self, expr, exp=None):
1023         tex = r"\left(%s, %s\right)" % (self._print(expr.args[0]),
1024                                         self._print(expr.args[1]))
1025 
1026         if exp is not None:
1027             return r"\gamma^{%s}%s" % (exp, tex)
1028         else:
1029             return r"\gamma%s" % tex
1030 
1031     def _hprint_one_arg_func(self, expr, exp=None):
1032         tex = r"\left(%s\right)" % self._print(expr.args[0])
1033 
1034         if exp is not None:
1035             return r"%s^{%s}%s" % (self._print(expr.func), exp, tex)
1036         else:
1037             return r"%s%s" % (self._print(expr.func), tex)
1038 
1039     _print_gamma = _hprint_one_arg_func
1040 
1041     def _print_Chi(self, expr, exp=None):
1042         tex = r"\left(%s\right)" % self._print(expr.args[0])
1043 
1044         if exp is not None:
1045             return r"\operatorname{Chi}^{%s}%s" % (exp, tex)
1046         else:
1047             return r"\operatorname{Chi}%s" % tex
1048 
1049     def _print_expint(self, expr, exp=None):
1050         tex = r"\left(%s\right)" % self._print(expr.args[1])
1051         nu = self._print(expr.args[0])
1052 
1053         if exp is not None:
1054             return r"\operatorname{E}_{%s}^{%s}%s" % (nu, exp, tex)
1055         else:
1056             return r"\operatorname{E}_{%s}%s" % (nu, tex)
1057 
1058     def _print_fresnels(self, expr, exp=None):
1059         tex = r"\left(%s\right)" % self._print(expr.args[0])
1060 
1061         if exp is not None:
1062             return r"S^{%s}%s" % (exp, tex)
1063         else:
1064             return r"S%s" % tex
1065 
1066     def _print_fresnelc(self, expr, exp=None):
1067         tex = r"\left(%s\right)" % self._print(expr.args[0])
1068 
1069         if exp is not None:
1070             return r"C^{%s}%s" % (exp, tex)
1071         else:
1072             return r"C%s" % tex
1073 
1074     def _print_subfactorial(self, expr, exp=None):
1075         tex = r"!%s" % self.parenthesize(expr.args[0], PRECEDENCE["Func"])
1076 
1077         if exp is not None:
1078             return r"\left(%s\right)^{%s}" % (tex, exp)
1079         else:
1080             return tex
1081 
1082     def _print_factorial(self, expr, exp=None):
1083         tex = r"%s!" % self.parenthesize(expr.args[0], PRECEDENCE["Func"])
1084 
1085         if exp is not None:
1086             return r"%s^{%s}" % (tex, exp)
1087         else:
1088             return tex
1089 
1090     def _print_factorial2(self, expr, exp=None):
1091         tex = r"%s!!" % self.parenthesize(expr.args[0], PRECEDENCE["Func"])
1092 
1093         if exp is not None:
1094             return r"%s^{%s}" % (tex, exp)
1095         else:
1096             return tex
1097 
1098     def _print_binomial(self, expr, exp=None):
1099         tex = r"{\binom{%s}{%s}}" % (self._print(expr.args[0]),
1100                                      self._print(expr.args[1]))
1101 
1102         if exp is not None:
1103             return r"%s^{%s}" % (tex, exp)
1104         else:
1105             return tex
1106 
1107     def _print_RisingFactorial(self, expr, exp=None):
1108         n, k = expr.args
1109         base = r"%s" % self.parenthesize(n, PRECEDENCE['Func'])
1110 
1111         tex = r"{%s}^{\left(%s\right)}" % (base, self._print(k))
1112 
1113         return self._do_exponent(tex, exp)
1114 
1115     def _print_FallingFactorial(self, expr, exp=None):
1116         n, k = expr.args
1117         sub = r"%s" % self.parenthesize(k, PRECEDENCE['Func'])
1118 
1119         tex = r"{\left(%s\right)}_{%s}" % (self._print(n), sub)
1120 
1121         return self._do_exponent(tex, exp)
1122 
1123     def _hprint_BesselBase(self, expr, exp, sym):
1124         tex = r"%s" % (sym)
1125 
1126         need_exp = False
1127         if exp is not None:
1128             if tex.find('^') == -1:
1129                 tex = r"%s^{%s}" % (tex, self._print(exp))
1130             else:
1131                 need_exp = True
1132 
1133         tex = r"%s_{%s}\left(%s\right)" % (tex, self._print(expr.order),
1134                                            self._print(expr.argument))
1135 
1136         if need_exp:
1137             tex = self._do_exponent(tex, exp)
1138         return tex
1139 
1140     def _hprint_vec(self, vec):
1141         if not vec:
1142             return ""
1143         s = ""
1144         for i in vec[:-1]:
1145             s += "%s, " % self._print(i)
1146         s += self._print(vec[-1])
1147         return s
1148 
1149     def _print_besselj(self, expr, exp=None):
1150         return self._hprint_BesselBase(expr, exp, 'J')
1151 
1152     def _print_besseli(self, expr, exp=None):
1153         return self._hprint_BesselBase(expr, exp, 'I')
1154 
1155     def _print_besselk(self, expr, exp=None):
1156         return self._hprint_BesselBase(expr, exp, 'K')
1157 
1158     def _print_bessely(self, expr, exp=None):
1159         return self._hprint_BesselBase(expr, exp, 'Y')
1160 
1161     def _print_yn(self, expr, exp=None):
1162         return self._hprint_BesselBase(expr, exp, 'y')
1163 
1164     def _print_jn(self, expr, exp=None):
1165         return self._hprint_BesselBase(expr, exp, 'j')
1166 
1167     def _print_hankel1(self, expr, exp=None):
1168         return self._hprint_BesselBase(expr, exp, 'H^{(1)}')
1169 
1170     def _print_hankel2(self, expr, exp=None):
1171         return self._hprint_BesselBase(expr, exp, 'H^{(2)}')
1172 
1173     def _print_hn1(self, expr, exp=None):
1174         return self._hprint_BesselBase(expr, exp, 'h^{(1)}')
1175 
1176     def _print_hn2(self, expr, exp=None):
1177         return self._hprint_BesselBase(expr, exp, 'h^{(2)}')
1178 
1179     def _hprint_airy(self, expr, exp=None, notation=""):
1180         tex = r"\left(%s\right)" % self._print(expr.args[0])
1181 
1182         if exp is not None:
1183             return r"%s^{%s}%s" % (notation, exp, tex)
1184         else:
1185             return r"%s%s" % (notation, tex)
1186 
1187     def _hprint_airy_prime(self, expr, exp=None, notation=""):
1188         tex = r"\left(%s\right)" % self._print(expr.args[0])
1189 
1190         if exp is not None:
1191             return r"{%s^\prime}^{%s}%s" % (notation, exp, tex)
1192         else:
1193             return r"%s^\prime%s" % (notation, tex)
1194 
1195     def _print_airyai(self, expr, exp=None):
1196         return self._hprint_airy(expr, exp, 'Ai')
1197 
1198     def _print_airybi(self, expr, exp=None):
1199         return self._hprint_airy(expr, exp, 'Bi')
1200 
1201     def _print_airyaiprime(self, expr, exp=None):
1202         return self._hprint_airy_prime(expr, exp, 'Ai')
1203 
1204     def _print_airybiprime(self, expr, exp=None):
1205         return self._hprint_airy_prime(expr, exp, 'Bi')
1206 
1207     def _print_hyper(self, expr, exp=None):
1208         tex = r"{{}_{%s}F_{%s}\left(\begin{matrix} %s \\ %s \end{matrix}" \
1209               r"\middle| {%s} \right)}" % \
1210             (self._print(len(expr.ap)), self._print(len(expr.bq)),
1211               self._hprint_vec(expr.ap), self._hprint_vec(expr.bq),
1212               self._print(expr.argument))
1213 
1214         if exp is not None:
1215             tex = r"{%s}^{%s}" % (tex, self._print(exp))
1216         return tex
1217 
1218     def _print_meijerg(self, expr, exp=None):
1219         tex = r"{G_{%s, %s}^{%s, %s}\left(\begin{matrix} %s & %s \\" \
1220               r"%s & %s \end{matrix} \middle| {%s} \right)}" % \
1221             (self._print(len(expr.ap)), self._print(len(expr.bq)),
1222               self._print(len(expr.bm)), self._print(len(expr.an)),
1223               self._hprint_vec(expr.an), self._hprint_vec(expr.aother),
1224               self._hprint_vec(expr.bm), self._hprint_vec(expr.bother),
1225               self._print(expr.argument))
1226 
1227         if exp is not None:
1228             tex = r"{%s}^{%s}" % (tex, self._print(exp))
1229         return tex
1230 
1231     def _print_dirichlet_eta(self, expr, exp=None):
1232         tex = r"\left(%s\right)" % self._print(expr.args[0])
1233         if exp is not None:
1234             return r"\eta^{%s}%s" % (self._print(exp), tex)
1235         return r"\eta%s" % tex
1236 
1237     def _print_zeta(self, expr, exp=None):
1238         if len(expr.args) == 2:
1239             tex = r"\left(%s, %s\right)" % tuple(map(self._print, expr.args))
1240         else:
1241             tex = r"\left(%s\right)" % self._print(expr.args[0])
1242         if exp is not None:
1243             return r"\zeta^{%s}%s" % (self._print(exp), tex)
1244         return r"\zeta%s" % tex
1245 
1246     def _print_lerchphi(self, expr, exp=None):
1247         tex = r"\left(%s, %s, %s\right)" % tuple(map(self._print, expr.args))
1248         if exp is None:
1249             return r"\Phi%s" % tex
1250         return r"\Phi^{%s}%s" % (self._print(exp), tex)
1251 
1252     def _print_polylog(self, expr, exp=None):
1253         s, z = map(self._print, expr.args)
1254         tex = r"\left(%s\right)" % z
1255         if exp is None:
1256             return r"\operatorname{Li}_{%s}%s" % (s, tex)
1257         return r"\operatorname{Li}_{%s}^{%s}%s" % (s, self._print(exp), tex)
1258 
1259     def _print_jacobi(self, expr, exp=None):
1260         n, a, b, x = map(self._print, expr.args)
1261         tex = r"P_{%s}^{\left(%s,%s\right)}\left(%s\right)" % (n, a, b, x)
1262         if exp is not None:
1263             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1264         return tex
1265 
1266     def _print_gegenbauer(self, expr, exp=None):
1267         n, a, x = map(self._print, expr.args)
1268         tex = r"C_{%s}^{\left(%s\right)}\left(%s\right)" % (n, a, x)
1269         if exp is not None:
1270             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1271         return tex
1272 
1273     def _print_chebyshevt(self, expr, exp=None):
1274         n, x = map(self._print, expr.args)
1275         tex = r"T_{%s}\left(%s\right)" % (n, x)
1276         if exp is not None:
1277             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1278         return tex
1279 
1280     def _print_chebyshevu(self, expr, exp=None):
1281         n, x = map(self._print, expr.args)
1282         tex = r"U_{%s}\left(%s\right)" % (n, x)
1283         if exp is not None:
1284             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1285         return tex
1286 
1287     def _print_legendre(self, expr, exp=None):
1288         n, x = map(self._print, expr.args)
1289         tex = r"P_{%s}\left(%s\right)" % (n, x)
1290         if exp is not None:
1291             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1292         return tex
1293 
1294     def _print_assoc_legendre(self, expr, exp=None):
1295         n, a, x = map(self._print, expr.args)
1296         tex = r"P_{%s}^{\left(%s\right)}\left(%s\right)" % (n, a, x)
1297         if exp is not None:
1298             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1299         return tex
1300 
1301     def _print_hermite(self, expr, exp=None):
1302         n, x = map(self._print, expr.args)
1303         tex = r"H_{%s}\left(%s\right)" % (n, x)
1304         if exp is not None:
1305             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1306         return tex
1307 
1308     def _print_laguerre(self, expr, exp=None):
1309         n, x = map(self._print, expr.args)
1310         tex = r"L_{%s}\left(%s\right)" % (n, x)
1311         if exp is not None:
1312             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1313         return tex
1314 
1315     def _print_assoc_laguerre(self, expr, exp=None):
1316         n, a, x = map(self._print, expr.args)
1317         tex = r"L_{%s}^{\left(%s\right)}\left(%s\right)" % (n, a, x)
1318         if exp is not None:
1319             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1320         return tex
1321 
1322     def _print_Ynm(self, expr, exp=None):
1323         n, m, theta, phi = map(self._print, expr.args)
1324         tex = r"Y_{%s}^{%s}\left(%s,%s\right)" % (n, m, theta, phi)
1325         if exp is not None:
1326             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1327         return tex
1328 
1329     def _print_Znm(self, expr, exp=None):
1330         n, m, theta, phi = map(self._print, expr.args)
1331         tex = r"Z_{%s}^{%s}\left(%s,%s\right)" % (n, m, theta, phi)
1332         if exp is not None:
1333             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1334         return tex
1335 
1336     def _print_Rational(self, expr):
1337         if expr.q != 1:
1338             sign = ""
1339             p = expr.p
1340             if expr.p < 0:
1341                 sign = "- "
1342                 p = -p
1343             if self._settings['fold_short_frac']:
1344                 return r"%s%d / %d" % (sign, p, expr.q)
1345             return r"%s\frac{%d}{%d}" % (sign, p, expr.q)
1346         else:
1347             return self._print(expr.p)
1348 
1349     def _print_Order(self, expr):
1350         s = self._print(expr.expr)
1351         if expr.point and any(p != S.Zero for p in expr.point) or \
1352            len(expr.variables) > 1:
1353             s += '; '
1354             if len(expr.variables) > 1:
1355                 s += self._print(expr.variables)
1356             elif expr.variables:
1357                 s += self._print(expr.variables[0])
1358             s += r'\rightarrow '
1359             if len(expr.point) > 1:
1360                 s += self._print(expr.point)
1361             else:
1362                 s += self._print(expr.point[0])
1363         return r"O\left(%s\right)" % s
1364 
1365     def _print_Symbol(self, expr, style='plain'):
1366         if expr in self._settings['symbol_names']:
1367             return self._settings['symbol_names'][expr]
1368 
1369         result = self._deal_with_super_sub(expr.name) if \
1370             '\\' not in expr.name else expr.name
1371 
1372         if style == 'bold':
1373             result = r"\mathbf{{{}}}".format(result)
1374 
1375         return result
1376 
1377     _print_RandomSymbol = _print_Symbol
1378 
1379     def _print_MatrixSymbol(self, expr):
1380         return self._print_Symbol(expr, style=self._settings['mat_symbol_style'])
1381 
1382     def _deal_with_super_sub(self, string):
1383         if '{' in string:
1384             return string
1385 
1386         name, supers, subs = split_super_sub(string)
1387 
1388         name = translate(name)
1389         supers = [translate(sup) for sup in supers]
1390         subs = [translate(sub) for sub in subs]
1391 
1392         # glue all items together:
1393         if supers:
1394             name += "^{%s}" % " ".join(supers)
1395         if subs:
1396             name += "_{%s}" % " ".join(subs)
1397 
1398         return name
1399 
1400     def _print_Relational(self, expr):
1401         if self._settings['itex']:
1402             gt = r"\gt"
1403             lt = r"\lt"
1404         else:
1405             gt = ">"
1406             lt = "<"
1407 
1408         charmap = {
1409             "==": "=",
1410             ">": gt,
1411             "<": lt,
1412             ">=": r"\geq",
1413             "<=": r"\leq",
1414             "!=": r"\neq",
1415         }
1416 
1417         return "%s %s %s" % (self._print(expr.lhs),
1418             charmap[expr.rel_op], self._print(expr.rhs))
1419 
1420     def _print_Piecewise(self, expr):
1421         ecpairs = [r"%s & \text{for}\: %s" % (self._print(e), self._print(c))
1422                    for e, c in expr.args[:-1]]
1423         if expr.args[-1].cond == true:
1424             ecpairs.append(r"%s & \text{otherwise}" %
1425                            self._print(expr.args[-1].expr))
1426         else:
1427             ecpairs.append(r"%s & \text{for}\: %s" %
1428                            (self._print(expr.args[-1].expr),
1429                             self._print(expr.args[-1].cond)))
1430         tex = r"\begin{cases} %s \end{cases}"
1431         return tex % r" \\".join(ecpairs)
1432 
1433     def _print_MatrixBase(self, expr):
1434         lines = []
1435 
1436         for line in range(expr.rows):  # horrible, should be 'rows'
1437             lines.append(" & ".join([ self._print(i) for i in expr[line, :] ]))
1438 
1439         mat_str = self._settings['mat_str']
1440         if mat_str is None:
1441             if self._settings['mode'] == 'inline':
1442                 mat_str = 'smallmatrix'
1443             else:
1444                 if (expr.cols <= 10) is True:
1445                     mat_str = 'matrix'
1446                 else:
1447                     mat_str = 'array'
1448 
1449         out_str = r'\begin{%MATSTR%}%s\end{%MATSTR%}'
1450         out_str = out_str.replace('%MATSTR%', mat_str)
1451         if mat_str == 'array':
1452             out_str = out_str.replace('%s', '{' + 'c'*expr.cols + '}%s')
1453         if self._settings['mat_delim']:
1454             left_delim = self._settings['mat_delim']
1455             right_delim = self._delim_dict[left_delim]
1456             out_str = r'\left' + left_delim + out_str + \
1457                       r'\right' + right_delim
1458         return out_str % r"\\".join(lines)
1459     _print_ImmutableMatrix = _print_ImmutableDenseMatrix \
1460                            = _print_Matrix \
1461                            = _print_MatrixBase
1462 
1463     def _print_MatrixElement(self, expr):
1464         return self.parenthesize(expr.parent, PRECEDENCE["Atom"], strict=True) \
1465             + '_{%s, %s}' % (
1466             self._print(expr.i),
1467             self._print(expr.j)
1468         )
1469 
1470     def _print_MatrixSlice(self, expr):
1471         def latexslice(x):
1472             x = list(x)
1473             if x[2] == 1:
1474                 del x[2]
1475             if x[1] == x[0] + 1:
1476                 del x[1]
1477             if x[0] == 0:
1478                 x[0] = ''
1479             return ':'.join(map(self._print, x))
1480         return (self._print(expr.parent) + r'\left[' +
1481                 latexslice(expr.rowslice) + ', ' +
1482                 latexslice(expr.colslice) + r'\right]')
1483 
1484     def _print_BlockMatrix(self, expr):
1485         return self._print(expr.blocks)
1486 
1487     def _print_Transpose(self, expr):
1488         mat = expr.arg
1489         from sympy.matrices import MatrixSymbol
1490         if not isinstance(mat, MatrixSymbol):
1491             return r"\left(%s\right)^T" % self._print(mat)
1492         else:
1493             return "%s^T" % self._print(mat)
1494 
1495     def _print_Trace(self, expr):
1496         mat = expr.arg
1497         return r"\mathrm{tr}\left(%s \right)" % self._print(mat)
1498 
1499     def _print_Adjoint(self, expr):
1500         mat = expr.arg
1501         from sympy.matrices import MatrixSymbol
1502         if not isinstance(mat, MatrixSymbol):
1503             return r"\left(%s\right)^\dagger" % self._print(mat)
1504         else:
1505             return r"%s^\dagger" % self._print(mat)
1506 
1507     def _print_MatMul(self, expr):
1508         from sympy import MatMul, Mul
1509 
1510         parens = lambda x: self.parenthesize(x, precedence_traditional(expr), False)
1511 
1512         args = expr.args
1513         if isinstance(args[0], Mul):
1514             args = args[0].as_ordered_factors() + list(args[1:])
1515         else:
1516             args = list(args)
1517 
1518         if isinstance(expr, MatMul) and _coeff_isneg(expr):
1519             if args[0] == -1:
1520                 args = args[1:]
1521             else:
1522                 args[0] = -args[0]
1523             return '- ' + ' '.join(map(parens, args))
1524         else:
1525             return ' '.join(map(parens, args))
1526 
1527     def _print_Mod(self, expr, exp=None):
1528         if exp is not None:
1529             return r'\left(%s\bmod{%s}\right)^{%s}' % (self.parenthesize(expr.args[0],
1530                     PRECEDENCE['Mul'], strict=True), self._print(expr.args[1]), self._print(exp))
1531         return r'%s\bmod{%s}' % (self.parenthesize(expr.args[0],
1532                 PRECEDENCE['Mul'], strict=True), self._print(expr.args[1]))
1533 
1534     def _print_HadamardProduct(self, expr):
1535         from sympy import Add, MatAdd, MatMul
1536 
1537         def parens(x):
1538             if isinstance(x, (Add, MatAdd, MatMul)):
1539                 return r"\left(%s\right)" % self._print(x)
1540             return self._print(x)
1541         return r' \circ '.join(map(parens, expr.args))
1542 
1543     def _print_KroneckerProduct(self, expr):
1544         from sympy import Add, MatAdd, MatMul
1545 
1546         def parens(x):
1547             if isinstance(x, (Add, MatAdd, MatMul)):
1548                 return r"\left(%s\right)" % self._print(x)
1549             return self._print(x)
1550         return r' \otimes '.join(map(parens, expr.args))
1551 
1552     def _print_MatPow(self, expr):
1553         base, exp = expr.base, expr.exp
1554         from sympy.matrices import MatrixSymbol
1555         if not isinstance(base, MatrixSymbol):
1556             return r"\left(%s\right)^{%s}" % (self._print(base), self._print(exp))
1557         else:
1558             return "%s^{%s}" % (self._print(base), self._print(exp))
1559 
1560     def _print_ZeroMatrix(self, Z):
1561         return r"\mathbb{0}"
1562 
1563     def _print_Identity(self, I):
1564         return r"\mathbb{I}"
1565 
1566     def _print_NDimArray(self, expr):
1567 
1568         if expr.rank() == 0:
1569             return self._print(expr[()])
1570 
1571         mat_str = self._settings['mat_str']
1572         if mat_str is None:
1573             if self._settings['mode'] == 'inline':
1574                 mat_str = 'smallmatrix'
1575             else:
1576                 if (expr.rank() == 0) or (expr.shape[-1] <= 10):
1577                     mat_str = 'matrix'
1578                 else:
1579                     mat_str = 'array'
1580         block_str = r'\begin{%MATSTR%}%s\end{%MATSTR%}'
1581         block_str = block_str.replace('%MATSTR%', mat_str)
1582         if self._settings['mat_delim']:
1583             left_delim = self._settings['mat_delim']
1584             right_delim = self._delim_dict[left_delim]
1585             block_str = r'\left' + left_delim + block_str + \
1586                       r'\right' + right_delim
1587 
1588         if expr.rank() == 0:
1589             return block_str % ""
1590 
1591         level_str = [[]] + [[] for i in range(expr.rank())]
1592         shape_ranges = [list(range(i)) for i in expr.shape]
1593         for outer_i in itertools.product(*shape_ranges):
1594             level_str[-1].append(self._print(expr[outer_i]))
1595             even = True
1596             for back_outer_i in range(expr.rank()-1, -1, -1):
1597                 if len(level_str[back_outer_i+1]) < expr.shape[back_outer_i]:
1598                     break
1599                 if even:
1600                     level_str[back_outer_i].append(r" & ".join(level_str[back_outer_i+1]))
1601                 else:
1602                     level_str[back_outer_i].append(block_str % (r"\\".join(level_str[back_outer_i+1])))
1603                     if len(level_str[back_outer_i+1]) == 1:
1604                         level_str[back_outer_i][-1] = r"\left[" + level_str[back_outer_i][-1] + r"\right]"
1605                 even = not even
1606                 level_str[back_outer_i+1] = []
1607 
1608         out_str = level_str[0][0]
1609 
1610         if expr.rank() % 2 == 1:
1611             out_str = block_str % out_str
1612 
1613         return out_str
1614 
1615     _print_ImmutableDenseNDimArray = _print_NDimArray
1616     _print_ImmutableSparseNDimArray = _print_NDimArray
1617     _print_MutableDenseNDimArray = _print_NDimArray
1618     _print_MutableSparseNDimArray = _print_NDimArray
1619 
1620     def _printer_tensor_indices(self, name, indices, index_map={}):
1621         out_str = self._print(name)
1622         last_valence = None
1623         prev_map = None
1624         for index in indices:
1625             new_valence = index.is_up
1626             if ((index in index_map) or prev_map) and last_valence == new_valence:
1627                 out_str += ","
1628             if last_valence != new_valence:
1629                 if last_valence is not None:
1630                     out_str += "}"
1631                 if index.is_up:
1632                     out_str += "{}^{"
1633                 else:
1634                     out_str += "{}_{"
1635             out_str += self._print(index.args[0])
1636             if index in index_map:
1637                 out_str += "="
1638                 out_str += self._print(index_map[index])
1639                 prev_map = True
1640             else:
1641                 prev_map = False
1642             last_valence = new_valence
1643         if last_valence is not None:
1644             out_str += "}"
1645         return out_str
1646 
1647     def _print_Tensor(self, expr):
1648         name = expr.args[0].args[0]
1649         indices = expr.get_indices()
1650         return self._printer_tensor_indices(name, indices)
1651 
1652     def _print_TensorElement(self, expr):
1653         name = expr.expr.args[0].args[0]
1654         indices = expr.expr.get_indices()
1655         index_map = expr.index_map
1656         return self._printer_tensor_indices(name, indices, index_map)
1657 
1658     def _print_TensMul(self, expr):
1659         # prints expressions like "A(a)", "3*A(a)", "(1+x)*A(a)"
1660         sign, args = expr._get_args_for_traditional_printer()
1661         return sign + "".join(
1662             [self.parenthesize(arg, precedence(expr)) for arg in args]
1663         )
1664 
1665     def _print_TensAdd(self, expr):
1666         a = []
1667         args = expr.args
1668         for x in args:
1669             a.append(self.parenthesize(x, precedence(expr)))
1670         a.sort()
1671         s = ' + '.join(a)
1672         s = s.replace('+ -', '- ')
1673         return s
1674 
1675     def _print_TensorIndex(self, expr):
1676         return "{}%s{%s}" % (
1677             "^" if expr.is_up else "_",
1678             self._print(expr.args[0])
1679         )
1680         return self._print(expr.args[0])
1681 
1682     def _print_tuple(self, expr):
1683         return r"\left( %s\right)" % \
1684             r", \  ".join([ self._print(i) for i in expr ])
1685 
1686     def _print_TensorProduct(self, expr):
1687         elements = [self._print(a) for a in expr.args]
1688         return r' \otimes '.join(elements)
1689 
1690     def _print_WedgeProduct(self, expr):
1691         elements = [self._print(a) for a in expr.args]
1692         return r' \wedge '.join(elements)
1693 
1694     def _print_Tuple(self, expr):
1695         return self._print_tuple(expr)
1696 
1697     def _print_list(self, expr):
1698         return r"\left[ %s\right]" % \
1699             r", \  ".join([ self._print(i) for i in expr ])
1700 
1701     def _print_dict(self, d):
1702         keys = sorted(d.keys(), key=default_sort_key)
1703         items = []
1704 
1705         for key in keys:
1706             val = d[key]
1707             items.append("%s : %s" % (self._print(key), self._print(val)))
1708 
1709         return r"\left\{ %s\right\}" % r", \  ".join(items)
1710 
1711     def _print_Dict(self, expr):
1712         return self._print_dict(expr)
1713 
1714     def _print_DiracDelta(self, expr, exp=None):
1715         if len(expr.args) == 1 or expr.args[1] == 0:
1716             tex = r"\delta\left(%s\right)" % self._print(expr.args[0])
1717         else:
1718             tex = r"\delta^{\left( %s \right)}\left( %s \right)" % (
1719                 self._print(expr.args[1]), self._print(expr.args[0]))
1720         if exp:
1721             tex = r"\left(%s\right)^{%s}" % (tex, exp)
1722         return tex
1723 
1724     def _print_SingularityFunction(self, expr):
1725         shift = self._print(expr.args[0] - expr.args[1])
1726         power = self._print(expr.args[2])
1727         tex = r"{\left\langle %s \right\rangle}^{%s}" % (shift, power)
1728         return tex
1729 
1730     def _print_Heaviside(self, expr, exp=None):
1731         tex = r"\theta\left(%s\right)" % self._print(expr.args[0])
1732         if exp:
1733             tex = r"\left(%s\right)^{%s}" % (tex, exp)
1734         return tex
1735 
1736     def _print_KroneckerDelta(self, expr, exp=None):
1737         i = self._print(expr.args[0])
1738         j = self._print(expr.args[1])
1739         if expr.args[0].is_Atom and expr.args[1].is_Atom:
1740             tex = r'\delta_{%s %s}' % (i, j)
1741         else:
1742             tex = r'\delta_{%s, %s}' % (i, j)
1743         if exp is not None:
1744             tex = r'\left(%s\right)^{%s}' % (tex, exp)
1745         return tex
1746 
1747     def _print_LeviCivita(self, expr, exp=None):
1748         indices = map(self._print, expr.args)
1749         if all(x.is_Atom for x in expr.args):
1750             tex = r'\varepsilon_{%s}' % " ".join(indices)
1751         else:
1752             tex = r'\varepsilon_{%s}' % ", ".join(indices)
1753         if exp:
1754             tex = r'\left(%s\right)^{%s}' % (tex, exp)
1755         return tex
1756 
1757     def _print_ProductSet(self, p):
1758         if len(p.sets) > 1 and not has_variety(p.sets):
1759             return self._print(p.sets[0]) + "^{%d}" % len(p.sets)
1760         else:
1761             return r" \times ".join(self._print(set) for set in p.sets)
1762 
1763     def _print_RandomDomain(self, d):
1764         if hasattr(d, 'as_boolean'):
1765             return 'Domain: ' + self._print(d.as_boolean())
1766         elif hasattr(d, 'set'):
1767             return ('Domain: ' + self._print(d.symbols) + ' in ' +
1768                     self._print(d.set))
1769         elif hasattr(d, 'symbols'):
1770             return 'Domain on ' + self._print(d.symbols)
1771         else:
1772             return self._print(None)
1773 
1774     def _print_FiniteSet(self, s):
1775         items = sorted(s.args, key=default_sort_key)
1776         return self._print_set(items)
1777 
1778     def _print_set(self, s):
1779         items = sorted(s, key=default_sort_key)
1780         items = ", ".join(map(self._print, items))
1781         return r"\left\{%s\right\}" % items
1782 
1783     _print_frozenset = _print_set
1784 
1785     def _print_Range(self, s):
1786         dots = r'\ldots'
1787 
1788         if s.start.is_infinite:
1789             printset = s.start, dots, s[-1] - s.step, s[-1]
1790         elif s.stop.is_infinite or len(s) > 4:
1791             it = iter(s)
1792             printset = next(it), next(it), dots, s[-1]
1793         else:
1794             printset = tuple(s)
1795 
1796         return (r"\left\{"
1797               + r", ".join(self._print(el) for el in printset)
1798               + r"\right\}")
1799 
1800     def _print_SeqFormula(self, s):
1801         if len(s.start.free_symbols) > 0 or len(s.stop.free_symbols) > 0:
1802             return r"\left\{%s\right\}_{%s=%s}^{%s}" % (
1803                 self._print(s.formula),
1804                 self._print(s.variables[0]),
1805                 self._print(s.start),
1806                 self._print(s.stop)
1807             )
1808         if s.start is S.NegativeInfinity:
1809             stop = s.stop
1810             printset = (r'\ldots', s.coeff(stop - 3), s.coeff(stop - 2),
1811                 s.coeff(stop - 1), s.coeff(stop))
1812         elif s.stop is S.Infinity or s.length > 4:
1813             printset = s[:4]
1814             printset.append(r'\ldots')
1815         else:
1816             printset = tuple(s)
1817 
1818         return (r"\left["
1819               + r", ".join(self._print(el) for el in printset)
1820               + r"\right]")
1821 
1822     _print_SeqPer = _print_SeqFormula
1823     _print_SeqAdd = _print_SeqFormula
1824     _print_SeqMul = _print_SeqFormula
1825 
1826     def _print_Interval(self, i):
1827         if i.start == i.end:
1828             return r"\left\{%s\right\}" % self._print(i.start)
1829 
1830         else:
1831             if i.left_open:
1832                 left = '('
1833             else:
1834                 left = '['
1835 
1836             if i.right_open:
1837                 right = ')'
1838             else:
1839                 right = ']'
1840 
1841             return r"\left%s%s, %s\right%s" % \
1842                    (left, self._print(i.start), self._print(i.end), right)
1843 
1844     def _print_AccumulationBounds(self, i):
1845         return r"\left\langle %s, %s\right\rangle" % \
1846                 (self._print(i.min), self._print(i.max))
1847 
1848     def _print_Union(self, u):
1849         return r" \cup ".join([self._print(i) for i in u.args])
1850 
1851     def _print_Complement(self, u):
1852         return r" \setminus ".join([self._print(i) for i in u.args])
1853 
1854     def _print_Intersection(self, u):
1855         return r" \cap ".join([self._print(i) for i in u.args])
1856 
1857     def _print_SymmetricDifference(self, u):
1858         return r" \triangle ".join([self._print(i) for i in u.args])
1859 
1860     def _print_EmptySet(self, e):
1861         return r"\emptyset"
1862 
1863     def _print_Naturals(self, n):
1864         return r"\mathbb{N}"
1865 
1866     def _print_Naturals0(self, n):
1867         return r"\mathbb{N}_0"
1868 
1869     def _print_Integers(self, i):
1870         return r"\mathbb{Z}"
1871 
1872     def _print_Reals(self, i):
1873         return r"\mathbb{R}"
1874 
1875     def _print_Complexes(self, i):
1876         return r"\mathbb{C}"
1877 
1878     def _print_ImageSet(self, s):
1879         sets = s.args[1:]
1880         varsets = [r"%s \in %s" % (self._print(var), self._print(setv))
1881             for var, setv in zip(s.lamda.variables, sets)]
1882         return r"\left\{%s\; |\; %s\right\}" % (
1883             self._print(s.lamda.expr),
1884             ', '.join(varsets))
1885 
1886     def _print_ConditionSet(self, s):
1887         vars_print = ', '.join([self._print(var) for var in Tuple(s.sym)])
1888         if s.base_set is S.UniversalSet:
1889             return r"\left\{%s \mid %s \right\}" % (
1890             vars_print,
1891             self._print(s.condition.as_expr()))
1892 
1893         return r"\left\{%s \mid %s \in %s \wedge %s \right\}" % (
1894             vars_print,
1895             vars_print,
1896             self._print(s.base_set),
1897             self._print(s.condition))
1898 
1899     def _print_ComplexRegion(self, s):
1900         vars_print = ', '.join([self._print(var) for var in s.variables])
1901         return r"\left\{%s\; |\; %s \in %s \right\}" % (
1902             self._print(s.expr),
1903             vars_print,
1904             self._print(s.sets))
1905 
1906     def _print_Contains(self, e):
1907         return r"%s \in %s" % tuple(self._print(a) for a in e.args)
1908 
1909     def _print_FourierSeries(self, s):
1910         return self._print_Add(s.truncate()) + self._print(r' + \ldots')
1911 
1912     def _print_FormalPowerSeries(self, s):
1913         return self._print_Add(s.infinite)
1914 
1915     def _print_FiniteField(self, expr):
1916         return r"\mathbb{F}_{%s}" % expr.mod
1917 
1918     def _print_IntegerRing(self, expr):
1919         return r"\mathbb{Z}"
1920 
1921     def _print_RationalField(self, expr):
1922         return r"\mathbb{Q}"
1923 
1924     def _print_RealField(self, expr):
1925         return r"\mathbb{R}"
1926 
1927     def _print_ComplexField(self, expr):
1928         return r"\mathbb{C}"
1929 
1930     def _print_PolynomialRing(self, expr):
1931         domain = self._print(expr.domain)
1932         symbols = ", ".join(map(self._print, expr.symbols))
1933         return r"%s\left[%s\right]" % (domain, symbols)
1934 
1935     def _print_FractionField(self, expr):
1936         domain = self._print(expr.domain)
1937         symbols = ", ".join(map(self._print, expr.symbols))
1938         return r"%s\left(%s\right)" % (domain, symbols)
1939 
1940     def _print_PolynomialRingBase(self, expr):
1941         domain = self._print(expr.domain)
1942         symbols = ", ".join(map(self._print, expr.symbols))
1943         inv = ""
1944         if not expr.is_Poly:
1945             inv = r"S_<^{-1}"
1946         return r"%s%s\left[%s\right]" % (inv, domain, symbols)
1947 
1948     def _print_Poly(self, poly):
1949         cls = poly.__class__.__name__
1950         terms = []
1951         for monom, coeff in poly.terms():
1952             s_monom = ''
1953             for i, exp in enumerate(monom):
1954                 if exp > 0:
1955                     if exp == 1:
1956                         s_monom += self._print(poly.gens[i])
1957                     else:
1958                         s_monom += self._print(pow(poly.gens[i], exp))
1959 
1960             if coeff.is_Add:
1961                 if s_monom:
1962                     s_coeff = r"\left(%s\right)" % self._print(coeff)
1963                 else:
1964                     s_coeff = self._print(coeff)
1965             else:
1966                 if s_monom:
1967                     if coeff is S.One:
1968                         terms.extend(['+', s_monom])
1969                         continue
1970 
1971                     if coeff is S.NegativeOne:
1972                         terms.extend(['-', s_monom])
1973                         continue
1974 
1975                 s_coeff = self._print(coeff)
1976 
1977             if not s_monom:
1978                 s_term = s_coeff
1979             else:
1980                 s_term = s_coeff + " " + s_monom
1981 
1982             if s_term.startswith('-'):
1983                 terms.extend(['-', s_term[1:]])
1984             else:
1985                 terms.extend(['+', s_term])
1986 
1987         if terms[0] in ['-', '+']:
1988             modifier = terms.pop(0)
1989 
1990             if modifier == '-':
1991                 terms[0] = '-' + terms[0]
1992 
1993         expr = ' '.join(terms)
1994         gens = list(map(self._print, poly.gens))
1995         domain = "domain=%s" % self._print(poly.get_domain())
1996 
1997         args = ", ".join([expr] + gens + [domain])
1998         if cls in accepted_latex_functions:
1999             tex = r"\%s {\left(%s \right)}" % (cls, args)
2000         else:
2001             tex = r"\operatorname{%s}{\left( %s \right)}" % (cls, args)
2002 
2003         return tex
2004 
2005     def _print_ComplexRootOf(self, root):
2006         cls = root.__class__.__name__
2007         if cls == "ComplexRootOf":
2008             cls = "CRootOf"
2009         expr = self._print(root.expr)
2010         index = root.index
2011         if cls in accepted_latex_functions:
2012             return r"\%s {\left(%s, %d\right)}" % (cls, expr, index)
2013         else:
2014             return r"\operatorname{%s} {\left(%s, %d\right)}" % (cls, expr, index)
2015 
2016     def _print_RootSum(self, expr):
2017         cls = expr.__class__.__name__
2018         args = [self._print(expr.expr)]
2019 
2020         if expr.fun is not S.IdentityFunction:
2021             args.append(self._print(expr.fun))
2022 
2023         if cls in accepted_latex_functions:
2024             return r"\%s {\left(%s\right)}" % (cls, ", ".join(args))
2025         else:
2026             return r"\operatorname{%s} {\left(%s\right)}" % (cls, ", ".join(args))
2027 
2028     def _print_PolyElement(self, poly):
2029         mul_symbol = self._settings['mul_symbol_latex']
2030         return poly.str(self, PRECEDENCE, "{%s}^{%d}", mul_symbol)
2031 
2032     def _print_FracElement(self, frac):
2033         if frac.denom == 1:
2034             return self._print(frac.numer)
2035         else:
2036             numer = self._print(frac.numer)
2037             denom = self._print(frac.denom)
2038             return r"\frac{%s}{%s}" % (numer, denom)
2039 
2040     def _print_euler(self, expr, exp=None):
2041         m, x = (expr.args[0], None) if len(expr.args) == 1 else expr.args
2042         tex = r"E_{%s}" % self._print(m)
2043         if exp is not None:
2044             tex = r"%s^{%s}" % (tex, self._print(exp))
2045         if x is not None:
2046             tex = r"%s\left(%s\right)" % (tex, self._print(x))
2047         return tex
2048 
2049     def _print_catalan(self, expr, exp=None):
2050         tex = r"C_{%s}" % self._print(expr.args[0])
2051         if exp is not None:
2052             tex = r"%s^{%s}" % (tex, self._print(exp))
2053         return tex
2054 
2055     def _print_MellinTransform(self, expr):
2056         return r"\mathcal{M}_{%s}\left[%s\right]\left(%s\right)" % (self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))
2057 
2058     def _print_InverseMellinTransform(self, expr):
2059         return r"\mathcal{M}^{-1}_{%s}\left[%s\right]\left(%s\right)" % (self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))
2060 
2061     def _print_LaplaceTransform(self, expr):
2062         return r"\mathcal{L}_{%s}\left[%s\right]\left(%s\right)" % (self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))
2063 
2064     def _print_InverseLaplaceTransform(self, expr):
2065         return r"\mathcal{L}^{-1}_{%s}\left[%s\right]\left(%s\right)" % (self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))
2066 
2067     def _print_FourierTransform(self, expr):
2068         return r"\mathcal{F}_{%s}\left[%s\right]\left(%s\right)" % (self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))
2069 
2070     def _print_InverseFourierTransform(self, expr):
2071         return r"\mathcal{F}^{-1}_{%s}\left[%s\right]\left(%s\right)" % (self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))
2072 
2073     def _print_SineTransform(self, expr):
2074         return r"\mathcal{SIN}_{%s}\left[%s\right]\left(%s\right)" % (self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))
2075 
2076     def _print_InverseSineTransform(self, expr):
2077         return r"\mathcal{SIN}^{-1}_{%s}\left[%s\right]\left(%s\right)" % (self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))
2078 
2079     def _print_CosineTransform(self, expr):
2080         return r"\mathcal{COS}_{%s}\left[%s\right]\left(%s\right)" % (self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))
2081 
2082     def _print_InverseCosineTransform(self, expr):
2083         return r"\mathcal{COS}^{-1}_{%s}\left[%s\right]\left(%s\right)" % (self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))
2084 
2085     def _print_DMP(self, p):
2086         try:
2087             if p.ring is not None:
2088                 # TODO incorporate order
2089                 return self._print(p.ring.to_sympy(p))
2090         except SympifyError:
2091             pass
2092         return self._print(repr(p))
2093 
2094     def _print_DMF(self, p):
2095         return self._print_DMP(p)
2096 
2097     def _print_Object(self, object):
2098         return self._print(Symbol(object.name))
2099 
2100     def _print_Morphism(self, morphism):
2101         domain = self._print(morphism.domain)
2102         codomain = self._print(morphism.codomain)
2103         return "%s\\rightarrow %s" % (domain, codomain)
2104 
2105     def _print_NamedMorphism(self, morphism):
2106         pretty_name = self._print(Symbol(morphism.name))
2107         pretty_morphism = self._print_Morphism(morphism)
2108         return "%s:%s" % (pretty_name, pretty_morphism)
2109 
2110     def _print_IdentityMorphism(self, morphism):
2111         from sympy.categories import NamedMorphism
2112         return self._print_NamedMorphism(NamedMorphism(
2113             morphism.domain, morphism.codomain, "id"))
2114 
2115     def _print_CompositeMorphism(self, morphism):
2116         # All components of the morphism have names and it is thus
2117         # possible to build the name of the composite.
2118         component_names_list = [self._print(Symbol(component.name)) for
2119                                 component in morphism.components]
2120         component_names_list.reverse()
2121         component_names = "\\circ ".join(component_names_list) + ":"
2122 
2123         pretty_morphism = self._print_Morphism(morphism)
2124         return component_names + pretty_morphism
2125 
2126     def _print_Category(self, morphism):
2127         return "\\mathbf{%s}" % self._print(Symbol(morphism.name))
2128 
2129     def _print_Diagram(self, diagram):
2130         if not diagram.premises:
2131             # This is an empty diagram.
2132             return self._print(S.EmptySet)
2133 
2134         latex_result = self._print(diagram.premises)
2135         if diagram.conclusions:
2136             latex_result += "\\Longrightarrow %s" % \
2137                             self._print(diagram.conclusions)
2138 
2139         return latex_result
2140 
2141     def _print_DiagramGrid(self, grid):
2142         latex_result = "\\begin{array}{%s}\n" % ("c" * grid.width)
2143 
2144         for i in range(grid.height):
2145             for j in range(grid.width):
2146                 if grid[i, j]:
2147                     latex_result += latex(grid[i, j])
2148                 latex_result += " "
2149                 if j != grid.width - 1:
2150                     latex_result += "& "
2151 
2152             if i != grid.height - 1:
2153                 latex_result += "\\\\"
2154             latex_result += "\n"
2155 
2156         latex_result += "\\end{array}\n"
2157         return latex_result
2158 
2159     def _print_FreeModule(self, M):
2160         return '{%s}^{%s}' % (self._print(M.ring), self._print(M.rank))
2161 
2162     def _print_FreeModuleElement(self, m):
2163         # Print as row vector for convenience, for now.
2164         return r"\left[ %s \right]" % ",".join(
2165             '{' + self._print(x) + '}' for x in m)
2166 
2167     def _print_SubModule(self, m):
2168         return r"\left\langle %s \right\rangle" % ",".join(
2169             '{' + self._print(x) + '}' for x in m.gens)
2170 
2171     def _print_ModuleImplementedIdeal(self, m):
2172         return r"\left\langle %s \right\rangle" % ",".join(
2173             '{' + self._print(x) + '}' for [x] in m._module.gens)
2174 
2175     def _print_Quaternion(self, expr):
2176         # TODO: This expression is potentially confusing,
2177         # shall we print it as `Quaternion( ... )`?
2178         s = [self.parenthesize(i, PRECEDENCE["Mul"], strict=True) for i in expr.args]
2179         a = [s[0]] + [i+" "+j for i, j in zip(s[1:], "ijk")]
2180         return " + ".join(a)
2181 
2182     def _print_QuotientRing(self, R):
2183         # TODO nicer fractions for few generators...
2184         return r"\frac{%s}{%s}" % (self._print(R.ring), self._print(R.base_ideal))
2185 
2186     def _print_QuotientRingElement(self, x):
2187         return r"{%s} + {%s}" % (self._print(x.data), self._print(x.ring.base_ideal))
2188 
2189     def _print_QuotientModuleElement(self, m):
2190         return r"{%s} + {%s}" % (self._print(m.data),
2191                                  self._print(m.module.killed_module))
2192 
2193     def _print_QuotientModule(self, M):
2194         # TODO nicer fractions for few generators...
2195         return r"\frac{%s}{%s}" % (self._print(M.base),
2196                                    self._print(M.killed_module))
2197 
2198     def _print_MatrixHomomorphism(self, h):
2199         return r"{%s} : {%s} \to {%s}" % (self._print(h._sympy_matrix()),
2200             self._print(h.domain), self._print(h.codomain))
2201 
2202     def _print_BaseScalarField(self, field):
2203         string = field._coord_sys._names[field._index]
2204         return r'\boldsymbol{\mathrm{%s}}' % self._print(Symbol(string))
2205 
2206     def _print_BaseVectorField(self, field):
2207         string = field._coord_sys._names[field._index]
2208         return r'\partial_{%s}' % self._print(Symbol(string))
2209 
2210     def _print_Differential(self, diff):
2211         field = diff._form_field
2212         if hasattr(field, '_coord_sys'):
2213             string = field._coord_sys._names[field._index]
2214             return r'\mathrm{d}%s' % self._print(Symbol(string))
2215         else:
2216             return 'd(%s)' % self._print(field)
2217             string = self._print(field)
2218             return r'\mathrm{d}\left(%s\right)' % string
2219 
2220     def _print_Tr(self, p):
2221         #Todo: Handle indices
2222         contents = self._print(p.args[0])
2223         return r'\mbox{Tr}\left(%s\right)' % (contents)
2224 
2225     def _print_totient(self, expr, exp=None):
2226         if exp is not None:
2227             return r'\left(\phi\left(%s\right)\right)^{%s}' % (self._print(expr.args[0]),
2228                     self._print(exp))
2229         return r'\phi\left(%s\right)' % self._print(expr.args[0])
2230 
2231     def _print_reduced_totient(self, expr, exp=None):
2232         if exp is not None:
2233             return r'\left(\lambda\left(%s\right)\right)^{%s}' % (self._print(expr.args[0]),
2234                     self._print(exp))
2235         return r'\lambda\left(%s\right)' % self._print(expr.args[0])
2236 
2237     def _print_divisor_sigma(self, expr, exp=None):
2238         if len(expr.args) == 2:
2239             tex = r"_%s\left(%s\right)" % tuple(map(self._print,
2240                                                 (expr.args[1], expr.args[0])))
2241         else:
2242             tex = r"\left(%s\right)" % self._print(expr.args[0])
2243         if exp is not None:
2244             return r"\sigma^{%s}%s" % (self._print(exp), tex)
2245         return r"\sigma%s" % tex
2246 
2247     def _print_udivisor_sigma(self, expr, exp=None):
2248         if len(expr.args) == 2:
2249             tex = r"_%s\left(%s\right)" % tuple(map(self._print,
2250                                                 (expr.args[1], expr.args[0])))
2251         else:
2252             tex = r"\left(%s\right)" % self._print(expr.args[0])
2253         if exp is not None:
2254             return r"\sigma^*^{%s}%s" % (self._print(exp), tex)
2255         return r"\sigma^*%s" % tex
2256 
2257     def _print_primenu(self, expr, exp=None):
2258         if exp is not None:
2259             return r'\left(\nu\left(%s\right)\right)^{%s}' % (self._print(expr.args[0]),
2260                     self._print(exp))
2261         return r'\nu\left(%s\right)' % self._print(expr.args[0])
2262 
2263     def _print_primeomega(self, expr, exp=None):
2264         if exp is not None:
2265             return r'\left(\Omega\left(%s\right)\right)^{%s}' % (self._print(expr.args[0]),
2266                     self._print(exp))
2267         return r'\Omega\left(%s\right)' % self._print(expr.args[0])
2268 
2269 
2270 def translate(s):
2271     r'''
2272     Check for a modifier ending the string.  If present, convert the
2273     modifier to latex and translate the rest recursively.
2274 
2275     Given a description of a Greek letter or other special character,
2276     return the appropriate latex.
2277 
2278     Let everything else pass as given.
2279 
2280     >>> from sympy.printing.latex import translate
2281     >>> translate('alphahatdotprime')
2282     "{\\dot{\\hat{\\alpha}}}'"
2283     '''
2284     # Process the rest
2285     tex = tex_greek_dictionary.get(s)
2286     if tex:
2287         return tex
2288     elif s.lower() in greek_letters_set:
2289         return "\\" + s.lower()
2290     elif s in other_symbols:
2291         return "\\" + s
2292     else:
2293         # Process modifiers, if any, and recurse
2294         for key in sorted(modifier_dict.keys(), key=lambda k:len(k), reverse=True):
2295             if s.lower().endswith(key) and len(s) > len(key):
2296                 return modifier_dict[key](translate(s[:-len(key)]))
2297         return s
2298 
2299 
2300 def latex(expr, fold_frac_powers=False, fold_func_brackets=False,
2301     fold_short_frac=None, inv_trig_style="abbreviated",
2302     itex=False, ln_notation=False, long_frac_ratio=None,
2303     mat_delim="[", mat_str=None, mode="plain", mul_symbol=None,
2304     order=None, symbol_names=None, root_notation=True,
2305     mat_symbol_style="plain", imaginary_unit="i"):
2306     r"""Convert the given expression to LaTeX string representation.
2307 
2308     Parameters
2309     ==========
2310     fold_frac_powers : boolean, optional
2311         Emit ``^{p/q}`` instead of ``^{\frac{p}{q}}`` for fractional powers.
2312     fold_func_brackets : boolean, optional
2313         Fold function brackets where applicable.
2314     fold_short_frac : boolean, optional
2315         Emit ``p / q`` instead of ``\frac{p}{q}`` when the denominator is
2316         simple enough (at most two terms and no powers). The default value is
2317         ``True`` for inline mode, ``False`` otherwise.
2318     inv_trig_style : string, optional
2319         How inverse trig functions should be displayed. Can be one of
2320         ``abbreviated``, ``full``, or ``power``. Defaults to ``abbreviated``.
2321     itex : boolean, optional
2322         Specifies if itex-specific syntax is used, including emitting
2323         ``$$...$$``.
2324     ln_notation : boolean, optional
2325         If set to ``True``, ``\ln`` is used instead of default ``\log``.
2326     long_frac_ratio : float or None, optional
2327         The allowed ratio of the width of the numerator to the width of the
2328         denominator before the printer breaks off long fractions. If ``None``
2329         (the default value), long fractions are not broken up.
2330     mat_delim : string, optional
2331         The delimiter to wrap around matrices. Can be one of ``[``, ``(``, or
2332         the empty string. Defaults to ``[``.
2333     mat_str : string, optional
2334         Which matrix environment string to emit. ``smallmatrix``, ``matrix``,
2335         ``array``, etc. Defaults to ``smallmatrix`` for inline mode, ``matrix``
2336         for matrices of no more than 10 columns, and ``array`` otherwise.
2337     mode: string, optional
2338         Specifies how the generated code will be delimited. ``mode`` can be one
2339         of ``plain``, ``inline``, ``equation`` or ``equation*``.  If ``mode``
2340         is set to ``plain``, then the resulting code will not be delimited at
2341         all (this is the default). If ``mode`` is set to ``inline`` then inline
2342         LaTeX ``$...$`` will be used. If ``mode`` is set to ``equation`` or
2343         ``equation*``, the resulting code will be enclosed in the ``equation``
2344         or ``equation*`` environment (remember to import ``amsmath`` for
2345         ``equation*``), unless the ``itex`` option is set. In the latter case,
2346         the ``$$...$$`` syntax is used.
2347     mul_symbol : string or None, optional
2348         The symbol to use for multiplication. Can be one of ``None``, ``ldot``,
2349         ``dot``, or ``times``.
2350     order: string, optional
2351         Any of the supported monomial orderings (currently ``lex``, ``grlex``,
2352         or ``grevlex``), ``old``, and ``none``. This parameter does nothing for
2353         Mul objects. Setting order to ``old`` uses the compatibility ordering
2354         for Add defined in Printer. For very large expressions, set the
2355         ``order`` keyword to ``none`` if speed is a concern.
2356     symbol_names : dictionary of strings mapped to symbols, optional
2357         Dictionary of symbols and the custom strings they should be emitted as.
2358     root_notation : boolean, optional
2359         If set to ``False``, exponents of the form 1/n are printed in fractonal form.
2360         Default is ``True``, to print exponent in root form.
2361     mat_symbol_style : string, optional
2362         Can be either ``plain`` (default) or ``bold``. If set to ``bold``,
2363         a MatrixSymbol A will be printed as ``\mathbf{A}``, otherwise as ``A``.
2364     imaginary_unit : string, optional
2365         String to use for the imaginary unit. Defined options are "i" (default)
2366         and "j". Adding "b" or "t" in front gives ``\mathrm`` or ``\text``, so
2367         "bi" leads to ``\mathrm{i}`` which gives `\mathrm{i}`.
2368 
2369     Notes
2370     =====
2371 
2372     Not using a print statement for printing, results in double backslashes for
2373     latex commands since that's the way Python escapes backslashes in strings.
2374 
2375     >>> from sympy import latex, Rational
2376     >>> from sympy.abc import tau
2377     >>> latex((2*tau)**Rational(7,2))
2378     '8 \\sqrt{2} \\tau^{\\frac{7}{2}}'
2379     >>> print(latex((2*tau)**Rational(7,2)))
2380     8 \sqrt{2} \tau^{\frac{7}{2}}
2381 
2382     Examples
2383     ========
2384 
2385     >>> from sympy import latex, pi, sin, asin, Integral, Matrix, Rational, log
2386     >>> from sympy.abc import x, y, mu, r, tau
2387 
2388     Basic usage:
2389 
2390     >>> print(latex((2*tau)**Rational(7,2)))
2391     8 \sqrt{2} \tau^{\frac{7}{2}}
2392 
2393     ``mode`` and ``itex`` options:
2394 
2395     >>> print(latex((2*mu)**Rational(7,2), mode='plain'))
2396     8 \sqrt{2} \mu^{\frac{7}{2}}
2397     >>> print(latex((2*tau)**Rational(7,2), mode='inline'))
2398     $8 \sqrt{2} \tau^{7 / 2}$
2399     >>> print(latex((2*mu)**Rational(7,2), mode='equation*'))
2400     \begin{equation*}8 \sqrt{2} \mu^{\frac{7}{2}}\end{equation*}
2401     >>> print(latex((2*mu)**Rational(7,2), mode='equation'))
2402     \begin{equation}8 \sqrt{2} \mu^{\frac{7}{2}}\end{equation}
2403     >>> print(latex((2*mu)**Rational(7,2), mode='equation', itex=True))
2404     $$8 \sqrt{2} \mu^{\frac{7}{2}}$$
2405     >>> print(latex((2*mu)**Rational(7,2), mode='plain'))
2406     8 \sqrt{2} \mu^{\frac{7}{2}}
2407     >>> print(latex((2*tau)**Rational(7,2), mode='inline'))
2408     $8 \sqrt{2} \tau^{7 / 2}$
2409     >>> print(latex((2*mu)**Rational(7,2), mode='equation*'))
2410     \begin{equation*}8 \sqrt{2} \mu^{\frac{7}{2}}\end{equation*}
2411     >>> print(latex((2*mu)**Rational(7,2), mode='equation'))
2412     \begin{equation}8 \sqrt{2} \mu^{\frac{7}{2}}\end{equation}
2413     >>> print(latex((2*mu)**Rational(7,2), mode='equation', itex=True))
2414     $$8 \sqrt{2} \mu^{\frac{7}{2}}$$
2415 
2416     Fraction options:
2417 
2418     >>> print(latex((2*tau)**Rational(7,2), fold_frac_powers=True))
2419     8 \sqrt{2} \tau^{7/2}
2420     >>> print(latex((2*tau)**sin(Rational(7,2))))
2421     \left(2 \tau\right)^{\sin{\left(\frac{7}{2} \right)}}
2422     >>> print(latex((2*tau)**sin(Rational(7,2)), fold_func_brackets=True))
2423     \left(2 \tau\right)^{\sin {\frac{7}{2}}}
2424     >>> print(latex(3*x**2/y))
2425     \frac{3 x^{2}}{y}
2426     >>> print(latex(3*x**2/y, fold_short_frac=True))
2427     3 x^{2} / y
2428     >>> print(latex(Integral(r, r)/2/pi, long_frac_ratio=2))
2429     \frac{\int r\, dr}{2 \pi}
2430     >>> print(latex(Integral(r, r)/2/pi, long_frac_ratio=0))
2431     \frac{1}{2 \pi} \int r\, dr
2432 
2433     Multiplication options:
2434 
2435     >>> print(latex((2*tau)**sin(Rational(7,2)), mul_symbol="times"))
2436     \left(2 \times \tau\right)^{\sin{\left(\frac{7}{2} \right)}}
2437 
2438     Trig options:
2439 
2440     >>> print(latex(asin(Rational(7,2))))
2441     \operatorname{asin}{\left(\frac{7}{2} \right)}
2442     >>> print(latex(asin(Rational(7,2)), inv_trig_style="full"))
2443     \arcsin{\left(\frac{7}{2} \right)}
2444     >>> print(latex(asin(Rational(7,2)), inv_trig_style="power"))
2445     \sin^{-1}{\left(\frac{7}{2} \right)}
2446 
2447     Matrix options:
2448 
2449     >>> print(latex(Matrix(2, 1, [x, y])))
2450     \left[\begin{matrix}x\\y\end{matrix}\right]
2451     >>> print(latex(Matrix(2, 1, [x, y]), mat_str = "array"))
2452     \left[\begin{array}{c}x\\y\end{array}\right]
2453     >>> print(latex(Matrix(2, 1, [x, y]), mat_delim="("))
2454     \left(\begin{matrix}x\\y\end{matrix}\right)
2455 
2456     Custom printing of symbols:
2457 
2458     >>> print(latex(x**2, symbol_names={x: 'x_i'}))
2459     x_i^{2}
2460 
2461     Logarithms:
2462 
2463     >>> print(latex(log(10)))
2464     \log{\left(10 \right)}
2465     >>> print(latex(log(10), ln_notation=True))
2466     \ln{\left(10 \right)}
2467 
2468     ``latex()`` also supports the builtin container types list, tuple, and
2469     dictionary.
2470 
2471     >>> print(latex([2/x, y], mode='inline'))
2472     $\left[ 2 / x, \  y\right]$
2473 
2474     """
2475     if symbol_names is None:
2476         symbol_names = {}
2477 
2478     settings = {
2479         'fold_frac_powers' : fold_frac_powers,
2480         'fold_func_brackets' : fold_func_brackets,
2481         'fold_short_frac' : fold_short_frac,
2482         'inv_trig_style' : inv_trig_style,
2483         'itex' : itex,
2484         'ln_notation' : ln_notation,
2485         'long_frac_ratio' : long_frac_ratio,
2486         'mat_delim' : mat_delim,
2487         'mat_str' : mat_str,
2488         'mode' : mode,
2489         'mul_symbol' : mul_symbol,
2490         'order' : order,
2491         'symbol_names' : symbol_names,
2492         'root_notation' : root_notation,
2493         'mat_symbol_style' : mat_symbol_style,
2494         'imaginary_unit' : imaginary_unit,
2495     }
2496 
2497     return LatexPrinter(settings).doprint(expr)
2498 
2499 
2500 def print_latex(expr, **settings):
2501     """Prints LaTeX representation of the given expression. Takes the same
2502     settings as ``latex()``."""
2503     print(latex(expr, **settings))

</code><intended_behavior>Given that LaTeX printing is a significant part of SymPy's output capabilities, ensuring that this module can handle and correctly print the SymPy representations of Mathematica matrices and arrays is essential. This might involve modifying or extending the LaTeX printer to detect when a matrix or array (possibly parsed from Mathematica syntax) is being printed and applying the correct formatting so that the output resembles or is compatible with Mathematica's own representation, or more generally, is mathematically accurate. If necessary, specific case handling for arrays and matrices originating from Mathematica syntax might be added to preserve the fidelity of the original expressions.</intended_behavior>]
2025-10-16 02:41:59.446 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-16 02:41:59.447 | INFO     | Search-only: skipping patch selection
2025-10-16 02:41:59.528 | INFO     | Task sympy__sympy-16221 completed successfully.
2025-10-16 02:41:59.529 | INFO     | No patch generated. You can try running ACR again.
