diff --git a/galleries/examples/misc/demo_ribbon_box.py b/galleries/examples/misc/demo_ribbon_box.py
--- a/galleries/examples/misc/demo_ribbon_box.py
+++ b/galleries/examples/misc/demo_ribbon_box.py
@@ -86,7 +86,7 @@ def main():
     background_gradient[:, :, :3] = [1, 1, 0]
     background_gradient[:, :, 3] = [[0.1, 0.3], [0.3, 0.5]]  # alpha channel
     ax.imshow(background_gradient, interpolation="bicubic", zorder=0.1,
-              extent=(0, 1, 0, 1), transform=ax.transAxes, aspect="auto")
+              extent=(0, 1, 0, 1), transform=ax.transAxes)
 
     plt.show()
 
diff --git a/lib/matplotlib/axes/_axes.py b/lib/matplotlib/axes/_axes.py
--- a/lib/matplotlib/axes/_axes.py
+++ b/lib/matplotlib/axes/_axes.py
@@ -5530,12 +5530,12 @@ def imshow(self, X, cmap=None, norm=None, *, aspect=None,
 
         The input may either be actual RGB(A) data, or 2D scalar data, which
         will be rendered as a pseudocolor image. For displaying a grayscale
-        image set up the colormapping using the parameters
+        image, set up the colormapping using the parameters
         ``cmap='gray', vmin=0, vmax=255``.
 
         The number of pixels used to render an image is set by the Axes size
-        and the *dpi* of the figure. This can lead to aliasing artifacts when
-        the image is resampled because the displayed image size will usually
+        and the figure *dpi*. This can lead to aliasing artifacts when
+        the image is resampled, because the displayed image size will usually
         not match the size of *X* (see
         :doc:`/gallery/images_contours_and_fields/image_antialiasing`).
         The resampling can be controlled via the *interpolation* parameter
@@ -5570,7 +5570,7 @@ def imshow(self, X, cmap=None, norm=None, *, aspect=None,
 
             This parameter is ignored if *X* is RGB(A).
 
-        aspect : {'equal', 'auto'} or float, default: :rc:`image.aspect`
+        aspect : {'equal', 'auto'} or float or None, default: None
             The aspect ratio of the Axes.  This parameter is particularly
             relevant for images since it determines whether data pixels are
             square.
@@ -5585,6 +5585,11 @@ def imshow(self, X, cmap=None, norm=None, *, aspect=None,
               that the data fit in the Axes. In general, this will result in
               non-square pixels.
 
+            Normally, None (the default) means to use :rc:`image.aspect`.  However, if
+            the image uses a transform that does not contain the axes data transform,
+            then None means to not modify the axes aspect at all (in that case, directly
+            call `.Axes.set_aspect` if desired).
+
         interpolation : str, default: :rc:`image.interpolation`
             The interpolation method used.
 
@@ -5718,9 +5723,6 @@ def imshow(self, X, cmap=None, norm=None, *, aspect=None,
         `~matplotlib.pyplot.imshow` expects RGB images adopting the straight
         (unassociated) alpha representation.
         """
-        if aspect is None:
-            aspect = mpl.rcParams['image.aspect']
-        self.set_aspect(aspect)
         im = mimage.AxesImage(self, cmap=cmap, norm=norm,
                               interpolation=interpolation, origin=origin,
                               extent=extent, filternorm=filternorm,
@@ -5728,6 +5730,13 @@ def imshow(self, X, cmap=None, norm=None, *, aspect=None,
                               interpolation_stage=interpolation_stage,
                               **kwargs)
 
+        if aspect is None and not (
+                im.is_transform_set()
+                and not im.get_transform().contains_branch(self.transData)):
+            aspect = mpl.rcParams['image.aspect']
+        if aspect is not None:
+            self.set_aspect(aspect)
+
         im.set_data(X)
         im.set_alpha(alpha)
         if im.get_clip_path() is None:
