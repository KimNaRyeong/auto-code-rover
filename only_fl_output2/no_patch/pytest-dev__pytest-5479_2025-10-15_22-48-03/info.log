2025-10-15 22:48:03.776 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-15 22:48:06.077 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=167, output_tokens=12, cost=0.002030
2025-10-15 22:48:19.300 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=347, output_tokens=493, cost=0.018260
2025-10-15 22:48:20.309 | INFO     | registered non reproducing test 0
2025-10-15 22:48:33.133 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1189, output_tokens=602, cost=0.029950
2025-10-15 22:48:34.099 | INFO     | registered non reproducing test 1
2025-10-15 22:48:46.996 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1219, output_tokens=595, cost=0.030040
2025-10-15 22:48:47.968 | INFO     | registered non reproducing test 2
2025-10-15 22:48:47.968 | WARNING  | Failed to write a reproducer test; skipping reproducer tracing
2025-10-15 22:48:47.975 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 22:48:53.824 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=474, output_tokens=210, cost=0.011040
2025-10-15 22:48:53.830 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 22:48:55.673 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=564, output_tokens=45, cost=0.006990
2025-10-15 22:48:55.675 | DEBUG    | Extracted a valid json.
2025-10-15 22:48:55.675 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_method(\"raises\")",
        "search_code(\"with pytest.raises\")",
        "search_code(\"\\u2603\")"
    ],
    "bug_locations": []
}
2025-10-15 22:48:55.773 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-15 22:48:55.773 | DEBUG    | <Agent search> Analyzing search results.
2025-10-15 22:49:11.593 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3070, output_tokens=762, cost=0.053560
2025-10-15 22:49:11.608 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 22:49:16.759 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=4048, output_tokens=166, cost=0.045460
2025-10-15 22:49:16.766 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 22:49:22.959 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=520, output_tokens=180, cost=0.010600
2025-10-15 22:49:22.960 | DEBUG    | Extracted a valid json.
2025-10-15 22:49:22.960 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "src/_pytest/python_api.py",
            "function": "raises",
            "intended_behavior": "The function `raises` should properly handle Unicode character comparisons in Python 2 without triggering a `UnicodeEncodeError`. When the `match` keyword is used with a Unicode regular expression pattern, the function should ensure that both the error message from the raised exception and the provided `match` pattern are appropriately encoded or decoded to avoid encoding incompatibilities. This correction must not alter the function's ability to handle ASCII or Unicode matches in either Python 2 or Python 3. The implementation should include checking the Python version and performing the necessary encoding/decoding operations only when required (i.e., under Python 2), ensuring that the functionality is preserved across different versions."
        }
    ]
}
2025-10-15 22:49:22.966 | DEBUG    | Bug location extracted successfully: [<file>src/_pytest/python_api.py</file>
<class>None</class>
<method>None</method>
<code>
1 # -*- coding: utf-8 -*-
2 from __future__ import absolute_import
3 
4 import math
5 import pprint
6 import sys
7 import warnings
8 from decimal import Decimal
9 from numbers import Number
10 
11 from more_itertools.more import always_iterable
12 from six.moves import filterfalse
13 from six.moves import zip
14 
15 import _pytest._code
16 from _pytest import deprecated
17 from _pytest.compat import isclass
18 from _pytest.compat import Iterable
19 from _pytest.compat import Mapping
20 from _pytest.compat import Sized
21 from _pytest.compat import STRING_TYPES
22 from _pytest.outcomes import fail
23 
24 BASE_TYPE = (type, STRING_TYPES)
25 
26 
27 def _cmp_raises_type_error(self, other):
28     """__cmp__ implementation which raises TypeError. Used
29     by Approx base classes to implement only == and != and raise a
30     TypeError for other comparisons.
31 
32     Needed in Python 2 only, Python 3 all it takes is not implementing the
33     other operators at all.
34     """
35     __tracebackhide__ = True
36     raise TypeError(
37         "Comparison operators other than == and != not supported by approx objects"
38     )
39 
40 
41 def _non_numeric_type_error(value, at):
42     at_str = " at {}".format(at) if at else ""
43     return TypeError(
44         "cannot make approximate comparisons to non-numeric values: {!r} {}".format(
45             value, at_str
46         )
47     )
48 
49 
50 # builtin pytest.approx helper
51 
52 
53 class ApproxBase(object):
54     """
55     Provide shared utilities for making approximate comparisons between numbers
56     or sequences of numbers.
57     """
58 
59     # Tell numpy to use our `__eq__` operator instead of its.
60     __array_ufunc__ = None
61     __array_priority__ = 100
62 
63     def __init__(self, expected, rel=None, abs=None, nan_ok=False):
64         __tracebackhide__ = True
65         self.expected = expected
66         self.abs = abs
67         self.rel = rel
68         self.nan_ok = nan_ok
69         self._check_type()
70 
71     def __repr__(self):
72         raise NotImplementedError
73 
74     def __eq__(self, actual):
75         return all(
76             a == self._approx_scalar(x) for a, x in self._yield_comparisons(actual)
77         )
78 
79     __hash__ = None
80 
81     def __ne__(self, actual):
82         return not (actual == self)
83 
84     if sys.version_info[0] == 2:
85         __cmp__ = _cmp_raises_type_error
86 
87     def _approx_scalar(self, x):
88         return ApproxScalar(x, rel=self.rel, abs=self.abs, nan_ok=self.nan_ok)
89 
90     def _yield_comparisons(self, actual):
91         """
92         Yield all the pairs of numbers to be compared.  This is used to
93         implement the `__eq__` method.
94         """
95         raise NotImplementedError
96 
97     def _check_type(self):
98         """
99         Raise a TypeError if the expected value is not a valid type.
100         """
101         # This is only a concern if the expected value is a sequence.  In every
102         # other case, the approx() function ensures that the expected value has
103         # a numeric type.  For this reason, the default is to do nothing.  The
104         # classes that deal with sequences should reimplement this method to
105         # raise if there are any non-numeric elements in the sequence.
106         pass
107 
108 
109 def _recursive_list_map(f, x):
110     if isinstance(x, list):
111         return list(_recursive_list_map(f, xi) for xi in x)
112     else:
113         return f(x)
114 
115 
116 class ApproxNumpy(ApproxBase):
117     """
118     Perform approximate comparisons where the expected value is numpy array.
119     """
120 
121     def __repr__(self):
122         list_scalars = _recursive_list_map(self._approx_scalar, self.expected.tolist())
123         return "approx({!r})".format(list_scalars)
124 
125     if sys.version_info[0] == 2:
126         __cmp__ = _cmp_raises_type_error
127 
128     def __eq__(self, actual):
129         import numpy as np
130 
131         # self.expected is supposed to always be an array here
132 
133         if not np.isscalar(actual):
134             try:
135                 actual = np.asarray(actual)
136             except:  # noqa
137                 raise TypeError("cannot compare '{}' to numpy.ndarray".format(actual))
138 
139         if not np.isscalar(actual) and actual.shape != self.expected.shape:
140             return False
141 
142         return ApproxBase.__eq__(self, actual)
143 
144     def _yield_comparisons(self, actual):
145         import numpy as np
146 
147         # `actual` can either be a numpy array or a scalar, it is treated in
148         # `__eq__` before being passed to `ApproxBase.__eq__`, which is the
149         # only method that calls this one.
150 
151         if np.isscalar(actual):
152             for i in np.ndindex(self.expected.shape):
153                 yield actual, self.expected[i].item()
154         else:
155             for i in np.ndindex(self.expected.shape):
156                 yield actual[i].item(), self.expected[i].item()
157 
158 
159 class ApproxMapping(ApproxBase):
160     """
161     Perform approximate comparisons where the expected value is a mapping with
162     numeric values (the keys can be anything).
163     """
164 
165     def __repr__(self):
166         return "approx({!r})".format(
167             {k: self._approx_scalar(v) for k, v in self.expected.items()}
168         )
169 
170     def __eq__(self, actual):
171         if set(actual.keys()) != set(self.expected.keys()):
172             return False
173 
174         return ApproxBase.__eq__(self, actual)
175 
176     def _yield_comparisons(self, actual):
177         for k in self.expected.keys():
178             yield actual[k], self.expected[k]
179 
180     def _check_type(self):
181         __tracebackhide__ = True
182         for key, value in self.expected.items():
183             if isinstance(value, type(self.expected)):
184                 msg = "pytest.approx() does not support nested dictionaries: key={!r} value={!r}\n  full mapping={}"
185                 raise TypeError(msg.format(key, value, pprint.pformat(self.expected)))
186             elif not isinstance(value, Number):
187                 raise _non_numeric_type_error(self.expected, at="key={!r}".format(key))
188 
189 
190 class ApproxSequencelike(ApproxBase):
191     """
192     Perform approximate comparisons where the expected value is a sequence of
193     numbers.
194     """
195 
196     def __repr__(self):
197         seq_type = type(self.expected)
198         if seq_type not in (tuple, list, set):
199             seq_type = list
200         return "approx({!r})".format(
201             seq_type(self._approx_scalar(x) for x in self.expected)
202         )
203 
204     def __eq__(self, actual):
205         if len(actual) != len(self.expected):
206             return False
207         return ApproxBase.__eq__(self, actual)
208 
209     def _yield_comparisons(self, actual):
210         return zip(actual, self.expected)
211 
212     def _check_type(self):
213         __tracebackhide__ = True
214         for index, x in enumerate(self.expected):
215             if isinstance(x, type(self.expected)):
216                 msg = "pytest.approx() does not support nested data structures: {!r} at index {}\n  full sequence: {}"
217                 raise TypeError(msg.format(x, index, pprint.pformat(self.expected)))
218             elif not isinstance(x, Number):
219                 raise _non_numeric_type_error(
220                     self.expected, at="index {}".format(index)
221                 )
222 
223 
224 class ApproxScalar(ApproxBase):
225     """
226     Perform approximate comparisons where the expected value is a single number.
227     """
228 
229     DEFAULT_ABSOLUTE_TOLERANCE = 1e-12
230     DEFAULT_RELATIVE_TOLERANCE = 1e-6
231 
232     def __repr__(self):
233         """
234         Return a string communicating both the expected value and the tolerance
235         for the comparison being made, e.g. '1.0 +- 1e-6'.  Use the unicode
236         plus/minus symbol if this is python3 (it's too hard to get right for
237         python2).
238         """
239         if isinstance(self.expected, complex):
240             return str(self.expected)
241 
242         # Infinities aren't compared using tolerances, so don't show a
243         # tolerance.
244         if math.isinf(self.expected):
245             return str(self.expected)
246 
247         # If a sensible tolerance can't be calculated, self.tolerance will
248         # raise a ValueError.  In this case, display '???'.
249         try:
250             vetted_tolerance = "{:.1e}".format(self.tolerance)
251         except ValueError:
252             vetted_tolerance = "???"
253 
254         if sys.version_info[0] == 2:
255             return "{} +- {}".format(self.expected, vetted_tolerance)
256         else:
257             return u"{} \u00b1 {}".format(self.expected, vetted_tolerance)
258 
259     def __eq__(self, actual):
260         """
261         Return true if the given value is equal to the expected value within
262         the pre-specified tolerance.
263         """
264         if _is_numpy_array(actual):
265             # Call ``__eq__()`` manually to prevent infinite-recursion with
266             # numpy<1.13.  See #3748.
267             return all(self.__eq__(a) for a in actual.flat)
268 
269         # Short-circuit exact equality.
270         if actual == self.expected:
271             return True
272 
273         # Allow the user to control whether NaNs are considered equal to each
274         # other or not.  The abs() calls are for compatibility with complex
275         # numbers.
276         if math.isnan(abs(self.expected)):
277             return self.nan_ok and math.isnan(abs(actual))
278 
279         # Infinity shouldn't be approximately equal to anything but itself, but
280         # if there's a relative tolerance, it will be infinite and infinity
281         # will seem approximately equal to everything.  The equal-to-itself
282         # case would have been short circuited above, so here we can just
283         # return false if the expected value is infinite.  The abs() call is
284         # for compatibility with complex numbers.
285         if math.isinf(abs(self.expected)):
286             return False
287 
288         # Return true if the two numbers are within the tolerance.
289         return abs(self.expected - actual) <= self.tolerance
290 
291     __hash__ = None
292 
293     @property
294     def tolerance(self):
295         """
296         Return the tolerance for the comparison.  This could be either an
297         absolute tolerance or a relative tolerance, depending on what the user
298         specified or which would be larger.
299         """
300 
301         def set_default(x, default):
302             return x if x is not None else default
303 
304         # Figure out what the absolute tolerance should be.  ``self.abs`` is
305         # either None or a value specified by the user.
306         absolute_tolerance = set_default(self.abs, self.DEFAULT_ABSOLUTE_TOLERANCE)
307 
308         if absolute_tolerance < 0:
309             raise ValueError(
310                 "absolute tolerance can't be negative: {}".format(absolute_tolerance)
311             )
312         if math.isnan(absolute_tolerance):
313             raise ValueError("absolute tolerance can't be NaN.")
314 
315         # If the user specified an absolute tolerance but not a relative one,
316         # just return the absolute tolerance.
317         if self.rel is None:
318             if self.abs is not None:
319                 return absolute_tolerance
320 
321         # Figure out what the relative tolerance should be.  ``self.rel`` is
322         # either None or a value specified by the user.  This is done after
323         # we've made sure the user didn't ask for an absolute tolerance only,
324         # because we don't want to raise errors about the relative tolerance if
325         # we aren't even going to use it.
326         relative_tolerance = set_default(
327             self.rel, self.DEFAULT_RELATIVE_TOLERANCE
328         ) * abs(self.expected)
329 
330         if relative_tolerance < 0:
331             raise ValueError(
332                 "relative tolerance can't be negative: {}".format(absolute_tolerance)
333             )
334         if math.isnan(relative_tolerance):
335             raise ValueError("relative tolerance can't be NaN.")
336 
337         # Return the larger of the relative and absolute tolerances.
338         return max(relative_tolerance, absolute_tolerance)
339 
340 
341 class ApproxDecimal(ApproxScalar):
342     """
343     Perform approximate comparisons where the expected value is a decimal.
344     """
345 
346     DEFAULT_ABSOLUTE_TOLERANCE = Decimal("1e-12")
347     DEFAULT_RELATIVE_TOLERANCE = Decimal("1e-6")
348 
349 
350 def approx(expected, rel=None, abs=None, nan_ok=False):
351     """
352     Assert that two numbers (or two sets of numbers) are equal to each other
353     within some tolerance.
354 
355     Due to the `intricacies of floating-point arithmetic`__, numbers that we
356     would intuitively expect to be equal are not always so::
357 
358         >>> 0.1 + 0.2 == 0.3
359         False
360 
361     __ https://docs.python.org/3/tutorial/floatingpoint.html
362 
363     This problem is commonly encountered when writing tests, e.g. when making
364     sure that floating-point values are what you expect them to be.  One way to
365     deal with this problem is to assert that two floating-point numbers are
366     equal to within some appropriate tolerance::
367 
368         >>> abs((0.1 + 0.2) - 0.3) < 1e-6
369         True
370 
371     However, comparisons like this are tedious to write and difficult to
372     understand.  Furthermore, absolute comparisons like the one above are
373     usually discouraged because there's no tolerance that works well for all
374     situations.  ``1e-6`` is good for numbers around ``1``, but too small for
375     very big numbers and too big for very small ones.  It's better to express
376     the tolerance as a fraction of the expected value, but relative comparisons
377     like that are even more difficult to write correctly and concisely.
378 
379     The ``approx`` class performs floating-point comparisons using a syntax
380     that's as intuitive as possible::
381 
382         >>> from pytest import approx
383         >>> 0.1 + 0.2 == approx(0.3)
384         True
385 
386     The same syntax also works for sequences of numbers::
387 
388         >>> (0.1 + 0.2, 0.2 + 0.4) == approx((0.3, 0.6))
389         True
390 
391     Dictionary *values*::
392 
393         >>> {'a': 0.1 + 0.2, 'b': 0.2 + 0.4} == approx({'a': 0.3, 'b': 0.6})
394         True
395 
396     ``numpy`` arrays::
397 
398         >>> import numpy as np                                                          # doctest: +SKIP
399         >>> np.array([0.1, 0.2]) + np.array([0.2, 0.4]) == approx(np.array([0.3, 0.6])) # doctest: +SKIP
400         True
401 
402     And for a ``numpy`` array against a scalar::
403 
404         >>> import numpy as np                                         # doctest: +SKIP
405         >>> np.array([0.1, 0.2]) + np.array([0.2, 0.1]) == approx(0.3) # doctest: +SKIP
406         True
407 
408     By default, ``approx`` considers numbers within a relative tolerance of
409     ``1e-6`` (i.e. one part in a million) of its expected value to be equal.
410     This treatment would lead to surprising results if the expected value was
411     ``0.0``, because nothing but ``0.0`` itself is relatively close to ``0.0``.
412     To handle this case less surprisingly, ``approx`` also considers numbers
413     within an absolute tolerance of ``1e-12`` of its expected value to be
414     equal.  Infinity and NaN are special cases.  Infinity is only considered
415     equal to itself, regardless of the relative tolerance.  NaN is not
416     considered equal to anything by default, but you can make it be equal to
417     itself by setting the ``nan_ok`` argument to True.  (This is meant to
418     facilitate comparing arrays that use NaN to mean "no data".)
419 
420     Both the relative and absolute tolerances can be changed by passing
421     arguments to the ``approx`` constructor::
422 
423         >>> 1.0001 == approx(1)
424         False
425         >>> 1.0001 == approx(1, rel=1e-3)
426         True
427         >>> 1.0001 == approx(1, abs=1e-3)
428         True
429 
430     If you specify ``abs`` but not ``rel``, the comparison will not consider
431     the relative tolerance at all.  In other words, two numbers that are within
432     the default relative tolerance of ``1e-6`` will still be considered unequal
433     if they exceed the specified absolute tolerance.  If you specify both
434     ``abs`` and ``rel``, the numbers will be considered equal if either
435     tolerance is met::
436 
437         >>> 1 + 1e-8 == approx(1)
438         True
439         >>> 1 + 1e-8 == approx(1, abs=1e-12)
440         False
441         >>> 1 + 1e-8 == approx(1, rel=1e-6, abs=1e-12)
442         True
443 
444     If you're thinking about using ``approx``, then you might want to know how
445     it compares to other good ways of comparing floating-point numbers.  All of
446     these algorithms are based on relative and absolute tolerances and should
447     agree for the most part, but they do have meaningful differences:
448 
449     - ``math.isclose(a, b, rel_tol=1e-9, abs_tol=0.0)``:  True if the relative
450       tolerance is met w.r.t. either ``a`` or ``b`` or if the absolute
451       tolerance is met.  Because the relative tolerance is calculated w.r.t.
452       both ``a`` and ``b``, this test is symmetric (i.e.  neither ``a`` nor
453       ``b`` is a "reference value").  You have to specify an absolute tolerance
454       if you want to compare to ``0.0`` because there is no tolerance by
455       default.  Only available in python>=3.5.  `More information...`__
456 
457       __ https://docs.python.org/3/library/math.html#math.isclose
458 
459     - ``numpy.isclose(a, b, rtol=1e-5, atol=1e-8)``: True if the difference
460       between ``a`` and ``b`` is less that the sum of the relative tolerance
461       w.r.t. ``b`` and the absolute tolerance.  Because the relative tolerance
462       is only calculated w.r.t. ``b``, this test is asymmetric and you can
463       think of ``b`` as the reference value.  Support for comparing sequences
464       is provided by ``numpy.allclose``.  `More information...`__
465 
466       __ http://docs.scipy.org/doc/numpy-1.10.0/reference/generated/numpy.isclose.html
467 
468     - ``unittest.TestCase.assertAlmostEqual(a, b)``: True if ``a`` and ``b``
469       are within an absolute tolerance of ``1e-7``.  No relative tolerance is
470       considered and the absolute tolerance cannot be changed, so this function
471       is not appropriate for very large or very small numbers.  Also, it's only
472       available in subclasses of ``unittest.TestCase`` and it's ugly because it
473       doesn't follow PEP8.  `More information...`__
474 
475       __ https://docs.python.org/3/library/unittest.html#unittest.TestCase.assertAlmostEqual
476 
477     - ``a == pytest.approx(b, rel=1e-6, abs=1e-12)``: True if the relative
478       tolerance is met w.r.t. ``b`` or if the absolute tolerance is met.
479       Because the relative tolerance is only calculated w.r.t. ``b``, this test
480       is asymmetric and you can think of ``b`` as the reference value.  In the
481       special case that you explicitly specify an absolute tolerance but not a
482       relative tolerance, only the absolute tolerance is considered.
483 
484     .. warning::
485 
486        .. versionchanged:: 3.2
487 
488        In order to avoid inconsistent behavior, ``TypeError`` is
489        raised for ``>``, ``>=``, ``<`` and ``<=`` comparisons.
490        The example below illustrates the problem::
491 
492            assert approx(0.1) > 0.1 + 1e-10  # calls approx(0.1).__gt__(0.1 + 1e-10)
493            assert 0.1 + 1e-10 > approx(0.1)  # calls approx(0.1).__lt__(0.1 + 1e-10)
494 
495        In the second example one expects ``approx(0.1).__le__(0.1 + 1e-10)``
496        to be called. But instead, ``approx(0.1).__lt__(0.1 + 1e-10)`` is used to
497        comparison. This is because the call hierarchy of rich comparisons
498        follows a fixed behavior. `More information...`__
499 
500        __ https://docs.python.org/3/reference/datamodel.html#object.__ge__
501     """
502 
503     # Delegate the comparison to a class that knows how to deal with the type
504     # of the expected value (e.g. int, float, list, dict, numpy.array, etc).
505     #
506     # The primary responsibility of these classes is to implement ``__eq__()``
507     # and ``__repr__()``.  The former is used to actually check if some
508     # "actual" value is equivalent to the given expected value within the
509     # allowed tolerance.  The latter is used to show the user the expected
510     # value and tolerance, in the case that a test failed.
511     #
512     # The actual logic for making approximate comparisons can be found in
513     # ApproxScalar, which is used to compare individual numbers.  All of the
514     # other Approx classes eventually delegate to this class.  The ApproxBase
515     # class provides some convenient methods and overloads, but isn't really
516     # essential.
517 
518     __tracebackhide__ = True
519 
520     if isinstance(expected, Decimal):
521         cls = ApproxDecimal
522     elif isinstance(expected, Number):
523         cls = ApproxScalar
524     elif isinstance(expected, Mapping):
525         cls = ApproxMapping
526     elif _is_numpy_array(expected):
527         cls = ApproxNumpy
528     elif (
529         isinstance(expected, Iterable)
530         and isinstance(expected, Sized)
531         and not isinstance(expected, STRING_TYPES)
532     ):
533         cls = ApproxSequencelike
534     else:
535         raise _non_numeric_type_error(expected, at=None)
536 
537     return cls(expected, rel, abs, nan_ok)
538 
539 
540 def _is_numpy_array(obj):
541     """
542     Return true if the given object is a numpy array.  Make a special effort to
543     avoid importing numpy unless it's really necessary.
544     """
545     import sys
546 
547     np = sys.modules.get("numpy")
548     if np is not None:
549         return isinstance(obj, np.ndarray)
550     return False
551 
552 
553 # builtin pytest.raises helper
554 
555 
556 def raises(expected_exception, *args, **kwargs):
557     r"""
558     Assert that a code block/function call raises ``expected_exception``
559     or raise a failure exception otherwise.
560 
561     :kwparam match: if specified, a string containing a regular expression,
562         or a regular expression object, that is tested against the string
563         representation of the exception using ``re.search``. To match a literal
564         string that may contain `special characters`__, the pattern can
565         first be escaped with ``re.escape``.
566 
567     __ https://docs.python.org/3/library/re.html#regular-expression-syntax
568 
569     :kwparam message: **(deprecated since 4.1)** if specified, provides a custom failure message
570         if the exception is not raised. See :ref:`the deprecation docs <raises message deprecated>` for a workaround.
571 
572     .. currentmodule:: _pytest._code
573 
574     Use ``pytest.raises`` as a context manager, which will capture the exception of the given
575     type::
576 
577         >>> with raises(ZeroDivisionError):
578         ...    1/0
579 
580     If the code block does not raise the expected exception (``ZeroDivisionError`` in the example
581     above), or no exception at all, the check will fail instead.
582 
583     You can also use the keyword argument ``match`` to assert that the
584     exception matches a text or regex::
585 
586         >>> with raises(ValueError, match='must be 0 or None'):
587         ...     raise ValueError("value must be 0 or None")
588 
589         >>> with raises(ValueError, match=r'must be \d+$'):
590         ...     raise ValueError("value must be 42")
591 
592     The context manager produces an :class:`ExceptionInfo` object which can be used to inspect the
593     details of the captured exception::
594 
595         >>> with raises(ValueError) as exc_info:
596         ...     raise ValueError("value must be 42")
597         >>> assert exc_info.type is ValueError
598         >>> assert exc_info.value.args[0] == "value must be 42"
599 
600     .. deprecated:: 4.1
601 
602         In the context manager form you may use the keyword argument
603         ``message`` to specify a custom failure message that will be displayed
604         in case the ``pytest.raises`` check fails. This has been deprecated as it
605         is considered error prone as users often mean to use ``match`` instead.
606         See :ref:`the deprecation docs <raises message deprecated>` for a workaround.
607 
608     .. note::
609 
610        When using ``pytest.raises`` as a context manager, it's worthwhile to
611        note that normal context manager rules apply and that the exception
612        raised *must* be the final line in the scope of the context manager.
613        Lines of code after that, within the scope of the context manager will
614        not be executed. For example::
615 
616            >>> value = 15
617            >>> with raises(ValueError) as exc_info:
618            ...     if value > 10:
619            ...         raise ValueError("value must be <= 10")
620            ...     assert exc_info.type is ValueError  # this will not execute
621 
622        Instead, the following approach must be taken (note the difference in
623        scope)::
624 
625            >>> with raises(ValueError) as exc_info:
626            ...     if value > 10:
627            ...         raise ValueError("value must be <= 10")
628            ...
629            >>> assert exc_info.type is ValueError
630 
631     **Using with** ``pytest.mark.parametrize``
632 
633     When using :ref:`pytest.mark.parametrize ref`
634     it is possible to parametrize tests such that
635     some runs raise an exception and others do not.
636 
637     See :ref:`parametrizing_conditional_raising` for an example.
638 
639     **Legacy form**
640 
641     It is possible to specify a callable by passing a to-be-called lambda::
642 
643         >>> raises(ZeroDivisionError, lambda: 1/0)
644         <ExceptionInfo ...>
645 
646     or you can specify an arbitrary callable with arguments::
647 
648         >>> def f(x): return 1/x
649         ...
650         >>> raises(ZeroDivisionError, f, 0)
651         <ExceptionInfo ...>
652         >>> raises(ZeroDivisionError, f, x=0)
653         <ExceptionInfo ...>
654 
655     The form above is fully supported but discouraged for new code because the
656     context manager form is regarded as more readable and less error-prone.
657 
658     .. note::
659         Similar to caught exception objects in Python, explicitly clearing
660         local references to returned ``ExceptionInfo`` objects can
661         help the Python interpreter speed up its garbage collection.
662 
663         Clearing those references breaks a reference cycle
664         (``ExceptionInfo`` --> caught exception --> frame stack raising
665         the exception --> current frame stack --> local variables -->
666         ``ExceptionInfo``) which makes Python keep all objects referenced
667         from that cycle (including all local variables in the current
668         frame) alive until the next cyclic garbage collection run. See the
669         official Python ``try`` statement documentation for more detailed
670         information.
671 
672     """
673     __tracebackhide__ = True
674     for exc in filterfalse(isclass, always_iterable(expected_exception, BASE_TYPE)):
675         msg = (
676             "exceptions must be old-style classes or"
677             " derived from BaseException, not %s"
678         )
679         raise TypeError(msg % type(exc))
680 
681     message = "DID NOT RAISE {}".format(expected_exception)
682     match_expr = None
683 
684     if not args:
685         if "message" in kwargs:
686             message = kwargs.pop("message")
687             warnings.warn(deprecated.RAISES_MESSAGE_PARAMETER, stacklevel=2)
688         if "match" in kwargs:
689             match_expr = kwargs.pop("match")
690         if kwargs:
691             msg = "Unexpected keyword arguments passed to pytest.raises: "
692             msg += ", ".join(sorted(kwargs))
693             raise TypeError(msg)
694         return RaisesContext(expected_exception, message, match_expr)
695     elif isinstance(args[0], str):
696         warnings.warn(deprecated.RAISES_EXEC, stacklevel=2)
697         code, = args
698         assert isinstance(code, str)
699         frame = sys._getframe(1)
700         loc = frame.f_locals.copy()
701         loc.update(kwargs)
702         # print "raises frame scope: %r" % frame.f_locals
703         try:
704             code = _pytest._code.Source(code).compile(_genframe=frame)
705             exec(code, frame.f_globals, loc)
706             # XXX didn't mean f_globals == f_locals something special?
707             #     this is destroyed here ...
708         except expected_exception:
709             return _pytest._code.ExceptionInfo.from_current()
710     else:
711         func = args[0]
712         try:
713             func(*args[1:], **kwargs)
714         except expected_exception:
715             return _pytest._code.ExceptionInfo.from_current()
716     fail(message)
717 
718 
719 raises.Exception = fail.Exception
720 
721 
722 class RaisesContext(object):
723     def __init__(self, expected_exception, message, match_expr):
724         self.expected_exception = expected_exception
725         self.message = message
726         self.match_expr = match_expr
727         self.excinfo = None
728 
729     def __enter__(self):
730         self.excinfo = _pytest._code.ExceptionInfo.for_later()
731         return self.excinfo
732 
733     def __exit__(self, *tp):
734         __tracebackhide__ = True
735         if tp[0] is None:
736             fail(self.message)
737         self.excinfo.__init__(tp)
738         suppress_exception = issubclass(self.excinfo.type, self.expected_exception)
739         if sys.version_info[0] == 2 and suppress_exception:
740             sys.exc_clear()
741         if self.match_expr is not None and suppress_exception:
742             self.excinfo.match(self.match_expr)
743         return suppress_exception

</code><intended_behavior>The function `raises` should properly handle Unicode character comparisons in Python 2 without triggering a `UnicodeEncodeError`. When the `match` keyword is used with a Unicode regular expression pattern, the function should ensure that both the error message from the raised exception and the provided `match` pattern are appropriately encoded or decoded to avoid encoding incompatibilities. This correction must not alter the function's ability to handle ASCII or Unicode matches in either Python 2 or Python 3. The implementation should include checking the Python version and performing the necessary encoding/decoding operations only when required (i.e., under Python 2), ensuring that the functionality is preserved across different versions.</intended_behavior>]
2025-10-15 22:49:22.966 | INFO     | Search completed. Bug locations: [<file>src/_pytest/python_api.py</file>
<class>None</class>
<method>None</method>
<code>
1 # -*- coding: utf-8 -*-
2 from __future__ import absolute_import
3 
4 import math
5 import pprint
6 import sys
7 import warnings
8 from decimal import Decimal
9 from numbers import Number
10 
11 from more_itertools.more import always_iterable
12 from six.moves import filterfalse
13 from six.moves import zip
14 
15 import _pytest._code
16 from _pytest import deprecated
17 from _pytest.compat import isclass
18 from _pytest.compat import Iterable
19 from _pytest.compat import Mapping
20 from _pytest.compat import Sized
21 from _pytest.compat import STRING_TYPES
22 from _pytest.outcomes import fail
23 
24 BASE_TYPE = (type, STRING_TYPES)
25 
26 
27 def _cmp_raises_type_error(self, other):
28     """__cmp__ implementation which raises TypeError. Used
29     by Approx base classes to implement only == and != and raise a
30     TypeError for other comparisons.
31 
32     Needed in Python 2 only, Python 3 all it takes is not implementing the
33     other operators at all.
34     """
35     __tracebackhide__ = True
36     raise TypeError(
37         "Comparison operators other than == and != not supported by approx objects"
38     )
39 
40 
41 def _non_numeric_type_error(value, at):
42     at_str = " at {}".format(at) if at else ""
43     return TypeError(
44         "cannot make approximate comparisons to non-numeric values: {!r} {}".format(
45             value, at_str
46         )
47     )
48 
49 
50 # builtin pytest.approx helper
51 
52 
53 class ApproxBase(object):
54     """
55     Provide shared utilities for making approximate comparisons between numbers
56     or sequences of numbers.
57     """
58 
59     # Tell numpy to use our `__eq__` operator instead of its.
60     __array_ufunc__ = None
61     __array_priority__ = 100
62 
63     def __init__(self, expected, rel=None, abs=None, nan_ok=False):
64         __tracebackhide__ = True
65         self.expected = expected
66         self.abs = abs
67         self.rel = rel
68         self.nan_ok = nan_ok
69         self._check_type()
70 
71     def __repr__(self):
72         raise NotImplementedError
73 
74     def __eq__(self, actual):
75         return all(
76             a == self._approx_scalar(x) for a, x in self._yield_comparisons(actual)
77         )
78 
79     __hash__ = None
80 
81     def __ne__(self, actual):
82         return not (actual == self)
83 
84     if sys.version_info[0] == 2:
85         __cmp__ = _cmp_raises_type_error
86 
87     def _approx_scalar(self, x):
88         return ApproxScalar(x, rel=self.rel, abs=self.abs, nan_ok=self.nan_ok)
89 
90     def _yield_comparisons(self, actual):
91         """
92         Yield all the pairs of numbers to be compared.  This is used to
93         implement the `__eq__` method.
94         """
95         raise NotImplementedError
96 
97     def _check_type(self):
98         """
99         Raise a TypeError if the expected value is not a valid type.
100         """
101         # This is only a concern if the expected value is a sequence.  In every
102         # other case, the approx() function ensures that the expected value has
103         # a numeric type.  For this reason, the default is to do nothing.  The
104         # classes that deal with sequences should reimplement this method to
105         # raise if there are any non-numeric elements in the sequence.
106         pass
107 
108 
109 def _recursive_list_map(f, x):
110     if isinstance(x, list):
111         return list(_recursive_list_map(f, xi) for xi in x)
112     else:
113         return f(x)
114 
115 
116 class ApproxNumpy(ApproxBase):
117     """
118     Perform approximate comparisons where the expected value is numpy array.
119     """
120 
121     def __repr__(self):
122         list_scalars = _recursive_list_map(self._approx_scalar, self.expected.tolist())
123         return "approx({!r})".format(list_scalars)
124 
125     if sys.version_info[0] == 2:
126         __cmp__ = _cmp_raises_type_error
127 
128     def __eq__(self, actual):
129         import numpy as np
130 
131         # self.expected is supposed to always be an array here
132 
133         if not np.isscalar(actual):
134             try:
135                 actual = np.asarray(actual)
136             except:  # noqa
137                 raise TypeError("cannot compare '{}' to numpy.ndarray".format(actual))
138 
139         if not np.isscalar(actual) and actual.shape != self.expected.shape:
140             return False
141 
142         return ApproxBase.__eq__(self, actual)
143 
144     def _yield_comparisons(self, actual):
145         import numpy as np
146 
147         # `actual` can either be a numpy array or a scalar, it is treated in
148         # `__eq__` before being passed to `ApproxBase.__eq__`, which is the
149         # only method that calls this one.
150 
151         if np.isscalar(actual):
152             for i in np.ndindex(self.expected.shape):
153                 yield actual, self.expected[i].item()
154         else:
155             for i in np.ndindex(self.expected.shape):
156                 yield actual[i].item(), self.expected[i].item()
157 
158 
159 class ApproxMapping(ApproxBase):
160     """
161     Perform approximate comparisons where the expected value is a mapping with
162     numeric values (the keys can be anything).
163     """
164 
165     def __repr__(self):
166         return "approx({!r})".format(
167             {k: self._approx_scalar(v) for k, v in self.expected.items()}
168         )
169 
170     def __eq__(self, actual):
171         if set(actual.keys()) != set(self.expected.keys()):
172             return False
173 
174         return ApproxBase.__eq__(self, actual)
175 
176     def _yield_comparisons(self, actual):
177         for k in self.expected.keys():
178             yield actual[k], self.expected[k]
179 
180     def _check_type(self):
181         __tracebackhide__ = True
182         for key, value in self.expected.items():
183             if isinstance(value, type(self.expected)):
184                 msg = "pytest.approx() does not support nested dictionaries: key={!r} value={!r}\n  full mapping={}"
185                 raise TypeError(msg.format(key, value, pprint.pformat(self.expected)))
186             elif not isinstance(value, Number):
187                 raise _non_numeric_type_error(self.expected, at="key={!r}".format(key))
188 
189 
190 class ApproxSequencelike(ApproxBase):
191     """
192     Perform approximate comparisons where the expected value is a sequence of
193     numbers.
194     """
195 
196     def __repr__(self):
197         seq_type = type(self.expected)
198         if seq_type not in (tuple, list, set):
199             seq_type = list
200         return "approx({!r})".format(
201             seq_type(self._approx_scalar(x) for x in self.expected)
202         )
203 
204     def __eq__(self, actual):
205         if len(actual) != len(self.expected):
206             return False
207         return ApproxBase.__eq__(self, actual)
208 
209     def _yield_comparisons(self, actual):
210         return zip(actual, self.expected)
211 
212     def _check_type(self):
213         __tracebackhide__ = True
214         for index, x in enumerate(self.expected):
215             if isinstance(x, type(self.expected)):
216                 msg = "pytest.approx() does not support nested data structures: {!r} at index {}\n  full sequence: {}"
217                 raise TypeError(msg.format(x, index, pprint.pformat(self.expected)))
218             elif not isinstance(x, Number):
219                 raise _non_numeric_type_error(
220                     self.expected, at="index {}".format(index)
221                 )
222 
223 
224 class ApproxScalar(ApproxBase):
225     """
226     Perform approximate comparisons where the expected value is a single number.
227     """
228 
229     DEFAULT_ABSOLUTE_TOLERANCE = 1e-12
230     DEFAULT_RELATIVE_TOLERANCE = 1e-6
231 
232     def __repr__(self):
233         """
234         Return a string communicating both the expected value and the tolerance
235         for the comparison being made, e.g. '1.0 +- 1e-6'.  Use the unicode
236         plus/minus symbol if this is python3 (it's too hard to get right for
237         python2).
238         """
239         if isinstance(self.expected, complex):
240             return str(self.expected)
241 
242         # Infinities aren't compared using tolerances, so don't show a
243         # tolerance.
244         if math.isinf(self.expected):
245             return str(self.expected)
246 
247         # If a sensible tolerance can't be calculated, self.tolerance will
248         # raise a ValueError.  In this case, display '???'.
249         try:
250             vetted_tolerance = "{:.1e}".format(self.tolerance)
251         except ValueError:
252             vetted_tolerance = "???"
253 
254         if sys.version_info[0] == 2:
255             return "{} +- {}".format(self.expected, vetted_tolerance)
256         else:
257             return u"{} \u00b1 {}".format(self.expected, vetted_tolerance)
258 
259     def __eq__(self, actual):
260         """
261         Return true if the given value is equal to the expected value within
262         the pre-specified tolerance.
263         """
264         if _is_numpy_array(actual):
265             # Call ``__eq__()`` manually to prevent infinite-recursion with
266             # numpy<1.13.  See #3748.
267             return all(self.__eq__(a) for a in actual.flat)
268 
269         # Short-circuit exact equality.
270         if actual == self.expected:
271             return True
272 
273         # Allow the user to control whether NaNs are considered equal to each
274         # other or not.  The abs() calls are for compatibility with complex
275         # numbers.
276         if math.isnan(abs(self.expected)):
277             return self.nan_ok and math.isnan(abs(actual))
278 
279         # Infinity shouldn't be approximately equal to anything but itself, but
280         # if there's a relative tolerance, it will be infinite and infinity
281         # will seem approximately equal to everything.  The equal-to-itself
282         # case would have been short circuited above, so here we can just
283         # return false if the expected value is infinite.  The abs() call is
284         # for compatibility with complex numbers.
285         if math.isinf(abs(self.expected)):
286             return False
287 
288         # Return true if the two numbers are within the tolerance.
289         return abs(self.expected - actual) <= self.tolerance
290 
291     __hash__ = None
292 
293     @property
294     def tolerance(self):
295         """
296         Return the tolerance for the comparison.  This could be either an
297         absolute tolerance or a relative tolerance, depending on what the user
298         specified or which would be larger.
299         """
300 
301         def set_default(x, default):
302             return x if x is not None else default
303 
304         # Figure out what the absolute tolerance should be.  ``self.abs`` is
305         # either None or a value specified by the user.
306         absolute_tolerance = set_default(self.abs, self.DEFAULT_ABSOLUTE_TOLERANCE)
307 
308         if absolute_tolerance < 0:
309             raise ValueError(
310                 "absolute tolerance can't be negative: {}".format(absolute_tolerance)
311             )
312         if math.isnan(absolute_tolerance):
313             raise ValueError("absolute tolerance can't be NaN.")
314 
315         # If the user specified an absolute tolerance but not a relative one,
316         # just return the absolute tolerance.
317         if self.rel is None:
318             if self.abs is not None:
319                 return absolute_tolerance
320 
321         # Figure out what the relative tolerance should be.  ``self.rel`` is
322         # either None or a value specified by the user.  This is done after
323         # we've made sure the user didn't ask for an absolute tolerance only,
324         # because we don't want to raise errors about the relative tolerance if
325         # we aren't even going to use it.
326         relative_tolerance = set_default(
327             self.rel, self.DEFAULT_RELATIVE_TOLERANCE
328         ) * abs(self.expected)
329 
330         if relative_tolerance < 0:
331             raise ValueError(
332                 "relative tolerance can't be negative: {}".format(absolute_tolerance)
333             )
334         if math.isnan(relative_tolerance):
335             raise ValueError("relative tolerance can't be NaN.")
336 
337         # Return the larger of the relative and absolute tolerances.
338         return max(relative_tolerance, absolute_tolerance)
339 
340 
341 class ApproxDecimal(ApproxScalar):
342     """
343     Perform approximate comparisons where the expected value is a decimal.
344     """
345 
346     DEFAULT_ABSOLUTE_TOLERANCE = Decimal("1e-12")
347     DEFAULT_RELATIVE_TOLERANCE = Decimal("1e-6")
348 
349 
350 def approx(expected, rel=None, abs=None, nan_ok=False):
351     """
352     Assert that two numbers (or two sets of numbers) are equal to each other
353     within some tolerance.
354 
355     Due to the `intricacies of floating-point arithmetic`__, numbers that we
356     would intuitively expect to be equal are not always so::
357 
358         >>> 0.1 + 0.2 == 0.3
359         False
360 
361     __ https://docs.python.org/3/tutorial/floatingpoint.html
362 
363     This problem is commonly encountered when writing tests, e.g. when making
364     sure that floating-point values are what you expect them to be.  One way to
365     deal with this problem is to assert that two floating-point numbers are
366     equal to within some appropriate tolerance::
367 
368         >>> abs((0.1 + 0.2) - 0.3) < 1e-6
369         True
370 
371     However, comparisons like this are tedious to write and difficult to
372     understand.  Furthermore, absolute comparisons like the one above are
373     usually discouraged because there's no tolerance that works well for all
374     situations.  ``1e-6`` is good for numbers around ``1``, but too small for
375     very big numbers and too big for very small ones.  It's better to express
376     the tolerance as a fraction of the expected value, but relative comparisons
377     like that are even more difficult to write correctly and concisely.
378 
379     The ``approx`` class performs floating-point comparisons using a syntax
380     that's as intuitive as possible::
381 
382         >>> from pytest import approx
383         >>> 0.1 + 0.2 == approx(0.3)
384         True
385 
386     The same syntax also works for sequences of numbers::
387 
388         >>> (0.1 + 0.2, 0.2 + 0.4) == approx((0.3, 0.6))
389         True
390 
391     Dictionary *values*::
392 
393         >>> {'a': 0.1 + 0.2, 'b': 0.2 + 0.4} == approx({'a': 0.3, 'b': 0.6})
394         True
395 
396     ``numpy`` arrays::
397 
398         >>> import numpy as np                                                          # doctest: +SKIP
399         >>> np.array([0.1, 0.2]) + np.array([0.2, 0.4]) == approx(np.array([0.3, 0.6])) # doctest: +SKIP
400         True
401 
402     And for a ``numpy`` array against a scalar::
403 
404         >>> import numpy as np                                         # doctest: +SKIP
405         >>> np.array([0.1, 0.2]) + np.array([0.2, 0.1]) == approx(0.3) # doctest: +SKIP
406         True
407 
408     By default, ``approx`` considers numbers within a relative tolerance of
409     ``1e-6`` (i.e. one part in a million) of its expected value to be equal.
410     This treatment would lead to surprising results if the expected value was
411     ``0.0``, because nothing but ``0.0`` itself is relatively close to ``0.0``.
412     To handle this case less surprisingly, ``approx`` also considers numbers
413     within an absolute tolerance of ``1e-12`` of its expected value to be
414     equal.  Infinity and NaN are special cases.  Infinity is only considered
415     equal to itself, regardless of the relative tolerance.  NaN is not
416     considered equal to anything by default, but you can make it be equal to
417     itself by setting the ``nan_ok`` argument to True.  (This is meant to
418     facilitate comparing arrays that use NaN to mean "no data".)
419 
420     Both the relative and absolute tolerances can be changed by passing
421     arguments to the ``approx`` constructor::
422 
423         >>> 1.0001 == approx(1)
424         False
425         >>> 1.0001 == approx(1, rel=1e-3)
426         True
427         >>> 1.0001 == approx(1, abs=1e-3)
428         True
429 
430     If you specify ``abs`` but not ``rel``, the comparison will not consider
431     the relative tolerance at all.  In other words, two numbers that are within
432     the default relative tolerance of ``1e-6`` will still be considered unequal
433     if they exceed the specified absolute tolerance.  If you specify both
434     ``abs`` and ``rel``, the numbers will be considered equal if either
435     tolerance is met::
436 
437         >>> 1 + 1e-8 == approx(1)
438         True
439         >>> 1 + 1e-8 == approx(1, abs=1e-12)
440         False
441         >>> 1 + 1e-8 == approx(1, rel=1e-6, abs=1e-12)
442         True
443 
444     If you're thinking about using ``approx``, then you might want to know how
445     it compares to other good ways of comparing floating-point numbers.  All of
446     these algorithms are based on relative and absolute tolerances and should
447     agree for the most part, but they do have meaningful differences:
448 
449     - ``math.isclose(a, b, rel_tol=1e-9, abs_tol=0.0)``:  True if the relative
450       tolerance is met w.r.t. either ``a`` or ``b`` or if the absolute
451       tolerance is met.  Because the relative tolerance is calculated w.r.t.
452       both ``a`` and ``b``, this test is symmetric (i.e.  neither ``a`` nor
453       ``b`` is a "reference value").  You have to specify an absolute tolerance
454       if you want to compare to ``0.0`` because there is no tolerance by
455       default.  Only available in python>=3.5.  `More information...`__
456 
457       __ https://docs.python.org/3/library/math.html#math.isclose
458 
459     - ``numpy.isclose(a, b, rtol=1e-5, atol=1e-8)``: True if the difference
460       between ``a`` and ``b`` is less that the sum of the relative tolerance
461       w.r.t. ``b`` and the absolute tolerance.  Because the relative tolerance
462       is only calculated w.r.t. ``b``, this test is asymmetric and you can
463       think of ``b`` as the reference value.  Support for comparing sequences
464       is provided by ``numpy.allclose``.  `More information...`__
465 
466       __ http://docs.scipy.org/doc/numpy-1.10.0/reference/generated/numpy.isclose.html
467 
468     - ``unittest.TestCase.assertAlmostEqual(a, b)``: True if ``a`` and ``b``
469       are within an absolute tolerance of ``1e-7``.  No relative tolerance is
470       considered and the absolute tolerance cannot be changed, so this function
471       is not appropriate for very large or very small numbers.  Also, it's only
472       available in subclasses of ``unittest.TestCase`` and it's ugly because it
473       doesn't follow PEP8.  `More information...`__
474 
475       __ https://docs.python.org/3/library/unittest.html#unittest.TestCase.assertAlmostEqual
476 
477     - ``a == pytest.approx(b, rel=1e-6, abs=1e-12)``: True if the relative
478       tolerance is met w.r.t. ``b`` or if the absolute tolerance is met.
479       Because the relative tolerance is only calculated w.r.t. ``b``, this test
480       is asymmetric and you can think of ``b`` as the reference value.  In the
481       special case that you explicitly specify an absolute tolerance but not a
482       relative tolerance, only the absolute tolerance is considered.
483 
484     .. warning::
485 
486        .. versionchanged:: 3.2
487 
488        In order to avoid inconsistent behavior, ``TypeError`` is
489        raised for ``>``, ``>=``, ``<`` and ``<=`` comparisons.
490        The example below illustrates the problem::
491 
492            assert approx(0.1) > 0.1 + 1e-10  # calls approx(0.1).__gt__(0.1 + 1e-10)
493            assert 0.1 + 1e-10 > approx(0.1)  # calls approx(0.1).__lt__(0.1 + 1e-10)
494 
495        In the second example one expects ``approx(0.1).__le__(0.1 + 1e-10)``
496        to be called. But instead, ``approx(0.1).__lt__(0.1 + 1e-10)`` is used to
497        comparison. This is because the call hierarchy of rich comparisons
498        follows a fixed behavior. `More information...`__
499 
500        __ https://docs.python.org/3/reference/datamodel.html#object.__ge__
501     """
502 
503     # Delegate the comparison to a class that knows how to deal with the type
504     # of the expected value (e.g. int, float, list, dict, numpy.array, etc).
505     #
506     # The primary responsibility of these classes is to implement ``__eq__()``
507     # and ``__repr__()``.  The former is used to actually check if some
508     # "actual" value is equivalent to the given expected value within the
509     # allowed tolerance.  The latter is used to show the user the expected
510     # value and tolerance, in the case that a test failed.
511     #
512     # The actual logic for making approximate comparisons can be found in
513     # ApproxScalar, which is used to compare individual numbers.  All of the
514     # other Approx classes eventually delegate to this class.  The ApproxBase
515     # class provides some convenient methods and overloads, but isn't really
516     # essential.
517 
518     __tracebackhide__ = True
519 
520     if isinstance(expected, Decimal):
521         cls = ApproxDecimal
522     elif isinstance(expected, Number):
523         cls = ApproxScalar
524     elif isinstance(expected, Mapping):
525         cls = ApproxMapping
526     elif _is_numpy_array(expected):
527         cls = ApproxNumpy
528     elif (
529         isinstance(expected, Iterable)
530         and isinstance(expected, Sized)
531         and not isinstance(expected, STRING_TYPES)
532     ):
533         cls = ApproxSequencelike
534     else:
535         raise _non_numeric_type_error(expected, at=None)
536 
537     return cls(expected, rel, abs, nan_ok)
538 
539 
540 def _is_numpy_array(obj):
541     """
542     Return true if the given object is a numpy array.  Make a special effort to
543     avoid importing numpy unless it's really necessary.
544     """
545     import sys
546 
547     np = sys.modules.get("numpy")
548     if np is not None:
549         return isinstance(obj, np.ndarray)
550     return False
551 
552 
553 # builtin pytest.raises helper
554 
555 
556 def raises(expected_exception, *args, **kwargs):
557     r"""
558     Assert that a code block/function call raises ``expected_exception``
559     or raise a failure exception otherwise.
560 
561     :kwparam match: if specified, a string containing a regular expression,
562         or a regular expression object, that is tested against the string
563         representation of the exception using ``re.search``. To match a literal
564         string that may contain `special characters`__, the pattern can
565         first be escaped with ``re.escape``.
566 
567     __ https://docs.python.org/3/library/re.html#regular-expression-syntax
568 
569     :kwparam message: **(deprecated since 4.1)** if specified, provides a custom failure message
570         if the exception is not raised. See :ref:`the deprecation docs <raises message deprecated>` for a workaround.
571 
572     .. currentmodule:: _pytest._code
573 
574     Use ``pytest.raises`` as a context manager, which will capture the exception of the given
575     type::
576 
577         >>> with raises(ZeroDivisionError):
578         ...    1/0
579 
580     If the code block does not raise the expected exception (``ZeroDivisionError`` in the example
581     above), or no exception at all, the check will fail instead.
582 
583     You can also use the keyword argument ``match`` to assert that the
584     exception matches a text or regex::
585 
586         >>> with raises(ValueError, match='must be 0 or None'):
587         ...     raise ValueError("value must be 0 or None")
588 
589         >>> with raises(ValueError, match=r'must be \d+$'):
590         ...     raise ValueError("value must be 42")
591 
592     The context manager produces an :class:`ExceptionInfo` object which can be used to inspect the
593     details of the captured exception::
594 
595         >>> with raises(ValueError) as exc_info:
596         ...     raise ValueError("value must be 42")
597         >>> assert exc_info.type is ValueError
598         >>> assert exc_info.value.args[0] == "value must be 42"
599 
600     .. deprecated:: 4.1
601 
602         In the context manager form you may use the keyword argument
603         ``message`` to specify a custom failure message that will be displayed
604         in case the ``pytest.raises`` check fails. This has been deprecated as it
605         is considered error prone as users often mean to use ``match`` instead.
606         See :ref:`the deprecation docs <raises message deprecated>` for a workaround.
607 
608     .. note::
609 
610        When using ``pytest.raises`` as a context manager, it's worthwhile to
611        note that normal context manager rules apply and that the exception
612        raised *must* be the final line in the scope of the context manager.
613        Lines of code after that, within the scope of the context manager will
614        not be executed. For example::
615 
616            >>> value = 15
617            >>> with raises(ValueError) as exc_info:
618            ...     if value > 10:
619            ...         raise ValueError("value must be <= 10")
620            ...     assert exc_info.type is ValueError  # this will not execute
621 
622        Instead, the following approach must be taken (note the difference in
623        scope)::
624 
625            >>> with raises(ValueError) as exc_info:
626            ...     if value > 10:
627            ...         raise ValueError("value must be <= 10")
628            ...
629            >>> assert exc_info.type is ValueError
630 
631     **Using with** ``pytest.mark.parametrize``
632 
633     When using :ref:`pytest.mark.parametrize ref`
634     it is possible to parametrize tests such that
635     some runs raise an exception and others do not.
636 
637     See :ref:`parametrizing_conditional_raising` for an example.
638 
639     **Legacy form**
640 
641     It is possible to specify a callable by passing a to-be-called lambda::
642 
643         >>> raises(ZeroDivisionError, lambda: 1/0)
644         <ExceptionInfo ...>
645 
646     or you can specify an arbitrary callable with arguments::
647 
648         >>> def f(x): return 1/x
649         ...
650         >>> raises(ZeroDivisionError, f, 0)
651         <ExceptionInfo ...>
652         >>> raises(ZeroDivisionError, f, x=0)
653         <ExceptionInfo ...>
654 
655     The form above is fully supported but discouraged for new code because the
656     context manager form is regarded as more readable and less error-prone.
657 
658     .. note::
659         Similar to caught exception objects in Python, explicitly clearing
660         local references to returned ``ExceptionInfo`` objects can
661         help the Python interpreter speed up its garbage collection.
662 
663         Clearing those references breaks a reference cycle
664         (``ExceptionInfo`` --> caught exception --> frame stack raising
665         the exception --> current frame stack --> local variables -->
666         ``ExceptionInfo``) which makes Python keep all objects referenced
667         from that cycle (including all local variables in the current
668         frame) alive until the next cyclic garbage collection run. See the
669         official Python ``try`` statement documentation for more detailed
670         information.
671 
672     """
673     __tracebackhide__ = True
674     for exc in filterfalse(isclass, always_iterable(expected_exception, BASE_TYPE)):
675         msg = (
676             "exceptions must be old-style classes or"
677             " derived from BaseException, not %s"
678         )
679         raise TypeError(msg % type(exc))
680 
681     message = "DID NOT RAISE {}".format(expected_exception)
682     match_expr = None
683 
684     if not args:
685         if "message" in kwargs:
686             message = kwargs.pop("message")
687             warnings.warn(deprecated.RAISES_MESSAGE_PARAMETER, stacklevel=2)
688         if "match" in kwargs:
689             match_expr = kwargs.pop("match")
690         if kwargs:
691             msg = "Unexpected keyword arguments passed to pytest.raises: "
692             msg += ", ".join(sorted(kwargs))
693             raise TypeError(msg)
694         return RaisesContext(expected_exception, message, match_expr)
695     elif isinstance(args[0], str):
696         warnings.warn(deprecated.RAISES_EXEC, stacklevel=2)
697         code, = args
698         assert isinstance(code, str)
699         frame = sys._getframe(1)
700         loc = frame.f_locals.copy()
701         loc.update(kwargs)
702         # print "raises frame scope: %r" % frame.f_locals
703         try:
704             code = _pytest._code.Source(code).compile(_genframe=frame)
705             exec(code, frame.f_globals, loc)
706             # XXX didn't mean f_globals == f_locals something special?
707             #     this is destroyed here ...
708         except expected_exception:
709             return _pytest._code.ExceptionInfo.from_current()
710     else:
711         func = args[0]
712         try:
713             func(*args[1:], **kwargs)
714         except expected_exception:
715             return _pytest._code.ExceptionInfo.from_current()
716     fail(message)
717 
718 
719 raises.Exception = fail.Exception
720 
721 
722 class RaisesContext(object):
723     def __init__(self, expected_exception, message, match_expr):
724         self.expected_exception = expected_exception
725         self.message = message
726         self.match_expr = match_expr
727         self.excinfo = None
728 
729     def __enter__(self):
730         self.excinfo = _pytest._code.ExceptionInfo.for_later()
731         return self.excinfo
732 
733     def __exit__(self, *tp):
734         __tracebackhide__ = True
735         if tp[0] is None:
736             fail(self.message)
737         self.excinfo.__init__(tp)
738         suppress_exception = issubclass(self.excinfo.type, self.expected_exception)
739         if sys.version_info[0] == 2 and suppress_exception:
740             sys.exc_clear()
741         if self.match_expr is not None and suppress_exception:
742             self.excinfo.match(self.match_expr)
743         return suppress_exception

</code><intended_behavior>The function `raises` should properly handle Unicode character comparisons in Python 2 without triggering a `UnicodeEncodeError`. When the `match` keyword is used with a Unicode regular expression pattern, the function should ensure that both the error message from the raised exception and the provided `match` pattern are appropriately encoded or decoded to avoid encoding incompatibilities. This correction must not alter the function's ability to handle ASCII or Unicode matches in either Python 2 or Python 3. The implementation should include checking the Python version and performing the necessary encoding/decoding operations only when required (i.e., under Python 2), ensuring that the functionality is preserved across different versions.</intended_behavior>]
2025-10-15 22:49:22.966 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-15 22:49:22.966 | INFO     | Search-only: skipping patch selection
2025-10-15 22:49:23.047 | INFO     | Task pytest-dev__pytest-5479 completed successfully.
2025-10-15 22:49:23.048 | INFO     | No patch generated. You can try running ACR again.
