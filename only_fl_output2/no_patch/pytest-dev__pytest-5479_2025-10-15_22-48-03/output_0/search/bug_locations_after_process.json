[
    {
        "rel_file_path": "src/_pytest/python_api.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/pytest-dev__pytest/setup_pytest-dev__pytest__4.6/src/_pytest/python_api.py",
        "start": 1,
        "end": 743,
        "class_name": null,
        "method_name": null,
        "code": "1 # -*- coding: utf-8 -*-\n2 from __future__ import absolute_import\n3 \n4 import math\n5 import pprint\n6 import sys\n7 import warnings\n8 from decimal import Decimal\n9 from numbers import Number\n10 \n11 from more_itertools.more import always_iterable\n12 from six.moves import filterfalse\n13 from six.moves import zip\n14 \n15 import _pytest._code\n16 from _pytest import deprecated\n17 from _pytest.compat import isclass\n18 from _pytest.compat import Iterable\n19 from _pytest.compat import Mapping\n20 from _pytest.compat import Sized\n21 from _pytest.compat import STRING_TYPES\n22 from _pytest.outcomes import fail\n23 \n24 BASE_TYPE = (type, STRING_TYPES)\n25 \n26 \n27 def _cmp_raises_type_error(self, other):\n28     \"\"\"__cmp__ implementation which raises TypeError. Used\n29     by Approx base classes to implement only == and != and raise a\n30     TypeError for other comparisons.\n31 \n32     Needed in Python 2 only, Python 3 all it takes is not implementing the\n33     other operators at all.\n34     \"\"\"\n35     __tracebackhide__ = True\n36     raise TypeError(\n37         \"Comparison operators other than == and != not supported by approx objects\"\n38     )\n39 \n40 \n41 def _non_numeric_type_error(value, at):\n42     at_str = \" at {}\".format(at) if at else \"\"\n43     return TypeError(\n44         \"cannot make approximate comparisons to non-numeric values: {!r} {}\".format(\n45             value, at_str\n46         )\n47     )\n48 \n49 \n50 # builtin pytest.approx helper\n51 \n52 \n53 class ApproxBase(object):\n54     \"\"\"\n55     Provide shared utilities for making approximate comparisons between numbers\n56     or sequences of numbers.\n57     \"\"\"\n58 \n59     # Tell numpy to use our `__eq__` operator instead of its.\n60     __array_ufunc__ = None\n61     __array_priority__ = 100\n62 \n63     def __init__(self, expected, rel=None, abs=None, nan_ok=False):\n64         __tracebackhide__ = True\n65         self.expected = expected\n66         self.abs = abs\n67         self.rel = rel\n68         self.nan_ok = nan_ok\n69         self._check_type()\n70 \n71     def __repr__(self):\n72         raise NotImplementedError\n73 \n74     def __eq__(self, actual):\n75         return all(\n76             a == self._approx_scalar(x) for a, x in self._yield_comparisons(actual)\n77         )\n78 \n79     __hash__ = None\n80 \n81     def __ne__(self, actual):\n82         return not (actual == self)\n83 \n84     if sys.version_info[0] == 2:\n85         __cmp__ = _cmp_raises_type_error\n86 \n87     def _approx_scalar(self, x):\n88         return ApproxScalar(x, rel=self.rel, abs=self.abs, nan_ok=self.nan_ok)\n89 \n90     def _yield_comparisons(self, actual):\n91         \"\"\"\n92         Yield all the pairs of numbers to be compared.  This is used to\n93         implement the `__eq__` method.\n94         \"\"\"\n95         raise NotImplementedError\n96 \n97     def _check_type(self):\n98         \"\"\"\n99         Raise a TypeError if the expected value is not a valid type.\n100         \"\"\"\n101         # This is only a concern if the expected value is a sequence.  In every\n102         # other case, the approx() function ensures that the expected value has\n103         # a numeric type.  For this reason, the default is to do nothing.  The\n104         # classes that deal with sequences should reimplement this method to\n105         # raise if there are any non-numeric elements in the sequence.\n106         pass\n107 \n108 \n109 def _recursive_list_map(f, x):\n110     if isinstance(x, list):\n111         return list(_recursive_list_map(f, xi) for xi in x)\n112     else:\n113         return f(x)\n114 \n115 \n116 class ApproxNumpy(ApproxBase):\n117     \"\"\"\n118     Perform approximate comparisons where the expected value is numpy array.\n119     \"\"\"\n120 \n121     def __repr__(self):\n122         list_scalars = _recursive_list_map(self._approx_scalar, self.expected.tolist())\n123         return \"approx({!r})\".format(list_scalars)\n124 \n125     if sys.version_info[0] == 2:\n126         __cmp__ = _cmp_raises_type_error\n127 \n128     def __eq__(self, actual):\n129         import numpy as np\n130 \n131         # self.expected is supposed to always be an array here\n132 \n133         if not np.isscalar(actual):\n134             try:\n135                 actual = np.asarray(actual)\n136             except:  # noqa\n137                 raise TypeError(\"cannot compare '{}' to numpy.ndarray\".format(actual))\n138 \n139         if not np.isscalar(actual) and actual.shape != self.expected.shape:\n140             return False\n141 \n142         return ApproxBase.__eq__(self, actual)\n143 \n144     def _yield_comparisons(self, actual):\n145         import numpy as np\n146 \n147         # `actual` can either be a numpy array or a scalar, it is treated in\n148         # `__eq__` before being passed to `ApproxBase.__eq__`, which is the\n149         # only method that calls this one.\n150 \n151         if np.isscalar(actual):\n152             for i in np.ndindex(self.expected.shape):\n153                 yield actual, self.expected[i].item()\n154         else:\n155             for i in np.ndindex(self.expected.shape):\n156                 yield actual[i].item(), self.expected[i].item()\n157 \n158 \n159 class ApproxMapping(ApproxBase):\n160     \"\"\"\n161     Perform approximate comparisons where the expected value is a mapping with\n162     numeric values (the keys can be anything).\n163     \"\"\"\n164 \n165     def __repr__(self):\n166         return \"approx({!r})\".format(\n167             {k: self._approx_scalar(v) for k, v in self.expected.items()}\n168         )\n169 \n170     def __eq__(self, actual):\n171         if set(actual.keys()) != set(self.expected.keys()):\n172             return False\n173 \n174         return ApproxBase.__eq__(self, actual)\n175 \n176     def _yield_comparisons(self, actual):\n177         for k in self.expected.keys():\n178             yield actual[k], self.expected[k]\n179 \n180     def _check_type(self):\n181         __tracebackhide__ = True\n182         for key, value in self.expected.items():\n183             if isinstance(value, type(self.expected)):\n184                 msg = \"pytest.approx() does not support nested dictionaries: key={!r} value={!r}\\n  full mapping={}\"\n185                 raise TypeError(msg.format(key, value, pprint.pformat(self.expected)))\n186             elif not isinstance(value, Number):\n187                 raise _non_numeric_type_error(self.expected, at=\"key={!r}\".format(key))\n188 \n189 \n190 class ApproxSequencelike(ApproxBase):\n191     \"\"\"\n192     Perform approximate comparisons where the expected value is a sequence of\n193     numbers.\n194     \"\"\"\n195 \n196     def __repr__(self):\n197         seq_type = type(self.expected)\n198         if seq_type not in (tuple, list, set):\n199             seq_type = list\n200         return \"approx({!r})\".format(\n201             seq_type(self._approx_scalar(x) for x in self.expected)\n202         )\n203 \n204     def __eq__(self, actual):\n205         if len(actual) != len(self.expected):\n206             return False\n207         return ApproxBase.__eq__(self, actual)\n208 \n209     def _yield_comparisons(self, actual):\n210         return zip(actual, self.expected)\n211 \n212     def _check_type(self):\n213         __tracebackhide__ = True\n214         for index, x in enumerate(self.expected):\n215             if isinstance(x, type(self.expected)):\n216                 msg = \"pytest.approx() does not support nested data structures: {!r} at index {}\\n  full sequence: {}\"\n217                 raise TypeError(msg.format(x, index, pprint.pformat(self.expected)))\n218             elif not isinstance(x, Number):\n219                 raise _non_numeric_type_error(\n220                     self.expected, at=\"index {}\".format(index)\n221                 )\n222 \n223 \n224 class ApproxScalar(ApproxBase):\n225     \"\"\"\n226     Perform approximate comparisons where the expected value is a single number.\n227     \"\"\"\n228 \n229     DEFAULT_ABSOLUTE_TOLERANCE = 1e-12\n230     DEFAULT_RELATIVE_TOLERANCE = 1e-6\n231 \n232     def __repr__(self):\n233         \"\"\"\n234         Return a string communicating both the expected value and the tolerance\n235         for the comparison being made, e.g. '1.0 +- 1e-6'.  Use the unicode\n236         plus/minus symbol if this is python3 (it's too hard to get right for\n237         python2).\n238         \"\"\"\n239         if isinstance(self.expected, complex):\n240             return str(self.expected)\n241 \n242         # Infinities aren't compared using tolerances, so don't show a\n243         # tolerance.\n244         if math.isinf(self.expected):\n245             return str(self.expected)\n246 \n247         # If a sensible tolerance can't be calculated, self.tolerance will\n248         # raise a ValueError.  In this case, display '???'.\n249         try:\n250             vetted_tolerance = \"{:.1e}\".format(self.tolerance)\n251         except ValueError:\n252             vetted_tolerance = \"???\"\n253 \n254         if sys.version_info[0] == 2:\n255             return \"{} +- {}\".format(self.expected, vetted_tolerance)\n256         else:\n257             return u\"{} \\u00b1 {}\".format(self.expected, vetted_tolerance)\n258 \n259     def __eq__(self, actual):\n260         \"\"\"\n261         Return true if the given value is equal to the expected value within\n262         the pre-specified tolerance.\n263         \"\"\"\n264         if _is_numpy_array(actual):\n265             # Call ``__eq__()`` manually to prevent infinite-recursion with\n266             # numpy<1.13.  See #3748.\n267             return all(self.__eq__(a) for a in actual.flat)\n268 \n269         # Short-circuit exact equality.\n270         if actual == self.expected:\n271             return True\n272 \n273         # Allow the user to control whether NaNs are considered equal to each\n274         # other or not.  The abs() calls are for compatibility with complex\n275         # numbers.\n276         if math.isnan(abs(self.expected)):\n277             return self.nan_ok and math.isnan(abs(actual))\n278 \n279         # Infinity shouldn't be approximately equal to anything but itself, but\n280         # if there's a relative tolerance, it will be infinite and infinity\n281         # will seem approximately equal to everything.  The equal-to-itself\n282         # case would have been short circuited above, so here we can just\n283         # return false if the expected value is infinite.  The abs() call is\n284         # for compatibility with complex numbers.\n285         if math.isinf(abs(self.expected)):\n286             return False\n287 \n288         # Return true if the two numbers are within the tolerance.\n289         return abs(self.expected - actual) <= self.tolerance\n290 \n291     __hash__ = None\n292 \n293     @property\n294     def tolerance(self):\n295         \"\"\"\n296         Return the tolerance for the comparison.  This could be either an\n297         absolute tolerance or a relative tolerance, depending on what the user\n298         specified or which would be larger.\n299         \"\"\"\n300 \n301         def set_default(x, default):\n302             return x if x is not None else default\n303 \n304         # Figure out what the absolute tolerance should be.  ``self.abs`` is\n305         # either None or a value specified by the user.\n306         absolute_tolerance = set_default(self.abs, self.DEFAULT_ABSOLUTE_TOLERANCE)\n307 \n308         if absolute_tolerance < 0:\n309             raise ValueError(\n310                 \"absolute tolerance can't be negative: {}\".format(absolute_tolerance)\n311             )\n312         if math.isnan(absolute_tolerance):\n313             raise ValueError(\"absolute tolerance can't be NaN.\")\n314 \n315         # If the user specified an absolute tolerance but not a relative one,\n316         # just return the absolute tolerance.\n317         if self.rel is None:\n318             if self.abs is not None:\n319                 return absolute_tolerance\n320 \n321         # Figure out what the relative tolerance should be.  ``self.rel`` is\n322         # either None or a value specified by the user.  This is done after\n323         # we've made sure the user didn't ask for an absolute tolerance only,\n324         # because we don't want to raise errors about the relative tolerance if\n325         # we aren't even going to use it.\n326         relative_tolerance = set_default(\n327             self.rel, self.DEFAULT_RELATIVE_TOLERANCE\n328         ) * abs(self.expected)\n329 \n330         if relative_tolerance < 0:\n331             raise ValueError(\n332                 \"relative tolerance can't be negative: {}\".format(absolute_tolerance)\n333             )\n334         if math.isnan(relative_tolerance):\n335             raise ValueError(\"relative tolerance can't be NaN.\")\n336 \n337         # Return the larger of the relative and absolute tolerances.\n338         return max(relative_tolerance, absolute_tolerance)\n339 \n340 \n341 class ApproxDecimal(ApproxScalar):\n342     \"\"\"\n343     Perform approximate comparisons where the expected value is a decimal.\n344     \"\"\"\n345 \n346     DEFAULT_ABSOLUTE_TOLERANCE = Decimal(\"1e-12\")\n347     DEFAULT_RELATIVE_TOLERANCE = Decimal(\"1e-6\")\n348 \n349 \n350 def approx(expected, rel=None, abs=None, nan_ok=False):\n351     \"\"\"\n352     Assert that two numbers (or two sets of numbers) are equal to each other\n353     within some tolerance.\n354 \n355     Due to the `intricacies of floating-point arithmetic`__, numbers that we\n356     would intuitively expect to be equal are not always so::\n357 \n358         >>> 0.1 + 0.2 == 0.3\n359         False\n360 \n361     __ https://docs.python.org/3/tutorial/floatingpoint.html\n362 \n363     This problem is commonly encountered when writing tests, e.g. when making\n364     sure that floating-point values are what you expect them to be.  One way to\n365     deal with this problem is to assert that two floating-point numbers are\n366     equal to within some appropriate tolerance::\n367 \n368         >>> abs((0.1 + 0.2) - 0.3) < 1e-6\n369         True\n370 \n371     However, comparisons like this are tedious to write and difficult to\n372     understand.  Furthermore, absolute comparisons like the one above are\n373     usually discouraged because there's no tolerance that works well for all\n374     situations.  ``1e-6`` is good for numbers around ``1``, but too small for\n375     very big numbers and too big for very small ones.  It's better to express\n376     the tolerance as a fraction of the expected value, but relative comparisons\n377     like that are even more difficult to write correctly and concisely.\n378 \n379     The ``approx`` class performs floating-point comparisons using a syntax\n380     that's as intuitive as possible::\n381 \n382         >>> from pytest import approx\n383         >>> 0.1 + 0.2 == approx(0.3)\n384         True\n385 \n386     The same syntax also works for sequences of numbers::\n387 \n388         >>> (0.1 + 0.2, 0.2 + 0.4) == approx((0.3, 0.6))\n389         True\n390 \n391     Dictionary *values*::\n392 \n393         >>> {'a': 0.1 + 0.2, 'b': 0.2 + 0.4} == approx({'a': 0.3, 'b': 0.6})\n394         True\n395 \n396     ``numpy`` arrays::\n397 \n398         >>> import numpy as np                                                          # doctest: +SKIP\n399         >>> np.array([0.1, 0.2]) + np.array([0.2, 0.4]) == approx(np.array([0.3, 0.6])) # doctest: +SKIP\n400         True\n401 \n402     And for a ``numpy`` array against a scalar::\n403 \n404         >>> import numpy as np                                         # doctest: +SKIP\n405         >>> np.array([0.1, 0.2]) + np.array([0.2, 0.1]) == approx(0.3) # doctest: +SKIP\n406         True\n407 \n408     By default, ``approx`` considers numbers within a relative tolerance of\n409     ``1e-6`` (i.e. one part in a million) of its expected value to be equal.\n410     This treatment would lead to surprising results if the expected value was\n411     ``0.0``, because nothing but ``0.0`` itself is relatively close to ``0.0``.\n412     To handle this case less surprisingly, ``approx`` also considers numbers\n413     within an absolute tolerance of ``1e-12`` of its expected value to be\n414     equal.  Infinity and NaN are special cases.  Infinity is only considered\n415     equal to itself, regardless of the relative tolerance.  NaN is not\n416     considered equal to anything by default, but you can make it be equal to\n417     itself by setting the ``nan_ok`` argument to True.  (This is meant to\n418     facilitate comparing arrays that use NaN to mean \"no data\".)\n419 \n420     Both the relative and absolute tolerances can be changed by passing\n421     arguments to the ``approx`` constructor::\n422 \n423         >>> 1.0001 == approx(1)\n424         False\n425         >>> 1.0001 == approx(1, rel=1e-3)\n426         True\n427         >>> 1.0001 == approx(1, abs=1e-3)\n428         True\n429 \n430     If you specify ``abs`` but not ``rel``, the comparison will not consider\n431     the relative tolerance at all.  In other words, two numbers that are within\n432     the default relative tolerance of ``1e-6`` will still be considered unequal\n433     if they exceed the specified absolute tolerance.  If you specify both\n434     ``abs`` and ``rel``, the numbers will be considered equal if either\n435     tolerance is met::\n436 \n437         >>> 1 + 1e-8 == approx(1)\n438         True\n439         >>> 1 + 1e-8 == approx(1, abs=1e-12)\n440         False\n441         >>> 1 + 1e-8 == approx(1, rel=1e-6, abs=1e-12)\n442         True\n443 \n444     If you're thinking about using ``approx``, then you might want to know how\n445     it compares to other good ways of comparing floating-point numbers.  All of\n446     these algorithms are based on relative and absolute tolerances and should\n447     agree for the most part, but they do have meaningful differences:\n448 \n449     - ``math.isclose(a, b, rel_tol=1e-9, abs_tol=0.0)``:  True if the relative\n450       tolerance is met w.r.t. either ``a`` or ``b`` or if the absolute\n451       tolerance is met.  Because the relative tolerance is calculated w.r.t.\n452       both ``a`` and ``b``, this test is symmetric (i.e.  neither ``a`` nor\n453       ``b`` is a \"reference value\").  You have to specify an absolute tolerance\n454       if you want to compare to ``0.0`` because there is no tolerance by\n455       default.  Only available in python>=3.5.  `More information...`__\n456 \n457       __ https://docs.python.org/3/library/math.html#math.isclose\n458 \n459     - ``numpy.isclose(a, b, rtol=1e-5, atol=1e-8)``: True if the difference\n460       between ``a`` and ``b`` is less that the sum of the relative tolerance\n461       w.r.t. ``b`` and the absolute tolerance.  Because the relative tolerance\n462       is only calculated w.r.t. ``b``, this test is asymmetric and you can\n463       think of ``b`` as the reference value.  Support for comparing sequences\n464       is provided by ``numpy.allclose``.  `More information...`__\n465 \n466       __ http://docs.scipy.org/doc/numpy-1.10.0/reference/generated/numpy.isclose.html\n467 \n468     - ``unittest.TestCase.assertAlmostEqual(a, b)``: True if ``a`` and ``b``\n469       are within an absolute tolerance of ``1e-7``.  No relative tolerance is\n470       considered and the absolute tolerance cannot be changed, so this function\n471       is not appropriate for very large or very small numbers.  Also, it's only\n472       available in subclasses of ``unittest.TestCase`` and it's ugly because it\n473       doesn't follow PEP8.  `More information...`__\n474 \n475       __ https://docs.python.org/3/library/unittest.html#unittest.TestCase.assertAlmostEqual\n476 \n477     - ``a == pytest.approx(b, rel=1e-6, abs=1e-12)``: True if the relative\n478       tolerance is met w.r.t. ``b`` or if the absolute tolerance is met.\n479       Because the relative tolerance is only calculated w.r.t. ``b``, this test\n480       is asymmetric and you can think of ``b`` as the reference value.  In the\n481       special case that you explicitly specify an absolute tolerance but not a\n482       relative tolerance, only the absolute tolerance is considered.\n483 \n484     .. warning::\n485 \n486        .. versionchanged:: 3.2\n487 \n488        In order to avoid inconsistent behavior, ``TypeError`` is\n489        raised for ``>``, ``>=``, ``<`` and ``<=`` comparisons.\n490        The example below illustrates the problem::\n491 \n492            assert approx(0.1) > 0.1 + 1e-10  # calls approx(0.1).__gt__(0.1 + 1e-10)\n493            assert 0.1 + 1e-10 > approx(0.1)  # calls approx(0.1).__lt__(0.1 + 1e-10)\n494 \n495        In the second example one expects ``approx(0.1).__le__(0.1 + 1e-10)``\n496        to be called. But instead, ``approx(0.1).__lt__(0.1 + 1e-10)`` is used to\n497        comparison. This is because the call hierarchy of rich comparisons\n498        follows a fixed behavior. `More information...`__\n499 \n500        __ https://docs.python.org/3/reference/datamodel.html#object.__ge__\n501     \"\"\"\n502 \n503     # Delegate the comparison to a class that knows how to deal with the type\n504     # of the expected value (e.g. int, float, list, dict, numpy.array, etc).\n505     #\n506     # The primary responsibility of these classes is to implement ``__eq__()``\n507     # and ``__repr__()``.  The former is used to actually check if some\n508     # \"actual\" value is equivalent to the given expected value within the\n509     # allowed tolerance.  The latter is used to show the user the expected\n510     # value and tolerance, in the case that a test failed.\n511     #\n512     # The actual logic for making approximate comparisons can be found in\n513     # ApproxScalar, which is used to compare individual numbers.  All of the\n514     # other Approx classes eventually delegate to this class.  The ApproxBase\n515     # class provides some convenient methods and overloads, but isn't really\n516     # essential.\n517 \n518     __tracebackhide__ = True\n519 \n520     if isinstance(expected, Decimal):\n521         cls = ApproxDecimal\n522     elif isinstance(expected, Number):\n523         cls = ApproxScalar\n524     elif isinstance(expected, Mapping):\n525         cls = ApproxMapping\n526     elif _is_numpy_array(expected):\n527         cls = ApproxNumpy\n528     elif (\n529         isinstance(expected, Iterable)\n530         and isinstance(expected, Sized)\n531         and not isinstance(expected, STRING_TYPES)\n532     ):\n533         cls = ApproxSequencelike\n534     else:\n535         raise _non_numeric_type_error(expected, at=None)\n536 \n537     return cls(expected, rel, abs, nan_ok)\n538 \n539 \n540 def _is_numpy_array(obj):\n541     \"\"\"\n542     Return true if the given object is a numpy array.  Make a special effort to\n543     avoid importing numpy unless it's really necessary.\n544     \"\"\"\n545     import sys\n546 \n547     np = sys.modules.get(\"numpy\")\n548     if np is not None:\n549         return isinstance(obj, np.ndarray)\n550     return False\n551 \n552 \n553 # builtin pytest.raises helper\n554 \n555 \n556 def raises(expected_exception, *args, **kwargs):\n557     r\"\"\"\n558     Assert that a code block/function call raises ``expected_exception``\n559     or raise a failure exception otherwise.\n560 \n561     :kwparam match: if specified, a string containing a regular expression,\n562         or a regular expression object, that is tested against the string\n563         representation of the exception using ``re.search``. To match a literal\n564         string that may contain `special characters`__, the pattern can\n565         first be escaped with ``re.escape``.\n566 \n567     __ https://docs.python.org/3/library/re.html#regular-expression-syntax\n568 \n569     :kwparam message: **(deprecated since 4.1)** if specified, provides a custom failure message\n570         if the exception is not raised. See :ref:`the deprecation docs <raises message deprecated>` for a workaround.\n571 \n572     .. currentmodule:: _pytest._code\n573 \n574     Use ``pytest.raises`` as a context manager, which will capture the exception of the given\n575     type::\n576 \n577         >>> with raises(ZeroDivisionError):\n578         ...    1/0\n579 \n580     If the code block does not raise the expected exception (``ZeroDivisionError`` in the example\n581     above), or no exception at all, the check will fail instead.\n582 \n583     You can also use the keyword argument ``match`` to assert that the\n584     exception matches a text or regex::\n585 \n586         >>> with raises(ValueError, match='must be 0 or None'):\n587         ...     raise ValueError(\"value must be 0 or None\")\n588 \n589         >>> with raises(ValueError, match=r'must be \\d+$'):\n590         ...     raise ValueError(\"value must be 42\")\n591 \n592     The context manager produces an :class:`ExceptionInfo` object which can be used to inspect the\n593     details of the captured exception::\n594 \n595         >>> with raises(ValueError) as exc_info:\n596         ...     raise ValueError(\"value must be 42\")\n597         >>> assert exc_info.type is ValueError\n598         >>> assert exc_info.value.args[0] == \"value must be 42\"\n599 \n600     .. deprecated:: 4.1\n601 \n602         In the context manager form you may use the keyword argument\n603         ``message`` to specify a custom failure message that will be displayed\n604         in case the ``pytest.raises`` check fails. This has been deprecated as it\n605         is considered error prone as users often mean to use ``match`` instead.\n606         See :ref:`the deprecation docs <raises message deprecated>` for a workaround.\n607 \n608     .. note::\n609 \n610        When using ``pytest.raises`` as a context manager, it's worthwhile to\n611        note that normal context manager rules apply and that the exception\n612        raised *must* be the final line in the scope of the context manager.\n613        Lines of code after that, within the scope of the context manager will\n614        not be executed. For example::\n615 \n616            >>> value = 15\n617            >>> with raises(ValueError) as exc_info:\n618            ...     if value > 10:\n619            ...         raise ValueError(\"value must be <= 10\")\n620            ...     assert exc_info.type is ValueError  # this will not execute\n621 \n622        Instead, the following approach must be taken (note the difference in\n623        scope)::\n624 \n625            >>> with raises(ValueError) as exc_info:\n626            ...     if value > 10:\n627            ...         raise ValueError(\"value must be <= 10\")\n628            ...\n629            >>> assert exc_info.type is ValueError\n630 \n631     **Using with** ``pytest.mark.parametrize``\n632 \n633     When using :ref:`pytest.mark.parametrize ref`\n634     it is possible to parametrize tests such that\n635     some runs raise an exception and others do not.\n636 \n637     See :ref:`parametrizing_conditional_raising` for an example.\n638 \n639     **Legacy form**\n640 \n641     It is possible to specify a callable by passing a to-be-called lambda::\n642 \n643         >>> raises(ZeroDivisionError, lambda: 1/0)\n644         <ExceptionInfo ...>\n645 \n646     or you can specify an arbitrary callable with arguments::\n647 \n648         >>> def f(x): return 1/x\n649         ...\n650         >>> raises(ZeroDivisionError, f, 0)\n651         <ExceptionInfo ...>\n652         >>> raises(ZeroDivisionError, f, x=0)\n653         <ExceptionInfo ...>\n654 \n655     The form above is fully supported but discouraged for new code because the\n656     context manager form is regarded as more readable and less error-prone.\n657 \n658     .. note::\n659         Similar to caught exception objects in Python, explicitly clearing\n660         local references to returned ``ExceptionInfo`` objects can\n661         help the Python interpreter speed up its garbage collection.\n662 \n663         Clearing those references breaks a reference cycle\n664         (``ExceptionInfo`` --> caught exception --> frame stack raising\n665         the exception --> current frame stack --> local variables -->\n666         ``ExceptionInfo``) which makes Python keep all objects referenced\n667         from that cycle (including all local variables in the current\n668         frame) alive until the next cyclic garbage collection run. See the\n669         official Python ``try`` statement documentation for more detailed\n670         information.\n671 \n672     \"\"\"\n673     __tracebackhide__ = True\n674     for exc in filterfalse(isclass, always_iterable(expected_exception, BASE_TYPE)):\n675         msg = (\n676             \"exceptions must be old-style classes or\"\n677             \" derived from BaseException, not %s\"\n678         )\n679         raise TypeError(msg % type(exc))\n680 \n681     message = \"DID NOT RAISE {}\".format(expected_exception)\n682     match_expr = None\n683 \n684     if not args:\n685         if \"message\" in kwargs:\n686             message = kwargs.pop(\"message\")\n687             warnings.warn(deprecated.RAISES_MESSAGE_PARAMETER, stacklevel=2)\n688         if \"match\" in kwargs:\n689             match_expr = kwargs.pop(\"match\")\n690         if kwargs:\n691             msg = \"Unexpected keyword arguments passed to pytest.raises: \"\n692             msg += \", \".join(sorted(kwargs))\n693             raise TypeError(msg)\n694         return RaisesContext(expected_exception, message, match_expr)\n695     elif isinstance(args[0], str):\n696         warnings.warn(deprecated.RAISES_EXEC, stacklevel=2)\n697         code, = args\n698         assert isinstance(code, str)\n699         frame = sys._getframe(1)\n700         loc = frame.f_locals.copy()\n701         loc.update(kwargs)\n702         # print \"raises frame scope: %r\" % frame.f_locals\n703         try:\n704             code = _pytest._code.Source(code).compile(_genframe=frame)\n705             exec(code, frame.f_globals, loc)\n706             # XXX didn't mean f_globals == f_locals something special?\n707             #     this is destroyed here ...\n708         except expected_exception:\n709             return _pytest._code.ExceptionInfo.from_current()\n710     else:\n711         func = args[0]\n712         try:\n713             func(*args[1:], **kwargs)\n714         except expected_exception:\n715             return _pytest._code.ExceptionInfo.from_current()\n716     fail(message)\n717 \n718 \n719 raises.Exception = fail.Exception\n720 \n721 \n722 class RaisesContext(object):\n723     def __init__(self, expected_exception, message, match_expr):\n724         self.expected_exception = expected_exception\n725         self.message = message\n726         self.match_expr = match_expr\n727         self.excinfo = None\n728 \n729     def __enter__(self):\n730         self.excinfo = _pytest._code.ExceptionInfo.for_later()\n731         return self.excinfo\n732 \n733     def __exit__(self, *tp):\n734         __tracebackhide__ = True\n735         if tp[0] is None:\n736             fail(self.message)\n737         self.excinfo.__init__(tp)\n738         suppress_exception = issubclass(self.excinfo.type, self.expected_exception)\n739         if sys.version_info[0] == 2 and suppress_exception:\n740             sys.exc_clear()\n741         if self.match_expr is not None and suppress_exception:\n742             self.excinfo.match(self.match_expr)\n743         return suppress_exception\n",
        "intended_behavior": "The function `raises` should properly handle Unicode character comparisons in Python 2 without triggering a `UnicodeEncodeError`. When the `match` keyword is used with a Unicode regular expression pattern, the function should ensure that both the error message from the raised exception and the provided `match` pattern are appropriately encoded or decoded to avoid encoding incompatibilities. This correction must not alter the function's ability to handle ASCII or Unicode matches in either Python 2 or Python 3. The implementation should include checking the Python version and performing the necessary encoding/decoding operations only when required (i.e., under Python 2), ensuring that the functionality is preserved across different versions."
    }
]