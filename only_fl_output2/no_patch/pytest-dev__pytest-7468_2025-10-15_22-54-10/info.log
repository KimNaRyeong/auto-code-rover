2025-10-15 22:54:10.166 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-15 22:54:13.245 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=247, output_tokens=12, cost=0.002830
2025-10-15 22:54:25.084 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=427, output_tokens=530, cost=0.020170
2025-10-15 22:54:26.228 | INFO     | registered non reproducing test 0
2025-10-15 22:54:41.271 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1233, output_tokens=687, cost=0.032940
2025-10-15 22:54:42.375 | INFO     | registered non reproducing test 1
2025-10-15 22:54:58.181 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1395, output_tokens=791, cost=0.037680
2025-10-15 22:54:59.294 | INFO     | registered non reproducing test 2
2025-10-15 22:54:59.294 | WARNING  | Failed to write a reproducer test; skipping reproducer tracing
2025-10-15 22:54:59.301 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 22:55:06.543 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=553, output_tokens=303, cost=0.014620
2025-10-15 22:55:06.551 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 22:55:08.041 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=657, output_tokens=44, cost=0.007890
2025-10-15 22:55:08.043 | DEBUG    | Extracted a valid json.
2025-10-15 22:55:08.043 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_code(\"--log-file\")",
        "search_method(\"configure_logging\")",
        "search_code(\"os.makedirs\")"
    ],
    "bug_locations": []
}
2025-10-15 22:55:08.270 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-15 22:55:08.270 | DEBUG    | <Agent search> Analyzing search results.
2025-10-15 22:55:21.638 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1713, output_tokens=644, cost=0.036450
2025-10-15 22:55:21.644 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 22:55:27.138 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2573, output_tokens=233, cost=0.032720
2025-10-15 22:55:27.145 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 22:55:33.953 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=587, output_tokens=261, cost=0.013700
2025-10-15 22:55:33.954 | DEBUG    | Extracted a valid json.
2025-10-15 22:55:33.955 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "src/_pytest/logging.py",
            "class": "",
            "method": "",
            "intended_behavior": "Within the handling of the `--log-file` option in `src/_pytest/logging.py`, the code should be updated to include a check for the existence of the directory specified for the log file. If the directory does not exist, it should be created before the log file is opened for writing. This behavior ensures that providing a `--log-file` argument with non-existing subdirectories does not result in a `FileNotFoundError`. This fix should preserve the existing functionality of log file handling while adding the safeguard to automatically create required directories, aligning it with how other parts of pytest, like `resultlog.py` and `junitxml.py`, manage directory creation for files. This would involve a sequence similar to:\n\n```python\ndirname = os.path.dirname(os.path.abspath(logfile))\nif not os.path.isdir(dirname):\n    os.makedirs(dirname)\n```\n\nBefore the logfile is opened within the logging setup process, this additional check ensures compatibility and user-friendly behavior for all valid `--log-file` input paths."
        }
    ]
}
2025-10-15 22:55:33.963 | DEBUG    | Bug location extracted successfully: [<file>src/_pytest/logging.py</file>
<class>None</class>
<method>None</method>
<code>
1 """ Access and control log capturing. """
2 import logging
3 import os
4 import re
5 import sys
6 from contextlib import contextmanager
7 from io import StringIO
8 from typing import AbstractSet
9 from typing import Dict
10 from typing import Generator
11 from typing import List
12 from typing import Mapping
13 from typing import Optional
14 from typing import Tuple
15 from typing import TypeVar
16 from typing import Union
17 
18 import pytest
19 from _pytest import nodes
20 from _pytest._io import TerminalWriter
21 from _pytest.capture import CaptureManager
22 from _pytest.compat import nullcontext
23 from _pytest.config import _strtobool
24 from _pytest.config import Config
25 from _pytest.config import create_terminal_writer
26 from _pytest.config.argparsing import Parser
27 from _pytest.fixtures import FixtureRequest
28 from _pytest.main import Session
29 from _pytest.pathlib import Path
30 from _pytest.store import StoreKey
31 from _pytest.terminal import TerminalReporter
32 
33 
34 DEFAULT_LOG_FORMAT = "%(levelname)-8s %(name)s:%(filename)s:%(lineno)d %(message)s"
35 DEFAULT_LOG_DATE_FORMAT = "%H:%M:%S"
36 _ANSI_ESCAPE_SEQ = re.compile(r"\x1b\[[\d;]+m")
37 caplog_handler_key = StoreKey["LogCaptureHandler"]()
38 caplog_records_key = StoreKey[Dict[str, List[logging.LogRecord]]]()
39 
40 
41 def _remove_ansi_escape_sequences(text: str) -> str:
42     return _ANSI_ESCAPE_SEQ.sub("", text)
43 
44 
45 class ColoredLevelFormatter(logging.Formatter):
46     """
47     Colorize the %(levelname)..s part of the log format passed to __init__.
48     """
49 
50     LOGLEVEL_COLOROPTS = {
51         logging.CRITICAL: {"red"},
52         logging.ERROR: {"red", "bold"},
53         logging.WARNING: {"yellow"},
54         logging.WARN: {"yellow"},
55         logging.INFO: {"green"},
56         logging.DEBUG: {"purple"},
57         logging.NOTSET: set(),
58     }  # type: Mapping[int, AbstractSet[str]]
59     LEVELNAME_FMT_REGEX = re.compile(r"%\(levelname\)([+-.]?\d*s)")
60 
61     def __init__(self, terminalwriter: TerminalWriter, *args, **kwargs) -> None:
62         super().__init__(*args, **kwargs)
63         self._original_fmt = self._style._fmt
64         self._level_to_fmt_mapping = {}  # type: Dict[int, str]
65 
66         assert self._fmt is not None
67         levelname_fmt_match = self.LEVELNAME_FMT_REGEX.search(self._fmt)
68         if not levelname_fmt_match:
69             return
70         levelname_fmt = levelname_fmt_match.group()
71 
72         for level, color_opts in self.LOGLEVEL_COLOROPTS.items():
73             formatted_levelname = levelname_fmt % {
74                 "levelname": logging.getLevelName(level)
75             }
76 
77             # add ANSI escape sequences around the formatted levelname
78             color_kwargs = {name: True for name in color_opts}
79             colorized_formatted_levelname = terminalwriter.markup(
80                 formatted_levelname, **color_kwargs
81             )
82             self._level_to_fmt_mapping[level] = self.LEVELNAME_FMT_REGEX.sub(
83                 colorized_formatted_levelname, self._fmt
84             )
85 
86     def format(self, record: logging.LogRecord) -> str:
87         fmt = self._level_to_fmt_mapping.get(record.levelno, self._original_fmt)
88         self._style._fmt = fmt
89         return super().format(record)
90 
91 
92 class PercentStyleMultiline(logging.PercentStyle):
93     """A logging style with special support for multiline messages.
94 
95     If the message of a record consists of multiple lines, this style
96     formats the message as if each line were logged separately.
97     """
98 
99     def __init__(self, fmt: str, auto_indent: Union[int, str, bool, None]) -> None:
100         super().__init__(fmt)
101         self._auto_indent = self._get_auto_indent(auto_indent)
102 
103     @staticmethod
104     def _update_message(
105         record_dict: Dict[str, object], message: str
106     ) -> Dict[str, object]:
107         tmp = record_dict.copy()
108         tmp["message"] = message
109         return tmp
110 
111     @staticmethod
112     def _get_auto_indent(auto_indent_option: Union[int, str, bool, None]) -> int:
113         """Determines the current auto indentation setting
114 
115         Specify auto indent behavior (on/off/fixed) by passing in
116         extra={"auto_indent": [value]} to the call to logging.log() or
117         using a --log-auto-indent [value] command line or the
118         log_auto_indent [value] config option.
119 
120         Default behavior is auto-indent off.
121 
122         Using the string "True" or "on" or the boolean True as the value
123         turns auto indent on, using the string "False" or "off" or the
124         boolean False or the int 0 turns it off, and specifying a
125         positive integer fixes the indentation position to the value
126         specified.
127 
128         Any other values for the option are invalid, and will silently be
129         converted to the default.
130 
131         :param any auto_indent_option: User specified option for indentation
132             from command line, config or extra kwarg. Accepts int, bool or str.
133             str option accepts the same range of values as boolean config options,
134             as well as positive integers represented in str form.
135 
136         :returns: indentation value, which can be
137             -1 (automatically determine indentation) or
138             0 (auto-indent turned off) or
139             >0 (explicitly set indentation position).
140         """
141 
142         if auto_indent_option is None:
143             return 0
144         elif isinstance(auto_indent_option, bool):
145             if auto_indent_option:
146                 return -1
147             else:
148                 return 0
149         elif isinstance(auto_indent_option, int):
150             return int(auto_indent_option)
151         elif isinstance(auto_indent_option, str):
152             try:
153                 return int(auto_indent_option)
154             except ValueError:
155                 pass
156             try:
157                 if _strtobool(auto_indent_option):
158                     return -1
159             except ValueError:
160                 return 0
161 
162         return 0
163 
164     def format(self, record: logging.LogRecord) -> str:
165         if "\n" in record.message:
166             if hasattr(record, "auto_indent"):
167                 # passed in from the "extra={}" kwarg on the call to logging.log()
168                 auto_indent = self._get_auto_indent(record.auto_indent)  # type: ignore[attr-defined] # noqa: F821
169             else:
170                 auto_indent = self._auto_indent
171 
172             if auto_indent:
173                 lines = record.message.splitlines()
174                 formatted = self._fmt % self._update_message(record.__dict__, lines[0])
175 
176                 if auto_indent < 0:
177                     indentation = _remove_ansi_escape_sequences(formatted).find(
178                         lines[0]
179                     )
180                 else:
181                     # optimizes logging by allowing a fixed indentation
182                     indentation = auto_indent
183                 lines[0] = formatted
184                 return ("\n" + " " * indentation).join(lines)
185         return self._fmt % record.__dict__
186 
187 
188 def get_option_ini(config: Config, *names: str):
189     for name in names:
190         ret = config.getoption(name)  # 'default' arg won't work as expected
191         if ret is None:
192             ret = config.getini(name)
193         if ret:
194             return ret
195 
196 
197 def pytest_addoption(parser: Parser) -> None:
198     """Add options to control log capturing."""
199     group = parser.getgroup("logging")
200 
201     def add_option_ini(option, dest, default=None, type=None, **kwargs):
202         parser.addini(
203             dest, default=default, type=type, help="default value for " + option
204         )
205         group.addoption(option, dest=dest, **kwargs)
206 
207     add_option_ini(
208         "--log-level",
209         dest="log_level",
210         default=None,
211         metavar="LEVEL",
212         help=(
213             "level of messages to catch/display.\n"
214             "Not set by default, so it depends on the root/parent log handler's"
215             ' effective level, where it is "WARNING" by default.'
216         ),
217     )
218     add_option_ini(
219         "--log-format",
220         dest="log_format",
221         default=DEFAULT_LOG_FORMAT,
222         help="log format as used by the logging module.",
223     )
224     add_option_ini(
225         "--log-date-format",
226         dest="log_date_format",
227         default=DEFAULT_LOG_DATE_FORMAT,
228         help="log date format as used by the logging module.",
229     )
230     parser.addini(
231         "log_cli",
232         default=False,
233         type="bool",
234         help='enable log display during test run (also known as "live logging").',
235     )
236     add_option_ini(
237         "--log-cli-level", dest="log_cli_level", default=None, help="cli logging level."
238     )
239     add_option_ini(
240         "--log-cli-format",
241         dest="log_cli_format",
242         default=None,
243         help="log format as used by the logging module.",
244     )
245     add_option_ini(
246         "--log-cli-date-format",
247         dest="log_cli_date_format",
248         default=None,
249         help="log date format as used by the logging module.",
250     )
251     add_option_ini(
252         "--log-file",
253         dest="log_file",
254         default=None,
255         help="path to a file when logging will be written to.",
256     )
257     add_option_ini(
258         "--log-file-level",
259         dest="log_file_level",
260         default=None,
261         help="log file logging level.",
262     )
263     add_option_ini(
264         "--log-file-format",
265         dest="log_file_format",
266         default=DEFAULT_LOG_FORMAT,
267         help="log format as used by the logging module.",
268     )
269     add_option_ini(
270         "--log-file-date-format",
271         dest="log_file_date_format",
272         default=DEFAULT_LOG_DATE_FORMAT,
273         help="log date format as used by the logging module.",
274     )
275     add_option_ini(
276         "--log-auto-indent",
277         dest="log_auto_indent",
278         default=None,
279         help="Auto-indent multiline messages passed to the logging module. Accepts true|on, false|off or an integer.",
280     )
281 
282 
283 _HandlerType = TypeVar("_HandlerType", bound=logging.Handler)
284 
285 
286 # Not using @contextmanager for performance reasons.
287 class catching_logs:
288     """Context manager that prepares the whole logging machinery properly."""
289 
290     __slots__ = ("handler", "level", "orig_level")
291 
292     def __init__(self, handler: _HandlerType, level: Optional[int] = None) -> None:
293         self.handler = handler
294         self.level = level
295 
296     def __enter__(self):
297         root_logger = logging.getLogger()
298         if self.level is not None:
299             self.handler.setLevel(self.level)
300         root_logger.addHandler(self.handler)
301         if self.level is not None:
302             self.orig_level = root_logger.level
303             root_logger.setLevel(min(self.orig_level, self.level))
304         return self.handler
305 
306     def __exit__(self, type, value, traceback):
307         root_logger = logging.getLogger()
308         if self.level is not None:
309             root_logger.setLevel(self.orig_level)
310         root_logger.removeHandler(self.handler)
311 
312 
313 class LogCaptureHandler(logging.StreamHandler):
314     """A logging handler that stores log records and the log text."""
315 
316     stream = None  # type: StringIO
317 
318     def __init__(self) -> None:
319         """Creates a new log handler."""
320         super().__init__(StringIO())
321         self.records = []  # type: List[logging.LogRecord]
322 
323     def emit(self, record: logging.LogRecord) -> None:
324         """Keep the log records in a list in addition to the log text."""
325         self.records.append(record)
326         super().emit(record)
327 
328     def reset(self) -> None:
329         self.records = []
330         self.stream = StringIO()
331 
332     def handleError(self, record: logging.LogRecord) -> None:
333         if logging.raiseExceptions:
334             # Fail the test if the log message is bad (emit failed).
335             # The default behavior of logging is to print "Logging error"
336             # to stderr with the call stack and some extra details.
337             # pytest wants to make such mistakes visible during testing.
338             raise
339 
340 
341 class LogCaptureFixture:
342     """Provides access and control of log capturing."""
343 
344     def __init__(self, item: nodes.Node) -> None:
345         """Creates a new funcarg."""
346         self._item = item
347         # dict of log name -> log level
348         self._initial_logger_levels = {}  # type: Dict[Optional[str], int]
349 
350     def _finalize(self) -> None:
351         """Finalizes the fixture.
352 
353         This restores the log levels changed by :meth:`set_level`.
354         """
355         # restore log levels
356         for logger_name, level in self._initial_logger_levels.items():
357             logger = logging.getLogger(logger_name)
358             logger.setLevel(level)
359 
360     @property
361     def handler(self) -> LogCaptureHandler:
362         """
363         :rtype: LogCaptureHandler
364         """
365         return self._item._store[caplog_handler_key]
366 
367     def get_records(self, when: str) -> List[logging.LogRecord]:
368         """
369         Get the logging records for one of the possible test phases.
370 
371         :param str when:
372             Which test phase to obtain the records from. Valid values are: "setup", "call" and "teardown".
373 
374         :rtype: List[logging.LogRecord]
375         :return: the list of captured records at the given stage
376 
377         .. versionadded:: 3.4
378         """
379         return self._item._store[caplog_records_key].get(when, [])
380 
381     @property
382     def text(self) -> str:
383         """Returns the formatted log text."""
384         return _remove_ansi_escape_sequences(self.handler.stream.getvalue())
385 
386     @property
387     def records(self) -> List[logging.LogRecord]:
388         """Returns the list of log records."""
389         return self.handler.records
390 
391     @property
392     def record_tuples(self) -> List[Tuple[str, int, str]]:
393         """Returns a list of a stripped down version of log records intended
394         for use in assertion comparison.
395 
396         The format of the tuple is:
397 
398             (logger_name, log_level, message)
399         """
400         return [(r.name, r.levelno, r.getMessage()) for r in self.records]
401 
402     @property
403     def messages(self) -> List[str]:
404         """Returns a list of format-interpolated log messages.
405 
406         Unlike 'records', which contains the format string and parameters for interpolation, log messages in this list
407         are all interpolated.
408         Unlike 'text', which contains the output from the handler, log messages in this list are unadorned with
409         levels, timestamps, etc, making exact comparisons more reliable.
410 
411         Note that traceback or stack info (from :func:`logging.exception` or the `exc_info` or `stack_info` arguments
412         to the logging functions) is not included, as this is added by the formatter in the handler.
413 
414         .. versionadded:: 3.7
415         """
416         return [r.getMessage() for r in self.records]
417 
418     def clear(self) -> None:
419         """Reset the list of log records and the captured log text."""
420         self.handler.reset()
421 
422     def set_level(self, level: Union[int, str], logger: Optional[str] = None) -> None:
423         """Sets the level for capturing of logs. The level will be restored to its previous value at the end of
424         the test.
425 
426         :param int level: the logger to level.
427         :param str logger: the logger to update the level. If not given, the root logger level is updated.
428 
429         .. versionchanged:: 3.4
430             The levels of the loggers changed by this function will be restored to their initial values at the
431             end of the test.
432         """
433         logger_obj = logging.getLogger(logger)
434         # save the original log-level to restore it during teardown
435         self._initial_logger_levels.setdefault(logger, logger_obj.level)
436         logger_obj.setLevel(level)
437         self.handler.setLevel(level)
438 
439     @contextmanager
440     def at_level(
441         self, level: int, logger: Optional[str] = None
442     ) -> Generator[None, None, None]:
443         """Context manager that sets the level for capturing of logs. After the end of the 'with' statement the
444         level is restored to its original value.
445 
446         :param int level: the logger to level.
447         :param str logger: the logger to update the level. If not given, the root logger level is updated.
448         """
449         logger_obj = logging.getLogger(logger)
450         orig_level = logger_obj.level
451         logger_obj.setLevel(level)
452         handler_orig_level = self.handler.level
453         self.handler.setLevel(level)
454         try:
455             yield
456         finally:
457             logger_obj.setLevel(orig_level)
458             self.handler.setLevel(handler_orig_level)
459 
460 
461 @pytest.fixture
462 def caplog(request: FixtureRequest) -> Generator[LogCaptureFixture, None, None]:
463     """Access and control log capturing.
464 
465     Captured logs are available through the following properties/methods::
466 
467     * caplog.messages        -> list of format-interpolated log messages
468     * caplog.text            -> string containing formatted log output
469     * caplog.records         -> list of logging.LogRecord instances
470     * caplog.record_tuples   -> list of (logger_name, level, message) tuples
471     * caplog.clear()         -> clear captured records and formatted log output string
472     """
473     result = LogCaptureFixture(request.node)
474     yield result
475     result._finalize()
476 
477 
478 def get_log_level_for_setting(config: Config, *setting_names: str) -> Optional[int]:
479     for setting_name in setting_names:
480         log_level = config.getoption(setting_name)
481         if log_level is None:
482             log_level = config.getini(setting_name)
483         if log_level:
484             break
485     else:
486         return None
487 
488     if isinstance(log_level, str):
489         log_level = log_level.upper()
490     try:
491         return int(getattr(logging, log_level, log_level))
492     except ValueError as e:
493         # Python logging does not recognise this as a logging level
494         raise pytest.UsageError(
495             "'{}' is not recognized as a logging level name for "
496             "'{}'. Please consider passing the "
497             "logging level num instead.".format(log_level, setting_name)
498         ) from e
499 
500 
501 # run after terminalreporter/capturemanager are configured
502 @pytest.hookimpl(trylast=True)
503 def pytest_configure(config: Config) -> None:
504     config.pluginmanager.register(LoggingPlugin(config), "logging-plugin")
505 
506 
507 class LoggingPlugin:
508     """Attaches to the logging module and captures log messages for each test.
509     """
510 
511     def __init__(self, config: Config) -> None:
512         """Creates a new plugin to capture log messages.
513 
514         The formatter can be safely shared across all handlers so
515         create a single one for the entire test session here.
516         """
517         self._config = config
518 
519         # Report logging.
520         self.formatter = self._create_formatter(
521             get_option_ini(config, "log_format"),
522             get_option_ini(config, "log_date_format"),
523             get_option_ini(config, "log_auto_indent"),
524         )
525         self.log_level = get_log_level_for_setting(config, "log_level")
526         self.caplog_handler = LogCaptureHandler()
527         self.caplog_handler.setFormatter(self.formatter)
528         self.report_handler = LogCaptureHandler()
529         self.report_handler.setFormatter(self.formatter)
530 
531         # File logging.
532         self.log_file_level = get_log_level_for_setting(config, "log_file_level")
533         log_file = get_option_ini(config, "log_file") or os.devnull
534         self.log_file_handler = _FileHandler(log_file, mode="w", encoding="UTF-8")
535         log_file_format = get_option_ini(config, "log_file_format", "log_format")
536         log_file_date_format = get_option_ini(
537             config, "log_file_date_format", "log_date_format"
538         )
539         log_file_formatter = logging.Formatter(
540             log_file_format, datefmt=log_file_date_format
541         )
542         self.log_file_handler.setFormatter(log_file_formatter)
543 
544         # CLI/live logging.
545         self.log_cli_level = get_log_level_for_setting(
546             config, "log_cli_level", "log_level"
547         )
548         if self._log_cli_enabled():
549             terminal_reporter = config.pluginmanager.get_plugin("terminalreporter")
550             capture_manager = config.pluginmanager.get_plugin("capturemanager")
551             # if capturemanager plugin is disabled, live logging still works.
552             self.log_cli_handler = _LiveLoggingStreamHandler(
553                 terminal_reporter, capture_manager
554             )  # type: Union[_LiveLoggingStreamHandler, _LiveLoggingNullHandler]
555         else:
556             self.log_cli_handler = _LiveLoggingNullHandler()
557         log_cli_formatter = self._create_formatter(
558             get_option_ini(config, "log_cli_format", "log_format"),
559             get_option_ini(config, "log_cli_date_format", "log_date_format"),
560             get_option_ini(config, "log_auto_indent"),
561         )
562         self.log_cli_handler.setFormatter(log_cli_formatter)
563 
564     def _create_formatter(self, log_format, log_date_format, auto_indent):
565         # color option doesn't exist if terminal plugin is disabled
566         color = getattr(self._config.option, "color", "no")
567         if color != "no" and ColoredLevelFormatter.LEVELNAME_FMT_REGEX.search(
568             log_format
569         ):
570             formatter = ColoredLevelFormatter(
571                 create_terminal_writer(self._config), log_format, log_date_format
572             )  # type: logging.Formatter
573         else:
574             formatter = logging.Formatter(log_format, log_date_format)
575 
576         formatter._style = PercentStyleMultiline(
577             formatter._style._fmt, auto_indent=auto_indent
578         )
579 
580         return formatter
581 
582     def set_log_path(self, fname: str) -> None:
583         """Public method, which can set filename parameter for
584         Logging.FileHandler(). Also creates parent directory if
585         it does not exist.
586 
587         .. warning::
588             Please considered as an experimental API.
589         """
590         fpath = Path(fname)
591 
592         if not fpath.is_absolute():
593             fpath = Path(str(self._config.rootdir), fpath)
594 
595         if not fpath.parent.exists():
596             fpath.parent.mkdir(exist_ok=True, parents=True)
597 
598         stream = fpath.open(mode="w", encoding="UTF-8")
599         if sys.version_info >= (3, 7):
600             old_stream = self.log_file_handler.setStream(stream)
601         else:
602             old_stream = self.log_file_handler.stream
603             self.log_file_handler.acquire()
604             try:
605                 self.log_file_handler.flush()
606                 self.log_file_handler.stream = stream
607             finally:
608                 self.log_file_handler.release()
609         if old_stream:
610             old_stream.close()
611 
612     def _log_cli_enabled(self):
613         """Return whether live logging is enabled."""
614         enabled = self._config.getoption(
615             "--log-cli-level"
616         ) is not None or self._config.getini("log_cli")
617         if not enabled:
618             return False
619 
620         terminal_reporter = self._config.pluginmanager.get_plugin("terminalreporter")
621         if terminal_reporter is None:
622             # terminal reporter is disabled e.g. by pytest-xdist.
623             return False
624 
625         return True
626 
627     @pytest.hookimpl(hookwrapper=True, tryfirst=True)
628     def pytest_sessionstart(self) -> Generator[None, None, None]:
629         self.log_cli_handler.set_when("sessionstart")
630 
631         with catching_logs(self.log_cli_handler, level=self.log_cli_level):
632             with catching_logs(self.log_file_handler, level=self.log_file_level):
633                 yield
634 
635     @pytest.hookimpl(hookwrapper=True, tryfirst=True)
636     def pytest_collection(self) -> Generator[None, None, None]:
637         self.log_cli_handler.set_when("collection")
638 
639         with catching_logs(self.log_cli_handler, level=self.log_cli_level):
640             with catching_logs(self.log_file_handler, level=self.log_file_level):
641                 yield
642 
643     @pytest.hookimpl(hookwrapper=True)
644     def pytest_runtestloop(self, session: Session) -> Generator[None, None, None]:
645         """Runs all collected test items."""
646 
647         if session.config.option.collectonly:
648             yield
649             return
650 
651         if self._log_cli_enabled() and self._config.getoption("verbose") < 1:
652             # setting verbose flag is needed to avoid messy test progress output
653             self._config.option.verbose = 1
654 
655         with catching_logs(self.log_cli_handler, level=self.log_cli_level):
656             with catching_logs(self.log_file_handler, level=self.log_file_level):
657                 yield  # run all the tests
658 
659     @pytest.hookimpl
660     def pytest_runtest_logstart(self) -> None:
661         self.log_cli_handler.reset()
662         self.log_cli_handler.set_when("start")
663 
664     @pytest.hookimpl
665     def pytest_runtest_logreport(self) -> None:
666         self.log_cli_handler.set_when("logreport")
667 
668     def _runtest_for(self, item: nodes.Item, when: str) -> Generator[None, None, None]:
669         """Implements the internals of pytest_runtest_xxx() hook."""
670         with catching_logs(
671             self.caplog_handler, level=self.log_level,
672         ) as caplog_handler, catching_logs(
673             self.report_handler, level=self.log_level,
674         ) as report_handler:
675             caplog_handler.reset()
676             report_handler.reset()
677             item._store[caplog_records_key][when] = caplog_handler.records
678             item._store[caplog_handler_key] = caplog_handler
679 
680             yield
681 
682             log = report_handler.stream.getvalue().strip()
683             item.add_report_section(when, "log", log)
684 
685     @pytest.hookimpl(hookwrapper=True)
686     def pytest_runtest_setup(self, item: nodes.Item) -> Generator[None, None, None]:
687         self.log_cli_handler.set_when("setup")
688 
689         empty = {}  # type: Dict[str, List[logging.LogRecord]]
690         item._store[caplog_records_key] = empty
691         yield from self._runtest_for(item, "setup")
692 
693     @pytest.hookimpl(hookwrapper=True)
694     def pytest_runtest_call(self, item: nodes.Item) -> Generator[None, None, None]:
695         self.log_cli_handler.set_when("call")
696 
697         yield from self._runtest_for(item, "call")
698 
699     @pytest.hookimpl(hookwrapper=True)
700     def pytest_runtest_teardown(self, item: nodes.Item) -> Generator[None, None, None]:
701         self.log_cli_handler.set_when("teardown")
702 
703         yield from self._runtest_for(item, "teardown")
704         del item._store[caplog_records_key]
705         del item._store[caplog_handler_key]
706 
707     @pytest.hookimpl
708     def pytest_runtest_logfinish(self) -> None:
709         self.log_cli_handler.set_when("finish")
710 
711     @pytest.hookimpl(hookwrapper=True, tryfirst=True)
712     def pytest_sessionfinish(self) -> Generator[None, None, None]:
713         self.log_cli_handler.set_when("sessionfinish")
714 
715         with catching_logs(self.log_cli_handler, level=self.log_cli_level):
716             with catching_logs(self.log_file_handler, level=self.log_file_level):
717                 yield
718 
719     @pytest.hookimpl
720     def pytest_unconfigure(self) -> None:
721         # Close the FileHandler explicitly.
722         # (logging.shutdown might have lost the weakref?!)
723         self.log_file_handler.close()
724 
725 
726 class _FileHandler(logging.FileHandler):
727     """
728     Custom FileHandler with pytest tweaks.
729     """
730 
731     def handleError(self, record: logging.LogRecord) -> None:
732         # Handled by LogCaptureHandler.
733         pass
734 
735 
736 class _LiveLoggingStreamHandler(logging.StreamHandler):
737     """
738     Custom StreamHandler used by the live logging feature: it will write a newline before the first log message
739     in each test.
740 
741     During live logging we must also explicitly disable stdout/stderr capturing otherwise it will get captured
742     and won't appear in the terminal.
743     """
744 
745     # Officially stream needs to be a IO[str], but TerminalReporter
746     # isn't. So force it.
747     stream = None  # type: TerminalReporter # type: ignore
748 
749     def __init__(
750         self,
751         terminal_reporter: TerminalReporter,
752         capture_manager: Optional[CaptureManager],
753     ) -> None:
754         """
755         :param _pytest.terminal.TerminalReporter terminal_reporter:
756         :param _pytest.capture.CaptureManager capture_manager:
757         """
758         logging.StreamHandler.__init__(self, stream=terminal_reporter)  # type: ignore[arg-type] # noqa: F821
759         self.capture_manager = capture_manager
760         self.reset()
761         self.set_when(None)
762         self._test_outcome_written = False
763 
764     def reset(self) -> None:
765         """Reset the handler; should be called before the start of each test"""
766         self._first_record_emitted = False
767 
768     def set_when(self, when: Optional[str]) -> None:
769         """Prepares for the given test phase (setup/call/teardown)"""
770         self._when = when
771         self._section_name_shown = False
772         if when == "start":
773             self._test_outcome_written = False
774 
775     def emit(self, record: logging.LogRecord) -> None:
776         ctx_manager = (
777             self.capture_manager.global_and_fixture_disabled()
778             if self.capture_manager
779             else nullcontext()
780         )
781         with ctx_manager:
782             if not self._first_record_emitted:
783                 self.stream.write("\n")
784                 self._first_record_emitted = True
785             elif self._when in ("teardown", "finish"):
786                 if not self._test_outcome_written:
787                     self._test_outcome_written = True
788                     self.stream.write("\n")
789             if not self._section_name_shown and self._when:
790                 self.stream.section("live log " + self._when, sep="-", bold=True)
791                 self._section_name_shown = True
792             super().emit(record)
793 
794     def handleError(self, record: logging.LogRecord) -> None:
795         # Handled by LogCaptureHandler.
796         pass
797 
798 
799 class _LiveLoggingNullHandler(logging.NullHandler):
800     """A handler used when live logging is disabled."""
801 
802     def reset(self) -> None:
803         pass
804 
805     def set_when(self, when: str) -> None:
806         pass
807 
808     def handleError(self, record: logging.LogRecord) -> None:
809         # Handled by LogCaptureHandler.
810         pass

</code><intended_behavior>Within the handling of the `--log-file` option in `src/_pytest/logging.py`, the code should be updated to include a check for the existence of the directory specified for the log file. If the directory does not exist, it should be created before the log file is opened for writing. This behavior ensures that providing a `--log-file` argument with non-existing subdirectories does not result in a `FileNotFoundError`. This fix should preserve the existing functionality of log file handling while adding the safeguard to automatically create required directories, aligning it with how other parts of pytest, like `resultlog.py` and `junitxml.py`, manage directory creation for files. This would involve a sequence similar to:

```python
dirname = os.path.dirname(os.path.abspath(logfile))
if not os.path.isdir(dirname):
    os.makedirs(dirname)
```

Before the logfile is opened within the logging setup process, this additional check ensures compatibility and user-friendly behavior for all valid `--log-file` input paths.</intended_behavior>]
2025-10-15 22:55:33.963 | INFO     | Search completed. Bug locations: [<file>src/_pytest/logging.py</file>
<class>None</class>
<method>None</method>
<code>
1 """ Access and control log capturing. """
2 import logging
3 import os
4 import re
5 import sys
6 from contextlib import contextmanager
7 from io import StringIO
8 from typing import AbstractSet
9 from typing import Dict
10 from typing import Generator
11 from typing import List
12 from typing import Mapping
13 from typing import Optional
14 from typing import Tuple
15 from typing import TypeVar
16 from typing import Union
17 
18 import pytest
19 from _pytest import nodes
20 from _pytest._io import TerminalWriter
21 from _pytest.capture import CaptureManager
22 from _pytest.compat import nullcontext
23 from _pytest.config import _strtobool
24 from _pytest.config import Config
25 from _pytest.config import create_terminal_writer
26 from _pytest.config.argparsing import Parser
27 from _pytest.fixtures import FixtureRequest
28 from _pytest.main import Session
29 from _pytest.pathlib import Path
30 from _pytest.store import StoreKey
31 from _pytest.terminal import TerminalReporter
32 
33 
34 DEFAULT_LOG_FORMAT = "%(levelname)-8s %(name)s:%(filename)s:%(lineno)d %(message)s"
35 DEFAULT_LOG_DATE_FORMAT = "%H:%M:%S"
36 _ANSI_ESCAPE_SEQ = re.compile(r"\x1b\[[\d;]+m")
37 caplog_handler_key = StoreKey["LogCaptureHandler"]()
38 caplog_records_key = StoreKey[Dict[str, List[logging.LogRecord]]]()
39 
40 
41 def _remove_ansi_escape_sequences(text: str) -> str:
42     return _ANSI_ESCAPE_SEQ.sub("", text)
43 
44 
45 class ColoredLevelFormatter(logging.Formatter):
46     """
47     Colorize the %(levelname)..s part of the log format passed to __init__.
48     """
49 
50     LOGLEVEL_COLOROPTS = {
51         logging.CRITICAL: {"red"},
52         logging.ERROR: {"red", "bold"},
53         logging.WARNING: {"yellow"},
54         logging.WARN: {"yellow"},
55         logging.INFO: {"green"},
56         logging.DEBUG: {"purple"},
57         logging.NOTSET: set(),
58     }  # type: Mapping[int, AbstractSet[str]]
59     LEVELNAME_FMT_REGEX = re.compile(r"%\(levelname\)([+-.]?\d*s)")
60 
61     def __init__(self, terminalwriter: TerminalWriter, *args, **kwargs) -> None:
62         super().__init__(*args, **kwargs)
63         self._original_fmt = self._style._fmt
64         self._level_to_fmt_mapping = {}  # type: Dict[int, str]
65 
66         assert self._fmt is not None
67         levelname_fmt_match = self.LEVELNAME_FMT_REGEX.search(self._fmt)
68         if not levelname_fmt_match:
69             return
70         levelname_fmt = levelname_fmt_match.group()
71 
72         for level, color_opts in self.LOGLEVEL_COLOROPTS.items():
73             formatted_levelname = levelname_fmt % {
74                 "levelname": logging.getLevelName(level)
75             }
76 
77             # add ANSI escape sequences around the formatted levelname
78             color_kwargs = {name: True for name in color_opts}
79             colorized_formatted_levelname = terminalwriter.markup(
80                 formatted_levelname, **color_kwargs
81             )
82             self._level_to_fmt_mapping[level] = self.LEVELNAME_FMT_REGEX.sub(
83                 colorized_formatted_levelname, self._fmt
84             )
85 
86     def format(self, record: logging.LogRecord) -> str:
87         fmt = self._level_to_fmt_mapping.get(record.levelno, self._original_fmt)
88         self._style._fmt = fmt
89         return super().format(record)
90 
91 
92 class PercentStyleMultiline(logging.PercentStyle):
93     """A logging style with special support for multiline messages.
94 
95     If the message of a record consists of multiple lines, this style
96     formats the message as if each line were logged separately.
97     """
98 
99     def __init__(self, fmt: str, auto_indent: Union[int, str, bool, None]) -> None:
100         super().__init__(fmt)
101         self._auto_indent = self._get_auto_indent(auto_indent)
102 
103     @staticmethod
104     def _update_message(
105         record_dict: Dict[str, object], message: str
106     ) -> Dict[str, object]:
107         tmp = record_dict.copy()
108         tmp["message"] = message
109         return tmp
110 
111     @staticmethod
112     def _get_auto_indent(auto_indent_option: Union[int, str, bool, None]) -> int:
113         """Determines the current auto indentation setting
114 
115         Specify auto indent behavior (on/off/fixed) by passing in
116         extra={"auto_indent": [value]} to the call to logging.log() or
117         using a --log-auto-indent [value] command line or the
118         log_auto_indent [value] config option.
119 
120         Default behavior is auto-indent off.
121 
122         Using the string "True" or "on" or the boolean True as the value
123         turns auto indent on, using the string "False" or "off" or the
124         boolean False or the int 0 turns it off, and specifying a
125         positive integer fixes the indentation position to the value
126         specified.
127 
128         Any other values for the option are invalid, and will silently be
129         converted to the default.
130 
131         :param any auto_indent_option: User specified option for indentation
132             from command line, config or extra kwarg. Accepts int, bool or str.
133             str option accepts the same range of values as boolean config options,
134             as well as positive integers represented in str form.
135 
136         :returns: indentation value, which can be
137             -1 (automatically determine indentation) or
138             0 (auto-indent turned off) or
139             >0 (explicitly set indentation position).
140         """
141 
142         if auto_indent_option is None:
143             return 0
144         elif isinstance(auto_indent_option, bool):
145             if auto_indent_option:
146                 return -1
147             else:
148                 return 0
149         elif isinstance(auto_indent_option, int):
150             return int(auto_indent_option)
151         elif isinstance(auto_indent_option, str):
152             try:
153                 return int(auto_indent_option)
154             except ValueError:
155                 pass
156             try:
157                 if _strtobool(auto_indent_option):
158                     return -1
159             except ValueError:
160                 return 0
161 
162         return 0
163 
164     def format(self, record: logging.LogRecord) -> str:
165         if "\n" in record.message:
166             if hasattr(record, "auto_indent"):
167                 # passed in from the "extra={}" kwarg on the call to logging.log()
168                 auto_indent = self._get_auto_indent(record.auto_indent)  # type: ignore[attr-defined] # noqa: F821
169             else:
170                 auto_indent = self._auto_indent
171 
172             if auto_indent:
173                 lines = record.message.splitlines()
174                 formatted = self._fmt % self._update_message(record.__dict__, lines[0])
175 
176                 if auto_indent < 0:
177                     indentation = _remove_ansi_escape_sequences(formatted).find(
178                         lines[0]
179                     )
180                 else:
181                     # optimizes logging by allowing a fixed indentation
182                     indentation = auto_indent
183                 lines[0] = formatted
184                 return ("\n" + " " * indentation).join(lines)
185         return self._fmt % record.__dict__
186 
187 
188 def get_option_ini(config: Config, *names: str):
189     for name in names:
190         ret = config.getoption(name)  # 'default' arg won't work as expected
191         if ret is None:
192             ret = config.getini(name)
193         if ret:
194             return ret
195 
196 
197 def pytest_addoption(parser: Parser) -> None:
198     """Add options to control log capturing."""
199     group = parser.getgroup("logging")
200 
201     def add_option_ini(option, dest, default=None, type=None, **kwargs):
202         parser.addini(
203             dest, default=default, type=type, help="default value for " + option
204         )
205         group.addoption(option, dest=dest, **kwargs)
206 
207     add_option_ini(
208         "--log-level",
209         dest="log_level",
210         default=None,
211         metavar="LEVEL",
212         help=(
213             "level of messages to catch/display.\n"
214             "Not set by default, so it depends on the root/parent log handler's"
215             ' effective level, where it is "WARNING" by default.'
216         ),
217     )
218     add_option_ini(
219         "--log-format",
220         dest="log_format",
221         default=DEFAULT_LOG_FORMAT,
222         help="log format as used by the logging module.",
223     )
224     add_option_ini(
225         "--log-date-format",
226         dest="log_date_format",
227         default=DEFAULT_LOG_DATE_FORMAT,
228         help="log date format as used by the logging module.",
229     )
230     parser.addini(
231         "log_cli",
232         default=False,
233         type="bool",
234         help='enable log display during test run (also known as "live logging").',
235     )
236     add_option_ini(
237         "--log-cli-level", dest="log_cli_level", default=None, help="cli logging level."
238     )
239     add_option_ini(
240         "--log-cli-format",
241         dest="log_cli_format",
242         default=None,
243         help="log format as used by the logging module.",
244     )
245     add_option_ini(
246         "--log-cli-date-format",
247         dest="log_cli_date_format",
248         default=None,
249         help="log date format as used by the logging module.",
250     )
251     add_option_ini(
252         "--log-file",
253         dest="log_file",
254         default=None,
255         help="path to a file when logging will be written to.",
256     )
257     add_option_ini(
258         "--log-file-level",
259         dest="log_file_level",
260         default=None,
261         help="log file logging level.",
262     )
263     add_option_ini(
264         "--log-file-format",
265         dest="log_file_format",
266         default=DEFAULT_LOG_FORMAT,
267         help="log format as used by the logging module.",
268     )
269     add_option_ini(
270         "--log-file-date-format",
271         dest="log_file_date_format",
272         default=DEFAULT_LOG_DATE_FORMAT,
273         help="log date format as used by the logging module.",
274     )
275     add_option_ini(
276         "--log-auto-indent",
277         dest="log_auto_indent",
278         default=None,
279         help="Auto-indent multiline messages passed to the logging module. Accepts true|on, false|off or an integer.",
280     )
281 
282 
283 _HandlerType = TypeVar("_HandlerType", bound=logging.Handler)
284 
285 
286 # Not using @contextmanager for performance reasons.
287 class catching_logs:
288     """Context manager that prepares the whole logging machinery properly."""
289 
290     __slots__ = ("handler", "level", "orig_level")
291 
292     def __init__(self, handler: _HandlerType, level: Optional[int] = None) -> None:
293         self.handler = handler
294         self.level = level
295 
296     def __enter__(self):
297         root_logger = logging.getLogger()
298         if self.level is not None:
299             self.handler.setLevel(self.level)
300         root_logger.addHandler(self.handler)
301         if self.level is not None:
302             self.orig_level = root_logger.level
303             root_logger.setLevel(min(self.orig_level, self.level))
304         return self.handler
305 
306     def __exit__(self, type, value, traceback):
307         root_logger = logging.getLogger()
308         if self.level is not None:
309             root_logger.setLevel(self.orig_level)
310         root_logger.removeHandler(self.handler)
311 
312 
313 class LogCaptureHandler(logging.StreamHandler):
314     """A logging handler that stores log records and the log text."""
315 
316     stream = None  # type: StringIO
317 
318     def __init__(self) -> None:
319         """Creates a new log handler."""
320         super().__init__(StringIO())
321         self.records = []  # type: List[logging.LogRecord]
322 
323     def emit(self, record: logging.LogRecord) -> None:
324         """Keep the log records in a list in addition to the log text."""
325         self.records.append(record)
326         super().emit(record)
327 
328     def reset(self) -> None:
329         self.records = []
330         self.stream = StringIO()
331 
332     def handleError(self, record: logging.LogRecord) -> None:
333         if logging.raiseExceptions:
334             # Fail the test if the log message is bad (emit failed).
335             # The default behavior of logging is to print "Logging error"
336             # to stderr with the call stack and some extra details.
337             # pytest wants to make such mistakes visible during testing.
338             raise
339 
340 
341 class LogCaptureFixture:
342     """Provides access and control of log capturing."""
343 
344     def __init__(self, item: nodes.Node) -> None:
345         """Creates a new funcarg."""
346         self._item = item
347         # dict of log name -> log level
348         self._initial_logger_levels = {}  # type: Dict[Optional[str], int]
349 
350     def _finalize(self) -> None:
351         """Finalizes the fixture.
352 
353         This restores the log levels changed by :meth:`set_level`.
354         """
355         # restore log levels
356         for logger_name, level in self._initial_logger_levels.items():
357             logger = logging.getLogger(logger_name)
358             logger.setLevel(level)
359 
360     @property
361     def handler(self) -> LogCaptureHandler:
362         """
363         :rtype: LogCaptureHandler
364         """
365         return self._item._store[caplog_handler_key]
366 
367     def get_records(self, when: str) -> List[logging.LogRecord]:
368         """
369         Get the logging records for one of the possible test phases.
370 
371         :param str when:
372             Which test phase to obtain the records from. Valid values are: "setup", "call" and "teardown".
373 
374         :rtype: List[logging.LogRecord]
375         :return: the list of captured records at the given stage
376 
377         .. versionadded:: 3.4
378         """
379         return self._item._store[caplog_records_key].get(when, [])
380 
381     @property
382     def text(self) -> str:
383         """Returns the formatted log text."""
384         return _remove_ansi_escape_sequences(self.handler.stream.getvalue())
385 
386     @property
387     def records(self) -> List[logging.LogRecord]:
388         """Returns the list of log records."""
389         return self.handler.records
390 
391     @property
392     def record_tuples(self) -> List[Tuple[str, int, str]]:
393         """Returns a list of a stripped down version of log records intended
394         for use in assertion comparison.
395 
396         The format of the tuple is:
397 
398             (logger_name, log_level, message)
399         """
400         return [(r.name, r.levelno, r.getMessage()) for r in self.records]
401 
402     @property
403     def messages(self) -> List[str]:
404         """Returns a list of format-interpolated log messages.
405 
406         Unlike 'records', which contains the format string and parameters for interpolation, log messages in this list
407         are all interpolated.
408         Unlike 'text', which contains the output from the handler, log messages in this list are unadorned with
409         levels, timestamps, etc, making exact comparisons more reliable.
410 
411         Note that traceback or stack info (from :func:`logging.exception` or the `exc_info` or `stack_info` arguments
412         to the logging functions) is not included, as this is added by the formatter in the handler.
413 
414         .. versionadded:: 3.7
415         """
416         return [r.getMessage() for r in self.records]
417 
418     def clear(self) -> None:
419         """Reset the list of log records and the captured log text."""
420         self.handler.reset()
421 
422     def set_level(self, level: Union[int, str], logger: Optional[str] = None) -> None:
423         """Sets the level for capturing of logs. The level will be restored to its previous value at the end of
424         the test.
425 
426         :param int level: the logger to level.
427         :param str logger: the logger to update the level. If not given, the root logger level is updated.
428 
429         .. versionchanged:: 3.4
430             The levels of the loggers changed by this function will be restored to their initial values at the
431             end of the test.
432         """
433         logger_obj = logging.getLogger(logger)
434         # save the original log-level to restore it during teardown
435         self._initial_logger_levels.setdefault(logger, logger_obj.level)
436         logger_obj.setLevel(level)
437         self.handler.setLevel(level)
438 
439     @contextmanager
440     def at_level(
441         self, level: int, logger: Optional[str] = None
442     ) -> Generator[None, None, None]:
443         """Context manager that sets the level for capturing of logs. After the end of the 'with' statement the
444         level is restored to its original value.
445 
446         :param int level: the logger to level.
447         :param str logger: the logger to update the level. If not given, the root logger level is updated.
448         """
449         logger_obj = logging.getLogger(logger)
450         orig_level = logger_obj.level
451         logger_obj.setLevel(level)
452         handler_orig_level = self.handler.level
453         self.handler.setLevel(level)
454         try:
455             yield
456         finally:
457             logger_obj.setLevel(orig_level)
458             self.handler.setLevel(handler_orig_level)
459 
460 
461 @pytest.fixture
462 def caplog(request: FixtureRequest) -> Generator[LogCaptureFixture, None, None]:
463     """Access and control log capturing.
464 
465     Captured logs are available through the following properties/methods::
466 
467     * caplog.messages        -> list of format-interpolated log messages
468     * caplog.text            -> string containing formatted log output
469     * caplog.records         -> list of logging.LogRecord instances
470     * caplog.record_tuples   -> list of (logger_name, level, message) tuples
471     * caplog.clear()         -> clear captured records and formatted log output string
472     """
473     result = LogCaptureFixture(request.node)
474     yield result
475     result._finalize()
476 
477 
478 def get_log_level_for_setting(config: Config, *setting_names: str) -> Optional[int]:
479     for setting_name in setting_names:
480         log_level = config.getoption(setting_name)
481         if log_level is None:
482             log_level = config.getini(setting_name)
483         if log_level:
484             break
485     else:
486         return None
487 
488     if isinstance(log_level, str):
489         log_level = log_level.upper()
490     try:
491         return int(getattr(logging, log_level, log_level))
492     except ValueError as e:
493         # Python logging does not recognise this as a logging level
494         raise pytest.UsageError(
495             "'{}' is not recognized as a logging level name for "
496             "'{}'. Please consider passing the "
497             "logging level num instead.".format(log_level, setting_name)
498         ) from e
499 
500 
501 # run after terminalreporter/capturemanager are configured
502 @pytest.hookimpl(trylast=True)
503 def pytest_configure(config: Config) -> None:
504     config.pluginmanager.register(LoggingPlugin(config), "logging-plugin")
505 
506 
507 class LoggingPlugin:
508     """Attaches to the logging module and captures log messages for each test.
509     """
510 
511     def __init__(self, config: Config) -> None:
512         """Creates a new plugin to capture log messages.
513 
514         The formatter can be safely shared across all handlers so
515         create a single one for the entire test session here.
516         """
517         self._config = config
518 
519         # Report logging.
520         self.formatter = self._create_formatter(
521             get_option_ini(config, "log_format"),
522             get_option_ini(config, "log_date_format"),
523             get_option_ini(config, "log_auto_indent"),
524         )
525         self.log_level = get_log_level_for_setting(config, "log_level")
526         self.caplog_handler = LogCaptureHandler()
527         self.caplog_handler.setFormatter(self.formatter)
528         self.report_handler = LogCaptureHandler()
529         self.report_handler.setFormatter(self.formatter)
530 
531         # File logging.
532         self.log_file_level = get_log_level_for_setting(config, "log_file_level")
533         log_file = get_option_ini(config, "log_file") or os.devnull
534         self.log_file_handler = _FileHandler(log_file, mode="w", encoding="UTF-8")
535         log_file_format = get_option_ini(config, "log_file_format", "log_format")
536         log_file_date_format = get_option_ini(
537             config, "log_file_date_format", "log_date_format"
538         )
539         log_file_formatter = logging.Formatter(
540             log_file_format, datefmt=log_file_date_format
541         )
542         self.log_file_handler.setFormatter(log_file_formatter)
543 
544         # CLI/live logging.
545         self.log_cli_level = get_log_level_for_setting(
546             config, "log_cli_level", "log_level"
547         )
548         if self._log_cli_enabled():
549             terminal_reporter = config.pluginmanager.get_plugin("terminalreporter")
550             capture_manager = config.pluginmanager.get_plugin("capturemanager")
551             # if capturemanager plugin is disabled, live logging still works.
552             self.log_cli_handler = _LiveLoggingStreamHandler(
553                 terminal_reporter, capture_manager
554             )  # type: Union[_LiveLoggingStreamHandler, _LiveLoggingNullHandler]
555         else:
556             self.log_cli_handler = _LiveLoggingNullHandler()
557         log_cli_formatter = self._create_formatter(
558             get_option_ini(config, "log_cli_format", "log_format"),
559             get_option_ini(config, "log_cli_date_format", "log_date_format"),
560             get_option_ini(config, "log_auto_indent"),
561         )
562         self.log_cli_handler.setFormatter(log_cli_formatter)
563 
564     def _create_formatter(self, log_format, log_date_format, auto_indent):
565         # color option doesn't exist if terminal plugin is disabled
566         color = getattr(self._config.option, "color", "no")
567         if color != "no" and ColoredLevelFormatter.LEVELNAME_FMT_REGEX.search(
568             log_format
569         ):
570             formatter = ColoredLevelFormatter(
571                 create_terminal_writer(self._config), log_format, log_date_format
572             )  # type: logging.Formatter
573         else:
574             formatter = logging.Formatter(log_format, log_date_format)
575 
576         formatter._style = PercentStyleMultiline(
577             formatter._style._fmt, auto_indent=auto_indent
578         )
579 
580         return formatter
581 
582     def set_log_path(self, fname: str) -> None:
583         """Public method, which can set filename parameter for
584         Logging.FileHandler(). Also creates parent directory if
585         it does not exist.
586 
587         .. warning::
588             Please considered as an experimental API.
589         """
590         fpath = Path(fname)
591 
592         if not fpath.is_absolute():
593             fpath = Path(str(self._config.rootdir), fpath)
594 
595         if not fpath.parent.exists():
596             fpath.parent.mkdir(exist_ok=True, parents=True)
597 
598         stream = fpath.open(mode="w", encoding="UTF-8")
599         if sys.version_info >= (3, 7):
600             old_stream = self.log_file_handler.setStream(stream)
601         else:
602             old_stream = self.log_file_handler.stream
603             self.log_file_handler.acquire()
604             try:
605                 self.log_file_handler.flush()
606                 self.log_file_handler.stream = stream
607             finally:
608                 self.log_file_handler.release()
609         if old_stream:
610             old_stream.close()
611 
612     def _log_cli_enabled(self):
613         """Return whether live logging is enabled."""
614         enabled = self._config.getoption(
615             "--log-cli-level"
616         ) is not None or self._config.getini("log_cli")
617         if not enabled:
618             return False
619 
620         terminal_reporter = self._config.pluginmanager.get_plugin("terminalreporter")
621         if terminal_reporter is None:
622             # terminal reporter is disabled e.g. by pytest-xdist.
623             return False
624 
625         return True
626 
627     @pytest.hookimpl(hookwrapper=True, tryfirst=True)
628     def pytest_sessionstart(self) -> Generator[None, None, None]:
629         self.log_cli_handler.set_when("sessionstart")
630 
631         with catching_logs(self.log_cli_handler, level=self.log_cli_level):
632             with catching_logs(self.log_file_handler, level=self.log_file_level):
633                 yield
634 
635     @pytest.hookimpl(hookwrapper=True, tryfirst=True)
636     def pytest_collection(self) -> Generator[None, None, None]:
637         self.log_cli_handler.set_when("collection")
638 
639         with catching_logs(self.log_cli_handler, level=self.log_cli_level):
640             with catching_logs(self.log_file_handler, level=self.log_file_level):
641                 yield
642 
643     @pytest.hookimpl(hookwrapper=True)
644     def pytest_runtestloop(self, session: Session) -> Generator[None, None, None]:
645         """Runs all collected test items."""
646 
647         if session.config.option.collectonly:
648             yield
649             return
650 
651         if self._log_cli_enabled() and self._config.getoption("verbose") < 1:
652             # setting verbose flag is needed to avoid messy test progress output
653             self._config.option.verbose = 1
654 
655         with catching_logs(self.log_cli_handler, level=self.log_cli_level):
656             with catching_logs(self.log_file_handler, level=self.log_file_level):
657                 yield  # run all the tests
658 
659     @pytest.hookimpl
660     def pytest_runtest_logstart(self) -> None:
661         self.log_cli_handler.reset()
662         self.log_cli_handler.set_when("start")
663 
664     @pytest.hookimpl
665     def pytest_runtest_logreport(self) -> None:
666         self.log_cli_handler.set_when("logreport")
667 
668     def _runtest_for(self, item: nodes.Item, when: str) -> Generator[None, None, None]:
669         """Implements the internals of pytest_runtest_xxx() hook."""
670         with catching_logs(
671             self.caplog_handler, level=self.log_level,
672         ) as caplog_handler, catching_logs(
673             self.report_handler, level=self.log_level,
674         ) as report_handler:
675             caplog_handler.reset()
676             report_handler.reset()
677             item._store[caplog_records_key][when] = caplog_handler.records
678             item._store[caplog_handler_key] = caplog_handler
679 
680             yield
681 
682             log = report_handler.stream.getvalue().strip()
683             item.add_report_section(when, "log", log)
684 
685     @pytest.hookimpl(hookwrapper=True)
686     def pytest_runtest_setup(self, item: nodes.Item) -> Generator[None, None, None]:
687         self.log_cli_handler.set_when("setup")
688 
689         empty = {}  # type: Dict[str, List[logging.LogRecord]]
690         item._store[caplog_records_key] = empty
691         yield from self._runtest_for(item, "setup")
692 
693     @pytest.hookimpl(hookwrapper=True)
694     def pytest_runtest_call(self, item: nodes.Item) -> Generator[None, None, None]:
695         self.log_cli_handler.set_when("call")
696 
697         yield from self._runtest_for(item, "call")
698 
699     @pytest.hookimpl(hookwrapper=True)
700     def pytest_runtest_teardown(self, item: nodes.Item) -> Generator[None, None, None]:
701         self.log_cli_handler.set_when("teardown")
702 
703         yield from self._runtest_for(item, "teardown")
704         del item._store[caplog_records_key]
705         del item._store[caplog_handler_key]
706 
707     @pytest.hookimpl
708     def pytest_runtest_logfinish(self) -> None:
709         self.log_cli_handler.set_when("finish")
710 
711     @pytest.hookimpl(hookwrapper=True, tryfirst=True)
712     def pytest_sessionfinish(self) -> Generator[None, None, None]:
713         self.log_cli_handler.set_when("sessionfinish")
714 
715         with catching_logs(self.log_cli_handler, level=self.log_cli_level):
716             with catching_logs(self.log_file_handler, level=self.log_file_level):
717                 yield
718 
719     @pytest.hookimpl
720     def pytest_unconfigure(self) -> None:
721         # Close the FileHandler explicitly.
722         # (logging.shutdown might have lost the weakref?!)
723         self.log_file_handler.close()
724 
725 
726 class _FileHandler(logging.FileHandler):
727     """
728     Custom FileHandler with pytest tweaks.
729     """
730 
731     def handleError(self, record: logging.LogRecord) -> None:
732         # Handled by LogCaptureHandler.
733         pass
734 
735 
736 class _LiveLoggingStreamHandler(logging.StreamHandler):
737     """
738     Custom StreamHandler used by the live logging feature: it will write a newline before the first log message
739     in each test.
740 
741     During live logging we must also explicitly disable stdout/stderr capturing otherwise it will get captured
742     and won't appear in the terminal.
743     """
744 
745     # Officially stream needs to be a IO[str], but TerminalReporter
746     # isn't. So force it.
747     stream = None  # type: TerminalReporter # type: ignore
748 
749     def __init__(
750         self,
751         terminal_reporter: TerminalReporter,
752         capture_manager: Optional[CaptureManager],
753     ) -> None:
754         """
755         :param _pytest.terminal.TerminalReporter terminal_reporter:
756         :param _pytest.capture.CaptureManager capture_manager:
757         """
758         logging.StreamHandler.__init__(self, stream=terminal_reporter)  # type: ignore[arg-type] # noqa: F821
759         self.capture_manager = capture_manager
760         self.reset()
761         self.set_when(None)
762         self._test_outcome_written = False
763 
764     def reset(self) -> None:
765         """Reset the handler; should be called before the start of each test"""
766         self._first_record_emitted = False
767 
768     def set_when(self, when: Optional[str]) -> None:
769         """Prepares for the given test phase (setup/call/teardown)"""
770         self._when = when
771         self._section_name_shown = False
772         if when == "start":
773             self._test_outcome_written = False
774 
775     def emit(self, record: logging.LogRecord) -> None:
776         ctx_manager = (
777             self.capture_manager.global_and_fixture_disabled()
778             if self.capture_manager
779             else nullcontext()
780         )
781         with ctx_manager:
782             if not self._first_record_emitted:
783                 self.stream.write("\n")
784                 self._first_record_emitted = True
785             elif self._when in ("teardown", "finish"):
786                 if not self._test_outcome_written:
787                     self._test_outcome_written = True
788                     self.stream.write("\n")
789             if not self._section_name_shown and self._when:
790                 self.stream.section("live log " + self._when, sep="-", bold=True)
791                 self._section_name_shown = True
792             super().emit(record)
793 
794     def handleError(self, record: logging.LogRecord) -> None:
795         # Handled by LogCaptureHandler.
796         pass
797 
798 
799 class _LiveLoggingNullHandler(logging.NullHandler):
800     """A handler used when live logging is disabled."""
801 
802     def reset(self) -> None:
803         pass
804 
805     def set_when(self, when: str) -> None:
806         pass
807 
808     def handleError(self, record: logging.LogRecord) -> None:
809         # Handled by LogCaptureHandler.
810         pass

</code><intended_behavior>Within the handling of the `--log-file` option in `src/_pytest/logging.py`, the code should be updated to include a check for the existence of the directory specified for the log file. If the directory does not exist, it should be created before the log file is opened for writing. This behavior ensures that providing a `--log-file` argument with non-existing subdirectories does not result in a `FileNotFoundError`. This fix should preserve the existing functionality of log file handling while adding the safeguard to automatically create required directories, aligning it with how other parts of pytest, like `resultlog.py` and `junitxml.py`, manage directory creation for files. This would involve a sequence similar to:

```python
dirname = os.path.dirname(os.path.abspath(logfile))
if not os.path.isdir(dirname):
    os.makedirs(dirname)
```

Before the logfile is opened within the logging setup process, this additional check ensures compatibility and user-friendly behavior for all valid `--log-file` input paths.</intended_behavior>]
2025-10-15 22:55:33.963 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-15 22:55:33.963 | INFO     | Search-only: skipping patch selection
2025-10-15 22:55:34.046 | INFO     | Task pytest-dev__pytest-7468 completed successfully.
2025-10-15 22:55:34.047 | INFO     | No patch generated. You can try running ACR again.
