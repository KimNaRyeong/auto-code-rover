[
    {
        "rel_file_path": "src/_pytest/logging.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/pytest-dev__pytest/setup_pytest-dev__pytest__5.4/src/_pytest/logging.py",
        "start": 1,
        "end": 810,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\" Access and control log capturing. \"\"\"\n2 import logging\n3 import os\n4 import re\n5 import sys\n6 from contextlib import contextmanager\n7 from io import StringIO\n8 from typing import AbstractSet\n9 from typing import Dict\n10 from typing import Generator\n11 from typing import List\n12 from typing import Mapping\n13 from typing import Optional\n14 from typing import Tuple\n15 from typing import TypeVar\n16 from typing import Union\n17 \n18 import pytest\n19 from _pytest import nodes\n20 from _pytest._io import TerminalWriter\n21 from _pytest.capture import CaptureManager\n22 from _pytest.compat import nullcontext\n23 from _pytest.config import _strtobool\n24 from _pytest.config import Config\n25 from _pytest.config import create_terminal_writer\n26 from _pytest.config.argparsing import Parser\n27 from _pytest.fixtures import FixtureRequest\n28 from _pytest.main import Session\n29 from _pytest.pathlib import Path\n30 from _pytest.store import StoreKey\n31 from _pytest.terminal import TerminalReporter\n32 \n33 \n34 DEFAULT_LOG_FORMAT = \"%(levelname)-8s %(name)s:%(filename)s:%(lineno)d %(message)s\"\n35 DEFAULT_LOG_DATE_FORMAT = \"%H:%M:%S\"\n36 _ANSI_ESCAPE_SEQ = re.compile(r\"\\x1b\\[[\\d;]+m\")\n37 caplog_handler_key = StoreKey[\"LogCaptureHandler\"]()\n38 caplog_records_key = StoreKey[Dict[str, List[logging.LogRecord]]]()\n39 \n40 \n41 def _remove_ansi_escape_sequences(text: str) -> str:\n42     return _ANSI_ESCAPE_SEQ.sub(\"\", text)\n43 \n44 \n45 class ColoredLevelFormatter(logging.Formatter):\n46     \"\"\"\n47     Colorize the %(levelname)..s part of the log format passed to __init__.\n48     \"\"\"\n49 \n50     LOGLEVEL_COLOROPTS = {\n51         logging.CRITICAL: {\"red\"},\n52         logging.ERROR: {\"red\", \"bold\"},\n53         logging.WARNING: {\"yellow\"},\n54         logging.WARN: {\"yellow\"},\n55         logging.INFO: {\"green\"},\n56         logging.DEBUG: {\"purple\"},\n57         logging.NOTSET: set(),\n58     }  # type: Mapping[int, AbstractSet[str]]\n59     LEVELNAME_FMT_REGEX = re.compile(r\"%\\(levelname\\)([+-.]?\\d*s)\")\n60 \n61     def __init__(self, terminalwriter: TerminalWriter, *args, **kwargs) -> None:\n62         super().__init__(*args, **kwargs)\n63         self._original_fmt = self._style._fmt\n64         self._level_to_fmt_mapping = {}  # type: Dict[int, str]\n65 \n66         assert self._fmt is not None\n67         levelname_fmt_match = self.LEVELNAME_FMT_REGEX.search(self._fmt)\n68         if not levelname_fmt_match:\n69             return\n70         levelname_fmt = levelname_fmt_match.group()\n71 \n72         for level, color_opts in self.LOGLEVEL_COLOROPTS.items():\n73             formatted_levelname = levelname_fmt % {\n74                 \"levelname\": logging.getLevelName(level)\n75             }\n76 \n77             # add ANSI escape sequences around the formatted levelname\n78             color_kwargs = {name: True for name in color_opts}\n79             colorized_formatted_levelname = terminalwriter.markup(\n80                 formatted_levelname, **color_kwargs\n81             )\n82             self._level_to_fmt_mapping[level] = self.LEVELNAME_FMT_REGEX.sub(\n83                 colorized_formatted_levelname, self._fmt\n84             )\n85 \n86     def format(self, record: logging.LogRecord) -> str:\n87         fmt = self._level_to_fmt_mapping.get(record.levelno, self._original_fmt)\n88         self._style._fmt = fmt\n89         return super().format(record)\n90 \n91 \n92 class PercentStyleMultiline(logging.PercentStyle):\n93     \"\"\"A logging style with special support for multiline messages.\n94 \n95     If the message of a record consists of multiple lines, this style\n96     formats the message as if each line were logged separately.\n97     \"\"\"\n98 \n99     def __init__(self, fmt: str, auto_indent: Union[int, str, bool, None]) -> None:\n100         super().__init__(fmt)\n101         self._auto_indent = self._get_auto_indent(auto_indent)\n102 \n103     @staticmethod\n104     def _update_message(\n105         record_dict: Dict[str, object], message: str\n106     ) -> Dict[str, object]:\n107         tmp = record_dict.copy()\n108         tmp[\"message\"] = message\n109         return tmp\n110 \n111     @staticmethod\n112     def _get_auto_indent(auto_indent_option: Union[int, str, bool, None]) -> int:\n113         \"\"\"Determines the current auto indentation setting\n114 \n115         Specify auto indent behavior (on/off/fixed) by passing in\n116         extra={\"auto_indent\": [value]} to the call to logging.log() or\n117         using a --log-auto-indent [value] command line or the\n118         log_auto_indent [value] config option.\n119 \n120         Default behavior is auto-indent off.\n121 \n122         Using the string \"True\" or \"on\" or the boolean True as the value\n123         turns auto indent on, using the string \"False\" or \"off\" or the\n124         boolean False or the int 0 turns it off, and specifying a\n125         positive integer fixes the indentation position to the value\n126         specified.\n127 \n128         Any other values for the option are invalid, and will silently be\n129         converted to the default.\n130 \n131         :param any auto_indent_option: User specified option for indentation\n132             from command line, config or extra kwarg. Accepts int, bool or str.\n133             str option accepts the same range of values as boolean config options,\n134             as well as positive integers represented in str form.\n135 \n136         :returns: indentation value, which can be\n137             -1 (automatically determine indentation) or\n138             0 (auto-indent turned off) or\n139             >0 (explicitly set indentation position).\n140         \"\"\"\n141 \n142         if auto_indent_option is None:\n143             return 0\n144         elif isinstance(auto_indent_option, bool):\n145             if auto_indent_option:\n146                 return -1\n147             else:\n148                 return 0\n149         elif isinstance(auto_indent_option, int):\n150             return int(auto_indent_option)\n151         elif isinstance(auto_indent_option, str):\n152             try:\n153                 return int(auto_indent_option)\n154             except ValueError:\n155                 pass\n156             try:\n157                 if _strtobool(auto_indent_option):\n158                     return -1\n159             except ValueError:\n160                 return 0\n161 \n162         return 0\n163 \n164     def format(self, record: logging.LogRecord) -> str:\n165         if \"\\n\" in record.message:\n166             if hasattr(record, \"auto_indent\"):\n167                 # passed in from the \"extra={}\" kwarg on the call to logging.log()\n168                 auto_indent = self._get_auto_indent(record.auto_indent)  # type: ignore[attr-defined] # noqa: F821\n169             else:\n170                 auto_indent = self._auto_indent\n171 \n172             if auto_indent:\n173                 lines = record.message.splitlines()\n174                 formatted = self._fmt % self._update_message(record.__dict__, lines[0])\n175 \n176                 if auto_indent < 0:\n177                     indentation = _remove_ansi_escape_sequences(formatted).find(\n178                         lines[0]\n179                     )\n180                 else:\n181                     # optimizes logging by allowing a fixed indentation\n182                     indentation = auto_indent\n183                 lines[0] = formatted\n184                 return (\"\\n\" + \" \" * indentation).join(lines)\n185         return self._fmt % record.__dict__\n186 \n187 \n188 def get_option_ini(config: Config, *names: str):\n189     for name in names:\n190         ret = config.getoption(name)  # 'default' arg won't work as expected\n191         if ret is None:\n192             ret = config.getini(name)\n193         if ret:\n194             return ret\n195 \n196 \n197 def pytest_addoption(parser: Parser) -> None:\n198     \"\"\"Add options to control log capturing.\"\"\"\n199     group = parser.getgroup(\"logging\")\n200 \n201     def add_option_ini(option, dest, default=None, type=None, **kwargs):\n202         parser.addini(\n203             dest, default=default, type=type, help=\"default value for \" + option\n204         )\n205         group.addoption(option, dest=dest, **kwargs)\n206 \n207     add_option_ini(\n208         \"--log-level\",\n209         dest=\"log_level\",\n210         default=None,\n211         metavar=\"LEVEL\",\n212         help=(\n213             \"level of messages to catch/display.\\n\"\n214             \"Not set by default, so it depends on the root/parent log handler's\"\n215             ' effective level, where it is \"WARNING\" by default.'\n216         ),\n217     )\n218     add_option_ini(\n219         \"--log-format\",\n220         dest=\"log_format\",\n221         default=DEFAULT_LOG_FORMAT,\n222         help=\"log format as used by the logging module.\",\n223     )\n224     add_option_ini(\n225         \"--log-date-format\",\n226         dest=\"log_date_format\",\n227         default=DEFAULT_LOG_DATE_FORMAT,\n228         help=\"log date format as used by the logging module.\",\n229     )\n230     parser.addini(\n231         \"log_cli\",\n232         default=False,\n233         type=\"bool\",\n234         help='enable log display during test run (also known as \"live logging\").',\n235     )\n236     add_option_ini(\n237         \"--log-cli-level\", dest=\"log_cli_level\", default=None, help=\"cli logging level.\"\n238     )\n239     add_option_ini(\n240         \"--log-cli-format\",\n241         dest=\"log_cli_format\",\n242         default=None,\n243         help=\"log format as used by the logging module.\",\n244     )\n245     add_option_ini(\n246         \"--log-cli-date-format\",\n247         dest=\"log_cli_date_format\",\n248         default=None,\n249         help=\"log date format as used by the logging module.\",\n250     )\n251     add_option_ini(\n252         \"--log-file\",\n253         dest=\"log_file\",\n254         default=None,\n255         help=\"path to a file when logging will be written to.\",\n256     )\n257     add_option_ini(\n258         \"--log-file-level\",\n259         dest=\"log_file_level\",\n260         default=None,\n261         help=\"log file logging level.\",\n262     )\n263     add_option_ini(\n264         \"--log-file-format\",\n265         dest=\"log_file_format\",\n266         default=DEFAULT_LOG_FORMAT,\n267         help=\"log format as used by the logging module.\",\n268     )\n269     add_option_ini(\n270         \"--log-file-date-format\",\n271         dest=\"log_file_date_format\",\n272         default=DEFAULT_LOG_DATE_FORMAT,\n273         help=\"log date format as used by the logging module.\",\n274     )\n275     add_option_ini(\n276         \"--log-auto-indent\",\n277         dest=\"log_auto_indent\",\n278         default=None,\n279         help=\"Auto-indent multiline messages passed to the logging module. Accepts true|on, false|off or an integer.\",\n280     )\n281 \n282 \n283 _HandlerType = TypeVar(\"_HandlerType\", bound=logging.Handler)\n284 \n285 \n286 # Not using @contextmanager for performance reasons.\n287 class catching_logs:\n288     \"\"\"Context manager that prepares the whole logging machinery properly.\"\"\"\n289 \n290     __slots__ = (\"handler\", \"level\", \"orig_level\")\n291 \n292     def __init__(self, handler: _HandlerType, level: Optional[int] = None) -> None:\n293         self.handler = handler\n294         self.level = level\n295 \n296     def __enter__(self):\n297         root_logger = logging.getLogger()\n298         if self.level is not None:\n299             self.handler.setLevel(self.level)\n300         root_logger.addHandler(self.handler)\n301         if self.level is not None:\n302             self.orig_level = root_logger.level\n303             root_logger.setLevel(min(self.orig_level, self.level))\n304         return self.handler\n305 \n306     def __exit__(self, type, value, traceback):\n307         root_logger = logging.getLogger()\n308         if self.level is not None:\n309             root_logger.setLevel(self.orig_level)\n310         root_logger.removeHandler(self.handler)\n311 \n312 \n313 class LogCaptureHandler(logging.StreamHandler):\n314     \"\"\"A logging handler that stores log records and the log text.\"\"\"\n315 \n316     stream = None  # type: StringIO\n317 \n318     def __init__(self) -> None:\n319         \"\"\"Creates a new log handler.\"\"\"\n320         super().__init__(StringIO())\n321         self.records = []  # type: List[logging.LogRecord]\n322 \n323     def emit(self, record: logging.LogRecord) -> None:\n324         \"\"\"Keep the log records in a list in addition to the log text.\"\"\"\n325         self.records.append(record)\n326         super().emit(record)\n327 \n328     def reset(self) -> None:\n329         self.records = []\n330         self.stream = StringIO()\n331 \n332     def handleError(self, record: logging.LogRecord) -> None:\n333         if logging.raiseExceptions:\n334             # Fail the test if the log message is bad (emit failed).\n335             # The default behavior of logging is to print \"Logging error\"\n336             # to stderr with the call stack and some extra details.\n337             # pytest wants to make such mistakes visible during testing.\n338             raise\n339 \n340 \n341 class LogCaptureFixture:\n342     \"\"\"Provides access and control of log capturing.\"\"\"\n343 \n344     def __init__(self, item: nodes.Node) -> None:\n345         \"\"\"Creates a new funcarg.\"\"\"\n346         self._item = item\n347         # dict of log name -> log level\n348         self._initial_logger_levels = {}  # type: Dict[Optional[str], int]\n349 \n350     def _finalize(self) -> None:\n351         \"\"\"Finalizes the fixture.\n352 \n353         This restores the log levels changed by :meth:`set_level`.\n354         \"\"\"\n355         # restore log levels\n356         for logger_name, level in self._initial_logger_levels.items():\n357             logger = logging.getLogger(logger_name)\n358             logger.setLevel(level)\n359 \n360     @property\n361     def handler(self) -> LogCaptureHandler:\n362         \"\"\"\n363         :rtype: LogCaptureHandler\n364         \"\"\"\n365         return self._item._store[caplog_handler_key]\n366 \n367     def get_records(self, when: str) -> List[logging.LogRecord]:\n368         \"\"\"\n369         Get the logging records for one of the possible test phases.\n370 \n371         :param str when:\n372             Which test phase to obtain the records from. Valid values are: \"setup\", \"call\" and \"teardown\".\n373 \n374         :rtype: List[logging.LogRecord]\n375         :return: the list of captured records at the given stage\n376 \n377         .. versionadded:: 3.4\n378         \"\"\"\n379         return self._item._store[caplog_records_key].get(when, [])\n380 \n381     @property\n382     def text(self) -> str:\n383         \"\"\"Returns the formatted log text.\"\"\"\n384         return _remove_ansi_escape_sequences(self.handler.stream.getvalue())\n385 \n386     @property\n387     def records(self) -> List[logging.LogRecord]:\n388         \"\"\"Returns the list of log records.\"\"\"\n389         return self.handler.records\n390 \n391     @property\n392     def record_tuples(self) -> List[Tuple[str, int, str]]:\n393         \"\"\"Returns a list of a stripped down version of log records intended\n394         for use in assertion comparison.\n395 \n396         The format of the tuple is:\n397 \n398             (logger_name, log_level, message)\n399         \"\"\"\n400         return [(r.name, r.levelno, r.getMessage()) for r in self.records]\n401 \n402     @property\n403     def messages(self) -> List[str]:\n404         \"\"\"Returns a list of format-interpolated log messages.\n405 \n406         Unlike 'records', which contains the format string and parameters for interpolation, log messages in this list\n407         are all interpolated.\n408         Unlike 'text', which contains the output from the handler, log messages in this list are unadorned with\n409         levels, timestamps, etc, making exact comparisons more reliable.\n410 \n411         Note that traceback or stack info (from :func:`logging.exception` or the `exc_info` or `stack_info` arguments\n412         to the logging functions) is not included, as this is added by the formatter in the handler.\n413 \n414         .. versionadded:: 3.7\n415         \"\"\"\n416         return [r.getMessage() for r in self.records]\n417 \n418     def clear(self) -> None:\n419         \"\"\"Reset the list of log records and the captured log text.\"\"\"\n420         self.handler.reset()\n421 \n422     def set_level(self, level: Union[int, str], logger: Optional[str] = None) -> None:\n423         \"\"\"Sets the level for capturing of logs. The level will be restored to its previous value at the end of\n424         the test.\n425 \n426         :param int level: the logger to level.\n427         :param str logger: the logger to update the level. If not given, the root logger level is updated.\n428 \n429         .. versionchanged:: 3.4\n430             The levels of the loggers changed by this function will be restored to their initial values at the\n431             end of the test.\n432         \"\"\"\n433         logger_obj = logging.getLogger(logger)\n434         # save the original log-level to restore it during teardown\n435         self._initial_logger_levels.setdefault(logger, logger_obj.level)\n436         logger_obj.setLevel(level)\n437         self.handler.setLevel(level)\n438 \n439     @contextmanager\n440     def at_level(\n441         self, level: int, logger: Optional[str] = None\n442     ) -> Generator[None, None, None]:\n443         \"\"\"Context manager that sets the level for capturing of logs. After the end of the 'with' statement the\n444         level is restored to its original value.\n445 \n446         :param int level: the logger to level.\n447         :param str logger: the logger to update the level. If not given, the root logger level is updated.\n448         \"\"\"\n449         logger_obj = logging.getLogger(logger)\n450         orig_level = logger_obj.level\n451         logger_obj.setLevel(level)\n452         handler_orig_level = self.handler.level\n453         self.handler.setLevel(level)\n454         try:\n455             yield\n456         finally:\n457             logger_obj.setLevel(orig_level)\n458             self.handler.setLevel(handler_orig_level)\n459 \n460 \n461 @pytest.fixture\n462 def caplog(request: FixtureRequest) -> Generator[LogCaptureFixture, None, None]:\n463     \"\"\"Access and control log capturing.\n464 \n465     Captured logs are available through the following properties/methods::\n466 \n467     * caplog.messages        -> list of format-interpolated log messages\n468     * caplog.text            -> string containing formatted log output\n469     * caplog.records         -> list of logging.LogRecord instances\n470     * caplog.record_tuples   -> list of (logger_name, level, message) tuples\n471     * caplog.clear()         -> clear captured records and formatted log output string\n472     \"\"\"\n473     result = LogCaptureFixture(request.node)\n474     yield result\n475     result._finalize()\n476 \n477 \n478 def get_log_level_for_setting(config: Config, *setting_names: str) -> Optional[int]:\n479     for setting_name in setting_names:\n480         log_level = config.getoption(setting_name)\n481         if log_level is None:\n482             log_level = config.getini(setting_name)\n483         if log_level:\n484             break\n485     else:\n486         return None\n487 \n488     if isinstance(log_level, str):\n489         log_level = log_level.upper()\n490     try:\n491         return int(getattr(logging, log_level, log_level))\n492     except ValueError as e:\n493         # Python logging does not recognise this as a logging level\n494         raise pytest.UsageError(\n495             \"'{}' is not recognized as a logging level name for \"\n496             \"'{}'. Please consider passing the \"\n497             \"logging level num instead.\".format(log_level, setting_name)\n498         ) from e\n499 \n500 \n501 # run after terminalreporter/capturemanager are configured\n502 @pytest.hookimpl(trylast=True)\n503 def pytest_configure(config: Config) -> None:\n504     config.pluginmanager.register(LoggingPlugin(config), \"logging-plugin\")\n505 \n506 \n507 class LoggingPlugin:\n508     \"\"\"Attaches to the logging module and captures log messages for each test.\n509     \"\"\"\n510 \n511     def __init__(self, config: Config) -> None:\n512         \"\"\"Creates a new plugin to capture log messages.\n513 \n514         The formatter can be safely shared across all handlers so\n515         create a single one for the entire test session here.\n516         \"\"\"\n517         self._config = config\n518 \n519         # Report logging.\n520         self.formatter = self._create_formatter(\n521             get_option_ini(config, \"log_format\"),\n522             get_option_ini(config, \"log_date_format\"),\n523             get_option_ini(config, \"log_auto_indent\"),\n524         )\n525         self.log_level = get_log_level_for_setting(config, \"log_level\")\n526         self.caplog_handler = LogCaptureHandler()\n527         self.caplog_handler.setFormatter(self.formatter)\n528         self.report_handler = LogCaptureHandler()\n529         self.report_handler.setFormatter(self.formatter)\n530 \n531         # File logging.\n532         self.log_file_level = get_log_level_for_setting(config, \"log_file_level\")\n533         log_file = get_option_ini(config, \"log_file\") or os.devnull\n534         self.log_file_handler = _FileHandler(log_file, mode=\"w\", encoding=\"UTF-8\")\n535         log_file_format = get_option_ini(config, \"log_file_format\", \"log_format\")\n536         log_file_date_format = get_option_ini(\n537             config, \"log_file_date_format\", \"log_date_format\"\n538         )\n539         log_file_formatter = logging.Formatter(\n540             log_file_format, datefmt=log_file_date_format\n541         )\n542         self.log_file_handler.setFormatter(log_file_formatter)\n543 \n544         # CLI/live logging.\n545         self.log_cli_level = get_log_level_for_setting(\n546             config, \"log_cli_level\", \"log_level\"\n547         )\n548         if self._log_cli_enabled():\n549             terminal_reporter = config.pluginmanager.get_plugin(\"terminalreporter\")\n550             capture_manager = config.pluginmanager.get_plugin(\"capturemanager\")\n551             # if capturemanager plugin is disabled, live logging still works.\n552             self.log_cli_handler = _LiveLoggingStreamHandler(\n553                 terminal_reporter, capture_manager\n554             )  # type: Union[_LiveLoggingStreamHandler, _LiveLoggingNullHandler]\n555         else:\n556             self.log_cli_handler = _LiveLoggingNullHandler()\n557         log_cli_formatter = self._create_formatter(\n558             get_option_ini(config, \"log_cli_format\", \"log_format\"),\n559             get_option_ini(config, \"log_cli_date_format\", \"log_date_format\"),\n560             get_option_ini(config, \"log_auto_indent\"),\n561         )\n562         self.log_cli_handler.setFormatter(log_cli_formatter)\n563 \n564     def _create_formatter(self, log_format, log_date_format, auto_indent):\n565         # color option doesn't exist if terminal plugin is disabled\n566         color = getattr(self._config.option, \"color\", \"no\")\n567         if color != \"no\" and ColoredLevelFormatter.LEVELNAME_FMT_REGEX.search(\n568             log_format\n569         ):\n570             formatter = ColoredLevelFormatter(\n571                 create_terminal_writer(self._config), log_format, log_date_format\n572             )  # type: logging.Formatter\n573         else:\n574             formatter = logging.Formatter(log_format, log_date_format)\n575 \n576         formatter._style = PercentStyleMultiline(\n577             formatter._style._fmt, auto_indent=auto_indent\n578         )\n579 \n580         return formatter\n581 \n582     def set_log_path(self, fname: str) -> None:\n583         \"\"\"Public method, which can set filename parameter for\n584         Logging.FileHandler(). Also creates parent directory if\n585         it does not exist.\n586 \n587         .. warning::\n588             Please considered as an experimental API.\n589         \"\"\"\n590         fpath = Path(fname)\n591 \n592         if not fpath.is_absolute():\n593             fpath = Path(str(self._config.rootdir), fpath)\n594 \n595         if not fpath.parent.exists():\n596             fpath.parent.mkdir(exist_ok=True, parents=True)\n597 \n598         stream = fpath.open(mode=\"w\", encoding=\"UTF-8\")\n599         if sys.version_info >= (3, 7):\n600             old_stream = self.log_file_handler.setStream(stream)\n601         else:\n602             old_stream = self.log_file_handler.stream\n603             self.log_file_handler.acquire()\n604             try:\n605                 self.log_file_handler.flush()\n606                 self.log_file_handler.stream = stream\n607             finally:\n608                 self.log_file_handler.release()\n609         if old_stream:\n610             old_stream.close()\n611 \n612     def _log_cli_enabled(self):\n613         \"\"\"Return whether live logging is enabled.\"\"\"\n614         enabled = self._config.getoption(\n615             \"--log-cli-level\"\n616         ) is not None or self._config.getini(\"log_cli\")\n617         if not enabled:\n618             return False\n619 \n620         terminal_reporter = self._config.pluginmanager.get_plugin(\"terminalreporter\")\n621         if terminal_reporter is None:\n622             # terminal reporter is disabled e.g. by pytest-xdist.\n623             return False\n624 \n625         return True\n626 \n627     @pytest.hookimpl(hookwrapper=True, tryfirst=True)\n628     def pytest_sessionstart(self) -> Generator[None, None, None]:\n629         self.log_cli_handler.set_when(\"sessionstart\")\n630 \n631         with catching_logs(self.log_cli_handler, level=self.log_cli_level):\n632             with catching_logs(self.log_file_handler, level=self.log_file_level):\n633                 yield\n634 \n635     @pytest.hookimpl(hookwrapper=True, tryfirst=True)\n636     def pytest_collection(self) -> Generator[None, None, None]:\n637         self.log_cli_handler.set_when(\"collection\")\n638 \n639         with catching_logs(self.log_cli_handler, level=self.log_cli_level):\n640             with catching_logs(self.log_file_handler, level=self.log_file_level):\n641                 yield\n642 \n643     @pytest.hookimpl(hookwrapper=True)\n644     def pytest_runtestloop(self, session: Session) -> Generator[None, None, None]:\n645         \"\"\"Runs all collected test items.\"\"\"\n646 \n647         if session.config.option.collectonly:\n648             yield\n649             return\n650 \n651         if self._log_cli_enabled() and self._config.getoption(\"verbose\") < 1:\n652             # setting verbose flag is needed to avoid messy test progress output\n653             self._config.option.verbose = 1\n654 \n655         with catching_logs(self.log_cli_handler, level=self.log_cli_level):\n656             with catching_logs(self.log_file_handler, level=self.log_file_level):\n657                 yield  # run all the tests\n658 \n659     @pytest.hookimpl\n660     def pytest_runtest_logstart(self) -> None:\n661         self.log_cli_handler.reset()\n662         self.log_cli_handler.set_when(\"start\")\n663 \n664     @pytest.hookimpl\n665     def pytest_runtest_logreport(self) -> None:\n666         self.log_cli_handler.set_when(\"logreport\")\n667 \n668     def _runtest_for(self, item: nodes.Item, when: str) -> Generator[None, None, None]:\n669         \"\"\"Implements the internals of pytest_runtest_xxx() hook.\"\"\"\n670         with catching_logs(\n671             self.caplog_handler, level=self.log_level,\n672         ) as caplog_handler, catching_logs(\n673             self.report_handler, level=self.log_level,\n674         ) as report_handler:\n675             caplog_handler.reset()\n676             report_handler.reset()\n677             item._store[caplog_records_key][when] = caplog_handler.records\n678             item._store[caplog_handler_key] = caplog_handler\n679 \n680             yield\n681 \n682             log = report_handler.stream.getvalue().strip()\n683             item.add_report_section(when, \"log\", log)\n684 \n685     @pytest.hookimpl(hookwrapper=True)\n686     def pytest_runtest_setup(self, item: nodes.Item) -> Generator[None, None, None]:\n687         self.log_cli_handler.set_when(\"setup\")\n688 \n689         empty = {}  # type: Dict[str, List[logging.LogRecord]]\n690         item._store[caplog_records_key] = empty\n691         yield from self._runtest_for(item, \"setup\")\n692 \n693     @pytest.hookimpl(hookwrapper=True)\n694     def pytest_runtest_call(self, item: nodes.Item) -> Generator[None, None, None]:\n695         self.log_cli_handler.set_when(\"call\")\n696 \n697         yield from self._runtest_for(item, \"call\")\n698 \n699     @pytest.hookimpl(hookwrapper=True)\n700     def pytest_runtest_teardown(self, item: nodes.Item) -> Generator[None, None, None]:\n701         self.log_cli_handler.set_when(\"teardown\")\n702 \n703         yield from self._runtest_for(item, \"teardown\")\n704         del item._store[caplog_records_key]\n705         del item._store[caplog_handler_key]\n706 \n707     @pytest.hookimpl\n708     def pytest_runtest_logfinish(self) -> None:\n709         self.log_cli_handler.set_when(\"finish\")\n710 \n711     @pytest.hookimpl(hookwrapper=True, tryfirst=True)\n712     def pytest_sessionfinish(self) -> Generator[None, None, None]:\n713         self.log_cli_handler.set_when(\"sessionfinish\")\n714 \n715         with catching_logs(self.log_cli_handler, level=self.log_cli_level):\n716             with catching_logs(self.log_file_handler, level=self.log_file_level):\n717                 yield\n718 \n719     @pytest.hookimpl\n720     def pytest_unconfigure(self) -> None:\n721         # Close the FileHandler explicitly.\n722         # (logging.shutdown might have lost the weakref?!)\n723         self.log_file_handler.close()\n724 \n725 \n726 class _FileHandler(logging.FileHandler):\n727     \"\"\"\n728     Custom FileHandler with pytest tweaks.\n729     \"\"\"\n730 \n731     def handleError(self, record: logging.LogRecord) -> None:\n732         # Handled by LogCaptureHandler.\n733         pass\n734 \n735 \n736 class _LiveLoggingStreamHandler(logging.StreamHandler):\n737     \"\"\"\n738     Custom StreamHandler used by the live logging feature: it will write a newline before the first log message\n739     in each test.\n740 \n741     During live logging we must also explicitly disable stdout/stderr capturing otherwise it will get captured\n742     and won't appear in the terminal.\n743     \"\"\"\n744 \n745     # Officially stream needs to be a IO[str], but TerminalReporter\n746     # isn't. So force it.\n747     stream = None  # type: TerminalReporter # type: ignore\n748 \n749     def __init__(\n750         self,\n751         terminal_reporter: TerminalReporter,\n752         capture_manager: Optional[CaptureManager],\n753     ) -> None:\n754         \"\"\"\n755         :param _pytest.terminal.TerminalReporter terminal_reporter:\n756         :param _pytest.capture.CaptureManager capture_manager:\n757         \"\"\"\n758         logging.StreamHandler.__init__(self, stream=terminal_reporter)  # type: ignore[arg-type] # noqa: F821\n759         self.capture_manager = capture_manager\n760         self.reset()\n761         self.set_when(None)\n762         self._test_outcome_written = False\n763 \n764     def reset(self) -> None:\n765         \"\"\"Reset the handler; should be called before the start of each test\"\"\"\n766         self._first_record_emitted = False\n767 \n768     def set_when(self, when: Optional[str]) -> None:\n769         \"\"\"Prepares for the given test phase (setup/call/teardown)\"\"\"\n770         self._when = when\n771         self._section_name_shown = False\n772         if when == \"start\":\n773             self._test_outcome_written = False\n774 \n775     def emit(self, record: logging.LogRecord) -> None:\n776         ctx_manager = (\n777             self.capture_manager.global_and_fixture_disabled()\n778             if self.capture_manager\n779             else nullcontext()\n780         )\n781         with ctx_manager:\n782             if not self._first_record_emitted:\n783                 self.stream.write(\"\\n\")\n784                 self._first_record_emitted = True\n785             elif self._when in (\"teardown\", \"finish\"):\n786                 if not self._test_outcome_written:\n787                     self._test_outcome_written = True\n788                     self.stream.write(\"\\n\")\n789             if not self._section_name_shown and self._when:\n790                 self.stream.section(\"live log \" + self._when, sep=\"-\", bold=True)\n791                 self._section_name_shown = True\n792             super().emit(record)\n793 \n794     def handleError(self, record: logging.LogRecord) -> None:\n795         # Handled by LogCaptureHandler.\n796         pass\n797 \n798 \n799 class _LiveLoggingNullHandler(logging.NullHandler):\n800     \"\"\"A handler used when live logging is disabled.\"\"\"\n801 \n802     def reset(self) -> None:\n803         pass\n804 \n805     def set_when(self, when: str) -> None:\n806         pass\n807 \n808     def handleError(self, record: logging.LogRecord) -> None:\n809         # Handled by LogCaptureHandler.\n810         pass\n",
        "intended_behavior": "Within the handling of the `--log-file` option in `src/_pytest/logging.py`, the code should be updated to include a check for the existence of the directory specified for the log file. If the directory does not exist, it should be created before the log file is opened for writing. This behavior ensures that providing a `--log-file` argument with non-existing subdirectories does not result in a `FileNotFoundError`. This fix should preserve the existing functionality of log file handling while adding the safeguard to automatically create required directories, aligning it with how other parts of pytest, like `resultlog.py` and `junitxml.py`, manage directory creation for files. This would involve a sequence similar to:\n\n```python\ndirname = os.path.dirname(os.path.abspath(logfile))\nif not os.path.isdir(dirname):\n    os.makedirs(dirname)\n```\n\nBefore the logfile is opened within the logging setup process, this additional check ensures compatibility and user-friendly behavior for all valid `--log-file` input paths."
    }
]