[
    {
        "rel_file_path": "django/contrib/admin/options.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__5.0/django/contrib/admin/options.py",
        "start": 412,
        "end": 422,
        "class_name": "BaseModelAdmin",
        "method_name": "get_queryset",
        "code": "412     def get_queryset(self, request):\n413         \"\"\"\n414         Return a QuerySet of all model instances that can be edited by the\n415         admin site. This is used by changelist_view.\n416         \"\"\"\n417         qs = self.model._default_manager.get_queryset()\n418         # TODO: this should be handled by some parameter to the ChangeList.\n419         ordering = self.get_ordering(request)\n420         if ordering:\n421             qs = qs.order_by(*ordering)\n422         return qs\n",
        "intended_behavior": "Modify this method to include a filtering mechanism that distinguishes `LogEntry` records based on models registered to the current `AdminSite` instance. This will likely involve extending the queryset to check if the `content_type` of each `LogEntry` record matches any of the models registered with the admin site. It's important that this is done in a way that doesn't disrupt the current functionality for non-`LogEntry` models being handled by admin views, implying that the filtering should be conditionally applied only when dealing with `LogEntry` instances."
    },
    {
        "rel_file_path": "django/contrib/admin/options.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__5.0/django/contrib/admin/options.py",
        "start": 117,
        "end": 611,
        "class_name": "BaseModelAdmin",
        "method_name": null,
        "code": "117 class BaseModelAdmin(metaclass=forms.MediaDefiningClass):\n118     \"\"\"Functionality common to both ModelAdmin and InlineAdmin.\"\"\"\n119 \n120     autocomplete_fields = ()\n121     raw_id_fields = ()\n122     fields = None\n123     exclude = None\n124     fieldsets = None\n125     form = forms.ModelForm\n126     filter_vertical = ()\n127     filter_horizontal = ()\n128     radio_fields = {}\n129     prepopulated_fields = {}\n130     formfield_overrides = {}\n131     readonly_fields = ()\n132     ordering = None\n133     sortable_by = None\n134     view_on_site = True\n135     show_full_result_count = True\n136     checks_class = BaseModelAdminChecks\n137 \n138     def check(self, **kwargs):\n139         return self.checks_class().check(self, **kwargs)\n140 \n141     def __init__(self):\n142         # Merge FORMFIELD_FOR_DBFIELD_DEFAULTS with the formfield_overrides\n143         # rather than simply overwriting.\n144         overrides = copy.deepcopy(FORMFIELD_FOR_DBFIELD_DEFAULTS)\n145         for k, v in self.formfield_overrides.items():\n146             overrides.setdefault(k, {}).update(v)\n147         self.formfield_overrides = overrides\n148 \n149     def formfield_for_dbfield(self, db_field, request, **kwargs):\n150         \"\"\"\n151         Hook for specifying the form Field instance for a given database Field\n152         instance.\n153 \n154         If kwargs are given, they're passed to the form Field's constructor.\n155         \"\"\"\n156         # If the field specifies choices, we don't need to look for special\n157         # admin widgets - we just need to use a select widget of some kind.\n158         if db_field.choices:\n159             return self.formfield_for_choice_field(db_field, request, **kwargs)\n160 \n161         # ForeignKey or ManyToManyFields\n162         if isinstance(db_field, (models.ForeignKey, models.ManyToManyField)):\n163             # Combine the field kwargs with any options for formfield_overrides.\n164             # Make sure the passed in **kwargs override anything in\n165             # formfield_overrides because **kwargs is more specific, and should\n166             # always win.\n167             if db_field.__class__ in self.formfield_overrides:\n168                 kwargs = {**self.formfield_overrides[db_field.__class__], **kwargs}\n169 \n170             # Get the correct formfield.\n171             if isinstance(db_field, models.ForeignKey):\n172                 formfield = self.formfield_for_foreignkey(db_field, request, **kwargs)\n173             elif isinstance(db_field, models.ManyToManyField):\n174                 formfield = self.formfield_for_manytomany(db_field, request, **kwargs)\n175 \n176             # For non-raw_id fields, wrap the widget with a wrapper that adds\n177             # extra HTML -- the \"add other\" interface -- to the end of the\n178             # rendered output. formfield can be None if it came from a\n179             # OneToOneField with parent_link=True or a M2M intermediary.\n180             if formfield and db_field.name not in self.raw_id_fields:\n181                 related_modeladmin = self.admin_site._registry.get(\n182                     db_field.remote_field.model\n183                 )\n184                 wrapper_kwargs = {}\n185                 if related_modeladmin:\n186                     wrapper_kwargs.update(\n187                         can_add_related=related_modeladmin.has_add_permission(request),\n188                         can_change_related=related_modeladmin.has_change_permission(\n189                             request\n190                         ),\n191                         can_delete_related=related_modeladmin.has_delete_permission(\n192                             request\n193                         ),\n194                         can_view_related=related_modeladmin.has_view_permission(\n195                             request\n196                         ),\n197                     )\n198                 formfield.widget = widgets.RelatedFieldWidgetWrapper(\n199                     formfield.widget,\n200                     db_field.remote_field,\n201                     self.admin_site,\n202                     **wrapper_kwargs,\n203                 )\n204 \n205             return formfield\n206 \n207         # If we've got overrides for the formfield defined, use 'em. **kwargs\n208         # passed to formfield_for_dbfield override the defaults.\n209         for klass in db_field.__class__.mro():\n210             if klass in self.formfield_overrides:\n211                 kwargs = {**copy.deepcopy(self.formfield_overrides[klass]), **kwargs}\n212                 return db_field.formfield(**kwargs)\n213 \n214         # For any other type of field, just call its formfield() method.\n215         return db_field.formfield(**kwargs)\n216 \n217     def formfield_for_choice_field(self, db_field, request, **kwargs):\n218         \"\"\"\n219         Get a form Field for a database Field that has declared choices.\n220         \"\"\"\n221         # If the field is named as a radio_field, use a RadioSelect\n222         if db_field.name in self.radio_fields:\n223             # Avoid stomping on custom widget/choices arguments.\n224             if \"widget\" not in kwargs:\n225                 kwargs[\"widget\"] = widgets.AdminRadioSelect(\n226                     attrs={\n227                         \"class\": get_ul_class(self.radio_fields[db_field.name]),\n228                     }\n229                 )\n230             if \"choices\" not in kwargs:\n231                 kwargs[\"choices\"] = db_field.get_choices(\n232                     include_blank=db_field.blank, blank_choice=[(\"\", _(\"None\"))]\n233                 )\n234         return db_field.formfield(**kwargs)\n235 \n236     def get_field_queryset(self, db, db_field, request):\n237         \"\"\"\n238         If the ModelAdmin specifies ordering, the queryset should respect that\n239         ordering.  Otherwise don't specify the queryset, let the field decide\n240         (return None in that case).\n241         \"\"\"\n242         related_admin = self.admin_site._registry.get(db_field.remote_field.model)\n243         if related_admin is not None:\n244             ordering = related_admin.get_ordering(request)\n245             if ordering is not None and ordering != ():\n246                 return db_field.remote_field.model._default_manager.using(db).order_by(\n247                     *ordering\n248                 )\n249         return None\n250 \n251     def formfield_for_foreignkey(self, db_field, request, **kwargs):\n252         \"\"\"\n253         Get a form Field for a ForeignKey.\n254         \"\"\"\n255         db = kwargs.get(\"using\")\n256 \n257         if \"widget\" not in kwargs:\n258             if db_field.name in self.get_autocomplete_fields(request):\n259                 kwargs[\"widget\"] = AutocompleteSelect(\n260                     db_field, self.admin_site, using=db\n261                 )\n262             elif db_field.name in self.raw_id_fields:\n263                 kwargs[\"widget\"] = widgets.ForeignKeyRawIdWidget(\n264                     db_field.remote_field, self.admin_site, using=db\n265                 )\n266             elif db_field.name in self.radio_fields:\n267                 kwargs[\"widget\"] = widgets.AdminRadioSelect(\n268                     attrs={\n269                         \"class\": get_ul_class(self.radio_fields[db_field.name]),\n270                     }\n271                 )\n272                 kwargs[\"empty_label\"] = (\n273                     kwargs.get(\"empty_label\", _(\"None\")) if db_field.blank else None\n274                 )\n275 \n276         if \"queryset\" not in kwargs:\n277             queryset = self.get_field_queryset(db, db_field, request)\n278             if queryset is not None:\n279                 kwargs[\"queryset\"] = queryset\n280 \n281         return db_field.formfield(**kwargs)\n282 \n283     def formfield_for_manytomany(self, db_field, request, **kwargs):\n284         \"\"\"\n285         Get a form Field for a ManyToManyField.\n286         \"\"\"\n287         # If it uses an intermediary model that isn't auto created, don't show\n288         # a field in admin.\n289         if not db_field.remote_field.through._meta.auto_created:\n290             return None\n291         db = kwargs.get(\"using\")\n292 \n293         if \"widget\" not in kwargs:\n294             autocomplete_fields = self.get_autocomplete_fields(request)\n295             if db_field.name in autocomplete_fields:\n296                 kwargs[\"widget\"] = AutocompleteSelectMultiple(\n297                     db_field,\n298                     self.admin_site,\n299                     using=db,\n300                 )\n301             elif db_field.name in self.raw_id_fields:\n302                 kwargs[\"widget\"] = widgets.ManyToManyRawIdWidget(\n303                     db_field.remote_field,\n304                     self.admin_site,\n305                     using=db,\n306                 )\n307             elif db_field.name in [*self.filter_vertical, *self.filter_horizontal]:\n308                 kwargs[\"widget\"] = widgets.FilteredSelectMultiple(\n309                     db_field.verbose_name, db_field.name in self.filter_vertical\n310                 )\n311         if \"queryset\" not in kwargs:\n312             queryset = self.get_field_queryset(db, db_field, request)\n313             if queryset is not None:\n314                 kwargs[\"queryset\"] = queryset\n315 \n316         form_field = db_field.formfield(**kwargs)\n317         if (\n318             isinstance(form_field.widget, SelectMultiple)\n319             and form_field.widget.allow_multiple_selected\n320             and not isinstance(\n321                 form_field.widget, (CheckboxSelectMultiple, AutocompleteSelectMultiple)\n322             )\n323         ):\n324             msg = _(\n325                 \"Hold down \u201cControl\u201d, or \u201cCommand\u201d on a Mac, to select more than one.\"\n326             )\n327             help_text = form_field.help_text\n328             form_field.help_text = (\n329                 format_lazy(\"{} {}\", help_text, msg) if help_text else msg\n330             )\n331         return form_field\n332 \n333     def get_autocomplete_fields(self, request):\n334         \"\"\"\n335         Return a list of ForeignKey and/or ManyToMany fields which should use\n336         an autocomplete widget.\n337         \"\"\"\n338         return self.autocomplete_fields\n339 \n340     def get_view_on_site_url(self, obj=None):\n341         if obj is None or not self.view_on_site:\n342             return None\n343 \n344         if callable(self.view_on_site):\n345             return self.view_on_site(obj)\n346         elif hasattr(obj, \"get_absolute_url\"):\n347             # use the ContentType lookup if view_on_site is True\n348             return reverse(\n349                 \"admin:view_on_site\",\n350                 kwargs={\n351                     \"content_type_id\": get_content_type_for_model(obj).pk,\n352                     \"object_id\": obj.pk,\n353                 },\n354                 current_app=self.admin_site.name,\n355             )\n356 \n357     def get_empty_value_display(self):\n358         \"\"\"\n359         Return the empty_value_display set on ModelAdmin or AdminSite.\n360         \"\"\"\n361         try:\n362             return mark_safe(self.empty_value_display)\n363         except AttributeError:\n364             return mark_safe(self.admin_site.empty_value_display)\n365 \n366     def get_exclude(self, request, obj=None):\n367         \"\"\"\n368         Hook for specifying exclude.\n369         \"\"\"\n370         return self.exclude\n371 \n372     def get_fields(self, request, obj=None):\n373         \"\"\"\n374         Hook for specifying fields.\n375         \"\"\"\n376         if self.fields:\n377             return self.fields\n378         # _get_form_for_get_fields() is implemented in subclasses.\n379         form = self._get_form_for_get_fields(request, obj)\n380         return [*form.base_fields, *self.get_readonly_fields(request, obj)]\n381 \n382     def get_fieldsets(self, request, obj=None):\n383         \"\"\"\n384         Hook for specifying fieldsets.\n385         \"\"\"\n386         if self.fieldsets:\n387             return self.fieldsets\n388         return [(None, {\"fields\": self.get_fields(request, obj)})]\n389 \n390     def get_inlines(self, request, obj):\n391         \"\"\"Hook for specifying custom inlines.\"\"\"\n392         return self.inlines\n393 \n394     def get_ordering(self, request):\n395         \"\"\"\n396         Hook for specifying field ordering.\n397         \"\"\"\n398         return self.ordering or ()  # otherwise we might try to *None, which is bad ;)\n399 \n400     def get_readonly_fields(self, request, obj=None):\n401         \"\"\"\n402         Hook for specifying custom readonly fields.\n403         \"\"\"\n404         return self.readonly_fields\n405 \n406     def get_prepopulated_fields(self, request, obj=None):\n407         \"\"\"\n408         Hook for specifying custom prepopulated fields.\n409         \"\"\"\n410         return self.prepopulated_fields\n411 \n412     def get_queryset(self, request):\n413         \"\"\"\n414         Return a QuerySet of all model instances that can be edited by the\n415         admin site. This is used by changelist_view.\n416         \"\"\"\n417         qs = self.model._default_manager.get_queryset()\n418         # TODO: this should be handled by some parameter to the ChangeList.\n419         ordering = self.get_ordering(request)\n420         if ordering:\n421             qs = qs.order_by(*ordering)\n422         return qs\n423 \n424     def get_sortable_by(self, request):\n425         \"\"\"Hook for specifying which fields can be sorted in the changelist.\"\"\"\n426         return (\n427             self.sortable_by\n428             if self.sortable_by is not None\n429             else self.get_list_display(request)\n430         )\n431 \n432     def lookup_allowed(self, lookup, value):\n433         from django.contrib.admin.filters import SimpleListFilter\n434 \n435         model = self.model\n436         # Check FKey lookups that are allowed, so that popups produced by\n437         # ForeignKeyRawIdWidget, on the basis of ForeignKey.limit_choices_to,\n438         # are allowed to work.\n439         for fk_lookup in model._meta.related_fkey_lookups:\n440             # As ``limit_choices_to`` can be a callable, invoke it here.\n441             if callable(fk_lookup):\n442                 fk_lookup = fk_lookup()\n443             if (lookup, value) in widgets.url_params_from_lookup_dict(\n444                 fk_lookup\n445             ).items():\n446                 return True\n447 \n448         relation_parts = []\n449         prev_field = None\n450         for part in lookup.split(LOOKUP_SEP):\n451             try:\n452                 field = model._meta.get_field(part)\n453             except FieldDoesNotExist:\n454                 # Lookups on nonexistent fields are ok, since they're ignored\n455                 # later.\n456                 break\n457             # It is allowed to filter on values that would be found from local\n458             # model anyways. For example, if you filter on employee__department__id,\n459             # then the id value would be found already from employee__department_id.\n460             if not prev_field or (\n461                 prev_field.is_relation\n462                 and field not in prev_field.path_infos[-1].target_fields\n463             ):\n464                 relation_parts.append(part)\n465             if not getattr(field, \"path_infos\", None):\n466                 # This is not a relational field, so further parts\n467                 # must be transforms.\n468                 break\n469             prev_field = field\n470             model = field.path_infos[-1].to_opts.model\n471 \n472         if len(relation_parts) <= 1:\n473             # Either a local field filter, or no fields at all.\n474             return True\n475         valid_lookups = {self.date_hierarchy}\n476         for filter_item in self.list_filter:\n477             if isinstance(filter_item, type) and issubclass(\n478                 filter_item, SimpleListFilter\n479             ):\n480                 valid_lookups.add(filter_item.parameter_name)\n481             elif isinstance(filter_item, (list, tuple)):\n482                 valid_lookups.add(filter_item[0])\n483             else:\n484                 valid_lookups.add(filter_item)\n485 \n486         # Is it a valid relational lookup?\n487         return not {\n488             LOOKUP_SEP.join(relation_parts),\n489             LOOKUP_SEP.join(relation_parts + [part]),\n490         }.isdisjoint(valid_lookups)\n491 \n492     def to_field_allowed(self, request, to_field):\n493         \"\"\"\n494         Return True if the model associated with this admin should be\n495         allowed to be referenced by the specified field.\n496         \"\"\"\n497         try:\n498             field = self.opts.get_field(to_field)\n499         except FieldDoesNotExist:\n500             return False\n501 \n502         # Always allow referencing the primary key since it's already possible\n503         # to get this information from the change view URL.\n504         if field.primary_key:\n505             return True\n506 \n507         # Allow reverse relationships to models defining m2m fields if they\n508         # target the specified field.\n509         for many_to_many in self.opts.many_to_many:\n510             if many_to_many.m2m_target_field_name() == to_field:\n511                 return True\n512 \n513         # Make sure at least one of the models registered for this site\n514         # references this field through a FK or a M2M relationship.\n515         registered_models = set()\n516         for model, admin in self.admin_site._registry.items():\n517             registered_models.add(model)\n518             for inline in admin.inlines:\n519                 registered_models.add(inline.model)\n520 \n521         related_objects = (\n522             f\n523             for f in self.opts.get_fields(include_hidden=True)\n524             if (f.auto_created and not f.concrete)\n525         )\n526         for related_object in related_objects:\n527             related_model = related_object.related_model\n528             remote_field = related_object.field.remote_field\n529             if (\n530                 any(issubclass(model, related_model) for model in registered_models)\n531                 and hasattr(remote_field, \"get_related_field\")\n532                 and remote_field.get_related_field() == field\n533             ):\n534                 return True\n535 \n536         return False\n537 \n538     def has_add_permission(self, request):\n539         \"\"\"\n540         Return True if the given request has permission to add an object.\n541         Can be overridden by the user in subclasses.\n542         \"\"\"\n543         opts = self.opts\n544         codename = get_permission_codename(\"add\", opts)\n545         return request.user.has_perm(\"%s.%s\" % (opts.app_label, codename))\n546 \n547     def has_change_permission(self, request, obj=None):\n548         \"\"\"\n549         Return True if the given request has permission to change the given\n550         Django model instance, the default implementation doesn't examine the\n551         `obj` parameter.\n552 \n553         Can be overridden by the user in subclasses. In such case it should\n554         return True if the given request has permission to change the `obj`\n555         model instance. If `obj` is None, this should return True if the given\n556         request has permission to change *any* object of the given type.\n557         \"\"\"\n558         opts = self.opts\n559         codename = get_permission_codename(\"change\", opts)\n560         return request.user.has_perm(\"%s.%s\" % (opts.app_label, codename))\n561 \n562     def has_delete_permission(self, request, obj=None):\n563         \"\"\"\n564         Return True if the given request has permission to delete the given\n565         Django model instance, the default implementation doesn't examine the\n566         `obj` parameter.\n567 \n568         Can be overridden by the user in subclasses. In such case it should\n569         return True if the given request has permission to delete the `obj`\n570         model instance. If `obj` is None, this should return True if the given\n571         request has permission to delete *any* object of the given type.\n572         \"\"\"\n573         opts = self.opts\n574         codename = get_permission_codename(\"delete\", opts)\n575         return request.user.has_perm(\"%s.%s\" % (opts.app_label, codename))\n576 \n577     def has_view_permission(self, request, obj=None):\n578         \"\"\"\n579         Return True if the given request has permission to view the given\n580         Django model instance. The default implementation doesn't examine the\n581         `obj` parameter.\n582 \n583         If overridden by the user in subclasses, it should return True if the\n584         given request has permission to view the `obj` model instance. If `obj`\n585         is None, it should return True if the request has permission to view\n586         any object of the given type.\n587         \"\"\"\n588         opts = self.opts\n589         codename_view = get_permission_codename(\"view\", opts)\n590         codename_change = get_permission_codename(\"change\", opts)\n591         return request.user.has_perm(\n592             \"%s.%s\" % (opts.app_label, codename_view)\n593         ) or request.user.has_perm(\"%s.%s\" % (opts.app_label, codename_change))\n594 \n595     def has_view_or_change_permission(self, request, obj=None):\n596         return self.has_view_permission(request, obj) or self.has_change_permission(\n597             request, obj\n598         )\n599 \n600     def has_module_permission(self, request):\n601         \"\"\"\n602         Return True if the given request has any permission in the given\n603         app label.\n604 \n605         Can be overridden by the user in subclasses. In such case it should\n606         return True if the given request has permission to view the module on\n607         the admin index page and access the module's index page. Overriding it\n608         does not restrict access to the add, change or delete views. Use\n609         `ModelAdmin.has_(add|change|delete)_permission` for that.\n610         \"\"\"\n611         return request.user.has_module_perms(self.opts.app_label)\n",
        "intended_behavior": "This class provides additional context to the issue."
    }
]