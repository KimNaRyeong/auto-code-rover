[
    {
        "rel_file_path": "pylint/config/utils.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/pylint-dev__pylint/setup_pylint-dev__pylint__2.14/pylint/config/utils.py",
        "start": 1,
        "end": 249,
        "class_name": null,
        "method_name": null,
        "code": "1 # Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n2 # For details: https://github.com/PyCQA/pylint/blob/main/LICENSE\n3 # Copyright (c) https://github.com/PyCQA/pylint/blob/main/CONTRIBUTORS.txt\n4 \n5 \"\"\"Utils for arguments/options parsing and handling.\"\"\"\n6 \n7 from __future__ import annotations\n8 \n9 import re\n10 import warnings\n11 from collections.abc import Callable, Sequence\n12 from pathlib import Path\n13 from typing import TYPE_CHECKING, Any\n14 \n15 from pylint import extensions, utils\n16 from pylint.config.argument import (\n17     _CallableArgument,\n18     _ExtendArgument,\n19     _StoreArgument,\n20     _StoreNewNamesArgument,\n21     _StoreOldNamesArgument,\n22     _StoreTrueArgument,\n23 )\n24 from pylint.config.callback_actions import _CallbackAction\n25 from pylint.config.exceptions import ArgumentPreprocessingError\n26 \n27 if TYPE_CHECKING:\n28     from pylint.lint.run import Run\n29 \n30 \n31 def _convert_option_to_argument(\n32     opt: str, optdict: dict[str, Any]\n33 ) -> (\n34     _StoreArgument\n35     | _StoreTrueArgument\n36     | _CallableArgument\n37     | _StoreOldNamesArgument\n38     | _StoreNewNamesArgument\n39     | _ExtendArgument\n40 ):\n41     \"\"\"Convert an optdict to an Argument class instance.\"\"\"\n42     if \"level\" in optdict and \"hide\" not in optdict:\n43         warnings.warn(\n44             \"The 'level' key in optdicts has been deprecated. \"\n45             \"Use 'hide' with a boolean to hide an option from the help message.\",\n46             DeprecationWarning,\n47         )\n48 \n49     # Get the long and short flags\n50     flags = [f\"--{opt}\"]\n51     if \"short\" in optdict:\n52         flags += [f\"-{optdict['short']}\"]\n53 \n54     # Get the action type\n55     action = optdict.get(\"action\", \"store\")\n56 \n57     if action == \"store_true\":\n58         return _StoreTrueArgument(\n59             flags=flags,\n60             action=action,\n61             default=optdict.get(\"default\", True),\n62             arg_help=optdict.get(\"help\", \"\"),\n63             hide_help=optdict.get(\"hide\", False),\n64             section=optdict.get(\"group\", None),\n65         )\n66     if not isinstance(action, str) and issubclass(action, _CallbackAction):\n67         return _CallableArgument(\n68             flags=flags,\n69             action=action,\n70             arg_help=optdict.get(\"help\", \"\"),\n71             kwargs=optdict.get(\"kwargs\", {}),\n72             hide_help=optdict.get(\"hide\", False),\n73             section=optdict.get(\"group\", None),\n74         )\n75     try:\n76         default = optdict[\"default\"]\n77     except KeyError:\n78         warnings.warn(\n79             \"An option dictionary should have a 'default' key to specify \"\n80             \"the option's default value. This key will be required in pylint \"\n81             \"3.0. It is not required for 'store_true' and callable actions.\",\n82             DeprecationWarning,\n83         )\n84         default = None\n85     if action == \"extend\":\n86         return _ExtendArgument(\n87             flags=flags,\n88             action=action,\n89             default=default,\n90             arg_type=optdict[\"type\"],\n91             choices=optdict.get(\"choices\", None),\n92             arg_help=optdict.get(\"help\", \"\"),\n93             metavar=optdict.get(\"metavar\", \"\"),\n94             hide_help=optdict.get(\"hide\", False),\n95             section=optdict.get(\"group\", None),\n96             dest=optdict.get(\"dest\", None),\n97         )\n98     if \"kwargs\" in optdict:\n99         if \"old_names\" in optdict[\"kwargs\"]:\n100             return _StoreOldNamesArgument(\n101                 flags=flags,\n102                 default=default,\n103                 arg_type=optdict[\"type\"],\n104                 choices=optdict.get(\"choices\", None),\n105                 arg_help=optdict.get(\"help\", \"\"),\n106                 metavar=optdict.get(\"metavar\", \"\"),\n107                 hide_help=optdict.get(\"hide\", False),\n108                 kwargs=optdict.get(\"kwargs\", {}),\n109                 section=optdict.get(\"group\", None),\n110             )\n111         if \"new_names\" in optdict[\"kwargs\"]:\n112             return _StoreNewNamesArgument(\n113                 flags=flags,\n114                 default=default,\n115                 arg_type=optdict[\"type\"],\n116                 choices=optdict.get(\"choices\", None),\n117                 arg_help=optdict.get(\"help\", \"\"),\n118                 metavar=optdict.get(\"metavar\", \"\"),\n119                 hide_help=optdict.get(\"hide\", False),\n120                 kwargs=optdict.get(\"kwargs\", {}),\n121                 section=optdict.get(\"group\", None),\n122             )\n123     if \"dest\" in optdict:\n124         return _StoreOldNamesArgument(\n125             flags=flags,\n126             default=default,\n127             arg_type=optdict[\"type\"],\n128             choices=optdict.get(\"choices\", None),\n129             arg_help=optdict.get(\"help\", \"\"),\n130             metavar=optdict.get(\"metavar\", \"\"),\n131             hide_help=optdict.get(\"hide\", False),\n132             kwargs={\"old_names\": [optdict[\"dest\"]]},\n133             section=optdict.get(\"group\", None),\n134         )\n135     return _StoreArgument(\n136         flags=flags,\n137         action=action,\n138         default=default,\n139         arg_type=optdict[\"type\"],\n140         choices=optdict.get(\"choices\", None),\n141         arg_help=optdict.get(\"help\", \"\"),\n142         metavar=optdict.get(\"metavar\", \"\"),\n143         hide_help=optdict.get(\"hide\", False),\n144         section=optdict.get(\"group\", None),\n145     )\n146 \n147 \n148 def _parse_rich_type_value(value: Any) -> str:\n149     \"\"\"Parse rich (toml) types into strings.\"\"\"\n150     if isinstance(value, (list, tuple)):\n151         return \",\".join(_parse_rich_type_value(i) for i in value)\n152     if isinstance(value, re.Pattern):\n153         return value.pattern\n154     if isinstance(value, dict):\n155         return \",\".join(f\"{k}:{v}\" for k, v in value.items())\n156     return str(value)\n157 \n158 \n159 # pylint: disable-next=unused-argument\n160 def _init_hook(run: Run, value: str | None) -> None:\n161     \"\"\"Execute arbitrary code from the init_hook.\n162 \n163     This can be used to set the 'sys.path' for example.\n164     \"\"\"\n165     assert value is not None\n166     exec(value)  # pylint: disable=exec-used\n167 \n168 \n169 def _set_rcfile(run: Run, value: str | None) -> None:\n170     \"\"\"Set the rcfile.\"\"\"\n171     assert value is not None\n172     run._rcfile = value\n173 \n174 \n175 def _set_output(run: Run, value: str | None) -> None:\n176     \"\"\"Set the output.\"\"\"\n177     assert value is not None\n178     run._output = value\n179 \n180 \n181 def _add_plugins(run: Run, value: str | None) -> None:\n182     \"\"\"Add plugins to the list of loadable plugins.\"\"\"\n183     assert value is not None\n184     run._plugins.extend(utils._splitstrip(value))\n185 \n186 \n187 def _set_verbose_mode(run: Run, value: str | None) -> None:\n188     assert value is None\n189     run.verbose = True\n190 \n191 \n192 def _enable_all_extensions(run: Run, value: str | None) -> None:\n193     \"\"\"Enable all extensions.\"\"\"\n194     assert value is None\n195     for filename in Path(extensions.__file__).parent.iterdir():\n196         if filename.suffix == \".py\" and not filename.stem.startswith(\"_\"):\n197             extension_name = f\"pylint.extensions.{filename.stem}\"\n198             if extension_name not in run._plugins:\n199                 run._plugins.append(extension_name)\n200 \n201 \n202 PREPROCESSABLE_OPTIONS: dict[\n203     str, tuple[bool, Callable[[Run, str | None], None]]\n204 ] = {  # pylint: disable=consider-using-namedtuple-or-dataclass\n205     \"--init-hook\": (True, _init_hook),\n206     \"--rcfile\": (True, _set_rcfile),\n207     \"--output\": (True, _set_output),\n208     \"--load-plugins\": (True, _add_plugins),\n209     \"--verbose\": (False, _set_verbose_mode),\n210     \"--enable-all-extensions\": (False, _enable_all_extensions),\n211 }\n212 \n213 \n214 def _preprocess_options(run: Run, args: Sequence[str]) -> list[str]:\n215     \"\"\"Preprocess options before full config parsing has started.\"\"\"\n216     processed_args: list[str] = []\n217 \n218     i = 0\n219     while i < len(args):\n220         argument = args[i]\n221         if not argument.startswith(\"--\"):\n222             processed_args.append(argument)\n223             i += 1\n224             continue\n225 \n226         try:\n227             option, value = argument.split(\"=\", 1)\n228         except ValueError:\n229             option, value = argument, None\n230 \n231         if option not in PREPROCESSABLE_OPTIONS:\n232             processed_args.append(argument)\n233             i += 1\n234             continue\n235 \n236         takearg, cb = PREPROCESSABLE_OPTIONS[option]\n237 \n238         if takearg and value is None:\n239             i += 1\n240             if i >= len(args) or args[i].startswith(\"-\"):\n241                 raise ArgumentPreprocessingError(f\"Option {option} expects a value\")\n242             value = args[i]\n243         elif not takearg and value is not None:\n244             raise ArgumentPreprocessingError(f\"Option {option} doesn't expects a value\")\n245 \n246         cb(run, value)\n247         i += 1\n248 \n249     return processed_args\n",
        "intended_behavior": "This file and specifically the configuration related to the `--verbose` flag should be examined to ensure that the `-v` short option is correctly mapped to the `--verbose` functionality without expecting an argument. The existing implementation for `--verbose` already properly sets up the option to not expect an argument and directly toggles verbosity mode. The intended behavior here is to ensure `-v` behaves identically, enabling verbose mode directly without requiring extra input. This might involve examining where `-v` is defined and making sure it's aligned with the `--verbose` configuration, potentially adjusting how the `-v` flag is parsed or linked to the verbose functionality to mirror the `--verbose` logic."
    }
]