2025-10-15 20:08:29.076 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-15 20:08:32.385 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=262, output_tokens=12, cost=0.002980
2025-10-15 20:08:32.386 | INFO     | Test agent decides that the issue statement does not contain reproduction steps; skipping reproducer tracing
2025-10-15 20:08:32.390 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 20:08:45.304 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=570, output_tokens=438, cost=0.018840
2025-10-15 20:08:45.311 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 20:08:48.529 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=792, output_tokens=74, cost=0.010140
2025-10-15 20:08:48.531 | DEBUG    | Extracted a valid json.
2025-10-15 20:08:48.531 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_class(\"ModelAdmin\")",
        "search_class(\"ManyToManyField\")",
        "search_method(\"validate\")",
        "search_code(\"filter_horizontal\")",
        "search_code(\"filter_vertical\")",
        "search_code(\"ManyToManyField(through=\")"
    ],
    "bug_locations": []
}
2025-10-15 20:08:48.681 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-15 20:08:48.681 | DEBUG    | <Agent search> Analyzing search results.
2025-10-15 20:09:06.769 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3170, output_tokens=826, cost=0.056480
2025-10-15 20:09:06.786 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 20:09:16.388 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=4212, output_tokens=392, cost=0.053880
2025-10-15 20:09:16.396 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 20:09:23.156 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=746, output_tokens=292, cost=0.016220
2025-10-15 20:09:23.157 | DEBUG    | Extracted a valid json.
2025-10-15 20:09:23.157 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "django/contrib/admin/options.py",
            "class": "ModelAdmin",
            "method": "",
            "intended_behavior": "A new validation method or an enhancement of an existing one within ModelAdmin should check if filter_horizontal or filter_vertical is used with a ManyToManyField that has a custom through model defined. This method should raise a validation error or at least a warning if such a configuration is detected, guiding developers away from this unsupported setup. The validation should be integrated into the admin system checks that run when the server starts or the checks framework is otherwise invoked. This preserves the functionality of filter_horizontal and filter_vertical by clearly communicating their limitations to developers."
        },
        {
            "file": "django/contrib/admin/checks.py",
            "class": "",
            "method": "",
            "intended_behavior": "Extend or introduce checks related to ModelAdmin configuration that specifically validate the use of filter_horizontal or filter_vertical in conjunction with ManyToManyField's through option. The check should verify that when either filter_horizontal or filter_vertical is configured, the related ManyToManyField does not declare a through model. If such a case is found, the check should emit a warning or error indicating the incompatibility. This enhancement would help developers identify configuration mistakes early in the development process, ensuring the admin interface behaves as expected."
        }
    ]
}
2025-10-15 20:09:23.176 | DEBUG    | Bug location extracted successfully: [<file>django/contrib/admin/options.py</file>
<class>ModelAdmin</class>
<method>None</method>
<code>
630 class ModelAdmin(BaseModelAdmin):
631     """Encapsulate all admin options and functionality for a given model."""
632 
633     list_display = ("__str__",)
634     list_display_links = ()
635     list_filter = ()
636     list_select_related = False
637     list_per_page = 100
638     list_max_show_all = 200
639     list_editable = ()
640     search_fields = ()
641     search_help_text = None
642     date_hierarchy = None
643     save_as = False
644     save_as_continue = True
645     save_on_top = False
646     paginator = Paginator
647     preserve_filters = True
648     show_facets = ShowFacets.ALLOW
649     inlines = ()
650 
651     # Custom templates (designed to be over-ridden in subclasses)
652     add_form_template = None
653     change_form_template = None
654     change_list_template = None
655     delete_confirmation_template = None
656     delete_selected_confirmation_template = None
657     object_history_template = None
658     popup_response_template = None
659 
660     # Actions
661     actions = ()
662     action_form = helpers.ActionForm
663     actions_on_top = True
664     actions_on_bottom = False
665     actions_selection_counter = True
666     checks_class = ModelAdminChecks
667 
668     def __init__(self, model, admin_site):
669         self.model = model
670         self.opts = model._meta
671         self.admin_site = admin_site
672         super().__init__()
673 
674     def __str__(self):
675         return "%s.%s" % (self.opts.app_label, self.__class__.__name__)
676 
677     def __repr__(self):
678         return (
679             f"<{self.__class__.__qualname__}: model={self.model.__qualname__} "
680             f"site={self.admin_site!r}>"
681         )
682 
683     def get_inline_instances(self, request, obj=None):
684         inline_instances = []
685         for inline_class in self.get_inlines(request, obj):
686             inline = inline_class(self.model, self.admin_site)
687             if request:
688                 if not (
689                     inline.has_view_or_change_permission(request, obj)
690                     or inline.has_add_permission(request, obj)
691                     or inline.has_delete_permission(request, obj)
692                 ):
693                     continue
694                 if not inline.has_add_permission(request, obj):
695                     inline.max_num = 0
696             inline_instances.append(inline)
697 
698         return inline_instances
699 
700     def get_urls(self):
701         from django.urls import path
702 
703         def wrap(view):
704             def wrapper(*args, **kwargs):
705                 return self.admin_site.admin_view(view)(*args, **kwargs)
706 
707             wrapper.model_admin = self
708             return update_wrapper(wrapper, view)
709 
710         info = self.opts.app_label, self.opts.model_name
711 
712         return [
713             path("", wrap(self.changelist_view), name="%s_%s_changelist" % info),
714             path("add/", wrap(self.add_view), name="%s_%s_add" % info),
715             path(
716                 "<path:object_id>/history/",
717                 wrap(self.history_view),
718                 name="%s_%s_history" % info,
719             ),
720             path(
721                 "<path:object_id>/delete/",
722                 wrap(self.delete_view),
723                 name="%s_%s_delete" % info,
724             ),
725             path(
726                 "<path:object_id>/change/",
727                 wrap(self.change_view),
728                 name="%s_%s_change" % info,
729             ),
730             # For backwards compatibility (was the change url before 1.9)
731             path(
732                 "<path:object_id>/",
733                 wrap(
734                     RedirectView.as_view(
735                         pattern_name="%s:%s_%s_change"
736                         % ((self.admin_site.name,) + info)
737                     )
738                 ),
739             ),
740         ]
741 
742     @property
743     def urls(self):
744         return self.get_urls()
745 
746     @property
747     def media(self):
748         extra = "" if settings.DEBUG else ".min"
749         js = [
750             "vendor/jquery/jquery%s.js" % extra,
751             "jquery.init.js",
752             "core.js",
753             "admin/RelatedObjectLookups.js",
754             "actions.js",
755             "urlify.js",
756             "prepopulate.js",
757             "vendor/xregexp/xregexp%s.js" % extra,
758         ]
759         return forms.Media(js=["admin/js/%s" % url for url in js])
760 
761     def get_model_perms(self, request):
762         """
763         Return a dict of all perms for this model. This dict has the keys
764         ``add``, ``change``, ``delete``, and ``view`` mapping to the True/False
765         for each of those actions.
766         """
767         return {
768             "add": self.has_add_permission(request),
769             "change": self.has_change_permission(request),
770             "delete": self.has_delete_permission(request),
771             "view": self.has_view_permission(request),
772         }
773 
774     def _get_form_for_get_fields(self, request, obj):
775         return self.get_form(request, obj, fields=None)
776 
777     def get_form(self, request, obj=None, change=False, **kwargs):
778         """
779         Return a Form class for use in the admin add view. This is used by
780         add_view and change_view.
781         """
782         if "fields" in kwargs:
783             fields = kwargs.pop("fields")
784         else:
785             fields = flatten_fieldsets(self.get_fieldsets(request, obj))
786         excluded = self.get_exclude(request, obj)
787         exclude = [] if excluded is None else list(excluded)
788         readonly_fields = self.get_readonly_fields(request, obj)
789         exclude.extend(readonly_fields)
790         # Exclude all fields if it's a change form and the user doesn't have
791         # the change permission.
792         if (
793             change
794             and hasattr(request, "user")
795             and not self.has_change_permission(request, obj)
796         ):
797             exclude.extend(fields)
798         if excluded is None and hasattr(self.form, "_meta") and self.form._meta.exclude:
799             # Take the custom ModelForm's Meta.exclude into account only if the
800             # ModelAdmin doesn't define its own.
801             exclude.extend(self.form._meta.exclude)
802         # if exclude is an empty list we pass None to be consistent with the
803         # default on modelform_factory
804         exclude = exclude or None
805 
806         # Remove declared form fields which are in readonly_fields.
807         new_attrs = dict.fromkeys(
808             f for f in readonly_fields if f in self.form.declared_fields
809         )
810         form = type(self.form.__name__, (self.form,), new_attrs)
811 
812         defaults = {
813             "form": form,
814             "fields": fields,
815             "exclude": exclude,
816             "formfield_callback": partial(self.formfield_for_dbfield, request=request),
817             **kwargs,
818         }
819 
820         if defaults["fields"] is None and not modelform_defines_fields(
821             defaults["form"]
822         ):
823             defaults["fields"] = forms.ALL_FIELDS
824 
825         try:
826             return modelform_factory(self.model, **defaults)
827         except FieldError as e:
828             raise FieldError(
829                 "%s. Check fields/fieldsets/exclude attributes of class %s."
830                 % (e, self.__class__.__name__)
831             )
832 
833     def get_changelist(self, request, **kwargs):
834         """
835         Return the ChangeList class for use on the changelist page.
836         """
837         from django.contrib.admin.views.main import ChangeList
838 
839         return ChangeList
840 
841     def get_changelist_instance(self, request):
842         """
843         Return a `ChangeList` instance based on `request`. May raise
844         `IncorrectLookupParameters`.
845         """
846         list_display = self.get_list_display(request)
847         list_display_links = self.get_list_display_links(request, list_display)
848         # Add the action checkboxes if any actions are available.
849         if self.get_actions(request):
850             list_display = ["action_checkbox", *list_display]
851         sortable_by = self.get_sortable_by(request)
852         ChangeList = self.get_changelist(request)
853         return ChangeList(
854             request,
855             self.model,
856             list_display,
857             list_display_links,
858             self.get_list_filter(request),
859             self.date_hierarchy,
860             self.get_search_fields(request),
861             self.get_list_select_related(request),
862             self.list_per_page,
863             self.list_max_show_all,
864             self.list_editable,
865             self,
866             sortable_by,
867             self.search_help_text,
868         )
869 
870     def get_object(self, request, object_id, from_field=None):
871         """
872         Return an instance matching the field and value provided, the primary
873         key is used if no field is provided. Return ``None`` if no match is
874         found or the object_id fails validation.
875         """
876         queryset = self.get_queryset(request)
877         model = queryset.model
878         field = (
879             model._meta.pk if from_field is None else model._meta.get_field(from_field)
880         )
881         try:
882             object_id = field.to_python(object_id)
883             return queryset.get(**{field.name: object_id})
884         except (model.DoesNotExist, ValidationError, ValueError):
885             return None
886 
887     def get_changelist_form(self, request, **kwargs):
888         """
889         Return a Form class for use in the Formset on the changelist page.
890         """
891         defaults = {
892             "formfield_callback": partial(self.formfield_for_dbfield, request=request),
893             **kwargs,
894         }
895         if defaults.get("fields") is None and not modelform_defines_fields(
896             defaults.get("form")
897         ):
898             defaults["fields"] = forms.ALL_FIELDS
899 
900         return modelform_factory(self.model, **defaults)
901 
902     def get_changelist_formset(self, request, **kwargs):
903         """
904         Return a FormSet class for use on the changelist page if list_editable
905         is used.
906         """
907         defaults = {
908             "formfield_callback": partial(self.formfield_for_dbfield, request=request),
909             **kwargs,
910         }
911         return modelformset_factory(
912             self.model,
913             self.get_changelist_form(request),
914             extra=0,
915             fields=self.list_editable,
916             **defaults,
917         )
918 
919     def get_formsets_with_inlines(self, request, obj=None):
920         """
921         Yield formsets and the corresponding inlines.
922         """
923         for inline in self.get_inline_instances(request, obj):
924             yield inline.get_formset(request, obj), inline
925 
926     def get_paginator(
927         self, request, queryset, per_page, orphans=0, allow_empty_first_page=True
928     ):
929         return self.paginator(queryset, per_page, orphans, allow_empty_first_page)
930 
931     def log_addition(self, request, obj, message):
932         """
933         Log that an object has been successfully added.
934 
935         The default implementation creates an admin LogEntry object.
936         """
937         from django.contrib.admin.models import ADDITION, LogEntry
938 
939         return LogEntry.objects.log_action(
940             user_id=request.user.pk,
941             content_type_id=get_content_type_for_model(obj).pk,
942             object_id=obj.pk,
943             object_repr=str(obj),
944             action_flag=ADDITION,
945             change_message=message,
946         )
947 
948     def log_change(self, request, obj, message):
949         """
950         Log that an object has been successfully changed.
951 
952         The default implementation creates an admin LogEntry object.
953         """
954         from django.contrib.admin.models import CHANGE, LogEntry
955 
956         return LogEntry.objects.log_action(
957             user_id=request.user.pk,
958             content_type_id=get_content_type_for_model(obj).pk,
959             object_id=obj.pk,
960             object_repr=str(obj),
961             action_flag=CHANGE,
962             change_message=message,
963         )
964 
965     def log_deletion(self, request, obj, object_repr):
966         """
967         Log that an object will be deleted. Note that this method must be
968         called before the deletion.
969 
970         The default implementation creates an admin LogEntry object.
971         """
972         from django.contrib.admin.models import DELETION, LogEntry
973 
974         return LogEntry.objects.log_action(
975             user_id=request.user.pk,
976             content_type_id=get_content_type_for_model(obj).pk,
977             object_id=obj.pk,
978             object_repr=object_repr,
979             action_flag=DELETION,
980         )
981 
982     def action_checkbox(self, obj):
983         """
984         A list_display column containing a checkbox widget.
985         """
986         attrs = {
987             "class": "action-select",
988             "aria-label": format_html(_("Select this object for an action - {}"), obj),
989         }
990         checkbox = forms.CheckboxInput(attrs, lambda value: False)
991         return checkbox.render(helpers.ACTION_CHECKBOX_NAME, str(obj.pk))
992 
993     @staticmethod
994     def _get_action_description(func, name):
995         return getattr(func, "short_description", capfirst(name.replace("_", " ")))
996 
997     def _get_base_actions(self):
998         """Return the list of actions, prior to any request-based filtering."""
999         actions = []
1000         base_actions = (self.get_action(action) for action in self.actions or [])
1001         # get_action might have returned None, so filter any of those out.
1002         base_actions = [action for action in base_actions if action]
1003         base_action_names = {name for _, name, _ in base_actions}
1004 
1005         # Gather actions from the admin site first
1006         for name, func in self.admin_site.actions:
1007             if name in base_action_names:
1008                 continue
1009             description = self._get_action_description(func, name)
1010             actions.append((func, name, description))
1011         # Add actions from this ModelAdmin.
1012         actions.extend(base_actions)
1013         return actions
1014 
1015     def _filter_actions_by_permissions(self, request, actions):
1016         """Filter out any actions that the user doesn't have access to."""
1017         filtered_actions = []
1018         for action in actions:
1019             callable = action[0]
1020             if not hasattr(callable, "allowed_permissions"):
1021                 filtered_actions.append(action)
1022                 continue
1023             permission_checks = (
1024                 getattr(self, "has_%s_permission" % permission)
1025                 for permission in callable.allowed_permissions
1026             )
1027             if any(has_permission(request) for has_permission in permission_checks):
1028                 filtered_actions.append(action)
1029         return filtered_actions
1030 
1031     def get_actions(self, request):
1032         """
1033         Return a dictionary mapping the names of all actions for this
1034         ModelAdmin to a tuple of (callable, name, description) for each action.
1035         """
1036         # If self.actions is set to None that means actions are disabled on
1037         # this page.
1038         if self.actions is None or IS_POPUP_VAR in request.GET:
1039             return {}
1040         actions = self._filter_actions_by_permissions(request, self._get_base_actions())
1041         return {name: (func, name, desc) for func, name, desc in actions}
1042 
1043     def get_action_choices(self, request, default_choices=models.BLANK_CHOICE_DASH):
1044         """
1045         Return a list of choices for use in a form object.  Each choice is a
1046         tuple (name, description).
1047         """
1048         choices = [] + default_choices
1049         for func, name, description in self.get_actions(request).values():
1050             choice = (name, description % model_format_dict(self.opts))
1051             choices.append(choice)
1052         return choices
1053 
1054     def get_action(self, action):
1055         """
1056         Return a given action from a parameter, which can either be a callable,
1057         or the name of a method on the ModelAdmin.  Return is a tuple of
1058         (callable, name, description).
1059         """
1060         # If the action is a callable, just use it.
1061         if callable(action):
1062             func = action
1063             action = action.__name__
1064 
1065         # Next, look for a method. Grab it off self.__class__ to get an unbound
1066         # method instead of a bound one; this ensures that the calling
1067         # conventions are the same for functions and methods.
1068         elif hasattr(self.__class__, action):
1069             func = getattr(self.__class__, action)
1070 
1071         # Finally, look for a named method on the admin site
1072         else:
1073             try:
1074                 func = self.admin_site.get_action(action)
1075             except KeyError:
1076                 return None
1077 
1078         description = self._get_action_description(func, action)
1079         return func, action, description
1080 
1081     def get_list_display(self, request):
1082         """
1083         Return a sequence containing the fields to be displayed on the
1084         changelist.
1085         """
1086         return self.list_display
1087 
1088     def get_list_display_links(self, request, list_display):
1089         """
1090         Return a sequence containing the fields to be displayed as links
1091         on the changelist. The list_display parameter is the list of fields
1092         returned by get_list_display().
1093         """
1094         if (
1095             self.list_display_links
1096             or self.list_display_links is None
1097             or not list_display
1098         ):
1099             return self.list_display_links
1100         else:
1101             # Use only the first item in list_display as link
1102             return list(list_display)[:1]
1103 
1104     def get_list_filter(self, request):
1105         """
1106         Return a sequence containing the fields to be displayed as filters in
1107         the right sidebar of the changelist page.
1108         """
1109         return self.list_filter
1110 
1111     def get_list_select_related(self, request):
1112         """
1113         Return a list of fields to add to the select_related() part of the
1114         changelist items query.
1115         """
1116         return self.list_select_related
1117 
1118     def get_search_fields(self, request):
1119         """
1120         Return a sequence containing the fields to be searched whenever
1121         somebody submits a search query.
1122         """
1123         return self.search_fields
1124 
1125     def get_search_results(self, request, queryset, search_term):
1126         """
1127         Return a tuple containing a queryset to implement the search
1128         and a boolean indicating if the results may contain duplicates.
1129         """
1130 
1131         # Apply keyword searches.
1132         def construct_search(field_name):
1133             if field_name.startswith("^"):
1134                 return "%s__istartswith" % field_name.removeprefix("^")
1135             elif field_name.startswith("="):
1136                 return "%s__iexact" % field_name.removeprefix("=")
1137             elif field_name.startswith("@"):
1138                 return "%s__search" % field_name.removeprefix("@")
1139             # Use field_name if it includes a lookup.
1140             opts = queryset.model._meta
1141             lookup_fields = field_name.split(LOOKUP_SEP)
1142             # Go through the fields, following all relations.
1143             prev_field = None
1144             for path_part in lookup_fields:
1145                 if path_part == "pk":
1146                     path_part = opts.pk.name
1147                 try:
1148                     field = opts.get_field(path_part)
1149                 except FieldDoesNotExist:
1150                     # Use valid query lookups.
1151                     if prev_field and prev_field.get_lookup(path_part):
1152                         return field_name
1153                 else:
1154                     prev_field = field
1155                     if hasattr(field, "path_infos"):
1156                         # Update opts to follow the relation.
1157                         opts = field.path_infos[-1].to_opts
1158             # Otherwise, use the field with icontains.
1159             return "%s__icontains" % field_name
1160 
1161         may_have_duplicates = False
1162         search_fields = self.get_search_fields(request)
1163         if search_fields and search_term:
1164             orm_lookups = [
1165                 construct_search(str(search_field)) for search_field in search_fields
1166             ]
1167             term_queries = []
1168             for bit in smart_split(search_term):
1169                 if bit.startswith(('"', "'")) and bit[0] == bit[-1]:
1170                     bit = unescape_string_literal(bit)
1171                 or_queries = models.Q.create(
1172                     [(orm_lookup, bit) for orm_lookup in orm_lookups],
1173                     connector=models.Q.OR,
1174                 )
1175                 term_queries.append(or_queries)
1176             queryset = queryset.filter(models.Q.create(term_queries))
1177             may_have_duplicates |= any(
1178                 lookup_spawns_duplicates(self.opts, search_spec)
1179                 for search_spec in orm_lookups
1180             )
1181         return queryset, may_have_duplicates
1182 
1183     def get_preserved_filters(self, request):
1184         """
1185         Return the preserved filters querystring.
1186         """
1187         match = request.resolver_match
1188         if self.preserve_filters and match:
1189             current_url = "%s:%s" % (match.app_name, match.url_name)
1190             changelist_url = "admin:%s_%s_changelist" % (
1191                 self.opts.app_label,
1192                 self.opts.model_name,
1193             )
1194             if current_url == changelist_url:
1195                 preserved_filters = request.GET.urlencode()
1196             else:
1197                 preserved_filters = request.GET.get("_changelist_filters")
1198 
1199             if preserved_filters:
1200                 return urlencode({"_changelist_filters": preserved_filters})
1201         return ""
1202 
1203     def construct_change_message(self, request, form, formsets, add=False):
1204         """
1205         Construct a JSON structure describing changes from a changed object.
1206         """
1207         return construct_change_message(form, formsets, add)
1208 
1209     def message_user(
1210         self, request, message, level=messages.INFO, extra_tags="", fail_silently=False
1211     ):
1212         """
1213         Send a message to the user. The default implementation
1214         posts a message using the django.contrib.messages backend.
1215 
1216         Exposes almost the same API as messages.add_message(), but accepts the
1217         positional arguments in a different order to maintain backwards
1218         compatibility. For convenience, it accepts the `level` argument as
1219         a string rather than the usual level number.
1220         """
1221         if not isinstance(level, int):
1222             # attempt to get the level if passed a string
1223             try:
1224                 level = getattr(messages.constants, level.upper())
1225             except AttributeError:
1226                 levels = messages.constants.DEFAULT_TAGS.values()
1227                 levels_repr = ", ".join("`%s`" % level for level in levels)
1228                 raise ValueError(
1229                     "Bad message level string: `%s`. Possible values are: %s"
1230                     % (level, levels_repr)
1231                 )
1232 
1233         messages.add_message(
1234             request, level, message, extra_tags=extra_tags, fail_silently=fail_silently
1235         )
1236 
1237     def save_form(self, request, form, change):
1238         """
1239         Given a ModelForm return an unsaved instance. ``change`` is True if
1240         the object is being changed, and False if it's being added.
1241         """
1242         return form.save(commit=False)
1243 
1244     def save_model(self, request, obj, form, change):
1245         """
1246         Given a model instance save it to the database.
1247         """
1248         obj.save()
1249 
1250     def delete_model(self, request, obj):
1251         """
1252         Given a model instance delete it from the database.
1253         """
1254         obj.delete()
1255 
1256     def delete_queryset(self, request, queryset):
1257         """Given a queryset, delete it from the database."""
1258         queryset.delete()
1259 
1260     def save_formset(self, request, form, formset, change):
1261         """
1262         Given an inline formset save it to the database.
1263         """
1264         formset.save()
1265 
1266     def save_related(self, request, form, formsets, change):
1267         """
1268         Given the ``HttpRequest``, the parent ``ModelForm`` instance, the
1269         list of inline formsets and a boolean value based on whether the
1270         parent is being added or changed, save the related objects to the
1271         database. Note that at this point save_form() and save_model() have
1272         already been called.
1273         """
1274         form.save_m2m()
1275         for formset in formsets:
1276             self.save_formset(request, form, formset, change=change)
1277 
1278     def render_change_form(
1279         self, request, context, add=False, change=False, form_url="", obj=None
1280     ):
1281         app_label = self.opts.app_label
1282         preserved_filters = self.get_preserved_filters(request)
1283         form_url = add_preserved_filters(
1284             {"preserved_filters": preserved_filters, "opts": self.opts}, form_url
1285         )
1286         view_on_site_url = self.get_view_on_site_url(obj)
1287         has_editable_inline_admin_formsets = False
1288         for inline in context["inline_admin_formsets"]:
1289             if (
1290                 inline.has_add_permission
1291                 or inline.has_change_permission
1292                 or inline.has_delete_permission
1293             ):
1294                 has_editable_inline_admin_formsets = True
1295                 break
1296         context.update(
1297             {
1298                 "add": add,
1299                 "change": change,
1300                 "has_view_permission": self.has_view_permission(request, obj),
1301                 "has_add_permission": self.has_add_permission(request),
1302                 "has_change_permission": self.has_change_permission(request, obj),
1303                 "has_delete_permission": self.has_delete_permission(request, obj),
1304                 "has_editable_inline_admin_formsets": (
1305                     has_editable_inline_admin_formsets
1306                 ),
1307                 "has_file_field": context["adminform"].form.is_multipart()
1308                 or any(
1309                     admin_formset.formset.is_multipart()
1310                     for admin_formset in context["inline_admin_formsets"]
1311                 ),
1312                 "has_absolute_url": view_on_site_url is not None,
1313                 "absolute_url": view_on_site_url,
1314                 "form_url": form_url,
1315                 "opts": self.opts,
1316                 "content_type_id": get_content_type_for_model(self.model).pk,
1317                 "save_as": self.save_as,
1318                 "save_on_top": self.save_on_top,
1319                 "to_field_var": TO_FIELD_VAR,
1320                 "is_popup_var": IS_POPUP_VAR,
1321                 "app_label": app_label,
1322             }
1323         )
1324         if add and self.add_form_template is not None:
1325             form_template = self.add_form_template
1326         else:
1327             form_template = self.change_form_template
1328 
1329         request.current_app = self.admin_site.name
1330 
1331         return TemplateResponse(
1332             request,
1333             form_template
1334             or [
1335                 "admin/%s/%s/change_form.html" % (app_label, self.opts.model_name),
1336                 "admin/%s/change_form.html" % app_label,
1337                 "admin/change_form.html",
1338             ],
1339             context,
1340         )
1341 
1342     def response_add(self, request, obj, post_url_continue=None):
1343         """
1344         Determine the HttpResponse for the add_view stage.
1345         """
1346         opts = obj._meta
1347         preserved_filters = self.get_preserved_filters(request)
1348         obj_url = reverse(
1349             "admin:%s_%s_change" % (opts.app_label, opts.model_name),
1350             args=(quote(obj.pk),),
1351             current_app=self.admin_site.name,
1352         )
1353         # Add a link to the object's change form if the user can edit the obj.
1354         if self.has_change_permission(request, obj):
1355             obj_repr = format_html('<a href="{}">{}</a>', urlquote(obj_url), obj)
1356         else:
1357             obj_repr = str(obj)
1358         msg_dict = {
1359             "name": opts.verbose_name,
1360             "obj": obj_repr,
1361         }
1362         # Here, we distinguish between different save types by checking for
1363         # the presence of keys in request.POST.
1364 
1365         if IS_POPUP_VAR in request.POST:
1366             to_field = request.POST.get(TO_FIELD_VAR)
1367             if to_field:
1368                 attr = str(to_field)
1369             else:
1370                 attr = obj._meta.pk.attname
1371             value = obj.serializable_value(attr)
1372             popup_response_data = json.dumps(
1373                 {
1374                     "value": str(value),
1375                     "obj": str(obj),
1376                 }
1377             )
1378             return TemplateResponse(
1379                 request,
1380                 self.popup_response_template
1381                 or [
1382                     "admin/%s/%s/popup_response.html"
1383                     % (opts.app_label, opts.model_name),
1384                     "admin/%s/popup_response.html" % opts.app_label,
1385                     "admin/popup_response.html",
1386                 ],
1387                 {
1388                     "popup_response_data": popup_response_data,
1389                 },
1390             )
1391 
1392         elif "_continue" in request.POST or (
1393             # Redirecting after "Save as new".
1394             "_saveasnew" in request.POST
1395             and self.save_as_continue
1396             and self.has_change_permission(request, obj)
1397         ):
1398             msg = _("The {name} “{obj}” was added successfully.")
1399             if self.has_change_permission(request, obj):
1400                 msg += " " + _("You may edit it again below.")
1401             self.message_user(request, format_html(msg, **msg_dict), messages.SUCCESS)
1402             if post_url_continue is None:
1403                 post_url_continue = obj_url
1404             post_url_continue = add_preserved_filters(
1405                 {"preserved_filters": preserved_filters, "opts": opts},
1406                 post_url_continue,
1407             )
1408             return HttpResponseRedirect(post_url_continue)
1409 
1410         elif "_addanother" in request.POST:
1411             msg = format_html(
1412                 _(
1413                     "The {name} “{obj}” was added successfully. You may add another "
1414                     "{name} below."
1415                 ),
1416                 **msg_dict,
1417             )
1418             self.message_user(request, msg, messages.SUCCESS)
1419             redirect_url = request.path
1420             redirect_url = add_preserved_filters(
1421                 {"preserved_filters": preserved_filters, "opts": opts}, redirect_url
1422             )
1423             return HttpResponseRedirect(redirect_url)
1424 
1425         else:
1426             msg = format_html(
1427                 _("The {name} “{obj}” was added successfully."), **msg_dict
1428             )
1429             self.message_user(request, msg, messages.SUCCESS)
1430             return self.response_post_save_add(request, obj)
1431 
1432     def response_change(self, request, obj):
1433         """
1434         Determine the HttpResponse for the change_view stage.
1435         """
1436 
1437         if IS_POPUP_VAR in request.POST:
1438             opts = obj._meta
1439             to_field = request.POST.get(TO_FIELD_VAR)
1440             attr = str(to_field) if to_field else opts.pk.attname
1441             value = request.resolver_match.kwargs["object_id"]
1442             new_value = obj.serializable_value(attr)
1443             popup_response_data = json.dumps(
1444                 {
1445                     "action": "change",
1446                     "value": str(value),
1447                     "obj": str(obj),
1448                     "new_value": str(new_value),
1449                 }
1450             )
1451             return TemplateResponse(
1452                 request,
1453                 self.popup_response_template
1454                 or [
1455                     "admin/%s/%s/popup_response.html"
1456                     % (opts.app_label, opts.model_name),
1457                     "admin/%s/popup_response.html" % opts.app_label,
1458                     "admin/popup_response.html",
1459                 ],
1460                 {
1461                     "popup_response_data": popup_response_data,
1462                 },
1463             )
1464 
1465         opts = self.opts
1466         preserved_filters = self.get_preserved_filters(request)
1467 
1468         msg_dict = {
1469             "name": opts.verbose_name,
1470             "obj": format_html('<a href="{}">{}</a>', urlquote(request.path), obj),
1471         }
1472         if "_continue" in request.POST:
1473             msg = format_html(
1474                 _(
1475                     "The {name} “{obj}” was changed successfully. You may edit it "
1476                     "again below."
1477                 ),
1478                 **msg_dict,
1479             )
1480             self.message_user(request, msg, messages.SUCCESS)
1481             redirect_url = request.path
1482             redirect_url = add_preserved_filters(
1483                 {"preserved_filters": preserved_filters, "opts": opts}, redirect_url
1484             )
1485             return HttpResponseRedirect(redirect_url)
1486 
1487         elif "_saveasnew" in request.POST:
1488             msg = format_html(
1489                 _(
1490                     "The {name} “{obj}” was added successfully. You may edit it again "
1491                     "below."
1492                 ),
1493                 **msg_dict,
1494             )
1495             self.message_user(request, msg, messages.SUCCESS)
1496             redirect_url = reverse(
1497                 "admin:%s_%s_change" % (opts.app_label, opts.model_name),
1498                 args=(obj.pk,),
1499                 current_app=self.admin_site.name,
1500             )
1501             redirect_url = add_preserved_filters(
1502                 {"preserved_filters": preserved_filters, "opts": opts}, redirect_url
1503             )
1504             return HttpResponseRedirect(redirect_url)
1505 
1506         elif "_addanother" in request.POST:
1507             msg = format_html(
1508                 _(
1509                     "The {name} “{obj}” was changed successfully. You may add another "
1510                     "{name} below."
1511                 ),
1512                 **msg_dict,
1513             )
1514             self.message_user(request, msg, messages.SUCCESS)
1515             redirect_url = reverse(
1516                 "admin:%s_%s_add" % (opts.app_label, opts.model_name),
1517                 current_app=self.admin_site.name,
1518             )
1519             redirect_url = add_preserved_filters(
1520                 {"preserved_filters": preserved_filters, "opts": opts}, redirect_url
1521             )
1522             return HttpResponseRedirect(redirect_url)
1523 
1524         else:
1525             msg = format_html(
1526                 _("The {name} “{obj}” was changed successfully."), **msg_dict
1527             )
1528             self.message_user(request, msg, messages.SUCCESS)
1529             return self.response_post_save_change(request, obj)
1530 
1531     def _response_post_save(self, request, obj):
1532         if self.has_view_or_change_permission(request):
1533             post_url = reverse(
1534                 "admin:%s_%s_changelist" % (self.opts.app_label, self.opts.model_name),
1535                 current_app=self.admin_site.name,
1536             )
1537             preserved_filters = self.get_preserved_filters(request)
1538             post_url = add_preserved_filters(
1539                 {"preserved_filters": preserved_filters, "opts": self.opts}, post_url
1540             )
1541         else:
1542             post_url = reverse("admin:index", current_app=self.admin_site.name)
1543         return HttpResponseRedirect(post_url)
1544 
1545     def response_post_save_add(self, request, obj):
1546         """
1547         Figure out where to redirect after the 'Save' button has been pressed
1548         when adding a new object.
1549         """
1550         return self._response_post_save(request, obj)
1551 
1552     def response_post_save_change(self, request, obj):
1553         """
1554         Figure out where to redirect after the 'Save' button has been pressed
1555         when editing an existing object.
1556         """
1557         return self._response_post_save(request, obj)
1558 
1559     def response_action(self, request, queryset):
1560         """
1561         Handle an admin action. This is called if a request is POSTed to the
1562         changelist; it returns an HttpResponse if the action was handled, and
1563         None otherwise.
1564         """
1565 
1566         # There can be multiple action forms on the page (at the top
1567         # and bottom of the change list, for example). Get the action
1568         # whose button was pushed.
1569         try:
1570             action_index = int(request.POST.get("index", 0))
1571         except ValueError:
1572             action_index = 0
1573 
1574         # Construct the action form.
1575         data = request.POST.copy()
1576         data.pop(helpers.ACTION_CHECKBOX_NAME, None)
1577         data.pop("index", None)
1578 
1579         # Use the action whose button was pushed
1580         try:
1581             data.update({"action": data.getlist("action")[action_index]})
1582         except IndexError:
1583             # If we didn't get an action from the chosen form that's invalid
1584             # POST data, so by deleting action it'll fail the validation check
1585             # below. So no need to do anything here
1586             pass
1587 
1588         action_form = self.action_form(data, auto_id=None)
1589         action_form.fields["action"].choices = self.get_action_choices(request)
1590 
1591         # If the form's valid we can handle the action.
1592         if action_form.is_valid():
1593             action = action_form.cleaned_data["action"]
1594             select_across = action_form.cleaned_data["select_across"]
1595             func = self.get_actions(request)[action][0]
1596 
1597             # Get the list of selected PKs. If nothing's selected, we can't
1598             # perform an action on it, so bail. Except we want to perform
1599             # the action explicitly on all objects.
1600             selected = request.POST.getlist(helpers.ACTION_CHECKBOX_NAME)
1601             if not selected and not select_across:
1602                 # Reminder that something needs to be selected or nothing will happen
1603                 msg = _(
1604                     "Items must be selected in order to perform "
1605                     "actions on them. No items have been changed."
1606                 )
1607                 self.message_user(request, msg, messages.WARNING)
1608                 return None
1609 
1610             if not select_across:
1611                 # Perform the action only on the selected objects
1612                 queryset = queryset.filter(pk__in=selected)
1613 
1614             response = func(self, request, queryset)
1615 
1616             # Actions may return an HttpResponse-like object, which will be
1617             # used as the response from the POST. If not, we'll be a good
1618             # little HTTP citizen and redirect back to the changelist page.
1619             if isinstance(response, HttpResponseBase):
1620                 return response
1621             else:
1622                 return HttpResponseRedirect(request.get_full_path())
1623         else:
1624             msg = _("No action selected.")
1625             self.message_user(request, msg, messages.WARNING)
1626             return None
1627 
1628     def response_delete(self, request, obj_display, obj_id):
1629         """
1630         Determine the HttpResponse for the delete_view stage.
1631         """
1632         if IS_POPUP_VAR in request.POST:
1633             popup_response_data = json.dumps(
1634                 {
1635                     "action": "delete",
1636                     "value": str(obj_id),
1637                 }
1638             )
1639             return TemplateResponse(
1640                 request,
1641                 self.popup_response_template
1642                 or [
1643                     "admin/%s/%s/popup_response.html"
1644                     % (self.opts.app_label, self.opts.model_name),
1645                     "admin/%s/popup_response.html" % self.opts.app_label,
1646                     "admin/popup_response.html",
1647                 ],
1648                 {
1649                     "popup_response_data": popup_response_data,
1650                 },
1651             )
1652 
1653         self.message_user(
1654             request,
1655             _("The %(name)s “%(obj)s” was deleted successfully.")
1656             % {
1657                 "name": self.opts.verbose_name,
1658                 "obj": obj_display,
1659             },
1660             messages.SUCCESS,
1661         )
1662 
1663         if self.has_change_permission(request, None):
1664             post_url = reverse(
1665                 "admin:%s_%s_changelist" % (self.opts.app_label, self.opts.model_name),
1666                 current_app=self.admin_site.name,
1667             )
1668             preserved_filters = self.get_preserved_filters(request)
1669             post_url = add_preserved_filters(
1670                 {"preserved_filters": preserved_filters, "opts": self.opts}, post_url
1671             )
1672         else:
1673             post_url = reverse("admin:index", current_app=self.admin_site.name)
1674         return HttpResponseRedirect(post_url)
1675 
1676     def render_delete_form(self, request, context):
1677         app_label = self.opts.app_label
1678 
1679         request.current_app = self.admin_site.name
1680         context.update(
1681             to_field_var=TO_FIELD_VAR,
1682             is_popup_var=IS_POPUP_VAR,
1683             media=self.media,
1684         )
1685 
1686         return TemplateResponse(
1687             request,
1688             self.delete_confirmation_template
1689             or [
1690                 "admin/{}/{}/delete_confirmation.html".format(
1691                     app_label, self.opts.model_name
1692                 ),
1693                 "admin/{}/delete_confirmation.html".format(app_label),
1694                 "admin/delete_confirmation.html",
1695             ],
1696             context,
1697         )
1698 
1699     def get_inline_formsets(self, request, formsets, inline_instances, obj=None):
1700         # Edit permissions on parent model are required for editable inlines.
1701         can_edit_parent = (
1702             self.has_change_permission(request, obj)
1703             if obj
1704             else self.has_add_permission(request)
1705         )
1706         inline_admin_formsets = []
1707         for inline, formset in zip(inline_instances, formsets):
1708             fieldsets = list(inline.get_fieldsets(request, obj))
1709             readonly = list(inline.get_readonly_fields(request, obj))
1710             if can_edit_parent:
1711                 has_add_permission = inline.has_add_permission(request, obj)
1712                 has_change_permission = inline.has_change_permission(request, obj)
1713                 has_delete_permission = inline.has_delete_permission(request, obj)
1714             else:
1715                 # Disable all edit-permissions, and override formset settings.
1716                 has_add_permission = (
1717                     has_change_permission
1718                 ) = has_delete_permission = False
1719                 formset.extra = formset.max_num = 0
1720             has_view_permission = inline.has_view_permission(request, obj)
1721             prepopulated = dict(inline.get_prepopulated_fields(request, obj))
1722             inline_admin_formset = helpers.InlineAdminFormSet(
1723                 inline,
1724                 formset,
1725                 fieldsets,
1726                 prepopulated,
1727                 readonly,
1728                 model_admin=self,
1729                 has_add_permission=has_add_permission,
1730                 has_change_permission=has_change_permission,
1731                 has_delete_permission=has_delete_permission,
1732                 has_view_permission=has_view_permission,
1733             )
1734             inline_admin_formsets.append(inline_admin_formset)
1735         return inline_admin_formsets
1736 
1737     def get_changeform_initial_data(self, request):
1738         """
1739         Get the initial form data from the request's GET params.
1740         """
1741         initial = dict(request.GET.items())
1742         for k in initial:
1743             try:
1744                 f = self.opts.get_field(k)
1745             except FieldDoesNotExist:
1746                 continue
1747             # We have to special-case M2Ms as a list of comma-separated PKs.
1748             if isinstance(f, models.ManyToManyField):
1749                 initial[k] = initial[k].split(",")
1750         return initial
1751 
1752     def _get_obj_does_not_exist_redirect(self, request, opts, object_id):
1753         """
1754         Create a message informing the user that the object doesn't exist
1755         and return a redirect to the admin index page.
1756         """
1757         msg = _("%(name)s with ID “%(key)s” doesn’t exist. Perhaps it was deleted?") % {
1758             "name": opts.verbose_name,
1759             "key": unquote(object_id),
1760         }
1761         self.message_user(request, msg, messages.WARNING)
1762         url = reverse("admin:index", current_app=self.admin_site.name)
1763         return HttpResponseRedirect(url)
1764 
1765     @csrf_protect_m
1766     def changeform_view(self, request, object_id=None, form_url="", extra_context=None):
1767         with transaction.atomic(using=router.db_for_write(self.model)):
1768             return self._changeform_view(request, object_id, form_url, extra_context)
1769 
1770     def _changeform_view(self, request, object_id, form_url, extra_context):
1771         to_field = request.POST.get(TO_FIELD_VAR, request.GET.get(TO_FIELD_VAR))
1772         if to_field and not self.to_field_allowed(request, to_field):
1773             raise DisallowedModelAdminToField(
1774                 "The field %s cannot be referenced." % to_field
1775             )
1776 
1777         if request.method == "POST" and "_saveasnew" in request.POST:
1778             object_id = None
1779 
1780         add = object_id is None
1781 
1782         if add:
1783             if not self.has_add_permission(request):
1784                 raise PermissionDenied
1785             obj = None
1786 
1787         else:
1788             obj = self.get_object(request, unquote(object_id), to_field)
1789 
1790             if request.method == "POST":
1791                 if not self.has_change_permission(request, obj):
1792                     raise PermissionDenied
1793             else:
1794                 if not self.has_view_or_change_permission(request, obj):
1795                     raise PermissionDenied
1796 
1797             if obj is None:
1798                 return self._get_obj_does_not_exist_redirect(
1799                     request, self.opts, object_id
1800                 )
1801 
1802         fieldsets = self.get_fieldsets(request, obj)
1803         ModelForm = self.get_form(
1804             request, obj, change=not add, fields=flatten_fieldsets(fieldsets)
1805         )
1806         if request.method == "POST":
1807             form = ModelForm(request.POST, request.FILES, instance=obj)
1808             formsets, inline_instances = self._create_formsets(
1809                 request,
1810                 form.instance,
1811                 change=not add,
1812             )
1813             form_validated = form.is_valid()
1814             if form_validated:
1815                 new_object = self.save_form(request, form, change=not add)
1816             else:
1817                 new_object = form.instance
1818             if all_valid(formsets) and form_validated:
1819                 self.save_model(request, new_object, form, not add)
1820                 self.save_related(request, form, formsets, not add)
1821                 change_message = self.construct_change_message(
1822                     request, form, formsets, add
1823                 )
1824                 if add:
1825                     self.log_addition(request, new_object, change_message)
1826                     return self.response_add(request, new_object)
1827                 else:
1828                     self.log_change(request, new_object, change_message)
1829                     return self.response_change(request, new_object)
1830             else:
1831                 form_validated = False
1832         else:
1833             if add:
1834                 initial = self.get_changeform_initial_data(request)
1835                 form = ModelForm(initial=initial)
1836                 formsets, inline_instances = self._create_formsets(
1837                     request, form.instance, change=False
1838                 )
1839             else:
1840                 form = ModelForm(instance=obj)
1841                 formsets, inline_instances = self._create_formsets(
1842                     request, obj, change=True
1843                 )
1844 
1845         if not add and not self.has_change_permission(request, obj):
1846             readonly_fields = flatten_fieldsets(fieldsets)
1847         else:
1848             readonly_fields = self.get_readonly_fields(request, obj)
1849         admin_form = helpers.AdminForm(
1850             form,
1851             list(fieldsets),
1852             # Clear prepopulated fields on a view-only form to avoid a crash.
1853             self.get_prepopulated_fields(request, obj)
1854             if add or self.has_change_permission(request, obj)
1855             else {},
1856             readonly_fields,
1857             model_admin=self,
1858         )
1859         media = self.media + admin_form.media
1860 
1861         inline_formsets = self.get_inline_formsets(
1862             request, formsets, inline_instances, obj
1863         )
1864         for inline_formset in inline_formsets:
1865             media += inline_formset.media
1866 
1867         if add:
1868             title = _("Add %s")
1869         elif self.has_change_permission(request, obj):
1870             title = _("Change %s")
1871         else:
1872             title = _("View %s")
1873         context = {
1874             **self.admin_site.each_context(request),
1875             "title": title % self.opts.verbose_name,
1876             "subtitle": str(obj) if obj else None,
1877             "adminform": admin_form,
1878             "object_id": object_id,
1879             "original": obj,
1880             "is_popup": IS_POPUP_VAR in request.POST or IS_POPUP_VAR in request.GET,
1881             "to_field": to_field,
1882             "media": media,
1883             "inline_admin_formsets": inline_formsets,
1884             "errors": helpers.AdminErrorList(form, formsets),
1885             "preserved_filters": self.get_preserved_filters(request),
1886         }
1887 
1888         # Hide the "Save" and "Save and continue" buttons if "Save as New" was
1889         # previously chosen to prevent the interface from getting confusing.
1890         if (
1891             request.method == "POST"
1892             and not form_validated
1893             and "_saveasnew" in request.POST
1894         ):
1895             context["show_save"] = False
1896             context["show_save_and_continue"] = False
1897             # Use the change template instead of the add template.
1898             add = False
1899 
1900         context.update(extra_context or {})
1901 
1902         return self.render_change_form(
1903             request, context, add=add, change=not add, obj=obj, form_url=form_url
1904         )
1905 
1906     def add_view(self, request, form_url="", extra_context=None):
1907         return self.changeform_view(request, None, form_url, extra_context)
1908 
1909     def change_view(self, request, object_id, form_url="", extra_context=None):
1910         return self.changeform_view(request, object_id, form_url, extra_context)
1911 
1912     def _get_edited_object_pks(self, request, prefix):
1913         """Return POST data values of list_editable primary keys."""
1914         pk_pattern = re.compile(
1915             r"{}-\d+-{}$".format(re.escape(prefix), self.opts.pk.name)
1916         )
1917         return [value for key, value in request.POST.items() if pk_pattern.match(key)]
1918 
1919     def _get_list_editable_queryset(self, request, prefix):
1920         """
1921         Based on POST data, return a queryset of the objects that were edited
1922         via list_editable.
1923         """
1924         object_pks = self._get_edited_object_pks(request, prefix)
1925         queryset = self.get_queryset(request)
1926         validate = queryset.model._meta.pk.to_python
1927         try:
1928             for pk in object_pks:
1929                 validate(pk)
1930         except ValidationError:
1931             # Disable the optimization if the POST data was tampered with.
1932             return queryset
1933         return queryset.filter(pk__in=object_pks)
1934 
1935     @csrf_protect_m
1936     def changelist_view(self, request, extra_context=None):
1937         """
1938         The 'change list' admin view for this model.
1939         """
1940         from django.contrib.admin.views.main import ERROR_FLAG
1941 
1942         app_label = self.opts.app_label
1943         if not self.has_view_or_change_permission(request):
1944             raise PermissionDenied
1945 
1946         try:
1947             cl = self.get_changelist_instance(request)
1948         except IncorrectLookupParameters:
1949             # Wacky lookup parameters were given, so redirect to the main
1950             # changelist page, without parameters, and pass an 'invalid=1'
1951             # parameter via the query string. If wacky parameters were given
1952             # and the 'invalid=1' parameter was already in the query string,
1953             # something is screwed up with the database, so display an error
1954             # page.
1955             if ERROR_FLAG in request.GET:
1956                 return SimpleTemplateResponse(
1957                     "admin/invalid_setup.html",
1958                     {
1959                         "title": _("Database error"),
1960                     },
1961                 )
1962             return HttpResponseRedirect(request.path + "?" + ERROR_FLAG + "=1")
1963 
1964         # If the request was POSTed, this might be a bulk action or a bulk
1965         # edit. Try to look up an action or confirmation first, but if this
1966         # isn't an action the POST will fall through to the bulk edit check,
1967         # below.
1968         action_failed = False
1969         selected = request.POST.getlist(helpers.ACTION_CHECKBOX_NAME)
1970 
1971         actions = self.get_actions(request)
1972         # Actions with no confirmation
1973         if (
1974             actions
1975             and request.method == "POST"
1976             and "index" in request.POST
1977             and "_save" not in request.POST
1978         ):
1979             if selected:
1980                 response = self.response_action(
1981                     request, queryset=cl.get_queryset(request)
1982                 )
1983                 if response:
1984                     return response
1985                 else:
1986                     action_failed = True
1987             else:
1988                 msg = _(
1989                     "Items must be selected in order to perform "
1990                     "actions on them. No items have been changed."
1991                 )
1992                 self.message_user(request, msg, messages.WARNING)
1993                 action_failed = True
1994 
1995         # Actions with confirmation
1996         if (
1997             actions
1998             and request.method == "POST"
1999             and helpers.ACTION_CHECKBOX_NAME in request.POST
2000             and "index" not in request.POST
2001             and "_save" not in request.POST
2002         ):
2003             if selected:
2004                 response = self.response_action(
2005                     request, queryset=cl.get_queryset(request)
2006                 )
2007                 if response:
2008                     return response
2009                 else:
2010                     action_failed = True
2011 
2012         if action_failed:
2013             # Redirect back to the changelist page to avoid resubmitting the
2014             # form if the user refreshes the browser or uses the "No, take
2015             # me back" button on the action confirmation page.
2016             return HttpResponseRedirect(request.get_full_path())
2017 
2018         # If we're allowing changelist editing, we need to construct a formset
2019         # for the changelist given all the fields to be edited. Then we'll
2020         # use the formset to validate/process POSTed data.
2021         formset = cl.formset = None
2022 
2023         # Handle POSTed bulk-edit data.
2024         if request.method == "POST" and cl.list_editable and "_save" in request.POST:
2025             if not self.has_change_permission(request):
2026                 raise PermissionDenied
2027             FormSet = self.get_changelist_formset(request)
2028             modified_objects = self._get_list_editable_queryset(
2029                 request, FormSet.get_default_prefix()
2030             )
2031             formset = cl.formset = FormSet(
2032                 request.POST, request.FILES, queryset=modified_objects
2033             )
2034             if formset.is_valid():
2035                 changecount = 0
2036                 with transaction.atomic(using=router.db_for_write(self.model)):
2037                     for form in formset.forms:
2038                         if form.has_changed():
2039                             obj = self.save_form(request, form, change=True)
2040                             self.save_model(request, obj, form, change=True)
2041                             self.save_related(request, form, formsets=[], change=True)
2042                             change_msg = self.construct_change_message(
2043                                 request, form, None
2044                             )
2045                             self.log_change(request, obj, change_msg)
2046                             changecount += 1
2047                 if changecount:
2048                     msg = ngettext(
2049                         "%(count)s %(name)s was changed successfully.",
2050                         "%(count)s %(name)s were changed successfully.",
2051                         changecount,
2052                     ) % {
2053                         "count": changecount,
2054                         "name": model_ngettext(self.opts, changecount),
2055                     }
2056                     self.message_user(request, msg, messages.SUCCESS)
2057 
2058                 return HttpResponseRedirect(request.get_full_path())
2059 
2060         # Handle GET -- construct a formset for display.
2061         elif cl.list_editable and self.has_change_permission(request):
2062             FormSet = self.get_changelist_formset(request)
2063             formset = cl.formset = FormSet(queryset=cl.result_list)
2064 
2065         # Build the list of media to be used by the formset.
2066         if formset:
2067             media = self.media + formset.media
2068         else:
2069             media = self.media
2070 
2071         # Build the action form and populate it with available actions.
2072         if actions:
2073             action_form = self.action_form(auto_id=None)
2074             action_form.fields["action"].choices = self.get_action_choices(request)
2075             media += action_form.media
2076         else:
2077             action_form = None
2078 
2079         selection_note_all = ngettext(
2080             "%(total_count)s selected", "All %(total_count)s selected", cl.result_count
2081         )
2082 
2083         context = {
2084             **self.admin_site.each_context(request),
2085             "module_name": str(self.opts.verbose_name_plural),
2086             "selection_note": _("0 of %(cnt)s selected") % {"cnt": len(cl.result_list)},
2087             "selection_note_all": selection_note_all % {"total_count": cl.result_count},
2088             "title": cl.title,
2089             "subtitle": None,
2090             "is_popup": cl.is_popup,
2091             "to_field": cl.to_field,
2092             "cl": cl,
2093             "media": media,
2094             "has_add_permission": self.has_add_permission(request),
2095             "opts": cl.opts,
2096             "action_form": action_form,
2097             "actions_on_top": self.actions_on_top,
2098             "actions_on_bottom": self.actions_on_bottom,
2099             "actions_selection_counter": self.actions_selection_counter,
2100             "preserved_filters": self.get_preserved_filters(request),
2101             **(extra_context or {}),
2102         }
2103 
2104         request.current_app = self.admin_site.name
2105 
2106         return TemplateResponse(
2107             request,
2108             self.change_list_template
2109             or [
2110                 "admin/%s/%s/change_list.html" % (app_label, self.opts.model_name),
2111                 "admin/%s/change_list.html" % app_label,
2112                 "admin/change_list.html",
2113             ],
2114             context,
2115         )
2116 
2117     def get_deleted_objects(self, objs, request):
2118         """
2119         Hook for customizing the delete process for the delete view and the
2120         "delete selected" action.
2121         """
2122         return get_deleted_objects(objs, request, self.admin_site)
2123 
2124     @csrf_protect_m
2125     def delete_view(self, request, object_id, extra_context=None):
2126         with transaction.atomic(using=router.db_for_write(self.model)):
2127             return self._delete_view(request, object_id, extra_context)
2128 
2129     def _delete_view(self, request, object_id, extra_context):
2130         "The 'delete' admin view for this model."
2131         app_label = self.opts.app_label
2132 
2133         to_field = request.POST.get(TO_FIELD_VAR, request.GET.get(TO_FIELD_VAR))
2134         if to_field and not self.to_field_allowed(request, to_field):
2135             raise DisallowedModelAdminToField(
2136                 "The field %s cannot be referenced." % to_field
2137             )
2138 
2139         obj = self.get_object(request, unquote(object_id), to_field)
2140 
2141         if not self.has_delete_permission(request, obj):
2142             raise PermissionDenied
2143 
2144         if obj is None:
2145             return self._get_obj_does_not_exist_redirect(request, self.opts, object_id)
2146 
2147         # Populate deleted_objects, a data structure of all related objects that
2148         # will also be deleted.
2149         (
2150             deleted_objects,
2151             model_count,
2152             perms_needed,
2153             protected,
2154         ) = self.get_deleted_objects([obj], request)
2155 
2156         if request.POST and not protected:  # The user has confirmed the deletion.
2157             if perms_needed:
2158                 raise PermissionDenied
2159             obj_display = str(obj)
2160             attr = str(to_field) if to_field else self.opts.pk.attname
2161             obj_id = obj.serializable_value(attr)
2162             self.log_deletion(request, obj, obj_display)
2163             self.delete_model(request, obj)
2164 
2165             return self.response_delete(request, obj_display, obj_id)
2166 
2167         object_name = str(self.opts.verbose_name)
2168 
2169         if perms_needed or protected:
2170             title = _("Cannot delete %(name)s") % {"name": object_name}
2171         else:
2172             title = _("Are you sure?")
2173 
2174         context = {
2175             **self.admin_site.each_context(request),
2176             "title": title,
2177             "subtitle": None,
2178             "object_name": object_name,
2179             "object": obj,
2180             "deleted_objects": deleted_objects,
2181             "model_count": dict(model_count).items(),
2182             "perms_lacking": perms_needed,
2183             "protected": protected,
2184             "opts": self.opts,
2185             "app_label": app_label,
2186             "preserved_filters": self.get_preserved_filters(request),
2187             "is_popup": IS_POPUP_VAR in request.POST or IS_POPUP_VAR in request.GET,
2188             "to_field": to_field,
2189             **(extra_context or {}),
2190         }
2191 
2192         return self.render_delete_form(request, context)
2193 
2194     def history_view(self, request, object_id, extra_context=None):
2195         "The 'history' admin view for this model."
2196         from django.contrib.admin.models import LogEntry
2197         from django.contrib.admin.views.main import PAGE_VAR
2198 
2199         # First check if the user can see this history.
2200         model = self.model
2201         obj = self.get_object(request, unquote(object_id))
2202         if obj is None:
2203             return self._get_obj_does_not_exist_redirect(
2204                 request, model._meta, object_id
2205             )
2206 
2207         if not self.has_view_or_change_permission(request, obj):
2208             raise PermissionDenied
2209 
2210         # Then get the history for this object.
2211         app_label = self.opts.app_label
2212         action_list = (
2213             LogEntry.objects.filter(
2214                 object_id=unquote(object_id),
2215                 content_type=get_content_type_for_model(model),
2216             )
2217             .select_related()
2218             .order_by("action_time")
2219         )
2220 
2221         paginator = self.get_paginator(request, action_list, 100)
2222         page_number = request.GET.get(PAGE_VAR, 1)
2223         page_obj = paginator.get_page(page_number)
2224         page_range = paginator.get_elided_page_range(page_obj.number)
2225 
2226         context = {
2227             **self.admin_site.each_context(request),
2228             "title": _("Change history: %s") % obj,
2229             "subtitle": None,
2230             "action_list": page_obj,
2231             "page_range": page_range,
2232             "page_var": PAGE_VAR,
2233             "pagination_required": paginator.count > 100,
2234             "module_name": str(capfirst(self.opts.verbose_name_plural)),
2235             "object": obj,
2236             "opts": self.opts,
2237             "preserved_filters": self.get_preserved_filters(request),
2238             **(extra_context or {}),
2239         }
2240 
2241         request.current_app = self.admin_site.name
2242 
2243         return TemplateResponse(
2244             request,
2245             self.object_history_template
2246             or [
2247                 "admin/%s/%s/object_history.html" % (app_label, self.opts.model_name),
2248                 "admin/%s/object_history.html" % app_label,
2249                 "admin/object_history.html",
2250             ],
2251             context,
2252         )
2253 
2254     def get_formset_kwargs(self, request, obj, inline, prefix):
2255         formset_params = {
2256             "instance": obj,
2257             "prefix": prefix,
2258             "queryset": inline.get_queryset(request),
2259         }
2260         if request.method == "POST":
2261             formset_params.update(
2262                 {
2263                     "data": request.POST.copy(),
2264                     "files": request.FILES,
2265                     "save_as_new": "_saveasnew" in request.POST,
2266                 }
2267             )
2268         return formset_params
2269 
2270     def _create_formsets(self, request, obj, change):
2271         "Helper function to generate formsets for add/change_view."
2272         formsets = []
2273         inline_instances = []
2274         prefixes = {}
2275         get_formsets_args = [request]
2276         if change:
2277             get_formsets_args.append(obj)
2278         for FormSet, inline in self.get_formsets_with_inlines(*get_formsets_args):
2279             prefix = FormSet.get_default_prefix()
2280             prefixes[prefix] = prefixes.get(prefix, 0) + 1
2281             if prefixes[prefix] != 1 or not prefix:
2282                 prefix = "%s-%s" % (prefix, prefixes[prefix])
2283             formset_params = self.get_formset_kwargs(request, obj, inline, prefix)
2284             formset = FormSet(**formset_params)
2285 
2286             def user_deleted_form(request, obj, formset, index, inline):
2287                 """Return whether or not the user deleted the form."""
2288                 return (
2289                     inline.has_delete_permission(request, obj)
2290                     and "{}-{}-DELETE".format(formset.prefix, index) in request.POST
2291                 )
2292 
2293             # Bypass validation of each view-only inline form (since the form's
2294             # data won't be in request.POST), unless the form was deleted.
2295             if not inline.has_change_permission(request, obj if change else None):
2296                 for index, form in enumerate(formset.initial_forms):
2297                     if user_deleted_form(request, obj, formset, index, inline):
2298                         continue
2299                     form._errors = {}
2300                     form.cleaned_data = form.initial
2301             formsets.append(formset)
2302             inline_instances.append(inline)
2303         return formsets, inline_instances

</code><intended_behavior>A new validation method or an enhancement of an existing one within ModelAdmin should check if filter_horizontal or filter_vertical is used with a ManyToManyField that has a custom through model defined. This method should raise a validation error or at least a warning if such a configuration is detected, guiding developers away from this unsupported setup. The validation should be integrated into the admin system checks that run when the server starts or the checks framework is otherwise invoked. This preserves the functionality of filter_horizontal and filter_vertical by clearly communicating their limitations to developers.</intended_behavior>, <file>django/contrib/admin/checks.py</file>
<class>None</class>
<method>None</method>
<code>
1 import collections
2 from itertools import chain
3 
4 from django.apps import apps
5 from django.conf import settings
6 from django.contrib.admin.utils import NotRelationField, flatten, get_fields_from_path
7 from django.core import checks
8 from django.core.exceptions import FieldDoesNotExist
9 from django.db import models
10 from django.db.models.constants import LOOKUP_SEP
11 from django.db.models.expressions import Combinable
12 from django.forms.models import BaseModelForm, BaseModelFormSet, _get_foreign_key
13 from django.template import engines
14 from django.template.backends.django import DjangoTemplates
15 from django.utils.module_loading import import_string
16 
17 
18 def _issubclass(cls, classinfo):
19     """
20     issubclass() variant that doesn't raise an exception if cls isn't a
21     class.
22     """
23     try:
24         return issubclass(cls, classinfo)
25     except TypeError:
26         return False
27 
28 
29 def _contains_subclass(class_path, candidate_paths):
30     """
31     Return whether or not a dotted class path (or a subclass of that class) is
32     found in a list of candidate paths.
33     """
34     cls = import_string(class_path)
35     for path in candidate_paths:
36         try:
37             candidate_cls = import_string(path)
38         except ImportError:
39             # ImportErrors are raised elsewhere.
40             continue
41         if _issubclass(candidate_cls, cls):
42             return True
43     return False
44 
45 
46 def check_admin_app(app_configs, **kwargs):
47     from django.contrib.admin.sites import all_sites
48 
49     errors = []
50     for site in all_sites:
51         errors.extend(site.check(app_configs))
52     return errors
53 
54 
55 def check_dependencies(**kwargs):
56     """
57     Check that the admin's dependencies are correctly installed.
58     """
59     from django.contrib.admin.sites import all_sites
60 
61     if not apps.is_installed("django.contrib.admin"):
62         return []
63     errors = []
64     app_dependencies = (
65         ("django.contrib.contenttypes", 401),
66         ("django.contrib.auth", 405),
67         ("django.contrib.messages", 406),
68     )
69     for app_name, error_code in app_dependencies:
70         if not apps.is_installed(app_name):
71             errors.append(
72                 checks.Error(
73                     "'%s' must be in INSTALLED_APPS in order to use the admin "
74                     "application." % app_name,
75                     id="admin.E%d" % error_code,
76                 )
77             )
78     for engine in engines.all():
79         if isinstance(engine, DjangoTemplates):
80             django_templates_instance = engine.engine
81             break
82     else:
83         django_templates_instance = None
84     if not django_templates_instance:
85         errors.append(
86             checks.Error(
87                 "A 'django.template.backends.django.DjangoTemplates' instance "
88                 "must be configured in TEMPLATES in order to use the admin "
89                 "application.",
90                 id="admin.E403",
91             )
92         )
93     else:
94         if (
95             "django.contrib.auth.context_processors.auth"
96             not in django_templates_instance.context_processors
97             and _contains_subclass(
98                 "django.contrib.auth.backends.ModelBackend",
99                 settings.AUTHENTICATION_BACKENDS,
100             )
101         ):
102             errors.append(
103                 checks.Error(
104                     "'django.contrib.auth.context_processors.auth' must be "
105                     "enabled in DjangoTemplates (TEMPLATES) if using the default "
106                     "auth backend in order to use the admin application.",
107                     id="admin.E402",
108                 )
109             )
110         if (
111             "django.contrib.messages.context_processors.messages"
112             not in django_templates_instance.context_processors
113         ):
114             errors.append(
115                 checks.Error(
116                     "'django.contrib.messages.context_processors.messages' must "
117                     "be enabled in DjangoTemplates (TEMPLATES) in order to use "
118                     "the admin application.",
119                     id="admin.E404",
120                 )
121             )
122         sidebar_enabled = any(site.enable_nav_sidebar for site in all_sites)
123         if (
124             sidebar_enabled
125             and "django.template.context_processors.request"
126             not in django_templates_instance.context_processors
127         ):
128             errors.append(
129                 checks.Warning(
130                     "'django.template.context_processors.request' must be enabled "
131                     "in DjangoTemplates (TEMPLATES) in order to use the admin "
132                     "navigation sidebar.",
133                     id="admin.W411",
134                 )
135             )
136 
137     if not _contains_subclass(
138         "django.contrib.auth.middleware.AuthenticationMiddleware", settings.MIDDLEWARE
139     ):
140         errors.append(
141             checks.Error(
142                 "'django.contrib.auth.middleware.AuthenticationMiddleware' must "
143                 "be in MIDDLEWARE in order to use the admin application.",
144                 id="admin.E408",
145             )
146         )
147     if not _contains_subclass(
148         "django.contrib.messages.middleware.MessageMiddleware", settings.MIDDLEWARE
149     ):
150         errors.append(
151             checks.Error(
152                 "'django.contrib.messages.middleware.MessageMiddleware' must "
153                 "be in MIDDLEWARE in order to use the admin application.",
154                 id="admin.E409",
155             )
156         )
157     if not _contains_subclass(
158         "django.contrib.sessions.middleware.SessionMiddleware", settings.MIDDLEWARE
159     ):
160         errors.append(
161             checks.Error(
162                 "'django.contrib.sessions.middleware.SessionMiddleware' must "
163                 "be in MIDDLEWARE in order to use the admin application.",
164                 hint=(
165                     "Insert "
166                     "'django.contrib.sessions.middleware.SessionMiddleware' "
167                     "before "
168                     "'django.contrib.auth.middleware.AuthenticationMiddleware'."
169                 ),
170                 id="admin.E410",
171             )
172         )
173     return errors
174 
175 
176 class BaseModelAdminChecks:
177     def check(self, admin_obj, **kwargs):
178         return [
179             *self._check_autocomplete_fields(admin_obj),
180             *self._check_raw_id_fields(admin_obj),
181             *self._check_fields(admin_obj),
182             *self._check_fieldsets(admin_obj),
183             *self._check_exclude(admin_obj),
184             *self._check_form(admin_obj),
185             *self._check_filter_vertical(admin_obj),
186             *self._check_filter_horizontal(admin_obj),
187             *self._check_radio_fields(admin_obj),
188             *self._check_prepopulated_fields(admin_obj),
189             *self._check_view_on_site_url(admin_obj),
190             *self._check_ordering(admin_obj),
191             *self._check_readonly_fields(admin_obj),
192         ]
193 
194     def _check_autocomplete_fields(self, obj):
195         """
196         Check that `autocomplete_fields` is a list or tuple of model fields.
197         """
198         if not isinstance(obj.autocomplete_fields, (list, tuple)):
199             return must_be(
200                 "a list or tuple",
201                 option="autocomplete_fields",
202                 obj=obj,
203                 id="admin.E036",
204             )
205         else:
206             return list(
207                 chain.from_iterable(
208                     [
209                         self._check_autocomplete_fields_item(
210                             obj, field_name, "autocomplete_fields[%d]" % index
211                         )
212                         for index, field_name in enumerate(obj.autocomplete_fields)
213                     ]
214                 )
215             )
216 
217     def _check_autocomplete_fields_item(self, obj, field_name, label):
218         """
219         Check that an item in `autocomplete_fields` is a ForeignKey or a
220         ManyToManyField and that the item has a related ModelAdmin with
221         search_fields defined.
222         """
223         try:
224             field = obj.model._meta.get_field(field_name)
225         except FieldDoesNotExist:
226             return refer_to_missing_field(
227                 field=field_name, option=label, obj=obj, id="admin.E037"
228             )
229         else:
230             if not field.many_to_many and not isinstance(field, models.ForeignKey):
231                 return must_be(
232                     "a foreign key or a many-to-many field",
233                     option=label,
234                     obj=obj,
235                     id="admin.E038",
236                 )
237             related_admin = obj.admin_site._registry.get(field.remote_field.model)
238             if related_admin is None:
239                 return [
240                     checks.Error(
241                         'An admin for model "%s" has to be registered '
242                         "to be referenced by %s.autocomplete_fields."
243                         % (
244                             field.remote_field.model.__name__,
245                             type(obj).__name__,
246                         ),
247                         obj=obj.__class__,
248                         id="admin.E039",
249                     )
250                 ]
251             elif not related_admin.search_fields:
252                 return [
253                     checks.Error(
254                         '%s must define "search_fields", because it\'s '
255                         "referenced by %s.autocomplete_fields."
256                         % (
257                             related_admin.__class__.__name__,
258                             type(obj).__name__,
259                         ),
260                         obj=obj.__class__,
261                         id="admin.E040",
262                     )
263                 ]
264             return []
265 
266     def _check_raw_id_fields(self, obj):
267         """Check that `raw_id_fields` only contains field names that are listed
268         on the model."""
269 
270         if not isinstance(obj.raw_id_fields, (list, tuple)):
271             return must_be(
272                 "a list or tuple", option="raw_id_fields", obj=obj, id="admin.E001"
273             )
274         else:
275             return list(
276                 chain.from_iterable(
277                     self._check_raw_id_fields_item(
278                         obj, field_name, "raw_id_fields[%d]" % index
279                     )
280                     for index, field_name in enumerate(obj.raw_id_fields)
281                 )
282             )
283 
284     def _check_raw_id_fields_item(self, obj, field_name, label):
285         """Check an item of `raw_id_fields`, i.e. check that field named
286         `field_name` exists in model `model` and is a ForeignKey or a
287         ManyToManyField."""
288 
289         try:
290             field = obj.model._meta.get_field(field_name)
291         except FieldDoesNotExist:
292             return refer_to_missing_field(
293                 field=field_name, option=label, obj=obj, id="admin.E002"
294             )
295         else:
296             # Using attname is not supported.
297             if field.name != field_name:
298                 return refer_to_missing_field(
299                     field=field_name,
300                     option=label,
301                     obj=obj,
302                     id="admin.E002",
303                 )
304             if not field.many_to_many and not isinstance(field, models.ForeignKey):
305                 return must_be(
306                     "a foreign key or a many-to-many field",
307                     option=label,
308                     obj=obj,
309                     id="admin.E003",
310                 )
311             else:
312                 return []
313 
314     def _check_fields(self, obj):
315         """Check that `fields` only refer to existing fields, doesn't contain
316         duplicates. Check if at most one of `fields` and `fieldsets` is defined.
317         """
318 
319         if obj.fields is None:
320             return []
321         elif not isinstance(obj.fields, (list, tuple)):
322             return must_be("a list or tuple", option="fields", obj=obj, id="admin.E004")
323         elif obj.fieldsets:
324             return [
325                 checks.Error(
326                     "Both 'fieldsets' and 'fields' are specified.",
327                     obj=obj.__class__,
328                     id="admin.E005",
329                 )
330             ]
331         fields = flatten(obj.fields)
332         if len(fields) != len(set(fields)):
333             return [
334                 checks.Error(
335                     "The value of 'fields' contains duplicate field(s).",
336                     obj=obj.__class__,
337                     id="admin.E006",
338                 )
339             ]
340 
341         return list(
342             chain.from_iterable(
343                 self._check_field_spec(obj, field_name, "fields")
344                 for field_name in obj.fields
345             )
346         )
347 
348     def _check_fieldsets(self, obj):
349         """Check that fieldsets is properly formatted and doesn't contain
350         duplicates."""
351 
352         if obj.fieldsets is None:
353             return []
354         elif not isinstance(obj.fieldsets, (list, tuple)):
355             return must_be(
356                 "a list or tuple", option="fieldsets", obj=obj, id="admin.E007"
357             )
358         else:
359             seen_fields = []
360             return list(
361                 chain.from_iterable(
362                     self._check_fieldsets_item(
363                         obj, fieldset, "fieldsets[%d]" % index, seen_fields
364                     )
365                     for index, fieldset in enumerate(obj.fieldsets)
366                 )
367             )
368 
369     def _check_fieldsets_item(self, obj, fieldset, label, seen_fields):
370         """Check an item of `fieldsets`, i.e. check that this is a pair of a
371         set name and a dictionary containing "fields" key."""
372 
373         if not isinstance(fieldset, (list, tuple)):
374             return must_be("a list or tuple", option=label, obj=obj, id="admin.E008")
375         elif len(fieldset) != 2:
376             return must_be("of length 2", option=label, obj=obj, id="admin.E009")
377         elif not isinstance(fieldset[1], dict):
378             return must_be(
379                 "a dictionary", option="%s[1]" % label, obj=obj, id="admin.E010"
380             )
381         elif "fields" not in fieldset[1]:
382             return [
383                 checks.Error(
384                     "The value of '%s[1]' must contain the key 'fields'." % label,
385                     obj=obj.__class__,
386                     id="admin.E011",
387                 )
388             ]
389         elif not isinstance(fieldset[1]["fields"], (list, tuple)):
390             return must_be(
391                 "a list or tuple",
392                 option="%s[1]['fields']" % label,
393                 obj=obj,
394                 id="admin.E008",
395             )
396 
397         seen_fields.extend(flatten(fieldset[1]["fields"]))
398         if len(seen_fields) != len(set(seen_fields)):
399             return [
400                 checks.Error(
401                     "There are duplicate field(s) in '%s[1]'." % label,
402                     obj=obj.__class__,
403                     id="admin.E012",
404                 )
405             ]
406         return list(
407             chain.from_iterable(
408                 self._check_field_spec(obj, fieldset_fields, '%s[1]["fields"]' % label)
409                 for fieldset_fields in fieldset[1]["fields"]
410             )
411         )
412 
413     def _check_field_spec(self, obj, fields, label):
414         """`fields` should be an item of `fields` or an item of
415         fieldset[1]['fields'] for any `fieldset` in `fieldsets`. It should be a
416         field name or a tuple of field names."""
417 
418         if isinstance(fields, tuple):
419             return list(
420                 chain.from_iterable(
421                     self._check_field_spec_item(
422                         obj, field_name, "%s[%d]" % (label, index)
423                     )
424                     for index, field_name in enumerate(fields)
425                 )
426             )
427         else:
428             return self._check_field_spec_item(obj, fields, label)
429 
430     def _check_field_spec_item(self, obj, field_name, label):
431         if field_name in obj.readonly_fields:
432             # Stuff can be put in fields that isn't actually a model field if
433             # it's in readonly_fields, readonly_fields will handle the
434             # validation of such things.
435             return []
436         else:
437             try:
438                 field = obj.model._meta.get_field(field_name)
439             except FieldDoesNotExist:
440                 # If we can't find a field on the model that matches, it could
441                 # be an extra field on the form.
442                 return []
443             else:
444                 if (
445                     isinstance(field, models.ManyToManyField)
446                     and not field.remote_field.through._meta.auto_created
447                 ):
448                     return [
449                         checks.Error(
450                             "The value of '%s' cannot include the ManyToManyField "
451                             "'%s', because that field manually specifies a "
452                             "relationship model." % (label, field_name),
453                             obj=obj.__class__,
454                             id="admin.E013",
455                         )
456                     ]
457                 else:
458                     return []
459 
460     def _check_exclude(self, obj):
461         """Check that exclude is a sequence without duplicates."""
462 
463         if obj.exclude is None:  # default value is None
464             return []
465         elif not isinstance(obj.exclude, (list, tuple)):
466             return must_be(
467                 "a list or tuple", option="exclude", obj=obj, id="admin.E014"
468             )
469         elif len(obj.exclude) > len(set(obj.exclude)):
470             return [
471                 checks.Error(
472                     "The value of 'exclude' contains duplicate field(s).",
473                     obj=obj.__class__,
474                     id="admin.E015",
475                 )
476             ]
477         else:
478             return []
479 
480     def _check_form(self, obj):
481         """Check that form subclasses BaseModelForm."""
482         if not _issubclass(obj.form, BaseModelForm):
483             return must_inherit_from(
484                 parent="BaseModelForm", option="form", obj=obj, id="admin.E016"
485             )
486         else:
487             return []
488 
489     def _check_filter_vertical(self, obj):
490         """Check that filter_vertical is a sequence of field names."""
491         if not isinstance(obj.filter_vertical, (list, tuple)):
492             return must_be(
493                 "a list or tuple", option="filter_vertical", obj=obj, id="admin.E017"
494             )
495         else:
496             return list(
497                 chain.from_iterable(
498                     self._check_filter_item(
499                         obj, field_name, "filter_vertical[%d]" % index
500                     )
501                     for index, field_name in enumerate(obj.filter_vertical)
502                 )
503             )
504 
505     def _check_filter_horizontal(self, obj):
506         """Check that filter_horizontal is a sequence of field names."""
507         if not isinstance(obj.filter_horizontal, (list, tuple)):
508             return must_be(
509                 "a list or tuple", option="filter_horizontal", obj=obj, id="admin.E018"
510             )
511         else:
512             return list(
513                 chain.from_iterable(
514                     self._check_filter_item(
515                         obj, field_name, "filter_horizontal[%d]" % index
516                     )
517                     for index, field_name in enumerate(obj.filter_horizontal)
518                 )
519             )
520 
521     def _check_filter_item(self, obj, field_name, label):
522         """Check one item of `filter_vertical` or `filter_horizontal`, i.e.
523         check that given field exists and is a ManyToManyField."""
524 
525         try:
526             field = obj.model._meta.get_field(field_name)
527         except FieldDoesNotExist:
528             return refer_to_missing_field(
529                 field=field_name, option=label, obj=obj, id="admin.E019"
530             )
531         else:
532             if not field.many_to_many:
533                 return must_be(
534                     "a many-to-many field", option=label, obj=obj, id="admin.E020"
535                 )
536             else:
537                 return []
538 
539     def _check_radio_fields(self, obj):
540         """Check that `radio_fields` is a dictionary."""
541         if not isinstance(obj.radio_fields, dict):
542             return must_be(
543                 "a dictionary", option="radio_fields", obj=obj, id="admin.E021"
544             )
545         else:
546             return list(
547                 chain.from_iterable(
548                     self._check_radio_fields_key(obj, field_name, "radio_fields")
549                     + self._check_radio_fields_value(
550                         obj, val, 'radio_fields["%s"]' % field_name
551                     )
552                     for field_name, val in obj.radio_fields.items()
553                 )
554             )
555 
556     def _check_radio_fields_key(self, obj, field_name, label):
557         """Check that a key of `radio_fields` dictionary is name of existing
558         field and that the field is a ForeignKey or has `choices` defined."""
559 
560         try:
561             field = obj.model._meta.get_field(field_name)
562         except FieldDoesNotExist:
563             return refer_to_missing_field(
564                 field=field_name, option=label, obj=obj, id="admin.E022"
565             )
566         else:
567             if not (isinstance(field, models.ForeignKey) or field.choices):
568                 return [
569                     checks.Error(
570                         "The value of '%s' refers to '%s', which is not an "
571                         "instance of ForeignKey, and does not have a 'choices' "
572                         "definition." % (label, field_name),
573                         obj=obj.__class__,
574                         id="admin.E023",
575                     )
576                 ]
577             else:
578                 return []
579 
580     def _check_radio_fields_value(self, obj, val, label):
581         """Check type of a value of `radio_fields` dictionary."""
582 
583         from django.contrib.admin.options import HORIZONTAL, VERTICAL
584 
585         if val not in (HORIZONTAL, VERTICAL):
586             return [
587                 checks.Error(
588                     "The value of '%s' must be either admin.HORIZONTAL or "
589                     "admin.VERTICAL." % label,
590                     obj=obj.__class__,
591                     id="admin.E024",
592                 )
593             ]
594         else:
595             return []
596 
597     def _check_view_on_site_url(self, obj):
598         if not callable(obj.view_on_site) and not isinstance(obj.view_on_site, bool):
599             return [
600                 checks.Error(
601                     "The value of 'view_on_site' must be a callable or a boolean "
602                     "value.",
603                     obj=obj.__class__,
604                     id="admin.E025",
605                 )
606             ]
607         else:
608             return []
609 
610     def _check_prepopulated_fields(self, obj):
611         """Check that `prepopulated_fields` is a dictionary containing allowed
612         field types."""
613         if not isinstance(obj.prepopulated_fields, dict):
614             return must_be(
615                 "a dictionary", option="prepopulated_fields", obj=obj, id="admin.E026"
616             )
617         else:
618             return list(
619                 chain.from_iterable(
620                     self._check_prepopulated_fields_key(
621                         obj, field_name, "prepopulated_fields"
622                     )
623                     + self._check_prepopulated_fields_value(
624                         obj, val, 'prepopulated_fields["%s"]' % field_name
625                     )
626                     for field_name, val in obj.prepopulated_fields.items()
627                 )
628             )
629 
630     def _check_prepopulated_fields_key(self, obj, field_name, label):
631         """Check a key of `prepopulated_fields` dictionary, i.e. check that it
632         is a name of existing field and the field is one of the allowed types.
633         """
634 
635         try:
636             field = obj.model._meta.get_field(field_name)
637         except FieldDoesNotExist:
638             return refer_to_missing_field(
639                 field=field_name, option=label, obj=obj, id="admin.E027"
640             )
641         else:
642             if isinstance(
643                 field, (models.DateTimeField, models.ForeignKey, models.ManyToManyField)
644             ):
645                 return [
646                     checks.Error(
647                         "The value of '%s' refers to '%s', which must not be a "
648                         "DateTimeField, a ForeignKey, a OneToOneField, or a "
649                         "ManyToManyField." % (label, field_name),
650                         obj=obj.__class__,
651                         id="admin.E028",
652                     )
653                 ]
654             else:
655                 return []
656 
657     def _check_prepopulated_fields_value(self, obj, val, label):
658         """Check a value of `prepopulated_fields` dictionary, i.e. it's an
659         iterable of existing fields."""
660 
661         if not isinstance(val, (list, tuple)):
662             return must_be("a list or tuple", option=label, obj=obj, id="admin.E029")
663         else:
664             return list(
665                 chain.from_iterable(
666                     self._check_prepopulated_fields_value_item(
667                         obj, subfield_name, "%s[%r]" % (label, index)
668                     )
669                     for index, subfield_name in enumerate(val)
670                 )
671             )
672 
673     def _check_prepopulated_fields_value_item(self, obj, field_name, label):
674         """For `prepopulated_fields` equal to {"slug": ("title",)},
675         `field_name` is "title"."""
676 
677         try:
678             obj.model._meta.get_field(field_name)
679         except FieldDoesNotExist:
680             return refer_to_missing_field(
681                 field=field_name, option=label, obj=obj, id="admin.E030"
682             )
683         else:
684             return []
685 
686     def _check_ordering(self, obj):
687         """Check that ordering refers to existing fields or is random."""
688 
689         # ordering = None
690         if obj.ordering is None:  # The default value is None
691             return []
692         elif not isinstance(obj.ordering, (list, tuple)):
693             return must_be(
694                 "a list or tuple", option="ordering", obj=obj, id="admin.E031"
695             )
696         else:
697             return list(
698                 chain.from_iterable(
699                     self._check_ordering_item(obj, field_name, "ordering[%d]" % index)
700                     for index, field_name in enumerate(obj.ordering)
701                 )
702             )
703 
704     def _check_ordering_item(self, obj, field_name, label):
705         """Check that `ordering` refers to existing fields."""
706         if isinstance(field_name, (Combinable, models.OrderBy)):
707             if not isinstance(field_name, models.OrderBy):
708                 field_name = field_name.asc()
709             if isinstance(field_name.expression, models.F):
710                 field_name = field_name.expression.name
711             else:
712                 return []
713         if field_name == "?" and len(obj.ordering) != 1:
714             return [
715                 checks.Error(
716                     "The value of 'ordering' has the random ordering marker '?', "
717                     "but contains other fields as well.",
718                     hint='Either remove the "?", or remove the other fields.',
719                     obj=obj.__class__,
720                     id="admin.E032",
721                 )
722             ]
723         elif field_name == "?":
724             return []
725         elif LOOKUP_SEP in field_name:
726             # Skip ordering in the format field1__field2 (FIXME: checking
727             # this format would be nice, but it's a little fiddly).
728             return []
729         else:
730             field_name = field_name.removeprefix("-")
731             if field_name == "pk":
732                 return []
733             try:
734                 obj.model._meta.get_field(field_name)
735             except FieldDoesNotExist:
736                 return refer_to_missing_field(
737                     field=field_name, option=label, obj=obj, id="admin.E033"
738                 )
739             else:
740                 return []
741 
742     def _check_readonly_fields(self, obj):
743         """Check that readonly_fields refers to proper attribute or field."""
744 
745         if obj.readonly_fields == ():
746             return []
747         elif not isinstance(obj.readonly_fields, (list, tuple)):
748             return must_be(
749                 "a list or tuple", option="readonly_fields", obj=obj, id="admin.E034"
750             )
751         else:
752             return list(
753                 chain.from_iterable(
754                     self._check_readonly_fields_item(
755                         obj, field_name, "readonly_fields[%d]" % index
756                     )
757                     for index, field_name in enumerate(obj.readonly_fields)
758                 )
759             )
760 
761     def _check_readonly_fields_item(self, obj, field_name, label):
762         if callable(field_name):
763             return []
764         elif hasattr(obj, field_name):
765             return []
766         elif hasattr(obj.model, field_name):
767             return []
768         else:
769             try:
770                 obj.model._meta.get_field(field_name)
771             except FieldDoesNotExist:
772                 return [
773                     checks.Error(
774                         "The value of '%s' refers to '%s', which is not a callable, "
775                         "an attribute of '%s', or an attribute of '%s'."
776                         % (
777                             label,
778                             field_name,
779                             obj.__class__.__name__,
780                             obj.model._meta.label,
781                         ),
782                         obj=obj.__class__,
783                         id="admin.E035",
784                     )
785                 ]
786             else:
787                 return []
788 
789 
790 class ModelAdminChecks(BaseModelAdminChecks):
791     def check(self, admin_obj, **kwargs):
792         return [
793             *super().check(admin_obj),
794             *self._check_save_as(admin_obj),
795             *self._check_save_on_top(admin_obj),
796             *self._check_inlines(admin_obj),
797             *self._check_list_display(admin_obj),
798             *self._check_list_display_links(admin_obj),
799             *self._check_list_filter(admin_obj),
800             *self._check_list_select_related(admin_obj),
801             *self._check_list_per_page(admin_obj),
802             *self._check_list_max_show_all(admin_obj),
803             *self._check_list_editable(admin_obj),
804             *self._check_search_fields(admin_obj),
805             *self._check_date_hierarchy(admin_obj),
806             *self._check_action_permission_methods(admin_obj),
807             *self._check_actions_uniqueness(admin_obj),
808         ]
809 
810     def _check_save_as(self, obj):
811         """Check save_as is a boolean."""
812 
813         if not isinstance(obj.save_as, bool):
814             return must_be("a boolean", option="save_as", obj=obj, id="admin.E101")
815         else:
816             return []
817 
818     def _check_save_on_top(self, obj):
819         """Check save_on_top is a boolean."""
820 
821         if not isinstance(obj.save_on_top, bool):
822             return must_be("a boolean", option="save_on_top", obj=obj, id="admin.E102")
823         else:
824             return []
825 
826     def _check_inlines(self, obj):
827         """Check all inline model admin classes."""
828 
829         if not isinstance(obj.inlines, (list, tuple)):
830             return must_be(
831                 "a list or tuple", option="inlines", obj=obj, id="admin.E103"
832             )
833         else:
834             return list(
835                 chain.from_iterable(
836                     self._check_inlines_item(obj, item, "inlines[%d]" % index)
837                     for index, item in enumerate(obj.inlines)
838                 )
839             )
840 
841     def _check_inlines_item(self, obj, inline, label):
842         """Check one inline model admin."""
843         try:
844             inline_label = inline.__module__ + "." + inline.__name__
845         except AttributeError:
846             return [
847                 checks.Error(
848                     "'%s' must inherit from 'InlineModelAdmin'." % obj,
849                     obj=obj.__class__,
850                     id="admin.E104",
851                 )
852             ]
853 
854         from django.contrib.admin.options import InlineModelAdmin
855 
856         if not _issubclass(inline, InlineModelAdmin):
857             return [
858                 checks.Error(
859                     "'%s' must inherit from 'InlineModelAdmin'." % inline_label,
860                     obj=obj.__class__,
861                     id="admin.E104",
862                 )
863             ]
864         elif not inline.model:
865             return [
866                 checks.Error(
867                     "'%s' must have a 'model' attribute." % inline_label,
868                     obj=obj.__class__,
869                     id="admin.E105",
870                 )
871             ]
872         elif not _issubclass(inline.model, models.Model):
873             return must_be(
874                 "a Model", option="%s.model" % inline_label, obj=obj, id="admin.E106"
875             )
876         else:
877             return inline(obj.model, obj.admin_site).check()
878 
879     def _check_list_display(self, obj):
880         """Check that list_display only contains fields or usable attributes."""
881 
882         if not isinstance(obj.list_display, (list, tuple)):
883             return must_be(
884                 "a list or tuple", option="list_display", obj=obj, id="admin.E107"
885             )
886         else:
887             return list(
888                 chain.from_iterable(
889                     self._check_list_display_item(obj, item, "list_display[%d]" % index)
890                     for index, item in enumerate(obj.list_display)
891                 )
892             )
893 
894     def _check_list_display_item(self, obj, item, label):
895         if callable(item):
896             return []
897         elif hasattr(obj, item):
898             return []
899         try:
900             field = obj.model._meta.get_field(item)
901         except FieldDoesNotExist:
902             try:
903                 field = getattr(obj.model, item)
904             except AttributeError:
905                 return [
906                     checks.Error(
907                         "The value of '%s' refers to '%s', which is not a "
908                         "callable, an attribute of '%s', or an attribute or "
909                         "method on '%s'."
910                         % (
911                             label,
912                             item,
913                             obj.__class__.__name__,
914                             obj.model._meta.label,
915                         ),
916                         obj=obj.__class__,
917                         id="admin.E108",
918                     )
919                 ]
920         if (
921             getattr(field, "is_relation", False)
922             and (field.many_to_many or field.one_to_many)
923         ) or (getattr(field, "rel", None) and field.rel.field.many_to_one):
924             return [
925                 checks.Error(
926                     f"The value of '{label}' must not be a many-to-many field or a "
927                     f"reverse foreign key.",
928                     obj=obj.__class__,
929                     id="admin.E109",
930                 )
931             ]
932         return []
933 
934     def _check_list_display_links(self, obj):
935         """Check that list_display_links is a unique subset of list_display."""
936         from django.contrib.admin.options import ModelAdmin
937 
938         if obj.list_display_links is None:
939             return []
940         elif not isinstance(obj.list_display_links, (list, tuple)):
941             return must_be(
942                 "a list, a tuple, or None",
943                 option="list_display_links",
944                 obj=obj,
945                 id="admin.E110",
946             )
947         # Check only if ModelAdmin.get_list_display() isn't overridden.
948         elif obj.get_list_display.__func__ is ModelAdmin.get_list_display:
949             return list(
950                 chain.from_iterable(
951                     self._check_list_display_links_item(
952                         obj, field_name, "list_display_links[%d]" % index
953                     )
954                     for index, field_name in enumerate(obj.list_display_links)
955                 )
956             )
957         return []
958 
959     def _check_list_display_links_item(self, obj, field_name, label):
960         if field_name not in obj.list_display:
961             return [
962                 checks.Error(
963                     "The value of '%s' refers to '%s', which is not defined in "
964                     "'list_display'." % (label, field_name),
965                     obj=obj.__class__,
966                     id="admin.E111",
967                 )
968             ]
969         else:
970             return []
971 
972     def _check_list_filter(self, obj):
973         if not isinstance(obj.list_filter, (list, tuple)):
974             return must_be(
975                 "a list or tuple", option="list_filter", obj=obj, id="admin.E112"
976             )
977         else:
978             return list(
979                 chain.from_iterable(
980                     self._check_list_filter_item(obj, item, "list_filter[%d]" % index)
981                     for index, item in enumerate(obj.list_filter)
982                 )
983             )
984 
985     def _check_list_filter_item(self, obj, item, label):
986         """
987         Check one item of `list_filter`, i.e. check if it is one of three options:
988         1. 'field' -- a basic field filter, possibly w/ relationships (e.g.
989            'field__rel')
990         2. ('field', SomeFieldListFilter) - a field-based list filter class
991         3. SomeListFilter - a non-field list filter class
992         """
993         from django.contrib.admin import FieldListFilter, ListFilter
994 
995         if callable(item) and not isinstance(item, models.Field):
996             # If item is option 3, it should be a ListFilter...
997             if not _issubclass(item, ListFilter):
998                 return must_inherit_from(
999                     parent="ListFilter", option=label, obj=obj, id="admin.E113"
1000                 )
1001             # ...  but not a FieldListFilter.
1002             elif issubclass(item, FieldListFilter):
1003                 return [
1004                     checks.Error(
1005                         "The value of '%s' must not inherit from 'FieldListFilter'."
1006                         % label,
1007                         obj=obj.__class__,
1008                         id="admin.E114",
1009                     )
1010                 ]
1011             else:
1012                 return []
1013         elif isinstance(item, (tuple, list)):
1014             # item is option #2
1015             field, list_filter_class = item
1016             if not _issubclass(list_filter_class, FieldListFilter):
1017                 return must_inherit_from(
1018                     parent="FieldListFilter",
1019                     option="%s[1]" % label,
1020                     obj=obj,
1021                     id="admin.E115",
1022                 )
1023             else:
1024                 return []
1025         else:
1026             # item is option #1
1027             field = item
1028 
1029             # Validate the field string
1030             try:
1031                 get_fields_from_path(obj.model, field)
1032             except (NotRelationField, FieldDoesNotExist):
1033                 return [
1034                     checks.Error(
1035                         "The value of '%s' refers to '%s', which does not refer to a "
1036                         "Field." % (label, field),
1037                         obj=obj.__class__,
1038                         id="admin.E116",
1039                     )
1040                 ]
1041             else:
1042                 return []
1043 
1044     def _check_list_select_related(self, obj):
1045         """Check that list_select_related is a boolean, a list or a tuple."""
1046 
1047         if not isinstance(obj.list_select_related, (bool, list, tuple)):
1048             return must_be(
1049                 "a boolean, tuple or list",
1050                 option="list_select_related",
1051                 obj=obj,
1052                 id="admin.E117",
1053             )
1054         else:
1055             return []
1056 
1057     def _check_list_per_page(self, obj):
1058         """Check that list_per_page is an integer."""
1059 
1060         if not isinstance(obj.list_per_page, int):
1061             return must_be(
1062                 "an integer", option="list_per_page", obj=obj, id="admin.E118"
1063             )
1064         else:
1065             return []
1066 
1067     def _check_list_max_show_all(self, obj):
1068         """Check that list_max_show_all is an integer."""
1069 
1070         if not isinstance(obj.list_max_show_all, int):
1071             return must_be(
1072                 "an integer", option="list_max_show_all", obj=obj, id="admin.E119"
1073             )
1074         else:
1075             return []
1076 
1077     def _check_list_editable(self, obj):
1078         """Check that list_editable is a sequence of editable fields from
1079         list_display without first element."""
1080 
1081         if not isinstance(obj.list_editable, (list, tuple)):
1082             return must_be(
1083                 "a list or tuple", option="list_editable", obj=obj, id="admin.E120"
1084             )
1085         else:
1086             return list(
1087                 chain.from_iterable(
1088                     self._check_list_editable_item(
1089                         obj, item, "list_editable[%d]" % index
1090                     )
1091                     for index, item in enumerate(obj.list_editable)
1092                 )
1093             )
1094 
1095     def _check_list_editable_item(self, obj, field_name, label):
1096         try:
1097             field = obj.model._meta.get_field(field_name)
1098         except FieldDoesNotExist:
1099             return refer_to_missing_field(
1100                 field=field_name, option=label, obj=obj, id="admin.E121"
1101             )
1102         else:
1103             if field_name not in obj.list_display:
1104                 return [
1105                     checks.Error(
1106                         "The value of '%s' refers to '%s', which is not "
1107                         "contained in 'list_display'." % (label, field_name),
1108                         obj=obj.__class__,
1109                         id="admin.E122",
1110                     )
1111                 ]
1112             elif obj.list_display_links and field_name in obj.list_display_links:
1113                 return [
1114                     checks.Error(
1115                         "The value of '%s' cannot be in both 'list_editable' and "
1116                         "'list_display_links'." % field_name,
1117                         obj=obj.__class__,
1118                         id="admin.E123",
1119                     )
1120                 ]
1121             # If list_display[0] is in list_editable, check that
1122             # list_display_links is set. See #22792 and #26229 for use cases.
1123             elif (
1124                 obj.list_display[0] == field_name
1125                 and not obj.list_display_links
1126                 and obj.list_display_links is not None
1127             ):
1128                 return [
1129                     checks.Error(
1130                         "The value of '%s' refers to the first field in 'list_display' "
1131                         "('%s'), which cannot be used unless 'list_display_links' is "
1132                         "set." % (label, obj.list_display[0]),
1133                         obj=obj.__class__,
1134                         id="admin.E124",
1135                     )
1136                 ]
1137             elif not field.editable or field.primary_key:
1138                 return [
1139                     checks.Error(
1140                         "The value of '%s' refers to '%s', which is not editable "
1141                         "through the admin." % (label, field_name),
1142                         obj=obj.__class__,
1143                         id="admin.E125",
1144                     )
1145                 ]
1146             else:
1147                 return []
1148 
1149     def _check_search_fields(self, obj):
1150         """Check search_fields is a sequence."""
1151 
1152         if not isinstance(obj.search_fields, (list, tuple)):
1153             return must_be(
1154                 "a list or tuple", option="search_fields", obj=obj, id="admin.E126"
1155             )
1156         else:
1157             return []
1158 
1159     def _check_date_hierarchy(self, obj):
1160         """Check that date_hierarchy refers to DateField or DateTimeField."""
1161 
1162         if obj.date_hierarchy is None:
1163             return []
1164         else:
1165             try:
1166                 field = get_fields_from_path(obj.model, obj.date_hierarchy)[-1]
1167             except (NotRelationField, FieldDoesNotExist):
1168                 return [
1169                     checks.Error(
1170                         "The value of 'date_hierarchy' refers to '%s', which "
1171                         "does not refer to a Field." % obj.date_hierarchy,
1172                         obj=obj.__class__,
1173                         id="admin.E127",
1174                     )
1175                 ]
1176             else:
1177                 if not isinstance(field, (models.DateField, models.DateTimeField)):
1178                     return must_be(
1179                         "a DateField or DateTimeField",
1180                         option="date_hierarchy",
1181                         obj=obj,
1182                         id="admin.E128",
1183                     )
1184                 else:
1185                     return []
1186 
1187     def _check_action_permission_methods(self, obj):
1188         """
1189         Actions with an allowed_permission attribute require the ModelAdmin to
1190         implement a has_<perm>_permission() method for each permission.
1191         """
1192         actions = obj._get_base_actions()
1193         errors = []
1194         for func, name, _ in actions:
1195             if not hasattr(func, "allowed_permissions"):
1196                 continue
1197             for permission in func.allowed_permissions:
1198                 method_name = "has_%s_permission" % permission
1199                 if not hasattr(obj, method_name):
1200                     errors.append(
1201                         checks.Error(
1202                             "%s must define a %s() method for the %s action."
1203                             % (
1204                                 obj.__class__.__name__,
1205                                 method_name,
1206                                 func.__name__,
1207                             ),
1208                             obj=obj.__class__,
1209                             id="admin.E129",
1210                         )
1211                     )
1212         return errors
1213 
1214     def _check_actions_uniqueness(self, obj):
1215         """Check that every action has a unique __name__."""
1216         errors = []
1217         names = collections.Counter(name for _, name, _ in obj._get_base_actions())
1218         for name, count in names.items():
1219             if count > 1:
1220                 errors.append(
1221                     checks.Error(
1222                         "__name__ attributes of actions defined in %s must be "
1223                         "unique. Name %r is not unique."
1224                         % (
1225                             obj.__class__.__name__,
1226                             name,
1227                         ),
1228                         obj=obj.__class__,
1229                         id="admin.E130",
1230                     )
1231                 )
1232         return errors
1233 
1234 
1235 class InlineModelAdminChecks(BaseModelAdminChecks):
1236     def check(self, inline_obj, **kwargs):
1237         parent_model = inline_obj.parent_model
1238         return [
1239             *super().check(inline_obj),
1240             *self._check_relation(inline_obj, parent_model),
1241             *self._check_exclude_of_parent_model(inline_obj, parent_model),
1242             *self._check_extra(inline_obj),
1243             *self._check_max_num(inline_obj),
1244             *self._check_min_num(inline_obj),
1245             *self._check_formset(inline_obj),
1246         ]
1247 
1248     def _check_exclude_of_parent_model(self, obj, parent_model):
1249         # Do not perform more specific checks if the base checks result in an
1250         # error.
1251         errors = super()._check_exclude(obj)
1252         if errors:
1253             return []
1254 
1255         # Skip if `fk_name` is invalid.
1256         if self._check_relation(obj, parent_model):
1257             return []
1258 
1259         if obj.exclude is None:
1260             return []
1261 
1262         fk = _get_foreign_key(parent_model, obj.model, fk_name=obj.fk_name)
1263         if fk.name in obj.exclude:
1264             return [
1265                 checks.Error(
1266                     "Cannot exclude the field '%s', because it is the foreign key "
1267                     "to the parent model '%s'."
1268                     % (
1269                         fk.name,
1270                         parent_model._meta.label,
1271                     ),
1272                     obj=obj.__class__,
1273                     id="admin.E201",
1274                 )
1275             ]
1276         else:
1277             return []
1278 
1279     def _check_relation(self, obj, parent_model):
1280         try:
1281             _get_foreign_key(parent_model, obj.model, fk_name=obj.fk_name)
1282         except ValueError as e:
1283             return [checks.Error(e.args[0], obj=obj.__class__, id="admin.E202")]
1284         else:
1285             return []
1286 
1287     def _check_extra(self, obj):
1288         """Check that extra is an integer."""
1289 
1290         if not isinstance(obj.extra, int):
1291             return must_be("an integer", option="extra", obj=obj, id="admin.E203")
1292         else:
1293             return []
1294 
1295     def _check_max_num(self, obj):
1296         """Check that max_num is an integer."""
1297 
1298         if obj.max_num is None:
1299             return []
1300         elif not isinstance(obj.max_num, int):
1301             return must_be("an integer", option="max_num", obj=obj, id="admin.E204")
1302         else:
1303             return []
1304 
1305     def _check_min_num(self, obj):
1306         """Check that min_num is an integer."""
1307 
1308         if obj.min_num is None:
1309             return []
1310         elif not isinstance(obj.min_num, int):
1311             return must_be("an integer", option="min_num", obj=obj, id="admin.E205")
1312         else:
1313             return []
1314 
1315     def _check_formset(self, obj):
1316         """Check formset is a subclass of BaseModelFormSet."""
1317 
1318         if not _issubclass(obj.formset, BaseModelFormSet):
1319             return must_inherit_from(
1320                 parent="BaseModelFormSet", option="formset", obj=obj, id="admin.E206"
1321             )
1322         else:
1323             return []
1324 
1325 
1326 def must_be(type, option, obj, id):
1327     return [
1328         checks.Error(
1329             "The value of '%s' must be %s." % (option, type),
1330             obj=obj.__class__,
1331             id=id,
1332         ),
1333     ]
1334 
1335 
1336 def must_inherit_from(parent, option, obj, id):
1337     return [
1338         checks.Error(
1339             "The value of '%s' must inherit from '%s'." % (option, parent),
1340             obj=obj.__class__,
1341             id=id,
1342         ),
1343     ]
1344 
1345 
1346 def refer_to_missing_field(field, option, obj, id):
1347     return [
1348         checks.Error(
1349             "The value of '%s' refers to '%s', which is not a field of '%s'."
1350             % (option, field, obj.model._meta.label),
1351             obj=obj.__class__,
1352             id=id,
1353         ),
1354     ]

</code><intended_behavior>Extend or introduce checks related to ModelAdmin configuration that specifically validate the use of filter_horizontal or filter_vertical in conjunction with ManyToManyField's through option. The check should verify that when either filter_horizontal or filter_vertical is configured, the related ManyToManyField does not declare a through model. If such a case is found, the check should emit a warning or error indicating the incompatibility. This enhancement would help developers identify configuration mistakes early in the development process, ensuring the admin interface behaves as expected.</intended_behavior>]
2025-10-15 20:09:23.176 | INFO     | Search completed. Bug locations: [<file>django/contrib/admin/options.py</file>
<class>ModelAdmin</class>
<method>None</method>
<code>
630 class ModelAdmin(BaseModelAdmin):
631     """Encapsulate all admin options and functionality for a given model."""
632 
633     list_display = ("__str__",)
634     list_display_links = ()
635     list_filter = ()
636     list_select_related = False
637     list_per_page = 100
638     list_max_show_all = 200
639     list_editable = ()
640     search_fields = ()
641     search_help_text = None
642     date_hierarchy = None
643     save_as = False
644     save_as_continue = True
645     save_on_top = False
646     paginator = Paginator
647     preserve_filters = True
648     show_facets = ShowFacets.ALLOW
649     inlines = ()
650 
651     # Custom templates (designed to be over-ridden in subclasses)
652     add_form_template = None
653     change_form_template = None
654     change_list_template = None
655     delete_confirmation_template = None
656     delete_selected_confirmation_template = None
657     object_history_template = None
658     popup_response_template = None
659 
660     # Actions
661     actions = ()
662     action_form = helpers.ActionForm
663     actions_on_top = True
664     actions_on_bottom = False
665     actions_selection_counter = True
666     checks_class = ModelAdminChecks
667 
668     def __init__(self, model, admin_site):
669         self.model = model
670         self.opts = model._meta
671         self.admin_site = admin_site
672         super().__init__()
673 
674     def __str__(self):
675         return "%s.%s" % (self.opts.app_label, self.__class__.__name__)
676 
677     def __repr__(self):
678         return (
679             f"<{self.__class__.__qualname__}: model={self.model.__qualname__} "
680             f"site={self.admin_site!r}>"
681         )
682 
683     def get_inline_instances(self, request, obj=None):
684         inline_instances = []
685         for inline_class in self.get_inlines(request, obj):
686             inline = inline_class(self.model, self.admin_site)
687             if request:
688                 if not (
689                     inline.has_view_or_change_permission(request, obj)
690                     or inline.has_add_permission(request, obj)
691                     or inline.has_delete_permission(request, obj)
692                 ):
693                     continue
694                 if not inline.has_add_permission(request, obj):
695                     inline.max_num = 0
696             inline_instances.append(inline)
697 
698         return inline_instances
699 
700     def get_urls(self):
701         from django.urls import path
702 
703         def wrap(view):
704             def wrapper(*args, **kwargs):
705                 return self.admin_site.admin_view(view)(*args, **kwargs)
706 
707             wrapper.model_admin = self
708             return update_wrapper(wrapper, view)
709 
710         info = self.opts.app_label, self.opts.model_name
711 
712         return [
713             path("", wrap(self.changelist_view), name="%s_%s_changelist" % info),
714             path("add/", wrap(self.add_view), name="%s_%s_add" % info),
715             path(
716                 "<path:object_id>/history/",
717                 wrap(self.history_view),
718                 name="%s_%s_history" % info,
719             ),
720             path(
721                 "<path:object_id>/delete/",
722                 wrap(self.delete_view),
723                 name="%s_%s_delete" % info,
724             ),
725             path(
726                 "<path:object_id>/change/",
727                 wrap(self.change_view),
728                 name="%s_%s_change" % info,
729             ),
730             # For backwards compatibility (was the change url before 1.9)
731             path(
732                 "<path:object_id>/",
733                 wrap(
734                     RedirectView.as_view(
735                         pattern_name="%s:%s_%s_change"
736                         % ((self.admin_site.name,) + info)
737                     )
738                 ),
739             ),
740         ]
741 
742     @property
743     def urls(self):
744         return self.get_urls()
745 
746     @property
747     def media(self):
748         extra = "" if settings.DEBUG else ".min"
749         js = [
750             "vendor/jquery/jquery%s.js" % extra,
751             "jquery.init.js",
752             "core.js",
753             "admin/RelatedObjectLookups.js",
754             "actions.js",
755             "urlify.js",
756             "prepopulate.js",
757             "vendor/xregexp/xregexp%s.js" % extra,
758         ]
759         return forms.Media(js=["admin/js/%s" % url for url in js])
760 
761     def get_model_perms(self, request):
762         """
763         Return a dict of all perms for this model. This dict has the keys
764         ``add``, ``change``, ``delete``, and ``view`` mapping to the True/False
765         for each of those actions.
766         """
767         return {
768             "add": self.has_add_permission(request),
769             "change": self.has_change_permission(request),
770             "delete": self.has_delete_permission(request),
771             "view": self.has_view_permission(request),
772         }
773 
774     def _get_form_for_get_fields(self, request, obj):
775         return self.get_form(request, obj, fields=None)
776 
777     def get_form(self, request, obj=None, change=False, **kwargs):
778         """
779         Return a Form class for use in the admin add view. This is used by
780         add_view and change_view.
781         """
782         if "fields" in kwargs:
783             fields = kwargs.pop("fields")
784         else:
785             fields = flatten_fieldsets(self.get_fieldsets(request, obj))
786         excluded = self.get_exclude(request, obj)
787         exclude = [] if excluded is None else list(excluded)
788         readonly_fields = self.get_readonly_fields(request, obj)
789         exclude.extend(readonly_fields)
790         # Exclude all fields if it's a change form and the user doesn't have
791         # the change permission.
792         if (
793             change
794             and hasattr(request, "user")
795             and not self.has_change_permission(request, obj)
796         ):
797             exclude.extend(fields)
798         if excluded is None and hasattr(self.form, "_meta") and self.form._meta.exclude:
799             # Take the custom ModelForm's Meta.exclude into account only if the
800             # ModelAdmin doesn't define its own.
801             exclude.extend(self.form._meta.exclude)
802         # if exclude is an empty list we pass None to be consistent with the
803         # default on modelform_factory
804         exclude = exclude or None
805 
806         # Remove declared form fields which are in readonly_fields.
807         new_attrs = dict.fromkeys(
808             f for f in readonly_fields if f in self.form.declared_fields
809         )
810         form = type(self.form.__name__, (self.form,), new_attrs)
811 
812         defaults = {
813             "form": form,
814             "fields": fields,
815             "exclude": exclude,
816             "formfield_callback": partial(self.formfield_for_dbfield, request=request),
817             **kwargs,
818         }
819 
820         if defaults["fields"] is None and not modelform_defines_fields(
821             defaults["form"]
822         ):
823             defaults["fields"] = forms.ALL_FIELDS
824 
825         try:
826             return modelform_factory(self.model, **defaults)
827         except FieldError as e:
828             raise FieldError(
829                 "%s. Check fields/fieldsets/exclude attributes of class %s."
830                 % (e, self.__class__.__name__)
831             )
832 
833     def get_changelist(self, request, **kwargs):
834         """
835         Return the ChangeList class for use on the changelist page.
836         """
837         from django.contrib.admin.views.main import ChangeList
838 
839         return ChangeList
840 
841     def get_changelist_instance(self, request):
842         """
843         Return a `ChangeList` instance based on `request`. May raise
844         `IncorrectLookupParameters`.
845         """
846         list_display = self.get_list_display(request)
847         list_display_links = self.get_list_display_links(request, list_display)
848         # Add the action checkboxes if any actions are available.
849         if self.get_actions(request):
850             list_display = ["action_checkbox", *list_display]
851         sortable_by = self.get_sortable_by(request)
852         ChangeList = self.get_changelist(request)
853         return ChangeList(
854             request,
855             self.model,
856             list_display,
857             list_display_links,
858             self.get_list_filter(request),
859             self.date_hierarchy,
860             self.get_search_fields(request),
861             self.get_list_select_related(request),
862             self.list_per_page,
863             self.list_max_show_all,
864             self.list_editable,
865             self,
866             sortable_by,
867             self.search_help_text,
868         )
869 
870     def get_object(self, request, object_id, from_field=None):
871         """
872         Return an instance matching the field and value provided, the primary
873         key is used if no field is provided. Return ``None`` if no match is
874         found or the object_id fails validation.
875         """
876         queryset = self.get_queryset(request)
877         model = queryset.model
878         field = (
879             model._meta.pk if from_field is None else model._meta.get_field(from_field)
880         )
881         try:
882             object_id = field.to_python(object_id)
883             return queryset.get(**{field.name: object_id})
884         except (model.DoesNotExist, ValidationError, ValueError):
885             return None
886 
887     def get_changelist_form(self, request, **kwargs):
888         """
889         Return a Form class for use in the Formset on the changelist page.
890         """
891         defaults = {
892             "formfield_callback": partial(self.formfield_for_dbfield, request=request),
893             **kwargs,
894         }
895         if defaults.get("fields") is None and not modelform_defines_fields(
896             defaults.get("form")
897         ):
898             defaults["fields"] = forms.ALL_FIELDS
899 
900         return modelform_factory(self.model, **defaults)
901 
902     def get_changelist_formset(self, request, **kwargs):
903         """
904         Return a FormSet class for use on the changelist page if list_editable
905         is used.
906         """
907         defaults = {
908             "formfield_callback": partial(self.formfield_for_dbfield, request=request),
909             **kwargs,
910         }
911         return modelformset_factory(
912             self.model,
913             self.get_changelist_form(request),
914             extra=0,
915             fields=self.list_editable,
916             **defaults,
917         )
918 
919     def get_formsets_with_inlines(self, request, obj=None):
920         """
921         Yield formsets and the corresponding inlines.
922         """
923         for inline in self.get_inline_instances(request, obj):
924             yield inline.get_formset(request, obj), inline
925 
926     def get_paginator(
927         self, request, queryset, per_page, orphans=0, allow_empty_first_page=True
928     ):
929         return self.paginator(queryset, per_page, orphans, allow_empty_first_page)
930 
931     def log_addition(self, request, obj, message):
932         """
933         Log that an object has been successfully added.
934 
935         The default implementation creates an admin LogEntry object.
936         """
937         from django.contrib.admin.models import ADDITION, LogEntry
938 
939         return LogEntry.objects.log_action(
940             user_id=request.user.pk,
941             content_type_id=get_content_type_for_model(obj).pk,
942             object_id=obj.pk,
943             object_repr=str(obj),
944             action_flag=ADDITION,
945             change_message=message,
946         )
947 
948     def log_change(self, request, obj, message):
949         """
950         Log that an object has been successfully changed.
951 
952         The default implementation creates an admin LogEntry object.
953         """
954         from django.contrib.admin.models import CHANGE, LogEntry
955 
956         return LogEntry.objects.log_action(
957             user_id=request.user.pk,
958             content_type_id=get_content_type_for_model(obj).pk,
959             object_id=obj.pk,
960             object_repr=str(obj),
961             action_flag=CHANGE,
962             change_message=message,
963         )
964 
965     def log_deletion(self, request, obj, object_repr):
966         """
967         Log that an object will be deleted. Note that this method must be
968         called before the deletion.
969 
970         The default implementation creates an admin LogEntry object.
971         """
972         from django.contrib.admin.models import DELETION, LogEntry
973 
974         return LogEntry.objects.log_action(
975             user_id=request.user.pk,
976             content_type_id=get_content_type_for_model(obj).pk,
977             object_id=obj.pk,
978             object_repr=object_repr,
979             action_flag=DELETION,
980         )
981 
982     def action_checkbox(self, obj):
983         """
984         A list_display column containing a checkbox widget.
985         """
986         attrs = {
987             "class": "action-select",
988             "aria-label": format_html(_("Select this object for an action - {}"), obj),
989         }
990         checkbox = forms.CheckboxInput(attrs, lambda value: False)
991         return checkbox.render(helpers.ACTION_CHECKBOX_NAME, str(obj.pk))
992 
993     @staticmethod
994     def _get_action_description(func, name):
995         return getattr(func, "short_description", capfirst(name.replace("_", " ")))
996 
997     def _get_base_actions(self):
998         """Return the list of actions, prior to any request-based filtering."""
999         actions = []
1000         base_actions = (self.get_action(action) for action in self.actions or [])
1001         # get_action might have returned None, so filter any of those out.
1002         base_actions = [action for action in base_actions if action]
1003         base_action_names = {name for _, name, _ in base_actions}
1004 
1005         # Gather actions from the admin site first
1006         for name, func in self.admin_site.actions:
1007             if name in base_action_names:
1008                 continue
1009             description = self._get_action_description(func, name)
1010             actions.append((func, name, description))
1011         # Add actions from this ModelAdmin.
1012         actions.extend(base_actions)
1013         return actions
1014 
1015     def _filter_actions_by_permissions(self, request, actions):
1016         """Filter out any actions that the user doesn't have access to."""
1017         filtered_actions = []
1018         for action in actions:
1019             callable = action[0]
1020             if not hasattr(callable, "allowed_permissions"):
1021                 filtered_actions.append(action)
1022                 continue
1023             permission_checks = (
1024                 getattr(self, "has_%s_permission" % permission)
1025                 for permission in callable.allowed_permissions
1026             )
1027             if any(has_permission(request) for has_permission in permission_checks):
1028                 filtered_actions.append(action)
1029         return filtered_actions
1030 
1031     def get_actions(self, request):
1032         """
1033         Return a dictionary mapping the names of all actions for this
1034         ModelAdmin to a tuple of (callable, name, description) for each action.
1035         """
1036         # If self.actions is set to None that means actions are disabled on
1037         # this page.
1038         if self.actions is None or IS_POPUP_VAR in request.GET:
1039             return {}
1040         actions = self._filter_actions_by_permissions(request, self._get_base_actions())
1041         return {name: (func, name, desc) for func, name, desc in actions}
1042 
1043     def get_action_choices(self, request, default_choices=models.BLANK_CHOICE_DASH):
1044         """
1045         Return a list of choices for use in a form object.  Each choice is a
1046         tuple (name, description).
1047         """
1048         choices = [] + default_choices
1049         for func, name, description in self.get_actions(request).values():
1050             choice = (name, description % model_format_dict(self.opts))
1051             choices.append(choice)
1052         return choices
1053 
1054     def get_action(self, action):
1055         """
1056         Return a given action from a parameter, which can either be a callable,
1057         or the name of a method on the ModelAdmin.  Return is a tuple of
1058         (callable, name, description).
1059         """
1060         # If the action is a callable, just use it.
1061         if callable(action):
1062             func = action
1063             action = action.__name__
1064 
1065         # Next, look for a method. Grab it off self.__class__ to get an unbound
1066         # method instead of a bound one; this ensures that the calling
1067         # conventions are the same for functions and methods.
1068         elif hasattr(self.__class__, action):
1069             func = getattr(self.__class__, action)
1070 
1071         # Finally, look for a named method on the admin site
1072         else:
1073             try:
1074                 func = self.admin_site.get_action(action)
1075             except KeyError:
1076                 return None
1077 
1078         description = self._get_action_description(func, action)
1079         return func, action, description
1080 
1081     def get_list_display(self, request):
1082         """
1083         Return a sequence containing the fields to be displayed on the
1084         changelist.
1085         """
1086         return self.list_display
1087 
1088     def get_list_display_links(self, request, list_display):
1089         """
1090         Return a sequence containing the fields to be displayed as links
1091         on the changelist. The list_display parameter is the list of fields
1092         returned by get_list_display().
1093         """
1094         if (
1095             self.list_display_links
1096             or self.list_display_links is None
1097             or not list_display
1098         ):
1099             return self.list_display_links
1100         else:
1101             # Use only the first item in list_display as link
1102             return list(list_display)[:1]
1103 
1104     def get_list_filter(self, request):
1105         """
1106         Return a sequence containing the fields to be displayed as filters in
1107         the right sidebar of the changelist page.
1108         """
1109         return self.list_filter
1110 
1111     def get_list_select_related(self, request):
1112         """
1113         Return a list of fields to add to the select_related() part of the
1114         changelist items query.
1115         """
1116         return self.list_select_related
1117 
1118     def get_search_fields(self, request):
1119         """
1120         Return a sequence containing the fields to be searched whenever
1121         somebody submits a search query.
1122         """
1123         return self.search_fields
1124 
1125     def get_search_results(self, request, queryset, search_term):
1126         """
1127         Return a tuple containing a queryset to implement the search
1128         and a boolean indicating if the results may contain duplicates.
1129         """
1130 
1131         # Apply keyword searches.
1132         def construct_search(field_name):
1133             if field_name.startswith("^"):
1134                 return "%s__istartswith" % field_name.removeprefix("^")
1135             elif field_name.startswith("="):
1136                 return "%s__iexact" % field_name.removeprefix("=")
1137             elif field_name.startswith("@"):
1138                 return "%s__search" % field_name.removeprefix("@")
1139             # Use field_name if it includes a lookup.
1140             opts = queryset.model._meta
1141             lookup_fields = field_name.split(LOOKUP_SEP)
1142             # Go through the fields, following all relations.
1143             prev_field = None
1144             for path_part in lookup_fields:
1145                 if path_part == "pk":
1146                     path_part = opts.pk.name
1147                 try:
1148                     field = opts.get_field(path_part)
1149                 except FieldDoesNotExist:
1150                     # Use valid query lookups.
1151                     if prev_field and prev_field.get_lookup(path_part):
1152                         return field_name
1153                 else:
1154                     prev_field = field
1155                     if hasattr(field, "path_infos"):
1156                         # Update opts to follow the relation.
1157                         opts = field.path_infos[-1].to_opts
1158             # Otherwise, use the field with icontains.
1159             return "%s__icontains" % field_name
1160 
1161         may_have_duplicates = False
1162         search_fields = self.get_search_fields(request)
1163         if search_fields and search_term:
1164             orm_lookups = [
1165                 construct_search(str(search_field)) for search_field in search_fields
1166             ]
1167             term_queries = []
1168             for bit in smart_split(search_term):
1169                 if bit.startswith(('"', "'")) and bit[0] == bit[-1]:
1170                     bit = unescape_string_literal(bit)
1171                 or_queries = models.Q.create(
1172                     [(orm_lookup, bit) for orm_lookup in orm_lookups],
1173                     connector=models.Q.OR,
1174                 )
1175                 term_queries.append(or_queries)
1176             queryset = queryset.filter(models.Q.create(term_queries))
1177             may_have_duplicates |= any(
1178                 lookup_spawns_duplicates(self.opts, search_spec)
1179                 for search_spec in orm_lookups
1180             )
1181         return queryset, may_have_duplicates
1182 
1183     def get_preserved_filters(self, request):
1184         """
1185         Return the preserved filters querystring.
1186         """
1187         match = request.resolver_match
1188         if self.preserve_filters and match:
1189             current_url = "%s:%s" % (match.app_name, match.url_name)
1190             changelist_url = "admin:%s_%s_changelist" % (
1191                 self.opts.app_label,
1192                 self.opts.model_name,
1193             )
1194             if current_url == changelist_url:
1195                 preserved_filters = request.GET.urlencode()
1196             else:
1197                 preserved_filters = request.GET.get("_changelist_filters")
1198 
1199             if preserved_filters:
1200                 return urlencode({"_changelist_filters": preserved_filters})
1201         return ""
1202 
1203     def construct_change_message(self, request, form, formsets, add=False):
1204         """
1205         Construct a JSON structure describing changes from a changed object.
1206         """
1207         return construct_change_message(form, formsets, add)
1208 
1209     def message_user(
1210         self, request, message, level=messages.INFO, extra_tags="", fail_silently=False
1211     ):
1212         """
1213         Send a message to the user. The default implementation
1214         posts a message using the django.contrib.messages backend.
1215 
1216         Exposes almost the same API as messages.add_message(), but accepts the
1217         positional arguments in a different order to maintain backwards
1218         compatibility. For convenience, it accepts the `level` argument as
1219         a string rather than the usual level number.
1220         """
1221         if not isinstance(level, int):
1222             # attempt to get the level if passed a string
1223             try:
1224                 level = getattr(messages.constants, level.upper())
1225             except AttributeError:
1226                 levels = messages.constants.DEFAULT_TAGS.values()
1227                 levels_repr = ", ".join("`%s`" % level for level in levels)
1228                 raise ValueError(
1229                     "Bad message level string: `%s`. Possible values are: %s"
1230                     % (level, levels_repr)
1231                 )
1232 
1233         messages.add_message(
1234             request, level, message, extra_tags=extra_tags, fail_silently=fail_silently
1235         )
1236 
1237     def save_form(self, request, form, change):
1238         """
1239         Given a ModelForm return an unsaved instance. ``change`` is True if
1240         the object is being changed, and False if it's being added.
1241         """
1242         return form.save(commit=False)
1243 
1244     def save_model(self, request, obj, form, change):
1245         """
1246         Given a model instance save it to the database.
1247         """
1248         obj.save()
1249 
1250     def delete_model(self, request, obj):
1251         """
1252         Given a model instance delete it from the database.
1253         """
1254         obj.delete()
1255 
1256     def delete_queryset(self, request, queryset):
1257         """Given a queryset, delete it from the database."""
1258         queryset.delete()
1259 
1260     def save_formset(self, request, form, formset, change):
1261         """
1262         Given an inline formset save it to the database.
1263         """
1264         formset.save()
1265 
1266     def save_related(self, request, form, formsets, change):
1267         """
1268         Given the ``HttpRequest``, the parent ``ModelForm`` instance, the
1269         list of inline formsets and a boolean value based on whether the
1270         parent is being added or changed, save the related objects to the
1271         database. Note that at this point save_form() and save_model() have
1272         already been called.
1273         """
1274         form.save_m2m()
1275         for formset in formsets:
1276             self.save_formset(request, form, formset, change=change)
1277 
1278     def render_change_form(
1279         self, request, context, add=False, change=False, form_url="", obj=None
1280     ):
1281         app_label = self.opts.app_label
1282         preserved_filters = self.get_preserved_filters(request)
1283         form_url = add_preserved_filters(
1284             {"preserved_filters": preserved_filters, "opts": self.opts}, form_url
1285         )
1286         view_on_site_url = self.get_view_on_site_url(obj)
1287         has_editable_inline_admin_formsets = False
1288         for inline in context["inline_admin_formsets"]:
1289             if (
1290                 inline.has_add_permission
1291                 or inline.has_change_permission
1292                 or inline.has_delete_permission
1293             ):
1294                 has_editable_inline_admin_formsets = True
1295                 break
1296         context.update(
1297             {
1298                 "add": add,
1299                 "change": change,
1300                 "has_view_permission": self.has_view_permission(request, obj),
1301                 "has_add_permission": self.has_add_permission(request),
1302                 "has_change_permission": self.has_change_permission(request, obj),
1303                 "has_delete_permission": self.has_delete_permission(request, obj),
1304                 "has_editable_inline_admin_formsets": (
1305                     has_editable_inline_admin_formsets
1306                 ),
1307                 "has_file_field": context["adminform"].form.is_multipart()
1308                 or any(
1309                     admin_formset.formset.is_multipart()
1310                     for admin_formset in context["inline_admin_formsets"]
1311                 ),
1312                 "has_absolute_url": view_on_site_url is not None,
1313                 "absolute_url": view_on_site_url,
1314                 "form_url": form_url,
1315                 "opts": self.opts,
1316                 "content_type_id": get_content_type_for_model(self.model).pk,
1317                 "save_as": self.save_as,
1318                 "save_on_top": self.save_on_top,
1319                 "to_field_var": TO_FIELD_VAR,
1320                 "is_popup_var": IS_POPUP_VAR,
1321                 "app_label": app_label,
1322             }
1323         )
1324         if add and self.add_form_template is not None:
1325             form_template = self.add_form_template
1326         else:
1327             form_template = self.change_form_template
1328 
1329         request.current_app = self.admin_site.name
1330 
1331         return TemplateResponse(
1332             request,
1333             form_template
1334             or [
1335                 "admin/%s/%s/change_form.html" % (app_label, self.opts.model_name),
1336                 "admin/%s/change_form.html" % app_label,
1337                 "admin/change_form.html",
1338             ],
1339             context,
1340         )
1341 
1342     def response_add(self, request, obj, post_url_continue=None):
1343         """
1344         Determine the HttpResponse for the add_view stage.
1345         """
1346         opts = obj._meta
1347         preserved_filters = self.get_preserved_filters(request)
1348         obj_url = reverse(
1349             "admin:%s_%s_change" % (opts.app_label, opts.model_name),
1350             args=(quote(obj.pk),),
1351             current_app=self.admin_site.name,
1352         )
1353         # Add a link to the object's change form if the user can edit the obj.
1354         if self.has_change_permission(request, obj):
1355             obj_repr = format_html('<a href="{}">{}</a>', urlquote(obj_url), obj)
1356         else:
1357             obj_repr = str(obj)
1358         msg_dict = {
1359             "name": opts.verbose_name,
1360             "obj": obj_repr,
1361         }
1362         # Here, we distinguish between different save types by checking for
1363         # the presence of keys in request.POST.
1364 
1365         if IS_POPUP_VAR in request.POST:
1366             to_field = request.POST.get(TO_FIELD_VAR)
1367             if to_field:
1368                 attr = str(to_field)
1369             else:
1370                 attr = obj._meta.pk.attname
1371             value = obj.serializable_value(attr)
1372             popup_response_data = json.dumps(
1373                 {
1374                     "value": str(value),
1375                     "obj": str(obj),
1376                 }
1377             )
1378             return TemplateResponse(
1379                 request,
1380                 self.popup_response_template
1381                 or [
1382                     "admin/%s/%s/popup_response.html"
1383                     % (opts.app_label, opts.model_name),
1384                     "admin/%s/popup_response.html" % opts.app_label,
1385                     "admin/popup_response.html",
1386                 ],
1387                 {
1388                     "popup_response_data": popup_response_data,
1389                 },
1390             )
1391 
1392         elif "_continue" in request.POST or (
1393             # Redirecting after "Save as new".
1394             "_saveasnew" in request.POST
1395             and self.save_as_continue
1396             and self.has_change_permission(request, obj)
1397         ):
1398             msg = _("The {name} “{obj}” was added successfully.")
1399             if self.has_change_permission(request, obj):
1400                 msg += " " + _("You may edit it again below.")
1401             self.message_user(request, format_html(msg, **msg_dict), messages.SUCCESS)
1402             if post_url_continue is None:
1403                 post_url_continue = obj_url
1404             post_url_continue = add_preserved_filters(
1405                 {"preserved_filters": preserved_filters, "opts": opts},
1406                 post_url_continue,
1407             )
1408             return HttpResponseRedirect(post_url_continue)
1409 
1410         elif "_addanother" in request.POST:
1411             msg = format_html(
1412                 _(
1413                     "The {name} “{obj}” was added successfully. You may add another "
1414                     "{name} below."
1415                 ),
1416                 **msg_dict,
1417             )
1418             self.message_user(request, msg, messages.SUCCESS)
1419             redirect_url = request.path
1420             redirect_url = add_preserved_filters(
1421                 {"preserved_filters": preserved_filters, "opts": opts}, redirect_url
1422             )
1423             return HttpResponseRedirect(redirect_url)
1424 
1425         else:
1426             msg = format_html(
1427                 _("The {name} “{obj}” was added successfully."), **msg_dict
1428             )
1429             self.message_user(request, msg, messages.SUCCESS)
1430             return self.response_post_save_add(request, obj)
1431 
1432     def response_change(self, request, obj):
1433         """
1434         Determine the HttpResponse for the change_view stage.
1435         """
1436 
1437         if IS_POPUP_VAR in request.POST:
1438             opts = obj._meta
1439             to_field = request.POST.get(TO_FIELD_VAR)
1440             attr = str(to_field) if to_field else opts.pk.attname
1441             value = request.resolver_match.kwargs["object_id"]
1442             new_value = obj.serializable_value(attr)
1443             popup_response_data = json.dumps(
1444                 {
1445                     "action": "change",
1446                     "value": str(value),
1447                     "obj": str(obj),
1448                     "new_value": str(new_value),
1449                 }
1450             )
1451             return TemplateResponse(
1452                 request,
1453                 self.popup_response_template
1454                 or [
1455                     "admin/%s/%s/popup_response.html"
1456                     % (opts.app_label, opts.model_name),
1457                     "admin/%s/popup_response.html" % opts.app_label,
1458                     "admin/popup_response.html",
1459                 ],
1460                 {
1461                     "popup_response_data": popup_response_data,
1462                 },
1463             )
1464 
1465         opts = self.opts
1466         preserved_filters = self.get_preserved_filters(request)
1467 
1468         msg_dict = {
1469             "name": opts.verbose_name,
1470             "obj": format_html('<a href="{}">{}</a>', urlquote(request.path), obj),
1471         }
1472         if "_continue" in request.POST:
1473             msg = format_html(
1474                 _(
1475                     "The {name} “{obj}” was changed successfully. You may edit it "
1476                     "again below."
1477                 ),
1478                 **msg_dict,
1479             )
1480             self.message_user(request, msg, messages.SUCCESS)
1481             redirect_url = request.path
1482             redirect_url = add_preserved_filters(
1483                 {"preserved_filters": preserved_filters, "opts": opts}, redirect_url
1484             )
1485             return HttpResponseRedirect(redirect_url)
1486 
1487         elif "_saveasnew" in request.POST:
1488             msg = format_html(
1489                 _(
1490                     "The {name} “{obj}” was added successfully. You may edit it again "
1491                     "below."
1492                 ),
1493                 **msg_dict,
1494             )
1495             self.message_user(request, msg, messages.SUCCESS)
1496             redirect_url = reverse(
1497                 "admin:%s_%s_change" % (opts.app_label, opts.model_name),
1498                 args=(obj.pk,),
1499                 current_app=self.admin_site.name,
1500             )
1501             redirect_url = add_preserved_filters(
1502                 {"preserved_filters": preserved_filters, "opts": opts}, redirect_url
1503             )
1504             return HttpResponseRedirect(redirect_url)
1505 
1506         elif "_addanother" in request.POST:
1507             msg = format_html(
1508                 _(
1509                     "The {name} “{obj}” was changed successfully. You may add another "
1510                     "{name} below."
1511                 ),
1512                 **msg_dict,
1513             )
1514             self.message_user(request, msg, messages.SUCCESS)
1515             redirect_url = reverse(
1516                 "admin:%s_%s_add" % (opts.app_label, opts.model_name),
1517                 current_app=self.admin_site.name,
1518             )
1519             redirect_url = add_preserved_filters(
1520                 {"preserved_filters": preserved_filters, "opts": opts}, redirect_url
1521             )
1522             return HttpResponseRedirect(redirect_url)
1523 
1524         else:
1525             msg = format_html(
1526                 _("The {name} “{obj}” was changed successfully."), **msg_dict
1527             )
1528             self.message_user(request, msg, messages.SUCCESS)
1529             return self.response_post_save_change(request, obj)
1530 
1531     def _response_post_save(self, request, obj):
1532         if self.has_view_or_change_permission(request):
1533             post_url = reverse(
1534                 "admin:%s_%s_changelist" % (self.opts.app_label, self.opts.model_name),
1535                 current_app=self.admin_site.name,
1536             )
1537             preserved_filters = self.get_preserved_filters(request)
1538             post_url = add_preserved_filters(
1539                 {"preserved_filters": preserved_filters, "opts": self.opts}, post_url
1540             )
1541         else:
1542             post_url = reverse("admin:index", current_app=self.admin_site.name)
1543         return HttpResponseRedirect(post_url)
1544 
1545     def response_post_save_add(self, request, obj):
1546         """
1547         Figure out where to redirect after the 'Save' button has been pressed
1548         when adding a new object.
1549         """
1550         return self._response_post_save(request, obj)
1551 
1552     def response_post_save_change(self, request, obj):
1553         """
1554         Figure out where to redirect after the 'Save' button has been pressed
1555         when editing an existing object.
1556         """
1557         return self._response_post_save(request, obj)
1558 
1559     def response_action(self, request, queryset):
1560         """
1561         Handle an admin action. This is called if a request is POSTed to the
1562         changelist; it returns an HttpResponse if the action was handled, and
1563         None otherwise.
1564         """
1565 
1566         # There can be multiple action forms on the page (at the top
1567         # and bottom of the change list, for example). Get the action
1568         # whose button was pushed.
1569         try:
1570             action_index = int(request.POST.get("index", 0))
1571         except ValueError:
1572             action_index = 0
1573 
1574         # Construct the action form.
1575         data = request.POST.copy()
1576         data.pop(helpers.ACTION_CHECKBOX_NAME, None)
1577         data.pop("index", None)
1578 
1579         # Use the action whose button was pushed
1580         try:
1581             data.update({"action": data.getlist("action")[action_index]})
1582         except IndexError:
1583             # If we didn't get an action from the chosen form that's invalid
1584             # POST data, so by deleting action it'll fail the validation check
1585             # below. So no need to do anything here
1586             pass
1587 
1588         action_form = self.action_form(data, auto_id=None)
1589         action_form.fields["action"].choices = self.get_action_choices(request)
1590 
1591         # If the form's valid we can handle the action.
1592         if action_form.is_valid():
1593             action = action_form.cleaned_data["action"]
1594             select_across = action_form.cleaned_data["select_across"]
1595             func = self.get_actions(request)[action][0]
1596 
1597             # Get the list of selected PKs. If nothing's selected, we can't
1598             # perform an action on it, so bail. Except we want to perform
1599             # the action explicitly on all objects.
1600             selected = request.POST.getlist(helpers.ACTION_CHECKBOX_NAME)
1601             if not selected and not select_across:
1602                 # Reminder that something needs to be selected or nothing will happen
1603                 msg = _(
1604                     "Items must be selected in order to perform "
1605                     "actions on them. No items have been changed."
1606                 )
1607                 self.message_user(request, msg, messages.WARNING)
1608                 return None
1609 
1610             if not select_across:
1611                 # Perform the action only on the selected objects
1612                 queryset = queryset.filter(pk__in=selected)
1613 
1614             response = func(self, request, queryset)
1615 
1616             # Actions may return an HttpResponse-like object, which will be
1617             # used as the response from the POST. If not, we'll be a good
1618             # little HTTP citizen and redirect back to the changelist page.
1619             if isinstance(response, HttpResponseBase):
1620                 return response
1621             else:
1622                 return HttpResponseRedirect(request.get_full_path())
1623         else:
1624             msg = _("No action selected.")
1625             self.message_user(request, msg, messages.WARNING)
1626             return None
1627 
1628     def response_delete(self, request, obj_display, obj_id):
1629         """
1630         Determine the HttpResponse for the delete_view stage.
1631         """
1632         if IS_POPUP_VAR in request.POST:
1633             popup_response_data = json.dumps(
1634                 {
1635                     "action": "delete",
1636                     "value": str(obj_id),
1637                 }
1638             )
1639             return TemplateResponse(
1640                 request,
1641                 self.popup_response_template
1642                 or [
1643                     "admin/%s/%s/popup_response.html"
1644                     % (self.opts.app_label, self.opts.model_name),
1645                     "admin/%s/popup_response.html" % self.opts.app_label,
1646                     "admin/popup_response.html",
1647                 ],
1648                 {
1649                     "popup_response_data": popup_response_data,
1650                 },
1651             )
1652 
1653         self.message_user(
1654             request,
1655             _("The %(name)s “%(obj)s” was deleted successfully.")
1656             % {
1657                 "name": self.opts.verbose_name,
1658                 "obj": obj_display,
1659             },
1660             messages.SUCCESS,
1661         )
1662 
1663         if self.has_change_permission(request, None):
1664             post_url = reverse(
1665                 "admin:%s_%s_changelist" % (self.opts.app_label, self.opts.model_name),
1666                 current_app=self.admin_site.name,
1667             )
1668             preserved_filters = self.get_preserved_filters(request)
1669             post_url = add_preserved_filters(
1670                 {"preserved_filters": preserved_filters, "opts": self.opts}, post_url
1671             )
1672         else:
1673             post_url = reverse("admin:index", current_app=self.admin_site.name)
1674         return HttpResponseRedirect(post_url)
1675 
1676     def render_delete_form(self, request, context):
1677         app_label = self.opts.app_label
1678 
1679         request.current_app = self.admin_site.name
1680         context.update(
1681             to_field_var=TO_FIELD_VAR,
1682             is_popup_var=IS_POPUP_VAR,
1683             media=self.media,
1684         )
1685 
1686         return TemplateResponse(
1687             request,
1688             self.delete_confirmation_template
1689             or [
1690                 "admin/{}/{}/delete_confirmation.html".format(
1691                     app_label, self.opts.model_name
1692                 ),
1693                 "admin/{}/delete_confirmation.html".format(app_label),
1694                 "admin/delete_confirmation.html",
1695             ],
1696             context,
1697         )
1698 
1699     def get_inline_formsets(self, request, formsets, inline_instances, obj=None):
1700         # Edit permissions on parent model are required for editable inlines.
1701         can_edit_parent = (
1702             self.has_change_permission(request, obj)
1703             if obj
1704             else self.has_add_permission(request)
1705         )
1706         inline_admin_formsets = []
1707         for inline, formset in zip(inline_instances, formsets):
1708             fieldsets = list(inline.get_fieldsets(request, obj))
1709             readonly = list(inline.get_readonly_fields(request, obj))
1710             if can_edit_parent:
1711                 has_add_permission = inline.has_add_permission(request, obj)
1712                 has_change_permission = inline.has_change_permission(request, obj)
1713                 has_delete_permission = inline.has_delete_permission(request, obj)
1714             else:
1715                 # Disable all edit-permissions, and override formset settings.
1716                 has_add_permission = (
1717                     has_change_permission
1718                 ) = has_delete_permission = False
1719                 formset.extra = formset.max_num = 0
1720             has_view_permission = inline.has_view_permission(request, obj)
1721             prepopulated = dict(inline.get_prepopulated_fields(request, obj))
1722             inline_admin_formset = helpers.InlineAdminFormSet(
1723                 inline,
1724                 formset,
1725                 fieldsets,
1726                 prepopulated,
1727                 readonly,
1728                 model_admin=self,
1729                 has_add_permission=has_add_permission,
1730                 has_change_permission=has_change_permission,
1731                 has_delete_permission=has_delete_permission,
1732                 has_view_permission=has_view_permission,
1733             )
1734             inline_admin_formsets.append(inline_admin_formset)
1735         return inline_admin_formsets
1736 
1737     def get_changeform_initial_data(self, request):
1738         """
1739         Get the initial form data from the request's GET params.
1740         """
1741         initial = dict(request.GET.items())
1742         for k in initial:
1743             try:
1744                 f = self.opts.get_field(k)
1745             except FieldDoesNotExist:
1746                 continue
1747             # We have to special-case M2Ms as a list of comma-separated PKs.
1748             if isinstance(f, models.ManyToManyField):
1749                 initial[k] = initial[k].split(",")
1750         return initial
1751 
1752     def _get_obj_does_not_exist_redirect(self, request, opts, object_id):
1753         """
1754         Create a message informing the user that the object doesn't exist
1755         and return a redirect to the admin index page.
1756         """
1757         msg = _("%(name)s with ID “%(key)s” doesn’t exist. Perhaps it was deleted?") % {
1758             "name": opts.verbose_name,
1759             "key": unquote(object_id),
1760         }
1761         self.message_user(request, msg, messages.WARNING)
1762         url = reverse("admin:index", current_app=self.admin_site.name)
1763         return HttpResponseRedirect(url)
1764 
1765     @csrf_protect_m
1766     def changeform_view(self, request, object_id=None, form_url="", extra_context=None):
1767         with transaction.atomic(using=router.db_for_write(self.model)):
1768             return self._changeform_view(request, object_id, form_url, extra_context)
1769 
1770     def _changeform_view(self, request, object_id, form_url, extra_context):
1771         to_field = request.POST.get(TO_FIELD_VAR, request.GET.get(TO_FIELD_VAR))
1772         if to_field and not self.to_field_allowed(request, to_field):
1773             raise DisallowedModelAdminToField(
1774                 "The field %s cannot be referenced." % to_field
1775             )
1776 
1777         if request.method == "POST" and "_saveasnew" in request.POST:
1778             object_id = None
1779 
1780         add = object_id is None
1781 
1782         if add:
1783             if not self.has_add_permission(request):
1784                 raise PermissionDenied
1785             obj = None
1786 
1787         else:
1788             obj = self.get_object(request, unquote(object_id), to_field)
1789 
1790             if request.method == "POST":
1791                 if not self.has_change_permission(request, obj):
1792                     raise PermissionDenied
1793             else:
1794                 if not self.has_view_or_change_permission(request, obj):
1795                     raise PermissionDenied
1796 
1797             if obj is None:
1798                 return self._get_obj_does_not_exist_redirect(
1799                     request, self.opts, object_id
1800                 )
1801 
1802         fieldsets = self.get_fieldsets(request, obj)
1803         ModelForm = self.get_form(
1804             request, obj, change=not add, fields=flatten_fieldsets(fieldsets)
1805         )
1806         if request.method == "POST":
1807             form = ModelForm(request.POST, request.FILES, instance=obj)
1808             formsets, inline_instances = self._create_formsets(
1809                 request,
1810                 form.instance,
1811                 change=not add,
1812             )
1813             form_validated = form.is_valid()
1814             if form_validated:
1815                 new_object = self.save_form(request, form, change=not add)
1816             else:
1817                 new_object = form.instance
1818             if all_valid(formsets) and form_validated:
1819                 self.save_model(request, new_object, form, not add)
1820                 self.save_related(request, form, formsets, not add)
1821                 change_message = self.construct_change_message(
1822                     request, form, formsets, add
1823                 )
1824                 if add:
1825                     self.log_addition(request, new_object, change_message)
1826                     return self.response_add(request, new_object)
1827                 else:
1828                     self.log_change(request, new_object, change_message)
1829                     return self.response_change(request, new_object)
1830             else:
1831                 form_validated = False
1832         else:
1833             if add:
1834                 initial = self.get_changeform_initial_data(request)
1835                 form = ModelForm(initial=initial)
1836                 formsets, inline_instances = self._create_formsets(
1837                     request, form.instance, change=False
1838                 )
1839             else:
1840                 form = ModelForm(instance=obj)
1841                 formsets, inline_instances = self._create_formsets(
1842                     request, obj, change=True
1843                 )
1844 
1845         if not add and not self.has_change_permission(request, obj):
1846             readonly_fields = flatten_fieldsets(fieldsets)
1847         else:
1848             readonly_fields = self.get_readonly_fields(request, obj)
1849         admin_form = helpers.AdminForm(
1850             form,
1851             list(fieldsets),
1852             # Clear prepopulated fields on a view-only form to avoid a crash.
1853             self.get_prepopulated_fields(request, obj)
1854             if add or self.has_change_permission(request, obj)
1855             else {},
1856             readonly_fields,
1857             model_admin=self,
1858         )
1859         media = self.media + admin_form.media
1860 
1861         inline_formsets = self.get_inline_formsets(
1862             request, formsets, inline_instances, obj
1863         )
1864         for inline_formset in inline_formsets:
1865             media += inline_formset.media
1866 
1867         if add:
1868             title = _("Add %s")
1869         elif self.has_change_permission(request, obj):
1870             title = _("Change %s")
1871         else:
1872             title = _("View %s")
1873         context = {
1874             **self.admin_site.each_context(request),
1875             "title": title % self.opts.verbose_name,
1876             "subtitle": str(obj) if obj else None,
1877             "adminform": admin_form,
1878             "object_id": object_id,
1879             "original": obj,
1880             "is_popup": IS_POPUP_VAR in request.POST or IS_POPUP_VAR in request.GET,
1881             "to_field": to_field,
1882             "media": media,
1883             "inline_admin_formsets": inline_formsets,
1884             "errors": helpers.AdminErrorList(form, formsets),
1885             "preserved_filters": self.get_preserved_filters(request),
1886         }
1887 
1888         # Hide the "Save" and "Save and continue" buttons if "Save as New" was
1889         # previously chosen to prevent the interface from getting confusing.
1890         if (
1891             request.method == "POST"
1892             and not form_validated
1893             and "_saveasnew" in request.POST
1894         ):
1895             context["show_save"] = False
1896             context["show_save_and_continue"] = False
1897             # Use the change template instead of the add template.
1898             add = False
1899 
1900         context.update(extra_context or {})
1901 
1902         return self.render_change_form(
1903             request, context, add=add, change=not add, obj=obj, form_url=form_url
1904         )
1905 
1906     def add_view(self, request, form_url="", extra_context=None):
1907         return self.changeform_view(request, None, form_url, extra_context)
1908 
1909     def change_view(self, request, object_id, form_url="", extra_context=None):
1910         return self.changeform_view(request, object_id, form_url, extra_context)
1911 
1912     def _get_edited_object_pks(self, request, prefix):
1913         """Return POST data values of list_editable primary keys."""
1914         pk_pattern = re.compile(
1915             r"{}-\d+-{}$".format(re.escape(prefix), self.opts.pk.name)
1916         )
1917         return [value for key, value in request.POST.items() if pk_pattern.match(key)]
1918 
1919     def _get_list_editable_queryset(self, request, prefix):
1920         """
1921         Based on POST data, return a queryset of the objects that were edited
1922         via list_editable.
1923         """
1924         object_pks = self._get_edited_object_pks(request, prefix)
1925         queryset = self.get_queryset(request)
1926         validate = queryset.model._meta.pk.to_python
1927         try:
1928             for pk in object_pks:
1929                 validate(pk)
1930         except ValidationError:
1931             # Disable the optimization if the POST data was tampered with.
1932             return queryset
1933         return queryset.filter(pk__in=object_pks)
1934 
1935     @csrf_protect_m
1936     def changelist_view(self, request, extra_context=None):
1937         """
1938         The 'change list' admin view for this model.
1939         """
1940         from django.contrib.admin.views.main import ERROR_FLAG
1941 
1942         app_label = self.opts.app_label
1943         if not self.has_view_or_change_permission(request):
1944             raise PermissionDenied
1945 
1946         try:
1947             cl = self.get_changelist_instance(request)
1948         except IncorrectLookupParameters:
1949             # Wacky lookup parameters were given, so redirect to the main
1950             # changelist page, without parameters, and pass an 'invalid=1'
1951             # parameter via the query string. If wacky parameters were given
1952             # and the 'invalid=1' parameter was already in the query string,
1953             # something is screwed up with the database, so display an error
1954             # page.
1955             if ERROR_FLAG in request.GET:
1956                 return SimpleTemplateResponse(
1957                     "admin/invalid_setup.html",
1958                     {
1959                         "title": _("Database error"),
1960                     },
1961                 )
1962             return HttpResponseRedirect(request.path + "?" + ERROR_FLAG + "=1")
1963 
1964         # If the request was POSTed, this might be a bulk action or a bulk
1965         # edit. Try to look up an action or confirmation first, but if this
1966         # isn't an action the POST will fall through to the bulk edit check,
1967         # below.
1968         action_failed = False
1969         selected = request.POST.getlist(helpers.ACTION_CHECKBOX_NAME)
1970 
1971         actions = self.get_actions(request)
1972         # Actions with no confirmation
1973         if (
1974             actions
1975             and request.method == "POST"
1976             and "index" in request.POST
1977             and "_save" not in request.POST
1978         ):
1979             if selected:
1980                 response = self.response_action(
1981                     request, queryset=cl.get_queryset(request)
1982                 )
1983                 if response:
1984                     return response
1985                 else:
1986                     action_failed = True
1987             else:
1988                 msg = _(
1989                     "Items must be selected in order to perform "
1990                     "actions on them. No items have been changed."
1991                 )
1992                 self.message_user(request, msg, messages.WARNING)
1993                 action_failed = True
1994 
1995         # Actions with confirmation
1996         if (
1997             actions
1998             and request.method == "POST"
1999             and helpers.ACTION_CHECKBOX_NAME in request.POST
2000             and "index" not in request.POST
2001             and "_save" not in request.POST
2002         ):
2003             if selected:
2004                 response = self.response_action(
2005                     request, queryset=cl.get_queryset(request)
2006                 )
2007                 if response:
2008                     return response
2009                 else:
2010                     action_failed = True
2011 
2012         if action_failed:
2013             # Redirect back to the changelist page to avoid resubmitting the
2014             # form if the user refreshes the browser or uses the "No, take
2015             # me back" button on the action confirmation page.
2016             return HttpResponseRedirect(request.get_full_path())
2017 
2018         # If we're allowing changelist editing, we need to construct a formset
2019         # for the changelist given all the fields to be edited. Then we'll
2020         # use the formset to validate/process POSTed data.
2021         formset = cl.formset = None
2022 
2023         # Handle POSTed bulk-edit data.
2024         if request.method == "POST" and cl.list_editable and "_save" in request.POST:
2025             if not self.has_change_permission(request):
2026                 raise PermissionDenied
2027             FormSet = self.get_changelist_formset(request)
2028             modified_objects = self._get_list_editable_queryset(
2029                 request, FormSet.get_default_prefix()
2030             )
2031             formset = cl.formset = FormSet(
2032                 request.POST, request.FILES, queryset=modified_objects
2033             )
2034             if formset.is_valid():
2035                 changecount = 0
2036                 with transaction.atomic(using=router.db_for_write(self.model)):
2037                     for form in formset.forms:
2038                         if form.has_changed():
2039                             obj = self.save_form(request, form, change=True)
2040                             self.save_model(request, obj, form, change=True)
2041                             self.save_related(request, form, formsets=[], change=True)
2042                             change_msg = self.construct_change_message(
2043                                 request, form, None
2044                             )
2045                             self.log_change(request, obj, change_msg)
2046                             changecount += 1
2047                 if changecount:
2048                     msg = ngettext(
2049                         "%(count)s %(name)s was changed successfully.",
2050                         "%(count)s %(name)s were changed successfully.",
2051                         changecount,
2052                     ) % {
2053                         "count": changecount,
2054                         "name": model_ngettext(self.opts, changecount),
2055                     }
2056                     self.message_user(request, msg, messages.SUCCESS)
2057 
2058                 return HttpResponseRedirect(request.get_full_path())
2059 
2060         # Handle GET -- construct a formset for display.
2061         elif cl.list_editable and self.has_change_permission(request):
2062             FormSet = self.get_changelist_formset(request)
2063             formset = cl.formset = FormSet(queryset=cl.result_list)
2064 
2065         # Build the list of media to be used by the formset.
2066         if formset:
2067             media = self.media + formset.media
2068         else:
2069             media = self.media
2070 
2071         # Build the action form and populate it with available actions.
2072         if actions:
2073             action_form = self.action_form(auto_id=None)
2074             action_form.fields["action"].choices = self.get_action_choices(request)
2075             media += action_form.media
2076         else:
2077             action_form = None
2078 
2079         selection_note_all = ngettext(
2080             "%(total_count)s selected", "All %(total_count)s selected", cl.result_count
2081         )
2082 
2083         context = {
2084             **self.admin_site.each_context(request),
2085             "module_name": str(self.opts.verbose_name_plural),
2086             "selection_note": _("0 of %(cnt)s selected") % {"cnt": len(cl.result_list)},
2087             "selection_note_all": selection_note_all % {"total_count": cl.result_count},
2088             "title": cl.title,
2089             "subtitle": None,
2090             "is_popup": cl.is_popup,
2091             "to_field": cl.to_field,
2092             "cl": cl,
2093             "media": media,
2094             "has_add_permission": self.has_add_permission(request),
2095             "opts": cl.opts,
2096             "action_form": action_form,
2097             "actions_on_top": self.actions_on_top,
2098             "actions_on_bottom": self.actions_on_bottom,
2099             "actions_selection_counter": self.actions_selection_counter,
2100             "preserved_filters": self.get_preserved_filters(request),
2101             **(extra_context or {}),
2102         }
2103 
2104         request.current_app = self.admin_site.name
2105 
2106         return TemplateResponse(
2107             request,
2108             self.change_list_template
2109             or [
2110                 "admin/%s/%s/change_list.html" % (app_label, self.opts.model_name),
2111                 "admin/%s/change_list.html" % app_label,
2112                 "admin/change_list.html",
2113             ],
2114             context,
2115         )
2116 
2117     def get_deleted_objects(self, objs, request):
2118         """
2119         Hook for customizing the delete process for the delete view and the
2120         "delete selected" action.
2121         """
2122         return get_deleted_objects(objs, request, self.admin_site)
2123 
2124     @csrf_protect_m
2125     def delete_view(self, request, object_id, extra_context=None):
2126         with transaction.atomic(using=router.db_for_write(self.model)):
2127             return self._delete_view(request, object_id, extra_context)
2128 
2129     def _delete_view(self, request, object_id, extra_context):
2130         "The 'delete' admin view for this model."
2131         app_label = self.opts.app_label
2132 
2133         to_field = request.POST.get(TO_FIELD_VAR, request.GET.get(TO_FIELD_VAR))
2134         if to_field and not self.to_field_allowed(request, to_field):
2135             raise DisallowedModelAdminToField(
2136                 "The field %s cannot be referenced." % to_field
2137             )
2138 
2139         obj = self.get_object(request, unquote(object_id), to_field)
2140 
2141         if not self.has_delete_permission(request, obj):
2142             raise PermissionDenied
2143 
2144         if obj is None:
2145             return self._get_obj_does_not_exist_redirect(request, self.opts, object_id)
2146 
2147         # Populate deleted_objects, a data structure of all related objects that
2148         # will also be deleted.
2149         (
2150             deleted_objects,
2151             model_count,
2152             perms_needed,
2153             protected,
2154         ) = self.get_deleted_objects([obj], request)
2155 
2156         if request.POST and not protected:  # The user has confirmed the deletion.
2157             if perms_needed:
2158                 raise PermissionDenied
2159             obj_display = str(obj)
2160             attr = str(to_field) if to_field else self.opts.pk.attname
2161             obj_id = obj.serializable_value(attr)
2162             self.log_deletion(request, obj, obj_display)
2163             self.delete_model(request, obj)
2164 
2165             return self.response_delete(request, obj_display, obj_id)
2166 
2167         object_name = str(self.opts.verbose_name)
2168 
2169         if perms_needed or protected:
2170             title = _("Cannot delete %(name)s") % {"name": object_name}
2171         else:
2172             title = _("Are you sure?")
2173 
2174         context = {
2175             **self.admin_site.each_context(request),
2176             "title": title,
2177             "subtitle": None,
2178             "object_name": object_name,
2179             "object": obj,
2180             "deleted_objects": deleted_objects,
2181             "model_count": dict(model_count).items(),
2182             "perms_lacking": perms_needed,
2183             "protected": protected,
2184             "opts": self.opts,
2185             "app_label": app_label,
2186             "preserved_filters": self.get_preserved_filters(request),
2187             "is_popup": IS_POPUP_VAR in request.POST or IS_POPUP_VAR in request.GET,
2188             "to_field": to_field,
2189             **(extra_context or {}),
2190         }
2191 
2192         return self.render_delete_form(request, context)
2193 
2194     def history_view(self, request, object_id, extra_context=None):
2195         "The 'history' admin view for this model."
2196         from django.contrib.admin.models import LogEntry
2197         from django.contrib.admin.views.main import PAGE_VAR
2198 
2199         # First check if the user can see this history.
2200         model = self.model
2201         obj = self.get_object(request, unquote(object_id))
2202         if obj is None:
2203             return self._get_obj_does_not_exist_redirect(
2204                 request, model._meta, object_id
2205             )
2206 
2207         if not self.has_view_or_change_permission(request, obj):
2208             raise PermissionDenied
2209 
2210         # Then get the history for this object.
2211         app_label = self.opts.app_label
2212         action_list = (
2213             LogEntry.objects.filter(
2214                 object_id=unquote(object_id),
2215                 content_type=get_content_type_for_model(model),
2216             )
2217             .select_related()
2218             .order_by("action_time")
2219         )
2220 
2221         paginator = self.get_paginator(request, action_list, 100)
2222         page_number = request.GET.get(PAGE_VAR, 1)
2223         page_obj = paginator.get_page(page_number)
2224         page_range = paginator.get_elided_page_range(page_obj.number)
2225 
2226         context = {
2227             **self.admin_site.each_context(request),
2228             "title": _("Change history: %s") % obj,
2229             "subtitle": None,
2230             "action_list": page_obj,
2231             "page_range": page_range,
2232             "page_var": PAGE_VAR,
2233             "pagination_required": paginator.count > 100,
2234             "module_name": str(capfirst(self.opts.verbose_name_plural)),
2235             "object": obj,
2236             "opts": self.opts,
2237             "preserved_filters": self.get_preserved_filters(request),
2238             **(extra_context or {}),
2239         }
2240 
2241         request.current_app = self.admin_site.name
2242 
2243         return TemplateResponse(
2244             request,
2245             self.object_history_template
2246             or [
2247                 "admin/%s/%s/object_history.html" % (app_label, self.opts.model_name),
2248                 "admin/%s/object_history.html" % app_label,
2249                 "admin/object_history.html",
2250             ],
2251             context,
2252         )
2253 
2254     def get_formset_kwargs(self, request, obj, inline, prefix):
2255         formset_params = {
2256             "instance": obj,
2257             "prefix": prefix,
2258             "queryset": inline.get_queryset(request),
2259         }
2260         if request.method == "POST":
2261             formset_params.update(
2262                 {
2263                     "data": request.POST.copy(),
2264                     "files": request.FILES,
2265                     "save_as_new": "_saveasnew" in request.POST,
2266                 }
2267             )
2268         return formset_params
2269 
2270     def _create_formsets(self, request, obj, change):
2271         "Helper function to generate formsets for add/change_view."
2272         formsets = []
2273         inline_instances = []
2274         prefixes = {}
2275         get_formsets_args = [request]
2276         if change:
2277             get_formsets_args.append(obj)
2278         for FormSet, inline in self.get_formsets_with_inlines(*get_formsets_args):
2279             prefix = FormSet.get_default_prefix()
2280             prefixes[prefix] = prefixes.get(prefix, 0) + 1
2281             if prefixes[prefix] != 1 or not prefix:
2282                 prefix = "%s-%s" % (prefix, prefixes[prefix])
2283             formset_params = self.get_formset_kwargs(request, obj, inline, prefix)
2284             formset = FormSet(**formset_params)
2285 
2286             def user_deleted_form(request, obj, formset, index, inline):
2287                 """Return whether or not the user deleted the form."""
2288                 return (
2289                     inline.has_delete_permission(request, obj)
2290                     and "{}-{}-DELETE".format(formset.prefix, index) in request.POST
2291                 )
2292 
2293             # Bypass validation of each view-only inline form (since the form's
2294             # data won't be in request.POST), unless the form was deleted.
2295             if not inline.has_change_permission(request, obj if change else None):
2296                 for index, form in enumerate(formset.initial_forms):
2297                     if user_deleted_form(request, obj, formset, index, inline):
2298                         continue
2299                     form._errors = {}
2300                     form.cleaned_data = form.initial
2301             formsets.append(formset)
2302             inline_instances.append(inline)
2303         return formsets, inline_instances

</code><intended_behavior>A new validation method or an enhancement of an existing one within ModelAdmin should check if filter_horizontal or filter_vertical is used with a ManyToManyField that has a custom through model defined. This method should raise a validation error or at least a warning if such a configuration is detected, guiding developers away from this unsupported setup. The validation should be integrated into the admin system checks that run when the server starts or the checks framework is otherwise invoked. This preserves the functionality of filter_horizontal and filter_vertical by clearly communicating their limitations to developers.</intended_behavior>, <file>django/contrib/admin/checks.py</file>
<class>None</class>
<method>None</method>
<code>
1 import collections
2 from itertools import chain
3 
4 from django.apps import apps
5 from django.conf import settings
6 from django.contrib.admin.utils import NotRelationField, flatten, get_fields_from_path
7 from django.core import checks
8 from django.core.exceptions import FieldDoesNotExist
9 from django.db import models
10 from django.db.models.constants import LOOKUP_SEP
11 from django.db.models.expressions import Combinable
12 from django.forms.models import BaseModelForm, BaseModelFormSet, _get_foreign_key
13 from django.template import engines
14 from django.template.backends.django import DjangoTemplates
15 from django.utils.module_loading import import_string
16 
17 
18 def _issubclass(cls, classinfo):
19     """
20     issubclass() variant that doesn't raise an exception if cls isn't a
21     class.
22     """
23     try:
24         return issubclass(cls, classinfo)
25     except TypeError:
26         return False
27 
28 
29 def _contains_subclass(class_path, candidate_paths):
30     """
31     Return whether or not a dotted class path (or a subclass of that class) is
32     found in a list of candidate paths.
33     """
34     cls = import_string(class_path)
35     for path in candidate_paths:
36         try:
37             candidate_cls = import_string(path)
38         except ImportError:
39             # ImportErrors are raised elsewhere.
40             continue
41         if _issubclass(candidate_cls, cls):
42             return True
43     return False
44 
45 
46 def check_admin_app(app_configs, **kwargs):
47     from django.contrib.admin.sites import all_sites
48 
49     errors = []
50     for site in all_sites:
51         errors.extend(site.check(app_configs))
52     return errors
53 
54 
55 def check_dependencies(**kwargs):
56     """
57     Check that the admin's dependencies are correctly installed.
58     """
59     from django.contrib.admin.sites import all_sites
60 
61     if not apps.is_installed("django.contrib.admin"):
62         return []
63     errors = []
64     app_dependencies = (
65         ("django.contrib.contenttypes", 401),
66         ("django.contrib.auth", 405),
67         ("django.contrib.messages", 406),
68     )
69     for app_name, error_code in app_dependencies:
70         if not apps.is_installed(app_name):
71             errors.append(
72                 checks.Error(
73                     "'%s' must be in INSTALLED_APPS in order to use the admin "
74                     "application." % app_name,
75                     id="admin.E%d" % error_code,
76                 )
77             )
78     for engine in engines.all():
79         if isinstance(engine, DjangoTemplates):
80             django_templates_instance = engine.engine
81             break
82     else:
83         django_templates_instance = None
84     if not django_templates_instance:
85         errors.append(
86             checks.Error(
87                 "A 'django.template.backends.django.DjangoTemplates' instance "
88                 "must be configured in TEMPLATES in order to use the admin "
89                 "application.",
90                 id="admin.E403",
91             )
92         )
93     else:
94         if (
95             "django.contrib.auth.context_processors.auth"
96             not in django_templates_instance.context_processors
97             and _contains_subclass(
98                 "django.contrib.auth.backends.ModelBackend",
99                 settings.AUTHENTICATION_BACKENDS,
100             )
101         ):
102             errors.append(
103                 checks.Error(
104                     "'django.contrib.auth.context_processors.auth' must be "
105                     "enabled in DjangoTemplates (TEMPLATES) if using the default "
106                     "auth backend in order to use the admin application.",
107                     id="admin.E402",
108                 )
109             )
110         if (
111             "django.contrib.messages.context_processors.messages"
112             not in django_templates_instance.context_processors
113         ):
114             errors.append(
115                 checks.Error(
116                     "'django.contrib.messages.context_processors.messages' must "
117                     "be enabled in DjangoTemplates (TEMPLATES) in order to use "
118                     "the admin application.",
119                     id="admin.E404",
120                 )
121             )
122         sidebar_enabled = any(site.enable_nav_sidebar for site in all_sites)
123         if (
124             sidebar_enabled
125             and "django.template.context_processors.request"
126             not in django_templates_instance.context_processors
127         ):
128             errors.append(
129                 checks.Warning(
130                     "'django.template.context_processors.request' must be enabled "
131                     "in DjangoTemplates (TEMPLATES) in order to use the admin "
132                     "navigation sidebar.",
133                     id="admin.W411",
134                 )
135             )
136 
137     if not _contains_subclass(
138         "django.contrib.auth.middleware.AuthenticationMiddleware", settings.MIDDLEWARE
139     ):
140         errors.append(
141             checks.Error(
142                 "'django.contrib.auth.middleware.AuthenticationMiddleware' must "
143                 "be in MIDDLEWARE in order to use the admin application.",
144                 id="admin.E408",
145             )
146         )
147     if not _contains_subclass(
148         "django.contrib.messages.middleware.MessageMiddleware", settings.MIDDLEWARE
149     ):
150         errors.append(
151             checks.Error(
152                 "'django.contrib.messages.middleware.MessageMiddleware' must "
153                 "be in MIDDLEWARE in order to use the admin application.",
154                 id="admin.E409",
155             )
156         )
157     if not _contains_subclass(
158         "django.contrib.sessions.middleware.SessionMiddleware", settings.MIDDLEWARE
159     ):
160         errors.append(
161             checks.Error(
162                 "'django.contrib.sessions.middleware.SessionMiddleware' must "
163                 "be in MIDDLEWARE in order to use the admin application.",
164                 hint=(
165                     "Insert "
166                     "'django.contrib.sessions.middleware.SessionMiddleware' "
167                     "before "
168                     "'django.contrib.auth.middleware.AuthenticationMiddleware'."
169                 ),
170                 id="admin.E410",
171             )
172         )
173     return errors
174 
175 
176 class BaseModelAdminChecks:
177     def check(self, admin_obj, **kwargs):
178         return [
179             *self._check_autocomplete_fields(admin_obj),
180             *self._check_raw_id_fields(admin_obj),
181             *self._check_fields(admin_obj),
182             *self._check_fieldsets(admin_obj),
183             *self._check_exclude(admin_obj),
184             *self._check_form(admin_obj),
185             *self._check_filter_vertical(admin_obj),
186             *self._check_filter_horizontal(admin_obj),
187             *self._check_radio_fields(admin_obj),
188             *self._check_prepopulated_fields(admin_obj),
189             *self._check_view_on_site_url(admin_obj),
190             *self._check_ordering(admin_obj),
191             *self._check_readonly_fields(admin_obj),
192         ]
193 
194     def _check_autocomplete_fields(self, obj):
195         """
196         Check that `autocomplete_fields` is a list or tuple of model fields.
197         """
198         if not isinstance(obj.autocomplete_fields, (list, tuple)):
199             return must_be(
200                 "a list or tuple",
201                 option="autocomplete_fields",
202                 obj=obj,
203                 id="admin.E036",
204             )
205         else:
206             return list(
207                 chain.from_iterable(
208                     [
209                         self._check_autocomplete_fields_item(
210                             obj, field_name, "autocomplete_fields[%d]" % index
211                         )
212                         for index, field_name in enumerate(obj.autocomplete_fields)
213                     ]
214                 )
215             )
216 
217     def _check_autocomplete_fields_item(self, obj, field_name, label):
218         """
219         Check that an item in `autocomplete_fields` is a ForeignKey or a
220         ManyToManyField and that the item has a related ModelAdmin with
221         search_fields defined.
222         """
223         try:
224             field = obj.model._meta.get_field(field_name)
225         except FieldDoesNotExist:
226             return refer_to_missing_field(
227                 field=field_name, option=label, obj=obj, id="admin.E037"
228             )
229         else:
230             if not field.many_to_many and not isinstance(field, models.ForeignKey):
231                 return must_be(
232                     "a foreign key or a many-to-many field",
233                     option=label,
234                     obj=obj,
235                     id="admin.E038",
236                 )
237             related_admin = obj.admin_site._registry.get(field.remote_field.model)
238             if related_admin is None:
239                 return [
240                     checks.Error(
241                         'An admin for model "%s" has to be registered '
242                         "to be referenced by %s.autocomplete_fields."
243                         % (
244                             field.remote_field.model.__name__,
245                             type(obj).__name__,
246                         ),
247                         obj=obj.__class__,
248                         id="admin.E039",
249                     )
250                 ]
251             elif not related_admin.search_fields:
252                 return [
253                     checks.Error(
254                         '%s must define "search_fields", because it\'s '
255                         "referenced by %s.autocomplete_fields."
256                         % (
257                             related_admin.__class__.__name__,
258                             type(obj).__name__,
259                         ),
260                         obj=obj.__class__,
261                         id="admin.E040",
262                     )
263                 ]
264             return []
265 
266     def _check_raw_id_fields(self, obj):
267         """Check that `raw_id_fields` only contains field names that are listed
268         on the model."""
269 
270         if not isinstance(obj.raw_id_fields, (list, tuple)):
271             return must_be(
272                 "a list or tuple", option="raw_id_fields", obj=obj, id="admin.E001"
273             )
274         else:
275             return list(
276                 chain.from_iterable(
277                     self._check_raw_id_fields_item(
278                         obj, field_name, "raw_id_fields[%d]" % index
279                     )
280                     for index, field_name in enumerate(obj.raw_id_fields)
281                 )
282             )
283 
284     def _check_raw_id_fields_item(self, obj, field_name, label):
285         """Check an item of `raw_id_fields`, i.e. check that field named
286         `field_name` exists in model `model` and is a ForeignKey or a
287         ManyToManyField."""
288 
289         try:
290             field = obj.model._meta.get_field(field_name)
291         except FieldDoesNotExist:
292             return refer_to_missing_field(
293                 field=field_name, option=label, obj=obj, id="admin.E002"
294             )
295         else:
296             # Using attname is not supported.
297             if field.name != field_name:
298                 return refer_to_missing_field(
299                     field=field_name,
300                     option=label,
301                     obj=obj,
302                     id="admin.E002",
303                 )
304             if not field.many_to_many and not isinstance(field, models.ForeignKey):
305                 return must_be(
306                     "a foreign key or a many-to-many field",
307                     option=label,
308                     obj=obj,
309                     id="admin.E003",
310                 )
311             else:
312                 return []
313 
314     def _check_fields(self, obj):
315         """Check that `fields` only refer to existing fields, doesn't contain
316         duplicates. Check if at most one of `fields` and `fieldsets` is defined.
317         """
318 
319         if obj.fields is None:
320             return []
321         elif not isinstance(obj.fields, (list, tuple)):
322             return must_be("a list or tuple", option="fields", obj=obj, id="admin.E004")
323         elif obj.fieldsets:
324             return [
325                 checks.Error(
326                     "Both 'fieldsets' and 'fields' are specified.",
327                     obj=obj.__class__,
328                     id="admin.E005",
329                 )
330             ]
331         fields = flatten(obj.fields)
332         if len(fields) != len(set(fields)):
333             return [
334                 checks.Error(
335                     "The value of 'fields' contains duplicate field(s).",
336                     obj=obj.__class__,
337                     id="admin.E006",
338                 )
339             ]
340 
341         return list(
342             chain.from_iterable(
343                 self._check_field_spec(obj, field_name, "fields")
344                 for field_name in obj.fields
345             )
346         )
347 
348     def _check_fieldsets(self, obj):
349         """Check that fieldsets is properly formatted and doesn't contain
350         duplicates."""
351 
352         if obj.fieldsets is None:
353             return []
354         elif not isinstance(obj.fieldsets, (list, tuple)):
355             return must_be(
356                 "a list or tuple", option="fieldsets", obj=obj, id="admin.E007"
357             )
358         else:
359             seen_fields = []
360             return list(
361                 chain.from_iterable(
362                     self._check_fieldsets_item(
363                         obj, fieldset, "fieldsets[%d]" % index, seen_fields
364                     )
365                     for index, fieldset in enumerate(obj.fieldsets)
366                 )
367             )
368 
369     def _check_fieldsets_item(self, obj, fieldset, label, seen_fields):
370         """Check an item of `fieldsets`, i.e. check that this is a pair of a
371         set name and a dictionary containing "fields" key."""
372 
373         if not isinstance(fieldset, (list, tuple)):
374             return must_be("a list or tuple", option=label, obj=obj, id="admin.E008")
375         elif len(fieldset) != 2:
376             return must_be("of length 2", option=label, obj=obj, id="admin.E009")
377         elif not isinstance(fieldset[1], dict):
378             return must_be(
379                 "a dictionary", option="%s[1]" % label, obj=obj, id="admin.E010"
380             )
381         elif "fields" not in fieldset[1]:
382             return [
383                 checks.Error(
384                     "The value of '%s[1]' must contain the key 'fields'." % label,
385                     obj=obj.__class__,
386                     id="admin.E011",
387                 )
388             ]
389         elif not isinstance(fieldset[1]["fields"], (list, tuple)):
390             return must_be(
391                 "a list or tuple",
392                 option="%s[1]['fields']" % label,
393                 obj=obj,
394                 id="admin.E008",
395             )
396 
397         seen_fields.extend(flatten(fieldset[1]["fields"]))
398         if len(seen_fields) != len(set(seen_fields)):
399             return [
400                 checks.Error(
401                     "There are duplicate field(s) in '%s[1]'." % label,
402                     obj=obj.__class__,
403                     id="admin.E012",
404                 )
405             ]
406         return list(
407             chain.from_iterable(
408                 self._check_field_spec(obj, fieldset_fields, '%s[1]["fields"]' % label)
409                 for fieldset_fields in fieldset[1]["fields"]
410             )
411         )
412 
413     def _check_field_spec(self, obj, fields, label):
414         """`fields` should be an item of `fields` or an item of
415         fieldset[1]['fields'] for any `fieldset` in `fieldsets`. It should be a
416         field name or a tuple of field names."""
417 
418         if isinstance(fields, tuple):
419             return list(
420                 chain.from_iterable(
421                     self._check_field_spec_item(
422                         obj, field_name, "%s[%d]" % (label, index)
423                     )
424                     for index, field_name in enumerate(fields)
425                 )
426             )
427         else:
428             return self._check_field_spec_item(obj, fields, label)
429 
430     def _check_field_spec_item(self, obj, field_name, label):
431         if field_name in obj.readonly_fields:
432             # Stuff can be put in fields that isn't actually a model field if
433             # it's in readonly_fields, readonly_fields will handle the
434             # validation of such things.
435             return []
436         else:
437             try:
438                 field = obj.model._meta.get_field(field_name)
439             except FieldDoesNotExist:
440                 # If we can't find a field on the model that matches, it could
441                 # be an extra field on the form.
442                 return []
443             else:
444                 if (
445                     isinstance(field, models.ManyToManyField)
446                     and not field.remote_field.through._meta.auto_created
447                 ):
448                     return [
449                         checks.Error(
450                             "The value of '%s' cannot include the ManyToManyField "
451                             "'%s', because that field manually specifies a "
452                             "relationship model." % (label, field_name),
453                             obj=obj.__class__,
454                             id="admin.E013",
455                         )
456                     ]
457                 else:
458                     return []
459 
460     def _check_exclude(self, obj):
461         """Check that exclude is a sequence without duplicates."""
462 
463         if obj.exclude is None:  # default value is None
464             return []
465         elif not isinstance(obj.exclude, (list, tuple)):
466             return must_be(
467                 "a list or tuple", option="exclude", obj=obj, id="admin.E014"
468             )
469         elif len(obj.exclude) > len(set(obj.exclude)):
470             return [
471                 checks.Error(
472                     "The value of 'exclude' contains duplicate field(s).",
473                     obj=obj.__class__,
474                     id="admin.E015",
475                 )
476             ]
477         else:
478             return []
479 
480     def _check_form(self, obj):
481         """Check that form subclasses BaseModelForm."""
482         if not _issubclass(obj.form, BaseModelForm):
483             return must_inherit_from(
484                 parent="BaseModelForm", option="form", obj=obj, id="admin.E016"
485             )
486         else:
487             return []
488 
489     def _check_filter_vertical(self, obj):
490         """Check that filter_vertical is a sequence of field names."""
491         if not isinstance(obj.filter_vertical, (list, tuple)):
492             return must_be(
493                 "a list or tuple", option="filter_vertical", obj=obj, id="admin.E017"
494             )
495         else:
496             return list(
497                 chain.from_iterable(
498                     self._check_filter_item(
499                         obj, field_name, "filter_vertical[%d]" % index
500                     )
501                     for index, field_name in enumerate(obj.filter_vertical)
502                 )
503             )
504 
505     def _check_filter_horizontal(self, obj):
506         """Check that filter_horizontal is a sequence of field names."""
507         if not isinstance(obj.filter_horizontal, (list, tuple)):
508             return must_be(
509                 "a list or tuple", option="filter_horizontal", obj=obj, id="admin.E018"
510             )
511         else:
512             return list(
513                 chain.from_iterable(
514                     self._check_filter_item(
515                         obj, field_name, "filter_horizontal[%d]" % index
516                     )
517                     for index, field_name in enumerate(obj.filter_horizontal)
518                 )
519             )
520 
521     def _check_filter_item(self, obj, field_name, label):
522         """Check one item of `filter_vertical` or `filter_horizontal`, i.e.
523         check that given field exists and is a ManyToManyField."""
524 
525         try:
526             field = obj.model._meta.get_field(field_name)
527         except FieldDoesNotExist:
528             return refer_to_missing_field(
529                 field=field_name, option=label, obj=obj, id="admin.E019"
530             )
531         else:
532             if not field.many_to_many:
533                 return must_be(
534                     "a many-to-many field", option=label, obj=obj, id="admin.E020"
535                 )
536             else:
537                 return []
538 
539     def _check_radio_fields(self, obj):
540         """Check that `radio_fields` is a dictionary."""
541         if not isinstance(obj.radio_fields, dict):
542             return must_be(
543                 "a dictionary", option="radio_fields", obj=obj, id="admin.E021"
544             )
545         else:
546             return list(
547                 chain.from_iterable(
548                     self._check_radio_fields_key(obj, field_name, "radio_fields")
549                     + self._check_radio_fields_value(
550                         obj, val, 'radio_fields["%s"]' % field_name
551                     )
552                     for field_name, val in obj.radio_fields.items()
553                 )
554             )
555 
556     def _check_radio_fields_key(self, obj, field_name, label):
557         """Check that a key of `radio_fields` dictionary is name of existing
558         field and that the field is a ForeignKey or has `choices` defined."""
559 
560         try:
561             field = obj.model._meta.get_field(field_name)
562         except FieldDoesNotExist:
563             return refer_to_missing_field(
564                 field=field_name, option=label, obj=obj, id="admin.E022"
565             )
566         else:
567             if not (isinstance(field, models.ForeignKey) or field.choices):
568                 return [
569                     checks.Error(
570                         "The value of '%s' refers to '%s', which is not an "
571                         "instance of ForeignKey, and does not have a 'choices' "
572                         "definition." % (label, field_name),
573                         obj=obj.__class__,
574                         id="admin.E023",
575                     )
576                 ]
577             else:
578                 return []
579 
580     def _check_radio_fields_value(self, obj, val, label):
581         """Check type of a value of `radio_fields` dictionary."""
582 
583         from django.contrib.admin.options import HORIZONTAL, VERTICAL
584 
585         if val not in (HORIZONTAL, VERTICAL):
586             return [
587                 checks.Error(
588                     "The value of '%s' must be either admin.HORIZONTAL or "
589                     "admin.VERTICAL." % label,
590                     obj=obj.__class__,
591                     id="admin.E024",
592                 )
593             ]
594         else:
595             return []
596 
597     def _check_view_on_site_url(self, obj):
598         if not callable(obj.view_on_site) and not isinstance(obj.view_on_site, bool):
599             return [
600                 checks.Error(
601                     "The value of 'view_on_site' must be a callable or a boolean "
602                     "value.",
603                     obj=obj.__class__,
604                     id="admin.E025",
605                 )
606             ]
607         else:
608             return []
609 
610     def _check_prepopulated_fields(self, obj):
611         """Check that `prepopulated_fields` is a dictionary containing allowed
612         field types."""
613         if not isinstance(obj.prepopulated_fields, dict):
614             return must_be(
615                 "a dictionary", option="prepopulated_fields", obj=obj, id="admin.E026"
616             )
617         else:
618             return list(
619                 chain.from_iterable(
620                     self._check_prepopulated_fields_key(
621                         obj, field_name, "prepopulated_fields"
622                     )
623                     + self._check_prepopulated_fields_value(
624                         obj, val, 'prepopulated_fields["%s"]' % field_name
625                     )
626                     for field_name, val in obj.prepopulated_fields.items()
627                 )
628             )
629 
630     def _check_prepopulated_fields_key(self, obj, field_name, label):
631         """Check a key of `prepopulated_fields` dictionary, i.e. check that it
632         is a name of existing field and the field is one of the allowed types.
633         """
634 
635         try:
636             field = obj.model._meta.get_field(field_name)
637         except FieldDoesNotExist:
638             return refer_to_missing_field(
639                 field=field_name, option=label, obj=obj, id="admin.E027"
640             )
641         else:
642             if isinstance(
643                 field, (models.DateTimeField, models.ForeignKey, models.ManyToManyField)
644             ):
645                 return [
646                     checks.Error(
647                         "The value of '%s' refers to '%s', which must not be a "
648                         "DateTimeField, a ForeignKey, a OneToOneField, or a "
649                         "ManyToManyField." % (label, field_name),
650                         obj=obj.__class__,
651                         id="admin.E028",
652                     )
653                 ]
654             else:
655                 return []
656 
657     def _check_prepopulated_fields_value(self, obj, val, label):
658         """Check a value of `prepopulated_fields` dictionary, i.e. it's an
659         iterable of existing fields."""
660 
661         if not isinstance(val, (list, tuple)):
662             return must_be("a list or tuple", option=label, obj=obj, id="admin.E029")
663         else:
664             return list(
665                 chain.from_iterable(
666                     self._check_prepopulated_fields_value_item(
667                         obj, subfield_name, "%s[%r]" % (label, index)
668                     )
669                     for index, subfield_name in enumerate(val)
670                 )
671             )
672 
673     def _check_prepopulated_fields_value_item(self, obj, field_name, label):
674         """For `prepopulated_fields` equal to {"slug": ("title",)},
675         `field_name` is "title"."""
676 
677         try:
678             obj.model._meta.get_field(field_name)
679         except FieldDoesNotExist:
680             return refer_to_missing_field(
681                 field=field_name, option=label, obj=obj, id="admin.E030"
682             )
683         else:
684             return []
685 
686     def _check_ordering(self, obj):
687         """Check that ordering refers to existing fields or is random."""
688 
689         # ordering = None
690         if obj.ordering is None:  # The default value is None
691             return []
692         elif not isinstance(obj.ordering, (list, tuple)):
693             return must_be(
694                 "a list or tuple", option="ordering", obj=obj, id="admin.E031"
695             )
696         else:
697             return list(
698                 chain.from_iterable(
699                     self._check_ordering_item(obj, field_name, "ordering[%d]" % index)
700                     for index, field_name in enumerate(obj.ordering)
701                 )
702             )
703 
704     def _check_ordering_item(self, obj, field_name, label):
705         """Check that `ordering` refers to existing fields."""
706         if isinstance(field_name, (Combinable, models.OrderBy)):
707             if not isinstance(field_name, models.OrderBy):
708                 field_name = field_name.asc()
709             if isinstance(field_name.expression, models.F):
710                 field_name = field_name.expression.name
711             else:
712                 return []
713         if field_name == "?" and len(obj.ordering) != 1:
714             return [
715                 checks.Error(
716                     "The value of 'ordering' has the random ordering marker '?', "
717                     "but contains other fields as well.",
718                     hint='Either remove the "?", or remove the other fields.',
719                     obj=obj.__class__,
720                     id="admin.E032",
721                 )
722             ]
723         elif field_name == "?":
724             return []
725         elif LOOKUP_SEP in field_name:
726             # Skip ordering in the format field1__field2 (FIXME: checking
727             # this format would be nice, but it's a little fiddly).
728             return []
729         else:
730             field_name = field_name.removeprefix("-")
731             if field_name == "pk":
732                 return []
733             try:
734                 obj.model._meta.get_field(field_name)
735             except FieldDoesNotExist:
736                 return refer_to_missing_field(
737                     field=field_name, option=label, obj=obj, id="admin.E033"
738                 )
739             else:
740                 return []
741 
742     def _check_readonly_fields(self, obj):
743         """Check that readonly_fields refers to proper attribute or field."""
744 
745         if obj.readonly_fields == ():
746             return []
747         elif not isinstance(obj.readonly_fields, (list, tuple)):
748             return must_be(
749                 "a list or tuple", option="readonly_fields", obj=obj, id="admin.E034"
750             )
751         else:
752             return list(
753                 chain.from_iterable(
754                     self._check_readonly_fields_item(
755                         obj, field_name, "readonly_fields[%d]" % index
756                     )
757                     for index, field_name in enumerate(obj.readonly_fields)
758                 )
759             )
760 
761     def _check_readonly_fields_item(self, obj, field_name, label):
762         if callable(field_name):
763             return []
764         elif hasattr(obj, field_name):
765             return []
766         elif hasattr(obj.model, field_name):
767             return []
768         else:
769             try:
770                 obj.model._meta.get_field(field_name)
771             except FieldDoesNotExist:
772                 return [
773                     checks.Error(
774                         "The value of '%s' refers to '%s', which is not a callable, "
775                         "an attribute of '%s', or an attribute of '%s'."
776                         % (
777                             label,
778                             field_name,
779                             obj.__class__.__name__,
780                             obj.model._meta.label,
781                         ),
782                         obj=obj.__class__,
783                         id="admin.E035",
784                     )
785                 ]
786             else:
787                 return []
788 
789 
790 class ModelAdminChecks(BaseModelAdminChecks):
791     def check(self, admin_obj, **kwargs):
792         return [
793             *super().check(admin_obj),
794             *self._check_save_as(admin_obj),
795             *self._check_save_on_top(admin_obj),
796             *self._check_inlines(admin_obj),
797             *self._check_list_display(admin_obj),
798             *self._check_list_display_links(admin_obj),
799             *self._check_list_filter(admin_obj),
800             *self._check_list_select_related(admin_obj),
801             *self._check_list_per_page(admin_obj),
802             *self._check_list_max_show_all(admin_obj),
803             *self._check_list_editable(admin_obj),
804             *self._check_search_fields(admin_obj),
805             *self._check_date_hierarchy(admin_obj),
806             *self._check_action_permission_methods(admin_obj),
807             *self._check_actions_uniqueness(admin_obj),
808         ]
809 
810     def _check_save_as(self, obj):
811         """Check save_as is a boolean."""
812 
813         if not isinstance(obj.save_as, bool):
814             return must_be("a boolean", option="save_as", obj=obj, id="admin.E101")
815         else:
816             return []
817 
818     def _check_save_on_top(self, obj):
819         """Check save_on_top is a boolean."""
820 
821         if not isinstance(obj.save_on_top, bool):
822             return must_be("a boolean", option="save_on_top", obj=obj, id="admin.E102")
823         else:
824             return []
825 
826     def _check_inlines(self, obj):
827         """Check all inline model admin classes."""
828 
829         if not isinstance(obj.inlines, (list, tuple)):
830             return must_be(
831                 "a list or tuple", option="inlines", obj=obj, id="admin.E103"
832             )
833         else:
834             return list(
835                 chain.from_iterable(
836                     self._check_inlines_item(obj, item, "inlines[%d]" % index)
837                     for index, item in enumerate(obj.inlines)
838                 )
839             )
840 
841     def _check_inlines_item(self, obj, inline, label):
842         """Check one inline model admin."""
843         try:
844             inline_label = inline.__module__ + "." + inline.__name__
845         except AttributeError:
846             return [
847                 checks.Error(
848                     "'%s' must inherit from 'InlineModelAdmin'." % obj,
849                     obj=obj.__class__,
850                     id="admin.E104",
851                 )
852             ]
853 
854         from django.contrib.admin.options import InlineModelAdmin
855 
856         if not _issubclass(inline, InlineModelAdmin):
857             return [
858                 checks.Error(
859                     "'%s' must inherit from 'InlineModelAdmin'." % inline_label,
860                     obj=obj.__class__,
861                     id="admin.E104",
862                 )
863             ]
864         elif not inline.model:
865             return [
866                 checks.Error(
867                     "'%s' must have a 'model' attribute." % inline_label,
868                     obj=obj.__class__,
869                     id="admin.E105",
870                 )
871             ]
872         elif not _issubclass(inline.model, models.Model):
873             return must_be(
874                 "a Model", option="%s.model" % inline_label, obj=obj, id="admin.E106"
875             )
876         else:
877             return inline(obj.model, obj.admin_site).check()
878 
879     def _check_list_display(self, obj):
880         """Check that list_display only contains fields or usable attributes."""
881 
882         if not isinstance(obj.list_display, (list, tuple)):
883             return must_be(
884                 "a list or tuple", option="list_display", obj=obj, id="admin.E107"
885             )
886         else:
887             return list(
888                 chain.from_iterable(
889                     self._check_list_display_item(obj, item, "list_display[%d]" % index)
890                     for index, item in enumerate(obj.list_display)
891                 )
892             )
893 
894     def _check_list_display_item(self, obj, item, label):
895         if callable(item):
896             return []
897         elif hasattr(obj, item):
898             return []
899         try:
900             field = obj.model._meta.get_field(item)
901         except FieldDoesNotExist:
902             try:
903                 field = getattr(obj.model, item)
904             except AttributeError:
905                 return [
906                     checks.Error(
907                         "The value of '%s' refers to '%s', which is not a "
908                         "callable, an attribute of '%s', or an attribute or "
909                         "method on '%s'."
910                         % (
911                             label,
912                             item,
913                             obj.__class__.__name__,
914                             obj.model._meta.label,
915                         ),
916                         obj=obj.__class__,
917                         id="admin.E108",
918                     )
919                 ]
920         if (
921             getattr(field, "is_relation", False)
922             and (field.many_to_many or field.one_to_many)
923         ) or (getattr(field, "rel", None) and field.rel.field.many_to_one):
924             return [
925                 checks.Error(
926                     f"The value of '{label}' must not be a many-to-many field or a "
927                     f"reverse foreign key.",
928                     obj=obj.__class__,
929                     id="admin.E109",
930                 )
931             ]
932         return []
933 
934     def _check_list_display_links(self, obj):
935         """Check that list_display_links is a unique subset of list_display."""
936         from django.contrib.admin.options import ModelAdmin
937 
938         if obj.list_display_links is None:
939             return []
940         elif not isinstance(obj.list_display_links, (list, tuple)):
941             return must_be(
942                 "a list, a tuple, or None",
943                 option="list_display_links",
944                 obj=obj,
945                 id="admin.E110",
946             )
947         # Check only if ModelAdmin.get_list_display() isn't overridden.
948         elif obj.get_list_display.__func__ is ModelAdmin.get_list_display:
949             return list(
950                 chain.from_iterable(
951                     self._check_list_display_links_item(
952                         obj, field_name, "list_display_links[%d]" % index
953                     )
954                     for index, field_name in enumerate(obj.list_display_links)
955                 )
956             )
957         return []
958 
959     def _check_list_display_links_item(self, obj, field_name, label):
960         if field_name not in obj.list_display:
961             return [
962                 checks.Error(
963                     "The value of '%s' refers to '%s', which is not defined in "
964                     "'list_display'." % (label, field_name),
965                     obj=obj.__class__,
966                     id="admin.E111",
967                 )
968             ]
969         else:
970             return []
971 
972     def _check_list_filter(self, obj):
973         if not isinstance(obj.list_filter, (list, tuple)):
974             return must_be(
975                 "a list or tuple", option="list_filter", obj=obj, id="admin.E112"
976             )
977         else:
978             return list(
979                 chain.from_iterable(
980                     self._check_list_filter_item(obj, item, "list_filter[%d]" % index)
981                     for index, item in enumerate(obj.list_filter)
982                 )
983             )
984 
985     def _check_list_filter_item(self, obj, item, label):
986         """
987         Check one item of `list_filter`, i.e. check if it is one of three options:
988         1. 'field' -- a basic field filter, possibly w/ relationships (e.g.
989            'field__rel')
990         2. ('field', SomeFieldListFilter) - a field-based list filter class
991         3. SomeListFilter - a non-field list filter class
992         """
993         from django.contrib.admin import FieldListFilter, ListFilter
994 
995         if callable(item) and not isinstance(item, models.Field):
996             # If item is option 3, it should be a ListFilter...
997             if not _issubclass(item, ListFilter):
998                 return must_inherit_from(
999                     parent="ListFilter", option=label, obj=obj, id="admin.E113"
1000                 )
1001             # ...  but not a FieldListFilter.
1002             elif issubclass(item, FieldListFilter):
1003                 return [
1004                     checks.Error(
1005                         "The value of '%s' must not inherit from 'FieldListFilter'."
1006                         % label,
1007                         obj=obj.__class__,
1008                         id="admin.E114",
1009                     )
1010                 ]
1011             else:
1012                 return []
1013         elif isinstance(item, (tuple, list)):
1014             # item is option #2
1015             field, list_filter_class = item
1016             if not _issubclass(list_filter_class, FieldListFilter):
1017                 return must_inherit_from(
1018                     parent="FieldListFilter",
1019                     option="%s[1]" % label,
1020                     obj=obj,
1021                     id="admin.E115",
1022                 )
1023             else:
1024                 return []
1025         else:
1026             # item is option #1
1027             field = item
1028 
1029             # Validate the field string
1030             try:
1031                 get_fields_from_path(obj.model, field)
1032             except (NotRelationField, FieldDoesNotExist):
1033                 return [
1034                     checks.Error(
1035                         "The value of '%s' refers to '%s', which does not refer to a "
1036                         "Field." % (label, field),
1037                         obj=obj.__class__,
1038                         id="admin.E116",
1039                     )
1040                 ]
1041             else:
1042                 return []
1043 
1044     def _check_list_select_related(self, obj):
1045         """Check that list_select_related is a boolean, a list or a tuple."""
1046 
1047         if not isinstance(obj.list_select_related, (bool, list, tuple)):
1048             return must_be(
1049                 "a boolean, tuple or list",
1050                 option="list_select_related",
1051                 obj=obj,
1052                 id="admin.E117",
1053             )
1054         else:
1055             return []
1056 
1057     def _check_list_per_page(self, obj):
1058         """Check that list_per_page is an integer."""
1059 
1060         if not isinstance(obj.list_per_page, int):
1061             return must_be(
1062                 "an integer", option="list_per_page", obj=obj, id="admin.E118"
1063             )
1064         else:
1065             return []
1066 
1067     def _check_list_max_show_all(self, obj):
1068         """Check that list_max_show_all is an integer."""
1069 
1070         if not isinstance(obj.list_max_show_all, int):
1071             return must_be(
1072                 "an integer", option="list_max_show_all", obj=obj, id="admin.E119"
1073             )
1074         else:
1075             return []
1076 
1077     def _check_list_editable(self, obj):
1078         """Check that list_editable is a sequence of editable fields from
1079         list_display without first element."""
1080 
1081         if not isinstance(obj.list_editable, (list, tuple)):
1082             return must_be(
1083                 "a list or tuple", option="list_editable", obj=obj, id="admin.E120"
1084             )
1085         else:
1086             return list(
1087                 chain.from_iterable(
1088                     self._check_list_editable_item(
1089                         obj, item, "list_editable[%d]" % index
1090                     )
1091                     for index, item in enumerate(obj.list_editable)
1092                 )
1093             )
1094 
1095     def _check_list_editable_item(self, obj, field_name, label):
1096         try:
1097             field = obj.model._meta.get_field(field_name)
1098         except FieldDoesNotExist:
1099             return refer_to_missing_field(
1100                 field=field_name, option=label, obj=obj, id="admin.E121"
1101             )
1102         else:
1103             if field_name not in obj.list_display:
1104                 return [
1105                     checks.Error(
1106                         "The value of '%s' refers to '%s', which is not "
1107                         "contained in 'list_display'." % (label, field_name),
1108                         obj=obj.__class__,
1109                         id="admin.E122",
1110                     )
1111                 ]
1112             elif obj.list_display_links and field_name in obj.list_display_links:
1113                 return [
1114                     checks.Error(
1115                         "The value of '%s' cannot be in both 'list_editable' and "
1116                         "'list_display_links'." % field_name,
1117                         obj=obj.__class__,
1118                         id="admin.E123",
1119                     )
1120                 ]
1121             # If list_display[0] is in list_editable, check that
1122             # list_display_links is set. See #22792 and #26229 for use cases.
1123             elif (
1124                 obj.list_display[0] == field_name
1125                 and not obj.list_display_links
1126                 and obj.list_display_links is not None
1127             ):
1128                 return [
1129                     checks.Error(
1130                         "The value of '%s' refers to the first field in 'list_display' "
1131                         "('%s'), which cannot be used unless 'list_display_links' is "
1132                         "set." % (label, obj.list_display[0]),
1133                         obj=obj.__class__,
1134                         id="admin.E124",
1135                     )
1136                 ]
1137             elif not field.editable or field.primary_key:
1138                 return [
1139                     checks.Error(
1140                         "The value of '%s' refers to '%s', which is not editable "
1141                         "through the admin." % (label, field_name),
1142                         obj=obj.__class__,
1143                         id="admin.E125",
1144                     )
1145                 ]
1146             else:
1147                 return []
1148 
1149     def _check_search_fields(self, obj):
1150         """Check search_fields is a sequence."""
1151 
1152         if not isinstance(obj.search_fields, (list, tuple)):
1153             return must_be(
1154                 "a list or tuple", option="search_fields", obj=obj, id="admin.E126"
1155             )
1156         else:
1157             return []
1158 
1159     def _check_date_hierarchy(self, obj):
1160         """Check that date_hierarchy refers to DateField or DateTimeField."""
1161 
1162         if obj.date_hierarchy is None:
1163             return []
1164         else:
1165             try:
1166                 field = get_fields_from_path(obj.model, obj.date_hierarchy)[-1]
1167             except (NotRelationField, FieldDoesNotExist):
1168                 return [
1169                     checks.Error(
1170                         "The value of 'date_hierarchy' refers to '%s', which "
1171                         "does not refer to a Field." % obj.date_hierarchy,
1172                         obj=obj.__class__,
1173                         id="admin.E127",
1174                     )
1175                 ]
1176             else:
1177                 if not isinstance(field, (models.DateField, models.DateTimeField)):
1178                     return must_be(
1179                         "a DateField or DateTimeField",
1180                         option="date_hierarchy",
1181                         obj=obj,
1182                         id="admin.E128",
1183                     )
1184                 else:
1185                     return []
1186 
1187     def _check_action_permission_methods(self, obj):
1188         """
1189         Actions with an allowed_permission attribute require the ModelAdmin to
1190         implement a has_<perm>_permission() method for each permission.
1191         """
1192         actions = obj._get_base_actions()
1193         errors = []
1194         for func, name, _ in actions:
1195             if not hasattr(func, "allowed_permissions"):
1196                 continue
1197             for permission in func.allowed_permissions:
1198                 method_name = "has_%s_permission" % permission
1199                 if not hasattr(obj, method_name):
1200                     errors.append(
1201                         checks.Error(
1202                             "%s must define a %s() method for the %s action."
1203                             % (
1204                                 obj.__class__.__name__,
1205                                 method_name,
1206                                 func.__name__,
1207                             ),
1208                             obj=obj.__class__,
1209                             id="admin.E129",
1210                         )
1211                     )
1212         return errors
1213 
1214     def _check_actions_uniqueness(self, obj):
1215         """Check that every action has a unique __name__."""
1216         errors = []
1217         names = collections.Counter(name for _, name, _ in obj._get_base_actions())
1218         for name, count in names.items():
1219             if count > 1:
1220                 errors.append(
1221                     checks.Error(
1222                         "__name__ attributes of actions defined in %s must be "
1223                         "unique. Name %r is not unique."
1224                         % (
1225                             obj.__class__.__name__,
1226                             name,
1227                         ),
1228                         obj=obj.__class__,
1229                         id="admin.E130",
1230                     )
1231                 )
1232         return errors
1233 
1234 
1235 class InlineModelAdminChecks(BaseModelAdminChecks):
1236     def check(self, inline_obj, **kwargs):
1237         parent_model = inline_obj.parent_model
1238         return [
1239             *super().check(inline_obj),
1240             *self._check_relation(inline_obj, parent_model),
1241             *self._check_exclude_of_parent_model(inline_obj, parent_model),
1242             *self._check_extra(inline_obj),
1243             *self._check_max_num(inline_obj),
1244             *self._check_min_num(inline_obj),
1245             *self._check_formset(inline_obj),
1246         ]
1247 
1248     def _check_exclude_of_parent_model(self, obj, parent_model):
1249         # Do not perform more specific checks if the base checks result in an
1250         # error.
1251         errors = super()._check_exclude(obj)
1252         if errors:
1253             return []
1254 
1255         # Skip if `fk_name` is invalid.
1256         if self._check_relation(obj, parent_model):
1257             return []
1258 
1259         if obj.exclude is None:
1260             return []
1261 
1262         fk = _get_foreign_key(parent_model, obj.model, fk_name=obj.fk_name)
1263         if fk.name in obj.exclude:
1264             return [
1265                 checks.Error(
1266                     "Cannot exclude the field '%s', because it is the foreign key "
1267                     "to the parent model '%s'."
1268                     % (
1269                         fk.name,
1270                         parent_model._meta.label,
1271                     ),
1272                     obj=obj.__class__,
1273                     id="admin.E201",
1274                 )
1275             ]
1276         else:
1277             return []
1278 
1279     def _check_relation(self, obj, parent_model):
1280         try:
1281             _get_foreign_key(parent_model, obj.model, fk_name=obj.fk_name)
1282         except ValueError as e:
1283             return [checks.Error(e.args[0], obj=obj.__class__, id="admin.E202")]
1284         else:
1285             return []
1286 
1287     def _check_extra(self, obj):
1288         """Check that extra is an integer."""
1289 
1290         if not isinstance(obj.extra, int):
1291             return must_be("an integer", option="extra", obj=obj, id="admin.E203")
1292         else:
1293             return []
1294 
1295     def _check_max_num(self, obj):
1296         """Check that max_num is an integer."""
1297 
1298         if obj.max_num is None:
1299             return []
1300         elif not isinstance(obj.max_num, int):
1301             return must_be("an integer", option="max_num", obj=obj, id="admin.E204")
1302         else:
1303             return []
1304 
1305     def _check_min_num(self, obj):
1306         """Check that min_num is an integer."""
1307 
1308         if obj.min_num is None:
1309             return []
1310         elif not isinstance(obj.min_num, int):
1311             return must_be("an integer", option="min_num", obj=obj, id="admin.E205")
1312         else:
1313             return []
1314 
1315     def _check_formset(self, obj):
1316         """Check formset is a subclass of BaseModelFormSet."""
1317 
1318         if not _issubclass(obj.formset, BaseModelFormSet):
1319             return must_inherit_from(
1320                 parent="BaseModelFormSet", option="formset", obj=obj, id="admin.E206"
1321             )
1322         else:
1323             return []
1324 
1325 
1326 def must_be(type, option, obj, id):
1327     return [
1328         checks.Error(
1329             "The value of '%s' must be %s." % (option, type),
1330             obj=obj.__class__,
1331             id=id,
1332         ),
1333     ]
1334 
1335 
1336 def must_inherit_from(parent, option, obj, id):
1337     return [
1338         checks.Error(
1339             "The value of '%s' must inherit from '%s'." % (option, parent),
1340             obj=obj.__class__,
1341             id=id,
1342         ),
1343     ]
1344 
1345 
1346 def refer_to_missing_field(field, option, obj, id):
1347     return [
1348         checks.Error(
1349             "The value of '%s' refers to '%s', which is not a field of '%s'."
1350             % (option, field, obj.model._meta.label),
1351             obj=obj.__class__,
1352             id=id,
1353         ),
1354     ]

</code><intended_behavior>Extend or introduce checks related to ModelAdmin configuration that specifically validate the use of filter_horizontal or filter_vertical in conjunction with ManyToManyField's through option. The check should verify that when either filter_horizontal or filter_vertical is configured, the related ManyToManyField does not declare a through model. If such a case is found, the check should emit a warning or error indicating the incompatibility. This enhancement would help developers identify configuration mistakes early in the development process, ensuring the admin interface behaves as expected.</intended_behavior>]
2025-10-15 20:09:23.177 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-15 20:09:23.177 | INFO     | Search-only: skipping patch selection
2025-10-15 20:09:23.314 | INFO     | Task django__django-16983 completed successfully.
2025-10-15 20:09:23.315 | INFO     | No patch generated. You can try running ACR again.
