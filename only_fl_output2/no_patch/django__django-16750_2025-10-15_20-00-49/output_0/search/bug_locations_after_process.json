[
    {
        "rel_file_path": "django/db/models/functions/text.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__5.0/django/db/models/functions/text.py",
        "start": 1,
        "end": 365,
        "class_name": null,
        "method_name": null,
        "code": "1 from django.db import NotSupportedError\n2 from django.db.models.expressions import Func, Value\n3 from django.db.models.fields import CharField, IntegerField, TextField\n4 from django.db.models.functions import Cast, Coalesce\n5 from django.db.models.lookups import Transform\n6 \n7 \n8 class MySQLSHA2Mixin:\n9     def as_mysql(self, compiler, connection, **extra_context):\n10         return super().as_sql(\n11             compiler,\n12             connection,\n13             template=\"SHA2(%%(expressions)s, %s)\" % self.function[3:],\n14             **extra_context,\n15         )\n16 \n17 \n18 class OracleHashMixin:\n19     def as_oracle(self, compiler, connection, **extra_context):\n20         return super().as_sql(\n21             compiler,\n22             connection,\n23             template=(\n24                 \"LOWER(RAWTOHEX(STANDARD_HASH(UTL_I18N.STRING_TO_RAW(\"\n25                 \"%(expressions)s, 'AL32UTF8'), '%(function)s')))\"\n26             ),\n27             **extra_context,\n28         )\n29 \n30 \n31 class PostgreSQLSHAMixin:\n32     def as_postgresql(self, compiler, connection, **extra_context):\n33         return super().as_sql(\n34             compiler,\n35             connection,\n36             template=\"ENCODE(DIGEST(%(expressions)s, '%(function)s'), 'hex')\",\n37             function=self.function.lower(),\n38             **extra_context,\n39         )\n40 \n41 \n42 class Chr(Transform):\n43     function = \"CHR\"\n44     lookup_name = \"chr\"\n45 \n46     def as_mysql(self, compiler, connection, **extra_context):\n47         return super().as_sql(\n48             compiler,\n49             connection,\n50             function=\"CHAR\",\n51             template=\"%(function)s(%(expressions)s USING utf16)\",\n52             **extra_context,\n53         )\n54 \n55     def as_oracle(self, compiler, connection, **extra_context):\n56         return super().as_sql(\n57             compiler,\n58             connection,\n59             template=\"%(function)s(%(expressions)s USING NCHAR_CS)\",\n60             **extra_context,\n61         )\n62 \n63     def as_sqlite(self, compiler, connection, **extra_context):\n64         return super().as_sql(compiler, connection, function=\"CHAR\", **extra_context)\n65 \n66 \n67 class ConcatPair(Func):\n68     \"\"\"\n69     Concatenate two arguments together. This is used by `Concat` because not\n70     all backend databases support more than two arguments.\n71     \"\"\"\n72 \n73     function = \"CONCAT\"\n74 \n75     def as_sqlite(self, compiler, connection, **extra_context):\n76         coalesced = self.coalesce()\n77         return super(ConcatPair, coalesced).as_sql(\n78             compiler,\n79             connection,\n80             template=\"%(expressions)s\",\n81             arg_joiner=\" || \",\n82             **extra_context,\n83         )\n84 \n85     def as_postgresql(self, compiler, connection, **extra_context):\n86         copy = self.copy()\n87         copy.set_source_expressions(\n88             [\n89                 Cast(expression, TextField())\n90                 for expression in copy.get_source_expressions()\n91             ]\n92         )\n93         return super(ConcatPair, copy).as_sql(\n94             compiler,\n95             connection,\n96             **extra_context,\n97         )\n98 \n99     def as_mysql(self, compiler, connection, **extra_context):\n100         # Use CONCAT_WS with an empty separator so that NULLs are ignored.\n101         return super().as_sql(\n102             compiler,\n103             connection,\n104             function=\"CONCAT_WS\",\n105             template=\"%(function)s('', %(expressions)s)\",\n106             **extra_context,\n107         )\n108 \n109     def coalesce(self):\n110         # null on either side results in null for expression, wrap with coalesce\n111         c = self.copy()\n112         c.set_source_expressions(\n113             [\n114                 Coalesce(expression, Value(\"\"))\n115                 for expression in c.get_source_expressions()\n116             ]\n117         )\n118         return c\n119 \n120 \n121 class Concat(Func):\n122     \"\"\"\n123     Concatenate text fields together. Backends that result in an entire\n124     null expression when any arguments are null will wrap each argument in\n125     coalesce functions to ensure a non-null result.\n126     \"\"\"\n127 \n128     function = None\n129     template = \"%(expressions)s\"\n130 \n131     def __init__(self, *expressions, **extra):\n132         if len(expressions) < 2:\n133             raise ValueError(\"Concat must take at least two expressions\")\n134         paired = self._paired(expressions)\n135         super().__init__(paired, **extra)\n136 \n137     def _paired(self, expressions):\n138         # wrap pairs of expressions in successive concat functions\n139         # exp = [a, b, c, d]\n140         # -> ConcatPair(a, ConcatPair(b, ConcatPair(c, d))))\n141         if len(expressions) == 2:\n142             return ConcatPair(*expressions)\n143         return ConcatPair(expressions[0], self._paired(expressions[1:]))\n144 \n145 \n146 class Left(Func):\n147     function = \"LEFT\"\n148     arity = 2\n149     output_field = CharField()\n150 \n151     def __init__(self, expression, length, **extra):\n152         \"\"\"\n153         expression: the name of a field, or an expression returning a string\n154         length: the number of characters to return from the start of the string\n155         \"\"\"\n156         if not hasattr(length, \"resolve_expression\"):\n157             if length < 1:\n158                 raise ValueError(\"'length' must be greater than 0.\")\n159         super().__init__(expression, length, **extra)\n160 \n161     def get_substr(self):\n162         return Substr(self.source_expressions[0], Value(1), self.source_expressions[1])\n163 \n164     def as_oracle(self, compiler, connection, **extra_context):\n165         return self.get_substr().as_oracle(compiler, connection, **extra_context)\n166 \n167     def as_sqlite(self, compiler, connection, **extra_context):\n168         return self.get_substr().as_sqlite(compiler, connection, **extra_context)\n169 \n170 \n171 class Length(Transform):\n172     \"\"\"Return the number of characters in the expression.\"\"\"\n173 \n174     function = \"LENGTH\"\n175     lookup_name = \"length\"\n176     output_field = IntegerField()\n177 \n178     def as_mysql(self, compiler, connection, **extra_context):\n179         return super().as_sql(\n180             compiler, connection, function=\"CHAR_LENGTH\", **extra_context\n181         )\n182 \n183 \n184 class Lower(Transform):\n185     function = \"LOWER\"\n186     lookup_name = \"lower\"\n187 \n188 \n189 class LPad(Func):\n190     function = \"LPAD\"\n191     output_field = CharField()\n192 \n193     def __init__(self, expression, length, fill_text=Value(\" \"), **extra):\n194         if (\n195             not hasattr(length, \"resolve_expression\")\n196             and length is not None\n197             and length < 0\n198         ):\n199             raise ValueError(\"'length' must be greater or equal to 0.\")\n200         super().__init__(expression, length, fill_text, **extra)\n201 \n202 \n203 class LTrim(Transform):\n204     function = \"LTRIM\"\n205     lookup_name = \"ltrim\"\n206 \n207 \n208 class MD5(OracleHashMixin, Transform):\n209     function = \"MD5\"\n210     lookup_name = \"md5\"\n211 \n212 \n213 class Ord(Transform):\n214     function = \"ASCII\"\n215     lookup_name = \"ord\"\n216     output_field = IntegerField()\n217 \n218     def as_mysql(self, compiler, connection, **extra_context):\n219         return super().as_sql(compiler, connection, function=\"ORD\", **extra_context)\n220 \n221     def as_sqlite(self, compiler, connection, **extra_context):\n222         return super().as_sql(compiler, connection, function=\"UNICODE\", **extra_context)\n223 \n224 \n225 class Repeat(Func):\n226     function = \"REPEAT\"\n227     output_field = CharField()\n228 \n229     def __init__(self, expression, number, **extra):\n230         if (\n231             not hasattr(number, \"resolve_expression\")\n232             and number is not None\n233             and number < 0\n234         ):\n235             raise ValueError(\"'number' must be greater or equal to 0.\")\n236         super().__init__(expression, number, **extra)\n237 \n238     def as_oracle(self, compiler, connection, **extra_context):\n239         expression, number = self.source_expressions\n240         length = None if number is None else Length(expression) * number\n241         rpad = RPad(expression, length, expression)\n242         return rpad.as_sql(compiler, connection, **extra_context)\n243 \n244 \n245 class Replace(Func):\n246     function = \"REPLACE\"\n247 \n248     def __init__(self, expression, text, replacement=Value(\"\"), **extra):\n249         super().__init__(expression, text, replacement, **extra)\n250 \n251 \n252 class Reverse(Transform):\n253     function = \"REVERSE\"\n254     lookup_name = \"reverse\"\n255 \n256     def as_oracle(self, compiler, connection, **extra_context):\n257         # REVERSE in Oracle is undocumented and doesn't support multi-byte\n258         # strings. Use a special subquery instead.\n259         return super().as_sql(\n260             compiler,\n261             connection,\n262             template=(\n263                 \"(SELECT LISTAGG(s) WITHIN GROUP (ORDER BY n DESC) FROM \"\n264                 \"(SELECT LEVEL n, SUBSTR(%(expressions)s, LEVEL, 1) s \"\n265                 \"FROM DUAL CONNECT BY LEVEL <= LENGTH(%(expressions)s)) \"\n266                 \"GROUP BY %(expressions)s)\"\n267             ),\n268             **extra_context,\n269         )\n270 \n271 \n272 class Right(Left):\n273     function = \"RIGHT\"\n274 \n275     def get_substr(self):\n276         return Substr(\n277             self.source_expressions[0], self.source_expressions[1] * Value(-1)\n278         )\n279 \n280 \n281 class RPad(LPad):\n282     function = \"RPAD\"\n283 \n284 \n285 class RTrim(Transform):\n286     function = \"RTRIM\"\n287     lookup_name = \"rtrim\"\n288 \n289 \n290 class SHA1(OracleHashMixin, PostgreSQLSHAMixin, Transform):\n291     function = \"SHA1\"\n292     lookup_name = \"sha1\"\n293 \n294 \n295 class SHA224(MySQLSHA2Mixin, PostgreSQLSHAMixin, Transform):\n296     function = \"SHA224\"\n297     lookup_name = \"sha224\"\n298 \n299     def as_oracle(self, compiler, connection, **extra_context):\n300         raise NotSupportedError(\"SHA224 is not supported on Oracle.\")\n301 \n302 \n303 class SHA256(MySQLSHA2Mixin, OracleHashMixin, PostgreSQLSHAMixin, Transform):\n304     function = \"SHA256\"\n305     lookup_name = \"sha256\"\n306 \n307 \n308 class SHA384(MySQLSHA2Mixin, OracleHashMixin, PostgreSQLSHAMixin, Transform):\n309     function = \"SHA384\"\n310     lookup_name = \"sha384\"\n311 \n312 \n313 class SHA512(MySQLSHA2Mixin, OracleHashMixin, PostgreSQLSHAMixin, Transform):\n314     function = \"SHA512\"\n315     lookup_name = \"sha512\"\n316 \n317 \n318 class StrIndex(Func):\n319     \"\"\"\n320     Return a positive integer corresponding to the 1-indexed position of the\n321     first occurrence of a substring inside another string, or 0 if the\n322     substring is not found.\n323     \"\"\"\n324 \n325     function = \"INSTR\"\n326     arity = 2\n327     output_field = IntegerField()\n328 \n329     def as_postgresql(self, compiler, connection, **extra_context):\n330         return super().as_sql(compiler, connection, function=\"STRPOS\", **extra_context)\n331 \n332 \n333 class Substr(Func):\n334     function = \"SUBSTRING\"\n335     output_field = CharField()\n336 \n337     def __init__(self, expression, pos, length=None, **extra):\n338         \"\"\"\n339         expression: the name of a field, or an expression returning a string\n340         pos: an integer > 0, or an expression returning an integer\n341         length: an optional number of characters to return\n342         \"\"\"\n343         if not hasattr(pos, \"resolve_expression\"):\n344             if pos < 1:\n345                 raise ValueError(\"'pos' must be greater than 0\")\n346         expressions = [expression, pos]\n347         if length is not None:\n348             expressions.append(length)\n349         super().__init__(*expressions, **extra)\n350 \n351     def as_sqlite(self, compiler, connection, **extra_context):\n352         return super().as_sql(compiler, connection, function=\"SUBSTR\", **extra_context)\n353 \n354     def as_oracle(self, compiler, connection, **extra_context):\n355         return super().as_sql(compiler, connection, function=\"SUBSTR\", **extra_context)\n356 \n357 \n358 class Trim(Transform):\n359     function = \"TRIM\"\n360     lookup_name = \"trim\"\n361 \n362 \n363 class Upper(Transform):\n364     function = \"UPPER\"\n365     lookup_name = \"upper\"\n",
        "intended_behavior": "The `Chr` function should explicitly define its output as a character field by setting `output_field=CharField()` within its implementation. This change will instruct Django's ORM to treat the output of the `Chr` function as text, thereby avoiding the `ValueError` when an attempt is made to interpret a non-integer value ('M' in the context of the bug report) as an integer. This adjustment should maintain the existing functionality of `Chr` for intended use cases, ensuring it can still be used wherever character representation of numeric values is required within Django model queries."
    }
]