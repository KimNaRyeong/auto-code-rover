[
    {
        "rel_file_path": "pylint/pyreverse/inspector.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/pylint-dev__pylint/setup_pylint-dev__pylint__2.9/pylint/pyreverse/inspector.py",
        "start": 1,
        "end": 355,
        "class_name": null,
        "method_name": null,
        "code": "1 # Copyright (c) 2015-2020 Claudiu Popa <pcmanticore@gmail.com>\n2 # Copyright (c) 2017 \u0141ukasz Rogalski <rogalski.91@gmail.com>\n3 # Copyright (c) 2018 ssolanki <sushobhitsolanki@gmail.com>\n4 # Copyright (c) 2018 Ville Skytt\u00e4 <ville.skytta@iki.fi>\n5 # Copyright (c) 2019-2021 Pierre Sassoulas <pierre.sassoulas@gmail.com>\n6 # Copyright (c) 2019 Hugo van Kemenade <hugovk@users.noreply.github.com>\n7 # Copyright (c) 2020 hippo91 <guillaume.peillex@gmail.com>\n8 # Copyright (c) 2020 Anthony Sottile <asottile@umich.edu>\n9 \n10 # Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n11 # For details: https://github.com/PyCQA/pylint/blob/master/LICENSE\n12 \n13 \"\"\"\n14 Visitor doing some postprocessing on the astroid tree.\n15 Try to resolve definitions (namespace) dictionary, relationship...\n16 \"\"\"\n17 import collections\n18 import os\n19 import traceback\n20 \n21 import astroid\n22 \n23 from pylint.pyreverse import utils\n24 \n25 \n26 def _iface_hdlr(_):\n27     \"\"\"Handler used by interfaces to handle suspicious interface nodes.\"\"\"\n28     return True\n29 \n30 \n31 def _astroid_wrapper(func, modname):\n32     print(\"parsing %s...\" % modname)\n33     try:\n34         return func(modname)\n35     except astroid.exceptions.AstroidBuildingException as exc:\n36         print(exc)\n37     except Exception:  # pylint: disable=broad-except\n38         traceback.print_exc()\n39     return None\n40 \n41 \n42 def interfaces(node, herited=True, handler_func=_iface_hdlr):\n43     \"\"\"Return an iterator on interfaces implemented by the given class node.\"\"\"\n44     try:\n45         implements = astroid.bases.Instance(node).getattr(\"__implements__\")[0]\n46     except astroid.exceptions.NotFoundError:\n47         return\n48     if not herited and implements.frame() is not node:\n49         return\n50     found = set()\n51     missing = False\n52     for iface in astroid.node_classes.unpack_infer(implements):\n53         if iface is astroid.Uninferable:\n54             missing = True\n55             continue\n56         if iface not in found and handler_func(iface):\n57             found.add(iface)\n58             yield iface\n59     if missing:\n60         raise astroid.exceptions.InferenceError()\n61 \n62 \n63 class IdGeneratorMixIn:\n64     \"\"\"Mixin adding the ability to generate integer uid.\"\"\"\n65 \n66     def __init__(self, start_value=0):\n67         self.id_count = start_value\n68 \n69     def init_counter(self, start_value=0):\n70         \"\"\"init the id counter\"\"\"\n71         self.id_count = start_value\n72 \n73     def generate_id(self):\n74         \"\"\"generate a new identifier\"\"\"\n75         self.id_count += 1\n76         return self.id_count\n77 \n78 \n79 class Linker(IdGeneratorMixIn, utils.LocalsVisitor):\n80     \"\"\"Walk on the project tree and resolve relationships.\n81 \n82     According to options the following attributes may be\n83     added to visited nodes:\n84 \n85     * uid,\n86       a unique identifier for the node (on astroid.Project, astroid.Module,\n87       astroid.Class and astroid.locals_type). Only if the linker\n88       has been instantiated with tag=True parameter (False by default).\n89 \n90     * Function\n91       a mapping from locals names to their bounded value, which may be a\n92       constant like a string or an integer, or an astroid node\n93       (on astroid.Module, astroid.Class and astroid.Function).\n94 \n95     * instance_attrs_type\n96       as locals_type but for klass member attributes (only on astroid.Class)\n97 \n98     * implements,\n99       list of implemented interface _objects_ (only on astroid.Class nodes)\n100     \"\"\"\n101 \n102     def __init__(self, project, inherited_interfaces=0, tag=False):\n103         IdGeneratorMixIn.__init__(self)\n104         utils.LocalsVisitor.__init__(self)\n105         # take inherited interface in consideration or not\n106         self.inherited_interfaces = inherited_interfaces\n107         # tag nodes or not\n108         self.tag = tag\n109         # visited project\n110         self.project = project\n111 \n112     def visit_project(self, node):\n113         \"\"\"visit a pyreverse.utils.Project node\n114 \n115         * optionally tag the node with a unique id\n116         \"\"\"\n117         if self.tag:\n118             node.uid = self.generate_id()\n119         for module in node.modules:\n120             self.visit(module)\n121 \n122     def visit_package(self, node):\n123         \"\"\"visit an astroid.Package node\n124 \n125         * optionally tag the node with a unique id\n126         \"\"\"\n127         if self.tag:\n128             node.uid = self.generate_id()\n129         for subelmt in node.values():\n130             self.visit(subelmt)\n131 \n132     def visit_module(self, node):\n133         \"\"\"visit an astroid.Module node\n134 \n135         * set the locals_type mapping\n136         * set the depends mapping\n137         * optionally tag the node with a unique id\n138         \"\"\"\n139         if hasattr(node, \"locals_type\"):\n140             return\n141         node.locals_type = collections.defaultdict(list)\n142         node.depends = []\n143         if self.tag:\n144             node.uid = self.generate_id()\n145 \n146     def visit_classdef(self, node):\n147         \"\"\"visit an astroid.Class node\n148 \n149         * set the locals_type and instance_attrs_type mappings\n150         * set the implements list and build it\n151         * optionally tag the node with a unique id\n152         \"\"\"\n153         if hasattr(node, \"locals_type\"):\n154             return\n155         node.locals_type = collections.defaultdict(list)\n156         if self.tag:\n157             node.uid = self.generate_id()\n158         # resolve ancestors\n159         for baseobj in node.ancestors(recurs=False):\n160             specializations = getattr(baseobj, \"specializations\", [])\n161             specializations.append(node)\n162             baseobj.specializations = specializations\n163         # resolve instance attributes\n164         node.instance_attrs_type = collections.defaultdict(list)\n165         for assignattrs in node.instance_attrs.values():\n166             for assignattr in assignattrs:\n167                 if not isinstance(assignattr, astroid.Unknown):\n168                     self.handle_assignattr_type(assignattr, node)\n169         # resolve implemented interface\n170         try:\n171             node.implements = list(interfaces(node, self.inherited_interfaces))\n172         except astroid.InferenceError:\n173             node.implements = ()\n174 \n175     def visit_functiondef(self, node):\n176         \"\"\"visit an astroid.Function node\n177 \n178         * set the locals_type mapping\n179         * optionally tag the node with a unique id\n180         \"\"\"\n181         if hasattr(node, \"locals_type\"):\n182             return\n183         node.locals_type = collections.defaultdict(list)\n184         if self.tag:\n185             node.uid = self.generate_id()\n186 \n187     link_project = visit_project\n188     link_module = visit_module\n189     link_class = visit_classdef\n190     link_function = visit_functiondef\n191 \n192     def visit_assignname(self, node):\n193         \"\"\"visit an astroid.AssignName node\n194 \n195         handle locals_type\n196         \"\"\"\n197         # avoid double parsing done by different Linkers.visit\n198         # running over the same project:\n199         if hasattr(node, \"_handled\"):\n200             return\n201         node._handled = True\n202         if node.name in node.frame():\n203             frame = node.frame()\n204         else:\n205             # the name has been defined as 'global' in the frame and belongs\n206             # there.\n207             frame = node.root()\n208         try:\n209             if not hasattr(frame, \"locals_type\"):\n210                 # If the frame doesn't have a locals_type yet,\n211                 # it means it wasn't yet visited. Visit it now\n212                 # to add what's missing from it.\n213                 if isinstance(frame, astroid.ClassDef):\n214                     self.visit_classdef(frame)\n215                 elif isinstance(frame, astroid.FunctionDef):\n216                     self.visit_functiondef(frame)\n217                 else:\n218                     self.visit_module(frame)\n219 \n220             current = frame.locals_type[node.name]\n221             values = set(node.infer())\n222             frame.locals_type[node.name] = list(set(current) | values)\n223         except astroid.InferenceError:\n224             pass\n225 \n226     @staticmethod\n227     def handle_assignattr_type(node, parent):\n228         \"\"\"handle an astroid.assignattr node\n229 \n230         handle instance_attrs_type\n231         \"\"\"\n232         try:\n233             values = set(node.infer())\n234             current = set(parent.instance_attrs_type[node.attrname])\n235             parent.instance_attrs_type[node.attrname] = list(current | values)\n236         except astroid.InferenceError:\n237             pass\n238 \n239     def visit_import(self, node):\n240         \"\"\"visit an astroid.Import node\n241 \n242         resolve module dependencies\n243         \"\"\"\n244         context_file = node.root().file\n245         for name in node.names:\n246             relative = astroid.modutils.is_relative(name[0], context_file)\n247             self._imported_module(node, name[0], relative)\n248 \n249     def visit_importfrom(self, node):\n250         \"\"\"visit an astroid.ImportFrom node\n251 \n252         resolve module dependencies\n253         \"\"\"\n254         basename = node.modname\n255         context_file = node.root().file\n256         if context_file is not None:\n257             relative = astroid.modutils.is_relative(basename, context_file)\n258         else:\n259             relative = False\n260         for name in node.names:\n261             if name[0] == \"*\":\n262                 continue\n263             # analyze dependencies\n264             fullname = f\"{basename}.{name[0]}\"\n265             if fullname.find(\".\") > -1:\n266                 try:\n267                     fullname = astroid.modutils.get_module_part(fullname, context_file)\n268                 except ImportError:\n269                     continue\n270             if fullname != basename:\n271                 self._imported_module(node, fullname, relative)\n272 \n273     def compute_module(self, context_name, mod_path):\n274         \"\"\"return true if the module should be added to dependencies\"\"\"\n275         package_dir = os.path.dirname(self.project.path)\n276         if context_name == mod_path:\n277             return 0\n278         if astroid.modutils.is_standard_module(mod_path, (package_dir,)):\n279             return 1\n280         return 0\n281 \n282     def _imported_module(self, node, mod_path, relative):\n283         \"\"\"Notify an imported module, used to analyze dependencies\"\"\"\n284         module = node.root()\n285         context_name = module.name\n286         if relative:\n287             mod_path = \"{}.{}\".format(\".\".join(context_name.split(\".\")[:-1]), mod_path)\n288         if self.compute_module(context_name, mod_path):\n289             # handle dependencies\n290             if not hasattr(module, \"depends\"):\n291                 module.depends = []\n292             mod_paths = module.depends\n293             if mod_path not in mod_paths:\n294                 mod_paths.append(mod_path)\n295 \n296 \n297 class Project:\n298     \"\"\"a project handle a set of modules / packages\"\"\"\n299 \n300     def __init__(self, name=\"\"):\n301         self.name = name\n302         self.path = None\n303         self.modules = []\n304         self.locals = {}\n305         self.__getitem__ = self.locals.__getitem__\n306         self.__iter__ = self.locals.__iter__\n307         self.values = self.locals.values\n308         self.keys = self.locals.keys\n309         self.items = self.locals.items\n310 \n311     def add_module(self, node):\n312         self.locals[node.name] = node\n313         self.modules.append(node)\n314 \n315     def get_module(self, name):\n316         return self.locals[name]\n317 \n318     def get_children(self):\n319         return self.modules\n320 \n321     def __repr__(self):\n322         return f\"<Project {self.name!r} at {id(self)} ({len(self.modules)} modules)>\"\n323 \n324 \n325 def project_from_files(\n326     files, func_wrapper=_astroid_wrapper, project_name=\"no name\", black_list=(\"CVS\",)\n327 ):\n328     \"\"\"return a Project from a list of files or modules\"\"\"\n329     # build the project representation\n330     astroid_manager = astroid.manager.AstroidManager()\n331     project = Project(project_name)\n332     for something in files:\n333         if not os.path.exists(something):\n334             fpath = astroid.modutils.file_from_modpath(something.split(\".\"))\n335         elif os.path.isdir(something):\n336             fpath = os.path.join(something, \"__init__.py\")\n337         else:\n338             fpath = something\n339         ast = func_wrapper(astroid_manager.ast_from_file, fpath)\n340         if ast is None:\n341             continue\n342         project.path = project.path or ast.file\n343         project.add_module(ast)\n344         base_name = ast.name\n345         # recurse in package except if __init__ was explicitly given\n346         if ast.package and something.find(\"__init__\") == -1:\n347             # recurse on others packages / modules if this is a package\n348             for fpath in astroid.modutils.get_module_files(\n349                 os.path.dirname(ast.file), black_list\n350             ):\n351                 ast = func_wrapper(astroid_manager.ast_from_file, fpath)\n352                 if ast is None or ast.name == base_name:\n353                     continue\n354                 project.add_module(ast)\n355     return project\n",
        "intended_behavior": "Proper parsing and recognition of type hints in method signatures, including the ability to handle default values like None while retaining the type hint for UML generation."
    },
    {
        "rel_file_path": "pylint/pyreverse/writer.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/pylint-dev__pylint/setup_pylint-dev__pylint__2.9/pylint/pyreverse/writer.py",
        "start": 1,
        "end": 218,
        "class_name": null,
        "method_name": null,
        "code": "1 # Copyright (c) 2008-2010, 2013-2014 LOGILAB S.A. (Paris, FRANCE) <contact@logilab.fr>\n2 # Copyright (c) 2014 Arun Persaud <arun@nubati.net>\n3 # Copyright (c) 2015-2018, 2020 Claudiu Popa <pcmanticore@gmail.com>\n4 # Copyright (c) 2015 Mike Frysinger <vapier@gentoo.org>\n5 # Copyright (c) 2015 Florian Bruhin <me@the-compiler.org>\n6 # Copyright (c) 2015 Ionel Cristian Maries <contact@ionelmc.ro>\n7 # Copyright (c) 2018, 2020 Anthony Sottile <asottile@umich.edu>\n8 # Copyright (c) 2018 ssolanki <sushobhitsolanki@gmail.com>\n9 # Copyright (c) 2019-2021 Pierre Sassoulas <pierre.sassoulas@gmail.com>\n10 # Copyright (c) 2019 Kylian <development@goudcode.nl>\n11 # Copyright (c) 2021 Andreas Finkler <andi.finkler@gmail.com>\n12 # Copyright (c) 2021 Mark Byrne <mbyrnepr2@gmail.com>\n13 \n14 # Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n15 # For details: https://github.com/PyCQA/pylint/blob/master/LICENSE\n16 \n17 \"\"\"Utilities for creating VCG and Dot diagrams\"\"\"\n18 \n19 import os\n20 \n21 from pylint.graph import DotBackend\n22 from pylint.pyreverse.utils import is_exception\n23 from pylint.pyreverse.vcgutils import VCGPrinter\n24 \n25 \n26 class DiagramWriter:\n27     \"\"\"base class for writing project diagrams\"\"\"\n28 \n29     def __init__(self, config, styles):\n30         self.config = config\n31         self.pkg_edges, self.inh_edges, self.imp_edges, self.association_edges = styles\n32         self.printer = None  # defined in set_printer\n33 \n34     def write(self, diadefs):\n35         \"\"\"write files for <project> according to <diadefs>\"\"\"\n36         for diagram in diadefs:\n37             basename = diagram.title.strip().replace(\" \", \"_\")\n38             file_name = f\"{basename}.{self.config.output_format}\"\n39             if os.path.exists(self.config.output_directory):\n40                 file_name = os.path.join(self.config.output_directory, file_name)\n41             self.set_printer(file_name, basename)\n42             if diagram.TYPE == \"class\":\n43                 self.write_classes(diagram)\n44             else:\n45                 self.write_packages(diagram)\n46             self.close_graph()\n47 \n48     def write_packages(self, diagram):\n49         \"\"\"write a package diagram\"\"\"\n50         # sorted to get predictable (hence testable) results\n51         for i, obj in enumerate(sorted(diagram.modules(), key=lambda x: x.title)):\n52             self.printer.emit_node(i, label=self.get_title(obj), shape=\"box\")\n53             obj.fig_id = i\n54         # package dependencies\n55         for rel in diagram.get_relationships(\"depends\"):\n56             self.printer.emit_edge(\n57                 rel.from_object.fig_id, rel.to_object.fig_id, **self.pkg_edges\n58             )\n59 \n60     def write_classes(self, diagram):\n61         \"\"\"write a class diagram\"\"\"\n62         # sorted to get predictable (hence testable) results\n63         for i, obj in enumerate(sorted(diagram.objects, key=lambda x: x.title)):\n64             self.printer.emit_node(i, **self.get_values(obj))\n65             obj.fig_id = i\n66         # inheritance links\n67         for rel in diagram.get_relationships(\"specialization\"):\n68             self.printer.emit_edge(\n69                 rel.from_object.fig_id, rel.to_object.fig_id, **self.inh_edges\n70             )\n71         # implementation links\n72         for rel in diagram.get_relationships(\"implements\"):\n73             self.printer.emit_edge(\n74                 rel.from_object.fig_id, rel.to_object.fig_id, **self.imp_edges\n75             )\n76         # generate associations\n77         for rel in diagram.get_relationships(\"association\"):\n78             self.printer.emit_edge(\n79                 rel.from_object.fig_id,\n80                 rel.to_object.fig_id,\n81                 label=rel.name,\n82                 **self.association_edges,\n83             )\n84 \n85     def set_printer(self, file_name, basename):\n86         \"\"\"set printer\"\"\"\n87         raise NotImplementedError\n88 \n89     def get_title(self, obj):\n90         \"\"\"get project title\"\"\"\n91         raise NotImplementedError\n92 \n93     def get_values(self, obj):\n94         \"\"\"get label and shape for classes.\"\"\"\n95         raise NotImplementedError\n96 \n97     def close_graph(self):\n98         \"\"\"finalize the graph\"\"\"\n99         raise NotImplementedError\n100 \n101 \n102 class DotWriter(DiagramWriter):\n103     \"\"\"write dot graphs from a diagram definition and a project\"\"\"\n104 \n105     def __init__(self, config):\n106         styles = [\n107             dict(arrowtail=\"none\", arrowhead=\"open\"),\n108             dict(arrowtail=\"none\", arrowhead=\"empty\"),\n109             dict(arrowtail=\"node\", arrowhead=\"empty\", style=\"dashed\"),\n110             dict(\n111                 fontcolor=\"green\", arrowtail=\"none\", arrowhead=\"diamond\", style=\"solid\"\n112             ),\n113         ]\n114         DiagramWriter.__init__(self, config, styles)\n115 \n116     def set_printer(self, file_name, basename):\n117         \"\"\"initialize DotWriter and add options for layout.\"\"\"\n118         layout = dict(rankdir=\"BT\")\n119         self.printer = DotBackend(basename, additional_param=layout)\n120         self.file_name = file_name\n121 \n122     def get_title(self, obj):\n123         \"\"\"get project title\"\"\"\n124         return obj.title\n125 \n126     def get_values(self, obj):\n127         \"\"\"get label and shape for classes.\n128 \n129         The label contains all attributes and methods\n130         \"\"\"\n131         label = obj.title\n132         if obj.shape == \"interface\":\n133             label = \"\u00abinterface\u00bb\\\\n%s\" % label\n134         if not self.config.only_classnames:\n135             label = r\"{}|{}\\l|\".format(label, r\"\\l\".join(obj.attrs))\n136             for func in obj.methods:\n137                 if func.args.args:\n138                     args = [arg.name for arg in func.args.args if arg.name != \"self\"]\n139                 else:\n140                     args = []\n141                 label = r\"{}{}({})\\l\".format(label, func.name, \", \".join(args))\n142             label = \"{%s}\" % label\n143         if is_exception(obj.node):\n144             return dict(fontcolor=\"red\", label=label, shape=\"record\")\n145         return dict(label=label, shape=\"record\")\n146 \n147     def close_graph(self):\n148         \"\"\"print the dot graph into <file_name>\"\"\"\n149         self.printer.generate(self.file_name)\n150 \n151 \n152 class VCGWriter(DiagramWriter):\n153     \"\"\"write vcg graphs from a diagram definition and a project\"\"\"\n154 \n155     def __init__(self, config):\n156         styles = [\n157             dict(arrowstyle=\"solid\", backarrowstyle=\"none\", backarrowsize=0),\n158             dict(arrowstyle=\"solid\", backarrowstyle=\"none\", backarrowsize=10),\n159             dict(\n160                 arrowstyle=\"solid\",\n161                 backarrowstyle=\"none\",\n162                 linestyle=\"dotted\",\n163                 backarrowsize=10,\n164             ),\n165             dict(arrowstyle=\"solid\", backarrowstyle=\"none\", textcolor=\"green\"),\n166         ]\n167         DiagramWriter.__init__(self, config, styles)\n168 \n169     def set_printer(self, file_name, basename):\n170         \"\"\"initialize VCGWriter for a UML graph\"\"\"\n171         self.graph_file = open(file_name, \"w+\")  # pylint: disable=consider-using-with\n172         self.printer = VCGPrinter(self.graph_file)\n173         self.printer.open_graph(\n174             title=basename,\n175             layoutalgorithm=\"dfs\",\n176             late_edge_labels=\"yes\",\n177             port_sharing=\"no\",\n178             manhattan_edges=\"yes\",\n179         )\n180         self.printer.emit_node = self.printer.node\n181         self.printer.emit_edge = self.printer.edge\n182 \n183     def get_title(self, obj):\n184         \"\"\"get project title in vcg format\"\"\"\n185         return r\"\\fb%s\\fn\" % obj.title\n186 \n187     def get_values(self, obj):\n188         \"\"\"get label and shape for classes.\n189 \n190         The label contains all attributes and methods\n191         \"\"\"\n192         if is_exception(obj.node):\n193             label = r\"\\fb\\f09%s\\fn\" % obj.title\n194         else:\n195             label = r\"\\fb%s\\fn\" % obj.title\n196         if obj.shape == \"interface\":\n197             shape = \"ellipse\"\n198         else:\n199             shape = \"box\"\n200         if not self.config.only_classnames:\n201             attrs = obj.attrs\n202             methods = [func.name for func in obj.methods]\n203             # box width for UML like diagram\n204             maxlen = max(len(name) for name in [obj.title] + methods + attrs)\n205             line = \"_\" * (maxlen + 2)\n206             label = fr\"{label}\\n\\f{line}\"\n207             for attr in attrs:\n208                 label = fr\"{label}\\n\\f08{attr}\"\n209             if attrs:\n210                 label = fr\"{label}\\n\\f{line}\"\n211             for func in methods:\n212                 label = fr\"{label}\\n\\f10{func}()\"\n213         return dict(label=label, shape=shape)\n214 \n215     def close_graph(self):\n216         \"\"\"close graph and file\"\"\"\n217         self.printer.close_graph()\n218         self.graph_file.close()\n",
        "intended_behavior": "Ensure that when type information is available, it correctly formats this information into the UML output, including representing types as specified in PEP 484 for parameters that have type hints."
    },
    {
        "rel_file_path": "pylint/pyreverse/diagrams.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/pylint-dev__pylint/setup_pylint-dev__pylint__2.9/pylint/pyreverse/diagrams.py",
        "start": 1,
        "end": 255,
        "class_name": null,
        "method_name": null,
        "code": "1 # Copyright (c) 2006, 2008-2010, 2012-2014 LOGILAB S.A. (Paris, FRANCE) <contact@logilab.fr>\n2 # Copyright (c) 2014-2018, 2020 Claudiu Popa <pcmanticore@gmail.com>\n3 # Copyright (c) 2014 Brett Cannon <brett@python.org>\n4 # Copyright (c) 2014 Arun Persaud <arun@nubati.net>\n5 # Copyright (c) 2015 Ionel Cristian Maries <contact@ionelmc.ro>\n6 # Copyright (c) 2018 ssolanki <sushobhitsolanki@gmail.com>\n7 # Copyright (c) 2019-2021 Pierre Sassoulas <pierre.sassoulas@gmail.com>\n8 # Copyright (c) 2020 hippo91 <guillaume.peillex@gmail.com>\n9 \n10 # Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n11 # For details: https://github.com/PyCQA/pylint/blob/master/LICENSE\n12 \n13 \"\"\"diagram objects\n14 \"\"\"\n15 \n16 import astroid\n17 \n18 from pylint.checkers.utils import decorated_with_property\n19 from pylint.pyreverse.utils import FilterMixIn, is_interface\n20 \n21 \n22 class Figure:\n23     \"\"\"base class for counter handling\"\"\"\n24 \n25 \n26 class Relationship(Figure):\n27     \"\"\"a relation ship from an object in the diagram to another\"\"\"\n28 \n29     def __init__(self, from_object, to_object, relation_type, name=None):\n30         Figure.__init__(self)\n31         self.from_object = from_object\n32         self.to_object = to_object\n33         self.type = relation_type\n34         self.name = name\n35 \n36 \n37 class DiagramEntity(Figure):\n38     \"\"\"a diagram object, i.e. a label associated to an astroid node\"\"\"\n39 \n40     def __init__(self, title=\"No name\", node=None):\n41         Figure.__init__(self)\n42         self.title = title\n43         self.node = node\n44 \n45 \n46 class ClassDiagram(Figure, FilterMixIn):\n47     \"\"\"main class diagram handling\"\"\"\n48 \n49     TYPE = \"class\"\n50 \n51     def __init__(self, title, mode):\n52         FilterMixIn.__init__(self, mode)\n53         Figure.__init__(self)\n54         self.title = title\n55         self.objects = []\n56         self.relationships = {}\n57         self._nodes = {}\n58         self.depends = []\n59 \n60     def get_relationships(self, role):\n61         # sorted to get predictable (hence testable) results\n62         return sorted(\n63             self.relationships.get(role, ()),\n64             key=lambda x: (x.from_object.fig_id, x.to_object.fig_id),\n65         )\n66 \n67     def add_relationship(self, from_object, to_object, relation_type, name=None):\n68         \"\"\"create a relation ship\"\"\"\n69         rel = Relationship(from_object, to_object, relation_type, name)\n70         self.relationships.setdefault(relation_type, []).append(rel)\n71 \n72     def get_relationship(self, from_object, relation_type):\n73         \"\"\"return a relation ship or None\"\"\"\n74         for rel in self.relationships.get(relation_type, ()):\n75             if rel.from_object is from_object:\n76                 return rel\n77         raise KeyError(relation_type)\n78 \n79     def get_attrs(self, node):\n80         \"\"\"return visible attributes, possibly with class name\"\"\"\n81         attrs = []\n82         properties = [\n83             (n, m)\n84             for n, m in node.items()\n85             if isinstance(m, astroid.FunctionDef) and decorated_with_property(m)\n86         ]\n87         for node_name, associated_nodes in (\n88             list(node.instance_attrs_type.items())\n89             + list(node.locals_type.items())\n90             + properties\n91         ):\n92             if not self.show_attr(node_name):\n93                 continue\n94             names = self.class_names(associated_nodes)\n95             if names:\n96                 node_name = \"{} : {}\".format(node_name, \", \".join(names))\n97             attrs.append(node_name)\n98         return sorted(attrs)\n99 \n100     def get_methods(self, node):\n101         \"\"\"return visible methods\"\"\"\n102         methods = [\n103             m\n104             for m in node.values()\n105             if isinstance(m, astroid.FunctionDef)\n106             and not decorated_with_property(m)\n107             and self.show_attr(m.name)\n108         ]\n109         return sorted(methods, key=lambda n: n.name)\n110 \n111     def add_object(self, title, node):\n112         \"\"\"create a diagram object\"\"\"\n113         assert node not in self._nodes\n114         ent = DiagramEntity(title, node)\n115         self._nodes[node] = ent\n116         self.objects.append(ent)\n117 \n118     def class_names(self, nodes):\n119         \"\"\"return class names if needed in diagram\"\"\"\n120         names = []\n121         for node in nodes:\n122             if isinstance(node, astroid.Instance):\n123                 node = node._proxied\n124             if (\n125                 isinstance(node, astroid.ClassDef)\n126                 and hasattr(node, \"name\")\n127                 and not self.has_node(node)\n128             ):\n129                 if node.name not in names:\n130                     node_name = node.name\n131                     names.append(node_name)\n132         return names\n133 \n134     def nodes(self):\n135         \"\"\"return the list of underlying nodes\"\"\"\n136         return self._nodes.keys()\n137 \n138     def has_node(self, node):\n139         \"\"\"return true if the given node is included in the diagram\"\"\"\n140         return node in self._nodes\n141 \n142     def object_from_node(self, node):\n143         \"\"\"return the diagram object mapped to node\"\"\"\n144         return self._nodes[node]\n145 \n146     def classes(self):\n147         \"\"\"return all class nodes in the diagram\"\"\"\n148         return [o for o in self.objects if isinstance(o.node, astroid.ClassDef)]\n149 \n150     def classe(self, name):\n151         \"\"\"return a class by its name, raise KeyError if not found\"\"\"\n152         for klass in self.classes():\n153             if klass.node.name == name:\n154                 return klass\n155         raise KeyError(name)\n156 \n157     def extract_relationships(self):\n158         \"\"\"extract relation ships between nodes in the diagram\"\"\"\n159         for obj in self.classes():\n160             node = obj.node\n161             obj.attrs = self.get_attrs(node)\n162             obj.methods = self.get_methods(node)\n163             # shape\n164             if is_interface(node):\n165                 obj.shape = \"interface\"\n166             else:\n167                 obj.shape = \"class\"\n168             # inheritance link\n169             for par_node in node.ancestors(recurs=False):\n170                 try:\n171                     par_obj = self.object_from_node(par_node)\n172                     self.add_relationship(obj, par_obj, \"specialization\")\n173                 except KeyError:\n174                     continue\n175             # implements link\n176             for impl_node in node.implements:\n177                 try:\n178                     impl_obj = self.object_from_node(impl_node)\n179                     self.add_relationship(obj, impl_obj, \"implements\")\n180                 except KeyError:\n181                     continue\n182             # associations link\n183             for name, values in list(node.instance_attrs_type.items()) + list(\n184                 node.locals_type.items()\n185             ):\n186                 for value in values:\n187                     if value is astroid.Uninferable:\n188                         continue\n189                     if isinstance(value, astroid.Instance):\n190                         value = value._proxied\n191                     try:\n192                         associated_obj = self.object_from_node(value)\n193                         self.add_relationship(associated_obj, obj, \"association\", name)\n194                     except KeyError:\n195                         continue\n196 \n197 \n198 class PackageDiagram(ClassDiagram):\n199     \"\"\"package diagram handling\"\"\"\n200 \n201     TYPE = \"package\"\n202 \n203     def modules(self):\n204         \"\"\"return all module nodes in the diagram\"\"\"\n205         return [o for o in self.objects if isinstance(o.node, astroid.Module)]\n206 \n207     def module(self, name):\n208         \"\"\"return a module by its name, raise KeyError if not found\"\"\"\n209         for mod in self.modules():\n210             if mod.node.name == name:\n211                 return mod\n212         raise KeyError(name)\n213 \n214     def get_module(self, name, node):\n215         \"\"\"return a module by its name, looking also for relative imports;\n216         raise KeyError if not found\n217         \"\"\"\n218         for mod in self.modules():\n219             mod_name = mod.node.name\n220             if mod_name == name:\n221                 return mod\n222             # search for fullname of relative import modules\n223             package = node.root().name\n224             if mod_name == f\"{package}.{name}\":\n225                 return mod\n226             if mod_name == \"{}.{}\".format(package.rsplit(\".\", 1)[0], name):\n227                 return mod\n228         raise KeyError(name)\n229 \n230     def add_from_depend(self, node, from_module):\n231         \"\"\"add dependencies created by from-imports\"\"\"\n232         mod_name = node.root().name\n233         obj = self.module(mod_name)\n234         if from_module not in obj.node.depends:\n235             obj.node.depends.append(from_module)\n236 \n237     def extract_relationships(self):\n238         \"\"\"extract relation ships between nodes in the diagram\"\"\"\n239         ClassDiagram.extract_relationships(self)\n240         for obj in self.classes():\n241             # ownership\n242             try:\n243                 mod = self.object_from_node(obj.node.root())\n244                 self.add_relationship(obj, mod, \"ownership\")\n245             except KeyError:\n246                 continue\n247         for obj in self.modules():\n248             obj.shape = \"package\"\n249             # dependencies\n250             for dep_name in obj.node.depends:\n251                 try:\n252                     dep = self.get_module(dep_name, obj.node)\n253                 except KeyError:\n254                     continue\n255                 self.add_relationship(obj, dep, \"depends\")\n",
        "intended_behavior": "Ensuring that attributes (and method parameters) derived from class constructors correctly include type information in their representation in the UML."
    }
]