2025-10-15 20:25:23.672 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-15 20:25:27.129 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=432, output_tokens=12, cost=0.004680
2025-10-15 20:25:35.234 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=612, output_tokens=363, cost=0.017010
2025-10-15 20:25:36.563 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 20:25:43.481 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=734, output_tokens=292, cost=0.016100
2025-10-15 20:25:43.484 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 20:25:45.709 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=646, output_tokens=43, cost=0.007750
2025-10-15 20:25:45.710 | DEBUG    | Extracted a valid json.
2025-10-15 20:25:45.710 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_method(\"sca\")",
        "search_code(\"fig.subfigures\")",
        "search_method(\"figure\")"
    ],
    "bug_locations": []
}
2025-10-15 20:25:45.771 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-15 20:25:45.772 | DEBUG    | <Agent search> Analyzing search results.
2025-10-15 20:26:01.407 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1632, output_tokens=733, cost=0.038310
2025-10-15 20:26:01.424 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 20:26:09.378 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2581, output_tokens=328, cost=0.035650
2025-10-15 20:26:09.386 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 20:26:16.518 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=682, output_tokens=293, cost=0.015610
2025-10-15 20:26:16.519 | DEBUG    | Extracted a valid json.
2025-10-15 20:26:16.519 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "lib/matplotlib/pyplot.py",
            "class": "",
            "method": "sca(ax)",
            "intended_behavior": "The code should correctly handle instances when `ax` is contained within a `SubFigure`, not just a standard `Figure`. Currently, it assumes `ax.figure` can always be directly passed to `figure(ax.figure)`, which fails with `SubFigure` instances due to type errors. The fix should include a check if `ax.figure` is a `SubFigure` instance and handle this case appropriately, possibly by navigating to the parent figure if necessary, without changing the behavior for standard figures."
        },
        {
            "file": "lib/matplotlib/pyplot.py",
            "class": "",
            "method": "figure(num)",
            "intended_behavior": "This method should be extended or adjusted to correctly recognize and handle `SubFigure` objects. When `num` is a `SubFigure`, instead of attempting (and failing) to convert it to an integer, the method should either navigate to its parent figure or directly manage the `SubFigure` without raising a type error. This change will allow `plt.sca()` to be used with axes that are part of subfigures, aligning with the intended seamless usage between figures and axes across different contexts in Matplotlib."
        }
    ]
}
2025-10-15 20:26:16.538 | DEBUG    | Bug location extracted successfully: [<file>lib/matplotlib/pyplot.py</file>
<class>None</class>
<method>None</method>
<code>
1 # Note: The first part of this file can be modified in place, but the latter
2 # part is autogenerated by the boilerplate.py script.
3 
4 """
5 `matplotlib.pyplot` is a state-based interface to matplotlib. It provides
6 an implicit,  MATLAB-like, way of plotting.  It also opens figures on your
7 screen, and acts as the figure GUI manager.
8 
9 pyplot is mainly intended for interactive plots and simple cases of
10 programmatic plot generation::
11 
12     import numpy as np
13     import matplotlib.pyplot as plt
14 
15     x = np.arange(0, 5, 0.1)
16     y = np.sin(x)
17     plt.plot(x, y)
18 
19 The explicit object-oriented API is recommended for complex plots, though
20 pyplot is still usually used to create the figure and often the axes in the
21 figure. See `.pyplot.figure`, `.pyplot.subplots`, and
22 `.pyplot.subplot_mosaic` to create figures, and
23 :doc:`Axes API <../axes_api>` for the plotting methods on an Axes::
24 
25     import numpy as np
26     import matplotlib.pyplot as plt
27 
28     x = np.arange(0, 5, 0.1)
29     y = np.sin(x)
30     fig, ax = plt.subplots()
31     ax.plot(x, y)
32 
33 
34 See :ref:`api_interfaces` for an explanation of the tradeoffs between the
35 implicit and explicit interfaces.
36 """
37 
38 from enum import Enum
39 import functools
40 import importlib
41 import inspect
42 import logging
43 from numbers import Number
44 import re
45 import sys
46 import time
47 try:
48     import threading
49 except ImportError:
50     import dummy_threading as threading
51 
52 from cycler import cycler
53 import matplotlib
54 import matplotlib.colorbar
55 import matplotlib.image
56 from matplotlib import _api
57 from matplotlib import rcsetup, style
58 from matplotlib import _pylab_helpers, interactive
59 from matplotlib import cbook
60 from matplotlib import _docstring
61 from matplotlib.backend_bases import FigureCanvasBase, MouseButton
62 from matplotlib.figure import Figure, figaspect
63 from matplotlib.gridspec import GridSpec, SubplotSpec
64 from matplotlib import rcParams, rcParamsDefault, get_backend, rcParamsOrig
65 from matplotlib.rcsetup import interactive_bk as _interactive_bk
66 from matplotlib.artist import Artist
67 from matplotlib.axes import Axes, Subplot
68 from matplotlib.projections import PolarAxes
69 from matplotlib import mlab  # for detrend_none, window_hanning
70 from matplotlib.scale import get_scale_names
71 
72 from matplotlib import cm
73 from matplotlib.cm import _colormaps as colormaps, get_cmap, register_cmap
74 from matplotlib.colors import _color_sequences as color_sequences
75 
76 import numpy as np
77 
78 # We may not need the following imports here:
79 from matplotlib.colors import Normalize
80 from matplotlib.lines import Line2D
81 from matplotlib.text import Text, Annotation
82 from matplotlib.patches import Polygon, Rectangle, Circle, Arrow
83 from matplotlib.widgets import Button, Slider, Widget
84 
85 from .ticker import (
86     TickHelper, Formatter, FixedFormatter, NullFormatter, FuncFormatter,
87     FormatStrFormatter, ScalarFormatter, LogFormatter, LogFormatterExponent,
88     LogFormatterMathtext, Locator, IndexLocator, FixedLocator, NullLocator,
89     LinearLocator, LogLocator, AutoLocator, MultipleLocator, MaxNLocator)
90 
91 _log = logging.getLogger(__name__)
92 
93 
94 def _copy_docstring_and_deprecators(method, func=None):
95     if func is None:
96         return functools.partial(_copy_docstring_and_deprecators, method)
97     decorators = [_docstring.copy(method)]
98     # Check whether the definition of *method* includes @_api.rename_parameter
99     # or @_api.make_keyword_only decorators; if so, propagate them to the
100     # pyplot wrapper as well.
101     while getattr(method, "__wrapped__", None) is not None:
102         decorator = _api.deprecation.DECORATORS.get(method)
103         if decorator:
104             decorators.append(decorator)
105         method = method.__wrapped__
106     for decorator in decorators[::-1]:
107         func = decorator(func)
108     return func
109 
110 
111 ## Global ##
112 
113 
114 # The state controlled by {,un}install_repl_displayhook().
115 _ReplDisplayHook = Enum("_ReplDisplayHook", ["NONE", "PLAIN", "IPYTHON"])
116 _REPL_DISPLAYHOOK = _ReplDisplayHook.NONE
117 
118 
119 def _draw_all_if_interactive():
120     if matplotlib.is_interactive():
121         draw_all()
122 
123 
124 def install_repl_displayhook():
125     """
126     Connect to the display hook of the current shell.
127 
128     The display hook gets called when the read-evaluate-print-loop (REPL) of
129     the shell has finished the execution of a command. We use this callback
130     to be able to automatically update a figure in interactive mode.
131 
132     This works both with IPython and with vanilla python shells.
133     """
134     global _REPL_DISPLAYHOOK
135 
136     if _REPL_DISPLAYHOOK is _ReplDisplayHook.IPYTHON:
137         return
138 
139     # See if we have IPython hooks around, if so use them.
140     # Use ``sys.modules.get(name)`` rather than ``name in sys.modules`` as
141     # entries can also have been explicitly set to None.
142     mod_ipython = sys.modules.get("IPython")
143     if not mod_ipython:
144         _REPL_DISPLAYHOOK = _ReplDisplayHook.PLAIN
145         return
146     ip = mod_ipython.get_ipython()
147     if not ip:
148         _REPL_DISPLAYHOOK = _ReplDisplayHook.PLAIN
149         return
150 
151     ip.events.register("post_execute", _draw_all_if_interactive)
152     _REPL_DISPLAYHOOK = _ReplDisplayHook.IPYTHON
153 
154     from IPython.core.pylabtools import backend2gui
155     # trigger IPython's eventloop integration, if available
156     ipython_gui_name = backend2gui.get(get_backend())
157     if ipython_gui_name:
158         ip.enable_gui(ipython_gui_name)
159 
160 
161 def uninstall_repl_displayhook():
162     """Disconnect from the display hook of the current shell."""
163     global _REPL_DISPLAYHOOK
164     if _REPL_DISPLAYHOOK is _ReplDisplayHook.IPYTHON:
165         from IPython import get_ipython
166         ip = get_ipython()
167         ip.events.unregister("post_execute", _draw_all_if_interactive)
168     _REPL_DISPLAYHOOK = _ReplDisplayHook.NONE
169 
170 
171 draw_all = _pylab_helpers.Gcf.draw_all
172 
173 
174 @_copy_docstring_and_deprecators(matplotlib.set_loglevel)
175 def set_loglevel(*args, **kwargs):  # Ensure this appears in the pyplot docs.
176     return matplotlib.set_loglevel(*args, **kwargs)
177 
178 
179 @_copy_docstring_and_deprecators(Artist.findobj)
180 def findobj(o=None, match=None, include_self=True):
181     if o is None:
182         o = gcf()
183     return o.findobj(match, include_self=include_self)
184 
185 
186 def _get_required_interactive_framework(backend_mod):
187     if not hasattr(backend_mod.FigureCanvas, "required_interactive_framework"):
188         _api.warn_deprecated(
189             "3.6", name="Support for FigureCanvases without a "
190             "required_interactive_framework attribute")
191         return None
192     # Inline this once the deprecation elapses.
193     return backend_mod.FigureCanvas.required_interactive_framework
194 
195 _backend_mod = None
196 
197 
198 def _get_backend_mod():
199     """
200     Ensure that a backend is selected and return it.
201 
202     This is currently private, but may be made public in the future.
203     """
204     if _backend_mod is None:
205         # Use __getitem__ here to avoid going through the fallback logic (which
206         # will (re)import pyplot and then call switch_backend if we need to
207         # resolve the auto sentinel)
208         switch_backend(dict.__getitem__(rcParams, "backend"))
209         # Just to be safe.  Interactive mode can be turned on without calling
210         # `plt.ion()` so register it again here.  This is safe because multiple
211         # calls to `install_repl_displayhook` are no-ops and the registered
212         # function respects `mpl.is_interactive()` to determine if it should
213         # trigger a draw.
214         install_repl_displayhook()
215     return _backend_mod
216 
217 
218 def switch_backend(newbackend):
219     """
220     Close all open figures and set the Matplotlib backend.
221 
222     The argument is case-insensitive.  Switching to an interactive backend is
223     possible only if no event loop for another interactive backend has started.
224     Switching to and from non-interactive backends is always possible.
225 
226     Parameters
227     ----------
228     newbackend : str
229         The name of the backend to use.
230     """
231     global _backend_mod
232     # make sure the init is pulled up so we can assign to it later
233     import matplotlib.backends
234     close("all")
235 
236     if newbackend is rcsetup._auto_backend_sentinel:
237         current_framework = cbook._get_running_interactive_framework()
238         mapping = {'qt': 'qtagg',
239                    'gtk3': 'gtk3agg',
240                    'gtk4': 'gtk4agg',
241                    'wx': 'wxagg',
242                    'tk': 'tkagg',
243                    'macosx': 'macosx',
244                    'headless': 'agg'}
245 
246         best_guess = mapping.get(current_framework, None)
247         if best_guess is not None:
248             candidates = [best_guess]
249         else:
250             candidates = []
251         candidates += [
252             "macosx", "qtagg", "gtk4agg", "gtk3agg", "tkagg", "wxagg"]
253 
254         # Don't try to fallback on the cairo-based backends as they each have
255         # an additional dependency (pycairo) over the agg-based backend, and
256         # are of worse quality.
257         for candidate in candidates:
258             try:
259                 switch_backend(candidate)
260             except ImportError:
261                 continue
262             else:
263                 rcParamsOrig['backend'] = candidate
264                 return
265         else:
266             # Switching to Agg should always succeed; if it doesn't, let the
267             # exception propagate out.
268             switch_backend("agg")
269             rcParamsOrig["backend"] = "agg"
270             return
271 
272     # Backends are implemented as modules, but "inherit" default method
273     # implementations from backend_bases._Backend.  This is achieved by
274     # creating a "class" that inherits from backend_bases._Backend and whose
275     # body is filled with the module's globals.
276 
277     backend_name = cbook._backend_module_name(newbackend)
278 
279     class backend_mod(matplotlib.backend_bases._Backend):
280         locals().update(vars(importlib.import_module(backend_name)))
281 
282     required_framework = _get_required_interactive_framework(backend_mod)
283     if required_framework is not None:
284         current_framework = cbook._get_running_interactive_framework()
285         if (current_framework and required_framework
286                 and current_framework != required_framework):
287             raise ImportError(
288                 "Cannot load backend {!r} which requires the {!r} interactive "
289                 "framework, as {!r} is currently running".format(
290                     newbackend, required_framework, current_framework))
291 
292     _log.debug("Loaded backend %s version %s.",
293                newbackend, backend_mod.backend_version)
294 
295     rcParams['backend'] = rcParamsDefault['backend'] = newbackend
296     _backend_mod = backend_mod
297     for func_name in ["new_figure_manager", "draw_if_interactive", "show"]:
298         globals()[func_name].__signature__ = inspect.signature(
299             getattr(backend_mod, func_name))
300 
301     # Need to keep a global reference to the backend for compatibility reasons.
302     # See https://github.com/matplotlib/matplotlib/issues/6092
303     matplotlib.backends.backend = newbackend
304 
305 
306 def _warn_if_gui_out_of_main_thread():
307     if (_get_required_interactive_framework(_get_backend_mod())
308             and threading.current_thread() is not threading.main_thread()):
309         _api.warn_external(
310             "Starting a Matplotlib GUI outside of the main thread will likely "
311             "fail.")
312 
313 
314 # This function's signature is rewritten upon backend-load by switch_backend.
315 def new_figure_manager(*args, **kwargs):
316     """Create a new figure manager instance."""
317     _warn_if_gui_out_of_main_thread()
318     return _get_backend_mod().new_figure_manager(*args, **kwargs)
319 
320 
321 # This function's signature is rewritten upon backend-load by switch_backend.
322 def draw_if_interactive(*args, **kwargs):
323     """
324     Redraw the current figure if in interactive mode.
325 
326     .. warning::
327 
328         End users will typically not have to call this function because the
329         the interactive mode takes care of this.
330     """
331     return _get_backend_mod().draw_if_interactive(*args, **kwargs)
332 
333 
334 # This function's signature is rewritten upon backend-load by switch_backend.
335 def show(*args, **kwargs):
336     """
337     Display all open figures.
338 
339     Parameters
340     ----------
341     block : bool, optional
342         Whether to wait for all figures to be closed before returning.
343 
344         If `True` block and run the GUI main loop until all figure windows
345         are closed.
346 
347         If `False` ensure that all figure windows are displayed and return
348         immediately.  In this case, you are responsible for ensuring
349         that the event loop is running to have responsive figures.
350 
351         Defaults to True in non-interactive mode and to False in interactive
352         mode (see `.pyplot.isinteractive`).
353 
354     See Also
355     --------
356     ion : Enable interactive mode, which shows / updates the figure after
357           every plotting command, so that calling ``show()`` is not necessary.
358     ioff : Disable interactive mode.
359     savefig : Save the figure to an image file instead of showing it on screen.
360 
361     Notes
362     -----
363     **Saving figures to file and showing a window at the same time**
364 
365     If you want an image file as well as a user interface window, use
366     `.pyplot.savefig` before `.pyplot.show`. At the end of (a blocking)
367     ``show()`` the figure is closed and thus unregistered from pyplot. Calling
368     `.pyplot.savefig` afterwards would save a new and thus empty figure. This
369     limitation of command order does not apply if the show is non-blocking or
370     if you keep a reference to the figure and use `.Figure.savefig`.
371 
372     **Auto-show in jupyter notebooks**
373 
374     The jupyter backends (activated via ``%matplotlib inline``,
375     ``%matplotlib notebook``, or ``%matplotlib widget``), call ``show()`` at
376     the end of every cell by default. Thus, you usually don't have to call it
377     explicitly there.
378     """
379     _warn_if_gui_out_of_main_thread()
380     return _get_backend_mod().show(*args, **kwargs)
381 
382 
383 def isinteractive():
384     """
385     Return whether plots are updated after every plotting command.
386 
387     The interactive mode is mainly useful if you build plots from the command
388     line and want to see the effect of each command while you are building the
389     figure.
390 
391     In interactive mode:
392 
393     - newly created figures will be shown immediately;
394     - figures will automatically redraw on change;
395     - `.pyplot.show` will not block by default.
396 
397     In non-interactive mode:
398 
399     - newly created figures and changes to figures will not be reflected until
400       explicitly asked to be;
401     - `.pyplot.show` will block by default.
402 
403     See Also
404     --------
405     ion : Enable interactive mode.
406     ioff : Disable interactive mode.
407     show : Show all figures (and maybe block).
408     pause : Show all figures, and block for a time.
409     """
410     return matplotlib.is_interactive()
411 
412 
413 class _IoffContext:
414     """
415     Context manager for `.ioff`.
416 
417     The state is changed in ``__init__()`` instead of ``__enter__()``. The
418     latter is a no-op. This allows using `.ioff` both as a function and
419     as a context.
420     """
421 
422     def __init__(self):
423         self.wasinteractive = isinteractive()
424         matplotlib.interactive(False)
425         uninstall_repl_displayhook()
426 
427     def __enter__(self):
428         pass
429 
430     def __exit__(self, exc_type, exc_value, traceback):
431         if self.wasinteractive:
432             matplotlib.interactive(True)
433             install_repl_displayhook()
434         else:
435             matplotlib.interactive(False)
436             uninstall_repl_displayhook()
437 
438 
439 class _IonContext:
440     """
441     Context manager for `.ion`.
442 
443     The state is changed in ``__init__()`` instead of ``__enter__()``. The
444     latter is a no-op. This allows using `.ion` both as a function and
445     as a context.
446     """
447 
448     def __init__(self):
449         self.wasinteractive = isinteractive()
450         matplotlib.interactive(True)
451         install_repl_displayhook()
452 
453     def __enter__(self):
454         pass
455 
456     def __exit__(self, exc_type, exc_value, traceback):
457         if not self.wasinteractive:
458             matplotlib.interactive(False)
459             uninstall_repl_displayhook()
460         else:
461             matplotlib.interactive(True)
462             install_repl_displayhook()
463 
464 
465 def ioff():
466     """
467     Disable interactive mode.
468 
469     See `.pyplot.isinteractive` for more details.
470 
471     See Also
472     --------
473     ion : Enable interactive mode.
474     isinteractive : Whether interactive mode is enabled.
475     show : Show all figures (and maybe block).
476     pause : Show all figures, and block for a time.
477 
478     Notes
479     -----
480     For a temporary change, this can be used as a context manager::
481 
482         # if interactive mode is on
483         # then figures will be shown on creation
484         plt.ion()
485         # This figure will be shown immediately
486         fig = plt.figure()
487 
488         with plt.ioff():
489             # interactive mode will be off
490             # figures will not automatically be shown
491             fig2 = plt.figure()
492             # ...
493 
494     To enable usage as a context manager, this function returns an
495     ``_IoffContext`` object. The return value is not intended to be stored
496     or accessed by the user.
497     """
498     return _IoffContext()
499 
500 
501 def ion():
502     """
503     Enable interactive mode.
504 
505     See `.pyplot.isinteractive` for more details.
506 
507     See Also
508     --------
509     ioff : Disable interactive mode.
510     isinteractive : Whether interactive mode is enabled.
511     show : Show all figures (and maybe block).
512     pause : Show all figures, and block for a time.
513 
514     Notes
515     -----
516     For a temporary change, this can be used as a context manager::
517 
518         # if interactive mode is off
519         # then figures will not be shown on creation
520         plt.ioff()
521         # This figure will not be shown immediately
522         fig = plt.figure()
523 
524         with plt.ion():
525             # interactive mode will be on
526             # figures will automatically be shown
527             fig2 = plt.figure()
528             # ...
529 
530     To enable usage as a context manager, this function returns an
531     ``_IonContext`` object. The return value is not intended to be stored
532     or accessed by the user.
533     """
534     return _IonContext()
535 
536 
537 def pause(interval):
538     """
539     Run the GUI event loop for *interval* seconds.
540 
541     If there is an active figure, it will be updated and displayed before the
542     pause, and the GUI event loop (if any) will run during the pause.
543 
544     This can be used for crude animation.  For more complex animation use
545     :mod:`matplotlib.animation`.
546 
547     If there is no active figure, sleep for *interval* seconds instead.
548 
549     See Also
550     --------
551     matplotlib.animation : Proper animations
552     show : Show all figures and optional block until all figures are closed.
553     """
554     manager = _pylab_helpers.Gcf.get_active()
555     if manager is not None:
556         canvas = manager.canvas
557         if canvas.figure.stale:
558             canvas.draw_idle()
559         show(block=False)
560         canvas.start_event_loop(interval)
561     else:
562         time.sleep(interval)
563 
564 
565 @_copy_docstring_and_deprecators(matplotlib.rc)
566 def rc(group, **kwargs):
567     matplotlib.rc(group, **kwargs)
568 
569 
570 @_copy_docstring_and_deprecators(matplotlib.rc_context)
571 def rc_context(rc=None, fname=None):
572     return matplotlib.rc_context(rc, fname)
573 
574 
575 @_copy_docstring_and_deprecators(matplotlib.rcdefaults)
576 def rcdefaults():
577     matplotlib.rcdefaults()
578     if matplotlib.is_interactive():
579         draw_all()
580 
581 
582 # getp/get/setp are explicitly reexported so that they show up in pyplot docs.
583 
584 
585 @_copy_docstring_and_deprecators(matplotlib.artist.getp)
586 def getp(obj, *args, **kwargs):
587     return matplotlib.artist.getp(obj, *args, **kwargs)
588 
589 
590 @_copy_docstring_and_deprecators(matplotlib.artist.get)
591 def get(obj, *args, **kwargs):
592     return matplotlib.artist.get(obj, *args, **kwargs)
593 
594 
595 @_copy_docstring_and_deprecators(matplotlib.artist.setp)
596 def setp(obj, *args, **kwargs):
597     return matplotlib.artist.setp(obj, *args, **kwargs)
598 
599 
600 def xkcd(scale=1, length=100, randomness=2):
601     """
602     Turn on `xkcd <https://xkcd.com/>`_ sketch-style drawing mode.  This will
603     only have effect on things drawn after this function is called.
604 
605     For best results, the "Humor Sans" font should be installed: it is
606     not included with Matplotlib.
607 
608     Parameters
609     ----------
610     scale : float, optional
611         The amplitude of the wiggle perpendicular to the source line.
612     length : float, optional
613         The length of the wiggle along the line.
614     randomness : float, optional
615         The scale factor by which the length is shrunken or expanded.
616 
617     Notes
618     -----
619     This function works by a number of rcParams, so it will probably
620     override others you have set before.
621 
622     If you want the effects of this function to be temporary, it can
623     be used as a context manager, for example::
624 
625         with plt.xkcd():
626             # This figure will be in XKCD-style
627             fig1 = plt.figure()
628             # ...
629 
630         # This figure will be in regular style
631         fig2 = plt.figure()
632     """
633     return _xkcd(scale, length, randomness)
634 
635 
636 class _xkcd:
637     # This cannot be implemented in terms of rc_context() because this needs to
638     # work as a non-contextmanager too.
639 
640     def __init__(self, scale, length, randomness):
641         self._orig = rcParams.copy()
642 
643         if rcParams['text.usetex']:
644             raise RuntimeError(
645                 "xkcd mode is not compatible with text.usetex = True")
646 
647         from matplotlib import patheffects
648         rcParams.update({
649             'font.family': ['xkcd', 'xkcd Script', 'Humor Sans', 'Comic Neue',
650                             'Comic Sans MS'],
651             'font.size': 14.0,
652             'path.sketch': (scale, length, randomness),
653             'path.effects': [
654                 patheffects.withStroke(linewidth=4, foreground="w")],
655             'axes.linewidth': 1.5,
656             'lines.linewidth': 2.0,
657             'figure.facecolor': 'white',
658             'grid.linewidth': 0.0,
659             'axes.grid': False,
660             'axes.unicode_minus': False,
661             'axes.edgecolor': 'black',
662             'xtick.major.size': 8,
663             'xtick.major.width': 3,
664             'ytick.major.size': 8,
665             'ytick.major.width': 3,
666         })
667 
668     def __enter__(self):
669         return self
670 
671     def __exit__(self, *args):
672         dict.update(rcParams, self._orig)
673 
674 
675 ## Figures ##
676 
677 @_api.make_keyword_only("3.6", "facecolor")
678 def figure(num=None,  # autoincrement if None, else integer from 1-N
679            figsize=None,  # defaults to rc figure.figsize
680            dpi=None,  # defaults to rc figure.dpi
681            facecolor=None,  # defaults to rc figure.facecolor
682            edgecolor=None,  # defaults to rc figure.edgecolor
683            frameon=True,
684            FigureClass=Figure,
685            clear=False,
686            **kwargs
687            ):
688     """
689     Create a new figure, or activate an existing figure.
690 
691     Parameters
692     ----------
693     num : int or str or `.Figure`, optional
694         A unique identifier for the figure.
695 
696         If a figure with that identifier already exists, this figure is made
697         active and returned. An integer refers to the ``Figure.number``
698         attribute, a string refers to the figure label.
699 
700         If there is no figure with the identifier or *num* is not given, a new
701         figure is created, made active and returned.  If *num* is an int, it
702         will be used for the ``Figure.number`` attribute, otherwise, an
703         auto-generated integer value is used (starting at 1 and incremented
704         for each new figure). If *num* is a string, the figure label and the
705         window title is set to this value.
706 
707     figsize : (float, float), default: :rc:`figure.figsize`
708         Width, height in inches.
709 
710     dpi : float, default: :rc:`figure.dpi`
711         The resolution of the figure in dots-per-inch.
712 
713     facecolor : color, default: :rc:`figure.facecolor`
714         The background color.
715 
716     edgecolor : color, default: :rc:`figure.edgecolor`
717         The border color.
718 
719     frameon : bool, default: True
720         If False, suppress drawing the figure frame.
721 
722     FigureClass : subclass of `~matplotlib.figure.Figure`
723         If set, an instance of this subclass will be created, rather than a
724         plain `.Figure`.
725 
726     clear : bool, default: False
727         If True and the figure already exists, then it is cleared.
728 
729     layout : {'constrained', 'tight', `.LayoutEngine`, None}, default: None
730         The layout mechanism for positioning of plot elements to avoid
731         overlapping Axes decorations (labels, ticks, etc). Note that layout
732         managers can measurably slow down figure display. Defaults to *None*
733         (but see the documentation of the `.Figure` constructor regarding the
734         interaction with rcParams).
735 
736     **kwargs
737         Additional keyword arguments are passed to the `.Figure` constructor.
738 
739     Returns
740     -------
741     `~matplotlib.figure.Figure`
742 
743     Notes
744     -----
745     Newly created figures will be passed to the
746     `~.backend_template.new_figure_manager` function provided by the current
747     backend, which will install a canvas and a manager on the figure.
748 
749     If you are creating many figures, make sure you explicitly call
750     `.pyplot.close` on the figures you are not using, because this will
751     enable pyplot to properly clean up the memory.
752 
753     `~matplotlib.rcParams` defines the default values, which can be modified
754     in the matplotlibrc file.
755     """
756     if isinstance(num, Figure):
757         if num.canvas.manager is None:
758             raise ValueError("The passed figure is not managed by pyplot")
759         _pylab_helpers.Gcf.set_active(num.canvas.manager)
760         return num
761 
762     allnums = get_fignums()
763     next_num = max(allnums) + 1 if allnums else 1
764     fig_label = ''
765     if num is None:
766         num = next_num
767     elif isinstance(num, str):
768         fig_label = num
769         all_labels = get_figlabels()
770         if fig_label not in all_labels:
771             if fig_label == 'all':
772                 _api.warn_external("close('all') closes all existing figures.")
773             num = next_num
774         else:
775             inum = all_labels.index(fig_label)
776             num = allnums[inum]
777     else:
778         num = int(num)  # crude validation of num argument
779 
780     manager = _pylab_helpers.Gcf.get_fig_manager(num)
781     if manager is None:
782         max_open_warning = rcParams['figure.max_open_warning']
783         if len(allnums) == max_open_warning >= 1:
784             _api.warn_external(
785                 f"More than {max_open_warning} figures have been opened. "
786                 f"Figures created through the pyplot interface "
787                 f"(`matplotlib.pyplot.figure`) are retained until explicitly "
788                 f"closed and may consume too much memory. (To control this "
789                 f"warning, see the rcParam `figure.max_open_warning`).",
790                 RuntimeWarning)
791 
792         manager = new_figure_manager(
793             num, figsize=figsize, dpi=dpi,
794             facecolor=facecolor, edgecolor=edgecolor, frameon=frameon,
795             FigureClass=FigureClass, **kwargs)
796         fig = manager.canvas.figure
797         if fig_label:
798             fig.set_label(fig_label)
799 
800         _pylab_helpers.Gcf._set_new_active_manager(manager)
801 
802         # make sure backends (inline) that we don't ship that expect this
803         # to be called in plotting commands to make the figure call show
804         # still work.  There is probably a better way to do this in the
805         # FigureManager base class.
806         draw_if_interactive()
807 
808         if _REPL_DISPLAYHOOK is _ReplDisplayHook.PLAIN:
809             fig.stale_callback = _auto_draw_if_interactive
810 
811     if clear:
812         manager.canvas.figure.clear()
813 
814     return manager.canvas.figure
815 
816 
817 def _auto_draw_if_interactive(fig, val):
818     """
819     An internal helper function for making sure that auto-redrawing
820     works as intended in the plain python repl.
821 
822     Parameters
823     ----------
824     fig : Figure
825         A figure object which is assumed to be associated with a canvas
826     """
827     if (val and matplotlib.is_interactive()
828             and not fig.canvas.is_saving()
829             and not fig.canvas._is_idle_drawing):
830         # Some artists can mark themselves as stale in the middle of drawing
831         # (e.g. axes position & tick labels being computed at draw time), but
832         # this shouldn't trigger a redraw because the current redraw will
833         # already take them into account.
834         with fig.canvas._idle_draw_cntx():
835             fig.canvas.draw_idle()
836 
837 
838 def gcf():
839     """
840     Get the current figure.
841 
842     If there is currently no figure on the pyplot figure stack, a new one is
843     created using `~.pyplot.figure()`.  (To test whether there is currently a
844     figure on the pyplot figure stack, check whether `~.pyplot.get_fignums()`
845     is empty.)
846     """
847     manager = _pylab_helpers.Gcf.get_active()
848     if manager is not None:
849         return manager.canvas.figure
850     else:
851         return figure()
852 
853 
854 def fignum_exists(num):
855     """Return whether the figure with the given id exists."""
856     return _pylab_helpers.Gcf.has_fignum(num) or num in get_figlabels()
857 
858 
859 def get_fignums():
860     """Return a list of existing figure numbers."""
861     return sorted(_pylab_helpers.Gcf.figs)
862 
863 
864 def get_figlabels():
865     """Return a list of existing figure labels."""
866     managers = _pylab_helpers.Gcf.get_all_fig_managers()
867     managers.sort(key=lambda m: m.num)
868     return [m.canvas.figure.get_label() for m in managers]
869 
870 
871 def get_current_fig_manager():
872     """
873     Return the figure manager of the current figure.
874 
875     The figure manager is a container for the actual backend-depended window
876     that displays the figure on screen.
877 
878     If no current figure exists, a new one is created, and its figure
879     manager is returned.
880 
881     Returns
882     -------
883     `.FigureManagerBase` or backend-dependent subclass thereof
884     """
885     return gcf().canvas.manager
886 
887 
888 @_copy_docstring_and_deprecators(FigureCanvasBase.mpl_connect)
889 def connect(s, func):
890     return gcf().canvas.mpl_connect(s, func)
891 
892 
893 @_copy_docstring_and_deprecators(FigureCanvasBase.mpl_disconnect)
894 def disconnect(cid):
895     return gcf().canvas.mpl_disconnect(cid)
896 
897 
898 def close(fig=None):
899     """
900     Close a figure window.
901 
902     Parameters
903     ----------
904     fig : None or int or str or `.Figure`
905         The figure to close. There are a number of ways to specify this:
906 
907         - *None*: the current figure
908         - `.Figure`: the given `.Figure` instance
909         - ``int``: a figure number
910         - ``str``: a figure name
911         - 'all': all figures
912 
913     """
914     if fig is None:
915         manager = _pylab_helpers.Gcf.get_active()
916         if manager is None:
917             return
918         else:
919             _pylab_helpers.Gcf.destroy(manager)
920     elif fig == 'all':
921         _pylab_helpers.Gcf.destroy_all()
922     elif isinstance(fig, int):
923         _pylab_helpers.Gcf.destroy(fig)
924     elif hasattr(fig, 'int'):
925         # if we are dealing with a type UUID, we
926         # can use its integer representation
927         _pylab_helpers.Gcf.destroy(fig.int)
928     elif isinstance(fig, str):
929         all_labels = get_figlabels()
930         if fig in all_labels:
931             num = get_fignums()[all_labels.index(fig)]
932             _pylab_helpers.Gcf.destroy(num)
933     elif isinstance(fig, Figure):
934         _pylab_helpers.Gcf.destroy_fig(fig)
935     else:
936         raise TypeError("close() argument must be a Figure, an int, a string, "
937                         "or None, not %s" % type(fig))
938 
939 
940 def clf():
941     """Clear the current figure."""
942     gcf().clear()
943 
944 
945 def draw():
946     """
947     Redraw the current figure.
948 
949     This is used to update a figure that has been altered, but not
950     automatically re-drawn.  If interactive mode is on (via `.ion()`), this
951     should be only rarely needed, but there may be ways to modify the state of
952     a figure without marking it as "stale".  Please report these cases as bugs.
953 
954     This is equivalent to calling ``fig.canvas.draw_idle()``, where ``fig`` is
955     the current figure.
956     """
957     gcf().canvas.draw_idle()
958 
959 
960 @_copy_docstring_and_deprecators(Figure.savefig)
961 def savefig(*args, **kwargs):
962     fig = gcf()
963     res = fig.savefig(*args, **kwargs)
964     fig.canvas.draw_idle()  # Need this if 'transparent=True', to reset colors.
965     return res
966 
967 
968 ## Putting things in figures ##
969 
970 
971 def figlegend(*args, **kwargs):
972     return gcf().legend(*args, **kwargs)
973 if Figure.legend.__doc__:
974     figlegend.__doc__ = Figure.legend.__doc__.replace("legend(", "figlegend(")
975 
976 
977 ## Axes ##
978 
979 @_docstring.dedent_interpd
980 def axes(arg=None, **kwargs):
981     """
982     Add an Axes to the current figure and make it the current Axes.
983 
984     Call signatures::
985 
986         plt.axes()
987         plt.axes(rect, projection=None, polar=False, **kwargs)
988         plt.axes(ax)
989 
990     Parameters
991     ----------
992     arg : None or 4-tuple
993         The exact behavior of this function depends on the type:
994 
995         - *None*: A new full window Axes is added using
996           ``subplot(**kwargs)``.
997         - 4-tuple of floats *rect* = ``[left, bottom, width, height]``.
998           A new Axes is added with dimensions *rect* in normalized
999           (0, 1) units using `~.Figure.add_axes` on the current figure.
1000 
1001     projection : {None, 'aitoff', 'hammer', 'lambert', 'mollweide', \
1002 'polar', 'rectilinear', str}, optional
1003         The projection type of the `~.axes.Axes`. *str* is the name of
1004         a custom projection, see `~matplotlib.projections`. The default
1005         None results in a 'rectilinear' projection.
1006 
1007     polar : bool, default: False
1008         If True, equivalent to projection='polar'.
1009 
1010     sharex, sharey : `~.axes.Axes`, optional
1011         Share the x or y `~matplotlib.axis` with sharex and/or sharey.
1012         The axis will have the same limits, ticks, and scale as the axis
1013         of the shared Axes.
1014 
1015     label : str
1016         A label for the returned Axes.
1017 
1018     Returns
1019     -------
1020     `~.axes.Axes`, or a subclass of `~.axes.Axes`
1021         The returned axes class depends on the projection used. It is
1022         `~.axes.Axes` if rectilinear projection is used and
1023         `.projections.polar.PolarAxes` if polar projection is used.
1024 
1025     Other Parameters
1026     ----------------
1027     **kwargs
1028         This method also takes the keyword arguments for
1029         the returned Axes class. The keyword arguments for the
1030         rectilinear Axes class `~.axes.Axes` can be found in
1031         the following table but there might also be other keyword
1032         arguments if another projection is used, see the actual Axes
1033         class.
1034 
1035         %(Axes:kwdoc)s
1036 
1037     Notes
1038     -----
1039     If the figure already has an Axes with key (*args*,
1040     *kwargs*) then it will simply make that axes current and
1041     return it.  This behavior is deprecated. Meanwhile, if you do
1042     not want this behavior (i.e., you want to force the creation of a
1043     new axes), you must use a unique set of args and kwargs.  The Axes
1044     *label* attribute has been exposed for this purpose: if you want
1045     two Axes that are otherwise identical to be added to the figure,
1046     make sure you give them unique labels.
1047 
1048     See Also
1049     --------
1050     .Figure.add_axes
1051     .pyplot.subplot
1052     .Figure.add_subplot
1053     .Figure.subplots
1054     .pyplot.subplots
1055 
1056     Examples
1057     --------
1058     ::
1059 
1060         # Creating a new full window Axes
1061         plt.axes()
1062 
1063         # Creating a new Axes with specified dimensions and a grey background
1064         plt.axes((left, bottom, width, height), facecolor='grey')
1065     """
1066     fig = gcf()
1067     pos = kwargs.pop('position', None)
1068     if arg is None:
1069         if pos is None:
1070             return fig.add_subplot(**kwargs)
1071         else:
1072             return fig.add_axes(pos, **kwargs)
1073     else:
1074         return fig.add_axes(arg, **kwargs)
1075 
1076 
1077 def delaxes(ax=None):
1078     """
1079     Remove an `~.axes.Axes` (defaulting to the current axes) from its figure.
1080     """
1081     if ax is None:
1082         ax = gca()
1083     ax.remove()
1084 
1085 
1086 def sca(ax):
1087     """
1088     Set the current Axes to *ax* and the current Figure to the parent of *ax*.
1089     """
1090     figure(ax.figure)
1091     ax.figure.sca(ax)
1092 
1093 
1094 def cla():
1095     """Clear the current axes."""
1096     # Not generated via boilerplate.py to allow a different docstring.
1097     return gca().cla()
1098 
1099 
1100 ## More ways of creating axes ##
1101 
1102 @_docstring.dedent_interpd
1103 def subplot(*args, **kwargs):
1104     """
1105     Add an Axes to the current figure or retrieve an existing Axes.
1106 
1107     This is a wrapper of `.Figure.add_subplot` which provides additional
1108     behavior when working with the implicit API (see the notes section).
1109 
1110     Call signatures::
1111 
1112        subplot(nrows, ncols, index, **kwargs)
1113        subplot(pos, **kwargs)
1114        subplot(**kwargs)
1115        subplot(ax)
1116 
1117     Parameters
1118     ----------
1119     *args : int, (int, int, *index*), or `.SubplotSpec`, default: (1, 1, 1)
1120         The position of the subplot described by one of
1121 
1122         - Three integers (*nrows*, *ncols*, *index*). The subplot will take the
1123           *index* position on a grid with *nrows* rows and *ncols* columns.
1124           *index* starts at 1 in the upper left corner and increases to the
1125           right. *index* can also be a two-tuple specifying the (*first*,
1126           *last*) indices (1-based, and including *last*) of the subplot, e.g.,
1127           ``fig.add_subplot(3, 1, (1, 2))`` makes a subplot that spans the
1128           upper 2/3 of the figure.
1129         - A 3-digit integer. The digits are interpreted as if given separately
1130           as three single-digit integers, i.e. ``fig.add_subplot(235)`` is the
1131           same as ``fig.add_subplot(2, 3, 5)``. Note that this can only be used
1132           if there are no more than 9 subplots.
1133         - A `.SubplotSpec`.
1134 
1135     projection : {None, 'aitoff', 'hammer', 'lambert', 'mollweide', \
1136 'polar', 'rectilinear', str}, optional
1137         The projection type of the subplot (`~.axes.Axes`). *str* is the name
1138         of a custom projection, see `~matplotlib.projections`. The default
1139         None results in a 'rectilinear' projection.
1140 
1141     polar : bool, default: False
1142         If True, equivalent to projection='polar'.
1143 
1144     sharex, sharey : `~.axes.Axes`, optional
1145         Share the x or y `~matplotlib.axis` with sharex and/or sharey. The
1146         axis will have the same limits, ticks, and scale as the axis of the
1147         shared axes.
1148 
1149     label : str
1150         A label for the returned axes.
1151 
1152     Returns
1153     -------
1154     `.axes.SubplotBase`, or another subclass of `~.axes.Axes`
1155 
1156         The axes of the subplot. The returned axes base class depends on
1157         the projection used. It is `~.axes.Axes` if rectilinear projection
1158         is used and `.projections.polar.PolarAxes` if polar projection
1159         is used. The returned axes is then a subplot subclass of the
1160         base class.
1161 
1162     Other Parameters
1163     ----------------
1164     **kwargs
1165         This method also takes the keyword arguments for the returned axes
1166         base class; except for the *figure* argument. The keyword arguments
1167         for the rectilinear base class `~.axes.Axes` can be found in
1168         the following table but there might also be other keyword
1169         arguments if another projection is used.
1170 
1171         %(Axes:kwdoc)s
1172 
1173     Notes
1174     -----
1175     Creating a new Axes will delete any pre-existing Axes that
1176     overlaps with it beyond sharing a boundary::
1177 
1178         import matplotlib.pyplot as plt
1179         # plot a line, implicitly creating a subplot(111)
1180         plt.plot([1, 2, 3])
1181         # now create a subplot which represents the top plot of a grid
1182         # with 2 rows and 1 column. Since this subplot will overlap the
1183         # first, the plot (and its axes) previously created, will be removed
1184         plt.subplot(211)
1185 
1186     If you do not want this behavior, use the `.Figure.add_subplot` method
1187     or the `.pyplot.axes` function instead.
1188 
1189     If no *kwargs* are passed and there exists an Axes in the location
1190     specified by *args* then that Axes will be returned rather than a new
1191     Axes being created.
1192 
1193     If *kwargs* are passed and there exists an Axes in the location
1194     specified by *args*, the projection type is the same, and the
1195     *kwargs* match with the existing Axes, then the existing Axes is
1196     returned.  Otherwise a new Axes is created with the specified
1197     parameters.  We save a reference to the *kwargs* which we use
1198     for this comparison.  If any of the values in *kwargs* are
1199     mutable we will not detect the case where they are mutated.
1200     In these cases we suggest using `.Figure.add_subplot` and the
1201     explicit Axes API rather than the implicit pyplot API.
1202 
1203     See Also
1204     --------
1205     .Figure.add_subplot
1206     .pyplot.subplots
1207     .pyplot.axes
1208     .Figure.subplots
1209 
1210     Examples
1211     --------
1212     ::
1213 
1214         plt.subplot(221)
1215 
1216         # equivalent but more general
1217         ax1 = plt.subplot(2, 2, 1)
1218 
1219         # add a subplot with no frame
1220         ax2 = plt.subplot(222, frameon=False)
1221 
1222         # add a polar subplot
1223         plt.subplot(223, projection='polar')
1224 
1225         # add a red subplot that shares the x-axis with ax1
1226         plt.subplot(224, sharex=ax1, facecolor='red')
1227 
1228         # delete ax2 from the figure
1229         plt.delaxes(ax2)
1230 
1231         # add ax2 to the figure again
1232         plt.subplot(ax2)
1233 
1234         # make the first axes "current" again
1235         plt.subplot(221)
1236 
1237     """
1238     # Here we will only normalize `polar=True` vs `projection='polar'` and let
1239     # downstream code deal with the rest.
1240     unset = object()
1241     projection = kwargs.get('projection', unset)
1242     polar = kwargs.pop('polar', unset)
1243     if polar is not unset and polar:
1244         # if we got mixed messages from the user, raise
1245         if projection is not unset and projection != 'polar':
1246             raise ValueError(
1247                 f"polar={polar}, yet projection={projection!r}. "
1248                 "Only one of these arguments should be supplied."
1249             )
1250         kwargs['projection'] = projection = 'polar'
1251 
1252     # if subplot called without arguments, create subplot(1, 1, 1)
1253     if len(args) == 0:
1254         args = (1, 1, 1)
1255 
1256     # This check was added because it is very easy to type subplot(1, 2, False)
1257     # when subplots(1, 2, False) was intended (sharex=False, that is). In most
1258     # cases, no error will ever occur, but mysterious behavior can result
1259     # because what was intended to be the sharex argument is instead treated as
1260     # a subplot index for subplot()
1261     if len(args) >= 3 and isinstance(args[2], bool):
1262         _api.warn_external("The subplot index argument to subplot() appears "
1263                            "to be a boolean. Did you intend to use "
1264                            "subplots()?")
1265     # Check for nrows and ncols, which are not valid subplot args:
1266     if 'nrows' in kwargs or 'ncols' in kwargs:
1267         raise TypeError("subplot() got an unexpected keyword argument 'ncols' "
1268                         "and/or 'nrows'.  Did you intend to call subplots()?")
1269 
1270     fig = gcf()
1271 
1272     # First, search for an existing subplot with a matching spec.
1273     key = SubplotSpec._from_subplot_args(fig, args)
1274 
1275     for ax in fig.axes:
1276         # if we found an Axes at the position sort out if we can re-use it
1277         if hasattr(ax, 'get_subplotspec') and ax.get_subplotspec() == key:
1278             # if the user passed no kwargs, re-use
1279             if kwargs == {}:
1280                 break
1281             # if the axes class and kwargs are identical, reuse
1282             elif ax._projection_init == fig._process_projection_requirements(
1283                 *args, **kwargs
1284             ):
1285                 break
1286     else:
1287         # we have exhausted the known Axes and none match, make a new one!
1288         ax = fig.add_subplot(*args, **kwargs)
1289 
1290     fig.sca(ax)
1291 
1292     axes_to_delete = [other for other in fig.axes
1293                       if other != ax and ax.bbox.fully_overlaps(other.bbox)]
1294     if axes_to_delete:
1295         _api.warn_deprecated(
1296             "3.6", message="Auto-removal of overlapping axes is deprecated "
1297             "since %(since)s and will be removed %(removal)s; explicitly call "
1298             "ax.remove() as needed.")
1299     for ax_to_del in axes_to_delete:
1300         delaxes(ax_to_del)
1301 
1302     return ax
1303 
1304 
1305 def subplots(nrows=1, ncols=1, *, sharex=False, sharey=False, squeeze=True,
1306              subplot_kw=None, gridspec_kw=None, **fig_kw):
1307     """
1308     Create a figure and a set of subplots.
1309 
1310     This utility wrapper makes it convenient to create common layouts of
1311     subplots, including the enclosing figure object, in a single call.
1312 
1313     Parameters
1314     ----------
1315     nrows, ncols : int, default: 1
1316         Number of rows/columns of the subplot grid.
1317 
1318     sharex, sharey : bool or {'none', 'all', 'row', 'col'}, default: False
1319         Controls sharing of properties among x (*sharex*) or y (*sharey*)
1320         axes:
1321 
1322         - True or 'all': x- or y-axis will be shared among all subplots.
1323         - False or 'none': each subplot x- or y-axis will be independent.
1324         - 'row': each subplot row will share an x- or y-axis.
1325         - 'col': each subplot column will share an x- or y-axis.
1326 
1327         When subplots have a shared x-axis along a column, only the x tick
1328         labels of the bottom subplot are created. Similarly, when subplots
1329         have a shared y-axis along a row, only the y tick labels of the first
1330         column subplot are created. To later turn other subplots' ticklabels
1331         on, use `~matplotlib.axes.Axes.tick_params`.
1332 
1333         When subplots have a shared axis that has units, calling
1334         `~matplotlib.axis.Axis.set_units` will update each axis with the
1335         new units.
1336 
1337     squeeze : bool, default: True
1338         - If True, extra dimensions are squeezed out from the returned
1339           array of `~matplotlib.axes.Axes`:
1340 
1341           - if only one subplot is constructed (nrows=ncols=1), the
1342             resulting single Axes object is returned as a scalar.
1343           - for Nx1 or 1xM subplots, the returned object is a 1D numpy
1344             object array of Axes objects.
1345           - for NxM, subplots with N>1 and M>1 are returned as a 2D array.
1346 
1347         - If False, no squeezing at all is done: the returned Axes object is
1348           always a 2D array containing Axes instances, even if it ends up
1349           being 1x1.
1350 
1351     subplot_kw : dict, optional
1352         Dict with keywords passed to the
1353         `~matplotlib.figure.Figure.add_subplot` call used to create each
1354         subplot.
1355 
1356     gridspec_kw : dict, optional
1357         Dict with keywords passed to the `~matplotlib.gridspec.GridSpec`
1358         constructor used to create the grid the subplots are placed on.
1359 
1360     **fig_kw
1361         All additional keyword arguments are passed to the
1362         `.pyplot.figure` call.
1363 
1364     Returns
1365     -------
1366     fig : `.Figure`
1367 
1368     ax : `~.axes.Axes` or array of Axes
1369         *ax* can be either a single `~.axes.Axes` object, or an array of Axes
1370         objects if more than one subplot was created.  The dimensions of the
1371         resulting array can be controlled with the squeeze keyword, see above.
1372 
1373         Typical idioms for handling the return value are::
1374 
1375             # using the variable ax for single a Axes
1376             fig, ax = plt.subplots()
1377 
1378             # using the variable axs for multiple Axes
1379             fig, axs = plt.subplots(2, 2)
1380 
1381             # using tuple unpacking for multiple Axes
1382             fig, (ax1, ax2) = plt.subplots(1, 2)
1383             fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2)
1384 
1385         The names ``ax`` and pluralized ``axs`` are preferred over ``axes``
1386         because for the latter it's not clear if it refers to a single
1387         `~.axes.Axes` instance or a collection of these.
1388 
1389     See Also
1390     --------
1391     .pyplot.figure
1392     .pyplot.subplot
1393     .pyplot.axes
1394     .Figure.subplots
1395     .Figure.add_subplot
1396 
1397     Examples
1398     --------
1399     ::
1400 
1401         # First create some toy data:
1402         x = np.linspace(0, 2*np.pi, 400)
1403         y = np.sin(x**2)
1404 
1405         # Create just a figure and only one subplot
1406         fig, ax = plt.subplots()
1407         ax.plot(x, y)
1408         ax.set_title('Simple plot')
1409 
1410         # Create two subplots and unpack the output array immediately
1411         f, (ax1, ax2) = plt.subplots(1, 2, sharey=True)
1412         ax1.plot(x, y)
1413         ax1.set_title('Sharing Y axis')
1414         ax2.scatter(x, y)
1415 
1416         # Create four polar axes and access them through the returned array
1417         fig, axs = plt.subplots(2, 2, subplot_kw=dict(projection="polar"))
1418         axs[0, 0].plot(x, y)
1419         axs[1, 1].scatter(x, y)
1420 
1421         # Share a X axis with each column of subplots
1422         plt.subplots(2, 2, sharex='col')
1423 
1424         # Share a Y axis with each row of subplots
1425         plt.subplots(2, 2, sharey='row')
1426 
1427         # Share both X and Y axes with all subplots
1428         plt.subplots(2, 2, sharex='all', sharey='all')
1429 
1430         # Note that this is the same as
1431         plt.subplots(2, 2, sharex=True, sharey=True)
1432 
1433         # Create figure number 10 with a single subplot
1434         # and clears it if it already exists.
1435         fig, ax = plt.subplots(num=10, clear=True)
1436 
1437     """
1438     fig = figure(**fig_kw)
1439     axs = fig.subplots(nrows=nrows, ncols=ncols, sharex=sharex, sharey=sharey,
1440                        squeeze=squeeze, subplot_kw=subplot_kw,
1441                        gridspec_kw=gridspec_kw)
1442     return fig, axs
1443 
1444 
1445 def subplot_mosaic(mosaic, *, sharex=False, sharey=False,
1446                    subplot_kw=None, gridspec_kw=None, empty_sentinel='.',
1447                    **fig_kw):
1448     """
1449     Build a layout of Axes based on ASCII art or nested lists.
1450 
1451     This is a helper function to build complex GridSpec layouts visually.
1452 
1453     .. note::
1454 
1455        This API is provisional and may be revised in the future based on
1456        early user feedback.
1457 
1458     See :doc:`/tutorials/provisional/mosaic`
1459     for an example and full API documentation
1460 
1461     Parameters
1462     ----------
1463     mosaic : list of list of {hashable or nested} or str
1464 
1465         A visual layout of how you want your Axes to be arranged
1466         labeled as strings.  For example ::
1467 
1468            x = [['A panel', 'A panel', 'edge'],
1469                 ['C panel', '.',       'edge']]
1470 
1471         produces 4 axes:
1472 
1473         - 'A panel' which is 1 row high and spans the first two columns
1474         - 'edge' which is 2 rows high and is on the right edge
1475         - 'C panel' which in 1 row and 1 column wide in the bottom left
1476         - a blank space 1 row and 1 column wide in the bottom center
1477 
1478         Any of the entries in the layout can be a list of lists
1479         of the same form to create nested layouts.
1480 
1481         If input is a str, then it must be of the form ::
1482 
1483           '''
1484           AAE
1485           C.E
1486           '''
1487 
1488         where each character is a column and each line is a row.
1489         This only allows only single character Axes labels and does
1490         not allow nesting but is very terse.
1491 
1492     sharex, sharey : bool, default: False
1493         If True, the x-axis (*sharex*) or y-axis (*sharey*) will be shared
1494         among all subplots.  In that case, tick label visibility and axis units
1495         behave as for `subplots`.  If False, each subplot's x- or y-axis will
1496         be independent.
1497 
1498     subplot_kw : dict, optional
1499         Dictionary with keywords passed to the `.Figure.add_subplot` call
1500         used to create each subplot.
1501 
1502     gridspec_kw : dict, optional
1503         Dictionary with keywords passed to the `.GridSpec` constructor used
1504         to create the grid the subplots are placed on.
1505 
1506     empty_sentinel : object, optional
1507         Entry in the layout to mean "leave this space empty".  Defaults
1508         to ``'.'``. Note, if *layout* is a string, it is processed via
1509         `inspect.cleandoc` to remove leading white space, which may
1510         interfere with using white-space as the empty sentinel.
1511 
1512     **fig_kw
1513         All additional keyword arguments are passed to the
1514         `.pyplot.figure` call.
1515 
1516     Returns
1517     -------
1518     fig : `.Figure`
1519        The new figure
1520 
1521     dict[label, Axes]
1522        A dictionary mapping the labels to the Axes objects.  The order of
1523        the axes is left-to-right and top-to-bottom of their position in the
1524        total layout.
1525 
1526     """
1527     fig = figure(**fig_kw)
1528     ax_dict = fig.subplot_mosaic(
1529         mosaic, sharex=sharex, sharey=sharey,
1530         subplot_kw=subplot_kw, gridspec_kw=gridspec_kw,
1531         empty_sentinel=empty_sentinel
1532     )
1533     return fig, ax_dict
1534 
1535 
1536 def subplot2grid(shape, loc, rowspan=1, colspan=1, fig=None, **kwargs):
1537     """
1538     Create a subplot at a specific location inside a regular grid.
1539 
1540     Parameters
1541     ----------
1542     shape : (int, int)
1543         Number of rows and of columns of the grid in which to place axis.
1544     loc : (int, int)
1545         Row number and column number of the axis location within the grid.
1546     rowspan : int, default: 1
1547         Number of rows for the axis to span downwards.
1548     colspan : int, default: 1
1549         Number of columns for the axis to span to the right.
1550     fig : `.Figure`, optional
1551         Figure to place the subplot in. Defaults to the current figure.
1552     **kwargs
1553         Additional keyword arguments are handed to `~.Figure.add_subplot`.
1554 
1555     Returns
1556     -------
1557     `.axes.SubplotBase`, or another subclass of `~.axes.Axes`
1558 
1559         The axes of the subplot.  The returned axes base class depends on the
1560         projection used.  It is `~.axes.Axes` if rectilinear projection is used
1561         and `.projections.polar.PolarAxes` if polar projection is used.  The
1562         returned axes is then a subplot subclass of the base class.
1563 
1564     Notes
1565     -----
1566     The following call ::
1567 
1568         ax = subplot2grid((nrows, ncols), (row, col), rowspan, colspan)
1569 
1570     is identical to ::
1571 
1572         fig = gcf()
1573         gs = fig.add_gridspec(nrows, ncols)
1574         ax = fig.add_subplot(gs[row:row+rowspan, col:col+colspan])
1575     """
1576 
1577     if fig is None:
1578         fig = gcf()
1579 
1580     rows, cols = shape
1581     gs = GridSpec._check_gridspec_exists(fig, rows, cols)
1582 
1583     subplotspec = gs.new_subplotspec(loc, rowspan=rowspan, colspan=colspan)
1584     ax = fig.add_subplot(subplotspec, **kwargs)
1585 
1586     axes_to_delete = [other for other in fig.axes
1587                       if other != ax and ax.bbox.fully_overlaps(other.bbox)]
1588     if axes_to_delete:
1589         _api.warn_deprecated(
1590             "3.6", message="Auto-removal of overlapping axes is deprecated "
1591             "since %(since)s and will be removed %(removal)s; explicitly call "
1592             "ax.remove() as needed.")
1593     for ax_to_del in axes_to_delete:
1594         delaxes(ax_to_del)
1595 
1596     return ax
1597 
1598 
1599 def twinx(ax=None):
1600     """
1601     Make and return a second axes that shares the *x*-axis.  The new axes will
1602     overlay *ax* (or the current axes if *ax* is *None*), and its ticks will be
1603     on the right.
1604 
1605     Examples
1606     --------
1607     :doc:`/gallery/subplots_axes_and_figures/two_scales`
1608     """
1609     if ax is None:
1610         ax = gca()
1611     ax1 = ax.twinx()
1612     return ax1
1613 
1614 
1615 def twiny(ax=None):
1616     """
1617     Make and return a second axes that shares the *y*-axis.  The new axes will
1618     overlay *ax* (or the current axes if *ax* is *None*), and its ticks will be
1619     on the top.
1620 
1621     Examples
1622     --------
1623     :doc:`/gallery/subplots_axes_and_figures/two_scales`
1624     """
1625     if ax is None:
1626         ax = gca()
1627     ax1 = ax.twiny()
1628     return ax1
1629 
1630 
1631 def subplot_tool(targetfig=None):
1632     """
1633     Launch a subplot tool window for a figure.
1634 
1635     Returns
1636     -------
1637     `matplotlib.widgets.SubplotTool`
1638     """
1639     if targetfig is None:
1640         targetfig = gcf()
1641     tb = targetfig.canvas.manager.toolbar
1642     if hasattr(tb, "configure_subplots"):  # toolbar2
1643         return tb.configure_subplots()
1644     elif hasattr(tb, "trigger_tool"):  # toolmanager
1645         return tb.trigger_tool("subplots")
1646     else:
1647         raise ValueError("subplot_tool can only be launched for figures with "
1648                          "an associated toolbar")
1649 
1650 
1651 def box(on=None):
1652     """
1653     Turn the axes box on or off on the current axes.
1654 
1655     Parameters
1656     ----------
1657     on : bool or None
1658         The new `~matplotlib.axes.Axes` box state. If ``None``, toggle
1659         the state.
1660 
1661     See Also
1662     --------
1663     :meth:`matplotlib.axes.Axes.set_frame_on`
1664     :meth:`matplotlib.axes.Axes.get_frame_on`
1665     """
1666     ax = gca()
1667     if on is None:
1668         on = not ax.get_frame_on()
1669     ax.set_frame_on(on)
1670 
1671 ## Axis ##
1672 
1673 
1674 def xlim(*args, **kwargs):
1675     """
1676     Get or set the x limits of the current axes.
1677 
1678     Call signatures::
1679 
1680         left, right = xlim()  # return the current xlim
1681         xlim((left, right))   # set the xlim to left, right
1682         xlim(left, right)     # set the xlim to left, right
1683 
1684     If you do not specify args, you can pass *left* or *right* as kwargs,
1685     i.e.::
1686 
1687         xlim(right=3)  # adjust the right leaving left unchanged
1688         xlim(left=1)  # adjust the left leaving right unchanged
1689 
1690     Setting limits turns autoscaling off for the x-axis.
1691 
1692     Returns
1693     -------
1694     left, right
1695         A tuple of the new x-axis limits.
1696 
1697     Notes
1698     -----
1699     Calling this function with no arguments (e.g. ``xlim()``) is the pyplot
1700     equivalent of calling `~.Axes.get_xlim` on the current axes.
1701     Calling this function with arguments is the pyplot equivalent of calling
1702     `~.Axes.set_xlim` on the current axes. All arguments are passed though.
1703     """
1704     ax = gca()
1705     if not args and not kwargs:
1706         return ax.get_xlim()
1707     ret = ax.set_xlim(*args, **kwargs)
1708     return ret
1709 
1710 
1711 def ylim(*args, **kwargs):
1712     """
1713     Get or set the y-limits of the current axes.
1714 
1715     Call signatures::
1716 
1717         bottom, top = ylim()  # return the current ylim
1718         ylim((bottom, top))   # set the ylim to bottom, top
1719         ylim(bottom, top)     # set the ylim to bottom, top
1720 
1721     If you do not specify args, you can alternatively pass *bottom* or
1722     *top* as kwargs, i.e.::
1723 
1724         ylim(top=3)  # adjust the top leaving bottom unchanged
1725         ylim(bottom=1)  # adjust the bottom leaving top unchanged
1726 
1727     Setting limits turns autoscaling off for the y-axis.
1728 
1729     Returns
1730     -------
1731     bottom, top
1732         A tuple of the new y-axis limits.
1733 
1734     Notes
1735     -----
1736     Calling this function with no arguments (e.g. ``ylim()``) is the pyplot
1737     equivalent of calling `~.Axes.get_ylim` on the current axes.
1738     Calling this function with arguments is the pyplot equivalent of calling
1739     `~.Axes.set_ylim` on the current axes. All arguments are passed though.
1740     """
1741     ax = gca()
1742     if not args and not kwargs:
1743         return ax.get_ylim()
1744     ret = ax.set_ylim(*args, **kwargs)
1745     return ret
1746 
1747 
1748 def xticks(ticks=None, labels=None, **kwargs):
1749     """
1750     Get or set the current tick locations and labels of the x-axis.
1751 
1752     Pass no arguments to return the current values without modifying them.
1753 
1754     Parameters
1755     ----------
1756     ticks : array-like, optional
1757         The list of xtick locations.  Passing an empty list removes all xticks.
1758     labels : array-like, optional
1759         The labels to place at the given *ticks* locations.  This argument can
1760         only be passed if *ticks* is passed as well.
1761     **kwargs
1762         `.Text` properties can be used to control the appearance of the labels.
1763 
1764     Returns
1765     -------
1766     locs
1767         The list of xtick locations.
1768     labels
1769         The list of xlabel `.Text` objects.
1770 
1771     Notes
1772     -----
1773     Calling this function with no arguments (e.g. ``xticks()``) is the pyplot
1774     equivalent of calling `~.Axes.get_xticks` and `~.Axes.get_xticklabels` on
1775     the current axes.
1776     Calling this function with arguments is the pyplot equivalent of calling
1777     `~.Axes.set_xticks` and `~.Axes.set_xticklabels` on the current axes.
1778 
1779     Examples
1780     --------
1781     >>> locs, labels = xticks()  # Get the current locations and labels.
1782     >>> xticks(np.arange(0, 1, step=0.2))  # Set label locations.
1783     >>> xticks(np.arange(3), ['Tom', 'Dick', 'Sue'])  # Set text labels.
1784     >>> xticks([0, 1, 2], ['January', 'February', 'March'],
1785     ...        rotation=20)  # Set text labels and properties.
1786     >>> xticks([])  # Disable xticks.
1787     """
1788     ax = gca()
1789 
1790     if ticks is None:
1791         locs = ax.get_xticks()
1792         if labels is not None:
1793             raise TypeError("xticks(): Parameter 'labels' can't be set "
1794                             "without setting 'ticks'")
1795     else:
1796         locs = ax.set_xticks(ticks)
1797 
1798     if labels is None:
1799         labels = ax.get_xticklabels()
1800         for l in labels:
1801             l._internal_update(kwargs)
1802     else:
1803         labels = ax.set_xticklabels(labels, **kwargs)
1804 
1805     return locs, labels
1806 
1807 
1808 def yticks(ticks=None, labels=None, **kwargs):
1809     """
1810     Get or set the current tick locations and labels of the y-axis.
1811 
1812     Pass no arguments to return the current values without modifying them.
1813 
1814     Parameters
1815     ----------
1816     ticks : array-like, optional
1817         The list of ytick locations.  Passing an empty list removes all yticks.
1818     labels : array-like, optional
1819         The labels to place at the given *ticks* locations.  This argument can
1820         only be passed if *ticks* is passed as well.
1821     **kwargs
1822         `.Text` properties can be used to control the appearance of the labels.
1823 
1824     Returns
1825     -------
1826     locs
1827         The list of ytick locations.
1828     labels
1829         The list of ylabel `.Text` objects.
1830 
1831     Notes
1832     -----
1833     Calling this function with no arguments (e.g. ``yticks()``) is the pyplot
1834     equivalent of calling `~.Axes.get_yticks` and `~.Axes.get_yticklabels` on
1835     the current axes.
1836     Calling this function with arguments is the pyplot equivalent of calling
1837     `~.Axes.set_yticks` and `~.Axes.set_yticklabels` on the current axes.
1838 
1839     Examples
1840     --------
1841     >>> locs, labels = yticks()  # Get the current locations and labels.
1842     >>> yticks(np.arange(0, 1, step=0.2))  # Set label locations.
1843     >>> yticks(np.arange(3), ['Tom', 'Dick', 'Sue'])  # Set text labels.
1844     >>> yticks([0, 1, 2], ['January', 'February', 'March'],
1845     ...        rotation=45)  # Set text labels and properties.
1846     >>> yticks([])  # Disable yticks.
1847     """
1848     ax = gca()
1849 
1850     if ticks is None:
1851         locs = ax.get_yticks()
1852         if labels is not None:
1853             raise TypeError("yticks(): Parameter 'labels' can't be set "
1854                             "without setting 'ticks'")
1855     else:
1856         locs = ax.set_yticks(ticks)
1857 
1858     if labels is None:
1859         labels = ax.get_yticklabels()
1860         for l in labels:
1861             l._internal_update(kwargs)
1862     else:
1863         labels = ax.set_yticklabels(labels, **kwargs)
1864 
1865     return locs, labels
1866 
1867 
1868 def rgrids(radii=None, labels=None, angle=None, fmt=None, **kwargs):
1869     """
1870     Get or set the radial gridlines on the current polar plot.
1871 
1872     Call signatures::
1873 
1874      lines, labels = rgrids()
1875      lines, labels = rgrids(radii, labels=None, angle=22.5, fmt=None, **kwargs)
1876 
1877     When called with no arguments, `.rgrids` simply returns the tuple
1878     (*lines*, *labels*). When called with arguments, the labels will
1879     appear at the specified radial distances and angle.
1880 
1881     Parameters
1882     ----------
1883     radii : tuple with floats
1884         The radii for the radial gridlines
1885 
1886     labels : tuple with strings or None
1887         The labels to use at each radial gridline. The
1888         `matplotlib.ticker.ScalarFormatter` will be used if None.
1889 
1890     angle : float
1891         The angular position of the radius labels in degrees.
1892 
1893     fmt : str or None
1894         Format string used in `matplotlib.ticker.FormatStrFormatter`.
1895         For example '%f'.
1896 
1897     Returns
1898     -------
1899     lines : list of `.lines.Line2D`
1900         The radial gridlines.
1901 
1902     labels : list of `.text.Text`
1903         The tick labels.
1904 
1905     Other Parameters
1906     ----------------
1907     **kwargs
1908         *kwargs* are optional `.Text` properties for the labels.
1909 
1910     See Also
1911     --------
1912     .pyplot.thetagrids
1913     .projections.polar.PolarAxes.set_rgrids
1914     .Axis.get_gridlines
1915     .Axis.get_ticklabels
1916 
1917     Examples
1918     --------
1919     ::
1920 
1921       # set the locations of the radial gridlines
1922       lines, labels = rgrids( (0.25, 0.5, 1.0) )
1923 
1924       # set the locations and labels of the radial gridlines
1925       lines, labels = rgrids( (0.25, 0.5, 1.0), ('Tom', 'Dick', 'Harry' ))
1926     """
1927     ax = gca()
1928     if not isinstance(ax, PolarAxes):
1929         raise RuntimeError('rgrids only defined for polar axes')
1930     if all(p is None for p in [radii, labels, angle, fmt]) and not kwargs:
1931         lines = ax.yaxis.get_gridlines()
1932         labels = ax.yaxis.get_ticklabels()
1933     else:
1934         lines, labels = ax.set_rgrids(
1935             radii, labels=labels, angle=angle, fmt=fmt, **kwargs)
1936     return lines, labels
1937 
1938 
1939 def thetagrids(angles=None, labels=None, fmt=None, **kwargs):
1940     """
1941     Get or set the theta gridlines on the current polar plot.
1942 
1943     Call signatures::
1944 
1945      lines, labels = thetagrids()
1946      lines, labels = thetagrids(angles, labels=None, fmt=None, **kwargs)
1947 
1948     When called with no arguments, `.thetagrids` simply returns the tuple
1949     (*lines*, *labels*). When called with arguments, the labels will
1950     appear at the specified angles.
1951 
1952     Parameters
1953     ----------
1954     angles : tuple with floats, degrees
1955         The angles of the theta gridlines.
1956 
1957     labels : tuple with strings or None
1958         The labels to use at each radial gridline. The
1959         `.projections.polar.ThetaFormatter` will be used if None.
1960 
1961     fmt : str or None
1962         Format string used in `matplotlib.ticker.FormatStrFormatter`.
1963         For example '%f'. Note that the angle in radians will be used.
1964 
1965     Returns
1966     -------
1967     lines : list of `.lines.Line2D`
1968         The theta gridlines.
1969 
1970     labels : list of `.text.Text`
1971         The tick labels.
1972 
1973     Other Parameters
1974     ----------------
1975     **kwargs
1976         *kwargs* are optional `.Text` properties for the labels.
1977 
1978     See Also
1979     --------
1980     .pyplot.rgrids
1981     .projections.polar.PolarAxes.set_thetagrids
1982     .Axis.get_gridlines
1983     .Axis.get_ticklabels
1984 
1985     Examples
1986     --------
1987     ::
1988 
1989       # set the locations of the angular gridlines
1990       lines, labels = thetagrids(range(45, 360, 90))
1991 
1992       # set the locations and labels of the angular gridlines
1993       lines, labels = thetagrids(range(45, 360, 90), ('NE', 'NW', 'SW', 'SE'))
1994     """
1995     ax = gca()
1996     if not isinstance(ax, PolarAxes):
1997         raise RuntimeError('thetagrids only defined for polar axes')
1998     if all(param is None for param in [angles, labels, fmt]) and not kwargs:
1999         lines = ax.xaxis.get_ticklines()
2000         labels = ax.xaxis.get_ticklabels()
2001     else:
2002         lines, labels = ax.set_thetagrids(angles,
2003                                           labels=labels, fmt=fmt, **kwargs)
2004     return lines, labels
2005 
2006 
2007 ## Plotting Info ##
2008 
2009 
2010 def plotting():
2011     pass
2012 
2013 
2014 def get_plot_commands():
2015     """
2016     Get a sorted list of all of the plotting commands.
2017     """
2018     # This works by searching for all functions in this module and removing
2019     # a few hard-coded exclusions, as well as all of the colormap-setting
2020     # functions, and anything marked as private with a preceding underscore.
2021     exclude = {'colormaps', 'colors', 'connect', 'disconnect',
2022                'get_plot_commands', 'get_current_fig_manager', 'ginput',
2023                'plotting', 'waitforbuttonpress'}
2024     exclude |= set(colormaps)
2025     this_module = inspect.getmodule(get_plot_commands)
2026     return sorted(
2027         name for name, obj in globals().items()
2028         if not name.startswith('_') and name not in exclude
2029            and inspect.isfunction(obj)
2030            and inspect.getmodule(obj) is this_module)
2031 
2032 
2033 def _setup_pyplot_info_docstrings():
2034     """
2035     Setup the docstring of `plotting` and of the colormap-setting functions.
2036 
2037     These must be done after the entire module is imported, so it is called
2038     from the end of this module, which is generated by boilerplate.py.
2039     """
2040     commands = get_plot_commands()
2041 
2042     first_sentence = re.compile(r"(?:\s*).+?\.(?:\s+|$)", flags=re.DOTALL)
2043 
2044     # Collect the first sentence of the docstring for all of the
2045     # plotting commands.
2046     rows = []
2047     max_name = len("Function")
2048     max_summary = len("Description")
2049     for name in commands:
2050         doc = globals()[name].__doc__
2051         summary = ''
2052         if doc is not None:
2053             match = first_sentence.match(doc)
2054             if match is not None:
2055                 summary = inspect.cleandoc(match.group(0)).replace('\n', ' ')
2056         name = '`%s`' % name
2057         rows.append([name, summary])
2058         max_name = max(max_name, len(name))
2059         max_summary = max(max_summary, len(summary))
2060 
2061     separator = '=' * max_name + ' ' + '=' * max_summary
2062     lines = [
2063         separator,
2064         '{:{}} {:{}}'.format('Function', max_name, 'Description', max_summary),
2065         separator,
2066     ] + [
2067         '{:{}} {:{}}'.format(name, max_name, summary, max_summary)
2068         for name, summary in rows
2069     ] + [
2070         separator,
2071     ]
2072     plotting.__doc__ = '\n'.join(lines)
2073 
2074     for cm_name in colormaps:
2075         if cm_name in globals():
2076             globals()[cm_name].__doc__ = f"""
2077     Set the colormap to {cm_name!r}.
2078 
2079     This changes the default colormap as well as the colormap of the current
2080     image if there is one. See ``help(colormaps)`` for more information.
2081     """
2082 
2083 
2084 ## Plotting part 1: manually generated functions and wrappers ##
2085 
2086 
2087 @_copy_docstring_and_deprecators(Figure.colorbar)
2088 def colorbar(mappable=None, cax=None, ax=None, **kwargs):
2089     if mappable is None:
2090         mappable = gci()
2091         if mappable is None:
2092             raise RuntimeError('No mappable was found to use for colorbar '
2093                                'creation. First define a mappable such as '
2094                                'an image (with imshow) or a contour set ('
2095                                'with contourf).')
2096     ret = gcf().colorbar(mappable, cax=cax, ax=ax, **kwargs)
2097     return ret
2098 
2099 
2100 def clim(vmin=None, vmax=None):
2101     """
2102     Set the color limits of the current image.
2103 
2104     If either *vmin* or *vmax* is None, the image min/max respectively
2105     will be used for color scaling.
2106 
2107     If you want to set the clim of multiple images, use
2108     `~.ScalarMappable.set_clim` on every image, for example::
2109 
2110       for im in gca().get_images():
2111           im.set_clim(0, 0.5)
2112 
2113     """
2114     im = gci()
2115     if im is None:
2116         raise RuntimeError('You must first define an image, e.g., with imshow')
2117 
2118     im.set_clim(vmin, vmax)
2119 
2120 
2121 def set_cmap(cmap):
2122     """
2123     Set the default colormap, and applies it to the current image if any.
2124 
2125     Parameters
2126     ----------
2127     cmap : `~matplotlib.colors.Colormap` or str
2128         A colormap instance or the name of a registered colormap.
2129 
2130     See Also
2131     --------
2132     colormaps
2133     matplotlib.cm.register_cmap
2134     matplotlib.cm.get_cmap
2135     """
2136     cmap = cm.get_cmap(cmap)
2137 
2138     rc('image', cmap=cmap.name)
2139     im = gci()
2140 
2141     if im is not None:
2142         im.set_cmap(cmap)
2143 
2144 
2145 @_copy_docstring_and_deprecators(matplotlib.image.imread)
2146 def imread(fname, format=None):
2147     return matplotlib.image.imread(fname, format)
2148 
2149 
2150 @_copy_docstring_and_deprecators(matplotlib.image.imsave)
2151 def imsave(fname, arr, **kwargs):
2152     return matplotlib.image.imsave(fname, arr, **kwargs)
2153 
2154 
2155 def matshow(A, fignum=None, **kwargs):
2156     """
2157     Display an array as a matrix in a new figure window.
2158 
2159     The origin is set at the upper left hand corner and rows (first
2160     dimension of the array) are displayed horizontally.  The aspect
2161     ratio of the figure window is that of the array, unless this would
2162     make an excessively short or narrow figure.
2163 
2164     Tick labels for the xaxis are placed on top.
2165 
2166     Parameters
2167     ----------
2168     A : 2D array-like
2169         The matrix to be displayed.
2170 
2171     fignum : None or int or False
2172         If *None*, create a new figure window with automatic numbering.
2173 
2174         If a nonzero integer, draw into the figure with the given number
2175         (create it if it does not exist).
2176 
2177         If 0, use the current axes (or create one if it does not exist).
2178 
2179         .. note::
2180 
2181            Because of how `.Axes.matshow` tries to set the figure aspect
2182            ratio to be the one of the array, strange things may happen if you
2183            reuse an existing figure.
2184 
2185     Returns
2186     -------
2187     `~matplotlib.image.AxesImage`
2188 
2189     Other Parameters
2190     ----------------
2191     **kwargs : `~matplotlib.axes.Axes.imshow` arguments
2192 
2193     """
2194     A = np.asanyarray(A)
2195     if fignum == 0:
2196         ax = gca()
2197     else:
2198         # Extract actual aspect ratio of array and make appropriately sized
2199         # figure.
2200         fig = figure(fignum, figsize=figaspect(A))
2201         ax = fig.add_axes([0.15, 0.09, 0.775, 0.775])
2202     im = ax.matshow(A, **kwargs)
2203     sci(im)
2204     return im
2205 
2206 
2207 def polar(*args, **kwargs):
2208     """
2209     Make a polar plot.
2210 
2211     call signature::
2212 
2213       polar(theta, r, **kwargs)
2214 
2215     Multiple *theta*, *r* arguments are supported, with format strings, as in
2216     `plot`.
2217     """
2218     # If an axis already exists, check if it has a polar projection
2219     if gcf().get_axes():
2220         ax = gca()
2221         if not isinstance(ax, PolarAxes):
2222             _api.warn_external('Trying to create polar plot on an Axes '
2223                                'that does not have a polar projection.')
2224     else:
2225         ax = axes(projection="polar")
2226     return ax.plot(*args, **kwargs)
2227 
2228 
2229 # If rcParams['backend_fallback'] is true, and an interactive backend is
2230 # requested, ignore rcParams['backend'] and force selection of a backend that
2231 # is compatible with the current running interactive framework.
2232 if (rcParams["backend_fallback"]
2233         and dict.__getitem__(rcParams, "backend") in (
2234             set(_interactive_bk) - {'WebAgg', 'nbAgg'})
2235         and cbook._get_running_interactive_framework()):
2236     dict.__setitem__(rcParams, "backend", rcsetup._auto_backend_sentinel)
2237 
2238 
2239 ################# REMAINING CONTENT GENERATED BY boilerplate.py ##############
2240 
2241 
2242 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2243 @_copy_docstring_and_deprecators(Figure.figimage)
2244 def figimage(
2245         X, xo=0, yo=0, alpha=None, norm=None, cmap=None, vmin=None,
2246         vmax=None, origin=None, resize=False, **kwargs):
2247     return gcf().figimage(
2248         X, xo=xo, yo=yo, alpha=alpha, norm=norm, cmap=cmap, vmin=vmin,
2249         vmax=vmax, origin=origin, resize=resize, **kwargs)
2250 
2251 
2252 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2253 @_copy_docstring_and_deprecators(Figure.text)
2254 def figtext(x, y, s, fontdict=None, **kwargs):
2255     return gcf().text(x, y, s, fontdict=fontdict, **kwargs)
2256 
2257 
2258 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2259 @_copy_docstring_and_deprecators(Figure.gca)
2260 def gca(**kwargs):
2261     return gcf().gca(**kwargs)
2262 
2263 
2264 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2265 @_copy_docstring_and_deprecators(Figure._gci)
2266 def gci():
2267     return gcf()._gci()
2268 
2269 
2270 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2271 @_copy_docstring_and_deprecators(Figure.ginput)
2272 def ginput(
2273         n=1, timeout=30, show_clicks=True,
2274         mouse_add=MouseButton.LEFT, mouse_pop=MouseButton.RIGHT,
2275         mouse_stop=MouseButton.MIDDLE):
2276     return gcf().ginput(
2277         n=n, timeout=timeout, show_clicks=show_clicks,
2278         mouse_add=mouse_add, mouse_pop=mouse_pop,
2279         mouse_stop=mouse_stop)
2280 
2281 
2282 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2283 @_copy_docstring_and_deprecators(Figure.subplots_adjust)
2284 def subplots_adjust(
2285         left=None, bottom=None, right=None, top=None, wspace=None,
2286         hspace=None):
2287     return gcf().subplots_adjust(
2288         left=left, bottom=bottom, right=right, top=top, wspace=wspace,
2289         hspace=hspace)
2290 
2291 
2292 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2293 @_copy_docstring_and_deprecators(Figure.suptitle)
2294 def suptitle(t, **kwargs):
2295     return gcf().suptitle(t, **kwargs)
2296 
2297 
2298 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2299 @_copy_docstring_and_deprecators(Figure.tight_layout)
2300 def tight_layout(*, pad=1.08, h_pad=None, w_pad=None, rect=None):
2301     return gcf().tight_layout(pad=pad, h_pad=h_pad, w_pad=w_pad, rect=rect)
2302 
2303 
2304 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2305 @_copy_docstring_and_deprecators(Figure.waitforbuttonpress)
2306 def waitforbuttonpress(timeout=-1):
2307     return gcf().waitforbuttonpress(timeout=timeout)
2308 
2309 
2310 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2311 @_copy_docstring_and_deprecators(Axes.acorr)
2312 def acorr(x, *, data=None, **kwargs):
2313     return gca().acorr(
2314         x, **({"data": data} if data is not None else {}), **kwargs)
2315 
2316 
2317 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2318 @_copy_docstring_and_deprecators(Axes.angle_spectrum)
2319 def angle_spectrum(
2320         x, Fs=None, Fc=None, window=None, pad_to=None, sides=None, *,
2321         data=None, **kwargs):
2322     return gca().angle_spectrum(
2323         x, Fs=Fs, Fc=Fc, window=window, pad_to=pad_to, sides=sides,
2324         **({"data": data} if data is not None else {}), **kwargs)
2325 
2326 
2327 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2328 @_copy_docstring_and_deprecators(Axes.annotate)
2329 def annotate(
2330         text, xy, xytext=None, xycoords='data', textcoords=None,
2331         arrowprops=None, annotation_clip=None, **kwargs):
2332     return gca().annotate(
2333         text, xy, xytext=xytext, xycoords=xycoords,
2334         textcoords=textcoords, arrowprops=arrowprops,
2335         annotation_clip=annotation_clip, **kwargs)
2336 
2337 
2338 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2339 @_copy_docstring_and_deprecators(Axes.arrow)
2340 def arrow(x, y, dx, dy, **kwargs):
2341     return gca().arrow(x, y, dx, dy, **kwargs)
2342 
2343 
2344 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2345 @_copy_docstring_and_deprecators(Axes.autoscale)
2346 def autoscale(enable=True, axis='both', tight=None):
2347     return gca().autoscale(enable=enable, axis=axis, tight=tight)
2348 
2349 
2350 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2351 @_copy_docstring_and_deprecators(Axes.axhline)
2352 def axhline(y=0, xmin=0, xmax=1, **kwargs):
2353     return gca().axhline(y=y, xmin=xmin, xmax=xmax, **kwargs)
2354 
2355 
2356 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2357 @_copy_docstring_and_deprecators(Axes.axhspan)
2358 def axhspan(ymin, ymax, xmin=0, xmax=1, **kwargs):
2359     return gca().axhspan(ymin, ymax, xmin=xmin, xmax=xmax, **kwargs)
2360 
2361 
2362 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2363 @_copy_docstring_and_deprecators(Axes.axis)
2364 def axis(*args, emit=True, **kwargs):
2365     return gca().axis(*args, emit=emit, **kwargs)
2366 
2367 
2368 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2369 @_copy_docstring_and_deprecators(Axes.axline)
2370 def axline(xy1, xy2=None, *, slope=None, **kwargs):
2371     return gca().axline(xy1, xy2=xy2, slope=slope, **kwargs)
2372 
2373 
2374 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2375 @_copy_docstring_and_deprecators(Axes.axvline)
2376 def axvline(x=0, ymin=0, ymax=1, **kwargs):
2377     return gca().axvline(x=x, ymin=ymin, ymax=ymax, **kwargs)
2378 
2379 
2380 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2381 @_copy_docstring_and_deprecators(Axes.axvspan)
2382 def axvspan(xmin, xmax, ymin=0, ymax=1, **kwargs):
2383     return gca().axvspan(xmin, xmax, ymin=ymin, ymax=ymax, **kwargs)
2384 
2385 
2386 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2387 @_copy_docstring_and_deprecators(Axes.bar)
2388 def bar(
2389         x, height, width=0.8, bottom=None, *, align='center',
2390         data=None, **kwargs):
2391     return gca().bar(
2392         x, height, width=width, bottom=bottom, align=align,
2393         **({"data": data} if data is not None else {}), **kwargs)
2394 
2395 
2396 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2397 @_copy_docstring_and_deprecators(Axes.barbs)
2398 def barbs(*args, data=None, **kwargs):
2399     return gca().barbs(
2400         *args, **({"data": data} if data is not None else {}),
2401         **kwargs)
2402 
2403 
2404 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2405 @_copy_docstring_and_deprecators(Axes.barh)
2406 def barh(y, width, height=0.8, left=None, *, align='center', **kwargs):
2407     return gca().barh(
2408         y, width, height=height, left=left, align=align, **kwargs)
2409 
2410 
2411 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2412 @_copy_docstring_and_deprecators(Axes.bar_label)
2413 def bar_label(
2414         container, labels=None, *, fmt='%g', label_type='edge',
2415         padding=0, **kwargs):
2416     return gca().bar_label(
2417         container, labels=labels, fmt=fmt, label_type=label_type,
2418         padding=padding, **kwargs)
2419 
2420 
2421 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2422 @_copy_docstring_and_deprecators(Axes.boxplot)
2423 def boxplot(
2424         x, notch=None, sym=None, vert=None, whis=None,
2425         positions=None, widths=None, patch_artist=None,
2426         bootstrap=None, usermedians=None, conf_intervals=None,
2427         meanline=None, showmeans=None, showcaps=None, showbox=None,
2428         showfliers=None, boxprops=None, labels=None, flierprops=None,
2429         medianprops=None, meanprops=None, capprops=None,
2430         whiskerprops=None, manage_ticks=True, autorange=False,
2431         zorder=None, capwidths=None, *, data=None):
2432     return gca().boxplot(
2433         x, notch=notch, sym=sym, vert=vert, whis=whis,
2434         positions=positions, widths=widths, patch_artist=patch_artist,
2435         bootstrap=bootstrap, usermedians=usermedians,
2436         conf_intervals=conf_intervals, meanline=meanline,
2437         showmeans=showmeans, showcaps=showcaps, showbox=showbox,
2438         showfliers=showfliers, boxprops=boxprops, labels=labels,
2439         flierprops=flierprops, medianprops=medianprops,
2440         meanprops=meanprops, capprops=capprops,
2441         whiskerprops=whiskerprops, manage_ticks=manage_ticks,
2442         autorange=autorange, zorder=zorder, capwidths=capwidths,
2443         **({"data": data} if data is not None else {}))
2444 
2445 
2446 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2447 @_copy_docstring_and_deprecators(Axes.broken_barh)
2448 def broken_barh(xranges, yrange, *, data=None, **kwargs):
2449     return gca().broken_barh(
2450         xranges, yrange,
2451         **({"data": data} if data is not None else {}), **kwargs)
2452 
2453 
2454 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2455 @_copy_docstring_and_deprecators(Axes.clabel)
2456 def clabel(CS, levels=None, **kwargs):
2457     return gca().clabel(CS, levels=levels, **kwargs)
2458 
2459 
2460 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2461 @_copy_docstring_and_deprecators(Axes.cohere)
2462 def cohere(
2463         x, y, NFFT=256, Fs=2, Fc=0, detrend=mlab.detrend_none,
2464         window=mlab.window_hanning, noverlap=0, pad_to=None,
2465         sides='default', scale_by_freq=None, *, data=None, **kwargs):
2466     return gca().cohere(
2467         x, y, NFFT=NFFT, Fs=Fs, Fc=Fc, detrend=detrend, window=window,
2468         noverlap=noverlap, pad_to=pad_to, sides=sides,
2469         scale_by_freq=scale_by_freq,
2470         **({"data": data} if data is not None else {}), **kwargs)
2471 
2472 
2473 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2474 @_copy_docstring_and_deprecators(Axes.contour)
2475 def contour(*args, data=None, **kwargs):
2476     __ret = gca().contour(
2477         *args, **({"data": data} if data is not None else {}),
2478         **kwargs)
2479     if __ret._A is not None: sci(__ret)  # noqa
2480     return __ret
2481 
2482 
2483 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2484 @_copy_docstring_and_deprecators(Axes.contourf)
2485 def contourf(*args, data=None, **kwargs):
2486     __ret = gca().contourf(
2487         *args, **({"data": data} if data is not None else {}),
2488         **kwargs)
2489     if __ret._A is not None: sci(__ret)  # noqa
2490     return __ret
2491 
2492 
2493 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2494 @_copy_docstring_and_deprecators(Axes.csd)
2495 def csd(
2496         x, y, NFFT=None, Fs=None, Fc=None, detrend=None, window=None,
2497         noverlap=None, pad_to=None, sides=None, scale_by_freq=None,
2498         return_line=None, *, data=None, **kwargs):
2499     return gca().csd(
2500         x, y, NFFT=NFFT, Fs=Fs, Fc=Fc, detrend=detrend, window=window,
2501         noverlap=noverlap, pad_to=pad_to, sides=sides,
2502         scale_by_freq=scale_by_freq, return_line=return_line,
2503         **({"data": data} if data is not None else {}), **kwargs)
2504 
2505 
2506 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2507 @_copy_docstring_and_deprecators(Axes.errorbar)
2508 def errorbar(
2509         x, y, yerr=None, xerr=None, fmt='', ecolor=None,
2510         elinewidth=None, capsize=None, barsabove=False, lolims=False,
2511         uplims=False, xlolims=False, xuplims=False, errorevery=1,
2512         capthick=None, *, data=None, **kwargs):
2513     return gca().errorbar(
2514         x, y, yerr=yerr, xerr=xerr, fmt=fmt, ecolor=ecolor,
2515         elinewidth=elinewidth, capsize=capsize, barsabove=barsabove,
2516         lolims=lolims, uplims=uplims, xlolims=xlolims,
2517         xuplims=xuplims, errorevery=errorevery, capthick=capthick,
2518         **({"data": data} if data is not None else {}), **kwargs)
2519 
2520 
2521 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2522 @_copy_docstring_and_deprecators(Axes.eventplot)
2523 def eventplot(
2524         positions, orientation='horizontal', lineoffsets=1,
2525         linelengths=1, linewidths=None, colors=None,
2526         linestyles='solid', *, data=None, **kwargs):
2527     return gca().eventplot(
2528         positions, orientation=orientation, lineoffsets=lineoffsets,
2529         linelengths=linelengths, linewidths=linewidths, colors=colors,
2530         linestyles=linestyles,
2531         **({"data": data} if data is not None else {}), **kwargs)
2532 
2533 
2534 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2535 @_copy_docstring_and_deprecators(Axes.fill)
2536 def fill(*args, data=None, **kwargs):
2537     return gca().fill(
2538         *args, **({"data": data} if data is not None else {}),
2539         **kwargs)
2540 
2541 
2542 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2543 @_copy_docstring_and_deprecators(Axes.fill_between)
2544 def fill_between(
2545         x, y1, y2=0, where=None, interpolate=False, step=None, *,
2546         data=None, **kwargs):
2547     return gca().fill_between(
2548         x, y1, y2=y2, where=where, interpolate=interpolate, step=step,
2549         **({"data": data} if data is not None else {}), **kwargs)
2550 
2551 
2552 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2553 @_copy_docstring_and_deprecators(Axes.fill_betweenx)
2554 def fill_betweenx(
2555         y, x1, x2=0, where=None, step=None, interpolate=False, *,
2556         data=None, **kwargs):
2557     return gca().fill_betweenx(
2558         y, x1, x2=x2, where=where, step=step, interpolate=interpolate,
2559         **({"data": data} if data is not None else {}), **kwargs)
2560 
2561 
2562 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2563 @_copy_docstring_and_deprecators(Axes.grid)
2564 def grid(visible=None, which='major', axis='both', **kwargs):
2565     return gca().grid(visible=visible, which=which, axis=axis, **kwargs)
2566 
2567 
2568 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2569 @_copy_docstring_and_deprecators(Axes.hexbin)
2570 def hexbin(
2571         x, y, C=None, gridsize=100, bins=None, xscale='linear',
2572         yscale='linear', extent=None, cmap=None, norm=None, vmin=None,
2573         vmax=None, alpha=None, linewidths=None, edgecolors='face',
2574         reduce_C_function=np.mean, mincnt=None, marginals=False, *,
2575         data=None, **kwargs):
2576     __ret = gca().hexbin(
2577         x, y, C=C, gridsize=gridsize, bins=bins, xscale=xscale,
2578         yscale=yscale, extent=extent, cmap=cmap, norm=norm, vmin=vmin,
2579         vmax=vmax, alpha=alpha, linewidths=linewidths,
2580         edgecolors=edgecolors, reduce_C_function=reduce_C_function,
2581         mincnt=mincnt, marginals=marginals,
2582         **({"data": data} if data is not None else {}), **kwargs)
2583     sci(__ret)
2584     return __ret
2585 
2586 
2587 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2588 @_copy_docstring_and_deprecators(Axes.hist)
2589 def hist(
2590         x, bins=None, range=None, density=False, weights=None,
2591         cumulative=False, bottom=None, histtype='bar', align='mid',
2592         orientation='vertical', rwidth=None, log=False, color=None,
2593         label=None, stacked=False, *, data=None, **kwargs):
2594     return gca().hist(
2595         x, bins=bins, range=range, density=density, weights=weights,
2596         cumulative=cumulative, bottom=bottom, histtype=histtype,
2597         align=align, orientation=orientation, rwidth=rwidth, log=log,
2598         color=color, label=label, stacked=stacked,
2599         **({"data": data} if data is not None else {}), **kwargs)
2600 
2601 
2602 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2603 @_copy_docstring_and_deprecators(Axes.stairs)
2604 def stairs(
2605         values, edges=None, *, orientation='vertical', baseline=0,
2606         fill=False, data=None, **kwargs):
2607     return gca().stairs(
2608         values, edges=edges, orientation=orientation,
2609         baseline=baseline, fill=fill,
2610         **({"data": data} if data is not None else {}), **kwargs)
2611 
2612 
2613 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2614 @_copy_docstring_and_deprecators(Axes.hist2d)
2615 def hist2d(
2616         x, y, bins=10, range=None, density=False, weights=None,
2617         cmin=None, cmax=None, *, data=None, **kwargs):
2618     __ret = gca().hist2d(
2619         x, y, bins=bins, range=range, density=density,
2620         weights=weights, cmin=cmin, cmax=cmax,
2621         **({"data": data} if data is not None else {}), **kwargs)
2622     sci(__ret[-1])
2623     return __ret
2624 
2625 
2626 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2627 @_copy_docstring_and_deprecators(Axes.hlines)
2628 def hlines(
2629         y, xmin, xmax, colors=None, linestyles='solid', label='', *,
2630         data=None, **kwargs):
2631     return gca().hlines(
2632         y, xmin, xmax, colors=colors, linestyles=linestyles,
2633         label=label, **({"data": data} if data is not None else {}),
2634         **kwargs)
2635 
2636 
2637 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2638 @_copy_docstring_and_deprecators(Axes.imshow)
2639 def imshow(
2640         X, cmap=None, norm=None, aspect=None, interpolation=None,
2641         alpha=None, vmin=None, vmax=None, origin=None, extent=None, *,
2642         interpolation_stage=None, filternorm=True, filterrad=4.0,
2643         resample=None, url=None, data=None, **kwargs):
2644     __ret = gca().imshow(
2645         X, cmap=cmap, norm=norm, aspect=aspect,
2646         interpolation=interpolation, alpha=alpha, vmin=vmin,
2647         vmax=vmax, origin=origin, extent=extent,
2648         interpolation_stage=interpolation_stage,
2649         filternorm=filternorm, filterrad=filterrad, resample=resample,
2650         url=url, **({"data": data} if data is not None else {}),
2651         **kwargs)
2652     sci(__ret)
2653     return __ret
2654 
2655 
2656 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2657 @_copy_docstring_and_deprecators(Axes.legend)
2658 def legend(*args, **kwargs):
2659     return gca().legend(*args, **kwargs)
2660 
2661 
2662 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2663 @_copy_docstring_and_deprecators(Axes.locator_params)
2664 def locator_params(axis='both', tight=None, **kwargs):
2665     return gca().locator_params(axis=axis, tight=tight, **kwargs)
2666 
2667 
2668 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2669 @_copy_docstring_and_deprecators(Axes.loglog)
2670 def loglog(*args, **kwargs):
2671     return gca().loglog(*args, **kwargs)
2672 
2673 
2674 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2675 @_copy_docstring_and_deprecators(Axes.magnitude_spectrum)
2676 def magnitude_spectrum(
2677         x, Fs=None, Fc=None, window=None, pad_to=None, sides=None,
2678         scale=None, *, data=None, **kwargs):
2679     return gca().magnitude_spectrum(
2680         x, Fs=Fs, Fc=Fc, window=window, pad_to=pad_to, sides=sides,
2681         scale=scale, **({"data": data} if data is not None else {}),
2682         **kwargs)
2683 
2684 
2685 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2686 @_copy_docstring_and_deprecators(Axes.margins)
2687 def margins(*margins, x=None, y=None, tight=True):
2688     return gca().margins(*margins, x=x, y=y, tight=tight)
2689 
2690 
2691 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2692 @_copy_docstring_and_deprecators(Axes.minorticks_off)
2693 def minorticks_off():
2694     return gca().minorticks_off()
2695 
2696 
2697 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2698 @_copy_docstring_and_deprecators(Axes.minorticks_on)
2699 def minorticks_on():
2700     return gca().minorticks_on()
2701 
2702 
2703 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2704 @_copy_docstring_and_deprecators(Axes.pcolor)
2705 def pcolor(
2706         *args, shading=None, alpha=None, norm=None, cmap=None,
2707         vmin=None, vmax=None, data=None, **kwargs):
2708     __ret = gca().pcolor(
2709         *args, shading=shading, alpha=alpha, norm=norm, cmap=cmap,
2710         vmin=vmin, vmax=vmax,
2711         **({"data": data} if data is not None else {}), **kwargs)
2712     sci(__ret)
2713     return __ret
2714 
2715 
2716 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2717 @_copy_docstring_and_deprecators(Axes.pcolormesh)
2718 def pcolormesh(
2719         *args, alpha=None, norm=None, cmap=None, vmin=None,
2720         vmax=None, shading=None, antialiased=False, data=None,
2721         **kwargs):
2722     __ret = gca().pcolormesh(
2723         *args, alpha=alpha, norm=norm, cmap=cmap, vmin=vmin,
2724         vmax=vmax, shading=shading, antialiased=antialiased,
2725         **({"data": data} if data is not None else {}), **kwargs)
2726     sci(__ret)
2727     return __ret
2728 
2729 
2730 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2731 @_copy_docstring_and_deprecators(Axes.phase_spectrum)
2732 def phase_spectrum(
2733         x, Fs=None, Fc=None, window=None, pad_to=None, sides=None, *,
2734         data=None, **kwargs):
2735     return gca().phase_spectrum(
2736         x, Fs=Fs, Fc=Fc, window=window, pad_to=pad_to, sides=sides,
2737         **({"data": data} if data is not None else {}), **kwargs)
2738 
2739 
2740 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2741 @_copy_docstring_and_deprecators(Axes.pie)
2742 def pie(
2743         x, explode=None, labels=None, colors=None, autopct=None,
2744         pctdistance=0.6, shadow=False, labeldistance=1.1,
2745         startangle=0, radius=1, counterclock=True, wedgeprops=None,
2746         textprops=None, center=(0, 0), frame=False,
2747         rotatelabels=False, *, normalize=True, data=None):
2748     return gca().pie(
2749         x, explode=explode, labels=labels, colors=colors,
2750         autopct=autopct, pctdistance=pctdistance, shadow=shadow,
2751         labeldistance=labeldistance, startangle=startangle,
2752         radius=radius, counterclock=counterclock,
2753         wedgeprops=wedgeprops, textprops=textprops, center=center,
2754         frame=frame, rotatelabels=rotatelabels, normalize=normalize,
2755         **({"data": data} if data is not None else {}))
2756 
2757 
2758 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2759 @_copy_docstring_and_deprecators(Axes.plot)
2760 def plot(*args, scalex=True, scaley=True, data=None, **kwargs):
2761     return gca().plot(
2762         *args, scalex=scalex, scaley=scaley,
2763         **({"data": data} if data is not None else {}), **kwargs)
2764 
2765 
2766 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2767 @_copy_docstring_and_deprecators(Axes.plot_date)
2768 def plot_date(
2769         x, y, fmt='o', tz=None, xdate=True, ydate=False, *,
2770         data=None, **kwargs):
2771     return gca().plot_date(
2772         x, y, fmt=fmt, tz=tz, xdate=xdate, ydate=ydate,
2773         **({"data": data} if data is not None else {}), **kwargs)
2774 
2775 
2776 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2777 @_copy_docstring_and_deprecators(Axes.psd)
2778 def psd(
2779         x, NFFT=None, Fs=None, Fc=None, detrend=None, window=None,
2780         noverlap=None, pad_to=None, sides=None, scale_by_freq=None,
2781         return_line=None, *, data=None, **kwargs):
2782     return gca().psd(
2783         x, NFFT=NFFT, Fs=Fs, Fc=Fc, detrend=detrend, window=window,
2784         noverlap=noverlap, pad_to=pad_to, sides=sides,
2785         scale_by_freq=scale_by_freq, return_line=return_line,
2786         **({"data": data} if data is not None else {}), **kwargs)
2787 
2788 
2789 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2790 @_copy_docstring_and_deprecators(Axes.quiver)
2791 def quiver(*args, data=None, **kwargs):
2792     __ret = gca().quiver(
2793         *args, **({"data": data} if data is not None else {}),
2794         **kwargs)
2795     sci(__ret)
2796     return __ret
2797 
2798 
2799 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2800 @_copy_docstring_and_deprecators(Axes.quiverkey)
2801 def quiverkey(Q, X, Y, U, label, **kwargs):
2802     return gca().quiverkey(Q, X, Y, U, label, **kwargs)
2803 
2804 
2805 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2806 @_copy_docstring_and_deprecators(Axes.scatter)
2807 def scatter(
2808         x, y, s=None, c=None, marker=None, cmap=None, norm=None,
2809         vmin=None, vmax=None, alpha=None, linewidths=None, *,
2810         edgecolors=None, plotnonfinite=False, data=None, **kwargs):
2811     __ret = gca().scatter(
2812         x, y, s=s, c=c, marker=marker, cmap=cmap, norm=norm,
2813         vmin=vmin, vmax=vmax, alpha=alpha, linewidths=linewidths,
2814         edgecolors=edgecolors, plotnonfinite=plotnonfinite,
2815         **({"data": data} if data is not None else {}), **kwargs)
2816     sci(__ret)
2817     return __ret
2818 
2819 
2820 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2821 @_copy_docstring_and_deprecators(Axes.semilogx)
2822 def semilogx(*args, **kwargs):
2823     return gca().semilogx(*args, **kwargs)
2824 
2825 
2826 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2827 @_copy_docstring_and_deprecators(Axes.semilogy)
2828 def semilogy(*args, **kwargs):
2829     return gca().semilogy(*args, **kwargs)
2830 
2831 
2832 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2833 @_copy_docstring_and_deprecators(Axes.specgram)
2834 def specgram(
2835         x, NFFT=None, Fs=None, Fc=None, detrend=None, window=None,
2836         noverlap=None, cmap=None, xextent=None, pad_to=None,
2837         sides=None, scale_by_freq=None, mode=None, scale=None,
2838         vmin=None, vmax=None, *, data=None, **kwargs):
2839     __ret = gca().specgram(
2840         x, NFFT=NFFT, Fs=Fs, Fc=Fc, detrend=detrend, window=window,
2841         noverlap=noverlap, cmap=cmap, xextent=xextent, pad_to=pad_to,
2842         sides=sides, scale_by_freq=scale_by_freq, mode=mode,
2843         scale=scale, vmin=vmin, vmax=vmax,
2844         **({"data": data} if data is not None else {}), **kwargs)
2845     sci(__ret[-1])
2846     return __ret
2847 
2848 
2849 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2850 @_copy_docstring_and_deprecators(Axes.spy)
2851 def spy(
2852         Z, precision=0, marker=None, markersize=None, aspect='equal',
2853         origin='upper', **kwargs):
2854     __ret = gca().spy(
2855         Z, precision=precision, marker=marker, markersize=markersize,
2856         aspect=aspect, origin=origin, **kwargs)
2857     if isinstance(__ret, cm.ScalarMappable): sci(__ret)  # noqa
2858     return __ret
2859 
2860 
2861 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2862 @_copy_docstring_and_deprecators(Axes.stackplot)
2863 def stackplot(
2864         x, *args, labels=(), colors=None, baseline='zero', data=None,
2865         **kwargs):
2866     return gca().stackplot(
2867         x, *args, labels=labels, colors=colors, baseline=baseline,
2868         **({"data": data} if data is not None else {}), **kwargs)
2869 
2870 
2871 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2872 @_copy_docstring_and_deprecators(Axes.stem)
2873 def stem(
2874         *args, linefmt=None, markerfmt=None, basefmt=None, bottom=0,
2875         label=None, use_line_collection=True, orientation='vertical',
2876         data=None):
2877     return gca().stem(
2878         *args, linefmt=linefmt, markerfmt=markerfmt, basefmt=basefmt,
2879         bottom=bottom, label=label,
2880         use_line_collection=use_line_collection,
2881         orientation=orientation,
2882         **({"data": data} if data is not None else {}))
2883 
2884 
2885 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2886 @_copy_docstring_and_deprecators(Axes.step)
2887 def step(x, y, *args, where='pre', data=None, **kwargs):
2888     return gca().step(
2889         x, y, *args, where=where,
2890         **({"data": data} if data is not None else {}), **kwargs)
2891 
2892 
2893 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2894 @_copy_docstring_and_deprecators(Axes.streamplot)
2895 def streamplot(
2896         x, y, u, v, density=1, linewidth=None, color=None, cmap=None,
2897         norm=None, arrowsize=1, arrowstyle='-|>', minlength=0.1,
2898         transform=None, zorder=None, start_points=None, maxlength=4.0,
2899         integration_direction='both', broken_streamlines=True, *,
2900         data=None):
2901     __ret = gca().streamplot(
2902         x, y, u, v, density=density, linewidth=linewidth, color=color,
2903         cmap=cmap, norm=norm, arrowsize=arrowsize,
2904         arrowstyle=arrowstyle, minlength=minlength,
2905         transform=transform, zorder=zorder, start_points=start_points,
2906         maxlength=maxlength,
2907         integration_direction=integration_direction,
2908         broken_streamlines=broken_streamlines,
2909         **({"data": data} if data is not None else {}))
2910     sci(__ret.lines)
2911     return __ret
2912 
2913 
2914 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2915 @_copy_docstring_and_deprecators(Axes.table)
2916 def table(
2917         cellText=None, cellColours=None, cellLoc='right',
2918         colWidths=None, rowLabels=None, rowColours=None,
2919         rowLoc='left', colLabels=None, colColours=None,
2920         colLoc='center', loc='bottom', bbox=None, edges='closed',
2921         **kwargs):
2922     return gca().table(
2923         cellText=cellText, cellColours=cellColours, cellLoc=cellLoc,
2924         colWidths=colWidths, rowLabels=rowLabels,
2925         rowColours=rowColours, rowLoc=rowLoc, colLabels=colLabels,
2926         colColours=colColours, colLoc=colLoc, loc=loc, bbox=bbox,
2927         edges=edges, **kwargs)
2928 
2929 
2930 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2931 @_copy_docstring_and_deprecators(Axes.text)
2932 def text(x, y, s, fontdict=None, **kwargs):
2933     return gca().text(x, y, s, fontdict=fontdict, **kwargs)
2934 
2935 
2936 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2937 @_copy_docstring_and_deprecators(Axes.tick_params)
2938 def tick_params(axis='both', **kwargs):
2939     return gca().tick_params(axis=axis, **kwargs)
2940 
2941 
2942 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2943 @_copy_docstring_and_deprecators(Axes.ticklabel_format)
2944 def ticklabel_format(
2945         *, axis='both', style='', scilimits=None, useOffset=None,
2946         useLocale=None, useMathText=None):
2947     return gca().ticklabel_format(
2948         axis=axis, style=style, scilimits=scilimits,
2949         useOffset=useOffset, useLocale=useLocale,
2950         useMathText=useMathText)
2951 
2952 
2953 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2954 @_copy_docstring_and_deprecators(Axes.tricontour)
2955 def tricontour(*args, **kwargs):
2956     __ret = gca().tricontour(*args, **kwargs)
2957     if __ret._A is not None: sci(__ret)  # noqa
2958     return __ret
2959 
2960 
2961 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2962 @_copy_docstring_and_deprecators(Axes.tricontourf)
2963 def tricontourf(*args, **kwargs):
2964     __ret = gca().tricontourf(*args, **kwargs)
2965     if __ret._A is not None: sci(__ret)  # noqa
2966     return __ret
2967 
2968 
2969 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2970 @_copy_docstring_and_deprecators(Axes.tripcolor)
2971 def tripcolor(
2972         *args, alpha=1.0, norm=None, cmap=None, vmin=None, vmax=None,
2973         shading='flat', facecolors=None, **kwargs):
2974     __ret = gca().tripcolor(
2975         *args, alpha=alpha, norm=norm, cmap=cmap, vmin=vmin,
2976         vmax=vmax, shading=shading, facecolors=facecolors, **kwargs)
2977     sci(__ret)
2978     return __ret
2979 
2980 
2981 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2982 @_copy_docstring_and_deprecators(Axes.triplot)
2983 def triplot(*args, **kwargs):
2984     return gca().triplot(*args, **kwargs)
2985 
2986 
2987 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2988 @_copy_docstring_and_deprecators(Axes.violinplot)
2989 def violinplot(
2990         dataset, positions=None, vert=True, widths=0.5,
2991         showmeans=False, showextrema=True, showmedians=False,
2992         quantiles=None, points=100, bw_method=None, *, data=None):
2993     return gca().violinplot(
2994         dataset, positions=positions, vert=vert, widths=widths,
2995         showmeans=showmeans, showextrema=showextrema,
2996         showmedians=showmedians, quantiles=quantiles, points=points,
2997         bw_method=bw_method,
2998         **({"data": data} if data is not None else {}))
2999 
3000 
3001 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3002 @_copy_docstring_and_deprecators(Axes.vlines)
3003 def vlines(
3004         x, ymin, ymax, colors=None, linestyles='solid', label='', *,
3005         data=None, **kwargs):
3006     return gca().vlines(
3007         x, ymin, ymax, colors=colors, linestyles=linestyles,
3008         label=label, **({"data": data} if data is not None else {}),
3009         **kwargs)
3010 
3011 
3012 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3013 @_copy_docstring_and_deprecators(Axes.xcorr)
3014 def xcorr(
3015         x, y, normed=True, detrend=mlab.detrend_none, usevlines=True,
3016         maxlags=10, *, data=None, **kwargs):
3017     return gca().xcorr(
3018         x, y, normed=normed, detrend=detrend, usevlines=usevlines,
3019         maxlags=maxlags,
3020         **({"data": data} if data is not None else {}), **kwargs)
3021 
3022 
3023 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3024 @_copy_docstring_and_deprecators(Axes._sci)
3025 def sci(im):
3026     return gca()._sci(im)
3027 
3028 
3029 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3030 @_copy_docstring_and_deprecators(Axes.set_title)
3031 def title(label, fontdict=None, loc=None, pad=None, *, y=None, **kwargs):
3032     return gca().set_title(
3033         label, fontdict=fontdict, loc=loc, pad=pad, y=y, **kwargs)
3034 
3035 
3036 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3037 @_copy_docstring_and_deprecators(Axes.set_xlabel)
3038 def xlabel(xlabel, fontdict=None, labelpad=None, *, loc=None, **kwargs):
3039     return gca().set_xlabel(
3040         xlabel, fontdict=fontdict, labelpad=labelpad, loc=loc,
3041         **kwargs)
3042 
3043 
3044 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3045 @_copy_docstring_and_deprecators(Axes.set_ylabel)
3046 def ylabel(ylabel, fontdict=None, labelpad=None, *, loc=None, **kwargs):
3047     return gca().set_ylabel(
3048         ylabel, fontdict=fontdict, labelpad=labelpad, loc=loc,
3049         **kwargs)
3050 
3051 
3052 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3053 @_copy_docstring_and_deprecators(Axes.set_xscale)
3054 def xscale(value, **kwargs):
3055     return gca().set_xscale(value, **kwargs)
3056 
3057 
3058 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3059 @_copy_docstring_and_deprecators(Axes.set_yscale)
3060 def yscale(value, **kwargs):
3061     return gca().set_yscale(value, **kwargs)
3062 
3063 
3064 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3065 def autumn(): set_cmap('autumn')
3066 def bone(): set_cmap('bone')
3067 def cool(): set_cmap('cool')
3068 def copper(): set_cmap('copper')
3069 def flag(): set_cmap('flag')
3070 def gray(): set_cmap('gray')
3071 def hot(): set_cmap('hot')
3072 def hsv(): set_cmap('hsv')
3073 def jet(): set_cmap('jet')
3074 def pink(): set_cmap('pink')
3075 def prism(): set_cmap('prism')
3076 def spring(): set_cmap('spring')
3077 def summer(): set_cmap('summer')
3078 def winter(): set_cmap('winter')
3079 def magma(): set_cmap('magma')
3080 def inferno(): set_cmap('inferno')
3081 def plasma(): set_cmap('plasma')
3082 def viridis(): set_cmap('viridis')
3083 def nipy_spectral(): set_cmap('nipy_spectral')
3084 
3085 
3086 _setup_pyplot_info_docstrings()

</code><intended_behavior>The code should correctly handle instances when `ax` is contained within a `SubFigure`, not just a standard `Figure`. Currently, it assumes `ax.figure` can always be directly passed to `figure(ax.figure)`, which fails with `SubFigure` instances due to type errors. The fix should include a check if `ax.figure` is a `SubFigure` instance and handle this case appropriately, possibly by navigating to the parent figure if necessary, without changing the behavior for standard figures.</intended_behavior>, <file>lib/matplotlib/pyplot.py</file>
<class>None</class>
<method>None</method>
<code>
1 # Note: The first part of this file can be modified in place, but the latter
2 # part is autogenerated by the boilerplate.py script.
3 
4 """
5 `matplotlib.pyplot` is a state-based interface to matplotlib. It provides
6 an implicit,  MATLAB-like, way of plotting.  It also opens figures on your
7 screen, and acts as the figure GUI manager.
8 
9 pyplot is mainly intended for interactive plots and simple cases of
10 programmatic plot generation::
11 
12     import numpy as np
13     import matplotlib.pyplot as plt
14 
15     x = np.arange(0, 5, 0.1)
16     y = np.sin(x)
17     plt.plot(x, y)
18 
19 The explicit object-oriented API is recommended for complex plots, though
20 pyplot is still usually used to create the figure and often the axes in the
21 figure. See `.pyplot.figure`, `.pyplot.subplots`, and
22 `.pyplot.subplot_mosaic` to create figures, and
23 :doc:`Axes API <../axes_api>` for the plotting methods on an Axes::
24 
25     import numpy as np
26     import matplotlib.pyplot as plt
27 
28     x = np.arange(0, 5, 0.1)
29     y = np.sin(x)
30     fig, ax = plt.subplots()
31     ax.plot(x, y)
32 
33 
34 See :ref:`api_interfaces` for an explanation of the tradeoffs between the
35 implicit and explicit interfaces.
36 """
37 
38 from enum import Enum
39 import functools
40 import importlib
41 import inspect
42 import logging
43 from numbers import Number
44 import re
45 import sys
46 import time
47 try:
48     import threading
49 except ImportError:
50     import dummy_threading as threading
51 
52 from cycler import cycler
53 import matplotlib
54 import matplotlib.colorbar
55 import matplotlib.image
56 from matplotlib import _api
57 from matplotlib import rcsetup, style
58 from matplotlib import _pylab_helpers, interactive
59 from matplotlib import cbook
60 from matplotlib import _docstring
61 from matplotlib.backend_bases import FigureCanvasBase, MouseButton
62 from matplotlib.figure import Figure, figaspect
63 from matplotlib.gridspec import GridSpec, SubplotSpec
64 from matplotlib import rcParams, rcParamsDefault, get_backend, rcParamsOrig
65 from matplotlib.rcsetup import interactive_bk as _interactive_bk
66 from matplotlib.artist import Artist
67 from matplotlib.axes import Axes, Subplot
68 from matplotlib.projections import PolarAxes
69 from matplotlib import mlab  # for detrend_none, window_hanning
70 from matplotlib.scale import get_scale_names
71 
72 from matplotlib import cm
73 from matplotlib.cm import _colormaps as colormaps, get_cmap, register_cmap
74 from matplotlib.colors import _color_sequences as color_sequences
75 
76 import numpy as np
77 
78 # We may not need the following imports here:
79 from matplotlib.colors import Normalize
80 from matplotlib.lines import Line2D
81 from matplotlib.text import Text, Annotation
82 from matplotlib.patches import Polygon, Rectangle, Circle, Arrow
83 from matplotlib.widgets import Button, Slider, Widget
84 
85 from .ticker import (
86     TickHelper, Formatter, FixedFormatter, NullFormatter, FuncFormatter,
87     FormatStrFormatter, ScalarFormatter, LogFormatter, LogFormatterExponent,
88     LogFormatterMathtext, Locator, IndexLocator, FixedLocator, NullLocator,
89     LinearLocator, LogLocator, AutoLocator, MultipleLocator, MaxNLocator)
90 
91 _log = logging.getLogger(__name__)
92 
93 
94 def _copy_docstring_and_deprecators(method, func=None):
95     if func is None:
96         return functools.partial(_copy_docstring_and_deprecators, method)
97     decorators = [_docstring.copy(method)]
98     # Check whether the definition of *method* includes @_api.rename_parameter
99     # or @_api.make_keyword_only decorators; if so, propagate them to the
100     # pyplot wrapper as well.
101     while getattr(method, "__wrapped__", None) is not None:
102         decorator = _api.deprecation.DECORATORS.get(method)
103         if decorator:
104             decorators.append(decorator)
105         method = method.__wrapped__
106     for decorator in decorators[::-1]:
107         func = decorator(func)
108     return func
109 
110 
111 ## Global ##
112 
113 
114 # The state controlled by {,un}install_repl_displayhook().
115 _ReplDisplayHook = Enum("_ReplDisplayHook", ["NONE", "PLAIN", "IPYTHON"])
116 _REPL_DISPLAYHOOK = _ReplDisplayHook.NONE
117 
118 
119 def _draw_all_if_interactive():
120     if matplotlib.is_interactive():
121         draw_all()
122 
123 
124 def install_repl_displayhook():
125     """
126     Connect to the display hook of the current shell.
127 
128     The display hook gets called when the read-evaluate-print-loop (REPL) of
129     the shell has finished the execution of a command. We use this callback
130     to be able to automatically update a figure in interactive mode.
131 
132     This works both with IPython and with vanilla python shells.
133     """
134     global _REPL_DISPLAYHOOK
135 
136     if _REPL_DISPLAYHOOK is _ReplDisplayHook.IPYTHON:
137         return
138 
139     # See if we have IPython hooks around, if so use them.
140     # Use ``sys.modules.get(name)`` rather than ``name in sys.modules`` as
141     # entries can also have been explicitly set to None.
142     mod_ipython = sys.modules.get("IPython")
143     if not mod_ipython:
144         _REPL_DISPLAYHOOK = _ReplDisplayHook.PLAIN
145         return
146     ip = mod_ipython.get_ipython()
147     if not ip:
148         _REPL_DISPLAYHOOK = _ReplDisplayHook.PLAIN
149         return
150 
151     ip.events.register("post_execute", _draw_all_if_interactive)
152     _REPL_DISPLAYHOOK = _ReplDisplayHook.IPYTHON
153 
154     from IPython.core.pylabtools import backend2gui
155     # trigger IPython's eventloop integration, if available
156     ipython_gui_name = backend2gui.get(get_backend())
157     if ipython_gui_name:
158         ip.enable_gui(ipython_gui_name)
159 
160 
161 def uninstall_repl_displayhook():
162     """Disconnect from the display hook of the current shell."""
163     global _REPL_DISPLAYHOOK
164     if _REPL_DISPLAYHOOK is _ReplDisplayHook.IPYTHON:
165         from IPython import get_ipython
166         ip = get_ipython()
167         ip.events.unregister("post_execute", _draw_all_if_interactive)
168     _REPL_DISPLAYHOOK = _ReplDisplayHook.NONE
169 
170 
171 draw_all = _pylab_helpers.Gcf.draw_all
172 
173 
174 @_copy_docstring_and_deprecators(matplotlib.set_loglevel)
175 def set_loglevel(*args, **kwargs):  # Ensure this appears in the pyplot docs.
176     return matplotlib.set_loglevel(*args, **kwargs)
177 
178 
179 @_copy_docstring_and_deprecators(Artist.findobj)
180 def findobj(o=None, match=None, include_self=True):
181     if o is None:
182         o = gcf()
183     return o.findobj(match, include_self=include_self)
184 
185 
186 def _get_required_interactive_framework(backend_mod):
187     if not hasattr(backend_mod.FigureCanvas, "required_interactive_framework"):
188         _api.warn_deprecated(
189             "3.6", name="Support for FigureCanvases without a "
190             "required_interactive_framework attribute")
191         return None
192     # Inline this once the deprecation elapses.
193     return backend_mod.FigureCanvas.required_interactive_framework
194 
195 _backend_mod = None
196 
197 
198 def _get_backend_mod():
199     """
200     Ensure that a backend is selected and return it.
201 
202     This is currently private, but may be made public in the future.
203     """
204     if _backend_mod is None:
205         # Use __getitem__ here to avoid going through the fallback logic (which
206         # will (re)import pyplot and then call switch_backend if we need to
207         # resolve the auto sentinel)
208         switch_backend(dict.__getitem__(rcParams, "backend"))
209         # Just to be safe.  Interactive mode can be turned on without calling
210         # `plt.ion()` so register it again here.  This is safe because multiple
211         # calls to `install_repl_displayhook` are no-ops and the registered
212         # function respects `mpl.is_interactive()` to determine if it should
213         # trigger a draw.
214         install_repl_displayhook()
215     return _backend_mod
216 
217 
218 def switch_backend(newbackend):
219     """
220     Close all open figures and set the Matplotlib backend.
221 
222     The argument is case-insensitive.  Switching to an interactive backend is
223     possible only if no event loop for another interactive backend has started.
224     Switching to and from non-interactive backends is always possible.
225 
226     Parameters
227     ----------
228     newbackend : str
229         The name of the backend to use.
230     """
231     global _backend_mod
232     # make sure the init is pulled up so we can assign to it later
233     import matplotlib.backends
234     close("all")
235 
236     if newbackend is rcsetup._auto_backend_sentinel:
237         current_framework = cbook._get_running_interactive_framework()
238         mapping = {'qt': 'qtagg',
239                    'gtk3': 'gtk3agg',
240                    'gtk4': 'gtk4agg',
241                    'wx': 'wxagg',
242                    'tk': 'tkagg',
243                    'macosx': 'macosx',
244                    'headless': 'agg'}
245 
246         best_guess = mapping.get(current_framework, None)
247         if best_guess is not None:
248             candidates = [best_guess]
249         else:
250             candidates = []
251         candidates += [
252             "macosx", "qtagg", "gtk4agg", "gtk3agg", "tkagg", "wxagg"]
253 
254         # Don't try to fallback on the cairo-based backends as they each have
255         # an additional dependency (pycairo) over the agg-based backend, and
256         # are of worse quality.
257         for candidate in candidates:
258             try:
259                 switch_backend(candidate)
260             except ImportError:
261                 continue
262             else:
263                 rcParamsOrig['backend'] = candidate
264                 return
265         else:
266             # Switching to Agg should always succeed; if it doesn't, let the
267             # exception propagate out.
268             switch_backend("agg")
269             rcParamsOrig["backend"] = "agg"
270             return
271 
272     # Backends are implemented as modules, but "inherit" default method
273     # implementations from backend_bases._Backend.  This is achieved by
274     # creating a "class" that inherits from backend_bases._Backend and whose
275     # body is filled with the module's globals.
276 
277     backend_name = cbook._backend_module_name(newbackend)
278 
279     class backend_mod(matplotlib.backend_bases._Backend):
280         locals().update(vars(importlib.import_module(backend_name)))
281 
282     required_framework = _get_required_interactive_framework(backend_mod)
283     if required_framework is not None:
284         current_framework = cbook._get_running_interactive_framework()
285         if (current_framework and required_framework
286                 and current_framework != required_framework):
287             raise ImportError(
288                 "Cannot load backend {!r} which requires the {!r} interactive "
289                 "framework, as {!r} is currently running".format(
290                     newbackend, required_framework, current_framework))
291 
292     _log.debug("Loaded backend %s version %s.",
293                newbackend, backend_mod.backend_version)
294 
295     rcParams['backend'] = rcParamsDefault['backend'] = newbackend
296     _backend_mod = backend_mod
297     for func_name in ["new_figure_manager", "draw_if_interactive", "show"]:
298         globals()[func_name].__signature__ = inspect.signature(
299             getattr(backend_mod, func_name))
300 
301     # Need to keep a global reference to the backend for compatibility reasons.
302     # See https://github.com/matplotlib/matplotlib/issues/6092
303     matplotlib.backends.backend = newbackend
304 
305 
306 def _warn_if_gui_out_of_main_thread():
307     if (_get_required_interactive_framework(_get_backend_mod())
308             and threading.current_thread() is not threading.main_thread()):
309         _api.warn_external(
310             "Starting a Matplotlib GUI outside of the main thread will likely "
311             "fail.")
312 
313 
314 # This function's signature is rewritten upon backend-load by switch_backend.
315 def new_figure_manager(*args, **kwargs):
316     """Create a new figure manager instance."""
317     _warn_if_gui_out_of_main_thread()
318     return _get_backend_mod().new_figure_manager(*args, **kwargs)
319 
320 
321 # This function's signature is rewritten upon backend-load by switch_backend.
322 def draw_if_interactive(*args, **kwargs):
323     """
324     Redraw the current figure if in interactive mode.
325 
326     .. warning::
327 
328         End users will typically not have to call this function because the
329         the interactive mode takes care of this.
330     """
331     return _get_backend_mod().draw_if_interactive(*args, **kwargs)
332 
333 
334 # This function's signature is rewritten upon backend-load by switch_backend.
335 def show(*args, **kwargs):
336     """
337     Display all open figures.
338 
339     Parameters
340     ----------
341     block : bool, optional
342         Whether to wait for all figures to be closed before returning.
343 
344         If `True` block and run the GUI main loop until all figure windows
345         are closed.
346 
347         If `False` ensure that all figure windows are displayed and return
348         immediately.  In this case, you are responsible for ensuring
349         that the event loop is running to have responsive figures.
350 
351         Defaults to True in non-interactive mode and to False in interactive
352         mode (see `.pyplot.isinteractive`).
353 
354     See Also
355     --------
356     ion : Enable interactive mode, which shows / updates the figure after
357           every plotting command, so that calling ``show()`` is not necessary.
358     ioff : Disable interactive mode.
359     savefig : Save the figure to an image file instead of showing it on screen.
360 
361     Notes
362     -----
363     **Saving figures to file and showing a window at the same time**
364 
365     If you want an image file as well as a user interface window, use
366     `.pyplot.savefig` before `.pyplot.show`. At the end of (a blocking)
367     ``show()`` the figure is closed and thus unregistered from pyplot. Calling
368     `.pyplot.savefig` afterwards would save a new and thus empty figure. This
369     limitation of command order does not apply if the show is non-blocking or
370     if you keep a reference to the figure and use `.Figure.savefig`.
371 
372     **Auto-show in jupyter notebooks**
373 
374     The jupyter backends (activated via ``%matplotlib inline``,
375     ``%matplotlib notebook``, or ``%matplotlib widget``), call ``show()`` at
376     the end of every cell by default. Thus, you usually don't have to call it
377     explicitly there.
378     """
379     _warn_if_gui_out_of_main_thread()
380     return _get_backend_mod().show(*args, **kwargs)
381 
382 
383 def isinteractive():
384     """
385     Return whether plots are updated after every plotting command.
386 
387     The interactive mode is mainly useful if you build plots from the command
388     line and want to see the effect of each command while you are building the
389     figure.
390 
391     In interactive mode:
392 
393     - newly created figures will be shown immediately;
394     - figures will automatically redraw on change;
395     - `.pyplot.show` will not block by default.
396 
397     In non-interactive mode:
398 
399     - newly created figures and changes to figures will not be reflected until
400       explicitly asked to be;
401     - `.pyplot.show` will block by default.
402 
403     See Also
404     --------
405     ion : Enable interactive mode.
406     ioff : Disable interactive mode.
407     show : Show all figures (and maybe block).
408     pause : Show all figures, and block for a time.
409     """
410     return matplotlib.is_interactive()
411 
412 
413 class _IoffContext:
414     """
415     Context manager for `.ioff`.
416 
417     The state is changed in ``__init__()`` instead of ``__enter__()``. The
418     latter is a no-op. This allows using `.ioff` both as a function and
419     as a context.
420     """
421 
422     def __init__(self):
423         self.wasinteractive = isinteractive()
424         matplotlib.interactive(False)
425         uninstall_repl_displayhook()
426 
427     def __enter__(self):
428         pass
429 
430     def __exit__(self, exc_type, exc_value, traceback):
431         if self.wasinteractive:
432             matplotlib.interactive(True)
433             install_repl_displayhook()
434         else:
435             matplotlib.interactive(False)
436             uninstall_repl_displayhook()
437 
438 
439 class _IonContext:
440     """
441     Context manager for `.ion`.
442 
443     The state is changed in ``__init__()`` instead of ``__enter__()``. The
444     latter is a no-op. This allows using `.ion` both as a function and
445     as a context.
446     """
447 
448     def __init__(self):
449         self.wasinteractive = isinteractive()
450         matplotlib.interactive(True)
451         install_repl_displayhook()
452 
453     def __enter__(self):
454         pass
455 
456     def __exit__(self, exc_type, exc_value, traceback):
457         if not self.wasinteractive:
458             matplotlib.interactive(False)
459             uninstall_repl_displayhook()
460         else:
461             matplotlib.interactive(True)
462             install_repl_displayhook()
463 
464 
465 def ioff():
466     """
467     Disable interactive mode.
468 
469     See `.pyplot.isinteractive` for more details.
470 
471     See Also
472     --------
473     ion : Enable interactive mode.
474     isinteractive : Whether interactive mode is enabled.
475     show : Show all figures (and maybe block).
476     pause : Show all figures, and block for a time.
477 
478     Notes
479     -----
480     For a temporary change, this can be used as a context manager::
481 
482         # if interactive mode is on
483         # then figures will be shown on creation
484         plt.ion()
485         # This figure will be shown immediately
486         fig = plt.figure()
487 
488         with plt.ioff():
489             # interactive mode will be off
490             # figures will not automatically be shown
491             fig2 = plt.figure()
492             # ...
493 
494     To enable usage as a context manager, this function returns an
495     ``_IoffContext`` object. The return value is not intended to be stored
496     or accessed by the user.
497     """
498     return _IoffContext()
499 
500 
501 def ion():
502     """
503     Enable interactive mode.
504 
505     See `.pyplot.isinteractive` for more details.
506 
507     See Also
508     --------
509     ioff : Disable interactive mode.
510     isinteractive : Whether interactive mode is enabled.
511     show : Show all figures (and maybe block).
512     pause : Show all figures, and block for a time.
513 
514     Notes
515     -----
516     For a temporary change, this can be used as a context manager::
517 
518         # if interactive mode is off
519         # then figures will not be shown on creation
520         plt.ioff()
521         # This figure will not be shown immediately
522         fig = plt.figure()
523 
524         with plt.ion():
525             # interactive mode will be on
526             # figures will automatically be shown
527             fig2 = plt.figure()
528             # ...
529 
530     To enable usage as a context manager, this function returns an
531     ``_IonContext`` object. The return value is not intended to be stored
532     or accessed by the user.
533     """
534     return _IonContext()
535 
536 
537 def pause(interval):
538     """
539     Run the GUI event loop for *interval* seconds.
540 
541     If there is an active figure, it will be updated and displayed before the
542     pause, and the GUI event loop (if any) will run during the pause.
543 
544     This can be used for crude animation.  For more complex animation use
545     :mod:`matplotlib.animation`.
546 
547     If there is no active figure, sleep for *interval* seconds instead.
548 
549     See Also
550     --------
551     matplotlib.animation : Proper animations
552     show : Show all figures and optional block until all figures are closed.
553     """
554     manager = _pylab_helpers.Gcf.get_active()
555     if manager is not None:
556         canvas = manager.canvas
557         if canvas.figure.stale:
558             canvas.draw_idle()
559         show(block=False)
560         canvas.start_event_loop(interval)
561     else:
562         time.sleep(interval)
563 
564 
565 @_copy_docstring_and_deprecators(matplotlib.rc)
566 def rc(group, **kwargs):
567     matplotlib.rc(group, **kwargs)
568 
569 
570 @_copy_docstring_and_deprecators(matplotlib.rc_context)
571 def rc_context(rc=None, fname=None):
572     return matplotlib.rc_context(rc, fname)
573 
574 
575 @_copy_docstring_and_deprecators(matplotlib.rcdefaults)
576 def rcdefaults():
577     matplotlib.rcdefaults()
578     if matplotlib.is_interactive():
579         draw_all()
580 
581 
582 # getp/get/setp are explicitly reexported so that they show up in pyplot docs.
583 
584 
585 @_copy_docstring_and_deprecators(matplotlib.artist.getp)
586 def getp(obj, *args, **kwargs):
587     return matplotlib.artist.getp(obj, *args, **kwargs)
588 
589 
590 @_copy_docstring_and_deprecators(matplotlib.artist.get)
591 def get(obj, *args, **kwargs):
592     return matplotlib.artist.get(obj, *args, **kwargs)
593 
594 
595 @_copy_docstring_and_deprecators(matplotlib.artist.setp)
596 def setp(obj, *args, **kwargs):
597     return matplotlib.artist.setp(obj, *args, **kwargs)
598 
599 
600 def xkcd(scale=1, length=100, randomness=2):
601     """
602     Turn on `xkcd <https://xkcd.com/>`_ sketch-style drawing mode.  This will
603     only have effect on things drawn after this function is called.
604 
605     For best results, the "Humor Sans" font should be installed: it is
606     not included with Matplotlib.
607 
608     Parameters
609     ----------
610     scale : float, optional
611         The amplitude of the wiggle perpendicular to the source line.
612     length : float, optional
613         The length of the wiggle along the line.
614     randomness : float, optional
615         The scale factor by which the length is shrunken or expanded.
616 
617     Notes
618     -----
619     This function works by a number of rcParams, so it will probably
620     override others you have set before.
621 
622     If you want the effects of this function to be temporary, it can
623     be used as a context manager, for example::
624 
625         with plt.xkcd():
626             # This figure will be in XKCD-style
627             fig1 = plt.figure()
628             # ...
629 
630         # This figure will be in regular style
631         fig2 = plt.figure()
632     """
633     return _xkcd(scale, length, randomness)
634 
635 
636 class _xkcd:
637     # This cannot be implemented in terms of rc_context() because this needs to
638     # work as a non-contextmanager too.
639 
640     def __init__(self, scale, length, randomness):
641         self._orig = rcParams.copy()
642 
643         if rcParams['text.usetex']:
644             raise RuntimeError(
645                 "xkcd mode is not compatible with text.usetex = True")
646 
647         from matplotlib import patheffects
648         rcParams.update({
649             'font.family': ['xkcd', 'xkcd Script', 'Humor Sans', 'Comic Neue',
650                             'Comic Sans MS'],
651             'font.size': 14.0,
652             'path.sketch': (scale, length, randomness),
653             'path.effects': [
654                 patheffects.withStroke(linewidth=4, foreground="w")],
655             'axes.linewidth': 1.5,
656             'lines.linewidth': 2.0,
657             'figure.facecolor': 'white',
658             'grid.linewidth': 0.0,
659             'axes.grid': False,
660             'axes.unicode_minus': False,
661             'axes.edgecolor': 'black',
662             'xtick.major.size': 8,
663             'xtick.major.width': 3,
664             'ytick.major.size': 8,
665             'ytick.major.width': 3,
666         })
667 
668     def __enter__(self):
669         return self
670 
671     def __exit__(self, *args):
672         dict.update(rcParams, self._orig)
673 
674 
675 ## Figures ##
676 
677 @_api.make_keyword_only("3.6", "facecolor")
678 def figure(num=None,  # autoincrement if None, else integer from 1-N
679            figsize=None,  # defaults to rc figure.figsize
680            dpi=None,  # defaults to rc figure.dpi
681            facecolor=None,  # defaults to rc figure.facecolor
682            edgecolor=None,  # defaults to rc figure.edgecolor
683            frameon=True,
684            FigureClass=Figure,
685            clear=False,
686            **kwargs
687            ):
688     """
689     Create a new figure, or activate an existing figure.
690 
691     Parameters
692     ----------
693     num : int or str or `.Figure`, optional
694         A unique identifier for the figure.
695 
696         If a figure with that identifier already exists, this figure is made
697         active and returned. An integer refers to the ``Figure.number``
698         attribute, a string refers to the figure label.
699 
700         If there is no figure with the identifier or *num* is not given, a new
701         figure is created, made active and returned.  If *num* is an int, it
702         will be used for the ``Figure.number`` attribute, otherwise, an
703         auto-generated integer value is used (starting at 1 and incremented
704         for each new figure). If *num* is a string, the figure label and the
705         window title is set to this value.
706 
707     figsize : (float, float), default: :rc:`figure.figsize`
708         Width, height in inches.
709 
710     dpi : float, default: :rc:`figure.dpi`
711         The resolution of the figure in dots-per-inch.
712 
713     facecolor : color, default: :rc:`figure.facecolor`
714         The background color.
715 
716     edgecolor : color, default: :rc:`figure.edgecolor`
717         The border color.
718 
719     frameon : bool, default: True
720         If False, suppress drawing the figure frame.
721 
722     FigureClass : subclass of `~matplotlib.figure.Figure`
723         If set, an instance of this subclass will be created, rather than a
724         plain `.Figure`.
725 
726     clear : bool, default: False
727         If True and the figure already exists, then it is cleared.
728 
729     layout : {'constrained', 'tight', `.LayoutEngine`, None}, default: None
730         The layout mechanism for positioning of plot elements to avoid
731         overlapping Axes decorations (labels, ticks, etc). Note that layout
732         managers can measurably slow down figure display. Defaults to *None*
733         (but see the documentation of the `.Figure` constructor regarding the
734         interaction with rcParams).
735 
736     **kwargs
737         Additional keyword arguments are passed to the `.Figure` constructor.
738 
739     Returns
740     -------
741     `~matplotlib.figure.Figure`
742 
743     Notes
744     -----
745     Newly created figures will be passed to the
746     `~.backend_template.new_figure_manager` function provided by the current
747     backend, which will install a canvas and a manager on the figure.
748 
749     If you are creating many figures, make sure you explicitly call
750     `.pyplot.close` on the figures you are not using, because this will
751     enable pyplot to properly clean up the memory.
752 
753     `~matplotlib.rcParams` defines the default values, which can be modified
754     in the matplotlibrc file.
755     """
756     if isinstance(num, Figure):
757         if num.canvas.manager is None:
758             raise ValueError("The passed figure is not managed by pyplot")
759         _pylab_helpers.Gcf.set_active(num.canvas.manager)
760         return num
761 
762     allnums = get_fignums()
763     next_num = max(allnums) + 1 if allnums else 1
764     fig_label = ''
765     if num is None:
766         num = next_num
767     elif isinstance(num, str):
768         fig_label = num
769         all_labels = get_figlabels()
770         if fig_label not in all_labels:
771             if fig_label == 'all':
772                 _api.warn_external("close('all') closes all existing figures.")
773             num = next_num
774         else:
775             inum = all_labels.index(fig_label)
776             num = allnums[inum]
777     else:
778         num = int(num)  # crude validation of num argument
779 
780     manager = _pylab_helpers.Gcf.get_fig_manager(num)
781     if manager is None:
782         max_open_warning = rcParams['figure.max_open_warning']
783         if len(allnums) == max_open_warning >= 1:
784             _api.warn_external(
785                 f"More than {max_open_warning} figures have been opened. "
786                 f"Figures created through the pyplot interface "
787                 f"(`matplotlib.pyplot.figure`) are retained until explicitly "
788                 f"closed and may consume too much memory. (To control this "
789                 f"warning, see the rcParam `figure.max_open_warning`).",
790                 RuntimeWarning)
791 
792         manager = new_figure_manager(
793             num, figsize=figsize, dpi=dpi,
794             facecolor=facecolor, edgecolor=edgecolor, frameon=frameon,
795             FigureClass=FigureClass, **kwargs)
796         fig = manager.canvas.figure
797         if fig_label:
798             fig.set_label(fig_label)
799 
800         _pylab_helpers.Gcf._set_new_active_manager(manager)
801 
802         # make sure backends (inline) that we don't ship that expect this
803         # to be called in plotting commands to make the figure call show
804         # still work.  There is probably a better way to do this in the
805         # FigureManager base class.
806         draw_if_interactive()
807 
808         if _REPL_DISPLAYHOOK is _ReplDisplayHook.PLAIN:
809             fig.stale_callback = _auto_draw_if_interactive
810 
811     if clear:
812         manager.canvas.figure.clear()
813 
814     return manager.canvas.figure
815 
816 
817 def _auto_draw_if_interactive(fig, val):
818     """
819     An internal helper function for making sure that auto-redrawing
820     works as intended in the plain python repl.
821 
822     Parameters
823     ----------
824     fig : Figure
825         A figure object which is assumed to be associated with a canvas
826     """
827     if (val and matplotlib.is_interactive()
828             and not fig.canvas.is_saving()
829             and not fig.canvas._is_idle_drawing):
830         # Some artists can mark themselves as stale in the middle of drawing
831         # (e.g. axes position & tick labels being computed at draw time), but
832         # this shouldn't trigger a redraw because the current redraw will
833         # already take them into account.
834         with fig.canvas._idle_draw_cntx():
835             fig.canvas.draw_idle()
836 
837 
838 def gcf():
839     """
840     Get the current figure.
841 
842     If there is currently no figure on the pyplot figure stack, a new one is
843     created using `~.pyplot.figure()`.  (To test whether there is currently a
844     figure on the pyplot figure stack, check whether `~.pyplot.get_fignums()`
845     is empty.)
846     """
847     manager = _pylab_helpers.Gcf.get_active()
848     if manager is not None:
849         return manager.canvas.figure
850     else:
851         return figure()
852 
853 
854 def fignum_exists(num):
855     """Return whether the figure with the given id exists."""
856     return _pylab_helpers.Gcf.has_fignum(num) or num in get_figlabels()
857 
858 
859 def get_fignums():
860     """Return a list of existing figure numbers."""
861     return sorted(_pylab_helpers.Gcf.figs)
862 
863 
864 def get_figlabels():
865     """Return a list of existing figure labels."""
866     managers = _pylab_helpers.Gcf.get_all_fig_managers()
867     managers.sort(key=lambda m: m.num)
868     return [m.canvas.figure.get_label() for m in managers]
869 
870 
871 def get_current_fig_manager():
872     """
873     Return the figure manager of the current figure.
874 
875     The figure manager is a container for the actual backend-depended window
876     that displays the figure on screen.
877 
878     If no current figure exists, a new one is created, and its figure
879     manager is returned.
880 
881     Returns
882     -------
883     `.FigureManagerBase` or backend-dependent subclass thereof
884     """
885     return gcf().canvas.manager
886 
887 
888 @_copy_docstring_and_deprecators(FigureCanvasBase.mpl_connect)
889 def connect(s, func):
890     return gcf().canvas.mpl_connect(s, func)
891 
892 
893 @_copy_docstring_and_deprecators(FigureCanvasBase.mpl_disconnect)
894 def disconnect(cid):
895     return gcf().canvas.mpl_disconnect(cid)
896 
897 
898 def close(fig=None):
899     """
900     Close a figure window.
901 
902     Parameters
903     ----------
904     fig : None or int or str or `.Figure`
905         The figure to close. There are a number of ways to specify this:
906 
907         - *None*: the current figure
908         - `.Figure`: the given `.Figure` instance
909         - ``int``: a figure number
910         - ``str``: a figure name
911         - 'all': all figures
912 
913     """
914     if fig is None:
915         manager = _pylab_helpers.Gcf.get_active()
916         if manager is None:
917             return
918         else:
919             _pylab_helpers.Gcf.destroy(manager)
920     elif fig == 'all':
921         _pylab_helpers.Gcf.destroy_all()
922     elif isinstance(fig, int):
923         _pylab_helpers.Gcf.destroy(fig)
924     elif hasattr(fig, 'int'):
925         # if we are dealing with a type UUID, we
926         # can use its integer representation
927         _pylab_helpers.Gcf.destroy(fig.int)
928     elif isinstance(fig, str):
929         all_labels = get_figlabels()
930         if fig in all_labels:
931             num = get_fignums()[all_labels.index(fig)]
932             _pylab_helpers.Gcf.destroy(num)
933     elif isinstance(fig, Figure):
934         _pylab_helpers.Gcf.destroy_fig(fig)
935     else:
936         raise TypeError("close() argument must be a Figure, an int, a string, "
937                         "or None, not %s" % type(fig))
938 
939 
940 def clf():
941     """Clear the current figure."""
942     gcf().clear()
943 
944 
945 def draw():
946     """
947     Redraw the current figure.
948 
949     This is used to update a figure that has been altered, but not
950     automatically re-drawn.  If interactive mode is on (via `.ion()`), this
951     should be only rarely needed, but there may be ways to modify the state of
952     a figure without marking it as "stale".  Please report these cases as bugs.
953 
954     This is equivalent to calling ``fig.canvas.draw_idle()``, where ``fig`` is
955     the current figure.
956     """
957     gcf().canvas.draw_idle()
958 
959 
960 @_copy_docstring_and_deprecators(Figure.savefig)
961 def savefig(*args, **kwargs):
962     fig = gcf()
963     res = fig.savefig(*args, **kwargs)
964     fig.canvas.draw_idle()  # Need this if 'transparent=True', to reset colors.
965     return res
966 
967 
968 ## Putting things in figures ##
969 
970 
971 def figlegend(*args, **kwargs):
972     return gcf().legend(*args, **kwargs)
973 if Figure.legend.__doc__:
974     figlegend.__doc__ = Figure.legend.__doc__.replace("legend(", "figlegend(")
975 
976 
977 ## Axes ##
978 
979 @_docstring.dedent_interpd
980 def axes(arg=None, **kwargs):
981     """
982     Add an Axes to the current figure and make it the current Axes.
983 
984     Call signatures::
985 
986         plt.axes()
987         plt.axes(rect, projection=None, polar=False, **kwargs)
988         plt.axes(ax)
989 
990     Parameters
991     ----------
992     arg : None or 4-tuple
993         The exact behavior of this function depends on the type:
994 
995         - *None*: A new full window Axes is added using
996           ``subplot(**kwargs)``.
997         - 4-tuple of floats *rect* = ``[left, bottom, width, height]``.
998           A new Axes is added with dimensions *rect* in normalized
999           (0, 1) units using `~.Figure.add_axes` on the current figure.
1000 
1001     projection : {None, 'aitoff', 'hammer', 'lambert', 'mollweide', \
1002 'polar', 'rectilinear', str}, optional
1003         The projection type of the `~.axes.Axes`. *str* is the name of
1004         a custom projection, see `~matplotlib.projections`. The default
1005         None results in a 'rectilinear' projection.
1006 
1007     polar : bool, default: False
1008         If True, equivalent to projection='polar'.
1009 
1010     sharex, sharey : `~.axes.Axes`, optional
1011         Share the x or y `~matplotlib.axis` with sharex and/or sharey.
1012         The axis will have the same limits, ticks, and scale as the axis
1013         of the shared Axes.
1014 
1015     label : str
1016         A label for the returned Axes.
1017 
1018     Returns
1019     -------
1020     `~.axes.Axes`, or a subclass of `~.axes.Axes`
1021         The returned axes class depends on the projection used. It is
1022         `~.axes.Axes` if rectilinear projection is used and
1023         `.projections.polar.PolarAxes` if polar projection is used.
1024 
1025     Other Parameters
1026     ----------------
1027     **kwargs
1028         This method also takes the keyword arguments for
1029         the returned Axes class. The keyword arguments for the
1030         rectilinear Axes class `~.axes.Axes` can be found in
1031         the following table but there might also be other keyword
1032         arguments if another projection is used, see the actual Axes
1033         class.
1034 
1035         %(Axes:kwdoc)s
1036 
1037     Notes
1038     -----
1039     If the figure already has an Axes with key (*args*,
1040     *kwargs*) then it will simply make that axes current and
1041     return it.  This behavior is deprecated. Meanwhile, if you do
1042     not want this behavior (i.e., you want to force the creation of a
1043     new axes), you must use a unique set of args and kwargs.  The Axes
1044     *label* attribute has been exposed for this purpose: if you want
1045     two Axes that are otherwise identical to be added to the figure,
1046     make sure you give them unique labels.
1047 
1048     See Also
1049     --------
1050     .Figure.add_axes
1051     .pyplot.subplot
1052     .Figure.add_subplot
1053     .Figure.subplots
1054     .pyplot.subplots
1055 
1056     Examples
1057     --------
1058     ::
1059 
1060         # Creating a new full window Axes
1061         plt.axes()
1062 
1063         # Creating a new Axes with specified dimensions and a grey background
1064         plt.axes((left, bottom, width, height), facecolor='grey')
1065     """
1066     fig = gcf()
1067     pos = kwargs.pop('position', None)
1068     if arg is None:
1069         if pos is None:
1070             return fig.add_subplot(**kwargs)
1071         else:
1072             return fig.add_axes(pos, **kwargs)
1073     else:
1074         return fig.add_axes(arg, **kwargs)
1075 
1076 
1077 def delaxes(ax=None):
1078     """
1079     Remove an `~.axes.Axes` (defaulting to the current axes) from its figure.
1080     """
1081     if ax is None:
1082         ax = gca()
1083     ax.remove()
1084 
1085 
1086 def sca(ax):
1087     """
1088     Set the current Axes to *ax* and the current Figure to the parent of *ax*.
1089     """
1090     figure(ax.figure)
1091     ax.figure.sca(ax)
1092 
1093 
1094 def cla():
1095     """Clear the current axes."""
1096     # Not generated via boilerplate.py to allow a different docstring.
1097     return gca().cla()
1098 
1099 
1100 ## More ways of creating axes ##
1101 
1102 @_docstring.dedent_interpd
1103 def subplot(*args, **kwargs):
1104     """
1105     Add an Axes to the current figure or retrieve an existing Axes.
1106 
1107     This is a wrapper of `.Figure.add_subplot` which provides additional
1108     behavior when working with the implicit API (see the notes section).
1109 
1110     Call signatures::
1111 
1112        subplot(nrows, ncols, index, **kwargs)
1113        subplot(pos, **kwargs)
1114        subplot(**kwargs)
1115        subplot(ax)
1116 
1117     Parameters
1118     ----------
1119     *args : int, (int, int, *index*), or `.SubplotSpec`, default: (1, 1, 1)
1120         The position of the subplot described by one of
1121 
1122         - Three integers (*nrows*, *ncols*, *index*). The subplot will take the
1123           *index* position on a grid with *nrows* rows and *ncols* columns.
1124           *index* starts at 1 in the upper left corner and increases to the
1125           right. *index* can also be a two-tuple specifying the (*first*,
1126           *last*) indices (1-based, and including *last*) of the subplot, e.g.,
1127           ``fig.add_subplot(3, 1, (1, 2))`` makes a subplot that spans the
1128           upper 2/3 of the figure.
1129         - A 3-digit integer. The digits are interpreted as if given separately
1130           as three single-digit integers, i.e. ``fig.add_subplot(235)`` is the
1131           same as ``fig.add_subplot(2, 3, 5)``. Note that this can only be used
1132           if there are no more than 9 subplots.
1133         - A `.SubplotSpec`.
1134 
1135     projection : {None, 'aitoff', 'hammer', 'lambert', 'mollweide', \
1136 'polar', 'rectilinear', str}, optional
1137         The projection type of the subplot (`~.axes.Axes`). *str* is the name
1138         of a custom projection, see `~matplotlib.projections`. The default
1139         None results in a 'rectilinear' projection.
1140 
1141     polar : bool, default: False
1142         If True, equivalent to projection='polar'.
1143 
1144     sharex, sharey : `~.axes.Axes`, optional
1145         Share the x or y `~matplotlib.axis` with sharex and/or sharey. The
1146         axis will have the same limits, ticks, and scale as the axis of the
1147         shared axes.
1148 
1149     label : str
1150         A label for the returned axes.
1151 
1152     Returns
1153     -------
1154     `.axes.SubplotBase`, or another subclass of `~.axes.Axes`
1155 
1156         The axes of the subplot. The returned axes base class depends on
1157         the projection used. It is `~.axes.Axes` if rectilinear projection
1158         is used and `.projections.polar.PolarAxes` if polar projection
1159         is used. The returned axes is then a subplot subclass of the
1160         base class.
1161 
1162     Other Parameters
1163     ----------------
1164     **kwargs
1165         This method also takes the keyword arguments for the returned axes
1166         base class; except for the *figure* argument. The keyword arguments
1167         for the rectilinear base class `~.axes.Axes` can be found in
1168         the following table but there might also be other keyword
1169         arguments if another projection is used.
1170 
1171         %(Axes:kwdoc)s
1172 
1173     Notes
1174     -----
1175     Creating a new Axes will delete any pre-existing Axes that
1176     overlaps with it beyond sharing a boundary::
1177 
1178         import matplotlib.pyplot as plt
1179         # plot a line, implicitly creating a subplot(111)
1180         plt.plot([1, 2, 3])
1181         # now create a subplot which represents the top plot of a grid
1182         # with 2 rows and 1 column. Since this subplot will overlap the
1183         # first, the plot (and its axes) previously created, will be removed
1184         plt.subplot(211)
1185 
1186     If you do not want this behavior, use the `.Figure.add_subplot` method
1187     or the `.pyplot.axes` function instead.
1188 
1189     If no *kwargs* are passed and there exists an Axes in the location
1190     specified by *args* then that Axes will be returned rather than a new
1191     Axes being created.
1192 
1193     If *kwargs* are passed and there exists an Axes in the location
1194     specified by *args*, the projection type is the same, and the
1195     *kwargs* match with the existing Axes, then the existing Axes is
1196     returned.  Otherwise a new Axes is created with the specified
1197     parameters.  We save a reference to the *kwargs* which we use
1198     for this comparison.  If any of the values in *kwargs* are
1199     mutable we will not detect the case where they are mutated.
1200     In these cases we suggest using `.Figure.add_subplot` and the
1201     explicit Axes API rather than the implicit pyplot API.
1202 
1203     See Also
1204     --------
1205     .Figure.add_subplot
1206     .pyplot.subplots
1207     .pyplot.axes
1208     .Figure.subplots
1209 
1210     Examples
1211     --------
1212     ::
1213 
1214         plt.subplot(221)
1215 
1216         # equivalent but more general
1217         ax1 = plt.subplot(2, 2, 1)
1218 
1219         # add a subplot with no frame
1220         ax2 = plt.subplot(222, frameon=False)
1221 
1222         # add a polar subplot
1223         plt.subplot(223, projection='polar')
1224 
1225         # add a red subplot that shares the x-axis with ax1
1226         plt.subplot(224, sharex=ax1, facecolor='red')
1227 
1228         # delete ax2 from the figure
1229         plt.delaxes(ax2)
1230 
1231         # add ax2 to the figure again
1232         plt.subplot(ax2)
1233 
1234         # make the first axes "current" again
1235         plt.subplot(221)
1236 
1237     """
1238     # Here we will only normalize `polar=True` vs `projection='polar'` and let
1239     # downstream code deal with the rest.
1240     unset = object()
1241     projection = kwargs.get('projection', unset)
1242     polar = kwargs.pop('polar', unset)
1243     if polar is not unset and polar:
1244         # if we got mixed messages from the user, raise
1245         if projection is not unset and projection != 'polar':
1246             raise ValueError(
1247                 f"polar={polar}, yet projection={projection!r}. "
1248                 "Only one of these arguments should be supplied."
1249             )
1250         kwargs['projection'] = projection = 'polar'
1251 
1252     # if subplot called without arguments, create subplot(1, 1, 1)
1253     if len(args) == 0:
1254         args = (1, 1, 1)
1255 
1256     # This check was added because it is very easy to type subplot(1, 2, False)
1257     # when subplots(1, 2, False) was intended (sharex=False, that is). In most
1258     # cases, no error will ever occur, but mysterious behavior can result
1259     # because what was intended to be the sharex argument is instead treated as
1260     # a subplot index for subplot()
1261     if len(args) >= 3 and isinstance(args[2], bool):
1262         _api.warn_external("The subplot index argument to subplot() appears "
1263                            "to be a boolean. Did you intend to use "
1264                            "subplots()?")
1265     # Check for nrows and ncols, which are not valid subplot args:
1266     if 'nrows' in kwargs or 'ncols' in kwargs:
1267         raise TypeError("subplot() got an unexpected keyword argument 'ncols' "
1268                         "and/or 'nrows'.  Did you intend to call subplots()?")
1269 
1270     fig = gcf()
1271 
1272     # First, search for an existing subplot with a matching spec.
1273     key = SubplotSpec._from_subplot_args(fig, args)
1274 
1275     for ax in fig.axes:
1276         # if we found an Axes at the position sort out if we can re-use it
1277         if hasattr(ax, 'get_subplotspec') and ax.get_subplotspec() == key:
1278             # if the user passed no kwargs, re-use
1279             if kwargs == {}:
1280                 break
1281             # if the axes class and kwargs are identical, reuse
1282             elif ax._projection_init == fig._process_projection_requirements(
1283                 *args, **kwargs
1284             ):
1285                 break
1286     else:
1287         # we have exhausted the known Axes and none match, make a new one!
1288         ax = fig.add_subplot(*args, **kwargs)
1289 
1290     fig.sca(ax)
1291 
1292     axes_to_delete = [other for other in fig.axes
1293                       if other != ax and ax.bbox.fully_overlaps(other.bbox)]
1294     if axes_to_delete:
1295         _api.warn_deprecated(
1296             "3.6", message="Auto-removal of overlapping axes is deprecated "
1297             "since %(since)s and will be removed %(removal)s; explicitly call "
1298             "ax.remove() as needed.")
1299     for ax_to_del in axes_to_delete:
1300         delaxes(ax_to_del)
1301 
1302     return ax
1303 
1304 
1305 def subplots(nrows=1, ncols=1, *, sharex=False, sharey=False, squeeze=True,
1306              subplot_kw=None, gridspec_kw=None, **fig_kw):
1307     """
1308     Create a figure and a set of subplots.
1309 
1310     This utility wrapper makes it convenient to create common layouts of
1311     subplots, including the enclosing figure object, in a single call.
1312 
1313     Parameters
1314     ----------
1315     nrows, ncols : int, default: 1
1316         Number of rows/columns of the subplot grid.
1317 
1318     sharex, sharey : bool or {'none', 'all', 'row', 'col'}, default: False
1319         Controls sharing of properties among x (*sharex*) or y (*sharey*)
1320         axes:
1321 
1322         - True or 'all': x- or y-axis will be shared among all subplots.
1323         - False or 'none': each subplot x- or y-axis will be independent.
1324         - 'row': each subplot row will share an x- or y-axis.
1325         - 'col': each subplot column will share an x- or y-axis.
1326 
1327         When subplots have a shared x-axis along a column, only the x tick
1328         labels of the bottom subplot are created. Similarly, when subplots
1329         have a shared y-axis along a row, only the y tick labels of the first
1330         column subplot are created. To later turn other subplots' ticklabels
1331         on, use `~matplotlib.axes.Axes.tick_params`.
1332 
1333         When subplots have a shared axis that has units, calling
1334         `~matplotlib.axis.Axis.set_units` will update each axis with the
1335         new units.
1336 
1337     squeeze : bool, default: True
1338         - If True, extra dimensions are squeezed out from the returned
1339           array of `~matplotlib.axes.Axes`:
1340 
1341           - if only one subplot is constructed (nrows=ncols=1), the
1342             resulting single Axes object is returned as a scalar.
1343           - for Nx1 or 1xM subplots, the returned object is a 1D numpy
1344             object array of Axes objects.
1345           - for NxM, subplots with N>1 and M>1 are returned as a 2D array.
1346 
1347         - If False, no squeezing at all is done: the returned Axes object is
1348           always a 2D array containing Axes instances, even if it ends up
1349           being 1x1.
1350 
1351     subplot_kw : dict, optional
1352         Dict with keywords passed to the
1353         `~matplotlib.figure.Figure.add_subplot` call used to create each
1354         subplot.
1355 
1356     gridspec_kw : dict, optional
1357         Dict with keywords passed to the `~matplotlib.gridspec.GridSpec`
1358         constructor used to create the grid the subplots are placed on.
1359 
1360     **fig_kw
1361         All additional keyword arguments are passed to the
1362         `.pyplot.figure` call.
1363 
1364     Returns
1365     -------
1366     fig : `.Figure`
1367 
1368     ax : `~.axes.Axes` or array of Axes
1369         *ax* can be either a single `~.axes.Axes` object, or an array of Axes
1370         objects if more than one subplot was created.  The dimensions of the
1371         resulting array can be controlled with the squeeze keyword, see above.
1372 
1373         Typical idioms for handling the return value are::
1374 
1375             # using the variable ax for single a Axes
1376             fig, ax = plt.subplots()
1377 
1378             # using the variable axs for multiple Axes
1379             fig, axs = plt.subplots(2, 2)
1380 
1381             # using tuple unpacking for multiple Axes
1382             fig, (ax1, ax2) = plt.subplots(1, 2)
1383             fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2)
1384 
1385         The names ``ax`` and pluralized ``axs`` are preferred over ``axes``
1386         because for the latter it's not clear if it refers to a single
1387         `~.axes.Axes` instance or a collection of these.
1388 
1389     See Also
1390     --------
1391     .pyplot.figure
1392     .pyplot.subplot
1393     .pyplot.axes
1394     .Figure.subplots
1395     .Figure.add_subplot
1396 
1397     Examples
1398     --------
1399     ::
1400 
1401         # First create some toy data:
1402         x = np.linspace(0, 2*np.pi, 400)
1403         y = np.sin(x**2)
1404 
1405         # Create just a figure and only one subplot
1406         fig, ax = plt.subplots()
1407         ax.plot(x, y)
1408         ax.set_title('Simple plot')
1409 
1410         # Create two subplots and unpack the output array immediately
1411         f, (ax1, ax2) = plt.subplots(1, 2, sharey=True)
1412         ax1.plot(x, y)
1413         ax1.set_title('Sharing Y axis')
1414         ax2.scatter(x, y)
1415 
1416         # Create four polar axes and access them through the returned array
1417         fig, axs = plt.subplots(2, 2, subplot_kw=dict(projection="polar"))
1418         axs[0, 0].plot(x, y)
1419         axs[1, 1].scatter(x, y)
1420 
1421         # Share a X axis with each column of subplots
1422         plt.subplots(2, 2, sharex='col')
1423 
1424         # Share a Y axis with each row of subplots
1425         plt.subplots(2, 2, sharey='row')
1426 
1427         # Share both X and Y axes with all subplots
1428         plt.subplots(2, 2, sharex='all', sharey='all')
1429 
1430         # Note that this is the same as
1431         plt.subplots(2, 2, sharex=True, sharey=True)
1432 
1433         # Create figure number 10 with a single subplot
1434         # and clears it if it already exists.
1435         fig, ax = plt.subplots(num=10, clear=True)
1436 
1437     """
1438     fig = figure(**fig_kw)
1439     axs = fig.subplots(nrows=nrows, ncols=ncols, sharex=sharex, sharey=sharey,
1440                        squeeze=squeeze, subplot_kw=subplot_kw,
1441                        gridspec_kw=gridspec_kw)
1442     return fig, axs
1443 
1444 
1445 def subplot_mosaic(mosaic, *, sharex=False, sharey=False,
1446                    subplot_kw=None, gridspec_kw=None, empty_sentinel='.',
1447                    **fig_kw):
1448     """
1449     Build a layout of Axes based on ASCII art or nested lists.
1450 
1451     This is a helper function to build complex GridSpec layouts visually.
1452 
1453     .. note::
1454 
1455        This API is provisional and may be revised in the future based on
1456        early user feedback.
1457 
1458     See :doc:`/tutorials/provisional/mosaic`
1459     for an example and full API documentation
1460 
1461     Parameters
1462     ----------
1463     mosaic : list of list of {hashable or nested} or str
1464 
1465         A visual layout of how you want your Axes to be arranged
1466         labeled as strings.  For example ::
1467 
1468            x = [['A panel', 'A panel', 'edge'],
1469                 ['C panel', '.',       'edge']]
1470 
1471         produces 4 axes:
1472 
1473         - 'A panel' which is 1 row high and spans the first two columns
1474         - 'edge' which is 2 rows high and is on the right edge
1475         - 'C panel' which in 1 row and 1 column wide in the bottom left
1476         - a blank space 1 row and 1 column wide in the bottom center
1477 
1478         Any of the entries in the layout can be a list of lists
1479         of the same form to create nested layouts.
1480 
1481         If input is a str, then it must be of the form ::
1482 
1483           '''
1484           AAE
1485           C.E
1486           '''
1487 
1488         where each character is a column and each line is a row.
1489         This only allows only single character Axes labels and does
1490         not allow nesting but is very terse.
1491 
1492     sharex, sharey : bool, default: False
1493         If True, the x-axis (*sharex*) or y-axis (*sharey*) will be shared
1494         among all subplots.  In that case, tick label visibility and axis units
1495         behave as for `subplots`.  If False, each subplot's x- or y-axis will
1496         be independent.
1497 
1498     subplot_kw : dict, optional
1499         Dictionary with keywords passed to the `.Figure.add_subplot` call
1500         used to create each subplot.
1501 
1502     gridspec_kw : dict, optional
1503         Dictionary with keywords passed to the `.GridSpec` constructor used
1504         to create the grid the subplots are placed on.
1505 
1506     empty_sentinel : object, optional
1507         Entry in the layout to mean "leave this space empty".  Defaults
1508         to ``'.'``. Note, if *layout* is a string, it is processed via
1509         `inspect.cleandoc` to remove leading white space, which may
1510         interfere with using white-space as the empty sentinel.
1511 
1512     **fig_kw
1513         All additional keyword arguments are passed to the
1514         `.pyplot.figure` call.
1515 
1516     Returns
1517     -------
1518     fig : `.Figure`
1519        The new figure
1520 
1521     dict[label, Axes]
1522        A dictionary mapping the labels to the Axes objects.  The order of
1523        the axes is left-to-right and top-to-bottom of their position in the
1524        total layout.
1525 
1526     """
1527     fig = figure(**fig_kw)
1528     ax_dict = fig.subplot_mosaic(
1529         mosaic, sharex=sharex, sharey=sharey,
1530         subplot_kw=subplot_kw, gridspec_kw=gridspec_kw,
1531         empty_sentinel=empty_sentinel
1532     )
1533     return fig, ax_dict
1534 
1535 
1536 def subplot2grid(shape, loc, rowspan=1, colspan=1, fig=None, **kwargs):
1537     """
1538     Create a subplot at a specific location inside a regular grid.
1539 
1540     Parameters
1541     ----------
1542     shape : (int, int)
1543         Number of rows and of columns of the grid in which to place axis.
1544     loc : (int, int)
1545         Row number and column number of the axis location within the grid.
1546     rowspan : int, default: 1
1547         Number of rows for the axis to span downwards.
1548     colspan : int, default: 1
1549         Number of columns for the axis to span to the right.
1550     fig : `.Figure`, optional
1551         Figure to place the subplot in. Defaults to the current figure.
1552     **kwargs
1553         Additional keyword arguments are handed to `~.Figure.add_subplot`.
1554 
1555     Returns
1556     -------
1557     `.axes.SubplotBase`, or another subclass of `~.axes.Axes`
1558 
1559         The axes of the subplot.  The returned axes base class depends on the
1560         projection used.  It is `~.axes.Axes` if rectilinear projection is used
1561         and `.projections.polar.PolarAxes` if polar projection is used.  The
1562         returned axes is then a subplot subclass of the base class.
1563 
1564     Notes
1565     -----
1566     The following call ::
1567 
1568         ax = subplot2grid((nrows, ncols), (row, col), rowspan, colspan)
1569 
1570     is identical to ::
1571 
1572         fig = gcf()
1573         gs = fig.add_gridspec(nrows, ncols)
1574         ax = fig.add_subplot(gs[row:row+rowspan, col:col+colspan])
1575     """
1576 
1577     if fig is None:
1578         fig = gcf()
1579 
1580     rows, cols = shape
1581     gs = GridSpec._check_gridspec_exists(fig, rows, cols)
1582 
1583     subplotspec = gs.new_subplotspec(loc, rowspan=rowspan, colspan=colspan)
1584     ax = fig.add_subplot(subplotspec, **kwargs)
1585 
1586     axes_to_delete = [other for other in fig.axes
1587                       if other != ax and ax.bbox.fully_overlaps(other.bbox)]
1588     if axes_to_delete:
1589         _api.warn_deprecated(
1590             "3.6", message="Auto-removal of overlapping axes is deprecated "
1591             "since %(since)s and will be removed %(removal)s; explicitly call "
1592             "ax.remove() as needed.")
1593     for ax_to_del in axes_to_delete:
1594         delaxes(ax_to_del)
1595 
1596     return ax
1597 
1598 
1599 def twinx(ax=None):
1600     """
1601     Make and return a second axes that shares the *x*-axis.  The new axes will
1602     overlay *ax* (or the current axes if *ax* is *None*), and its ticks will be
1603     on the right.
1604 
1605     Examples
1606     --------
1607     :doc:`/gallery/subplots_axes_and_figures/two_scales`
1608     """
1609     if ax is None:
1610         ax = gca()
1611     ax1 = ax.twinx()
1612     return ax1
1613 
1614 
1615 def twiny(ax=None):
1616     """
1617     Make and return a second axes that shares the *y*-axis.  The new axes will
1618     overlay *ax* (or the current axes if *ax* is *None*), and its ticks will be
1619     on the top.
1620 
1621     Examples
1622     --------
1623     :doc:`/gallery/subplots_axes_and_figures/two_scales`
1624     """
1625     if ax is None:
1626         ax = gca()
1627     ax1 = ax.twiny()
1628     return ax1
1629 
1630 
1631 def subplot_tool(targetfig=None):
1632     """
1633     Launch a subplot tool window for a figure.
1634 
1635     Returns
1636     -------
1637     `matplotlib.widgets.SubplotTool`
1638     """
1639     if targetfig is None:
1640         targetfig = gcf()
1641     tb = targetfig.canvas.manager.toolbar
1642     if hasattr(tb, "configure_subplots"):  # toolbar2
1643         return tb.configure_subplots()
1644     elif hasattr(tb, "trigger_tool"):  # toolmanager
1645         return tb.trigger_tool("subplots")
1646     else:
1647         raise ValueError("subplot_tool can only be launched for figures with "
1648                          "an associated toolbar")
1649 
1650 
1651 def box(on=None):
1652     """
1653     Turn the axes box on or off on the current axes.
1654 
1655     Parameters
1656     ----------
1657     on : bool or None
1658         The new `~matplotlib.axes.Axes` box state. If ``None``, toggle
1659         the state.
1660 
1661     See Also
1662     --------
1663     :meth:`matplotlib.axes.Axes.set_frame_on`
1664     :meth:`matplotlib.axes.Axes.get_frame_on`
1665     """
1666     ax = gca()
1667     if on is None:
1668         on = not ax.get_frame_on()
1669     ax.set_frame_on(on)
1670 
1671 ## Axis ##
1672 
1673 
1674 def xlim(*args, **kwargs):
1675     """
1676     Get or set the x limits of the current axes.
1677 
1678     Call signatures::
1679 
1680         left, right = xlim()  # return the current xlim
1681         xlim((left, right))   # set the xlim to left, right
1682         xlim(left, right)     # set the xlim to left, right
1683 
1684     If you do not specify args, you can pass *left* or *right* as kwargs,
1685     i.e.::
1686 
1687         xlim(right=3)  # adjust the right leaving left unchanged
1688         xlim(left=1)  # adjust the left leaving right unchanged
1689 
1690     Setting limits turns autoscaling off for the x-axis.
1691 
1692     Returns
1693     -------
1694     left, right
1695         A tuple of the new x-axis limits.
1696 
1697     Notes
1698     -----
1699     Calling this function with no arguments (e.g. ``xlim()``) is the pyplot
1700     equivalent of calling `~.Axes.get_xlim` on the current axes.
1701     Calling this function with arguments is the pyplot equivalent of calling
1702     `~.Axes.set_xlim` on the current axes. All arguments are passed though.
1703     """
1704     ax = gca()
1705     if not args and not kwargs:
1706         return ax.get_xlim()
1707     ret = ax.set_xlim(*args, **kwargs)
1708     return ret
1709 
1710 
1711 def ylim(*args, **kwargs):
1712     """
1713     Get or set the y-limits of the current axes.
1714 
1715     Call signatures::
1716 
1717         bottom, top = ylim()  # return the current ylim
1718         ylim((bottom, top))   # set the ylim to bottom, top
1719         ylim(bottom, top)     # set the ylim to bottom, top
1720 
1721     If you do not specify args, you can alternatively pass *bottom* or
1722     *top* as kwargs, i.e.::
1723 
1724         ylim(top=3)  # adjust the top leaving bottom unchanged
1725         ylim(bottom=1)  # adjust the bottom leaving top unchanged
1726 
1727     Setting limits turns autoscaling off for the y-axis.
1728 
1729     Returns
1730     -------
1731     bottom, top
1732         A tuple of the new y-axis limits.
1733 
1734     Notes
1735     -----
1736     Calling this function with no arguments (e.g. ``ylim()``) is the pyplot
1737     equivalent of calling `~.Axes.get_ylim` on the current axes.
1738     Calling this function with arguments is the pyplot equivalent of calling
1739     `~.Axes.set_ylim` on the current axes. All arguments are passed though.
1740     """
1741     ax = gca()
1742     if not args and not kwargs:
1743         return ax.get_ylim()
1744     ret = ax.set_ylim(*args, **kwargs)
1745     return ret
1746 
1747 
1748 def xticks(ticks=None, labels=None, **kwargs):
1749     """
1750     Get or set the current tick locations and labels of the x-axis.
1751 
1752     Pass no arguments to return the current values without modifying them.
1753 
1754     Parameters
1755     ----------
1756     ticks : array-like, optional
1757         The list of xtick locations.  Passing an empty list removes all xticks.
1758     labels : array-like, optional
1759         The labels to place at the given *ticks* locations.  This argument can
1760         only be passed if *ticks* is passed as well.
1761     **kwargs
1762         `.Text` properties can be used to control the appearance of the labels.
1763 
1764     Returns
1765     -------
1766     locs
1767         The list of xtick locations.
1768     labels
1769         The list of xlabel `.Text` objects.
1770 
1771     Notes
1772     -----
1773     Calling this function with no arguments (e.g. ``xticks()``) is the pyplot
1774     equivalent of calling `~.Axes.get_xticks` and `~.Axes.get_xticklabels` on
1775     the current axes.
1776     Calling this function with arguments is the pyplot equivalent of calling
1777     `~.Axes.set_xticks` and `~.Axes.set_xticklabels` on the current axes.
1778 
1779     Examples
1780     --------
1781     >>> locs, labels = xticks()  # Get the current locations and labels.
1782     >>> xticks(np.arange(0, 1, step=0.2))  # Set label locations.
1783     >>> xticks(np.arange(3), ['Tom', 'Dick', 'Sue'])  # Set text labels.
1784     >>> xticks([0, 1, 2], ['January', 'February', 'March'],
1785     ...        rotation=20)  # Set text labels and properties.
1786     >>> xticks([])  # Disable xticks.
1787     """
1788     ax = gca()
1789 
1790     if ticks is None:
1791         locs = ax.get_xticks()
1792         if labels is not None:
1793             raise TypeError("xticks(): Parameter 'labels' can't be set "
1794                             "without setting 'ticks'")
1795     else:
1796         locs = ax.set_xticks(ticks)
1797 
1798     if labels is None:
1799         labels = ax.get_xticklabels()
1800         for l in labels:
1801             l._internal_update(kwargs)
1802     else:
1803         labels = ax.set_xticklabels(labels, **kwargs)
1804 
1805     return locs, labels
1806 
1807 
1808 def yticks(ticks=None, labels=None, **kwargs):
1809     """
1810     Get or set the current tick locations and labels of the y-axis.
1811 
1812     Pass no arguments to return the current values without modifying them.
1813 
1814     Parameters
1815     ----------
1816     ticks : array-like, optional
1817         The list of ytick locations.  Passing an empty list removes all yticks.
1818     labels : array-like, optional
1819         The labels to place at the given *ticks* locations.  This argument can
1820         only be passed if *ticks* is passed as well.
1821     **kwargs
1822         `.Text` properties can be used to control the appearance of the labels.
1823 
1824     Returns
1825     -------
1826     locs
1827         The list of ytick locations.
1828     labels
1829         The list of ylabel `.Text` objects.
1830 
1831     Notes
1832     -----
1833     Calling this function with no arguments (e.g. ``yticks()``) is the pyplot
1834     equivalent of calling `~.Axes.get_yticks` and `~.Axes.get_yticklabels` on
1835     the current axes.
1836     Calling this function with arguments is the pyplot equivalent of calling
1837     `~.Axes.set_yticks` and `~.Axes.set_yticklabels` on the current axes.
1838 
1839     Examples
1840     --------
1841     >>> locs, labels = yticks()  # Get the current locations and labels.
1842     >>> yticks(np.arange(0, 1, step=0.2))  # Set label locations.
1843     >>> yticks(np.arange(3), ['Tom', 'Dick', 'Sue'])  # Set text labels.
1844     >>> yticks([0, 1, 2], ['January', 'February', 'March'],
1845     ...        rotation=45)  # Set text labels and properties.
1846     >>> yticks([])  # Disable yticks.
1847     """
1848     ax = gca()
1849 
1850     if ticks is None:
1851         locs = ax.get_yticks()
1852         if labels is not None:
1853             raise TypeError("yticks(): Parameter 'labels' can't be set "
1854                             "without setting 'ticks'")
1855     else:
1856         locs = ax.set_yticks(ticks)
1857 
1858     if labels is None:
1859         labels = ax.get_yticklabels()
1860         for l in labels:
1861             l._internal_update(kwargs)
1862     else:
1863         labels = ax.set_yticklabels(labels, **kwargs)
1864 
1865     return locs, labels
1866 
1867 
1868 def rgrids(radii=None, labels=None, angle=None, fmt=None, **kwargs):
1869     """
1870     Get or set the radial gridlines on the current polar plot.
1871 
1872     Call signatures::
1873 
1874      lines, labels = rgrids()
1875      lines, labels = rgrids(radii, labels=None, angle=22.5, fmt=None, **kwargs)
1876 
1877     When called with no arguments, `.rgrids` simply returns the tuple
1878     (*lines*, *labels*). When called with arguments, the labels will
1879     appear at the specified radial distances and angle.
1880 
1881     Parameters
1882     ----------
1883     radii : tuple with floats
1884         The radii for the radial gridlines
1885 
1886     labels : tuple with strings or None
1887         The labels to use at each radial gridline. The
1888         `matplotlib.ticker.ScalarFormatter` will be used if None.
1889 
1890     angle : float
1891         The angular position of the radius labels in degrees.
1892 
1893     fmt : str or None
1894         Format string used in `matplotlib.ticker.FormatStrFormatter`.
1895         For example '%f'.
1896 
1897     Returns
1898     -------
1899     lines : list of `.lines.Line2D`
1900         The radial gridlines.
1901 
1902     labels : list of `.text.Text`
1903         The tick labels.
1904 
1905     Other Parameters
1906     ----------------
1907     **kwargs
1908         *kwargs* are optional `.Text` properties for the labels.
1909 
1910     See Also
1911     --------
1912     .pyplot.thetagrids
1913     .projections.polar.PolarAxes.set_rgrids
1914     .Axis.get_gridlines
1915     .Axis.get_ticklabels
1916 
1917     Examples
1918     --------
1919     ::
1920 
1921       # set the locations of the radial gridlines
1922       lines, labels = rgrids( (0.25, 0.5, 1.0) )
1923 
1924       # set the locations and labels of the radial gridlines
1925       lines, labels = rgrids( (0.25, 0.5, 1.0), ('Tom', 'Dick', 'Harry' ))
1926     """
1927     ax = gca()
1928     if not isinstance(ax, PolarAxes):
1929         raise RuntimeError('rgrids only defined for polar axes')
1930     if all(p is None for p in [radii, labels, angle, fmt]) and not kwargs:
1931         lines = ax.yaxis.get_gridlines()
1932         labels = ax.yaxis.get_ticklabels()
1933     else:
1934         lines, labels = ax.set_rgrids(
1935             radii, labels=labels, angle=angle, fmt=fmt, **kwargs)
1936     return lines, labels
1937 
1938 
1939 def thetagrids(angles=None, labels=None, fmt=None, **kwargs):
1940     """
1941     Get or set the theta gridlines on the current polar plot.
1942 
1943     Call signatures::
1944 
1945      lines, labels = thetagrids()
1946      lines, labels = thetagrids(angles, labels=None, fmt=None, **kwargs)
1947 
1948     When called with no arguments, `.thetagrids` simply returns the tuple
1949     (*lines*, *labels*). When called with arguments, the labels will
1950     appear at the specified angles.
1951 
1952     Parameters
1953     ----------
1954     angles : tuple with floats, degrees
1955         The angles of the theta gridlines.
1956 
1957     labels : tuple with strings or None
1958         The labels to use at each radial gridline. The
1959         `.projections.polar.ThetaFormatter` will be used if None.
1960 
1961     fmt : str or None
1962         Format string used in `matplotlib.ticker.FormatStrFormatter`.
1963         For example '%f'. Note that the angle in radians will be used.
1964 
1965     Returns
1966     -------
1967     lines : list of `.lines.Line2D`
1968         The theta gridlines.
1969 
1970     labels : list of `.text.Text`
1971         The tick labels.
1972 
1973     Other Parameters
1974     ----------------
1975     **kwargs
1976         *kwargs* are optional `.Text` properties for the labels.
1977 
1978     See Also
1979     --------
1980     .pyplot.rgrids
1981     .projections.polar.PolarAxes.set_thetagrids
1982     .Axis.get_gridlines
1983     .Axis.get_ticklabels
1984 
1985     Examples
1986     --------
1987     ::
1988 
1989       # set the locations of the angular gridlines
1990       lines, labels = thetagrids(range(45, 360, 90))
1991 
1992       # set the locations and labels of the angular gridlines
1993       lines, labels = thetagrids(range(45, 360, 90), ('NE', 'NW', 'SW', 'SE'))
1994     """
1995     ax = gca()
1996     if not isinstance(ax, PolarAxes):
1997         raise RuntimeError('thetagrids only defined for polar axes')
1998     if all(param is None for param in [angles, labels, fmt]) and not kwargs:
1999         lines = ax.xaxis.get_ticklines()
2000         labels = ax.xaxis.get_ticklabels()
2001     else:
2002         lines, labels = ax.set_thetagrids(angles,
2003                                           labels=labels, fmt=fmt, **kwargs)
2004     return lines, labels
2005 
2006 
2007 ## Plotting Info ##
2008 
2009 
2010 def plotting():
2011     pass
2012 
2013 
2014 def get_plot_commands():
2015     """
2016     Get a sorted list of all of the plotting commands.
2017     """
2018     # This works by searching for all functions in this module and removing
2019     # a few hard-coded exclusions, as well as all of the colormap-setting
2020     # functions, and anything marked as private with a preceding underscore.
2021     exclude = {'colormaps', 'colors', 'connect', 'disconnect',
2022                'get_plot_commands', 'get_current_fig_manager', 'ginput',
2023                'plotting', 'waitforbuttonpress'}
2024     exclude |= set(colormaps)
2025     this_module = inspect.getmodule(get_plot_commands)
2026     return sorted(
2027         name for name, obj in globals().items()
2028         if not name.startswith('_') and name not in exclude
2029            and inspect.isfunction(obj)
2030            and inspect.getmodule(obj) is this_module)
2031 
2032 
2033 def _setup_pyplot_info_docstrings():
2034     """
2035     Setup the docstring of `plotting` and of the colormap-setting functions.
2036 
2037     These must be done after the entire module is imported, so it is called
2038     from the end of this module, which is generated by boilerplate.py.
2039     """
2040     commands = get_plot_commands()
2041 
2042     first_sentence = re.compile(r"(?:\s*).+?\.(?:\s+|$)", flags=re.DOTALL)
2043 
2044     # Collect the first sentence of the docstring for all of the
2045     # plotting commands.
2046     rows = []
2047     max_name = len("Function")
2048     max_summary = len("Description")
2049     for name in commands:
2050         doc = globals()[name].__doc__
2051         summary = ''
2052         if doc is not None:
2053             match = first_sentence.match(doc)
2054             if match is not None:
2055                 summary = inspect.cleandoc(match.group(0)).replace('\n', ' ')
2056         name = '`%s`' % name
2057         rows.append([name, summary])
2058         max_name = max(max_name, len(name))
2059         max_summary = max(max_summary, len(summary))
2060 
2061     separator = '=' * max_name + ' ' + '=' * max_summary
2062     lines = [
2063         separator,
2064         '{:{}} {:{}}'.format('Function', max_name, 'Description', max_summary),
2065         separator,
2066     ] + [
2067         '{:{}} {:{}}'.format(name, max_name, summary, max_summary)
2068         for name, summary in rows
2069     ] + [
2070         separator,
2071     ]
2072     plotting.__doc__ = '\n'.join(lines)
2073 
2074     for cm_name in colormaps:
2075         if cm_name in globals():
2076             globals()[cm_name].__doc__ = f"""
2077     Set the colormap to {cm_name!r}.
2078 
2079     This changes the default colormap as well as the colormap of the current
2080     image if there is one. See ``help(colormaps)`` for more information.
2081     """
2082 
2083 
2084 ## Plotting part 1: manually generated functions and wrappers ##
2085 
2086 
2087 @_copy_docstring_and_deprecators(Figure.colorbar)
2088 def colorbar(mappable=None, cax=None, ax=None, **kwargs):
2089     if mappable is None:
2090         mappable = gci()
2091         if mappable is None:
2092             raise RuntimeError('No mappable was found to use for colorbar '
2093                                'creation. First define a mappable such as '
2094                                'an image (with imshow) or a contour set ('
2095                                'with contourf).')
2096     ret = gcf().colorbar(mappable, cax=cax, ax=ax, **kwargs)
2097     return ret
2098 
2099 
2100 def clim(vmin=None, vmax=None):
2101     """
2102     Set the color limits of the current image.
2103 
2104     If either *vmin* or *vmax* is None, the image min/max respectively
2105     will be used for color scaling.
2106 
2107     If you want to set the clim of multiple images, use
2108     `~.ScalarMappable.set_clim` on every image, for example::
2109 
2110       for im in gca().get_images():
2111           im.set_clim(0, 0.5)
2112 
2113     """
2114     im = gci()
2115     if im is None:
2116         raise RuntimeError('You must first define an image, e.g., with imshow')
2117 
2118     im.set_clim(vmin, vmax)
2119 
2120 
2121 def set_cmap(cmap):
2122     """
2123     Set the default colormap, and applies it to the current image if any.
2124 
2125     Parameters
2126     ----------
2127     cmap : `~matplotlib.colors.Colormap` or str
2128         A colormap instance or the name of a registered colormap.
2129 
2130     See Also
2131     --------
2132     colormaps
2133     matplotlib.cm.register_cmap
2134     matplotlib.cm.get_cmap
2135     """
2136     cmap = cm.get_cmap(cmap)
2137 
2138     rc('image', cmap=cmap.name)
2139     im = gci()
2140 
2141     if im is not None:
2142         im.set_cmap(cmap)
2143 
2144 
2145 @_copy_docstring_and_deprecators(matplotlib.image.imread)
2146 def imread(fname, format=None):
2147     return matplotlib.image.imread(fname, format)
2148 
2149 
2150 @_copy_docstring_and_deprecators(matplotlib.image.imsave)
2151 def imsave(fname, arr, **kwargs):
2152     return matplotlib.image.imsave(fname, arr, **kwargs)
2153 
2154 
2155 def matshow(A, fignum=None, **kwargs):
2156     """
2157     Display an array as a matrix in a new figure window.
2158 
2159     The origin is set at the upper left hand corner and rows (first
2160     dimension of the array) are displayed horizontally.  The aspect
2161     ratio of the figure window is that of the array, unless this would
2162     make an excessively short or narrow figure.
2163 
2164     Tick labels for the xaxis are placed on top.
2165 
2166     Parameters
2167     ----------
2168     A : 2D array-like
2169         The matrix to be displayed.
2170 
2171     fignum : None or int or False
2172         If *None*, create a new figure window with automatic numbering.
2173 
2174         If a nonzero integer, draw into the figure with the given number
2175         (create it if it does not exist).
2176 
2177         If 0, use the current axes (or create one if it does not exist).
2178 
2179         .. note::
2180 
2181            Because of how `.Axes.matshow` tries to set the figure aspect
2182            ratio to be the one of the array, strange things may happen if you
2183            reuse an existing figure.
2184 
2185     Returns
2186     -------
2187     `~matplotlib.image.AxesImage`
2188 
2189     Other Parameters
2190     ----------------
2191     **kwargs : `~matplotlib.axes.Axes.imshow` arguments
2192 
2193     """
2194     A = np.asanyarray(A)
2195     if fignum == 0:
2196         ax = gca()
2197     else:
2198         # Extract actual aspect ratio of array and make appropriately sized
2199         # figure.
2200         fig = figure(fignum, figsize=figaspect(A))
2201         ax = fig.add_axes([0.15, 0.09, 0.775, 0.775])
2202     im = ax.matshow(A, **kwargs)
2203     sci(im)
2204     return im
2205 
2206 
2207 def polar(*args, **kwargs):
2208     """
2209     Make a polar plot.
2210 
2211     call signature::
2212 
2213       polar(theta, r, **kwargs)
2214 
2215     Multiple *theta*, *r* arguments are supported, with format strings, as in
2216     `plot`.
2217     """
2218     # If an axis already exists, check if it has a polar projection
2219     if gcf().get_axes():
2220         ax = gca()
2221         if not isinstance(ax, PolarAxes):
2222             _api.warn_external('Trying to create polar plot on an Axes '
2223                                'that does not have a polar projection.')
2224     else:
2225         ax = axes(projection="polar")
2226     return ax.plot(*args, **kwargs)
2227 
2228 
2229 # If rcParams['backend_fallback'] is true, and an interactive backend is
2230 # requested, ignore rcParams['backend'] and force selection of a backend that
2231 # is compatible with the current running interactive framework.
2232 if (rcParams["backend_fallback"]
2233         and dict.__getitem__(rcParams, "backend") in (
2234             set(_interactive_bk) - {'WebAgg', 'nbAgg'})
2235         and cbook._get_running_interactive_framework()):
2236     dict.__setitem__(rcParams, "backend", rcsetup._auto_backend_sentinel)
2237 
2238 
2239 ################# REMAINING CONTENT GENERATED BY boilerplate.py ##############
2240 
2241 
2242 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2243 @_copy_docstring_and_deprecators(Figure.figimage)
2244 def figimage(
2245         X, xo=0, yo=0, alpha=None, norm=None, cmap=None, vmin=None,
2246         vmax=None, origin=None, resize=False, **kwargs):
2247     return gcf().figimage(
2248         X, xo=xo, yo=yo, alpha=alpha, norm=norm, cmap=cmap, vmin=vmin,
2249         vmax=vmax, origin=origin, resize=resize, **kwargs)
2250 
2251 
2252 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2253 @_copy_docstring_and_deprecators(Figure.text)
2254 def figtext(x, y, s, fontdict=None, **kwargs):
2255     return gcf().text(x, y, s, fontdict=fontdict, **kwargs)
2256 
2257 
2258 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2259 @_copy_docstring_and_deprecators(Figure.gca)
2260 def gca(**kwargs):
2261     return gcf().gca(**kwargs)
2262 
2263 
2264 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2265 @_copy_docstring_and_deprecators(Figure._gci)
2266 def gci():
2267     return gcf()._gci()
2268 
2269 
2270 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2271 @_copy_docstring_and_deprecators(Figure.ginput)
2272 def ginput(
2273         n=1, timeout=30, show_clicks=True,
2274         mouse_add=MouseButton.LEFT, mouse_pop=MouseButton.RIGHT,
2275         mouse_stop=MouseButton.MIDDLE):
2276     return gcf().ginput(
2277         n=n, timeout=timeout, show_clicks=show_clicks,
2278         mouse_add=mouse_add, mouse_pop=mouse_pop,
2279         mouse_stop=mouse_stop)
2280 
2281 
2282 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2283 @_copy_docstring_and_deprecators(Figure.subplots_adjust)
2284 def subplots_adjust(
2285         left=None, bottom=None, right=None, top=None, wspace=None,
2286         hspace=None):
2287     return gcf().subplots_adjust(
2288         left=left, bottom=bottom, right=right, top=top, wspace=wspace,
2289         hspace=hspace)
2290 
2291 
2292 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2293 @_copy_docstring_and_deprecators(Figure.suptitle)
2294 def suptitle(t, **kwargs):
2295     return gcf().suptitle(t, **kwargs)
2296 
2297 
2298 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2299 @_copy_docstring_and_deprecators(Figure.tight_layout)
2300 def tight_layout(*, pad=1.08, h_pad=None, w_pad=None, rect=None):
2301     return gcf().tight_layout(pad=pad, h_pad=h_pad, w_pad=w_pad, rect=rect)
2302 
2303 
2304 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2305 @_copy_docstring_and_deprecators(Figure.waitforbuttonpress)
2306 def waitforbuttonpress(timeout=-1):
2307     return gcf().waitforbuttonpress(timeout=timeout)
2308 
2309 
2310 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2311 @_copy_docstring_and_deprecators(Axes.acorr)
2312 def acorr(x, *, data=None, **kwargs):
2313     return gca().acorr(
2314         x, **({"data": data} if data is not None else {}), **kwargs)
2315 
2316 
2317 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2318 @_copy_docstring_and_deprecators(Axes.angle_spectrum)
2319 def angle_spectrum(
2320         x, Fs=None, Fc=None, window=None, pad_to=None, sides=None, *,
2321         data=None, **kwargs):
2322     return gca().angle_spectrum(
2323         x, Fs=Fs, Fc=Fc, window=window, pad_to=pad_to, sides=sides,
2324         **({"data": data} if data is not None else {}), **kwargs)
2325 
2326 
2327 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2328 @_copy_docstring_and_deprecators(Axes.annotate)
2329 def annotate(
2330         text, xy, xytext=None, xycoords='data', textcoords=None,
2331         arrowprops=None, annotation_clip=None, **kwargs):
2332     return gca().annotate(
2333         text, xy, xytext=xytext, xycoords=xycoords,
2334         textcoords=textcoords, arrowprops=arrowprops,
2335         annotation_clip=annotation_clip, **kwargs)
2336 
2337 
2338 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2339 @_copy_docstring_and_deprecators(Axes.arrow)
2340 def arrow(x, y, dx, dy, **kwargs):
2341     return gca().arrow(x, y, dx, dy, **kwargs)
2342 
2343 
2344 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2345 @_copy_docstring_and_deprecators(Axes.autoscale)
2346 def autoscale(enable=True, axis='both', tight=None):
2347     return gca().autoscale(enable=enable, axis=axis, tight=tight)
2348 
2349 
2350 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2351 @_copy_docstring_and_deprecators(Axes.axhline)
2352 def axhline(y=0, xmin=0, xmax=1, **kwargs):
2353     return gca().axhline(y=y, xmin=xmin, xmax=xmax, **kwargs)
2354 
2355 
2356 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2357 @_copy_docstring_and_deprecators(Axes.axhspan)
2358 def axhspan(ymin, ymax, xmin=0, xmax=1, **kwargs):
2359     return gca().axhspan(ymin, ymax, xmin=xmin, xmax=xmax, **kwargs)
2360 
2361 
2362 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2363 @_copy_docstring_and_deprecators(Axes.axis)
2364 def axis(*args, emit=True, **kwargs):
2365     return gca().axis(*args, emit=emit, **kwargs)
2366 
2367 
2368 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2369 @_copy_docstring_and_deprecators(Axes.axline)
2370 def axline(xy1, xy2=None, *, slope=None, **kwargs):
2371     return gca().axline(xy1, xy2=xy2, slope=slope, **kwargs)
2372 
2373 
2374 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2375 @_copy_docstring_and_deprecators(Axes.axvline)
2376 def axvline(x=0, ymin=0, ymax=1, **kwargs):
2377     return gca().axvline(x=x, ymin=ymin, ymax=ymax, **kwargs)
2378 
2379 
2380 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2381 @_copy_docstring_and_deprecators(Axes.axvspan)
2382 def axvspan(xmin, xmax, ymin=0, ymax=1, **kwargs):
2383     return gca().axvspan(xmin, xmax, ymin=ymin, ymax=ymax, **kwargs)
2384 
2385 
2386 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2387 @_copy_docstring_and_deprecators(Axes.bar)
2388 def bar(
2389         x, height, width=0.8, bottom=None, *, align='center',
2390         data=None, **kwargs):
2391     return gca().bar(
2392         x, height, width=width, bottom=bottom, align=align,
2393         **({"data": data} if data is not None else {}), **kwargs)
2394 
2395 
2396 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2397 @_copy_docstring_and_deprecators(Axes.barbs)
2398 def barbs(*args, data=None, **kwargs):
2399     return gca().barbs(
2400         *args, **({"data": data} if data is not None else {}),
2401         **kwargs)
2402 
2403 
2404 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2405 @_copy_docstring_and_deprecators(Axes.barh)
2406 def barh(y, width, height=0.8, left=None, *, align='center', **kwargs):
2407     return gca().barh(
2408         y, width, height=height, left=left, align=align, **kwargs)
2409 
2410 
2411 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2412 @_copy_docstring_and_deprecators(Axes.bar_label)
2413 def bar_label(
2414         container, labels=None, *, fmt='%g', label_type='edge',
2415         padding=0, **kwargs):
2416     return gca().bar_label(
2417         container, labels=labels, fmt=fmt, label_type=label_type,
2418         padding=padding, **kwargs)
2419 
2420 
2421 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2422 @_copy_docstring_and_deprecators(Axes.boxplot)
2423 def boxplot(
2424         x, notch=None, sym=None, vert=None, whis=None,
2425         positions=None, widths=None, patch_artist=None,
2426         bootstrap=None, usermedians=None, conf_intervals=None,
2427         meanline=None, showmeans=None, showcaps=None, showbox=None,
2428         showfliers=None, boxprops=None, labels=None, flierprops=None,
2429         medianprops=None, meanprops=None, capprops=None,
2430         whiskerprops=None, manage_ticks=True, autorange=False,
2431         zorder=None, capwidths=None, *, data=None):
2432     return gca().boxplot(
2433         x, notch=notch, sym=sym, vert=vert, whis=whis,
2434         positions=positions, widths=widths, patch_artist=patch_artist,
2435         bootstrap=bootstrap, usermedians=usermedians,
2436         conf_intervals=conf_intervals, meanline=meanline,
2437         showmeans=showmeans, showcaps=showcaps, showbox=showbox,
2438         showfliers=showfliers, boxprops=boxprops, labels=labels,
2439         flierprops=flierprops, medianprops=medianprops,
2440         meanprops=meanprops, capprops=capprops,
2441         whiskerprops=whiskerprops, manage_ticks=manage_ticks,
2442         autorange=autorange, zorder=zorder, capwidths=capwidths,
2443         **({"data": data} if data is not None else {}))
2444 
2445 
2446 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2447 @_copy_docstring_and_deprecators(Axes.broken_barh)
2448 def broken_barh(xranges, yrange, *, data=None, **kwargs):
2449     return gca().broken_barh(
2450         xranges, yrange,
2451         **({"data": data} if data is not None else {}), **kwargs)
2452 
2453 
2454 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2455 @_copy_docstring_and_deprecators(Axes.clabel)
2456 def clabel(CS, levels=None, **kwargs):
2457     return gca().clabel(CS, levels=levels, **kwargs)
2458 
2459 
2460 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2461 @_copy_docstring_and_deprecators(Axes.cohere)
2462 def cohere(
2463         x, y, NFFT=256, Fs=2, Fc=0, detrend=mlab.detrend_none,
2464         window=mlab.window_hanning, noverlap=0, pad_to=None,
2465         sides='default', scale_by_freq=None, *, data=None, **kwargs):
2466     return gca().cohere(
2467         x, y, NFFT=NFFT, Fs=Fs, Fc=Fc, detrend=detrend, window=window,
2468         noverlap=noverlap, pad_to=pad_to, sides=sides,
2469         scale_by_freq=scale_by_freq,
2470         **({"data": data} if data is not None else {}), **kwargs)
2471 
2472 
2473 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2474 @_copy_docstring_and_deprecators(Axes.contour)
2475 def contour(*args, data=None, **kwargs):
2476     __ret = gca().contour(
2477         *args, **({"data": data} if data is not None else {}),
2478         **kwargs)
2479     if __ret._A is not None: sci(__ret)  # noqa
2480     return __ret
2481 
2482 
2483 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2484 @_copy_docstring_and_deprecators(Axes.contourf)
2485 def contourf(*args, data=None, **kwargs):
2486     __ret = gca().contourf(
2487         *args, **({"data": data} if data is not None else {}),
2488         **kwargs)
2489     if __ret._A is not None: sci(__ret)  # noqa
2490     return __ret
2491 
2492 
2493 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2494 @_copy_docstring_and_deprecators(Axes.csd)
2495 def csd(
2496         x, y, NFFT=None, Fs=None, Fc=None, detrend=None, window=None,
2497         noverlap=None, pad_to=None, sides=None, scale_by_freq=None,
2498         return_line=None, *, data=None, **kwargs):
2499     return gca().csd(
2500         x, y, NFFT=NFFT, Fs=Fs, Fc=Fc, detrend=detrend, window=window,
2501         noverlap=noverlap, pad_to=pad_to, sides=sides,
2502         scale_by_freq=scale_by_freq, return_line=return_line,
2503         **({"data": data} if data is not None else {}), **kwargs)
2504 
2505 
2506 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2507 @_copy_docstring_and_deprecators(Axes.errorbar)
2508 def errorbar(
2509         x, y, yerr=None, xerr=None, fmt='', ecolor=None,
2510         elinewidth=None, capsize=None, barsabove=False, lolims=False,
2511         uplims=False, xlolims=False, xuplims=False, errorevery=1,
2512         capthick=None, *, data=None, **kwargs):
2513     return gca().errorbar(
2514         x, y, yerr=yerr, xerr=xerr, fmt=fmt, ecolor=ecolor,
2515         elinewidth=elinewidth, capsize=capsize, barsabove=barsabove,
2516         lolims=lolims, uplims=uplims, xlolims=xlolims,
2517         xuplims=xuplims, errorevery=errorevery, capthick=capthick,
2518         **({"data": data} if data is not None else {}), **kwargs)
2519 
2520 
2521 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2522 @_copy_docstring_and_deprecators(Axes.eventplot)
2523 def eventplot(
2524         positions, orientation='horizontal', lineoffsets=1,
2525         linelengths=1, linewidths=None, colors=None,
2526         linestyles='solid', *, data=None, **kwargs):
2527     return gca().eventplot(
2528         positions, orientation=orientation, lineoffsets=lineoffsets,
2529         linelengths=linelengths, linewidths=linewidths, colors=colors,
2530         linestyles=linestyles,
2531         **({"data": data} if data is not None else {}), **kwargs)
2532 
2533 
2534 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2535 @_copy_docstring_and_deprecators(Axes.fill)
2536 def fill(*args, data=None, **kwargs):
2537     return gca().fill(
2538         *args, **({"data": data} if data is not None else {}),
2539         **kwargs)
2540 
2541 
2542 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2543 @_copy_docstring_and_deprecators(Axes.fill_between)
2544 def fill_between(
2545         x, y1, y2=0, where=None, interpolate=False, step=None, *,
2546         data=None, **kwargs):
2547     return gca().fill_between(
2548         x, y1, y2=y2, where=where, interpolate=interpolate, step=step,
2549         **({"data": data} if data is not None else {}), **kwargs)
2550 
2551 
2552 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2553 @_copy_docstring_and_deprecators(Axes.fill_betweenx)
2554 def fill_betweenx(
2555         y, x1, x2=0, where=None, step=None, interpolate=False, *,
2556         data=None, **kwargs):
2557     return gca().fill_betweenx(
2558         y, x1, x2=x2, where=where, step=step, interpolate=interpolate,
2559         **({"data": data} if data is not None else {}), **kwargs)
2560 
2561 
2562 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2563 @_copy_docstring_and_deprecators(Axes.grid)
2564 def grid(visible=None, which='major', axis='both', **kwargs):
2565     return gca().grid(visible=visible, which=which, axis=axis, **kwargs)
2566 
2567 
2568 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2569 @_copy_docstring_and_deprecators(Axes.hexbin)
2570 def hexbin(
2571         x, y, C=None, gridsize=100, bins=None, xscale='linear',
2572         yscale='linear', extent=None, cmap=None, norm=None, vmin=None,
2573         vmax=None, alpha=None, linewidths=None, edgecolors='face',
2574         reduce_C_function=np.mean, mincnt=None, marginals=False, *,
2575         data=None, **kwargs):
2576     __ret = gca().hexbin(
2577         x, y, C=C, gridsize=gridsize, bins=bins, xscale=xscale,
2578         yscale=yscale, extent=extent, cmap=cmap, norm=norm, vmin=vmin,
2579         vmax=vmax, alpha=alpha, linewidths=linewidths,
2580         edgecolors=edgecolors, reduce_C_function=reduce_C_function,
2581         mincnt=mincnt, marginals=marginals,
2582         **({"data": data} if data is not None else {}), **kwargs)
2583     sci(__ret)
2584     return __ret
2585 
2586 
2587 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2588 @_copy_docstring_and_deprecators(Axes.hist)
2589 def hist(
2590         x, bins=None, range=None, density=False, weights=None,
2591         cumulative=False, bottom=None, histtype='bar', align='mid',
2592         orientation='vertical', rwidth=None, log=False, color=None,
2593         label=None, stacked=False, *, data=None, **kwargs):
2594     return gca().hist(
2595         x, bins=bins, range=range, density=density, weights=weights,
2596         cumulative=cumulative, bottom=bottom, histtype=histtype,
2597         align=align, orientation=orientation, rwidth=rwidth, log=log,
2598         color=color, label=label, stacked=stacked,
2599         **({"data": data} if data is not None else {}), **kwargs)
2600 
2601 
2602 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2603 @_copy_docstring_and_deprecators(Axes.stairs)
2604 def stairs(
2605         values, edges=None, *, orientation='vertical', baseline=0,
2606         fill=False, data=None, **kwargs):
2607     return gca().stairs(
2608         values, edges=edges, orientation=orientation,
2609         baseline=baseline, fill=fill,
2610         **({"data": data} if data is not None else {}), **kwargs)
2611 
2612 
2613 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2614 @_copy_docstring_and_deprecators(Axes.hist2d)
2615 def hist2d(
2616         x, y, bins=10, range=None, density=False, weights=None,
2617         cmin=None, cmax=None, *, data=None, **kwargs):
2618     __ret = gca().hist2d(
2619         x, y, bins=bins, range=range, density=density,
2620         weights=weights, cmin=cmin, cmax=cmax,
2621         **({"data": data} if data is not None else {}), **kwargs)
2622     sci(__ret[-1])
2623     return __ret
2624 
2625 
2626 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2627 @_copy_docstring_and_deprecators(Axes.hlines)
2628 def hlines(
2629         y, xmin, xmax, colors=None, linestyles='solid', label='', *,
2630         data=None, **kwargs):
2631     return gca().hlines(
2632         y, xmin, xmax, colors=colors, linestyles=linestyles,
2633         label=label, **({"data": data} if data is not None else {}),
2634         **kwargs)
2635 
2636 
2637 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2638 @_copy_docstring_and_deprecators(Axes.imshow)
2639 def imshow(
2640         X, cmap=None, norm=None, aspect=None, interpolation=None,
2641         alpha=None, vmin=None, vmax=None, origin=None, extent=None, *,
2642         interpolation_stage=None, filternorm=True, filterrad=4.0,
2643         resample=None, url=None, data=None, **kwargs):
2644     __ret = gca().imshow(
2645         X, cmap=cmap, norm=norm, aspect=aspect,
2646         interpolation=interpolation, alpha=alpha, vmin=vmin,
2647         vmax=vmax, origin=origin, extent=extent,
2648         interpolation_stage=interpolation_stage,
2649         filternorm=filternorm, filterrad=filterrad, resample=resample,
2650         url=url, **({"data": data} if data is not None else {}),
2651         **kwargs)
2652     sci(__ret)
2653     return __ret
2654 
2655 
2656 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2657 @_copy_docstring_and_deprecators(Axes.legend)
2658 def legend(*args, **kwargs):
2659     return gca().legend(*args, **kwargs)
2660 
2661 
2662 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2663 @_copy_docstring_and_deprecators(Axes.locator_params)
2664 def locator_params(axis='both', tight=None, **kwargs):
2665     return gca().locator_params(axis=axis, tight=tight, **kwargs)
2666 
2667 
2668 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2669 @_copy_docstring_and_deprecators(Axes.loglog)
2670 def loglog(*args, **kwargs):
2671     return gca().loglog(*args, **kwargs)
2672 
2673 
2674 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2675 @_copy_docstring_and_deprecators(Axes.magnitude_spectrum)
2676 def magnitude_spectrum(
2677         x, Fs=None, Fc=None, window=None, pad_to=None, sides=None,
2678         scale=None, *, data=None, **kwargs):
2679     return gca().magnitude_spectrum(
2680         x, Fs=Fs, Fc=Fc, window=window, pad_to=pad_to, sides=sides,
2681         scale=scale, **({"data": data} if data is not None else {}),
2682         **kwargs)
2683 
2684 
2685 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2686 @_copy_docstring_and_deprecators(Axes.margins)
2687 def margins(*margins, x=None, y=None, tight=True):
2688     return gca().margins(*margins, x=x, y=y, tight=tight)
2689 
2690 
2691 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2692 @_copy_docstring_and_deprecators(Axes.minorticks_off)
2693 def minorticks_off():
2694     return gca().minorticks_off()
2695 
2696 
2697 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2698 @_copy_docstring_and_deprecators(Axes.minorticks_on)
2699 def minorticks_on():
2700     return gca().minorticks_on()
2701 
2702 
2703 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2704 @_copy_docstring_and_deprecators(Axes.pcolor)
2705 def pcolor(
2706         *args, shading=None, alpha=None, norm=None, cmap=None,
2707         vmin=None, vmax=None, data=None, **kwargs):
2708     __ret = gca().pcolor(
2709         *args, shading=shading, alpha=alpha, norm=norm, cmap=cmap,
2710         vmin=vmin, vmax=vmax,
2711         **({"data": data} if data is not None else {}), **kwargs)
2712     sci(__ret)
2713     return __ret
2714 
2715 
2716 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2717 @_copy_docstring_and_deprecators(Axes.pcolormesh)
2718 def pcolormesh(
2719         *args, alpha=None, norm=None, cmap=None, vmin=None,
2720         vmax=None, shading=None, antialiased=False, data=None,
2721         **kwargs):
2722     __ret = gca().pcolormesh(
2723         *args, alpha=alpha, norm=norm, cmap=cmap, vmin=vmin,
2724         vmax=vmax, shading=shading, antialiased=antialiased,
2725         **({"data": data} if data is not None else {}), **kwargs)
2726     sci(__ret)
2727     return __ret
2728 
2729 
2730 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2731 @_copy_docstring_and_deprecators(Axes.phase_spectrum)
2732 def phase_spectrum(
2733         x, Fs=None, Fc=None, window=None, pad_to=None, sides=None, *,
2734         data=None, **kwargs):
2735     return gca().phase_spectrum(
2736         x, Fs=Fs, Fc=Fc, window=window, pad_to=pad_to, sides=sides,
2737         **({"data": data} if data is not None else {}), **kwargs)
2738 
2739 
2740 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2741 @_copy_docstring_and_deprecators(Axes.pie)
2742 def pie(
2743         x, explode=None, labels=None, colors=None, autopct=None,
2744         pctdistance=0.6, shadow=False, labeldistance=1.1,
2745         startangle=0, radius=1, counterclock=True, wedgeprops=None,
2746         textprops=None, center=(0, 0), frame=False,
2747         rotatelabels=False, *, normalize=True, data=None):
2748     return gca().pie(
2749         x, explode=explode, labels=labels, colors=colors,
2750         autopct=autopct, pctdistance=pctdistance, shadow=shadow,
2751         labeldistance=labeldistance, startangle=startangle,
2752         radius=radius, counterclock=counterclock,
2753         wedgeprops=wedgeprops, textprops=textprops, center=center,
2754         frame=frame, rotatelabels=rotatelabels, normalize=normalize,
2755         **({"data": data} if data is not None else {}))
2756 
2757 
2758 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2759 @_copy_docstring_and_deprecators(Axes.plot)
2760 def plot(*args, scalex=True, scaley=True, data=None, **kwargs):
2761     return gca().plot(
2762         *args, scalex=scalex, scaley=scaley,
2763         **({"data": data} if data is not None else {}), **kwargs)
2764 
2765 
2766 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2767 @_copy_docstring_and_deprecators(Axes.plot_date)
2768 def plot_date(
2769         x, y, fmt='o', tz=None, xdate=True, ydate=False, *,
2770         data=None, **kwargs):
2771     return gca().plot_date(
2772         x, y, fmt=fmt, tz=tz, xdate=xdate, ydate=ydate,
2773         **({"data": data} if data is not None else {}), **kwargs)
2774 
2775 
2776 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2777 @_copy_docstring_and_deprecators(Axes.psd)
2778 def psd(
2779         x, NFFT=None, Fs=None, Fc=None, detrend=None, window=None,
2780         noverlap=None, pad_to=None, sides=None, scale_by_freq=None,
2781         return_line=None, *, data=None, **kwargs):
2782     return gca().psd(
2783         x, NFFT=NFFT, Fs=Fs, Fc=Fc, detrend=detrend, window=window,
2784         noverlap=noverlap, pad_to=pad_to, sides=sides,
2785         scale_by_freq=scale_by_freq, return_line=return_line,
2786         **({"data": data} if data is not None else {}), **kwargs)
2787 
2788 
2789 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2790 @_copy_docstring_and_deprecators(Axes.quiver)
2791 def quiver(*args, data=None, **kwargs):
2792     __ret = gca().quiver(
2793         *args, **({"data": data} if data is not None else {}),
2794         **kwargs)
2795     sci(__ret)
2796     return __ret
2797 
2798 
2799 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2800 @_copy_docstring_and_deprecators(Axes.quiverkey)
2801 def quiverkey(Q, X, Y, U, label, **kwargs):
2802     return gca().quiverkey(Q, X, Y, U, label, **kwargs)
2803 
2804 
2805 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2806 @_copy_docstring_and_deprecators(Axes.scatter)
2807 def scatter(
2808         x, y, s=None, c=None, marker=None, cmap=None, norm=None,
2809         vmin=None, vmax=None, alpha=None, linewidths=None, *,
2810         edgecolors=None, plotnonfinite=False, data=None, **kwargs):
2811     __ret = gca().scatter(
2812         x, y, s=s, c=c, marker=marker, cmap=cmap, norm=norm,
2813         vmin=vmin, vmax=vmax, alpha=alpha, linewidths=linewidths,
2814         edgecolors=edgecolors, plotnonfinite=plotnonfinite,
2815         **({"data": data} if data is not None else {}), **kwargs)
2816     sci(__ret)
2817     return __ret
2818 
2819 
2820 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2821 @_copy_docstring_and_deprecators(Axes.semilogx)
2822 def semilogx(*args, **kwargs):
2823     return gca().semilogx(*args, **kwargs)
2824 
2825 
2826 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2827 @_copy_docstring_and_deprecators(Axes.semilogy)
2828 def semilogy(*args, **kwargs):
2829     return gca().semilogy(*args, **kwargs)
2830 
2831 
2832 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2833 @_copy_docstring_and_deprecators(Axes.specgram)
2834 def specgram(
2835         x, NFFT=None, Fs=None, Fc=None, detrend=None, window=None,
2836         noverlap=None, cmap=None, xextent=None, pad_to=None,
2837         sides=None, scale_by_freq=None, mode=None, scale=None,
2838         vmin=None, vmax=None, *, data=None, **kwargs):
2839     __ret = gca().specgram(
2840         x, NFFT=NFFT, Fs=Fs, Fc=Fc, detrend=detrend, window=window,
2841         noverlap=noverlap, cmap=cmap, xextent=xextent, pad_to=pad_to,
2842         sides=sides, scale_by_freq=scale_by_freq, mode=mode,
2843         scale=scale, vmin=vmin, vmax=vmax,
2844         **({"data": data} if data is not None else {}), **kwargs)
2845     sci(__ret[-1])
2846     return __ret
2847 
2848 
2849 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2850 @_copy_docstring_and_deprecators(Axes.spy)
2851 def spy(
2852         Z, precision=0, marker=None, markersize=None, aspect='equal',
2853         origin='upper', **kwargs):
2854     __ret = gca().spy(
2855         Z, precision=precision, marker=marker, markersize=markersize,
2856         aspect=aspect, origin=origin, **kwargs)
2857     if isinstance(__ret, cm.ScalarMappable): sci(__ret)  # noqa
2858     return __ret
2859 
2860 
2861 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2862 @_copy_docstring_and_deprecators(Axes.stackplot)
2863 def stackplot(
2864         x, *args, labels=(), colors=None, baseline='zero', data=None,
2865         **kwargs):
2866     return gca().stackplot(
2867         x, *args, labels=labels, colors=colors, baseline=baseline,
2868         **({"data": data} if data is not None else {}), **kwargs)
2869 
2870 
2871 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2872 @_copy_docstring_and_deprecators(Axes.stem)
2873 def stem(
2874         *args, linefmt=None, markerfmt=None, basefmt=None, bottom=0,
2875         label=None, use_line_collection=True, orientation='vertical',
2876         data=None):
2877     return gca().stem(
2878         *args, linefmt=linefmt, markerfmt=markerfmt, basefmt=basefmt,
2879         bottom=bottom, label=label,
2880         use_line_collection=use_line_collection,
2881         orientation=orientation,
2882         **({"data": data} if data is not None else {}))
2883 
2884 
2885 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2886 @_copy_docstring_and_deprecators(Axes.step)
2887 def step(x, y, *args, where='pre', data=None, **kwargs):
2888     return gca().step(
2889         x, y, *args, where=where,
2890         **({"data": data} if data is not None else {}), **kwargs)
2891 
2892 
2893 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2894 @_copy_docstring_and_deprecators(Axes.streamplot)
2895 def streamplot(
2896         x, y, u, v, density=1, linewidth=None, color=None, cmap=None,
2897         norm=None, arrowsize=1, arrowstyle='-|>', minlength=0.1,
2898         transform=None, zorder=None, start_points=None, maxlength=4.0,
2899         integration_direction='both', broken_streamlines=True, *,
2900         data=None):
2901     __ret = gca().streamplot(
2902         x, y, u, v, density=density, linewidth=linewidth, color=color,
2903         cmap=cmap, norm=norm, arrowsize=arrowsize,
2904         arrowstyle=arrowstyle, minlength=minlength,
2905         transform=transform, zorder=zorder, start_points=start_points,
2906         maxlength=maxlength,
2907         integration_direction=integration_direction,
2908         broken_streamlines=broken_streamlines,
2909         **({"data": data} if data is not None else {}))
2910     sci(__ret.lines)
2911     return __ret
2912 
2913 
2914 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2915 @_copy_docstring_and_deprecators(Axes.table)
2916 def table(
2917         cellText=None, cellColours=None, cellLoc='right',
2918         colWidths=None, rowLabels=None, rowColours=None,
2919         rowLoc='left', colLabels=None, colColours=None,
2920         colLoc='center', loc='bottom', bbox=None, edges='closed',
2921         **kwargs):
2922     return gca().table(
2923         cellText=cellText, cellColours=cellColours, cellLoc=cellLoc,
2924         colWidths=colWidths, rowLabels=rowLabels,
2925         rowColours=rowColours, rowLoc=rowLoc, colLabels=colLabels,
2926         colColours=colColours, colLoc=colLoc, loc=loc, bbox=bbox,
2927         edges=edges, **kwargs)
2928 
2929 
2930 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2931 @_copy_docstring_and_deprecators(Axes.text)
2932 def text(x, y, s, fontdict=None, **kwargs):
2933     return gca().text(x, y, s, fontdict=fontdict, **kwargs)
2934 
2935 
2936 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2937 @_copy_docstring_and_deprecators(Axes.tick_params)
2938 def tick_params(axis='both', **kwargs):
2939     return gca().tick_params(axis=axis, **kwargs)
2940 
2941 
2942 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2943 @_copy_docstring_and_deprecators(Axes.ticklabel_format)
2944 def ticklabel_format(
2945         *, axis='both', style='', scilimits=None, useOffset=None,
2946         useLocale=None, useMathText=None):
2947     return gca().ticklabel_format(
2948         axis=axis, style=style, scilimits=scilimits,
2949         useOffset=useOffset, useLocale=useLocale,
2950         useMathText=useMathText)
2951 
2952 
2953 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2954 @_copy_docstring_and_deprecators(Axes.tricontour)
2955 def tricontour(*args, **kwargs):
2956     __ret = gca().tricontour(*args, **kwargs)
2957     if __ret._A is not None: sci(__ret)  # noqa
2958     return __ret
2959 
2960 
2961 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2962 @_copy_docstring_and_deprecators(Axes.tricontourf)
2963 def tricontourf(*args, **kwargs):
2964     __ret = gca().tricontourf(*args, **kwargs)
2965     if __ret._A is not None: sci(__ret)  # noqa
2966     return __ret
2967 
2968 
2969 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2970 @_copy_docstring_and_deprecators(Axes.tripcolor)
2971 def tripcolor(
2972         *args, alpha=1.0, norm=None, cmap=None, vmin=None, vmax=None,
2973         shading='flat', facecolors=None, **kwargs):
2974     __ret = gca().tripcolor(
2975         *args, alpha=alpha, norm=norm, cmap=cmap, vmin=vmin,
2976         vmax=vmax, shading=shading, facecolors=facecolors, **kwargs)
2977     sci(__ret)
2978     return __ret
2979 
2980 
2981 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2982 @_copy_docstring_and_deprecators(Axes.triplot)
2983 def triplot(*args, **kwargs):
2984     return gca().triplot(*args, **kwargs)
2985 
2986 
2987 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2988 @_copy_docstring_and_deprecators(Axes.violinplot)
2989 def violinplot(
2990         dataset, positions=None, vert=True, widths=0.5,
2991         showmeans=False, showextrema=True, showmedians=False,
2992         quantiles=None, points=100, bw_method=None, *, data=None):
2993     return gca().violinplot(
2994         dataset, positions=positions, vert=vert, widths=widths,
2995         showmeans=showmeans, showextrema=showextrema,
2996         showmedians=showmedians, quantiles=quantiles, points=points,
2997         bw_method=bw_method,
2998         **({"data": data} if data is not None else {}))
2999 
3000 
3001 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3002 @_copy_docstring_and_deprecators(Axes.vlines)
3003 def vlines(
3004         x, ymin, ymax, colors=None, linestyles='solid', label='', *,
3005         data=None, **kwargs):
3006     return gca().vlines(
3007         x, ymin, ymax, colors=colors, linestyles=linestyles,
3008         label=label, **({"data": data} if data is not None else {}),
3009         **kwargs)
3010 
3011 
3012 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3013 @_copy_docstring_and_deprecators(Axes.xcorr)
3014 def xcorr(
3015         x, y, normed=True, detrend=mlab.detrend_none, usevlines=True,
3016         maxlags=10, *, data=None, **kwargs):
3017     return gca().xcorr(
3018         x, y, normed=normed, detrend=detrend, usevlines=usevlines,
3019         maxlags=maxlags,
3020         **({"data": data} if data is not None else {}), **kwargs)
3021 
3022 
3023 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3024 @_copy_docstring_and_deprecators(Axes._sci)
3025 def sci(im):
3026     return gca()._sci(im)
3027 
3028 
3029 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3030 @_copy_docstring_and_deprecators(Axes.set_title)
3031 def title(label, fontdict=None, loc=None, pad=None, *, y=None, **kwargs):
3032     return gca().set_title(
3033         label, fontdict=fontdict, loc=loc, pad=pad, y=y, **kwargs)
3034 
3035 
3036 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3037 @_copy_docstring_and_deprecators(Axes.set_xlabel)
3038 def xlabel(xlabel, fontdict=None, labelpad=None, *, loc=None, **kwargs):
3039     return gca().set_xlabel(
3040         xlabel, fontdict=fontdict, labelpad=labelpad, loc=loc,
3041         **kwargs)
3042 
3043 
3044 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3045 @_copy_docstring_and_deprecators(Axes.set_ylabel)
3046 def ylabel(ylabel, fontdict=None, labelpad=None, *, loc=None, **kwargs):
3047     return gca().set_ylabel(
3048         ylabel, fontdict=fontdict, labelpad=labelpad, loc=loc,
3049         **kwargs)
3050 
3051 
3052 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3053 @_copy_docstring_and_deprecators(Axes.set_xscale)
3054 def xscale(value, **kwargs):
3055     return gca().set_xscale(value, **kwargs)
3056 
3057 
3058 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3059 @_copy_docstring_and_deprecators(Axes.set_yscale)
3060 def yscale(value, **kwargs):
3061     return gca().set_yscale(value, **kwargs)
3062 
3063 
3064 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3065 def autumn(): set_cmap('autumn')
3066 def bone(): set_cmap('bone')
3067 def cool(): set_cmap('cool')
3068 def copper(): set_cmap('copper')
3069 def flag(): set_cmap('flag')
3070 def gray(): set_cmap('gray')
3071 def hot(): set_cmap('hot')
3072 def hsv(): set_cmap('hsv')
3073 def jet(): set_cmap('jet')
3074 def pink(): set_cmap('pink')
3075 def prism(): set_cmap('prism')
3076 def spring(): set_cmap('spring')
3077 def summer(): set_cmap('summer')
3078 def winter(): set_cmap('winter')
3079 def magma(): set_cmap('magma')
3080 def inferno(): set_cmap('inferno')
3081 def plasma(): set_cmap('plasma')
3082 def viridis(): set_cmap('viridis')
3083 def nipy_spectral(): set_cmap('nipy_spectral')
3084 
3085 
3086 _setup_pyplot_info_docstrings()

</code><intended_behavior>This method should be extended or adjusted to correctly recognize and handle `SubFigure` objects. When `num` is a `SubFigure`, instead of attempting (and failing) to convert it to an integer, the method should either navigate to its parent figure or directly manage the `SubFigure` without raising a type error. This change will allow `plt.sca()` to be used with axes that are part of subfigures, aligning with the intended seamless usage between figures and axes across different contexts in Matplotlib.</intended_behavior>]
2025-10-15 20:26:16.539 | INFO     | Search completed. Bug locations: [<file>lib/matplotlib/pyplot.py</file>
<class>None</class>
<method>None</method>
<code>
1 # Note: The first part of this file can be modified in place, but the latter
2 # part is autogenerated by the boilerplate.py script.
3 
4 """
5 `matplotlib.pyplot` is a state-based interface to matplotlib. It provides
6 an implicit,  MATLAB-like, way of plotting.  It also opens figures on your
7 screen, and acts as the figure GUI manager.
8 
9 pyplot is mainly intended for interactive plots and simple cases of
10 programmatic plot generation::
11 
12     import numpy as np
13     import matplotlib.pyplot as plt
14 
15     x = np.arange(0, 5, 0.1)
16     y = np.sin(x)
17     plt.plot(x, y)
18 
19 The explicit object-oriented API is recommended for complex plots, though
20 pyplot is still usually used to create the figure and often the axes in the
21 figure. See `.pyplot.figure`, `.pyplot.subplots`, and
22 `.pyplot.subplot_mosaic` to create figures, and
23 :doc:`Axes API <../axes_api>` for the plotting methods on an Axes::
24 
25     import numpy as np
26     import matplotlib.pyplot as plt
27 
28     x = np.arange(0, 5, 0.1)
29     y = np.sin(x)
30     fig, ax = plt.subplots()
31     ax.plot(x, y)
32 
33 
34 See :ref:`api_interfaces` for an explanation of the tradeoffs between the
35 implicit and explicit interfaces.
36 """
37 
38 from enum import Enum
39 import functools
40 import importlib
41 import inspect
42 import logging
43 from numbers import Number
44 import re
45 import sys
46 import time
47 try:
48     import threading
49 except ImportError:
50     import dummy_threading as threading
51 
52 from cycler import cycler
53 import matplotlib
54 import matplotlib.colorbar
55 import matplotlib.image
56 from matplotlib import _api
57 from matplotlib import rcsetup, style
58 from matplotlib import _pylab_helpers, interactive
59 from matplotlib import cbook
60 from matplotlib import _docstring
61 from matplotlib.backend_bases import FigureCanvasBase, MouseButton
62 from matplotlib.figure import Figure, figaspect
63 from matplotlib.gridspec import GridSpec, SubplotSpec
64 from matplotlib import rcParams, rcParamsDefault, get_backend, rcParamsOrig
65 from matplotlib.rcsetup import interactive_bk as _interactive_bk
66 from matplotlib.artist import Artist
67 from matplotlib.axes import Axes, Subplot
68 from matplotlib.projections import PolarAxes
69 from matplotlib import mlab  # for detrend_none, window_hanning
70 from matplotlib.scale import get_scale_names
71 
72 from matplotlib import cm
73 from matplotlib.cm import _colormaps as colormaps, get_cmap, register_cmap
74 from matplotlib.colors import _color_sequences as color_sequences
75 
76 import numpy as np
77 
78 # We may not need the following imports here:
79 from matplotlib.colors import Normalize
80 from matplotlib.lines import Line2D
81 from matplotlib.text import Text, Annotation
82 from matplotlib.patches import Polygon, Rectangle, Circle, Arrow
83 from matplotlib.widgets import Button, Slider, Widget
84 
85 from .ticker import (
86     TickHelper, Formatter, FixedFormatter, NullFormatter, FuncFormatter,
87     FormatStrFormatter, ScalarFormatter, LogFormatter, LogFormatterExponent,
88     LogFormatterMathtext, Locator, IndexLocator, FixedLocator, NullLocator,
89     LinearLocator, LogLocator, AutoLocator, MultipleLocator, MaxNLocator)
90 
91 _log = logging.getLogger(__name__)
92 
93 
94 def _copy_docstring_and_deprecators(method, func=None):
95     if func is None:
96         return functools.partial(_copy_docstring_and_deprecators, method)
97     decorators = [_docstring.copy(method)]
98     # Check whether the definition of *method* includes @_api.rename_parameter
99     # or @_api.make_keyword_only decorators; if so, propagate them to the
100     # pyplot wrapper as well.
101     while getattr(method, "__wrapped__", None) is not None:
102         decorator = _api.deprecation.DECORATORS.get(method)
103         if decorator:
104             decorators.append(decorator)
105         method = method.__wrapped__
106     for decorator in decorators[::-1]:
107         func = decorator(func)
108     return func
109 
110 
111 ## Global ##
112 
113 
114 # The state controlled by {,un}install_repl_displayhook().
115 _ReplDisplayHook = Enum("_ReplDisplayHook", ["NONE", "PLAIN", "IPYTHON"])
116 _REPL_DISPLAYHOOK = _ReplDisplayHook.NONE
117 
118 
119 def _draw_all_if_interactive():
120     if matplotlib.is_interactive():
121         draw_all()
122 
123 
124 def install_repl_displayhook():
125     """
126     Connect to the display hook of the current shell.
127 
128     The display hook gets called when the read-evaluate-print-loop (REPL) of
129     the shell has finished the execution of a command. We use this callback
130     to be able to automatically update a figure in interactive mode.
131 
132     This works both with IPython and with vanilla python shells.
133     """
134     global _REPL_DISPLAYHOOK
135 
136     if _REPL_DISPLAYHOOK is _ReplDisplayHook.IPYTHON:
137         return
138 
139     # See if we have IPython hooks around, if so use them.
140     # Use ``sys.modules.get(name)`` rather than ``name in sys.modules`` as
141     # entries can also have been explicitly set to None.
142     mod_ipython = sys.modules.get("IPython")
143     if not mod_ipython:
144         _REPL_DISPLAYHOOK = _ReplDisplayHook.PLAIN
145         return
146     ip = mod_ipython.get_ipython()
147     if not ip:
148         _REPL_DISPLAYHOOK = _ReplDisplayHook.PLAIN
149         return
150 
151     ip.events.register("post_execute", _draw_all_if_interactive)
152     _REPL_DISPLAYHOOK = _ReplDisplayHook.IPYTHON
153 
154     from IPython.core.pylabtools import backend2gui
155     # trigger IPython's eventloop integration, if available
156     ipython_gui_name = backend2gui.get(get_backend())
157     if ipython_gui_name:
158         ip.enable_gui(ipython_gui_name)
159 
160 
161 def uninstall_repl_displayhook():
162     """Disconnect from the display hook of the current shell."""
163     global _REPL_DISPLAYHOOK
164     if _REPL_DISPLAYHOOK is _ReplDisplayHook.IPYTHON:
165         from IPython import get_ipython
166         ip = get_ipython()
167         ip.events.unregister("post_execute", _draw_all_if_interactive)
168     _REPL_DISPLAYHOOK = _ReplDisplayHook.NONE
169 
170 
171 draw_all = _pylab_helpers.Gcf.draw_all
172 
173 
174 @_copy_docstring_and_deprecators(matplotlib.set_loglevel)
175 def set_loglevel(*args, **kwargs):  # Ensure this appears in the pyplot docs.
176     return matplotlib.set_loglevel(*args, **kwargs)
177 
178 
179 @_copy_docstring_and_deprecators(Artist.findobj)
180 def findobj(o=None, match=None, include_self=True):
181     if o is None:
182         o = gcf()
183     return o.findobj(match, include_self=include_self)
184 
185 
186 def _get_required_interactive_framework(backend_mod):
187     if not hasattr(backend_mod.FigureCanvas, "required_interactive_framework"):
188         _api.warn_deprecated(
189             "3.6", name="Support for FigureCanvases without a "
190             "required_interactive_framework attribute")
191         return None
192     # Inline this once the deprecation elapses.
193     return backend_mod.FigureCanvas.required_interactive_framework
194 
195 _backend_mod = None
196 
197 
198 def _get_backend_mod():
199     """
200     Ensure that a backend is selected and return it.
201 
202     This is currently private, but may be made public in the future.
203     """
204     if _backend_mod is None:
205         # Use __getitem__ here to avoid going through the fallback logic (which
206         # will (re)import pyplot and then call switch_backend if we need to
207         # resolve the auto sentinel)
208         switch_backend(dict.__getitem__(rcParams, "backend"))
209         # Just to be safe.  Interactive mode can be turned on without calling
210         # `plt.ion()` so register it again here.  This is safe because multiple
211         # calls to `install_repl_displayhook` are no-ops and the registered
212         # function respects `mpl.is_interactive()` to determine if it should
213         # trigger a draw.
214         install_repl_displayhook()
215     return _backend_mod
216 
217 
218 def switch_backend(newbackend):
219     """
220     Close all open figures and set the Matplotlib backend.
221 
222     The argument is case-insensitive.  Switching to an interactive backend is
223     possible only if no event loop for another interactive backend has started.
224     Switching to and from non-interactive backends is always possible.
225 
226     Parameters
227     ----------
228     newbackend : str
229         The name of the backend to use.
230     """
231     global _backend_mod
232     # make sure the init is pulled up so we can assign to it later
233     import matplotlib.backends
234     close("all")
235 
236     if newbackend is rcsetup._auto_backend_sentinel:
237         current_framework = cbook._get_running_interactive_framework()
238         mapping = {'qt': 'qtagg',
239                    'gtk3': 'gtk3agg',
240                    'gtk4': 'gtk4agg',
241                    'wx': 'wxagg',
242                    'tk': 'tkagg',
243                    'macosx': 'macosx',
244                    'headless': 'agg'}
245 
246         best_guess = mapping.get(current_framework, None)
247         if best_guess is not None:
248             candidates = [best_guess]
249         else:
250             candidates = []
251         candidates += [
252             "macosx", "qtagg", "gtk4agg", "gtk3agg", "tkagg", "wxagg"]
253 
254         # Don't try to fallback on the cairo-based backends as they each have
255         # an additional dependency (pycairo) over the agg-based backend, and
256         # are of worse quality.
257         for candidate in candidates:
258             try:
259                 switch_backend(candidate)
260             except ImportError:
261                 continue
262             else:
263                 rcParamsOrig['backend'] = candidate
264                 return
265         else:
266             # Switching to Agg should always succeed; if it doesn't, let the
267             # exception propagate out.
268             switch_backend("agg")
269             rcParamsOrig["backend"] = "agg"
270             return
271 
272     # Backends are implemented as modules, but "inherit" default method
273     # implementations from backend_bases._Backend.  This is achieved by
274     # creating a "class" that inherits from backend_bases._Backend and whose
275     # body is filled with the module's globals.
276 
277     backend_name = cbook._backend_module_name(newbackend)
278 
279     class backend_mod(matplotlib.backend_bases._Backend):
280         locals().update(vars(importlib.import_module(backend_name)))
281 
282     required_framework = _get_required_interactive_framework(backend_mod)
283     if required_framework is not None:
284         current_framework = cbook._get_running_interactive_framework()
285         if (current_framework and required_framework
286                 and current_framework != required_framework):
287             raise ImportError(
288                 "Cannot load backend {!r} which requires the {!r} interactive "
289                 "framework, as {!r} is currently running".format(
290                     newbackend, required_framework, current_framework))
291 
292     _log.debug("Loaded backend %s version %s.",
293                newbackend, backend_mod.backend_version)
294 
295     rcParams['backend'] = rcParamsDefault['backend'] = newbackend
296     _backend_mod = backend_mod
297     for func_name in ["new_figure_manager", "draw_if_interactive", "show"]:
298         globals()[func_name].__signature__ = inspect.signature(
299             getattr(backend_mod, func_name))
300 
301     # Need to keep a global reference to the backend for compatibility reasons.
302     # See https://github.com/matplotlib/matplotlib/issues/6092
303     matplotlib.backends.backend = newbackend
304 
305 
306 def _warn_if_gui_out_of_main_thread():
307     if (_get_required_interactive_framework(_get_backend_mod())
308             and threading.current_thread() is not threading.main_thread()):
309         _api.warn_external(
310             "Starting a Matplotlib GUI outside of the main thread will likely "
311             "fail.")
312 
313 
314 # This function's signature is rewritten upon backend-load by switch_backend.
315 def new_figure_manager(*args, **kwargs):
316     """Create a new figure manager instance."""
317     _warn_if_gui_out_of_main_thread()
318     return _get_backend_mod().new_figure_manager(*args, **kwargs)
319 
320 
321 # This function's signature is rewritten upon backend-load by switch_backend.
322 def draw_if_interactive(*args, **kwargs):
323     """
324     Redraw the current figure if in interactive mode.
325 
326     .. warning::
327 
328         End users will typically not have to call this function because the
329         the interactive mode takes care of this.
330     """
331     return _get_backend_mod().draw_if_interactive(*args, **kwargs)
332 
333 
334 # This function's signature is rewritten upon backend-load by switch_backend.
335 def show(*args, **kwargs):
336     """
337     Display all open figures.
338 
339     Parameters
340     ----------
341     block : bool, optional
342         Whether to wait for all figures to be closed before returning.
343 
344         If `True` block and run the GUI main loop until all figure windows
345         are closed.
346 
347         If `False` ensure that all figure windows are displayed and return
348         immediately.  In this case, you are responsible for ensuring
349         that the event loop is running to have responsive figures.
350 
351         Defaults to True in non-interactive mode and to False in interactive
352         mode (see `.pyplot.isinteractive`).
353 
354     See Also
355     --------
356     ion : Enable interactive mode, which shows / updates the figure after
357           every plotting command, so that calling ``show()`` is not necessary.
358     ioff : Disable interactive mode.
359     savefig : Save the figure to an image file instead of showing it on screen.
360 
361     Notes
362     -----
363     **Saving figures to file and showing a window at the same time**
364 
365     If you want an image file as well as a user interface window, use
366     `.pyplot.savefig` before `.pyplot.show`. At the end of (a blocking)
367     ``show()`` the figure is closed and thus unregistered from pyplot. Calling
368     `.pyplot.savefig` afterwards would save a new and thus empty figure. This
369     limitation of command order does not apply if the show is non-blocking or
370     if you keep a reference to the figure and use `.Figure.savefig`.
371 
372     **Auto-show in jupyter notebooks**
373 
374     The jupyter backends (activated via ``%matplotlib inline``,
375     ``%matplotlib notebook``, or ``%matplotlib widget``), call ``show()`` at
376     the end of every cell by default. Thus, you usually don't have to call it
377     explicitly there.
378     """
379     _warn_if_gui_out_of_main_thread()
380     return _get_backend_mod().show(*args, **kwargs)
381 
382 
383 def isinteractive():
384     """
385     Return whether plots are updated after every plotting command.
386 
387     The interactive mode is mainly useful if you build plots from the command
388     line and want to see the effect of each command while you are building the
389     figure.
390 
391     In interactive mode:
392 
393     - newly created figures will be shown immediately;
394     - figures will automatically redraw on change;
395     - `.pyplot.show` will not block by default.
396 
397     In non-interactive mode:
398 
399     - newly created figures and changes to figures will not be reflected until
400       explicitly asked to be;
401     - `.pyplot.show` will block by default.
402 
403     See Also
404     --------
405     ion : Enable interactive mode.
406     ioff : Disable interactive mode.
407     show : Show all figures (and maybe block).
408     pause : Show all figures, and block for a time.
409     """
410     return matplotlib.is_interactive()
411 
412 
413 class _IoffContext:
414     """
415     Context manager for `.ioff`.
416 
417     The state is changed in ``__init__()`` instead of ``__enter__()``. The
418     latter is a no-op. This allows using `.ioff` both as a function and
419     as a context.
420     """
421 
422     def __init__(self):
423         self.wasinteractive = isinteractive()
424         matplotlib.interactive(False)
425         uninstall_repl_displayhook()
426 
427     def __enter__(self):
428         pass
429 
430     def __exit__(self, exc_type, exc_value, traceback):
431         if self.wasinteractive:
432             matplotlib.interactive(True)
433             install_repl_displayhook()
434         else:
435             matplotlib.interactive(False)
436             uninstall_repl_displayhook()
437 
438 
439 class _IonContext:
440     """
441     Context manager for `.ion`.
442 
443     The state is changed in ``__init__()`` instead of ``__enter__()``. The
444     latter is a no-op. This allows using `.ion` both as a function and
445     as a context.
446     """
447 
448     def __init__(self):
449         self.wasinteractive = isinteractive()
450         matplotlib.interactive(True)
451         install_repl_displayhook()
452 
453     def __enter__(self):
454         pass
455 
456     def __exit__(self, exc_type, exc_value, traceback):
457         if not self.wasinteractive:
458             matplotlib.interactive(False)
459             uninstall_repl_displayhook()
460         else:
461             matplotlib.interactive(True)
462             install_repl_displayhook()
463 
464 
465 def ioff():
466     """
467     Disable interactive mode.
468 
469     See `.pyplot.isinteractive` for more details.
470 
471     See Also
472     --------
473     ion : Enable interactive mode.
474     isinteractive : Whether interactive mode is enabled.
475     show : Show all figures (and maybe block).
476     pause : Show all figures, and block for a time.
477 
478     Notes
479     -----
480     For a temporary change, this can be used as a context manager::
481 
482         # if interactive mode is on
483         # then figures will be shown on creation
484         plt.ion()
485         # This figure will be shown immediately
486         fig = plt.figure()
487 
488         with plt.ioff():
489             # interactive mode will be off
490             # figures will not automatically be shown
491             fig2 = plt.figure()
492             # ...
493 
494     To enable usage as a context manager, this function returns an
495     ``_IoffContext`` object. The return value is not intended to be stored
496     or accessed by the user.
497     """
498     return _IoffContext()
499 
500 
501 def ion():
502     """
503     Enable interactive mode.
504 
505     See `.pyplot.isinteractive` for more details.
506 
507     See Also
508     --------
509     ioff : Disable interactive mode.
510     isinteractive : Whether interactive mode is enabled.
511     show : Show all figures (and maybe block).
512     pause : Show all figures, and block for a time.
513 
514     Notes
515     -----
516     For a temporary change, this can be used as a context manager::
517 
518         # if interactive mode is off
519         # then figures will not be shown on creation
520         plt.ioff()
521         # This figure will not be shown immediately
522         fig = plt.figure()
523 
524         with plt.ion():
525             # interactive mode will be on
526             # figures will automatically be shown
527             fig2 = plt.figure()
528             # ...
529 
530     To enable usage as a context manager, this function returns an
531     ``_IonContext`` object. The return value is not intended to be stored
532     or accessed by the user.
533     """
534     return _IonContext()
535 
536 
537 def pause(interval):
538     """
539     Run the GUI event loop for *interval* seconds.
540 
541     If there is an active figure, it will be updated and displayed before the
542     pause, and the GUI event loop (if any) will run during the pause.
543 
544     This can be used for crude animation.  For more complex animation use
545     :mod:`matplotlib.animation`.
546 
547     If there is no active figure, sleep for *interval* seconds instead.
548 
549     See Also
550     --------
551     matplotlib.animation : Proper animations
552     show : Show all figures and optional block until all figures are closed.
553     """
554     manager = _pylab_helpers.Gcf.get_active()
555     if manager is not None:
556         canvas = manager.canvas
557         if canvas.figure.stale:
558             canvas.draw_idle()
559         show(block=False)
560         canvas.start_event_loop(interval)
561     else:
562         time.sleep(interval)
563 
564 
565 @_copy_docstring_and_deprecators(matplotlib.rc)
566 def rc(group, **kwargs):
567     matplotlib.rc(group, **kwargs)
568 
569 
570 @_copy_docstring_and_deprecators(matplotlib.rc_context)
571 def rc_context(rc=None, fname=None):
572     return matplotlib.rc_context(rc, fname)
573 
574 
575 @_copy_docstring_and_deprecators(matplotlib.rcdefaults)
576 def rcdefaults():
577     matplotlib.rcdefaults()
578     if matplotlib.is_interactive():
579         draw_all()
580 
581 
582 # getp/get/setp are explicitly reexported so that they show up in pyplot docs.
583 
584 
585 @_copy_docstring_and_deprecators(matplotlib.artist.getp)
586 def getp(obj, *args, **kwargs):
587     return matplotlib.artist.getp(obj, *args, **kwargs)
588 
589 
590 @_copy_docstring_and_deprecators(matplotlib.artist.get)
591 def get(obj, *args, **kwargs):
592     return matplotlib.artist.get(obj, *args, **kwargs)
593 
594 
595 @_copy_docstring_and_deprecators(matplotlib.artist.setp)
596 def setp(obj, *args, **kwargs):
597     return matplotlib.artist.setp(obj, *args, **kwargs)
598 
599 
600 def xkcd(scale=1, length=100, randomness=2):
601     """
602     Turn on `xkcd <https://xkcd.com/>`_ sketch-style drawing mode.  This will
603     only have effect on things drawn after this function is called.
604 
605     For best results, the "Humor Sans" font should be installed: it is
606     not included with Matplotlib.
607 
608     Parameters
609     ----------
610     scale : float, optional
611         The amplitude of the wiggle perpendicular to the source line.
612     length : float, optional
613         The length of the wiggle along the line.
614     randomness : float, optional
615         The scale factor by which the length is shrunken or expanded.
616 
617     Notes
618     -----
619     This function works by a number of rcParams, so it will probably
620     override others you have set before.
621 
622     If you want the effects of this function to be temporary, it can
623     be used as a context manager, for example::
624 
625         with plt.xkcd():
626             # This figure will be in XKCD-style
627             fig1 = plt.figure()
628             # ...
629 
630         # This figure will be in regular style
631         fig2 = plt.figure()
632     """
633     return _xkcd(scale, length, randomness)
634 
635 
636 class _xkcd:
637     # This cannot be implemented in terms of rc_context() because this needs to
638     # work as a non-contextmanager too.
639 
640     def __init__(self, scale, length, randomness):
641         self._orig = rcParams.copy()
642 
643         if rcParams['text.usetex']:
644             raise RuntimeError(
645                 "xkcd mode is not compatible with text.usetex = True")
646 
647         from matplotlib import patheffects
648         rcParams.update({
649             'font.family': ['xkcd', 'xkcd Script', 'Humor Sans', 'Comic Neue',
650                             'Comic Sans MS'],
651             'font.size': 14.0,
652             'path.sketch': (scale, length, randomness),
653             'path.effects': [
654                 patheffects.withStroke(linewidth=4, foreground="w")],
655             'axes.linewidth': 1.5,
656             'lines.linewidth': 2.0,
657             'figure.facecolor': 'white',
658             'grid.linewidth': 0.0,
659             'axes.grid': False,
660             'axes.unicode_minus': False,
661             'axes.edgecolor': 'black',
662             'xtick.major.size': 8,
663             'xtick.major.width': 3,
664             'ytick.major.size': 8,
665             'ytick.major.width': 3,
666         })
667 
668     def __enter__(self):
669         return self
670 
671     def __exit__(self, *args):
672         dict.update(rcParams, self._orig)
673 
674 
675 ## Figures ##
676 
677 @_api.make_keyword_only("3.6", "facecolor")
678 def figure(num=None,  # autoincrement if None, else integer from 1-N
679            figsize=None,  # defaults to rc figure.figsize
680            dpi=None,  # defaults to rc figure.dpi
681            facecolor=None,  # defaults to rc figure.facecolor
682            edgecolor=None,  # defaults to rc figure.edgecolor
683            frameon=True,
684            FigureClass=Figure,
685            clear=False,
686            **kwargs
687            ):
688     """
689     Create a new figure, or activate an existing figure.
690 
691     Parameters
692     ----------
693     num : int or str or `.Figure`, optional
694         A unique identifier for the figure.
695 
696         If a figure with that identifier already exists, this figure is made
697         active and returned. An integer refers to the ``Figure.number``
698         attribute, a string refers to the figure label.
699 
700         If there is no figure with the identifier or *num* is not given, a new
701         figure is created, made active and returned.  If *num* is an int, it
702         will be used for the ``Figure.number`` attribute, otherwise, an
703         auto-generated integer value is used (starting at 1 and incremented
704         for each new figure). If *num* is a string, the figure label and the
705         window title is set to this value.
706 
707     figsize : (float, float), default: :rc:`figure.figsize`
708         Width, height in inches.
709 
710     dpi : float, default: :rc:`figure.dpi`
711         The resolution of the figure in dots-per-inch.
712 
713     facecolor : color, default: :rc:`figure.facecolor`
714         The background color.
715 
716     edgecolor : color, default: :rc:`figure.edgecolor`
717         The border color.
718 
719     frameon : bool, default: True
720         If False, suppress drawing the figure frame.
721 
722     FigureClass : subclass of `~matplotlib.figure.Figure`
723         If set, an instance of this subclass will be created, rather than a
724         plain `.Figure`.
725 
726     clear : bool, default: False
727         If True and the figure already exists, then it is cleared.
728 
729     layout : {'constrained', 'tight', `.LayoutEngine`, None}, default: None
730         The layout mechanism for positioning of plot elements to avoid
731         overlapping Axes decorations (labels, ticks, etc). Note that layout
732         managers can measurably slow down figure display. Defaults to *None*
733         (but see the documentation of the `.Figure` constructor regarding the
734         interaction with rcParams).
735 
736     **kwargs
737         Additional keyword arguments are passed to the `.Figure` constructor.
738 
739     Returns
740     -------
741     `~matplotlib.figure.Figure`
742 
743     Notes
744     -----
745     Newly created figures will be passed to the
746     `~.backend_template.new_figure_manager` function provided by the current
747     backend, which will install a canvas and a manager on the figure.
748 
749     If you are creating many figures, make sure you explicitly call
750     `.pyplot.close` on the figures you are not using, because this will
751     enable pyplot to properly clean up the memory.
752 
753     `~matplotlib.rcParams` defines the default values, which can be modified
754     in the matplotlibrc file.
755     """
756     if isinstance(num, Figure):
757         if num.canvas.manager is None:
758             raise ValueError("The passed figure is not managed by pyplot")
759         _pylab_helpers.Gcf.set_active(num.canvas.manager)
760         return num
761 
762     allnums = get_fignums()
763     next_num = max(allnums) + 1 if allnums else 1
764     fig_label = ''
765     if num is None:
766         num = next_num
767     elif isinstance(num, str):
768         fig_label = num
769         all_labels = get_figlabels()
770         if fig_label not in all_labels:
771             if fig_label == 'all':
772                 _api.warn_external("close('all') closes all existing figures.")
773             num = next_num
774         else:
775             inum = all_labels.index(fig_label)
776             num = allnums[inum]
777     else:
778         num = int(num)  # crude validation of num argument
779 
780     manager = _pylab_helpers.Gcf.get_fig_manager(num)
781     if manager is None:
782         max_open_warning = rcParams['figure.max_open_warning']
783         if len(allnums) == max_open_warning >= 1:
784             _api.warn_external(
785                 f"More than {max_open_warning} figures have been opened. "
786                 f"Figures created through the pyplot interface "
787                 f"(`matplotlib.pyplot.figure`) are retained until explicitly "
788                 f"closed and may consume too much memory. (To control this "
789                 f"warning, see the rcParam `figure.max_open_warning`).",
790                 RuntimeWarning)
791 
792         manager = new_figure_manager(
793             num, figsize=figsize, dpi=dpi,
794             facecolor=facecolor, edgecolor=edgecolor, frameon=frameon,
795             FigureClass=FigureClass, **kwargs)
796         fig = manager.canvas.figure
797         if fig_label:
798             fig.set_label(fig_label)
799 
800         _pylab_helpers.Gcf._set_new_active_manager(manager)
801 
802         # make sure backends (inline) that we don't ship that expect this
803         # to be called in plotting commands to make the figure call show
804         # still work.  There is probably a better way to do this in the
805         # FigureManager base class.
806         draw_if_interactive()
807 
808         if _REPL_DISPLAYHOOK is _ReplDisplayHook.PLAIN:
809             fig.stale_callback = _auto_draw_if_interactive
810 
811     if clear:
812         manager.canvas.figure.clear()
813 
814     return manager.canvas.figure
815 
816 
817 def _auto_draw_if_interactive(fig, val):
818     """
819     An internal helper function for making sure that auto-redrawing
820     works as intended in the plain python repl.
821 
822     Parameters
823     ----------
824     fig : Figure
825         A figure object which is assumed to be associated with a canvas
826     """
827     if (val and matplotlib.is_interactive()
828             and not fig.canvas.is_saving()
829             and not fig.canvas._is_idle_drawing):
830         # Some artists can mark themselves as stale in the middle of drawing
831         # (e.g. axes position & tick labels being computed at draw time), but
832         # this shouldn't trigger a redraw because the current redraw will
833         # already take them into account.
834         with fig.canvas._idle_draw_cntx():
835             fig.canvas.draw_idle()
836 
837 
838 def gcf():
839     """
840     Get the current figure.
841 
842     If there is currently no figure on the pyplot figure stack, a new one is
843     created using `~.pyplot.figure()`.  (To test whether there is currently a
844     figure on the pyplot figure stack, check whether `~.pyplot.get_fignums()`
845     is empty.)
846     """
847     manager = _pylab_helpers.Gcf.get_active()
848     if manager is not None:
849         return manager.canvas.figure
850     else:
851         return figure()
852 
853 
854 def fignum_exists(num):
855     """Return whether the figure with the given id exists."""
856     return _pylab_helpers.Gcf.has_fignum(num) or num in get_figlabels()
857 
858 
859 def get_fignums():
860     """Return a list of existing figure numbers."""
861     return sorted(_pylab_helpers.Gcf.figs)
862 
863 
864 def get_figlabels():
865     """Return a list of existing figure labels."""
866     managers = _pylab_helpers.Gcf.get_all_fig_managers()
867     managers.sort(key=lambda m: m.num)
868     return [m.canvas.figure.get_label() for m in managers]
869 
870 
871 def get_current_fig_manager():
872     """
873     Return the figure manager of the current figure.
874 
875     The figure manager is a container for the actual backend-depended window
876     that displays the figure on screen.
877 
878     If no current figure exists, a new one is created, and its figure
879     manager is returned.
880 
881     Returns
882     -------
883     `.FigureManagerBase` or backend-dependent subclass thereof
884     """
885     return gcf().canvas.manager
886 
887 
888 @_copy_docstring_and_deprecators(FigureCanvasBase.mpl_connect)
889 def connect(s, func):
890     return gcf().canvas.mpl_connect(s, func)
891 
892 
893 @_copy_docstring_and_deprecators(FigureCanvasBase.mpl_disconnect)
894 def disconnect(cid):
895     return gcf().canvas.mpl_disconnect(cid)
896 
897 
898 def close(fig=None):
899     """
900     Close a figure window.
901 
902     Parameters
903     ----------
904     fig : None or int or str or `.Figure`
905         The figure to close. There are a number of ways to specify this:
906 
907         - *None*: the current figure
908         - `.Figure`: the given `.Figure` instance
909         - ``int``: a figure number
910         - ``str``: a figure name
911         - 'all': all figures
912 
913     """
914     if fig is None:
915         manager = _pylab_helpers.Gcf.get_active()
916         if manager is None:
917             return
918         else:
919             _pylab_helpers.Gcf.destroy(manager)
920     elif fig == 'all':
921         _pylab_helpers.Gcf.destroy_all()
922     elif isinstance(fig, int):
923         _pylab_helpers.Gcf.destroy(fig)
924     elif hasattr(fig, 'int'):
925         # if we are dealing with a type UUID, we
926         # can use its integer representation
927         _pylab_helpers.Gcf.destroy(fig.int)
928     elif isinstance(fig, str):
929         all_labels = get_figlabels()
930         if fig in all_labels:
931             num = get_fignums()[all_labels.index(fig)]
932             _pylab_helpers.Gcf.destroy(num)
933     elif isinstance(fig, Figure):
934         _pylab_helpers.Gcf.destroy_fig(fig)
935     else:
936         raise TypeError("close() argument must be a Figure, an int, a string, "
937                         "or None, not %s" % type(fig))
938 
939 
940 def clf():
941     """Clear the current figure."""
942     gcf().clear()
943 
944 
945 def draw():
946     """
947     Redraw the current figure.
948 
949     This is used to update a figure that has been altered, but not
950     automatically re-drawn.  If interactive mode is on (via `.ion()`), this
951     should be only rarely needed, but there may be ways to modify the state of
952     a figure without marking it as "stale".  Please report these cases as bugs.
953 
954     This is equivalent to calling ``fig.canvas.draw_idle()``, where ``fig`` is
955     the current figure.
956     """
957     gcf().canvas.draw_idle()
958 
959 
960 @_copy_docstring_and_deprecators(Figure.savefig)
961 def savefig(*args, **kwargs):
962     fig = gcf()
963     res = fig.savefig(*args, **kwargs)
964     fig.canvas.draw_idle()  # Need this if 'transparent=True', to reset colors.
965     return res
966 
967 
968 ## Putting things in figures ##
969 
970 
971 def figlegend(*args, **kwargs):
972     return gcf().legend(*args, **kwargs)
973 if Figure.legend.__doc__:
974     figlegend.__doc__ = Figure.legend.__doc__.replace("legend(", "figlegend(")
975 
976 
977 ## Axes ##
978 
979 @_docstring.dedent_interpd
980 def axes(arg=None, **kwargs):
981     """
982     Add an Axes to the current figure and make it the current Axes.
983 
984     Call signatures::
985 
986         plt.axes()
987         plt.axes(rect, projection=None, polar=False, **kwargs)
988         plt.axes(ax)
989 
990     Parameters
991     ----------
992     arg : None or 4-tuple
993         The exact behavior of this function depends on the type:
994 
995         - *None*: A new full window Axes is added using
996           ``subplot(**kwargs)``.
997         - 4-tuple of floats *rect* = ``[left, bottom, width, height]``.
998           A new Axes is added with dimensions *rect* in normalized
999           (0, 1) units using `~.Figure.add_axes` on the current figure.
1000 
1001     projection : {None, 'aitoff', 'hammer', 'lambert', 'mollweide', \
1002 'polar', 'rectilinear', str}, optional
1003         The projection type of the `~.axes.Axes`. *str* is the name of
1004         a custom projection, see `~matplotlib.projections`. The default
1005         None results in a 'rectilinear' projection.
1006 
1007     polar : bool, default: False
1008         If True, equivalent to projection='polar'.
1009 
1010     sharex, sharey : `~.axes.Axes`, optional
1011         Share the x or y `~matplotlib.axis` with sharex and/or sharey.
1012         The axis will have the same limits, ticks, and scale as the axis
1013         of the shared Axes.
1014 
1015     label : str
1016         A label for the returned Axes.
1017 
1018     Returns
1019     -------
1020     `~.axes.Axes`, or a subclass of `~.axes.Axes`
1021         The returned axes class depends on the projection used. It is
1022         `~.axes.Axes` if rectilinear projection is used and
1023         `.projections.polar.PolarAxes` if polar projection is used.
1024 
1025     Other Parameters
1026     ----------------
1027     **kwargs
1028         This method also takes the keyword arguments for
1029         the returned Axes class. The keyword arguments for the
1030         rectilinear Axes class `~.axes.Axes` can be found in
1031         the following table but there might also be other keyword
1032         arguments if another projection is used, see the actual Axes
1033         class.
1034 
1035         %(Axes:kwdoc)s
1036 
1037     Notes
1038     -----
1039     If the figure already has an Axes with key (*args*,
1040     *kwargs*) then it will simply make that axes current and
1041     return it.  This behavior is deprecated. Meanwhile, if you do
1042     not want this behavior (i.e., you want to force the creation of a
1043     new axes), you must use a unique set of args and kwargs.  The Axes
1044     *label* attribute has been exposed for this purpose: if you want
1045     two Axes that are otherwise identical to be added to the figure,
1046     make sure you give them unique labels.
1047 
1048     See Also
1049     --------
1050     .Figure.add_axes
1051     .pyplot.subplot
1052     .Figure.add_subplot
1053     .Figure.subplots
1054     .pyplot.subplots
1055 
1056     Examples
1057     --------
1058     ::
1059 
1060         # Creating a new full window Axes
1061         plt.axes()
1062 
1063         # Creating a new Axes with specified dimensions and a grey background
1064         plt.axes((left, bottom, width, height), facecolor='grey')
1065     """
1066     fig = gcf()
1067     pos = kwargs.pop('position', None)
1068     if arg is None:
1069         if pos is None:
1070             return fig.add_subplot(**kwargs)
1071         else:
1072             return fig.add_axes(pos, **kwargs)
1073     else:
1074         return fig.add_axes(arg, **kwargs)
1075 
1076 
1077 def delaxes(ax=None):
1078     """
1079     Remove an `~.axes.Axes` (defaulting to the current axes) from its figure.
1080     """
1081     if ax is None:
1082         ax = gca()
1083     ax.remove()
1084 
1085 
1086 def sca(ax):
1087     """
1088     Set the current Axes to *ax* and the current Figure to the parent of *ax*.
1089     """
1090     figure(ax.figure)
1091     ax.figure.sca(ax)
1092 
1093 
1094 def cla():
1095     """Clear the current axes."""
1096     # Not generated via boilerplate.py to allow a different docstring.
1097     return gca().cla()
1098 
1099 
1100 ## More ways of creating axes ##
1101 
1102 @_docstring.dedent_interpd
1103 def subplot(*args, **kwargs):
1104     """
1105     Add an Axes to the current figure or retrieve an existing Axes.
1106 
1107     This is a wrapper of `.Figure.add_subplot` which provides additional
1108     behavior when working with the implicit API (see the notes section).
1109 
1110     Call signatures::
1111 
1112        subplot(nrows, ncols, index, **kwargs)
1113        subplot(pos, **kwargs)
1114        subplot(**kwargs)
1115        subplot(ax)
1116 
1117     Parameters
1118     ----------
1119     *args : int, (int, int, *index*), or `.SubplotSpec`, default: (1, 1, 1)
1120         The position of the subplot described by one of
1121 
1122         - Three integers (*nrows*, *ncols*, *index*). The subplot will take the
1123           *index* position on a grid with *nrows* rows and *ncols* columns.
1124           *index* starts at 1 in the upper left corner and increases to the
1125           right. *index* can also be a two-tuple specifying the (*first*,
1126           *last*) indices (1-based, and including *last*) of the subplot, e.g.,
1127           ``fig.add_subplot(3, 1, (1, 2))`` makes a subplot that spans the
1128           upper 2/3 of the figure.
1129         - A 3-digit integer. The digits are interpreted as if given separately
1130           as three single-digit integers, i.e. ``fig.add_subplot(235)`` is the
1131           same as ``fig.add_subplot(2, 3, 5)``. Note that this can only be used
1132           if there are no more than 9 subplots.
1133         - A `.SubplotSpec`.
1134 
1135     projection : {None, 'aitoff', 'hammer', 'lambert', 'mollweide', \
1136 'polar', 'rectilinear', str}, optional
1137         The projection type of the subplot (`~.axes.Axes`). *str* is the name
1138         of a custom projection, see `~matplotlib.projections`. The default
1139         None results in a 'rectilinear' projection.
1140 
1141     polar : bool, default: False
1142         If True, equivalent to projection='polar'.
1143 
1144     sharex, sharey : `~.axes.Axes`, optional
1145         Share the x or y `~matplotlib.axis` with sharex and/or sharey. The
1146         axis will have the same limits, ticks, and scale as the axis of the
1147         shared axes.
1148 
1149     label : str
1150         A label for the returned axes.
1151 
1152     Returns
1153     -------
1154     `.axes.SubplotBase`, or another subclass of `~.axes.Axes`
1155 
1156         The axes of the subplot. The returned axes base class depends on
1157         the projection used. It is `~.axes.Axes` if rectilinear projection
1158         is used and `.projections.polar.PolarAxes` if polar projection
1159         is used. The returned axes is then a subplot subclass of the
1160         base class.
1161 
1162     Other Parameters
1163     ----------------
1164     **kwargs
1165         This method also takes the keyword arguments for the returned axes
1166         base class; except for the *figure* argument. The keyword arguments
1167         for the rectilinear base class `~.axes.Axes` can be found in
1168         the following table but there might also be other keyword
1169         arguments if another projection is used.
1170 
1171         %(Axes:kwdoc)s
1172 
1173     Notes
1174     -----
1175     Creating a new Axes will delete any pre-existing Axes that
1176     overlaps with it beyond sharing a boundary::
1177 
1178         import matplotlib.pyplot as plt
1179         # plot a line, implicitly creating a subplot(111)
1180         plt.plot([1, 2, 3])
1181         # now create a subplot which represents the top plot of a grid
1182         # with 2 rows and 1 column. Since this subplot will overlap the
1183         # first, the plot (and its axes) previously created, will be removed
1184         plt.subplot(211)
1185 
1186     If you do not want this behavior, use the `.Figure.add_subplot` method
1187     or the `.pyplot.axes` function instead.
1188 
1189     If no *kwargs* are passed and there exists an Axes in the location
1190     specified by *args* then that Axes will be returned rather than a new
1191     Axes being created.
1192 
1193     If *kwargs* are passed and there exists an Axes in the location
1194     specified by *args*, the projection type is the same, and the
1195     *kwargs* match with the existing Axes, then the existing Axes is
1196     returned.  Otherwise a new Axes is created with the specified
1197     parameters.  We save a reference to the *kwargs* which we use
1198     for this comparison.  If any of the values in *kwargs* are
1199     mutable we will not detect the case where they are mutated.
1200     In these cases we suggest using `.Figure.add_subplot` and the
1201     explicit Axes API rather than the implicit pyplot API.
1202 
1203     See Also
1204     --------
1205     .Figure.add_subplot
1206     .pyplot.subplots
1207     .pyplot.axes
1208     .Figure.subplots
1209 
1210     Examples
1211     --------
1212     ::
1213 
1214         plt.subplot(221)
1215 
1216         # equivalent but more general
1217         ax1 = plt.subplot(2, 2, 1)
1218 
1219         # add a subplot with no frame
1220         ax2 = plt.subplot(222, frameon=False)
1221 
1222         # add a polar subplot
1223         plt.subplot(223, projection='polar')
1224 
1225         # add a red subplot that shares the x-axis with ax1
1226         plt.subplot(224, sharex=ax1, facecolor='red')
1227 
1228         # delete ax2 from the figure
1229         plt.delaxes(ax2)
1230 
1231         # add ax2 to the figure again
1232         plt.subplot(ax2)
1233 
1234         # make the first axes "current" again
1235         plt.subplot(221)
1236 
1237     """
1238     # Here we will only normalize `polar=True` vs `projection='polar'` and let
1239     # downstream code deal with the rest.
1240     unset = object()
1241     projection = kwargs.get('projection', unset)
1242     polar = kwargs.pop('polar', unset)
1243     if polar is not unset and polar:
1244         # if we got mixed messages from the user, raise
1245         if projection is not unset and projection != 'polar':
1246             raise ValueError(
1247                 f"polar={polar}, yet projection={projection!r}. "
1248                 "Only one of these arguments should be supplied."
1249             )
1250         kwargs['projection'] = projection = 'polar'
1251 
1252     # if subplot called without arguments, create subplot(1, 1, 1)
1253     if len(args) == 0:
1254         args = (1, 1, 1)
1255 
1256     # This check was added because it is very easy to type subplot(1, 2, False)
1257     # when subplots(1, 2, False) was intended (sharex=False, that is). In most
1258     # cases, no error will ever occur, but mysterious behavior can result
1259     # because what was intended to be the sharex argument is instead treated as
1260     # a subplot index for subplot()
1261     if len(args) >= 3 and isinstance(args[2], bool):
1262         _api.warn_external("The subplot index argument to subplot() appears "
1263                            "to be a boolean. Did you intend to use "
1264                            "subplots()?")
1265     # Check for nrows and ncols, which are not valid subplot args:
1266     if 'nrows' in kwargs or 'ncols' in kwargs:
1267         raise TypeError("subplot() got an unexpected keyword argument 'ncols' "
1268                         "and/or 'nrows'.  Did you intend to call subplots()?")
1269 
1270     fig = gcf()
1271 
1272     # First, search for an existing subplot with a matching spec.
1273     key = SubplotSpec._from_subplot_args(fig, args)
1274 
1275     for ax in fig.axes:
1276         # if we found an Axes at the position sort out if we can re-use it
1277         if hasattr(ax, 'get_subplotspec') and ax.get_subplotspec() == key:
1278             # if the user passed no kwargs, re-use
1279             if kwargs == {}:
1280                 break
1281             # if the axes class and kwargs are identical, reuse
1282             elif ax._projection_init == fig._process_projection_requirements(
1283                 *args, **kwargs
1284             ):
1285                 break
1286     else:
1287         # we have exhausted the known Axes and none match, make a new one!
1288         ax = fig.add_subplot(*args, **kwargs)
1289 
1290     fig.sca(ax)
1291 
1292     axes_to_delete = [other for other in fig.axes
1293                       if other != ax and ax.bbox.fully_overlaps(other.bbox)]
1294     if axes_to_delete:
1295         _api.warn_deprecated(
1296             "3.6", message="Auto-removal of overlapping axes is deprecated "
1297             "since %(since)s and will be removed %(removal)s; explicitly call "
1298             "ax.remove() as needed.")
1299     for ax_to_del in axes_to_delete:
1300         delaxes(ax_to_del)
1301 
1302     return ax
1303 
1304 
1305 def subplots(nrows=1, ncols=1, *, sharex=False, sharey=False, squeeze=True,
1306              subplot_kw=None, gridspec_kw=None, **fig_kw):
1307     """
1308     Create a figure and a set of subplots.
1309 
1310     This utility wrapper makes it convenient to create common layouts of
1311     subplots, including the enclosing figure object, in a single call.
1312 
1313     Parameters
1314     ----------
1315     nrows, ncols : int, default: 1
1316         Number of rows/columns of the subplot grid.
1317 
1318     sharex, sharey : bool or {'none', 'all', 'row', 'col'}, default: False
1319         Controls sharing of properties among x (*sharex*) or y (*sharey*)
1320         axes:
1321 
1322         - True or 'all': x- or y-axis will be shared among all subplots.
1323         - False or 'none': each subplot x- or y-axis will be independent.
1324         - 'row': each subplot row will share an x- or y-axis.
1325         - 'col': each subplot column will share an x- or y-axis.
1326 
1327         When subplots have a shared x-axis along a column, only the x tick
1328         labels of the bottom subplot are created. Similarly, when subplots
1329         have a shared y-axis along a row, only the y tick labels of the first
1330         column subplot are created. To later turn other subplots' ticklabels
1331         on, use `~matplotlib.axes.Axes.tick_params`.
1332 
1333         When subplots have a shared axis that has units, calling
1334         `~matplotlib.axis.Axis.set_units` will update each axis with the
1335         new units.
1336 
1337     squeeze : bool, default: True
1338         - If True, extra dimensions are squeezed out from the returned
1339           array of `~matplotlib.axes.Axes`:
1340 
1341           - if only one subplot is constructed (nrows=ncols=1), the
1342             resulting single Axes object is returned as a scalar.
1343           - for Nx1 or 1xM subplots, the returned object is a 1D numpy
1344             object array of Axes objects.
1345           - for NxM, subplots with N>1 and M>1 are returned as a 2D array.
1346 
1347         - If False, no squeezing at all is done: the returned Axes object is
1348           always a 2D array containing Axes instances, even if it ends up
1349           being 1x1.
1350 
1351     subplot_kw : dict, optional
1352         Dict with keywords passed to the
1353         `~matplotlib.figure.Figure.add_subplot` call used to create each
1354         subplot.
1355 
1356     gridspec_kw : dict, optional
1357         Dict with keywords passed to the `~matplotlib.gridspec.GridSpec`
1358         constructor used to create the grid the subplots are placed on.
1359 
1360     **fig_kw
1361         All additional keyword arguments are passed to the
1362         `.pyplot.figure` call.
1363 
1364     Returns
1365     -------
1366     fig : `.Figure`
1367 
1368     ax : `~.axes.Axes` or array of Axes
1369         *ax* can be either a single `~.axes.Axes` object, or an array of Axes
1370         objects if more than one subplot was created.  The dimensions of the
1371         resulting array can be controlled with the squeeze keyword, see above.
1372 
1373         Typical idioms for handling the return value are::
1374 
1375             # using the variable ax for single a Axes
1376             fig, ax = plt.subplots()
1377 
1378             # using the variable axs for multiple Axes
1379             fig, axs = plt.subplots(2, 2)
1380 
1381             # using tuple unpacking for multiple Axes
1382             fig, (ax1, ax2) = plt.subplots(1, 2)
1383             fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2)
1384 
1385         The names ``ax`` and pluralized ``axs`` are preferred over ``axes``
1386         because for the latter it's not clear if it refers to a single
1387         `~.axes.Axes` instance or a collection of these.
1388 
1389     See Also
1390     --------
1391     .pyplot.figure
1392     .pyplot.subplot
1393     .pyplot.axes
1394     .Figure.subplots
1395     .Figure.add_subplot
1396 
1397     Examples
1398     --------
1399     ::
1400 
1401         # First create some toy data:
1402         x = np.linspace(0, 2*np.pi, 400)
1403         y = np.sin(x**2)
1404 
1405         # Create just a figure and only one subplot
1406         fig, ax = plt.subplots()
1407         ax.plot(x, y)
1408         ax.set_title('Simple plot')
1409 
1410         # Create two subplots and unpack the output array immediately
1411         f, (ax1, ax2) = plt.subplots(1, 2, sharey=True)
1412         ax1.plot(x, y)
1413         ax1.set_title('Sharing Y axis')
1414         ax2.scatter(x, y)
1415 
1416         # Create four polar axes and access them through the returned array
1417         fig, axs = plt.subplots(2, 2, subplot_kw=dict(projection="polar"))
1418         axs[0, 0].plot(x, y)
1419         axs[1, 1].scatter(x, y)
1420 
1421         # Share a X axis with each column of subplots
1422         plt.subplots(2, 2, sharex='col')
1423 
1424         # Share a Y axis with each row of subplots
1425         plt.subplots(2, 2, sharey='row')
1426 
1427         # Share both X and Y axes with all subplots
1428         plt.subplots(2, 2, sharex='all', sharey='all')
1429 
1430         # Note that this is the same as
1431         plt.subplots(2, 2, sharex=True, sharey=True)
1432 
1433         # Create figure number 10 with a single subplot
1434         # and clears it if it already exists.
1435         fig, ax = plt.subplots(num=10, clear=True)
1436 
1437     """
1438     fig = figure(**fig_kw)
1439     axs = fig.subplots(nrows=nrows, ncols=ncols, sharex=sharex, sharey=sharey,
1440                        squeeze=squeeze, subplot_kw=subplot_kw,
1441                        gridspec_kw=gridspec_kw)
1442     return fig, axs
1443 
1444 
1445 def subplot_mosaic(mosaic, *, sharex=False, sharey=False,
1446                    subplot_kw=None, gridspec_kw=None, empty_sentinel='.',
1447                    **fig_kw):
1448     """
1449     Build a layout of Axes based on ASCII art or nested lists.
1450 
1451     This is a helper function to build complex GridSpec layouts visually.
1452 
1453     .. note::
1454 
1455        This API is provisional and may be revised in the future based on
1456        early user feedback.
1457 
1458     See :doc:`/tutorials/provisional/mosaic`
1459     for an example and full API documentation
1460 
1461     Parameters
1462     ----------
1463     mosaic : list of list of {hashable or nested} or str
1464 
1465         A visual layout of how you want your Axes to be arranged
1466         labeled as strings.  For example ::
1467 
1468            x = [['A panel', 'A panel', 'edge'],
1469                 ['C panel', '.',       'edge']]
1470 
1471         produces 4 axes:
1472 
1473         - 'A panel' which is 1 row high and spans the first two columns
1474         - 'edge' which is 2 rows high and is on the right edge
1475         - 'C panel' which in 1 row and 1 column wide in the bottom left
1476         - a blank space 1 row and 1 column wide in the bottom center
1477 
1478         Any of the entries in the layout can be a list of lists
1479         of the same form to create nested layouts.
1480 
1481         If input is a str, then it must be of the form ::
1482 
1483           '''
1484           AAE
1485           C.E
1486           '''
1487 
1488         where each character is a column and each line is a row.
1489         This only allows only single character Axes labels and does
1490         not allow nesting but is very terse.
1491 
1492     sharex, sharey : bool, default: False
1493         If True, the x-axis (*sharex*) or y-axis (*sharey*) will be shared
1494         among all subplots.  In that case, tick label visibility and axis units
1495         behave as for `subplots`.  If False, each subplot's x- or y-axis will
1496         be independent.
1497 
1498     subplot_kw : dict, optional
1499         Dictionary with keywords passed to the `.Figure.add_subplot` call
1500         used to create each subplot.
1501 
1502     gridspec_kw : dict, optional
1503         Dictionary with keywords passed to the `.GridSpec` constructor used
1504         to create the grid the subplots are placed on.
1505 
1506     empty_sentinel : object, optional
1507         Entry in the layout to mean "leave this space empty".  Defaults
1508         to ``'.'``. Note, if *layout* is a string, it is processed via
1509         `inspect.cleandoc` to remove leading white space, which may
1510         interfere with using white-space as the empty sentinel.
1511 
1512     **fig_kw
1513         All additional keyword arguments are passed to the
1514         `.pyplot.figure` call.
1515 
1516     Returns
1517     -------
1518     fig : `.Figure`
1519        The new figure
1520 
1521     dict[label, Axes]
1522        A dictionary mapping the labels to the Axes objects.  The order of
1523        the axes is left-to-right and top-to-bottom of their position in the
1524        total layout.
1525 
1526     """
1527     fig = figure(**fig_kw)
1528     ax_dict = fig.subplot_mosaic(
1529         mosaic, sharex=sharex, sharey=sharey,
1530         subplot_kw=subplot_kw, gridspec_kw=gridspec_kw,
1531         empty_sentinel=empty_sentinel
1532     )
1533     return fig, ax_dict
1534 
1535 
1536 def subplot2grid(shape, loc, rowspan=1, colspan=1, fig=None, **kwargs):
1537     """
1538     Create a subplot at a specific location inside a regular grid.
1539 
1540     Parameters
1541     ----------
1542     shape : (int, int)
1543         Number of rows and of columns of the grid in which to place axis.
1544     loc : (int, int)
1545         Row number and column number of the axis location within the grid.
1546     rowspan : int, default: 1
1547         Number of rows for the axis to span downwards.
1548     colspan : int, default: 1
1549         Number of columns for the axis to span to the right.
1550     fig : `.Figure`, optional
1551         Figure to place the subplot in. Defaults to the current figure.
1552     **kwargs
1553         Additional keyword arguments are handed to `~.Figure.add_subplot`.
1554 
1555     Returns
1556     -------
1557     `.axes.SubplotBase`, or another subclass of `~.axes.Axes`
1558 
1559         The axes of the subplot.  The returned axes base class depends on the
1560         projection used.  It is `~.axes.Axes` if rectilinear projection is used
1561         and `.projections.polar.PolarAxes` if polar projection is used.  The
1562         returned axes is then a subplot subclass of the base class.
1563 
1564     Notes
1565     -----
1566     The following call ::
1567 
1568         ax = subplot2grid((nrows, ncols), (row, col), rowspan, colspan)
1569 
1570     is identical to ::
1571 
1572         fig = gcf()
1573         gs = fig.add_gridspec(nrows, ncols)
1574         ax = fig.add_subplot(gs[row:row+rowspan, col:col+colspan])
1575     """
1576 
1577     if fig is None:
1578         fig = gcf()
1579 
1580     rows, cols = shape
1581     gs = GridSpec._check_gridspec_exists(fig, rows, cols)
1582 
1583     subplotspec = gs.new_subplotspec(loc, rowspan=rowspan, colspan=colspan)
1584     ax = fig.add_subplot(subplotspec, **kwargs)
1585 
1586     axes_to_delete = [other for other in fig.axes
1587                       if other != ax and ax.bbox.fully_overlaps(other.bbox)]
1588     if axes_to_delete:
1589         _api.warn_deprecated(
1590             "3.6", message="Auto-removal of overlapping axes is deprecated "
1591             "since %(since)s and will be removed %(removal)s; explicitly call "
1592             "ax.remove() as needed.")
1593     for ax_to_del in axes_to_delete:
1594         delaxes(ax_to_del)
1595 
1596     return ax
1597 
1598 
1599 def twinx(ax=None):
1600     """
1601     Make and return a second axes that shares the *x*-axis.  The new axes will
1602     overlay *ax* (or the current axes if *ax* is *None*), and its ticks will be
1603     on the right.
1604 
1605     Examples
1606     --------
1607     :doc:`/gallery/subplots_axes_and_figures/two_scales`
1608     """
1609     if ax is None:
1610         ax = gca()
1611     ax1 = ax.twinx()
1612     return ax1
1613 
1614 
1615 def twiny(ax=None):
1616     """
1617     Make and return a second axes that shares the *y*-axis.  The new axes will
1618     overlay *ax* (or the current axes if *ax* is *None*), and its ticks will be
1619     on the top.
1620 
1621     Examples
1622     --------
1623     :doc:`/gallery/subplots_axes_and_figures/two_scales`
1624     """
1625     if ax is None:
1626         ax = gca()
1627     ax1 = ax.twiny()
1628     return ax1
1629 
1630 
1631 def subplot_tool(targetfig=None):
1632     """
1633     Launch a subplot tool window for a figure.
1634 
1635     Returns
1636     -------
1637     `matplotlib.widgets.SubplotTool`
1638     """
1639     if targetfig is None:
1640         targetfig = gcf()
1641     tb = targetfig.canvas.manager.toolbar
1642     if hasattr(tb, "configure_subplots"):  # toolbar2
1643         return tb.configure_subplots()
1644     elif hasattr(tb, "trigger_tool"):  # toolmanager
1645         return tb.trigger_tool("subplots")
1646     else:
1647         raise ValueError("subplot_tool can only be launched for figures with "
1648                          "an associated toolbar")
1649 
1650 
1651 def box(on=None):
1652     """
1653     Turn the axes box on or off on the current axes.
1654 
1655     Parameters
1656     ----------
1657     on : bool or None
1658         The new `~matplotlib.axes.Axes` box state. If ``None``, toggle
1659         the state.
1660 
1661     See Also
1662     --------
1663     :meth:`matplotlib.axes.Axes.set_frame_on`
1664     :meth:`matplotlib.axes.Axes.get_frame_on`
1665     """
1666     ax = gca()
1667     if on is None:
1668         on = not ax.get_frame_on()
1669     ax.set_frame_on(on)
1670 
1671 ## Axis ##
1672 
1673 
1674 def xlim(*args, **kwargs):
1675     """
1676     Get or set the x limits of the current axes.
1677 
1678     Call signatures::
1679 
1680         left, right = xlim()  # return the current xlim
1681         xlim((left, right))   # set the xlim to left, right
1682         xlim(left, right)     # set the xlim to left, right
1683 
1684     If you do not specify args, you can pass *left* or *right* as kwargs,
1685     i.e.::
1686 
1687         xlim(right=3)  # adjust the right leaving left unchanged
1688         xlim(left=1)  # adjust the left leaving right unchanged
1689 
1690     Setting limits turns autoscaling off for the x-axis.
1691 
1692     Returns
1693     -------
1694     left, right
1695         A tuple of the new x-axis limits.
1696 
1697     Notes
1698     -----
1699     Calling this function with no arguments (e.g. ``xlim()``) is the pyplot
1700     equivalent of calling `~.Axes.get_xlim` on the current axes.
1701     Calling this function with arguments is the pyplot equivalent of calling
1702     `~.Axes.set_xlim` on the current axes. All arguments are passed though.
1703     """
1704     ax = gca()
1705     if not args and not kwargs:
1706         return ax.get_xlim()
1707     ret = ax.set_xlim(*args, **kwargs)
1708     return ret
1709 
1710 
1711 def ylim(*args, **kwargs):
1712     """
1713     Get or set the y-limits of the current axes.
1714 
1715     Call signatures::
1716 
1717         bottom, top = ylim()  # return the current ylim
1718         ylim((bottom, top))   # set the ylim to bottom, top
1719         ylim(bottom, top)     # set the ylim to bottom, top
1720 
1721     If you do not specify args, you can alternatively pass *bottom* or
1722     *top* as kwargs, i.e.::
1723 
1724         ylim(top=3)  # adjust the top leaving bottom unchanged
1725         ylim(bottom=1)  # adjust the bottom leaving top unchanged
1726 
1727     Setting limits turns autoscaling off for the y-axis.
1728 
1729     Returns
1730     -------
1731     bottom, top
1732         A tuple of the new y-axis limits.
1733 
1734     Notes
1735     -----
1736     Calling this function with no arguments (e.g. ``ylim()``) is the pyplot
1737     equivalent of calling `~.Axes.get_ylim` on the current axes.
1738     Calling this function with arguments is the pyplot equivalent of calling
1739     `~.Axes.set_ylim` on the current axes. All arguments are passed though.
1740     """
1741     ax = gca()
1742     if not args and not kwargs:
1743         return ax.get_ylim()
1744     ret = ax.set_ylim(*args, **kwargs)
1745     return ret
1746 
1747 
1748 def xticks(ticks=None, labels=None, **kwargs):
1749     """
1750     Get or set the current tick locations and labels of the x-axis.
1751 
1752     Pass no arguments to return the current values without modifying them.
1753 
1754     Parameters
1755     ----------
1756     ticks : array-like, optional
1757         The list of xtick locations.  Passing an empty list removes all xticks.
1758     labels : array-like, optional
1759         The labels to place at the given *ticks* locations.  This argument can
1760         only be passed if *ticks* is passed as well.
1761     **kwargs
1762         `.Text` properties can be used to control the appearance of the labels.
1763 
1764     Returns
1765     -------
1766     locs
1767         The list of xtick locations.
1768     labels
1769         The list of xlabel `.Text` objects.
1770 
1771     Notes
1772     -----
1773     Calling this function with no arguments (e.g. ``xticks()``) is the pyplot
1774     equivalent of calling `~.Axes.get_xticks` and `~.Axes.get_xticklabels` on
1775     the current axes.
1776     Calling this function with arguments is the pyplot equivalent of calling
1777     `~.Axes.set_xticks` and `~.Axes.set_xticklabels` on the current axes.
1778 
1779     Examples
1780     --------
1781     >>> locs, labels = xticks()  # Get the current locations and labels.
1782     >>> xticks(np.arange(0, 1, step=0.2))  # Set label locations.
1783     >>> xticks(np.arange(3), ['Tom', 'Dick', 'Sue'])  # Set text labels.
1784     >>> xticks([0, 1, 2], ['January', 'February', 'March'],
1785     ...        rotation=20)  # Set text labels and properties.
1786     >>> xticks([])  # Disable xticks.
1787     """
1788     ax = gca()
1789 
1790     if ticks is None:
1791         locs = ax.get_xticks()
1792         if labels is not None:
1793             raise TypeError("xticks(): Parameter 'labels' can't be set "
1794                             "without setting 'ticks'")
1795     else:
1796         locs = ax.set_xticks(ticks)
1797 
1798     if labels is None:
1799         labels = ax.get_xticklabels()
1800         for l in labels:
1801             l._internal_update(kwargs)
1802     else:
1803         labels = ax.set_xticklabels(labels, **kwargs)
1804 
1805     return locs, labels
1806 
1807 
1808 def yticks(ticks=None, labels=None, **kwargs):
1809     """
1810     Get or set the current tick locations and labels of the y-axis.
1811 
1812     Pass no arguments to return the current values without modifying them.
1813 
1814     Parameters
1815     ----------
1816     ticks : array-like, optional
1817         The list of ytick locations.  Passing an empty list removes all yticks.
1818     labels : array-like, optional
1819         The labels to place at the given *ticks* locations.  This argument can
1820         only be passed if *ticks* is passed as well.
1821     **kwargs
1822         `.Text` properties can be used to control the appearance of the labels.
1823 
1824     Returns
1825     -------
1826     locs
1827         The list of ytick locations.
1828     labels
1829         The list of ylabel `.Text` objects.
1830 
1831     Notes
1832     -----
1833     Calling this function with no arguments (e.g. ``yticks()``) is the pyplot
1834     equivalent of calling `~.Axes.get_yticks` and `~.Axes.get_yticklabels` on
1835     the current axes.
1836     Calling this function with arguments is the pyplot equivalent of calling
1837     `~.Axes.set_yticks` and `~.Axes.set_yticklabels` on the current axes.
1838 
1839     Examples
1840     --------
1841     >>> locs, labels = yticks()  # Get the current locations and labels.
1842     >>> yticks(np.arange(0, 1, step=0.2))  # Set label locations.
1843     >>> yticks(np.arange(3), ['Tom', 'Dick', 'Sue'])  # Set text labels.
1844     >>> yticks([0, 1, 2], ['January', 'February', 'March'],
1845     ...        rotation=45)  # Set text labels and properties.
1846     >>> yticks([])  # Disable yticks.
1847     """
1848     ax = gca()
1849 
1850     if ticks is None:
1851         locs = ax.get_yticks()
1852         if labels is not None:
1853             raise TypeError("yticks(): Parameter 'labels' can't be set "
1854                             "without setting 'ticks'")
1855     else:
1856         locs = ax.set_yticks(ticks)
1857 
1858     if labels is None:
1859         labels = ax.get_yticklabels()
1860         for l in labels:
1861             l._internal_update(kwargs)
1862     else:
1863         labels = ax.set_yticklabels(labels, **kwargs)
1864 
1865     return locs, labels
1866 
1867 
1868 def rgrids(radii=None, labels=None, angle=None, fmt=None, **kwargs):
1869     """
1870     Get or set the radial gridlines on the current polar plot.
1871 
1872     Call signatures::
1873 
1874      lines, labels = rgrids()
1875      lines, labels = rgrids(radii, labels=None, angle=22.5, fmt=None, **kwargs)
1876 
1877     When called with no arguments, `.rgrids` simply returns the tuple
1878     (*lines*, *labels*). When called with arguments, the labels will
1879     appear at the specified radial distances and angle.
1880 
1881     Parameters
1882     ----------
1883     radii : tuple with floats
1884         The radii for the radial gridlines
1885 
1886     labels : tuple with strings or None
1887         The labels to use at each radial gridline. The
1888         `matplotlib.ticker.ScalarFormatter` will be used if None.
1889 
1890     angle : float
1891         The angular position of the radius labels in degrees.
1892 
1893     fmt : str or None
1894         Format string used in `matplotlib.ticker.FormatStrFormatter`.
1895         For example '%f'.
1896 
1897     Returns
1898     -------
1899     lines : list of `.lines.Line2D`
1900         The radial gridlines.
1901 
1902     labels : list of `.text.Text`
1903         The tick labels.
1904 
1905     Other Parameters
1906     ----------------
1907     **kwargs
1908         *kwargs* are optional `.Text` properties for the labels.
1909 
1910     See Also
1911     --------
1912     .pyplot.thetagrids
1913     .projections.polar.PolarAxes.set_rgrids
1914     .Axis.get_gridlines
1915     .Axis.get_ticklabels
1916 
1917     Examples
1918     --------
1919     ::
1920 
1921       # set the locations of the radial gridlines
1922       lines, labels = rgrids( (0.25, 0.5, 1.0) )
1923 
1924       # set the locations and labels of the radial gridlines
1925       lines, labels = rgrids( (0.25, 0.5, 1.0), ('Tom', 'Dick', 'Harry' ))
1926     """
1927     ax = gca()
1928     if not isinstance(ax, PolarAxes):
1929         raise RuntimeError('rgrids only defined for polar axes')
1930     if all(p is None for p in [radii, labels, angle, fmt]) and not kwargs:
1931         lines = ax.yaxis.get_gridlines()
1932         labels = ax.yaxis.get_ticklabels()
1933     else:
1934         lines, labels = ax.set_rgrids(
1935             radii, labels=labels, angle=angle, fmt=fmt, **kwargs)
1936     return lines, labels
1937 
1938 
1939 def thetagrids(angles=None, labels=None, fmt=None, **kwargs):
1940     """
1941     Get or set the theta gridlines on the current polar plot.
1942 
1943     Call signatures::
1944 
1945      lines, labels = thetagrids()
1946      lines, labels = thetagrids(angles, labels=None, fmt=None, **kwargs)
1947 
1948     When called with no arguments, `.thetagrids` simply returns the tuple
1949     (*lines*, *labels*). When called with arguments, the labels will
1950     appear at the specified angles.
1951 
1952     Parameters
1953     ----------
1954     angles : tuple with floats, degrees
1955         The angles of the theta gridlines.
1956 
1957     labels : tuple with strings or None
1958         The labels to use at each radial gridline. The
1959         `.projections.polar.ThetaFormatter` will be used if None.
1960 
1961     fmt : str or None
1962         Format string used in `matplotlib.ticker.FormatStrFormatter`.
1963         For example '%f'. Note that the angle in radians will be used.
1964 
1965     Returns
1966     -------
1967     lines : list of `.lines.Line2D`
1968         The theta gridlines.
1969 
1970     labels : list of `.text.Text`
1971         The tick labels.
1972 
1973     Other Parameters
1974     ----------------
1975     **kwargs
1976         *kwargs* are optional `.Text` properties for the labels.
1977 
1978     See Also
1979     --------
1980     .pyplot.rgrids
1981     .projections.polar.PolarAxes.set_thetagrids
1982     .Axis.get_gridlines
1983     .Axis.get_ticklabels
1984 
1985     Examples
1986     --------
1987     ::
1988 
1989       # set the locations of the angular gridlines
1990       lines, labels = thetagrids(range(45, 360, 90))
1991 
1992       # set the locations and labels of the angular gridlines
1993       lines, labels = thetagrids(range(45, 360, 90), ('NE', 'NW', 'SW', 'SE'))
1994     """
1995     ax = gca()
1996     if not isinstance(ax, PolarAxes):
1997         raise RuntimeError('thetagrids only defined for polar axes')
1998     if all(param is None for param in [angles, labels, fmt]) and not kwargs:
1999         lines = ax.xaxis.get_ticklines()
2000         labels = ax.xaxis.get_ticklabels()
2001     else:
2002         lines, labels = ax.set_thetagrids(angles,
2003                                           labels=labels, fmt=fmt, **kwargs)
2004     return lines, labels
2005 
2006 
2007 ## Plotting Info ##
2008 
2009 
2010 def plotting():
2011     pass
2012 
2013 
2014 def get_plot_commands():
2015     """
2016     Get a sorted list of all of the plotting commands.
2017     """
2018     # This works by searching for all functions in this module and removing
2019     # a few hard-coded exclusions, as well as all of the colormap-setting
2020     # functions, and anything marked as private with a preceding underscore.
2021     exclude = {'colormaps', 'colors', 'connect', 'disconnect',
2022                'get_plot_commands', 'get_current_fig_manager', 'ginput',
2023                'plotting', 'waitforbuttonpress'}
2024     exclude |= set(colormaps)
2025     this_module = inspect.getmodule(get_plot_commands)
2026     return sorted(
2027         name for name, obj in globals().items()
2028         if not name.startswith('_') and name not in exclude
2029            and inspect.isfunction(obj)
2030            and inspect.getmodule(obj) is this_module)
2031 
2032 
2033 def _setup_pyplot_info_docstrings():
2034     """
2035     Setup the docstring of `plotting` and of the colormap-setting functions.
2036 
2037     These must be done after the entire module is imported, so it is called
2038     from the end of this module, which is generated by boilerplate.py.
2039     """
2040     commands = get_plot_commands()
2041 
2042     first_sentence = re.compile(r"(?:\s*).+?\.(?:\s+|$)", flags=re.DOTALL)
2043 
2044     # Collect the first sentence of the docstring for all of the
2045     # plotting commands.
2046     rows = []
2047     max_name = len("Function")
2048     max_summary = len("Description")
2049     for name in commands:
2050         doc = globals()[name].__doc__
2051         summary = ''
2052         if doc is not None:
2053             match = first_sentence.match(doc)
2054             if match is not None:
2055                 summary = inspect.cleandoc(match.group(0)).replace('\n', ' ')
2056         name = '`%s`' % name
2057         rows.append([name, summary])
2058         max_name = max(max_name, len(name))
2059         max_summary = max(max_summary, len(summary))
2060 
2061     separator = '=' * max_name + ' ' + '=' * max_summary
2062     lines = [
2063         separator,
2064         '{:{}} {:{}}'.format('Function', max_name, 'Description', max_summary),
2065         separator,
2066     ] + [
2067         '{:{}} {:{}}'.format(name, max_name, summary, max_summary)
2068         for name, summary in rows
2069     ] + [
2070         separator,
2071     ]
2072     plotting.__doc__ = '\n'.join(lines)
2073 
2074     for cm_name in colormaps:
2075         if cm_name in globals():
2076             globals()[cm_name].__doc__ = f"""
2077     Set the colormap to {cm_name!r}.
2078 
2079     This changes the default colormap as well as the colormap of the current
2080     image if there is one. See ``help(colormaps)`` for more information.
2081     """
2082 
2083 
2084 ## Plotting part 1: manually generated functions and wrappers ##
2085 
2086 
2087 @_copy_docstring_and_deprecators(Figure.colorbar)
2088 def colorbar(mappable=None, cax=None, ax=None, **kwargs):
2089     if mappable is None:
2090         mappable = gci()
2091         if mappable is None:
2092             raise RuntimeError('No mappable was found to use for colorbar '
2093                                'creation. First define a mappable such as '
2094                                'an image (with imshow) or a contour set ('
2095                                'with contourf).')
2096     ret = gcf().colorbar(mappable, cax=cax, ax=ax, **kwargs)
2097     return ret
2098 
2099 
2100 def clim(vmin=None, vmax=None):
2101     """
2102     Set the color limits of the current image.
2103 
2104     If either *vmin* or *vmax* is None, the image min/max respectively
2105     will be used for color scaling.
2106 
2107     If you want to set the clim of multiple images, use
2108     `~.ScalarMappable.set_clim` on every image, for example::
2109 
2110       for im in gca().get_images():
2111           im.set_clim(0, 0.5)
2112 
2113     """
2114     im = gci()
2115     if im is None:
2116         raise RuntimeError('You must first define an image, e.g., with imshow')
2117 
2118     im.set_clim(vmin, vmax)
2119 
2120 
2121 def set_cmap(cmap):
2122     """
2123     Set the default colormap, and applies it to the current image if any.
2124 
2125     Parameters
2126     ----------
2127     cmap : `~matplotlib.colors.Colormap` or str
2128         A colormap instance or the name of a registered colormap.
2129 
2130     See Also
2131     --------
2132     colormaps
2133     matplotlib.cm.register_cmap
2134     matplotlib.cm.get_cmap
2135     """
2136     cmap = cm.get_cmap(cmap)
2137 
2138     rc('image', cmap=cmap.name)
2139     im = gci()
2140 
2141     if im is not None:
2142         im.set_cmap(cmap)
2143 
2144 
2145 @_copy_docstring_and_deprecators(matplotlib.image.imread)
2146 def imread(fname, format=None):
2147     return matplotlib.image.imread(fname, format)
2148 
2149 
2150 @_copy_docstring_and_deprecators(matplotlib.image.imsave)
2151 def imsave(fname, arr, **kwargs):
2152     return matplotlib.image.imsave(fname, arr, **kwargs)
2153 
2154 
2155 def matshow(A, fignum=None, **kwargs):
2156     """
2157     Display an array as a matrix in a new figure window.
2158 
2159     The origin is set at the upper left hand corner and rows (first
2160     dimension of the array) are displayed horizontally.  The aspect
2161     ratio of the figure window is that of the array, unless this would
2162     make an excessively short or narrow figure.
2163 
2164     Tick labels for the xaxis are placed on top.
2165 
2166     Parameters
2167     ----------
2168     A : 2D array-like
2169         The matrix to be displayed.
2170 
2171     fignum : None or int or False
2172         If *None*, create a new figure window with automatic numbering.
2173 
2174         If a nonzero integer, draw into the figure with the given number
2175         (create it if it does not exist).
2176 
2177         If 0, use the current axes (or create one if it does not exist).
2178 
2179         .. note::
2180 
2181            Because of how `.Axes.matshow` tries to set the figure aspect
2182            ratio to be the one of the array, strange things may happen if you
2183            reuse an existing figure.
2184 
2185     Returns
2186     -------
2187     `~matplotlib.image.AxesImage`
2188 
2189     Other Parameters
2190     ----------------
2191     **kwargs : `~matplotlib.axes.Axes.imshow` arguments
2192 
2193     """
2194     A = np.asanyarray(A)
2195     if fignum == 0:
2196         ax = gca()
2197     else:
2198         # Extract actual aspect ratio of array and make appropriately sized
2199         # figure.
2200         fig = figure(fignum, figsize=figaspect(A))
2201         ax = fig.add_axes([0.15, 0.09, 0.775, 0.775])
2202     im = ax.matshow(A, **kwargs)
2203     sci(im)
2204     return im
2205 
2206 
2207 def polar(*args, **kwargs):
2208     """
2209     Make a polar plot.
2210 
2211     call signature::
2212 
2213       polar(theta, r, **kwargs)
2214 
2215     Multiple *theta*, *r* arguments are supported, with format strings, as in
2216     `plot`.
2217     """
2218     # If an axis already exists, check if it has a polar projection
2219     if gcf().get_axes():
2220         ax = gca()
2221         if not isinstance(ax, PolarAxes):
2222             _api.warn_external('Trying to create polar plot on an Axes '
2223                                'that does not have a polar projection.')
2224     else:
2225         ax = axes(projection="polar")
2226     return ax.plot(*args, **kwargs)
2227 
2228 
2229 # If rcParams['backend_fallback'] is true, and an interactive backend is
2230 # requested, ignore rcParams['backend'] and force selection of a backend that
2231 # is compatible with the current running interactive framework.
2232 if (rcParams["backend_fallback"]
2233         and dict.__getitem__(rcParams, "backend") in (
2234             set(_interactive_bk) - {'WebAgg', 'nbAgg'})
2235         and cbook._get_running_interactive_framework()):
2236     dict.__setitem__(rcParams, "backend", rcsetup._auto_backend_sentinel)
2237 
2238 
2239 ################# REMAINING CONTENT GENERATED BY boilerplate.py ##############
2240 
2241 
2242 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2243 @_copy_docstring_and_deprecators(Figure.figimage)
2244 def figimage(
2245         X, xo=0, yo=0, alpha=None, norm=None, cmap=None, vmin=None,
2246         vmax=None, origin=None, resize=False, **kwargs):
2247     return gcf().figimage(
2248         X, xo=xo, yo=yo, alpha=alpha, norm=norm, cmap=cmap, vmin=vmin,
2249         vmax=vmax, origin=origin, resize=resize, **kwargs)
2250 
2251 
2252 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2253 @_copy_docstring_and_deprecators(Figure.text)
2254 def figtext(x, y, s, fontdict=None, **kwargs):
2255     return gcf().text(x, y, s, fontdict=fontdict, **kwargs)
2256 
2257 
2258 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2259 @_copy_docstring_and_deprecators(Figure.gca)
2260 def gca(**kwargs):
2261     return gcf().gca(**kwargs)
2262 
2263 
2264 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2265 @_copy_docstring_and_deprecators(Figure._gci)
2266 def gci():
2267     return gcf()._gci()
2268 
2269 
2270 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2271 @_copy_docstring_and_deprecators(Figure.ginput)
2272 def ginput(
2273         n=1, timeout=30, show_clicks=True,
2274         mouse_add=MouseButton.LEFT, mouse_pop=MouseButton.RIGHT,
2275         mouse_stop=MouseButton.MIDDLE):
2276     return gcf().ginput(
2277         n=n, timeout=timeout, show_clicks=show_clicks,
2278         mouse_add=mouse_add, mouse_pop=mouse_pop,
2279         mouse_stop=mouse_stop)
2280 
2281 
2282 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2283 @_copy_docstring_and_deprecators(Figure.subplots_adjust)
2284 def subplots_adjust(
2285         left=None, bottom=None, right=None, top=None, wspace=None,
2286         hspace=None):
2287     return gcf().subplots_adjust(
2288         left=left, bottom=bottom, right=right, top=top, wspace=wspace,
2289         hspace=hspace)
2290 
2291 
2292 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2293 @_copy_docstring_and_deprecators(Figure.suptitle)
2294 def suptitle(t, **kwargs):
2295     return gcf().suptitle(t, **kwargs)
2296 
2297 
2298 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2299 @_copy_docstring_and_deprecators(Figure.tight_layout)
2300 def tight_layout(*, pad=1.08, h_pad=None, w_pad=None, rect=None):
2301     return gcf().tight_layout(pad=pad, h_pad=h_pad, w_pad=w_pad, rect=rect)
2302 
2303 
2304 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2305 @_copy_docstring_and_deprecators(Figure.waitforbuttonpress)
2306 def waitforbuttonpress(timeout=-1):
2307     return gcf().waitforbuttonpress(timeout=timeout)
2308 
2309 
2310 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2311 @_copy_docstring_and_deprecators(Axes.acorr)
2312 def acorr(x, *, data=None, **kwargs):
2313     return gca().acorr(
2314         x, **({"data": data} if data is not None else {}), **kwargs)
2315 
2316 
2317 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2318 @_copy_docstring_and_deprecators(Axes.angle_spectrum)
2319 def angle_spectrum(
2320         x, Fs=None, Fc=None, window=None, pad_to=None, sides=None, *,
2321         data=None, **kwargs):
2322     return gca().angle_spectrum(
2323         x, Fs=Fs, Fc=Fc, window=window, pad_to=pad_to, sides=sides,
2324         **({"data": data} if data is not None else {}), **kwargs)
2325 
2326 
2327 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2328 @_copy_docstring_and_deprecators(Axes.annotate)
2329 def annotate(
2330         text, xy, xytext=None, xycoords='data', textcoords=None,
2331         arrowprops=None, annotation_clip=None, **kwargs):
2332     return gca().annotate(
2333         text, xy, xytext=xytext, xycoords=xycoords,
2334         textcoords=textcoords, arrowprops=arrowprops,
2335         annotation_clip=annotation_clip, **kwargs)
2336 
2337 
2338 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2339 @_copy_docstring_and_deprecators(Axes.arrow)
2340 def arrow(x, y, dx, dy, **kwargs):
2341     return gca().arrow(x, y, dx, dy, **kwargs)
2342 
2343 
2344 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2345 @_copy_docstring_and_deprecators(Axes.autoscale)
2346 def autoscale(enable=True, axis='both', tight=None):
2347     return gca().autoscale(enable=enable, axis=axis, tight=tight)
2348 
2349 
2350 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2351 @_copy_docstring_and_deprecators(Axes.axhline)
2352 def axhline(y=0, xmin=0, xmax=1, **kwargs):
2353     return gca().axhline(y=y, xmin=xmin, xmax=xmax, **kwargs)
2354 
2355 
2356 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2357 @_copy_docstring_and_deprecators(Axes.axhspan)
2358 def axhspan(ymin, ymax, xmin=0, xmax=1, **kwargs):
2359     return gca().axhspan(ymin, ymax, xmin=xmin, xmax=xmax, **kwargs)
2360 
2361 
2362 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2363 @_copy_docstring_and_deprecators(Axes.axis)
2364 def axis(*args, emit=True, **kwargs):
2365     return gca().axis(*args, emit=emit, **kwargs)
2366 
2367 
2368 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2369 @_copy_docstring_and_deprecators(Axes.axline)
2370 def axline(xy1, xy2=None, *, slope=None, **kwargs):
2371     return gca().axline(xy1, xy2=xy2, slope=slope, **kwargs)
2372 
2373 
2374 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2375 @_copy_docstring_and_deprecators(Axes.axvline)
2376 def axvline(x=0, ymin=0, ymax=1, **kwargs):
2377     return gca().axvline(x=x, ymin=ymin, ymax=ymax, **kwargs)
2378 
2379 
2380 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2381 @_copy_docstring_and_deprecators(Axes.axvspan)
2382 def axvspan(xmin, xmax, ymin=0, ymax=1, **kwargs):
2383     return gca().axvspan(xmin, xmax, ymin=ymin, ymax=ymax, **kwargs)
2384 
2385 
2386 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2387 @_copy_docstring_and_deprecators(Axes.bar)
2388 def bar(
2389         x, height, width=0.8, bottom=None, *, align='center',
2390         data=None, **kwargs):
2391     return gca().bar(
2392         x, height, width=width, bottom=bottom, align=align,
2393         **({"data": data} if data is not None else {}), **kwargs)
2394 
2395 
2396 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2397 @_copy_docstring_and_deprecators(Axes.barbs)
2398 def barbs(*args, data=None, **kwargs):
2399     return gca().barbs(
2400         *args, **({"data": data} if data is not None else {}),
2401         **kwargs)
2402 
2403 
2404 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2405 @_copy_docstring_and_deprecators(Axes.barh)
2406 def barh(y, width, height=0.8, left=None, *, align='center', **kwargs):
2407     return gca().barh(
2408         y, width, height=height, left=left, align=align, **kwargs)
2409 
2410 
2411 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2412 @_copy_docstring_and_deprecators(Axes.bar_label)
2413 def bar_label(
2414         container, labels=None, *, fmt='%g', label_type='edge',
2415         padding=0, **kwargs):
2416     return gca().bar_label(
2417         container, labels=labels, fmt=fmt, label_type=label_type,
2418         padding=padding, **kwargs)
2419 
2420 
2421 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2422 @_copy_docstring_and_deprecators(Axes.boxplot)
2423 def boxplot(
2424         x, notch=None, sym=None, vert=None, whis=None,
2425         positions=None, widths=None, patch_artist=None,
2426         bootstrap=None, usermedians=None, conf_intervals=None,
2427         meanline=None, showmeans=None, showcaps=None, showbox=None,
2428         showfliers=None, boxprops=None, labels=None, flierprops=None,
2429         medianprops=None, meanprops=None, capprops=None,
2430         whiskerprops=None, manage_ticks=True, autorange=False,
2431         zorder=None, capwidths=None, *, data=None):
2432     return gca().boxplot(
2433         x, notch=notch, sym=sym, vert=vert, whis=whis,
2434         positions=positions, widths=widths, patch_artist=patch_artist,
2435         bootstrap=bootstrap, usermedians=usermedians,
2436         conf_intervals=conf_intervals, meanline=meanline,
2437         showmeans=showmeans, showcaps=showcaps, showbox=showbox,
2438         showfliers=showfliers, boxprops=boxprops, labels=labels,
2439         flierprops=flierprops, medianprops=medianprops,
2440         meanprops=meanprops, capprops=capprops,
2441         whiskerprops=whiskerprops, manage_ticks=manage_ticks,
2442         autorange=autorange, zorder=zorder, capwidths=capwidths,
2443         **({"data": data} if data is not None else {}))
2444 
2445 
2446 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2447 @_copy_docstring_and_deprecators(Axes.broken_barh)
2448 def broken_barh(xranges, yrange, *, data=None, **kwargs):
2449     return gca().broken_barh(
2450         xranges, yrange,
2451         **({"data": data} if data is not None else {}), **kwargs)
2452 
2453 
2454 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2455 @_copy_docstring_and_deprecators(Axes.clabel)
2456 def clabel(CS, levels=None, **kwargs):
2457     return gca().clabel(CS, levels=levels, **kwargs)
2458 
2459 
2460 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2461 @_copy_docstring_and_deprecators(Axes.cohere)
2462 def cohere(
2463         x, y, NFFT=256, Fs=2, Fc=0, detrend=mlab.detrend_none,
2464         window=mlab.window_hanning, noverlap=0, pad_to=None,
2465         sides='default', scale_by_freq=None, *, data=None, **kwargs):
2466     return gca().cohere(
2467         x, y, NFFT=NFFT, Fs=Fs, Fc=Fc, detrend=detrend, window=window,
2468         noverlap=noverlap, pad_to=pad_to, sides=sides,
2469         scale_by_freq=scale_by_freq,
2470         **({"data": data} if data is not None else {}), **kwargs)
2471 
2472 
2473 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2474 @_copy_docstring_and_deprecators(Axes.contour)
2475 def contour(*args, data=None, **kwargs):
2476     __ret = gca().contour(
2477         *args, **({"data": data} if data is not None else {}),
2478         **kwargs)
2479     if __ret._A is not None: sci(__ret)  # noqa
2480     return __ret
2481 
2482 
2483 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2484 @_copy_docstring_and_deprecators(Axes.contourf)
2485 def contourf(*args, data=None, **kwargs):
2486     __ret = gca().contourf(
2487         *args, **({"data": data} if data is not None else {}),
2488         **kwargs)
2489     if __ret._A is not None: sci(__ret)  # noqa
2490     return __ret
2491 
2492 
2493 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2494 @_copy_docstring_and_deprecators(Axes.csd)
2495 def csd(
2496         x, y, NFFT=None, Fs=None, Fc=None, detrend=None, window=None,
2497         noverlap=None, pad_to=None, sides=None, scale_by_freq=None,
2498         return_line=None, *, data=None, **kwargs):
2499     return gca().csd(
2500         x, y, NFFT=NFFT, Fs=Fs, Fc=Fc, detrend=detrend, window=window,
2501         noverlap=noverlap, pad_to=pad_to, sides=sides,
2502         scale_by_freq=scale_by_freq, return_line=return_line,
2503         **({"data": data} if data is not None else {}), **kwargs)
2504 
2505 
2506 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2507 @_copy_docstring_and_deprecators(Axes.errorbar)
2508 def errorbar(
2509         x, y, yerr=None, xerr=None, fmt='', ecolor=None,
2510         elinewidth=None, capsize=None, barsabove=False, lolims=False,
2511         uplims=False, xlolims=False, xuplims=False, errorevery=1,
2512         capthick=None, *, data=None, **kwargs):
2513     return gca().errorbar(
2514         x, y, yerr=yerr, xerr=xerr, fmt=fmt, ecolor=ecolor,
2515         elinewidth=elinewidth, capsize=capsize, barsabove=barsabove,
2516         lolims=lolims, uplims=uplims, xlolims=xlolims,
2517         xuplims=xuplims, errorevery=errorevery, capthick=capthick,
2518         **({"data": data} if data is not None else {}), **kwargs)
2519 
2520 
2521 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2522 @_copy_docstring_and_deprecators(Axes.eventplot)
2523 def eventplot(
2524         positions, orientation='horizontal', lineoffsets=1,
2525         linelengths=1, linewidths=None, colors=None,
2526         linestyles='solid', *, data=None, **kwargs):
2527     return gca().eventplot(
2528         positions, orientation=orientation, lineoffsets=lineoffsets,
2529         linelengths=linelengths, linewidths=linewidths, colors=colors,
2530         linestyles=linestyles,
2531         **({"data": data} if data is not None else {}), **kwargs)
2532 
2533 
2534 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2535 @_copy_docstring_and_deprecators(Axes.fill)
2536 def fill(*args, data=None, **kwargs):
2537     return gca().fill(
2538         *args, **({"data": data} if data is not None else {}),
2539         **kwargs)
2540 
2541 
2542 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2543 @_copy_docstring_and_deprecators(Axes.fill_between)
2544 def fill_between(
2545         x, y1, y2=0, where=None, interpolate=False, step=None, *,
2546         data=None, **kwargs):
2547     return gca().fill_between(
2548         x, y1, y2=y2, where=where, interpolate=interpolate, step=step,
2549         **({"data": data} if data is not None else {}), **kwargs)
2550 
2551 
2552 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2553 @_copy_docstring_and_deprecators(Axes.fill_betweenx)
2554 def fill_betweenx(
2555         y, x1, x2=0, where=None, step=None, interpolate=False, *,
2556         data=None, **kwargs):
2557     return gca().fill_betweenx(
2558         y, x1, x2=x2, where=where, step=step, interpolate=interpolate,
2559         **({"data": data} if data is not None else {}), **kwargs)
2560 
2561 
2562 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2563 @_copy_docstring_and_deprecators(Axes.grid)
2564 def grid(visible=None, which='major', axis='both', **kwargs):
2565     return gca().grid(visible=visible, which=which, axis=axis, **kwargs)
2566 
2567 
2568 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2569 @_copy_docstring_and_deprecators(Axes.hexbin)
2570 def hexbin(
2571         x, y, C=None, gridsize=100, bins=None, xscale='linear',
2572         yscale='linear', extent=None, cmap=None, norm=None, vmin=None,
2573         vmax=None, alpha=None, linewidths=None, edgecolors='face',
2574         reduce_C_function=np.mean, mincnt=None, marginals=False, *,
2575         data=None, **kwargs):
2576     __ret = gca().hexbin(
2577         x, y, C=C, gridsize=gridsize, bins=bins, xscale=xscale,
2578         yscale=yscale, extent=extent, cmap=cmap, norm=norm, vmin=vmin,
2579         vmax=vmax, alpha=alpha, linewidths=linewidths,
2580         edgecolors=edgecolors, reduce_C_function=reduce_C_function,
2581         mincnt=mincnt, marginals=marginals,
2582         **({"data": data} if data is not None else {}), **kwargs)
2583     sci(__ret)
2584     return __ret
2585 
2586 
2587 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2588 @_copy_docstring_and_deprecators(Axes.hist)
2589 def hist(
2590         x, bins=None, range=None, density=False, weights=None,
2591         cumulative=False, bottom=None, histtype='bar', align='mid',
2592         orientation='vertical', rwidth=None, log=False, color=None,
2593         label=None, stacked=False, *, data=None, **kwargs):
2594     return gca().hist(
2595         x, bins=bins, range=range, density=density, weights=weights,
2596         cumulative=cumulative, bottom=bottom, histtype=histtype,
2597         align=align, orientation=orientation, rwidth=rwidth, log=log,
2598         color=color, label=label, stacked=stacked,
2599         **({"data": data} if data is not None else {}), **kwargs)
2600 
2601 
2602 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2603 @_copy_docstring_and_deprecators(Axes.stairs)
2604 def stairs(
2605         values, edges=None, *, orientation='vertical', baseline=0,
2606         fill=False, data=None, **kwargs):
2607     return gca().stairs(
2608         values, edges=edges, orientation=orientation,
2609         baseline=baseline, fill=fill,
2610         **({"data": data} if data is not None else {}), **kwargs)
2611 
2612 
2613 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2614 @_copy_docstring_and_deprecators(Axes.hist2d)
2615 def hist2d(
2616         x, y, bins=10, range=None, density=False, weights=None,
2617         cmin=None, cmax=None, *, data=None, **kwargs):
2618     __ret = gca().hist2d(
2619         x, y, bins=bins, range=range, density=density,
2620         weights=weights, cmin=cmin, cmax=cmax,
2621         **({"data": data} if data is not None else {}), **kwargs)
2622     sci(__ret[-1])
2623     return __ret
2624 
2625 
2626 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2627 @_copy_docstring_and_deprecators(Axes.hlines)
2628 def hlines(
2629         y, xmin, xmax, colors=None, linestyles='solid', label='', *,
2630         data=None, **kwargs):
2631     return gca().hlines(
2632         y, xmin, xmax, colors=colors, linestyles=linestyles,
2633         label=label, **({"data": data} if data is not None else {}),
2634         **kwargs)
2635 
2636 
2637 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2638 @_copy_docstring_and_deprecators(Axes.imshow)
2639 def imshow(
2640         X, cmap=None, norm=None, aspect=None, interpolation=None,
2641         alpha=None, vmin=None, vmax=None, origin=None, extent=None, *,
2642         interpolation_stage=None, filternorm=True, filterrad=4.0,
2643         resample=None, url=None, data=None, **kwargs):
2644     __ret = gca().imshow(
2645         X, cmap=cmap, norm=norm, aspect=aspect,
2646         interpolation=interpolation, alpha=alpha, vmin=vmin,
2647         vmax=vmax, origin=origin, extent=extent,
2648         interpolation_stage=interpolation_stage,
2649         filternorm=filternorm, filterrad=filterrad, resample=resample,
2650         url=url, **({"data": data} if data is not None else {}),
2651         **kwargs)
2652     sci(__ret)
2653     return __ret
2654 
2655 
2656 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2657 @_copy_docstring_and_deprecators(Axes.legend)
2658 def legend(*args, **kwargs):
2659     return gca().legend(*args, **kwargs)
2660 
2661 
2662 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2663 @_copy_docstring_and_deprecators(Axes.locator_params)
2664 def locator_params(axis='both', tight=None, **kwargs):
2665     return gca().locator_params(axis=axis, tight=tight, **kwargs)
2666 
2667 
2668 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2669 @_copy_docstring_and_deprecators(Axes.loglog)
2670 def loglog(*args, **kwargs):
2671     return gca().loglog(*args, **kwargs)
2672 
2673 
2674 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2675 @_copy_docstring_and_deprecators(Axes.magnitude_spectrum)
2676 def magnitude_spectrum(
2677         x, Fs=None, Fc=None, window=None, pad_to=None, sides=None,
2678         scale=None, *, data=None, **kwargs):
2679     return gca().magnitude_spectrum(
2680         x, Fs=Fs, Fc=Fc, window=window, pad_to=pad_to, sides=sides,
2681         scale=scale, **({"data": data} if data is not None else {}),
2682         **kwargs)
2683 
2684 
2685 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2686 @_copy_docstring_and_deprecators(Axes.margins)
2687 def margins(*margins, x=None, y=None, tight=True):
2688     return gca().margins(*margins, x=x, y=y, tight=tight)
2689 
2690 
2691 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2692 @_copy_docstring_and_deprecators(Axes.minorticks_off)
2693 def minorticks_off():
2694     return gca().minorticks_off()
2695 
2696 
2697 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2698 @_copy_docstring_and_deprecators(Axes.minorticks_on)
2699 def minorticks_on():
2700     return gca().minorticks_on()
2701 
2702 
2703 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2704 @_copy_docstring_and_deprecators(Axes.pcolor)
2705 def pcolor(
2706         *args, shading=None, alpha=None, norm=None, cmap=None,
2707         vmin=None, vmax=None, data=None, **kwargs):
2708     __ret = gca().pcolor(
2709         *args, shading=shading, alpha=alpha, norm=norm, cmap=cmap,
2710         vmin=vmin, vmax=vmax,
2711         **({"data": data} if data is not None else {}), **kwargs)
2712     sci(__ret)
2713     return __ret
2714 
2715 
2716 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2717 @_copy_docstring_and_deprecators(Axes.pcolormesh)
2718 def pcolormesh(
2719         *args, alpha=None, norm=None, cmap=None, vmin=None,
2720         vmax=None, shading=None, antialiased=False, data=None,
2721         **kwargs):
2722     __ret = gca().pcolormesh(
2723         *args, alpha=alpha, norm=norm, cmap=cmap, vmin=vmin,
2724         vmax=vmax, shading=shading, antialiased=antialiased,
2725         **({"data": data} if data is not None else {}), **kwargs)
2726     sci(__ret)
2727     return __ret
2728 
2729 
2730 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2731 @_copy_docstring_and_deprecators(Axes.phase_spectrum)
2732 def phase_spectrum(
2733         x, Fs=None, Fc=None, window=None, pad_to=None, sides=None, *,
2734         data=None, **kwargs):
2735     return gca().phase_spectrum(
2736         x, Fs=Fs, Fc=Fc, window=window, pad_to=pad_to, sides=sides,
2737         **({"data": data} if data is not None else {}), **kwargs)
2738 
2739 
2740 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2741 @_copy_docstring_and_deprecators(Axes.pie)
2742 def pie(
2743         x, explode=None, labels=None, colors=None, autopct=None,
2744         pctdistance=0.6, shadow=False, labeldistance=1.1,
2745         startangle=0, radius=1, counterclock=True, wedgeprops=None,
2746         textprops=None, center=(0, 0), frame=False,
2747         rotatelabels=False, *, normalize=True, data=None):
2748     return gca().pie(
2749         x, explode=explode, labels=labels, colors=colors,
2750         autopct=autopct, pctdistance=pctdistance, shadow=shadow,
2751         labeldistance=labeldistance, startangle=startangle,
2752         radius=radius, counterclock=counterclock,
2753         wedgeprops=wedgeprops, textprops=textprops, center=center,
2754         frame=frame, rotatelabels=rotatelabels, normalize=normalize,
2755         **({"data": data} if data is not None else {}))
2756 
2757 
2758 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2759 @_copy_docstring_and_deprecators(Axes.plot)
2760 def plot(*args, scalex=True, scaley=True, data=None, **kwargs):
2761     return gca().plot(
2762         *args, scalex=scalex, scaley=scaley,
2763         **({"data": data} if data is not None else {}), **kwargs)
2764 
2765 
2766 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2767 @_copy_docstring_and_deprecators(Axes.plot_date)
2768 def plot_date(
2769         x, y, fmt='o', tz=None, xdate=True, ydate=False, *,
2770         data=None, **kwargs):
2771     return gca().plot_date(
2772         x, y, fmt=fmt, tz=tz, xdate=xdate, ydate=ydate,
2773         **({"data": data} if data is not None else {}), **kwargs)
2774 
2775 
2776 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2777 @_copy_docstring_and_deprecators(Axes.psd)
2778 def psd(
2779         x, NFFT=None, Fs=None, Fc=None, detrend=None, window=None,
2780         noverlap=None, pad_to=None, sides=None, scale_by_freq=None,
2781         return_line=None, *, data=None, **kwargs):
2782     return gca().psd(
2783         x, NFFT=NFFT, Fs=Fs, Fc=Fc, detrend=detrend, window=window,
2784         noverlap=noverlap, pad_to=pad_to, sides=sides,
2785         scale_by_freq=scale_by_freq, return_line=return_line,
2786         **({"data": data} if data is not None else {}), **kwargs)
2787 
2788 
2789 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2790 @_copy_docstring_and_deprecators(Axes.quiver)
2791 def quiver(*args, data=None, **kwargs):
2792     __ret = gca().quiver(
2793         *args, **({"data": data} if data is not None else {}),
2794         **kwargs)
2795     sci(__ret)
2796     return __ret
2797 
2798 
2799 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2800 @_copy_docstring_and_deprecators(Axes.quiverkey)
2801 def quiverkey(Q, X, Y, U, label, **kwargs):
2802     return gca().quiverkey(Q, X, Y, U, label, **kwargs)
2803 
2804 
2805 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2806 @_copy_docstring_and_deprecators(Axes.scatter)
2807 def scatter(
2808         x, y, s=None, c=None, marker=None, cmap=None, norm=None,
2809         vmin=None, vmax=None, alpha=None, linewidths=None, *,
2810         edgecolors=None, plotnonfinite=False, data=None, **kwargs):
2811     __ret = gca().scatter(
2812         x, y, s=s, c=c, marker=marker, cmap=cmap, norm=norm,
2813         vmin=vmin, vmax=vmax, alpha=alpha, linewidths=linewidths,
2814         edgecolors=edgecolors, plotnonfinite=plotnonfinite,
2815         **({"data": data} if data is not None else {}), **kwargs)
2816     sci(__ret)
2817     return __ret
2818 
2819 
2820 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2821 @_copy_docstring_and_deprecators(Axes.semilogx)
2822 def semilogx(*args, **kwargs):
2823     return gca().semilogx(*args, **kwargs)
2824 
2825 
2826 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2827 @_copy_docstring_and_deprecators(Axes.semilogy)
2828 def semilogy(*args, **kwargs):
2829     return gca().semilogy(*args, **kwargs)
2830 
2831 
2832 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2833 @_copy_docstring_and_deprecators(Axes.specgram)
2834 def specgram(
2835         x, NFFT=None, Fs=None, Fc=None, detrend=None, window=None,
2836         noverlap=None, cmap=None, xextent=None, pad_to=None,
2837         sides=None, scale_by_freq=None, mode=None, scale=None,
2838         vmin=None, vmax=None, *, data=None, **kwargs):
2839     __ret = gca().specgram(
2840         x, NFFT=NFFT, Fs=Fs, Fc=Fc, detrend=detrend, window=window,
2841         noverlap=noverlap, cmap=cmap, xextent=xextent, pad_to=pad_to,
2842         sides=sides, scale_by_freq=scale_by_freq, mode=mode,
2843         scale=scale, vmin=vmin, vmax=vmax,
2844         **({"data": data} if data is not None else {}), **kwargs)
2845     sci(__ret[-1])
2846     return __ret
2847 
2848 
2849 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2850 @_copy_docstring_and_deprecators(Axes.spy)
2851 def spy(
2852         Z, precision=0, marker=None, markersize=None, aspect='equal',
2853         origin='upper', **kwargs):
2854     __ret = gca().spy(
2855         Z, precision=precision, marker=marker, markersize=markersize,
2856         aspect=aspect, origin=origin, **kwargs)
2857     if isinstance(__ret, cm.ScalarMappable): sci(__ret)  # noqa
2858     return __ret
2859 
2860 
2861 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2862 @_copy_docstring_and_deprecators(Axes.stackplot)
2863 def stackplot(
2864         x, *args, labels=(), colors=None, baseline='zero', data=None,
2865         **kwargs):
2866     return gca().stackplot(
2867         x, *args, labels=labels, colors=colors, baseline=baseline,
2868         **({"data": data} if data is not None else {}), **kwargs)
2869 
2870 
2871 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2872 @_copy_docstring_and_deprecators(Axes.stem)
2873 def stem(
2874         *args, linefmt=None, markerfmt=None, basefmt=None, bottom=0,
2875         label=None, use_line_collection=True, orientation='vertical',
2876         data=None):
2877     return gca().stem(
2878         *args, linefmt=linefmt, markerfmt=markerfmt, basefmt=basefmt,
2879         bottom=bottom, label=label,
2880         use_line_collection=use_line_collection,
2881         orientation=orientation,
2882         **({"data": data} if data is not None else {}))
2883 
2884 
2885 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2886 @_copy_docstring_and_deprecators(Axes.step)
2887 def step(x, y, *args, where='pre', data=None, **kwargs):
2888     return gca().step(
2889         x, y, *args, where=where,
2890         **({"data": data} if data is not None else {}), **kwargs)
2891 
2892 
2893 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2894 @_copy_docstring_and_deprecators(Axes.streamplot)
2895 def streamplot(
2896         x, y, u, v, density=1, linewidth=None, color=None, cmap=None,
2897         norm=None, arrowsize=1, arrowstyle='-|>', minlength=0.1,
2898         transform=None, zorder=None, start_points=None, maxlength=4.0,
2899         integration_direction='both', broken_streamlines=True, *,
2900         data=None):
2901     __ret = gca().streamplot(
2902         x, y, u, v, density=density, linewidth=linewidth, color=color,
2903         cmap=cmap, norm=norm, arrowsize=arrowsize,
2904         arrowstyle=arrowstyle, minlength=minlength,
2905         transform=transform, zorder=zorder, start_points=start_points,
2906         maxlength=maxlength,
2907         integration_direction=integration_direction,
2908         broken_streamlines=broken_streamlines,
2909         **({"data": data} if data is not None else {}))
2910     sci(__ret.lines)
2911     return __ret
2912 
2913 
2914 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2915 @_copy_docstring_and_deprecators(Axes.table)
2916 def table(
2917         cellText=None, cellColours=None, cellLoc='right',
2918         colWidths=None, rowLabels=None, rowColours=None,
2919         rowLoc='left', colLabels=None, colColours=None,
2920         colLoc='center', loc='bottom', bbox=None, edges='closed',
2921         **kwargs):
2922     return gca().table(
2923         cellText=cellText, cellColours=cellColours, cellLoc=cellLoc,
2924         colWidths=colWidths, rowLabels=rowLabels,
2925         rowColours=rowColours, rowLoc=rowLoc, colLabels=colLabels,
2926         colColours=colColours, colLoc=colLoc, loc=loc, bbox=bbox,
2927         edges=edges, **kwargs)
2928 
2929 
2930 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2931 @_copy_docstring_and_deprecators(Axes.text)
2932 def text(x, y, s, fontdict=None, **kwargs):
2933     return gca().text(x, y, s, fontdict=fontdict, **kwargs)
2934 
2935 
2936 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2937 @_copy_docstring_and_deprecators(Axes.tick_params)
2938 def tick_params(axis='both', **kwargs):
2939     return gca().tick_params(axis=axis, **kwargs)
2940 
2941 
2942 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2943 @_copy_docstring_and_deprecators(Axes.ticklabel_format)
2944 def ticklabel_format(
2945         *, axis='both', style='', scilimits=None, useOffset=None,
2946         useLocale=None, useMathText=None):
2947     return gca().ticklabel_format(
2948         axis=axis, style=style, scilimits=scilimits,
2949         useOffset=useOffset, useLocale=useLocale,
2950         useMathText=useMathText)
2951 
2952 
2953 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2954 @_copy_docstring_and_deprecators(Axes.tricontour)
2955 def tricontour(*args, **kwargs):
2956     __ret = gca().tricontour(*args, **kwargs)
2957     if __ret._A is not None: sci(__ret)  # noqa
2958     return __ret
2959 
2960 
2961 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2962 @_copy_docstring_and_deprecators(Axes.tricontourf)
2963 def tricontourf(*args, **kwargs):
2964     __ret = gca().tricontourf(*args, **kwargs)
2965     if __ret._A is not None: sci(__ret)  # noqa
2966     return __ret
2967 
2968 
2969 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2970 @_copy_docstring_and_deprecators(Axes.tripcolor)
2971 def tripcolor(
2972         *args, alpha=1.0, norm=None, cmap=None, vmin=None, vmax=None,
2973         shading='flat', facecolors=None, **kwargs):
2974     __ret = gca().tripcolor(
2975         *args, alpha=alpha, norm=norm, cmap=cmap, vmin=vmin,
2976         vmax=vmax, shading=shading, facecolors=facecolors, **kwargs)
2977     sci(__ret)
2978     return __ret
2979 
2980 
2981 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2982 @_copy_docstring_and_deprecators(Axes.triplot)
2983 def triplot(*args, **kwargs):
2984     return gca().triplot(*args, **kwargs)
2985 
2986 
2987 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2988 @_copy_docstring_and_deprecators(Axes.violinplot)
2989 def violinplot(
2990         dataset, positions=None, vert=True, widths=0.5,
2991         showmeans=False, showextrema=True, showmedians=False,
2992         quantiles=None, points=100, bw_method=None, *, data=None):
2993     return gca().violinplot(
2994         dataset, positions=positions, vert=vert, widths=widths,
2995         showmeans=showmeans, showextrema=showextrema,
2996         showmedians=showmedians, quantiles=quantiles, points=points,
2997         bw_method=bw_method,
2998         **({"data": data} if data is not None else {}))
2999 
3000 
3001 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3002 @_copy_docstring_and_deprecators(Axes.vlines)
3003 def vlines(
3004         x, ymin, ymax, colors=None, linestyles='solid', label='', *,
3005         data=None, **kwargs):
3006     return gca().vlines(
3007         x, ymin, ymax, colors=colors, linestyles=linestyles,
3008         label=label, **({"data": data} if data is not None else {}),
3009         **kwargs)
3010 
3011 
3012 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3013 @_copy_docstring_and_deprecators(Axes.xcorr)
3014 def xcorr(
3015         x, y, normed=True, detrend=mlab.detrend_none, usevlines=True,
3016         maxlags=10, *, data=None, **kwargs):
3017     return gca().xcorr(
3018         x, y, normed=normed, detrend=detrend, usevlines=usevlines,
3019         maxlags=maxlags,
3020         **({"data": data} if data is not None else {}), **kwargs)
3021 
3022 
3023 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3024 @_copy_docstring_and_deprecators(Axes._sci)
3025 def sci(im):
3026     return gca()._sci(im)
3027 
3028 
3029 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3030 @_copy_docstring_and_deprecators(Axes.set_title)
3031 def title(label, fontdict=None, loc=None, pad=None, *, y=None, **kwargs):
3032     return gca().set_title(
3033         label, fontdict=fontdict, loc=loc, pad=pad, y=y, **kwargs)
3034 
3035 
3036 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3037 @_copy_docstring_and_deprecators(Axes.set_xlabel)
3038 def xlabel(xlabel, fontdict=None, labelpad=None, *, loc=None, **kwargs):
3039     return gca().set_xlabel(
3040         xlabel, fontdict=fontdict, labelpad=labelpad, loc=loc,
3041         **kwargs)
3042 
3043 
3044 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3045 @_copy_docstring_and_deprecators(Axes.set_ylabel)
3046 def ylabel(ylabel, fontdict=None, labelpad=None, *, loc=None, **kwargs):
3047     return gca().set_ylabel(
3048         ylabel, fontdict=fontdict, labelpad=labelpad, loc=loc,
3049         **kwargs)
3050 
3051 
3052 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3053 @_copy_docstring_and_deprecators(Axes.set_xscale)
3054 def xscale(value, **kwargs):
3055     return gca().set_xscale(value, **kwargs)
3056 
3057 
3058 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3059 @_copy_docstring_and_deprecators(Axes.set_yscale)
3060 def yscale(value, **kwargs):
3061     return gca().set_yscale(value, **kwargs)
3062 
3063 
3064 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3065 def autumn(): set_cmap('autumn')
3066 def bone(): set_cmap('bone')
3067 def cool(): set_cmap('cool')
3068 def copper(): set_cmap('copper')
3069 def flag(): set_cmap('flag')
3070 def gray(): set_cmap('gray')
3071 def hot(): set_cmap('hot')
3072 def hsv(): set_cmap('hsv')
3073 def jet(): set_cmap('jet')
3074 def pink(): set_cmap('pink')
3075 def prism(): set_cmap('prism')
3076 def spring(): set_cmap('spring')
3077 def summer(): set_cmap('summer')
3078 def winter(): set_cmap('winter')
3079 def magma(): set_cmap('magma')
3080 def inferno(): set_cmap('inferno')
3081 def plasma(): set_cmap('plasma')
3082 def viridis(): set_cmap('viridis')
3083 def nipy_spectral(): set_cmap('nipy_spectral')
3084 
3085 
3086 _setup_pyplot_info_docstrings()

</code><intended_behavior>The code should correctly handle instances when `ax` is contained within a `SubFigure`, not just a standard `Figure`. Currently, it assumes `ax.figure` can always be directly passed to `figure(ax.figure)`, which fails with `SubFigure` instances due to type errors. The fix should include a check if `ax.figure` is a `SubFigure` instance and handle this case appropriately, possibly by navigating to the parent figure if necessary, without changing the behavior for standard figures.</intended_behavior>, <file>lib/matplotlib/pyplot.py</file>
<class>None</class>
<method>None</method>
<code>
1 # Note: The first part of this file can be modified in place, but the latter
2 # part is autogenerated by the boilerplate.py script.
3 
4 """
5 `matplotlib.pyplot` is a state-based interface to matplotlib. It provides
6 an implicit,  MATLAB-like, way of plotting.  It also opens figures on your
7 screen, and acts as the figure GUI manager.
8 
9 pyplot is mainly intended for interactive plots and simple cases of
10 programmatic plot generation::
11 
12     import numpy as np
13     import matplotlib.pyplot as plt
14 
15     x = np.arange(0, 5, 0.1)
16     y = np.sin(x)
17     plt.plot(x, y)
18 
19 The explicit object-oriented API is recommended for complex plots, though
20 pyplot is still usually used to create the figure and often the axes in the
21 figure. See `.pyplot.figure`, `.pyplot.subplots`, and
22 `.pyplot.subplot_mosaic` to create figures, and
23 :doc:`Axes API <../axes_api>` for the plotting methods on an Axes::
24 
25     import numpy as np
26     import matplotlib.pyplot as plt
27 
28     x = np.arange(0, 5, 0.1)
29     y = np.sin(x)
30     fig, ax = plt.subplots()
31     ax.plot(x, y)
32 
33 
34 See :ref:`api_interfaces` for an explanation of the tradeoffs between the
35 implicit and explicit interfaces.
36 """
37 
38 from enum import Enum
39 import functools
40 import importlib
41 import inspect
42 import logging
43 from numbers import Number
44 import re
45 import sys
46 import time
47 try:
48     import threading
49 except ImportError:
50     import dummy_threading as threading
51 
52 from cycler import cycler
53 import matplotlib
54 import matplotlib.colorbar
55 import matplotlib.image
56 from matplotlib import _api
57 from matplotlib import rcsetup, style
58 from matplotlib import _pylab_helpers, interactive
59 from matplotlib import cbook
60 from matplotlib import _docstring
61 from matplotlib.backend_bases import FigureCanvasBase, MouseButton
62 from matplotlib.figure import Figure, figaspect
63 from matplotlib.gridspec import GridSpec, SubplotSpec
64 from matplotlib import rcParams, rcParamsDefault, get_backend, rcParamsOrig
65 from matplotlib.rcsetup import interactive_bk as _interactive_bk
66 from matplotlib.artist import Artist
67 from matplotlib.axes import Axes, Subplot
68 from matplotlib.projections import PolarAxes
69 from matplotlib import mlab  # for detrend_none, window_hanning
70 from matplotlib.scale import get_scale_names
71 
72 from matplotlib import cm
73 from matplotlib.cm import _colormaps as colormaps, get_cmap, register_cmap
74 from matplotlib.colors import _color_sequences as color_sequences
75 
76 import numpy as np
77 
78 # We may not need the following imports here:
79 from matplotlib.colors import Normalize
80 from matplotlib.lines import Line2D
81 from matplotlib.text import Text, Annotation
82 from matplotlib.patches import Polygon, Rectangle, Circle, Arrow
83 from matplotlib.widgets import Button, Slider, Widget
84 
85 from .ticker import (
86     TickHelper, Formatter, FixedFormatter, NullFormatter, FuncFormatter,
87     FormatStrFormatter, ScalarFormatter, LogFormatter, LogFormatterExponent,
88     LogFormatterMathtext, Locator, IndexLocator, FixedLocator, NullLocator,
89     LinearLocator, LogLocator, AutoLocator, MultipleLocator, MaxNLocator)
90 
91 _log = logging.getLogger(__name__)
92 
93 
94 def _copy_docstring_and_deprecators(method, func=None):
95     if func is None:
96         return functools.partial(_copy_docstring_and_deprecators, method)
97     decorators = [_docstring.copy(method)]
98     # Check whether the definition of *method* includes @_api.rename_parameter
99     # or @_api.make_keyword_only decorators; if so, propagate them to the
100     # pyplot wrapper as well.
101     while getattr(method, "__wrapped__", None) is not None:
102         decorator = _api.deprecation.DECORATORS.get(method)
103         if decorator:
104             decorators.append(decorator)
105         method = method.__wrapped__
106     for decorator in decorators[::-1]:
107         func = decorator(func)
108     return func
109 
110 
111 ## Global ##
112 
113 
114 # The state controlled by {,un}install_repl_displayhook().
115 _ReplDisplayHook = Enum("_ReplDisplayHook", ["NONE", "PLAIN", "IPYTHON"])
116 _REPL_DISPLAYHOOK = _ReplDisplayHook.NONE
117 
118 
119 def _draw_all_if_interactive():
120     if matplotlib.is_interactive():
121         draw_all()
122 
123 
124 def install_repl_displayhook():
125     """
126     Connect to the display hook of the current shell.
127 
128     The display hook gets called when the read-evaluate-print-loop (REPL) of
129     the shell has finished the execution of a command. We use this callback
130     to be able to automatically update a figure in interactive mode.
131 
132     This works both with IPython and with vanilla python shells.
133     """
134     global _REPL_DISPLAYHOOK
135 
136     if _REPL_DISPLAYHOOK is _ReplDisplayHook.IPYTHON:
137         return
138 
139     # See if we have IPython hooks around, if so use them.
140     # Use ``sys.modules.get(name)`` rather than ``name in sys.modules`` as
141     # entries can also have been explicitly set to None.
142     mod_ipython = sys.modules.get("IPython")
143     if not mod_ipython:
144         _REPL_DISPLAYHOOK = _ReplDisplayHook.PLAIN
145         return
146     ip = mod_ipython.get_ipython()
147     if not ip:
148         _REPL_DISPLAYHOOK = _ReplDisplayHook.PLAIN
149         return
150 
151     ip.events.register("post_execute", _draw_all_if_interactive)
152     _REPL_DISPLAYHOOK = _ReplDisplayHook.IPYTHON
153 
154     from IPython.core.pylabtools import backend2gui
155     # trigger IPython's eventloop integration, if available
156     ipython_gui_name = backend2gui.get(get_backend())
157     if ipython_gui_name:
158         ip.enable_gui(ipython_gui_name)
159 
160 
161 def uninstall_repl_displayhook():
162     """Disconnect from the display hook of the current shell."""
163     global _REPL_DISPLAYHOOK
164     if _REPL_DISPLAYHOOK is _ReplDisplayHook.IPYTHON:
165         from IPython import get_ipython
166         ip = get_ipython()
167         ip.events.unregister("post_execute", _draw_all_if_interactive)
168     _REPL_DISPLAYHOOK = _ReplDisplayHook.NONE
169 
170 
171 draw_all = _pylab_helpers.Gcf.draw_all
172 
173 
174 @_copy_docstring_and_deprecators(matplotlib.set_loglevel)
175 def set_loglevel(*args, **kwargs):  # Ensure this appears in the pyplot docs.
176     return matplotlib.set_loglevel(*args, **kwargs)
177 
178 
179 @_copy_docstring_and_deprecators(Artist.findobj)
180 def findobj(o=None, match=None, include_self=True):
181     if o is None:
182         o = gcf()
183     return o.findobj(match, include_self=include_self)
184 
185 
186 def _get_required_interactive_framework(backend_mod):
187     if not hasattr(backend_mod.FigureCanvas, "required_interactive_framework"):
188         _api.warn_deprecated(
189             "3.6", name="Support for FigureCanvases without a "
190             "required_interactive_framework attribute")
191         return None
192     # Inline this once the deprecation elapses.
193     return backend_mod.FigureCanvas.required_interactive_framework
194 
195 _backend_mod = None
196 
197 
198 def _get_backend_mod():
199     """
200     Ensure that a backend is selected and return it.
201 
202     This is currently private, but may be made public in the future.
203     """
204     if _backend_mod is None:
205         # Use __getitem__ here to avoid going through the fallback logic (which
206         # will (re)import pyplot and then call switch_backend if we need to
207         # resolve the auto sentinel)
208         switch_backend(dict.__getitem__(rcParams, "backend"))
209         # Just to be safe.  Interactive mode can be turned on without calling
210         # `plt.ion()` so register it again here.  This is safe because multiple
211         # calls to `install_repl_displayhook` are no-ops and the registered
212         # function respects `mpl.is_interactive()` to determine if it should
213         # trigger a draw.
214         install_repl_displayhook()
215     return _backend_mod
216 
217 
218 def switch_backend(newbackend):
219     """
220     Close all open figures and set the Matplotlib backend.
221 
222     The argument is case-insensitive.  Switching to an interactive backend is
223     possible only if no event loop for another interactive backend has started.
224     Switching to and from non-interactive backends is always possible.
225 
226     Parameters
227     ----------
228     newbackend : str
229         The name of the backend to use.
230     """
231     global _backend_mod
232     # make sure the init is pulled up so we can assign to it later
233     import matplotlib.backends
234     close("all")
235 
236     if newbackend is rcsetup._auto_backend_sentinel:
237         current_framework = cbook._get_running_interactive_framework()
238         mapping = {'qt': 'qtagg',
239                    'gtk3': 'gtk3agg',
240                    'gtk4': 'gtk4agg',
241                    'wx': 'wxagg',
242                    'tk': 'tkagg',
243                    'macosx': 'macosx',
244                    'headless': 'agg'}
245 
246         best_guess = mapping.get(current_framework, None)
247         if best_guess is not None:
248             candidates = [best_guess]
249         else:
250             candidates = []
251         candidates += [
252             "macosx", "qtagg", "gtk4agg", "gtk3agg", "tkagg", "wxagg"]
253 
254         # Don't try to fallback on the cairo-based backends as they each have
255         # an additional dependency (pycairo) over the agg-based backend, and
256         # are of worse quality.
257         for candidate in candidates:
258             try:
259                 switch_backend(candidate)
260             except ImportError:
261                 continue
262             else:
263                 rcParamsOrig['backend'] = candidate
264                 return
265         else:
266             # Switching to Agg should always succeed; if it doesn't, let the
267             # exception propagate out.
268             switch_backend("agg")
269             rcParamsOrig["backend"] = "agg"
270             return
271 
272     # Backends are implemented as modules, but "inherit" default method
273     # implementations from backend_bases._Backend.  This is achieved by
274     # creating a "class" that inherits from backend_bases._Backend and whose
275     # body is filled with the module's globals.
276 
277     backend_name = cbook._backend_module_name(newbackend)
278 
279     class backend_mod(matplotlib.backend_bases._Backend):
280         locals().update(vars(importlib.import_module(backend_name)))
281 
282     required_framework = _get_required_interactive_framework(backend_mod)
283     if required_framework is not None:
284         current_framework = cbook._get_running_interactive_framework()
285         if (current_framework and required_framework
286                 and current_framework != required_framework):
287             raise ImportError(
288                 "Cannot load backend {!r} which requires the {!r} interactive "
289                 "framework, as {!r} is currently running".format(
290                     newbackend, required_framework, current_framework))
291 
292     _log.debug("Loaded backend %s version %s.",
293                newbackend, backend_mod.backend_version)
294 
295     rcParams['backend'] = rcParamsDefault['backend'] = newbackend
296     _backend_mod = backend_mod
297     for func_name in ["new_figure_manager", "draw_if_interactive", "show"]:
298         globals()[func_name].__signature__ = inspect.signature(
299             getattr(backend_mod, func_name))
300 
301     # Need to keep a global reference to the backend for compatibility reasons.
302     # See https://github.com/matplotlib/matplotlib/issues/6092
303     matplotlib.backends.backend = newbackend
304 
305 
306 def _warn_if_gui_out_of_main_thread():
307     if (_get_required_interactive_framework(_get_backend_mod())
308             and threading.current_thread() is not threading.main_thread()):
309         _api.warn_external(
310             "Starting a Matplotlib GUI outside of the main thread will likely "
311             "fail.")
312 
313 
314 # This function's signature is rewritten upon backend-load by switch_backend.
315 def new_figure_manager(*args, **kwargs):
316     """Create a new figure manager instance."""
317     _warn_if_gui_out_of_main_thread()
318     return _get_backend_mod().new_figure_manager(*args, **kwargs)
319 
320 
321 # This function's signature is rewritten upon backend-load by switch_backend.
322 def draw_if_interactive(*args, **kwargs):
323     """
324     Redraw the current figure if in interactive mode.
325 
326     .. warning::
327 
328         End users will typically not have to call this function because the
329         the interactive mode takes care of this.
330     """
331     return _get_backend_mod().draw_if_interactive(*args, **kwargs)
332 
333 
334 # This function's signature is rewritten upon backend-load by switch_backend.
335 def show(*args, **kwargs):
336     """
337     Display all open figures.
338 
339     Parameters
340     ----------
341     block : bool, optional
342         Whether to wait for all figures to be closed before returning.
343 
344         If `True` block and run the GUI main loop until all figure windows
345         are closed.
346 
347         If `False` ensure that all figure windows are displayed and return
348         immediately.  In this case, you are responsible for ensuring
349         that the event loop is running to have responsive figures.
350 
351         Defaults to True in non-interactive mode and to False in interactive
352         mode (see `.pyplot.isinteractive`).
353 
354     See Also
355     --------
356     ion : Enable interactive mode, which shows / updates the figure after
357           every plotting command, so that calling ``show()`` is not necessary.
358     ioff : Disable interactive mode.
359     savefig : Save the figure to an image file instead of showing it on screen.
360 
361     Notes
362     -----
363     **Saving figures to file and showing a window at the same time**
364 
365     If you want an image file as well as a user interface window, use
366     `.pyplot.savefig` before `.pyplot.show`. At the end of (a blocking)
367     ``show()`` the figure is closed and thus unregistered from pyplot. Calling
368     `.pyplot.savefig` afterwards would save a new and thus empty figure. This
369     limitation of command order does not apply if the show is non-blocking or
370     if you keep a reference to the figure and use `.Figure.savefig`.
371 
372     **Auto-show in jupyter notebooks**
373 
374     The jupyter backends (activated via ``%matplotlib inline``,
375     ``%matplotlib notebook``, or ``%matplotlib widget``), call ``show()`` at
376     the end of every cell by default. Thus, you usually don't have to call it
377     explicitly there.
378     """
379     _warn_if_gui_out_of_main_thread()
380     return _get_backend_mod().show(*args, **kwargs)
381 
382 
383 def isinteractive():
384     """
385     Return whether plots are updated after every plotting command.
386 
387     The interactive mode is mainly useful if you build plots from the command
388     line and want to see the effect of each command while you are building the
389     figure.
390 
391     In interactive mode:
392 
393     - newly created figures will be shown immediately;
394     - figures will automatically redraw on change;
395     - `.pyplot.show` will not block by default.
396 
397     In non-interactive mode:
398 
399     - newly created figures and changes to figures will not be reflected until
400       explicitly asked to be;
401     - `.pyplot.show` will block by default.
402 
403     See Also
404     --------
405     ion : Enable interactive mode.
406     ioff : Disable interactive mode.
407     show : Show all figures (and maybe block).
408     pause : Show all figures, and block for a time.
409     """
410     return matplotlib.is_interactive()
411 
412 
413 class _IoffContext:
414     """
415     Context manager for `.ioff`.
416 
417     The state is changed in ``__init__()`` instead of ``__enter__()``. The
418     latter is a no-op. This allows using `.ioff` both as a function and
419     as a context.
420     """
421 
422     def __init__(self):
423         self.wasinteractive = isinteractive()
424         matplotlib.interactive(False)
425         uninstall_repl_displayhook()
426 
427     def __enter__(self):
428         pass
429 
430     def __exit__(self, exc_type, exc_value, traceback):
431         if self.wasinteractive:
432             matplotlib.interactive(True)
433             install_repl_displayhook()
434         else:
435             matplotlib.interactive(False)
436             uninstall_repl_displayhook()
437 
438 
439 class _IonContext:
440     """
441     Context manager for `.ion`.
442 
443     The state is changed in ``__init__()`` instead of ``__enter__()``. The
444     latter is a no-op. This allows using `.ion` both as a function and
445     as a context.
446     """
447 
448     def __init__(self):
449         self.wasinteractive = isinteractive()
450         matplotlib.interactive(True)
451         install_repl_displayhook()
452 
453     def __enter__(self):
454         pass
455 
456     def __exit__(self, exc_type, exc_value, traceback):
457         if not self.wasinteractive:
458             matplotlib.interactive(False)
459             uninstall_repl_displayhook()
460         else:
461             matplotlib.interactive(True)
462             install_repl_displayhook()
463 
464 
465 def ioff():
466     """
467     Disable interactive mode.
468 
469     See `.pyplot.isinteractive` for more details.
470 
471     See Also
472     --------
473     ion : Enable interactive mode.
474     isinteractive : Whether interactive mode is enabled.
475     show : Show all figures (and maybe block).
476     pause : Show all figures, and block for a time.
477 
478     Notes
479     -----
480     For a temporary change, this can be used as a context manager::
481 
482         # if interactive mode is on
483         # then figures will be shown on creation
484         plt.ion()
485         # This figure will be shown immediately
486         fig = plt.figure()
487 
488         with plt.ioff():
489             # interactive mode will be off
490             # figures will not automatically be shown
491             fig2 = plt.figure()
492             # ...
493 
494     To enable usage as a context manager, this function returns an
495     ``_IoffContext`` object. The return value is not intended to be stored
496     or accessed by the user.
497     """
498     return _IoffContext()
499 
500 
501 def ion():
502     """
503     Enable interactive mode.
504 
505     See `.pyplot.isinteractive` for more details.
506 
507     See Also
508     --------
509     ioff : Disable interactive mode.
510     isinteractive : Whether interactive mode is enabled.
511     show : Show all figures (and maybe block).
512     pause : Show all figures, and block for a time.
513 
514     Notes
515     -----
516     For a temporary change, this can be used as a context manager::
517 
518         # if interactive mode is off
519         # then figures will not be shown on creation
520         plt.ioff()
521         # This figure will not be shown immediately
522         fig = plt.figure()
523 
524         with plt.ion():
525             # interactive mode will be on
526             # figures will automatically be shown
527             fig2 = plt.figure()
528             # ...
529 
530     To enable usage as a context manager, this function returns an
531     ``_IonContext`` object. The return value is not intended to be stored
532     or accessed by the user.
533     """
534     return _IonContext()
535 
536 
537 def pause(interval):
538     """
539     Run the GUI event loop for *interval* seconds.
540 
541     If there is an active figure, it will be updated and displayed before the
542     pause, and the GUI event loop (if any) will run during the pause.
543 
544     This can be used for crude animation.  For more complex animation use
545     :mod:`matplotlib.animation`.
546 
547     If there is no active figure, sleep for *interval* seconds instead.
548 
549     See Also
550     --------
551     matplotlib.animation : Proper animations
552     show : Show all figures and optional block until all figures are closed.
553     """
554     manager = _pylab_helpers.Gcf.get_active()
555     if manager is not None:
556         canvas = manager.canvas
557         if canvas.figure.stale:
558             canvas.draw_idle()
559         show(block=False)
560         canvas.start_event_loop(interval)
561     else:
562         time.sleep(interval)
563 
564 
565 @_copy_docstring_and_deprecators(matplotlib.rc)
566 def rc(group, **kwargs):
567     matplotlib.rc(group, **kwargs)
568 
569 
570 @_copy_docstring_and_deprecators(matplotlib.rc_context)
571 def rc_context(rc=None, fname=None):
572     return matplotlib.rc_context(rc, fname)
573 
574 
575 @_copy_docstring_and_deprecators(matplotlib.rcdefaults)
576 def rcdefaults():
577     matplotlib.rcdefaults()
578     if matplotlib.is_interactive():
579         draw_all()
580 
581 
582 # getp/get/setp are explicitly reexported so that they show up in pyplot docs.
583 
584 
585 @_copy_docstring_and_deprecators(matplotlib.artist.getp)
586 def getp(obj, *args, **kwargs):
587     return matplotlib.artist.getp(obj, *args, **kwargs)
588 
589 
590 @_copy_docstring_and_deprecators(matplotlib.artist.get)
591 def get(obj, *args, **kwargs):
592     return matplotlib.artist.get(obj, *args, **kwargs)
593 
594 
595 @_copy_docstring_and_deprecators(matplotlib.artist.setp)
596 def setp(obj, *args, **kwargs):
597     return matplotlib.artist.setp(obj, *args, **kwargs)
598 
599 
600 def xkcd(scale=1, length=100, randomness=2):
601     """
602     Turn on `xkcd <https://xkcd.com/>`_ sketch-style drawing mode.  This will
603     only have effect on things drawn after this function is called.
604 
605     For best results, the "Humor Sans" font should be installed: it is
606     not included with Matplotlib.
607 
608     Parameters
609     ----------
610     scale : float, optional
611         The amplitude of the wiggle perpendicular to the source line.
612     length : float, optional
613         The length of the wiggle along the line.
614     randomness : float, optional
615         The scale factor by which the length is shrunken or expanded.
616 
617     Notes
618     -----
619     This function works by a number of rcParams, so it will probably
620     override others you have set before.
621 
622     If you want the effects of this function to be temporary, it can
623     be used as a context manager, for example::
624 
625         with plt.xkcd():
626             # This figure will be in XKCD-style
627             fig1 = plt.figure()
628             # ...
629 
630         # This figure will be in regular style
631         fig2 = plt.figure()
632     """
633     return _xkcd(scale, length, randomness)
634 
635 
636 class _xkcd:
637     # This cannot be implemented in terms of rc_context() because this needs to
638     # work as a non-contextmanager too.
639 
640     def __init__(self, scale, length, randomness):
641         self._orig = rcParams.copy()
642 
643         if rcParams['text.usetex']:
644             raise RuntimeError(
645                 "xkcd mode is not compatible with text.usetex = True")
646 
647         from matplotlib import patheffects
648         rcParams.update({
649             'font.family': ['xkcd', 'xkcd Script', 'Humor Sans', 'Comic Neue',
650                             'Comic Sans MS'],
651             'font.size': 14.0,
652             'path.sketch': (scale, length, randomness),
653             'path.effects': [
654                 patheffects.withStroke(linewidth=4, foreground="w")],
655             'axes.linewidth': 1.5,
656             'lines.linewidth': 2.0,
657             'figure.facecolor': 'white',
658             'grid.linewidth': 0.0,
659             'axes.grid': False,
660             'axes.unicode_minus': False,
661             'axes.edgecolor': 'black',
662             'xtick.major.size': 8,
663             'xtick.major.width': 3,
664             'ytick.major.size': 8,
665             'ytick.major.width': 3,
666         })
667 
668     def __enter__(self):
669         return self
670 
671     def __exit__(self, *args):
672         dict.update(rcParams, self._orig)
673 
674 
675 ## Figures ##
676 
677 @_api.make_keyword_only("3.6", "facecolor")
678 def figure(num=None,  # autoincrement if None, else integer from 1-N
679            figsize=None,  # defaults to rc figure.figsize
680            dpi=None,  # defaults to rc figure.dpi
681            facecolor=None,  # defaults to rc figure.facecolor
682            edgecolor=None,  # defaults to rc figure.edgecolor
683            frameon=True,
684            FigureClass=Figure,
685            clear=False,
686            **kwargs
687            ):
688     """
689     Create a new figure, or activate an existing figure.
690 
691     Parameters
692     ----------
693     num : int or str or `.Figure`, optional
694         A unique identifier for the figure.
695 
696         If a figure with that identifier already exists, this figure is made
697         active and returned. An integer refers to the ``Figure.number``
698         attribute, a string refers to the figure label.
699 
700         If there is no figure with the identifier or *num* is not given, a new
701         figure is created, made active and returned.  If *num* is an int, it
702         will be used for the ``Figure.number`` attribute, otherwise, an
703         auto-generated integer value is used (starting at 1 and incremented
704         for each new figure). If *num* is a string, the figure label and the
705         window title is set to this value.
706 
707     figsize : (float, float), default: :rc:`figure.figsize`
708         Width, height in inches.
709 
710     dpi : float, default: :rc:`figure.dpi`
711         The resolution of the figure in dots-per-inch.
712 
713     facecolor : color, default: :rc:`figure.facecolor`
714         The background color.
715 
716     edgecolor : color, default: :rc:`figure.edgecolor`
717         The border color.
718 
719     frameon : bool, default: True
720         If False, suppress drawing the figure frame.
721 
722     FigureClass : subclass of `~matplotlib.figure.Figure`
723         If set, an instance of this subclass will be created, rather than a
724         plain `.Figure`.
725 
726     clear : bool, default: False
727         If True and the figure already exists, then it is cleared.
728 
729     layout : {'constrained', 'tight', `.LayoutEngine`, None}, default: None
730         The layout mechanism for positioning of plot elements to avoid
731         overlapping Axes decorations (labels, ticks, etc). Note that layout
732         managers can measurably slow down figure display. Defaults to *None*
733         (but see the documentation of the `.Figure` constructor regarding the
734         interaction with rcParams).
735 
736     **kwargs
737         Additional keyword arguments are passed to the `.Figure` constructor.
738 
739     Returns
740     -------
741     `~matplotlib.figure.Figure`
742 
743     Notes
744     -----
745     Newly created figures will be passed to the
746     `~.backend_template.new_figure_manager` function provided by the current
747     backend, which will install a canvas and a manager on the figure.
748 
749     If you are creating many figures, make sure you explicitly call
750     `.pyplot.close` on the figures you are not using, because this will
751     enable pyplot to properly clean up the memory.
752 
753     `~matplotlib.rcParams` defines the default values, which can be modified
754     in the matplotlibrc file.
755     """
756     if isinstance(num, Figure):
757         if num.canvas.manager is None:
758             raise ValueError("The passed figure is not managed by pyplot")
759         _pylab_helpers.Gcf.set_active(num.canvas.manager)
760         return num
761 
762     allnums = get_fignums()
763     next_num = max(allnums) + 1 if allnums else 1
764     fig_label = ''
765     if num is None:
766         num = next_num
767     elif isinstance(num, str):
768         fig_label = num
769         all_labels = get_figlabels()
770         if fig_label not in all_labels:
771             if fig_label == 'all':
772                 _api.warn_external("close('all') closes all existing figures.")
773             num = next_num
774         else:
775             inum = all_labels.index(fig_label)
776             num = allnums[inum]
777     else:
778         num = int(num)  # crude validation of num argument
779 
780     manager = _pylab_helpers.Gcf.get_fig_manager(num)
781     if manager is None:
782         max_open_warning = rcParams['figure.max_open_warning']
783         if len(allnums) == max_open_warning >= 1:
784             _api.warn_external(
785                 f"More than {max_open_warning} figures have been opened. "
786                 f"Figures created through the pyplot interface "
787                 f"(`matplotlib.pyplot.figure`) are retained until explicitly "
788                 f"closed and may consume too much memory. (To control this "
789                 f"warning, see the rcParam `figure.max_open_warning`).",
790                 RuntimeWarning)
791 
792         manager = new_figure_manager(
793             num, figsize=figsize, dpi=dpi,
794             facecolor=facecolor, edgecolor=edgecolor, frameon=frameon,
795             FigureClass=FigureClass, **kwargs)
796         fig = manager.canvas.figure
797         if fig_label:
798             fig.set_label(fig_label)
799 
800         _pylab_helpers.Gcf._set_new_active_manager(manager)
801 
802         # make sure backends (inline) that we don't ship that expect this
803         # to be called in plotting commands to make the figure call show
804         # still work.  There is probably a better way to do this in the
805         # FigureManager base class.
806         draw_if_interactive()
807 
808         if _REPL_DISPLAYHOOK is _ReplDisplayHook.PLAIN:
809             fig.stale_callback = _auto_draw_if_interactive
810 
811     if clear:
812         manager.canvas.figure.clear()
813 
814     return manager.canvas.figure
815 
816 
817 def _auto_draw_if_interactive(fig, val):
818     """
819     An internal helper function for making sure that auto-redrawing
820     works as intended in the plain python repl.
821 
822     Parameters
823     ----------
824     fig : Figure
825         A figure object which is assumed to be associated with a canvas
826     """
827     if (val and matplotlib.is_interactive()
828             and not fig.canvas.is_saving()
829             and not fig.canvas._is_idle_drawing):
830         # Some artists can mark themselves as stale in the middle of drawing
831         # (e.g. axes position & tick labels being computed at draw time), but
832         # this shouldn't trigger a redraw because the current redraw will
833         # already take them into account.
834         with fig.canvas._idle_draw_cntx():
835             fig.canvas.draw_idle()
836 
837 
838 def gcf():
839     """
840     Get the current figure.
841 
842     If there is currently no figure on the pyplot figure stack, a new one is
843     created using `~.pyplot.figure()`.  (To test whether there is currently a
844     figure on the pyplot figure stack, check whether `~.pyplot.get_fignums()`
845     is empty.)
846     """
847     manager = _pylab_helpers.Gcf.get_active()
848     if manager is not None:
849         return manager.canvas.figure
850     else:
851         return figure()
852 
853 
854 def fignum_exists(num):
855     """Return whether the figure with the given id exists."""
856     return _pylab_helpers.Gcf.has_fignum(num) or num in get_figlabels()
857 
858 
859 def get_fignums():
860     """Return a list of existing figure numbers."""
861     return sorted(_pylab_helpers.Gcf.figs)
862 
863 
864 def get_figlabels():
865     """Return a list of existing figure labels."""
866     managers = _pylab_helpers.Gcf.get_all_fig_managers()
867     managers.sort(key=lambda m: m.num)
868     return [m.canvas.figure.get_label() for m in managers]
869 
870 
871 def get_current_fig_manager():
872     """
873     Return the figure manager of the current figure.
874 
875     The figure manager is a container for the actual backend-depended window
876     that displays the figure on screen.
877 
878     If no current figure exists, a new one is created, and its figure
879     manager is returned.
880 
881     Returns
882     -------
883     `.FigureManagerBase` or backend-dependent subclass thereof
884     """
885     return gcf().canvas.manager
886 
887 
888 @_copy_docstring_and_deprecators(FigureCanvasBase.mpl_connect)
889 def connect(s, func):
890     return gcf().canvas.mpl_connect(s, func)
891 
892 
893 @_copy_docstring_and_deprecators(FigureCanvasBase.mpl_disconnect)
894 def disconnect(cid):
895     return gcf().canvas.mpl_disconnect(cid)
896 
897 
898 def close(fig=None):
899     """
900     Close a figure window.
901 
902     Parameters
903     ----------
904     fig : None or int or str or `.Figure`
905         The figure to close. There are a number of ways to specify this:
906 
907         - *None*: the current figure
908         - `.Figure`: the given `.Figure` instance
909         - ``int``: a figure number
910         - ``str``: a figure name
911         - 'all': all figures
912 
913     """
914     if fig is None:
915         manager = _pylab_helpers.Gcf.get_active()
916         if manager is None:
917             return
918         else:
919             _pylab_helpers.Gcf.destroy(manager)
920     elif fig == 'all':
921         _pylab_helpers.Gcf.destroy_all()
922     elif isinstance(fig, int):
923         _pylab_helpers.Gcf.destroy(fig)
924     elif hasattr(fig, 'int'):
925         # if we are dealing with a type UUID, we
926         # can use its integer representation
927         _pylab_helpers.Gcf.destroy(fig.int)
928     elif isinstance(fig, str):
929         all_labels = get_figlabels()
930         if fig in all_labels:
931             num = get_fignums()[all_labels.index(fig)]
932             _pylab_helpers.Gcf.destroy(num)
933     elif isinstance(fig, Figure):
934         _pylab_helpers.Gcf.destroy_fig(fig)
935     else:
936         raise TypeError("close() argument must be a Figure, an int, a string, "
937                         "or None, not %s" % type(fig))
938 
939 
940 def clf():
941     """Clear the current figure."""
942     gcf().clear()
943 
944 
945 def draw():
946     """
947     Redraw the current figure.
948 
949     This is used to update a figure that has been altered, but not
950     automatically re-drawn.  If interactive mode is on (via `.ion()`), this
951     should be only rarely needed, but there may be ways to modify the state of
952     a figure without marking it as "stale".  Please report these cases as bugs.
953 
954     This is equivalent to calling ``fig.canvas.draw_idle()``, where ``fig`` is
955     the current figure.
956     """
957     gcf().canvas.draw_idle()
958 
959 
960 @_copy_docstring_and_deprecators(Figure.savefig)
961 def savefig(*args, **kwargs):
962     fig = gcf()
963     res = fig.savefig(*args, **kwargs)
964     fig.canvas.draw_idle()  # Need this if 'transparent=True', to reset colors.
965     return res
966 
967 
968 ## Putting things in figures ##
969 
970 
971 def figlegend(*args, **kwargs):
972     return gcf().legend(*args, **kwargs)
973 if Figure.legend.__doc__:
974     figlegend.__doc__ = Figure.legend.__doc__.replace("legend(", "figlegend(")
975 
976 
977 ## Axes ##
978 
979 @_docstring.dedent_interpd
980 def axes(arg=None, **kwargs):
981     """
982     Add an Axes to the current figure and make it the current Axes.
983 
984     Call signatures::
985 
986         plt.axes()
987         plt.axes(rect, projection=None, polar=False, **kwargs)
988         plt.axes(ax)
989 
990     Parameters
991     ----------
992     arg : None or 4-tuple
993         The exact behavior of this function depends on the type:
994 
995         - *None*: A new full window Axes is added using
996           ``subplot(**kwargs)``.
997         - 4-tuple of floats *rect* = ``[left, bottom, width, height]``.
998           A new Axes is added with dimensions *rect* in normalized
999           (0, 1) units using `~.Figure.add_axes` on the current figure.
1000 
1001     projection : {None, 'aitoff', 'hammer', 'lambert', 'mollweide', \
1002 'polar', 'rectilinear', str}, optional
1003         The projection type of the `~.axes.Axes`. *str* is the name of
1004         a custom projection, see `~matplotlib.projections`. The default
1005         None results in a 'rectilinear' projection.
1006 
1007     polar : bool, default: False
1008         If True, equivalent to projection='polar'.
1009 
1010     sharex, sharey : `~.axes.Axes`, optional
1011         Share the x or y `~matplotlib.axis` with sharex and/or sharey.
1012         The axis will have the same limits, ticks, and scale as the axis
1013         of the shared Axes.
1014 
1015     label : str
1016         A label for the returned Axes.
1017 
1018     Returns
1019     -------
1020     `~.axes.Axes`, or a subclass of `~.axes.Axes`
1021         The returned axes class depends on the projection used. It is
1022         `~.axes.Axes` if rectilinear projection is used and
1023         `.projections.polar.PolarAxes` if polar projection is used.
1024 
1025     Other Parameters
1026     ----------------
1027     **kwargs
1028         This method also takes the keyword arguments for
1029         the returned Axes class. The keyword arguments for the
1030         rectilinear Axes class `~.axes.Axes` can be found in
1031         the following table but there might also be other keyword
1032         arguments if another projection is used, see the actual Axes
1033         class.
1034 
1035         %(Axes:kwdoc)s
1036 
1037     Notes
1038     -----
1039     If the figure already has an Axes with key (*args*,
1040     *kwargs*) then it will simply make that axes current and
1041     return it.  This behavior is deprecated. Meanwhile, if you do
1042     not want this behavior (i.e., you want to force the creation of a
1043     new axes), you must use a unique set of args and kwargs.  The Axes
1044     *label* attribute has been exposed for this purpose: if you want
1045     two Axes that are otherwise identical to be added to the figure,
1046     make sure you give them unique labels.
1047 
1048     See Also
1049     --------
1050     .Figure.add_axes
1051     .pyplot.subplot
1052     .Figure.add_subplot
1053     .Figure.subplots
1054     .pyplot.subplots
1055 
1056     Examples
1057     --------
1058     ::
1059 
1060         # Creating a new full window Axes
1061         plt.axes()
1062 
1063         # Creating a new Axes with specified dimensions and a grey background
1064         plt.axes((left, bottom, width, height), facecolor='grey')
1065     """
1066     fig = gcf()
1067     pos = kwargs.pop('position', None)
1068     if arg is None:
1069         if pos is None:
1070             return fig.add_subplot(**kwargs)
1071         else:
1072             return fig.add_axes(pos, **kwargs)
1073     else:
1074         return fig.add_axes(arg, **kwargs)
1075 
1076 
1077 def delaxes(ax=None):
1078     """
1079     Remove an `~.axes.Axes` (defaulting to the current axes) from its figure.
1080     """
1081     if ax is None:
1082         ax = gca()
1083     ax.remove()
1084 
1085 
1086 def sca(ax):
1087     """
1088     Set the current Axes to *ax* and the current Figure to the parent of *ax*.
1089     """
1090     figure(ax.figure)
1091     ax.figure.sca(ax)
1092 
1093 
1094 def cla():
1095     """Clear the current axes."""
1096     # Not generated via boilerplate.py to allow a different docstring.
1097     return gca().cla()
1098 
1099 
1100 ## More ways of creating axes ##
1101 
1102 @_docstring.dedent_interpd
1103 def subplot(*args, **kwargs):
1104     """
1105     Add an Axes to the current figure or retrieve an existing Axes.
1106 
1107     This is a wrapper of `.Figure.add_subplot` which provides additional
1108     behavior when working with the implicit API (see the notes section).
1109 
1110     Call signatures::
1111 
1112        subplot(nrows, ncols, index, **kwargs)
1113        subplot(pos, **kwargs)
1114        subplot(**kwargs)
1115        subplot(ax)
1116 
1117     Parameters
1118     ----------
1119     *args : int, (int, int, *index*), or `.SubplotSpec`, default: (1, 1, 1)
1120         The position of the subplot described by one of
1121 
1122         - Three integers (*nrows*, *ncols*, *index*). The subplot will take the
1123           *index* position on a grid with *nrows* rows and *ncols* columns.
1124           *index* starts at 1 in the upper left corner and increases to the
1125           right. *index* can also be a two-tuple specifying the (*first*,
1126           *last*) indices (1-based, and including *last*) of the subplot, e.g.,
1127           ``fig.add_subplot(3, 1, (1, 2))`` makes a subplot that spans the
1128           upper 2/3 of the figure.
1129         - A 3-digit integer. The digits are interpreted as if given separately
1130           as three single-digit integers, i.e. ``fig.add_subplot(235)`` is the
1131           same as ``fig.add_subplot(2, 3, 5)``. Note that this can only be used
1132           if there are no more than 9 subplots.
1133         - A `.SubplotSpec`.
1134 
1135     projection : {None, 'aitoff', 'hammer', 'lambert', 'mollweide', \
1136 'polar', 'rectilinear', str}, optional
1137         The projection type of the subplot (`~.axes.Axes`). *str* is the name
1138         of a custom projection, see `~matplotlib.projections`. The default
1139         None results in a 'rectilinear' projection.
1140 
1141     polar : bool, default: False
1142         If True, equivalent to projection='polar'.
1143 
1144     sharex, sharey : `~.axes.Axes`, optional
1145         Share the x or y `~matplotlib.axis` with sharex and/or sharey. The
1146         axis will have the same limits, ticks, and scale as the axis of the
1147         shared axes.
1148 
1149     label : str
1150         A label for the returned axes.
1151 
1152     Returns
1153     -------
1154     `.axes.SubplotBase`, or another subclass of `~.axes.Axes`
1155 
1156         The axes of the subplot. The returned axes base class depends on
1157         the projection used. It is `~.axes.Axes` if rectilinear projection
1158         is used and `.projections.polar.PolarAxes` if polar projection
1159         is used. The returned axes is then a subplot subclass of the
1160         base class.
1161 
1162     Other Parameters
1163     ----------------
1164     **kwargs
1165         This method also takes the keyword arguments for the returned axes
1166         base class; except for the *figure* argument. The keyword arguments
1167         for the rectilinear base class `~.axes.Axes` can be found in
1168         the following table but there might also be other keyword
1169         arguments if another projection is used.
1170 
1171         %(Axes:kwdoc)s
1172 
1173     Notes
1174     -----
1175     Creating a new Axes will delete any pre-existing Axes that
1176     overlaps with it beyond sharing a boundary::
1177 
1178         import matplotlib.pyplot as plt
1179         # plot a line, implicitly creating a subplot(111)
1180         plt.plot([1, 2, 3])
1181         # now create a subplot which represents the top plot of a grid
1182         # with 2 rows and 1 column. Since this subplot will overlap the
1183         # first, the plot (and its axes) previously created, will be removed
1184         plt.subplot(211)
1185 
1186     If you do not want this behavior, use the `.Figure.add_subplot` method
1187     or the `.pyplot.axes` function instead.
1188 
1189     If no *kwargs* are passed and there exists an Axes in the location
1190     specified by *args* then that Axes will be returned rather than a new
1191     Axes being created.
1192 
1193     If *kwargs* are passed and there exists an Axes in the location
1194     specified by *args*, the projection type is the same, and the
1195     *kwargs* match with the existing Axes, then the existing Axes is
1196     returned.  Otherwise a new Axes is created with the specified
1197     parameters.  We save a reference to the *kwargs* which we use
1198     for this comparison.  If any of the values in *kwargs* are
1199     mutable we will not detect the case where they are mutated.
1200     In these cases we suggest using `.Figure.add_subplot` and the
1201     explicit Axes API rather than the implicit pyplot API.
1202 
1203     See Also
1204     --------
1205     .Figure.add_subplot
1206     .pyplot.subplots
1207     .pyplot.axes
1208     .Figure.subplots
1209 
1210     Examples
1211     --------
1212     ::
1213 
1214         plt.subplot(221)
1215 
1216         # equivalent but more general
1217         ax1 = plt.subplot(2, 2, 1)
1218 
1219         # add a subplot with no frame
1220         ax2 = plt.subplot(222, frameon=False)
1221 
1222         # add a polar subplot
1223         plt.subplot(223, projection='polar')
1224 
1225         # add a red subplot that shares the x-axis with ax1
1226         plt.subplot(224, sharex=ax1, facecolor='red')
1227 
1228         # delete ax2 from the figure
1229         plt.delaxes(ax2)
1230 
1231         # add ax2 to the figure again
1232         plt.subplot(ax2)
1233 
1234         # make the first axes "current" again
1235         plt.subplot(221)
1236 
1237     """
1238     # Here we will only normalize `polar=True` vs `projection='polar'` and let
1239     # downstream code deal with the rest.
1240     unset = object()
1241     projection = kwargs.get('projection', unset)
1242     polar = kwargs.pop('polar', unset)
1243     if polar is not unset and polar:
1244         # if we got mixed messages from the user, raise
1245         if projection is not unset and projection != 'polar':
1246             raise ValueError(
1247                 f"polar={polar}, yet projection={projection!r}. "
1248                 "Only one of these arguments should be supplied."
1249             )
1250         kwargs['projection'] = projection = 'polar'
1251 
1252     # if subplot called without arguments, create subplot(1, 1, 1)
1253     if len(args) == 0:
1254         args = (1, 1, 1)
1255 
1256     # This check was added because it is very easy to type subplot(1, 2, False)
1257     # when subplots(1, 2, False) was intended (sharex=False, that is). In most
1258     # cases, no error will ever occur, but mysterious behavior can result
1259     # because what was intended to be the sharex argument is instead treated as
1260     # a subplot index for subplot()
1261     if len(args) >= 3 and isinstance(args[2], bool):
1262         _api.warn_external("The subplot index argument to subplot() appears "
1263                            "to be a boolean. Did you intend to use "
1264                            "subplots()?")
1265     # Check for nrows and ncols, which are not valid subplot args:
1266     if 'nrows' in kwargs or 'ncols' in kwargs:
1267         raise TypeError("subplot() got an unexpected keyword argument 'ncols' "
1268                         "and/or 'nrows'.  Did you intend to call subplots()?")
1269 
1270     fig = gcf()
1271 
1272     # First, search for an existing subplot with a matching spec.
1273     key = SubplotSpec._from_subplot_args(fig, args)
1274 
1275     for ax in fig.axes:
1276         # if we found an Axes at the position sort out if we can re-use it
1277         if hasattr(ax, 'get_subplotspec') and ax.get_subplotspec() == key:
1278             # if the user passed no kwargs, re-use
1279             if kwargs == {}:
1280                 break
1281             # if the axes class and kwargs are identical, reuse
1282             elif ax._projection_init == fig._process_projection_requirements(
1283                 *args, **kwargs
1284             ):
1285                 break
1286     else:
1287         # we have exhausted the known Axes and none match, make a new one!
1288         ax = fig.add_subplot(*args, **kwargs)
1289 
1290     fig.sca(ax)
1291 
1292     axes_to_delete = [other for other in fig.axes
1293                       if other != ax and ax.bbox.fully_overlaps(other.bbox)]
1294     if axes_to_delete:
1295         _api.warn_deprecated(
1296             "3.6", message="Auto-removal of overlapping axes is deprecated "
1297             "since %(since)s and will be removed %(removal)s; explicitly call "
1298             "ax.remove() as needed.")
1299     for ax_to_del in axes_to_delete:
1300         delaxes(ax_to_del)
1301 
1302     return ax
1303 
1304 
1305 def subplots(nrows=1, ncols=1, *, sharex=False, sharey=False, squeeze=True,
1306              subplot_kw=None, gridspec_kw=None, **fig_kw):
1307     """
1308     Create a figure and a set of subplots.
1309 
1310     This utility wrapper makes it convenient to create common layouts of
1311     subplots, including the enclosing figure object, in a single call.
1312 
1313     Parameters
1314     ----------
1315     nrows, ncols : int, default: 1
1316         Number of rows/columns of the subplot grid.
1317 
1318     sharex, sharey : bool or {'none', 'all', 'row', 'col'}, default: False
1319         Controls sharing of properties among x (*sharex*) or y (*sharey*)
1320         axes:
1321 
1322         - True or 'all': x- or y-axis will be shared among all subplots.
1323         - False or 'none': each subplot x- or y-axis will be independent.
1324         - 'row': each subplot row will share an x- or y-axis.
1325         - 'col': each subplot column will share an x- or y-axis.
1326 
1327         When subplots have a shared x-axis along a column, only the x tick
1328         labels of the bottom subplot are created. Similarly, when subplots
1329         have a shared y-axis along a row, only the y tick labels of the first
1330         column subplot are created. To later turn other subplots' ticklabels
1331         on, use `~matplotlib.axes.Axes.tick_params`.
1332 
1333         When subplots have a shared axis that has units, calling
1334         `~matplotlib.axis.Axis.set_units` will update each axis with the
1335         new units.
1336 
1337     squeeze : bool, default: True
1338         - If True, extra dimensions are squeezed out from the returned
1339           array of `~matplotlib.axes.Axes`:
1340 
1341           - if only one subplot is constructed (nrows=ncols=1), the
1342             resulting single Axes object is returned as a scalar.
1343           - for Nx1 or 1xM subplots, the returned object is a 1D numpy
1344             object array of Axes objects.
1345           - for NxM, subplots with N>1 and M>1 are returned as a 2D array.
1346 
1347         - If False, no squeezing at all is done: the returned Axes object is
1348           always a 2D array containing Axes instances, even if it ends up
1349           being 1x1.
1350 
1351     subplot_kw : dict, optional
1352         Dict with keywords passed to the
1353         `~matplotlib.figure.Figure.add_subplot` call used to create each
1354         subplot.
1355 
1356     gridspec_kw : dict, optional
1357         Dict with keywords passed to the `~matplotlib.gridspec.GridSpec`
1358         constructor used to create the grid the subplots are placed on.
1359 
1360     **fig_kw
1361         All additional keyword arguments are passed to the
1362         `.pyplot.figure` call.
1363 
1364     Returns
1365     -------
1366     fig : `.Figure`
1367 
1368     ax : `~.axes.Axes` or array of Axes
1369         *ax* can be either a single `~.axes.Axes` object, or an array of Axes
1370         objects if more than one subplot was created.  The dimensions of the
1371         resulting array can be controlled with the squeeze keyword, see above.
1372 
1373         Typical idioms for handling the return value are::
1374 
1375             # using the variable ax for single a Axes
1376             fig, ax = plt.subplots()
1377 
1378             # using the variable axs for multiple Axes
1379             fig, axs = plt.subplots(2, 2)
1380 
1381             # using tuple unpacking for multiple Axes
1382             fig, (ax1, ax2) = plt.subplots(1, 2)
1383             fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2)
1384 
1385         The names ``ax`` and pluralized ``axs`` are preferred over ``axes``
1386         because for the latter it's not clear if it refers to a single
1387         `~.axes.Axes` instance or a collection of these.
1388 
1389     See Also
1390     --------
1391     .pyplot.figure
1392     .pyplot.subplot
1393     .pyplot.axes
1394     .Figure.subplots
1395     .Figure.add_subplot
1396 
1397     Examples
1398     --------
1399     ::
1400 
1401         # First create some toy data:
1402         x = np.linspace(0, 2*np.pi, 400)
1403         y = np.sin(x**2)
1404 
1405         # Create just a figure and only one subplot
1406         fig, ax = plt.subplots()
1407         ax.plot(x, y)
1408         ax.set_title('Simple plot')
1409 
1410         # Create two subplots and unpack the output array immediately
1411         f, (ax1, ax2) = plt.subplots(1, 2, sharey=True)
1412         ax1.plot(x, y)
1413         ax1.set_title('Sharing Y axis')
1414         ax2.scatter(x, y)
1415 
1416         # Create four polar axes and access them through the returned array
1417         fig, axs = plt.subplots(2, 2, subplot_kw=dict(projection="polar"))
1418         axs[0, 0].plot(x, y)
1419         axs[1, 1].scatter(x, y)
1420 
1421         # Share a X axis with each column of subplots
1422         plt.subplots(2, 2, sharex='col')
1423 
1424         # Share a Y axis with each row of subplots
1425         plt.subplots(2, 2, sharey='row')
1426 
1427         # Share both X and Y axes with all subplots
1428         plt.subplots(2, 2, sharex='all', sharey='all')
1429 
1430         # Note that this is the same as
1431         plt.subplots(2, 2, sharex=True, sharey=True)
1432 
1433         # Create figure number 10 with a single subplot
1434         # and clears it if it already exists.
1435         fig, ax = plt.subplots(num=10, clear=True)
1436 
1437     """
1438     fig = figure(**fig_kw)
1439     axs = fig.subplots(nrows=nrows, ncols=ncols, sharex=sharex, sharey=sharey,
1440                        squeeze=squeeze, subplot_kw=subplot_kw,
1441                        gridspec_kw=gridspec_kw)
1442     return fig, axs
1443 
1444 
1445 def subplot_mosaic(mosaic, *, sharex=False, sharey=False,
1446                    subplot_kw=None, gridspec_kw=None, empty_sentinel='.',
1447                    **fig_kw):
1448     """
1449     Build a layout of Axes based on ASCII art or nested lists.
1450 
1451     This is a helper function to build complex GridSpec layouts visually.
1452 
1453     .. note::
1454 
1455        This API is provisional and may be revised in the future based on
1456        early user feedback.
1457 
1458     See :doc:`/tutorials/provisional/mosaic`
1459     for an example and full API documentation
1460 
1461     Parameters
1462     ----------
1463     mosaic : list of list of {hashable or nested} or str
1464 
1465         A visual layout of how you want your Axes to be arranged
1466         labeled as strings.  For example ::
1467 
1468            x = [['A panel', 'A panel', 'edge'],
1469                 ['C panel', '.',       'edge']]
1470 
1471         produces 4 axes:
1472 
1473         - 'A panel' which is 1 row high and spans the first two columns
1474         - 'edge' which is 2 rows high and is on the right edge
1475         - 'C panel' which in 1 row and 1 column wide in the bottom left
1476         - a blank space 1 row and 1 column wide in the bottom center
1477 
1478         Any of the entries in the layout can be a list of lists
1479         of the same form to create nested layouts.
1480 
1481         If input is a str, then it must be of the form ::
1482 
1483           '''
1484           AAE
1485           C.E
1486           '''
1487 
1488         where each character is a column and each line is a row.
1489         This only allows only single character Axes labels and does
1490         not allow nesting but is very terse.
1491 
1492     sharex, sharey : bool, default: False
1493         If True, the x-axis (*sharex*) or y-axis (*sharey*) will be shared
1494         among all subplots.  In that case, tick label visibility and axis units
1495         behave as for `subplots`.  If False, each subplot's x- or y-axis will
1496         be independent.
1497 
1498     subplot_kw : dict, optional
1499         Dictionary with keywords passed to the `.Figure.add_subplot` call
1500         used to create each subplot.
1501 
1502     gridspec_kw : dict, optional
1503         Dictionary with keywords passed to the `.GridSpec` constructor used
1504         to create the grid the subplots are placed on.
1505 
1506     empty_sentinel : object, optional
1507         Entry in the layout to mean "leave this space empty".  Defaults
1508         to ``'.'``. Note, if *layout* is a string, it is processed via
1509         `inspect.cleandoc` to remove leading white space, which may
1510         interfere with using white-space as the empty sentinel.
1511 
1512     **fig_kw
1513         All additional keyword arguments are passed to the
1514         `.pyplot.figure` call.
1515 
1516     Returns
1517     -------
1518     fig : `.Figure`
1519        The new figure
1520 
1521     dict[label, Axes]
1522        A dictionary mapping the labels to the Axes objects.  The order of
1523        the axes is left-to-right and top-to-bottom of their position in the
1524        total layout.
1525 
1526     """
1527     fig = figure(**fig_kw)
1528     ax_dict = fig.subplot_mosaic(
1529         mosaic, sharex=sharex, sharey=sharey,
1530         subplot_kw=subplot_kw, gridspec_kw=gridspec_kw,
1531         empty_sentinel=empty_sentinel
1532     )
1533     return fig, ax_dict
1534 
1535 
1536 def subplot2grid(shape, loc, rowspan=1, colspan=1, fig=None, **kwargs):
1537     """
1538     Create a subplot at a specific location inside a regular grid.
1539 
1540     Parameters
1541     ----------
1542     shape : (int, int)
1543         Number of rows and of columns of the grid in which to place axis.
1544     loc : (int, int)
1545         Row number and column number of the axis location within the grid.
1546     rowspan : int, default: 1
1547         Number of rows for the axis to span downwards.
1548     colspan : int, default: 1
1549         Number of columns for the axis to span to the right.
1550     fig : `.Figure`, optional
1551         Figure to place the subplot in. Defaults to the current figure.
1552     **kwargs
1553         Additional keyword arguments are handed to `~.Figure.add_subplot`.
1554 
1555     Returns
1556     -------
1557     `.axes.SubplotBase`, or another subclass of `~.axes.Axes`
1558 
1559         The axes of the subplot.  The returned axes base class depends on the
1560         projection used.  It is `~.axes.Axes` if rectilinear projection is used
1561         and `.projections.polar.PolarAxes` if polar projection is used.  The
1562         returned axes is then a subplot subclass of the base class.
1563 
1564     Notes
1565     -----
1566     The following call ::
1567 
1568         ax = subplot2grid((nrows, ncols), (row, col), rowspan, colspan)
1569 
1570     is identical to ::
1571 
1572         fig = gcf()
1573         gs = fig.add_gridspec(nrows, ncols)
1574         ax = fig.add_subplot(gs[row:row+rowspan, col:col+colspan])
1575     """
1576 
1577     if fig is None:
1578         fig = gcf()
1579 
1580     rows, cols = shape
1581     gs = GridSpec._check_gridspec_exists(fig, rows, cols)
1582 
1583     subplotspec = gs.new_subplotspec(loc, rowspan=rowspan, colspan=colspan)
1584     ax = fig.add_subplot(subplotspec, **kwargs)
1585 
1586     axes_to_delete = [other for other in fig.axes
1587                       if other != ax and ax.bbox.fully_overlaps(other.bbox)]
1588     if axes_to_delete:
1589         _api.warn_deprecated(
1590             "3.6", message="Auto-removal of overlapping axes is deprecated "
1591             "since %(since)s and will be removed %(removal)s; explicitly call "
1592             "ax.remove() as needed.")
1593     for ax_to_del in axes_to_delete:
1594         delaxes(ax_to_del)
1595 
1596     return ax
1597 
1598 
1599 def twinx(ax=None):
1600     """
1601     Make and return a second axes that shares the *x*-axis.  The new axes will
1602     overlay *ax* (or the current axes if *ax* is *None*), and its ticks will be
1603     on the right.
1604 
1605     Examples
1606     --------
1607     :doc:`/gallery/subplots_axes_and_figures/two_scales`
1608     """
1609     if ax is None:
1610         ax = gca()
1611     ax1 = ax.twinx()
1612     return ax1
1613 
1614 
1615 def twiny(ax=None):
1616     """
1617     Make and return a second axes that shares the *y*-axis.  The new axes will
1618     overlay *ax* (or the current axes if *ax* is *None*), and its ticks will be
1619     on the top.
1620 
1621     Examples
1622     --------
1623     :doc:`/gallery/subplots_axes_and_figures/two_scales`
1624     """
1625     if ax is None:
1626         ax = gca()
1627     ax1 = ax.twiny()
1628     return ax1
1629 
1630 
1631 def subplot_tool(targetfig=None):
1632     """
1633     Launch a subplot tool window for a figure.
1634 
1635     Returns
1636     -------
1637     `matplotlib.widgets.SubplotTool`
1638     """
1639     if targetfig is None:
1640         targetfig = gcf()
1641     tb = targetfig.canvas.manager.toolbar
1642     if hasattr(tb, "configure_subplots"):  # toolbar2
1643         return tb.configure_subplots()
1644     elif hasattr(tb, "trigger_tool"):  # toolmanager
1645         return tb.trigger_tool("subplots")
1646     else:
1647         raise ValueError("subplot_tool can only be launched for figures with "
1648                          "an associated toolbar")
1649 
1650 
1651 def box(on=None):
1652     """
1653     Turn the axes box on or off on the current axes.
1654 
1655     Parameters
1656     ----------
1657     on : bool or None
1658         The new `~matplotlib.axes.Axes` box state. If ``None``, toggle
1659         the state.
1660 
1661     See Also
1662     --------
1663     :meth:`matplotlib.axes.Axes.set_frame_on`
1664     :meth:`matplotlib.axes.Axes.get_frame_on`
1665     """
1666     ax = gca()
1667     if on is None:
1668         on = not ax.get_frame_on()
1669     ax.set_frame_on(on)
1670 
1671 ## Axis ##
1672 
1673 
1674 def xlim(*args, **kwargs):
1675     """
1676     Get or set the x limits of the current axes.
1677 
1678     Call signatures::
1679 
1680         left, right = xlim()  # return the current xlim
1681         xlim((left, right))   # set the xlim to left, right
1682         xlim(left, right)     # set the xlim to left, right
1683 
1684     If you do not specify args, you can pass *left* or *right* as kwargs,
1685     i.e.::
1686 
1687         xlim(right=3)  # adjust the right leaving left unchanged
1688         xlim(left=1)  # adjust the left leaving right unchanged
1689 
1690     Setting limits turns autoscaling off for the x-axis.
1691 
1692     Returns
1693     -------
1694     left, right
1695         A tuple of the new x-axis limits.
1696 
1697     Notes
1698     -----
1699     Calling this function with no arguments (e.g. ``xlim()``) is the pyplot
1700     equivalent of calling `~.Axes.get_xlim` on the current axes.
1701     Calling this function with arguments is the pyplot equivalent of calling
1702     `~.Axes.set_xlim` on the current axes. All arguments are passed though.
1703     """
1704     ax = gca()
1705     if not args and not kwargs:
1706         return ax.get_xlim()
1707     ret = ax.set_xlim(*args, **kwargs)
1708     return ret
1709 
1710 
1711 def ylim(*args, **kwargs):
1712     """
1713     Get or set the y-limits of the current axes.
1714 
1715     Call signatures::
1716 
1717         bottom, top = ylim()  # return the current ylim
1718         ylim((bottom, top))   # set the ylim to bottom, top
1719         ylim(bottom, top)     # set the ylim to bottom, top
1720 
1721     If you do not specify args, you can alternatively pass *bottom* or
1722     *top* as kwargs, i.e.::
1723 
1724         ylim(top=3)  # adjust the top leaving bottom unchanged
1725         ylim(bottom=1)  # adjust the bottom leaving top unchanged
1726 
1727     Setting limits turns autoscaling off for the y-axis.
1728 
1729     Returns
1730     -------
1731     bottom, top
1732         A tuple of the new y-axis limits.
1733 
1734     Notes
1735     -----
1736     Calling this function with no arguments (e.g. ``ylim()``) is the pyplot
1737     equivalent of calling `~.Axes.get_ylim` on the current axes.
1738     Calling this function with arguments is the pyplot equivalent of calling
1739     `~.Axes.set_ylim` on the current axes. All arguments are passed though.
1740     """
1741     ax = gca()
1742     if not args and not kwargs:
1743         return ax.get_ylim()
1744     ret = ax.set_ylim(*args, **kwargs)
1745     return ret
1746 
1747 
1748 def xticks(ticks=None, labels=None, **kwargs):
1749     """
1750     Get or set the current tick locations and labels of the x-axis.
1751 
1752     Pass no arguments to return the current values without modifying them.
1753 
1754     Parameters
1755     ----------
1756     ticks : array-like, optional
1757         The list of xtick locations.  Passing an empty list removes all xticks.
1758     labels : array-like, optional
1759         The labels to place at the given *ticks* locations.  This argument can
1760         only be passed if *ticks* is passed as well.
1761     **kwargs
1762         `.Text` properties can be used to control the appearance of the labels.
1763 
1764     Returns
1765     -------
1766     locs
1767         The list of xtick locations.
1768     labels
1769         The list of xlabel `.Text` objects.
1770 
1771     Notes
1772     -----
1773     Calling this function with no arguments (e.g. ``xticks()``) is the pyplot
1774     equivalent of calling `~.Axes.get_xticks` and `~.Axes.get_xticklabels` on
1775     the current axes.
1776     Calling this function with arguments is the pyplot equivalent of calling
1777     `~.Axes.set_xticks` and `~.Axes.set_xticklabels` on the current axes.
1778 
1779     Examples
1780     --------
1781     >>> locs, labels = xticks()  # Get the current locations and labels.
1782     >>> xticks(np.arange(0, 1, step=0.2))  # Set label locations.
1783     >>> xticks(np.arange(3), ['Tom', 'Dick', 'Sue'])  # Set text labels.
1784     >>> xticks([0, 1, 2], ['January', 'February', 'March'],
1785     ...        rotation=20)  # Set text labels and properties.
1786     >>> xticks([])  # Disable xticks.
1787     """
1788     ax = gca()
1789 
1790     if ticks is None:
1791         locs = ax.get_xticks()
1792         if labels is not None:
1793             raise TypeError("xticks(): Parameter 'labels' can't be set "
1794                             "without setting 'ticks'")
1795     else:
1796         locs = ax.set_xticks(ticks)
1797 
1798     if labels is None:
1799         labels = ax.get_xticklabels()
1800         for l in labels:
1801             l._internal_update(kwargs)
1802     else:
1803         labels = ax.set_xticklabels(labels, **kwargs)
1804 
1805     return locs, labels
1806 
1807 
1808 def yticks(ticks=None, labels=None, **kwargs):
1809     """
1810     Get or set the current tick locations and labels of the y-axis.
1811 
1812     Pass no arguments to return the current values without modifying them.
1813 
1814     Parameters
1815     ----------
1816     ticks : array-like, optional
1817         The list of ytick locations.  Passing an empty list removes all yticks.
1818     labels : array-like, optional
1819         The labels to place at the given *ticks* locations.  This argument can
1820         only be passed if *ticks* is passed as well.
1821     **kwargs
1822         `.Text` properties can be used to control the appearance of the labels.
1823 
1824     Returns
1825     -------
1826     locs
1827         The list of ytick locations.
1828     labels
1829         The list of ylabel `.Text` objects.
1830 
1831     Notes
1832     -----
1833     Calling this function with no arguments (e.g. ``yticks()``) is the pyplot
1834     equivalent of calling `~.Axes.get_yticks` and `~.Axes.get_yticklabels` on
1835     the current axes.
1836     Calling this function with arguments is the pyplot equivalent of calling
1837     `~.Axes.set_yticks` and `~.Axes.set_yticklabels` on the current axes.
1838 
1839     Examples
1840     --------
1841     >>> locs, labels = yticks()  # Get the current locations and labels.
1842     >>> yticks(np.arange(0, 1, step=0.2))  # Set label locations.
1843     >>> yticks(np.arange(3), ['Tom', 'Dick', 'Sue'])  # Set text labels.
1844     >>> yticks([0, 1, 2], ['January', 'February', 'March'],
1845     ...        rotation=45)  # Set text labels and properties.
1846     >>> yticks([])  # Disable yticks.
1847     """
1848     ax = gca()
1849 
1850     if ticks is None:
1851         locs = ax.get_yticks()
1852         if labels is not None:
1853             raise TypeError("yticks(): Parameter 'labels' can't be set "
1854                             "without setting 'ticks'")
1855     else:
1856         locs = ax.set_yticks(ticks)
1857 
1858     if labels is None:
1859         labels = ax.get_yticklabels()
1860         for l in labels:
1861             l._internal_update(kwargs)
1862     else:
1863         labels = ax.set_yticklabels(labels, **kwargs)
1864 
1865     return locs, labels
1866 
1867 
1868 def rgrids(radii=None, labels=None, angle=None, fmt=None, **kwargs):
1869     """
1870     Get or set the radial gridlines on the current polar plot.
1871 
1872     Call signatures::
1873 
1874      lines, labels = rgrids()
1875      lines, labels = rgrids(radii, labels=None, angle=22.5, fmt=None, **kwargs)
1876 
1877     When called with no arguments, `.rgrids` simply returns the tuple
1878     (*lines*, *labels*). When called with arguments, the labels will
1879     appear at the specified radial distances and angle.
1880 
1881     Parameters
1882     ----------
1883     radii : tuple with floats
1884         The radii for the radial gridlines
1885 
1886     labels : tuple with strings or None
1887         The labels to use at each radial gridline. The
1888         `matplotlib.ticker.ScalarFormatter` will be used if None.
1889 
1890     angle : float
1891         The angular position of the radius labels in degrees.
1892 
1893     fmt : str or None
1894         Format string used in `matplotlib.ticker.FormatStrFormatter`.
1895         For example '%f'.
1896 
1897     Returns
1898     -------
1899     lines : list of `.lines.Line2D`
1900         The radial gridlines.
1901 
1902     labels : list of `.text.Text`
1903         The tick labels.
1904 
1905     Other Parameters
1906     ----------------
1907     **kwargs
1908         *kwargs* are optional `.Text` properties for the labels.
1909 
1910     See Also
1911     --------
1912     .pyplot.thetagrids
1913     .projections.polar.PolarAxes.set_rgrids
1914     .Axis.get_gridlines
1915     .Axis.get_ticklabels
1916 
1917     Examples
1918     --------
1919     ::
1920 
1921       # set the locations of the radial gridlines
1922       lines, labels = rgrids( (0.25, 0.5, 1.0) )
1923 
1924       # set the locations and labels of the radial gridlines
1925       lines, labels = rgrids( (0.25, 0.5, 1.0), ('Tom', 'Dick', 'Harry' ))
1926     """
1927     ax = gca()
1928     if not isinstance(ax, PolarAxes):
1929         raise RuntimeError('rgrids only defined for polar axes')
1930     if all(p is None for p in [radii, labels, angle, fmt]) and not kwargs:
1931         lines = ax.yaxis.get_gridlines()
1932         labels = ax.yaxis.get_ticklabels()
1933     else:
1934         lines, labels = ax.set_rgrids(
1935             radii, labels=labels, angle=angle, fmt=fmt, **kwargs)
1936     return lines, labels
1937 
1938 
1939 def thetagrids(angles=None, labels=None, fmt=None, **kwargs):
1940     """
1941     Get or set the theta gridlines on the current polar plot.
1942 
1943     Call signatures::
1944 
1945      lines, labels = thetagrids()
1946      lines, labels = thetagrids(angles, labels=None, fmt=None, **kwargs)
1947 
1948     When called with no arguments, `.thetagrids` simply returns the tuple
1949     (*lines*, *labels*). When called with arguments, the labels will
1950     appear at the specified angles.
1951 
1952     Parameters
1953     ----------
1954     angles : tuple with floats, degrees
1955         The angles of the theta gridlines.
1956 
1957     labels : tuple with strings or None
1958         The labels to use at each radial gridline. The
1959         `.projections.polar.ThetaFormatter` will be used if None.
1960 
1961     fmt : str or None
1962         Format string used in `matplotlib.ticker.FormatStrFormatter`.
1963         For example '%f'. Note that the angle in radians will be used.
1964 
1965     Returns
1966     -------
1967     lines : list of `.lines.Line2D`
1968         The theta gridlines.
1969 
1970     labels : list of `.text.Text`
1971         The tick labels.
1972 
1973     Other Parameters
1974     ----------------
1975     **kwargs
1976         *kwargs* are optional `.Text` properties for the labels.
1977 
1978     See Also
1979     --------
1980     .pyplot.rgrids
1981     .projections.polar.PolarAxes.set_thetagrids
1982     .Axis.get_gridlines
1983     .Axis.get_ticklabels
1984 
1985     Examples
1986     --------
1987     ::
1988 
1989       # set the locations of the angular gridlines
1990       lines, labels = thetagrids(range(45, 360, 90))
1991 
1992       # set the locations and labels of the angular gridlines
1993       lines, labels = thetagrids(range(45, 360, 90), ('NE', 'NW', 'SW', 'SE'))
1994     """
1995     ax = gca()
1996     if not isinstance(ax, PolarAxes):
1997         raise RuntimeError('thetagrids only defined for polar axes')
1998     if all(param is None for param in [angles, labels, fmt]) and not kwargs:
1999         lines = ax.xaxis.get_ticklines()
2000         labels = ax.xaxis.get_ticklabels()
2001     else:
2002         lines, labels = ax.set_thetagrids(angles,
2003                                           labels=labels, fmt=fmt, **kwargs)
2004     return lines, labels
2005 
2006 
2007 ## Plotting Info ##
2008 
2009 
2010 def plotting():
2011     pass
2012 
2013 
2014 def get_plot_commands():
2015     """
2016     Get a sorted list of all of the plotting commands.
2017     """
2018     # This works by searching for all functions in this module and removing
2019     # a few hard-coded exclusions, as well as all of the colormap-setting
2020     # functions, and anything marked as private with a preceding underscore.
2021     exclude = {'colormaps', 'colors', 'connect', 'disconnect',
2022                'get_plot_commands', 'get_current_fig_manager', 'ginput',
2023                'plotting', 'waitforbuttonpress'}
2024     exclude |= set(colormaps)
2025     this_module = inspect.getmodule(get_plot_commands)
2026     return sorted(
2027         name for name, obj in globals().items()
2028         if not name.startswith('_') and name not in exclude
2029            and inspect.isfunction(obj)
2030            and inspect.getmodule(obj) is this_module)
2031 
2032 
2033 def _setup_pyplot_info_docstrings():
2034     """
2035     Setup the docstring of `plotting` and of the colormap-setting functions.
2036 
2037     These must be done after the entire module is imported, so it is called
2038     from the end of this module, which is generated by boilerplate.py.
2039     """
2040     commands = get_plot_commands()
2041 
2042     first_sentence = re.compile(r"(?:\s*).+?\.(?:\s+|$)", flags=re.DOTALL)
2043 
2044     # Collect the first sentence of the docstring for all of the
2045     # plotting commands.
2046     rows = []
2047     max_name = len("Function")
2048     max_summary = len("Description")
2049     for name in commands:
2050         doc = globals()[name].__doc__
2051         summary = ''
2052         if doc is not None:
2053             match = first_sentence.match(doc)
2054             if match is not None:
2055                 summary = inspect.cleandoc(match.group(0)).replace('\n', ' ')
2056         name = '`%s`' % name
2057         rows.append([name, summary])
2058         max_name = max(max_name, len(name))
2059         max_summary = max(max_summary, len(summary))
2060 
2061     separator = '=' * max_name + ' ' + '=' * max_summary
2062     lines = [
2063         separator,
2064         '{:{}} {:{}}'.format('Function', max_name, 'Description', max_summary),
2065         separator,
2066     ] + [
2067         '{:{}} {:{}}'.format(name, max_name, summary, max_summary)
2068         for name, summary in rows
2069     ] + [
2070         separator,
2071     ]
2072     plotting.__doc__ = '\n'.join(lines)
2073 
2074     for cm_name in colormaps:
2075         if cm_name in globals():
2076             globals()[cm_name].__doc__ = f"""
2077     Set the colormap to {cm_name!r}.
2078 
2079     This changes the default colormap as well as the colormap of the current
2080     image if there is one. See ``help(colormaps)`` for more information.
2081     """
2082 
2083 
2084 ## Plotting part 1: manually generated functions and wrappers ##
2085 
2086 
2087 @_copy_docstring_and_deprecators(Figure.colorbar)
2088 def colorbar(mappable=None, cax=None, ax=None, **kwargs):
2089     if mappable is None:
2090         mappable = gci()
2091         if mappable is None:
2092             raise RuntimeError('No mappable was found to use for colorbar '
2093                                'creation. First define a mappable such as '
2094                                'an image (with imshow) or a contour set ('
2095                                'with contourf).')
2096     ret = gcf().colorbar(mappable, cax=cax, ax=ax, **kwargs)
2097     return ret
2098 
2099 
2100 def clim(vmin=None, vmax=None):
2101     """
2102     Set the color limits of the current image.
2103 
2104     If either *vmin* or *vmax* is None, the image min/max respectively
2105     will be used for color scaling.
2106 
2107     If you want to set the clim of multiple images, use
2108     `~.ScalarMappable.set_clim` on every image, for example::
2109 
2110       for im in gca().get_images():
2111           im.set_clim(0, 0.5)
2112 
2113     """
2114     im = gci()
2115     if im is None:
2116         raise RuntimeError('You must first define an image, e.g., with imshow')
2117 
2118     im.set_clim(vmin, vmax)
2119 
2120 
2121 def set_cmap(cmap):
2122     """
2123     Set the default colormap, and applies it to the current image if any.
2124 
2125     Parameters
2126     ----------
2127     cmap : `~matplotlib.colors.Colormap` or str
2128         A colormap instance or the name of a registered colormap.
2129 
2130     See Also
2131     --------
2132     colormaps
2133     matplotlib.cm.register_cmap
2134     matplotlib.cm.get_cmap
2135     """
2136     cmap = cm.get_cmap(cmap)
2137 
2138     rc('image', cmap=cmap.name)
2139     im = gci()
2140 
2141     if im is not None:
2142         im.set_cmap(cmap)
2143 
2144 
2145 @_copy_docstring_and_deprecators(matplotlib.image.imread)
2146 def imread(fname, format=None):
2147     return matplotlib.image.imread(fname, format)
2148 
2149 
2150 @_copy_docstring_and_deprecators(matplotlib.image.imsave)
2151 def imsave(fname, arr, **kwargs):
2152     return matplotlib.image.imsave(fname, arr, **kwargs)
2153 
2154 
2155 def matshow(A, fignum=None, **kwargs):
2156     """
2157     Display an array as a matrix in a new figure window.
2158 
2159     The origin is set at the upper left hand corner and rows (first
2160     dimension of the array) are displayed horizontally.  The aspect
2161     ratio of the figure window is that of the array, unless this would
2162     make an excessively short or narrow figure.
2163 
2164     Tick labels for the xaxis are placed on top.
2165 
2166     Parameters
2167     ----------
2168     A : 2D array-like
2169         The matrix to be displayed.
2170 
2171     fignum : None or int or False
2172         If *None*, create a new figure window with automatic numbering.
2173 
2174         If a nonzero integer, draw into the figure with the given number
2175         (create it if it does not exist).
2176 
2177         If 0, use the current axes (or create one if it does not exist).
2178 
2179         .. note::
2180 
2181            Because of how `.Axes.matshow` tries to set the figure aspect
2182            ratio to be the one of the array, strange things may happen if you
2183            reuse an existing figure.
2184 
2185     Returns
2186     -------
2187     `~matplotlib.image.AxesImage`
2188 
2189     Other Parameters
2190     ----------------
2191     **kwargs : `~matplotlib.axes.Axes.imshow` arguments
2192 
2193     """
2194     A = np.asanyarray(A)
2195     if fignum == 0:
2196         ax = gca()
2197     else:
2198         # Extract actual aspect ratio of array and make appropriately sized
2199         # figure.
2200         fig = figure(fignum, figsize=figaspect(A))
2201         ax = fig.add_axes([0.15, 0.09, 0.775, 0.775])
2202     im = ax.matshow(A, **kwargs)
2203     sci(im)
2204     return im
2205 
2206 
2207 def polar(*args, **kwargs):
2208     """
2209     Make a polar plot.
2210 
2211     call signature::
2212 
2213       polar(theta, r, **kwargs)
2214 
2215     Multiple *theta*, *r* arguments are supported, with format strings, as in
2216     `plot`.
2217     """
2218     # If an axis already exists, check if it has a polar projection
2219     if gcf().get_axes():
2220         ax = gca()
2221         if not isinstance(ax, PolarAxes):
2222             _api.warn_external('Trying to create polar plot on an Axes '
2223                                'that does not have a polar projection.')
2224     else:
2225         ax = axes(projection="polar")
2226     return ax.plot(*args, **kwargs)
2227 
2228 
2229 # If rcParams['backend_fallback'] is true, and an interactive backend is
2230 # requested, ignore rcParams['backend'] and force selection of a backend that
2231 # is compatible with the current running interactive framework.
2232 if (rcParams["backend_fallback"]
2233         and dict.__getitem__(rcParams, "backend") in (
2234             set(_interactive_bk) - {'WebAgg', 'nbAgg'})
2235         and cbook._get_running_interactive_framework()):
2236     dict.__setitem__(rcParams, "backend", rcsetup._auto_backend_sentinel)
2237 
2238 
2239 ################# REMAINING CONTENT GENERATED BY boilerplate.py ##############
2240 
2241 
2242 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2243 @_copy_docstring_and_deprecators(Figure.figimage)
2244 def figimage(
2245         X, xo=0, yo=0, alpha=None, norm=None, cmap=None, vmin=None,
2246         vmax=None, origin=None, resize=False, **kwargs):
2247     return gcf().figimage(
2248         X, xo=xo, yo=yo, alpha=alpha, norm=norm, cmap=cmap, vmin=vmin,
2249         vmax=vmax, origin=origin, resize=resize, **kwargs)
2250 
2251 
2252 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2253 @_copy_docstring_and_deprecators(Figure.text)
2254 def figtext(x, y, s, fontdict=None, **kwargs):
2255     return gcf().text(x, y, s, fontdict=fontdict, **kwargs)
2256 
2257 
2258 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2259 @_copy_docstring_and_deprecators(Figure.gca)
2260 def gca(**kwargs):
2261     return gcf().gca(**kwargs)
2262 
2263 
2264 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2265 @_copy_docstring_and_deprecators(Figure._gci)
2266 def gci():
2267     return gcf()._gci()
2268 
2269 
2270 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2271 @_copy_docstring_and_deprecators(Figure.ginput)
2272 def ginput(
2273         n=1, timeout=30, show_clicks=True,
2274         mouse_add=MouseButton.LEFT, mouse_pop=MouseButton.RIGHT,
2275         mouse_stop=MouseButton.MIDDLE):
2276     return gcf().ginput(
2277         n=n, timeout=timeout, show_clicks=show_clicks,
2278         mouse_add=mouse_add, mouse_pop=mouse_pop,
2279         mouse_stop=mouse_stop)
2280 
2281 
2282 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2283 @_copy_docstring_and_deprecators(Figure.subplots_adjust)
2284 def subplots_adjust(
2285         left=None, bottom=None, right=None, top=None, wspace=None,
2286         hspace=None):
2287     return gcf().subplots_adjust(
2288         left=left, bottom=bottom, right=right, top=top, wspace=wspace,
2289         hspace=hspace)
2290 
2291 
2292 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2293 @_copy_docstring_and_deprecators(Figure.suptitle)
2294 def suptitle(t, **kwargs):
2295     return gcf().suptitle(t, **kwargs)
2296 
2297 
2298 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2299 @_copy_docstring_and_deprecators(Figure.tight_layout)
2300 def tight_layout(*, pad=1.08, h_pad=None, w_pad=None, rect=None):
2301     return gcf().tight_layout(pad=pad, h_pad=h_pad, w_pad=w_pad, rect=rect)
2302 
2303 
2304 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2305 @_copy_docstring_and_deprecators(Figure.waitforbuttonpress)
2306 def waitforbuttonpress(timeout=-1):
2307     return gcf().waitforbuttonpress(timeout=timeout)
2308 
2309 
2310 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2311 @_copy_docstring_and_deprecators(Axes.acorr)
2312 def acorr(x, *, data=None, **kwargs):
2313     return gca().acorr(
2314         x, **({"data": data} if data is not None else {}), **kwargs)
2315 
2316 
2317 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2318 @_copy_docstring_and_deprecators(Axes.angle_spectrum)
2319 def angle_spectrum(
2320         x, Fs=None, Fc=None, window=None, pad_to=None, sides=None, *,
2321         data=None, **kwargs):
2322     return gca().angle_spectrum(
2323         x, Fs=Fs, Fc=Fc, window=window, pad_to=pad_to, sides=sides,
2324         **({"data": data} if data is not None else {}), **kwargs)
2325 
2326 
2327 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2328 @_copy_docstring_and_deprecators(Axes.annotate)
2329 def annotate(
2330         text, xy, xytext=None, xycoords='data', textcoords=None,
2331         arrowprops=None, annotation_clip=None, **kwargs):
2332     return gca().annotate(
2333         text, xy, xytext=xytext, xycoords=xycoords,
2334         textcoords=textcoords, arrowprops=arrowprops,
2335         annotation_clip=annotation_clip, **kwargs)
2336 
2337 
2338 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2339 @_copy_docstring_and_deprecators(Axes.arrow)
2340 def arrow(x, y, dx, dy, **kwargs):
2341     return gca().arrow(x, y, dx, dy, **kwargs)
2342 
2343 
2344 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2345 @_copy_docstring_and_deprecators(Axes.autoscale)
2346 def autoscale(enable=True, axis='both', tight=None):
2347     return gca().autoscale(enable=enable, axis=axis, tight=tight)
2348 
2349 
2350 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2351 @_copy_docstring_and_deprecators(Axes.axhline)
2352 def axhline(y=0, xmin=0, xmax=1, **kwargs):
2353     return gca().axhline(y=y, xmin=xmin, xmax=xmax, **kwargs)
2354 
2355 
2356 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2357 @_copy_docstring_and_deprecators(Axes.axhspan)
2358 def axhspan(ymin, ymax, xmin=0, xmax=1, **kwargs):
2359     return gca().axhspan(ymin, ymax, xmin=xmin, xmax=xmax, **kwargs)
2360 
2361 
2362 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2363 @_copy_docstring_and_deprecators(Axes.axis)
2364 def axis(*args, emit=True, **kwargs):
2365     return gca().axis(*args, emit=emit, **kwargs)
2366 
2367 
2368 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2369 @_copy_docstring_and_deprecators(Axes.axline)
2370 def axline(xy1, xy2=None, *, slope=None, **kwargs):
2371     return gca().axline(xy1, xy2=xy2, slope=slope, **kwargs)
2372 
2373 
2374 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2375 @_copy_docstring_and_deprecators(Axes.axvline)
2376 def axvline(x=0, ymin=0, ymax=1, **kwargs):
2377     return gca().axvline(x=x, ymin=ymin, ymax=ymax, **kwargs)
2378 
2379 
2380 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2381 @_copy_docstring_and_deprecators(Axes.axvspan)
2382 def axvspan(xmin, xmax, ymin=0, ymax=1, **kwargs):
2383     return gca().axvspan(xmin, xmax, ymin=ymin, ymax=ymax, **kwargs)
2384 
2385 
2386 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2387 @_copy_docstring_and_deprecators(Axes.bar)
2388 def bar(
2389         x, height, width=0.8, bottom=None, *, align='center',
2390         data=None, **kwargs):
2391     return gca().bar(
2392         x, height, width=width, bottom=bottom, align=align,
2393         **({"data": data} if data is not None else {}), **kwargs)
2394 
2395 
2396 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2397 @_copy_docstring_and_deprecators(Axes.barbs)
2398 def barbs(*args, data=None, **kwargs):
2399     return gca().barbs(
2400         *args, **({"data": data} if data is not None else {}),
2401         **kwargs)
2402 
2403 
2404 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2405 @_copy_docstring_and_deprecators(Axes.barh)
2406 def barh(y, width, height=0.8, left=None, *, align='center', **kwargs):
2407     return gca().barh(
2408         y, width, height=height, left=left, align=align, **kwargs)
2409 
2410 
2411 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2412 @_copy_docstring_and_deprecators(Axes.bar_label)
2413 def bar_label(
2414         container, labels=None, *, fmt='%g', label_type='edge',
2415         padding=0, **kwargs):
2416     return gca().bar_label(
2417         container, labels=labels, fmt=fmt, label_type=label_type,
2418         padding=padding, **kwargs)
2419 
2420 
2421 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2422 @_copy_docstring_and_deprecators(Axes.boxplot)
2423 def boxplot(
2424         x, notch=None, sym=None, vert=None, whis=None,
2425         positions=None, widths=None, patch_artist=None,
2426         bootstrap=None, usermedians=None, conf_intervals=None,
2427         meanline=None, showmeans=None, showcaps=None, showbox=None,
2428         showfliers=None, boxprops=None, labels=None, flierprops=None,
2429         medianprops=None, meanprops=None, capprops=None,
2430         whiskerprops=None, manage_ticks=True, autorange=False,
2431         zorder=None, capwidths=None, *, data=None):
2432     return gca().boxplot(
2433         x, notch=notch, sym=sym, vert=vert, whis=whis,
2434         positions=positions, widths=widths, patch_artist=patch_artist,
2435         bootstrap=bootstrap, usermedians=usermedians,
2436         conf_intervals=conf_intervals, meanline=meanline,
2437         showmeans=showmeans, showcaps=showcaps, showbox=showbox,
2438         showfliers=showfliers, boxprops=boxprops, labels=labels,
2439         flierprops=flierprops, medianprops=medianprops,
2440         meanprops=meanprops, capprops=capprops,
2441         whiskerprops=whiskerprops, manage_ticks=manage_ticks,
2442         autorange=autorange, zorder=zorder, capwidths=capwidths,
2443         **({"data": data} if data is not None else {}))
2444 
2445 
2446 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2447 @_copy_docstring_and_deprecators(Axes.broken_barh)
2448 def broken_barh(xranges, yrange, *, data=None, **kwargs):
2449     return gca().broken_barh(
2450         xranges, yrange,
2451         **({"data": data} if data is not None else {}), **kwargs)
2452 
2453 
2454 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2455 @_copy_docstring_and_deprecators(Axes.clabel)
2456 def clabel(CS, levels=None, **kwargs):
2457     return gca().clabel(CS, levels=levels, **kwargs)
2458 
2459 
2460 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2461 @_copy_docstring_and_deprecators(Axes.cohere)
2462 def cohere(
2463         x, y, NFFT=256, Fs=2, Fc=0, detrend=mlab.detrend_none,
2464         window=mlab.window_hanning, noverlap=0, pad_to=None,
2465         sides='default', scale_by_freq=None, *, data=None, **kwargs):
2466     return gca().cohere(
2467         x, y, NFFT=NFFT, Fs=Fs, Fc=Fc, detrend=detrend, window=window,
2468         noverlap=noverlap, pad_to=pad_to, sides=sides,
2469         scale_by_freq=scale_by_freq,
2470         **({"data": data} if data is not None else {}), **kwargs)
2471 
2472 
2473 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2474 @_copy_docstring_and_deprecators(Axes.contour)
2475 def contour(*args, data=None, **kwargs):
2476     __ret = gca().contour(
2477         *args, **({"data": data} if data is not None else {}),
2478         **kwargs)
2479     if __ret._A is not None: sci(__ret)  # noqa
2480     return __ret
2481 
2482 
2483 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2484 @_copy_docstring_and_deprecators(Axes.contourf)
2485 def contourf(*args, data=None, **kwargs):
2486     __ret = gca().contourf(
2487         *args, **({"data": data} if data is not None else {}),
2488         **kwargs)
2489     if __ret._A is not None: sci(__ret)  # noqa
2490     return __ret
2491 
2492 
2493 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2494 @_copy_docstring_and_deprecators(Axes.csd)
2495 def csd(
2496         x, y, NFFT=None, Fs=None, Fc=None, detrend=None, window=None,
2497         noverlap=None, pad_to=None, sides=None, scale_by_freq=None,
2498         return_line=None, *, data=None, **kwargs):
2499     return gca().csd(
2500         x, y, NFFT=NFFT, Fs=Fs, Fc=Fc, detrend=detrend, window=window,
2501         noverlap=noverlap, pad_to=pad_to, sides=sides,
2502         scale_by_freq=scale_by_freq, return_line=return_line,
2503         **({"data": data} if data is not None else {}), **kwargs)
2504 
2505 
2506 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2507 @_copy_docstring_and_deprecators(Axes.errorbar)
2508 def errorbar(
2509         x, y, yerr=None, xerr=None, fmt='', ecolor=None,
2510         elinewidth=None, capsize=None, barsabove=False, lolims=False,
2511         uplims=False, xlolims=False, xuplims=False, errorevery=1,
2512         capthick=None, *, data=None, **kwargs):
2513     return gca().errorbar(
2514         x, y, yerr=yerr, xerr=xerr, fmt=fmt, ecolor=ecolor,
2515         elinewidth=elinewidth, capsize=capsize, barsabove=barsabove,
2516         lolims=lolims, uplims=uplims, xlolims=xlolims,
2517         xuplims=xuplims, errorevery=errorevery, capthick=capthick,
2518         **({"data": data} if data is not None else {}), **kwargs)
2519 
2520 
2521 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2522 @_copy_docstring_and_deprecators(Axes.eventplot)
2523 def eventplot(
2524         positions, orientation='horizontal', lineoffsets=1,
2525         linelengths=1, linewidths=None, colors=None,
2526         linestyles='solid', *, data=None, **kwargs):
2527     return gca().eventplot(
2528         positions, orientation=orientation, lineoffsets=lineoffsets,
2529         linelengths=linelengths, linewidths=linewidths, colors=colors,
2530         linestyles=linestyles,
2531         **({"data": data} if data is not None else {}), **kwargs)
2532 
2533 
2534 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2535 @_copy_docstring_and_deprecators(Axes.fill)
2536 def fill(*args, data=None, **kwargs):
2537     return gca().fill(
2538         *args, **({"data": data} if data is not None else {}),
2539         **kwargs)
2540 
2541 
2542 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2543 @_copy_docstring_and_deprecators(Axes.fill_between)
2544 def fill_between(
2545         x, y1, y2=0, where=None, interpolate=False, step=None, *,
2546         data=None, **kwargs):
2547     return gca().fill_between(
2548         x, y1, y2=y2, where=where, interpolate=interpolate, step=step,
2549         **({"data": data} if data is not None else {}), **kwargs)
2550 
2551 
2552 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2553 @_copy_docstring_and_deprecators(Axes.fill_betweenx)
2554 def fill_betweenx(
2555         y, x1, x2=0, where=None, step=None, interpolate=False, *,
2556         data=None, **kwargs):
2557     return gca().fill_betweenx(
2558         y, x1, x2=x2, where=where, step=step, interpolate=interpolate,
2559         **({"data": data} if data is not None else {}), **kwargs)
2560 
2561 
2562 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2563 @_copy_docstring_and_deprecators(Axes.grid)
2564 def grid(visible=None, which='major', axis='both', **kwargs):
2565     return gca().grid(visible=visible, which=which, axis=axis, **kwargs)
2566 
2567 
2568 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2569 @_copy_docstring_and_deprecators(Axes.hexbin)
2570 def hexbin(
2571         x, y, C=None, gridsize=100, bins=None, xscale='linear',
2572         yscale='linear', extent=None, cmap=None, norm=None, vmin=None,
2573         vmax=None, alpha=None, linewidths=None, edgecolors='face',
2574         reduce_C_function=np.mean, mincnt=None, marginals=False, *,
2575         data=None, **kwargs):
2576     __ret = gca().hexbin(
2577         x, y, C=C, gridsize=gridsize, bins=bins, xscale=xscale,
2578         yscale=yscale, extent=extent, cmap=cmap, norm=norm, vmin=vmin,
2579         vmax=vmax, alpha=alpha, linewidths=linewidths,
2580         edgecolors=edgecolors, reduce_C_function=reduce_C_function,
2581         mincnt=mincnt, marginals=marginals,
2582         **({"data": data} if data is not None else {}), **kwargs)
2583     sci(__ret)
2584     return __ret
2585 
2586 
2587 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2588 @_copy_docstring_and_deprecators(Axes.hist)
2589 def hist(
2590         x, bins=None, range=None, density=False, weights=None,
2591         cumulative=False, bottom=None, histtype='bar', align='mid',
2592         orientation='vertical', rwidth=None, log=False, color=None,
2593         label=None, stacked=False, *, data=None, **kwargs):
2594     return gca().hist(
2595         x, bins=bins, range=range, density=density, weights=weights,
2596         cumulative=cumulative, bottom=bottom, histtype=histtype,
2597         align=align, orientation=orientation, rwidth=rwidth, log=log,
2598         color=color, label=label, stacked=stacked,
2599         **({"data": data} if data is not None else {}), **kwargs)
2600 
2601 
2602 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2603 @_copy_docstring_and_deprecators(Axes.stairs)
2604 def stairs(
2605         values, edges=None, *, orientation='vertical', baseline=0,
2606         fill=False, data=None, **kwargs):
2607     return gca().stairs(
2608         values, edges=edges, orientation=orientation,
2609         baseline=baseline, fill=fill,
2610         **({"data": data} if data is not None else {}), **kwargs)
2611 
2612 
2613 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2614 @_copy_docstring_and_deprecators(Axes.hist2d)
2615 def hist2d(
2616         x, y, bins=10, range=None, density=False, weights=None,
2617         cmin=None, cmax=None, *, data=None, **kwargs):
2618     __ret = gca().hist2d(
2619         x, y, bins=bins, range=range, density=density,
2620         weights=weights, cmin=cmin, cmax=cmax,
2621         **({"data": data} if data is not None else {}), **kwargs)
2622     sci(__ret[-1])
2623     return __ret
2624 
2625 
2626 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2627 @_copy_docstring_and_deprecators(Axes.hlines)
2628 def hlines(
2629         y, xmin, xmax, colors=None, linestyles='solid', label='', *,
2630         data=None, **kwargs):
2631     return gca().hlines(
2632         y, xmin, xmax, colors=colors, linestyles=linestyles,
2633         label=label, **({"data": data} if data is not None else {}),
2634         **kwargs)
2635 
2636 
2637 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2638 @_copy_docstring_and_deprecators(Axes.imshow)
2639 def imshow(
2640         X, cmap=None, norm=None, aspect=None, interpolation=None,
2641         alpha=None, vmin=None, vmax=None, origin=None, extent=None, *,
2642         interpolation_stage=None, filternorm=True, filterrad=4.0,
2643         resample=None, url=None, data=None, **kwargs):
2644     __ret = gca().imshow(
2645         X, cmap=cmap, norm=norm, aspect=aspect,
2646         interpolation=interpolation, alpha=alpha, vmin=vmin,
2647         vmax=vmax, origin=origin, extent=extent,
2648         interpolation_stage=interpolation_stage,
2649         filternorm=filternorm, filterrad=filterrad, resample=resample,
2650         url=url, **({"data": data} if data is not None else {}),
2651         **kwargs)
2652     sci(__ret)
2653     return __ret
2654 
2655 
2656 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2657 @_copy_docstring_and_deprecators(Axes.legend)
2658 def legend(*args, **kwargs):
2659     return gca().legend(*args, **kwargs)
2660 
2661 
2662 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2663 @_copy_docstring_and_deprecators(Axes.locator_params)
2664 def locator_params(axis='both', tight=None, **kwargs):
2665     return gca().locator_params(axis=axis, tight=tight, **kwargs)
2666 
2667 
2668 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2669 @_copy_docstring_and_deprecators(Axes.loglog)
2670 def loglog(*args, **kwargs):
2671     return gca().loglog(*args, **kwargs)
2672 
2673 
2674 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2675 @_copy_docstring_and_deprecators(Axes.magnitude_spectrum)
2676 def magnitude_spectrum(
2677         x, Fs=None, Fc=None, window=None, pad_to=None, sides=None,
2678         scale=None, *, data=None, **kwargs):
2679     return gca().magnitude_spectrum(
2680         x, Fs=Fs, Fc=Fc, window=window, pad_to=pad_to, sides=sides,
2681         scale=scale, **({"data": data} if data is not None else {}),
2682         **kwargs)
2683 
2684 
2685 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2686 @_copy_docstring_and_deprecators(Axes.margins)
2687 def margins(*margins, x=None, y=None, tight=True):
2688     return gca().margins(*margins, x=x, y=y, tight=tight)
2689 
2690 
2691 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2692 @_copy_docstring_and_deprecators(Axes.minorticks_off)
2693 def minorticks_off():
2694     return gca().minorticks_off()
2695 
2696 
2697 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2698 @_copy_docstring_and_deprecators(Axes.minorticks_on)
2699 def minorticks_on():
2700     return gca().minorticks_on()
2701 
2702 
2703 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2704 @_copy_docstring_and_deprecators(Axes.pcolor)
2705 def pcolor(
2706         *args, shading=None, alpha=None, norm=None, cmap=None,
2707         vmin=None, vmax=None, data=None, **kwargs):
2708     __ret = gca().pcolor(
2709         *args, shading=shading, alpha=alpha, norm=norm, cmap=cmap,
2710         vmin=vmin, vmax=vmax,
2711         **({"data": data} if data is not None else {}), **kwargs)
2712     sci(__ret)
2713     return __ret
2714 
2715 
2716 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2717 @_copy_docstring_and_deprecators(Axes.pcolormesh)
2718 def pcolormesh(
2719         *args, alpha=None, norm=None, cmap=None, vmin=None,
2720         vmax=None, shading=None, antialiased=False, data=None,
2721         **kwargs):
2722     __ret = gca().pcolormesh(
2723         *args, alpha=alpha, norm=norm, cmap=cmap, vmin=vmin,
2724         vmax=vmax, shading=shading, antialiased=antialiased,
2725         **({"data": data} if data is not None else {}), **kwargs)
2726     sci(__ret)
2727     return __ret
2728 
2729 
2730 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2731 @_copy_docstring_and_deprecators(Axes.phase_spectrum)
2732 def phase_spectrum(
2733         x, Fs=None, Fc=None, window=None, pad_to=None, sides=None, *,
2734         data=None, **kwargs):
2735     return gca().phase_spectrum(
2736         x, Fs=Fs, Fc=Fc, window=window, pad_to=pad_to, sides=sides,
2737         **({"data": data} if data is not None else {}), **kwargs)
2738 
2739 
2740 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2741 @_copy_docstring_and_deprecators(Axes.pie)
2742 def pie(
2743         x, explode=None, labels=None, colors=None, autopct=None,
2744         pctdistance=0.6, shadow=False, labeldistance=1.1,
2745         startangle=0, radius=1, counterclock=True, wedgeprops=None,
2746         textprops=None, center=(0, 0), frame=False,
2747         rotatelabels=False, *, normalize=True, data=None):
2748     return gca().pie(
2749         x, explode=explode, labels=labels, colors=colors,
2750         autopct=autopct, pctdistance=pctdistance, shadow=shadow,
2751         labeldistance=labeldistance, startangle=startangle,
2752         radius=radius, counterclock=counterclock,
2753         wedgeprops=wedgeprops, textprops=textprops, center=center,
2754         frame=frame, rotatelabels=rotatelabels, normalize=normalize,
2755         **({"data": data} if data is not None else {}))
2756 
2757 
2758 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2759 @_copy_docstring_and_deprecators(Axes.plot)
2760 def plot(*args, scalex=True, scaley=True, data=None, **kwargs):
2761     return gca().plot(
2762         *args, scalex=scalex, scaley=scaley,
2763         **({"data": data} if data is not None else {}), **kwargs)
2764 
2765 
2766 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2767 @_copy_docstring_and_deprecators(Axes.plot_date)
2768 def plot_date(
2769         x, y, fmt='o', tz=None, xdate=True, ydate=False, *,
2770         data=None, **kwargs):
2771     return gca().plot_date(
2772         x, y, fmt=fmt, tz=tz, xdate=xdate, ydate=ydate,
2773         **({"data": data} if data is not None else {}), **kwargs)
2774 
2775 
2776 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2777 @_copy_docstring_and_deprecators(Axes.psd)
2778 def psd(
2779         x, NFFT=None, Fs=None, Fc=None, detrend=None, window=None,
2780         noverlap=None, pad_to=None, sides=None, scale_by_freq=None,
2781         return_line=None, *, data=None, **kwargs):
2782     return gca().psd(
2783         x, NFFT=NFFT, Fs=Fs, Fc=Fc, detrend=detrend, window=window,
2784         noverlap=noverlap, pad_to=pad_to, sides=sides,
2785         scale_by_freq=scale_by_freq, return_line=return_line,
2786         **({"data": data} if data is not None else {}), **kwargs)
2787 
2788 
2789 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2790 @_copy_docstring_and_deprecators(Axes.quiver)
2791 def quiver(*args, data=None, **kwargs):
2792     __ret = gca().quiver(
2793         *args, **({"data": data} if data is not None else {}),
2794         **kwargs)
2795     sci(__ret)
2796     return __ret
2797 
2798 
2799 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2800 @_copy_docstring_and_deprecators(Axes.quiverkey)
2801 def quiverkey(Q, X, Y, U, label, **kwargs):
2802     return gca().quiverkey(Q, X, Y, U, label, **kwargs)
2803 
2804 
2805 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2806 @_copy_docstring_and_deprecators(Axes.scatter)
2807 def scatter(
2808         x, y, s=None, c=None, marker=None, cmap=None, norm=None,
2809         vmin=None, vmax=None, alpha=None, linewidths=None, *,
2810         edgecolors=None, plotnonfinite=False, data=None, **kwargs):
2811     __ret = gca().scatter(
2812         x, y, s=s, c=c, marker=marker, cmap=cmap, norm=norm,
2813         vmin=vmin, vmax=vmax, alpha=alpha, linewidths=linewidths,
2814         edgecolors=edgecolors, plotnonfinite=plotnonfinite,
2815         **({"data": data} if data is not None else {}), **kwargs)
2816     sci(__ret)
2817     return __ret
2818 
2819 
2820 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2821 @_copy_docstring_and_deprecators(Axes.semilogx)
2822 def semilogx(*args, **kwargs):
2823     return gca().semilogx(*args, **kwargs)
2824 
2825 
2826 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2827 @_copy_docstring_and_deprecators(Axes.semilogy)
2828 def semilogy(*args, **kwargs):
2829     return gca().semilogy(*args, **kwargs)
2830 
2831 
2832 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2833 @_copy_docstring_and_deprecators(Axes.specgram)
2834 def specgram(
2835         x, NFFT=None, Fs=None, Fc=None, detrend=None, window=None,
2836         noverlap=None, cmap=None, xextent=None, pad_to=None,
2837         sides=None, scale_by_freq=None, mode=None, scale=None,
2838         vmin=None, vmax=None, *, data=None, **kwargs):
2839     __ret = gca().specgram(
2840         x, NFFT=NFFT, Fs=Fs, Fc=Fc, detrend=detrend, window=window,
2841         noverlap=noverlap, cmap=cmap, xextent=xextent, pad_to=pad_to,
2842         sides=sides, scale_by_freq=scale_by_freq, mode=mode,
2843         scale=scale, vmin=vmin, vmax=vmax,
2844         **({"data": data} if data is not None else {}), **kwargs)
2845     sci(__ret[-1])
2846     return __ret
2847 
2848 
2849 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2850 @_copy_docstring_and_deprecators(Axes.spy)
2851 def spy(
2852         Z, precision=0, marker=None, markersize=None, aspect='equal',
2853         origin='upper', **kwargs):
2854     __ret = gca().spy(
2855         Z, precision=precision, marker=marker, markersize=markersize,
2856         aspect=aspect, origin=origin, **kwargs)
2857     if isinstance(__ret, cm.ScalarMappable): sci(__ret)  # noqa
2858     return __ret
2859 
2860 
2861 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2862 @_copy_docstring_and_deprecators(Axes.stackplot)
2863 def stackplot(
2864         x, *args, labels=(), colors=None, baseline='zero', data=None,
2865         **kwargs):
2866     return gca().stackplot(
2867         x, *args, labels=labels, colors=colors, baseline=baseline,
2868         **({"data": data} if data is not None else {}), **kwargs)
2869 
2870 
2871 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2872 @_copy_docstring_and_deprecators(Axes.stem)
2873 def stem(
2874         *args, linefmt=None, markerfmt=None, basefmt=None, bottom=0,
2875         label=None, use_line_collection=True, orientation='vertical',
2876         data=None):
2877     return gca().stem(
2878         *args, linefmt=linefmt, markerfmt=markerfmt, basefmt=basefmt,
2879         bottom=bottom, label=label,
2880         use_line_collection=use_line_collection,
2881         orientation=orientation,
2882         **({"data": data} if data is not None else {}))
2883 
2884 
2885 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2886 @_copy_docstring_and_deprecators(Axes.step)
2887 def step(x, y, *args, where='pre', data=None, **kwargs):
2888     return gca().step(
2889         x, y, *args, where=where,
2890         **({"data": data} if data is not None else {}), **kwargs)
2891 
2892 
2893 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2894 @_copy_docstring_and_deprecators(Axes.streamplot)
2895 def streamplot(
2896         x, y, u, v, density=1, linewidth=None, color=None, cmap=None,
2897         norm=None, arrowsize=1, arrowstyle='-|>', minlength=0.1,
2898         transform=None, zorder=None, start_points=None, maxlength=4.0,
2899         integration_direction='both', broken_streamlines=True, *,
2900         data=None):
2901     __ret = gca().streamplot(
2902         x, y, u, v, density=density, linewidth=linewidth, color=color,
2903         cmap=cmap, norm=norm, arrowsize=arrowsize,
2904         arrowstyle=arrowstyle, minlength=minlength,
2905         transform=transform, zorder=zorder, start_points=start_points,
2906         maxlength=maxlength,
2907         integration_direction=integration_direction,
2908         broken_streamlines=broken_streamlines,
2909         **({"data": data} if data is not None else {}))
2910     sci(__ret.lines)
2911     return __ret
2912 
2913 
2914 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2915 @_copy_docstring_and_deprecators(Axes.table)
2916 def table(
2917         cellText=None, cellColours=None, cellLoc='right',
2918         colWidths=None, rowLabels=None, rowColours=None,
2919         rowLoc='left', colLabels=None, colColours=None,
2920         colLoc='center', loc='bottom', bbox=None, edges='closed',
2921         **kwargs):
2922     return gca().table(
2923         cellText=cellText, cellColours=cellColours, cellLoc=cellLoc,
2924         colWidths=colWidths, rowLabels=rowLabels,
2925         rowColours=rowColours, rowLoc=rowLoc, colLabels=colLabels,
2926         colColours=colColours, colLoc=colLoc, loc=loc, bbox=bbox,
2927         edges=edges, **kwargs)
2928 
2929 
2930 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2931 @_copy_docstring_and_deprecators(Axes.text)
2932 def text(x, y, s, fontdict=None, **kwargs):
2933     return gca().text(x, y, s, fontdict=fontdict, **kwargs)
2934 
2935 
2936 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2937 @_copy_docstring_and_deprecators(Axes.tick_params)
2938 def tick_params(axis='both', **kwargs):
2939     return gca().tick_params(axis=axis, **kwargs)
2940 
2941 
2942 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2943 @_copy_docstring_and_deprecators(Axes.ticklabel_format)
2944 def ticklabel_format(
2945         *, axis='both', style='', scilimits=None, useOffset=None,
2946         useLocale=None, useMathText=None):
2947     return gca().ticklabel_format(
2948         axis=axis, style=style, scilimits=scilimits,
2949         useOffset=useOffset, useLocale=useLocale,
2950         useMathText=useMathText)
2951 
2952 
2953 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2954 @_copy_docstring_and_deprecators(Axes.tricontour)
2955 def tricontour(*args, **kwargs):
2956     __ret = gca().tricontour(*args, **kwargs)
2957     if __ret._A is not None: sci(__ret)  # noqa
2958     return __ret
2959 
2960 
2961 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2962 @_copy_docstring_and_deprecators(Axes.tricontourf)
2963 def tricontourf(*args, **kwargs):
2964     __ret = gca().tricontourf(*args, **kwargs)
2965     if __ret._A is not None: sci(__ret)  # noqa
2966     return __ret
2967 
2968 
2969 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2970 @_copy_docstring_and_deprecators(Axes.tripcolor)
2971 def tripcolor(
2972         *args, alpha=1.0, norm=None, cmap=None, vmin=None, vmax=None,
2973         shading='flat', facecolors=None, **kwargs):
2974     __ret = gca().tripcolor(
2975         *args, alpha=alpha, norm=norm, cmap=cmap, vmin=vmin,
2976         vmax=vmax, shading=shading, facecolors=facecolors, **kwargs)
2977     sci(__ret)
2978     return __ret
2979 
2980 
2981 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2982 @_copy_docstring_and_deprecators(Axes.triplot)
2983 def triplot(*args, **kwargs):
2984     return gca().triplot(*args, **kwargs)
2985 
2986 
2987 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2988 @_copy_docstring_and_deprecators(Axes.violinplot)
2989 def violinplot(
2990         dataset, positions=None, vert=True, widths=0.5,
2991         showmeans=False, showextrema=True, showmedians=False,
2992         quantiles=None, points=100, bw_method=None, *, data=None):
2993     return gca().violinplot(
2994         dataset, positions=positions, vert=vert, widths=widths,
2995         showmeans=showmeans, showextrema=showextrema,
2996         showmedians=showmedians, quantiles=quantiles, points=points,
2997         bw_method=bw_method,
2998         **({"data": data} if data is not None else {}))
2999 
3000 
3001 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3002 @_copy_docstring_and_deprecators(Axes.vlines)
3003 def vlines(
3004         x, ymin, ymax, colors=None, linestyles='solid', label='', *,
3005         data=None, **kwargs):
3006     return gca().vlines(
3007         x, ymin, ymax, colors=colors, linestyles=linestyles,
3008         label=label, **({"data": data} if data is not None else {}),
3009         **kwargs)
3010 
3011 
3012 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3013 @_copy_docstring_and_deprecators(Axes.xcorr)
3014 def xcorr(
3015         x, y, normed=True, detrend=mlab.detrend_none, usevlines=True,
3016         maxlags=10, *, data=None, **kwargs):
3017     return gca().xcorr(
3018         x, y, normed=normed, detrend=detrend, usevlines=usevlines,
3019         maxlags=maxlags,
3020         **({"data": data} if data is not None else {}), **kwargs)
3021 
3022 
3023 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3024 @_copy_docstring_and_deprecators(Axes._sci)
3025 def sci(im):
3026     return gca()._sci(im)
3027 
3028 
3029 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3030 @_copy_docstring_and_deprecators(Axes.set_title)
3031 def title(label, fontdict=None, loc=None, pad=None, *, y=None, **kwargs):
3032     return gca().set_title(
3033         label, fontdict=fontdict, loc=loc, pad=pad, y=y, **kwargs)
3034 
3035 
3036 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3037 @_copy_docstring_and_deprecators(Axes.set_xlabel)
3038 def xlabel(xlabel, fontdict=None, labelpad=None, *, loc=None, **kwargs):
3039     return gca().set_xlabel(
3040         xlabel, fontdict=fontdict, labelpad=labelpad, loc=loc,
3041         **kwargs)
3042 
3043 
3044 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3045 @_copy_docstring_and_deprecators(Axes.set_ylabel)
3046 def ylabel(ylabel, fontdict=None, labelpad=None, *, loc=None, **kwargs):
3047     return gca().set_ylabel(
3048         ylabel, fontdict=fontdict, labelpad=labelpad, loc=loc,
3049         **kwargs)
3050 
3051 
3052 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3053 @_copy_docstring_and_deprecators(Axes.set_xscale)
3054 def xscale(value, **kwargs):
3055     return gca().set_xscale(value, **kwargs)
3056 
3057 
3058 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3059 @_copy_docstring_and_deprecators(Axes.set_yscale)
3060 def yscale(value, **kwargs):
3061     return gca().set_yscale(value, **kwargs)
3062 
3063 
3064 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3065 def autumn(): set_cmap('autumn')
3066 def bone(): set_cmap('bone')
3067 def cool(): set_cmap('cool')
3068 def copper(): set_cmap('copper')
3069 def flag(): set_cmap('flag')
3070 def gray(): set_cmap('gray')
3071 def hot(): set_cmap('hot')
3072 def hsv(): set_cmap('hsv')
3073 def jet(): set_cmap('jet')
3074 def pink(): set_cmap('pink')
3075 def prism(): set_cmap('prism')
3076 def spring(): set_cmap('spring')
3077 def summer(): set_cmap('summer')
3078 def winter(): set_cmap('winter')
3079 def magma(): set_cmap('magma')
3080 def inferno(): set_cmap('inferno')
3081 def plasma(): set_cmap('plasma')
3082 def viridis(): set_cmap('viridis')
3083 def nipy_spectral(): set_cmap('nipy_spectral')
3084 
3085 
3086 _setup_pyplot_info_docstrings()

</code><intended_behavior>This method should be extended or adjusted to correctly recognize and handle `SubFigure` objects. When `num` is a `SubFigure`, instead of attempting (and failing) to convert it to an integer, the method should either navigate to its parent figure or directly manage the `SubFigure` without raising a type error. This change will allow `plt.sca()` to be used with axes that are part of subfigures, aligning with the intended seamless usage between figures and axes across different contexts in Matplotlib.</intended_behavior>]
2025-10-15 20:26:16.540 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-15 20:26:16.540 | INFO     | Search-only: skipping patch selection
2025-10-15 20:26:16.661 | INFO     | Task matplotlib__matplotlib-22991 completed successfully.
2025-10-15 20:26:16.662 | INFO     | No patch generated. You can try running ACR again.
