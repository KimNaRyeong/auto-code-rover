[
    {
        "rel_file_path": "lib/matplotlib/pyplot.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/matplotlib__matplotlib/setup_matplotlib__matplotlib__3.5/lib/matplotlib/pyplot.py",
        "start": 1,
        "end": 3086,
        "class_name": null,
        "method_name": null,
        "code": "1 # Note: The first part of this file can be modified in place, but the latter\n2 # part is autogenerated by the boilerplate.py script.\n3 \n4 \"\"\"\n5 `matplotlib.pyplot` is a state-based interface to matplotlib. It provides\n6 an implicit,  MATLAB-like, way of plotting.  It also opens figures on your\n7 screen, and acts as the figure GUI manager.\n8 \n9 pyplot is mainly intended for interactive plots and simple cases of\n10 programmatic plot generation::\n11 \n12     import numpy as np\n13     import matplotlib.pyplot as plt\n14 \n15     x = np.arange(0, 5, 0.1)\n16     y = np.sin(x)\n17     plt.plot(x, y)\n18 \n19 The explicit object-oriented API is recommended for complex plots, though\n20 pyplot is still usually used to create the figure and often the axes in the\n21 figure. See `.pyplot.figure`, `.pyplot.subplots`, and\n22 `.pyplot.subplot_mosaic` to create figures, and\n23 :doc:`Axes API <../axes_api>` for the plotting methods on an Axes::\n24 \n25     import numpy as np\n26     import matplotlib.pyplot as plt\n27 \n28     x = np.arange(0, 5, 0.1)\n29     y = np.sin(x)\n30     fig, ax = plt.subplots()\n31     ax.plot(x, y)\n32 \n33 \n34 See :ref:`api_interfaces` for an explanation of the tradeoffs between the\n35 implicit and explicit interfaces.\n36 \"\"\"\n37 \n38 from enum import Enum\n39 import functools\n40 import importlib\n41 import inspect\n42 import logging\n43 from numbers import Number\n44 import re\n45 import sys\n46 import time\n47 try:\n48     import threading\n49 except ImportError:\n50     import dummy_threading as threading\n51 \n52 from cycler import cycler\n53 import matplotlib\n54 import matplotlib.colorbar\n55 import matplotlib.image\n56 from matplotlib import _api\n57 from matplotlib import rcsetup, style\n58 from matplotlib import _pylab_helpers, interactive\n59 from matplotlib import cbook\n60 from matplotlib import _docstring\n61 from matplotlib.backend_bases import FigureCanvasBase, MouseButton\n62 from matplotlib.figure import Figure, figaspect\n63 from matplotlib.gridspec import GridSpec, SubplotSpec\n64 from matplotlib import rcParams, rcParamsDefault, get_backend, rcParamsOrig\n65 from matplotlib.rcsetup import interactive_bk as _interactive_bk\n66 from matplotlib.artist import Artist\n67 from matplotlib.axes import Axes, Subplot\n68 from matplotlib.projections import PolarAxes\n69 from matplotlib import mlab  # for detrend_none, window_hanning\n70 from matplotlib.scale import get_scale_names\n71 \n72 from matplotlib import cm\n73 from matplotlib.cm import _colormaps as colormaps, get_cmap, register_cmap\n74 from matplotlib.colors import _color_sequences as color_sequences\n75 \n76 import numpy as np\n77 \n78 # We may not need the following imports here:\n79 from matplotlib.colors import Normalize\n80 from matplotlib.lines import Line2D\n81 from matplotlib.text import Text, Annotation\n82 from matplotlib.patches import Polygon, Rectangle, Circle, Arrow\n83 from matplotlib.widgets import Button, Slider, Widget\n84 \n85 from .ticker import (\n86     TickHelper, Formatter, FixedFormatter, NullFormatter, FuncFormatter,\n87     FormatStrFormatter, ScalarFormatter, LogFormatter, LogFormatterExponent,\n88     LogFormatterMathtext, Locator, IndexLocator, FixedLocator, NullLocator,\n89     LinearLocator, LogLocator, AutoLocator, MultipleLocator, MaxNLocator)\n90 \n91 _log = logging.getLogger(__name__)\n92 \n93 \n94 def _copy_docstring_and_deprecators(method, func=None):\n95     if func is None:\n96         return functools.partial(_copy_docstring_and_deprecators, method)\n97     decorators = [_docstring.copy(method)]\n98     # Check whether the definition of *method* includes @_api.rename_parameter\n99     # or @_api.make_keyword_only decorators; if so, propagate them to the\n100     # pyplot wrapper as well.\n101     while getattr(method, \"__wrapped__\", None) is not None:\n102         decorator = _api.deprecation.DECORATORS.get(method)\n103         if decorator:\n104             decorators.append(decorator)\n105         method = method.__wrapped__\n106     for decorator in decorators[::-1]:\n107         func = decorator(func)\n108     return func\n109 \n110 \n111 ## Global ##\n112 \n113 \n114 # The state controlled by {,un}install_repl_displayhook().\n115 _ReplDisplayHook = Enum(\"_ReplDisplayHook\", [\"NONE\", \"PLAIN\", \"IPYTHON\"])\n116 _REPL_DISPLAYHOOK = _ReplDisplayHook.NONE\n117 \n118 \n119 def _draw_all_if_interactive():\n120     if matplotlib.is_interactive():\n121         draw_all()\n122 \n123 \n124 def install_repl_displayhook():\n125     \"\"\"\n126     Connect to the display hook of the current shell.\n127 \n128     The display hook gets called when the read-evaluate-print-loop (REPL) of\n129     the shell has finished the execution of a command. We use this callback\n130     to be able to automatically update a figure in interactive mode.\n131 \n132     This works both with IPython and with vanilla python shells.\n133     \"\"\"\n134     global _REPL_DISPLAYHOOK\n135 \n136     if _REPL_DISPLAYHOOK is _ReplDisplayHook.IPYTHON:\n137         return\n138 \n139     # See if we have IPython hooks around, if so use them.\n140     # Use ``sys.modules.get(name)`` rather than ``name in sys.modules`` as\n141     # entries can also have been explicitly set to None.\n142     mod_ipython = sys.modules.get(\"IPython\")\n143     if not mod_ipython:\n144         _REPL_DISPLAYHOOK = _ReplDisplayHook.PLAIN\n145         return\n146     ip = mod_ipython.get_ipython()\n147     if not ip:\n148         _REPL_DISPLAYHOOK = _ReplDisplayHook.PLAIN\n149         return\n150 \n151     ip.events.register(\"post_execute\", _draw_all_if_interactive)\n152     _REPL_DISPLAYHOOK = _ReplDisplayHook.IPYTHON\n153 \n154     from IPython.core.pylabtools import backend2gui\n155     # trigger IPython's eventloop integration, if available\n156     ipython_gui_name = backend2gui.get(get_backend())\n157     if ipython_gui_name:\n158         ip.enable_gui(ipython_gui_name)\n159 \n160 \n161 def uninstall_repl_displayhook():\n162     \"\"\"Disconnect from the display hook of the current shell.\"\"\"\n163     global _REPL_DISPLAYHOOK\n164     if _REPL_DISPLAYHOOK is _ReplDisplayHook.IPYTHON:\n165         from IPython import get_ipython\n166         ip = get_ipython()\n167         ip.events.unregister(\"post_execute\", _draw_all_if_interactive)\n168     _REPL_DISPLAYHOOK = _ReplDisplayHook.NONE\n169 \n170 \n171 draw_all = _pylab_helpers.Gcf.draw_all\n172 \n173 \n174 @_copy_docstring_and_deprecators(matplotlib.set_loglevel)\n175 def set_loglevel(*args, **kwargs):  # Ensure this appears in the pyplot docs.\n176     return matplotlib.set_loglevel(*args, **kwargs)\n177 \n178 \n179 @_copy_docstring_and_deprecators(Artist.findobj)\n180 def findobj(o=None, match=None, include_self=True):\n181     if o is None:\n182         o = gcf()\n183     return o.findobj(match, include_self=include_self)\n184 \n185 \n186 def _get_required_interactive_framework(backend_mod):\n187     if not hasattr(backend_mod.FigureCanvas, \"required_interactive_framework\"):\n188         _api.warn_deprecated(\n189             \"3.6\", name=\"Support for FigureCanvases without a \"\n190             \"required_interactive_framework attribute\")\n191         return None\n192     # Inline this once the deprecation elapses.\n193     return backend_mod.FigureCanvas.required_interactive_framework\n194 \n195 _backend_mod = None\n196 \n197 \n198 def _get_backend_mod():\n199     \"\"\"\n200     Ensure that a backend is selected and return it.\n201 \n202     This is currently private, but may be made public in the future.\n203     \"\"\"\n204     if _backend_mod is None:\n205         # Use __getitem__ here to avoid going through the fallback logic (which\n206         # will (re)import pyplot and then call switch_backend if we need to\n207         # resolve the auto sentinel)\n208         switch_backend(dict.__getitem__(rcParams, \"backend\"))\n209         # Just to be safe.  Interactive mode can be turned on without calling\n210         # `plt.ion()` so register it again here.  This is safe because multiple\n211         # calls to `install_repl_displayhook` are no-ops and the registered\n212         # function respects `mpl.is_interactive()` to determine if it should\n213         # trigger a draw.\n214         install_repl_displayhook()\n215     return _backend_mod\n216 \n217 \n218 def switch_backend(newbackend):\n219     \"\"\"\n220     Close all open figures and set the Matplotlib backend.\n221 \n222     The argument is case-insensitive.  Switching to an interactive backend is\n223     possible only if no event loop for another interactive backend has started.\n224     Switching to and from non-interactive backends is always possible.\n225 \n226     Parameters\n227     ----------\n228     newbackend : str\n229         The name of the backend to use.\n230     \"\"\"\n231     global _backend_mod\n232     # make sure the init is pulled up so we can assign to it later\n233     import matplotlib.backends\n234     close(\"all\")\n235 \n236     if newbackend is rcsetup._auto_backend_sentinel:\n237         current_framework = cbook._get_running_interactive_framework()\n238         mapping = {'qt': 'qtagg',\n239                    'gtk3': 'gtk3agg',\n240                    'gtk4': 'gtk4agg',\n241                    'wx': 'wxagg',\n242                    'tk': 'tkagg',\n243                    'macosx': 'macosx',\n244                    'headless': 'agg'}\n245 \n246         best_guess = mapping.get(current_framework, None)\n247         if best_guess is not None:\n248             candidates = [best_guess]\n249         else:\n250             candidates = []\n251         candidates += [\n252             \"macosx\", \"qtagg\", \"gtk4agg\", \"gtk3agg\", \"tkagg\", \"wxagg\"]\n253 \n254         # Don't try to fallback on the cairo-based backends as they each have\n255         # an additional dependency (pycairo) over the agg-based backend, and\n256         # are of worse quality.\n257         for candidate in candidates:\n258             try:\n259                 switch_backend(candidate)\n260             except ImportError:\n261                 continue\n262             else:\n263                 rcParamsOrig['backend'] = candidate\n264                 return\n265         else:\n266             # Switching to Agg should always succeed; if it doesn't, let the\n267             # exception propagate out.\n268             switch_backend(\"agg\")\n269             rcParamsOrig[\"backend\"] = \"agg\"\n270             return\n271 \n272     # Backends are implemented as modules, but \"inherit\" default method\n273     # implementations from backend_bases._Backend.  This is achieved by\n274     # creating a \"class\" that inherits from backend_bases._Backend and whose\n275     # body is filled with the module's globals.\n276 \n277     backend_name = cbook._backend_module_name(newbackend)\n278 \n279     class backend_mod(matplotlib.backend_bases._Backend):\n280         locals().update(vars(importlib.import_module(backend_name)))\n281 \n282     required_framework = _get_required_interactive_framework(backend_mod)\n283     if required_framework is not None:\n284         current_framework = cbook._get_running_interactive_framework()\n285         if (current_framework and required_framework\n286                 and current_framework != required_framework):\n287             raise ImportError(\n288                 \"Cannot load backend {!r} which requires the {!r} interactive \"\n289                 \"framework, as {!r} is currently running\".format(\n290                     newbackend, required_framework, current_framework))\n291 \n292     _log.debug(\"Loaded backend %s version %s.\",\n293                newbackend, backend_mod.backend_version)\n294 \n295     rcParams['backend'] = rcParamsDefault['backend'] = newbackend\n296     _backend_mod = backend_mod\n297     for func_name in [\"new_figure_manager\", \"draw_if_interactive\", \"show\"]:\n298         globals()[func_name].__signature__ = inspect.signature(\n299             getattr(backend_mod, func_name))\n300 \n301     # Need to keep a global reference to the backend for compatibility reasons.\n302     # See https://github.com/matplotlib/matplotlib/issues/6092\n303     matplotlib.backends.backend = newbackend\n304 \n305 \n306 def _warn_if_gui_out_of_main_thread():\n307     if (_get_required_interactive_framework(_get_backend_mod())\n308             and threading.current_thread() is not threading.main_thread()):\n309         _api.warn_external(\n310             \"Starting a Matplotlib GUI outside of the main thread will likely \"\n311             \"fail.\")\n312 \n313 \n314 # This function's signature is rewritten upon backend-load by switch_backend.\n315 def new_figure_manager(*args, **kwargs):\n316     \"\"\"Create a new figure manager instance.\"\"\"\n317     _warn_if_gui_out_of_main_thread()\n318     return _get_backend_mod().new_figure_manager(*args, **kwargs)\n319 \n320 \n321 # This function's signature is rewritten upon backend-load by switch_backend.\n322 def draw_if_interactive(*args, **kwargs):\n323     \"\"\"\n324     Redraw the current figure if in interactive mode.\n325 \n326     .. warning::\n327 \n328         End users will typically not have to call this function because the\n329         the interactive mode takes care of this.\n330     \"\"\"\n331     return _get_backend_mod().draw_if_interactive(*args, **kwargs)\n332 \n333 \n334 # This function's signature is rewritten upon backend-load by switch_backend.\n335 def show(*args, **kwargs):\n336     \"\"\"\n337     Display all open figures.\n338 \n339     Parameters\n340     ----------\n341     block : bool, optional\n342         Whether to wait for all figures to be closed before returning.\n343 \n344         If `True` block and run the GUI main loop until all figure windows\n345         are closed.\n346 \n347         If `False` ensure that all figure windows are displayed and return\n348         immediately.  In this case, you are responsible for ensuring\n349         that the event loop is running to have responsive figures.\n350 \n351         Defaults to True in non-interactive mode and to False in interactive\n352         mode (see `.pyplot.isinteractive`).\n353 \n354     See Also\n355     --------\n356     ion : Enable interactive mode, which shows / updates the figure after\n357           every plotting command, so that calling ``show()`` is not necessary.\n358     ioff : Disable interactive mode.\n359     savefig : Save the figure to an image file instead of showing it on screen.\n360 \n361     Notes\n362     -----\n363     **Saving figures to file and showing a window at the same time**\n364 \n365     If you want an image file as well as a user interface window, use\n366     `.pyplot.savefig` before `.pyplot.show`. At the end of (a blocking)\n367     ``show()`` the figure is closed and thus unregistered from pyplot. Calling\n368     `.pyplot.savefig` afterwards would save a new and thus empty figure. This\n369     limitation of command order does not apply if the show is non-blocking or\n370     if you keep a reference to the figure and use `.Figure.savefig`.\n371 \n372     **Auto-show in jupyter notebooks**\n373 \n374     The jupyter backends (activated via ``%matplotlib inline``,\n375     ``%matplotlib notebook``, or ``%matplotlib widget``), call ``show()`` at\n376     the end of every cell by default. Thus, you usually don't have to call it\n377     explicitly there.\n378     \"\"\"\n379     _warn_if_gui_out_of_main_thread()\n380     return _get_backend_mod().show(*args, **kwargs)\n381 \n382 \n383 def isinteractive():\n384     \"\"\"\n385     Return whether plots are updated after every plotting command.\n386 \n387     The interactive mode is mainly useful if you build plots from the command\n388     line and want to see the effect of each command while you are building the\n389     figure.\n390 \n391     In interactive mode:\n392 \n393     - newly created figures will be shown immediately;\n394     - figures will automatically redraw on change;\n395     - `.pyplot.show` will not block by default.\n396 \n397     In non-interactive mode:\n398 \n399     - newly created figures and changes to figures will not be reflected until\n400       explicitly asked to be;\n401     - `.pyplot.show` will block by default.\n402 \n403     See Also\n404     --------\n405     ion : Enable interactive mode.\n406     ioff : Disable interactive mode.\n407     show : Show all figures (and maybe block).\n408     pause : Show all figures, and block for a time.\n409     \"\"\"\n410     return matplotlib.is_interactive()\n411 \n412 \n413 class _IoffContext:\n414     \"\"\"\n415     Context manager for `.ioff`.\n416 \n417     The state is changed in ``__init__()`` instead of ``__enter__()``. The\n418     latter is a no-op. This allows using `.ioff` both as a function and\n419     as a context.\n420     \"\"\"\n421 \n422     def __init__(self):\n423         self.wasinteractive = isinteractive()\n424         matplotlib.interactive(False)\n425         uninstall_repl_displayhook()\n426 \n427     def __enter__(self):\n428         pass\n429 \n430     def __exit__(self, exc_type, exc_value, traceback):\n431         if self.wasinteractive:\n432             matplotlib.interactive(True)\n433             install_repl_displayhook()\n434         else:\n435             matplotlib.interactive(False)\n436             uninstall_repl_displayhook()\n437 \n438 \n439 class _IonContext:\n440     \"\"\"\n441     Context manager for `.ion`.\n442 \n443     The state is changed in ``__init__()`` instead of ``__enter__()``. The\n444     latter is a no-op. This allows using `.ion` both as a function and\n445     as a context.\n446     \"\"\"\n447 \n448     def __init__(self):\n449         self.wasinteractive = isinteractive()\n450         matplotlib.interactive(True)\n451         install_repl_displayhook()\n452 \n453     def __enter__(self):\n454         pass\n455 \n456     def __exit__(self, exc_type, exc_value, traceback):\n457         if not self.wasinteractive:\n458             matplotlib.interactive(False)\n459             uninstall_repl_displayhook()\n460         else:\n461             matplotlib.interactive(True)\n462             install_repl_displayhook()\n463 \n464 \n465 def ioff():\n466     \"\"\"\n467     Disable interactive mode.\n468 \n469     See `.pyplot.isinteractive` for more details.\n470 \n471     See Also\n472     --------\n473     ion : Enable interactive mode.\n474     isinteractive : Whether interactive mode is enabled.\n475     show : Show all figures (and maybe block).\n476     pause : Show all figures, and block for a time.\n477 \n478     Notes\n479     -----\n480     For a temporary change, this can be used as a context manager::\n481 \n482         # if interactive mode is on\n483         # then figures will be shown on creation\n484         plt.ion()\n485         # This figure will be shown immediately\n486         fig = plt.figure()\n487 \n488         with plt.ioff():\n489             # interactive mode will be off\n490             # figures will not automatically be shown\n491             fig2 = plt.figure()\n492             # ...\n493 \n494     To enable usage as a context manager, this function returns an\n495     ``_IoffContext`` object. The return value is not intended to be stored\n496     or accessed by the user.\n497     \"\"\"\n498     return _IoffContext()\n499 \n500 \n501 def ion():\n502     \"\"\"\n503     Enable interactive mode.\n504 \n505     See `.pyplot.isinteractive` for more details.\n506 \n507     See Also\n508     --------\n509     ioff : Disable interactive mode.\n510     isinteractive : Whether interactive mode is enabled.\n511     show : Show all figures (and maybe block).\n512     pause : Show all figures, and block for a time.\n513 \n514     Notes\n515     -----\n516     For a temporary change, this can be used as a context manager::\n517 \n518         # if interactive mode is off\n519         # then figures will not be shown on creation\n520         plt.ioff()\n521         # This figure will not be shown immediately\n522         fig = plt.figure()\n523 \n524         with plt.ion():\n525             # interactive mode will be on\n526             # figures will automatically be shown\n527             fig2 = plt.figure()\n528             # ...\n529 \n530     To enable usage as a context manager, this function returns an\n531     ``_IonContext`` object. The return value is not intended to be stored\n532     or accessed by the user.\n533     \"\"\"\n534     return _IonContext()\n535 \n536 \n537 def pause(interval):\n538     \"\"\"\n539     Run the GUI event loop for *interval* seconds.\n540 \n541     If there is an active figure, it will be updated and displayed before the\n542     pause, and the GUI event loop (if any) will run during the pause.\n543 \n544     This can be used for crude animation.  For more complex animation use\n545     :mod:`matplotlib.animation`.\n546 \n547     If there is no active figure, sleep for *interval* seconds instead.\n548 \n549     See Also\n550     --------\n551     matplotlib.animation : Proper animations\n552     show : Show all figures and optional block until all figures are closed.\n553     \"\"\"\n554     manager = _pylab_helpers.Gcf.get_active()\n555     if manager is not None:\n556         canvas = manager.canvas\n557         if canvas.figure.stale:\n558             canvas.draw_idle()\n559         show(block=False)\n560         canvas.start_event_loop(interval)\n561     else:\n562         time.sleep(interval)\n563 \n564 \n565 @_copy_docstring_and_deprecators(matplotlib.rc)\n566 def rc(group, **kwargs):\n567     matplotlib.rc(group, **kwargs)\n568 \n569 \n570 @_copy_docstring_and_deprecators(matplotlib.rc_context)\n571 def rc_context(rc=None, fname=None):\n572     return matplotlib.rc_context(rc, fname)\n573 \n574 \n575 @_copy_docstring_and_deprecators(matplotlib.rcdefaults)\n576 def rcdefaults():\n577     matplotlib.rcdefaults()\n578     if matplotlib.is_interactive():\n579         draw_all()\n580 \n581 \n582 # getp/get/setp are explicitly reexported so that they show up in pyplot docs.\n583 \n584 \n585 @_copy_docstring_and_deprecators(matplotlib.artist.getp)\n586 def getp(obj, *args, **kwargs):\n587     return matplotlib.artist.getp(obj, *args, **kwargs)\n588 \n589 \n590 @_copy_docstring_and_deprecators(matplotlib.artist.get)\n591 def get(obj, *args, **kwargs):\n592     return matplotlib.artist.get(obj, *args, **kwargs)\n593 \n594 \n595 @_copy_docstring_and_deprecators(matplotlib.artist.setp)\n596 def setp(obj, *args, **kwargs):\n597     return matplotlib.artist.setp(obj, *args, **kwargs)\n598 \n599 \n600 def xkcd(scale=1, length=100, randomness=2):\n601     \"\"\"\n602     Turn on `xkcd <https://xkcd.com/>`_ sketch-style drawing mode.  This will\n603     only have effect on things drawn after this function is called.\n604 \n605     For best results, the \"Humor Sans\" font should be installed: it is\n606     not included with Matplotlib.\n607 \n608     Parameters\n609     ----------\n610     scale : float, optional\n611         The amplitude of the wiggle perpendicular to the source line.\n612     length : float, optional\n613         The length of the wiggle along the line.\n614     randomness : float, optional\n615         The scale factor by which the length is shrunken or expanded.\n616 \n617     Notes\n618     -----\n619     This function works by a number of rcParams, so it will probably\n620     override others you have set before.\n621 \n622     If you want the effects of this function to be temporary, it can\n623     be used as a context manager, for example::\n624 \n625         with plt.xkcd():\n626             # This figure will be in XKCD-style\n627             fig1 = plt.figure()\n628             # ...\n629 \n630         # This figure will be in regular style\n631         fig2 = plt.figure()\n632     \"\"\"\n633     return _xkcd(scale, length, randomness)\n634 \n635 \n636 class _xkcd:\n637     # This cannot be implemented in terms of rc_context() because this needs to\n638     # work as a non-contextmanager too.\n639 \n640     def __init__(self, scale, length, randomness):\n641         self._orig = rcParams.copy()\n642 \n643         if rcParams['text.usetex']:\n644             raise RuntimeError(\n645                 \"xkcd mode is not compatible with text.usetex = True\")\n646 \n647         from matplotlib import patheffects\n648         rcParams.update({\n649             'font.family': ['xkcd', 'xkcd Script', 'Humor Sans', 'Comic Neue',\n650                             'Comic Sans MS'],\n651             'font.size': 14.0,\n652             'path.sketch': (scale, length, randomness),\n653             'path.effects': [\n654                 patheffects.withStroke(linewidth=4, foreground=\"w\")],\n655             'axes.linewidth': 1.5,\n656             'lines.linewidth': 2.0,\n657             'figure.facecolor': 'white',\n658             'grid.linewidth': 0.0,\n659             'axes.grid': False,\n660             'axes.unicode_minus': False,\n661             'axes.edgecolor': 'black',\n662             'xtick.major.size': 8,\n663             'xtick.major.width': 3,\n664             'ytick.major.size': 8,\n665             'ytick.major.width': 3,\n666         })\n667 \n668     def __enter__(self):\n669         return self\n670 \n671     def __exit__(self, *args):\n672         dict.update(rcParams, self._orig)\n673 \n674 \n675 ## Figures ##\n676 \n677 @_api.make_keyword_only(\"3.6\", \"facecolor\")\n678 def figure(num=None,  # autoincrement if None, else integer from 1-N\n679            figsize=None,  # defaults to rc figure.figsize\n680            dpi=None,  # defaults to rc figure.dpi\n681            facecolor=None,  # defaults to rc figure.facecolor\n682            edgecolor=None,  # defaults to rc figure.edgecolor\n683            frameon=True,\n684            FigureClass=Figure,\n685            clear=False,\n686            **kwargs\n687            ):\n688     \"\"\"\n689     Create a new figure, or activate an existing figure.\n690 \n691     Parameters\n692     ----------\n693     num : int or str or `.Figure`, optional\n694         A unique identifier for the figure.\n695 \n696         If a figure with that identifier already exists, this figure is made\n697         active and returned. An integer refers to the ``Figure.number``\n698         attribute, a string refers to the figure label.\n699 \n700         If there is no figure with the identifier or *num* is not given, a new\n701         figure is created, made active and returned.  If *num* is an int, it\n702         will be used for the ``Figure.number`` attribute, otherwise, an\n703         auto-generated integer value is used (starting at 1 and incremented\n704         for each new figure). If *num* is a string, the figure label and the\n705         window title is set to this value.\n706 \n707     figsize : (float, float), default: :rc:`figure.figsize`\n708         Width, height in inches.\n709 \n710     dpi : float, default: :rc:`figure.dpi`\n711         The resolution of the figure in dots-per-inch.\n712 \n713     facecolor : color, default: :rc:`figure.facecolor`\n714         The background color.\n715 \n716     edgecolor : color, default: :rc:`figure.edgecolor`\n717         The border color.\n718 \n719     frameon : bool, default: True\n720         If False, suppress drawing the figure frame.\n721 \n722     FigureClass : subclass of `~matplotlib.figure.Figure`\n723         If set, an instance of this subclass will be created, rather than a\n724         plain `.Figure`.\n725 \n726     clear : bool, default: False\n727         If True and the figure already exists, then it is cleared.\n728 \n729     layout : {'constrained', 'tight', `.LayoutEngine`, None}, default: None\n730         The layout mechanism for positioning of plot elements to avoid\n731         overlapping Axes decorations (labels, ticks, etc). Note that layout\n732         managers can measurably slow down figure display. Defaults to *None*\n733         (but see the documentation of the `.Figure` constructor regarding the\n734         interaction with rcParams).\n735 \n736     **kwargs\n737         Additional keyword arguments are passed to the `.Figure` constructor.\n738 \n739     Returns\n740     -------\n741     `~matplotlib.figure.Figure`\n742 \n743     Notes\n744     -----\n745     Newly created figures will be passed to the\n746     `~.backend_template.new_figure_manager` function provided by the current\n747     backend, which will install a canvas and a manager on the figure.\n748 \n749     If you are creating many figures, make sure you explicitly call\n750     `.pyplot.close` on the figures you are not using, because this will\n751     enable pyplot to properly clean up the memory.\n752 \n753     `~matplotlib.rcParams` defines the default values, which can be modified\n754     in the matplotlibrc file.\n755     \"\"\"\n756     if isinstance(num, Figure):\n757         if num.canvas.manager is None:\n758             raise ValueError(\"The passed figure is not managed by pyplot\")\n759         _pylab_helpers.Gcf.set_active(num.canvas.manager)\n760         return num\n761 \n762     allnums = get_fignums()\n763     next_num = max(allnums) + 1 if allnums else 1\n764     fig_label = ''\n765     if num is None:\n766         num = next_num\n767     elif isinstance(num, str):\n768         fig_label = num\n769         all_labels = get_figlabels()\n770         if fig_label not in all_labels:\n771             if fig_label == 'all':\n772                 _api.warn_external(\"close('all') closes all existing figures.\")\n773             num = next_num\n774         else:\n775             inum = all_labels.index(fig_label)\n776             num = allnums[inum]\n777     else:\n778         num = int(num)  # crude validation of num argument\n779 \n780     manager = _pylab_helpers.Gcf.get_fig_manager(num)\n781     if manager is None:\n782         max_open_warning = rcParams['figure.max_open_warning']\n783         if len(allnums) == max_open_warning >= 1:\n784             _api.warn_external(\n785                 f\"More than {max_open_warning} figures have been opened. \"\n786                 f\"Figures created through the pyplot interface \"\n787                 f\"(`matplotlib.pyplot.figure`) are retained until explicitly \"\n788                 f\"closed and may consume too much memory. (To control this \"\n789                 f\"warning, see the rcParam `figure.max_open_warning`).\",\n790                 RuntimeWarning)\n791 \n792         manager = new_figure_manager(\n793             num, figsize=figsize, dpi=dpi,\n794             facecolor=facecolor, edgecolor=edgecolor, frameon=frameon,\n795             FigureClass=FigureClass, **kwargs)\n796         fig = manager.canvas.figure\n797         if fig_label:\n798             fig.set_label(fig_label)\n799 \n800         _pylab_helpers.Gcf._set_new_active_manager(manager)\n801 \n802         # make sure backends (inline) that we don't ship that expect this\n803         # to be called in plotting commands to make the figure call show\n804         # still work.  There is probably a better way to do this in the\n805         # FigureManager base class.\n806         draw_if_interactive()\n807 \n808         if _REPL_DISPLAYHOOK is _ReplDisplayHook.PLAIN:\n809             fig.stale_callback = _auto_draw_if_interactive\n810 \n811     if clear:\n812         manager.canvas.figure.clear()\n813 \n814     return manager.canvas.figure\n815 \n816 \n817 def _auto_draw_if_interactive(fig, val):\n818     \"\"\"\n819     An internal helper function for making sure that auto-redrawing\n820     works as intended in the plain python repl.\n821 \n822     Parameters\n823     ----------\n824     fig : Figure\n825         A figure object which is assumed to be associated with a canvas\n826     \"\"\"\n827     if (val and matplotlib.is_interactive()\n828             and not fig.canvas.is_saving()\n829             and not fig.canvas._is_idle_drawing):\n830         # Some artists can mark themselves as stale in the middle of drawing\n831         # (e.g. axes position & tick labels being computed at draw time), but\n832         # this shouldn't trigger a redraw because the current redraw will\n833         # already take them into account.\n834         with fig.canvas._idle_draw_cntx():\n835             fig.canvas.draw_idle()\n836 \n837 \n838 def gcf():\n839     \"\"\"\n840     Get the current figure.\n841 \n842     If there is currently no figure on the pyplot figure stack, a new one is\n843     created using `~.pyplot.figure()`.  (To test whether there is currently a\n844     figure on the pyplot figure stack, check whether `~.pyplot.get_fignums()`\n845     is empty.)\n846     \"\"\"\n847     manager = _pylab_helpers.Gcf.get_active()\n848     if manager is not None:\n849         return manager.canvas.figure\n850     else:\n851         return figure()\n852 \n853 \n854 def fignum_exists(num):\n855     \"\"\"Return whether the figure with the given id exists.\"\"\"\n856     return _pylab_helpers.Gcf.has_fignum(num) or num in get_figlabels()\n857 \n858 \n859 def get_fignums():\n860     \"\"\"Return a list of existing figure numbers.\"\"\"\n861     return sorted(_pylab_helpers.Gcf.figs)\n862 \n863 \n864 def get_figlabels():\n865     \"\"\"Return a list of existing figure labels.\"\"\"\n866     managers = _pylab_helpers.Gcf.get_all_fig_managers()\n867     managers.sort(key=lambda m: m.num)\n868     return [m.canvas.figure.get_label() for m in managers]\n869 \n870 \n871 def get_current_fig_manager():\n872     \"\"\"\n873     Return the figure manager of the current figure.\n874 \n875     The figure manager is a container for the actual backend-depended window\n876     that displays the figure on screen.\n877 \n878     If no current figure exists, a new one is created, and its figure\n879     manager is returned.\n880 \n881     Returns\n882     -------\n883     `.FigureManagerBase` or backend-dependent subclass thereof\n884     \"\"\"\n885     return gcf().canvas.manager\n886 \n887 \n888 @_copy_docstring_and_deprecators(FigureCanvasBase.mpl_connect)\n889 def connect(s, func):\n890     return gcf().canvas.mpl_connect(s, func)\n891 \n892 \n893 @_copy_docstring_and_deprecators(FigureCanvasBase.mpl_disconnect)\n894 def disconnect(cid):\n895     return gcf().canvas.mpl_disconnect(cid)\n896 \n897 \n898 def close(fig=None):\n899     \"\"\"\n900     Close a figure window.\n901 \n902     Parameters\n903     ----------\n904     fig : None or int or str or `.Figure`\n905         The figure to close. There are a number of ways to specify this:\n906 \n907         - *None*: the current figure\n908         - `.Figure`: the given `.Figure` instance\n909         - ``int``: a figure number\n910         - ``str``: a figure name\n911         - 'all': all figures\n912 \n913     \"\"\"\n914     if fig is None:\n915         manager = _pylab_helpers.Gcf.get_active()\n916         if manager is None:\n917             return\n918         else:\n919             _pylab_helpers.Gcf.destroy(manager)\n920     elif fig == 'all':\n921         _pylab_helpers.Gcf.destroy_all()\n922     elif isinstance(fig, int):\n923         _pylab_helpers.Gcf.destroy(fig)\n924     elif hasattr(fig, 'int'):\n925         # if we are dealing with a type UUID, we\n926         # can use its integer representation\n927         _pylab_helpers.Gcf.destroy(fig.int)\n928     elif isinstance(fig, str):\n929         all_labels = get_figlabels()\n930         if fig in all_labels:\n931             num = get_fignums()[all_labels.index(fig)]\n932             _pylab_helpers.Gcf.destroy(num)\n933     elif isinstance(fig, Figure):\n934         _pylab_helpers.Gcf.destroy_fig(fig)\n935     else:\n936         raise TypeError(\"close() argument must be a Figure, an int, a string, \"\n937                         \"or None, not %s\" % type(fig))\n938 \n939 \n940 def clf():\n941     \"\"\"Clear the current figure.\"\"\"\n942     gcf().clear()\n943 \n944 \n945 def draw():\n946     \"\"\"\n947     Redraw the current figure.\n948 \n949     This is used to update a figure that has been altered, but not\n950     automatically re-drawn.  If interactive mode is on (via `.ion()`), this\n951     should be only rarely needed, but there may be ways to modify the state of\n952     a figure without marking it as \"stale\".  Please report these cases as bugs.\n953 \n954     This is equivalent to calling ``fig.canvas.draw_idle()``, where ``fig`` is\n955     the current figure.\n956     \"\"\"\n957     gcf().canvas.draw_idle()\n958 \n959 \n960 @_copy_docstring_and_deprecators(Figure.savefig)\n961 def savefig(*args, **kwargs):\n962     fig = gcf()\n963     res = fig.savefig(*args, **kwargs)\n964     fig.canvas.draw_idle()  # Need this if 'transparent=True', to reset colors.\n965     return res\n966 \n967 \n968 ## Putting things in figures ##\n969 \n970 \n971 def figlegend(*args, **kwargs):\n972     return gcf().legend(*args, **kwargs)\n973 if Figure.legend.__doc__:\n974     figlegend.__doc__ = Figure.legend.__doc__.replace(\"legend(\", \"figlegend(\")\n975 \n976 \n977 ## Axes ##\n978 \n979 @_docstring.dedent_interpd\n980 def axes(arg=None, **kwargs):\n981     \"\"\"\n982     Add an Axes to the current figure and make it the current Axes.\n983 \n984     Call signatures::\n985 \n986         plt.axes()\n987         plt.axes(rect, projection=None, polar=False, **kwargs)\n988         plt.axes(ax)\n989 \n990     Parameters\n991     ----------\n992     arg : None or 4-tuple\n993         The exact behavior of this function depends on the type:\n994 \n995         - *None*: A new full window Axes is added using\n996           ``subplot(**kwargs)``.\n997         - 4-tuple of floats *rect* = ``[left, bottom, width, height]``.\n998           A new Axes is added with dimensions *rect* in normalized\n999           (0, 1) units using `~.Figure.add_axes` on the current figure.\n1000 \n1001     projection : {None, 'aitoff', 'hammer', 'lambert', 'mollweide', \\\n1002 'polar', 'rectilinear', str}, optional\n1003         The projection type of the `~.axes.Axes`. *str* is the name of\n1004         a custom projection, see `~matplotlib.projections`. The default\n1005         None results in a 'rectilinear' projection.\n1006 \n1007     polar : bool, default: False\n1008         If True, equivalent to projection='polar'.\n1009 \n1010     sharex, sharey : `~.axes.Axes`, optional\n1011         Share the x or y `~matplotlib.axis` with sharex and/or sharey.\n1012         The axis will have the same limits, ticks, and scale as the axis\n1013         of the shared Axes.\n1014 \n1015     label : str\n1016         A label for the returned Axes.\n1017 \n1018     Returns\n1019     -------\n1020     `~.axes.Axes`, or a subclass of `~.axes.Axes`\n1021         The returned axes class depends on the projection used. It is\n1022         `~.axes.Axes` if rectilinear projection is used and\n1023         `.projections.polar.PolarAxes` if polar projection is used.\n1024 \n1025     Other Parameters\n1026     ----------------\n1027     **kwargs\n1028         This method also takes the keyword arguments for\n1029         the returned Axes class. The keyword arguments for the\n1030         rectilinear Axes class `~.axes.Axes` can be found in\n1031         the following table but there might also be other keyword\n1032         arguments if another projection is used, see the actual Axes\n1033         class.\n1034 \n1035         %(Axes:kwdoc)s\n1036 \n1037     Notes\n1038     -----\n1039     If the figure already has an Axes with key (*args*,\n1040     *kwargs*) then it will simply make that axes current and\n1041     return it.  This behavior is deprecated. Meanwhile, if you do\n1042     not want this behavior (i.e., you want to force the creation of a\n1043     new axes), you must use a unique set of args and kwargs.  The Axes\n1044     *label* attribute has been exposed for this purpose: if you want\n1045     two Axes that are otherwise identical to be added to the figure,\n1046     make sure you give them unique labels.\n1047 \n1048     See Also\n1049     --------\n1050     .Figure.add_axes\n1051     .pyplot.subplot\n1052     .Figure.add_subplot\n1053     .Figure.subplots\n1054     .pyplot.subplots\n1055 \n1056     Examples\n1057     --------\n1058     ::\n1059 \n1060         # Creating a new full window Axes\n1061         plt.axes()\n1062 \n1063         # Creating a new Axes with specified dimensions and a grey background\n1064         plt.axes((left, bottom, width, height), facecolor='grey')\n1065     \"\"\"\n1066     fig = gcf()\n1067     pos = kwargs.pop('position', None)\n1068     if arg is None:\n1069         if pos is None:\n1070             return fig.add_subplot(**kwargs)\n1071         else:\n1072             return fig.add_axes(pos, **kwargs)\n1073     else:\n1074         return fig.add_axes(arg, **kwargs)\n1075 \n1076 \n1077 def delaxes(ax=None):\n1078     \"\"\"\n1079     Remove an `~.axes.Axes` (defaulting to the current axes) from its figure.\n1080     \"\"\"\n1081     if ax is None:\n1082         ax = gca()\n1083     ax.remove()\n1084 \n1085 \n1086 def sca(ax):\n1087     \"\"\"\n1088     Set the current Axes to *ax* and the current Figure to the parent of *ax*.\n1089     \"\"\"\n1090     figure(ax.figure)\n1091     ax.figure.sca(ax)\n1092 \n1093 \n1094 def cla():\n1095     \"\"\"Clear the current axes.\"\"\"\n1096     # Not generated via boilerplate.py to allow a different docstring.\n1097     return gca().cla()\n1098 \n1099 \n1100 ## More ways of creating axes ##\n1101 \n1102 @_docstring.dedent_interpd\n1103 def subplot(*args, **kwargs):\n1104     \"\"\"\n1105     Add an Axes to the current figure or retrieve an existing Axes.\n1106 \n1107     This is a wrapper of `.Figure.add_subplot` which provides additional\n1108     behavior when working with the implicit API (see the notes section).\n1109 \n1110     Call signatures::\n1111 \n1112        subplot(nrows, ncols, index, **kwargs)\n1113        subplot(pos, **kwargs)\n1114        subplot(**kwargs)\n1115        subplot(ax)\n1116 \n1117     Parameters\n1118     ----------\n1119     *args : int, (int, int, *index*), or `.SubplotSpec`, default: (1, 1, 1)\n1120         The position of the subplot described by one of\n1121 \n1122         - Three integers (*nrows*, *ncols*, *index*). The subplot will take the\n1123           *index* position on a grid with *nrows* rows and *ncols* columns.\n1124           *index* starts at 1 in the upper left corner and increases to the\n1125           right. *index* can also be a two-tuple specifying the (*first*,\n1126           *last*) indices (1-based, and including *last*) of the subplot, e.g.,\n1127           ``fig.add_subplot(3, 1, (1, 2))`` makes a subplot that spans the\n1128           upper 2/3 of the figure.\n1129         - A 3-digit integer. The digits are interpreted as if given separately\n1130           as three single-digit integers, i.e. ``fig.add_subplot(235)`` is the\n1131           same as ``fig.add_subplot(2, 3, 5)``. Note that this can only be used\n1132           if there are no more than 9 subplots.\n1133         - A `.SubplotSpec`.\n1134 \n1135     projection : {None, 'aitoff', 'hammer', 'lambert', 'mollweide', \\\n1136 'polar', 'rectilinear', str}, optional\n1137         The projection type of the subplot (`~.axes.Axes`). *str* is the name\n1138         of a custom projection, see `~matplotlib.projections`. The default\n1139         None results in a 'rectilinear' projection.\n1140 \n1141     polar : bool, default: False\n1142         If True, equivalent to projection='polar'.\n1143 \n1144     sharex, sharey : `~.axes.Axes`, optional\n1145         Share the x or y `~matplotlib.axis` with sharex and/or sharey. The\n1146         axis will have the same limits, ticks, and scale as the axis of the\n1147         shared axes.\n1148 \n1149     label : str\n1150         A label for the returned axes.\n1151 \n1152     Returns\n1153     -------\n1154     `.axes.SubplotBase`, or another subclass of `~.axes.Axes`\n1155 \n1156         The axes of the subplot. The returned axes base class depends on\n1157         the projection used. It is `~.axes.Axes` if rectilinear projection\n1158         is used and `.projections.polar.PolarAxes` if polar projection\n1159         is used. The returned axes is then a subplot subclass of the\n1160         base class.\n1161 \n1162     Other Parameters\n1163     ----------------\n1164     **kwargs\n1165         This method also takes the keyword arguments for the returned axes\n1166         base class; except for the *figure* argument. The keyword arguments\n1167         for the rectilinear base class `~.axes.Axes` can be found in\n1168         the following table but there might also be other keyword\n1169         arguments if another projection is used.\n1170 \n1171         %(Axes:kwdoc)s\n1172 \n1173     Notes\n1174     -----\n1175     Creating a new Axes will delete any pre-existing Axes that\n1176     overlaps with it beyond sharing a boundary::\n1177 \n1178         import matplotlib.pyplot as plt\n1179         # plot a line, implicitly creating a subplot(111)\n1180         plt.plot([1, 2, 3])\n1181         # now create a subplot which represents the top plot of a grid\n1182         # with 2 rows and 1 column. Since this subplot will overlap the\n1183         # first, the plot (and its axes) previously created, will be removed\n1184         plt.subplot(211)\n1185 \n1186     If you do not want this behavior, use the `.Figure.add_subplot` method\n1187     or the `.pyplot.axes` function instead.\n1188 \n1189     If no *kwargs* are passed and there exists an Axes in the location\n1190     specified by *args* then that Axes will be returned rather than a new\n1191     Axes being created.\n1192 \n1193     If *kwargs* are passed and there exists an Axes in the location\n1194     specified by *args*, the projection type is the same, and the\n1195     *kwargs* match with the existing Axes, then the existing Axes is\n1196     returned.  Otherwise a new Axes is created with the specified\n1197     parameters.  We save a reference to the *kwargs* which we use\n1198     for this comparison.  If any of the values in *kwargs* are\n1199     mutable we will not detect the case where they are mutated.\n1200     In these cases we suggest using `.Figure.add_subplot` and the\n1201     explicit Axes API rather than the implicit pyplot API.\n1202 \n1203     See Also\n1204     --------\n1205     .Figure.add_subplot\n1206     .pyplot.subplots\n1207     .pyplot.axes\n1208     .Figure.subplots\n1209 \n1210     Examples\n1211     --------\n1212     ::\n1213 \n1214         plt.subplot(221)\n1215 \n1216         # equivalent but more general\n1217         ax1 = plt.subplot(2, 2, 1)\n1218 \n1219         # add a subplot with no frame\n1220         ax2 = plt.subplot(222, frameon=False)\n1221 \n1222         # add a polar subplot\n1223         plt.subplot(223, projection='polar')\n1224 \n1225         # add a red subplot that shares the x-axis with ax1\n1226         plt.subplot(224, sharex=ax1, facecolor='red')\n1227 \n1228         # delete ax2 from the figure\n1229         plt.delaxes(ax2)\n1230 \n1231         # add ax2 to the figure again\n1232         plt.subplot(ax2)\n1233 \n1234         # make the first axes \"current\" again\n1235         plt.subplot(221)\n1236 \n1237     \"\"\"\n1238     # Here we will only normalize `polar=True` vs `projection='polar'` and let\n1239     # downstream code deal with the rest.\n1240     unset = object()\n1241     projection = kwargs.get('projection', unset)\n1242     polar = kwargs.pop('polar', unset)\n1243     if polar is not unset and polar:\n1244         # if we got mixed messages from the user, raise\n1245         if projection is not unset and projection != 'polar':\n1246             raise ValueError(\n1247                 f\"polar={polar}, yet projection={projection!r}. \"\n1248                 \"Only one of these arguments should be supplied.\"\n1249             )\n1250         kwargs['projection'] = projection = 'polar'\n1251 \n1252     # if subplot called without arguments, create subplot(1, 1, 1)\n1253     if len(args) == 0:\n1254         args = (1, 1, 1)\n1255 \n1256     # This check was added because it is very easy to type subplot(1, 2, False)\n1257     # when subplots(1, 2, False) was intended (sharex=False, that is). In most\n1258     # cases, no error will ever occur, but mysterious behavior can result\n1259     # because what was intended to be the sharex argument is instead treated as\n1260     # a subplot index for subplot()\n1261     if len(args) >= 3 and isinstance(args[2], bool):\n1262         _api.warn_external(\"The subplot index argument to subplot() appears \"\n1263                            \"to be a boolean. Did you intend to use \"\n1264                            \"subplots()?\")\n1265     # Check for nrows and ncols, which are not valid subplot args:\n1266     if 'nrows' in kwargs or 'ncols' in kwargs:\n1267         raise TypeError(\"subplot() got an unexpected keyword argument 'ncols' \"\n1268                         \"and/or 'nrows'.  Did you intend to call subplots()?\")\n1269 \n1270     fig = gcf()\n1271 \n1272     # First, search for an existing subplot with a matching spec.\n1273     key = SubplotSpec._from_subplot_args(fig, args)\n1274 \n1275     for ax in fig.axes:\n1276         # if we found an Axes at the position sort out if we can re-use it\n1277         if hasattr(ax, 'get_subplotspec') and ax.get_subplotspec() == key:\n1278             # if the user passed no kwargs, re-use\n1279             if kwargs == {}:\n1280                 break\n1281             # if the axes class and kwargs are identical, reuse\n1282             elif ax._projection_init == fig._process_projection_requirements(\n1283                 *args, **kwargs\n1284             ):\n1285                 break\n1286     else:\n1287         # we have exhausted the known Axes and none match, make a new one!\n1288         ax = fig.add_subplot(*args, **kwargs)\n1289 \n1290     fig.sca(ax)\n1291 \n1292     axes_to_delete = [other for other in fig.axes\n1293                       if other != ax and ax.bbox.fully_overlaps(other.bbox)]\n1294     if axes_to_delete:\n1295         _api.warn_deprecated(\n1296             \"3.6\", message=\"Auto-removal of overlapping axes is deprecated \"\n1297             \"since %(since)s and will be removed %(removal)s; explicitly call \"\n1298             \"ax.remove() as needed.\")\n1299     for ax_to_del in axes_to_delete:\n1300         delaxes(ax_to_del)\n1301 \n1302     return ax\n1303 \n1304 \n1305 def subplots(nrows=1, ncols=1, *, sharex=False, sharey=False, squeeze=True,\n1306              subplot_kw=None, gridspec_kw=None, **fig_kw):\n1307     \"\"\"\n1308     Create a figure and a set of subplots.\n1309 \n1310     This utility wrapper makes it convenient to create common layouts of\n1311     subplots, including the enclosing figure object, in a single call.\n1312 \n1313     Parameters\n1314     ----------\n1315     nrows, ncols : int, default: 1\n1316         Number of rows/columns of the subplot grid.\n1317 \n1318     sharex, sharey : bool or {'none', 'all', 'row', 'col'}, default: False\n1319         Controls sharing of properties among x (*sharex*) or y (*sharey*)\n1320         axes:\n1321 \n1322         - True or 'all': x- or y-axis will be shared among all subplots.\n1323         - False or 'none': each subplot x- or y-axis will be independent.\n1324         - 'row': each subplot row will share an x- or y-axis.\n1325         - 'col': each subplot column will share an x- or y-axis.\n1326 \n1327         When subplots have a shared x-axis along a column, only the x tick\n1328         labels of the bottom subplot are created. Similarly, when subplots\n1329         have a shared y-axis along a row, only the y tick labels of the first\n1330         column subplot are created. To later turn other subplots' ticklabels\n1331         on, use `~matplotlib.axes.Axes.tick_params`.\n1332 \n1333         When subplots have a shared axis that has units, calling\n1334         `~matplotlib.axis.Axis.set_units` will update each axis with the\n1335         new units.\n1336 \n1337     squeeze : bool, default: True\n1338         - If True, extra dimensions are squeezed out from the returned\n1339           array of `~matplotlib.axes.Axes`:\n1340 \n1341           - if only one subplot is constructed (nrows=ncols=1), the\n1342             resulting single Axes object is returned as a scalar.\n1343           - for Nx1 or 1xM subplots, the returned object is a 1D numpy\n1344             object array of Axes objects.\n1345           - for NxM, subplots with N>1 and M>1 are returned as a 2D array.\n1346 \n1347         - If False, no squeezing at all is done: the returned Axes object is\n1348           always a 2D array containing Axes instances, even if it ends up\n1349           being 1x1.\n1350 \n1351     subplot_kw : dict, optional\n1352         Dict with keywords passed to the\n1353         `~matplotlib.figure.Figure.add_subplot` call used to create each\n1354         subplot.\n1355 \n1356     gridspec_kw : dict, optional\n1357         Dict with keywords passed to the `~matplotlib.gridspec.GridSpec`\n1358         constructor used to create the grid the subplots are placed on.\n1359 \n1360     **fig_kw\n1361         All additional keyword arguments are passed to the\n1362         `.pyplot.figure` call.\n1363 \n1364     Returns\n1365     -------\n1366     fig : `.Figure`\n1367 \n1368     ax : `~.axes.Axes` or array of Axes\n1369         *ax* can be either a single `~.axes.Axes` object, or an array of Axes\n1370         objects if more than one subplot was created.  The dimensions of the\n1371         resulting array can be controlled with the squeeze keyword, see above.\n1372 \n1373         Typical idioms for handling the return value are::\n1374 \n1375             # using the variable ax for single a Axes\n1376             fig, ax = plt.subplots()\n1377 \n1378             # using the variable axs for multiple Axes\n1379             fig, axs = plt.subplots(2, 2)\n1380 \n1381             # using tuple unpacking for multiple Axes\n1382             fig, (ax1, ax2) = plt.subplots(1, 2)\n1383             fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2)\n1384 \n1385         The names ``ax`` and pluralized ``axs`` are preferred over ``axes``\n1386         because for the latter it's not clear if it refers to a single\n1387         `~.axes.Axes` instance or a collection of these.\n1388 \n1389     See Also\n1390     --------\n1391     .pyplot.figure\n1392     .pyplot.subplot\n1393     .pyplot.axes\n1394     .Figure.subplots\n1395     .Figure.add_subplot\n1396 \n1397     Examples\n1398     --------\n1399     ::\n1400 \n1401         # First create some toy data:\n1402         x = np.linspace(0, 2*np.pi, 400)\n1403         y = np.sin(x**2)\n1404 \n1405         # Create just a figure and only one subplot\n1406         fig, ax = plt.subplots()\n1407         ax.plot(x, y)\n1408         ax.set_title('Simple plot')\n1409 \n1410         # Create two subplots and unpack the output array immediately\n1411         f, (ax1, ax2) = plt.subplots(1, 2, sharey=True)\n1412         ax1.plot(x, y)\n1413         ax1.set_title('Sharing Y axis')\n1414         ax2.scatter(x, y)\n1415 \n1416         # Create four polar axes and access them through the returned array\n1417         fig, axs = plt.subplots(2, 2, subplot_kw=dict(projection=\"polar\"))\n1418         axs[0, 0].plot(x, y)\n1419         axs[1, 1].scatter(x, y)\n1420 \n1421         # Share a X axis with each column of subplots\n1422         plt.subplots(2, 2, sharex='col')\n1423 \n1424         # Share a Y axis with each row of subplots\n1425         plt.subplots(2, 2, sharey='row')\n1426 \n1427         # Share both X and Y axes with all subplots\n1428         plt.subplots(2, 2, sharex='all', sharey='all')\n1429 \n1430         # Note that this is the same as\n1431         plt.subplots(2, 2, sharex=True, sharey=True)\n1432 \n1433         # Create figure number 10 with a single subplot\n1434         # and clears it if it already exists.\n1435         fig, ax = plt.subplots(num=10, clear=True)\n1436 \n1437     \"\"\"\n1438     fig = figure(**fig_kw)\n1439     axs = fig.subplots(nrows=nrows, ncols=ncols, sharex=sharex, sharey=sharey,\n1440                        squeeze=squeeze, subplot_kw=subplot_kw,\n1441                        gridspec_kw=gridspec_kw)\n1442     return fig, axs\n1443 \n1444 \n1445 def subplot_mosaic(mosaic, *, sharex=False, sharey=False,\n1446                    subplot_kw=None, gridspec_kw=None, empty_sentinel='.',\n1447                    **fig_kw):\n1448     \"\"\"\n1449     Build a layout of Axes based on ASCII art or nested lists.\n1450 \n1451     This is a helper function to build complex GridSpec layouts visually.\n1452 \n1453     .. note::\n1454 \n1455        This API is provisional and may be revised in the future based on\n1456        early user feedback.\n1457 \n1458     See :doc:`/tutorials/provisional/mosaic`\n1459     for an example and full API documentation\n1460 \n1461     Parameters\n1462     ----------\n1463     mosaic : list of list of {hashable or nested} or str\n1464 \n1465         A visual layout of how you want your Axes to be arranged\n1466         labeled as strings.  For example ::\n1467 \n1468            x = [['A panel', 'A panel', 'edge'],\n1469                 ['C panel', '.',       'edge']]\n1470 \n1471         produces 4 axes:\n1472 \n1473         - 'A panel' which is 1 row high and spans the first two columns\n1474         - 'edge' which is 2 rows high and is on the right edge\n1475         - 'C panel' which in 1 row and 1 column wide in the bottom left\n1476         - a blank space 1 row and 1 column wide in the bottom center\n1477 \n1478         Any of the entries in the layout can be a list of lists\n1479         of the same form to create nested layouts.\n1480 \n1481         If input is a str, then it must be of the form ::\n1482 \n1483           '''\n1484           AAE\n1485           C.E\n1486           '''\n1487 \n1488         where each character is a column and each line is a row.\n1489         This only allows only single character Axes labels and does\n1490         not allow nesting but is very terse.\n1491 \n1492     sharex, sharey : bool, default: False\n1493         If True, the x-axis (*sharex*) or y-axis (*sharey*) will be shared\n1494         among all subplots.  In that case, tick label visibility and axis units\n1495         behave as for `subplots`.  If False, each subplot's x- or y-axis will\n1496         be independent.\n1497 \n1498     subplot_kw : dict, optional\n1499         Dictionary with keywords passed to the `.Figure.add_subplot` call\n1500         used to create each subplot.\n1501 \n1502     gridspec_kw : dict, optional\n1503         Dictionary with keywords passed to the `.GridSpec` constructor used\n1504         to create the grid the subplots are placed on.\n1505 \n1506     empty_sentinel : object, optional\n1507         Entry in the layout to mean \"leave this space empty\".  Defaults\n1508         to ``'.'``. Note, if *layout* is a string, it is processed via\n1509         `inspect.cleandoc` to remove leading white space, which may\n1510         interfere with using white-space as the empty sentinel.\n1511 \n1512     **fig_kw\n1513         All additional keyword arguments are passed to the\n1514         `.pyplot.figure` call.\n1515 \n1516     Returns\n1517     -------\n1518     fig : `.Figure`\n1519        The new figure\n1520 \n1521     dict[label, Axes]\n1522        A dictionary mapping the labels to the Axes objects.  The order of\n1523        the axes is left-to-right and top-to-bottom of their position in the\n1524        total layout.\n1525 \n1526     \"\"\"\n1527     fig = figure(**fig_kw)\n1528     ax_dict = fig.subplot_mosaic(\n1529         mosaic, sharex=sharex, sharey=sharey,\n1530         subplot_kw=subplot_kw, gridspec_kw=gridspec_kw,\n1531         empty_sentinel=empty_sentinel\n1532     )\n1533     return fig, ax_dict\n1534 \n1535 \n1536 def subplot2grid(shape, loc, rowspan=1, colspan=1, fig=None, **kwargs):\n1537     \"\"\"\n1538     Create a subplot at a specific location inside a regular grid.\n1539 \n1540     Parameters\n1541     ----------\n1542     shape : (int, int)\n1543         Number of rows and of columns of the grid in which to place axis.\n1544     loc : (int, int)\n1545         Row number and column number of the axis location within the grid.\n1546     rowspan : int, default: 1\n1547         Number of rows for the axis to span downwards.\n1548     colspan : int, default: 1\n1549         Number of columns for the axis to span to the right.\n1550     fig : `.Figure`, optional\n1551         Figure to place the subplot in. Defaults to the current figure.\n1552     **kwargs\n1553         Additional keyword arguments are handed to `~.Figure.add_subplot`.\n1554 \n1555     Returns\n1556     -------\n1557     `.axes.SubplotBase`, or another subclass of `~.axes.Axes`\n1558 \n1559         The axes of the subplot.  The returned axes base class depends on the\n1560         projection used.  It is `~.axes.Axes` if rectilinear projection is used\n1561         and `.projections.polar.PolarAxes` if polar projection is used.  The\n1562         returned axes is then a subplot subclass of the base class.\n1563 \n1564     Notes\n1565     -----\n1566     The following call ::\n1567 \n1568         ax = subplot2grid((nrows, ncols), (row, col), rowspan, colspan)\n1569 \n1570     is identical to ::\n1571 \n1572         fig = gcf()\n1573         gs = fig.add_gridspec(nrows, ncols)\n1574         ax = fig.add_subplot(gs[row:row+rowspan, col:col+colspan])\n1575     \"\"\"\n1576 \n1577     if fig is None:\n1578         fig = gcf()\n1579 \n1580     rows, cols = shape\n1581     gs = GridSpec._check_gridspec_exists(fig, rows, cols)\n1582 \n1583     subplotspec = gs.new_subplotspec(loc, rowspan=rowspan, colspan=colspan)\n1584     ax = fig.add_subplot(subplotspec, **kwargs)\n1585 \n1586     axes_to_delete = [other for other in fig.axes\n1587                       if other != ax and ax.bbox.fully_overlaps(other.bbox)]\n1588     if axes_to_delete:\n1589         _api.warn_deprecated(\n1590             \"3.6\", message=\"Auto-removal of overlapping axes is deprecated \"\n1591             \"since %(since)s and will be removed %(removal)s; explicitly call \"\n1592             \"ax.remove() as needed.\")\n1593     for ax_to_del in axes_to_delete:\n1594         delaxes(ax_to_del)\n1595 \n1596     return ax\n1597 \n1598 \n1599 def twinx(ax=None):\n1600     \"\"\"\n1601     Make and return a second axes that shares the *x*-axis.  The new axes will\n1602     overlay *ax* (or the current axes if *ax* is *None*), and its ticks will be\n1603     on the right.\n1604 \n1605     Examples\n1606     --------\n1607     :doc:`/gallery/subplots_axes_and_figures/two_scales`\n1608     \"\"\"\n1609     if ax is None:\n1610         ax = gca()\n1611     ax1 = ax.twinx()\n1612     return ax1\n1613 \n1614 \n1615 def twiny(ax=None):\n1616     \"\"\"\n1617     Make and return a second axes that shares the *y*-axis.  The new axes will\n1618     overlay *ax* (or the current axes if *ax* is *None*), and its ticks will be\n1619     on the top.\n1620 \n1621     Examples\n1622     --------\n1623     :doc:`/gallery/subplots_axes_and_figures/two_scales`\n1624     \"\"\"\n1625     if ax is None:\n1626         ax = gca()\n1627     ax1 = ax.twiny()\n1628     return ax1\n1629 \n1630 \n1631 def subplot_tool(targetfig=None):\n1632     \"\"\"\n1633     Launch a subplot tool window for a figure.\n1634 \n1635     Returns\n1636     -------\n1637     `matplotlib.widgets.SubplotTool`\n1638     \"\"\"\n1639     if targetfig is None:\n1640         targetfig = gcf()\n1641     tb = targetfig.canvas.manager.toolbar\n1642     if hasattr(tb, \"configure_subplots\"):  # toolbar2\n1643         return tb.configure_subplots()\n1644     elif hasattr(tb, \"trigger_tool\"):  # toolmanager\n1645         return tb.trigger_tool(\"subplots\")\n1646     else:\n1647         raise ValueError(\"subplot_tool can only be launched for figures with \"\n1648                          \"an associated toolbar\")\n1649 \n1650 \n1651 def box(on=None):\n1652     \"\"\"\n1653     Turn the axes box on or off on the current axes.\n1654 \n1655     Parameters\n1656     ----------\n1657     on : bool or None\n1658         The new `~matplotlib.axes.Axes` box state. If ``None``, toggle\n1659         the state.\n1660 \n1661     See Also\n1662     --------\n1663     :meth:`matplotlib.axes.Axes.set_frame_on`\n1664     :meth:`matplotlib.axes.Axes.get_frame_on`\n1665     \"\"\"\n1666     ax = gca()\n1667     if on is None:\n1668         on = not ax.get_frame_on()\n1669     ax.set_frame_on(on)\n1670 \n1671 ## Axis ##\n1672 \n1673 \n1674 def xlim(*args, **kwargs):\n1675     \"\"\"\n1676     Get or set the x limits of the current axes.\n1677 \n1678     Call signatures::\n1679 \n1680         left, right = xlim()  # return the current xlim\n1681         xlim((left, right))   # set the xlim to left, right\n1682         xlim(left, right)     # set the xlim to left, right\n1683 \n1684     If you do not specify args, you can pass *left* or *right* as kwargs,\n1685     i.e.::\n1686 \n1687         xlim(right=3)  # adjust the right leaving left unchanged\n1688         xlim(left=1)  # adjust the left leaving right unchanged\n1689 \n1690     Setting limits turns autoscaling off for the x-axis.\n1691 \n1692     Returns\n1693     -------\n1694     left, right\n1695         A tuple of the new x-axis limits.\n1696 \n1697     Notes\n1698     -----\n1699     Calling this function with no arguments (e.g. ``xlim()``) is the pyplot\n1700     equivalent of calling `~.Axes.get_xlim` on the current axes.\n1701     Calling this function with arguments is the pyplot equivalent of calling\n1702     `~.Axes.set_xlim` on the current axes. All arguments are passed though.\n1703     \"\"\"\n1704     ax = gca()\n1705     if not args and not kwargs:\n1706         return ax.get_xlim()\n1707     ret = ax.set_xlim(*args, **kwargs)\n1708     return ret\n1709 \n1710 \n1711 def ylim(*args, **kwargs):\n1712     \"\"\"\n1713     Get or set the y-limits of the current axes.\n1714 \n1715     Call signatures::\n1716 \n1717         bottom, top = ylim()  # return the current ylim\n1718         ylim((bottom, top))   # set the ylim to bottom, top\n1719         ylim(bottom, top)     # set the ylim to bottom, top\n1720 \n1721     If you do not specify args, you can alternatively pass *bottom* or\n1722     *top* as kwargs, i.e.::\n1723 \n1724         ylim(top=3)  # adjust the top leaving bottom unchanged\n1725         ylim(bottom=1)  # adjust the bottom leaving top unchanged\n1726 \n1727     Setting limits turns autoscaling off for the y-axis.\n1728 \n1729     Returns\n1730     -------\n1731     bottom, top\n1732         A tuple of the new y-axis limits.\n1733 \n1734     Notes\n1735     -----\n1736     Calling this function with no arguments (e.g. ``ylim()``) is the pyplot\n1737     equivalent of calling `~.Axes.get_ylim` on the current axes.\n1738     Calling this function with arguments is the pyplot equivalent of calling\n1739     `~.Axes.set_ylim` on the current axes. All arguments are passed though.\n1740     \"\"\"\n1741     ax = gca()\n1742     if not args and not kwargs:\n1743         return ax.get_ylim()\n1744     ret = ax.set_ylim(*args, **kwargs)\n1745     return ret\n1746 \n1747 \n1748 def xticks(ticks=None, labels=None, **kwargs):\n1749     \"\"\"\n1750     Get or set the current tick locations and labels of the x-axis.\n1751 \n1752     Pass no arguments to return the current values without modifying them.\n1753 \n1754     Parameters\n1755     ----------\n1756     ticks : array-like, optional\n1757         The list of xtick locations.  Passing an empty list removes all xticks.\n1758     labels : array-like, optional\n1759         The labels to place at the given *ticks* locations.  This argument can\n1760         only be passed if *ticks* is passed as well.\n1761     **kwargs\n1762         `.Text` properties can be used to control the appearance of the labels.\n1763 \n1764     Returns\n1765     -------\n1766     locs\n1767         The list of xtick locations.\n1768     labels\n1769         The list of xlabel `.Text` objects.\n1770 \n1771     Notes\n1772     -----\n1773     Calling this function with no arguments (e.g. ``xticks()``) is the pyplot\n1774     equivalent of calling `~.Axes.get_xticks` and `~.Axes.get_xticklabels` on\n1775     the current axes.\n1776     Calling this function with arguments is the pyplot equivalent of calling\n1777     `~.Axes.set_xticks` and `~.Axes.set_xticklabels` on the current axes.\n1778 \n1779     Examples\n1780     --------\n1781     >>> locs, labels = xticks()  # Get the current locations and labels.\n1782     >>> xticks(np.arange(0, 1, step=0.2))  # Set label locations.\n1783     >>> xticks(np.arange(3), ['Tom', 'Dick', 'Sue'])  # Set text labels.\n1784     >>> xticks([0, 1, 2], ['January', 'February', 'March'],\n1785     ...        rotation=20)  # Set text labels and properties.\n1786     >>> xticks([])  # Disable xticks.\n1787     \"\"\"\n1788     ax = gca()\n1789 \n1790     if ticks is None:\n1791         locs = ax.get_xticks()\n1792         if labels is not None:\n1793             raise TypeError(\"xticks(): Parameter 'labels' can't be set \"\n1794                             \"without setting 'ticks'\")\n1795     else:\n1796         locs = ax.set_xticks(ticks)\n1797 \n1798     if labels is None:\n1799         labels = ax.get_xticklabels()\n1800         for l in labels:\n1801             l._internal_update(kwargs)\n1802     else:\n1803         labels = ax.set_xticklabels(labels, **kwargs)\n1804 \n1805     return locs, labels\n1806 \n1807 \n1808 def yticks(ticks=None, labels=None, **kwargs):\n1809     \"\"\"\n1810     Get or set the current tick locations and labels of the y-axis.\n1811 \n1812     Pass no arguments to return the current values without modifying them.\n1813 \n1814     Parameters\n1815     ----------\n1816     ticks : array-like, optional\n1817         The list of ytick locations.  Passing an empty list removes all yticks.\n1818     labels : array-like, optional\n1819         The labels to place at the given *ticks* locations.  This argument can\n1820         only be passed if *ticks* is passed as well.\n1821     **kwargs\n1822         `.Text` properties can be used to control the appearance of the labels.\n1823 \n1824     Returns\n1825     -------\n1826     locs\n1827         The list of ytick locations.\n1828     labels\n1829         The list of ylabel `.Text` objects.\n1830 \n1831     Notes\n1832     -----\n1833     Calling this function with no arguments (e.g. ``yticks()``) is the pyplot\n1834     equivalent of calling `~.Axes.get_yticks` and `~.Axes.get_yticklabels` on\n1835     the current axes.\n1836     Calling this function with arguments is the pyplot equivalent of calling\n1837     `~.Axes.set_yticks` and `~.Axes.set_yticklabels` on the current axes.\n1838 \n1839     Examples\n1840     --------\n1841     >>> locs, labels = yticks()  # Get the current locations and labels.\n1842     >>> yticks(np.arange(0, 1, step=0.2))  # Set label locations.\n1843     >>> yticks(np.arange(3), ['Tom', 'Dick', 'Sue'])  # Set text labels.\n1844     >>> yticks([0, 1, 2], ['January', 'February', 'March'],\n1845     ...        rotation=45)  # Set text labels and properties.\n1846     >>> yticks([])  # Disable yticks.\n1847     \"\"\"\n1848     ax = gca()\n1849 \n1850     if ticks is None:\n1851         locs = ax.get_yticks()\n1852         if labels is not None:\n1853             raise TypeError(\"yticks(): Parameter 'labels' can't be set \"\n1854                             \"without setting 'ticks'\")\n1855     else:\n1856         locs = ax.set_yticks(ticks)\n1857 \n1858     if labels is None:\n1859         labels = ax.get_yticklabels()\n1860         for l in labels:\n1861             l._internal_update(kwargs)\n1862     else:\n1863         labels = ax.set_yticklabels(labels, **kwargs)\n1864 \n1865     return locs, labels\n1866 \n1867 \n1868 def rgrids(radii=None, labels=None, angle=None, fmt=None, **kwargs):\n1869     \"\"\"\n1870     Get or set the radial gridlines on the current polar plot.\n1871 \n1872     Call signatures::\n1873 \n1874      lines, labels = rgrids()\n1875      lines, labels = rgrids(radii, labels=None, angle=22.5, fmt=None, **kwargs)\n1876 \n1877     When called with no arguments, `.rgrids` simply returns the tuple\n1878     (*lines*, *labels*). When called with arguments, the labels will\n1879     appear at the specified radial distances and angle.\n1880 \n1881     Parameters\n1882     ----------\n1883     radii : tuple with floats\n1884         The radii for the radial gridlines\n1885 \n1886     labels : tuple with strings or None\n1887         The labels to use at each radial gridline. The\n1888         `matplotlib.ticker.ScalarFormatter` will be used if None.\n1889 \n1890     angle : float\n1891         The angular position of the radius labels in degrees.\n1892 \n1893     fmt : str or None\n1894         Format string used in `matplotlib.ticker.FormatStrFormatter`.\n1895         For example '%f'.\n1896 \n1897     Returns\n1898     -------\n1899     lines : list of `.lines.Line2D`\n1900         The radial gridlines.\n1901 \n1902     labels : list of `.text.Text`\n1903         The tick labels.\n1904 \n1905     Other Parameters\n1906     ----------------\n1907     **kwargs\n1908         *kwargs* are optional `.Text` properties for the labels.\n1909 \n1910     See Also\n1911     --------\n1912     .pyplot.thetagrids\n1913     .projections.polar.PolarAxes.set_rgrids\n1914     .Axis.get_gridlines\n1915     .Axis.get_ticklabels\n1916 \n1917     Examples\n1918     --------\n1919     ::\n1920 \n1921       # set the locations of the radial gridlines\n1922       lines, labels = rgrids( (0.25, 0.5, 1.0) )\n1923 \n1924       # set the locations and labels of the radial gridlines\n1925       lines, labels = rgrids( (0.25, 0.5, 1.0), ('Tom', 'Dick', 'Harry' ))\n1926     \"\"\"\n1927     ax = gca()\n1928     if not isinstance(ax, PolarAxes):\n1929         raise RuntimeError('rgrids only defined for polar axes')\n1930     if all(p is None for p in [radii, labels, angle, fmt]) and not kwargs:\n1931         lines = ax.yaxis.get_gridlines()\n1932         labels = ax.yaxis.get_ticklabels()\n1933     else:\n1934         lines, labels = ax.set_rgrids(\n1935             radii, labels=labels, angle=angle, fmt=fmt, **kwargs)\n1936     return lines, labels\n1937 \n1938 \n1939 def thetagrids(angles=None, labels=None, fmt=None, **kwargs):\n1940     \"\"\"\n1941     Get or set the theta gridlines on the current polar plot.\n1942 \n1943     Call signatures::\n1944 \n1945      lines, labels = thetagrids()\n1946      lines, labels = thetagrids(angles, labels=None, fmt=None, **kwargs)\n1947 \n1948     When called with no arguments, `.thetagrids` simply returns the tuple\n1949     (*lines*, *labels*). When called with arguments, the labels will\n1950     appear at the specified angles.\n1951 \n1952     Parameters\n1953     ----------\n1954     angles : tuple with floats, degrees\n1955         The angles of the theta gridlines.\n1956 \n1957     labels : tuple with strings or None\n1958         The labels to use at each radial gridline. The\n1959         `.projections.polar.ThetaFormatter` will be used if None.\n1960 \n1961     fmt : str or None\n1962         Format string used in `matplotlib.ticker.FormatStrFormatter`.\n1963         For example '%f'. Note that the angle in radians will be used.\n1964 \n1965     Returns\n1966     -------\n1967     lines : list of `.lines.Line2D`\n1968         The theta gridlines.\n1969 \n1970     labels : list of `.text.Text`\n1971         The tick labels.\n1972 \n1973     Other Parameters\n1974     ----------------\n1975     **kwargs\n1976         *kwargs* are optional `.Text` properties for the labels.\n1977 \n1978     See Also\n1979     --------\n1980     .pyplot.rgrids\n1981     .projections.polar.PolarAxes.set_thetagrids\n1982     .Axis.get_gridlines\n1983     .Axis.get_ticklabels\n1984 \n1985     Examples\n1986     --------\n1987     ::\n1988 \n1989       # set the locations of the angular gridlines\n1990       lines, labels = thetagrids(range(45, 360, 90))\n1991 \n1992       # set the locations and labels of the angular gridlines\n1993       lines, labels = thetagrids(range(45, 360, 90), ('NE', 'NW', 'SW', 'SE'))\n1994     \"\"\"\n1995     ax = gca()\n1996     if not isinstance(ax, PolarAxes):\n1997         raise RuntimeError('thetagrids only defined for polar axes')\n1998     if all(param is None for param in [angles, labels, fmt]) and not kwargs:\n1999         lines = ax.xaxis.get_ticklines()\n2000         labels = ax.xaxis.get_ticklabels()\n2001     else:\n2002         lines, labels = ax.set_thetagrids(angles,\n2003                                           labels=labels, fmt=fmt, **kwargs)\n2004     return lines, labels\n2005 \n2006 \n2007 ## Plotting Info ##\n2008 \n2009 \n2010 def plotting():\n2011     pass\n2012 \n2013 \n2014 def get_plot_commands():\n2015     \"\"\"\n2016     Get a sorted list of all of the plotting commands.\n2017     \"\"\"\n2018     # This works by searching for all functions in this module and removing\n2019     # a few hard-coded exclusions, as well as all of the colormap-setting\n2020     # functions, and anything marked as private with a preceding underscore.\n2021     exclude = {'colormaps', 'colors', 'connect', 'disconnect',\n2022                'get_plot_commands', 'get_current_fig_manager', 'ginput',\n2023                'plotting', 'waitforbuttonpress'}\n2024     exclude |= set(colormaps)\n2025     this_module = inspect.getmodule(get_plot_commands)\n2026     return sorted(\n2027         name for name, obj in globals().items()\n2028         if not name.startswith('_') and name not in exclude\n2029            and inspect.isfunction(obj)\n2030            and inspect.getmodule(obj) is this_module)\n2031 \n2032 \n2033 def _setup_pyplot_info_docstrings():\n2034     \"\"\"\n2035     Setup the docstring of `plotting` and of the colormap-setting functions.\n2036 \n2037     These must be done after the entire module is imported, so it is called\n2038     from the end of this module, which is generated by boilerplate.py.\n2039     \"\"\"\n2040     commands = get_plot_commands()\n2041 \n2042     first_sentence = re.compile(r\"(?:\\s*).+?\\.(?:\\s+|$)\", flags=re.DOTALL)\n2043 \n2044     # Collect the first sentence of the docstring for all of the\n2045     # plotting commands.\n2046     rows = []\n2047     max_name = len(\"Function\")\n2048     max_summary = len(\"Description\")\n2049     for name in commands:\n2050         doc = globals()[name].__doc__\n2051         summary = ''\n2052         if doc is not None:\n2053             match = first_sentence.match(doc)\n2054             if match is not None:\n2055                 summary = inspect.cleandoc(match.group(0)).replace('\\n', ' ')\n2056         name = '`%s`' % name\n2057         rows.append([name, summary])\n2058         max_name = max(max_name, len(name))\n2059         max_summary = max(max_summary, len(summary))\n2060 \n2061     separator = '=' * max_name + ' ' + '=' * max_summary\n2062     lines = [\n2063         separator,\n2064         '{:{}} {:{}}'.format('Function', max_name, 'Description', max_summary),\n2065         separator,\n2066     ] + [\n2067         '{:{}} {:{}}'.format(name, max_name, summary, max_summary)\n2068         for name, summary in rows\n2069     ] + [\n2070         separator,\n2071     ]\n2072     plotting.__doc__ = '\\n'.join(lines)\n2073 \n2074     for cm_name in colormaps:\n2075         if cm_name in globals():\n2076             globals()[cm_name].__doc__ = f\"\"\"\n2077     Set the colormap to {cm_name!r}.\n2078 \n2079     This changes the default colormap as well as the colormap of the current\n2080     image if there is one. See ``help(colormaps)`` for more information.\n2081     \"\"\"\n2082 \n2083 \n2084 ## Plotting part 1: manually generated functions and wrappers ##\n2085 \n2086 \n2087 @_copy_docstring_and_deprecators(Figure.colorbar)\n2088 def colorbar(mappable=None, cax=None, ax=None, **kwargs):\n2089     if mappable is None:\n2090         mappable = gci()\n2091         if mappable is None:\n2092             raise RuntimeError('No mappable was found to use for colorbar '\n2093                                'creation. First define a mappable such as '\n2094                                'an image (with imshow) or a contour set ('\n2095                                'with contourf).')\n2096     ret = gcf().colorbar(mappable, cax=cax, ax=ax, **kwargs)\n2097     return ret\n2098 \n2099 \n2100 def clim(vmin=None, vmax=None):\n2101     \"\"\"\n2102     Set the color limits of the current image.\n2103 \n2104     If either *vmin* or *vmax* is None, the image min/max respectively\n2105     will be used for color scaling.\n2106 \n2107     If you want to set the clim of multiple images, use\n2108     `~.ScalarMappable.set_clim` on every image, for example::\n2109 \n2110       for im in gca().get_images():\n2111           im.set_clim(0, 0.5)\n2112 \n2113     \"\"\"\n2114     im = gci()\n2115     if im is None:\n2116         raise RuntimeError('You must first define an image, e.g., with imshow')\n2117 \n2118     im.set_clim(vmin, vmax)\n2119 \n2120 \n2121 def set_cmap(cmap):\n2122     \"\"\"\n2123     Set the default colormap, and applies it to the current image if any.\n2124 \n2125     Parameters\n2126     ----------\n2127     cmap : `~matplotlib.colors.Colormap` or str\n2128         A colormap instance or the name of a registered colormap.\n2129 \n2130     See Also\n2131     --------\n2132     colormaps\n2133     matplotlib.cm.register_cmap\n2134     matplotlib.cm.get_cmap\n2135     \"\"\"\n2136     cmap = cm.get_cmap(cmap)\n2137 \n2138     rc('image', cmap=cmap.name)\n2139     im = gci()\n2140 \n2141     if im is not None:\n2142         im.set_cmap(cmap)\n2143 \n2144 \n2145 @_copy_docstring_and_deprecators(matplotlib.image.imread)\n2146 def imread(fname, format=None):\n2147     return matplotlib.image.imread(fname, format)\n2148 \n2149 \n2150 @_copy_docstring_and_deprecators(matplotlib.image.imsave)\n2151 def imsave(fname, arr, **kwargs):\n2152     return matplotlib.image.imsave(fname, arr, **kwargs)\n2153 \n2154 \n2155 def matshow(A, fignum=None, **kwargs):\n2156     \"\"\"\n2157     Display an array as a matrix in a new figure window.\n2158 \n2159     The origin is set at the upper left hand corner and rows (first\n2160     dimension of the array) are displayed horizontally.  The aspect\n2161     ratio of the figure window is that of the array, unless this would\n2162     make an excessively short or narrow figure.\n2163 \n2164     Tick labels for the xaxis are placed on top.\n2165 \n2166     Parameters\n2167     ----------\n2168     A : 2D array-like\n2169         The matrix to be displayed.\n2170 \n2171     fignum : None or int or False\n2172         If *None*, create a new figure window with automatic numbering.\n2173 \n2174         If a nonzero integer, draw into the figure with the given number\n2175         (create it if it does not exist).\n2176 \n2177         If 0, use the current axes (or create one if it does not exist).\n2178 \n2179         .. note::\n2180 \n2181            Because of how `.Axes.matshow` tries to set the figure aspect\n2182            ratio to be the one of the array, strange things may happen if you\n2183            reuse an existing figure.\n2184 \n2185     Returns\n2186     -------\n2187     `~matplotlib.image.AxesImage`\n2188 \n2189     Other Parameters\n2190     ----------------\n2191     **kwargs : `~matplotlib.axes.Axes.imshow` arguments\n2192 \n2193     \"\"\"\n2194     A = np.asanyarray(A)\n2195     if fignum == 0:\n2196         ax = gca()\n2197     else:\n2198         # Extract actual aspect ratio of array and make appropriately sized\n2199         # figure.\n2200         fig = figure(fignum, figsize=figaspect(A))\n2201         ax = fig.add_axes([0.15, 0.09, 0.775, 0.775])\n2202     im = ax.matshow(A, **kwargs)\n2203     sci(im)\n2204     return im\n2205 \n2206 \n2207 def polar(*args, **kwargs):\n2208     \"\"\"\n2209     Make a polar plot.\n2210 \n2211     call signature::\n2212 \n2213       polar(theta, r, **kwargs)\n2214 \n2215     Multiple *theta*, *r* arguments are supported, with format strings, as in\n2216     `plot`.\n2217     \"\"\"\n2218     # If an axis already exists, check if it has a polar projection\n2219     if gcf().get_axes():\n2220         ax = gca()\n2221         if not isinstance(ax, PolarAxes):\n2222             _api.warn_external('Trying to create polar plot on an Axes '\n2223                                'that does not have a polar projection.')\n2224     else:\n2225         ax = axes(projection=\"polar\")\n2226     return ax.plot(*args, **kwargs)\n2227 \n2228 \n2229 # If rcParams['backend_fallback'] is true, and an interactive backend is\n2230 # requested, ignore rcParams['backend'] and force selection of a backend that\n2231 # is compatible with the current running interactive framework.\n2232 if (rcParams[\"backend_fallback\"]\n2233         and dict.__getitem__(rcParams, \"backend\") in (\n2234             set(_interactive_bk) - {'WebAgg', 'nbAgg'})\n2235         and cbook._get_running_interactive_framework()):\n2236     dict.__setitem__(rcParams, \"backend\", rcsetup._auto_backend_sentinel)\n2237 \n2238 \n2239 ################# REMAINING CONTENT GENERATED BY boilerplate.py ##############\n2240 \n2241 \n2242 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2243 @_copy_docstring_and_deprecators(Figure.figimage)\n2244 def figimage(\n2245         X, xo=0, yo=0, alpha=None, norm=None, cmap=None, vmin=None,\n2246         vmax=None, origin=None, resize=False, **kwargs):\n2247     return gcf().figimage(\n2248         X, xo=xo, yo=yo, alpha=alpha, norm=norm, cmap=cmap, vmin=vmin,\n2249         vmax=vmax, origin=origin, resize=resize, **kwargs)\n2250 \n2251 \n2252 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2253 @_copy_docstring_and_deprecators(Figure.text)\n2254 def figtext(x, y, s, fontdict=None, **kwargs):\n2255     return gcf().text(x, y, s, fontdict=fontdict, **kwargs)\n2256 \n2257 \n2258 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2259 @_copy_docstring_and_deprecators(Figure.gca)\n2260 def gca(**kwargs):\n2261     return gcf().gca(**kwargs)\n2262 \n2263 \n2264 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2265 @_copy_docstring_and_deprecators(Figure._gci)\n2266 def gci():\n2267     return gcf()._gci()\n2268 \n2269 \n2270 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2271 @_copy_docstring_and_deprecators(Figure.ginput)\n2272 def ginput(\n2273         n=1, timeout=30, show_clicks=True,\n2274         mouse_add=MouseButton.LEFT, mouse_pop=MouseButton.RIGHT,\n2275         mouse_stop=MouseButton.MIDDLE):\n2276     return gcf().ginput(\n2277         n=n, timeout=timeout, show_clicks=show_clicks,\n2278         mouse_add=mouse_add, mouse_pop=mouse_pop,\n2279         mouse_stop=mouse_stop)\n2280 \n2281 \n2282 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2283 @_copy_docstring_and_deprecators(Figure.subplots_adjust)\n2284 def subplots_adjust(\n2285         left=None, bottom=None, right=None, top=None, wspace=None,\n2286         hspace=None):\n2287     return gcf().subplots_adjust(\n2288         left=left, bottom=bottom, right=right, top=top, wspace=wspace,\n2289         hspace=hspace)\n2290 \n2291 \n2292 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2293 @_copy_docstring_and_deprecators(Figure.suptitle)\n2294 def suptitle(t, **kwargs):\n2295     return gcf().suptitle(t, **kwargs)\n2296 \n2297 \n2298 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2299 @_copy_docstring_and_deprecators(Figure.tight_layout)\n2300 def tight_layout(*, pad=1.08, h_pad=None, w_pad=None, rect=None):\n2301     return gcf().tight_layout(pad=pad, h_pad=h_pad, w_pad=w_pad, rect=rect)\n2302 \n2303 \n2304 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2305 @_copy_docstring_and_deprecators(Figure.waitforbuttonpress)\n2306 def waitforbuttonpress(timeout=-1):\n2307     return gcf().waitforbuttonpress(timeout=timeout)\n2308 \n2309 \n2310 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2311 @_copy_docstring_and_deprecators(Axes.acorr)\n2312 def acorr(x, *, data=None, **kwargs):\n2313     return gca().acorr(\n2314         x, **({\"data\": data} if data is not None else {}), **kwargs)\n2315 \n2316 \n2317 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2318 @_copy_docstring_and_deprecators(Axes.angle_spectrum)\n2319 def angle_spectrum(\n2320         x, Fs=None, Fc=None, window=None, pad_to=None, sides=None, *,\n2321         data=None, **kwargs):\n2322     return gca().angle_spectrum(\n2323         x, Fs=Fs, Fc=Fc, window=window, pad_to=pad_to, sides=sides,\n2324         **({\"data\": data} if data is not None else {}), **kwargs)\n2325 \n2326 \n2327 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2328 @_copy_docstring_and_deprecators(Axes.annotate)\n2329 def annotate(\n2330         text, xy, xytext=None, xycoords='data', textcoords=None,\n2331         arrowprops=None, annotation_clip=None, **kwargs):\n2332     return gca().annotate(\n2333         text, xy, xytext=xytext, xycoords=xycoords,\n2334         textcoords=textcoords, arrowprops=arrowprops,\n2335         annotation_clip=annotation_clip, **kwargs)\n2336 \n2337 \n2338 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2339 @_copy_docstring_and_deprecators(Axes.arrow)\n2340 def arrow(x, y, dx, dy, **kwargs):\n2341     return gca().arrow(x, y, dx, dy, **kwargs)\n2342 \n2343 \n2344 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2345 @_copy_docstring_and_deprecators(Axes.autoscale)\n2346 def autoscale(enable=True, axis='both', tight=None):\n2347     return gca().autoscale(enable=enable, axis=axis, tight=tight)\n2348 \n2349 \n2350 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2351 @_copy_docstring_and_deprecators(Axes.axhline)\n2352 def axhline(y=0, xmin=0, xmax=1, **kwargs):\n2353     return gca().axhline(y=y, xmin=xmin, xmax=xmax, **kwargs)\n2354 \n2355 \n2356 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2357 @_copy_docstring_and_deprecators(Axes.axhspan)\n2358 def axhspan(ymin, ymax, xmin=0, xmax=1, **kwargs):\n2359     return gca().axhspan(ymin, ymax, xmin=xmin, xmax=xmax, **kwargs)\n2360 \n2361 \n2362 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2363 @_copy_docstring_and_deprecators(Axes.axis)\n2364 def axis(*args, emit=True, **kwargs):\n2365     return gca().axis(*args, emit=emit, **kwargs)\n2366 \n2367 \n2368 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2369 @_copy_docstring_and_deprecators(Axes.axline)\n2370 def axline(xy1, xy2=None, *, slope=None, **kwargs):\n2371     return gca().axline(xy1, xy2=xy2, slope=slope, **kwargs)\n2372 \n2373 \n2374 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2375 @_copy_docstring_and_deprecators(Axes.axvline)\n2376 def axvline(x=0, ymin=0, ymax=1, **kwargs):\n2377     return gca().axvline(x=x, ymin=ymin, ymax=ymax, **kwargs)\n2378 \n2379 \n2380 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2381 @_copy_docstring_and_deprecators(Axes.axvspan)\n2382 def axvspan(xmin, xmax, ymin=0, ymax=1, **kwargs):\n2383     return gca().axvspan(xmin, xmax, ymin=ymin, ymax=ymax, **kwargs)\n2384 \n2385 \n2386 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2387 @_copy_docstring_and_deprecators(Axes.bar)\n2388 def bar(\n2389         x, height, width=0.8, bottom=None, *, align='center',\n2390         data=None, **kwargs):\n2391     return gca().bar(\n2392         x, height, width=width, bottom=bottom, align=align,\n2393         **({\"data\": data} if data is not None else {}), **kwargs)\n2394 \n2395 \n2396 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2397 @_copy_docstring_and_deprecators(Axes.barbs)\n2398 def barbs(*args, data=None, **kwargs):\n2399     return gca().barbs(\n2400         *args, **({\"data\": data} if data is not None else {}),\n2401         **kwargs)\n2402 \n2403 \n2404 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2405 @_copy_docstring_and_deprecators(Axes.barh)\n2406 def barh(y, width, height=0.8, left=None, *, align='center', **kwargs):\n2407     return gca().barh(\n2408         y, width, height=height, left=left, align=align, **kwargs)\n2409 \n2410 \n2411 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2412 @_copy_docstring_and_deprecators(Axes.bar_label)\n2413 def bar_label(\n2414         container, labels=None, *, fmt='%g', label_type='edge',\n2415         padding=0, **kwargs):\n2416     return gca().bar_label(\n2417         container, labels=labels, fmt=fmt, label_type=label_type,\n2418         padding=padding, **kwargs)\n2419 \n2420 \n2421 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2422 @_copy_docstring_and_deprecators(Axes.boxplot)\n2423 def boxplot(\n2424         x, notch=None, sym=None, vert=None, whis=None,\n2425         positions=None, widths=None, patch_artist=None,\n2426         bootstrap=None, usermedians=None, conf_intervals=None,\n2427         meanline=None, showmeans=None, showcaps=None, showbox=None,\n2428         showfliers=None, boxprops=None, labels=None, flierprops=None,\n2429         medianprops=None, meanprops=None, capprops=None,\n2430         whiskerprops=None, manage_ticks=True, autorange=False,\n2431         zorder=None, capwidths=None, *, data=None):\n2432     return gca().boxplot(\n2433         x, notch=notch, sym=sym, vert=vert, whis=whis,\n2434         positions=positions, widths=widths, patch_artist=patch_artist,\n2435         bootstrap=bootstrap, usermedians=usermedians,\n2436         conf_intervals=conf_intervals, meanline=meanline,\n2437         showmeans=showmeans, showcaps=showcaps, showbox=showbox,\n2438         showfliers=showfliers, boxprops=boxprops, labels=labels,\n2439         flierprops=flierprops, medianprops=medianprops,\n2440         meanprops=meanprops, capprops=capprops,\n2441         whiskerprops=whiskerprops, manage_ticks=manage_ticks,\n2442         autorange=autorange, zorder=zorder, capwidths=capwidths,\n2443         **({\"data\": data} if data is not None else {}))\n2444 \n2445 \n2446 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2447 @_copy_docstring_and_deprecators(Axes.broken_barh)\n2448 def broken_barh(xranges, yrange, *, data=None, **kwargs):\n2449     return gca().broken_barh(\n2450         xranges, yrange,\n2451         **({\"data\": data} if data is not None else {}), **kwargs)\n2452 \n2453 \n2454 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2455 @_copy_docstring_and_deprecators(Axes.clabel)\n2456 def clabel(CS, levels=None, **kwargs):\n2457     return gca().clabel(CS, levels=levels, **kwargs)\n2458 \n2459 \n2460 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2461 @_copy_docstring_and_deprecators(Axes.cohere)\n2462 def cohere(\n2463         x, y, NFFT=256, Fs=2, Fc=0, detrend=mlab.detrend_none,\n2464         window=mlab.window_hanning, noverlap=0, pad_to=None,\n2465         sides='default', scale_by_freq=None, *, data=None, **kwargs):\n2466     return gca().cohere(\n2467         x, y, NFFT=NFFT, Fs=Fs, Fc=Fc, detrend=detrend, window=window,\n2468         noverlap=noverlap, pad_to=pad_to, sides=sides,\n2469         scale_by_freq=scale_by_freq,\n2470         **({\"data\": data} if data is not None else {}), **kwargs)\n2471 \n2472 \n2473 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2474 @_copy_docstring_and_deprecators(Axes.contour)\n2475 def contour(*args, data=None, **kwargs):\n2476     __ret = gca().contour(\n2477         *args, **({\"data\": data} if data is not None else {}),\n2478         **kwargs)\n2479     if __ret._A is not None: sci(__ret)  # noqa\n2480     return __ret\n2481 \n2482 \n2483 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2484 @_copy_docstring_and_deprecators(Axes.contourf)\n2485 def contourf(*args, data=None, **kwargs):\n2486     __ret = gca().contourf(\n2487         *args, **({\"data\": data} if data is not None else {}),\n2488         **kwargs)\n2489     if __ret._A is not None: sci(__ret)  # noqa\n2490     return __ret\n2491 \n2492 \n2493 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2494 @_copy_docstring_and_deprecators(Axes.csd)\n2495 def csd(\n2496         x, y, NFFT=None, Fs=None, Fc=None, detrend=None, window=None,\n2497         noverlap=None, pad_to=None, sides=None, scale_by_freq=None,\n2498         return_line=None, *, data=None, **kwargs):\n2499     return gca().csd(\n2500         x, y, NFFT=NFFT, Fs=Fs, Fc=Fc, detrend=detrend, window=window,\n2501         noverlap=noverlap, pad_to=pad_to, sides=sides,\n2502         scale_by_freq=scale_by_freq, return_line=return_line,\n2503         **({\"data\": data} if data is not None else {}), **kwargs)\n2504 \n2505 \n2506 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2507 @_copy_docstring_and_deprecators(Axes.errorbar)\n2508 def errorbar(\n2509         x, y, yerr=None, xerr=None, fmt='', ecolor=None,\n2510         elinewidth=None, capsize=None, barsabove=False, lolims=False,\n2511         uplims=False, xlolims=False, xuplims=False, errorevery=1,\n2512         capthick=None, *, data=None, **kwargs):\n2513     return gca().errorbar(\n2514         x, y, yerr=yerr, xerr=xerr, fmt=fmt, ecolor=ecolor,\n2515         elinewidth=elinewidth, capsize=capsize, barsabove=barsabove,\n2516         lolims=lolims, uplims=uplims, xlolims=xlolims,\n2517         xuplims=xuplims, errorevery=errorevery, capthick=capthick,\n2518         **({\"data\": data} if data is not None else {}), **kwargs)\n2519 \n2520 \n2521 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2522 @_copy_docstring_and_deprecators(Axes.eventplot)\n2523 def eventplot(\n2524         positions, orientation='horizontal', lineoffsets=1,\n2525         linelengths=1, linewidths=None, colors=None,\n2526         linestyles='solid', *, data=None, **kwargs):\n2527     return gca().eventplot(\n2528         positions, orientation=orientation, lineoffsets=lineoffsets,\n2529         linelengths=linelengths, linewidths=linewidths, colors=colors,\n2530         linestyles=linestyles,\n2531         **({\"data\": data} if data is not None else {}), **kwargs)\n2532 \n2533 \n2534 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2535 @_copy_docstring_and_deprecators(Axes.fill)\n2536 def fill(*args, data=None, **kwargs):\n2537     return gca().fill(\n2538         *args, **({\"data\": data} if data is not None else {}),\n2539         **kwargs)\n2540 \n2541 \n2542 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2543 @_copy_docstring_and_deprecators(Axes.fill_between)\n2544 def fill_between(\n2545         x, y1, y2=0, where=None, interpolate=False, step=None, *,\n2546         data=None, **kwargs):\n2547     return gca().fill_between(\n2548         x, y1, y2=y2, where=where, interpolate=interpolate, step=step,\n2549         **({\"data\": data} if data is not None else {}), **kwargs)\n2550 \n2551 \n2552 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2553 @_copy_docstring_and_deprecators(Axes.fill_betweenx)\n2554 def fill_betweenx(\n2555         y, x1, x2=0, where=None, step=None, interpolate=False, *,\n2556         data=None, **kwargs):\n2557     return gca().fill_betweenx(\n2558         y, x1, x2=x2, where=where, step=step, interpolate=interpolate,\n2559         **({\"data\": data} if data is not None else {}), **kwargs)\n2560 \n2561 \n2562 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2563 @_copy_docstring_and_deprecators(Axes.grid)\n2564 def grid(visible=None, which='major', axis='both', **kwargs):\n2565     return gca().grid(visible=visible, which=which, axis=axis, **kwargs)\n2566 \n2567 \n2568 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2569 @_copy_docstring_and_deprecators(Axes.hexbin)\n2570 def hexbin(\n2571         x, y, C=None, gridsize=100, bins=None, xscale='linear',\n2572         yscale='linear', extent=None, cmap=None, norm=None, vmin=None,\n2573         vmax=None, alpha=None, linewidths=None, edgecolors='face',\n2574         reduce_C_function=np.mean, mincnt=None, marginals=False, *,\n2575         data=None, **kwargs):\n2576     __ret = gca().hexbin(\n2577         x, y, C=C, gridsize=gridsize, bins=bins, xscale=xscale,\n2578         yscale=yscale, extent=extent, cmap=cmap, norm=norm, vmin=vmin,\n2579         vmax=vmax, alpha=alpha, linewidths=linewidths,\n2580         edgecolors=edgecolors, reduce_C_function=reduce_C_function,\n2581         mincnt=mincnt, marginals=marginals,\n2582         **({\"data\": data} if data is not None else {}), **kwargs)\n2583     sci(__ret)\n2584     return __ret\n2585 \n2586 \n2587 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2588 @_copy_docstring_and_deprecators(Axes.hist)\n2589 def hist(\n2590         x, bins=None, range=None, density=False, weights=None,\n2591         cumulative=False, bottom=None, histtype='bar', align='mid',\n2592         orientation='vertical', rwidth=None, log=False, color=None,\n2593         label=None, stacked=False, *, data=None, **kwargs):\n2594     return gca().hist(\n2595         x, bins=bins, range=range, density=density, weights=weights,\n2596         cumulative=cumulative, bottom=bottom, histtype=histtype,\n2597         align=align, orientation=orientation, rwidth=rwidth, log=log,\n2598         color=color, label=label, stacked=stacked,\n2599         **({\"data\": data} if data is not None else {}), **kwargs)\n2600 \n2601 \n2602 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2603 @_copy_docstring_and_deprecators(Axes.stairs)\n2604 def stairs(\n2605         values, edges=None, *, orientation='vertical', baseline=0,\n2606         fill=False, data=None, **kwargs):\n2607     return gca().stairs(\n2608         values, edges=edges, orientation=orientation,\n2609         baseline=baseline, fill=fill,\n2610         **({\"data\": data} if data is not None else {}), **kwargs)\n2611 \n2612 \n2613 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2614 @_copy_docstring_and_deprecators(Axes.hist2d)\n2615 def hist2d(\n2616         x, y, bins=10, range=None, density=False, weights=None,\n2617         cmin=None, cmax=None, *, data=None, **kwargs):\n2618     __ret = gca().hist2d(\n2619         x, y, bins=bins, range=range, density=density,\n2620         weights=weights, cmin=cmin, cmax=cmax,\n2621         **({\"data\": data} if data is not None else {}), **kwargs)\n2622     sci(__ret[-1])\n2623     return __ret\n2624 \n2625 \n2626 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2627 @_copy_docstring_and_deprecators(Axes.hlines)\n2628 def hlines(\n2629         y, xmin, xmax, colors=None, linestyles='solid', label='', *,\n2630         data=None, **kwargs):\n2631     return gca().hlines(\n2632         y, xmin, xmax, colors=colors, linestyles=linestyles,\n2633         label=label, **({\"data\": data} if data is not None else {}),\n2634         **kwargs)\n2635 \n2636 \n2637 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2638 @_copy_docstring_and_deprecators(Axes.imshow)\n2639 def imshow(\n2640         X, cmap=None, norm=None, aspect=None, interpolation=None,\n2641         alpha=None, vmin=None, vmax=None, origin=None, extent=None, *,\n2642         interpolation_stage=None, filternorm=True, filterrad=4.0,\n2643         resample=None, url=None, data=None, **kwargs):\n2644     __ret = gca().imshow(\n2645         X, cmap=cmap, norm=norm, aspect=aspect,\n2646         interpolation=interpolation, alpha=alpha, vmin=vmin,\n2647         vmax=vmax, origin=origin, extent=extent,\n2648         interpolation_stage=interpolation_stage,\n2649         filternorm=filternorm, filterrad=filterrad, resample=resample,\n2650         url=url, **({\"data\": data} if data is not None else {}),\n2651         **kwargs)\n2652     sci(__ret)\n2653     return __ret\n2654 \n2655 \n2656 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2657 @_copy_docstring_and_deprecators(Axes.legend)\n2658 def legend(*args, **kwargs):\n2659     return gca().legend(*args, **kwargs)\n2660 \n2661 \n2662 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2663 @_copy_docstring_and_deprecators(Axes.locator_params)\n2664 def locator_params(axis='both', tight=None, **kwargs):\n2665     return gca().locator_params(axis=axis, tight=tight, **kwargs)\n2666 \n2667 \n2668 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2669 @_copy_docstring_and_deprecators(Axes.loglog)\n2670 def loglog(*args, **kwargs):\n2671     return gca().loglog(*args, **kwargs)\n2672 \n2673 \n2674 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2675 @_copy_docstring_and_deprecators(Axes.magnitude_spectrum)\n2676 def magnitude_spectrum(\n2677         x, Fs=None, Fc=None, window=None, pad_to=None, sides=None,\n2678         scale=None, *, data=None, **kwargs):\n2679     return gca().magnitude_spectrum(\n2680         x, Fs=Fs, Fc=Fc, window=window, pad_to=pad_to, sides=sides,\n2681         scale=scale, **({\"data\": data} if data is not None else {}),\n2682         **kwargs)\n2683 \n2684 \n2685 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2686 @_copy_docstring_and_deprecators(Axes.margins)\n2687 def margins(*margins, x=None, y=None, tight=True):\n2688     return gca().margins(*margins, x=x, y=y, tight=tight)\n2689 \n2690 \n2691 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2692 @_copy_docstring_and_deprecators(Axes.minorticks_off)\n2693 def minorticks_off():\n2694     return gca().minorticks_off()\n2695 \n2696 \n2697 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2698 @_copy_docstring_and_deprecators(Axes.minorticks_on)\n2699 def minorticks_on():\n2700     return gca().minorticks_on()\n2701 \n2702 \n2703 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2704 @_copy_docstring_and_deprecators(Axes.pcolor)\n2705 def pcolor(\n2706         *args, shading=None, alpha=None, norm=None, cmap=None,\n2707         vmin=None, vmax=None, data=None, **kwargs):\n2708     __ret = gca().pcolor(\n2709         *args, shading=shading, alpha=alpha, norm=norm, cmap=cmap,\n2710         vmin=vmin, vmax=vmax,\n2711         **({\"data\": data} if data is not None else {}), **kwargs)\n2712     sci(__ret)\n2713     return __ret\n2714 \n2715 \n2716 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2717 @_copy_docstring_and_deprecators(Axes.pcolormesh)\n2718 def pcolormesh(\n2719         *args, alpha=None, norm=None, cmap=None, vmin=None,\n2720         vmax=None, shading=None, antialiased=False, data=None,\n2721         **kwargs):\n2722     __ret = gca().pcolormesh(\n2723         *args, alpha=alpha, norm=norm, cmap=cmap, vmin=vmin,\n2724         vmax=vmax, shading=shading, antialiased=antialiased,\n2725         **({\"data\": data} if data is not None else {}), **kwargs)\n2726     sci(__ret)\n2727     return __ret\n2728 \n2729 \n2730 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2731 @_copy_docstring_and_deprecators(Axes.phase_spectrum)\n2732 def phase_spectrum(\n2733         x, Fs=None, Fc=None, window=None, pad_to=None, sides=None, *,\n2734         data=None, **kwargs):\n2735     return gca().phase_spectrum(\n2736         x, Fs=Fs, Fc=Fc, window=window, pad_to=pad_to, sides=sides,\n2737         **({\"data\": data} if data is not None else {}), **kwargs)\n2738 \n2739 \n2740 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2741 @_copy_docstring_and_deprecators(Axes.pie)\n2742 def pie(\n2743         x, explode=None, labels=None, colors=None, autopct=None,\n2744         pctdistance=0.6, shadow=False, labeldistance=1.1,\n2745         startangle=0, radius=1, counterclock=True, wedgeprops=None,\n2746         textprops=None, center=(0, 0), frame=False,\n2747         rotatelabels=False, *, normalize=True, data=None):\n2748     return gca().pie(\n2749         x, explode=explode, labels=labels, colors=colors,\n2750         autopct=autopct, pctdistance=pctdistance, shadow=shadow,\n2751         labeldistance=labeldistance, startangle=startangle,\n2752         radius=radius, counterclock=counterclock,\n2753         wedgeprops=wedgeprops, textprops=textprops, center=center,\n2754         frame=frame, rotatelabels=rotatelabels, normalize=normalize,\n2755         **({\"data\": data} if data is not None else {}))\n2756 \n2757 \n2758 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2759 @_copy_docstring_and_deprecators(Axes.plot)\n2760 def plot(*args, scalex=True, scaley=True, data=None, **kwargs):\n2761     return gca().plot(\n2762         *args, scalex=scalex, scaley=scaley,\n2763         **({\"data\": data} if data is not None else {}), **kwargs)\n2764 \n2765 \n2766 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2767 @_copy_docstring_and_deprecators(Axes.plot_date)\n2768 def plot_date(\n2769         x, y, fmt='o', tz=None, xdate=True, ydate=False, *,\n2770         data=None, **kwargs):\n2771     return gca().plot_date(\n2772         x, y, fmt=fmt, tz=tz, xdate=xdate, ydate=ydate,\n2773         **({\"data\": data} if data is not None else {}), **kwargs)\n2774 \n2775 \n2776 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2777 @_copy_docstring_and_deprecators(Axes.psd)\n2778 def psd(\n2779         x, NFFT=None, Fs=None, Fc=None, detrend=None, window=None,\n2780         noverlap=None, pad_to=None, sides=None, scale_by_freq=None,\n2781         return_line=None, *, data=None, **kwargs):\n2782     return gca().psd(\n2783         x, NFFT=NFFT, Fs=Fs, Fc=Fc, detrend=detrend, window=window,\n2784         noverlap=noverlap, pad_to=pad_to, sides=sides,\n2785         scale_by_freq=scale_by_freq, return_line=return_line,\n2786         **({\"data\": data} if data is not None else {}), **kwargs)\n2787 \n2788 \n2789 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2790 @_copy_docstring_and_deprecators(Axes.quiver)\n2791 def quiver(*args, data=None, **kwargs):\n2792     __ret = gca().quiver(\n2793         *args, **({\"data\": data} if data is not None else {}),\n2794         **kwargs)\n2795     sci(__ret)\n2796     return __ret\n2797 \n2798 \n2799 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2800 @_copy_docstring_and_deprecators(Axes.quiverkey)\n2801 def quiverkey(Q, X, Y, U, label, **kwargs):\n2802     return gca().quiverkey(Q, X, Y, U, label, **kwargs)\n2803 \n2804 \n2805 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2806 @_copy_docstring_and_deprecators(Axes.scatter)\n2807 def scatter(\n2808         x, y, s=None, c=None, marker=None, cmap=None, norm=None,\n2809         vmin=None, vmax=None, alpha=None, linewidths=None, *,\n2810         edgecolors=None, plotnonfinite=False, data=None, **kwargs):\n2811     __ret = gca().scatter(\n2812         x, y, s=s, c=c, marker=marker, cmap=cmap, norm=norm,\n2813         vmin=vmin, vmax=vmax, alpha=alpha, linewidths=linewidths,\n2814         edgecolors=edgecolors, plotnonfinite=plotnonfinite,\n2815         **({\"data\": data} if data is not None else {}), **kwargs)\n2816     sci(__ret)\n2817     return __ret\n2818 \n2819 \n2820 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2821 @_copy_docstring_and_deprecators(Axes.semilogx)\n2822 def semilogx(*args, **kwargs):\n2823     return gca().semilogx(*args, **kwargs)\n2824 \n2825 \n2826 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2827 @_copy_docstring_and_deprecators(Axes.semilogy)\n2828 def semilogy(*args, **kwargs):\n2829     return gca().semilogy(*args, **kwargs)\n2830 \n2831 \n2832 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2833 @_copy_docstring_and_deprecators(Axes.specgram)\n2834 def specgram(\n2835         x, NFFT=None, Fs=None, Fc=None, detrend=None, window=None,\n2836         noverlap=None, cmap=None, xextent=None, pad_to=None,\n2837         sides=None, scale_by_freq=None, mode=None, scale=None,\n2838         vmin=None, vmax=None, *, data=None, **kwargs):\n2839     __ret = gca().specgram(\n2840         x, NFFT=NFFT, Fs=Fs, Fc=Fc, detrend=detrend, window=window,\n2841         noverlap=noverlap, cmap=cmap, xextent=xextent, pad_to=pad_to,\n2842         sides=sides, scale_by_freq=scale_by_freq, mode=mode,\n2843         scale=scale, vmin=vmin, vmax=vmax,\n2844         **({\"data\": data} if data is not None else {}), **kwargs)\n2845     sci(__ret[-1])\n2846     return __ret\n2847 \n2848 \n2849 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2850 @_copy_docstring_and_deprecators(Axes.spy)\n2851 def spy(\n2852         Z, precision=0, marker=None, markersize=None, aspect='equal',\n2853         origin='upper', **kwargs):\n2854     __ret = gca().spy(\n2855         Z, precision=precision, marker=marker, markersize=markersize,\n2856         aspect=aspect, origin=origin, **kwargs)\n2857     if isinstance(__ret, cm.ScalarMappable): sci(__ret)  # noqa\n2858     return __ret\n2859 \n2860 \n2861 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2862 @_copy_docstring_and_deprecators(Axes.stackplot)\n2863 def stackplot(\n2864         x, *args, labels=(), colors=None, baseline='zero', data=None,\n2865         **kwargs):\n2866     return gca().stackplot(\n2867         x, *args, labels=labels, colors=colors, baseline=baseline,\n2868         **({\"data\": data} if data is not None else {}), **kwargs)\n2869 \n2870 \n2871 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2872 @_copy_docstring_and_deprecators(Axes.stem)\n2873 def stem(\n2874         *args, linefmt=None, markerfmt=None, basefmt=None, bottom=0,\n2875         label=None, use_line_collection=True, orientation='vertical',\n2876         data=None):\n2877     return gca().stem(\n2878         *args, linefmt=linefmt, markerfmt=markerfmt, basefmt=basefmt,\n2879         bottom=bottom, label=label,\n2880         use_line_collection=use_line_collection,\n2881         orientation=orientation,\n2882         **({\"data\": data} if data is not None else {}))\n2883 \n2884 \n2885 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2886 @_copy_docstring_and_deprecators(Axes.step)\n2887 def step(x, y, *args, where='pre', data=None, **kwargs):\n2888     return gca().step(\n2889         x, y, *args, where=where,\n2890         **({\"data\": data} if data is not None else {}), **kwargs)\n2891 \n2892 \n2893 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2894 @_copy_docstring_and_deprecators(Axes.streamplot)\n2895 def streamplot(\n2896         x, y, u, v, density=1, linewidth=None, color=None, cmap=None,\n2897         norm=None, arrowsize=1, arrowstyle='-|>', minlength=0.1,\n2898         transform=None, zorder=None, start_points=None, maxlength=4.0,\n2899         integration_direction='both', broken_streamlines=True, *,\n2900         data=None):\n2901     __ret = gca().streamplot(\n2902         x, y, u, v, density=density, linewidth=linewidth, color=color,\n2903         cmap=cmap, norm=norm, arrowsize=arrowsize,\n2904         arrowstyle=arrowstyle, minlength=minlength,\n2905         transform=transform, zorder=zorder, start_points=start_points,\n2906         maxlength=maxlength,\n2907         integration_direction=integration_direction,\n2908         broken_streamlines=broken_streamlines,\n2909         **({\"data\": data} if data is not None else {}))\n2910     sci(__ret.lines)\n2911     return __ret\n2912 \n2913 \n2914 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2915 @_copy_docstring_and_deprecators(Axes.table)\n2916 def table(\n2917         cellText=None, cellColours=None, cellLoc='right',\n2918         colWidths=None, rowLabels=None, rowColours=None,\n2919         rowLoc='left', colLabels=None, colColours=None,\n2920         colLoc='center', loc='bottom', bbox=None, edges='closed',\n2921         **kwargs):\n2922     return gca().table(\n2923         cellText=cellText, cellColours=cellColours, cellLoc=cellLoc,\n2924         colWidths=colWidths, rowLabels=rowLabels,\n2925         rowColours=rowColours, rowLoc=rowLoc, colLabels=colLabels,\n2926         colColours=colColours, colLoc=colLoc, loc=loc, bbox=bbox,\n2927         edges=edges, **kwargs)\n2928 \n2929 \n2930 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2931 @_copy_docstring_and_deprecators(Axes.text)\n2932 def text(x, y, s, fontdict=None, **kwargs):\n2933     return gca().text(x, y, s, fontdict=fontdict, **kwargs)\n2934 \n2935 \n2936 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2937 @_copy_docstring_and_deprecators(Axes.tick_params)\n2938 def tick_params(axis='both', **kwargs):\n2939     return gca().tick_params(axis=axis, **kwargs)\n2940 \n2941 \n2942 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2943 @_copy_docstring_and_deprecators(Axes.ticklabel_format)\n2944 def ticklabel_format(\n2945         *, axis='both', style='', scilimits=None, useOffset=None,\n2946         useLocale=None, useMathText=None):\n2947     return gca().ticklabel_format(\n2948         axis=axis, style=style, scilimits=scilimits,\n2949         useOffset=useOffset, useLocale=useLocale,\n2950         useMathText=useMathText)\n2951 \n2952 \n2953 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2954 @_copy_docstring_and_deprecators(Axes.tricontour)\n2955 def tricontour(*args, **kwargs):\n2956     __ret = gca().tricontour(*args, **kwargs)\n2957     if __ret._A is not None: sci(__ret)  # noqa\n2958     return __ret\n2959 \n2960 \n2961 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2962 @_copy_docstring_and_deprecators(Axes.tricontourf)\n2963 def tricontourf(*args, **kwargs):\n2964     __ret = gca().tricontourf(*args, **kwargs)\n2965     if __ret._A is not None: sci(__ret)  # noqa\n2966     return __ret\n2967 \n2968 \n2969 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2970 @_copy_docstring_and_deprecators(Axes.tripcolor)\n2971 def tripcolor(\n2972         *args, alpha=1.0, norm=None, cmap=None, vmin=None, vmax=None,\n2973         shading='flat', facecolors=None, **kwargs):\n2974     __ret = gca().tripcolor(\n2975         *args, alpha=alpha, norm=norm, cmap=cmap, vmin=vmin,\n2976         vmax=vmax, shading=shading, facecolors=facecolors, **kwargs)\n2977     sci(__ret)\n2978     return __ret\n2979 \n2980 \n2981 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2982 @_copy_docstring_and_deprecators(Axes.triplot)\n2983 def triplot(*args, **kwargs):\n2984     return gca().triplot(*args, **kwargs)\n2985 \n2986 \n2987 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2988 @_copy_docstring_and_deprecators(Axes.violinplot)\n2989 def violinplot(\n2990         dataset, positions=None, vert=True, widths=0.5,\n2991         showmeans=False, showextrema=True, showmedians=False,\n2992         quantiles=None, points=100, bw_method=None, *, data=None):\n2993     return gca().violinplot(\n2994         dataset, positions=positions, vert=vert, widths=widths,\n2995         showmeans=showmeans, showextrema=showextrema,\n2996         showmedians=showmedians, quantiles=quantiles, points=points,\n2997         bw_method=bw_method,\n2998         **({\"data\": data} if data is not None else {}))\n2999 \n3000 \n3001 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n3002 @_copy_docstring_and_deprecators(Axes.vlines)\n3003 def vlines(\n3004         x, ymin, ymax, colors=None, linestyles='solid', label='', *,\n3005         data=None, **kwargs):\n3006     return gca().vlines(\n3007         x, ymin, ymax, colors=colors, linestyles=linestyles,\n3008         label=label, **({\"data\": data} if data is not None else {}),\n3009         **kwargs)\n3010 \n3011 \n3012 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n3013 @_copy_docstring_and_deprecators(Axes.xcorr)\n3014 def xcorr(\n3015         x, y, normed=True, detrend=mlab.detrend_none, usevlines=True,\n3016         maxlags=10, *, data=None, **kwargs):\n3017     return gca().xcorr(\n3018         x, y, normed=normed, detrend=detrend, usevlines=usevlines,\n3019         maxlags=maxlags,\n3020         **({\"data\": data} if data is not None else {}), **kwargs)\n3021 \n3022 \n3023 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n3024 @_copy_docstring_and_deprecators(Axes._sci)\n3025 def sci(im):\n3026     return gca()._sci(im)\n3027 \n3028 \n3029 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n3030 @_copy_docstring_and_deprecators(Axes.set_title)\n3031 def title(label, fontdict=None, loc=None, pad=None, *, y=None, **kwargs):\n3032     return gca().set_title(\n3033         label, fontdict=fontdict, loc=loc, pad=pad, y=y, **kwargs)\n3034 \n3035 \n3036 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n3037 @_copy_docstring_and_deprecators(Axes.set_xlabel)\n3038 def xlabel(xlabel, fontdict=None, labelpad=None, *, loc=None, **kwargs):\n3039     return gca().set_xlabel(\n3040         xlabel, fontdict=fontdict, labelpad=labelpad, loc=loc,\n3041         **kwargs)\n3042 \n3043 \n3044 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n3045 @_copy_docstring_and_deprecators(Axes.set_ylabel)\n3046 def ylabel(ylabel, fontdict=None, labelpad=None, *, loc=None, **kwargs):\n3047     return gca().set_ylabel(\n3048         ylabel, fontdict=fontdict, labelpad=labelpad, loc=loc,\n3049         **kwargs)\n3050 \n3051 \n3052 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n3053 @_copy_docstring_and_deprecators(Axes.set_xscale)\n3054 def xscale(value, **kwargs):\n3055     return gca().set_xscale(value, **kwargs)\n3056 \n3057 \n3058 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n3059 @_copy_docstring_and_deprecators(Axes.set_yscale)\n3060 def yscale(value, **kwargs):\n3061     return gca().set_yscale(value, **kwargs)\n3062 \n3063 \n3064 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n3065 def autumn(): set_cmap('autumn')\n3066 def bone(): set_cmap('bone')\n3067 def cool(): set_cmap('cool')\n3068 def copper(): set_cmap('copper')\n3069 def flag(): set_cmap('flag')\n3070 def gray(): set_cmap('gray')\n3071 def hot(): set_cmap('hot')\n3072 def hsv(): set_cmap('hsv')\n3073 def jet(): set_cmap('jet')\n3074 def pink(): set_cmap('pink')\n3075 def prism(): set_cmap('prism')\n3076 def spring(): set_cmap('spring')\n3077 def summer(): set_cmap('summer')\n3078 def winter(): set_cmap('winter')\n3079 def magma(): set_cmap('magma')\n3080 def inferno(): set_cmap('inferno')\n3081 def plasma(): set_cmap('plasma')\n3082 def viridis(): set_cmap('viridis')\n3083 def nipy_spectral(): set_cmap('nipy_spectral')\n3084 \n3085 \n3086 _setup_pyplot_info_docstrings()\n",
        "intended_behavior": "The code should correctly handle instances when `ax` is contained within a `SubFigure`, not just a standard `Figure`. Currently, it assumes `ax.figure` can always be directly passed to `figure(ax.figure)`, which fails with `SubFigure` instances due to type errors. The fix should include a check if `ax.figure` is a `SubFigure` instance and handle this case appropriately, possibly by navigating to the parent figure if necessary, without changing the behavior for standard figures."
    },
    {
        "rel_file_path": "lib/matplotlib/pyplot.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/matplotlib__matplotlib/setup_matplotlib__matplotlib__3.5/lib/matplotlib/pyplot.py",
        "start": 1,
        "end": 3086,
        "class_name": null,
        "method_name": null,
        "code": "1 # Note: The first part of this file can be modified in place, but the latter\n2 # part is autogenerated by the boilerplate.py script.\n3 \n4 \"\"\"\n5 `matplotlib.pyplot` is a state-based interface to matplotlib. It provides\n6 an implicit,  MATLAB-like, way of plotting.  It also opens figures on your\n7 screen, and acts as the figure GUI manager.\n8 \n9 pyplot is mainly intended for interactive plots and simple cases of\n10 programmatic plot generation::\n11 \n12     import numpy as np\n13     import matplotlib.pyplot as plt\n14 \n15     x = np.arange(0, 5, 0.1)\n16     y = np.sin(x)\n17     plt.plot(x, y)\n18 \n19 The explicit object-oriented API is recommended for complex plots, though\n20 pyplot is still usually used to create the figure and often the axes in the\n21 figure. See `.pyplot.figure`, `.pyplot.subplots`, and\n22 `.pyplot.subplot_mosaic` to create figures, and\n23 :doc:`Axes API <../axes_api>` for the plotting methods on an Axes::\n24 \n25     import numpy as np\n26     import matplotlib.pyplot as plt\n27 \n28     x = np.arange(0, 5, 0.1)\n29     y = np.sin(x)\n30     fig, ax = plt.subplots()\n31     ax.plot(x, y)\n32 \n33 \n34 See :ref:`api_interfaces` for an explanation of the tradeoffs between the\n35 implicit and explicit interfaces.\n36 \"\"\"\n37 \n38 from enum import Enum\n39 import functools\n40 import importlib\n41 import inspect\n42 import logging\n43 from numbers import Number\n44 import re\n45 import sys\n46 import time\n47 try:\n48     import threading\n49 except ImportError:\n50     import dummy_threading as threading\n51 \n52 from cycler import cycler\n53 import matplotlib\n54 import matplotlib.colorbar\n55 import matplotlib.image\n56 from matplotlib import _api\n57 from matplotlib import rcsetup, style\n58 from matplotlib import _pylab_helpers, interactive\n59 from matplotlib import cbook\n60 from matplotlib import _docstring\n61 from matplotlib.backend_bases import FigureCanvasBase, MouseButton\n62 from matplotlib.figure import Figure, figaspect\n63 from matplotlib.gridspec import GridSpec, SubplotSpec\n64 from matplotlib import rcParams, rcParamsDefault, get_backend, rcParamsOrig\n65 from matplotlib.rcsetup import interactive_bk as _interactive_bk\n66 from matplotlib.artist import Artist\n67 from matplotlib.axes import Axes, Subplot\n68 from matplotlib.projections import PolarAxes\n69 from matplotlib import mlab  # for detrend_none, window_hanning\n70 from matplotlib.scale import get_scale_names\n71 \n72 from matplotlib import cm\n73 from matplotlib.cm import _colormaps as colormaps, get_cmap, register_cmap\n74 from matplotlib.colors import _color_sequences as color_sequences\n75 \n76 import numpy as np\n77 \n78 # We may not need the following imports here:\n79 from matplotlib.colors import Normalize\n80 from matplotlib.lines import Line2D\n81 from matplotlib.text import Text, Annotation\n82 from matplotlib.patches import Polygon, Rectangle, Circle, Arrow\n83 from matplotlib.widgets import Button, Slider, Widget\n84 \n85 from .ticker import (\n86     TickHelper, Formatter, FixedFormatter, NullFormatter, FuncFormatter,\n87     FormatStrFormatter, ScalarFormatter, LogFormatter, LogFormatterExponent,\n88     LogFormatterMathtext, Locator, IndexLocator, FixedLocator, NullLocator,\n89     LinearLocator, LogLocator, AutoLocator, MultipleLocator, MaxNLocator)\n90 \n91 _log = logging.getLogger(__name__)\n92 \n93 \n94 def _copy_docstring_and_deprecators(method, func=None):\n95     if func is None:\n96         return functools.partial(_copy_docstring_and_deprecators, method)\n97     decorators = [_docstring.copy(method)]\n98     # Check whether the definition of *method* includes @_api.rename_parameter\n99     # or @_api.make_keyword_only decorators; if so, propagate them to the\n100     # pyplot wrapper as well.\n101     while getattr(method, \"__wrapped__\", None) is not None:\n102         decorator = _api.deprecation.DECORATORS.get(method)\n103         if decorator:\n104             decorators.append(decorator)\n105         method = method.__wrapped__\n106     for decorator in decorators[::-1]:\n107         func = decorator(func)\n108     return func\n109 \n110 \n111 ## Global ##\n112 \n113 \n114 # The state controlled by {,un}install_repl_displayhook().\n115 _ReplDisplayHook = Enum(\"_ReplDisplayHook\", [\"NONE\", \"PLAIN\", \"IPYTHON\"])\n116 _REPL_DISPLAYHOOK = _ReplDisplayHook.NONE\n117 \n118 \n119 def _draw_all_if_interactive():\n120     if matplotlib.is_interactive():\n121         draw_all()\n122 \n123 \n124 def install_repl_displayhook():\n125     \"\"\"\n126     Connect to the display hook of the current shell.\n127 \n128     The display hook gets called when the read-evaluate-print-loop (REPL) of\n129     the shell has finished the execution of a command. We use this callback\n130     to be able to automatically update a figure in interactive mode.\n131 \n132     This works both with IPython and with vanilla python shells.\n133     \"\"\"\n134     global _REPL_DISPLAYHOOK\n135 \n136     if _REPL_DISPLAYHOOK is _ReplDisplayHook.IPYTHON:\n137         return\n138 \n139     # See if we have IPython hooks around, if so use them.\n140     # Use ``sys.modules.get(name)`` rather than ``name in sys.modules`` as\n141     # entries can also have been explicitly set to None.\n142     mod_ipython = sys.modules.get(\"IPython\")\n143     if not mod_ipython:\n144         _REPL_DISPLAYHOOK = _ReplDisplayHook.PLAIN\n145         return\n146     ip = mod_ipython.get_ipython()\n147     if not ip:\n148         _REPL_DISPLAYHOOK = _ReplDisplayHook.PLAIN\n149         return\n150 \n151     ip.events.register(\"post_execute\", _draw_all_if_interactive)\n152     _REPL_DISPLAYHOOK = _ReplDisplayHook.IPYTHON\n153 \n154     from IPython.core.pylabtools import backend2gui\n155     # trigger IPython's eventloop integration, if available\n156     ipython_gui_name = backend2gui.get(get_backend())\n157     if ipython_gui_name:\n158         ip.enable_gui(ipython_gui_name)\n159 \n160 \n161 def uninstall_repl_displayhook():\n162     \"\"\"Disconnect from the display hook of the current shell.\"\"\"\n163     global _REPL_DISPLAYHOOK\n164     if _REPL_DISPLAYHOOK is _ReplDisplayHook.IPYTHON:\n165         from IPython import get_ipython\n166         ip = get_ipython()\n167         ip.events.unregister(\"post_execute\", _draw_all_if_interactive)\n168     _REPL_DISPLAYHOOK = _ReplDisplayHook.NONE\n169 \n170 \n171 draw_all = _pylab_helpers.Gcf.draw_all\n172 \n173 \n174 @_copy_docstring_and_deprecators(matplotlib.set_loglevel)\n175 def set_loglevel(*args, **kwargs):  # Ensure this appears in the pyplot docs.\n176     return matplotlib.set_loglevel(*args, **kwargs)\n177 \n178 \n179 @_copy_docstring_and_deprecators(Artist.findobj)\n180 def findobj(o=None, match=None, include_self=True):\n181     if o is None:\n182         o = gcf()\n183     return o.findobj(match, include_self=include_self)\n184 \n185 \n186 def _get_required_interactive_framework(backend_mod):\n187     if not hasattr(backend_mod.FigureCanvas, \"required_interactive_framework\"):\n188         _api.warn_deprecated(\n189             \"3.6\", name=\"Support for FigureCanvases without a \"\n190             \"required_interactive_framework attribute\")\n191         return None\n192     # Inline this once the deprecation elapses.\n193     return backend_mod.FigureCanvas.required_interactive_framework\n194 \n195 _backend_mod = None\n196 \n197 \n198 def _get_backend_mod():\n199     \"\"\"\n200     Ensure that a backend is selected and return it.\n201 \n202     This is currently private, but may be made public in the future.\n203     \"\"\"\n204     if _backend_mod is None:\n205         # Use __getitem__ here to avoid going through the fallback logic (which\n206         # will (re)import pyplot and then call switch_backend if we need to\n207         # resolve the auto sentinel)\n208         switch_backend(dict.__getitem__(rcParams, \"backend\"))\n209         # Just to be safe.  Interactive mode can be turned on without calling\n210         # `plt.ion()` so register it again here.  This is safe because multiple\n211         # calls to `install_repl_displayhook` are no-ops and the registered\n212         # function respects `mpl.is_interactive()` to determine if it should\n213         # trigger a draw.\n214         install_repl_displayhook()\n215     return _backend_mod\n216 \n217 \n218 def switch_backend(newbackend):\n219     \"\"\"\n220     Close all open figures and set the Matplotlib backend.\n221 \n222     The argument is case-insensitive.  Switching to an interactive backend is\n223     possible only if no event loop for another interactive backend has started.\n224     Switching to and from non-interactive backends is always possible.\n225 \n226     Parameters\n227     ----------\n228     newbackend : str\n229         The name of the backend to use.\n230     \"\"\"\n231     global _backend_mod\n232     # make sure the init is pulled up so we can assign to it later\n233     import matplotlib.backends\n234     close(\"all\")\n235 \n236     if newbackend is rcsetup._auto_backend_sentinel:\n237         current_framework = cbook._get_running_interactive_framework()\n238         mapping = {'qt': 'qtagg',\n239                    'gtk3': 'gtk3agg',\n240                    'gtk4': 'gtk4agg',\n241                    'wx': 'wxagg',\n242                    'tk': 'tkagg',\n243                    'macosx': 'macosx',\n244                    'headless': 'agg'}\n245 \n246         best_guess = mapping.get(current_framework, None)\n247         if best_guess is not None:\n248             candidates = [best_guess]\n249         else:\n250             candidates = []\n251         candidates += [\n252             \"macosx\", \"qtagg\", \"gtk4agg\", \"gtk3agg\", \"tkagg\", \"wxagg\"]\n253 \n254         # Don't try to fallback on the cairo-based backends as they each have\n255         # an additional dependency (pycairo) over the agg-based backend, and\n256         # are of worse quality.\n257         for candidate in candidates:\n258             try:\n259                 switch_backend(candidate)\n260             except ImportError:\n261                 continue\n262             else:\n263                 rcParamsOrig['backend'] = candidate\n264                 return\n265         else:\n266             # Switching to Agg should always succeed; if it doesn't, let the\n267             # exception propagate out.\n268             switch_backend(\"agg\")\n269             rcParamsOrig[\"backend\"] = \"agg\"\n270             return\n271 \n272     # Backends are implemented as modules, but \"inherit\" default method\n273     # implementations from backend_bases._Backend.  This is achieved by\n274     # creating a \"class\" that inherits from backend_bases._Backend and whose\n275     # body is filled with the module's globals.\n276 \n277     backend_name = cbook._backend_module_name(newbackend)\n278 \n279     class backend_mod(matplotlib.backend_bases._Backend):\n280         locals().update(vars(importlib.import_module(backend_name)))\n281 \n282     required_framework = _get_required_interactive_framework(backend_mod)\n283     if required_framework is not None:\n284         current_framework = cbook._get_running_interactive_framework()\n285         if (current_framework and required_framework\n286                 and current_framework != required_framework):\n287             raise ImportError(\n288                 \"Cannot load backend {!r} which requires the {!r} interactive \"\n289                 \"framework, as {!r} is currently running\".format(\n290                     newbackend, required_framework, current_framework))\n291 \n292     _log.debug(\"Loaded backend %s version %s.\",\n293                newbackend, backend_mod.backend_version)\n294 \n295     rcParams['backend'] = rcParamsDefault['backend'] = newbackend\n296     _backend_mod = backend_mod\n297     for func_name in [\"new_figure_manager\", \"draw_if_interactive\", \"show\"]:\n298         globals()[func_name].__signature__ = inspect.signature(\n299             getattr(backend_mod, func_name))\n300 \n301     # Need to keep a global reference to the backend for compatibility reasons.\n302     # See https://github.com/matplotlib/matplotlib/issues/6092\n303     matplotlib.backends.backend = newbackend\n304 \n305 \n306 def _warn_if_gui_out_of_main_thread():\n307     if (_get_required_interactive_framework(_get_backend_mod())\n308             and threading.current_thread() is not threading.main_thread()):\n309         _api.warn_external(\n310             \"Starting a Matplotlib GUI outside of the main thread will likely \"\n311             \"fail.\")\n312 \n313 \n314 # This function's signature is rewritten upon backend-load by switch_backend.\n315 def new_figure_manager(*args, **kwargs):\n316     \"\"\"Create a new figure manager instance.\"\"\"\n317     _warn_if_gui_out_of_main_thread()\n318     return _get_backend_mod().new_figure_manager(*args, **kwargs)\n319 \n320 \n321 # This function's signature is rewritten upon backend-load by switch_backend.\n322 def draw_if_interactive(*args, **kwargs):\n323     \"\"\"\n324     Redraw the current figure if in interactive mode.\n325 \n326     .. warning::\n327 \n328         End users will typically not have to call this function because the\n329         the interactive mode takes care of this.\n330     \"\"\"\n331     return _get_backend_mod().draw_if_interactive(*args, **kwargs)\n332 \n333 \n334 # This function's signature is rewritten upon backend-load by switch_backend.\n335 def show(*args, **kwargs):\n336     \"\"\"\n337     Display all open figures.\n338 \n339     Parameters\n340     ----------\n341     block : bool, optional\n342         Whether to wait for all figures to be closed before returning.\n343 \n344         If `True` block and run the GUI main loop until all figure windows\n345         are closed.\n346 \n347         If `False` ensure that all figure windows are displayed and return\n348         immediately.  In this case, you are responsible for ensuring\n349         that the event loop is running to have responsive figures.\n350 \n351         Defaults to True in non-interactive mode and to False in interactive\n352         mode (see `.pyplot.isinteractive`).\n353 \n354     See Also\n355     --------\n356     ion : Enable interactive mode, which shows / updates the figure after\n357           every plotting command, so that calling ``show()`` is not necessary.\n358     ioff : Disable interactive mode.\n359     savefig : Save the figure to an image file instead of showing it on screen.\n360 \n361     Notes\n362     -----\n363     **Saving figures to file and showing a window at the same time**\n364 \n365     If you want an image file as well as a user interface window, use\n366     `.pyplot.savefig` before `.pyplot.show`. At the end of (a blocking)\n367     ``show()`` the figure is closed and thus unregistered from pyplot. Calling\n368     `.pyplot.savefig` afterwards would save a new and thus empty figure. This\n369     limitation of command order does not apply if the show is non-blocking or\n370     if you keep a reference to the figure and use `.Figure.savefig`.\n371 \n372     **Auto-show in jupyter notebooks**\n373 \n374     The jupyter backends (activated via ``%matplotlib inline``,\n375     ``%matplotlib notebook``, or ``%matplotlib widget``), call ``show()`` at\n376     the end of every cell by default. Thus, you usually don't have to call it\n377     explicitly there.\n378     \"\"\"\n379     _warn_if_gui_out_of_main_thread()\n380     return _get_backend_mod().show(*args, **kwargs)\n381 \n382 \n383 def isinteractive():\n384     \"\"\"\n385     Return whether plots are updated after every plotting command.\n386 \n387     The interactive mode is mainly useful if you build plots from the command\n388     line and want to see the effect of each command while you are building the\n389     figure.\n390 \n391     In interactive mode:\n392 \n393     - newly created figures will be shown immediately;\n394     - figures will automatically redraw on change;\n395     - `.pyplot.show` will not block by default.\n396 \n397     In non-interactive mode:\n398 \n399     - newly created figures and changes to figures will not be reflected until\n400       explicitly asked to be;\n401     - `.pyplot.show` will block by default.\n402 \n403     See Also\n404     --------\n405     ion : Enable interactive mode.\n406     ioff : Disable interactive mode.\n407     show : Show all figures (and maybe block).\n408     pause : Show all figures, and block for a time.\n409     \"\"\"\n410     return matplotlib.is_interactive()\n411 \n412 \n413 class _IoffContext:\n414     \"\"\"\n415     Context manager for `.ioff`.\n416 \n417     The state is changed in ``__init__()`` instead of ``__enter__()``. The\n418     latter is a no-op. This allows using `.ioff` both as a function and\n419     as a context.\n420     \"\"\"\n421 \n422     def __init__(self):\n423         self.wasinteractive = isinteractive()\n424         matplotlib.interactive(False)\n425         uninstall_repl_displayhook()\n426 \n427     def __enter__(self):\n428         pass\n429 \n430     def __exit__(self, exc_type, exc_value, traceback):\n431         if self.wasinteractive:\n432             matplotlib.interactive(True)\n433             install_repl_displayhook()\n434         else:\n435             matplotlib.interactive(False)\n436             uninstall_repl_displayhook()\n437 \n438 \n439 class _IonContext:\n440     \"\"\"\n441     Context manager for `.ion`.\n442 \n443     The state is changed in ``__init__()`` instead of ``__enter__()``. The\n444     latter is a no-op. This allows using `.ion` both as a function and\n445     as a context.\n446     \"\"\"\n447 \n448     def __init__(self):\n449         self.wasinteractive = isinteractive()\n450         matplotlib.interactive(True)\n451         install_repl_displayhook()\n452 \n453     def __enter__(self):\n454         pass\n455 \n456     def __exit__(self, exc_type, exc_value, traceback):\n457         if not self.wasinteractive:\n458             matplotlib.interactive(False)\n459             uninstall_repl_displayhook()\n460         else:\n461             matplotlib.interactive(True)\n462             install_repl_displayhook()\n463 \n464 \n465 def ioff():\n466     \"\"\"\n467     Disable interactive mode.\n468 \n469     See `.pyplot.isinteractive` for more details.\n470 \n471     See Also\n472     --------\n473     ion : Enable interactive mode.\n474     isinteractive : Whether interactive mode is enabled.\n475     show : Show all figures (and maybe block).\n476     pause : Show all figures, and block for a time.\n477 \n478     Notes\n479     -----\n480     For a temporary change, this can be used as a context manager::\n481 \n482         # if interactive mode is on\n483         # then figures will be shown on creation\n484         plt.ion()\n485         # This figure will be shown immediately\n486         fig = plt.figure()\n487 \n488         with plt.ioff():\n489             # interactive mode will be off\n490             # figures will not automatically be shown\n491             fig2 = plt.figure()\n492             # ...\n493 \n494     To enable usage as a context manager, this function returns an\n495     ``_IoffContext`` object. The return value is not intended to be stored\n496     or accessed by the user.\n497     \"\"\"\n498     return _IoffContext()\n499 \n500 \n501 def ion():\n502     \"\"\"\n503     Enable interactive mode.\n504 \n505     See `.pyplot.isinteractive` for more details.\n506 \n507     See Also\n508     --------\n509     ioff : Disable interactive mode.\n510     isinteractive : Whether interactive mode is enabled.\n511     show : Show all figures (and maybe block).\n512     pause : Show all figures, and block for a time.\n513 \n514     Notes\n515     -----\n516     For a temporary change, this can be used as a context manager::\n517 \n518         # if interactive mode is off\n519         # then figures will not be shown on creation\n520         plt.ioff()\n521         # This figure will not be shown immediately\n522         fig = plt.figure()\n523 \n524         with plt.ion():\n525             # interactive mode will be on\n526             # figures will automatically be shown\n527             fig2 = plt.figure()\n528             # ...\n529 \n530     To enable usage as a context manager, this function returns an\n531     ``_IonContext`` object. The return value is not intended to be stored\n532     or accessed by the user.\n533     \"\"\"\n534     return _IonContext()\n535 \n536 \n537 def pause(interval):\n538     \"\"\"\n539     Run the GUI event loop for *interval* seconds.\n540 \n541     If there is an active figure, it will be updated and displayed before the\n542     pause, and the GUI event loop (if any) will run during the pause.\n543 \n544     This can be used for crude animation.  For more complex animation use\n545     :mod:`matplotlib.animation`.\n546 \n547     If there is no active figure, sleep for *interval* seconds instead.\n548 \n549     See Also\n550     --------\n551     matplotlib.animation : Proper animations\n552     show : Show all figures and optional block until all figures are closed.\n553     \"\"\"\n554     manager = _pylab_helpers.Gcf.get_active()\n555     if manager is not None:\n556         canvas = manager.canvas\n557         if canvas.figure.stale:\n558             canvas.draw_idle()\n559         show(block=False)\n560         canvas.start_event_loop(interval)\n561     else:\n562         time.sleep(interval)\n563 \n564 \n565 @_copy_docstring_and_deprecators(matplotlib.rc)\n566 def rc(group, **kwargs):\n567     matplotlib.rc(group, **kwargs)\n568 \n569 \n570 @_copy_docstring_and_deprecators(matplotlib.rc_context)\n571 def rc_context(rc=None, fname=None):\n572     return matplotlib.rc_context(rc, fname)\n573 \n574 \n575 @_copy_docstring_and_deprecators(matplotlib.rcdefaults)\n576 def rcdefaults():\n577     matplotlib.rcdefaults()\n578     if matplotlib.is_interactive():\n579         draw_all()\n580 \n581 \n582 # getp/get/setp are explicitly reexported so that they show up in pyplot docs.\n583 \n584 \n585 @_copy_docstring_and_deprecators(matplotlib.artist.getp)\n586 def getp(obj, *args, **kwargs):\n587     return matplotlib.artist.getp(obj, *args, **kwargs)\n588 \n589 \n590 @_copy_docstring_and_deprecators(matplotlib.artist.get)\n591 def get(obj, *args, **kwargs):\n592     return matplotlib.artist.get(obj, *args, **kwargs)\n593 \n594 \n595 @_copy_docstring_and_deprecators(matplotlib.artist.setp)\n596 def setp(obj, *args, **kwargs):\n597     return matplotlib.artist.setp(obj, *args, **kwargs)\n598 \n599 \n600 def xkcd(scale=1, length=100, randomness=2):\n601     \"\"\"\n602     Turn on `xkcd <https://xkcd.com/>`_ sketch-style drawing mode.  This will\n603     only have effect on things drawn after this function is called.\n604 \n605     For best results, the \"Humor Sans\" font should be installed: it is\n606     not included with Matplotlib.\n607 \n608     Parameters\n609     ----------\n610     scale : float, optional\n611         The amplitude of the wiggle perpendicular to the source line.\n612     length : float, optional\n613         The length of the wiggle along the line.\n614     randomness : float, optional\n615         The scale factor by which the length is shrunken or expanded.\n616 \n617     Notes\n618     -----\n619     This function works by a number of rcParams, so it will probably\n620     override others you have set before.\n621 \n622     If you want the effects of this function to be temporary, it can\n623     be used as a context manager, for example::\n624 \n625         with plt.xkcd():\n626             # This figure will be in XKCD-style\n627             fig1 = plt.figure()\n628             # ...\n629 \n630         # This figure will be in regular style\n631         fig2 = plt.figure()\n632     \"\"\"\n633     return _xkcd(scale, length, randomness)\n634 \n635 \n636 class _xkcd:\n637     # This cannot be implemented in terms of rc_context() because this needs to\n638     # work as a non-contextmanager too.\n639 \n640     def __init__(self, scale, length, randomness):\n641         self._orig = rcParams.copy()\n642 \n643         if rcParams['text.usetex']:\n644             raise RuntimeError(\n645                 \"xkcd mode is not compatible with text.usetex = True\")\n646 \n647         from matplotlib import patheffects\n648         rcParams.update({\n649             'font.family': ['xkcd', 'xkcd Script', 'Humor Sans', 'Comic Neue',\n650                             'Comic Sans MS'],\n651             'font.size': 14.0,\n652             'path.sketch': (scale, length, randomness),\n653             'path.effects': [\n654                 patheffects.withStroke(linewidth=4, foreground=\"w\")],\n655             'axes.linewidth': 1.5,\n656             'lines.linewidth': 2.0,\n657             'figure.facecolor': 'white',\n658             'grid.linewidth': 0.0,\n659             'axes.grid': False,\n660             'axes.unicode_minus': False,\n661             'axes.edgecolor': 'black',\n662             'xtick.major.size': 8,\n663             'xtick.major.width': 3,\n664             'ytick.major.size': 8,\n665             'ytick.major.width': 3,\n666         })\n667 \n668     def __enter__(self):\n669         return self\n670 \n671     def __exit__(self, *args):\n672         dict.update(rcParams, self._orig)\n673 \n674 \n675 ## Figures ##\n676 \n677 @_api.make_keyword_only(\"3.6\", \"facecolor\")\n678 def figure(num=None,  # autoincrement if None, else integer from 1-N\n679            figsize=None,  # defaults to rc figure.figsize\n680            dpi=None,  # defaults to rc figure.dpi\n681            facecolor=None,  # defaults to rc figure.facecolor\n682            edgecolor=None,  # defaults to rc figure.edgecolor\n683            frameon=True,\n684            FigureClass=Figure,\n685            clear=False,\n686            **kwargs\n687            ):\n688     \"\"\"\n689     Create a new figure, or activate an existing figure.\n690 \n691     Parameters\n692     ----------\n693     num : int or str or `.Figure`, optional\n694         A unique identifier for the figure.\n695 \n696         If a figure with that identifier already exists, this figure is made\n697         active and returned. An integer refers to the ``Figure.number``\n698         attribute, a string refers to the figure label.\n699 \n700         If there is no figure with the identifier or *num* is not given, a new\n701         figure is created, made active and returned.  If *num* is an int, it\n702         will be used for the ``Figure.number`` attribute, otherwise, an\n703         auto-generated integer value is used (starting at 1 and incremented\n704         for each new figure). If *num* is a string, the figure label and the\n705         window title is set to this value.\n706 \n707     figsize : (float, float), default: :rc:`figure.figsize`\n708         Width, height in inches.\n709 \n710     dpi : float, default: :rc:`figure.dpi`\n711         The resolution of the figure in dots-per-inch.\n712 \n713     facecolor : color, default: :rc:`figure.facecolor`\n714         The background color.\n715 \n716     edgecolor : color, default: :rc:`figure.edgecolor`\n717         The border color.\n718 \n719     frameon : bool, default: True\n720         If False, suppress drawing the figure frame.\n721 \n722     FigureClass : subclass of `~matplotlib.figure.Figure`\n723         If set, an instance of this subclass will be created, rather than a\n724         plain `.Figure`.\n725 \n726     clear : bool, default: False\n727         If True and the figure already exists, then it is cleared.\n728 \n729     layout : {'constrained', 'tight', `.LayoutEngine`, None}, default: None\n730         The layout mechanism for positioning of plot elements to avoid\n731         overlapping Axes decorations (labels, ticks, etc). Note that layout\n732         managers can measurably slow down figure display. Defaults to *None*\n733         (but see the documentation of the `.Figure` constructor regarding the\n734         interaction with rcParams).\n735 \n736     **kwargs\n737         Additional keyword arguments are passed to the `.Figure` constructor.\n738 \n739     Returns\n740     -------\n741     `~matplotlib.figure.Figure`\n742 \n743     Notes\n744     -----\n745     Newly created figures will be passed to the\n746     `~.backend_template.new_figure_manager` function provided by the current\n747     backend, which will install a canvas and a manager on the figure.\n748 \n749     If you are creating many figures, make sure you explicitly call\n750     `.pyplot.close` on the figures you are not using, because this will\n751     enable pyplot to properly clean up the memory.\n752 \n753     `~matplotlib.rcParams` defines the default values, which can be modified\n754     in the matplotlibrc file.\n755     \"\"\"\n756     if isinstance(num, Figure):\n757         if num.canvas.manager is None:\n758             raise ValueError(\"The passed figure is not managed by pyplot\")\n759         _pylab_helpers.Gcf.set_active(num.canvas.manager)\n760         return num\n761 \n762     allnums = get_fignums()\n763     next_num = max(allnums) + 1 if allnums else 1\n764     fig_label = ''\n765     if num is None:\n766         num = next_num\n767     elif isinstance(num, str):\n768         fig_label = num\n769         all_labels = get_figlabels()\n770         if fig_label not in all_labels:\n771             if fig_label == 'all':\n772                 _api.warn_external(\"close('all') closes all existing figures.\")\n773             num = next_num\n774         else:\n775             inum = all_labels.index(fig_label)\n776             num = allnums[inum]\n777     else:\n778         num = int(num)  # crude validation of num argument\n779 \n780     manager = _pylab_helpers.Gcf.get_fig_manager(num)\n781     if manager is None:\n782         max_open_warning = rcParams['figure.max_open_warning']\n783         if len(allnums) == max_open_warning >= 1:\n784             _api.warn_external(\n785                 f\"More than {max_open_warning} figures have been opened. \"\n786                 f\"Figures created through the pyplot interface \"\n787                 f\"(`matplotlib.pyplot.figure`) are retained until explicitly \"\n788                 f\"closed and may consume too much memory. (To control this \"\n789                 f\"warning, see the rcParam `figure.max_open_warning`).\",\n790                 RuntimeWarning)\n791 \n792         manager = new_figure_manager(\n793             num, figsize=figsize, dpi=dpi,\n794             facecolor=facecolor, edgecolor=edgecolor, frameon=frameon,\n795             FigureClass=FigureClass, **kwargs)\n796         fig = manager.canvas.figure\n797         if fig_label:\n798             fig.set_label(fig_label)\n799 \n800         _pylab_helpers.Gcf._set_new_active_manager(manager)\n801 \n802         # make sure backends (inline) that we don't ship that expect this\n803         # to be called in plotting commands to make the figure call show\n804         # still work.  There is probably a better way to do this in the\n805         # FigureManager base class.\n806         draw_if_interactive()\n807 \n808         if _REPL_DISPLAYHOOK is _ReplDisplayHook.PLAIN:\n809             fig.stale_callback = _auto_draw_if_interactive\n810 \n811     if clear:\n812         manager.canvas.figure.clear()\n813 \n814     return manager.canvas.figure\n815 \n816 \n817 def _auto_draw_if_interactive(fig, val):\n818     \"\"\"\n819     An internal helper function for making sure that auto-redrawing\n820     works as intended in the plain python repl.\n821 \n822     Parameters\n823     ----------\n824     fig : Figure\n825         A figure object which is assumed to be associated with a canvas\n826     \"\"\"\n827     if (val and matplotlib.is_interactive()\n828             and not fig.canvas.is_saving()\n829             and not fig.canvas._is_idle_drawing):\n830         # Some artists can mark themselves as stale in the middle of drawing\n831         # (e.g. axes position & tick labels being computed at draw time), but\n832         # this shouldn't trigger a redraw because the current redraw will\n833         # already take them into account.\n834         with fig.canvas._idle_draw_cntx():\n835             fig.canvas.draw_idle()\n836 \n837 \n838 def gcf():\n839     \"\"\"\n840     Get the current figure.\n841 \n842     If there is currently no figure on the pyplot figure stack, a new one is\n843     created using `~.pyplot.figure()`.  (To test whether there is currently a\n844     figure on the pyplot figure stack, check whether `~.pyplot.get_fignums()`\n845     is empty.)\n846     \"\"\"\n847     manager = _pylab_helpers.Gcf.get_active()\n848     if manager is not None:\n849         return manager.canvas.figure\n850     else:\n851         return figure()\n852 \n853 \n854 def fignum_exists(num):\n855     \"\"\"Return whether the figure with the given id exists.\"\"\"\n856     return _pylab_helpers.Gcf.has_fignum(num) or num in get_figlabels()\n857 \n858 \n859 def get_fignums():\n860     \"\"\"Return a list of existing figure numbers.\"\"\"\n861     return sorted(_pylab_helpers.Gcf.figs)\n862 \n863 \n864 def get_figlabels():\n865     \"\"\"Return a list of existing figure labels.\"\"\"\n866     managers = _pylab_helpers.Gcf.get_all_fig_managers()\n867     managers.sort(key=lambda m: m.num)\n868     return [m.canvas.figure.get_label() for m in managers]\n869 \n870 \n871 def get_current_fig_manager():\n872     \"\"\"\n873     Return the figure manager of the current figure.\n874 \n875     The figure manager is a container for the actual backend-depended window\n876     that displays the figure on screen.\n877 \n878     If no current figure exists, a new one is created, and its figure\n879     manager is returned.\n880 \n881     Returns\n882     -------\n883     `.FigureManagerBase` or backend-dependent subclass thereof\n884     \"\"\"\n885     return gcf().canvas.manager\n886 \n887 \n888 @_copy_docstring_and_deprecators(FigureCanvasBase.mpl_connect)\n889 def connect(s, func):\n890     return gcf().canvas.mpl_connect(s, func)\n891 \n892 \n893 @_copy_docstring_and_deprecators(FigureCanvasBase.mpl_disconnect)\n894 def disconnect(cid):\n895     return gcf().canvas.mpl_disconnect(cid)\n896 \n897 \n898 def close(fig=None):\n899     \"\"\"\n900     Close a figure window.\n901 \n902     Parameters\n903     ----------\n904     fig : None or int or str or `.Figure`\n905         The figure to close. There are a number of ways to specify this:\n906 \n907         - *None*: the current figure\n908         - `.Figure`: the given `.Figure` instance\n909         - ``int``: a figure number\n910         - ``str``: a figure name\n911         - 'all': all figures\n912 \n913     \"\"\"\n914     if fig is None:\n915         manager = _pylab_helpers.Gcf.get_active()\n916         if manager is None:\n917             return\n918         else:\n919             _pylab_helpers.Gcf.destroy(manager)\n920     elif fig == 'all':\n921         _pylab_helpers.Gcf.destroy_all()\n922     elif isinstance(fig, int):\n923         _pylab_helpers.Gcf.destroy(fig)\n924     elif hasattr(fig, 'int'):\n925         # if we are dealing with a type UUID, we\n926         # can use its integer representation\n927         _pylab_helpers.Gcf.destroy(fig.int)\n928     elif isinstance(fig, str):\n929         all_labels = get_figlabels()\n930         if fig in all_labels:\n931             num = get_fignums()[all_labels.index(fig)]\n932             _pylab_helpers.Gcf.destroy(num)\n933     elif isinstance(fig, Figure):\n934         _pylab_helpers.Gcf.destroy_fig(fig)\n935     else:\n936         raise TypeError(\"close() argument must be a Figure, an int, a string, \"\n937                         \"or None, not %s\" % type(fig))\n938 \n939 \n940 def clf():\n941     \"\"\"Clear the current figure.\"\"\"\n942     gcf().clear()\n943 \n944 \n945 def draw():\n946     \"\"\"\n947     Redraw the current figure.\n948 \n949     This is used to update a figure that has been altered, but not\n950     automatically re-drawn.  If interactive mode is on (via `.ion()`), this\n951     should be only rarely needed, but there may be ways to modify the state of\n952     a figure without marking it as \"stale\".  Please report these cases as bugs.\n953 \n954     This is equivalent to calling ``fig.canvas.draw_idle()``, where ``fig`` is\n955     the current figure.\n956     \"\"\"\n957     gcf().canvas.draw_idle()\n958 \n959 \n960 @_copy_docstring_and_deprecators(Figure.savefig)\n961 def savefig(*args, **kwargs):\n962     fig = gcf()\n963     res = fig.savefig(*args, **kwargs)\n964     fig.canvas.draw_idle()  # Need this if 'transparent=True', to reset colors.\n965     return res\n966 \n967 \n968 ## Putting things in figures ##\n969 \n970 \n971 def figlegend(*args, **kwargs):\n972     return gcf().legend(*args, **kwargs)\n973 if Figure.legend.__doc__:\n974     figlegend.__doc__ = Figure.legend.__doc__.replace(\"legend(\", \"figlegend(\")\n975 \n976 \n977 ## Axes ##\n978 \n979 @_docstring.dedent_interpd\n980 def axes(arg=None, **kwargs):\n981     \"\"\"\n982     Add an Axes to the current figure and make it the current Axes.\n983 \n984     Call signatures::\n985 \n986         plt.axes()\n987         plt.axes(rect, projection=None, polar=False, **kwargs)\n988         plt.axes(ax)\n989 \n990     Parameters\n991     ----------\n992     arg : None or 4-tuple\n993         The exact behavior of this function depends on the type:\n994 \n995         - *None*: A new full window Axes is added using\n996           ``subplot(**kwargs)``.\n997         - 4-tuple of floats *rect* = ``[left, bottom, width, height]``.\n998           A new Axes is added with dimensions *rect* in normalized\n999           (0, 1) units using `~.Figure.add_axes` on the current figure.\n1000 \n1001     projection : {None, 'aitoff', 'hammer', 'lambert', 'mollweide', \\\n1002 'polar', 'rectilinear', str}, optional\n1003         The projection type of the `~.axes.Axes`. *str* is the name of\n1004         a custom projection, see `~matplotlib.projections`. The default\n1005         None results in a 'rectilinear' projection.\n1006 \n1007     polar : bool, default: False\n1008         If True, equivalent to projection='polar'.\n1009 \n1010     sharex, sharey : `~.axes.Axes`, optional\n1011         Share the x or y `~matplotlib.axis` with sharex and/or sharey.\n1012         The axis will have the same limits, ticks, and scale as the axis\n1013         of the shared Axes.\n1014 \n1015     label : str\n1016         A label for the returned Axes.\n1017 \n1018     Returns\n1019     -------\n1020     `~.axes.Axes`, or a subclass of `~.axes.Axes`\n1021         The returned axes class depends on the projection used. It is\n1022         `~.axes.Axes` if rectilinear projection is used and\n1023         `.projections.polar.PolarAxes` if polar projection is used.\n1024 \n1025     Other Parameters\n1026     ----------------\n1027     **kwargs\n1028         This method also takes the keyword arguments for\n1029         the returned Axes class. The keyword arguments for the\n1030         rectilinear Axes class `~.axes.Axes` can be found in\n1031         the following table but there might also be other keyword\n1032         arguments if another projection is used, see the actual Axes\n1033         class.\n1034 \n1035         %(Axes:kwdoc)s\n1036 \n1037     Notes\n1038     -----\n1039     If the figure already has an Axes with key (*args*,\n1040     *kwargs*) then it will simply make that axes current and\n1041     return it.  This behavior is deprecated. Meanwhile, if you do\n1042     not want this behavior (i.e., you want to force the creation of a\n1043     new axes), you must use a unique set of args and kwargs.  The Axes\n1044     *label* attribute has been exposed for this purpose: if you want\n1045     two Axes that are otherwise identical to be added to the figure,\n1046     make sure you give them unique labels.\n1047 \n1048     See Also\n1049     --------\n1050     .Figure.add_axes\n1051     .pyplot.subplot\n1052     .Figure.add_subplot\n1053     .Figure.subplots\n1054     .pyplot.subplots\n1055 \n1056     Examples\n1057     --------\n1058     ::\n1059 \n1060         # Creating a new full window Axes\n1061         plt.axes()\n1062 \n1063         # Creating a new Axes with specified dimensions and a grey background\n1064         plt.axes((left, bottom, width, height), facecolor='grey')\n1065     \"\"\"\n1066     fig = gcf()\n1067     pos = kwargs.pop('position', None)\n1068     if arg is None:\n1069         if pos is None:\n1070             return fig.add_subplot(**kwargs)\n1071         else:\n1072             return fig.add_axes(pos, **kwargs)\n1073     else:\n1074         return fig.add_axes(arg, **kwargs)\n1075 \n1076 \n1077 def delaxes(ax=None):\n1078     \"\"\"\n1079     Remove an `~.axes.Axes` (defaulting to the current axes) from its figure.\n1080     \"\"\"\n1081     if ax is None:\n1082         ax = gca()\n1083     ax.remove()\n1084 \n1085 \n1086 def sca(ax):\n1087     \"\"\"\n1088     Set the current Axes to *ax* and the current Figure to the parent of *ax*.\n1089     \"\"\"\n1090     figure(ax.figure)\n1091     ax.figure.sca(ax)\n1092 \n1093 \n1094 def cla():\n1095     \"\"\"Clear the current axes.\"\"\"\n1096     # Not generated via boilerplate.py to allow a different docstring.\n1097     return gca().cla()\n1098 \n1099 \n1100 ## More ways of creating axes ##\n1101 \n1102 @_docstring.dedent_interpd\n1103 def subplot(*args, **kwargs):\n1104     \"\"\"\n1105     Add an Axes to the current figure or retrieve an existing Axes.\n1106 \n1107     This is a wrapper of `.Figure.add_subplot` which provides additional\n1108     behavior when working with the implicit API (see the notes section).\n1109 \n1110     Call signatures::\n1111 \n1112        subplot(nrows, ncols, index, **kwargs)\n1113        subplot(pos, **kwargs)\n1114        subplot(**kwargs)\n1115        subplot(ax)\n1116 \n1117     Parameters\n1118     ----------\n1119     *args : int, (int, int, *index*), or `.SubplotSpec`, default: (1, 1, 1)\n1120         The position of the subplot described by one of\n1121 \n1122         - Three integers (*nrows*, *ncols*, *index*). The subplot will take the\n1123           *index* position on a grid with *nrows* rows and *ncols* columns.\n1124           *index* starts at 1 in the upper left corner and increases to the\n1125           right. *index* can also be a two-tuple specifying the (*first*,\n1126           *last*) indices (1-based, and including *last*) of the subplot, e.g.,\n1127           ``fig.add_subplot(3, 1, (1, 2))`` makes a subplot that spans the\n1128           upper 2/3 of the figure.\n1129         - A 3-digit integer. The digits are interpreted as if given separately\n1130           as three single-digit integers, i.e. ``fig.add_subplot(235)`` is the\n1131           same as ``fig.add_subplot(2, 3, 5)``. Note that this can only be used\n1132           if there are no more than 9 subplots.\n1133         - A `.SubplotSpec`.\n1134 \n1135     projection : {None, 'aitoff', 'hammer', 'lambert', 'mollweide', \\\n1136 'polar', 'rectilinear', str}, optional\n1137         The projection type of the subplot (`~.axes.Axes`). *str* is the name\n1138         of a custom projection, see `~matplotlib.projections`. The default\n1139         None results in a 'rectilinear' projection.\n1140 \n1141     polar : bool, default: False\n1142         If True, equivalent to projection='polar'.\n1143 \n1144     sharex, sharey : `~.axes.Axes`, optional\n1145         Share the x or y `~matplotlib.axis` with sharex and/or sharey. The\n1146         axis will have the same limits, ticks, and scale as the axis of the\n1147         shared axes.\n1148 \n1149     label : str\n1150         A label for the returned axes.\n1151 \n1152     Returns\n1153     -------\n1154     `.axes.SubplotBase`, or another subclass of `~.axes.Axes`\n1155 \n1156         The axes of the subplot. The returned axes base class depends on\n1157         the projection used. It is `~.axes.Axes` if rectilinear projection\n1158         is used and `.projections.polar.PolarAxes` if polar projection\n1159         is used. The returned axes is then a subplot subclass of the\n1160         base class.\n1161 \n1162     Other Parameters\n1163     ----------------\n1164     **kwargs\n1165         This method also takes the keyword arguments for the returned axes\n1166         base class; except for the *figure* argument. The keyword arguments\n1167         for the rectilinear base class `~.axes.Axes` can be found in\n1168         the following table but there might also be other keyword\n1169         arguments if another projection is used.\n1170 \n1171         %(Axes:kwdoc)s\n1172 \n1173     Notes\n1174     -----\n1175     Creating a new Axes will delete any pre-existing Axes that\n1176     overlaps with it beyond sharing a boundary::\n1177 \n1178         import matplotlib.pyplot as plt\n1179         # plot a line, implicitly creating a subplot(111)\n1180         plt.plot([1, 2, 3])\n1181         # now create a subplot which represents the top plot of a grid\n1182         # with 2 rows and 1 column. Since this subplot will overlap the\n1183         # first, the plot (and its axes) previously created, will be removed\n1184         plt.subplot(211)\n1185 \n1186     If you do not want this behavior, use the `.Figure.add_subplot` method\n1187     or the `.pyplot.axes` function instead.\n1188 \n1189     If no *kwargs* are passed and there exists an Axes in the location\n1190     specified by *args* then that Axes will be returned rather than a new\n1191     Axes being created.\n1192 \n1193     If *kwargs* are passed and there exists an Axes in the location\n1194     specified by *args*, the projection type is the same, and the\n1195     *kwargs* match with the existing Axes, then the existing Axes is\n1196     returned.  Otherwise a new Axes is created with the specified\n1197     parameters.  We save a reference to the *kwargs* which we use\n1198     for this comparison.  If any of the values in *kwargs* are\n1199     mutable we will not detect the case where they are mutated.\n1200     In these cases we suggest using `.Figure.add_subplot` and the\n1201     explicit Axes API rather than the implicit pyplot API.\n1202 \n1203     See Also\n1204     --------\n1205     .Figure.add_subplot\n1206     .pyplot.subplots\n1207     .pyplot.axes\n1208     .Figure.subplots\n1209 \n1210     Examples\n1211     --------\n1212     ::\n1213 \n1214         plt.subplot(221)\n1215 \n1216         # equivalent but more general\n1217         ax1 = plt.subplot(2, 2, 1)\n1218 \n1219         # add a subplot with no frame\n1220         ax2 = plt.subplot(222, frameon=False)\n1221 \n1222         # add a polar subplot\n1223         plt.subplot(223, projection='polar')\n1224 \n1225         # add a red subplot that shares the x-axis with ax1\n1226         plt.subplot(224, sharex=ax1, facecolor='red')\n1227 \n1228         # delete ax2 from the figure\n1229         plt.delaxes(ax2)\n1230 \n1231         # add ax2 to the figure again\n1232         plt.subplot(ax2)\n1233 \n1234         # make the first axes \"current\" again\n1235         plt.subplot(221)\n1236 \n1237     \"\"\"\n1238     # Here we will only normalize `polar=True` vs `projection='polar'` and let\n1239     # downstream code deal with the rest.\n1240     unset = object()\n1241     projection = kwargs.get('projection', unset)\n1242     polar = kwargs.pop('polar', unset)\n1243     if polar is not unset and polar:\n1244         # if we got mixed messages from the user, raise\n1245         if projection is not unset and projection != 'polar':\n1246             raise ValueError(\n1247                 f\"polar={polar}, yet projection={projection!r}. \"\n1248                 \"Only one of these arguments should be supplied.\"\n1249             )\n1250         kwargs['projection'] = projection = 'polar'\n1251 \n1252     # if subplot called without arguments, create subplot(1, 1, 1)\n1253     if len(args) == 0:\n1254         args = (1, 1, 1)\n1255 \n1256     # This check was added because it is very easy to type subplot(1, 2, False)\n1257     # when subplots(1, 2, False) was intended (sharex=False, that is). In most\n1258     # cases, no error will ever occur, but mysterious behavior can result\n1259     # because what was intended to be the sharex argument is instead treated as\n1260     # a subplot index for subplot()\n1261     if len(args) >= 3 and isinstance(args[2], bool):\n1262         _api.warn_external(\"The subplot index argument to subplot() appears \"\n1263                            \"to be a boolean. Did you intend to use \"\n1264                            \"subplots()?\")\n1265     # Check for nrows and ncols, which are not valid subplot args:\n1266     if 'nrows' in kwargs or 'ncols' in kwargs:\n1267         raise TypeError(\"subplot() got an unexpected keyword argument 'ncols' \"\n1268                         \"and/or 'nrows'.  Did you intend to call subplots()?\")\n1269 \n1270     fig = gcf()\n1271 \n1272     # First, search for an existing subplot with a matching spec.\n1273     key = SubplotSpec._from_subplot_args(fig, args)\n1274 \n1275     for ax in fig.axes:\n1276         # if we found an Axes at the position sort out if we can re-use it\n1277         if hasattr(ax, 'get_subplotspec') and ax.get_subplotspec() == key:\n1278             # if the user passed no kwargs, re-use\n1279             if kwargs == {}:\n1280                 break\n1281             # if the axes class and kwargs are identical, reuse\n1282             elif ax._projection_init == fig._process_projection_requirements(\n1283                 *args, **kwargs\n1284             ):\n1285                 break\n1286     else:\n1287         # we have exhausted the known Axes and none match, make a new one!\n1288         ax = fig.add_subplot(*args, **kwargs)\n1289 \n1290     fig.sca(ax)\n1291 \n1292     axes_to_delete = [other for other in fig.axes\n1293                       if other != ax and ax.bbox.fully_overlaps(other.bbox)]\n1294     if axes_to_delete:\n1295         _api.warn_deprecated(\n1296             \"3.6\", message=\"Auto-removal of overlapping axes is deprecated \"\n1297             \"since %(since)s and will be removed %(removal)s; explicitly call \"\n1298             \"ax.remove() as needed.\")\n1299     for ax_to_del in axes_to_delete:\n1300         delaxes(ax_to_del)\n1301 \n1302     return ax\n1303 \n1304 \n1305 def subplots(nrows=1, ncols=1, *, sharex=False, sharey=False, squeeze=True,\n1306              subplot_kw=None, gridspec_kw=None, **fig_kw):\n1307     \"\"\"\n1308     Create a figure and a set of subplots.\n1309 \n1310     This utility wrapper makes it convenient to create common layouts of\n1311     subplots, including the enclosing figure object, in a single call.\n1312 \n1313     Parameters\n1314     ----------\n1315     nrows, ncols : int, default: 1\n1316         Number of rows/columns of the subplot grid.\n1317 \n1318     sharex, sharey : bool or {'none', 'all', 'row', 'col'}, default: False\n1319         Controls sharing of properties among x (*sharex*) or y (*sharey*)\n1320         axes:\n1321 \n1322         - True or 'all': x- or y-axis will be shared among all subplots.\n1323         - False or 'none': each subplot x- or y-axis will be independent.\n1324         - 'row': each subplot row will share an x- or y-axis.\n1325         - 'col': each subplot column will share an x- or y-axis.\n1326 \n1327         When subplots have a shared x-axis along a column, only the x tick\n1328         labels of the bottom subplot are created. Similarly, when subplots\n1329         have a shared y-axis along a row, only the y tick labels of the first\n1330         column subplot are created. To later turn other subplots' ticklabels\n1331         on, use `~matplotlib.axes.Axes.tick_params`.\n1332 \n1333         When subplots have a shared axis that has units, calling\n1334         `~matplotlib.axis.Axis.set_units` will update each axis with the\n1335         new units.\n1336 \n1337     squeeze : bool, default: True\n1338         - If True, extra dimensions are squeezed out from the returned\n1339           array of `~matplotlib.axes.Axes`:\n1340 \n1341           - if only one subplot is constructed (nrows=ncols=1), the\n1342             resulting single Axes object is returned as a scalar.\n1343           - for Nx1 or 1xM subplots, the returned object is a 1D numpy\n1344             object array of Axes objects.\n1345           - for NxM, subplots with N>1 and M>1 are returned as a 2D array.\n1346 \n1347         - If False, no squeezing at all is done: the returned Axes object is\n1348           always a 2D array containing Axes instances, even if it ends up\n1349           being 1x1.\n1350 \n1351     subplot_kw : dict, optional\n1352         Dict with keywords passed to the\n1353         `~matplotlib.figure.Figure.add_subplot` call used to create each\n1354         subplot.\n1355 \n1356     gridspec_kw : dict, optional\n1357         Dict with keywords passed to the `~matplotlib.gridspec.GridSpec`\n1358         constructor used to create the grid the subplots are placed on.\n1359 \n1360     **fig_kw\n1361         All additional keyword arguments are passed to the\n1362         `.pyplot.figure` call.\n1363 \n1364     Returns\n1365     -------\n1366     fig : `.Figure`\n1367 \n1368     ax : `~.axes.Axes` or array of Axes\n1369         *ax* can be either a single `~.axes.Axes` object, or an array of Axes\n1370         objects if more than one subplot was created.  The dimensions of the\n1371         resulting array can be controlled with the squeeze keyword, see above.\n1372 \n1373         Typical idioms for handling the return value are::\n1374 \n1375             # using the variable ax for single a Axes\n1376             fig, ax = plt.subplots()\n1377 \n1378             # using the variable axs for multiple Axes\n1379             fig, axs = plt.subplots(2, 2)\n1380 \n1381             # using tuple unpacking for multiple Axes\n1382             fig, (ax1, ax2) = plt.subplots(1, 2)\n1383             fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2)\n1384 \n1385         The names ``ax`` and pluralized ``axs`` are preferred over ``axes``\n1386         because for the latter it's not clear if it refers to a single\n1387         `~.axes.Axes` instance or a collection of these.\n1388 \n1389     See Also\n1390     --------\n1391     .pyplot.figure\n1392     .pyplot.subplot\n1393     .pyplot.axes\n1394     .Figure.subplots\n1395     .Figure.add_subplot\n1396 \n1397     Examples\n1398     --------\n1399     ::\n1400 \n1401         # First create some toy data:\n1402         x = np.linspace(0, 2*np.pi, 400)\n1403         y = np.sin(x**2)\n1404 \n1405         # Create just a figure and only one subplot\n1406         fig, ax = plt.subplots()\n1407         ax.plot(x, y)\n1408         ax.set_title('Simple plot')\n1409 \n1410         # Create two subplots and unpack the output array immediately\n1411         f, (ax1, ax2) = plt.subplots(1, 2, sharey=True)\n1412         ax1.plot(x, y)\n1413         ax1.set_title('Sharing Y axis')\n1414         ax2.scatter(x, y)\n1415 \n1416         # Create four polar axes and access them through the returned array\n1417         fig, axs = plt.subplots(2, 2, subplot_kw=dict(projection=\"polar\"))\n1418         axs[0, 0].plot(x, y)\n1419         axs[1, 1].scatter(x, y)\n1420 \n1421         # Share a X axis with each column of subplots\n1422         plt.subplots(2, 2, sharex='col')\n1423 \n1424         # Share a Y axis with each row of subplots\n1425         plt.subplots(2, 2, sharey='row')\n1426 \n1427         # Share both X and Y axes with all subplots\n1428         plt.subplots(2, 2, sharex='all', sharey='all')\n1429 \n1430         # Note that this is the same as\n1431         plt.subplots(2, 2, sharex=True, sharey=True)\n1432 \n1433         # Create figure number 10 with a single subplot\n1434         # and clears it if it already exists.\n1435         fig, ax = plt.subplots(num=10, clear=True)\n1436 \n1437     \"\"\"\n1438     fig = figure(**fig_kw)\n1439     axs = fig.subplots(nrows=nrows, ncols=ncols, sharex=sharex, sharey=sharey,\n1440                        squeeze=squeeze, subplot_kw=subplot_kw,\n1441                        gridspec_kw=gridspec_kw)\n1442     return fig, axs\n1443 \n1444 \n1445 def subplot_mosaic(mosaic, *, sharex=False, sharey=False,\n1446                    subplot_kw=None, gridspec_kw=None, empty_sentinel='.',\n1447                    **fig_kw):\n1448     \"\"\"\n1449     Build a layout of Axes based on ASCII art or nested lists.\n1450 \n1451     This is a helper function to build complex GridSpec layouts visually.\n1452 \n1453     .. note::\n1454 \n1455        This API is provisional and may be revised in the future based on\n1456        early user feedback.\n1457 \n1458     See :doc:`/tutorials/provisional/mosaic`\n1459     for an example and full API documentation\n1460 \n1461     Parameters\n1462     ----------\n1463     mosaic : list of list of {hashable or nested} or str\n1464 \n1465         A visual layout of how you want your Axes to be arranged\n1466         labeled as strings.  For example ::\n1467 \n1468            x = [['A panel', 'A panel', 'edge'],\n1469                 ['C panel', '.',       'edge']]\n1470 \n1471         produces 4 axes:\n1472 \n1473         - 'A panel' which is 1 row high and spans the first two columns\n1474         - 'edge' which is 2 rows high and is on the right edge\n1475         - 'C panel' which in 1 row and 1 column wide in the bottom left\n1476         - a blank space 1 row and 1 column wide in the bottom center\n1477 \n1478         Any of the entries in the layout can be a list of lists\n1479         of the same form to create nested layouts.\n1480 \n1481         If input is a str, then it must be of the form ::\n1482 \n1483           '''\n1484           AAE\n1485           C.E\n1486           '''\n1487 \n1488         where each character is a column and each line is a row.\n1489         This only allows only single character Axes labels and does\n1490         not allow nesting but is very terse.\n1491 \n1492     sharex, sharey : bool, default: False\n1493         If True, the x-axis (*sharex*) or y-axis (*sharey*) will be shared\n1494         among all subplots.  In that case, tick label visibility and axis units\n1495         behave as for `subplots`.  If False, each subplot's x- or y-axis will\n1496         be independent.\n1497 \n1498     subplot_kw : dict, optional\n1499         Dictionary with keywords passed to the `.Figure.add_subplot` call\n1500         used to create each subplot.\n1501 \n1502     gridspec_kw : dict, optional\n1503         Dictionary with keywords passed to the `.GridSpec` constructor used\n1504         to create the grid the subplots are placed on.\n1505 \n1506     empty_sentinel : object, optional\n1507         Entry in the layout to mean \"leave this space empty\".  Defaults\n1508         to ``'.'``. Note, if *layout* is a string, it is processed via\n1509         `inspect.cleandoc` to remove leading white space, which may\n1510         interfere with using white-space as the empty sentinel.\n1511 \n1512     **fig_kw\n1513         All additional keyword arguments are passed to the\n1514         `.pyplot.figure` call.\n1515 \n1516     Returns\n1517     -------\n1518     fig : `.Figure`\n1519        The new figure\n1520 \n1521     dict[label, Axes]\n1522        A dictionary mapping the labels to the Axes objects.  The order of\n1523        the axes is left-to-right and top-to-bottom of their position in the\n1524        total layout.\n1525 \n1526     \"\"\"\n1527     fig = figure(**fig_kw)\n1528     ax_dict = fig.subplot_mosaic(\n1529         mosaic, sharex=sharex, sharey=sharey,\n1530         subplot_kw=subplot_kw, gridspec_kw=gridspec_kw,\n1531         empty_sentinel=empty_sentinel\n1532     )\n1533     return fig, ax_dict\n1534 \n1535 \n1536 def subplot2grid(shape, loc, rowspan=1, colspan=1, fig=None, **kwargs):\n1537     \"\"\"\n1538     Create a subplot at a specific location inside a regular grid.\n1539 \n1540     Parameters\n1541     ----------\n1542     shape : (int, int)\n1543         Number of rows and of columns of the grid in which to place axis.\n1544     loc : (int, int)\n1545         Row number and column number of the axis location within the grid.\n1546     rowspan : int, default: 1\n1547         Number of rows for the axis to span downwards.\n1548     colspan : int, default: 1\n1549         Number of columns for the axis to span to the right.\n1550     fig : `.Figure`, optional\n1551         Figure to place the subplot in. Defaults to the current figure.\n1552     **kwargs\n1553         Additional keyword arguments are handed to `~.Figure.add_subplot`.\n1554 \n1555     Returns\n1556     -------\n1557     `.axes.SubplotBase`, or another subclass of `~.axes.Axes`\n1558 \n1559         The axes of the subplot.  The returned axes base class depends on the\n1560         projection used.  It is `~.axes.Axes` if rectilinear projection is used\n1561         and `.projections.polar.PolarAxes` if polar projection is used.  The\n1562         returned axes is then a subplot subclass of the base class.\n1563 \n1564     Notes\n1565     -----\n1566     The following call ::\n1567 \n1568         ax = subplot2grid((nrows, ncols), (row, col), rowspan, colspan)\n1569 \n1570     is identical to ::\n1571 \n1572         fig = gcf()\n1573         gs = fig.add_gridspec(nrows, ncols)\n1574         ax = fig.add_subplot(gs[row:row+rowspan, col:col+colspan])\n1575     \"\"\"\n1576 \n1577     if fig is None:\n1578         fig = gcf()\n1579 \n1580     rows, cols = shape\n1581     gs = GridSpec._check_gridspec_exists(fig, rows, cols)\n1582 \n1583     subplotspec = gs.new_subplotspec(loc, rowspan=rowspan, colspan=colspan)\n1584     ax = fig.add_subplot(subplotspec, **kwargs)\n1585 \n1586     axes_to_delete = [other for other in fig.axes\n1587                       if other != ax and ax.bbox.fully_overlaps(other.bbox)]\n1588     if axes_to_delete:\n1589         _api.warn_deprecated(\n1590             \"3.6\", message=\"Auto-removal of overlapping axes is deprecated \"\n1591             \"since %(since)s and will be removed %(removal)s; explicitly call \"\n1592             \"ax.remove() as needed.\")\n1593     for ax_to_del in axes_to_delete:\n1594         delaxes(ax_to_del)\n1595 \n1596     return ax\n1597 \n1598 \n1599 def twinx(ax=None):\n1600     \"\"\"\n1601     Make and return a second axes that shares the *x*-axis.  The new axes will\n1602     overlay *ax* (or the current axes if *ax* is *None*), and its ticks will be\n1603     on the right.\n1604 \n1605     Examples\n1606     --------\n1607     :doc:`/gallery/subplots_axes_and_figures/two_scales`\n1608     \"\"\"\n1609     if ax is None:\n1610         ax = gca()\n1611     ax1 = ax.twinx()\n1612     return ax1\n1613 \n1614 \n1615 def twiny(ax=None):\n1616     \"\"\"\n1617     Make and return a second axes that shares the *y*-axis.  The new axes will\n1618     overlay *ax* (or the current axes if *ax* is *None*), and its ticks will be\n1619     on the top.\n1620 \n1621     Examples\n1622     --------\n1623     :doc:`/gallery/subplots_axes_and_figures/two_scales`\n1624     \"\"\"\n1625     if ax is None:\n1626         ax = gca()\n1627     ax1 = ax.twiny()\n1628     return ax1\n1629 \n1630 \n1631 def subplot_tool(targetfig=None):\n1632     \"\"\"\n1633     Launch a subplot tool window for a figure.\n1634 \n1635     Returns\n1636     -------\n1637     `matplotlib.widgets.SubplotTool`\n1638     \"\"\"\n1639     if targetfig is None:\n1640         targetfig = gcf()\n1641     tb = targetfig.canvas.manager.toolbar\n1642     if hasattr(tb, \"configure_subplots\"):  # toolbar2\n1643         return tb.configure_subplots()\n1644     elif hasattr(tb, \"trigger_tool\"):  # toolmanager\n1645         return tb.trigger_tool(\"subplots\")\n1646     else:\n1647         raise ValueError(\"subplot_tool can only be launched for figures with \"\n1648                          \"an associated toolbar\")\n1649 \n1650 \n1651 def box(on=None):\n1652     \"\"\"\n1653     Turn the axes box on or off on the current axes.\n1654 \n1655     Parameters\n1656     ----------\n1657     on : bool or None\n1658         The new `~matplotlib.axes.Axes` box state. If ``None``, toggle\n1659         the state.\n1660 \n1661     See Also\n1662     --------\n1663     :meth:`matplotlib.axes.Axes.set_frame_on`\n1664     :meth:`matplotlib.axes.Axes.get_frame_on`\n1665     \"\"\"\n1666     ax = gca()\n1667     if on is None:\n1668         on = not ax.get_frame_on()\n1669     ax.set_frame_on(on)\n1670 \n1671 ## Axis ##\n1672 \n1673 \n1674 def xlim(*args, **kwargs):\n1675     \"\"\"\n1676     Get or set the x limits of the current axes.\n1677 \n1678     Call signatures::\n1679 \n1680         left, right = xlim()  # return the current xlim\n1681         xlim((left, right))   # set the xlim to left, right\n1682         xlim(left, right)     # set the xlim to left, right\n1683 \n1684     If you do not specify args, you can pass *left* or *right* as kwargs,\n1685     i.e.::\n1686 \n1687         xlim(right=3)  # adjust the right leaving left unchanged\n1688         xlim(left=1)  # adjust the left leaving right unchanged\n1689 \n1690     Setting limits turns autoscaling off for the x-axis.\n1691 \n1692     Returns\n1693     -------\n1694     left, right\n1695         A tuple of the new x-axis limits.\n1696 \n1697     Notes\n1698     -----\n1699     Calling this function with no arguments (e.g. ``xlim()``) is the pyplot\n1700     equivalent of calling `~.Axes.get_xlim` on the current axes.\n1701     Calling this function with arguments is the pyplot equivalent of calling\n1702     `~.Axes.set_xlim` on the current axes. All arguments are passed though.\n1703     \"\"\"\n1704     ax = gca()\n1705     if not args and not kwargs:\n1706         return ax.get_xlim()\n1707     ret = ax.set_xlim(*args, **kwargs)\n1708     return ret\n1709 \n1710 \n1711 def ylim(*args, **kwargs):\n1712     \"\"\"\n1713     Get or set the y-limits of the current axes.\n1714 \n1715     Call signatures::\n1716 \n1717         bottom, top = ylim()  # return the current ylim\n1718         ylim((bottom, top))   # set the ylim to bottom, top\n1719         ylim(bottom, top)     # set the ylim to bottom, top\n1720 \n1721     If you do not specify args, you can alternatively pass *bottom* or\n1722     *top* as kwargs, i.e.::\n1723 \n1724         ylim(top=3)  # adjust the top leaving bottom unchanged\n1725         ylim(bottom=1)  # adjust the bottom leaving top unchanged\n1726 \n1727     Setting limits turns autoscaling off for the y-axis.\n1728 \n1729     Returns\n1730     -------\n1731     bottom, top\n1732         A tuple of the new y-axis limits.\n1733 \n1734     Notes\n1735     -----\n1736     Calling this function with no arguments (e.g. ``ylim()``) is the pyplot\n1737     equivalent of calling `~.Axes.get_ylim` on the current axes.\n1738     Calling this function with arguments is the pyplot equivalent of calling\n1739     `~.Axes.set_ylim` on the current axes. All arguments are passed though.\n1740     \"\"\"\n1741     ax = gca()\n1742     if not args and not kwargs:\n1743         return ax.get_ylim()\n1744     ret = ax.set_ylim(*args, **kwargs)\n1745     return ret\n1746 \n1747 \n1748 def xticks(ticks=None, labels=None, **kwargs):\n1749     \"\"\"\n1750     Get or set the current tick locations and labels of the x-axis.\n1751 \n1752     Pass no arguments to return the current values without modifying them.\n1753 \n1754     Parameters\n1755     ----------\n1756     ticks : array-like, optional\n1757         The list of xtick locations.  Passing an empty list removes all xticks.\n1758     labels : array-like, optional\n1759         The labels to place at the given *ticks* locations.  This argument can\n1760         only be passed if *ticks* is passed as well.\n1761     **kwargs\n1762         `.Text` properties can be used to control the appearance of the labels.\n1763 \n1764     Returns\n1765     -------\n1766     locs\n1767         The list of xtick locations.\n1768     labels\n1769         The list of xlabel `.Text` objects.\n1770 \n1771     Notes\n1772     -----\n1773     Calling this function with no arguments (e.g. ``xticks()``) is the pyplot\n1774     equivalent of calling `~.Axes.get_xticks` and `~.Axes.get_xticklabels` on\n1775     the current axes.\n1776     Calling this function with arguments is the pyplot equivalent of calling\n1777     `~.Axes.set_xticks` and `~.Axes.set_xticklabels` on the current axes.\n1778 \n1779     Examples\n1780     --------\n1781     >>> locs, labels = xticks()  # Get the current locations and labels.\n1782     >>> xticks(np.arange(0, 1, step=0.2))  # Set label locations.\n1783     >>> xticks(np.arange(3), ['Tom', 'Dick', 'Sue'])  # Set text labels.\n1784     >>> xticks([0, 1, 2], ['January', 'February', 'March'],\n1785     ...        rotation=20)  # Set text labels and properties.\n1786     >>> xticks([])  # Disable xticks.\n1787     \"\"\"\n1788     ax = gca()\n1789 \n1790     if ticks is None:\n1791         locs = ax.get_xticks()\n1792         if labels is not None:\n1793             raise TypeError(\"xticks(): Parameter 'labels' can't be set \"\n1794                             \"without setting 'ticks'\")\n1795     else:\n1796         locs = ax.set_xticks(ticks)\n1797 \n1798     if labels is None:\n1799         labels = ax.get_xticklabels()\n1800         for l in labels:\n1801             l._internal_update(kwargs)\n1802     else:\n1803         labels = ax.set_xticklabels(labels, **kwargs)\n1804 \n1805     return locs, labels\n1806 \n1807 \n1808 def yticks(ticks=None, labels=None, **kwargs):\n1809     \"\"\"\n1810     Get or set the current tick locations and labels of the y-axis.\n1811 \n1812     Pass no arguments to return the current values without modifying them.\n1813 \n1814     Parameters\n1815     ----------\n1816     ticks : array-like, optional\n1817         The list of ytick locations.  Passing an empty list removes all yticks.\n1818     labels : array-like, optional\n1819         The labels to place at the given *ticks* locations.  This argument can\n1820         only be passed if *ticks* is passed as well.\n1821     **kwargs\n1822         `.Text` properties can be used to control the appearance of the labels.\n1823 \n1824     Returns\n1825     -------\n1826     locs\n1827         The list of ytick locations.\n1828     labels\n1829         The list of ylabel `.Text` objects.\n1830 \n1831     Notes\n1832     -----\n1833     Calling this function with no arguments (e.g. ``yticks()``) is the pyplot\n1834     equivalent of calling `~.Axes.get_yticks` and `~.Axes.get_yticklabels` on\n1835     the current axes.\n1836     Calling this function with arguments is the pyplot equivalent of calling\n1837     `~.Axes.set_yticks` and `~.Axes.set_yticklabels` on the current axes.\n1838 \n1839     Examples\n1840     --------\n1841     >>> locs, labels = yticks()  # Get the current locations and labels.\n1842     >>> yticks(np.arange(0, 1, step=0.2))  # Set label locations.\n1843     >>> yticks(np.arange(3), ['Tom', 'Dick', 'Sue'])  # Set text labels.\n1844     >>> yticks([0, 1, 2], ['January', 'February', 'March'],\n1845     ...        rotation=45)  # Set text labels and properties.\n1846     >>> yticks([])  # Disable yticks.\n1847     \"\"\"\n1848     ax = gca()\n1849 \n1850     if ticks is None:\n1851         locs = ax.get_yticks()\n1852         if labels is not None:\n1853             raise TypeError(\"yticks(): Parameter 'labels' can't be set \"\n1854                             \"without setting 'ticks'\")\n1855     else:\n1856         locs = ax.set_yticks(ticks)\n1857 \n1858     if labels is None:\n1859         labels = ax.get_yticklabels()\n1860         for l in labels:\n1861             l._internal_update(kwargs)\n1862     else:\n1863         labels = ax.set_yticklabels(labels, **kwargs)\n1864 \n1865     return locs, labels\n1866 \n1867 \n1868 def rgrids(radii=None, labels=None, angle=None, fmt=None, **kwargs):\n1869     \"\"\"\n1870     Get or set the radial gridlines on the current polar plot.\n1871 \n1872     Call signatures::\n1873 \n1874      lines, labels = rgrids()\n1875      lines, labels = rgrids(radii, labels=None, angle=22.5, fmt=None, **kwargs)\n1876 \n1877     When called with no arguments, `.rgrids` simply returns the tuple\n1878     (*lines*, *labels*). When called with arguments, the labels will\n1879     appear at the specified radial distances and angle.\n1880 \n1881     Parameters\n1882     ----------\n1883     radii : tuple with floats\n1884         The radii for the radial gridlines\n1885 \n1886     labels : tuple with strings or None\n1887         The labels to use at each radial gridline. The\n1888         `matplotlib.ticker.ScalarFormatter` will be used if None.\n1889 \n1890     angle : float\n1891         The angular position of the radius labels in degrees.\n1892 \n1893     fmt : str or None\n1894         Format string used in `matplotlib.ticker.FormatStrFormatter`.\n1895         For example '%f'.\n1896 \n1897     Returns\n1898     -------\n1899     lines : list of `.lines.Line2D`\n1900         The radial gridlines.\n1901 \n1902     labels : list of `.text.Text`\n1903         The tick labels.\n1904 \n1905     Other Parameters\n1906     ----------------\n1907     **kwargs\n1908         *kwargs* are optional `.Text` properties for the labels.\n1909 \n1910     See Also\n1911     --------\n1912     .pyplot.thetagrids\n1913     .projections.polar.PolarAxes.set_rgrids\n1914     .Axis.get_gridlines\n1915     .Axis.get_ticklabels\n1916 \n1917     Examples\n1918     --------\n1919     ::\n1920 \n1921       # set the locations of the radial gridlines\n1922       lines, labels = rgrids( (0.25, 0.5, 1.0) )\n1923 \n1924       # set the locations and labels of the radial gridlines\n1925       lines, labels = rgrids( (0.25, 0.5, 1.0), ('Tom', 'Dick', 'Harry' ))\n1926     \"\"\"\n1927     ax = gca()\n1928     if not isinstance(ax, PolarAxes):\n1929         raise RuntimeError('rgrids only defined for polar axes')\n1930     if all(p is None for p in [radii, labels, angle, fmt]) and not kwargs:\n1931         lines = ax.yaxis.get_gridlines()\n1932         labels = ax.yaxis.get_ticklabels()\n1933     else:\n1934         lines, labels = ax.set_rgrids(\n1935             radii, labels=labels, angle=angle, fmt=fmt, **kwargs)\n1936     return lines, labels\n1937 \n1938 \n1939 def thetagrids(angles=None, labels=None, fmt=None, **kwargs):\n1940     \"\"\"\n1941     Get or set the theta gridlines on the current polar plot.\n1942 \n1943     Call signatures::\n1944 \n1945      lines, labels = thetagrids()\n1946      lines, labels = thetagrids(angles, labels=None, fmt=None, **kwargs)\n1947 \n1948     When called with no arguments, `.thetagrids` simply returns the tuple\n1949     (*lines*, *labels*). When called with arguments, the labels will\n1950     appear at the specified angles.\n1951 \n1952     Parameters\n1953     ----------\n1954     angles : tuple with floats, degrees\n1955         The angles of the theta gridlines.\n1956 \n1957     labels : tuple with strings or None\n1958         The labels to use at each radial gridline. The\n1959         `.projections.polar.ThetaFormatter` will be used if None.\n1960 \n1961     fmt : str or None\n1962         Format string used in `matplotlib.ticker.FormatStrFormatter`.\n1963         For example '%f'. Note that the angle in radians will be used.\n1964 \n1965     Returns\n1966     -------\n1967     lines : list of `.lines.Line2D`\n1968         The theta gridlines.\n1969 \n1970     labels : list of `.text.Text`\n1971         The tick labels.\n1972 \n1973     Other Parameters\n1974     ----------------\n1975     **kwargs\n1976         *kwargs* are optional `.Text` properties for the labels.\n1977 \n1978     See Also\n1979     --------\n1980     .pyplot.rgrids\n1981     .projections.polar.PolarAxes.set_thetagrids\n1982     .Axis.get_gridlines\n1983     .Axis.get_ticklabels\n1984 \n1985     Examples\n1986     --------\n1987     ::\n1988 \n1989       # set the locations of the angular gridlines\n1990       lines, labels = thetagrids(range(45, 360, 90))\n1991 \n1992       # set the locations and labels of the angular gridlines\n1993       lines, labels = thetagrids(range(45, 360, 90), ('NE', 'NW', 'SW', 'SE'))\n1994     \"\"\"\n1995     ax = gca()\n1996     if not isinstance(ax, PolarAxes):\n1997         raise RuntimeError('thetagrids only defined for polar axes')\n1998     if all(param is None for param in [angles, labels, fmt]) and not kwargs:\n1999         lines = ax.xaxis.get_ticklines()\n2000         labels = ax.xaxis.get_ticklabels()\n2001     else:\n2002         lines, labels = ax.set_thetagrids(angles,\n2003                                           labels=labels, fmt=fmt, **kwargs)\n2004     return lines, labels\n2005 \n2006 \n2007 ## Plotting Info ##\n2008 \n2009 \n2010 def plotting():\n2011     pass\n2012 \n2013 \n2014 def get_plot_commands():\n2015     \"\"\"\n2016     Get a sorted list of all of the plotting commands.\n2017     \"\"\"\n2018     # This works by searching for all functions in this module and removing\n2019     # a few hard-coded exclusions, as well as all of the colormap-setting\n2020     # functions, and anything marked as private with a preceding underscore.\n2021     exclude = {'colormaps', 'colors', 'connect', 'disconnect',\n2022                'get_plot_commands', 'get_current_fig_manager', 'ginput',\n2023                'plotting', 'waitforbuttonpress'}\n2024     exclude |= set(colormaps)\n2025     this_module = inspect.getmodule(get_plot_commands)\n2026     return sorted(\n2027         name for name, obj in globals().items()\n2028         if not name.startswith('_') and name not in exclude\n2029            and inspect.isfunction(obj)\n2030            and inspect.getmodule(obj) is this_module)\n2031 \n2032 \n2033 def _setup_pyplot_info_docstrings():\n2034     \"\"\"\n2035     Setup the docstring of `plotting` and of the colormap-setting functions.\n2036 \n2037     These must be done after the entire module is imported, so it is called\n2038     from the end of this module, which is generated by boilerplate.py.\n2039     \"\"\"\n2040     commands = get_plot_commands()\n2041 \n2042     first_sentence = re.compile(r\"(?:\\s*).+?\\.(?:\\s+|$)\", flags=re.DOTALL)\n2043 \n2044     # Collect the first sentence of the docstring for all of the\n2045     # plotting commands.\n2046     rows = []\n2047     max_name = len(\"Function\")\n2048     max_summary = len(\"Description\")\n2049     for name in commands:\n2050         doc = globals()[name].__doc__\n2051         summary = ''\n2052         if doc is not None:\n2053             match = first_sentence.match(doc)\n2054             if match is not None:\n2055                 summary = inspect.cleandoc(match.group(0)).replace('\\n', ' ')\n2056         name = '`%s`' % name\n2057         rows.append([name, summary])\n2058         max_name = max(max_name, len(name))\n2059         max_summary = max(max_summary, len(summary))\n2060 \n2061     separator = '=' * max_name + ' ' + '=' * max_summary\n2062     lines = [\n2063         separator,\n2064         '{:{}} {:{}}'.format('Function', max_name, 'Description', max_summary),\n2065         separator,\n2066     ] + [\n2067         '{:{}} {:{}}'.format(name, max_name, summary, max_summary)\n2068         for name, summary in rows\n2069     ] + [\n2070         separator,\n2071     ]\n2072     plotting.__doc__ = '\\n'.join(lines)\n2073 \n2074     for cm_name in colormaps:\n2075         if cm_name in globals():\n2076             globals()[cm_name].__doc__ = f\"\"\"\n2077     Set the colormap to {cm_name!r}.\n2078 \n2079     This changes the default colormap as well as the colormap of the current\n2080     image if there is one. See ``help(colormaps)`` for more information.\n2081     \"\"\"\n2082 \n2083 \n2084 ## Plotting part 1: manually generated functions and wrappers ##\n2085 \n2086 \n2087 @_copy_docstring_and_deprecators(Figure.colorbar)\n2088 def colorbar(mappable=None, cax=None, ax=None, **kwargs):\n2089     if mappable is None:\n2090         mappable = gci()\n2091         if mappable is None:\n2092             raise RuntimeError('No mappable was found to use for colorbar '\n2093                                'creation. First define a mappable such as '\n2094                                'an image (with imshow) or a contour set ('\n2095                                'with contourf).')\n2096     ret = gcf().colorbar(mappable, cax=cax, ax=ax, **kwargs)\n2097     return ret\n2098 \n2099 \n2100 def clim(vmin=None, vmax=None):\n2101     \"\"\"\n2102     Set the color limits of the current image.\n2103 \n2104     If either *vmin* or *vmax* is None, the image min/max respectively\n2105     will be used for color scaling.\n2106 \n2107     If you want to set the clim of multiple images, use\n2108     `~.ScalarMappable.set_clim` on every image, for example::\n2109 \n2110       for im in gca().get_images():\n2111           im.set_clim(0, 0.5)\n2112 \n2113     \"\"\"\n2114     im = gci()\n2115     if im is None:\n2116         raise RuntimeError('You must first define an image, e.g., with imshow')\n2117 \n2118     im.set_clim(vmin, vmax)\n2119 \n2120 \n2121 def set_cmap(cmap):\n2122     \"\"\"\n2123     Set the default colormap, and applies it to the current image if any.\n2124 \n2125     Parameters\n2126     ----------\n2127     cmap : `~matplotlib.colors.Colormap` or str\n2128         A colormap instance or the name of a registered colormap.\n2129 \n2130     See Also\n2131     --------\n2132     colormaps\n2133     matplotlib.cm.register_cmap\n2134     matplotlib.cm.get_cmap\n2135     \"\"\"\n2136     cmap = cm.get_cmap(cmap)\n2137 \n2138     rc('image', cmap=cmap.name)\n2139     im = gci()\n2140 \n2141     if im is not None:\n2142         im.set_cmap(cmap)\n2143 \n2144 \n2145 @_copy_docstring_and_deprecators(matplotlib.image.imread)\n2146 def imread(fname, format=None):\n2147     return matplotlib.image.imread(fname, format)\n2148 \n2149 \n2150 @_copy_docstring_and_deprecators(matplotlib.image.imsave)\n2151 def imsave(fname, arr, **kwargs):\n2152     return matplotlib.image.imsave(fname, arr, **kwargs)\n2153 \n2154 \n2155 def matshow(A, fignum=None, **kwargs):\n2156     \"\"\"\n2157     Display an array as a matrix in a new figure window.\n2158 \n2159     The origin is set at the upper left hand corner and rows (first\n2160     dimension of the array) are displayed horizontally.  The aspect\n2161     ratio of the figure window is that of the array, unless this would\n2162     make an excessively short or narrow figure.\n2163 \n2164     Tick labels for the xaxis are placed on top.\n2165 \n2166     Parameters\n2167     ----------\n2168     A : 2D array-like\n2169         The matrix to be displayed.\n2170 \n2171     fignum : None or int or False\n2172         If *None*, create a new figure window with automatic numbering.\n2173 \n2174         If a nonzero integer, draw into the figure with the given number\n2175         (create it if it does not exist).\n2176 \n2177         If 0, use the current axes (or create one if it does not exist).\n2178 \n2179         .. note::\n2180 \n2181            Because of how `.Axes.matshow` tries to set the figure aspect\n2182            ratio to be the one of the array, strange things may happen if you\n2183            reuse an existing figure.\n2184 \n2185     Returns\n2186     -------\n2187     `~matplotlib.image.AxesImage`\n2188 \n2189     Other Parameters\n2190     ----------------\n2191     **kwargs : `~matplotlib.axes.Axes.imshow` arguments\n2192 \n2193     \"\"\"\n2194     A = np.asanyarray(A)\n2195     if fignum == 0:\n2196         ax = gca()\n2197     else:\n2198         # Extract actual aspect ratio of array and make appropriately sized\n2199         # figure.\n2200         fig = figure(fignum, figsize=figaspect(A))\n2201         ax = fig.add_axes([0.15, 0.09, 0.775, 0.775])\n2202     im = ax.matshow(A, **kwargs)\n2203     sci(im)\n2204     return im\n2205 \n2206 \n2207 def polar(*args, **kwargs):\n2208     \"\"\"\n2209     Make a polar plot.\n2210 \n2211     call signature::\n2212 \n2213       polar(theta, r, **kwargs)\n2214 \n2215     Multiple *theta*, *r* arguments are supported, with format strings, as in\n2216     `plot`.\n2217     \"\"\"\n2218     # If an axis already exists, check if it has a polar projection\n2219     if gcf().get_axes():\n2220         ax = gca()\n2221         if not isinstance(ax, PolarAxes):\n2222             _api.warn_external('Trying to create polar plot on an Axes '\n2223                                'that does not have a polar projection.')\n2224     else:\n2225         ax = axes(projection=\"polar\")\n2226     return ax.plot(*args, **kwargs)\n2227 \n2228 \n2229 # If rcParams['backend_fallback'] is true, and an interactive backend is\n2230 # requested, ignore rcParams['backend'] and force selection of a backend that\n2231 # is compatible with the current running interactive framework.\n2232 if (rcParams[\"backend_fallback\"]\n2233         and dict.__getitem__(rcParams, \"backend\") in (\n2234             set(_interactive_bk) - {'WebAgg', 'nbAgg'})\n2235         and cbook._get_running_interactive_framework()):\n2236     dict.__setitem__(rcParams, \"backend\", rcsetup._auto_backend_sentinel)\n2237 \n2238 \n2239 ################# REMAINING CONTENT GENERATED BY boilerplate.py ##############\n2240 \n2241 \n2242 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2243 @_copy_docstring_and_deprecators(Figure.figimage)\n2244 def figimage(\n2245         X, xo=0, yo=0, alpha=None, norm=None, cmap=None, vmin=None,\n2246         vmax=None, origin=None, resize=False, **kwargs):\n2247     return gcf().figimage(\n2248         X, xo=xo, yo=yo, alpha=alpha, norm=norm, cmap=cmap, vmin=vmin,\n2249         vmax=vmax, origin=origin, resize=resize, **kwargs)\n2250 \n2251 \n2252 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2253 @_copy_docstring_and_deprecators(Figure.text)\n2254 def figtext(x, y, s, fontdict=None, **kwargs):\n2255     return gcf().text(x, y, s, fontdict=fontdict, **kwargs)\n2256 \n2257 \n2258 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2259 @_copy_docstring_and_deprecators(Figure.gca)\n2260 def gca(**kwargs):\n2261     return gcf().gca(**kwargs)\n2262 \n2263 \n2264 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2265 @_copy_docstring_and_deprecators(Figure._gci)\n2266 def gci():\n2267     return gcf()._gci()\n2268 \n2269 \n2270 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2271 @_copy_docstring_and_deprecators(Figure.ginput)\n2272 def ginput(\n2273         n=1, timeout=30, show_clicks=True,\n2274         mouse_add=MouseButton.LEFT, mouse_pop=MouseButton.RIGHT,\n2275         mouse_stop=MouseButton.MIDDLE):\n2276     return gcf().ginput(\n2277         n=n, timeout=timeout, show_clicks=show_clicks,\n2278         mouse_add=mouse_add, mouse_pop=mouse_pop,\n2279         mouse_stop=mouse_stop)\n2280 \n2281 \n2282 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2283 @_copy_docstring_and_deprecators(Figure.subplots_adjust)\n2284 def subplots_adjust(\n2285         left=None, bottom=None, right=None, top=None, wspace=None,\n2286         hspace=None):\n2287     return gcf().subplots_adjust(\n2288         left=left, bottom=bottom, right=right, top=top, wspace=wspace,\n2289         hspace=hspace)\n2290 \n2291 \n2292 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2293 @_copy_docstring_and_deprecators(Figure.suptitle)\n2294 def suptitle(t, **kwargs):\n2295     return gcf().suptitle(t, **kwargs)\n2296 \n2297 \n2298 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2299 @_copy_docstring_and_deprecators(Figure.tight_layout)\n2300 def tight_layout(*, pad=1.08, h_pad=None, w_pad=None, rect=None):\n2301     return gcf().tight_layout(pad=pad, h_pad=h_pad, w_pad=w_pad, rect=rect)\n2302 \n2303 \n2304 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2305 @_copy_docstring_and_deprecators(Figure.waitforbuttonpress)\n2306 def waitforbuttonpress(timeout=-1):\n2307     return gcf().waitforbuttonpress(timeout=timeout)\n2308 \n2309 \n2310 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2311 @_copy_docstring_and_deprecators(Axes.acorr)\n2312 def acorr(x, *, data=None, **kwargs):\n2313     return gca().acorr(\n2314         x, **({\"data\": data} if data is not None else {}), **kwargs)\n2315 \n2316 \n2317 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2318 @_copy_docstring_and_deprecators(Axes.angle_spectrum)\n2319 def angle_spectrum(\n2320         x, Fs=None, Fc=None, window=None, pad_to=None, sides=None, *,\n2321         data=None, **kwargs):\n2322     return gca().angle_spectrum(\n2323         x, Fs=Fs, Fc=Fc, window=window, pad_to=pad_to, sides=sides,\n2324         **({\"data\": data} if data is not None else {}), **kwargs)\n2325 \n2326 \n2327 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2328 @_copy_docstring_and_deprecators(Axes.annotate)\n2329 def annotate(\n2330         text, xy, xytext=None, xycoords='data', textcoords=None,\n2331         arrowprops=None, annotation_clip=None, **kwargs):\n2332     return gca().annotate(\n2333         text, xy, xytext=xytext, xycoords=xycoords,\n2334         textcoords=textcoords, arrowprops=arrowprops,\n2335         annotation_clip=annotation_clip, **kwargs)\n2336 \n2337 \n2338 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2339 @_copy_docstring_and_deprecators(Axes.arrow)\n2340 def arrow(x, y, dx, dy, **kwargs):\n2341     return gca().arrow(x, y, dx, dy, **kwargs)\n2342 \n2343 \n2344 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2345 @_copy_docstring_and_deprecators(Axes.autoscale)\n2346 def autoscale(enable=True, axis='both', tight=None):\n2347     return gca().autoscale(enable=enable, axis=axis, tight=tight)\n2348 \n2349 \n2350 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2351 @_copy_docstring_and_deprecators(Axes.axhline)\n2352 def axhline(y=0, xmin=0, xmax=1, **kwargs):\n2353     return gca().axhline(y=y, xmin=xmin, xmax=xmax, **kwargs)\n2354 \n2355 \n2356 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2357 @_copy_docstring_and_deprecators(Axes.axhspan)\n2358 def axhspan(ymin, ymax, xmin=0, xmax=1, **kwargs):\n2359     return gca().axhspan(ymin, ymax, xmin=xmin, xmax=xmax, **kwargs)\n2360 \n2361 \n2362 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2363 @_copy_docstring_and_deprecators(Axes.axis)\n2364 def axis(*args, emit=True, **kwargs):\n2365     return gca().axis(*args, emit=emit, **kwargs)\n2366 \n2367 \n2368 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2369 @_copy_docstring_and_deprecators(Axes.axline)\n2370 def axline(xy1, xy2=None, *, slope=None, **kwargs):\n2371     return gca().axline(xy1, xy2=xy2, slope=slope, **kwargs)\n2372 \n2373 \n2374 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2375 @_copy_docstring_and_deprecators(Axes.axvline)\n2376 def axvline(x=0, ymin=0, ymax=1, **kwargs):\n2377     return gca().axvline(x=x, ymin=ymin, ymax=ymax, **kwargs)\n2378 \n2379 \n2380 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2381 @_copy_docstring_and_deprecators(Axes.axvspan)\n2382 def axvspan(xmin, xmax, ymin=0, ymax=1, **kwargs):\n2383     return gca().axvspan(xmin, xmax, ymin=ymin, ymax=ymax, **kwargs)\n2384 \n2385 \n2386 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2387 @_copy_docstring_and_deprecators(Axes.bar)\n2388 def bar(\n2389         x, height, width=0.8, bottom=None, *, align='center',\n2390         data=None, **kwargs):\n2391     return gca().bar(\n2392         x, height, width=width, bottom=bottom, align=align,\n2393         **({\"data\": data} if data is not None else {}), **kwargs)\n2394 \n2395 \n2396 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2397 @_copy_docstring_and_deprecators(Axes.barbs)\n2398 def barbs(*args, data=None, **kwargs):\n2399     return gca().barbs(\n2400         *args, **({\"data\": data} if data is not None else {}),\n2401         **kwargs)\n2402 \n2403 \n2404 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2405 @_copy_docstring_and_deprecators(Axes.barh)\n2406 def barh(y, width, height=0.8, left=None, *, align='center', **kwargs):\n2407     return gca().barh(\n2408         y, width, height=height, left=left, align=align, **kwargs)\n2409 \n2410 \n2411 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2412 @_copy_docstring_and_deprecators(Axes.bar_label)\n2413 def bar_label(\n2414         container, labels=None, *, fmt='%g', label_type='edge',\n2415         padding=0, **kwargs):\n2416     return gca().bar_label(\n2417         container, labels=labels, fmt=fmt, label_type=label_type,\n2418         padding=padding, **kwargs)\n2419 \n2420 \n2421 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2422 @_copy_docstring_and_deprecators(Axes.boxplot)\n2423 def boxplot(\n2424         x, notch=None, sym=None, vert=None, whis=None,\n2425         positions=None, widths=None, patch_artist=None,\n2426         bootstrap=None, usermedians=None, conf_intervals=None,\n2427         meanline=None, showmeans=None, showcaps=None, showbox=None,\n2428         showfliers=None, boxprops=None, labels=None, flierprops=None,\n2429         medianprops=None, meanprops=None, capprops=None,\n2430         whiskerprops=None, manage_ticks=True, autorange=False,\n2431         zorder=None, capwidths=None, *, data=None):\n2432     return gca().boxplot(\n2433         x, notch=notch, sym=sym, vert=vert, whis=whis,\n2434         positions=positions, widths=widths, patch_artist=patch_artist,\n2435         bootstrap=bootstrap, usermedians=usermedians,\n2436         conf_intervals=conf_intervals, meanline=meanline,\n2437         showmeans=showmeans, showcaps=showcaps, showbox=showbox,\n2438         showfliers=showfliers, boxprops=boxprops, labels=labels,\n2439         flierprops=flierprops, medianprops=medianprops,\n2440         meanprops=meanprops, capprops=capprops,\n2441         whiskerprops=whiskerprops, manage_ticks=manage_ticks,\n2442         autorange=autorange, zorder=zorder, capwidths=capwidths,\n2443         **({\"data\": data} if data is not None else {}))\n2444 \n2445 \n2446 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2447 @_copy_docstring_and_deprecators(Axes.broken_barh)\n2448 def broken_barh(xranges, yrange, *, data=None, **kwargs):\n2449     return gca().broken_barh(\n2450         xranges, yrange,\n2451         **({\"data\": data} if data is not None else {}), **kwargs)\n2452 \n2453 \n2454 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2455 @_copy_docstring_and_deprecators(Axes.clabel)\n2456 def clabel(CS, levels=None, **kwargs):\n2457     return gca().clabel(CS, levels=levels, **kwargs)\n2458 \n2459 \n2460 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2461 @_copy_docstring_and_deprecators(Axes.cohere)\n2462 def cohere(\n2463         x, y, NFFT=256, Fs=2, Fc=0, detrend=mlab.detrend_none,\n2464         window=mlab.window_hanning, noverlap=0, pad_to=None,\n2465         sides='default', scale_by_freq=None, *, data=None, **kwargs):\n2466     return gca().cohere(\n2467         x, y, NFFT=NFFT, Fs=Fs, Fc=Fc, detrend=detrend, window=window,\n2468         noverlap=noverlap, pad_to=pad_to, sides=sides,\n2469         scale_by_freq=scale_by_freq,\n2470         **({\"data\": data} if data is not None else {}), **kwargs)\n2471 \n2472 \n2473 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2474 @_copy_docstring_and_deprecators(Axes.contour)\n2475 def contour(*args, data=None, **kwargs):\n2476     __ret = gca().contour(\n2477         *args, **({\"data\": data} if data is not None else {}),\n2478         **kwargs)\n2479     if __ret._A is not None: sci(__ret)  # noqa\n2480     return __ret\n2481 \n2482 \n2483 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2484 @_copy_docstring_and_deprecators(Axes.contourf)\n2485 def contourf(*args, data=None, **kwargs):\n2486     __ret = gca().contourf(\n2487         *args, **({\"data\": data} if data is not None else {}),\n2488         **kwargs)\n2489     if __ret._A is not None: sci(__ret)  # noqa\n2490     return __ret\n2491 \n2492 \n2493 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2494 @_copy_docstring_and_deprecators(Axes.csd)\n2495 def csd(\n2496         x, y, NFFT=None, Fs=None, Fc=None, detrend=None, window=None,\n2497         noverlap=None, pad_to=None, sides=None, scale_by_freq=None,\n2498         return_line=None, *, data=None, **kwargs):\n2499     return gca().csd(\n2500         x, y, NFFT=NFFT, Fs=Fs, Fc=Fc, detrend=detrend, window=window,\n2501         noverlap=noverlap, pad_to=pad_to, sides=sides,\n2502         scale_by_freq=scale_by_freq, return_line=return_line,\n2503         **({\"data\": data} if data is not None else {}), **kwargs)\n2504 \n2505 \n2506 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2507 @_copy_docstring_and_deprecators(Axes.errorbar)\n2508 def errorbar(\n2509         x, y, yerr=None, xerr=None, fmt='', ecolor=None,\n2510         elinewidth=None, capsize=None, barsabove=False, lolims=False,\n2511         uplims=False, xlolims=False, xuplims=False, errorevery=1,\n2512         capthick=None, *, data=None, **kwargs):\n2513     return gca().errorbar(\n2514         x, y, yerr=yerr, xerr=xerr, fmt=fmt, ecolor=ecolor,\n2515         elinewidth=elinewidth, capsize=capsize, barsabove=barsabove,\n2516         lolims=lolims, uplims=uplims, xlolims=xlolims,\n2517         xuplims=xuplims, errorevery=errorevery, capthick=capthick,\n2518         **({\"data\": data} if data is not None else {}), **kwargs)\n2519 \n2520 \n2521 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2522 @_copy_docstring_and_deprecators(Axes.eventplot)\n2523 def eventplot(\n2524         positions, orientation='horizontal', lineoffsets=1,\n2525         linelengths=1, linewidths=None, colors=None,\n2526         linestyles='solid', *, data=None, **kwargs):\n2527     return gca().eventplot(\n2528         positions, orientation=orientation, lineoffsets=lineoffsets,\n2529         linelengths=linelengths, linewidths=linewidths, colors=colors,\n2530         linestyles=linestyles,\n2531         **({\"data\": data} if data is not None else {}), **kwargs)\n2532 \n2533 \n2534 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2535 @_copy_docstring_and_deprecators(Axes.fill)\n2536 def fill(*args, data=None, **kwargs):\n2537     return gca().fill(\n2538         *args, **({\"data\": data} if data is not None else {}),\n2539         **kwargs)\n2540 \n2541 \n2542 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2543 @_copy_docstring_and_deprecators(Axes.fill_between)\n2544 def fill_between(\n2545         x, y1, y2=0, where=None, interpolate=False, step=None, *,\n2546         data=None, **kwargs):\n2547     return gca().fill_between(\n2548         x, y1, y2=y2, where=where, interpolate=interpolate, step=step,\n2549         **({\"data\": data} if data is not None else {}), **kwargs)\n2550 \n2551 \n2552 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2553 @_copy_docstring_and_deprecators(Axes.fill_betweenx)\n2554 def fill_betweenx(\n2555         y, x1, x2=0, where=None, step=None, interpolate=False, *,\n2556         data=None, **kwargs):\n2557     return gca().fill_betweenx(\n2558         y, x1, x2=x2, where=where, step=step, interpolate=interpolate,\n2559         **({\"data\": data} if data is not None else {}), **kwargs)\n2560 \n2561 \n2562 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2563 @_copy_docstring_and_deprecators(Axes.grid)\n2564 def grid(visible=None, which='major', axis='both', **kwargs):\n2565     return gca().grid(visible=visible, which=which, axis=axis, **kwargs)\n2566 \n2567 \n2568 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2569 @_copy_docstring_and_deprecators(Axes.hexbin)\n2570 def hexbin(\n2571         x, y, C=None, gridsize=100, bins=None, xscale='linear',\n2572         yscale='linear', extent=None, cmap=None, norm=None, vmin=None,\n2573         vmax=None, alpha=None, linewidths=None, edgecolors='face',\n2574         reduce_C_function=np.mean, mincnt=None, marginals=False, *,\n2575         data=None, **kwargs):\n2576     __ret = gca().hexbin(\n2577         x, y, C=C, gridsize=gridsize, bins=bins, xscale=xscale,\n2578         yscale=yscale, extent=extent, cmap=cmap, norm=norm, vmin=vmin,\n2579         vmax=vmax, alpha=alpha, linewidths=linewidths,\n2580         edgecolors=edgecolors, reduce_C_function=reduce_C_function,\n2581         mincnt=mincnt, marginals=marginals,\n2582         **({\"data\": data} if data is not None else {}), **kwargs)\n2583     sci(__ret)\n2584     return __ret\n2585 \n2586 \n2587 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2588 @_copy_docstring_and_deprecators(Axes.hist)\n2589 def hist(\n2590         x, bins=None, range=None, density=False, weights=None,\n2591         cumulative=False, bottom=None, histtype='bar', align='mid',\n2592         orientation='vertical', rwidth=None, log=False, color=None,\n2593         label=None, stacked=False, *, data=None, **kwargs):\n2594     return gca().hist(\n2595         x, bins=bins, range=range, density=density, weights=weights,\n2596         cumulative=cumulative, bottom=bottom, histtype=histtype,\n2597         align=align, orientation=orientation, rwidth=rwidth, log=log,\n2598         color=color, label=label, stacked=stacked,\n2599         **({\"data\": data} if data is not None else {}), **kwargs)\n2600 \n2601 \n2602 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2603 @_copy_docstring_and_deprecators(Axes.stairs)\n2604 def stairs(\n2605         values, edges=None, *, orientation='vertical', baseline=0,\n2606         fill=False, data=None, **kwargs):\n2607     return gca().stairs(\n2608         values, edges=edges, orientation=orientation,\n2609         baseline=baseline, fill=fill,\n2610         **({\"data\": data} if data is not None else {}), **kwargs)\n2611 \n2612 \n2613 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2614 @_copy_docstring_and_deprecators(Axes.hist2d)\n2615 def hist2d(\n2616         x, y, bins=10, range=None, density=False, weights=None,\n2617         cmin=None, cmax=None, *, data=None, **kwargs):\n2618     __ret = gca().hist2d(\n2619         x, y, bins=bins, range=range, density=density,\n2620         weights=weights, cmin=cmin, cmax=cmax,\n2621         **({\"data\": data} if data is not None else {}), **kwargs)\n2622     sci(__ret[-1])\n2623     return __ret\n2624 \n2625 \n2626 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2627 @_copy_docstring_and_deprecators(Axes.hlines)\n2628 def hlines(\n2629         y, xmin, xmax, colors=None, linestyles='solid', label='', *,\n2630         data=None, **kwargs):\n2631     return gca().hlines(\n2632         y, xmin, xmax, colors=colors, linestyles=linestyles,\n2633         label=label, **({\"data\": data} if data is not None else {}),\n2634         **kwargs)\n2635 \n2636 \n2637 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2638 @_copy_docstring_and_deprecators(Axes.imshow)\n2639 def imshow(\n2640         X, cmap=None, norm=None, aspect=None, interpolation=None,\n2641         alpha=None, vmin=None, vmax=None, origin=None, extent=None, *,\n2642         interpolation_stage=None, filternorm=True, filterrad=4.0,\n2643         resample=None, url=None, data=None, **kwargs):\n2644     __ret = gca().imshow(\n2645         X, cmap=cmap, norm=norm, aspect=aspect,\n2646         interpolation=interpolation, alpha=alpha, vmin=vmin,\n2647         vmax=vmax, origin=origin, extent=extent,\n2648         interpolation_stage=interpolation_stage,\n2649         filternorm=filternorm, filterrad=filterrad, resample=resample,\n2650         url=url, **({\"data\": data} if data is not None else {}),\n2651         **kwargs)\n2652     sci(__ret)\n2653     return __ret\n2654 \n2655 \n2656 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2657 @_copy_docstring_and_deprecators(Axes.legend)\n2658 def legend(*args, **kwargs):\n2659     return gca().legend(*args, **kwargs)\n2660 \n2661 \n2662 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2663 @_copy_docstring_and_deprecators(Axes.locator_params)\n2664 def locator_params(axis='both', tight=None, **kwargs):\n2665     return gca().locator_params(axis=axis, tight=tight, **kwargs)\n2666 \n2667 \n2668 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2669 @_copy_docstring_and_deprecators(Axes.loglog)\n2670 def loglog(*args, **kwargs):\n2671     return gca().loglog(*args, **kwargs)\n2672 \n2673 \n2674 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2675 @_copy_docstring_and_deprecators(Axes.magnitude_spectrum)\n2676 def magnitude_spectrum(\n2677         x, Fs=None, Fc=None, window=None, pad_to=None, sides=None,\n2678         scale=None, *, data=None, **kwargs):\n2679     return gca().magnitude_spectrum(\n2680         x, Fs=Fs, Fc=Fc, window=window, pad_to=pad_to, sides=sides,\n2681         scale=scale, **({\"data\": data} if data is not None else {}),\n2682         **kwargs)\n2683 \n2684 \n2685 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2686 @_copy_docstring_and_deprecators(Axes.margins)\n2687 def margins(*margins, x=None, y=None, tight=True):\n2688     return gca().margins(*margins, x=x, y=y, tight=tight)\n2689 \n2690 \n2691 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2692 @_copy_docstring_and_deprecators(Axes.minorticks_off)\n2693 def minorticks_off():\n2694     return gca().minorticks_off()\n2695 \n2696 \n2697 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2698 @_copy_docstring_and_deprecators(Axes.minorticks_on)\n2699 def minorticks_on():\n2700     return gca().minorticks_on()\n2701 \n2702 \n2703 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2704 @_copy_docstring_and_deprecators(Axes.pcolor)\n2705 def pcolor(\n2706         *args, shading=None, alpha=None, norm=None, cmap=None,\n2707         vmin=None, vmax=None, data=None, **kwargs):\n2708     __ret = gca().pcolor(\n2709         *args, shading=shading, alpha=alpha, norm=norm, cmap=cmap,\n2710         vmin=vmin, vmax=vmax,\n2711         **({\"data\": data} if data is not None else {}), **kwargs)\n2712     sci(__ret)\n2713     return __ret\n2714 \n2715 \n2716 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2717 @_copy_docstring_and_deprecators(Axes.pcolormesh)\n2718 def pcolormesh(\n2719         *args, alpha=None, norm=None, cmap=None, vmin=None,\n2720         vmax=None, shading=None, antialiased=False, data=None,\n2721         **kwargs):\n2722     __ret = gca().pcolormesh(\n2723         *args, alpha=alpha, norm=norm, cmap=cmap, vmin=vmin,\n2724         vmax=vmax, shading=shading, antialiased=antialiased,\n2725         **({\"data\": data} if data is not None else {}), **kwargs)\n2726     sci(__ret)\n2727     return __ret\n2728 \n2729 \n2730 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2731 @_copy_docstring_and_deprecators(Axes.phase_spectrum)\n2732 def phase_spectrum(\n2733         x, Fs=None, Fc=None, window=None, pad_to=None, sides=None, *,\n2734         data=None, **kwargs):\n2735     return gca().phase_spectrum(\n2736         x, Fs=Fs, Fc=Fc, window=window, pad_to=pad_to, sides=sides,\n2737         **({\"data\": data} if data is not None else {}), **kwargs)\n2738 \n2739 \n2740 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2741 @_copy_docstring_and_deprecators(Axes.pie)\n2742 def pie(\n2743         x, explode=None, labels=None, colors=None, autopct=None,\n2744         pctdistance=0.6, shadow=False, labeldistance=1.1,\n2745         startangle=0, radius=1, counterclock=True, wedgeprops=None,\n2746         textprops=None, center=(0, 0), frame=False,\n2747         rotatelabels=False, *, normalize=True, data=None):\n2748     return gca().pie(\n2749         x, explode=explode, labels=labels, colors=colors,\n2750         autopct=autopct, pctdistance=pctdistance, shadow=shadow,\n2751         labeldistance=labeldistance, startangle=startangle,\n2752         radius=radius, counterclock=counterclock,\n2753         wedgeprops=wedgeprops, textprops=textprops, center=center,\n2754         frame=frame, rotatelabels=rotatelabels, normalize=normalize,\n2755         **({\"data\": data} if data is not None else {}))\n2756 \n2757 \n2758 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2759 @_copy_docstring_and_deprecators(Axes.plot)\n2760 def plot(*args, scalex=True, scaley=True, data=None, **kwargs):\n2761     return gca().plot(\n2762         *args, scalex=scalex, scaley=scaley,\n2763         **({\"data\": data} if data is not None else {}), **kwargs)\n2764 \n2765 \n2766 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2767 @_copy_docstring_and_deprecators(Axes.plot_date)\n2768 def plot_date(\n2769         x, y, fmt='o', tz=None, xdate=True, ydate=False, *,\n2770         data=None, **kwargs):\n2771     return gca().plot_date(\n2772         x, y, fmt=fmt, tz=tz, xdate=xdate, ydate=ydate,\n2773         **({\"data\": data} if data is not None else {}), **kwargs)\n2774 \n2775 \n2776 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2777 @_copy_docstring_and_deprecators(Axes.psd)\n2778 def psd(\n2779         x, NFFT=None, Fs=None, Fc=None, detrend=None, window=None,\n2780         noverlap=None, pad_to=None, sides=None, scale_by_freq=None,\n2781         return_line=None, *, data=None, **kwargs):\n2782     return gca().psd(\n2783         x, NFFT=NFFT, Fs=Fs, Fc=Fc, detrend=detrend, window=window,\n2784         noverlap=noverlap, pad_to=pad_to, sides=sides,\n2785         scale_by_freq=scale_by_freq, return_line=return_line,\n2786         **({\"data\": data} if data is not None else {}), **kwargs)\n2787 \n2788 \n2789 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2790 @_copy_docstring_and_deprecators(Axes.quiver)\n2791 def quiver(*args, data=None, **kwargs):\n2792     __ret = gca().quiver(\n2793         *args, **({\"data\": data} if data is not None else {}),\n2794         **kwargs)\n2795     sci(__ret)\n2796     return __ret\n2797 \n2798 \n2799 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2800 @_copy_docstring_and_deprecators(Axes.quiverkey)\n2801 def quiverkey(Q, X, Y, U, label, **kwargs):\n2802     return gca().quiverkey(Q, X, Y, U, label, **kwargs)\n2803 \n2804 \n2805 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2806 @_copy_docstring_and_deprecators(Axes.scatter)\n2807 def scatter(\n2808         x, y, s=None, c=None, marker=None, cmap=None, norm=None,\n2809         vmin=None, vmax=None, alpha=None, linewidths=None, *,\n2810         edgecolors=None, plotnonfinite=False, data=None, **kwargs):\n2811     __ret = gca().scatter(\n2812         x, y, s=s, c=c, marker=marker, cmap=cmap, norm=norm,\n2813         vmin=vmin, vmax=vmax, alpha=alpha, linewidths=linewidths,\n2814         edgecolors=edgecolors, plotnonfinite=plotnonfinite,\n2815         **({\"data\": data} if data is not None else {}), **kwargs)\n2816     sci(__ret)\n2817     return __ret\n2818 \n2819 \n2820 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2821 @_copy_docstring_and_deprecators(Axes.semilogx)\n2822 def semilogx(*args, **kwargs):\n2823     return gca().semilogx(*args, **kwargs)\n2824 \n2825 \n2826 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2827 @_copy_docstring_and_deprecators(Axes.semilogy)\n2828 def semilogy(*args, **kwargs):\n2829     return gca().semilogy(*args, **kwargs)\n2830 \n2831 \n2832 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2833 @_copy_docstring_and_deprecators(Axes.specgram)\n2834 def specgram(\n2835         x, NFFT=None, Fs=None, Fc=None, detrend=None, window=None,\n2836         noverlap=None, cmap=None, xextent=None, pad_to=None,\n2837         sides=None, scale_by_freq=None, mode=None, scale=None,\n2838         vmin=None, vmax=None, *, data=None, **kwargs):\n2839     __ret = gca().specgram(\n2840         x, NFFT=NFFT, Fs=Fs, Fc=Fc, detrend=detrend, window=window,\n2841         noverlap=noverlap, cmap=cmap, xextent=xextent, pad_to=pad_to,\n2842         sides=sides, scale_by_freq=scale_by_freq, mode=mode,\n2843         scale=scale, vmin=vmin, vmax=vmax,\n2844         **({\"data\": data} if data is not None else {}), **kwargs)\n2845     sci(__ret[-1])\n2846     return __ret\n2847 \n2848 \n2849 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2850 @_copy_docstring_and_deprecators(Axes.spy)\n2851 def spy(\n2852         Z, precision=0, marker=None, markersize=None, aspect='equal',\n2853         origin='upper', **kwargs):\n2854     __ret = gca().spy(\n2855         Z, precision=precision, marker=marker, markersize=markersize,\n2856         aspect=aspect, origin=origin, **kwargs)\n2857     if isinstance(__ret, cm.ScalarMappable): sci(__ret)  # noqa\n2858     return __ret\n2859 \n2860 \n2861 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2862 @_copy_docstring_and_deprecators(Axes.stackplot)\n2863 def stackplot(\n2864         x, *args, labels=(), colors=None, baseline='zero', data=None,\n2865         **kwargs):\n2866     return gca().stackplot(\n2867         x, *args, labels=labels, colors=colors, baseline=baseline,\n2868         **({\"data\": data} if data is not None else {}), **kwargs)\n2869 \n2870 \n2871 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2872 @_copy_docstring_and_deprecators(Axes.stem)\n2873 def stem(\n2874         *args, linefmt=None, markerfmt=None, basefmt=None, bottom=0,\n2875         label=None, use_line_collection=True, orientation='vertical',\n2876         data=None):\n2877     return gca().stem(\n2878         *args, linefmt=linefmt, markerfmt=markerfmt, basefmt=basefmt,\n2879         bottom=bottom, label=label,\n2880         use_line_collection=use_line_collection,\n2881         orientation=orientation,\n2882         **({\"data\": data} if data is not None else {}))\n2883 \n2884 \n2885 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2886 @_copy_docstring_and_deprecators(Axes.step)\n2887 def step(x, y, *args, where='pre', data=None, **kwargs):\n2888     return gca().step(\n2889         x, y, *args, where=where,\n2890         **({\"data\": data} if data is not None else {}), **kwargs)\n2891 \n2892 \n2893 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2894 @_copy_docstring_and_deprecators(Axes.streamplot)\n2895 def streamplot(\n2896         x, y, u, v, density=1, linewidth=None, color=None, cmap=None,\n2897         norm=None, arrowsize=1, arrowstyle='-|>', minlength=0.1,\n2898         transform=None, zorder=None, start_points=None, maxlength=4.0,\n2899         integration_direction='both', broken_streamlines=True, *,\n2900         data=None):\n2901     __ret = gca().streamplot(\n2902         x, y, u, v, density=density, linewidth=linewidth, color=color,\n2903         cmap=cmap, norm=norm, arrowsize=arrowsize,\n2904         arrowstyle=arrowstyle, minlength=minlength,\n2905         transform=transform, zorder=zorder, start_points=start_points,\n2906         maxlength=maxlength,\n2907         integration_direction=integration_direction,\n2908         broken_streamlines=broken_streamlines,\n2909         **({\"data\": data} if data is not None else {}))\n2910     sci(__ret.lines)\n2911     return __ret\n2912 \n2913 \n2914 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2915 @_copy_docstring_and_deprecators(Axes.table)\n2916 def table(\n2917         cellText=None, cellColours=None, cellLoc='right',\n2918         colWidths=None, rowLabels=None, rowColours=None,\n2919         rowLoc='left', colLabels=None, colColours=None,\n2920         colLoc='center', loc='bottom', bbox=None, edges='closed',\n2921         **kwargs):\n2922     return gca().table(\n2923         cellText=cellText, cellColours=cellColours, cellLoc=cellLoc,\n2924         colWidths=colWidths, rowLabels=rowLabels,\n2925         rowColours=rowColours, rowLoc=rowLoc, colLabels=colLabels,\n2926         colColours=colColours, colLoc=colLoc, loc=loc, bbox=bbox,\n2927         edges=edges, **kwargs)\n2928 \n2929 \n2930 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2931 @_copy_docstring_and_deprecators(Axes.text)\n2932 def text(x, y, s, fontdict=None, **kwargs):\n2933     return gca().text(x, y, s, fontdict=fontdict, **kwargs)\n2934 \n2935 \n2936 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2937 @_copy_docstring_and_deprecators(Axes.tick_params)\n2938 def tick_params(axis='both', **kwargs):\n2939     return gca().tick_params(axis=axis, **kwargs)\n2940 \n2941 \n2942 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2943 @_copy_docstring_and_deprecators(Axes.ticklabel_format)\n2944 def ticklabel_format(\n2945         *, axis='both', style='', scilimits=None, useOffset=None,\n2946         useLocale=None, useMathText=None):\n2947     return gca().ticklabel_format(\n2948         axis=axis, style=style, scilimits=scilimits,\n2949         useOffset=useOffset, useLocale=useLocale,\n2950         useMathText=useMathText)\n2951 \n2952 \n2953 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2954 @_copy_docstring_and_deprecators(Axes.tricontour)\n2955 def tricontour(*args, **kwargs):\n2956     __ret = gca().tricontour(*args, **kwargs)\n2957     if __ret._A is not None: sci(__ret)  # noqa\n2958     return __ret\n2959 \n2960 \n2961 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2962 @_copy_docstring_and_deprecators(Axes.tricontourf)\n2963 def tricontourf(*args, **kwargs):\n2964     __ret = gca().tricontourf(*args, **kwargs)\n2965     if __ret._A is not None: sci(__ret)  # noqa\n2966     return __ret\n2967 \n2968 \n2969 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2970 @_copy_docstring_and_deprecators(Axes.tripcolor)\n2971 def tripcolor(\n2972         *args, alpha=1.0, norm=None, cmap=None, vmin=None, vmax=None,\n2973         shading='flat', facecolors=None, **kwargs):\n2974     __ret = gca().tripcolor(\n2975         *args, alpha=alpha, norm=norm, cmap=cmap, vmin=vmin,\n2976         vmax=vmax, shading=shading, facecolors=facecolors, **kwargs)\n2977     sci(__ret)\n2978     return __ret\n2979 \n2980 \n2981 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2982 @_copy_docstring_and_deprecators(Axes.triplot)\n2983 def triplot(*args, **kwargs):\n2984     return gca().triplot(*args, **kwargs)\n2985 \n2986 \n2987 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2988 @_copy_docstring_and_deprecators(Axes.violinplot)\n2989 def violinplot(\n2990         dataset, positions=None, vert=True, widths=0.5,\n2991         showmeans=False, showextrema=True, showmedians=False,\n2992         quantiles=None, points=100, bw_method=None, *, data=None):\n2993     return gca().violinplot(\n2994         dataset, positions=positions, vert=vert, widths=widths,\n2995         showmeans=showmeans, showextrema=showextrema,\n2996         showmedians=showmedians, quantiles=quantiles, points=points,\n2997         bw_method=bw_method,\n2998         **({\"data\": data} if data is not None else {}))\n2999 \n3000 \n3001 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n3002 @_copy_docstring_and_deprecators(Axes.vlines)\n3003 def vlines(\n3004         x, ymin, ymax, colors=None, linestyles='solid', label='', *,\n3005         data=None, **kwargs):\n3006     return gca().vlines(\n3007         x, ymin, ymax, colors=colors, linestyles=linestyles,\n3008         label=label, **({\"data\": data} if data is not None else {}),\n3009         **kwargs)\n3010 \n3011 \n3012 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n3013 @_copy_docstring_and_deprecators(Axes.xcorr)\n3014 def xcorr(\n3015         x, y, normed=True, detrend=mlab.detrend_none, usevlines=True,\n3016         maxlags=10, *, data=None, **kwargs):\n3017     return gca().xcorr(\n3018         x, y, normed=normed, detrend=detrend, usevlines=usevlines,\n3019         maxlags=maxlags,\n3020         **({\"data\": data} if data is not None else {}), **kwargs)\n3021 \n3022 \n3023 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n3024 @_copy_docstring_and_deprecators(Axes._sci)\n3025 def sci(im):\n3026     return gca()._sci(im)\n3027 \n3028 \n3029 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n3030 @_copy_docstring_and_deprecators(Axes.set_title)\n3031 def title(label, fontdict=None, loc=None, pad=None, *, y=None, **kwargs):\n3032     return gca().set_title(\n3033         label, fontdict=fontdict, loc=loc, pad=pad, y=y, **kwargs)\n3034 \n3035 \n3036 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n3037 @_copy_docstring_and_deprecators(Axes.set_xlabel)\n3038 def xlabel(xlabel, fontdict=None, labelpad=None, *, loc=None, **kwargs):\n3039     return gca().set_xlabel(\n3040         xlabel, fontdict=fontdict, labelpad=labelpad, loc=loc,\n3041         **kwargs)\n3042 \n3043 \n3044 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n3045 @_copy_docstring_and_deprecators(Axes.set_ylabel)\n3046 def ylabel(ylabel, fontdict=None, labelpad=None, *, loc=None, **kwargs):\n3047     return gca().set_ylabel(\n3048         ylabel, fontdict=fontdict, labelpad=labelpad, loc=loc,\n3049         **kwargs)\n3050 \n3051 \n3052 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n3053 @_copy_docstring_and_deprecators(Axes.set_xscale)\n3054 def xscale(value, **kwargs):\n3055     return gca().set_xscale(value, **kwargs)\n3056 \n3057 \n3058 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n3059 @_copy_docstring_and_deprecators(Axes.set_yscale)\n3060 def yscale(value, **kwargs):\n3061     return gca().set_yscale(value, **kwargs)\n3062 \n3063 \n3064 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n3065 def autumn(): set_cmap('autumn')\n3066 def bone(): set_cmap('bone')\n3067 def cool(): set_cmap('cool')\n3068 def copper(): set_cmap('copper')\n3069 def flag(): set_cmap('flag')\n3070 def gray(): set_cmap('gray')\n3071 def hot(): set_cmap('hot')\n3072 def hsv(): set_cmap('hsv')\n3073 def jet(): set_cmap('jet')\n3074 def pink(): set_cmap('pink')\n3075 def prism(): set_cmap('prism')\n3076 def spring(): set_cmap('spring')\n3077 def summer(): set_cmap('summer')\n3078 def winter(): set_cmap('winter')\n3079 def magma(): set_cmap('magma')\n3080 def inferno(): set_cmap('inferno')\n3081 def plasma(): set_cmap('plasma')\n3082 def viridis(): set_cmap('viridis')\n3083 def nipy_spectral(): set_cmap('nipy_spectral')\n3084 \n3085 \n3086 _setup_pyplot_info_docstrings()\n",
        "intended_behavior": "This method should be extended or adjusted to correctly recognize and handle `SubFigure` objects. When `num` is a `SubFigure`, instead of attempting (and failing) to convert it to an integer, the method should either navigate to its parent figure or directly manage the `SubFigure` without raising a type error. This change will allow `plt.sca()` to be used with axes that are part of subfigures, aligning with the intended seamless usage between figures and axes across different contexts in Matplotlib."
    }
]