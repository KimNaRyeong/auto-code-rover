2025-10-15 21:13:54.124 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-15 21:13:55.302 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=878, output_tokens=12, cost=0.009140
2025-10-15 21:14:07.576 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1058, output_tokens=534, cost=0.026600
2025-10-15 21:14:08.600 | INFO     | registered non reproducing test 0
2025-10-15 21:14:26.311 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2114, output_tokens=738, cost=0.043280
2025-10-15 21:14:44.325 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2114, output_tokens=792, cost=0.044900
2025-10-15 21:14:45.319 | INFO     | registered non reproducing test 2
2025-10-15 21:14:45.319 | WARNING  | Failed to write a reproducer test; skipping reproducer tracing
2025-10-15 21:14:45.322 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 21:14:55.254 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1175, output_tokens=305, cost=0.020900
2025-10-15 21:14:55.260 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 21:14:58.824 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=659, output_tokens=71, cost=0.008720
2025-10-15 21:14:58.825 | DEBUG    | Extracted a valid json.
2025-10-15 21:14:58.826 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_class(\"Flask\")",
        "search_class(\"Blueprint\")",
        "search_method(\"register_blueprint\")",
        "search_code(\"app.config['SERVER_NAME'] =\")",
        "search_method_in_class(\"add_url_rule\", \"Blueprint\")"
    ],
    "bug_locations": []
}
2025-10-15 21:14:58.905 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-15 21:14:58.906 | DEBUG    | <Agent search> Analyzing search results.
2025-10-15 21:15:19.181 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=5215, output_tokens=682, cost=0.072610
2025-10-15 21:15:19.195 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 21:15:33.784 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=6113, output_tokens=593, cost=0.078920
2025-10-15 21:15:33.789 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 21:15:40.501 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=947, output_tokens=283, cost=0.017960
2025-10-15 21:15:40.501 | DEBUG    | Extracted a valid json.
2025-10-15 21:15:40.501 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_method(\"subdomain_matching\")",
        "search_method(\"url_map_class\")",
        "search_method_in_class(\"register\", \"Blueprint\")",
        "search_method_in_class(\"make_setup_state\", \"Blueprint\")"
    ],
    "bug_locations": [
        {
            "file": "src/flask/blueprints.py",
            "class": "Blueprint",
            "method": "register_blueprint",
            "intended_behavior": "When registering a nested blueprint (a child blueprint within another blueprint), ensure that subdomain settings of the parent are effectively passed down or correctly resolved for the child blueprint. This might involve adjusting how options (like subdomain) are handled or inherited during the registration process to ensure that routes defined in child blueprints are accessible under the parent blueprint's subdomain."
        },
        {
            "file": "src/flask/app.py",
            "class": "Flask",
            "method": "register_blueprint",
            "intended_behavior": "Enhance this method to better handle the case where a blueprint is registered with a subdomain, especially ensuring that nested blueprints inherit or acknowledge this subdomain in their routing logic. This may involve modifications to how the Flask app constructs its URL map when subdomains are involved, taking care to include routes from nested blueprints under the appropriate subdomain."
        }
    ]
}
2025-10-15 21:15:40.522 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-15 21:15:40.522 | DEBUG    | <Agent search> Analyzing search results.
2025-10-15 21:15:57.053 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=8219, output_tokens=659, cost=0.101960
2025-10-15 21:15:57.060 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 21:16:08.306 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=9094, output_tokens=438, cost=0.104080
2025-10-15 21:16:08.315 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 21:16:17.016 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=792, output_tokens=362, cost=0.018780
2025-10-15 21:16:17.016 | DEBUG    | Extracted a valid json.
2025-10-15 21:16:17.016 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "src/flask/blueprints.py",
            "class": "Blueprint",
            "method": "register",
            "intended_behavior": "This method should be enhanced to ensure that when a blueprint is registered (especially nested blueprints), the subdomain configuration of the parent is correctly inherited and applied. Specifically, if a parent blueprint is registered with a subdomain, all nested child blueprints should automatically inherit this subdomain setting unless explicitly overridden. This adjustment will ensure that routes defined in nested blueprints are accessible under the correctly configured subdomain of their parent blueprint, thereby preserving the intended routing hierarchy envisioned when using nesting and subdomains together. The existing functionality for blueprints that do not utilize subdomains or are not part of a nested structure should remain unaffected."
        },
        {
            "file": "src/flask/app.py",
            "class": "Flask",
            "method": "register_blueprint",
            "intended_behavior": "While this method might not directly exhibit a bug in the context provided by the search results, it could be an area to ensure integration of enhanced subdomain handling as described for `Blueprint.register`. The intended behavior would be to adjust or ensure that the blueprint registration process, specifically when handling subdomains, is robust and takes into consideration the inheritance of subdomains in nested blueprints. This might include verifying that the subdomain information is correctly passed on and utilized during the registration process, aligning with the enhancements suggested for the Blueprint class's `register` method. The goal is to provide a consistent and intuitive behavior when registering blueprints, respecting subdomains across both parent and nested blueprints without disrupting existing functionality or behaviors for other use cases."
        }
    ]
}
2025-10-15 21:16:17.029 | DEBUG    | Bug location extracted successfully: [<file>src/flask/blueprints.py</file>
<class>Blueprint</class>
<method>register</method>
<code>
350     def register(self, app: "Flask", options: dict) -> None:
351         """Called by :meth:`Flask.register_blueprint` to register all
352         views and callbacks registered on the blueprint with the
353         application. Creates a :class:`.BlueprintSetupState` and calls
354         each :meth:`record` callback with it.
355 
356         :param app: The application this blueprint is being registered
357             with.
358         :param options: Keyword arguments forwarded from
359             :meth:`~Flask.register_blueprint`.
360 
361         .. versionchanged:: 2.0.1
362             Nested blueprints are registered with their dotted name.
363             This allows different blueprints with the same name to be
364             nested at different locations.
365 
366         .. versionchanged:: 2.0.1
367             The ``name`` option can be used to change the (pre-dotted)
368             name the blueprint is registered with. This allows the same
369             blueprint to be registered multiple times with unique names
370             for ``url_for``.
371 
372         .. versionchanged:: 2.0.1
373             Registering the same blueprint with the same name multiple
374             times is deprecated and will become an error in Flask 2.1.
375         """
376         name_prefix = options.get("name_prefix", "")
377         self_name = options.get("name", self.name)
378         name = f"{name_prefix}.{self_name}".lstrip(".")
379 
380         if name in app.blueprints:
381             bp_desc = "this" if app.blueprints[name] is self else "a different"
382             existing_at = f" '{name}'" if self_name != name else ""
383 
384             raise ValueError(
385                 f"The name '{self_name}' is already registered for"
386                 f" {bp_desc} blueprint{existing_at}. Use 'name=' to"
387                 f" provide a unique name."
388             )
389 
390         first_bp_registration = not any(bp is self for bp in app.blueprints.values())
391         first_name_registration = name not in app.blueprints
392 
393         app.blueprints[name] = self
394         self._got_registered_once = True
395         state = self.make_setup_state(app, options, first_bp_registration)
396 
397         if self.has_static_folder:
398             state.add_url_rule(
399                 f"{self.static_url_path}/<path:filename>",
400                 view_func=self.send_static_file,
401                 endpoint="static",
402             )
403 
404         # Merge blueprint data into parent.
405         if first_bp_registration or first_name_registration:
406 
407             def extend(bp_dict, parent_dict):
408                 for key, values in bp_dict.items():
409                     key = name if key is None else f"{name}.{key}"
410                     parent_dict[key].extend(values)
411 
412             for key, value in self.error_handler_spec.items():
413                 key = name if key is None else f"{name}.{key}"
414                 value = defaultdict(
415                     dict,
416                     {
417                         code: {
418                             exc_class: func for exc_class, func in code_values.items()
419                         }
420                         for code, code_values in value.items()
421                     },
422                 )
423                 app.error_handler_spec[key] = value
424 
425             for endpoint, func in self.view_functions.items():
426                 app.view_functions[endpoint] = func
427 
428             extend(self.before_request_funcs, app.before_request_funcs)
429             extend(self.after_request_funcs, app.after_request_funcs)
430             extend(
431                 self.teardown_request_funcs,
432                 app.teardown_request_funcs,
433             )
434             extend(self.url_default_functions, app.url_default_functions)
435             extend(self.url_value_preprocessors, app.url_value_preprocessors)
436             extend(self.template_context_processors, app.template_context_processors)
437 
438         for deferred in self.deferred_functions:
439             deferred(state)
440 
441         cli_resolved_group = options.get("cli_group", self.cli_group)
442 
443         if self.cli.commands:
444             if cli_resolved_group is None:
445                 app.cli.commands.update(self.cli.commands)
446             elif cli_resolved_group is _sentinel:
447                 self.cli.name = name
448                 app.cli.add_command(self.cli)
449             else:
450                 self.cli.name = cli_resolved_group
451                 app.cli.add_command(self.cli)
452 
453         for blueprint, bp_options in self._blueprints:
454             bp_options = bp_options.copy()
455             bp_url_prefix = bp_options.get("url_prefix")
456 
457             if bp_url_prefix is None:
458                 bp_url_prefix = blueprint.url_prefix
459 
460             if state.url_prefix is not None and bp_url_prefix is not None:
461                 bp_options["url_prefix"] = (
462                     state.url_prefix.rstrip("/") + "/" + bp_url_prefix.lstrip("/")
463                 )
464             elif bp_url_prefix is not None:
465                 bp_options["url_prefix"] = bp_url_prefix
466             elif state.url_prefix is not None:
467                 bp_options["url_prefix"] = state.url_prefix
468 
469             bp_options["name_prefix"] = name
470             blueprint.register(app, bp_options)

</code><intended_behavior>This method should be enhanced to ensure that when a blueprint is registered (especially nested blueprints), the subdomain configuration of the parent is correctly inherited and applied. Specifically, if a parent blueprint is registered with a subdomain, all nested child blueprints should automatically inherit this subdomain setting unless explicitly overridden. This adjustment will ensure that routes defined in nested blueprints are accessible under the correctly configured subdomain of their parent blueprint, thereby preserving the intended routing hierarchy envisioned when using nesting and subdomains together. The existing functionality for blueprints that do not utilize subdomains or are not part of a nested structure should remain unaffected.</intended_behavior>, <file>src/flask/blueprints.py</file>
<class>Blueprint</class>
<method>None</method>
<code>
121 class Blueprint(Scaffold):
122     """Represents a blueprint, a collection of routes and other
123     app-related functions that can be registered on a real application
124     later.
125 
126     A blueprint is an object that allows defining application functions
127     without requiring an application object ahead of time. It uses the
128     same decorators as :class:`~flask.Flask`, but defers the need for an
129     application by recording them for later registration.
130 
131     Decorating a function with a blueprint creates a deferred function
132     that is called with :class:`~flask.blueprints.BlueprintSetupState`
133     when the blueprint is registered on an application.
134 
135     See :doc:`/blueprints` for more information.
136 
137     :param name: The name of the blueprint. Will be prepended to each
138         endpoint name.
139     :param import_name: The name of the blueprint package, usually
140         ``__name__``. This helps locate the ``root_path`` for the
141         blueprint.
142     :param static_folder: A folder with static files that should be
143         served by the blueprint's static route. The path is relative to
144         the blueprint's root path. Blueprint static files are disabled
145         by default.
146     :param static_url_path: The url to serve static files from.
147         Defaults to ``static_folder``. If the blueprint does not have
148         a ``url_prefix``, the app's static route will take precedence,
149         and the blueprint's static files won't be accessible.
150     :param template_folder: A folder with templates that should be added
151         to the app's template search path. The path is relative to the
152         blueprint's root path. Blueprint templates are disabled by
153         default. Blueprint templates have a lower precedence than those
154         in the app's templates folder.
155     :param url_prefix: A path to prepend to all of the blueprint's URLs,
156         to make them distinct from the rest of the app's routes.
157     :param subdomain: A subdomain that blueprint routes will match on by
158         default.
159     :param url_defaults: A dict of default values that blueprint routes
160         will receive by default.
161     :param root_path: By default, the blueprint will automatically set
162         this based on ``import_name``. In certain situations this
163         automatic detection can fail, so the path can be specified
164         manually instead.
165 
166     .. versionchanged:: 1.1.0
167         Blueprints have a ``cli`` group to register nested CLI commands.
168         The ``cli_group`` parameter controls the name of the group under
169         the ``flask`` command.
170 
171     .. versionadded:: 0.7
172     """
173 
174     _got_registered_once = False
175 
176     _json_encoder: t.Union[t.Type[json.JSONEncoder], None] = None
177     _json_decoder: t.Union[t.Type[json.JSONDecoder], None] = None
178 
179     @property
180     def json_encoder(
181         self,
182     ) -> t.Union[t.Type[json.JSONEncoder], None]:
183         """Blueprint-local JSON encoder class to use. Set to ``None`` to use the app's.
184 
185         .. deprecated:: 2.2
186              Will be removed in Flask 2.3. Customize
187              :attr:`json_provider_class` instead.
188 
189         .. versionadded:: 0.10
190         """
191         import warnings
192 
193         warnings.warn(
194             "'bp.json_encoder' is deprecated and will be removed in Flask 2.3."
195             " Customize 'app.json_provider_class' or 'app.json' instead.",
196             DeprecationWarning,
197             stacklevel=2,
198         )
199         return self._json_encoder
200 
201     @json_encoder.setter
202     def json_encoder(self, value: t.Union[t.Type[json.JSONEncoder], None]) -> None:
203         import warnings
204 
205         warnings.warn(
206             "'bp.json_encoder' is deprecated and will be removed in Flask 2.3."
207             " Customize 'app.json_provider_class' or 'app.json' instead.",
208             DeprecationWarning,
209             stacklevel=2,
210         )
211         self._json_encoder = value
212 
213     @property
214     def json_decoder(
215         self,
216     ) -> t.Union[t.Type[json.JSONDecoder], None]:
217         """Blueprint-local JSON decoder class to use. Set to ``None`` to use the app's.
218 
219         .. deprecated:: 2.2
220              Will be removed in Flask 2.3. Customize
221              :attr:`json_provider_class` instead.
222 
223         .. versionadded:: 0.10
224         """
225         import warnings
226 
227         warnings.warn(
228             "'bp.json_decoder' is deprecated and will be removed in Flask 2.3."
229             " Customize 'app.json_provider_class' or 'app.json' instead.",
230             DeprecationWarning,
231             stacklevel=2,
232         )
233         return self._json_decoder
234 
235     @json_decoder.setter
236     def json_decoder(self, value: t.Union[t.Type[json.JSONDecoder], None]) -> None:
237         import warnings
238 
239         warnings.warn(
240             "'bp.json_decoder' is deprecated and will be removed in Flask 2.3."
241             " Customize 'app.json_provider_class' or 'app.json' instead.",
242             DeprecationWarning,
243             stacklevel=2,
244         )
245         self._json_decoder = value
246 
247     def __init__(
248         self,
249         name: str,
250         import_name: str,
251         static_folder: t.Optional[t.Union[str, os.PathLike]] = None,
252         static_url_path: t.Optional[str] = None,
253         template_folder: t.Optional[t.Union[str, os.PathLike]] = None,
254         url_prefix: t.Optional[str] = None,
255         subdomain: t.Optional[str] = None,
256         url_defaults: t.Optional[dict] = None,
257         root_path: t.Optional[str] = None,
258         cli_group: t.Optional[str] = _sentinel,  # type: ignore
259     ):
260         super().__init__(
261             import_name=import_name,
262             static_folder=static_folder,
263             static_url_path=static_url_path,
264             template_folder=template_folder,
265             root_path=root_path,
266         )
267 
268         if "." in name:
269             raise ValueError("'name' may not contain a dot '.' character.")
270 
271         self.name = name
272         self.url_prefix = url_prefix
273         self.subdomain = subdomain
274         self.deferred_functions: t.List[DeferredSetupFunction] = []
275 
276         if url_defaults is None:
277             url_defaults = {}
278 
279         self.url_values_defaults = url_defaults
280         self.cli_group = cli_group
281         self._blueprints: t.List[t.Tuple["Blueprint", dict]] = []
282 
283     def _check_setup_finished(self, f_name: str) -> None:
284         if self._got_registered_once:
285             import warnings
286 
287             warnings.warn(
288                 f"The setup method '{f_name}' can no longer be called on"
289                 f" the blueprint '{self.name}'. It has already been"
290                 " registered at least once, any changes will not be"
291                 " applied consistently.\n"
292                 "Make sure all imports, decorators, functions, etc."
293                 " needed to set up the blueprint are done before"
294                 " registering it.\n"
295                 "This warning will become an exception in Flask 2.3.",
296                 UserWarning,
297                 stacklevel=3,
298             )
299 
300     @setupmethod
301     def record(self, func: t.Callable) -> None:
302         """Registers a function that is called when the blueprint is
303         registered on the application.  This function is called with the
304         state as argument as returned by the :meth:`make_setup_state`
305         method.
306         """
307         self.deferred_functions.append(func)
308 
309     @setupmethod
310     def record_once(self, func: t.Callable) -> None:
311         """Works like :meth:`record` but wraps the function in another
312         function that will ensure the function is only called once.  If the
313         blueprint is registered a second time on the application, the
314         function passed is not called.
315         """
316 
317         def wrapper(state: BlueprintSetupState) -> None:
318             if state.first_registration:
319                 func(state)
320 
321         self.record(update_wrapper(wrapper, func))
322 
323     def make_setup_state(
324         self, app: "Flask", options: dict, first_registration: bool = False
325     ) -> BlueprintSetupState:
326         """Creates an instance of :meth:`~flask.blueprints.BlueprintSetupState`
327         object that is later passed to the register callback functions.
328         Subclasses can override this to return a subclass of the setup state.
329         """
330         return BlueprintSetupState(self, app, options, first_registration)
331 
332     @setupmethod
333     def register_blueprint(self, blueprint: "Blueprint", **options: t.Any) -> None:
334         """Register a :class:`~flask.Blueprint` on this blueprint. Keyword
335         arguments passed to this method will override the defaults set
336         on the blueprint.
337 
338         .. versionchanged:: 2.0.1
339             The ``name`` option can be used to change the (pre-dotted)
340             name the blueprint is registered with. This allows the same
341             blueprint to be registered multiple times with unique names
342             for ``url_for``.
343 
344         .. versionadded:: 2.0
345         """
346         if blueprint is self:
347             raise ValueError("Cannot register a blueprint on itself")
348         self._blueprints.append((blueprint, options))
349 
350     def register(self, app: "Flask", options: dict) -> None:
351         """Called by :meth:`Flask.register_blueprint` to register all
352         views and callbacks registered on the blueprint with the
353         application. Creates a :class:`.BlueprintSetupState` and calls
354         each :meth:`record` callback with it.
355 
356         :param app: The application this blueprint is being registered
357             with.
358         :param options: Keyword arguments forwarded from
359             :meth:`~Flask.register_blueprint`.
360 
361         .. versionchanged:: 2.0.1
362             Nested blueprints are registered with their dotted name.
363             This allows different blueprints with the same name to be
364             nested at different locations.
365 
366         .. versionchanged:: 2.0.1
367             The ``name`` option can be used to change the (pre-dotted)
368             name the blueprint is registered with. This allows the same
369             blueprint to be registered multiple times with unique names
370             for ``url_for``.
371 
372         .. versionchanged:: 2.0.1
373             Registering the same blueprint with the same name multiple
374             times is deprecated and will become an error in Flask 2.1.
375         """
376         name_prefix = options.get("name_prefix", "")
377         self_name = options.get("name", self.name)
378         name = f"{name_prefix}.{self_name}".lstrip(".")
379 
380         if name in app.blueprints:
381             bp_desc = "this" if app.blueprints[name] is self else "a different"
382             existing_at = f" '{name}'" if self_name != name else ""
383 
384             raise ValueError(
385                 f"The name '{self_name}' is already registered for"
386                 f" {bp_desc} blueprint{existing_at}. Use 'name=' to"
387                 f" provide a unique name."
388             )
389 
390         first_bp_registration = not any(bp is self for bp in app.blueprints.values())
391         first_name_registration = name not in app.blueprints
392 
393         app.blueprints[name] = self
394         self._got_registered_once = True
395         state = self.make_setup_state(app, options, first_bp_registration)
396 
397         if self.has_static_folder:
398             state.add_url_rule(
399                 f"{self.static_url_path}/<path:filename>",
400                 view_func=self.send_static_file,
401                 endpoint="static",
402             )
403 
404         # Merge blueprint data into parent.
405         if first_bp_registration or first_name_registration:
406 
407             def extend(bp_dict, parent_dict):
408                 for key, values in bp_dict.items():
409                     key = name if key is None else f"{name}.{key}"
410                     parent_dict[key].extend(values)
411 
412             for key, value in self.error_handler_spec.items():
413                 key = name if key is None else f"{name}.{key}"
414                 value = defaultdict(
415                     dict,
416                     {
417                         code: {
418                             exc_class: func for exc_class, func in code_values.items()
419                         }
420                         for code, code_values in value.items()
421                     },
422                 )
423                 app.error_handler_spec[key] = value
424 
425             for endpoint, func in self.view_functions.items():
426                 app.view_functions[endpoint] = func
427 
428             extend(self.before_request_funcs, app.before_request_funcs)
429             extend(self.after_request_funcs, app.after_request_funcs)
430             extend(
431                 self.teardown_request_funcs,
432                 app.teardown_request_funcs,
433             )
434             extend(self.url_default_functions, app.url_default_functions)
435             extend(self.url_value_preprocessors, app.url_value_preprocessors)
436             extend(self.template_context_processors, app.template_context_processors)
437 
438         for deferred in self.deferred_functions:
439             deferred(state)
440 
441         cli_resolved_group = options.get("cli_group", self.cli_group)
442 
443         if self.cli.commands:
444             if cli_resolved_group is None:
445                 app.cli.commands.update(self.cli.commands)
446             elif cli_resolved_group is _sentinel:
447                 self.cli.name = name
448                 app.cli.add_command(self.cli)
449             else:
450                 self.cli.name = cli_resolved_group
451                 app.cli.add_command(self.cli)
452 
453         for blueprint, bp_options in self._blueprints:
454             bp_options = bp_options.copy()
455             bp_url_prefix = bp_options.get("url_prefix")
456 
457             if bp_url_prefix is None:
458                 bp_url_prefix = blueprint.url_prefix
459 
460             if state.url_prefix is not None and bp_url_prefix is not None:
461                 bp_options["url_prefix"] = (
462                     state.url_prefix.rstrip("/") + "/" + bp_url_prefix.lstrip("/")
463                 )
464             elif bp_url_prefix is not None:
465                 bp_options["url_prefix"] = bp_url_prefix
466             elif state.url_prefix is not None:
467                 bp_options["url_prefix"] = state.url_prefix
468 
469             bp_options["name_prefix"] = name
470             blueprint.register(app, bp_options)
471 
472     @setupmethod
473     def add_url_rule(
474         self,
475         rule: str,
476         endpoint: t.Optional[str] = None,
477         view_func: t.Optional[ft.RouteCallable] = None,
478         provide_automatic_options: t.Optional[bool] = None,
479         **options: t.Any,
480     ) -> None:
481         """Like :meth:`Flask.add_url_rule` but for a blueprint.  The endpoint for
482         the :func:`url_for` function is prefixed with the name of the blueprint.
483         """
484         if endpoint and "." in endpoint:
485             raise ValueError("'endpoint' may not contain a dot '.' character.")
486 
487         if view_func and hasattr(view_func, "__name__") and "." in view_func.__name__:
488             raise ValueError("'view_func' name may not contain a dot '.' character.")
489 
490         self.record(
491             lambda s: s.add_url_rule(
492                 rule,
493                 endpoint,
494                 view_func,
495                 provide_automatic_options=provide_automatic_options,
496                 **options,
497             )
498         )
499 
500     @setupmethod
501     def app_template_filter(
502         self, name: t.Optional[str] = None
503     ) -> t.Callable[[T_template_filter], T_template_filter]:
504         """Register a custom template filter, available application wide.  Like
505         :meth:`Flask.template_filter` but for a blueprint.
506 
507         :param name: the optional name of the filter, otherwise the
508                      function name will be used.
509         """
510 
511         def decorator(f: T_template_filter) -> T_template_filter:
512             self.add_app_template_filter(f, name=name)
513             return f
514 
515         return decorator
516 
517     @setupmethod
518     def add_app_template_filter(
519         self, f: ft.TemplateFilterCallable, name: t.Optional[str] = None
520     ) -> None:
521         """Register a custom template filter, available application wide.  Like
522         :meth:`Flask.add_template_filter` but for a blueprint.  Works exactly
523         like the :meth:`app_template_filter` decorator.
524 
525         :param name: the optional name of the filter, otherwise the
526                      function name will be used.
527         """
528 
529         def register_template(state: BlueprintSetupState) -> None:
530             state.app.jinja_env.filters[name or f.__name__] = f
531 
532         self.record_once(register_template)
533 
534     @setupmethod
535     def app_template_test(
536         self, name: t.Optional[str] = None
537     ) -> t.Callable[[T_template_test], T_template_test]:
538         """Register a custom template test, available application wide.  Like
539         :meth:`Flask.template_test` but for a blueprint.
540 
541         .. versionadded:: 0.10
542 
543         :param name: the optional name of the test, otherwise the
544                      function name will be used.
545         """
546 
547         def decorator(f: T_template_test) -> T_template_test:
548             self.add_app_template_test(f, name=name)
549             return f
550 
551         return decorator
552 
553     @setupmethod
554     def add_app_template_test(
555         self, f: ft.TemplateTestCallable, name: t.Optional[str] = None
556     ) -> None:
557         """Register a custom template test, available application wide.  Like
558         :meth:`Flask.add_template_test` but for a blueprint.  Works exactly
559         like the :meth:`app_template_test` decorator.
560 
561         .. versionadded:: 0.10
562 
563         :param name: the optional name of the test, otherwise the
564                      function name will be used.
565         """
566 
567         def register_template(state: BlueprintSetupState) -> None:
568             state.app.jinja_env.tests[name or f.__name__] = f
569 
570         self.record_once(register_template)
571 
572     @setupmethod
573     def app_template_global(
574         self, name: t.Optional[str] = None
575     ) -> t.Callable[[T_template_global], T_template_global]:
576         """Register a custom template global, available application wide.  Like
577         :meth:`Flask.template_global` but for a blueprint.
578 
579         .. versionadded:: 0.10
580 
581         :param name: the optional name of the global, otherwise the
582                      function name will be used.
583         """
584 
585         def decorator(f: T_template_global) -> T_template_global:
586             self.add_app_template_global(f, name=name)
587             return f
588 
589         return decorator
590 
591     @setupmethod
592     def add_app_template_global(
593         self, f: ft.TemplateGlobalCallable, name: t.Optional[str] = None
594     ) -> None:
595         """Register a custom template global, available application wide.  Like
596         :meth:`Flask.add_template_global` but for a blueprint.  Works exactly
597         like the :meth:`app_template_global` decorator.
598 
599         .. versionadded:: 0.10
600 
601         :param name: the optional name of the global, otherwise the
602                      function name will be used.
603         """
604 
605         def register_template(state: BlueprintSetupState) -> None:
606             state.app.jinja_env.globals[name or f.__name__] = f
607 
608         self.record_once(register_template)
609 
610     @setupmethod
611     def before_app_request(self, f: T_before_request) -> T_before_request:
612         """Like :meth:`Flask.before_request`.  Such a function is executed
613         before each request, even if outside of a blueprint.
614         """
615         self.record_once(
616             lambda s: s.app.before_request_funcs.setdefault(None, []).append(f)
617         )
618         return f
619 
620     @setupmethod
621     def before_app_first_request(
622         self, f: T_before_first_request
623     ) -> T_before_first_request:
624         """Like :meth:`Flask.before_first_request`.  Such a function is
625         executed before the first request to the application.
626 
627         .. deprecated:: 2.2
628             Will be removed in Flask 2.3. Run setup code when creating
629             the application instead.
630         """
631         import warnings
632 
633         warnings.warn(
634             "'before_app_first_request' is deprecated and will be"
635             " removed in Flask 2.3. Use 'record_once' instead to run"
636             " setup code when registering the blueprint.",
637             DeprecationWarning,
638             stacklevel=2,
639         )
640         self.record_once(lambda s: s.app.before_first_request_funcs.append(f))
641         return f
642 
643     @setupmethod
644     def after_app_request(self, f: T_after_request) -> T_after_request:
645         """Like :meth:`Flask.after_request` but for a blueprint.  Such a function
646         is executed after each request, even if outside of the blueprint.
647         """
648         self.record_once(
649             lambda s: s.app.after_request_funcs.setdefault(None, []).append(f)
650         )
651         return f
652 
653     @setupmethod
654     def teardown_app_request(self, f: T_teardown) -> T_teardown:
655         """Like :meth:`Flask.teardown_request` but for a blueprint.  Such a
656         function is executed when tearing down each request, even if outside of
657         the blueprint.
658         """
659         self.record_once(
660             lambda s: s.app.teardown_request_funcs.setdefault(None, []).append(f)
661         )
662         return f
663 
664     @setupmethod
665     def app_context_processor(
666         self, f: T_template_context_processor
667     ) -> T_template_context_processor:
668         """Like :meth:`Flask.context_processor` but for a blueprint.  Such a
669         function is executed each request, even if outside of the blueprint.
670         """
671         self.record_once(
672             lambda s: s.app.template_context_processors.setdefault(None, []).append(f)
673         )
674         return f
675 
676     @setupmethod
677     def app_errorhandler(
678         self, code: t.Union[t.Type[Exception], int]
679     ) -> t.Callable[[T_error_handler], T_error_handler]:
680         """Like :meth:`Flask.errorhandler` but for a blueprint.  This
681         handler is used for all requests, even if outside of the blueprint.
682         """
683 
684         def decorator(f: T_error_handler) -> T_error_handler:
685             self.record_once(lambda s: s.app.errorhandler(code)(f))
686             return f
687 
688         return decorator
689 
690     @setupmethod
691     def app_url_value_preprocessor(
692         self, f: T_url_value_preprocessor
693     ) -> T_url_value_preprocessor:
694         """Same as :meth:`url_value_preprocessor` but application wide."""
695         self.record_once(
696             lambda s: s.app.url_value_preprocessors.setdefault(None, []).append(f)
697         )
698         return f
699 
700     @setupmethod
701     def app_url_defaults(self, f: T_url_defaults) -> T_url_defaults:
702         """Same as :meth:`url_defaults` but application wide."""
703         self.record_once(
704             lambda s: s.app.url_default_functions.setdefault(None, []).append(f)
705         )
706         return f

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>, <file>src/flask/app.py</file>
<class>Flask</class>
<method>register_blueprint</method>
<code>
1274     def register_blueprint(self, blueprint: "Blueprint", **options: t.Any) -> None:
1275         """Register a :class:`~flask.Blueprint` on the application. Keyword
1276         arguments passed to this method will override the defaults set on the
1277         blueprint.
1278 
1279         Calls the blueprint's :meth:`~flask.Blueprint.register` method after
1280         recording the blueprint in the application's :attr:`blueprints`.
1281 
1282         :param blueprint: The blueprint to register.
1283         :param url_prefix: Blueprint routes will be prefixed with this.
1284         :param subdomain: Blueprint routes will match on this subdomain.
1285         :param url_defaults: Blueprint routes will use these default values for
1286             view arguments.
1287         :param options: Additional keyword arguments are passed to
1288             :class:`~flask.blueprints.BlueprintSetupState`. They can be
1289             accessed in :meth:`~flask.Blueprint.record` callbacks.
1290 
1291         .. versionchanged:: 2.0.1
1292             The ``name`` option can be used to change the (pre-dotted)
1293             name the blueprint is registered with. This allows the same
1294             blueprint to be registered multiple times with unique names
1295             for ``url_for``.
1296 
1297         .. versionadded:: 0.7
1298         """
1299         blueprint.register(self, options)

</code><intended_behavior>While this method might not directly exhibit a bug in the context provided by the search results, it could be an area to ensure integration of enhanced subdomain handling as described for `Blueprint.register`. The intended behavior would be to adjust or ensure that the blueprint registration process, specifically when handling subdomains, is robust and takes into consideration the inheritance of subdomains in nested blueprints. This might include verifying that the subdomain information is correctly passed on and utilized during the registration process, aligning with the enhancements suggested for the Blueprint class's `register` method. The goal is to provide a consistent and intuitive behavior when registering blueprints, respecting subdomains across both parent and nested blueprints without disrupting existing functionality or behaviors for other use cases.</intended_behavior>, <file>src/flask/app.py</file>
<class>Flask</class>
<method>None</method>
<code>
110 class Flask(Scaffold):
111     """The flask object implements a WSGI application and acts as the central
112     object.  It is passed the name of the module or package of the
113     application.  Once it is created it will act as a central registry for
114     the view functions, the URL rules, template configuration and much more.
115 
116     The name of the package is used to resolve resources from inside the
117     package or the folder the module is contained in depending on if the
118     package parameter resolves to an actual python package (a folder with
119     an :file:`__init__.py` file inside) or a standard module (just a ``.py`` file).
120 
121     For more information about resource loading, see :func:`open_resource`.
122 
123     Usually you create a :class:`Flask` instance in your main module or
124     in the :file:`__init__.py` file of your package like this::
125 
126         from flask import Flask
127         app = Flask(__name__)
128 
129     .. admonition:: About the First Parameter
130 
131         The idea of the first parameter is to give Flask an idea of what
132         belongs to your application.  This name is used to find resources
133         on the filesystem, can be used by extensions to improve debugging
134         information and a lot more.
135 
136         So it's important what you provide there.  If you are using a single
137         module, `__name__` is always the correct value.  If you however are
138         using a package, it's usually recommended to hardcode the name of
139         your package there.
140 
141         For example if your application is defined in :file:`yourapplication/app.py`
142         you should create it with one of the two versions below::
143 
144             app = Flask('yourapplication')
145             app = Flask(__name__.split('.')[0])
146 
147         Why is that?  The application will work even with `__name__`, thanks
148         to how resources are looked up.  However it will make debugging more
149         painful.  Certain extensions can make assumptions based on the
150         import name of your application.  For example the Flask-SQLAlchemy
151         extension will look for the code in your application that triggered
152         an SQL query in debug mode.  If the import name is not properly set
153         up, that debugging information is lost.  (For example it would only
154         pick up SQL queries in `yourapplication.app` and not
155         `yourapplication.views.frontend`)
156 
157     .. versionadded:: 0.7
158        The `static_url_path`, `static_folder`, and `template_folder`
159        parameters were added.
160 
161     .. versionadded:: 0.8
162        The `instance_path` and `instance_relative_config` parameters were
163        added.
164 
165     .. versionadded:: 0.11
166        The `root_path` parameter was added.
167 
168     .. versionadded:: 1.0
169        The ``host_matching`` and ``static_host`` parameters were added.
170 
171     .. versionadded:: 1.0
172        The ``subdomain_matching`` parameter was added. Subdomain
173        matching needs to be enabled manually now. Setting
174        :data:`SERVER_NAME` does not implicitly enable it.
175 
176     :param import_name: the name of the application package
177     :param static_url_path: can be used to specify a different path for the
178                             static files on the web.  Defaults to the name
179                             of the `static_folder` folder.
180     :param static_folder: The folder with static files that is served at
181         ``static_url_path``. Relative to the application ``root_path``
182         or an absolute path. Defaults to ``'static'``.
183     :param static_host: the host to use when adding the static route.
184         Defaults to None. Required when using ``host_matching=True``
185         with a ``static_folder`` configured.
186     :param host_matching: set ``url_map.host_matching`` attribute.
187         Defaults to False.
188     :param subdomain_matching: consider the subdomain relative to
189         :data:`SERVER_NAME` when matching routes. Defaults to False.
190     :param template_folder: the folder that contains the templates that should
191                             be used by the application.  Defaults to
192                             ``'templates'`` folder in the root path of the
193                             application.
194     :param instance_path: An alternative instance path for the application.
195                           By default the folder ``'instance'`` next to the
196                           package or module is assumed to be the instance
197                           path.
198     :param instance_relative_config: if set to ``True`` relative filenames
199                                      for loading the config are assumed to
200                                      be relative to the instance path instead
201                                      of the application root.
202     :param root_path: The path to the root of the application files.
203         This should only be set manually when it can't be detected
204         automatically, such as for namespace packages.
205     """
206 
207     #: The class that is used for request objects.  See :class:`~flask.Request`
208     #: for more information.
209     request_class = Request
210 
211     #: The class that is used for response objects.  See
212     #: :class:`~flask.Response` for more information.
213     response_class = Response
214 
215     #: The class of the object assigned to :attr:`aborter`, created by
216     #: :meth:`create_aborter`. That object is called by
217     #: :func:`flask.abort` to raise HTTP errors, and can be
218     #: called directly as well.
219     #:
220     #: Defaults to :class:`werkzeug.exceptions.Aborter`.
221     #:
222     #: .. versionadded:: 2.2
223     aborter_class = Aborter
224 
225     #: The class that is used for the Jinja environment.
226     #:
227     #: .. versionadded:: 0.11
228     jinja_environment = Environment
229 
230     #: The class that is used for the :data:`~flask.g` instance.
231     #:
232     #: Example use cases for a custom class:
233     #:
234     #: 1. Store arbitrary attributes on flask.g.
235     #: 2. Add a property for lazy per-request database connectors.
236     #: 3. Return None instead of AttributeError on unexpected attributes.
237     #: 4. Raise exception if an unexpected attr is set, a "controlled" flask.g.
238     #:
239     #: In Flask 0.9 this property was called `request_globals_class` but it
240     #: was changed in 0.10 to :attr:`app_ctx_globals_class` because the
241     #: flask.g object is now application context scoped.
242     #:
243     #: .. versionadded:: 0.10
244     app_ctx_globals_class = _AppCtxGlobals
245 
246     #: The class that is used for the ``config`` attribute of this app.
247     #: Defaults to :class:`~flask.Config`.
248     #:
249     #: Example use cases for a custom class:
250     #:
251     #: 1. Default values for certain config options.
252     #: 2. Access to config values through attributes in addition to keys.
253     #:
254     #: .. versionadded:: 0.11
255     config_class = Config
256 
257     #: The testing flag.  Set this to ``True`` to enable the test mode of
258     #: Flask extensions (and in the future probably also Flask itself).
259     #: For example this might activate test helpers that have an
260     #: additional runtime cost which should not be enabled by default.
261     #:
262     #: If this is enabled and PROPAGATE_EXCEPTIONS is not changed from the
263     #: default it's implicitly enabled.
264     #:
265     #: This attribute can also be configured from the config with the
266     #: ``TESTING`` configuration key.  Defaults to ``False``.
267     testing = ConfigAttribute("TESTING")
268 
269     #: If a secret key is set, cryptographic components can use this to
270     #: sign cookies and other things. Set this to a complex random value
271     #: when you want to use the secure cookie for instance.
272     #:
273     #: This attribute can also be configured from the config with the
274     #: :data:`SECRET_KEY` configuration key. Defaults to ``None``.
275     secret_key = ConfigAttribute("SECRET_KEY")
276 
277     @property
278     def session_cookie_name(self) -> str:
279         """The name of the cookie set by the session interface.
280 
281         .. deprecated:: 2.2
282             Will be removed in Flask 2.3. Use ``app.config["SESSION_COOKIE_NAME"]``
283             instead.
284         """
285         import warnings
286 
287         warnings.warn(
288             "'session_cookie_name' is deprecated and will be removed in Flask 2.3. Use"
289             " 'SESSION_COOKIE_NAME' in 'app.config' instead.",
290             DeprecationWarning,
291             stacklevel=2,
292         )
293         return self.config["SESSION_COOKIE_NAME"]
294 
295     @session_cookie_name.setter
296     def session_cookie_name(self, value: str) -> None:
297         import warnings
298 
299         warnings.warn(
300             "'session_cookie_name' is deprecated and will be removed in Flask 2.3. Use"
301             " 'SESSION_COOKIE_NAME' in 'app.config' instead.",
302             DeprecationWarning,
303             stacklevel=2,
304         )
305         self.config["SESSION_COOKIE_NAME"] = value
306 
307     #: A :class:`~datetime.timedelta` which is used to set the expiration
308     #: date of a permanent session.  The default is 31 days which makes a
309     #: permanent session survive for roughly one month.
310     #:
311     #: This attribute can also be configured from the config with the
312     #: ``PERMANENT_SESSION_LIFETIME`` configuration key.  Defaults to
313     #: ``timedelta(days=31)``
314     permanent_session_lifetime = ConfigAttribute(
315         "PERMANENT_SESSION_LIFETIME", get_converter=_make_timedelta
316     )
317 
318     @property
319     def send_file_max_age_default(self) -> t.Optional[timedelta]:
320         """The default value for ``max_age`` for :func:`~flask.send_file`. The default
321         is ``None``, which tells the browser to use conditional requests instead of a
322         timed cache.
323 
324         .. deprecated:: 2.2
325             Will be removed in Flask 2.3. Use
326             ``app.config["SEND_FILE_MAX_AGE_DEFAULT"]`` instead.
327 
328         .. versionchanged:: 2.0
329             Defaults to ``None`` instead of 12 hours.
330         """
331         import warnings
332 
333         warnings.warn(
334             "'send_file_max_age_default' is deprecated and will be removed in Flask"
335             " 2.3. Use 'SEND_FILE_MAX_AGE_DEFAULT' in 'app.config' instead.",
336             DeprecationWarning,
337             stacklevel=2,
338         )
339         return _make_timedelta(self.config["SEND_FILE_MAX_AGE_DEFAULT"])
340 
341     @send_file_max_age_default.setter
342     def send_file_max_age_default(self, value: t.Union[int, timedelta, None]) -> None:
343         import warnings
344 
345         warnings.warn(
346             "'send_file_max_age_default' is deprecated and will be removed in Flask"
347             " 2.3. Use 'SEND_FILE_MAX_AGE_DEFAULT' in 'app.config' instead.",
348             DeprecationWarning,
349             stacklevel=2,
350         )
351         self.config["SEND_FILE_MAX_AGE_DEFAULT"] = _make_timedelta(value)
352 
353     @property
354     def use_x_sendfile(self) -> bool:
355         """Enable this to use the ``X-Sendfile`` feature, assuming the server supports
356         it, from :func:`~flask.send_file`.
357 
358         .. deprecated:: 2.2
359             Will be removed in Flask 2.3. Use ``app.config["USE_X_SENDFILE"]`` instead.
360         """
361         import warnings
362 
363         warnings.warn(
364             "'use_x_sendfile' is deprecated and will be removed in Flask 2.3. Use"
365             " 'USE_X_SENDFILE' in 'app.config' instead.",
366             DeprecationWarning,
367             stacklevel=2,
368         )
369         return self.config["USE_X_SENDFILE"]
370 
371     @use_x_sendfile.setter
372     def use_x_sendfile(self, value: bool) -> None:
373         import warnings
374 
375         warnings.warn(
376             "'use_x_sendfile' is deprecated and will be removed in Flask 2.3. Use"
377             " 'USE_X_SENDFILE' in 'app.config' instead.",
378             DeprecationWarning,
379             stacklevel=2,
380         )
381         self.config["USE_X_SENDFILE"] = value
382 
383     _json_encoder: t.Union[t.Type[json.JSONEncoder], None] = None
384     _json_decoder: t.Union[t.Type[json.JSONDecoder], None] = None
385 
386     @property  # type: ignore[override]
387     def json_encoder(self) -> t.Type[json.JSONEncoder]:
388         """The JSON encoder class to use. Defaults to
389         :class:`~flask.json.JSONEncoder`.
390 
391         .. deprecated:: 2.2
392              Will be removed in Flask 2.3. Customize
393              :attr:`json_provider_class` instead.
394 
395         .. versionadded:: 0.10
396         """
397         import warnings
398 
399         warnings.warn(
400             "'app.json_encoder' is deprecated and will be removed in Flask 2.3."
401             " Customize 'app.json_provider_class' or 'app.json' instead.",
402             DeprecationWarning,
403             stacklevel=2,
404         )
405 
406         if self._json_encoder is None:
407             from . import json
408 
409             return json.JSONEncoder
410 
411         return self._json_encoder
412 
413     @json_encoder.setter
414     def json_encoder(self, value: t.Type[json.JSONEncoder]) -> None:
415         import warnings
416 
417         warnings.warn(
418             "'app.json_encoder' is deprecated and will be removed in Flask 2.3."
419             " Customize 'app.json_provider_class' or 'app.json' instead.",
420             DeprecationWarning,
421             stacklevel=2,
422         )
423         self._json_encoder = value
424 
425     @property  # type: ignore[override]
426     def json_decoder(self) -> t.Type[json.JSONDecoder]:
427         """The JSON decoder class to use. Defaults to
428         :class:`~flask.json.JSONDecoder`.
429 
430         .. deprecated:: 2.2
431              Will be removed in Flask 2.3. Customize
432              :attr:`json_provider_class` instead.
433 
434         .. versionadded:: 0.10
435         """
436         import warnings
437 
438         warnings.warn(
439             "'app.json_decoder' is deprecated and will be removed in Flask 2.3."
440             " Customize 'app.json_provider_class' or 'app.json' instead.",
441             DeprecationWarning,
442             stacklevel=2,
443         )
444 
445         if self._json_decoder is None:
446             from . import json
447 
448             return json.JSONDecoder
449 
450         return self._json_decoder
451 
452     @json_decoder.setter
453     def json_decoder(self, value: t.Type[json.JSONDecoder]) -> None:
454         import warnings
455 
456         warnings.warn(
457             "'app.json_decoder' is deprecated and will be removed in Flask 2.3."
458             " Customize 'app.json_provider_class' or 'app.json' instead.",
459             DeprecationWarning,
460             stacklevel=2,
461         )
462         self._json_decoder = value
463 
464     json_provider_class: t.Type[JSONProvider] = DefaultJSONProvider
465     """A subclass of :class:`~flask.json.provider.JSONProvider`. An
466     instance is created and assigned to :attr:`app.json` when creating
467     the app.
468 
469     The default, :class:`~flask.json.provider.DefaultJSONProvider`, uses
470     Python's built-in :mod:`json` library. A different provider can use
471     a different JSON library.
472 
473     .. versionadded:: 2.2
474     """
475 
476     #: Options that are passed to the Jinja environment in
477     #: :meth:`create_jinja_environment`. Changing these options after
478     #: the environment is created (accessing :attr:`jinja_env`) will
479     #: have no effect.
480     #:
481     #: .. versionchanged:: 1.1.0
482     #:     This is a ``dict`` instead of an ``ImmutableDict`` to allow
483     #:     easier configuration.
484     #:
485     jinja_options: dict = {}
486 
487     #: Default configuration parameters.
488     default_config = ImmutableDict(
489         {
490             "ENV": None,
491             "DEBUG": None,
492             "TESTING": False,
493             "PROPAGATE_EXCEPTIONS": None,
494             "SECRET_KEY": None,
495             "PERMANENT_SESSION_LIFETIME": timedelta(days=31),
496             "USE_X_SENDFILE": False,
497             "SERVER_NAME": None,
498             "APPLICATION_ROOT": "/",
499             "SESSION_COOKIE_NAME": "session",
500             "SESSION_COOKIE_DOMAIN": None,
501             "SESSION_COOKIE_PATH": None,
502             "SESSION_COOKIE_HTTPONLY": True,
503             "SESSION_COOKIE_SECURE": False,
504             "SESSION_COOKIE_SAMESITE": None,
505             "SESSION_REFRESH_EACH_REQUEST": True,
506             "MAX_CONTENT_LENGTH": None,
507             "SEND_FILE_MAX_AGE_DEFAULT": None,
508             "TRAP_BAD_REQUEST_ERRORS": None,
509             "TRAP_HTTP_EXCEPTIONS": False,
510             "EXPLAIN_TEMPLATE_LOADING": False,
511             "PREFERRED_URL_SCHEME": "http",
512             "JSON_AS_ASCII": None,
513             "JSON_SORT_KEYS": None,
514             "JSONIFY_PRETTYPRINT_REGULAR": None,
515             "JSONIFY_MIMETYPE": None,
516             "TEMPLATES_AUTO_RELOAD": None,
517             "MAX_COOKIE_SIZE": 4093,
518         }
519     )
520 
521     #: The rule object to use for URL rules created.  This is used by
522     #: :meth:`add_url_rule`.  Defaults to :class:`werkzeug.routing.Rule`.
523     #:
524     #: .. versionadded:: 0.7
525     url_rule_class = Rule
526 
527     #: The map object to use for storing the URL rules and routing
528     #: configuration parameters. Defaults to :class:`werkzeug.routing.Map`.
529     #:
530     #: .. versionadded:: 1.1.0
531     url_map_class = Map
532 
533     #: The :meth:`test_client` method creates an instance of this test
534     #: client class. Defaults to :class:`~flask.testing.FlaskClient`.
535     #:
536     #: .. versionadded:: 0.7
537     test_client_class: t.Optional[t.Type["FlaskClient"]] = None
538 
539     #: The :class:`~click.testing.CliRunner` subclass, by default
540     #: :class:`~flask.testing.FlaskCliRunner` that is used by
541     #: :meth:`test_cli_runner`. Its ``__init__`` method should take a
542     #: Flask app object as the first argument.
543     #:
544     #: .. versionadded:: 1.0
545     test_cli_runner_class: t.Optional[t.Type["FlaskCliRunner"]] = None
546 
547     #: the session interface to use.  By default an instance of
548     #: :class:`~flask.sessions.SecureCookieSessionInterface` is used here.
549     #:
550     #: .. versionadded:: 0.8
551     session_interface: SessionInterface = SecureCookieSessionInterface()
552 
553     def __init__(
554         self,
555         import_name: str,
556         static_url_path: t.Optional[str] = None,
557         static_folder: t.Optional[t.Union[str, os.PathLike]] = "static",
558         static_host: t.Optional[str] = None,
559         host_matching: bool = False,
560         subdomain_matching: bool = False,
561         template_folder: t.Optional[t.Union[str, os.PathLike]] = "templates",
562         instance_path: t.Optional[str] = None,
563         instance_relative_config: bool = False,
564         root_path: t.Optional[str] = None,
565     ):
566         super().__init__(
567             import_name=import_name,
568             static_folder=static_folder,
569             static_url_path=static_url_path,
570             template_folder=template_folder,
571             root_path=root_path,
572         )
573 
574         if instance_path is None:
575             instance_path = self.auto_find_instance_path()
576         elif not os.path.isabs(instance_path):
577             raise ValueError(
578                 "If an instance path is provided it must be absolute."
579                 " A relative path was given instead."
580             )
581 
582         #: Holds the path to the instance folder.
583         #:
584         #: .. versionadded:: 0.8
585         self.instance_path = instance_path
586 
587         #: The configuration dictionary as :class:`Config`.  This behaves
588         #: exactly like a regular dictionary but supports additional methods
589         #: to load a config from files.
590         self.config = self.make_config(instance_relative_config)
591 
592         #: An instance of :attr:`aborter_class` created by
593         #: :meth:`make_aborter`. This is called by :func:`flask.abort`
594         #: to raise HTTP errors, and can be called directly as well.
595         #:
596         #: .. versionadded:: 2.2
597         #:     Moved from ``flask.abort``, which calls this object.
598         self.aborter = self.make_aborter()
599 
600         self.json: JSONProvider = self.json_provider_class(self)
601         """Provides access to JSON methods. Functions in ``flask.json``
602         will call methods on this provider when the application context
603         is active. Used for handling JSON requests and responses.
604 
605         An instance of :attr:`json_provider_class`. Can be customized by
606         changing that attribute on a subclass, or by assigning to this
607         attribute afterwards.
608 
609         The default, :class:`~flask.json.provider.DefaultJSONProvider`,
610         uses Python's built-in :mod:`json` library. A different provider
611         can use a different JSON library.
612 
613         .. versionadded:: 2.2
614         """
615 
616         #: A list of functions that are called by
617         #: :meth:`handle_url_build_error` when :meth:`.url_for` raises a
618         #: :exc:`~werkzeug.routing.BuildError`. Each function is called
619         #: with ``error``, ``endpoint`` and ``values``. If a function
620         #: returns ``None`` or raises a ``BuildError``, it is skipped.
621         #: Otherwise, its return value is returned by ``url_for``.
622         #:
623         #: .. versionadded:: 0.9
624         self.url_build_error_handlers: t.List[
625             t.Callable[[Exception, str, t.Dict[str, t.Any]], str]
626         ] = []
627 
628         #: A list of functions that will be called at the beginning of the
629         #: first request to this instance. To register a function, use the
630         #: :meth:`before_first_request` decorator.
631         #:
632         #: .. deprecated:: 2.2
633         #:     Will be removed in Flask 2.3. Run setup code when
634         #:     creating the application instead.
635         #:
636         #: .. versionadded:: 0.8
637         self.before_first_request_funcs: t.List[ft.BeforeFirstRequestCallable] = []
638 
639         #: A list of functions that are called when the application context
640         #: is destroyed.  Since the application context is also torn down
641         #: if the request ends this is the place to store code that disconnects
642         #: from databases.
643         #:
644         #: .. versionadded:: 0.9
645         self.teardown_appcontext_funcs: t.List[ft.TeardownCallable] = []
646 
647         #: A list of shell context processor functions that should be run
648         #: when a shell context is created.
649         #:
650         #: .. versionadded:: 0.11
651         self.shell_context_processors: t.List[ft.ShellContextProcessorCallable] = []
652 
653         #: Maps registered blueprint names to blueprint objects. The
654         #: dict retains the order the blueprints were registered in.
655         #: Blueprints can be registered multiple times, this dict does
656         #: not track how often they were attached.
657         #:
658         #: .. versionadded:: 0.7
659         self.blueprints: t.Dict[str, "Blueprint"] = {}
660 
661         #: a place where extensions can store application specific state.  For
662         #: example this is where an extension could store database engines and
663         #: similar things.
664         #:
665         #: The key must match the name of the extension module. For example in
666         #: case of a "Flask-Foo" extension in `flask_foo`, the key would be
667         #: ``'foo'``.
668         #:
669         #: .. versionadded:: 0.7
670         self.extensions: dict = {}
671 
672         #: The :class:`~werkzeug.routing.Map` for this instance.  You can use
673         #: this to change the routing converters after the class was created
674         #: but before any routes are connected.  Example::
675         #:
676         #:    from werkzeug.routing import BaseConverter
677         #:
678         #:    class ListConverter(BaseConverter):
679         #:        def to_python(self, value):
680         #:            return value.split(',')
681         #:        def to_url(self, values):
682         #:            return ','.join(super(ListConverter, self).to_url(value)
683         #:                            for value in values)
684         #:
685         #:    app = Flask(__name__)
686         #:    app.url_map.converters['list'] = ListConverter
687         self.url_map = self.url_map_class()
688 
689         self.url_map.host_matching = host_matching
690         self.subdomain_matching = subdomain_matching
691 
692         # tracks internally if the application already handled at least one
693         # request.
694         self._got_first_request = False
695         self._before_request_lock = Lock()
696 
697         # Add a static route using the provided static_url_path, static_host,
698         # and static_folder if there is a configured static_folder.
699         # Note we do this without checking if static_folder exists.
700         # For one, it might be created while the server is running (e.g. during
701         # development). Also, Google App Engine stores static files somewhere
702         if self.has_static_folder:
703             assert (
704                 bool(static_host) == host_matching
705             ), "Invalid static_host/host_matching combination"
706             # Use a weakref to avoid creating a reference cycle between the app
707             # and the view function (see #3761).
708             self_ref = weakref.ref(self)
709             self.add_url_rule(
710                 f"{self.static_url_path}/<path:filename>",
711                 endpoint="static",
712                 host=static_host,
713                 view_func=lambda **kw: self_ref().send_static_file(**kw),  # type: ignore # noqa: B950
714             )
715 
716         # Set the name of the Click group in case someone wants to add
717         # the app's commands to another CLI tool.
718         self.cli.name = self.name
719 
720     def _check_setup_finished(self, f_name: str) -> None:
721         if self._got_first_request:
722             raise AssertionError(
723                 f"The setup method '{f_name}' can no longer be called"
724                 " on the application. It has already handled its first"
725                 " request, any changes will not be applied"
726                 " consistently.\n"
727                 "Make sure all imports, decorators, functions, etc."
728                 " needed to set up the application are done before"
729                 " running it."
730             )
731 
732     @locked_cached_property
733     def name(self) -> str:  # type: ignore
734         """The name of the application.  This is usually the import name
735         with the difference that it's guessed from the run file if the
736         import name is main.  This name is used as a display name when
737         Flask needs the name of the application.  It can be set and overridden
738         to change the value.
739 
740         .. versionadded:: 0.8
741         """
742         if self.import_name == "__main__":
743             fn = getattr(sys.modules["__main__"], "__file__", None)
744             if fn is None:
745                 return "__main__"
746             return os.path.splitext(os.path.basename(fn))[0]
747         return self.import_name
748 
749     @property
750     def propagate_exceptions(self) -> bool:
751         """Returns the value of the ``PROPAGATE_EXCEPTIONS`` configuration
752         value in case it's set, otherwise a sensible default is returned.
753 
754         .. deprecated:: 2.2
755             Will be removed in Flask 2.3.
756 
757         .. versionadded:: 0.7
758         """
759         import warnings
760 
761         warnings.warn(
762             "'propagate_exceptions' is deprecated and will be removed in Flask 2.3.",
763             DeprecationWarning,
764             stacklevel=2,
765         )
766         rv = self.config["PROPAGATE_EXCEPTIONS"]
767         if rv is not None:
768             return rv
769         return self.testing or self.debug
770 
771     @locked_cached_property
772     def logger(self) -> logging.Logger:
773         """A standard Python :class:`~logging.Logger` for the app, with
774         the same name as :attr:`name`.
775 
776         In debug mode, the logger's :attr:`~logging.Logger.level` will
777         be set to :data:`~logging.DEBUG`.
778 
779         If there are no handlers configured, a default handler will be
780         added. See :doc:`/logging` for more information.
781 
782         .. versionchanged:: 1.1.0
783             The logger takes the same name as :attr:`name` rather than
784             hard-coding ``"flask.app"``.
785 
786         .. versionchanged:: 1.0.0
787             Behavior was simplified. The logger is always named
788             ``"flask.app"``. The level is only set during configuration,
789             it doesn't check ``app.debug`` each time. Only one format is
790             used, not different ones depending on ``app.debug``. No
791             handlers are removed, and a handler is only added if no
792             handlers are already configured.
793 
794         .. versionadded:: 0.3
795         """
796         return create_logger(self)
797 
798     @locked_cached_property
799     def jinja_env(self) -> Environment:
800         """The Jinja environment used to load templates.
801 
802         The environment is created the first time this property is
803         accessed. Changing :attr:`jinja_options` after that will have no
804         effect.
805         """
806         return self.create_jinja_environment()
807 
808     @property
809     def got_first_request(self) -> bool:
810         """This attribute is set to ``True`` if the application started
811         handling the first request.
812 
813         .. versionadded:: 0.8
814         """
815         return self._got_first_request
816 
817     def make_config(self, instance_relative: bool = False) -> Config:
818         """Used to create the config attribute by the Flask constructor.
819         The `instance_relative` parameter is passed in from the constructor
820         of Flask (there named `instance_relative_config`) and indicates if
821         the config should be relative to the instance path or the root path
822         of the application.
823 
824         .. versionadded:: 0.8
825         """
826         root_path = self.root_path
827         if instance_relative:
828             root_path = self.instance_path
829         defaults = dict(self.default_config)
830         defaults["ENV"] = os.environ.get("FLASK_ENV") or "production"
831         defaults["DEBUG"] = get_debug_flag()
832         return self.config_class(root_path, defaults)
833 
834     def make_aborter(self) -> Aborter:
835         """Create the object to assign to :attr:`aborter`. That object
836         is called by :func:`flask.abort` to raise HTTP errors, and can
837         be called directly as well.
838 
839         By default, this creates an instance of :attr:`aborter_class`,
840         which defaults to :class:`werkzeug.exceptions.Aborter`.
841 
842         .. versionadded:: 2.2
843         """
844         return self.aborter_class()
845 
846     def auto_find_instance_path(self) -> str:
847         """Tries to locate the instance path if it was not provided to the
848         constructor of the application class.  It will basically calculate
849         the path to a folder named ``instance`` next to your main file or
850         the package.
851 
852         .. versionadded:: 0.8
853         """
854         prefix, package_path = find_package(self.import_name)
855         if prefix is None:
856             return os.path.join(package_path, "instance")
857         return os.path.join(prefix, "var", f"{self.name}-instance")
858 
859     def open_instance_resource(self, resource: str, mode: str = "rb") -> t.IO[t.AnyStr]:
860         """Opens a resource from the application's instance folder
861         (:attr:`instance_path`).  Otherwise works like
862         :meth:`open_resource`.  Instance resources can also be opened for
863         writing.
864 
865         :param resource: the name of the resource.  To access resources within
866                          subfolders use forward slashes as separator.
867         :param mode: resource file opening mode, default is 'rb'.
868         """
869         return open(os.path.join(self.instance_path, resource), mode)
870 
871     @property
872     def templates_auto_reload(self) -> bool:
873         """Reload templates when they are changed. Used by
874         :meth:`create_jinja_environment`. It is enabled by default in debug mode.
875 
876         .. deprecated:: 2.2
877             Will be removed in Flask 2.3. Use ``app.config["TEMPLATES_AUTO_RELOAD"]``
878             instead.
879 
880         .. versionadded:: 1.0
881             This property was added but the underlying config and behavior
882             already existed.
883         """
884         import warnings
885 
886         warnings.warn(
887             "'templates_auto_reload' is deprecated and will be removed in Flask 2.3."
888             " Use 'TEMPLATES_AUTO_RELOAD' in 'app.config' instead.",
889             DeprecationWarning,
890             stacklevel=2,
891         )
892         rv = self.config["TEMPLATES_AUTO_RELOAD"]
893         return rv if rv is not None else self.debug
894 
895     @templates_auto_reload.setter
896     def templates_auto_reload(self, value: bool) -> None:
897         import warnings
898 
899         warnings.warn(
900             "'templates_auto_reload' is deprecated and will be removed in Flask 2.3."
901             " Use 'TEMPLATES_AUTO_RELOAD' in 'app.config' instead.",
902             DeprecationWarning,
903             stacklevel=2,
904         )
905         self.config["TEMPLATES_AUTO_RELOAD"] = value
906 
907     def create_jinja_environment(self) -> Environment:
908         """Create the Jinja environment based on :attr:`jinja_options`
909         and the various Jinja-related methods of the app. Changing
910         :attr:`jinja_options` after this will have no effect. Also adds
911         Flask-related globals and filters to the environment.
912 
913         .. versionchanged:: 0.11
914            ``Environment.auto_reload`` set in accordance with
915            ``TEMPLATES_AUTO_RELOAD`` configuration option.
916 
917         .. versionadded:: 0.5
918         """
919         options = dict(self.jinja_options)
920 
921         if "autoescape" not in options:
922             options["autoescape"] = self.select_jinja_autoescape
923 
924         if "auto_reload" not in options:
925             auto_reload = self.config["TEMPLATES_AUTO_RELOAD"]
926 
927             if auto_reload is None:
928                 auto_reload = self.debug
929 
930             options["auto_reload"] = auto_reload
931 
932         rv = self.jinja_environment(self, **options)
933         rv.globals.update(
934             url_for=self.url_for,
935             get_flashed_messages=get_flashed_messages,
936             config=self.config,
937             # request, session and g are normally added with the
938             # context processor for efficiency reasons but for imported
939             # templates we also want the proxies in there.
940             request=request,
941             session=session,
942             g=g,
943         )
944         rv.policies["json.dumps_function"] = self.json.dumps
945         return rv
946 
947     def create_global_jinja_loader(self) -> DispatchingJinjaLoader:
948         """Creates the loader for the Jinja2 environment.  Can be used to
949         override just the loader and keeping the rest unchanged.  It's
950         discouraged to override this function.  Instead one should override
951         the :meth:`jinja_loader` function instead.
952 
953         The global loader dispatches between the loaders of the application
954         and the individual blueprints.
955 
956         .. versionadded:: 0.7
957         """
958         return DispatchingJinjaLoader(self)
959 
960     def select_jinja_autoescape(self, filename: str) -> bool:
961         """Returns ``True`` if autoescaping should be active for the given
962         template name. If no template name is given, returns `True`.
963 
964         .. versionchanged:: 2.2
965             Autoescaping is now enabled by default for ``.svg`` files.
966 
967         .. versionadded:: 0.5
968         """
969         if filename is None:
970             return True
971         return filename.endswith((".html", ".htm", ".xml", ".xhtml", ".svg"))
972 
973     def update_template_context(self, context: dict) -> None:
974         """Update the template context with some commonly used variables.
975         This injects request, session, config and g into the template
976         context as well as everything template context processors want
977         to inject.  Note that the as of Flask 0.6, the original values
978         in the context will not be overridden if a context processor
979         decides to return a value with the same key.
980 
981         :param context: the context as a dictionary that is updated in place
982                         to add extra variables.
983         """
984         names: t.Iterable[t.Optional[str]] = (None,)
985 
986         # A template may be rendered outside a request context.
987         if request:
988             names = chain(names, reversed(request.blueprints))
989 
990         # The values passed to render_template take precedence. Keep a
991         # copy to re-apply after all context functions.
992         orig_ctx = context.copy()
993 
994         for name in names:
995             if name in self.template_context_processors:
996                 for func in self.template_context_processors[name]:
997                     context.update(func())
998 
999         context.update(orig_ctx)
1000 
1001     def make_shell_context(self) -> dict:
1002         """Returns the shell context for an interactive shell for this
1003         application.  This runs all the registered shell context
1004         processors.
1005 
1006         .. versionadded:: 0.11
1007         """
1008         rv = {"app": self, "g": g}
1009         for processor in self.shell_context_processors:
1010             rv.update(processor())
1011         return rv
1012 
1013     @property
1014     def env(self) -> str:
1015         """What environment the app is running in. This maps to the :data:`ENV` config
1016         key.
1017 
1018         **Do not enable development when deploying in production.**
1019 
1020         Default: ``'production'``
1021 
1022         .. deprecated:: 2.2
1023             Will be removed in Flask 2.3.
1024         """
1025         import warnings
1026 
1027         warnings.warn(
1028             "'app.env' is deprecated and will be removed in Flask 2.3."
1029             " Use 'app.debug' instead.",
1030             DeprecationWarning,
1031             stacklevel=2,
1032         )
1033         return self.config["ENV"]
1034 
1035     @env.setter
1036     def env(self, value: str) -> None:
1037         import warnings
1038 
1039         warnings.warn(
1040             "'app.env' is deprecated and will be removed in Flask 2.3."
1041             " Use 'app.debug' instead.",
1042             DeprecationWarning,
1043             stacklevel=2,
1044         )
1045         self.config["ENV"] = value
1046 
1047     @property
1048     def debug(self) -> bool:
1049         """Whether debug mode is enabled. When using ``flask run`` to start the
1050         development server, an interactive debugger will be shown for unhandled
1051         exceptions, and the server will be reloaded when code changes. This maps to the
1052         :data:`DEBUG` config key. It may not behave as expected if set late.
1053 
1054         **Do not enable debug mode when deploying in production.**
1055 
1056         Default: ``False``
1057         """
1058         return self.config["DEBUG"]
1059 
1060     @debug.setter
1061     def debug(self, value: bool) -> None:
1062         self.config["DEBUG"] = value
1063 
1064         if self.config["TEMPLATES_AUTO_RELOAD"] is None:
1065             self.jinja_env.auto_reload = value
1066 
1067     def run(
1068         self,
1069         host: t.Optional[str] = None,
1070         port: t.Optional[int] = None,
1071         debug: t.Optional[bool] = None,
1072         load_dotenv: bool = True,
1073         **options: t.Any,
1074     ) -> None:
1075         """Runs the application on a local development server.
1076 
1077         Do not use ``run()`` in a production setting. It is not intended to
1078         meet security and performance requirements for a production server.
1079         Instead, see :doc:`/deploying/index` for WSGI server recommendations.
1080 
1081         If the :attr:`debug` flag is set the server will automatically reload
1082         for code changes and show a debugger in case an exception happened.
1083 
1084         If you want to run the application in debug mode, but disable the
1085         code execution on the interactive debugger, you can pass
1086         ``use_evalex=False`` as parameter.  This will keep the debugger's
1087         traceback screen active, but disable code execution.
1088 
1089         It is not recommended to use this function for development with
1090         automatic reloading as this is badly supported.  Instead you should
1091         be using the :command:`flask` command line script's ``run`` support.
1092 
1093         .. admonition:: Keep in Mind
1094 
1095            Flask will suppress any server error with a generic error page
1096            unless it is in debug mode.  As such to enable just the
1097            interactive debugger without the code reloading, you have to
1098            invoke :meth:`run` with ``debug=True`` and ``use_reloader=False``.
1099            Setting ``use_debugger`` to ``True`` without being in debug mode
1100            won't catch any exceptions because there won't be any to
1101            catch.
1102 
1103         :param host: the hostname to listen on. Set this to ``'0.0.0.0'`` to
1104             have the server available externally as well. Defaults to
1105             ``'127.0.0.1'`` or the host in the ``SERVER_NAME`` config variable
1106             if present.
1107         :param port: the port of the webserver. Defaults to ``5000`` or the
1108             port defined in the ``SERVER_NAME`` config variable if present.
1109         :param debug: if given, enable or disable debug mode. See
1110             :attr:`debug`.
1111         :param load_dotenv: Load the nearest :file:`.env` and :file:`.flaskenv`
1112             files to set environment variables. Will also change the working
1113             directory to the directory containing the first file found.
1114         :param options: the options to be forwarded to the underlying Werkzeug
1115             server. See :func:`werkzeug.serving.run_simple` for more
1116             information.
1117 
1118         .. versionchanged:: 1.0
1119             If installed, python-dotenv will be used to load environment
1120             variables from :file:`.env` and :file:`.flaskenv` files.
1121 
1122             The :envvar:`FLASK_DEBUG` environment variable will override :attr:`debug`.
1123 
1124             Threaded mode is enabled by default.
1125 
1126         .. versionchanged:: 0.10
1127             The default port is now picked from the ``SERVER_NAME``
1128             variable.
1129         """
1130         # Ignore this call so that it doesn't start another server if
1131         # the 'flask run' command is used.
1132         if os.environ.get("FLASK_RUN_FROM_CLI") == "true":
1133             if not is_running_from_reloader():
1134                 click.secho(
1135                     " * Ignoring a call to 'app.run()' that would block"
1136                     " the current 'flask' CLI command.\n"
1137                     "   Only call 'app.run()' in an 'if __name__ =="
1138                     ' "__main__"\' guard.',
1139                     fg="red",
1140                 )
1141 
1142             return
1143 
1144         if get_load_dotenv(load_dotenv):
1145             cli.load_dotenv()
1146 
1147             # if set, let env vars override previous values
1148             if "FLASK_ENV" in os.environ:
1149                 print(
1150                     "'FLASK_ENV' is deprecated and will not be used in"
1151                     " Flask 2.3. Use 'FLASK_DEBUG' instead.",
1152                     file=sys.stderr,
1153                 )
1154                 self.config["ENV"] = os.environ.get("FLASK_ENV") or "production"
1155                 self.debug = get_debug_flag()
1156             elif "FLASK_DEBUG" in os.environ:
1157                 self.debug = get_debug_flag()
1158 
1159         # debug passed to method overrides all other sources
1160         if debug is not None:
1161             self.debug = bool(debug)
1162 
1163         server_name = self.config.get("SERVER_NAME")
1164         sn_host = sn_port = None
1165 
1166         if server_name:
1167             sn_host, _, sn_port = server_name.partition(":")
1168 
1169         if not host:
1170             if sn_host:
1171                 host = sn_host
1172             else:
1173                 host = "127.0.0.1"
1174 
1175         if port or port == 0:
1176             port = int(port)
1177         elif sn_port:
1178             port = int(sn_port)
1179         else:
1180             port = 5000
1181 
1182         options.setdefault("use_reloader", self.debug)
1183         options.setdefault("use_debugger", self.debug)
1184         options.setdefault("threaded", True)
1185 
1186         cli.show_server_banner(self.debug, self.name)
1187 
1188         from werkzeug.serving import run_simple
1189 
1190         try:
1191             run_simple(t.cast(str, host), port, self, **options)
1192         finally:
1193             # reset the first request information if the development server
1194             # reset normally.  This makes it possible to restart the server
1195             # without reloader and that stuff from an interactive shell.
1196             self._got_first_request = False
1197 
1198     def test_client(self, use_cookies: bool = True, **kwargs: t.Any) -> "FlaskClient":
1199         """Creates a test client for this application.  For information
1200         about unit testing head over to :doc:`/testing`.
1201 
1202         Note that if you are testing for assertions or exceptions in your
1203         application code, you must set ``app.testing = True`` in order for the
1204         exceptions to propagate to the test client.  Otherwise, the exception
1205         will be handled by the application (not visible to the test client) and
1206         the only indication of an AssertionError or other exception will be a
1207         500 status code response to the test client.  See the :attr:`testing`
1208         attribute.  For example::
1209 
1210             app.testing = True
1211             client = app.test_client()
1212 
1213         The test client can be used in a ``with`` block to defer the closing down
1214         of the context until the end of the ``with`` block.  This is useful if
1215         you want to access the context locals for testing::
1216 
1217             with app.test_client() as c:
1218                 rv = c.get('/?vodka=42')
1219                 assert request.args['vodka'] == '42'
1220 
1221         Additionally, you may pass optional keyword arguments that will then
1222         be passed to the application's :attr:`test_client_class` constructor.
1223         For example::
1224 
1225             from flask.testing import FlaskClient
1226 
1227             class CustomClient(FlaskClient):
1228                 def __init__(self, *args, **kwargs):
1229                     self._authentication = kwargs.pop("authentication")
1230                     super(CustomClient,self).__init__( *args, **kwargs)
1231 
1232             app.test_client_class = CustomClient
1233             client = app.test_client(authentication='Basic ....')
1234 
1235         See :class:`~flask.testing.FlaskClient` for more information.
1236 
1237         .. versionchanged:: 0.4
1238            added support for ``with`` block usage for the client.
1239 
1240         .. versionadded:: 0.7
1241            The `use_cookies` parameter was added as well as the ability
1242            to override the client to be used by setting the
1243            :attr:`test_client_class` attribute.
1244 
1245         .. versionchanged:: 0.11
1246            Added `**kwargs` to support passing additional keyword arguments to
1247            the constructor of :attr:`test_client_class`.
1248         """
1249         cls = self.test_client_class
1250         if cls is None:
1251             from .testing import FlaskClient as cls  # type: ignore
1252         return cls(  # type: ignore
1253             self, self.response_class, use_cookies=use_cookies, **kwargs
1254         )
1255 
1256     def test_cli_runner(self, **kwargs: t.Any) -> "FlaskCliRunner":
1257         """Create a CLI runner for testing CLI commands.
1258         See :ref:`testing-cli`.
1259 
1260         Returns an instance of :attr:`test_cli_runner_class`, by default
1261         :class:`~flask.testing.FlaskCliRunner`. The Flask app object is
1262         passed as the first argument.
1263 
1264         .. versionadded:: 1.0
1265         """
1266         cls = self.test_cli_runner_class
1267 
1268         if cls is None:
1269             from .testing import FlaskCliRunner as cls  # type: ignore
1270 
1271         return cls(self, **kwargs)  # type: ignore
1272 
1273     @setupmethod
1274     def register_blueprint(self, blueprint: "Blueprint", **options: t.Any) -> None:
1275         """Register a :class:`~flask.Blueprint` on the application. Keyword
1276         arguments passed to this method will override the defaults set on the
1277         blueprint.
1278 
1279         Calls the blueprint's :meth:`~flask.Blueprint.register` method after
1280         recording the blueprint in the application's :attr:`blueprints`.
1281 
1282         :param blueprint: The blueprint to register.
1283         :param url_prefix: Blueprint routes will be prefixed with this.
1284         :param subdomain: Blueprint routes will match on this subdomain.
1285         :param url_defaults: Blueprint routes will use these default values for
1286             view arguments.
1287         :param options: Additional keyword arguments are passed to
1288             :class:`~flask.blueprints.BlueprintSetupState`. They can be
1289             accessed in :meth:`~flask.Blueprint.record` callbacks.
1290 
1291         .. versionchanged:: 2.0.1
1292             The ``name`` option can be used to change the (pre-dotted)
1293             name the blueprint is registered with. This allows the same
1294             blueprint to be registered multiple times with unique names
1295             for ``url_for``.
1296 
1297         .. versionadded:: 0.7
1298         """
1299         blueprint.register(self, options)
1300 
1301     def iter_blueprints(self) -> t.ValuesView["Blueprint"]:
1302         """Iterates over all blueprints by the order they were registered.
1303 
1304         .. versionadded:: 0.11
1305         """
1306         return self.blueprints.values()
1307 
1308     @setupmethod
1309     def add_url_rule(
1310         self,
1311         rule: str,
1312         endpoint: t.Optional[str] = None,
1313         view_func: t.Optional[ft.RouteCallable] = None,
1314         provide_automatic_options: t.Optional[bool] = None,
1315         **options: t.Any,
1316     ) -> None:
1317         if endpoint is None:
1318             endpoint = _endpoint_from_view_func(view_func)  # type: ignore
1319         options["endpoint"] = endpoint
1320         methods = options.pop("methods", None)
1321 
1322         # if the methods are not given and the view_func object knows its
1323         # methods we can use that instead.  If neither exists, we go with
1324         # a tuple of only ``GET`` as default.
1325         if methods is None:
1326             methods = getattr(view_func, "methods", None) or ("GET",)
1327         if isinstance(methods, str):
1328             raise TypeError(
1329                 "Allowed methods must be a list of strings, for"
1330                 ' example: @app.route(..., methods=["POST"])'
1331             )
1332         methods = {item.upper() for item in methods}
1333 
1334         # Methods that should always be added
1335         required_methods = set(getattr(view_func, "required_methods", ()))
1336 
1337         # starting with Flask 0.8 the view_func object can disable and
1338         # force-enable the automatic options handling.
1339         if provide_automatic_options is None:
1340             provide_automatic_options = getattr(
1341                 view_func, "provide_automatic_options", None
1342             )
1343 
1344         if provide_automatic_options is None:
1345             if "OPTIONS" not in methods:
1346                 provide_automatic_options = True
1347                 required_methods.add("OPTIONS")
1348             else:
1349                 provide_automatic_options = False
1350 
1351         # Add the required methods now.
1352         methods |= required_methods
1353 
1354         rule = self.url_rule_class(rule, methods=methods, **options)
1355         rule.provide_automatic_options = provide_automatic_options  # type: ignore
1356 
1357         self.url_map.add(rule)
1358         if view_func is not None:
1359             old_func = self.view_functions.get(endpoint)
1360             if old_func is not None and old_func != view_func:
1361                 raise AssertionError(
1362                     "View function mapping is overwriting an existing"
1363                     f" endpoint function: {endpoint}"
1364                 )
1365             self.view_functions[endpoint] = view_func
1366 
1367     @setupmethod
1368     def template_filter(
1369         self, name: t.Optional[str] = None
1370     ) -> t.Callable[[T_template_filter], T_template_filter]:
1371         """A decorator that is used to register custom template filter.
1372         You can specify a name for the filter, otherwise the function
1373         name will be used. Example::
1374 
1375           @app.template_filter()
1376           def reverse(s):
1377               return s[::-1]
1378 
1379         :param name: the optional name of the filter, otherwise the
1380                      function name will be used.
1381         """
1382 
1383         def decorator(f: T_template_filter) -> T_template_filter:
1384             self.add_template_filter(f, name=name)
1385             return f
1386 
1387         return decorator
1388 
1389     @setupmethod
1390     def add_template_filter(
1391         self, f: ft.TemplateFilterCallable, name: t.Optional[str] = None
1392     ) -> None:
1393         """Register a custom template filter.  Works exactly like the
1394         :meth:`template_filter` decorator.
1395 
1396         :param name: the optional name of the filter, otherwise the
1397                      function name will be used.
1398         """
1399         self.jinja_env.filters[name or f.__name__] = f
1400 
1401     @setupmethod
1402     def template_test(
1403         self, name: t.Optional[str] = None
1404     ) -> t.Callable[[T_template_test], T_template_test]:
1405         """A decorator that is used to register custom template test.
1406         You can specify a name for the test, otherwise the function
1407         name will be used. Example::
1408 
1409           @app.template_test()
1410           def is_prime(n):
1411               if n == 2:
1412                   return True
1413               for i in range(2, int(math.ceil(math.sqrt(n))) + 1):
1414                   if n % i == 0:
1415                       return False
1416               return True
1417 
1418         .. versionadded:: 0.10
1419 
1420         :param name: the optional name of the test, otherwise the
1421                      function name will be used.
1422         """
1423 
1424         def decorator(f: T_template_test) -> T_template_test:
1425             self.add_template_test(f, name=name)
1426             return f
1427 
1428         return decorator
1429 
1430     @setupmethod
1431     def add_template_test(
1432         self, f: ft.TemplateTestCallable, name: t.Optional[str] = None
1433     ) -> None:
1434         """Register a custom template test.  Works exactly like the
1435         :meth:`template_test` decorator.
1436 
1437         .. versionadded:: 0.10
1438 
1439         :param name: the optional name of the test, otherwise the
1440                      function name will be used.
1441         """
1442         self.jinja_env.tests[name or f.__name__] = f
1443 
1444     @setupmethod
1445     def template_global(
1446         self, name: t.Optional[str] = None
1447     ) -> t.Callable[[T_template_global], T_template_global]:
1448         """A decorator that is used to register a custom template global function.
1449         You can specify a name for the global function, otherwise the function
1450         name will be used. Example::
1451 
1452             @app.template_global()
1453             def double(n):
1454                 return 2 * n
1455 
1456         .. versionadded:: 0.10
1457 
1458         :param name: the optional name of the global function, otherwise the
1459                      function name will be used.
1460         """
1461 
1462         def decorator(f: T_template_global) -> T_template_global:
1463             self.add_template_global(f, name=name)
1464             return f
1465 
1466         return decorator
1467 
1468     @setupmethod
1469     def add_template_global(
1470         self, f: ft.TemplateGlobalCallable, name: t.Optional[str] = None
1471     ) -> None:
1472         """Register a custom template global function. Works exactly like the
1473         :meth:`template_global` decorator.
1474 
1475         .. versionadded:: 0.10
1476 
1477         :param name: the optional name of the global function, otherwise the
1478                      function name will be used.
1479         """
1480         self.jinja_env.globals[name or f.__name__] = f
1481 
1482     @setupmethod
1483     def before_first_request(self, f: T_before_first_request) -> T_before_first_request:
1484         """Registers a function to be run before the first request to this
1485         instance of the application.
1486 
1487         The function will be called without any arguments and its return
1488         value is ignored.
1489 
1490         .. deprecated:: 2.2
1491             Will be removed in Flask 2.3. Run setup code when creating
1492             the application instead.
1493 
1494         .. versionadded:: 0.8
1495         """
1496         import warnings
1497 
1498         warnings.warn(
1499             "'before_first_request' is deprecated and will be removed"
1500             " in Flask 2.3. Run setup code while creating the"
1501             " application instead.",
1502             DeprecationWarning,
1503             stacklevel=2,
1504         )
1505         self.before_first_request_funcs.append(f)
1506         return f
1507 
1508     @setupmethod
1509     def teardown_appcontext(self, f: T_teardown) -> T_teardown:
1510         """Registers a function to be called when the application
1511         context is popped. The application context is typically popped
1512         after the request context for each request, at the end of CLI
1513         commands, or after a manually pushed context ends.
1514 
1515         .. code-block:: python
1516 
1517             with app.app_context():
1518                 ...
1519 
1520         When the ``with`` block exits (or ``ctx.pop()`` is called), the
1521         teardown functions are called just before the app context is
1522         made inactive. Since a request context typically also manages an
1523         application context it would also be called when you pop a
1524         request context.
1525 
1526         When a teardown function was called because of an unhandled
1527         exception it will be passed an error object. If an
1528         :meth:`errorhandler` is registered, it will handle the exception
1529         and the teardown will not receive it.
1530 
1531         Teardown functions must avoid raising exceptions. If they
1532         execute code that might fail they must surround that code with a
1533         ``try``/``except`` block and log any errors.
1534 
1535         The return values of teardown functions are ignored.
1536 
1537         .. versionadded:: 0.9
1538         """
1539         self.teardown_appcontext_funcs.append(f)
1540         return f
1541 
1542     @setupmethod
1543     def shell_context_processor(
1544         self, f: T_shell_context_processor
1545     ) -> T_shell_context_processor:
1546         """Registers a shell context processor function.
1547 
1548         .. versionadded:: 0.11
1549         """
1550         self.shell_context_processors.append(f)
1551         return f
1552 
1553     def _find_error_handler(self, e: Exception) -> t.Optional[ft.ErrorHandlerCallable]:
1554         """Return a registered error handler for an exception in this order:
1555         blueprint handler for a specific code, app handler for a specific code,
1556         blueprint handler for an exception class, app handler for an exception
1557         class, or ``None`` if a suitable handler is not found.
1558         """
1559         exc_class, code = self._get_exc_class_and_code(type(e))
1560         names = (*request.blueprints, None)
1561 
1562         for c in (code, None) if code is not None else (None,):
1563             for name in names:
1564                 handler_map = self.error_handler_spec[name][c]
1565 
1566                 if not handler_map:
1567                     continue
1568 
1569                 for cls in exc_class.__mro__:
1570                     handler = handler_map.get(cls)
1571 
1572                     if handler is not None:
1573                         return handler
1574         return None
1575 
1576     def handle_http_exception(
1577         self, e: HTTPException
1578     ) -> t.Union[HTTPException, ft.ResponseReturnValue]:
1579         """Handles an HTTP exception.  By default this will invoke the
1580         registered error handlers and fall back to returning the
1581         exception as response.
1582 
1583         .. versionchanged:: 1.0.3
1584             ``RoutingException``, used internally for actions such as
1585              slash redirects during routing, is not passed to error
1586              handlers.
1587 
1588         .. versionchanged:: 1.0
1589             Exceptions are looked up by code *and* by MRO, so
1590             ``HTTPException`` subclasses can be handled with a catch-all
1591             handler for the base ``HTTPException``.
1592 
1593         .. versionadded:: 0.3
1594         """
1595         # Proxy exceptions don't have error codes.  We want to always return
1596         # those unchanged as errors
1597         if e.code is None:
1598             return e
1599 
1600         # RoutingExceptions are used internally to trigger routing
1601         # actions, such as slash redirects raising RequestRedirect. They
1602         # are not raised or handled in user code.
1603         if isinstance(e, RoutingException):
1604             return e
1605 
1606         handler = self._find_error_handler(e)
1607         if handler is None:
1608             return e
1609         return self.ensure_sync(handler)(e)
1610 
1611     def trap_http_exception(self, e: Exception) -> bool:
1612         """Checks if an HTTP exception should be trapped or not.  By default
1613         this will return ``False`` for all exceptions except for a bad request
1614         key error if ``TRAP_BAD_REQUEST_ERRORS`` is set to ``True``.  It
1615         also returns ``True`` if ``TRAP_HTTP_EXCEPTIONS`` is set to ``True``.
1616 
1617         This is called for all HTTP exceptions raised by a view function.
1618         If it returns ``True`` for any exception the error handler for this
1619         exception is not called and it shows up as regular exception in the
1620         traceback.  This is helpful for debugging implicitly raised HTTP
1621         exceptions.
1622 
1623         .. versionchanged:: 1.0
1624             Bad request errors are not trapped by default in debug mode.
1625 
1626         .. versionadded:: 0.8
1627         """
1628         if self.config["TRAP_HTTP_EXCEPTIONS"]:
1629             return True
1630 
1631         trap_bad_request = self.config["TRAP_BAD_REQUEST_ERRORS"]
1632 
1633         # if unset, trap key errors in debug mode
1634         if (
1635             trap_bad_request is None
1636             and self.debug
1637             and isinstance(e, BadRequestKeyError)
1638         ):
1639             return True
1640 
1641         if trap_bad_request:
1642             return isinstance(e, BadRequest)
1643 
1644         return False
1645 
1646     def handle_user_exception(
1647         self, e: Exception
1648     ) -> t.Union[HTTPException, ft.ResponseReturnValue]:
1649         """This method is called whenever an exception occurs that
1650         should be handled. A special case is :class:`~werkzeug
1651         .exceptions.HTTPException` which is forwarded to the
1652         :meth:`handle_http_exception` method. This function will either
1653         return a response value or reraise the exception with the same
1654         traceback.
1655 
1656         .. versionchanged:: 1.0
1657             Key errors raised from request data like ``form`` show the
1658             bad key in debug mode rather than a generic bad request
1659             message.
1660 
1661         .. versionadded:: 0.7
1662         """
1663         if isinstance(e, BadRequestKeyError) and (
1664             self.debug or self.config["TRAP_BAD_REQUEST_ERRORS"]
1665         ):
1666             e.show_exception = True
1667 
1668         if isinstance(e, HTTPException) and not self.trap_http_exception(e):
1669             return self.handle_http_exception(e)
1670 
1671         handler = self._find_error_handler(e)
1672 
1673         if handler is None:
1674             raise
1675 
1676         return self.ensure_sync(handler)(e)
1677 
1678     def handle_exception(self, e: Exception) -> Response:
1679         """Handle an exception that did not have an error handler
1680         associated with it, or that was raised from an error handler.
1681         This always causes a 500 ``InternalServerError``.
1682 
1683         Always sends the :data:`got_request_exception` signal.
1684 
1685         If :attr:`propagate_exceptions` is ``True``, such as in debug
1686         mode, the error will be re-raised so that the debugger can
1687         display it. Otherwise, the original exception is logged, and
1688         an :exc:`~werkzeug.exceptions.InternalServerError` is returned.
1689 
1690         If an error handler is registered for ``InternalServerError`` or
1691         ``500``, it will be used. For consistency, the handler will
1692         always receive the ``InternalServerError``. The original
1693         unhandled exception is available as ``e.original_exception``.
1694 
1695         .. versionchanged:: 1.1.0
1696             Always passes the ``InternalServerError`` instance to the
1697             handler, setting ``original_exception`` to the unhandled
1698             error.
1699 
1700         .. versionchanged:: 1.1.0
1701             ``after_request`` functions and other finalization is done
1702             even for the default 500 response when there is no handler.
1703 
1704         .. versionadded:: 0.3
1705         """
1706         exc_info = sys.exc_info()
1707         got_request_exception.send(self, exception=e)
1708         propagate = self.config["PROPAGATE_EXCEPTIONS"]
1709 
1710         if propagate is None:
1711             propagate = self.testing or self.debug
1712 
1713         if propagate:
1714             # Re-raise if called with an active exception, otherwise
1715             # raise the passed in exception.
1716             if exc_info[1] is e:
1717                 raise
1718 
1719             raise e
1720 
1721         self.log_exception(exc_info)
1722         server_error: t.Union[InternalServerError, ft.ResponseReturnValue]
1723         server_error = InternalServerError(original_exception=e)
1724         handler = self._find_error_handler(server_error)
1725 
1726         if handler is not None:
1727             server_error = self.ensure_sync(handler)(server_error)
1728 
1729         return self.finalize_request(server_error, from_error_handler=True)
1730 
1731     def log_exception(
1732         self,
1733         exc_info: t.Union[
1734             t.Tuple[type, BaseException, TracebackType], t.Tuple[None, None, None]
1735         ],
1736     ) -> None:
1737         """Logs an exception.  This is called by :meth:`handle_exception`
1738         if debugging is disabled and right before the handler is called.
1739         The default implementation logs the exception as error on the
1740         :attr:`logger`.
1741 
1742         .. versionadded:: 0.8
1743         """
1744         self.logger.error(
1745             f"Exception on {request.path} [{request.method}]", exc_info=exc_info
1746         )
1747 
1748     def raise_routing_exception(self, request: Request) -> "te.NoReturn":
1749         """Intercept routing exceptions and possibly do something else.
1750 
1751         In debug mode, intercept a routing redirect and replace it with
1752         an error if the body will be discarded.
1753 
1754         With modern Werkzeug this shouldn't occur, since it now uses a
1755         308 status which tells the browser to resend the method and
1756         body.
1757 
1758         .. versionchanged:: 2.1
1759             Don't intercept 307 and 308 redirects.
1760 
1761         :meta private:
1762         :internal:
1763         """
1764         if (
1765             not self.debug
1766             or not isinstance(request.routing_exception, RequestRedirect)
1767             or request.routing_exception.code in {307, 308}
1768             or request.method in {"GET", "HEAD", "OPTIONS"}
1769         ):
1770             raise request.routing_exception  # type: ignore
1771 
1772         from .debughelpers import FormDataRoutingRedirect
1773 
1774         raise FormDataRoutingRedirect(request)
1775 
1776     def dispatch_request(self) -> ft.ResponseReturnValue:
1777         """Does the request dispatching.  Matches the URL and returns the
1778         return value of the view or error handler.  This does not have to
1779         be a response object.  In order to convert the return value to a
1780         proper response object, call :func:`make_response`.
1781 
1782         .. versionchanged:: 0.7
1783            This no longer does the exception handling, this code was
1784            moved to the new :meth:`full_dispatch_request`.
1785         """
1786         req = request_ctx.request
1787         if req.routing_exception is not None:
1788             self.raise_routing_exception(req)
1789         rule: Rule = req.url_rule  # type: ignore[assignment]
1790         # if we provide automatic options for this URL and the
1791         # request came with the OPTIONS method, reply automatically
1792         if (
1793             getattr(rule, "provide_automatic_options", False)
1794             and req.method == "OPTIONS"
1795         ):
1796             return self.make_default_options_response()
1797         # otherwise dispatch to the handler for that endpoint
1798         view_args: t.Dict[str, t.Any] = req.view_args  # type: ignore[assignment]
1799         return self.ensure_sync(self.view_functions[rule.endpoint])(**view_args)
1800 
1801     def full_dispatch_request(self) -> Response:
1802         """Dispatches the request and on top of that performs request
1803         pre and postprocessing as well as HTTP exception catching and
1804         error handling.
1805 
1806         .. versionadded:: 0.7
1807         """
1808         # Run before_first_request functions if this is the thread's first request.
1809         # Inlined to avoid a method call on subsequent requests.
1810         # This is deprecated, will be removed in Flask 2.3.
1811         if not self._got_first_request:
1812             with self._before_request_lock:
1813                 if not self._got_first_request:
1814                     for func in self.before_first_request_funcs:
1815                         self.ensure_sync(func)()
1816 
1817                     self._got_first_request = True
1818 
1819         try:
1820             request_started.send(self)
1821             rv = self.preprocess_request()
1822             if rv is None:
1823                 rv = self.dispatch_request()
1824         except Exception as e:
1825             rv = self.handle_user_exception(e)
1826         return self.finalize_request(rv)
1827 
1828     def finalize_request(
1829         self,
1830         rv: t.Union[ft.ResponseReturnValue, HTTPException],
1831         from_error_handler: bool = False,
1832     ) -> Response:
1833         """Given the return value from a view function this finalizes
1834         the request by converting it into a response and invoking the
1835         postprocessing functions.  This is invoked for both normal
1836         request dispatching as well as error handlers.
1837 
1838         Because this means that it might be called as a result of a
1839         failure a special safe mode is available which can be enabled
1840         with the `from_error_handler` flag.  If enabled, failures in
1841         response processing will be logged and otherwise ignored.
1842 
1843         :internal:
1844         """
1845         response = self.make_response(rv)
1846         try:
1847             response = self.process_response(response)
1848             request_finished.send(self, response=response)
1849         except Exception:
1850             if not from_error_handler:
1851                 raise
1852             self.logger.exception(
1853                 "Request finalizing failed with an error while handling an error"
1854             )
1855         return response
1856 
1857     def make_default_options_response(self) -> Response:
1858         """This method is called to create the default ``OPTIONS`` response.
1859         This can be changed through subclassing to change the default
1860         behavior of ``OPTIONS`` responses.
1861 
1862         .. versionadded:: 0.7
1863         """
1864         adapter = request_ctx.url_adapter
1865         methods = adapter.allowed_methods()  # type: ignore[union-attr]
1866         rv = self.response_class()
1867         rv.allow.update(methods)
1868         return rv
1869 
1870     def should_ignore_error(self, error: t.Optional[BaseException]) -> bool:
1871         """This is called to figure out if an error should be ignored
1872         or not as far as the teardown system is concerned.  If this
1873         function returns ``True`` then the teardown handlers will not be
1874         passed the error.
1875 
1876         .. versionadded:: 0.10
1877         """
1878         return False
1879 
1880     def ensure_sync(self, func: t.Callable) -> t.Callable:
1881         """Ensure that the function is synchronous for WSGI workers.
1882         Plain ``def`` functions are returned as-is. ``async def``
1883         functions are wrapped to run and wait for the response.
1884 
1885         Override this method to change how the app runs async views.
1886 
1887         .. versionadded:: 2.0
1888         """
1889         if iscoroutinefunction(func):
1890             return self.async_to_sync(func)
1891 
1892         return func
1893 
1894     def async_to_sync(
1895         self, func: t.Callable[..., t.Coroutine]
1896     ) -> t.Callable[..., t.Any]:
1897         """Return a sync function that will run the coroutine function.
1898 
1899         .. code-block:: python
1900 
1901             result = app.async_to_sync(func)(*args, **kwargs)
1902 
1903         Override this method to change how the app converts async code
1904         to be synchronously callable.
1905 
1906         .. versionadded:: 2.0
1907         """
1908         try:
1909             from asgiref.sync import async_to_sync as asgiref_async_to_sync
1910         except ImportError:
1911             raise RuntimeError(
1912                 "Install Flask with the 'async' extra in order to use async views."
1913             ) from None
1914 
1915         return asgiref_async_to_sync(func)
1916 
1917     def url_for(
1918         self,
1919         endpoint: str,
1920         *,
1921         _anchor: t.Optional[str] = None,
1922         _method: t.Optional[str] = None,
1923         _scheme: t.Optional[str] = None,
1924         _external: t.Optional[bool] = None,
1925         **values: t.Any,
1926     ) -> str:
1927         """Generate a URL to the given endpoint with the given values.
1928 
1929         This is called by :func:`flask.url_for`, and can be called
1930         directly as well.
1931 
1932         An *endpoint* is the name of a URL rule, usually added with
1933         :meth:`@app.route() <route>`, and usually the same name as the
1934         view function. A route defined in a :class:`~flask.Blueprint`
1935         will prepend the blueprint's name separated by a ``.`` to the
1936         endpoint.
1937 
1938         In some cases, such as email messages, you want URLs to include
1939         the scheme and domain, like ``https://example.com/hello``. When
1940         not in an active request, URLs will be external by default, but
1941         this requires setting :data:`SERVER_NAME` so Flask knows what
1942         domain to use. :data:`APPLICATION_ROOT` and
1943         :data:`PREFERRED_URL_SCHEME` should also be configured as
1944         needed. This config is only used when not in an active request.
1945 
1946         Functions can be decorated with :meth:`url_defaults` to modify
1947         keyword arguments before the URL is built.
1948 
1949         If building fails for some reason, such as an unknown endpoint
1950         or incorrect values, the app's :meth:`handle_url_build_error`
1951         method is called. If that returns a string, that is returned,
1952         otherwise a :exc:`~werkzeug.routing.BuildError` is raised.
1953 
1954         :param endpoint: The endpoint name associated with the URL to
1955             generate. If this starts with a ``.``, the current blueprint
1956             name (if any) will be used.
1957         :param _anchor: If given, append this as ``#anchor`` to the URL.
1958         :param _method: If given, generate the URL associated with this
1959             method for the endpoint.
1960         :param _scheme: If given, the URL will have this scheme if it
1961             is external.
1962         :param _external: If given, prefer the URL to be internal
1963             (False) or require it to be external (True). External URLs
1964             include the scheme and domain. When not in an active
1965             request, URLs are external by default.
1966         :param values: Values to use for the variable parts of the URL
1967             rule. Unknown keys are appended as query string arguments,
1968             like ``?a=b&c=d``.
1969 
1970         .. versionadded:: 2.2
1971             Moved from ``flask.url_for``, which calls this method.
1972         """
1973         req_ctx = _cv_request.get(None)
1974 
1975         if req_ctx is not None:
1976             url_adapter = req_ctx.url_adapter
1977             blueprint_name = req_ctx.request.blueprint
1978 
1979             # If the endpoint starts with "." and the request matches a
1980             # blueprint, the endpoint is relative to the blueprint.
1981             if endpoint[:1] == ".":
1982                 if blueprint_name is not None:
1983                     endpoint = f"{blueprint_name}{endpoint}"
1984                 else:
1985                     endpoint = endpoint[1:]
1986 
1987             # When in a request, generate a URL without scheme and
1988             # domain by default, unless a scheme is given.
1989             if _external is None:
1990                 _external = _scheme is not None
1991         else:
1992             app_ctx = _cv_app.get(None)
1993 
1994             # If called by helpers.url_for, an app context is active,
1995             # use its url_adapter. Otherwise, app.url_for was called
1996             # directly, build an adapter.
1997             if app_ctx is not None:
1998                 url_adapter = app_ctx.url_adapter
1999             else:
2000                 url_adapter = self.create_url_adapter(None)
2001 
2002             if url_adapter is None:
2003                 raise RuntimeError(
2004                     "Unable to build URLs outside an active request"
2005                     " without 'SERVER_NAME' configured. Also configure"
2006                     " 'APPLICATION_ROOT' and 'PREFERRED_URL_SCHEME' as"
2007                     " needed."
2008                 )
2009 
2010             # When outside a request, generate a URL with scheme and
2011             # domain by default.
2012             if _external is None:
2013                 _external = True
2014 
2015         # It is an error to set _scheme when _external=False, in order
2016         # to avoid accidental insecure URLs.
2017         if _scheme is not None and not _external:
2018             raise ValueError("When specifying '_scheme', '_external' must be True.")
2019 
2020         self.inject_url_defaults(endpoint, values)
2021 
2022         try:
2023             rv = url_adapter.build(  # type: ignore[union-attr]
2024                 endpoint,
2025                 values,
2026                 method=_method,
2027                 url_scheme=_scheme,
2028                 force_external=_external,
2029             )
2030         except BuildError as error:
2031             values.update(
2032                 _anchor=_anchor, _method=_method, _scheme=_scheme, _external=_external
2033             )
2034             return self.handle_url_build_error(error, endpoint, values)
2035 
2036         if _anchor is not None:
2037             rv = f"{rv}#{url_quote(_anchor)}"
2038 
2039         return rv
2040 
2041     def redirect(self, location: str, code: int = 302) -> BaseResponse:
2042         """Create a redirect response object.
2043 
2044         This is called by :func:`flask.redirect`, and can be called
2045         directly as well.
2046 
2047         :param location: The URL to redirect to.
2048         :param code: The status code for the redirect.
2049 
2050         .. versionadded:: 2.2
2051             Moved from ``flask.redirect``, which calls this method.
2052         """
2053         return _wz_redirect(location, code=code, Response=self.response_class)
2054 
2055     def make_response(self, rv: ft.ResponseReturnValue) -> Response:
2056         """Convert the return value from a view function to an instance of
2057         :attr:`response_class`.
2058 
2059         :param rv: the return value from the view function. The view function
2060             must return a response. Returning ``None``, or the view ending
2061             without returning, is not allowed. The following types are allowed
2062             for ``view_rv``:
2063 
2064             ``str``
2065                 A response object is created with the string encoded to UTF-8
2066                 as the body.
2067 
2068             ``bytes``
2069                 A response object is created with the bytes as the body.
2070 
2071             ``dict``
2072                 A dictionary that will be jsonify'd before being returned.
2073 
2074             ``list``
2075                 A list that will be jsonify'd before being returned.
2076 
2077             ``generator`` or ``iterator``
2078                 A generator that returns ``str`` or ``bytes`` to be
2079                 streamed as the response.
2080 
2081             ``tuple``
2082                 Either ``(body, status, headers)``, ``(body, status)``, or
2083                 ``(body, headers)``, where ``body`` is any of the other types
2084                 allowed here, ``status`` is a string or an integer, and
2085                 ``headers`` is a dictionary or a list of ``(key, value)``
2086                 tuples. If ``body`` is a :attr:`response_class` instance,
2087                 ``status`` overwrites the exiting value and ``headers`` are
2088                 extended.
2089 
2090             :attr:`response_class`
2091                 The object is returned unchanged.
2092 
2093             other :class:`~werkzeug.wrappers.Response` class
2094                 The object is coerced to :attr:`response_class`.
2095 
2096             :func:`callable`
2097                 The function is called as a WSGI application. The result is
2098                 used to create a response object.
2099 
2100         .. versionchanged:: 2.2
2101             A generator will be converted to a streaming response.
2102             A list will be converted to a JSON response.
2103 
2104         .. versionchanged:: 1.1
2105             A dict will be converted to a JSON response.
2106 
2107         .. versionchanged:: 0.9
2108            Previously a tuple was interpreted as the arguments for the
2109            response object.
2110         """
2111 
2112         status = headers = None
2113 
2114         # unpack tuple returns
2115         if isinstance(rv, tuple):
2116             len_rv = len(rv)
2117 
2118             # a 3-tuple is unpacked directly
2119             if len_rv == 3:
2120                 rv, status, headers = rv  # type: ignore[misc]
2121             # decide if a 2-tuple has status or headers
2122             elif len_rv == 2:
2123                 if isinstance(rv[1], (Headers, dict, tuple, list)):
2124                     rv, headers = rv
2125                 else:
2126                     rv, status = rv  # type: ignore[assignment,misc]
2127             # other sized tuples are not allowed
2128             else:
2129                 raise TypeError(
2130                     "The view function did not return a valid response tuple."
2131                     " The tuple must have the form (body, status, headers),"
2132                     " (body, status), or (body, headers)."
2133                 )
2134 
2135         # the body must not be None
2136         if rv is None:
2137             raise TypeError(
2138                 f"The view function for {request.endpoint!r} did not"
2139                 " return a valid response. The function either returned"
2140                 " None or ended without a return statement."
2141             )
2142 
2143         # make sure the body is an instance of the response class
2144         if not isinstance(rv, self.response_class):
2145             if isinstance(rv, (str, bytes, bytearray)) or isinstance(rv, _abc_Iterator):
2146                 # let the response class set the status and headers instead of
2147                 # waiting to do it manually, so that the class can handle any
2148                 # special logic
2149                 rv = self.response_class(
2150                     rv,
2151                     status=status,
2152                     headers=headers,  # type: ignore[arg-type]
2153                 )
2154                 status = headers = None
2155             elif isinstance(rv, (dict, list)):
2156                 rv = self.json.response(rv)
2157             elif isinstance(rv, BaseResponse) or callable(rv):
2158                 # evaluate a WSGI callable, or coerce a different response
2159                 # class to the correct type
2160                 try:
2161                     rv = self.response_class.force_type(
2162                         rv, request.environ  # type: ignore[arg-type]
2163                     )
2164                 except TypeError as e:
2165                     raise TypeError(
2166                         f"{e}\nThe view function did not return a valid"
2167                         " response. The return type must be a string,"
2168                         " dict, list, tuple with headers or status,"
2169                         " Response instance, or WSGI callable, but it"
2170                         f" was a {type(rv).__name__}."
2171                     ).with_traceback(sys.exc_info()[2]) from None
2172             else:
2173                 raise TypeError(
2174                     "The view function did not return a valid"
2175                     " response. The return type must be a string,"
2176                     " dict, list, tuple with headers or status,"
2177                     " Response instance, or WSGI callable, but it was a"
2178                     f" {type(rv).__name__}."
2179                 )
2180 
2181         rv = t.cast(Response, rv)
2182         # prefer the status if it was provided
2183         if status is not None:
2184             if isinstance(status, (str, bytes, bytearray)):
2185                 rv.status = status
2186             else:
2187                 rv.status_code = status
2188 
2189         # extend existing headers with provided headers
2190         if headers:
2191             rv.headers.update(headers)  # type: ignore[arg-type]
2192 
2193         return rv
2194 
2195     def create_url_adapter(
2196         self, request: t.Optional[Request]
2197     ) -> t.Optional[MapAdapter]:
2198         """Creates a URL adapter for the given request. The URL adapter
2199         is created at a point where the request context is not yet set
2200         up so the request is passed explicitly.
2201 
2202         .. versionadded:: 0.6
2203 
2204         .. versionchanged:: 0.9
2205            This can now also be called without a request object when the
2206            URL adapter is created for the application context.
2207 
2208         .. versionchanged:: 1.0
2209             :data:`SERVER_NAME` no longer implicitly enables subdomain
2210             matching. Use :attr:`subdomain_matching` instead.
2211         """
2212         if request is not None:
2213             # If subdomain matching is disabled (the default), use the
2214             # default subdomain in all cases. This should be the default
2215             # in Werkzeug but it currently does not have that feature.
2216             if not self.subdomain_matching:
2217                 subdomain = self.url_map.default_subdomain or None
2218             else:
2219                 subdomain = None
2220 
2221             return self.url_map.bind_to_environ(
2222                 request.environ,
2223                 server_name=self.config["SERVER_NAME"],
2224                 subdomain=subdomain,
2225             )
2226         # We need at the very least the server name to be set for this
2227         # to work.
2228         if self.config["SERVER_NAME"] is not None:
2229             return self.url_map.bind(
2230                 self.config["SERVER_NAME"],
2231                 script_name=self.config["APPLICATION_ROOT"],
2232                 url_scheme=self.config["PREFERRED_URL_SCHEME"],
2233             )
2234 
2235         return None
2236 
2237     def inject_url_defaults(self, endpoint: str, values: dict) -> None:
2238         """Injects the URL defaults for the given endpoint directly into
2239         the values dictionary passed.  This is used internally and
2240         automatically called on URL building.
2241 
2242         .. versionadded:: 0.7
2243         """
2244         names: t.Iterable[t.Optional[str]] = (None,)
2245 
2246         # url_for may be called outside a request context, parse the
2247         # passed endpoint instead of using request.blueprints.
2248         if "." in endpoint:
2249             names = chain(
2250                 names, reversed(_split_blueprint_path(endpoint.rpartition(".")[0]))
2251             )
2252 
2253         for name in names:
2254             if name in self.url_default_functions:
2255                 for func in self.url_default_functions[name]:
2256                     func(endpoint, values)
2257 
2258     def handle_url_build_error(
2259         self, error: BuildError, endpoint: str, values: t.Dict[str, t.Any]
2260     ) -> str:
2261         """Called by :meth:`.url_for` if a
2262         :exc:`~werkzeug.routing.BuildError` was raised. If this returns
2263         a value, it will be returned by ``url_for``, otherwise the error
2264         will be re-raised.
2265 
2266         Each function in :attr:`url_build_error_handlers` is called with
2267         ``error``, ``endpoint`` and ``values``. If a function returns
2268         ``None`` or raises a ``BuildError``, it is skipped. Otherwise,
2269         its return value is returned by ``url_for``.
2270 
2271         :param error: The active ``BuildError`` being handled.
2272         :param endpoint: The endpoint being built.
2273         :param values: The keyword arguments passed to ``url_for``.
2274         """
2275         for handler in self.url_build_error_handlers:
2276             try:
2277                 rv = handler(error, endpoint, values)
2278             except BuildError as e:
2279                 # make error available outside except block
2280                 error = e
2281             else:
2282                 if rv is not None:
2283                     return rv
2284 
2285         # Re-raise if called with an active exception, otherwise raise
2286         # the passed in exception.
2287         if error is sys.exc_info()[1]:
2288             raise
2289 
2290         raise error
2291 
2292     def preprocess_request(self) -> t.Optional[ft.ResponseReturnValue]:
2293         """Called before the request is dispatched. Calls
2294         :attr:`url_value_preprocessors` registered with the app and the
2295         current blueprint (if any). Then calls :attr:`before_request_funcs`
2296         registered with the app and the blueprint.
2297 
2298         If any :meth:`before_request` handler returns a non-None value, the
2299         value is handled as if it was the return value from the view, and
2300         further request handling is stopped.
2301         """
2302         names = (None, *reversed(request.blueprints))
2303 
2304         for name in names:
2305             if name in self.url_value_preprocessors:
2306                 for url_func in self.url_value_preprocessors[name]:
2307                     url_func(request.endpoint, request.view_args)
2308 
2309         for name in names:
2310             if name in self.before_request_funcs:
2311                 for before_func in self.before_request_funcs[name]:
2312                     rv = self.ensure_sync(before_func)()
2313 
2314                     if rv is not None:
2315                         return rv
2316 
2317         return None
2318 
2319     def process_response(self, response: Response) -> Response:
2320         """Can be overridden in order to modify the response object
2321         before it's sent to the WSGI server.  By default this will
2322         call all the :meth:`after_request` decorated functions.
2323 
2324         .. versionchanged:: 0.5
2325            As of Flask 0.5 the functions registered for after request
2326            execution are called in reverse order of registration.
2327 
2328         :param response: a :attr:`response_class` object.
2329         :return: a new response object or the same, has to be an
2330                  instance of :attr:`response_class`.
2331         """
2332         ctx = request_ctx._get_current_object()  # type: ignore[attr-defined]
2333 
2334         for func in ctx._after_request_functions:
2335             response = self.ensure_sync(func)(response)
2336 
2337         for name in chain(request.blueprints, (None,)):
2338             if name in self.after_request_funcs:
2339                 for func in reversed(self.after_request_funcs[name]):
2340                     response = self.ensure_sync(func)(response)
2341 
2342         if not self.session_interface.is_null_session(ctx.session):
2343             self.session_interface.save_session(self, ctx.session, response)
2344 
2345         return response
2346 
2347     def do_teardown_request(
2348         self, exc: t.Optional[BaseException] = _sentinel  # type: ignore
2349     ) -> None:
2350         """Called after the request is dispatched and the response is
2351         returned, right before the request context is popped.
2352 
2353         This calls all functions decorated with
2354         :meth:`teardown_request`, and :meth:`Blueprint.teardown_request`
2355         if a blueprint handled the request. Finally, the
2356         :data:`request_tearing_down` signal is sent.
2357 
2358         This is called by
2359         :meth:`RequestContext.pop() <flask.ctx.RequestContext.pop>`,
2360         which may be delayed during testing to maintain access to
2361         resources.
2362 
2363         :param exc: An unhandled exception raised while dispatching the
2364             request. Detected from the current exception information if
2365             not passed. Passed to each teardown function.
2366 
2367         .. versionchanged:: 0.9
2368             Added the ``exc`` argument.
2369         """
2370         if exc is _sentinel:
2371             exc = sys.exc_info()[1]
2372 
2373         for name in chain(request.blueprints, (None,)):
2374             if name in self.teardown_request_funcs:
2375                 for func in reversed(self.teardown_request_funcs[name]):
2376                     self.ensure_sync(func)(exc)
2377 
2378         request_tearing_down.send(self, exc=exc)
2379 
2380     def do_teardown_appcontext(
2381         self, exc: t.Optional[BaseException] = _sentinel  # type: ignore
2382     ) -> None:
2383         """Called right before the application context is popped.
2384 
2385         When handling a request, the application context is popped
2386         after the request context. See :meth:`do_teardown_request`.
2387 
2388         This calls all functions decorated with
2389         :meth:`teardown_appcontext`. Then the
2390         :data:`appcontext_tearing_down` signal is sent.
2391 
2392         This is called by
2393         :meth:`AppContext.pop() <flask.ctx.AppContext.pop>`.
2394 
2395         .. versionadded:: 0.9
2396         """
2397         if exc is _sentinel:
2398             exc = sys.exc_info()[1]
2399 
2400         for func in reversed(self.teardown_appcontext_funcs):
2401             self.ensure_sync(func)(exc)
2402 
2403         appcontext_tearing_down.send(self, exc=exc)
2404 
2405     def app_context(self) -> AppContext:
2406         """Create an :class:`~flask.ctx.AppContext`. Use as a ``with``
2407         block to push the context, which will make :data:`current_app`
2408         point at this application.
2409 
2410         An application context is automatically pushed by
2411         :meth:`RequestContext.push() <flask.ctx.RequestContext.push>`
2412         when handling a request, and when running a CLI command. Use
2413         this to manually create a context outside of these situations.
2414 
2415         ::
2416 
2417             with app.app_context():
2418                 init_db()
2419 
2420         See :doc:`/appcontext`.
2421 
2422         .. versionadded:: 0.9
2423         """
2424         return AppContext(self)
2425 
2426     def request_context(self, environ: dict) -> RequestContext:
2427         """Create a :class:`~flask.ctx.RequestContext` representing a
2428         WSGI environment. Use a ``with`` block to push the context,
2429         which will make :data:`request` point at this request.
2430 
2431         See :doc:`/reqcontext`.
2432 
2433         Typically you should not call this from your own code. A request
2434         context is automatically pushed by the :meth:`wsgi_app` when
2435         handling a request. Use :meth:`test_request_context` to create
2436         an environment and context instead of this method.
2437 
2438         :param environ: a WSGI environment
2439         """
2440         return RequestContext(self, environ)
2441 
2442     def test_request_context(self, *args: t.Any, **kwargs: t.Any) -> RequestContext:
2443         """Create a :class:`~flask.ctx.RequestContext` for a WSGI
2444         environment created from the given values. This is mostly useful
2445         during testing, where you may want to run a function that uses
2446         request data without dispatching a full request.
2447 
2448         See :doc:`/reqcontext`.
2449 
2450         Use a ``with`` block to push the context, which will make
2451         :data:`request` point at the request for the created
2452         environment. ::
2453 
2454             with app.test_request_context(...):
2455                 generate_report()
2456 
2457         When using the shell, it may be easier to push and pop the
2458         context manually to avoid indentation. ::
2459 
2460             ctx = app.test_request_context(...)
2461             ctx.push()
2462             ...
2463             ctx.pop()
2464 
2465         Takes the same arguments as Werkzeug's
2466         :class:`~werkzeug.test.EnvironBuilder`, with some defaults from
2467         the application. See the linked Werkzeug docs for most of the
2468         available arguments. Flask-specific behavior is listed here.
2469 
2470         :param path: URL path being requested.
2471         :param base_url: Base URL where the app is being served, which
2472             ``path`` is relative to. If not given, built from
2473             :data:`PREFERRED_URL_SCHEME`, ``subdomain``,
2474             :data:`SERVER_NAME`, and :data:`APPLICATION_ROOT`.
2475         :param subdomain: Subdomain name to append to
2476             :data:`SERVER_NAME`.
2477         :param url_scheme: Scheme to use instead of
2478             :data:`PREFERRED_URL_SCHEME`.
2479         :param data: The request body, either as a string or a dict of
2480             form keys and values.
2481         :param json: If given, this is serialized as JSON and passed as
2482             ``data``. Also defaults ``content_type`` to
2483             ``application/json``.
2484         :param args: other positional arguments passed to
2485             :class:`~werkzeug.test.EnvironBuilder`.
2486         :param kwargs: other keyword arguments passed to
2487             :class:`~werkzeug.test.EnvironBuilder`.
2488         """
2489         from .testing import EnvironBuilder
2490 
2491         builder = EnvironBuilder(self, *args, **kwargs)
2492 
2493         try:
2494             return self.request_context(builder.get_environ())
2495         finally:
2496             builder.close()
2497 
2498     def wsgi_app(self, environ: dict, start_response: t.Callable) -> t.Any:
2499         """The actual WSGI application. This is not implemented in
2500         :meth:`__call__` so that middlewares can be applied without
2501         losing a reference to the app object. Instead of doing this::
2502 
2503             app = MyMiddleware(app)
2504 
2505         It's a better idea to do this instead::
2506 
2507             app.wsgi_app = MyMiddleware(app.wsgi_app)
2508 
2509         Then you still have the original application object around and
2510         can continue to call methods on it.
2511 
2512         .. versionchanged:: 0.7
2513             Teardown events for the request and app contexts are called
2514             even if an unhandled error occurs. Other events may not be
2515             called depending on when an error occurs during dispatch.
2516             See :ref:`callbacks-and-errors`.
2517 
2518         :param environ: A WSGI environment.
2519         :param start_response: A callable accepting a status code,
2520             a list of headers, and an optional exception context to
2521             start the response.
2522         """
2523         ctx = self.request_context(environ)
2524         error: t.Optional[BaseException] = None
2525         try:
2526             try:
2527                 ctx.push()
2528                 response = self.full_dispatch_request()
2529             except Exception as e:
2530                 error = e
2531                 response = self.handle_exception(e)
2532             except:  # noqa: B001
2533                 error = sys.exc_info()[1]
2534                 raise
2535             return response(environ, start_response)
2536         finally:
2537             if "werkzeug.debug.preserve_context" in environ:
2538                 environ["werkzeug.debug.preserve_context"](_cv_app.get())
2539                 environ["werkzeug.debug.preserve_context"](_cv_request.get())
2540 
2541             if error is not None and self.should_ignore_error(error):
2542                 error = None
2543 
2544             ctx.pop(error)
2545 
2546     def __call__(self, environ: dict, start_response: t.Callable) -> t.Any:
2547         """The WSGI server calls the Flask application object as the
2548         WSGI application. This calls :meth:`wsgi_app`, which can be
2549         wrapped to apply middleware.
2550         """
2551         return self.wsgi_app(environ, start_response)

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>]
2025-10-15 21:16:17.030 | INFO     | Search completed. Bug locations: [<file>src/flask/blueprints.py</file>
<class>Blueprint</class>
<method>register</method>
<code>
350     def register(self, app: "Flask", options: dict) -> None:
351         """Called by :meth:`Flask.register_blueprint` to register all
352         views and callbacks registered on the blueprint with the
353         application. Creates a :class:`.BlueprintSetupState` and calls
354         each :meth:`record` callback with it.
355 
356         :param app: The application this blueprint is being registered
357             with.
358         :param options: Keyword arguments forwarded from
359             :meth:`~Flask.register_blueprint`.
360 
361         .. versionchanged:: 2.0.1
362             Nested blueprints are registered with their dotted name.
363             This allows different blueprints with the same name to be
364             nested at different locations.
365 
366         .. versionchanged:: 2.0.1
367             The ``name`` option can be used to change the (pre-dotted)
368             name the blueprint is registered with. This allows the same
369             blueprint to be registered multiple times with unique names
370             for ``url_for``.
371 
372         .. versionchanged:: 2.0.1
373             Registering the same blueprint with the same name multiple
374             times is deprecated and will become an error in Flask 2.1.
375         """
376         name_prefix = options.get("name_prefix", "")
377         self_name = options.get("name", self.name)
378         name = f"{name_prefix}.{self_name}".lstrip(".")
379 
380         if name in app.blueprints:
381             bp_desc = "this" if app.blueprints[name] is self else "a different"
382             existing_at = f" '{name}'" if self_name != name else ""
383 
384             raise ValueError(
385                 f"The name '{self_name}' is already registered for"
386                 f" {bp_desc} blueprint{existing_at}. Use 'name=' to"
387                 f" provide a unique name."
388             )
389 
390         first_bp_registration = not any(bp is self for bp in app.blueprints.values())
391         first_name_registration = name not in app.blueprints
392 
393         app.blueprints[name] = self
394         self._got_registered_once = True
395         state = self.make_setup_state(app, options, first_bp_registration)
396 
397         if self.has_static_folder:
398             state.add_url_rule(
399                 f"{self.static_url_path}/<path:filename>",
400                 view_func=self.send_static_file,
401                 endpoint="static",
402             )
403 
404         # Merge blueprint data into parent.
405         if first_bp_registration or first_name_registration:
406 
407             def extend(bp_dict, parent_dict):
408                 for key, values in bp_dict.items():
409                     key = name if key is None else f"{name}.{key}"
410                     parent_dict[key].extend(values)
411 
412             for key, value in self.error_handler_spec.items():
413                 key = name if key is None else f"{name}.{key}"
414                 value = defaultdict(
415                     dict,
416                     {
417                         code: {
418                             exc_class: func for exc_class, func in code_values.items()
419                         }
420                         for code, code_values in value.items()
421                     },
422                 )
423                 app.error_handler_spec[key] = value
424 
425             for endpoint, func in self.view_functions.items():
426                 app.view_functions[endpoint] = func
427 
428             extend(self.before_request_funcs, app.before_request_funcs)
429             extend(self.after_request_funcs, app.after_request_funcs)
430             extend(
431                 self.teardown_request_funcs,
432                 app.teardown_request_funcs,
433             )
434             extend(self.url_default_functions, app.url_default_functions)
435             extend(self.url_value_preprocessors, app.url_value_preprocessors)
436             extend(self.template_context_processors, app.template_context_processors)
437 
438         for deferred in self.deferred_functions:
439             deferred(state)
440 
441         cli_resolved_group = options.get("cli_group", self.cli_group)
442 
443         if self.cli.commands:
444             if cli_resolved_group is None:
445                 app.cli.commands.update(self.cli.commands)
446             elif cli_resolved_group is _sentinel:
447                 self.cli.name = name
448                 app.cli.add_command(self.cli)
449             else:
450                 self.cli.name = cli_resolved_group
451                 app.cli.add_command(self.cli)
452 
453         for blueprint, bp_options in self._blueprints:
454             bp_options = bp_options.copy()
455             bp_url_prefix = bp_options.get("url_prefix")
456 
457             if bp_url_prefix is None:
458                 bp_url_prefix = blueprint.url_prefix
459 
460             if state.url_prefix is not None and bp_url_prefix is not None:
461                 bp_options["url_prefix"] = (
462                     state.url_prefix.rstrip("/") + "/" + bp_url_prefix.lstrip("/")
463                 )
464             elif bp_url_prefix is not None:
465                 bp_options["url_prefix"] = bp_url_prefix
466             elif state.url_prefix is not None:
467                 bp_options["url_prefix"] = state.url_prefix
468 
469             bp_options["name_prefix"] = name
470             blueprint.register(app, bp_options)

</code><intended_behavior>This method should be enhanced to ensure that when a blueprint is registered (especially nested blueprints), the subdomain configuration of the parent is correctly inherited and applied. Specifically, if a parent blueprint is registered with a subdomain, all nested child blueprints should automatically inherit this subdomain setting unless explicitly overridden. This adjustment will ensure that routes defined in nested blueprints are accessible under the correctly configured subdomain of their parent blueprint, thereby preserving the intended routing hierarchy envisioned when using nesting and subdomains together. The existing functionality for blueprints that do not utilize subdomains or are not part of a nested structure should remain unaffected.</intended_behavior>, <file>src/flask/blueprints.py</file>
<class>Blueprint</class>
<method>None</method>
<code>
121 class Blueprint(Scaffold):
122     """Represents a blueprint, a collection of routes and other
123     app-related functions that can be registered on a real application
124     later.
125 
126     A blueprint is an object that allows defining application functions
127     without requiring an application object ahead of time. It uses the
128     same decorators as :class:`~flask.Flask`, but defers the need for an
129     application by recording them for later registration.
130 
131     Decorating a function with a blueprint creates a deferred function
132     that is called with :class:`~flask.blueprints.BlueprintSetupState`
133     when the blueprint is registered on an application.
134 
135     See :doc:`/blueprints` for more information.
136 
137     :param name: The name of the blueprint. Will be prepended to each
138         endpoint name.
139     :param import_name: The name of the blueprint package, usually
140         ``__name__``. This helps locate the ``root_path`` for the
141         blueprint.
142     :param static_folder: A folder with static files that should be
143         served by the blueprint's static route. The path is relative to
144         the blueprint's root path. Blueprint static files are disabled
145         by default.
146     :param static_url_path: The url to serve static files from.
147         Defaults to ``static_folder``. If the blueprint does not have
148         a ``url_prefix``, the app's static route will take precedence,
149         and the blueprint's static files won't be accessible.
150     :param template_folder: A folder with templates that should be added
151         to the app's template search path. The path is relative to the
152         blueprint's root path. Blueprint templates are disabled by
153         default. Blueprint templates have a lower precedence than those
154         in the app's templates folder.
155     :param url_prefix: A path to prepend to all of the blueprint's URLs,
156         to make them distinct from the rest of the app's routes.
157     :param subdomain: A subdomain that blueprint routes will match on by
158         default.
159     :param url_defaults: A dict of default values that blueprint routes
160         will receive by default.
161     :param root_path: By default, the blueprint will automatically set
162         this based on ``import_name``. In certain situations this
163         automatic detection can fail, so the path can be specified
164         manually instead.
165 
166     .. versionchanged:: 1.1.0
167         Blueprints have a ``cli`` group to register nested CLI commands.
168         The ``cli_group`` parameter controls the name of the group under
169         the ``flask`` command.
170 
171     .. versionadded:: 0.7
172     """
173 
174     _got_registered_once = False
175 
176     _json_encoder: t.Union[t.Type[json.JSONEncoder], None] = None
177     _json_decoder: t.Union[t.Type[json.JSONDecoder], None] = None
178 
179     @property
180     def json_encoder(
181         self,
182     ) -> t.Union[t.Type[json.JSONEncoder], None]:
183         """Blueprint-local JSON encoder class to use. Set to ``None`` to use the app's.
184 
185         .. deprecated:: 2.2
186              Will be removed in Flask 2.3. Customize
187              :attr:`json_provider_class` instead.
188 
189         .. versionadded:: 0.10
190         """
191         import warnings
192 
193         warnings.warn(
194             "'bp.json_encoder' is deprecated and will be removed in Flask 2.3."
195             " Customize 'app.json_provider_class' or 'app.json' instead.",
196             DeprecationWarning,
197             stacklevel=2,
198         )
199         return self._json_encoder
200 
201     @json_encoder.setter
202     def json_encoder(self, value: t.Union[t.Type[json.JSONEncoder], None]) -> None:
203         import warnings
204 
205         warnings.warn(
206             "'bp.json_encoder' is deprecated and will be removed in Flask 2.3."
207             " Customize 'app.json_provider_class' or 'app.json' instead.",
208             DeprecationWarning,
209             stacklevel=2,
210         )
211         self._json_encoder = value
212 
213     @property
214     def json_decoder(
215         self,
216     ) -> t.Union[t.Type[json.JSONDecoder], None]:
217         """Blueprint-local JSON decoder class to use. Set to ``None`` to use the app's.
218 
219         .. deprecated:: 2.2
220              Will be removed in Flask 2.3. Customize
221              :attr:`json_provider_class` instead.
222 
223         .. versionadded:: 0.10
224         """
225         import warnings
226 
227         warnings.warn(
228             "'bp.json_decoder' is deprecated and will be removed in Flask 2.3."
229             " Customize 'app.json_provider_class' or 'app.json' instead.",
230             DeprecationWarning,
231             stacklevel=2,
232         )
233         return self._json_decoder
234 
235     @json_decoder.setter
236     def json_decoder(self, value: t.Union[t.Type[json.JSONDecoder], None]) -> None:
237         import warnings
238 
239         warnings.warn(
240             "'bp.json_decoder' is deprecated and will be removed in Flask 2.3."
241             " Customize 'app.json_provider_class' or 'app.json' instead.",
242             DeprecationWarning,
243             stacklevel=2,
244         )
245         self._json_decoder = value
246 
247     def __init__(
248         self,
249         name: str,
250         import_name: str,
251         static_folder: t.Optional[t.Union[str, os.PathLike]] = None,
252         static_url_path: t.Optional[str] = None,
253         template_folder: t.Optional[t.Union[str, os.PathLike]] = None,
254         url_prefix: t.Optional[str] = None,
255         subdomain: t.Optional[str] = None,
256         url_defaults: t.Optional[dict] = None,
257         root_path: t.Optional[str] = None,
258         cli_group: t.Optional[str] = _sentinel,  # type: ignore
259     ):
260         super().__init__(
261             import_name=import_name,
262             static_folder=static_folder,
263             static_url_path=static_url_path,
264             template_folder=template_folder,
265             root_path=root_path,
266         )
267 
268         if "." in name:
269             raise ValueError("'name' may not contain a dot '.' character.")
270 
271         self.name = name
272         self.url_prefix = url_prefix
273         self.subdomain = subdomain
274         self.deferred_functions: t.List[DeferredSetupFunction] = []
275 
276         if url_defaults is None:
277             url_defaults = {}
278 
279         self.url_values_defaults = url_defaults
280         self.cli_group = cli_group
281         self._blueprints: t.List[t.Tuple["Blueprint", dict]] = []
282 
283     def _check_setup_finished(self, f_name: str) -> None:
284         if self._got_registered_once:
285             import warnings
286 
287             warnings.warn(
288                 f"The setup method '{f_name}' can no longer be called on"
289                 f" the blueprint '{self.name}'. It has already been"
290                 " registered at least once, any changes will not be"
291                 " applied consistently.\n"
292                 "Make sure all imports, decorators, functions, etc."
293                 " needed to set up the blueprint are done before"
294                 " registering it.\n"
295                 "This warning will become an exception in Flask 2.3.",
296                 UserWarning,
297                 stacklevel=3,
298             )
299 
300     @setupmethod
301     def record(self, func: t.Callable) -> None:
302         """Registers a function that is called when the blueprint is
303         registered on the application.  This function is called with the
304         state as argument as returned by the :meth:`make_setup_state`
305         method.
306         """
307         self.deferred_functions.append(func)
308 
309     @setupmethod
310     def record_once(self, func: t.Callable) -> None:
311         """Works like :meth:`record` but wraps the function in another
312         function that will ensure the function is only called once.  If the
313         blueprint is registered a second time on the application, the
314         function passed is not called.
315         """
316 
317         def wrapper(state: BlueprintSetupState) -> None:
318             if state.first_registration:
319                 func(state)
320 
321         self.record(update_wrapper(wrapper, func))
322 
323     def make_setup_state(
324         self, app: "Flask", options: dict, first_registration: bool = False
325     ) -> BlueprintSetupState:
326         """Creates an instance of :meth:`~flask.blueprints.BlueprintSetupState`
327         object that is later passed to the register callback functions.
328         Subclasses can override this to return a subclass of the setup state.
329         """
330         return BlueprintSetupState(self, app, options, first_registration)
331 
332     @setupmethod
333     def register_blueprint(self, blueprint: "Blueprint", **options: t.Any) -> None:
334         """Register a :class:`~flask.Blueprint` on this blueprint. Keyword
335         arguments passed to this method will override the defaults set
336         on the blueprint.
337 
338         .. versionchanged:: 2.0.1
339             The ``name`` option can be used to change the (pre-dotted)
340             name the blueprint is registered with. This allows the same
341             blueprint to be registered multiple times with unique names
342             for ``url_for``.
343 
344         .. versionadded:: 2.0
345         """
346         if blueprint is self:
347             raise ValueError("Cannot register a blueprint on itself")
348         self._blueprints.append((blueprint, options))
349 
350     def register(self, app: "Flask", options: dict) -> None:
351         """Called by :meth:`Flask.register_blueprint` to register all
352         views and callbacks registered on the blueprint with the
353         application. Creates a :class:`.BlueprintSetupState` and calls
354         each :meth:`record` callback with it.
355 
356         :param app: The application this blueprint is being registered
357             with.
358         :param options: Keyword arguments forwarded from
359             :meth:`~Flask.register_blueprint`.
360 
361         .. versionchanged:: 2.0.1
362             Nested blueprints are registered with their dotted name.
363             This allows different blueprints with the same name to be
364             nested at different locations.
365 
366         .. versionchanged:: 2.0.1
367             The ``name`` option can be used to change the (pre-dotted)
368             name the blueprint is registered with. This allows the same
369             blueprint to be registered multiple times with unique names
370             for ``url_for``.
371 
372         .. versionchanged:: 2.0.1
373             Registering the same blueprint with the same name multiple
374             times is deprecated and will become an error in Flask 2.1.
375         """
376         name_prefix = options.get("name_prefix", "")
377         self_name = options.get("name", self.name)
378         name = f"{name_prefix}.{self_name}".lstrip(".")
379 
380         if name in app.blueprints:
381             bp_desc = "this" if app.blueprints[name] is self else "a different"
382             existing_at = f" '{name}'" if self_name != name else ""
383 
384             raise ValueError(
385                 f"The name '{self_name}' is already registered for"
386                 f" {bp_desc} blueprint{existing_at}. Use 'name=' to"
387                 f" provide a unique name."
388             )
389 
390         first_bp_registration = not any(bp is self for bp in app.blueprints.values())
391         first_name_registration = name not in app.blueprints
392 
393         app.blueprints[name] = self
394         self._got_registered_once = True
395         state = self.make_setup_state(app, options, first_bp_registration)
396 
397         if self.has_static_folder:
398             state.add_url_rule(
399                 f"{self.static_url_path}/<path:filename>",
400                 view_func=self.send_static_file,
401                 endpoint="static",
402             )
403 
404         # Merge blueprint data into parent.
405         if first_bp_registration or first_name_registration:
406 
407             def extend(bp_dict, parent_dict):
408                 for key, values in bp_dict.items():
409                     key = name if key is None else f"{name}.{key}"
410                     parent_dict[key].extend(values)
411 
412             for key, value in self.error_handler_spec.items():
413                 key = name if key is None else f"{name}.{key}"
414                 value = defaultdict(
415                     dict,
416                     {
417                         code: {
418                             exc_class: func for exc_class, func in code_values.items()
419                         }
420                         for code, code_values in value.items()
421                     },
422                 )
423                 app.error_handler_spec[key] = value
424 
425             for endpoint, func in self.view_functions.items():
426                 app.view_functions[endpoint] = func
427 
428             extend(self.before_request_funcs, app.before_request_funcs)
429             extend(self.after_request_funcs, app.after_request_funcs)
430             extend(
431                 self.teardown_request_funcs,
432                 app.teardown_request_funcs,
433             )
434             extend(self.url_default_functions, app.url_default_functions)
435             extend(self.url_value_preprocessors, app.url_value_preprocessors)
436             extend(self.template_context_processors, app.template_context_processors)
437 
438         for deferred in self.deferred_functions:
439             deferred(state)
440 
441         cli_resolved_group = options.get("cli_group", self.cli_group)
442 
443         if self.cli.commands:
444             if cli_resolved_group is None:
445                 app.cli.commands.update(self.cli.commands)
446             elif cli_resolved_group is _sentinel:
447                 self.cli.name = name
448                 app.cli.add_command(self.cli)
449             else:
450                 self.cli.name = cli_resolved_group
451                 app.cli.add_command(self.cli)
452 
453         for blueprint, bp_options in self._blueprints:
454             bp_options = bp_options.copy()
455             bp_url_prefix = bp_options.get("url_prefix")
456 
457             if bp_url_prefix is None:
458                 bp_url_prefix = blueprint.url_prefix
459 
460             if state.url_prefix is not None and bp_url_prefix is not None:
461                 bp_options["url_prefix"] = (
462                     state.url_prefix.rstrip("/") + "/" + bp_url_prefix.lstrip("/")
463                 )
464             elif bp_url_prefix is not None:
465                 bp_options["url_prefix"] = bp_url_prefix
466             elif state.url_prefix is not None:
467                 bp_options["url_prefix"] = state.url_prefix
468 
469             bp_options["name_prefix"] = name
470             blueprint.register(app, bp_options)
471 
472     @setupmethod
473     def add_url_rule(
474         self,
475         rule: str,
476         endpoint: t.Optional[str] = None,
477         view_func: t.Optional[ft.RouteCallable] = None,
478         provide_automatic_options: t.Optional[bool] = None,
479         **options: t.Any,
480     ) -> None:
481         """Like :meth:`Flask.add_url_rule` but for a blueprint.  The endpoint for
482         the :func:`url_for` function is prefixed with the name of the blueprint.
483         """
484         if endpoint and "." in endpoint:
485             raise ValueError("'endpoint' may not contain a dot '.' character.")
486 
487         if view_func and hasattr(view_func, "__name__") and "." in view_func.__name__:
488             raise ValueError("'view_func' name may not contain a dot '.' character.")
489 
490         self.record(
491             lambda s: s.add_url_rule(
492                 rule,
493                 endpoint,
494                 view_func,
495                 provide_automatic_options=provide_automatic_options,
496                 **options,
497             )
498         )
499 
500     @setupmethod
501     def app_template_filter(
502         self, name: t.Optional[str] = None
503     ) -> t.Callable[[T_template_filter], T_template_filter]:
504         """Register a custom template filter, available application wide.  Like
505         :meth:`Flask.template_filter` but for a blueprint.
506 
507         :param name: the optional name of the filter, otherwise the
508                      function name will be used.
509         """
510 
511         def decorator(f: T_template_filter) -> T_template_filter:
512             self.add_app_template_filter(f, name=name)
513             return f
514 
515         return decorator
516 
517     @setupmethod
518     def add_app_template_filter(
519         self, f: ft.TemplateFilterCallable, name: t.Optional[str] = None
520     ) -> None:
521         """Register a custom template filter, available application wide.  Like
522         :meth:`Flask.add_template_filter` but for a blueprint.  Works exactly
523         like the :meth:`app_template_filter` decorator.
524 
525         :param name: the optional name of the filter, otherwise the
526                      function name will be used.
527         """
528 
529         def register_template(state: BlueprintSetupState) -> None:
530             state.app.jinja_env.filters[name or f.__name__] = f
531 
532         self.record_once(register_template)
533 
534     @setupmethod
535     def app_template_test(
536         self, name: t.Optional[str] = None
537     ) -> t.Callable[[T_template_test], T_template_test]:
538         """Register a custom template test, available application wide.  Like
539         :meth:`Flask.template_test` but for a blueprint.
540 
541         .. versionadded:: 0.10
542 
543         :param name: the optional name of the test, otherwise the
544                      function name will be used.
545         """
546 
547         def decorator(f: T_template_test) -> T_template_test:
548             self.add_app_template_test(f, name=name)
549             return f
550 
551         return decorator
552 
553     @setupmethod
554     def add_app_template_test(
555         self, f: ft.TemplateTestCallable, name: t.Optional[str] = None
556     ) -> None:
557         """Register a custom template test, available application wide.  Like
558         :meth:`Flask.add_template_test` but for a blueprint.  Works exactly
559         like the :meth:`app_template_test` decorator.
560 
561         .. versionadded:: 0.10
562 
563         :param name: the optional name of the test, otherwise the
564                      function name will be used.
565         """
566 
567         def register_template(state: BlueprintSetupState) -> None:
568             state.app.jinja_env.tests[name or f.__name__] = f
569 
570         self.record_once(register_template)
571 
572     @setupmethod
573     def app_template_global(
574         self, name: t.Optional[str] = None
575     ) -> t.Callable[[T_template_global], T_template_global]:
576         """Register a custom template global, available application wide.  Like
577         :meth:`Flask.template_global` but for a blueprint.
578 
579         .. versionadded:: 0.10
580 
581         :param name: the optional name of the global, otherwise the
582                      function name will be used.
583         """
584 
585         def decorator(f: T_template_global) -> T_template_global:
586             self.add_app_template_global(f, name=name)
587             return f
588 
589         return decorator
590 
591     @setupmethod
592     def add_app_template_global(
593         self, f: ft.TemplateGlobalCallable, name: t.Optional[str] = None
594     ) -> None:
595         """Register a custom template global, available application wide.  Like
596         :meth:`Flask.add_template_global` but for a blueprint.  Works exactly
597         like the :meth:`app_template_global` decorator.
598 
599         .. versionadded:: 0.10
600 
601         :param name: the optional name of the global, otherwise the
602                      function name will be used.
603         """
604 
605         def register_template(state: BlueprintSetupState) -> None:
606             state.app.jinja_env.globals[name or f.__name__] = f
607 
608         self.record_once(register_template)
609 
610     @setupmethod
611     def before_app_request(self, f: T_before_request) -> T_before_request:
612         """Like :meth:`Flask.before_request`.  Such a function is executed
613         before each request, even if outside of a blueprint.
614         """
615         self.record_once(
616             lambda s: s.app.before_request_funcs.setdefault(None, []).append(f)
617         )
618         return f
619 
620     @setupmethod
621     def before_app_first_request(
622         self, f: T_before_first_request
623     ) -> T_before_first_request:
624         """Like :meth:`Flask.before_first_request`.  Such a function is
625         executed before the first request to the application.
626 
627         .. deprecated:: 2.2
628             Will be removed in Flask 2.3. Run setup code when creating
629             the application instead.
630         """
631         import warnings
632 
633         warnings.warn(
634             "'before_app_first_request' is deprecated and will be"
635             " removed in Flask 2.3. Use 'record_once' instead to run"
636             " setup code when registering the blueprint.",
637             DeprecationWarning,
638             stacklevel=2,
639         )
640         self.record_once(lambda s: s.app.before_first_request_funcs.append(f))
641         return f
642 
643     @setupmethod
644     def after_app_request(self, f: T_after_request) -> T_after_request:
645         """Like :meth:`Flask.after_request` but for a blueprint.  Such a function
646         is executed after each request, even if outside of the blueprint.
647         """
648         self.record_once(
649             lambda s: s.app.after_request_funcs.setdefault(None, []).append(f)
650         )
651         return f
652 
653     @setupmethod
654     def teardown_app_request(self, f: T_teardown) -> T_teardown:
655         """Like :meth:`Flask.teardown_request` but for a blueprint.  Such a
656         function is executed when tearing down each request, even if outside of
657         the blueprint.
658         """
659         self.record_once(
660             lambda s: s.app.teardown_request_funcs.setdefault(None, []).append(f)
661         )
662         return f
663 
664     @setupmethod
665     def app_context_processor(
666         self, f: T_template_context_processor
667     ) -> T_template_context_processor:
668         """Like :meth:`Flask.context_processor` but for a blueprint.  Such a
669         function is executed each request, even if outside of the blueprint.
670         """
671         self.record_once(
672             lambda s: s.app.template_context_processors.setdefault(None, []).append(f)
673         )
674         return f
675 
676     @setupmethod
677     def app_errorhandler(
678         self, code: t.Union[t.Type[Exception], int]
679     ) -> t.Callable[[T_error_handler], T_error_handler]:
680         """Like :meth:`Flask.errorhandler` but for a blueprint.  This
681         handler is used for all requests, even if outside of the blueprint.
682         """
683 
684         def decorator(f: T_error_handler) -> T_error_handler:
685             self.record_once(lambda s: s.app.errorhandler(code)(f))
686             return f
687 
688         return decorator
689 
690     @setupmethod
691     def app_url_value_preprocessor(
692         self, f: T_url_value_preprocessor
693     ) -> T_url_value_preprocessor:
694         """Same as :meth:`url_value_preprocessor` but application wide."""
695         self.record_once(
696             lambda s: s.app.url_value_preprocessors.setdefault(None, []).append(f)
697         )
698         return f
699 
700     @setupmethod
701     def app_url_defaults(self, f: T_url_defaults) -> T_url_defaults:
702         """Same as :meth:`url_defaults` but application wide."""
703         self.record_once(
704             lambda s: s.app.url_default_functions.setdefault(None, []).append(f)
705         )
706         return f

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>, <file>src/flask/app.py</file>
<class>Flask</class>
<method>register_blueprint</method>
<code>
1274     def register_blueprint(self, blueprint: "Blueprint", **options: t.Any) -> None:
1275         """Register a :class:`~flask.Blueprint` on the application. Keyword
1276         arguments passed to this method will override the defaults set on the
1277         blueprint.
1278 
1279         Calls the blueprint's :meth:`~flask.Blueprint.register` method after
1280         recording the blueprint in the application's :attr:`blueprints`.
1281 
1282         :param blueprint: The blueprint to register.
1283         :param url_prefix: Blueprint routes will be prefixed with this.
1284         :param subdomain: Blueprint routes will match on this subdomain.
1285         :param url_defaults: Blueprint routes will use these default values for
1286             view arguments.
1287         :param options: Additional keyword arguments are passed to
1288             :class:`~flask.blueprints.BlueprintSetupState`. They can be
1289             accessed in :meth:`~flask.Blueprint.record` callbacks.
1290 
1291         .. versionchanged:: 2.0.1
1292             The ``name`` option can be used to change the (pre-dotted)
1293             name the blueprint is registered with. This allows the same
1294             blueprint to be registered multiple times with unique names
1295             for ``url_for``.
1296 
1297         .. versionadded:: 0.7
1298         """
1299         blueprint.register(self, options)

</code><intended_behavior>While this method might not directly exhibit a bug in the context provided by the search results, it could be an area to ensure integration of enhanced subdomain handling as described for `Blueprint.register`. The intended behavior would be to adjust or ensure that the blueprint registration process, specifically when handling subdomains, is robust and takes into consideration the inheritance of subdomains in nested blueprints. This might include verifying that the subdomain information is correctly passed on and utilized during the registration process, aligning with the enhancements suggested for the Blueprint class's `register` method. The goal is to provide a consistent and intuitive behavior when registering blueprints, respecting subdomains across both parent and nested blueprints without disrupting existing functionality or behaviors for other use cases.</intended_behavior>, <file>src/flask/app.py</file>
<class>Flask</class>
<method>None</method>
<code>
110 class Flask(Scaffold):
111     """The flask object implements a WSGI application and acts as the central
112     object.  It is passed the name of the module or package of the
113     application.  Once it is created it will act as a central registry for
114     the view functions, the URL rules, template configuration and much more.
115 
116     The name of the package is used to resolve resources from inside the
117     package or the folder the module is contained in depending on if the
118     package parameter resolves to an actual python package (a folder with
119     an :file:`__init__.py` file inside) or a standard module (just a ``.py`` file).
120 
121     For more information about resource loading, see :func:`open_resource`.
122 
123     Usually you create a :class:`Flask` instance in your main module or
124     in the :file:`__init__.py` file of your package like this::
125 
126         from flask import Flask
127         app = Flask(__name__)
128 
129     .. admonition:: About the First Parameter
130 
131         The idea of the first parameter is to give Flask an idea of what
132         belongs to your application.  This name is used to find resources
133         on the filesystem, can be used by extensions to improve debugging
134         information and a lot more.
135 
136         So it's important what you provide there.  If you are using a single
137         module, `__name__` is always the correct value.  If you however are
138         using a package, it's usually recommended to hardcode the name of
139         your package there.
140 
141         For example if your application is defined in :file:`yourapplication/app.py`
142         you should create it with one of the two versions below::
143 
144             app = Flask('yourapplication')
145             app = Flask(__name__.split('.')[0])
146 
147         Why is that?  The application will work even with `__name__`, thanks
148         to how resources are looked up.  However it will make debugging more
149         painful.  Certain extensions can make assumptions based on the
150         import name of your application.  For example the Flask-SQLAlchemy
151         extension will look for the code in your application that triggered
152         an SQL query in debug mode.  If the import name is not properly set
153         up, that debugging information is lost.  (For example it would only
154         pick up SQL queries in `yourapplication.app` and not
155         `yourapplication.views.frontend`)
156 
157     .. versionadded:: 0.7
158        The `static_url_path`, `static_folder`, and `template_folder`
159        parameters were added.
160 
161     .. versionadded:: 0.8
162        The `instance_path` and `instance_relative_config` parameters were
163        added.
164 
165     .. versionadded:: 0.11
166        The `root_path` parameter was added.
167 
168     .. versionadded:: 1.0
169        The ``host_matching`` and ``static_host`` parameters were added.
170 
171     .. versionadded:: 1.0
172        The ``subdomain_matching`` parameter was added. Subdomain
173        matching needs to be enabled manually now. Setting
174        :data:`SERVER_NAME` does not implicitly enable it.
175 
176     :param import_name: the name of the application package
177     :param static_url_path: can be used to specify a different path for the
178                             static files on the web.  Defaults to the name
179                             of the `static_folder` folder.
180     :param static_folder: The folder with static files that is served at
181         ``static_url_path``. Relative to the application ``root_path``
182         or an absolute path. Defaults to ``'static'``.
183     :param static_host: the host to use when adding the static route.
184         Defaults to None. Required when using ``host_matching=True``
185         with a ``static_folder`` configured.
186     :param host_matching: set ``url_map.host_matching`` attribute.
187         Defaults to False.
188     :param subdomain_matching: consider the subdomain relative to
189         :data:`SERVER_NAME` when matching routes. Defaults to False.
190     :param template_folder: the folder that contains the templates that should
191                             be used by the application.  Defaults to
192                             ``'templates'`` folder in the root path of the
193                             application.
194     :param instance_path: An alternative instance path for the application.
195                           By default the folder ``'instance'`` next to the
196                           package or module is assumed to be the instance
197                           path.
198     :param instance_relative_config: if set to ``True`` relative filenames
199                                      for loading the config are assumed to
200                                      be relative to the instance path instead
201                                      of the application root.
202     :param root_path: The path to the root of the application files.
203         This should only be set manually when it can't be detected
204         automatically, such as for namespace packages.
205     """
206 
207     #: The class that is used for request objects.  See :class:`~flask.Request`
208     #: for more information.
209     request_class = Request
210 
211     #: The class that is used for response objects.  See
212     #: :class:`~flask.Response` for more information.
213     response_class = Response
214 
215     #: The class of the object assigned to :attr:`aborter`, created by
216     #: :meth:`create_aborter`. That object is called by
217     #: :func:`flask.abort` to raise HTTP errors, and can be
218     #: called directly as well.
219     #:
220     #: Defaults to :class:`werkzeug.exceptions.Aborter`.
221     #:
222     #: .. versionadded:: 2.2
223     aborter_class = Aborter
224 
225     #: The class that is used for the Jinja environment.
226     #:
227     #: .. versionadded:: 0.11
228     jinja_environment = Environment
229 
230     #: The class that is used for the :data:`~flask.g` instance.
231     #:
232     #: Example use cases for a custom class:
233     #:
234     #: 1. Store arbitrary attributes on flask.g.
235     #: 2. Add a property for lazy per-request database connectors.
236     #: 3. Return None instead of AttributeError on unexpected attributes.
237     #: 4. Raise exception if an unexpected attr is set, a "controlled" flask.g.
238     #:
239     #: In Flask 0.9 this property was called `request_globals_class` but it
240     #: was changed in 0.10 to :attr:`app_ctx_globals_class` because the
241     #: flask.g object is now application context scoped.
242     #:
243     #: .. versionadded:: 0.10
244     app_ctx_globals_class = _AppCtxGlobals
245 
246     #: The class that is used for the ``config`` attribute of this app.
247     #: Defaults to :class:`~flask.Config`.
248     #:
249     #: Example use cases for a custom class:
250     #:
251     #: 1. Default values for certain config options.
252     #: 2. Access to config values through attributes in addition to keys.
253     #:
254     #: .. versionadded:: 0.11
255     config_class = Config
256 
257     #: The testing flag.  Set this to ``True`` to enable the test mode of
258     #: Flask extensions (and in the future probably also Flask itself).
259     #: For example this might activate test helpers that have an
260     #: additional runtime cost which should not be enabled by default.
261     #:
262     #: If this is enabled and PROPAGATE_EXCEPTIONS is not changed from the
263     #: default it's implicitly enabled.
264     #:
265     #: This attribute can also be configured from the config with the
266     #: ``TESTING`` configuration key.  Defaults to ``False``.
267     testing = ConfigAttribute("TESTING")
268 
269     #: If a secret key is set, cryptographic components can use this to
270     #: sign cookies and other things. Set this to a complex random value
271     #: when you want to use the secure cookie for instance.
272     #:
273     #: This attribute can also be configured from the config with the
274     #: :data:`SECRET_KEY` configuration key. Defaults to ``None``.
275     secret_key = ConfigAttribute("SECRET_KEY")
276 
277     @property
278     def session_cookie_name(self) -> str:
279         """The name of the cookie set by the session interface.
280 
281         .. deprecated:: 2.2
282             Will be removed in Flask 2.3. Use ``app.config["SESSION_COOKIE_NAME"]``
283             instead.
284         """
285         import warnings
286 
287         warnings.warn(
288             "'session_cookie_name' is deprecated and will be removed in Flask 2.3. Use"
289             " 'SESSION_COOKIE_NAME' in 'app.config' instead.",
290             DeprecationWarning,
291             stacklevel=2,
292         )
293         return self.config["SESSION_COOKIE_NAME"]
294 
295     @session_cookie_name.setter
296     def session_cookie_name(self, value: str) -> None:
297         import warnings
298 
299         warnings.warn(
300             "'session_cookie_name' is deprecated and will be removed in Flask 2.3. Use"
301             " 'SESSION_COOKIE_NAME' in 'app.config' instead.",
302             DeprecationWarning,
303             stacklevel=2,
304         )
305         self.config["SESSION_COOKIE_NAME"] = value
306 
307     #: A :class:`~datetime.timedelta` which is used to set the expiration
308     #: date of a permanent session.  The default is 31 days which makes a
309     #: permanent session survive for roughly one month.
310     #:
311     #: This attribute can also be configured from the config with the
312     #: ``PERMANENT_SESSION_LIFETIME`` configuration key.  Defaults to
313     #: ``timedelta(days=31)``
314     permanent_session_lifetime = ConfigAttribute(
315         "PERMANENT_SESSION_LIFETIME", get_converter=_make_timedelta
316     )
317 
318     @property
319     def send_file_max_age_default(self) -> t.Optional[timedelta]:
320         """The default value for ``max_age`` for :func:`~flask.send_file`. The default
321         is ``None``, which tells the browser to use conditional requests instead of a
322         timed cache.
323 
324         .. deprecated:: 2.2
325             Will be removed in Flask 2.3. Use
326             ``app.config["SEND_FILE_MAX_AGE_DEFAULT"]`` instead.
327 
328         .. versionchanged:: 2.0
329             Defaults to ``None`` instead of 12 hours.
330         """
331         import warnings
332 
333         warnings.warn(
334             "'send_file_max_age_default' is deprecated and will be removed in Flask"
335             " 2.3. Use 'SEND_FILE_MAX_AGE_DEFAULT' in 'app.config' instead.",
336             DeprecationWarning,
337             stacklevel=2,
338         )
339         return _make_timedelta(self.config["SEND_FILE_MAX_AGE_DEFAULT"])
340 
341     @send_file_max_age_default.setter
342     def send_file_max_age_default(self, value: t.Union[int, timedelta, None]) -> None:
343         import warnings
344 
345         warnings.warn(
346             "'send_file_max_age_default' is deprecated and will be removed in Flask"
347             " 2.3. Use 'SEND_FILE_MAX_AGE_DEFAULT' in 'app.config' instead.",
348             DeprecationWarning,
349             stacklevel=2,
350         )
351         self.config["SEND_FILE_MAX_AGE_DEFAULT"] = _make_timedelta(value)
352 
353     @property
354     def use_x_sendfile(self) -> bool:
355         """Enable this to use the ``X-Sendfile`` feature, assuming the server supports
356         it, from :func:`~flask.send_file`.
357 
358         .. deprecated:: 2.2
359             Will be removed in Flask 2.3. Use ``app.config["USE_X_SENDFILE"]`` instead.
360         """
361         import warnings
362 
363         warnings.warn(
364             "'use_x_sendfile' is deprecated and will be removed in Flask 2.3. Use"
365             " 'USE_X_SENDFILE' in 'app.config' instead.",
366             DeprecationWarning,
367             stacklevel=2,
368         )
369         return self.config["USE_X_SENDFILE"]
370 
371     @use_x_sendfile.setter
372     def use_x_sendfile(self, value: bool) -> None:
373         import warnings
374 
375         warnings.warn(
376             "'use_x_sendfile' is deprecated and will be removed in Flask 2.3. Use"
377             " 'USE_X_SENDFILE' in 'app.config' instead.",
378             DeprecationWarning,
379             stacklevel=2,
380         )
381         self.config["USE_X_SENDFILE"] = value
382 
383     _json_encoder: t.Union[t.Type[json.JSONEncoder], None] = None
384     _json_decoder: t.Union[t.Type[json.JSONDecoder], None] = None
385 
386     @property  # type: ignore[override]
387     def json_encoder(self) -> t.Type[json.JSONEncoder]:
388         """The JSON encoder class to use. Defaults to
389         :class:`~flask.json.JSONEncoder`.
390 
391         .. deprecated:: 2.2
392              Will be removed in Flask 2.3. Customize
393              :attr:`json_provider_class` instead.
394 
395         .. versionadded:: 0.10
396         """
397         import warnings
398 
399         warnings.warn(
400             "'app.json_encoder' is deprecated and will be removed in Flask 2.3."
401             " Customize 'app.json_provider_class' or 'app.json' instead.",
402             DeprecationWarning,
403             stacklevel=2,
404         )
405 
406         if self._json_encoder is None:
407             from . import json
408 
409             return json.JSONEncoder
410 
411         return self._json_encoder
412 
413     @json_encoder.setter
414     def json_encoder(self, value: t.Type[json.JSONEncoder]) -> None:
415         import warnings
416 
417         warnings.warn(
418             "'app.json_encoder' is deprecated and will be removed in Flask 2.3."
419             " Customize 'app.json_provider_class' or 'app.json' instead.",
420             DeprecationWarning,
421             stacklevel=2,
422         )
423         self._json_encoder = value
424 
425     @property  # type: ignore[override]
426     def json_decoder(self) -> t.Type[json.JSONDecoder]:
427         """The JSON decoder class to use. Defaults to
428         :class:`~flask.json.JSONDecoder`.
429 
430         .. deprecated:: 2.2
431              Will be removed in Flask 2.3. Customize
432              :attr:`json_provider_class` instead.
433 
434         .. versionadded:: 0.10
435         """
436         import warnings
437 
438         warnings.warn(
439             "'app.json_decoder' is deprecated and will be removed in Flask 2.3."
440             " Customize 'app.json_provider_class' or 'app.json' instead.",
441             DeprecationWarning,
442             stacklevel=2,
443         )
444 
445         if self._json_decoder is None:
446             from . import json
447 
448             return json.JSONDecoder
449 
450         return self._json_decoder
451 
452     @json_decoder.setter
453     def json_decoder(self, value: t.Type[json.JSONDecoder]) -> None:
454         import warnings
455 
456         warnings.warn(
457             "'app.json_decoder' is deprecated and will be removed in Flask 2.3."
458             " Customize 'app.json_provider_class' or 'app.json' instead.",
459             DeprecationWarning,
460             stacklevel=2,
461         )
462         self._json_decoder = value
463 
464     json_provider_class: t.Type[JSONProvider] = DefaultJSONProvider
465     """A subclass of :class:`~flask.json.provider.JSONProvider`. An
466     instance is created and assigned to :attr:`app.json` when creating
467     the app.
468 
469     The default, :class:`~flask.json.provider.DefaultJSONProvider`, uses
470     Python's built-in :mod:`json` library. A different provider can use
471     a different JSON library.
472 
473     .. versionadded:: 2.2
474     """
475 
476     #: Options that are passed to the Jinja environment in
477     #: :meth:`create_jinja_environment`. Changing these options after
478     #: the environment is created (accessing :attr:`jinja_env`) will
479     #: have no effect.
480     #:
481     #: .. versionchanged:: 1.1.0
482     #:     This is a ``dict`` instead of an ``ImmutableDict`` to allow
483     #:     easier configuration.
484     #:
485     jinja_options: dict = {}
486 
487     #: Default configuration parameters.
488     default_config = ImmutableDict(
489         {
490             "ENV": None,
491             "DEBUG": None,
492             "TESTING": False,
493             "PROPAGATE_EXCEPTIONS": None,
494             "SECRET_KEY": None,
495             "PERMANENT_SESSION_LIFETIME": timedelta(days=31),
496             "USE_X_SENDFILE": False,
497             "SERVER_NAME": None,
498             "APPLICATION_ROOT": "/",
499             "SESSION_COOKIE_NAME": "session",
500             "SESSION_COOKIE_DOMAIN": None,
501             "SESSION_COOKIE_PATH": None,
502             "SESSION_COOKIE_HTTPONLY": True,
503             "SESSION_COOKIE_SECURE": False,
504             "SESSION_COOKIE_SAMESITE": None,
505             "SESSION_REFRESH_EACH_REQUEST": True,
506             "MAX_CONTENT_LENGTH": None,
507             "SEND_FILE_MAX_AGE_DEFAULT": None,
508             "TRAP_BAD_REQUEST_ERRORS": None,
509             "TRAP_HTTP_EXCEPTIONS": False,
510             "EXPLAIN_TEMPLATE_LOADING": False,
511             "PREFERRED_URL_SCHEME": "http",
512             "JSON_AS_ASCII": None,
513             "JSON_SORT_KEYS": None,
514             "JSONIFY_PRETTYPRINT_REGULAR": None,
515             "JSONIFY_MIMETYPE": None,
516             "TEMPLATES_AUTO_RELOAD": None,
517             "MAX_COOKIE_SIZE": 4093,
518         }
519     )
520 
521     #: The rule object to use for URL rules created.  This is used by
522     #: :meth:`add_url_rule`.  Defaults to :class:`werkzeug.routing.Rule`.
523     #:
524     #: .. versionadded:: 0.7
525     url_rule_class = Rule
526 
527     #: The map object to use for storing the URL rules and routing
528     #: configuration parameters. Defaults to :class:`werkzeug.routing.Map`.
529     #:
530     #: .. versionadded:: 1.1.0
531     url_map_class = Map
532 
533     #: The :meth:`test_client` method creates an instance of this test
534     #: client class. Defaults to :class:`~flask.testing.FlaskClient`.
535     #:
536     #: .. versionadded:: 0.7
537     test_client_class: t.Optional[t.Type["FlaskClient"]] = None
538 
539     #: The :class:`~click.testing.CliRunner` subclass, by default
540     #: :class:`~flask.testing.FlaskCliRunner` that is used by
541     #: :meth:`test_cli_runner`. Its ``__init__`` method should take a
542     #: Flask app object as the first argument.
543     #:
544     #: .. versionadded:: 1.0
545     test_cli_runner_class: t.Optional[t.Type["FlaskCliRunner"]] = None
546 
547     #: the session interface to use.  By default an instance of
548     #: :class:`~flask.sessions.SecureCookieSessionInterface` is used here.
549     #:
550     #: .. versionadded:: 0.8
551     session_interface: SessionInterface = SecureCookieSessionInterface()
552 
553     def __init__(
554         self,
555         import_name: str,
556         static_url_path: t.Optional[str] = None,
557         static_folder: t.Optional[t.Union[str, os.PathLike]] = "static",
558         static_host: t.Optional[str] = None,
559         host_matching: bool = False,
560         subdomain_matching: bool = False,
561         template_folder: t.Optional[t.Union[str, os.PathLike]] = "templates",
562         instance_path: t.Optional[str] = None,
563         instance_relative_config: bool = False,
564         root_path: t.Optional[str] = None,
565     ):
566         super().__init__(
567             import_name=import_name,
568             static_folder=static_folder,
569             static_url_path=static_url_path,
570             template_folder=template_folder,
571             root_path=root_path,
572         )
573 
574         if instance_path is None:
575             instance_path = self.auto_find_instance_path()
576         elif not os.path.isabs(instance_path):
577             raise ValueError(
578                 "If an instance path is provided it must be absolute."
579                 " A relative path was given instead."
580             )
581 
582         #: Holds the path to the instance folder.
583         #:
584         #: .. versionadded:: 0.8
585         self.instance_path = instance_path
586 
587         #: The configuration dictionary as :class:`Config`.  This behaves
588         #: exactly like a regular dictionary but supports additional methods
589         #: to load a config from files.
590         self.config = self.make_config(instance_relative_config)
591 
592         #: An instance of :attr:`aborter_class` created by
593         #: :meth:`make_aborter`. This is called by :func:`flask.abort`
594         #: to raise HTTP errors, and can be called directly as well.
595         #:
596         #: .. versionadded:: 2.2
597         #:     Moved from ``flask.abort``, which calls this object.
598         self.aborter = self.make_aborter()
599 
600         self.json: JSONProvider = self.json_provider_class(self)
601         """Provides access to JSON methods. Functions in ``flask.json``
602         will call methods on this provider when the application context
603         is active. Used for handling JSON requests and responses.
604 
605         An instance of :attr:`json_provider_class`. Can be customized by
606         changing that attribute on a subclass, or by assigning to this
607         attribute afterwards.
608 
609         The default, :class:`~flask.json.provider.DefaultJSONProvider`,
610         uses Python's built-in :mod:`json` library. A different provider
611         can use a different JSON library.
612 
613         .. versionadded:: 2.2
614         """
615 
616         #: A list of functions that are called by
617         #: :meth:`handle_url_build_error` when :meth:`.url_for` raises a
618         #: :exc:`~werkzeug.routing.BuildError`. Each function is called
619         #: with ``error``, ``endpoint`` and ``values``. If a function
620         #: returns ``None`` or raises a ``BuildError``, it is skipped.
621         #: Otherwise, its return value is returned by ``url_for``.
622         #:
623         #: .. versionadded:: 0.9
624         self.url_build_error_handlers: t.List[
625             t.Callable[[Exception, str, t.Dict[str, t.Any]], str]
626         ] = []
627 
628         #: A list of functions that will be called at the beginning of the
629         #: first request to this instance. To register a function, use the
630         #: :meth:`before_first_request` decorator.
631         #:
632         #: .. deprecated:: 2.2
633         #:     Will be removed in Flask 2.3. Run setup code when
634         #:     creating the application instead.
635         #:
636         #: .. versionadded:: 0.8
637         self.before_first_request_funcs: t.List[ft.BeforeFirstRequestCallable] = []
638 
639         #: A list of functions that are called when the application context
640         #: is destroyed.  Since the application context is also torn down
641         #: if the request ends this is the place to store code that disconnects
642         #: from databases.
643         #:
644         #: .. versionadded:: 0.9
645         self.teardown_appcontext_funcs: t.List[ft.TeardownCallable] = []
646 
647         #: A list of shell context processor functions that should be run
648         #: when a shell context is created.
649         #:
650         #: .. versionadded:: 0.11
651         self.shell_context_processors: t.List[ft.ShellContextProcessorCallable] = []
652 
653         #: Maps registered blueprint names to blueprint objects. The
654         #: dict retains the order the blueprints were registered in.
655         #: Blueprints can be registered multiple times, this dict does
656         #: not track how often they were attached.
657         #:
658         #: .. versionadded:: 0.7
659         self.blueprints: t.Dict[str, "Blueprint"] = {}
660 
661         #: a place where extensions can store application specific state.  For
662         #: example this is where an extension could store database engines and
663         #: similar things.
664         #:
665         #: The key must match the name of the extension module. For example in
666         #: case of a "Flask-Foo" extension in `flask_foo`, the key would be
667         #: ``'foo'``.
668         #:
669         #: .. versionadded:: 0.7
670         self.extensions: dict = {}
671 
672         #: The :class:`~werkzeug.routing.Map` for this instance.  You can use
673         #: this to change the routing converters after the class was created
674         #: but before any routes are connected.  Example::
675         #:
676         #:    from werkzeug.routing import BaseConverter
677         #:
678         #:    class ListConverter(BaseConverter):
679         #:        def to_python(self, value):
680         #:            return value.split(',')
681         #:        def to_url(self, values):
682         #:            return ','.join(super(ListConverter, self).to_url(value)
683         #:                            for value in values)
684         #:
685         #:    app = Flask(__name__)
686         #:    app.url_map.converters['list'] = ListConverter
687         self.url_map = self.url_map_class()
688 
689         self.url_map.host_matching = host_matching
690         self.subdomain_matching = subdomain_matching
691 
692         # tracks internally if the application already handled at least one
693         # request.
694         self._got_first_request = False
695         self._before_request_lock = Lock()
696 
697         # Add a static route using the provided static_url_path, static_host,
698         # and static_folder if there is a configured static_folder.
699         # Note we do this without checking if static_folder exists.
700         # For one, it might be created while the server is running (e.g. during
701         # development). Also, Google App Engine stores static files somewhere
702         if self.has_static_folder:
703             assert (
704                 bool(static_host) == host_matching
705             ), "Invalid static_host/host_matching combination"
706             # Use a weakref to avoid creating a reference cycle between the app
707             # and the view function (see #3761).
708             self_ref = weakref.ref(self)
709             self.add_url_rule(
710                 f"{self.static_url_path}/<path:filename>",
711                 endpoint="static",
712                 host=static_host,
713                 view_func=lambda **kw: self_ref().send_static_file(**kw),  # type: ignore # noqa: B950
714             )
715 
716         # Set the name of the Click group in case someone wants to add
717         # the app's commands to another CLI tool.
718         self.cli.name = self.name
719 
720     def _check_setup_finished(self, f_name: str) -> None:
721         if self._got_first_request:
722             raise AssertionError(
723                 f"The setup method '{f_name}' can no longer be called"
724                 " on the application. It has already handled its first"
725                 " request, any changes will not be applied"
726                 " consistently.\n"
727                 "Make sure all imports, decorators, functions, etc."
728                 " needed to set up the application are done before"
729                 " running it."
730             )
731 
732     @locked_cached_property
733     def name(self) -> str:  # type: ignore
734         """The name of the application.  This is usually the import name
735         with the difference that it's guessed from the run file if the
736         import name is main.  This name is used as a display name when
737         Flask needs the name of the application.  It can be set and overridden
738         to change the value.
739 
740         .. versionadded:: 0.8
741         """
742         if self.import_name == "__main__":
743             fn = getattr(sys.modules["__main__"], "__file__", None)
744             if fn is None:
745                 return "__main__"
746             return os.path.splitext(os.path.basename(fn))[0]
747         return self.import_name
748 
749     @property
750     def propagate_exceptions(self) -> bool:
751         """Returns the value of the ``PROPAGATE_EXCEPTIONS`` configuration
752         value in case it's set, otherwise a sensible default is returned.
753 
754         .. deprecated:: 2.2
755             Will be removed in Flask 2.3.
756 
757         .. versionadded:: 0.7
758         """
759         import warnings
760 
761         warnings.warn(
762             "'propagate_exceptions' is deprecated and will be removed in Flask 2.3.",
763             DeprecationWarning,
764             stacklevel=2,
765         )
766         rv = self.config["PROPAGATE_EXCEPTIONS"]
767         if rv is not None:
768             return rv
769         return self.testing or self.debug
770 
771     @locked_cached_property
772     def logger(self) -> logging.Logger:
773         """A standard Python :class:`~logging.Logger` for the app, with
774         the same name as :attr:`name`.
775 
776         In debug mode, the logger's :attr:`~logging.Logger.level` will
777         be set to :data:`~logging.DEBUG`.
778 
779         If there are no handlers configured, a default handler will be
780         added. See :doc:`/logging` for more information.
781 
782         .. versionchanged:: 1.1.0
783             The logger takes the same name as :attr:`name` rather than
784             hard-coding ``"flask.app"``.
785 
786         .. versionchanged:: 1.0.0
787             Behavior was simplified. The logger is always named
788             ``"flask.app"``. The level is only set during configuration,
789             it doesn't check ``app.debug`` each time. Only one format is
790             used, not different ones depending on ``app.debug``. No
791             handlers are removed, and a handler is only added if no
792             handlers are already configured.
793 
794         .. versionadded:: 0.3
795         """
796         return create_logger(self)
797 
798     @locked_cached_property
799     def jinja_env(self) -> Environment:
800         """The Jinja environment used to load templates.
801 
802         The environment is created the first time this property is
803         accessed. Changing :attr:`jinja_options` after that will have no
804         effect.
805         """
806         return self.create_jinja_environment()
807 
808     @property
809     def got_first_request(self) -> bool:
810         """This attribute is set to ``True`` if the application started
811         handling the first request.
812 
813         .. versionadded:: 0.8
814         """
815         return self._got_first_request
816 
817     def make_config(self, instance_relative: bool = False) -> Config:
818         """Used to create the config attribute by the Flask constructor.
819         The `instance_relative` parameter is passed in from the constructor
820         of Flask (there named `instance_relative_config`) and indicates if
821         the config should be relative to the instance path or the root path
822         of the application.
823 
824         .. versionadded:: 0.8
825         """
826         root_path = self.root_path
827         if instance_relative:
828             root_path = self.instance_path
829         defaults = dict(self.default_config)
830         defaults["ENV"] = os.environ.get("FLASK_ENV") or "production"
831         defaults["DEBUG"] = get_debug_flag()
832         return self.config_class(root_path, defaults)
833 
834     def make_aborter(self) -> Aborter:
835         """Create the object to assign to :attr:`aborter`. That object
836         is called by :func:`flask.abort` to raise HTTP errors, and can
837         be called directly as well.
838 
839         By default, this creates an instance of :attr:`aborter_class`,
840         which defaults to :class:`werkzeug.exceptions.Aborter`.
841 
842         .. versionadded:: 2.2
843         """
844         return self.aborter_class()
845 
846     def auto_find_instance_path(self) -> str:
847         """Tries to locate the instance path if it was not provided to the
848         constructor of the application class.  It will basically calculate
849         the path to a folder named ``instance`` next to your main file or
850         the package.
851 
852         .. versionadded:: 0.8
853         """
854         prefix, package_path = find_package(self.import_name)
855         if prefix is None:
856             return os.path.join(package_path, "instance")
857         return os.path.join(prefix, "var", f"{self.name}-instance")
858 
859     def open_instance_resource(self, resource: str, mode: str = "rb") -> t.IO[t.AnyStr]:
860         """Opens a resource from the application's instance folder
861         (:attr:`instance_path`).  Otherwise works like
862         :meth:`open_resource`.  Instance resources can also be opened for
863         writing.
864 
865         :param resource: the name of the resource.  To access resources within
866                          subfolders use forward slashes as separator.
867         :param mode: resource file opening mode, default is 'rb'.
868         """
869         return open(os.path.join(self.instance_path, resource), mode)
870 
871     @property
872     def templates_auto_reload(self) -> bool:
873         """Reload templates when they are changed. Used by
874         :meth:`create_jinja_environment`. It is enabled by default in debug mode.
875 
876         .. deprecated:: 2.2
877             Will be removed in Flask 2.3. Use ``app.config["TEMPLATES_AUTO_RELOAD"]``
878             instead.
879 
880         .. versionadded:: 1.0
881             This property was added but the underlying config and behavior
882             already existed.
883         """
884         import warnings
885 
886         warnings.warn(
887             "'templates_auto_reload' is deprecated and will be removed in Flask 2.3."
888             " Use 'TEMPLATES_AUTO_RELOAD' in 'app.config' instead.",
889             DeprecationWarning,
890             stacklevel=2,
891         )
892         rv = self.config["TEMPLATES_AUTO_RELOAD"]
893         return rv if rv is not None else self.debug
894 
895     @templates_auto_reload.setter
896     def templates_auto_reload(self, value: bool) -> None:
897         import warnings
898 
899         warnings.warn(
900             "'templates_auto_reload' is deprecated and will be removed in Flask 2.3."
901             " Use 'TEMPLATES_AUTO_RELOAD' in 'app.config' instead.",
902             DeprecationWarning,
903             stacklevel=2,
904         )
905         self.config["TEMPLATES_AUTO_RELOAD"] = value
906 
907     def create_jinja_environment(self) -> Environment:
908         """Create the Jinja environment based on :attr:`jinja_options`
909         and the various Jinja-related methods of the app. Changing
910         :attr:`jinja_options` after this will have no effect. Also adds
911         Flask-related globals and filters to the environment.
912 
913         .. versionchanged:: 0.11
914            ``Environment.auto_reload`` set in accordance with
915            ``TEMPLATES_AUTO_RELOAD`` configuration option.
916 
917         .. versionadded:: 0.5
918         """
919         options = dict(self.jinja_options)
920 
921         if "autoescape" not in options:
922             options["autoescape"] = self.select_jinja_autoescape
923 
924         if "auto_reload" not in options:
925             auto_reload = self.config["TEMPLATES_AUTO_RELOAD"]
926 
927             if auto_reload is None:
928                 auto_reload = self.debug
929 
930             options["auto_reload"] = auto_reload
931 
932         rv = self.jinja_environment(self, **options)
933         rv.globals.update(
934             url_for=self.url_for,
935             get_flashed_messages=get_flashed_messages,
936             config=self.config,
937             # request, session and g are normally added with the
938             # context processor for efficiency reasons but for imported
939             # templates we also want the proxies in there.
940             request=request,
941             session=session,
942             g=g,
943         )
944         rv.policies["json.dumps_function"] = self.json.dumps
945         return rv
946 
947     def create_global_jinja_loader(self) -> DispatchingJinjaLoader:
948         """Creates the loader for the Jinja2 environment.  Can be used to
949         override just the loader and keeping the rest unchanged.  It's
950         discouraged to override this function.  Instead one should override
951         the :meth:`jinja_loader` function instead.
952 
953         The global loader dispatches between the loaders of the application
954         and the individual blueprints.
955 
956         .. versionadded:: 0.7
957         """
958         return DispatchingJinjaLoader(self)
959 
960     def select_jinja_autoescape(self, filename: str) -> bool:
961         """Returns ``True`` if autoescaping should be active for the given
962         template name. If no template name is given, returns `True`.
963 
964         .. versionchanged:: 2.2
965             Autoescaping is now enabled by default for ``.svg`` files.
966 
967         .. versionadded:: 0.5
968         """
969         if filename is None:
970             return True
971         return filename.endswith((".html", ".htm", ".xml", ".xhtml", ".svg"))
972 
973     def update_template_context(self, context: dict) -> None:
974         """Update the template context with some commonly used variables.
975         This injects request, session, config and g into the template
976         context as well as everything template context processors want
977         to inject.  Note that the as of Flask 0.6, the original values
978         in the context will not be overridden if a context processor
979         decides to return a value with the same key.
980 
981         :param context: the context as a dictionary that is updated in place
982                         to add extra variables.
983         """
984         names: t.Iterable[t.Optional[str]] = (None,)
985 
986         # A template may be rendered outside a request context.
987         if request:
988             names = chain(names, reversed(request.blueprints))
989 
990         # The values passed to render_template take precedence. Keep a
991         # copy to re-apply after all context functions.
992         orig_ctx = context.copy()
993 
994         for name in names:
995             if name in self.template_context_processors:
996                 for func in self.template_context_processors[name]:
997                     context.update(func())
998 
999         context.update(orig_ctx)
1000 
1001     def make_shell_context(self) -> dict:
1002         """Returns the shell context for an interactive shell for this
1003         application.  This runs all the registered shell context
1004         processors.
1005 
1006         .. versionadded:: 0.11
1007         """
1008         rv = {"app": self, "g": g}
1009         for processor in self.shell_context_processors:
1010             rv.update(processor())
1011         return rv
1012 
1013     @property
1014     def env(self) -> str:
1015         """What environment the app is running in. This maps to the :data:`ENV` config
1016         key.
1017 
1018         **Do not enable development when deploying in production.**
1019 
1020         Default: ``'production'``
1021 
1022         .. deprecated:: 2.2
1023             Will be removed in Flask 2.3.
1024         """
1025         import warnings
1026 
1027         warnings.warn(
1028             "'app.env' is deprecated and will be removed in Flask 2.3."
1029             " Use 'app.debug' instead.",
1030             DeprecationWarning,
1031             stacklevel=2,
1032         )
1033         return self.config["ENV"]
1034 
1035     @env.setter
1036     def env(self, value: str) -> None:
1037         import warnings
1038 
1039         warnings.warn(
1040             "'app.env' is deprecated and will be removed in Flask 2.3."
1041             " Use 'app.debug' instead.",
1042             DeprecationWarning,
1043             stacklevel=2,
1044         )
1045         self.config["ENV"] = value
1046 
1047     @property
1048     def debug(self) -> bool:
1049         """Whether debug mode is enabled. When using ``flask run`` to start the
1050         development server, an interactive debugger will be shown for unhandled
1051         exceptions, and the server will be reloaded when code changes. This maps to the
1052         :data:`DEBUG` config key. It may not behave as expected if set late.
1053 
1054         **Do not enable debug mode when deploying in production.**
1055 
1056         Default: ``False``
1057         """
1058         return self.config["DEBUG"]
1059 
1060     @debug.setter
1061     def debug(self, value: bool) -> None:
1062         self.config["DEBUG"] = value
1063 
1064         if self.config["TEMPLATES_AUTO_RELOAD"] is None:
1065             self.jinja_env.auto_reload = value
1066 
1067     def run(
1068         self,
1069         host: t.Optional[str] = None,
1070         port: t.Optional[int] = None,
1071         debug: t.Optional[bool] = None,
1072         load_dotenv: bool = True,
1073         **options: t.Any,
1074     ) -> None:
1075         """Runs the application on a local development server.
1076 
1077         Do not use ``run()`` in a production setting. It is not intended to
1078         meet security and performance requirements for a production server.
1079         Instead, see :doc:`/deploying/index` for WSGI server recommendations.
1080 
1081         If the :attr:`debug` flag is set the server will automatically reload
1082         for code changes and show a debugger in case an exception happened.
1083 
1084         If you want to run the application in debug mode, but disable the
1085         code execution on the interactive debugger, you can pass
1086         ``use_evalex=False`` as parameter.  This will keep the debugger's
1087         traceback screen active, but disable code execution.
1088 
1089         It is not recommended to use this function for development with
1090         automatic reloading as this is badly supported.  Instead you should
1091         be using the :command:`flask` command line script's ``run`` support.
1092 
1093         .. admonition:: Keep in Mind
1094 
1095            Flask will suppress any server error with a generic error page
1096            unless it is in debug mode.  As such to enable just the
1097            interactive debugger without the code reloading, you have to
1098            invoke :meth:`run` with ``debug=True`` and ``use_reloader=False``.
1099            Setting ``use_debugger`` to ``True`` without being in debug mode
1100            won't catch any exceptions because there won't be any to
1101            catch.
1102 
1103         :param host: the hostname to listen on. Set this to ``'0.0.0.0'`` to
1104             have the server available externally as well. Defaults to
1105             ``'127.0.0.1'`` or the host in the ``SERVER_NAME`` config variable
1106             if present.
1107         :param port: the port of the webserver. Defaults to ``5000`` or the
1108             port defined in the ``SERVER_NAME`` config variable if present.
1109         :param debug: if given, enable or disable debug mode. See
1110             :attr:`debug`.
1111         :param load_dotenv: Load the nearest :file:`.env` and :file:`.flaskenv`
1112             files to set environment variables. Will also change the working
1113             directory to the directory containing the first file found.
1114         :param options: the options to be forwarded to the underlying Werkzeug
1115             server. See :func:`werkzeug.serving.run_simple` for more
1116             information.
1117 
1118         .. versionchanged:: 1.0
1119             If installed, python-dotenv will be used to load environment
1120             variables from :file:`.env` and :file:`.flaskenv` files.
1121 
1122             The :envvar:`FLASK_DEBUG` environment variable will override :attr:`debug`.
1123 
1124             Threaded mode is enabled by default.
1125 
1126         .. versionchanged:: 0.10
1127             The default port is now picked from the ``SERVER_NAME``
1128             variable.
1129         """
1130         # Ignore this call so that it doesn't start another server if
1131         # the 'flask run' command is used.
1132         if os.environ.get("FLASK_RUN_FROM_CLI") == "true":
1133             if not is_running_from_reloader():
1134                 click.secho(
1135                     " * Ignoring a call to 'app.run()' that would block"
1136                     " the current 'flask' CLI command.\n"
1137                     "   Only call 'app.run()' in an 'if __name__ =="
1138                     ' "__main__"\' guard.',
1139                     fg="red",
1140                 )
1141 
1142             return
1143 
1144         if get_load_dotenv(load_dotenv):
1145             cli.load_dotenv()
1146 
1147             # if set, let env vars override previous values
1148             if "FLASK_ENV" in os.environ:
1149                 print(
1150                     "'FLASK_ENV' is deprecated and will not be used in"
1151                     " Flask 2.3. Use 'FLASK_DEBUG' instead.",
1152                     file=sys.stderr,
1153                 )
1154                 self.config["ENV"] = os.environ.get("FLASK_ENV") or "production"
1155                 self.debug = get_debug_flag()
1156             elif "FLASK_DEBUG" in os.environ:
1157                 self.debug = get_debug_flag()
1158 
1159         # debug passed to method overrides all other sources
1160         if debug is not None:
1161             self.debug = bool(debug)
1162 
1163         server_name = self.config.get("SERVER_NAME")
1164         sn_host = sn_port = None
1165 
1166         if server_name:
1167             sn_host, _, sn_port = server_name.partition(":")
1168 
1169         if not host:
1170             if sn_host:
1171                 host = sn_host
1172             else:
1173                 host = "127.0.0.1"
1174 
1175         if port or port == 0:
1176             port = int(port)
1177         elif sn_port:
1178             port = int(sn_port)
1179         else:
1180             port = 5000
1181 
1182         options.setdefault("use_reloader", self.debug)
1183         options.setdefault("use_debugger", self.debug)
1184         options.setdefault("threaded", True)
1185 
1186         cli.show_server_banner(self.debug, self.name)
1187 
1188         from werkzeug.serving import run_simple
1189 
1190         try:
1191             run_simple(t.cast(str, host), port, self, **options)
1192         finally:
1193             # reset the first request information if the development server
1194             # reset normally.  This makes it possible to restart the server
1195             # without reloader and that stuff from an interactive shell.
1196             self._got_first_request = False
1197 
1198     def test_client(self, use_cookies: bool = True, **kwargs: t.Any) -> "FlaskClient":
1199         """Creates a test client for this application.  For information
1200         about unit testing head over to :doc:`/testing`.
1201 
1202         Note that if you are testing for assertions or exceptions in your
1203         application code, you must set ``app.testing = True`` in order for the
1204         exceptions to propagate to the test client.  Otherwise, the exception
1205         will be handled by the application (not visible to the test client) and
1206         the only indication of an AssertionError or other exception will be a
1207         500 status code response to the test client.  See the :attr:`testing`
1208         attribute.  For example::
1209 
1210             app.testing = True
1211             client = app.test_client()
1212 
1213         The test client can be used in a ``with`` block to defer the closing down
1214         of the context until the end of the ``with`` block.  This is useful if
1215         you want to access the context locals for testing::
1216 
1217             with app.test_client() as c:
1218                 rv = c.get('/?vodka=42')
1219                 assert request.args['vodka'] == '42'
1220 
1221         Additionally, you may pass optional keyword arguments that will then
1222         be passed to the application's :attr:`test_client_class` constructor.
1223         For example::
1224 
1225             from flask.testing import FlaskClient
1226 
1227             class CustomClient(FlaskClient):
1228                 def __init__(self, *args, **kwargs):
1229                     self._authentication = kwargs.pop("authentication")
1230                     super(CustomClient,self).__init__( *args, **kwargs)
1231 
1232             app.test_client_class = CustomClient
1233             client = app.test_client(authentication='Basic ....')
1234 
1235         See :class:`~flask.testing.FlaskClient` for more information.
1236 
1237         .. versionchanged:: 0.4
1238            added support for ``with`` block usage for the client.
1239 
1240         .. versionadded:: 0.7
1241            The `use_cookies` parameter was added as well as the ability
1242            to override the client to be used by setting the
1243            :attr:`test_client_class` attribute.
1244 
1245         .. versionchanged:: 0.11
1246            Added `**kwargs` to support passing additional keyword arguments to
1247            the constructor of :attr:`test_client_class`.
1248         """
1249         cls = self.test_client_class
1250         if cls is None:
1251             from .testing import FlaskClient as cls  # type: ignore
1252         return cls(  # type: ignore
1253             self, self.response_class, use_cookies=use_cookies, **kwargs
1254         )
1255 
1256     def test_cli_runner(self, **kwargs: t.Any) -> "FlaskCliRunner":
1257         """Create a CLI runner for testing CLI commands.
1258         See :ref:`testing-cli`.
1259 
1260         Returns an instance of :attr:`test_cli_runner_class`, by default
1261         :class:`~flask.testing.FlaskCliRunner`. The Flask app object is
1262         passed as the first argument.
1263 
1264         .. versionadded:: 1.0
1265         """
1266         cls = self.test_cli_runner_class
1267 
1268         if cls is None:
1269             from .testing import FlaskCliRunner as cls  # type: ignore
1270 
1271         return cls(self, **kwargs)  # type: ignore
1272 
1273     @setupmethod
1274     def register_blueprint(self, blueprint: "Blueprint", **options: t.Any) -> None:
1275         """Register a :class:`~flask.Blueprint` on the application. Keyword
1276         arguments passed to this method will override the defaults set on the
1277         blueprint.
1278 
1279         Calls the blueprint's :meth:`~flask.Blueprint.register` method after
1280         recording the blueprint in the application's :attr:`blueprints`.
1281 
1282         :param blueprint: The blueprint to register.
1283         :param url_prefix: Blueprint routes will be prefixed with this.
1284         :param subdomain: Blueprint routes will match on this subdomain.
1285         :param url_defaults: Blueprint routes will use these default values for
1286             view arguments.
1287         :param options: Additional keyword arguments are passed to
1288             :class:`~flask.blueprints.BlueprintSetupState`. They can be
1289             accessed in :meth:`~flask.Blueprint.record` callbacks.
1290 
1291         .. versionchanged:: 2.0.1
1292             The ``name`` option can be used to change the (pre-dotted)
1293             name the blueprint is registered with. This allows the same
1294             blueprint to be registered multiple times with unique names
1295             for ``url_for``.
1296 
1297         .. versionadded:: 0.7
1298         """
1299         blueprint.register(self, options)
1300 
1301     def iter_blueprints(self) -> t.ValuesView["Blueprint"]:
1302         """Iterates over all blueprints by the order they were registered.
1303 
1304         .. versionadded:: 0.11
1305         """
1306         return self.blueprints.values()
1307 
1308     @setupmethod
1309     def add_url_rule(
1310         self,
1311         rule: str,
1312         endpoint: t.Optional[str] = None,
1313         view_func: t.Optional[ft.RouteCallable] = None,
1314         provide_automatic_options: t.Optional[bool] = None,
1315         **options: t.Any,
1316     ) -> None:
1317         if endpoint is None:
1318             endpoint = _endpoint_from_view_func(view_func)  # type: ignore
1319         options["endpoint"] = endpoint
1320         methods = options.pop("methods", None)
1321 
1322         # if the methods are not given and the view_func object knows its
1323         # methods we can use that instead.  If neither exists, we go with
1324         # a tuple of only ``GET`` as default.
1325         if methods is None:
1326             methods = getattr(view_func, "methods", None) or ("GET",)
1327         if isinstance(methods, str):
1328             raise TypeError(
1329                 "Allowed methods must be a list of strings, for"
1330                 ' example: @app.route(..., methods=["POST"])'
1331             )
1332         methods = {item.upper() for item in methods}
1333 
1334         # Methods that should always be added
1335         required_methods = set(getattr(view_func, "required_methods", ()))
1336 
1337         # starting with Flask 0.8 the view_func object can disable and
1338         # force-enable the automatic options handling.
1339         if provide_automatic_options is None:
1340             provide_automatic_options = getattr(
1341                 view_func, "provide_automatic_options", None
1342             )
1343 
1344         if provide_automatic_options is None:
1345             if "OPTIONS" not in methods:
1346                 provide_automatic_options = True
1347                 required_methods.add("OPTIONS")
1348             else:
1349                 provide_automatic_options = False
1350 
1351         # Add the required methods now.
1352         methods |= required_methods
1353 
1354         rule = self.url_rule_class(rule, methods=methods, **options)
1355         rule.provide_automatic_options = provide_automatic_options  # type: ignore
1356 
1357         self.url_map.add(rule)
1358         if view_func is not None:
1359             old_func = self.view_functions.get(endpoint)
1360             if old_func is not None and old_func != view_func:
1361                 raise AssertionError(
1362                     "View function mapping is overwriting an existing"
1363                     f" endpoint function: {endpoint}"
1364                 )
1365             self.view_functions[endpoint] = view_func
1366 
1367     @setupmethod
1368     def template_filter(
1369         self, name: t.Optional[str] = None
1370     ) -> t.Callable[[T_template_filter], T_template_filter]:
1371         """A decorator that is used to register custom template filter.
1372         You can specify a name for the filter, otherwise the function
1373         name will be used. Example::
1374 
1375           @app.template_filter()
1376           def reverse(s):
1377               return s[::-1]
1378 
1379         :param name: the optional name of the filter, otherwise the
1380                      function name will be used.
1381         """
1382 
1383         def decorator(f: T_template_filter) -> T_template_filter:
1384             self.add_template_filter(f, name=name)
1385             return f
1386 
1387         return decorator
1388 
1389     @setupmethod
1390     def add_template_filter(
1391         self, f: ft.TemplateFilterCallable, name: t.Optional[str] = None
1392     ) -> None:
1393         """Register a custom template filter.  Works exactly like the
1394         :meth:`template_filter` decorator.
1395 
1396         :param name: the optional name of the filter, otherwise the
1397                      function name will be used.
1398         """
1399         self.jinja_env.filters[name or f.__name__] = f
1400 
1401     @setupmethod
1402     def template_test(
1403         self, name: t.Optional[str] = None
1404     ) -> t.Callable[[T_template_test], T_template_test]:
1405         """A decorator that is used to register custom template test.
1406         You can specify a name for the test, otherwise the function
1407         name will be used. Example::
1408 
1409           @app.template_test()
1410           def is_prime(n):
1411               if n == 2:
1412                   return True
1413               for i in range(2, int(math.ceil(math.sqrt(n))) + 1):
1414                   if n % i == 0:
1415                       return False
1416               return True
1417 
1418         .. versionadded:: 0.10
1419 
1420         :param name: the optional name of the test, otherwise the
1421                      function name will be used.
1422         """
1423 
1424         def decorator(f: T_template_test) -> T_template_test:
1425             self.add_template_test(f, name=name)
1426             return f
1427 
1428         return decorator
1429 
1430     @setupmethod
1431     def add_template_test(
1432         self, f: ft.TemplateTestCallable, name: t.Optional[str] = None
1433     ) -> None:
1434         """Register a custom template test.  Works exactly like the
1435         :meth:`template_test` decorator.
1436 
1437         .. versionadded:: 0.10
1438 
1439         :param name: the optional name of the test, otherwise the
1440                      function name will be used.
1441         """
1442         self.jinja_env.tests[name or f.__name__] = f
1443 
1444     @setupmethod
1445     def template_global(
1446         self, name: t.Optional[str] = None
1447     ) -> t.Callable[[T_template_global], T_template_global]:
1448         """A decorator that is used to register a custom template global function.
1449         You can specify a name for the global function, otherwise the function
1450         name will be used. Example::
1451 
1452             @app.template_global()
1453             def double(n):
1454                 return 2 * n
1455 
1456         .. versionadded:: 0.10
1457 
1458         :param name: the optional name of the global function, otherwise the
1459                      function name will be used.
1460         """
1461 
1462         def decorator(f: T_template_global) -> T_template_global:
1463             self.add_template_global(f, name=name)
1464             return f
1465 
1466         return decorator
1467 
1468     @setupmethod
1469     def add_template_global(
1470         self, f: ft.TemplateGlobalCallable, name: t.Optional[str] = None
1471     ) -> None:
1472         """Register a custom template global function. Works exactly like the
1473         :meth:`template_global` decorator.
1474 
1475         .. versionadded:: 0.10
1476 
1477         :param name: the optional name of the global function, otherwise the
1478                      function name will be used.
1479         """
1480         self.jinja_env.globals[name or f.__name__] = f
1481 
1482     @setupmethod
1483     def before_first_request(self, f: T_before_first_request) -> T_before_first_request:
1484         """Registers a function to be run before the first request to this
1485         instance of the application.
1486 
1487         The function will be called without any arguments and its return
1488         value is ignored.
1489 
1490         .. deprecated:: 2.2
1491             Will be removed in Flask 2.3. Run setup code when creating
1492             the application instead.
1493 
1494         .. versionadded:: 0.8
1495         """
1496         import warnings
1497 
1498         warnings.warn(
1499             "'before_first_request' is deprecated and will be removed"
1500             " in Flask 2.3. Run setup code while creating the"
1501             " application instead.",
1502             DeprecationWarning,
1503             stacklevel=2,
1504         )
1505         self.before_first_request_funcs.append(f)
1506         return f
1507 
1508     @setupmethod
1509     def teardown_appcontext(self, f: T_teardown) -> T_teardown:
1510         """Registers a function to be called when the application
1511         context is popped. The application context is typically popped
1512         after the request context for each request, at the end of CLI
1513         commands, or after a manually pushed context ends.
1514 
1515         .. code-block:: python
1516 
1517             with app.app_context():
1518                 ...
1519 
1520         When the ``with`` block exits (or ``ctx.pop()`` is called), the
1521         teardown functions are called just before the app context is
1522         made inactive. Since a request context typically also manages an
1523         application context it would also be called when you pop a
1524         request context.
1525 
1526         When a teardown function was called because of an unhandled
1527         exception it will be passed an error object. If an
1528         :meth:`errorhandler` is registered, it will handle the exception
1529         and the teardown will not receive it.
1530 
1531         Teardown functions must avoid raising exceptions. If they
1532         execute code that might fail they must surround that code with a
1533         ``try``/``except`` block and log any errors.
1534 
1535         The return values of teardown functions are ignored.
1536 
1537         .. versionadded:: 0.9
1538         """
1539         self.teardown_appcontext_funcs.append(f)
1540         return f
1541 
1542     @setupmethod
1543     def shell_context_processor(
1544         self, f: T_shell_context_processor
1545     ) -> T_shell_context_processor:
1546         """Registers a shell context processor function.
1547 
1548         .. versionadded:: 0.11
1549         """
1550         self.shell_context_processors.append(f)
1551         return f
1552 
1553     def _find_error_handler(self, e: Exception) -> t.Optional[ft.ErrorHandlerCallable]:
1554         """Return a registered error handler for an exception in this order:
1555         blueprint handler for a specific code, app handler for a specific code,
1556         blueprint handler for an exception class, app handler for an exception
1557         class, or ``None`` if a suitable handler is not found.
1558         """
1559         exc_class, code = self._get_exc_class_and_code(type(e))
1560         names = (*request.blueprints, None)
1561 
1562         for c in (code, None) if code is not None else (None,):
1563             for name in names:
1564                 handler_map = self.error_handler_spec[name][c]
1565 
1566                 if not handler_map:
1567                     continue
1568 
1569                 for cls in exc_class.__mro__:
1570                     handler = handler_map.get(cls)
1571 
1572                     if handler is not None:
1573                         return handler
1574         return None
1575 
1576     def handle_http_exception(
1577         self, e: HTTPException
1578     ) -> t.Union[HTTPException, ft.ResponseReturnValue]:
1579         """Handles an HTTP exception.  By default this will invoke the
1580         registered error handlers and fall back to returning the
1581         exception as response.
1582 
1583         .. versionchanged:: 1.0.3
1584             ``RoutingException``, used internally for actions such as
1585              slash redirects during routing, is not passed to error
1586              handlers.
1587 
1588         .. versionchanged:: 1.0
1589             Exceptions are looked up by code *and* by MRO, so
1590             ``HTTPException`` subclasses can be handled with a catch-all
1591             handler for the base ``HTTPException``.
1592 
1593         .. versionadded:: 0.3
1594         """
1595         # Proxy exceptions don't have error codes.  We want to always return
1596         # those unchanged as errors
1597         if e.code is None:
1598             return e
1599 
1600         # RoutingExceptions are used internally to trigger routing
1601         # actions, such as slash redirects raising RequestRedirect. They
1602         # are not raised or handled in user code.
1603         if isinstance(e, RoutingException):
1604             return e
1605 
1606         handler = self._find_error_handler(e)
1607         if handler is None:
1608             return e
1609         return self.ensure_sync(handler)(e)
1610 
1611     def trap_http_exception(self, e: Exception) -> bool:
1612         """Checks if an HTTP exception should be trapped or not.  By default
1613         this will return ``False`` for all exceptions except for a bad request
1614         key error if ``TRAP_BAD_REQUEST_ERRORS`` is set to ``True``.  It
1615         also returns ``True`` if ``TRAP_HTTP_EXCEPTIONS`` is set to ``True``.
1616 
1617         This is called for all HTTP exceptions raised by a view function.
1618         If it returns ``True`` for any exception the error handler for this
1619         exception is not called and it shows up as regular exception in the
1620         traceback.  This is helpful for debugging implicitly raised HTTP
1621         exceptions.
1622 
1623         .. versionchanged:: 1.0
1624             Bad request errors are not trapped by default in debug mode.
1625 
1626         .. versionadded:: 0.8
1627         """
1628         if self.config["TRAP_HTTP_EXCEPTIONS"]:
1629             return True
1630 
1631         trap_bad_request = self.config["TRAP_BAD_REQUEST_ERRORS"]
1632 
1633         # if unset, trap key errors in debug mode
1634         if (
1635             trap_bad_request is None
1636             and self.debug
1637             and isinstance(e, BadRequestKeyError)
1638         ):
1639             return True
1640 
1641         if trap_bad_request:
1642             return isinstance(e, BadRequest)
1643 
1644         return False
1645 
1646     def handle_user_exception(
1647         self, e: Exception
1648     ) -> t.Union[HTTPException, ft.ResponseReturnValue]:
1649         """This method is called whenever an exception occurs that
1650         should be handled. A special case is :class:`~werkzeug
1651         .exceptions.HTTPException` which is forwarded to the
1652         :meth:`handle_http_exception` method. This function will either
1653         return a response value or reraise the exception with the same
1654         traceback.
1655 
1656         .. versionchanged:: 1.0
1657             Key errors raised from request data like ``form`` show the
1658             bad key in debug mode rather than a generic bad request
1659             message.
1660 
1661         .. versionadded:: 0.7
1662         """
1663         if isinstance(e, BadRequestKeyError) and (
1664             self.debug or self.config["TRAP_BAD_REQUEST_ERRORS"]
1665         ):
1666             e.show_exception = True
1667 
1668         if isinstance(e, HTTPException) and not self.trap_http_exception(e):
1669             return self.handle_http_exception(e)
1670 
1671         handler = self._find_error_handler(e)
1672 
1673         if handler is None:
1674             raise
1675 
1676         return self.ensure_sync(handler)(e)
1677 
1678     def handle_exception(self, e: Exception) -> Response:
1679         """Handle an exception that did not have an error handler
1680         associated with it, or that was raised from an error handler.
1681         This always causes a 500 ``InternalServerError``.
1682 
1683         Always sends the :data:`got_request_exception` signal.
1684 
1685         If :attr:`propagate_exceptions` is ``True``, such as in debug
1686         mode, the error will be re-raised so that the debugger can
1687         display it. Otherwise, the original exception is logged, and
1688         an :exc:`~werkzeug.exceptions.InternalServerError` is returned.
1689 
1690         If an error handler is registered for ``InternalServerError`` or
1691         ``500``, it will be used. For consistency, the handler will
1692         always receive the ``InternalServerError``. The original
1693         unhandled exception is available as ``e.original_exception``.
1694 
1695         .. versionchanged:: 1.1.0
1696             Always passes the ``InternalServerError`` instance to the
1697             handler, setting ``original_exception`` to the unhandled
1698             error.
1699 
1700         .. versionchanged:: 1.1.0
1701             ``after_request`` functions and other finalization is done
1702             even for the default 500 response when there is no handler.
1703 
1704         .. versionadded:: 0.3
1705         """
1706         exc_info = sys.exc_info()
1707         got_request_exception.send(self, exception=e)
1708         propagate = self.config["PROPAGATE_EXCEPTIONS"]
1709 
1710         if propagate is None:
1711             propagate = self.testing or self.debug
1712 
1713         if propagate:
1714             # Re-raise if called with an active exception, otherwise
1715             # raise the passed in exception.
1716             if exc_info[1] is e:
1717                 raise
1718 
1719             raise e
1720 
1721         self.log_exception(exc_info)
1722         server_error: t.Union[InternalServerError, ft.ResponseReturnValue]
1723         server_error = InternalServerError(original_exception=e)
1724         handler = self._find_error_handler(server_error)
1725 
1726         if handler is not None:
1727             server_error = self.ensure_sync(handler)(server_error)
1728 
1729         return self.finalize_request(server_error, from_error_handler=True)
1730 
1731     def log_exception(
1732         self,
1733         exc_info: t.Union[
1734             t.Tuple[type, BaseException, TracebackType], t.Tuple[None, None, None]
1735         ],
1736     ) -> None:
1737         """Logs an exception.  This is called by :meth:`handle_exception`
1738         if debugging is disabled and right before the handler is called.
1739         The default implementation logs the exception as error on the
1740         :attr:`logger`.
1741 
1742         .. versionadded:: 0.8
1743         """
1744         self.logger.error(
1745             f"Exception on {request.path} [{request.method}]", exc_info=exc_info
1746         )
1747 
1748     def raise_routing_exception(self, request: Request) -> "te.NoReturn":
1749         """Intercept routing exceptions and possibly do something else.
1750 
1751         In debug mode, intercept a routing redirect and replace it with
1752         an error if the body will be discarded.
1753 
1754         With modern Werkzeug this shouldn't occur, since it now uses a
1755         308 status which tells the browser to resend the method and
1756         body.
1757 
1758         .. versionchanged:: 2.1
1759             Don't intercept 307 and 308 redirects.
1760 
1761         :meta private:
1762         :internal:
1763         """
1764         if (
1765             not self.debug
1766             or not isinstance(request.routing_exception, RequestRedirect)
1767             or request.routing_exception.code in {307, 308}
1768             or request.method in {"GET", "HEAD", "OPTIONS"}
1769         ):
1770             raise request.routing_exception  # type: ignore
1771 
1772         from .debughelpers import FormDataRoutingRedirect
1773 
1774         raise FormDataRoutingRedirect(request)
1775 
1776     def dispatch_request(self) -> ft.ResponseReturnValue:
1777         """Does the request dispatching.  Matches the URL and returns the
1778         return value of the view or error handler.  This does not have to
1779         be a response object.  In order to convert the return value to a
1780         proper response object, call :func:`make_response`.
1781 
1782         .. versionchanged:: 0.7
1783            This no longer does the exception handling, this code was
1784            moved to the new :meth:`full_dispatch_request`.
1785         """
1786         req = request_ctx.request
1787         if req.routing_exception is not None:
1788             self.raise_routing_exception(req)
1789         rule: Rule = req.url_rule  # type: ignore[assignment]
1790         # if we provide automatic options for this URL and the
1791         # request came with the OPTIONS method, reply automatically
1792         if (
1793             getattr(rule, "provide_automatic_options", False)
1794             and req.method == "OPTIONS"
1795         ):
1796             return self.make_default_options_response()
1797         # otherwise dispatch to the handler for that endpoint
1798         view_args: t.Dict[str, t.Any] = req.view_args  # type: ignore[assignment]
1799         return self.ensure_sync(self.view_functions[rule.endpoint])(**view_args)
1800 
1801     def full_dispatch_request(self) -> Response:
1802         """Dispatches the request and on top of that performs request
1803         pre and postprocessing as well as HTTP exception catching and
1804         error handling.
1805 
1806         .. versionadded:: 0.7
1807         """
1808         # Run before_first_request functions if this is the thread's first request.
1809         # Inlined to avoid a method call on subsequent requests.
1810         # This is deprecated, will be removed in Flask 2.3.
1811         if not self._got_first_request:
1812             with self._before_request_lock:
1813                 if not self._got_first_request:
1814                     for func in self.before_first_request_funcs:
1815                         self.ensure_sync(func)()
1816 
1817                     self._got_first_request = True
1818 
1819         try:
1820             request_started.send(self)
1821             rv = self.preprocess_request()
1822             if rv is None:
1823                 rv = self.dispatch_request()
1824         except Exception as e:
1825             rv = self.handle_user_exception(e)
1826         return self.finalize_request(rv)
1827 
1828     def finalize_request(
1829         self,
1830         rv: t.Union[ft.ResponseReturnValue, HTTPException],
1831         from_error_handler: bool = False,
1832     ) -> Response:
1833         """Given the return value from a view function this finalizes
1834         the request by converting it into a response and invoking the
1835         postprocessing functions.  This is invoked for both normal
1836         request dispatching as well as error handlers.
1837 
1838         Because this means that it might be called as a result of a
1839         failure a special safe mode is available which can be enabled
1840         with the `from_error_handler` flag.  If enabled, failures in
1841         response processing will be logged and otherwise ignored.
1842 
1843         :internal:
1844         """
1845         response = self.make_response(rv)
1846         try:
1847             response = self.process_response(response)
1848             request_finished.send(self, response=response)
1849         except Exception:
1850             if not from_error_handler:
1851                 raise
1852             self.logger.exception(
1853                 "Request finalizing failed with an error while handling an error"
1854             )
1855         return response
1856 
1857     def make_default_options_response(self) -> Response:
1858         """This method is called to create the default ``OPTIONS`` response.
1859         This can be changed through subclassing to change the default
1860         behavior of ``OPTIONS`` responses.
1861 
1862         .. versionadded:: 0.7
1863         """
1864         adapter = request_ctx.url_adapter
1865         methods = adapter.allowed_methods()  # type: ignore[union-attr]
1866         rv = self.response_class()
1867         rv.allow.update(methods)
1868         return rv
1869 
1870     def should_ignore_error(self, error: t.Optional[BaseException]) -> bool:
1871         """This is called to figure out if an error should be ignored
1872         or not as far as the teardown system is concerned.  If this
1873         function returns ``True`` then the teardown handlers will not be
1874         passed the error.
1875 
1876         .. versionadded:: 0.10
1877         """
1878         return False
1879 
1880     def ensure_sync(self, func: t.Callable) -> t.Callable:
1881         """Ensure that the function is synchronous for WSGI workers.
1882         Plain ``def`` functions are returned as-is. ``async def``
1883         functions are wrapped to run and wait for the response.
1884 
1885         Override this method to change how the app runs async views.
1886 
1887         .. versionadded:: 2.0
1888         """
1889         if iscoroutinefunction(func):
1890             return self.async_to_sync(func)
1891 
1892         return func
1893 
1894     def async_to_sync(
1895         self, func: t.Callable[..., t.Coroutine]
1896     ) -> t.Callable[..., t.Any]:
1897         """Return a sync function that will run the coroutine function.
1898 
1899         .. code-block:: python
1900 
1901             result = app.async_to_sync(func)(*args, **kwargs)
1902 
1903         Override this method to change how the app converts async code
1904         to be synchronously callable.
1905 
1906         .. versionadded:: 2.0
1907         """
1908         try:
1909             from asgiref.sync import async_to_sync as asgiref_async_to_sync
1910         except ImportError:
1911             raise RuntimeError(
1912                 "Install Flask with the 'async' extra in order to use async views."
1913             ) from None
1914 
1915         return asgiref_async_to_sync(func)
1916 
1917     def url_for(
1918         self,
1919         endpoint: str,
1920         *,
1921         _anchor: t.Optional[str] = None,
1922         _method: t.Optional[str] = None,
1923         _scheme: t.Optional[str] = None,
1924         _external: t.Optional[bool] = None,
1925         **values: t.Any,
1926     ) -> str:
1927         """Generate a URL to the given endpoint with the given values.
1928 
1929         This is called by :func:`flask.url_for`, and can be called
1930         directly as well.
1931 
1932         An *endpoint* is the name of a URL rule, usually added with
1933         :meth:`@app.route() <route>`, and usually the same name as the
1934         view function. A route defined in a :class:`~flask.Blueprint`
1935         will prepend the blueprint's name separated by a ``.`` to the
1936         endpoint.
1937 
1938         In some cases, such as email messages, you want URLs to include
1939         the scheme and domain, like ``https://example.com/hello``. When
1940         not in an active request, URLs will be external by default, but
1941         this requires setting :data:`SERVER_NAME` so Flask knows what
1942         domain to use. :data:`APPLICATION_ROOT` and
1943         :data:`PREFERRED_URL_SCHEME` should also be configured as
1944         needed. This config is only used when not in an active request.
1945 
1946         Functions can be decorated with :meth:`url_defaults` to modify
1947         keyword arguments before the URL is built.
1948 
1949         If building fails for some reason, such as an unknown endpoint
1950         or incorrect values, the app's :meth:`handle_url_build_error`
1951         method is called. If that returns a string, that is returned,
1952         otherwise a :exc:`~werkzeug.routing.BuildError` is raised.
1953 
1954         :param endpoint: The endpoint name associated with the URL to
1955             generate. If this starts with a ``.``, the current blueprint
1956             name (if any) will be used.
1957         :param _anchor: If given, append this as ``#anchor`` to the URL.
1958         :param _method: If given, generate the URL associated with this
1959             method for the endpoint.
1960         :param _scheme: If given, the URL will have this scheme if it
1961             is external.
1962         :param _external: If given, prefer the URL to be internal
1963             (False) or require it to be external (True). External URLs
1964             include the scheme and domain. When not in an active
1965             request, URLs are external by default.
1966         :param values: Values to use for the variable parts of the URL
1967             rule. Unknown keys are appended as query string arguments,
1968             like ``?a=b&c=d``.
1969 
1970         .. versionadded:: 2.2
1971             Moved from ``flask.url_for``, which calls this method.
1972         """
1973         req_ctx = _cv_request.get(None)
1974 
1975         if req_ctx is not None:
1976             url_adapter = req_ctx.url_adapter
1977             blueprint_name = req_ctx.request.blueprint
1978 
1979             # If the endpoint starts with "." and the request matches a
1980             # blueprint, the endpoint is relative to the blueprint.
1981             if endpoint[:1] == ".":
1982                 if blueprint_name is not None:
1983                     endpoint = f"{blueprint_name}{endpoint}"
1984                 else:
1985                     endpoint = endpoint[1:]
1986 
1987             # When in a request, generate a URL without scheme and
1988             # domain by default, unless a scheme is given.
1989             if _external is None:
1990                 _external = _scheme is not None
1991         else:
1992             app_ctx = _cv_app.get(None)
1993 
1994             # If called by helpers.url_for, an app context is active,
1995             # use its url_adapter. Otherwise, app.url_for was called
1996             # directly, build an adapter.
1997             if app_ctx is not None:
1998                 url_adapter = app_ctx.url_adapter
1999             else:
2000                 url_adapter = self.create_url_adapter(None)
2001 
2002             if url_adapter is None:
2003                 raise RuntimeError(
2004                     "Unable to build URLs outside an active request"
2005                     " without 'SERVER_NAME' configured. Also configure"
2006                     " 'APPLICATION_ROOT' and 'PREFERRED_URL_SCHEME' as"
2007                     " needed."
2008                 )
2009 
2010             # When outside a request, generate a URL with scheme and
2011             # domain by default.
2012             if _external is None:
2013                 _external = True
2014 
2015         # It is an error to set _scheme when _external=False, in order
2016         # to avoid accidental insecure URLs.
2017         if _scheme is not None and not _external:
2018             raise ValueError("When specifying '_scheme', '_external' must be True.")
2019 
2020         self.inject_url_defaults(endpoint, values)
2021 
2022         try:
2023             rv = url_adapter.build(  # type: ignore[union-attr]
2024                 endpoint,
2025                 values,
2026                 method=_method,
2027                 url_scheme=_scheme,
2028                 force_external=_external,
2029             )
2030         except BuildError as error:
2031             values.update(
2032                 _anchor=_anchor, _method=_method, _scheme=_scheme, _external=_external
2033             )
2034             return self.handle_url_build_error(error, endpoint, values)
2035 
2036         if _anchor is not None:
2037             rv = f"{rv}#{url_quote(_anchor)}"
2038 
2039         return rv
2040 
2041     def redirect(self, location: str, code: int = 302) -> BaseResponse:
2042         """Create a redirect response object.
2043 
2044         This is called by :func:`flask.redirect`, and can be called
2045         directly as well.
2046 
2047         :param location: The URL to redirect to.
2048         :param code: The status code for the redirect.
2049 
2050         .. versionadded:: 2.2
2051             Moved from ``flask.redirect``, which calls this method.
2052         """
2053         return _wz_redirect(location, code=code, Response=self.response_class)
2054 
2055     def make_response(self, rv: ft.ResponseReturnValue) -> Response:
2056         """Convert the return value from a view function to an instance of
2057         :attr:`response_class`.
2058 
2059         :param rv: the return value from the view function. The view function
2060             must return a response. Returning ``None``, or the view ending
2061             without returning, is not allowed. The following types are allowed
2062             for ``view_rv``:
2063 
2064             ``str``
2065                 A response object is created with the string encoded to UTF-8
2066                 as the body.
2067 
2068             ``bytes``
2069                 A response object is created with the bytes as the body.
2070 
2071             ``dict``
2072                 A dictionary that will be jsonify'd before being returned.
2073 
2074             ``list``
2075                 A list that will be jsonify'd before being returned.
2076 
2077             ``generator`` or ``iterator``
2078                 A generator that returns ``str`` or ``bytes`` to be
2079                 streamed as the response.
2080 
2081             ``tuple``
2082                 Either ``(body, status, headers)``, ``(body, status)``, or
2083                 ``(body, headers)``, where ``body`` is any of the other types
2084                 allowed here, ``status`` is a string or an integer, and
2085                 ``headers`` is a dictionary or a list of ``(key, value)``
2086                 tuples. If ``body`` is a :attr:`response_class` instance,
2087                 ``status`` overwrites the exiting value and ``headers`` are
2088                 extended.
2089 
2090             :attr:`response_class`
2091                 The object is returned unchanged.
2092 
2093             other :class:`~werkzeug.wrappers.Response` class
2094                 The object is coerced to :attr:`response_class`.
2095 
2096             :func:`callable`
2097                 The function is called as a WSGI application. The result is
2098                 used to create a response object.
2099 
2100         .. versionchanged:: 2.2
2101             A generator will be converted to a streaming response.
2102             A list will be converted to a JSON response.
2103 
2104         .. versionchanged:: 1.1
2105             A dict will be converted to a JSON response.
2106 
2107         .. versionchanged:: 0.9
2108            Previously a tuple was interpreted as the arguments for the
2109            response object.
2110         """
2111 
2112         status = headers = None
2113 
2114         # unpack tuple returns
2115         if isinstance(rv, tuple):
2116             len_rv = len(rv)
2117 
2118             # a 3-tuple is unpacked directly
2119             if len_rv == 3:
2120                 rv, status, headers = rv  # type: ignore[misc]
2121             # decide if a 2-tuple has status or headers
2122             elif len_rv == 2:
2123                 if isinstance(rv[1], (Headers, dict, tuple, list)):
2124                     rv, headers = rv
2125                 else:
2126                     rv, status = rv  # type: ignore[assignment,misc]
2127             # other sized tuples are not allowed
2128             else:
2129                 raise TypeError(
2130                     "The view function did not return a valid response tuple."
2131                     " The tuple must have the form (body, status, headers),"
2132                     " (body, status), or (body, headers)."
2133                 )
2134 
2135         # the body must not be None
2136         if rv is None:
2137             raise TypeError(
2138                 f"The view function for {request.endpoint!r} did not"
2139                 " return a valid response. The function either returned"
2140                 " None or ended without a return statement."
2141             )
2142 
2143         # make sure the body is an instance of the response class
2144         if not isinstance(rv, self.response_class):
2145             if isinstance(rv, (str, bytes, bytearray)) or isinstance(rv, _abc_Iterator):
2146                 # let the response class set the status and headers instead of
2147                 # waiting to do it manually, so that the class can handle any
2148                 # special logic
2149                 rv = self.response_class(
2150                     rv,
2151                     status=status,
2152                     headers=headers,  # type: ignore[arg-type]
2153                 )
2154                 status = headers = None
2155             elif isinstance(rv, (dict, list)):
2156                 rv = self.json.response(rv)
2157             elif isinstance(rv, BaseResponse) or callable(rv):
2158                 # evaluate a WSGI callable, or coerce a different response
2159                 # class to the correct type
2160                 try:
2161                     rv = self.response_class.force_type(
2162                         rv, request.environ  # type: ignore[arg-type]
2163                     )
2164                 except TypeError as e:
2165                     raise TypeError(
2166                         f"{e}\nThe view function did not return a valid"
2167                         " response. The return type must be a string,"
2168                         " dict, list, tuple with headers or status,"
2169                         " Response instance, or WSGI callable, but it"
2170                         f" was a {type(rv).__name__}."
2171                     ).with_traceback(sys.exc_info()[2]) from None
2172             else:
2173                 raise TypeError(
2174                     "The view function did not return a valid"
2175                     " response. The return type must be a string,"
2176                     " dict, list, tuple with headers or status,"
2177                     " Response instance, or WSGI callable, but it was a"
2178                     f" {type(rv).__name__}."
2179                 )
2180 
2181         rv = t.cast(Response, rv)
2182         # prefer the status if it was provided
2183         if status is not None:
2184             if isinstance(status, (str, bytes, bytearray)):
2185                 rv.status = status
2186             else:
2187                 rv.status_code = status
2188 
2189         # extend existing headers with provided headers
2190         if headers:
2191             rv.headers.update(headers)  # type: ignore[arg-type]
2192 
2193         return rv
2194 
2195     def create_url_adapter(
2196         self, request: t.Optional[Request]
2197     ) -> t.Optional[MapAdapter]:
2198         """Creates a URL adapter for the given request. The URL adapter
2199         is created at a point where the request context is not yet set
2200         up so the request is passed explicitly.
2201 
2202         .. versionadded:: 0.6
2203 
2204         .. versionchanged:: 0.9
2205            This can now also be called without a request object when the
2206            URL adapter is created for the application context.
2207 
2208         .. versionchanged:: 1.0
2209             :data:`SERVER_NAME` no longer implicitly enables subdomain
2210             matching. Use :attr:`subdomain_matching` instead.
2211         """
2212         if request is not None:
2213             # If subdomain matching is disabled (the default), use the
2214             # default subdomain in all cases. This should be the default
2215             # in Werkzeug but it currently does not have that feature.
2216             if not self.subdomain_matching:
2217                 subdomain = self.url_map.default_subdomain or None
2218             else:
2219                 subdomain = None
2220 
2221             return self.url_map.bind_to_environ(
2222                 request.environ,
2223                 server_name=self.config["SERVER_NAME"],
2224                 subdomain=subdomain,
2225             )
2226         # We need at the very least the server name to be set for this
2227         # to work.
2228         if self.config["SERVER_NAME"] is not None:
2229             return self.url_map.bind(
2230                 self.config["SERVER_NAME"],
2231                 script_name=self.config["APPLICATION_ROOT"],
2232                 url_scheme=self.config["PREFERRED_URL_SCHEME"],
2233             )
2234 
2235         return None
2236 
2237     def inject_url_defaults(self, endpoint: str, values: dict) -> None:
2238         """Injects the URL defaults for the given endpoint directly into
2239         the values dictionary passed.  This is used internally and
2240         automatically called on URL building.
2241 
2242         .. versionadded:: 0.7
2243         """
2244         names: t.Iterable[t.Optional[str]] = (None,)
2245 
2246         # url_for may be called outside a request context, parse the
2247         # passed endpoint instead of using request.blueprints.
2248         if "." in endpoint:
2249             names = chain(
2250                 names, reversed(_split_blueprint_path(endpoint.rpartition(".")[0]))
2251             )
2252 
2253         for name in names:
2254             if name in self.url_default_functions:
2255                 for func in self.url_default_functions[name]:
2256                     func(endpoint, values)
2257 
2258     def handle_url_build_error(
2259         self, error: BuildError, endpoint: str, values: t.Dict[str, t.Any]
2260     ) -> str:
2261         """Called by :meth:`.url_for` if a
2262         :exc:`~werkzeug.routing.BuildError` was raised. If this returns
2263         a value, it will be returned by ``url_for``, otherwise the error
2264         will be re-raised.
2265 
2266         Each function in :attr:`url_build_error_handlers` is called with
2267         ``error``, ``endpoint`` and ``values``. If a function returns
2268         ``None`` or raises a ``BuildError``, it is skipped. Otherwise,
2269         its return value is returned by ``url_for``.
2270 
2271         :param error: The active ``BuildError`` being handled.
2272         :param endpoint: The endpoint being built.
2273         :param values: The keyword arguments passed to ``url_for``.
2274         """
2275         for handler in self.url_build_error_handlers:
2276             try:
2277                 rv = handler(error, endpoint, values)
2278             except BuildError as e:
2279                 # make error available outside except block
2280                 error = e
2281             else:
2282                 if rv is not None:
2283                     return rv
2284 
2285         # Re-raise if called with an active exception, otherwise raise
2286         # the passed in exception.
2287         if error is sys.exc_info()[1]:
2288             raise
2289 
2290         raise error
2291 
2292     def preprocess_request(self) -> t.Optional[ft.ResponseReturnValue]:
2293         """Called before the request is dispatched. Calls
2294         :attr:`url_value_preprocessors` registered with the app and the
2295         current blueprint (if any). Then calls :attr:`before_request_funcs`
2296         registered with the app and the blueprint.
2297 
2298         If any :meth:`before_request` handler returns a non-None value, the
2299         value is handled as if it was the return value from the view, and
2300         further request handling is stopped.
2301         """
2302         names = (None, *reversed(request.blueprints))
2303 
2304         for name in names:
2305             if name in self.url_value_preprocessors:
2306                 for url_func in self.url_value_preprocessors[name]:
2307                     url_func(request.endpoint, request.view_args)
2308 
2309         for name in names:
2310             if name in self.before_request_funcs:
2311                 for before_func in self.before_request_funcs[name]:
2312                     rv = self.ensure_sync(before_func)()
2313 
2314                     if rv is not None:
2315                         return rv
2316 
2317         return None
2318 
2319     def process_response(self, response: Response) -> Response:
2320         """Can be overridden in order to modify the response object
2321         before it's sent to the WSGI server.  By default this will
2322         call all the :meth:`after_request` decorated functions.
2323 
2324         .. versionchanged:: 0.5
2325            As of Flask 0.5 the functions registered for after request
2326            execution are called in reverse order of registration.
2327 
2328         :param response: a :attr:`response_class` object.
2329         :return: a new response object or the same, has to be an
2330                  instance of :attr:`response_class`.
2331         """
2332         ctx = request_ctx._get_current_object()  # type: ignore[attr-defined]
2333 
2334         for func in ctx._after_request_functions:
2335             response = self.ensure_sync(func)(response)
2336 
2337         for name in chain(request.blueprints, (None,)):
2338             if name in self.after_request_funcs:
2339                 for func in reversed(self.after_request_funcs[name]):
2340                     response = self.ensure_sync(func)(response)
2341 
2342         if not self.session_interface.is_null_session(ctx.session):
2343             self.session_interface.save_session(self, ctx.session, response)
2344 
2345         return response
2346 
2347     def do_teardown_request(
2348         self, exc: t.Optional[BaseException] = _sentinel  # type: ignore
2349     ) -> None:
2350         """Called after the request is dispatched and the response is
2351         returned, right before the request context is popped.
2352 
2353         This calls all functions decorated with
2354         :meth:`teardown_request`, and :meth:`Blueprint.teardown_request`
2355         if a blueprint handled the request. Finally, the
2356         :data:`request_tearing_down` signal is sent.
2357 
2358         This is called by
2359         :meth:`RequestContext.pop() <flask.ctx.RequestContext.pop>`,
2360         which may be delayed during testing to maintain access to
2361         resources.
2362 
2363         :param exc: An unhandled exception raised while dispatching the
2364             request. Detected from the current exception information if
2365             not passed. Passed to each teardown function.
2366 
2367         .. versionchanged:: 0.9
2368             Added the ``exc`` argument.
2369         """
2370         if exc is _sentinel:
2371             exc = sys.exc_info()[1]
2372 
2373         for name in chain(request.blueprints, (None,)):
2374             if name in self.teardown_request_funcs:
2375                 for func in reversed(self.teardown_request_funcs[name]):
2376                     self.ensure_sync(func)(exc)
2377 
2378         request_tearing_down.send(self, exc=exc)
2379 
2380     def do_teardown_appcontext(
2381         self, exc: t.Optional[BaseException] = _sentinel  # type: ignore
2382     ) -> None:
2383         """Called right before the application context is popped.
2384 
2385         When handling a request, the application context is popped
2386         after the request context. See :meth:`do_teardown_request`.
2387 
2388         This calls all functions decorated with
2389         :meth:`teardown_appcontext`. Then the
2390         :data:`appcontext_tearing_down` signal is sent.
2391 
2392         This is called by
2393         :meth:`AppContext.pop() <flask.ctx.AppContext.pop>`.
2394 
2395         .. versionadded:: 0.9
2396         """
2397         if exc is _sentinel:
2398             exc = sys.exc_info()[1]
2399 
2400         for func in reversed(self.teardown_appcontext_funcs):
2401             self.ensure_sync(func)(exc)
2402 
2403         appcontext_tearing_down.send(self, exc=exc)
2404 
2405     def app_context(self) -> AppContext:
2406         """Create an :class:`~flask.ctx.AppContext`. Use as a ``with``
2407         block to push the context, which will make :data:`current_app`
2408         point at this application.
2409 
2410         An application context is automatically pushed by
2411         :meth:`RequestContext.push() <flask.ctx.RequestContext.push>`
2412         when handling a request, and when running a CLI command. Use
2413         this to manually create a context outside of these situations.
2414 
2415         ::
2416 
2417             with app.app_context():
2418                 init_db()
2419 
2420         See :doc:`/appcontext`.
2421 
2422         .. versionadded:: 0.9
2423         """
2424         return AppContext(self)
2425 
2426     def request_context(self, environ: dict) -> RequestContext:
2427         """Create a :class:`~flask.ctx.RequestContext` representing a
2428         WSGI environment. Use a ``with`` block to push the context,
2429         which will make :data:`request` point at this request.
2430 
2431         See :doc:`/reqcontext`.
2432 
2433         Typically you should not call this from your own code. A request
2434         context is automatically pushed by the :meth:`wsgi_app` when
2435         handling a request. Use :meth:`test_request_context` to create
2436         an environment and context instead of this method.
2437 
2438         :param environ: a WSGI environment
2439         """
2440         return RequestContext(self, environ)
2441 
2442     def test_request_context(self, *args: t.Any, **kwargs: t.Any) -> RequestContext:
2443         """Create a :class:`~flask.ctx.RequestContext` for a WSGI
2444         environment created from the given values. This is mostly useful
2445         during testing, where you may want to run a function that uses
2446         request data without dispatching a full request.
2447 
2448         See :doc:`/reqcontext`.
2449 
2450         Use a ``with`` block to push the context, which will make
2451         :data:`request` point at the request for the created
2452         environment. ::
2453 
2454             with app.test_request_context(...):
2455                 generate_report()
2456 
2457         When using the shell, it may be easier to push and pop the
2458         context manually to avoid indentation. ::
2459 
2460             ctx = app.test_request_context(...)
2461             ctx.push()
2462             ...
2463             ctx.pop()
2464 
2465         Takes the same arguments as Werkzeug's
2466         :class:`~werkzeug.test.EnvironBuilder`, with some defaults from
2467         the application. See the linked Werkzeug docs for most of the
2468         available arguments. Flask-specific behavior is listed here.
2469 
2470         :param path: URL path being requested.
2471         :param base_url: Base URL where the app is being served, which
2472             ``path`` is relative to. If not given, built from
2473             :data:`PREFERRED_URL_SCHEME`, ``subdomain``,
2474             :data:`SERVER_NAME`, and :data:`APPLICATION_ROOT`.
2475         :param subdomain: Subdomain name to append to
2476             :data:`SERVER_NAME`.
2477         :param url_scheme: Scheme to use instead of
2478             :data:`PREFERRED_URL_SCHEME`.
2479         :param data: The request body, either as a string or a dict of
2480             form keys and values.
2481         :param json: If given, this is serialized as JSON and passed as
2482             ``data``. Also defaults ``content_type`` to
2483             ``application/json``.
2484         :param args: other positional arguments passed to
2485             :class:`~werkzeug.test.EnvironBuilder`.
2486         :param kwargs: other keyword arguments passed to
2487             :class:`~werkzeug.test.EnvironBuilder`.
2488         """
2489         from .testing import EnvironBuilder
2490 
2491         builder = EnvironBuilder(self, *args, **kwargs)
2492 
2493         try:
2494             return self.request_context(builder.get_environ())
2495         finally:
2496             builder.close()
2497 
2498     def wsgi_app(self, environ: dict, start_response: t.Callable) -> t.Any:
2499         """The actual WSGI application. This is not implemented in
2500         :meth:`__call__` so that middlewares can be applied without
2501         losing a reference to the app object. Instead of doing this::
2502 
2503             app = MyMiddleware(app)
2504 
2505         It's a better idea to do this instead::
2506 
2507             app.wsgi_app = MyMiddleware(app.wsgi_app)
2508 
2509         Then you still have the original application object around and
2510         can continue to call methods on it.
2511 
2512         .. versionchanged:: 0.7
2513             Teardown events for the request and app contexts are called
2514             even if an unhandled error occurs. Other events may not be
2515             called depending on when an error occurs during dispatch.
2516             See :ref:`callbacks-and-errors`.
2517 
2518         :param environ: A WSGI environment.
2519         :param start_response: A callable accepting a status code,
2520             a list of headers, and an optional exception context to
2521             start the response.
2522         """
2523         ctx = self.request_context(environ)
2524         error: t.Optional[BaseException] = None
2525         try:
2526             try:
2527                 ctx.push()
2528                 response = self.full_dispatch_request()
2529             except Exception as e:
2530                 error = e
2531                 response = self.handle_exception(e)
2532             except:  # noqa: B001
2533                 error = sys.exc_info()[1]
2534                 raise
2535             return response(environ, start_response)
2536         finally:
2537             if "werkzeug.debug.preserve_context" in environ:
2538                 environ["werkzeug.debug.preserve_context"](_cv_app.get())
2539                 environ["werkzeug.debug.preserve_context"](_cv_request.get())
2540 
2541             if error is not None and self.should_ignore_error(error):
2542                 error = None
2543 
2544             ctx.pop(error)
2545 
2546     def __call__(self, environ: dict, start_response: t.Callable) -> t.Any:
2547         """The WSGI server calls the Flask application object as the
2548         WSGI application. This calls :meth:`wsgi_app`, which can be
2549         wrapped to apply middleware.
2550         """
2551         return self.wsgi_app(environ, start_response)

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>]
2025-10-15 21:16:17.030 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-15 21:16:17.030 | INFO     | Search-only: skipping patch selection
2025-10-15 21:16:17.095 | INFO     | Task pallets__flask-4935 completed successfully.
2025-10-15 21:16:17.096 | INFO     | No patch generated. You can try running ACR again.
