2025-10-18 06:16:17.011 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-18 06:16:19.736 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1989, output_tokens=12, cost=0.020250
2025-10-18 06:16:44.142 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2169, output_tokens=970, cost=0.050790
2025-10-18 06:16:45.163 | INFO     | registered non reproducing test 0
2025-10-18 06:17:00.888 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3697, output_tokens=613, cost=0.055360
2025-10-18 06:17:01.863 | INFO     | registered non reproducing test 1
2025-10-18 06:17:23.135 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3350, output_tokens=941, cost=0.061730
2025-10-18 06:17:24.116 | INFO     | registered non reproducing test 2
2025-10-18 06:17:24.116 | WARNING  | Failed to write a reproducer test; skipping reproducer tracing
2025-10-18 06:17:24.119 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 06:17:32.675 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2264, output_tokens=368, cost=0.033680
2025-10-18 06:17:32.682 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 06:17:35.688 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=722, output_tokens=63, cost=0.009110
2025-10-18 06:17:35.689 | DEBUG    | Extracted a valid json.
2025-10-18 06:17:35.689 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_code(\"rst to latex\")",
        "search_code(\"convert rst\")",
        "search_code(\"glossary\")",
        "search_code(\"latex format\")",
        "search_code(\"latex template\")"
    ],
    "bug_locations": []
}
2025-10-18 06:17:35.764 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 06:17:35.765 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 06:17:53.884 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3007, output_tokens=716, cost=0.051550
2025-10-18 06:17:53.890 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 06:18:02.749 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3939, output_tokens=388, cost=0.051030
2025-10-18 06:18:02.756 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 06:18:11.461 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=742, output_tokens=340, cost=0.017620
2025-10-18 06:18:11.462 | DEBUG    | Extracted a valid json.
2025-10-18 06:18:11.462 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "sphinx/writers/latex.py",
            "class": "",
            "method": "",
            "intended_behavior": "This file should include a method or modify an existing method to ensure that glossary terms and similarly formatted items are separated by appropriate LaTeX commands to enforce a newline where expected. The intended behavior is to preserve glossary term separations in such a way that when converted to LaTeX, the output mimics the separation seen in HTML and other formats, without introducing undue vertical whitespace for grouped terms. This could involve checking for glossary term definitions and applying a LaTeX newline command (\\ or \\par) at the correct places while preserving existing functionality for handling other elements within .rst files. The code should ensure no unintended side effects on the rest of the LaTeX document's formatting."
        },
        {
            "file": "sphinx/domains/std.py",
            "class": "",
            "method": "",
            "intended_behavior": "This file likely handles the logical structuring or interpretation of standard domain elements, including glossaries. The intended behavior here is to ensure that data structure passed from this processing step to the LaTeX writer (sphinx/writers/latex.py) is correctly formatted or tagged in a way that facilitates the appropriate LaTeX separation of glossary terms. If issues stem from how glossary terms are aggregated or passed along, adjusting this to support clearer separation in LaTeX output is necessary. This might not require adding new methods but rather adjusting existing logic to ensure that groupings of glossary terms are maintained or appropriately flagged for the LaTeX output stage."
        }
    ]
}
2025-10-18 06:18:11.471 | DEBUG    | Bug location extracted successfully: [<file>sphinx/writers/latex.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2     sphinx.writers.latex
3     ~~~~~~~~~~~~~~~~~~~~
4 
5     Custom docutils writer for LaTeX.
6 
7     Much of this code is adapted from Dave Kuhlman's "docpy" writer from his
8     docutils sandbox.
9 
10     :copyright: Copyright 2007-2021 by the Sphinx team, see AUTHORS.
11     :license: BSD, see LICENSE for details.
12 """
13 
14 import re
15 import warnings
16 from collections import defaultdict
17 from os import path
18 from typing import TYPE_CHECKING, Any, Dict, Iterable, List, Set, Tuple, cast
19 
20 from docutils import nodes, writers
21 from docutils.nodes import Element, Node, Text
22 
23 from sphinx import addnodes, highlighting
24 from sphinx.deprecation import RemovedInSphinx70Warning
25 from sphinx.domains import IndexEntry
26 from sphinx.domains.std import StandardDomain
27 from sphinx.errors import SphinxError
28 from sphinx.locale import _, __, admonitionlabels
29 from sphinx.util import logging, split_into, texescape
30 from sphinx.util.docutils import SphinxTranslator
31 from sphinx.util.nodes import clean_astext, get_prev_node
32 from sphinx.util.template import LaTeXRenderer
33 from sphinx.util.texescape import tex_replace_map
34 
35 try:
36     from docutils.utils.roman import toRoman
37 except ImportError:
38     # In Debian/Ubuntu, roman package is provided as roman, not as docutils.utils.roman
39     from roman import toRoman  # type: ignore
40 
41 if TYPE_CHECKING:
42     from sphinx.builders.latex import LaTeXBuilder
43     from sphinx.builders.latex.theming import Theme
44 
45 
46 logger = logging.getLogger(__name__)
47 
48 MAX_CITATION_LABEL_LENGTH = 8
49 LATEXSECTIONNAMES = ["part", "chapter", "section", "subsection",
50                      "subsubsection", "paragraph", "subparagraph"]
51 ENUMERATE_LIST_STYLE = defaultdict(lambda: r'\arabic',
52                                    {
53                                        'arabic': r'\arabic',
54                                        'loweralpha': r'\alph',
55                                        'upperalpha': r'\Alph',
56                                        'lowerroman': r'\roman',
57                                        'upperroman': r'\Roman',
58                                    })
59 
60 CR = '\n'
61 BLANKLINE = '\n\n'
62 EXTRA_RE = re.compile(r'^(.*\S)\s+\(([^()]*)\)\s*$')
63 
64 
65 class collected_footnote(nodes.footnote):
66     """Footnotes that are collected are assigned this class."""
67 
68 
69 class UnsupportedError(SphinxError):
70     category = 'Markup is unsupported in LaTeX'
71 
72 
73 class LaTeXWriter(writers.Writer):
74 
75     supported = ('sphinxlatex',)
76 
77     settings_spec = ('LaTeX writer options', '', (
78         ('Document name', ['--docname'], {'default': ''}),
79         ('Document class', ['--docclass'], {'default': 'manual'}),
80         ('Author', ['--author'], {'default': ''}),
81     ))
82     settings_defaults: Dict = {}
83 
84     output = None
85 
86     def __init__(self, builder: "LaTeXBuilder") -> None:
87         super().__init__()
88         self.builder = builder
89         self.theme: Theme = None
90 
91     def translate(self) -> None:
92         visitor = self.builder.create_translator(self.document, self.builder, self.theme)
93         self.document.walkabout(visitor)
94         self.output = cast(LaTeXTranslator, visitor).astext()
95 
96 
97 # Helper classes
98 
99 class Table:
100     """A table data"""
101 
102     def __init__(self, node: Element) -> None:
103         self.header: List[str] = []
104         self.body: List[str] = []
105         self.align = node.get('align', 'default')
106         self.classes: List[str] = node.get('classes', [])
107         self.colcount = 0
108         self.colspec: str = None
109         self.colwidths: List[int] = []
110         self.has_problematic = False
111         self.has_oldproblematic = False
112         self.has_verbatim = False
113         self.caption: List[str] = None
114         self.stubs: List[int] = []
115 
116         # current position
117         self.col = 0
118         self.row = 0
119 
120         # A dict mapping a table location to a cell_id (cell = rectangular area)
121         self.cells: Dict[Tuple[int, int], int] = defaultdict(int)
122         self.cell_id = 0  # last assigned cell_id
123 
124     def is_longtable(self) -> bool:
125         """True if and only if table uses longtable environment."""
126         return self.row > 30 or 'longtable' in self.classes
127 
128     def get_table_type(self) -> str:
129         """Returns the LaTeX environment name for the table.
130 
131         The class currently supports:
132 
133         * longtable
134         * tabular
135         * tabulary
136         """
137         if self.is_longtable():
138             return 'longtable'
139         elif self.has_verbatim:
140             return 'tabular'
141         elif self.colspec:
142             return 'tabulary'
143         elif self.has_problematic or (self.colwidths and 'colwidths-given' in self.classes):
144             return 'tabular'
145         else:
146             return 'tabulary'
147 
148     def get_colspec(self) -> str:
149         """Returns a column spec of table.
150 
151         This is what LaTeX calls the 'preamble argument' of the used table environment.
152 
153         .. note:: the ``\\X`` and ``T`` column type specifiers are defined in ``sphinx.sty``.
154         """
155         if self.colspec:
156             return self.colspec
157         elif self.colwidths and 'colwidths-given' in self.classes:
158             total = sum(self.colwidths)
159             colspecs = [r'\X{%d}{%d}' % (width, total) for width in self.colwidths]
160             return '{|%s|}' % '|'.join(colspecs) + CR
161         elif self.has_problematic:
162             return r'{|*{%d}{\X{1}{%d}|}}' % (self.colcount, self.colcount) + CR
163         elif self.get_table_type() == 'tabulary':
164             # sphinx.sty sets T to be J by default.
165             return '{|' + ('T|' * self.colcount) + '}' + CR
166         elif self.has_oldproblematic:
167             return r'{|*{%d}{\X{1}{%d}|}}' % (self.colcount, self.colcount) + CR
168         else:
169             return '{|' + ('l|' * self.colcount) + '}' + CR
170 
171     def add_cell(self, height: int, width: int) -> None:
172         """Adds a new cell to a table.
173 
174         It will be located at current position: (``self.row``, ``self.col``).
175         """
176         self.cell_id += 1
177         for col in range(width):
178             for row in range(height):
179                 assert self.cells[(self.row + row, self.col + col)] == 0
180                 self.cells[(self.row + row, self.col + col)] = self.cell_id
181 
182     def cell(self, row: int = None, col: int = None) -> "TableCell":
183         """Returns a cell object (i.e. rectangular area) containing given position.
184 
185         If no option arguments: ``row`` or ``col`` are given, the current position;
186         ``self.row`` and ``self.col`` are used to get a cell object by default.
187         """
188         try:
189             if row is None:
190                 row = self.row
191             if col is None:
192                 col = self.col
193             return TableCell(self, row, col)
194         except IndexError:
195             return None
196 
197 
198 class TableCell:
199     """Data of a cell in a table."""
200 
201     def __init__(self, table: Table, row: int, col: int) -> None:
202         if table.cells[(row, col)] == 0:
203             raise IndexError
204 
205         self.table = table
206         self.cell_id = table.cells[(row, col)]
207         self.row = row
208         self.col = col
209 
210         # adjust position for multirow/multicol cell
211         while table.cells[(self.row - 1, self.col)] == self.cell_id:
212             self.row -= 1
213         while table.cells[(self.row, self.col - 1)] == self.cell_id:
214             self.col -= 1
215 
216     @property
217     def width(self) -> int:
218         """Returns the cell width."""
219         width = 0
220         while self.table.cells[(self.row, self.col + width)] == self.cell_id:
221             width += 1
222         return width
223 
224     @property
225     def height(self) -> int:
226         """Returns the cell height."""
227         height = 0
228         while self.table.cells[(self.row + height, self.col)] == self.cell_id:
229             height += 1
230         return height
231 
232 
233 def escape_abbr(text: str) -> str:
234     """Adjust spacing after abbreviations."""
235     return re.sub(r'\.(?=\s|$)', r'.\@', text)
236 
237 
238 def rstdim_to_latexdim(width_str: str, scale: int = 100) -> str:
239     """Convert `width_str` with rst length to LaTeX length."""
240     match = re.match(r'^(\d*\.?\d*)\s*(\S*)$', width_str)
241     if not match:
242         raise ValueError
243     res = width_str
244     amount, unit = match.groups()[:2]
245     if scale == 100:
246         float(amount)  # validate amount is float
247         if unit in ('', "px"):
248             res = r"%s\sphinxpxdimen" % amount
249         elif unit == 'pt':
250             res = '%sbp' % amount  # convert to 'bp'
251         elif unit == "%":
252             res = r"%.3f\linewidth" % (float(amount) / 100.0)
253     else:
254         amount_float = float(amount) * scale / 100.0
255         if unit in ('', "px"):
256             res = r"%.5f\sphinxpxdimen" % amount_float
257         elif unit == 'pt':
258             res = '%.5fbp' % amount_float
259         elif unit == "%":
260             res = r"%.5f\linewidth" % (amount_float / 100.0)
261         else:
262             res = "%.5f%s" % (amount_float, unit)
263     return res
264 
265 
266 class LaTeXTranslator(SphinxTranslator):
267     builder: "LaTeXBuilder" = None
268 
269     secnumdepth = 2  # legacy sphinxhowto.cls uses this, whereas article.cls
270     # default is originally 3. For book/report, 2 is already LaTeX default.
271     ignore_missing_images = False
272 
273     def __init__(self, document: nodes.document, builder: "LaTeXBuilder",
274                  theme: "Theme") -> None:
275         super().__init__(document, builder)
276         self.body: List[str] = []
277         self.theme = theme
278 
279         # flags
280         self.in_title = 0
281         self.in_production_list = 0
282         self.in_footnote = 0
283         self.in_caption = 0
284         self.in_term = 0
285         self.needs_linetrimming = 0
286         self.in_minipage = 0
287         self.no_latex_floats = 0
288         self.first_document = 1
289         self.this_is_the_title = 1
290         self.literal_whitespace = 0
291         self.in_parsed_literal = 0
292         self.compact_list = 0
293         self.first_param = 0
294 
295         sphinxpkgoptions = []
296 
297         # sort out some elements
298         self.elements = self.builder.context.copy()
299 
300         # initial section names
301         self.sectionnames = LATEXSECTIONNAMES[:]
302         if self.theme.toplevel_sectioning == 'section':
303             self.sectionnames.remove('chapter')
304 
305         # determine top section level
306         self.top_sectionlevel = 1
307         if self.config.latex_toplevel_sectioning:
308             try:
309                 self.top_sectionlevel = \
310                     self.sectionnames.index(self.config.latex_toplevel_sectioning)
311             except ValueError:
312                 logger.warning(__('unknown %r toplevel_sectioning for class %r') %
313                                (self.config.latex_toplevel_sectioning, self.theme.docclass))
314 
315         if self.config.numfig:
316             self.numfig_secnum_depth = self.config.numfig_secnum_depth
317             if self.numfig_secnum_depth > 0:  # default is 1
318                 # numfig_secnum_depth as passed to sphinx.sty indices same names as in
319                 # LATEXSECTIONNAMES but with -1 for part, 0 for chapter, 1 for section...
320                 if len(self.sectionnames) < len(LATEXSECTIONNAMES) and \
321                    self.top_sectionlevel > 0:
322                     self.numfig_secnum_depth += self.top_sectionlevel
323                 else:
324                     self.numfig_secnum_depth += self.top_sectionlevel - 1
325                 # this (minus one) will serve as minimum to LaTeX's secnumdepth
326                 self.numfig_secnum_depth = min(self.numfig_secnum_depth,
327                                                len(LATEXSECTIONNAMES) - 1)
328                 # if passed key value is < 1 LaTeX will act as if 0; see sphinx.sty
329                 sphinxpkgoptions.append('numfigreset=%s' % self.numfig_secnum_depth)
330             else:
331                 sphinxpkgoptions.append('nonumfigreset')
332 
333         if self.config.numfig and self.config.math_numfig:
334             sphinxpkgoptions.append('mathnumfig')
335 
336         if (self.config.language not in {None, 'en', 'ja'} and
337                 'fncychap' not in self.config.latex_elements):
338             # use Sonny style if any language specified (except English)
339             self.elements['fncychap'] = (r'\usepackage[Sonny]{fncychap}' + CR +
340                                          r'\ChNameVar{\Large\normalfont\sffamily}' + CR +
341                                          r'\ChTitleVar{\Large\normalfont\sffamily}')
342 
343         self.babel = self.builder.babel
344         if self.config.language and not self.babel.is_supported_language():
345             # emit warning if specified language is invalid
346             # (only emitting, nothing changed to processing)
347             logger.warning(__('no Babel option known for language %r'),
348                            self.config.language)
349 
350         minsecnumdepth = self.secnumdepth  # 2 from legacy sphinx manual/howto
351         if self.document.get('tocdepth'):
352             # reduce tocdepth if `part` or `chapter` is used for top_sectionlevel
353             #   tocdepth = -1: show only parts
354             #   tocdepth =  0: show parts and chapters
355             #   tocdepth =  1: show parts, chapters and sections
356             #   tocdepth =  2: show parts, chapters, sections and subsections
357             #   ...
358             tocdepth = self.document.get('tocdepth', 999) + self.top_sectionlevel - 2
359             if len(self.sectionnames) < len(LATEXSECTIONNAMES) and \
360                self.top_sectionlevel > 0:
361                 tocdepth += 1  # because top_sectionlevel is shifted by -1
362             if tocdepth > len(LATEXSECTIONNAMES) - 2:  # default is 5 <-> subparagraph
363                 logger.warning(__('too large :maxdepth:, ignored.'))
364                 tocdepth = len(LATEXSECTIONNAMES) - 2
365 
366             self.elements['tocdepth'] = r'\setcounter{tocdepth}{%d}' % tocdepth
367             minsecnumdepth = max(minsecnumdepth, tocdepth)
368 
369         if self.config.numfig and (self.config.numfig_secnum_depth > 0):
370             minsecnumdepth = max(minsecnumdepth, self.numfig_secnum_depth - 1)
371 
372         if minsecnumdepth > self.secnumdepth:
373             self.elements['secnumdepth'] = r'\setcounter{secnumdepth}{%d}' %\
374                                            minsecnumdepth
375 
376         contentsname = document.get('contentsname')
377         if contentsname:
378             self.elements['contentsname'] = self.babel_renewcommand(r'\contentsname',
379                                                                     contentsname)
380 
381         if self.elements['maxlistdepth']:
382             sphinxpkgoptions.append('maxlistdepth=%s' % self.elements['maxlistdepth'])
383         if sphinxpkgoptions:
384             self.elements['sphinxpkgoptions'] = '[,%s]' % ','.join(sphinxpkgoptions)
385         if self.elements['sphinxsetup']:
386             self.elements['sphinxsetup'] = (r'\sphinxsetup{%s}' % self.elements['sphinxsetup'])
387         if self.elements['extraclassoptions']:
388             self.elements['classoptions'] += ',' + \
389                                              self.elements['extraclassoptions']
390 
391         self.highlighter = highlighting.PygmentsBridge('latex', self.config.pygments_style,
392                                                        latex_engine=self.config.latex_engine)
393         self.context: List[Any] = []
394         self.descstack: List[str] = []
395         self.tables: List[Table] = []
396         self.next_table_colspec: str = None
397         self.bodystack: List[List[str]] = []
398         self.footnote_restricted: Element = None
399         self.pending_footnotes: List[nodes.footnote_reference] = []
400         self.curfilestack: List[str] = []
401         self.handled_abbrs: Set[str] = set()
402 
403     def pushbody(self, newbody: List[str]) -> None:
404         self.bodystack.append(self.body)
405         self.body = newbody
406 
407     def popbody(self) -> List[str]:
408         body = self.body
409         self.body = self.bodystack.pop()
410         return body
411 
412     def astext(self) -> str:
413         self.elements.update({
414             'body': ''.join(self.body),
415             'indices': self.generate_indices()
416         })
417         return self.render('latex.tex_t', self.elements)
418 
419     def hypertarget(self, id: str, withdoc: bool = True, anchor: bool = True) -> str:
420         if withdoc:
421             id = self.curfilestack[-1] + ':' + id
422         return (r'\phantomsection' if anchor else '') + r'\label{%s}' % self.idescape(id)
423 
424     def hypertarget_to(self, node: Element, anchor: bool = False) -> str:
425         labels = ''.join(self.hypertarget(node_id, anchor=False) for node_id in node['ids'])
426         if anchor:
427             return r'\phantomsection' + labels
428         else:
429             return labels
430 
431     def hyperlink(self, id: str) -> str:
432         return r'{\hyperref[%s]{' % self.idescape(id)
433 
434     def hyperpageref(self, id: str) -> str:
435         return r'\autopageref*{%s}' % self.idescape(id)
436 
437     def escape(self, s: str) -> str:
438         return texescape.escape(s, self.config.latex_engine)
439 
440     def idescape(self, id: str) -> str:
441         return r'\detokenize{%s}' % str(id).translate(tex_replace_map).\
442             encode('ascii', 'backslashreplace').decode('ascii').\
443             replace('\\', '_')
444 
445     def babel_renewcommand(self, command: str, definition: str) -> str:
446         if self.elements['multilingual']:
447             prefix = r'\addto\captions%s{' % self.babel.get_language()
448             suffix = '}'
449         else:  # babel is disabled (mainly for Japanese environment)
450             prefix = ''
451             suffix = ''
452 
453         return r'%s\renewcommand{%s}{%s}%s' % (prefix, command, definition, suffix) + CR
454 
455     def generate_indices(self) -> str:
456         def generate(content: List[Tuple[str, List[IndexEntry]]], collapsed: bool) -> None:
457             ret.append(r'\begin{sphinxtheindex}' + CR)
458             ret.append(r'\let\bigletter\sphinxstyleindexlettergroup' + CR)
459             for i, (letter, entries) in enumerate(content):
460                 if i > 0:
461                     ret.append(r'\indexspace' + CR)
462                 ret.append(r'\bigletter{%s}' % self.escape(letter) + CR)
463                 for entry in entries:
464                     if not entry[3]:
465                         continue
466                     ret.append(r'\item\relax\sphinxstyleindexentry{%s}' %
467                                self.encode(entry[0]))
468                     if entry[4]:
469                         # add "extra" info
470                         ret.append(r'\sphinxstyleindexextra{%s}' % self.encode(entry[4]))
471                     ret.append(r'\sphinxstyleindexpageref{%s:%s}' %
472                                (entry[2], self.idescape(entry[3])) + CR)
473             ret.append(r'\end{sphinxtheindex}' + CR)
474 
475         ret = []
476         # latex_domain_indices can be False/True or a list of index names
477         indices_config = self.config.latex_domain_indices
478         if indices_config:
479             for domain in self.builder.env.domains.values():
480                 for indexcls in domain.indices:
481                     indexname = '%s-%s' % (domain.name, indexcls.name)
482                     if isinstance(indices_config, list):
483                         if indexname not in indices_config:
484                             continue
485                     content, collapsed = indexcls(domain).generate(
486                         self.builder.docnames)
487                     if not content:
488                         continue
489                     ret.append(r'\renewcommand{\indexname}{%s}' % indexcls.localname + CR)
490                     generate(content, collapsed)
491 
492         return ''.join(ret)
493 
494     def render(self, template_name: str, variables: Dict) -> str:
495         renderer = LaTeXRenderer(latex_engine=self.config.latex_engine)
496         for template_dir in self.config.templates_path:
497             template = path.join(self.builder.confdir, template_dir,
498                                  template_name)
499             if path.exists(template):
500                 return renderer.render(template, variables)
501 
502         return renderer.render(template_name, variables)
503 
504     @property
505     def table(self) -> Table:
506         """Get current table."""
507         if self.tables:
508             return self.tables[-1]
509         else:
510             return None
511 
512     def visit_document(self, node: Element) -> None:
513         self.curfilestack.append(node.get('docname', ''))
514         if self.first_document == 1:
515             # the first document is all the regular content ...
516             self.first_document = 0
517         elif self.first_document == 0:
518             # ... and all others are the appendices
519             self.body.append(CR + r'\appendix' + CR)
520             self.first_document = -1
521         if 'docname' in node:
522             self.body.append(self.hypertarget(':doc'))
523         # "- 1" because the level is increased before the title is visited
524         self.sectionlevel = self.top_sectionlevel - 1
525 
526     def depart_document(self, node: Element) -> None:
527         pass
528 
529     def visit_start_of_file(self, node: Element) -> None:
530         self.curfilestack.append(node['docname'])
531 
532     def depart_start_of_file(self, node: Element) -> None:
533         self.curfilestack.pop()
534 
535     def visit_section(self, node: Element) -> None:
536         if not self.this_is_the_title:
537             self.sectionlevel += 1
538         self.body.append(BLANKLINE)
539 
540     def depart_section(self, node: Element) -> None:
541         self.sectionlevel = max(self.sectionlevel - 1,
542                                 self.top_sectionlevel - 1)
543 
544     def visit_problematic(self, node: Element) -> None:
545         self.body.append(r'{\color{red}\bfseries{}')
546 
547     def depart_problematic(self, node: Element) -> None:
548         self.body.append('}')
549 
550     def visit_topic(self, node: Element) -> None:
551         self.in_minipage = 1
552         self.body.append(CR + r'\begin{sphinxShadowBox}' + CR)
553 
554     def depart_topic(self, node: Element) -> None:
555         self.in_minipage = 0
556         self.body.append(r'\end{sphinxShadowBox}' + CR)
557     visit_sidebar = visit_topic
558     depart_sidebar = depart_topic
559 
560     def visit_glossary(self, node: Element) -> None:
561         pass
562 
563     def depart_glossary(self, node: Element) -> None:
564         pass
565 
566     def visit_productionlist(self, node: Element) -> None:
567         self.body.append(BLANKLINE)
568         self.body.append(r'\begin{productionlist}' + CR)
569         self.in_production_list = 1
570 
571     def depart_productionlist(self, node: Element) -> None:
572         self.body.append(r'\end{productionlist}' + BLANKLINE)
573         self.in_production_list = 0
574 
575     def visit_production(self, node: Element) -> None:
576         if node['tokenname']:
577             tn = node['tokenname']
578             self.body.append(self.hypertarget('grammar-token-' + tn))
579             self.body.append(r'\production{%s}{' % self.encode(tn))
580         else:
581             self.body.append(r'\productioncont{')
582 
583     def depart_production(self, node: Element) -> None:
584         self.body.append('}' + CR)
585 
586     def visit_transition(self, node: Element) -> None:
587         self.body.append(self.elements['transition'])
588 
589     def depart_transition(self, node: Element) -> None:
590         pass
591 
592     def visit_title(self, node: Element) -> None:
593         parent = node.parent
594         if isinstance(parent, addnodes.seealso):
595             # the environment already handles this
596             raise nodes.SkipNode
597         elif isinstance(parent, nodes.section):
598             if self.this_is_the_title:
599                 if len(node.children) != 1 and not isinstance(node.children[0],
600                                                               nodes.Text):
601                     logger.warning(__('document title is not a single Text node'),
602                                    location=node)
603                 if not self.elements['title']:
604                     # text needs to be escaped since it is inserted into
605                     # the output literally
606                     self.elements['title'] = self.escape(node.astext())
607                 self.this_is_the_title = 0
608                 raise nodes.SkipNode
609             else:
610                 short = ''
611                 if list(node.traverse(nodes.image)):
612                     short = ('[%s]' % self.escape(' '.join(clean_astext(node).split())))
613 
614                 try:
615                     self.body.append(r'\%s%s{' % (self.sectionnames[self.sectionlevel], short))
616                 except IndexError:
617                     # just use "subparagraph", it's not numbered anyway
618                     self.body.append(r'\%s%s{' % (self.sectionnames[-1], short))
619                 self.context.append('}' + CR + self.hypertarget_to(node.parent))
620         elif isinstance(parent, nodes.topic):
621             self.body.append(r'\sphinxstyletopictitle{')
622             self.context.append('}' + CR)
623         elif isinstance(parent, nodes.sidebar):
624             self.body.append(r'\sphinxstylesidebartitle{')
625             self.context.append('}' + CR)
626         elif isinstance(parent, nodes.Admonition):
627             self.body.append('{')
628             self.context.append('}' + CR)
629         elif isinstance(parent, nodes.table):
630             # Redirect body output until title is finished.
631             self.pushbody([])
632         else:
633             logger.warning(__('encountered title node not in section, topic, table, '
634                               'admonition or sidebar'),
635                            location=node)
636             self.body.append(r'\sphinxstyleothertitle{')
637             self.context.append('}' + CR)
638         self.in_title = 1
639 
640     def depart_title(self, node: Element) -> None:
641         self.in_title = 0
642         if isinstance(node.parent, nodes.table):
643             self.table.caption = self.popbody()
644         else:
645             self.body.append(self.context.pop())
646 
647     def visit_subtitle(self, node: Element) -> None:
648         if isinstance(node.parent, nodes.sidebar):
649             self.body.append(r'\sphinxstylesidebarsubtitle{')
650             self.context.append('}' + CR)
651         else:
652             self.context.append('')
653 
654     def depart_subtitle(self, node: Element) -> None:
655         self.body.append(self.context.pop())
656 
657     #############################################################
658     # Domain-specific object descriptions
659     #############################################################
660 
661     # Top-level nodes for descriptions
662     ##################################
663 
664     def visit_desc(self, node: Element) -> None:
665         if self.config.latex_show_urls == 'footnote':
666             self.body.append(BLANKLINE)
667             self.body.append(r'\begin{savenotes}\begin{fulllineitems}' + CR)
668         else:
669             self.body.append(BLANKLINE)
670             self.body.append(r'\begin{fulllineitems}' + CR)
671         if self.table:
672             self.table.has_problematic = True
673 
674     def depart_desc(self, node: Element) -> None:
675         if self.config.latex_show_urls == 'footnote':
676             self.body.append(CR + r'\end{fulllineitems}\end{savenotes}' + BLANKLINE)
677         else:
678             self.body.append(CR + r'\end{fulllineitems}' + BLANKLINE)
679 
680     def _visit_signature_line(self, node: Element) -> None:
681         for child in node:
682             if isinstance(child, addnodes.desc_parameterlist):
683                 self.body.append(r'\pysiglinewithargsret{')
684                 break
685         else:
686             self.body.append(r'\pysigline{')
687 
688     def _depart_signature_line(self, node: Element) -> None:
689         self.body.append('}')
690 
691     def visit_desc_signature(self, node: Element) -> None:
692         if node.parent['objtype'] != 'describe' and node['ids']:
693             hyper = self.hypertarget(node['ids'][0])
694         else:
695             hyper = ''
696         self.body.append(hyper)
697         if not node.get('is_multiline'):
698             self._visit_signature_line(node)
699         else:
700             self.body.append('%' + CR)
701             self.body.append(r'\pysigstartmultiline' + CR)
702 
703     def depart_desc_signature(self, node: Element) -> None:
704         if not node.get('is_multiline'):
705             self._depart_signature_line(node)
706         else:
707             self.body.append('%' + CR)
708             self.body.append(r'\pysigstopmultiline')
709 
710     def visit_desc_signature_line(self, node: Element) -> None:
711         self._visit_signature_line(node)
712 
713     def depart_desc_signature_line(self, node: Element) -> None:
714         self._depart_signature_line(node)
715 
716     def visit_desc_content(self, node: Element) -> None:
717         pass
718 
719     def depart_desc_content(self, node: Element) -> None:
720         pass
721 
722     def visit_desc_inline(self, node: Element) -> None:
723         self.body.append(r'\sphinxcode{\sphinxupquote{')
724 
725     def depart_desc_inline(self, node: Element) -> None:
726         self.body.append('}}')
727 
728     # Nodes for high-level structure in signatures
729     ##############################################
730 
731     def visit_desc_name(self, node: Element) -> None:
732         self.body.append(r'\sphinxbfcode{\sphinxupquote{')
733         self.literal_whitespace += 1
734 
735     def depart_desc_name(self, node: Element) -> None:
736         self.body.append('}}')
737         self.literal_whitespace -= 1
738 
739     def visit_desc_addname(self, node: Element) -> None:
740         self.body.append(r'\sphinxcode{\sphinxupquote{')
741         self.literal_whitespace += 1
742 
743     def depart_desc_addname(self, node: Element) -> None:
744         self.body.append('}}')
745         self.literal_whitespace -= 1
746 
747     def visit_desc_type(self, node: Element) -> None:
748         pass
749 
750     def depart_desc_type(self, node: Element) -> None:
751         pass
752 
753     def visit_desc_returns(self, node: Element) -> None:
754         self.body.append(r'{ $\rightarrow$ ')
755 
756     def depart_desc_returns(self, node: Element) -> None:
757         self.body.append(r'}')
758 
759     def visit_desc_parameterlist(self, node: Element) -> None:
760         # close name, open parameterlist
761         self.body.append('}{')
762         self.first_param = 1
763 
764     def depart_desc_parameterlist(self, node: Element) -> None:
765         # close parameterlist, open return annotation
766         self.body.append('}{')
767 
768     def visit_desc_parameter(self, node: Element) -> None:
769         if not self.first_param:
770             self.body.append(', ')
771         else:
772             self.first_param = 0
773         if not node.hasattr('noemph'):
774             self.body.append(r'\emph{')
775 
776     def depart_desc_parameter(self, node: Element) -> None:
777         if not node.hasattr('noemph'):
778             self.body.append('}')
779 
780     def visit_desc_optional(self, node: Element) -> None:
781         self.body.append(r'\sphinxoptional{')
782 
783     def depart_desc_optional(self, node: Element) -> None:
784         self.body.append('}')
785 
786     def visit_desc_annotation(self, node: Element) -> None:
787         self.body.append(r'\sphinxbfcode{\sphinxupquote{')
788 
789     def depart_desc_annotation(self, node: Element) -> None:
790         self.body.append('}}')
791 
792     ##############################################
793 
794     def visit_seealso(self, node: Element) -> None:
795         self.body.append(BLANKLINE)
796         self.body.append(r'\sphinxstrong{%s:}' % admonitionlabels['seealso'] + CR)
797         self.body.append(r'\nopagebreak' + BLANKLINE)
798 
799     def depart_seealso(self, node: Element) -> None:
800         self.body.append(BLANKLINE)
801 
802     def visit_rubric(self, node: Element) -> None:
803         if len(node) == 1 and node.astext() in ('Footnotes', _('Footnotes')):
804             raise nodes.SkipNode
805         self.body.append(r'\subsubsection*{')
806         self.context.append('}' + CR)
807         self.in_title = 1
808 
809     def depart_rubric(self, node: Element) -> None:
810         self.in_title = 0
811         self.body.append(self.context.pop())
812 
813     def visit_footnote(self, node: Element) -> None:
814         self.in_footnote += 1
815         label = cast(nodes.label, node[0])
816         if 'auto' not in node:
817             self.body.append(r'\sphinxstepexplicit ')
818         if self.in_parsed_literal:
819             self.body.append(r'\begin{footnote}[%s]' % label.astext())
820         else:
821             self.body.append('%' + CR)
822             self.body.append(r'\begin{footnote}[%s]' % label.astext())
823         if 'auto' not in node:
824             self.body.append(r'\phantomsection'
825                              r'\label{\thesphinxscope.%s}%%' % label.astext() + CR)
826         self.body.append(r'\sphinxAtStartFootnote' + CR)
827 
828     def depart_footnote(self, node: Element) -> None:
829         if self.in_parsed_literal:
830             self.body.append(r'\end{footnote}')
831         else:
832             self.body.append('%' + CR)
833             self.body.append(r'\end{footnote}')
834         self.in_footnote -= 1
835 
836     def visit_label(self, node: Element) -> None:
837         raise nodes.SkipNode
838 
839     def visit_tabular_col_spec(self, node: Element) -> None:
840         self.next_table_colspec = node['spec']
841         raise nodes.SkipNode
842 
843     def visit_table(self, node: Element) -> None:
844         if len(self.tables) == 1:
845             if self.table.get_table_type() == 'longtable':
846                 raise UnsupportedError(
847                     '%s:%s: longtable does not support nesting a table.' %
848                     (self.curfilestack[-1], node.line or ''))
849             else:
850                 # change type of parent table to tabular
851                 # see https://groups.google.com/d/msg/sphinx-users/7m3NeOBixeo/9LKP2B4WBQAJ
852                 self.table.has_problematic = True
853         elif len(self.tables) > 2:
854             raise UnsupportedError(
855                 '%s:%s: deeply nested tables are not implemented.' %
856                 (self.curfilestack[-1], node.line or ''))
857 
858         self.tables.append(Table(node))
859         if self.next_table_colspec:
860             self.table.colspec = '{%s}' % self.next_table_colspec + CR
861             if 'colwidths-given' in node.get('classes', []):
862                 logger.info(__('both tabularcolumns and :widths: option are given. '
863                                ':widths: is ignored.'), location=node)
864         self.next_table_colspec = None
865 
866     def depart_table(self, node: Element) -> None:
867         labels = self.hypertarget_to(node)
868         table_type = self.table.get_table_type()
869         table = self.render(table_type + '.tex_t',
870                             dict(table=self.table, labels=labels))
871         self.body.append(BLANKLINE)
872         self.body.append(table)
873         self.body.append(CR)
874 
875         self.tables.pop()
876 
877     def visit_colspec(self, node: Element) -> None:
878         self.table.colcount += 1
879         if 'colwidth' in node:
880             self.table.colwidths.append(node['colwidth'])
881         if 'stub' in node:
882             self.table.stubs.append(self.table.colcount - 1)
883 
884     def depart_colspec(self, node: Element) -> None:
885         pass
886 
887     def visit_tgroup(self, node: Element) -> None:
888         pass
889 
890     def depart_tgroup(self, node: Element) -> None:
891         pass
892 
893     def visit_thead(self, node: Element) -> None:
894         # Redirect head output until header is finished.
895         self.pushbody(self.table.header)
896 
897     def depart_thead(self, node: Element) -> None:
898         self.popbody()
899 
900     def visit_tbody(self, node: Element) -> None:
901         # Redirect body output until table is finished.
902         self.pushbody(self.table.body)
903 
904     def depart_tbody(self, node: Element) -> None:
905         self.popbody()
906 
907     def visit_row(self, node: Element) -> None:
908         self.table.col = 0
909 
910         # fill columns if the row starts with the bottom of multirow cell
911         while True:
912             cell = self.table.cell(self.table.row, self.table.col)
913             if cell is None:  # not a bottom of multirow cell
914                 break
915             else:  # a bottom of multirow cell
916                 self.table.col += cell.width
917                 if cell.col:
918                     self.body.append('&')
919                 if cell.width == 1:
920                     # insert suitable strut for equalizing row heights in given multirow
921                     self.body.append(r'\sphinxtablestrut{%d}' % cell.cell_id)
922                 else:  # use \multicolumn for wide multirow cell
923                     self.body.append(r'\multicolumn{%d}{|l|}{\sphinxtablestrut{%d}}' %
924                                      (cell.width, cell.cell_id))
925 
926     def depart_row(self, node: Element) -> None:
927         self.body.append(r'\\' + CR)
928         cells = [self.table.cell(self.table.row, i) for i in range(self.table.colcount)]
929         underlined = [cell.row + cell.height == self.table.row + 1 for cell in cells]
930         if all(underlined):
931             self.body.append(r'\hline')
932         else:
933             i = 0
934             underlined.extend([False])  # sentinel
935             while i < len(underlined):
936                 if underlined[i] is True:
937                     j = underlined[i:].index(False)
938                     self.body.append(r'\cline{%d-%d}' % (i + 1, i + j))
939                     i += j
940                 i += 1
941         self.table.row += 1
942 
943     def visit_entry(self, node: Element) -> None:
944         if self.table.col > 0:
945             self.body.append('&')
946         self.table.add_cell(node.get('morerows', 0) + 1, node.get('morecols', 0) + 1)
947         cell = self.table.cell()
948         context = ''
949         if cell.width > 1:
950             if self.config.latex_use_latex_multicolumn:
951                 if self.table.col == 0:
952                     self.body.append(r'\multicolumn{%d}{|l|}{%%' % cell.width + CR)
953                 else:
954                     self.body.append(r'\multicolumn{%d}{l|}{%%' % cell.width + CR)
955                 context = '}%' + CR
956             else:
957                 self.body.append(r'\sphinxstartmulticolumn{%d}%%' % cell.width + CR)
958                 context = r'\sphinxstopmulticolumn' + CR
959         if cell.height > 1:
960             # \sphinxmultirow 2nd arg "cell_id" will serve as id for LaTeX macros as well
961             self.body.append(r'\sphinxmultirow{%d}{%d}{%%' % (cell.height, cell.cell_id) + CR)
962             context = '}%' + CR + context
963         if cell.width > 1 or cell.height > 1:
964             self.body.append(r'\begin{varwidth}[t]{\sphinxcolwidth{%d}{%d}}'
965                              % (cell.width, self.table.colcount) + CR)
966             context = (r'\par' + CR + r'\vskip-\baselineskip'
967                        r'\vbox{\hbox{\strut}}\end{varwidth}%' + CR + context)
968             self.needs_linetrimming = 1
969         if len(list(node.traverse(nodes.paragraph))) >= 2:
970             self.table.has_oldproblematic = True
971         if isinstance(node.parent.parent, nodes.thead) or (cell.col in self.table.stubs):
972             if len(node) == 1 and isinstance(node[0], nodes.paragraph) and node.astext() == '':
973                 pass
974             else:
975                 self.body.append(r'\sphinxstyletheadfamily ')
976         if self.needs_linetrimming:
977             self.pushbody([])
978         self.context.append(context)
979 
980     def depart_entry(self, node: Element) -> None:
981         if self.needs_linetrimming:
982             self.needs_linetrimming = 0
983             body = self.popbody()
984 
985             # Remove empty lines from top of merged cell
986             while body and body[0] == CR:
987                 body.pop(0)
988             self.body.extend(body)
989 
990         self.body.append(self.context.pop())
991 
992         cell = self.table.cell()
993         self.table.col += cell.width
994 
995         # fill columns if next ones are a bottom of wide-multirow cell
996         while True:
997             nextcell = self.table.cell()
998             if nextcell is None:  # not a bottom of multirow cell
999                 break
1000             else:  # a bottom part of multirow cell
1001                 self.table.col += nextcell.width
1002                 self.body.append('&')
1003                 if nextcell.width == 1:
1004                     # insert suitable strut for equalizing row heights in multirow
1005                     # they also serve to clear colour panels which would hide the text
1006                     self.body.append(r'\sphinxtablestrut{%d}' % nextcell.cell_id)
1007                 else:
1008                     # use \multicolumn for wide multirow cell
1009                     self.body.append(r'\multicolumn{%d}{l|}{\sphinxtablestrut{%d}}' %
1010                                      (nextcell.width, nextcell.cell_id))
1011 
1012     def visit_acks(self, node: Element) -> None:
1013         # this is a list in the source, but should be rendered as a
1014         # comma-separated list here
1015         bullet_list = cast(nodes.bullet_list, node[0])
1016         list_items = cast(Iterable[nodes.list_item], bullet_list)
1017         self.body.append(BLANKLINE)
1018         self.body.append(', '.join(n.astext() for n in list_items) + '.')
1019         self.body.append(BLANKLINE)
1020         raise nodes.SkipNode
1021 
1022     def visit_bullet_list(self, node: Element) -> None:
1023         if not self.compact_list:
1024             self.body.append(r'\begin{itemize}' + CR)
1025         if self.table:
1026             self.table.has_problematic = True
1027 
1028     def depart_bullet_list(self, node: Element) -> None:
1029         if not self.compact_list:
1030             self.body.append(r'\end{itemize}' + CR)
1031 
1032     def visit_enumerated_list(self, node: Element) -> None:
1033         def get_enumtype(node: Element) -> str:
1034             enumtype = node.get('enumtype', 'arabic')
1035             if 'alpha' in enumtype and 26 < node.get('start', 0) + len(node):
1036                 # fallback to arabic if alphabet counter overflows
1037                 enumtype = 'arabic'
1038 
1039             return enumtype
1040 
1041         def get_nested_level(node: Element) -> int:
1042             if node is None:
1043                 return 0
1044             elif isinstance(node, nodes.enumerated_list):
1045                 return get_nested_level(node.parent) + 1
1046             else:
1047                 return get_nested_level(node.parent)
1048 
1049         enum = "enum%s" % toRoman(get_nested_level(node)).lower()
1050         enumnext = "enum%s" % toRoman(get_nested_level(node) + 1).lower()
1051         style = ENUMERATE_LIST_STYLE.get(get_enumtype(node))
1052         prefix = node.get('prefix', '')
1053         suffix = node.get('suffix', '.')
1054 
1055         self.body.append(r'\begin{enumerate}' + CR)
1056         self.body.append(r'\sphinxsetlistlabels{%s}{%s}{%s}{%s}{%s}%%' %
1057                          (style, enum, enumnext, prefix, suffix) + CR)
1058         if 'start' in node:
1059             self.body.append(r'\setcounter{%s}{%d}' % (enum, node['start'] - 1) + CR)
1060         if self.table:
1061             self.table.has_problematic = True
1062 
1063     def depart_enumerated_list(self, node: Element) -> None:
1064         self.body.append(r'\end{enumerate}' + CR)
1065 
1066     def visit_list_item(self, node: Element) -> None:
1067         # Append "{}" in case the next character is "[", which would break
1068         # LaTeX's list environment (no numbering and the "[" is not printed).
1069         self.body.append(r'\item {} ')
1070 
1071     def depart_list_item(self, node: Element) -> None:
1072         self.body.append(CR)
1073 
1074     def visit_definition_list(self, node: Element) -> None:
1075         self.body.append(r'\begin{description}' + CR)
1076         if self.table:
1077             self.table.has_problematic = True
1078 
1079     def depart_definition_list(self, node: Element) -> None:
1080         self.body.append(r'\end{description}' + CR)
1081 
1082     def visit_definition_list_item(self, node: Element) -> None:
1083         pass
1084 
1085     def depart_definition_list_item(self, node: Element) -> None:
1086         pass
1087 
1088     def visit_term(self, node: Element) -> None:
1089         self.in_term += 1
1090         ctx = ''
1091         if node.get('ids'):
1092             ctx = r'\phantomsection'
1093             for node_id in node['ids']:
1094                 ctx += self.hypertarget(node_id, anchor=False)
1095         ctx += r'}] \leavevmode'
1096         self.body.append(r'\item[{')
1097         self.context.append(ctx)
1098 
1099     def depart_term(self, node: Element) -> None:
1100         self.body.append(self.context.pop())
1101         self.in_term -= 1
1102 
1103     def visit_classifier(self, node: Element) -> None:
1104         self.body.append('{[}')
1105 
1106     def depart_classifier(self, node: Element) -> None:
1107         self.body.append('{]}')
1108 
1109     def visit_definition(self, node: Element) -> None:
1110         pass
1111 
1112     def depart_definition(self, node: Element) -> None:
1113         self.body.append(CR)
1114 
1115     def visit_field_list(self, node: Element) -> None:
1116         self.body.append(r'\begin{quote}\begin{description}' + CR)
1117         if self.table:
1118             self.table.has_problematic = True
1119 
1120     def depart_field_list(self, node: Element) -> None:
1121         self.body.append(r'\end{description}\end{quote}' + CR)
1122 
1123     def visit_field(self, node: Element) -> None:
1124         pass
1125 
1126     def depart_field(self, node: Element) -> None:
1127         pass
1128 
1129     visit_field_name = visit_term
1130     depart_field_name = depart_term
1131 
1132     visit_field_body = visit_definition
1133     depart_field_body = depart_definition
1134 
1135     def visit_paragraph(self, node: Element) -> None:
1136         index = node.parent.index(node)
1137         if (index > 0 and isinstance(node.parent, nodes.compound) and
1138                 not isinstance(node.parent[index - 1], nodes.paragraph) and
1139                 not isinstance(node.parent[index - 1], nodes.compound)):
1140             # insert blank line, if the paragraph follows a non-paragraph node in a compound
1141             self.body.append(r'\noindent' + CR)
1142         elif index == 1 and isinstance(node.parent, (nodes.footnote, footnotetext)):
1143             # don't insert blank line, if the paragraph is second child of a footnote
1144             # (first one is label node)
1145             pass
1146         else:
1147             # the \sphinxAtStartPar is to allow hyphenation of first word of
1148             # a paragraph in narrow contexts such as in a table cell
1149             # added as two items (cf. line trimming in depart_entry())
1150             self.body.extend([CR, r'\sphinxAtStartPar' + CR])
1151 
1152     def depart_paragraph(self, node: Element) -> None:
1153         self.body.append(CR)
1154 
1155     def visit_centered(self, node: Element) -> None:
1156         self.body.append(CR + r'\begin{center}')
1157         if self.table:
1158             self.table.has_problematic = True
1159 
1160     def depart_centered(self, node: Element) -> None:
1161         self.body.append(CR + r'\end{center}')
1162 
1163     def visit_hlist(self, node: Element) -> None:
1164         self.compact_list += 1
1165         ncolumns = node['ncolumns']
1166         if self.compact_list > 1:
1167             self.body.append(r'\setlength{\multicolsep}{0pt}' + CR)
1168         self.body.append(r'\begin{multicols}{' + ncolumns + r'}\raggedright' + CR)
1169         self.body.append(r'\begin{itemize}\setlength{\itemsep}{0pt}'
1170                          r'\setlength{\parskip}{0pt}' + CR)
1171         if self.table:
1172             self.table.has_problematic = True
1173 
1174     def depart_hlist(self, node: Element) -> None:
1175         self.compact_list -= 1
1176         self.body.append(r'\end{itemize}\raggedcolumns\end{multicols}' + CR)
1177 
1178     def visit_hlistcol(self, node: Element) -> None:
1179         pass
1180 
1181     def depart_hlistcol(self, node: Element) -> None:
1182         # \columnbreak would guarantee same columns as in html output.  But
1183         # some testing with long items showed that columns may be too uneven.
1184         # And in case only of short items, the automatic column breaks should
1185         # match the ones pre-computed by the hlist() directive.
1186         # self.body.append(r'\columnbreak\n')
1187         pass
1188 
1189     def latex_image_length(self, width_str: str, scale: int = 100) -> str:
1190         try:
1191             return rstdim_to_latexdim(width_str, scale)
1192         except ValueError:
1193             logger.warning(__('dimension unit %s is invalid. Ignored.'), width_str)
1194             return None
1195 
1196     def is_inline(self, node: Element) -> bool:
1197         """Check whether a node represents an inline element."""
1198         return isinstance(node.parent, nodes.TextElement)
1199 
1200     def visit_image(self, node: Element) -> None:
1201         pre: List[str] = []  # in reverse order
1202         post: List[str] = []
1203         include_graphics_options = []
1204         has_hyperlink = isinstance(node.parent, nodes.reference)
1205         if has_hyperlink:
1206             is_inline = self.is_inline(node.parent)
1207         else:
1208             is_inline = self.is_inline(node)
1209         if 'width' in node:
1210             if 'scale' in node:
1211                 w = self.latex_image_length(node['width'], node['scale'])
1212             else:
1213                 w = self.latex_image_length(node['width'])
1214             if w:
1215                 include_graphics_options.append('width=%s' % w)
1216         if 'height' in node:
1217             if 'scale' in node:
1218                 h = self.latex_image_length(node['height'], node['scale'])
1219             else:
1220                 h = self.latex_image_length(node['height'])
1221             if h:
1222                 include_graphics_options.append('height=%s' % h)
1223         if 'scale' in node:
1224             if not include_graphics_options:
1225                 # if no "width" nor "height", \sphinxincludegraphics will fit
1226                 # to the available text width if oversized after rescaling.
1227                 include_graphics_options.append('scale=%s'
1228                                                 % (float(node['scale']) / 100.0))
1229         if 'align' in node:
1230             align_prepost = {
1231                 # By default latex aligns the top of an image.
1232                 (1, 'top'): ('', ''),
1233                 (1, 'middle'): (r'\raisebox{-0.5\height}{', '}'),
1234                 (1, 'bottom'): (r'\raisebox{-\height}{', '}'),
1235                 (0, 'center'): (r'{\hspace*{\fill}', r'\hspace*{\fill}}'),
1236                 # These 2 don't exactly do the right thing.  The image should
1237                 # be floated alongside the paragraph.  See
1238                 # https://www.w3.org/TR/html4/struct/objects.html#adef-align-IMG
1239                 (0, 'left'): ('{', r'\hspace*{\fill}}'),
1240                 (0, 'right'): (r'{\hspace*{\fill}', '}'),
1241             }
1242             try:
1243                 pre.append(align_prepost[is_inline, node['align']][0])
1244                 post.append(align_prepost[is_inline, node['align']][1])
1245             except KeyError:
1246                 pass
1247         if self.in_parsed_literal:
1248             pre.append(r'{\sphinxunactivateextrasandspace ')
1249             post.append('}')
1250         if not is_inline and not has_hyperlink:
1251             pre.append(CR + r'\noindent')
1252             post.append(CR)
1253         pre.reverse()
1254         if node['uri'] in self.builder.images:
1255             uri = self.builder.images[node['uri']]
1256         else:
1257             # missing image!
1258             if self.ignore_missing_images:
1259                 return
1260             uri = node['uri']
1261         if uri.find('://') != -1:
1262             # ignore remote images
1263             return
1264         self.body.extend(pre)
1265         options = ''
1266         if include_graphics_options:
1267             options = '[%s]' % ','.join(include_graphics_options)
1268         base, ext = path.splitext(uri)
1269         if self.in_title and base:
1270             # Lowercase tokens forcely because some fncychap themes capitalize
1271             # the options of \sphinxincludegraphics unexpectedly (ex. WIDTH=...).
1272             self.body.append(r'\lowercase{\sphinxincludegraphics%s}{{%s}%s}' %
1273                              (options, base, ext))
1274         else:
1275             self.body.append(r'\sphinxincludegraphics%s{{%s}%s}' %
1276                              (options, base, ext))
1277         self.body.extend(post)
1278 
1279     def depart_image(self, node: Element) -> None:
1280         pass
1281 
1282     def visit_figure(self, node: Element) -> None:
1283         align = self.elements['figure_align']
1284         if self.no_latex_floats:
1285             align = "H"
1286         if self.table:
1287             # TODO: support align option
1288             if 'width' in node:
1289                 length = self.latex_image_length(node['width'])
1290                 if length:
1291                     self.body.append(r'\begin{sphinxfigure-in-table}[%s]' % length + CR)
1292                     self.body.append(r'\centering' + CR)
1293             else:
1294                 self.body.append(r'\begin{sphinxfigure-in-table}' + CR)
1295                 self.body.append(r'\centering' + CR)
1296             if any(isinstance(child, nodes.caption) for child in node):
1297                 self.body.append(r'\capstart')
1298             self.context.append(r'\end{sphinxfigure-in-table}\relax' + CR)
1299         elif node.get('align', '') in ('left', 'right'):
1300             length = None
1301             if 'width' in node:
1302                 length = self.latex_image_length(node['width'])
1303             elif isinstance(node[0], nodes.image) and 'width' in node[0]:
1304                 length = self.latex_image_length(node[0]['width'])
1305             self.body.append(BLANKLINE)     # Insert a blank line to prevent infinite loop
1306                                             # https://github.com/sphinx-doc/sphinx/issues/7059
1307             self.body.append(r'\begin{wrapfigure}{%s}{%s}' %
1308                              ('r' if node['align'] == 'right' else 'l', length or '0pt') + CR)
1309             self.body.append(r'\centering')
1310             self.context.append(r'\end{wrapfigure}' + CR)
1311         elif self.in_minipage:
1312             self.body.append(CR + r'\begin{center}')
1313             self.context.append(r'\end{center}' + CR)
1314         else:
1315             self.body.append(CR + r'\begin{figure}[%s]' % align + CR)
1316             self.body.append(r'\centering' + CR)
1317             if any(isinstance(child, nodes.caption) for child in node):
1318                 self.body.append(r'\capstart' + CR)
1319             self.context.append(r'\end{figure}' + CR)
1320 
1321     def depart_figure(self, node: Element) -> None:
1322         self.body.append(self.context.pop())
1323 
1324     def visit_caption(self, node: Element) -> None:
1325         self.in_caption += 1
1326         if isinstance(node.parent, captioned_literal_block):
1327             self.body.append(r'\sphinxSetupCaptionForVerbatim{')
1328         elif self.in_minipage and isinstance(node.parent, nodes.figure):
1329             self.body.append(r'\captionof{figure}{')
1330         elif self.table and node.parent.tagname == 'figure':
1331             self.body.append(r'\sphinxfigcaption{')
1332         else:
1333             self.body.append(r'\caption{')
1334 
1335     def depart_caption(self, node: Element) -> None:
1336         self.body.append('}')
1337         if isinstance(node.parent, nodes.figure):
1338             labels = self.hypertarget_to(node.parent)
1339             self.body.append(labels)
1340         self.in_caption -= 1
1341 
1342     def visit_legend(self, node: Element) -> None:
1343         self.body.append(CR + r'\begin{sphinxlegend}')
1344 
1345     def depart_legend(self, node: Element) -> None:
1346         self.body.append(r'\end{sphinxlegend}' + CR)
1347 
1348     def visit_admonition(self, node: Element) -> None:
1349         self.body.append(CR + r'\begin{sphinxadmonition}{note}')
1350         self.no_latex_floats += 1
1351 
1352     def depart_admonition(self, node: Element) -> None:
1353         self.body.append(r'\end{sphinxadmonition}' + CR)
1354         self.no_latex_floats -= 1
1355 
1356     def _visit_named_admonition(self, node: Element) -> None:
1357         label = admonitionlabels[node.tagname]
1358         self.body.append(CR + r'\begin{sphinxadmonition}{%s}{%s:}' %
1359                          (node.tagname, label))
1360         self.no_latex_floats += 1
1361 
1362     def _depart_named_admonition(self, node: Element) -> None:
1363         self.body.append(r'\end{sphinxadmonition}' + CR)
1364         self.no_latex_floats -= 1
1365 
1366     visit_attention = _visit_named_admonition
1367     depart_attention = _depart_named_admonition
1368     visit_caution = _visit_named_admonition
1369     depart_caution = _depart_named_admonition
1370     visit_danger = _visit_named_admonition
1371     depart_danger = _depart_named_admonition
1372     visit_error = _visit_named_admonition
1373     depart_error = _depart_named_admonition
1374     visit_hint = _visit_named_admonition
1375     depart_hint = _depart_named_admonition
1376     visit_important = _visit_named_admonition
1377     depart_important = _depart_named_admonition
1378     visit_note = _visit_named_admonition
1379     depart_note = _depart_named_admonition
1380     visit_tip = _visit_named_admonition
1381     depart_tip = _depart_named_admonition
1382     visit_warning = _visit_named_admonition
1383     depart_warning = _depart_named_admonition
1384 
1385     def visit_versionmodified(self, node: Element) -> None:
1386         pass
1387 
1388     def depart_versionmodified(self, node: Element) -> None:
1389         pass
1390 
1391     def visit_target(self, node: Element) -> None:
1392         def add_target(id: str) -> None:
1393             # indexing uses standard LaTeX index markup, so the targets
1394             # will be generated differently
1395             if id.startswith('index-'):
1396                 return
1397 
1398             # equations also need no extra blank line nor hypertarget
1399             # TODO: fix this dependency on mathbase extension internals
1400             if id.startswith('equation-'):
1401                 return
1402 
1403             # insert blank line, if the target follows a paragraph node
1404             index = node.parent.index(node)
1405             if index > 0 and isinstance(node.parent[index - 1], nodes.paragraph):
1406                 self.body.append(CR)
1407 
1408             # do not generate \phantomsection in \section{}
1409             anchor = not self.in_title
1410             self.body.append(self.hypertarget(id, anchor=anchor))
1411 
1412         # skip if visitor for next node supports hyperlink
1413         next_node: Node = node
1414         while isinstance(next_node, nodes.target):
1415             next_node = next_node.next_node(ascend=True)
1416 
1417         domain = cast(StandardDomain, self.builder.env.get_domain('std'))
1418         if isinstance(next_node, HYPERLINK_SUPPORT_NODES):
1419             return
1420         elif domain.get_enumerable_node_type(next_node) and domain.get_numfig_title(next_node):
1421             return
1422 
1423         if 'refuri' in node:
1424             return
1425         if 'anonymous' in node:
1426             return
1427         if node.get('refid'):
1428             prev_node = get_prev_node(node)
1429             if isinstance(prev_node, nodes.reference) and node['refid'] == prev_node['refid']:
1430                 # a target for a hyperlink reference having alias
1431                 pass
1432             else:
1433                 add_target(node['refid'])
1434         for id in node['ids']:
1435             add_target(id)
1436 
1437     def depart_target(self, node: Element) -> None:
1438         pass
1439 
1440     def visit_attribution(self, node: Element) -> None:
1441         self.body.append(CR + r'\begin{flushright}' + CR)
1442         self.body.append('---')
1443 
1444     def depart_attribution(self, node: Element) -> None:
1445         self.body.append(CR + r'\end{flushright}' + CR)
1446 
1447     def visit_index(self, node: Element) -> None:
1448         def escape(value: str) -> str:
1449             value = self.encode(value)
1450             value = value.replace(r'\{', r'\sphinxleftcurlybrace{}')
1451             value = value.replace(r'\}', r'\sphinxrightcurlybrace{}')
1452             value = value.replace('"', '""')
1453             value = value.replace('@', '"@')
1454             value = value.replace('!', '"!')
1455             value = value.replace('|', r'\textbar{}')
1456             return value
1457 
1458         def style(string: str) -> str:
1459             match = EXTRA_RE.match(string)
1460             if match:
1461                 return match.expand(r'\\spxentry{\1}\\spxextra{\2}')
1462             else:
1463                 return r'\spxentry{%s}' % string
1464 
1465         if not node.get('inline', True):
1466             self.body.append(CR)
1467         entries = node['entries']
1468         for type, string, tid, ismain, key_ in entries:
1469             m = ''
1470             if ismain:
1471                 m = '|spxpagem'
1472             try:
1473                 if type == 'single':
1474                     try:
1475                         p1, p2 = [escape(x) for x in split_into(2, 'single', string)]
1476                         P1, P2 = style(p1), style(p2)
1477                         self.body.append(r'\index{%s@%s!%s@%s%s}' % (p1, P1, p2, P2, m))
1478                     except ValueError:
1479                         p = escape(split_into(1, 'single', string)[0])
1480                         P = style(p)
1481                         self.body.append(r'\index{%s@%s%s}' % (p, P, m))
1482                 elif type == 'pair':
1483                     p1, p2 = [escape(x) for x in split_into(2, 'pair', string)]
1484                     P1, P2 = style(p1), style(p2)
1485                     self.body.append(r'\index{%s@%s!%s@%s%s}\index{%s@%s!%s@%s%s}' %
1486                                      (p1, P1, p2, P2, m, p2, P2, p1, P1, m))
1487                 elif type == 'triple':
1488                     p1, p2, p3 = [escape(x) for x in split_into(3, 'triple', string)]
1489                     P1, P2, P3 = style(p1), style(p2), style(p3)
1490                     self.body.append(
1491                         r'\index{%s@%s!%s %s@%s %s%s}'
1492                         r'\index{%s@%s!%s, %s@%s, %s%s}'
1493                         r'\index{%s@%s!%s %s@%s %s%s}' %
1494                         (p1, P1, p2, p3, P2, P3, m,
1495                          p2, P2, p3, p1, P3, P1, m,
1496                          p3, P3, p1, p2, P1, P2, m))
1497                 elif type == 'see':
1498                     p1, p2 = [escape(x) for x in split_into(2, 'see', string)]
1499                     P1 = style(p1)
1500                     self.body.append(r'\index{%s@%s|see{%s}}' % (p1, P1, p2))
1501                 elif type == 'seealso':
1502                     p1, p2 = [escape(x) for x in split_into(2, 'seealso', string)]
1503                     P1 = style(p1)
1504                     self.body.append(r'\index{%s@%s|see{%s}}' % (p1, P1, p2))
1505                 else:
1506                     logger.warning(__('unknown index entry type %s found'), type)
1507             except ValueError as err:
1508                 logger.warning(str(err))
1509         if not node.get('inline', True):
1510             self.body.append(r'\ignorespaces ')
1511         raise nodes.SkipNode
1512 
1513     def visit_raw(self, node: Element) -> None:
1514         if not self.is_inline(node):
1515             self.body.append(CR)
1516         if 'latex' in node.get('format', '').split():
1517             self.body.append(node.astext())
1518         if not self.is_inline(node):
1519             self.body.append(CR)
1520         raise nodes.SkipNode
1521 
1522     def visit_reference(self, node: Element) -> None:
1523         if not self.in_title:
1524             for id in node.get('ids'):
1525                 anchor = not self.in_caption
1526                 self.body += self.hypertarget(id, anchor=anchor)
1527         if not self.is_inline(node):
1528             self.body.append(CR)
1529         uri = node.get('refuri', '')
1530         if not uri and node.get('refid'):
1531             uri = '%' + self.curfilestack[-1] + '#' + node['refid']
1532         if self.in_title or not uri:
1533             self.context.append('')
1534         elif uri.startswith('#'):
1535             # references to labels in the same document
1536             id = self.curfilestack[-1] + ':' + uri[1:]
1537             self.body.append(self.hyperlink(id))
1538             self.body.append(r'\emph{')
1539             if self.config.latex_show_pagerefs and not \
1540                     self.in_production_list:
1541                 self.context.append('}}} (%s)' % self.hyperpageref(id))
1542             else:
1543                 self.context.append('}}}')
1544         elif uri.startswith('%'):
1545             # references to documents or labels inside documents
1546             hashindex = uri.find('#')
1547             if hashindex == -1:
1548                 # reference to the document
1549                 id = uri[1:] + '::doc'
1550             else:
1551                 # reference to a label
1552                 id = uri[1:].replace('#', ':')
1553             self.body.append(self.hyperlink(id))
1554             if (len(node) and
1555                     isinstance(node[0], nodes.Element) and
1556                     'std-term' in node[0].get('classes', [])):
1557                 # don't add a pageref for glossary terms
1558                 self.context.append('}}}')
1559                 # mark up as termreference
1560                 self.body.append(r'\sphinxtermref{')
1561             else:
1562                 self.body.append(r'\sphinxcrossref{')
1563                 if self.config.latex_show_pagerefs and not self.in_production_list:
1564                     self.context.append('}}} (%s)' % self.hyperpageref(id))
1565                 else:
1566                     self.context.append('}}}')
1567         else:
1568             if len(node) == 1 and uri == node[0]:
1569                 if node.get('nolinkurl'):
1570                     self.body.append(r'\sphinxnolinkurl{%s}' % self.encode_uri(uri))
1571                 else:
1572                     self.body.append(r'\sphinxurl{%s}' % self.encode_uri(uri))
1573                 raise nodes.SkipNode
1574             else:
1575                 self.body.append(r'\sphinxhref{%s}{' % self.encode_uri(uri))
1576                 self.context.append('}')
1577 
1578     def depart_reference(self, node: Element) -> None:
1579         self.body.append(self.context.pop())
1580         if not self.is_inline(node):
1581             self.body.append(CR)
1582 
1583     def visit_number_reference(self, node: Element) -> None:
1584         if node.get('refid'):
1585             id = self.curfilestack[-1] + ':' + node['refid']
1586         else:
1587             id = node.get('refuri', '')[1:].replace('#', ':')
1588 
1589         title = self.escape(node.get('title', '%s')).replace(r'\%s', '%s')
1590         if r'\{name\}' in title or r'\{number\}' in title:
1591             # new style format (cf. "Fig.%{number}")
1592             title = title.replace(r'\{name\}', '{name}').replace(r'\{number\}', '{number}')
1593             text = escape_abbr(title).format(name=r'\nameref{%s}' % self.idescape(id),
1594                                              number=r'\ref{%s}' % self.idescape(id))
1595         else:
1596             # old style format (cf. "Fig.%{number}")
1597             text = escape_abbr(title) % (r'\ref{%s}' % self.idescape(id))
1598         hyperref = r'\hyperref[%s]{%s}' % (self.idescape(id), text)
1599         self.body.append(hyperref)
1600 
1601         raise nodes.SkipNode
1602 
1603     def visit_download_reference(self, node: Element) -> None:
1604         pass
1605 
1606     def depart_download_reference(self, node: Element) -> None:
1607         pass
1608 
1609     def visit_pending_xref(self, node: Element) -> None:
1610         pass
1611 
1612     def depart_pending_xref(self, node: Element) -> None:
1613         pass
1614 
1615     def visit_emphasis(self, node: Element) -> None:
1616         self.body.append(r'\sphinxstyleemphasis{')
1617 
1618     def depart_emphasis(self, node: Element) -> None:
1619         self.body.append('}')
1620 
1621     def visit_literal_emphasis(self, node: Element) -> None:
1622         self.body.append(r'\sphinxstyleliteralemphasis{\sphinxupquote{')
1623 
1624     def depart_literal_emphasis(self, node: Element) -> None:
1625         self.body.append('}}')
1626 
1627     def visit_strong(self, node: Element) -> None:
1628         self.body.append(r'\sphinxstylestrong{')
1629 
1630     def depart_strong(self, node: Element) -> None:
1631         self.body.append('}')
1632 
1633     def visit_literal_strong(self, node: Element) -> None:
1634         self.body.append(r'\sphinxstyleliteralstrong{\sphinxupquote{')
1635 
1636     def depart_literal_strong(self, node: Element) -> None:
1637         self.body.append('}}')
1638 
1639     def visit_abbreviation(self, node: Element) -> None:
1640         abbr = node.astext()
1641         self.body.append(r'\sphinxstyleabbreviation{')
1642         # spell out the explanation once
1643         if node.hasattr('explanation') and abbr not in self.handled_abbrs:
1644             self.context.append('} (%s)' % self.encode(node['explanation']))
1645             self.handled_abbrs.add(abbr)
1646         else:
1647             self.context.append('}')
1648 
1649     def depart_abbreviation(self, node: Element) -> None:
1650         self.body.append(self.context.pop())
1651 
1652     def visit_manpage(self, node: Element) -> None:
1653         return self.visit_literal_emphasis(node)
1654 
1655     def depart_manpage(self, node: Element) -> None:
1656         return self.depart_literal_emphasis(node)
1657 
1658     def visit_title_reference(self, node: Element) -> None:
1659         self.body.append(r'\sphinxtitleref{')
1660 
1661     def depart_title_reference(self, node: Element) -> None:
1662         self.body.append('}')
1663 
1664     def visit_thebibliography(self, node: Element) -> None:
1665         citations = cast(Iterable[nodes.citation], node)
1666         labels = (cast(nodes.label, citation[0]) for citation in citations)
1667         longest_label = max((label.astext() for label in labels), key=len)
1668         if len(longest_label) > MAX_CITATION_LABEL_LENGTH:
1669             # adjust max width of citation labels not to break the layout
1670             longest_label = longest_label[:MAX_CITATION_LABEL_LENGTH]
1671 
1672         self.body.append(CR + r'\begin{sphinxthebibliography}{%s}' %
1673                          self.encode(longest_label) + CR)
1674 
1675     def depart_thebibliography(self, node: Element) -> None:
1676         self.body.append(r'\end{sphinxthebibliography}' + CR)
1677 
1678     def visit_citation(self, node: Element) -> None:
1679         label = cast(nodes.label, node[0])
1680         self.body.append(r'\bibitem[%s]{%s:%s}' % (self.encode(label.astext()),
1681                                                    node['docname'], node['ids'][0]))
1682 
1683     def depart_citation(self, node: Element) -> None:
1684         pass
1685 
1686     def visit_citation_reference(self, node: Element) -> None:
1687         if self.in_title:
1688             pass
1689         else:
1690             self.body.append(r'\sphinxcite{%s:%s}' % (node['docname'], node['refname']))
1691             raise nodes.SkipNode
1692 
1693     def depart_citation_reference(self, node: Element) -> None:
1694         pass
1695 
1696     def visit_literal(self, node: Element) -> None:
1697         if self.in_title:
1698             self.body.append(r'\sphinxstyleliteralintitle{\sphinxupquote{')
1699         elif 'kbd' in node['classes']:
1700             self.body.append(r'\sphinxkeyboard{\sphinxupquote{')
1701         else:
1702             self.body.append(r'\sphinxcode{\sphinxupquote{')
1703 
1704     def depart_literal(self, node: Element) -> None:
1705         self.body.append('}}')
1706 
1707     def visit_footnote_reference(self, node: Element) -> None:
1708         raise nodes.SkipNode
1709 
1710     def visit_footnotemark(self, node: Element) -> None:
1711         self.body.append(r'\sphinxfootnotemark[')
1712 
1713     def depart_footnotemark(self, node: Element) -> None:
1714         self.body.append(']')
1715 
1716     def visit_footnotetext(self, node: Element) -> None:
1717         label = cast(nodes.label, node[0])
1718         self.body.append('%' + CR)
1719         self.body.append(r'\begin{footnotetext}[%s]'
1720                          r'\phantomsection\label{\thesphinxscope.%s}%%'
1721                          % (label.astext(), label.astext()) + CR)
1722         self.body.append(r'\sphinxAtStartFootnote' + CR)
1723 
1724     def depart_footnotetext(self, node: Element) -> None:
1725         # the \ignorespaces in particular for after table header use
1726         self.body.append('%' + CR)
1727         self.body.append(r'\end{footnotetext}\ignorespaces ')
1728 
1729     def visit_captioned_literal_block(self, node: Element) -> None:
1730         pass
1731 
1732     def depart_captioned_literal_block(self, node: Element) -> None:
1733         pass
1734 
1735     def visit_literal_block(self, node: Element) -> None:
1736         if node.rawsource != node.astext():
1737             # most probably a parsed-literal block -- don't highlight
1738             self.in_parsed_literal += 1
1739             self.body.append(r'\begin{sphinxalltt}' + CR)
1740         else:
1741             labels = self.hypertarget_to(node)
1742             if isinstance(node.parent, captioned_literal_block):
1743                 labels += self.hypertarget_to(node.parent)
1744             if labels and not self.in_footnote:
1745                 self.body.append(CR + r'\def\sphinxLiteralBlockLabel{' + labels + '}')
1746 
1747             lang = node.get('language', 'default')
1748             linenos = node.get('linenos', False)
1749             highlight_args = node.get('highlight_args', {})
1750             highlight_args['force'] = node.get('force', False)
1751             opts = self.config.highlight_options.get(lang, {})
1752 
1753             hlcode = self.highlighter.highlight_block(
1754                 node.rawsource, lang, opts=opts, linenos=linenos,
1755                 location=node, **highlight_args
1756             )
1757             if self.in_footnote:
1758                 self.body.append(CR + r'\sphinxSetupCodeBlockInFootnote')
1759                 hlcode = hlcode.replace(r'\begin{Verbatim}',
1760                                         r'\begin{sphinxVerbatim}')
1761             # if in table raise verbatim flag to avoid "tabulary" environment
1762             # and opt for sphinxVerbatimintable to handle caption & long lines
1763             elif self.table:
1764                 self.table.has_problematic = True
1765                 self.table.has_verbatim = True
1766                 hlcode = hlcode.replace(r'\begin{Verbatim}',
1767                                         r'\begin{sphinxVerbatimintable}')
1768             else:
1769                 hlcode = hlcode.replace(r'\begin{Verbatim}',
1770                                         r'\begin{sphinxVerbatim}')
1771             # get consistent trailer
1772             hlcode = hlcode.rstrip()[:-14]  # strip \end{Verbatim}
1773             if self.table and not self.in_footnote:
1774                 hlcode += r'\end{sphinxVerbatimintable}'
1775             else:
1776                 hlcode += r'\end{sphinxVerbatim}'
1777 
1778             hllines = str(highlight_args.get('hl_lines', []))[1:-1]
1779             if hllines:
1780                 self.body.append(CR + r'\fvset{hllines={, %s,}}%%' % hllines)
1781             self.body.append(CR + hlcode + CR)
1782             if hllines:
1783                 self.body.append(r'\sphinxresetverbatimhllines' + CR)
1784             raise nodes.SkipNode
1785 
1786     def depart_literal_block(self, node: Element) -> None:
1787         self.body.append(CR + r'\end{sphinxalltt}' + CR)
1788         self.in_parsed_literal -= 1
1789     visit_doctest_block = visit_literal_block
1790     depart_doctest_block = depart_literal_block
1791 
1792     def visit_line(self, node: Element) -> None:
1793         self.body.append(r'\item[] ')
1794 
1795     def depart_line(self, node: Element) -> None:
1796         self.body.append(CR)
1797 
1798     def visit_line_block(self, node: Element) -> None:
1799         if isinstance(node.parent, nodes.line_block):
1800             self.body.append(r'\item[]' + CR)
1801             self.body.append(r'\begin{DUlineblock}{\DUlineblockindent}' + CR)
1802         else:
1803             self.body.append(CR + r'\begin{DUlineblock}{0em}' + CR)
1804         if self.table:
1805             self.table.has_problematic = True
1806 
1807     def depart_line_block(self, node: Element) -> None:
1808         self.body.append(r'\end{DUlineblock}' + CR)
1809 
1810     def visit_block_quote(self, node: Element) -> None:
1811         # If the block quote contains a single object and that object
1812         # is a list, then generate a list not a block quote.
1813         # This lets us indent lists.
1814         done = 0
1815         if len(node.children) == 1:
1816             child = node.children[0]
1817             if isinstance(child, nodes.bullet_list) or \
1818                     isinstance(child, nodes.enumerated_list):
1819                 done = 1
1820         if not done:
1821             self.body.append(r'\begin{quote}' + CR)
1822             if self.table:
1823                 self.table.has_problematic = True
1824 
1825     def depart_block_quote(self, node: Element) -> None:
1826         done = 0
1827         if len(node.children) == 1:
1828             child = node.children[0]
1829             if isinstance(child, nodes.bullet_list) or \
1830                     isinstance(child, nodes.enumerated_list):
1831                 done = 1
1832         if not done:
1833             self.body.append(r'\end{quote}' + CR)
1834 
1835     # option node handling copied from docutils' latex writer
1836 
1837     def visit_option(self, node: Element) -> None:
1838         if self.context[-1]:
1839             # this is not the first option
1840             self.body.append(', ')
1841 
1842     def depart_option(self, node: Element) -> None:
1843         # flag that the first option is done.
1844         self.context[-1] += 1
1845 
1846     def visit_option_argument(self, node: Element) -> None:
1847         """The delimiter between an option and its argument."""
1848         self.body.append(node.get('delimiter', ' '))
1849 
1850     def depart_option_argument(self, node: Element) -> None:
1851         pass
1852 
1853     def visit_option_group(self, node: Element) -> None:
1854         self.body.append(r'\item [')
1855         # flag for first option
1856         self.context.append(0)
1857 
1858     def depart_option_group(self, node: Element) -> None:
1859         self.context.pop()  # the flag
1860         self.body.append('] ')
1861 
1862     def visit_option_list(self, node: Element) -> None:
1863         self.body.append(r'\begin{optionlist}{3cm}' + CR)
1864         if self.table:
1865             self.table.has_problematic = True
1866 
1867     def depart_option_list(self, node: Element) -> None:
1868         self.body.append(r'\end{optionlist}' + CR)
1869 
1870     def visit_option_list_item(self, node: Element) -> None:
1871         pass
1872 
1873     def depart_option_list_item(self, node: Element) -> None:
1874         pass
1875 
1876     def visit_option_string(self, node: Element) -> None:
1877         ostring = node.astext()
1878         self.body.append(self.encode(ostring))
1879         raise nodes.SkipNode
1880 
1881     def visit_description(self, node: Element) -> None:
1882         self.body.append(' ')
1883 
1884     def depart_description(self, node: Element) -> None:
1885         pass
1886 
1887     def visit_superscript(self, node: Element) -> None:
1888         self.body.append(r'$^{\text{')
1889 
1890     def depart_superscript(self, node: Element) -> None:
1891         self.body.append('}}$')
1892 
1893     def visit_subscript(self, node: Element) -> None:
1894         self.body.append(r'$_{\text{')
1895 
1896     def depart_subscript(self, node: Element) -> None:
1897         self.body.append('}}$')
1898 
1899     def visit_inline(self, node: Element) -> None:
1900         classes = node.get('classes', [])
1901         if classes in [['menuselection']]:
1902             self.body.append(r'\sphinxmenuselection{')
1903             self.context.append('}')
1904         elif classes in [['guilabel']]:
1905             self.body.append(r'\sphinxguilabel{')
1906             self.context.append('}')
1907         elif classes in [['accelerator']]:
1908             self.body.append(r'\sphinxaccelerator{')
1909             self.context.append('}')
1910         elif classes and not self.in_title:
1911             self.body.append(r'\DUrole{%s}{' % ','.join(classes))
1912             self.context.append('}')
1913         else:
1914             self.context.append('')
1915 
1916     def depart_inline(self, node: Element) -> None:
1917         self.body.append(self.context.pop())
1918 
1919     def visit_generated(self, node: Element) -> None:
1920         pass
1921 
1922     def depart_generated(self, node: Element) -> None:
1923         pass
1924 
1925     def visit_compound(self, node: Element) -> None:
1926         pass
1927 
1928     def depart_compound(self, node: Element) -> None:
1929         pass
1930 
1931     def visit_container(self, node: Element) -> None:
1932         classes = node.get('classes', [])
1933         for c in classes:
1934             self.body.append('\n\\begin{sphinxuseclass}{%s}' % c)
1935 
1936     def depart_container(self, node: Element) -> None:
1937         classes = node.get('classes', [])
1938         for c in classes:
1939             self.body.append('\n\\end{sphinxuseclass}')
1940 
1941     def visit_decoration(self, node: Element) -> None:
1942         pass
1943 
1944     def depart_decoration(self, node: Element) -> None:
1945         pass
1946 
1947     # docutils-generated elements that we don't support
1948 
1949     def visit_header(self, node: Element) -> None:
1950         raise nodes.SkipNode
1951 
1952     def visit_footer(self, node: Element) -> None:
1953         raise nodes.SkipNode
1954 
1955     def visit_docinfo(self, node: Element) -> None:
1956         raise nodes.SkipNode
1957 
1958     # text handling
1959 
1960     def encode(self, text: str) -> str:
1961         text = self.escape(text)
1962         if self.literal_whitespace:
1963             # Insert a blank before the newline, to avoid
1964             # ! LaTeX Error: There's no line here to end.
1965             text = text.replace(CR, r'~\\' + CR).replace(' ', '~')
1966         return text
1967 
1968     def encode_uri(self, text: str) -> str:
1969         # TODO: it is probably wrong that this uses texescape.escape()
1970         #       this must be checked against hyperref package exact dealings
1971         #       mainly, %, #, {, } and \ need escaping via a \ escape
1972         # in \href, the tilde is allowed and must be represented literally
1973         return self.encode(text).replace(r'\textasciitilde{}', '~').\
1974             replace(r'\sphinxhyphen{}', '-').\
1975             replace(r'\textquotesingle{}', "'")
1976 
1977     def visit_Text(self, node: Text) -> None:
1978         text = self.encode(node.astext())
1979         self.body.append(text)
1980 
1981     def depart_Text(self, node: Text) -> None:
1982         pass
1983 
1984     def visit_comment(self, node: Element) -> None:
1985         raise nodes.SkipNode
1986 
1987     def visit_meta(self, node: Element) -> None:
1988         # only valid for HTML
1989         raise nodes.SkipNode
1990 
1991     def visit_system_message(self, node: Element) -> None:
1992         pass
1993 
1994     def depart_system_message(self, node: Element) -> None:
1995         self.body.append(CR)
1996 
1997     def visit_math(self, node: Element) -> None:
1998         if self.in_title:
1999             self.body.append(r'\protect\(%s\protect\)' % node.astext())
2000         else:
2001             self.body.append(r'\(%s\)' % node.astext())
2002         raise nodes.SkipNode
2003 
2004     def visit_math_block(self, node: Element) -> None:
2005         if node.get('label'):
2006             label = "equation:%s:%s" % (node['docname'], node['label'])
2007         else:
2008             label = None
2009 
2010         if node.get('nowrap'):
2011             if label:
2012                 self.body.append(r'\label{%s}' % label)
2013             self.body.append(node.astext())
2014         else:
2015             from sphinx.util.math import wrap_displaymath
2016             self.body.append(wrap_displaymath(node.astext(), label,
2017                                               self.config.math_number_all))
2018         raise nodes.SkipNode
2019 
2020     def visit_math_reference(self, node: Element) -> None:
2021         label = "equation:%s:%s" % (node['docname'], node['target'])
2022         eqref_format = self.config.math_eqref_format
2023         if eqref_format:
2024             try:
2025                 ref = r'\ref{%s}' % label
2026                 self.body.append(eqref_format.format(number=ref))
2027             except KeyError as exc:
2028                 logger.warning(__('Invalid math_eqref_format: %r'), exc,
2029                                location=node)
2030                 self.body.append(r'\eqref{%s}' % label)
2031         else:
2032             self.body.append(r'\eqref{%s}' % label)
2033 
2034     def depart_math_reference(self, node: Element) -> None:
2035         pass
2036 
2037     def unknown_visit(self, node: Node) -> None:
2038         raise NotImplementedError('Unknown node: ' + node.__class__.__name__)
2039 
2040     @property
2041     def docclasses(self) -> Tuple[str, str]:
2042         """Prepends prefix to sphinx document classes"""
2043         warnings.warn('LaTeXWriter.docclasses() is deprecated.',
2044                       RemovedInSphinx70Warning, stacklevel=2)
2045         return ('howto', 'manual')
2046 
2047 
2048 # FIXME: Workaround to avoid circular import
2049 # refs: https://github.com/sphinx-doc/sphinx/issues/5433
2050 from sphinx.builders.latex.nodes import ( # NOQA isort:skip
2051     HYPERLINK_SUPPORT_NODES, captioned_literal_block, footnotetext,
2052 )

</code><intended_behavior>This file should include a method or modify an existing method to ensure that glossary terms and similarly formatted items are separated by appropriate LaTeX commands to enforce a newline where expected. The intended behavior is to preserve glossary term separations in such a way that when converted to LaTeX, the output mimics the separation seen in HTML and other formats, without introducing undue vertical whitespace for grouped terms. This could involve checking for glossary term definitions and applying a LaTeX newline command (\ or \par) at the correct places while preserving existing functionality for handling other elements within .rst files. The code should ensure no unintended side effects on the rest of the LaTeX document's formatting.</intended_behavior>, <file>sphinx/domains/std.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2     sphinx.domains.std
3     ~~~~~~~~~~~~~~~~~~
4 
5     The standard domain.
6 
7     :copyright: Copyright 2007-2021 by the Sphinx team, see AUTHORS.
8     :license: BSD, see LICENSE for details.
9 """
10 
11 import re
12 import unicodedata
13 from copy import copy
14 from typing import (TYPE_CHECKING, Any, Callable, Dict, Iterable, Iterator, List, Optional,
15                     Tuple, Type, Union, cast)
16 
17 from docutils import nodes
18 from docutils.nodes import Element, Node, system_message
19 from docutils.parsers.rst import Directive, directives
20 from docutils.statemachine import StringList
21 
22 from sphinx import addnodes
23 from sphinx.addnodes import desc_signature, pending_xref
24 from sphinx.directives import ObjectDescription
25 from sphinx.domains import Domain, ObjType
26 from sphinx.locale import _, __
27 from sphinx.roles import XRefRole
28 from sphinx.util import docname_join, logging, ws_re
29 from sphinx.util.docutils import SphinxDirective
30 from sphinx.util.nodes import clean_astext, make_id, make_refnode
31 from sphinx.util.typing import OptionSpec, RoleFunction
32 
33 if TYPE_CHECKING:
34     from sphinx.application import Sphinx
35     from sphinx.builders import Builder
36     from sphinx.environment import BuildEnvironment
37 
38 logger = logging.getLogger(__name__)
39 
40 
41 # RE for option descriptions
42 option_desc_re = re.compile(r'((?:/|--|-|\+)?[^\s=]+)(=?\s*.*)')
43 # RE for grammar tokens
44 token_re = re.compile(r'`((~?\w*:)?\w+)`', re.U)
45 
46 
47 class GenericObject(ObjectDescription[str]):
48     """
49     A generic x-ref directive registered with Sphinx.add_object_type().
50     """
51     indextemplate: str = ''
52     parse_node: Callable[["GenericObject", "BuildEnvironment", str, desc_signature], str] = None  # NOQA
53 
54     def handle_signature(self, sig: str, signode: desc_signature) -> str:
55         if self.parse_node:
56             name = self.parse_node(self.env, sig, signode)
57         else:
58             signode.clear()
59             signode += addnodes.desc_name(sig, sig)
60             # normalize whitespace like XRefRole does
61             name = ws_re.sub(' ', sig)
62         return name
63 
64     def add_target_and_index(self, name: str, sig: str, signode: desc_signature) -> None:
65         node_id = make_id(self.env, self.state.document, self.objtype, name)
66         signode['ids'].append(node_id)
67 
68         # Assign old styled node_id not to break old hyperlinks (if possible)
69         # Note: Will be removed in Sphinx-5.0 (RemovedInSphinx50Warning)
70         old_node_id = self.make_old_id(name)
71         if old_node_id not in self.state.document.ids and old_node_id not in signode['ids']:
72             signode['ids'].append(old_node_id)
73 
74         self.state.document.note_explicit_target(signode)
75 
76         if self.indextemplate:
77             colon = self.indextemplate.find(':')
78             if colon != -1:
79                 indextype = self.indextemplate[:colon].strip()
80                 indexentry = self.indextemplate[colon + 1:].strip() % (name,)
81             else:
82                 indextype = 'single'
83                 indexentry = self.indextemplate % (name,)
84             self.indexnode['entries'].append((indextype, indexentry, node_id, '', None))
85 
86         std = cast(StandardDomain, self.env.get_domain('std'))
87         std.note_object(self.objtype, name, node_id, location=signode)
88 
89     def make_old_id(self, name: str) -> str:
90         """Generate old styled node_id for generic objects.
91 
92         .. note:: Old Styled node_id was used until Sphinx-3.0.
93                   This will be removed in Sphinx-5.0.
94         """
95         return self.objtype + '-' + name
96 
97 
98 class EnvVar(GenericObject):
99     indextemplate = _('environment variable; %s')
100 
101 
102 class EnvVarXRefRole(XRefRole):
103     """
104     Cross-referencing role for environment variables (adds an index entry).
105     """
106 
107     def result_nodes(self, document: nodes.document, env: "BuildEnvironment", node: Element,
108                      is_ref: bool) -> Tuple[List[Node], List[system_message]]:
109         if not is_ref:
110             return [node], []
111         varname = node['reftarget']
112         tgtid = 'index-%s' % env.new_serialno('index')
113         indexnode = addnodes.index()
114         indexnode['entries'] = [
115             ('single', varname, tgtid, '', None),
116             ('single', _('environment variable; %s') % varname, tgtid, '', None)
117         ]
118         targetnode = nodes.target('', '', ids=[tgtid])
119         document.note_explicit_target(targetnode)
120         return [indexnode, targetnode, node], []
121 
122 
123 class Target(SphinxDirective):
124     """
125     Generic target for user-defined cross-reference types.
126     """
127     indextemplate = ''
128 
129     has_content = False
130     required_arguments = 1
131     optional_arguments = 0
132     final_argument_whitespace = True
133     option_spec: OptionSpec = {}
134 
135     def run(self) -> List[Node]:
136         # normalize whitespace in fullname like XRefRole does
137         fullname = ws_re.sub(' ', self.arguments[0].strip())
138         node_id = make_id(self.env, self.state.document, self.name, fullname)
139         node = nodes.target('', '', ids=[node_id])
140         self.set_source_info(node)
141 
142         # Assign old styled node_id not to break old hyperlinks (if possible)
143         # Note: Will be removed in Sphinx-5.0 (RemovedInSphinx50Warning)
144         old_node_id = self.make_old_id(fullname)
145         if old_node_id not in self.state.document.ids and old_node_id not in node['ids']:
146             node['ids'].append(old_node_id)
147 
148         self.state.document.note_explicit_target(node)
149         ret: List[Node] = [node]
150         if self.indextemplate:
151             indexentry = self.indextemplate % (fullname,)
152             indextype = 'single'
153             colon = indexentry.find(':')
154             if colon != -1:
155                 indextype = indexentry[:colon].strip()
156                 indexentry = indexentry[colon + 1:].strip()
157             inode = addnodes.index(entries=[(indextype, indexentry, node_id, '', None)])
158             ret.insert(0, inode)
159         name = self.name
160         if ':' in self.name:
161             _, name = self.name.split(':', 1)
162 
163         std = cast(StandardDomain, self.env.get_domain('std'))
164         std.note_object(name, fullname, node_id, location=node)
165 
166         return ret
167 
168     def make_old_id(self, name: str) -> str:
169         """Generate old styled node_id for targets.
170 
171         .. note:: Old Styled node_id was used until Sphinx-3.0.
172                   This will be removed in Sphinx-5.0.
173         """
174         return self.name + '-' + name
175 
176 
177 class Cmdoption(ObjectDescription[str]):
178     """
179     Description of a command-line option (.. option).
180     """
181 
182     def handle_signature(self, sig: str, signode: desc_signature) -> str:
183         """Transform an option description into RST nodes."""
184         count = 0
185         firstname = ''
186         for potential_option in sig.split(', '):
187             potential_option = potential_option.strip()
188             m = option_desc_re.match(potential_option)
189             if not m:
190                 logger.warning(__('Malformed option description %r, should '
191                                   'look like "opt", "-opt args", "--opt args", '
192                                   '"/opt args" or "+opt args"'), potential_option,
193                                location=signode)
194                 continue
195             optname, args = m.groups()
196             if optname.endswith('[') and args.endswith(']'):
197                 # optional value surrounded by brackets (ex. foo[=bar])
198                 optname = optname[:-1]
199                 args = '[' + args
200 
201             if count:
202                 signode += addnodes.desc_addname(', ', ', ')
203             signode += addnodes.desc_name(optname, optname)
204             signode += addnodes.desc_addname(args, args)
205             if not count:
206                 firstname = optname
207                 signode['allnames'] = [optname]
208             else:
209                 signode['allnames'].append(optname)
210             count += 1
211         if not firstname:
212             raise ValueError
213         return firstname
214 
215     def add_target_and_index(self, firstname: str, sig: str, signode: desc_signature) -> None:
216         currprogram = self.env.ref_context.get('std:program')
217         for optname in signode.get('allnames', []):
218             prefixes = ['cmdoption']
219             if currprogram:
220                 prefixes.append(currprogram)
221             if not optname.startswith(('-', '/')):
222                 prefixes.append('arg')
223             prefix = '-'.join(prefixes)
224             node_id = make_id(self.env, self.state.document, prefix, optname)
225             signode['ids'].append(node_id)
226 
227             old_node_id = self.make_old_id(prefix, optname)
228             if old_node_id not in self.state.document.ids and \
229                old_node_id not in signode['ids']:
230                 signode['ids'].append(old_node_id)
231 
232         self.state.document.note_explicit_target(signode)
233 
234         domain = cast(StandardDomain, self.env.get_domain('std'))
235         for optname in signode.get('allnames', []):
236             domain.add_program_option(currprogram, optname,
237                                       self.env.docname, signode['ids'][0])
238 
239         # create an index entry
240         if currprogram:
241             descr = _('%s command line option') % currprogram
242         else:
243             descr = _('command line option')
244         for option in sig.split(', '):
245             entry = '; '.join([descr, option])
246             self.indexnode['entries'].append(('pair', entry, signode['ids'][0], '', None))
247 
248     def make_old_id(self, prefix: str, optname: str) -> str:
249         """Generate old styled node_id for cmdoption.
250 
251         .. note:: Old Styled node_id was used until Sphinx-3.0.
252                   This will be removed in Sphinx-5.0.
253         """
254         return nodes.make_id(prefix + '-' + optname)
255 
256 
257 class Program(SphinxDirective):
258     """
259     Directive to name the program for which options are documented.
260     """
261 
262     has_content = False
263     required_arguments = 1
264     optional_arguments = 0
265     final_argument_whitespace = True
266     option_spec: OptionSpec = {}
267 
268     def run(self) -> List[Node]:
269         program = ws_re.sub('-', self.arguments[0].strip())
270         if program == 'None':
271             self.env.ref_context.pop('std:program', None)
272         else:
273             self.env.ref_context['std:program'] = program
274         return []
275 
276 
277 class OptionXRefRole(XRefRole):
278     def process_link(self, env: "BuildEnvironment", refnode: Element, has_explicit_title: bool,
279                      title: str, target: str) -> Tuple[str, str]:
280         refnode['std:program'] = env.ref_context.get('std:program')
281         return title, target
282 
283 
284 def split_term_classifiers(line: str) -> List[Optional[str]]:
285     # split line into a term and classifiers. if no classifier, None is used..
286     parts: List[Optional[str]] = re.split(' +: +', line) + [None]
287     return parts
288 
289 
290 def make_glossary_term(env: "BuildEnvironment", textnodes: Iterable[Node], index_key: str,
291                        source: str, lineno: int, node_id: str, document: nodes.document
292                        ) -> nodes.term:
293     # get a text-only representation of the term and register it
294     # as a cross-reference target
295     term = nodes.term('', '', *textnodes)
296     term.source = source
297     term.line = lineno
298     termtext = term.astext()
299 
300     if node_id:
301         # node_id is given from outside (mainly i18n module), use it forcedly
302         term['ids'].append(node_id)
303     else:
304         node_id = make_id(env, document, 'term', termtext)
305         term['ids'].append(node_id)
306         document.note_explicit_target(term)
307 
308     std = cast(StandardDomain, env.get_domain('std'))
309     std._note_term(termtext, node_id, location=term)
310 
311     # add an index entry too
312     indexnode = addnodes.index()
313     indexnode['entries'] = [('single', termtext, node_id, 'main', index_key)]
314     indexnode.source, indexnode.line = term.source, term.line
315     term.append(indexnode)
316 
317     return term
318 
319 
320 class Glossary(SphinxDirective):
321     """
322     Directive to create a glossary with cross-reference targets for :term:
323     roles.
324     """
325 
326     has_content = True
327     required_arguments = 0
328     optional_arguments = 0
329     final_argument_whitespace = False
330     option_spec: OptionSpec = {
331         'sorted': directives.flag,
332     }
333 
334     def run(self) -> List[Node]:
335         node = addnodes.glossary()
336         node.document = self.state.document
337 
338         # This directive implements a custom format of the reST definition list
339         # that allows multiple lines of terms before the definition.  This is
340         # easy to parse since we know that the contents of the glossary *must
341         # be* a definition list.
342 
343         # first, collect single entries
344         entries: List[Tuple[List[Tuple[str, str, int]], StringList]] = []
345         in_definition = True
346         in_comment = False
347         was_empty = True
348         messages: List[Node] = []
349         for line, (source, lineno) in zip(self.content, self.content.items):
350             # empty line -> add to last definition
351             if not line:
352                 if in_definition and entries:
353                     entries[-1][1].append('', source, lineno)
354                 was_empty = True
355                 continue
356             # unindented line -> a term
357             if line and not line[0].isspace():
358                 # enable comments
359                 if line.startswith('.. '):
360                     in_comment = True
361                     continue
362                 else:
363                     in_comment = False
364 
365                 # first term of definition
366                 if in_definition:
367                     if not was_empty:
368                         messages.append(self.state.reporter.warning(
369                             _('glossary term must be preceded by empty line'),
370                             source=source, line=lineno))
371                     entries.append(([(line, source, lineno)], StringList()))
372                     in_definition = False
373                 # second term and following
374                 else:
375                     if was_empty:
376                         messages.append(self.state.reporter.warning(
377                             _('glossary terms must not be separated by empty lines'),
378                             source=source, line=lineno))
379                     if entries:
380                         entries[-1][0].append((line, source, lineno))
381                     else:
382                         messages.append(self.state.reporter.warning(
383                             _('glossary seems to be misformatted, check indentation'),
384                             source=source, line=lineno))
385             elif in_comment:
386                 pass
387             else:
388                 if not in_definition:
389                     # first line of definition, determines indentation
390                     in_definition = True
391                     indent_len = len(line) - len(line.lstrip())
392                 if entries:
393                     entries[-1][1].append(line[indent_len:], source, lineno)
394                 else:
395                     messages.append(self.state.reporter.warning(
396                         _('glossary seems to be misformatted, check indentation'),
397                         source=source, line=lineno))
398             was_empty = False
399 
400         # now, parse all the entries into a big definition list
401         items = []
402         for terms, definition in entries:
403             termtexts: List[str] = []
404             termnodes: List[Node] = []
405             system_messages: List[Node] = []
406             for line, source, lineno in terms:
407                 parts = split_term_classifiers(line)
408                 # parse the term with inline markup
409                 # classifiers (parts[1:]) will not be shown on doctree
410                 textnodes, sysmsg = self.state.inline_text(parts[0], lineno)
411 
412                 # use first classifier as a index key
413                 term = make_glossary_term(self.env, textnodes, parts[1], source, lineno,
414                                           node_id=None, document=self.state.document)
415                 term.rawsource = line
416                 system_messages.extend(sysmsg)
417                 termtexts.append(term.astext())
418                 termnodes.append(term)
419 
420             termnodes.extend(system_messages)
421 
422             defnode = nodes.definition()
423             if definition:
424                 self.state.nested_parse(definition, definition.items[0][1],
425                                         defnode)
426             termnodes.append(defnode)
427             items.append((termtexts,
428                           nodes.definition_list_item('', *termnodes)))
429 
430         if 'sorted' in self.options:
431             items.sort(key=lambda x:
432                        unicodedata.normalize('NFD', x[0][0].lower()))
433 
434         dlist = nodes.definition_list()
435         dlist['classes'].append('glossary')
436         dlist.extend(item[1] for item in items)
437         node += dlist
438         return messages + [node]
439 
440 
441 def token_xrefs(text: str, productionGroup: str = '') -> List[Node]:
442     if len(productionGroup) != 0:
443         productionGroup += ':'
444     retnodes: List[Node] = []
445     pos = 0
446     for m in token_re.finditer(text):
447         if m.start() > pos:
448             txt = text[pos:m.start()]
449             retnodes.append(nodes.Text(txt, txt))
450         token = m.group(1)
451         if ':' in token:
452             if token[0] == '~':
453                 _, title = token.split(':')
454                 target = token[1:]
455             elif token[0] == ':':
456                 title = token[1:]
457                 target = title
458             else:
459                 title = token
460                 target = token
461         else:
462             title = token
463             target = productionGroup + token
464         refnode = pending_xref(title, reftype='token', refdomain='std',
465                                reftarget=target)
466         refnode += nodes.literal(token, title, classes=['xref'])
467         retnodes.append(refnode)
468         pos = m.end()
469     if pos < len(text):
470         retnodes.append(nodes.Text(text[pos:], text[pos:]))
471     return retnodes
472 
473 
474 class ProductionList(SphinxDirective):
475     """
476     Directive to list grammar productions.
477     """
478 
479     has_content = False
480     required_arguments = 1
481     optional_arguments = 0
482     final_argument_whitespace = True
483     option_spec: OptionSpec = {}
484 
485     def run(self) -> List[Node]:
486         domain = cast(StandardDomain, self.env.get_domain('std'))
487         node: Element = addnodes.productionlist()
488         self.set_source_info(node)
489         # The backslash handling is from ObjectDescription.get_signatures
490         nl_escape_re = re.compile(r'\\\n')
491         lines = nl_escape_re.sub('', self.arguments[0]).split('\n')
492 
493         productionGroup = ""
494         i = 0
495         for rule in lines:
496             if i == 0 and ':' not in rule:
497                 productionGroup = rule.strip()
498                 continue
499             i += 1
500             try:
501                 name, tokens = rule.split(':', 1)
502             except ValueError:
503                 break
504             subnode = addnodes.production(rule)
505             name = name.strip()
506             subnode['tokenname'] = name
507             if subnode['tokenname']:
508                 prefix = 'grammar-token-%s' % productionGroup
509                 node_id = make_id(self.env, self.state.document, prefix, name)
510                 subnode['ids'].append(node_id)
511 
512                 # Assign old styled node_id not to break old hyperlinks (if possible)
513                 # Note: Will be removed in Sphinx-5.0 (RemovedInSphinx50Warning)
514                 old_node_id = self.make_old_id(name)
515                 if (old_node_id not in self.state.document.ids and
516                         old_node_id not in subnode['ids']):
517                     subnode['ids'].append(old_node_id)
518 
519                 self.state.document.note_implicit_target(subnode, subnode)
520 
521                 if len(productionGroup) != 0:
522                     objName = "%s:%s" % (productionGroup, name)
523                 else:
524                     objName = name
525                 domain.note_object('token', objName, node_id, location=node)
526             subnode.extend(token_xrefs(tokens, productionGroup))
527             node.append(subnode)
528         return [node]
529 
530     def make_old_id(self, token: str) -> str:
531         """Generate old styled node_id for tokens.
532 
533         .. note:: Old Styled node_id was used until Sphinx-3.0.
534                   This will be removed in Sphinx-5.0.
535         """
536         return nodes.make_id('grammar-token-' + token)
537 
538 
539 class TokenXRefRole(XRefRole):
540     def process_link(self, env: "BuildEnvironment", refnode: Element, has_explicit_title: bool,
541                      title: str, target: str) -> Tuple[str, str]:
542         target = target.lstrip('~')  # a title-specific thing
543         if not self.has_explicit_title and title[0] == '~':
544             if ':' in title:
545                 _, title = title.split(':')
546             else:
547                 title = title[1:]
548         return title, target
549 
550 
551 class StandardDomain(Domain):
552     """
553     Domain for all objects that don't fit into another domain or are added
554     via the application interface.
555     """
556 
557     name = 'std'
558     label = 'Default'
559 
560     object_types: Dict[str, ObjType] = {
561         'term': ObjType(_('glossary term'), 'term', searchprio=-1),
562         'token': ObjType(_('grammar token'), 'token', searchprio=-1),
563         'label': ObjType(_('reference label'), 'ref', 'keyword',
564                          searchprio=-1),
565         'envvar': ObjType(_('environment variable'), 'envvar'),
566         'cmdoption': ObjType(_('program option'), 'option'),
567         'doc': ObjType(_('document'), 'doc', searchprio=-1)
568     }
569 
570     directives: Dict[str, Type[Directive]] = {
571         'program': Program,
572         'cmdoption': Cmdoption,  # old name for backwards compatibility
573         'option': Cmdoption,
574         'envvar': EnvVar,
575         'glossary': Glossary,
576         'productionlist': ProductionList,
577     }
578     roles: Dict[str, Union[RoleFunction, XRefRole]] = {
579         'option':  OptionXRefRole(warn_dangling=True),
580         'envvar':  EnvVarXRefRole(),
581         # links to tokens in grammar productions
582         'token':   TokenXRefRole(),
583         # links to terms in glossary
584         'term':    XRefRole(innernodeclass=nodes.inline,
585                             warn_dangling=True),
586         # links to headings or arbitrary labels
587         'ref':     XRefRole(lowercase=True, innernodeclass=nodes.inline,
588                             warn_dangling=True),
589         # links to labels of numbered figures, tables and code-blocks
590         'numref':  XRefRole(lowercase=True,
591                             warn_dangling=True),
592         # links to labels, without a different title
593         'keyword': XRefRole(warn_dangling=True),
594         # links to documents
595         'doc':     XRefRole(warn_dangling=True, innernodeclass=nodes.inline),
596     }
597 
598     initial_data = {
599         'progoptions': {},      # (program, name) -> docname, labelid
600         'objects': {},          # (type, name) -> docname, labelid
601         'labels': {             # labelname -> docname, labelid, sectionname
602             'genindex': ('genindex', '', _('Index')),
603             'modindex': ('py-modindex', '', _('Module Index')),
604             'search':   ('search', '', _('Search Page')),
605         },
606         'anonlabels': {         # labelname -> docname, labelid
607             'genindex': ('genindex', ''),
608             'modindex': ('py-modindex', ''),
609             'search':   ('search', ''),
610         },
611     }
612 
613     dangling_warnings = {
614         'term': 'term not in glossary: %(target)s',
615         'numref':  'undefined label: %(target)s',
616         'keyword': 'unknown keyword: %(target)s',
617         'doc': 'unknown document: %(target)s',
618         'option': 'unknown option: %(target)s',
619     }
620 
621     # node_class -> (figtype, title_getter)
622     enumerable_nodes: Dict[Type[Node], Tuple[str, Optional[Callable]]] = {
623         nodes.figure: ('figure', None),
624         nodes.table: ('table', None),
625         nodes.container: ('code-block', None),
626     }
627 
628     def __init__(self, env: "BuildEnvironment") -> None:
629         super().__init__(env)
630 
631         # set up enumerable nodes
632         self.enumerable_nodes = copy(self.enumerable_nodes)  # create a copy for this instance
633         for node, settings in env.app.registry.enumerable_nodes.items():
634             self.enumerable_nodes[node] = settings
635 
636     def note_hyperlink_target(self, name: str, docname: str, node_id: str,
637                               title: str = '') -> None:
638         """Add a hyperlink target for cross reference.
639 
640         .. warning::
641 
642            This is only for internal use.  Please don't use this from your extension.
643            ``document.note_explicit_target()`` or ``note_implicit_target()`` are recommended to
644            add a hyperlink target to the document.
645 
646            This only adds a hyperlink target to the StandardDomain.  And this does not add a
647            node_id to node.  Therefore, it is very fragile to calling this without
648            understanding hyperlink target framework in both docutils and Sphinx.
649 
650         .. versionadded:: 3.0
651         """
652         if name in self.anonlabels and self.anonlabels[name] != (docname, node_id):
653             logger.warning(__('duplicate label %s, other instance in %s'),
654                            name, self.env.doc2path(self.anonlabels[name][0]))
655 
656         self.anonlabels[name] = (docname, node_id)
657         if title:
658             self.labels[name] = (docname, node_id, title)
659 
660     @property
661     def objects(self) -> Dict[Tuple[str, str], Tuple[str, str]]:
662         return self.data.setdefault('objects', {})  # (objtype, name) -> docname, labelid
663 
664     def note_object(self, objtype: str, name: str, labelid: str, location: Any = None
665                     ) -> None:
666         """Note a generic object for cross reference.
667 
668         .. versionadded:: 3.0
669         """
670         if (objtype, name) in self.objects:
671             docname = self.objects[objtype, name][0]
672             logger.warning(__('duplicate %s description of %s, other instance in %s'),
673                            objtype, name, docname, location=location)
674         self.objects[objtype, name] = (self.env.docname, labelid)
675 
676     @property
677     def _terms(self) -> Dict[str, Tuple[str, str]]:
678         """.. note:: Will be removed soon. internal use only."""
679         return self.data.setdefault('terms', {})  # (name) -> docname, labelid
680 
681     def _note_term(self, term: str, labelid: str, location: Any = None) -> None:
682         """Note a term for cross reference.
683 
684         .. note:: Will be removed soon. internal use only.
685         """
686         self.note_object('term', term, labelid, location)
687 
688         self._terms[term.lower()] = (self.env.docname, labelid)
689 
690     @property
691     def progoptions(self) -> Dict[Tuple[str, str], Tuple[str, str]]:
692         return self.data.setdefault('progoptions', {})  # (program, name) -> docname, labelid
693 
694     @property
695     def labels(self) -> Dict[str, Tuple[str, str, str]]:
696         return self.data.setdefault('labels', {})  # labelname -> docname, labelid, sectionname
697 
698     @property
699     def anonlabels(self) -> Dict[str, Tuple[str, str]]:
700         return self.data.setdefault('anonlabels', {})  # labelname -> docname, labelid
701 
702     def clear_doc(self, docname: str) -> None:
703         key: Any = None
704         for key, (fn, _l) in list(self.progoptions.items()):
705             if fn == docname:
706                 del self.progoptions[key]
707         for key, (fn, _l) in list(self.objects.items()):
708             if fn == docname:
709                 del self.objects[key]
710         for key, (fn, _l) in list(self._terms.items()):
711             if fn == docname:
712                 del self._terms[key]
713         for key, (fn, _l, _l) in list(self.labels.items()):
714             if fn == docname:
715                 del self.labels[key]
716         for key, (fn, _l) in list(self.anonlabels.items()):
717             if fn == docname:
718                 del self.anonlabels[key]
719 
720     def merge_domaindata(self, docnames: List[str], otherdata: Dict) -> None:
721         # XXX duplicates?
722         for key, data in otherdata['progoptions'].items():
723             if data[0] in docnames:
724                 self.progoptions[key] = data
725         for key, data in otherdata['objects'].items():
726             if data[0] in docnames:
727                 self.objects[key] = data
728         for key, data in otherdata['terms'].items():
729             if data[0] in docnames:
730                 self._terms[key] = data
731         for key, data in otherdata['labels'].items():
732             if data[0] in docnames:
733                 self.labels[key] = data
734         for key, data in otherdata['anonlabels'].items():
735             if data[0] in docnames:
736                 self.anonlabels[key] = data
737 
738     def process_doc(self, env: "BuildEnvironment", docname: str, document: nodes.document) -> None:  # NOQA
739         for name, explicit in document.nametypes.items():
740             if not explicit:
741                 continue
742             labelid = document.nameids[name]
743             if labelid is None:
744                 continue
745             node = document.ids[labelid]
746             if isinstance(node, nodes.target) and 'refid' in node:
747                 # indirect hyperlink targets
748                 node = document.ids.get(node['refid'])
749                 labelid = node['names'][0]
750             if (node.tagname == 'footnote' or
751                     'refuri' in node or
752                     node.tagname.startswith('desc_')):
753                 # ignore footnote labels, labels automatically generated from a
754                 # link and object descriptions
755                 continue
756             if name in self.labels:
757                 logger.warning(__('duplicate label %s, other instance in %s'),
758                                name, env.doc2path(self.labels[name][0]),
759                                location=node)
760             self.anonlabels[name] = docname, labelid
761             if node.tagname == 'section':
762                 title = cast(nodes.title, node[0])
763                 sectname = clean_astext(title)
764             elif node.tagname == 'rubric':
765                 sectname = clean_astext(node)
766             elif node.tagname == 'target' and len(node) > 0:
767                 # inline target (ex: blah _`blah` blah)
768                 sectname = clean_astext(node)
769             elif self.is_enumerable_node(node):
770                 sectname = self.get_numfig_title(node)
771             else:
772                 toctree = next(iter(node.traverse(addnodes.toctree)), None)
773                 if toctree and toctree.get('caption'):
774                     sectname = toctree.get('caption')
775                 else:
776                     # anonymous-only labels
777                     continue
778             if sectname:
779                 self.labels[name] = docname, labelid, sectname
780 
781     def add_program_option(self, program: str, name: str, docname: str, labelid: str) -> None:
782         self.progoptions[program, name] = (docname, labelid)
783 
784     def build_reference_node(self, fromdocname: str, builder: "Builder", docname: str,
785                              labelid: str, sectname: str, rolename: str, **options: Any
786                              ) -> Element:
787         nodeclass = options.pop('nodeclass', nodes.reference)
788         newnode = nodeclass('', '', internal=True, **options)
789         innernode = nodes.inline(sectname, sectname)
790         if innernode.get('classes') is not None:
791             innernode['classes'].append('std')
792             innernode['classes'].append('std-' + rolename)
793         if docname == fromdocname:
794             newnode['refid'] = labelid
795         else:
796             # set more info in contnode; in case the
797             # get_relative_uri call raises NoUri,
798             # the builder will then have to resolve these
799             contnode = pending_xref('')
800             contnode['refdocname'] = docname
801             contnode['refsectname'] = sectname
802             newnode['refuri'] = builder.get_relative_uri(
803                 fromdocname, docname)
804             if labelid:
805                 newnode['refuri'] += '#' + labelid
806         newnode.append(innernode)
807         return newnode
808 
809     def resolve_xref(self, env: "BuildEnvironment", fromdocname: str, builder: "Builder",
810                      typ: str, target: str, node: pending_xref, contnode: Element
811                      ) -> Optional[Element]:
812         if typ == 'ref':
813             resolver = self._resolve_ref_xref
814         elif typ == 'numref':
815             resolver = self._resolve_numref_xref
816         elif typ == 'keyword':
817             resolver = self._resolve_keyword_xref
818         elif typ == 'doc':
819             resolver = self._resolve_doc_xref
820         elif typ == 'option':
821             resolver = self._resolve_option_xref
822         elif typ == 'term':
823             resolver = self._resolve_term_xref
824         else:
825             resolver = self._resolve_obj_xref
826 
827         return resolver(env, fromdocname, builder, typ, target, node, contnode)
828 
829     def _resolve_ref_xref(self, env: "BuildEnvironment", fromdocname: str,
830                           builder: "Builder", typ: str, target: str, node: pending_xref,
831                           contnode: Element) -> Optional[Element]:
832         if node['refexplicit']:
833             # reference to anonymous label; the reference uses
834             # the supplied link caption
835             docname, labelid = self.anonlabels.get(target, ('', ''))
836             sectname = node.astext()
837         else:
838             # reference to named label; the final node will
839             # contain the section name after the label
840             docname, labelid, sectname = self.labels.get(target, ('', '', ''))
841         if not docname:
842             return None
843 
844         return self.build_reference_node(fromdocname, builder,
845                                          docname, labelid, sectname, 'ref')
846 
847     def _resolve_numref_xref(self, env: "BuildEnvironment", fromdocname: str,
848                              builder: "Builder", typ: str, target: str,
849                              node: pending_xref, contnode: Element) -> Optional[Element]:
850         if target in self.labels:
851             docname, labelid, figname = self.labels.get(target, ('', '', ''))
852         else:
853             docname, labelid = self.anonlabels.get(target, ('', ''))
854             figname = None
855 
856         if not docname:
857             return None
858 
859         target_node = env.get_doctree(docname).ids.get(labelid)
860         figtype = self.get_enumerable_node_type(target_node)
861         if figtype is None:
862             return None
863 
864         if figtype != 'section' and env.config.numfig is False:
865             logger.warning(__('numfig is disabled. :numref: is ignored.'), location=node)
866             return contnode
867 
868         try:
869             fignumber = self.get_fignumber(env, builder, figtype, docname, target_node)
870             if fignumber is None:
871                 return contnode
872         except ValueError:
873             logger.warning(__("Failed to create a cross reference. Any number is not "
874                               "assigned: %s"),
875                            labelid, location=node)
876             return contnode
877 
878         try:
879             if node['refexplicit']:
880                 title = contnode.astext()
881             else:
882                 title = env.config.numfig_format.get(figtype, '')
883 
884             if figname is None and '{name}' in title:
885                 logger.warning(__('the link has no caption: %s'), title, location=node)
886                 return contnode
887             else:
888                 fignum = '.'.join(map(str, fignumber))
889                 if '{name}' in title or 'number' in title:
890                     # new style format (cf. "Fig.{number}")
891                     if figname:
892                         newtitle = title.format(name=figname, number=fignum)
893                     else:
894                         newtitle = title.format(number=fignum)
895                 else:
896                     # old style format (cf. "Fig.%s")
897                     newtitle = title % fignum
898         except KeyError as exc:
899             logger.warning(__('invalid numfig_format: %s (%r)'), title, exc, location=node)
900             return contnode
901         except TypeError:
902             logger.warning(__('invalid numfig_format: %s'), title, location=node)
903             return contnode
904 
905         return self.build_reference_node(fromdocname, builder,
906                                          docname, labelid, newtitle, 'numref',
907                                          nodeclass=addnodes.number_reference,
908                                          title=title)
909 
910     def _resolve_keyword_xref(self, env: "BuildEnvironment", fromdocname: str,
911                               builder: "Builder", typ: str, target: str,
912                               node: pending_xref, contnode: Element) -> Optional[Element]:
913         # keywords are oddballs: they are referenced by named labels
914         docname, labelid, _ = self.labels.get(target, ('', '', ''))
915         if not docname:
916             return None
917         return make_refnode(builder, fromdocname, docname,
918                             labelid, contnode)
919 
920     def _resolve_doc_xref(self, env: "BuildEnvironment", fromdocname: str,
921                           builder: "Builder", typ: str, target: str,
922                           node: pending_xref, contnode: Element) -> Optional[Element]:
923         # directly reference to document by source name; can be absolute or relative
924         refdoc = node.get('refdoc', fromdocname)
925         docname = docname_join(refdoc, node['reftarget'])
926         if docname not in env.all_docs:
927             return None
928         else:
929             if node['refexplicit']:
930                 # reference with explicit title
931                 caption = node.astext()
932             else:
933                 caption = clean_astext(env.titles[docname])
934             innernode = nodes.inline(caption, caption, classes=['doc'])
935             return make_refnode(builder, fromdocname, docname, None, innernode)
936 
937     def _resolve_option_xref(self, env: "BuildEnvironment", fromdocname: str,
938                              builder: "Builder", typ: str, target: str,
939                              node: pending_xref, contnode: Element) -> Optional[Element]:
940         progname = node.get('std:program')
941         target = target.strip()
942         docname, labelid = self.progoptions.get((progname, target), ('', ''))
943         if not docname:
944             commands = []
945             while ws_re.search(target):
946                 subcommand, target = ws_re.split(target, 1)
947                 commands.append(subcommand)
948                 progname = "-".join(commands)
949 
950                 docname, labelid = self.progoptions.get((progname, target), ('', ''))
951                 if docname:
952                     break
953             else:
954                 return None
955 
956         return make_refnode(builder, fromdocname, docname,
957                             labelid, contnode)
958 
959     def _resolve_term_xref(self, env: "BuildEnvironment", fromdocname: str,
960                            builder: "Builder", typ: str, target: str,
961                            node: pending_xref, contnode: Element) -> Element:
962         result = self._resolve_obj_xref(env, fromdocname, builder, typ,
963                                         target, node, contnode)
964         if result:
965             return result
966         else:
967             # fallback to case insentive match
968             if target.lower() in self._terms:
969                 docname, labelid = self._terms[target.lower()]
970                 return make_refnode(builder, fromdocname, docname, labelid, contnode)
971             else:
972                 return None
973 
974     def _resolve_obj_xref(self, env: "BuildEnvironment", fromdocname: str,
975                           builder: "Builder", typ: str, target: str,
976                           node: pending_xref, contnode: Element) -> Optional[Element]:
977         objtypes = self.objtypes_for_role(typ) or []
978         for objtype in objtypes:
979             if (objtype, target) in self.objects:
980                 docname, labelid = self.objects[objtype, target]
981                 break
982         else:
983             docname, labelid = '', ''
984         if not docname:
985             return None
986         return make_refnode(builder, fromdocname, docname,
987                             labelid, contnode)
988 
989     def resolve_any_xref(self, env: "BuildEnvironment", fromdocname: str,
990                          builder: "Builder", target: str, node: pending_xref,
991                          contnode: Element) -> List[Tuple[str, Element]]:
992         results: List[Tuple[str, Element]] = []
993         ltarget = target.lower()  # :ref: lowercases its target automatically
994         for role in ('ref', 'option'):  # do not try "keyword"
995             res = self.resolve_xref(env, fromdocname, builder, role,
996                                     ltarget if role == 'ref' else target,
997                                     node, contnode)
998             if res:
999                 results.append(('std:' + role, res))
1000         # all others
1001         for objtype in self.object_types:
1002             key = (objtype, target)
1003             if objtype == 'term':
1004                 key = (objtype, ltarget)
1005             if key in self.objects:
1006                 docname, labelid = self.objects[key]
1007                 results.append(('std:' + self.role_for_objtype(objtype),
1008                                 make_refnode(builder, fromdocname, docname,
1009                                              labelid, contnode)))
1010         return results
1011 
1012     def get_objects(self) -> Iterator[Tuple[str, str, str, str, str, int]]:
1013         # handle the special 'doc' reference here
1014         for doc in self.env.all_docs:
1015             yield (doc, clean_astext(self.env.titles[doc]), 'doc', doc, '', -1)
1016         for (prog, option), info in self.progoptions.items():
1017             if prog:
1018                 fullname = ".".join([prog, option])
1019                 yield (fullname, fullname, 'cmdoption', info[0], info[1], 1)
1020             else:
1021                 yield (option, option, 'cmdoption', info[0], info[1], 1)
1022         for (type, name), info in self.objects.items():
1023             yield (name, name, type, info[0], info[1],
1024                    self.object_types[type].attrs['searchprio'])
1025         for name, (docname, labelid, sectionname) in self.labels.items():
1026             yield (name, sectionname, 'label', docname, labelid, -1)
1027         # add anonymous-only labels as well
1028         non_anon_labels = set(self.labels)
1029         for name, (docname, labelid) in self.anonlabels.items():
1030             if name not in non_anon_labels:
1031                 yield (name, name, 'label', docname, labelid, -1)
1032 
1033     def get_type_name(self, type: ObjType, primary: bool = False) -> str:
1034         # never prepend "Default"
1035         return type.lname
1036 
1037     def is_enumerable_node(self, node: Node) -> bool:
1038         return node.__class__ in self.enumerable_nodes
1039 
1040     def get_numfig_title(self, node: Node) -> Optional[str]:
1041         """Get the title of enumerable nodes to refer them using its title"""
1042         if self.is_enumerable_node(node):
1043             elem = cast(Element, node)
1044             _, title_getter = self.enumerable_nodes.get(elem.__class__, (None, None))
1045             if title_getter:
1046                 return title_getter(elem)
1047             else:
1048                 for subnode in elem:
1049                     if isinstance(subnode, (nodes.caption, nodes.title)):
1050                         return clean_astext(subnode)
1051 
1052         return None
1053 
1054     def get_enumerable_node_type(self, node: Node) -> Optional[str]:
1055         """Get type of enumerable nodes."""
1056         def has_child(node: Element, cls: Type) -> bool:
1057             return any(isinstance(child, cls) for child in node)
1058 
1059         if isinstance(node, nodes.section):
1060             return 'section'
1061         elif (isinstance(node, nodes.container) and
1062               'literal_block' in node and
1063               has_child(node, nodes.literal_block)):
1064             # given node is a code-block having caption
1065             return 'code-block'
1066         else:
1067             figtype, _ = self.enumerable_nodes.get(node.__class__, (None, None))
1068             return figtype
1069 
1070     def get_fignumber(self, env: "BuildEnvironment", builder: "Builder",
1071                       figtype: str, docname: str, target_node: Element) -> Tuple[int, ...]:
1072         if figtype == 'section':
1073             if builder.name == 'latex':
1074                 return tuple()
1075             elif docname not in env.toc_secnumbers:
1076                 raise ValueError  # no number assigned
1077             else:
1078                 anchorname = '#' + target_node['ids'][0]
1079                 if anchorname not in env.toc_secnumbers[docname]:
1080                     # try first heading which has no anchor
1081                     return env.toc_secnumbers[docname].get('')
1082                 else:
1083                     return env.toc_secnumbers[docname].get(anchorname)
1084         else:
1085             try:
1086                 figure_id = target_node['ids'][0]
1087                 return env.toc_fignumbers[docname][figtype][figure_id]
1088             except (KeyError, IndexError) as exc:
1089                 # target_node is found, but fignumber is not assigned.
1090                 # Maybe it is defined in orphaned document.
1091                 raise ValueError from exc
1092 
1093     def get_full_qualified_name(self, node: Element) -> Optional[str]:
1094         if node.get('reftype') == 'option':
1095             progname = node.get('std:program')
1096             command = ws_re.split(node.get('reftarget'))
1097             if progname:
1098                 command.insert(0, progname)
1099             option = command.pop()
1100             if command:
1101                 return '.'.join(['-'.join(command), option])
1102             else:
1103                 return None
1104         else:
1105             return None
1106 
1107 
1108 def warn_missing_reference(app: "Sphinx", domain: Domain, node: pending_xref
1109                            ) -> Optional[bool]:
1110     if (domain and domain.name != 'std') or node['reftype'] != 'ref':
1111         return None
1112     else:
1113         target = node['reftarget']
1114         if target not in domain.anonlabels:  # type: ignore
1115             msg = __('undefined label: %s')
1116         else:
1117             msg = __('Failed to create a cross reference. A title or caption not found: %s')
1118 
1119         logger.warning(msg % target, location=node, type='ref', subtype=node['reftype'])
1120         return True
1121 
1122 
1123 def setup(app: "Sphinx") -> Dict[str, Any]:
1124     app.add_domain(StandardDomain)
1125     app.connect('warn-missing-reference', warn_missing_reference)
1126 
1127     return {
1128         'version': 'builtin',
1129         'env_version': 2,
1130         'parallel_read_safe': True,
1131         'parallel_write_safe': True,
1132     }

</code><intended_behavior>This file likely handles the logical structuring or interpretation of standard domain elements, including glossaries. The intended behavior here is to ensure that data structure passed from this processing step to the LaTeX writer (sphinx/writers/latex.py) is correctly formatted or tagged in a way that facilitates the appropriate LaTeX separation of glossary terms. If issues stem from how glossary terms are aggregated or passed along, adjusting this to support clearer separation in LaTeX output is necessary. This might not require adding new methods but rather adjusting existing logic to ensure that groupings of glossary terms are maintained or appropriately flagged for the LaTeX output stage.</intended_behavior>]
2025-10-18 06:18:11.472 | INFO     | Search completed. Bug locations: [<file>sphinx/writers/latex.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2     sphinx.writers.latex
3     ~~~~~~~~~~~~~~~~~~~~
4 
5     Custom docutils writer for LaTeX.
6 
7     Much of this code is adapted from Dave Kuhlman's "docpy" writer from his
8     docutils sandbox.
9 
10     :copyright: Copyright 2007-2021 by the Sphinx team, see AUTHORS.
11     :license: BSD, see LICENSE for details.
12 """
13 
14 import re
15 import warnings
16 from collections import defaultdict
17 from os import path
18 from typing import TYPE_CHECKING, Any, Dict, Iterable, List, Set, Tuple, cast
19 
20 from docutils import nodes, writers
21 from docutils.nodes import Element, Node, Text
22 
23 from sphinx import addnodes, highlighting
24 from sphinx.deprecation import RemovedInSphinx70Warning
25 from sphinx.domains import IndexEntry
26 from sphinx.domains.std import StandardDomain
27 from sphinx.errors import SphinxError
28 from sphinx.locale import _, __, admonitionlabels
29 from sphinx.util import logging, split_into, texescape
30 from sphinx.util.docutils import SphinxTranslator
31 from sphinx.util.nodes import clean_astext, get_prev_node
32 from sphinx.util.template import LaTeXRenderer
33 from sphinx.util.texescape import tex_replace_map
34 
35 try:
36     from docutils.utils.roman import toRoman
37 except ImportError:
38     # In Debian/Ubuntu, roman package is provided as roman, not as docutils.utils.roman
39     from roman import toRoman  # type: ignore
40 
41 if TYPE_CHECKING:
42     from sphinx.builders.latex import LaTeXBuilder
43     from sphinx.builders.latex.theming import Theme
44 
45 
46 logger = logging.getLogger(__name__)
47 
48 MAX_CITATION_LABEL_LENGTH = 8
49 LATEXSECTIONNAMES = ["part", "chapter", "section", "subsection",
50                      "subsubsection", "paragraph", "subparagraph"]
51 ENUMERATE_LIST_STYLE = defaultdict(lambda: r'\arabic',
52                                    {
53                                        'arabic': r'\arabic',
54                                        'loweralpha': r'\alph',
55                                        'upperalpha': r'\Alph',
56                                        'lowerroman': r'\roman',
57                                        'upperroman': r'\Roman',
58                                    })
59 
60 CR = '\n'
61 BLANKLINE = '\n\n'
62 EXTRA_RE = re.compile(r'^(.*\S)\s+\(([^()]*)\)\s*$')
63 
64 
65 class collected_footnote(nodes.footnote):
66     """Footnotes that are collected are assigned this class."""
67 
68 
69 class UnsupportedError(SphinxError):
70     category = 'Markup is unsupported in LaTeX'
71 
72 
73 class LaTeXWriter(writers.Writer):
74 
75     supported = ('sphinxlatex',)
76 
77     settings_spec = ('LaTeX writer options', '', (
78         ('Document name', ['--docname'], {'default': ''}),
79         ('Document class', ['--docclass'], {'default': 'manual'}),
80         ('Author', ['--author'], {'default': ''}),
81     ))
82     settings_defaults: Dict = {}
83 
84     output = None
85 
86     def __init__(self, builder: "LaTeXBuilder") -> None:
87         super().__init__()
88         self.builder = builder
89         self.theme: Theme = None
90 
91     def translate(self) -> None:
92         visitor = self.builder.create_translator(self.document, self.builder, self.theme)
93         self.document.walkabout(visitor)
94         self.output = cast(LaTeXTranslator, visitor).astext()
95 
96 
97 # Helper classes
98 
99 class Table:
100     """A table data"""
101 
102     def __init__(self, node: Element) -> None:
103         self.header: List[str] = []
104         self.body: List[str] = []
105         self.align = node.get('align', 'default')
106         self.classes: List[str] = node.get('classes', [])
107         self.colcount = 0
108         self.colspec: str = None
109         self.colwidths: List[int] = []
110         self.has_problematic = False
111         self.has_oldproblematic = False
112         self.has_verbatim = False
113         self.caption: List[str] = None
114         self.stubs: List[int] = []
115 
116         # current position
117         self.col = 0
118         self.row = 0
119 
120         # A dict mapping a table location to a cell_id (cell = rectangular area)
121         self.cells: Dict[Tuple[int, int], int] = defaultdict(int)
122         self.cell_id = 0  # last assigned cell_id
123 
124     def is_longtable(self) -> bool:
125         """True if and only if table uses longtable environment."""
126         return self.row > 30 or 'longtable' in self.classes
127 
128     def get_table_type(self) -> str:
129         """Returns the LaTeX environment name for the table.
130 
131         The class currently supports:
132 
133         * longtable
134         * tabular
135         * tabulary
136         """
137         if self.is_longtable():
138             return 'longtable'
139         elif self.has_verbatim:
140             return 'tabular'
141         elif self.colspec:
142             return 'tabulary'
143         elif self.has_problematic or (self.colwidths and 'colwidths-given' in self.classes):
144             return 'tabular'
145         else:
146             return 'tabulary'
147 
148     def get_colspec(self) -> str:
149         """Returns a column spec of table.
150 
151         This is what LaTeX calls the 'preamble argument' of the used table environment.
152 
153         .. note:: the ``\\X`` and ``T`` column type specifiers are defined in ``sphinx.sty``.
154         """
155         if self.colspec:
156             return self.colspec
157         elif self.colwidths and 'colwidths-given' in self.classes:
158             total = sum(self.colwidths)
159             colspecs = [r'\X{%d}{%d}' % (width, total) for width in self.colwidths]
160             return '{|%s|}' % '|'.join(colspecs) + CR
161         elif self.has_problematic:
162             return r'{|*{%d}{\X{1}{%d}|}}' % (self.colcount, self.colcount) + CR
163         elif self.get_table_type() == 'tabulary':
164             # sphinx.sty sets T to be J by default.
165             return '{|' + ('T|' * self.colcount) + '}' + CR
166         elif self.has_oldproblematic:
167             return r'{|*{%d}{\X{1}{%d}|}}' % (self.colcount, self.colcount) + CR
168         else:
169             return '{|' + ('l|' * self.colcount) + '}' + CR
170 
171     def add_cell(self, height: int, width: int) -> None:
172         """Adds a new cell to a table.
173 
174         It will be located at current position: (``self.row``, ``self.col``).
175         """
176         self.cell_id += 1
177         for col in range(width):
178             for row in range(height):
179                 assert self.cells[(self.row + row, self.col + col)] == 0
180                 self.cells[(self.row + row, self.col + col)] = self.cell_id
181 
182     def cell(self, row: int = None, col: int = None) -> "TableCell":
183         """Returns a cell object (i.e. rectangular area) containing given position.
184 
185         If no option arguments: ``row`` or ``col`` are given, the current position;
186         ``self.row`` and ``self.col`` are used to get a cell object by default.
187         """
188         try:
189             if row is None:
190                 row = self.row
191             if col is None:
192                 col = self.col
193             return TableCell(self, row, col)
194         except IndexError:
195             return None
196 
197 
198 class TableCell:
199     """Data of a cell in a table."""
200 
201     def __init__(self, table: Table, row: int, col: int) -> None:
202         if table.cells[(row, col)] == 0:
203             raise IndexError
204 
205         self.table = table
206         self.cell_id = table.cells[(row, col)]
207         self.row = row
208         self.col = col
209 
210         # adjust position for multirow/multicol cell
211         while table.cells[(self.row - 1, self.col)] == self.cell_id:
212             self.row -= 1
213         while table.cells[(self.row, self.col - 1)] == self.cell_id:
214             self.col -= 1
215 
216     @property
217     def width(self) -> int:
218         """Returns the cell width."""
219         width = 0
220         while self.table.cells[(self.row, self.col + width)] == self.cell_id:
221             width += 1
222         return width
223 
224     @property
225     def height(self) -> int:
226         """Returns the cell height."""
227         height = 0
228         while self.table.cells[(self.row + height, self.col)] == self.cell_id:
229             height += 1
230         return height
231 
232 
233 def escape_abbr(text: str) -> str:
234     """Adjust spacing after abbreviations."""
235     return re.sub(r'\.(?=\s|$)', r'.\@', text)
236 
237 
238 def rstdim_to_latexdim(width_str: str, scale: int = 100) -> str:
239     """Convert `width_str` with rst length to LaTeX length."""
240     match = re.match(r'^(\d*\.?\d*)\s*(\S*)$', width_str)
241     if not match:
242         raise ValueError
243     res = width_str
244     amount, unit = match.groups()[:2]
245     if scale == 100:
246         float(amount)  # validate amount is float
247         if unit in ('', "px"):
248             res = r"%s\sphinxpxdimen" % amount
249         elif unit == 'pt':
250             res = '%sbp' % amount  # convert to 'bp'
251         elif unit == "%":
252             res = r"%.3f\linewidth" % (float(amount) / 100.0)
253     else:
254         amount_float = float(amount) * scale / 100.0
255         if unit in ('', "px"):
256             res = r"%.5f\sphinxpxdimen" % amount_float
257         elif unit == 'pt':
258             res = '%.5fbp' % amount_float
259         elif unit == "%":
260             res = r"%.5f\linewidth" % (amount_float / 100.0)
261         else:
262             res = "%.5f%s" % (amount_float, unit)
263     return res
264 
265 
266 class LaTeXTranslator(SphinxTranslator):
267     builder: "LaTeXBuilder" = None
268 
269     secnumdepth = 2  # legacy sphinxhowto.cls uses this, whereas article.cls
270     # default is originally 3. For book/report, 2 is already LaTeX default.
271     ignore_missing_images = False
272 
273     def __init__(self, document: nodes.document, builder: "LaTeXBuilder",
274                  theme: "Theme") -> None:
275         super().__init__(document, builder)
276         self.body: List[str] = []
277         self.theme = theme
278 
279         # flags
280         self.in_title = 0
281         self.in_production_list = 0
282         self.in_footnote = 0
283         self.in_caption = 0
284         self.in_term = 0
285         self.needs_linetrimming = 0
286         self.in_minipage = 0
287         self.no_latex_floats = 0
288         self.first_document = 1
289         self.this_is_the_title = 1
290         self.literal_whitespace = 0
291         self.in_parsed_literal = 0
292         self.compact_list = 0
293         self.first_param = 0
294 
295         sphinxpkgoptions = []
296 
297         # sort out some elements
298         self.elements = self.builder.context.copy()
299 
300         # initial section names
301         self.sectionnames = LATEXSECTIONNAMES[:]
302         if self.theme.toplevel_sectioning == 'section':
303             self.sectionnames.remove('chapter')
304 
305         # determine top section level
306         self.top_sectionlevel = 1
307         if self.config.latex_toplevel_sectioning:
308             try:
309                 self.top_sectionlevel = \
310                     self.sectionnames.index(self.config.latex_toplevel_sectioning)
311             except ValueError:
312                 logger.warning(__('unknown %r toplevel_sectioning for class %r') %
313                                (self.config.latex_toplevel_sectioning, self.theme.docclass))
314 
315         if self.config.numfig:
316             self.numfig_secnum_depth = self.config.numfig_secnum_depth
317             if self.numfig_secnum_depth > 0:  # default is 1
318                 # numfig_secnum_depth as passed to sphinx.sty indices same names as in
319                 # LATEXSECTIONNAMES but with -1 for part, 0 for chapter, 1 for section...
320                 if len(self.sectionnames) < len(LATEXSECTIONNAMES) and \
321                    self.top_sectionlevel > 0:
322                     self.numfig_secnum_depth += self.top_sectionlevel
323                 else:
324                     self.numfig_secnum_depth += self.top_sectionlevel - 1
325                 # this (minus one) will serve as minimum to LaTeX's secnumdepth
326                 self.numfig_secnum_depth = min(self.numfig_secnum_depth,
327                                                len(LATEXSECTIONNAMES) - 1)
328                 # if passed key value is < 1 LaTeX will act as if 0; see sphinx.sty
329                 sphinxpkgoptions.append('numfigreset=%s' % self.numfig_secnum_depth)
330             else:
331                 sphinxpkgoptions.append('nonumfigreset')
332 
333         if self.config.numfig and self.config.math_numfig:
334             sphinxpkgoptions.append('mathnumfig')
335 
336         if (self.config.language not in {None, 'en', 'ja'} and
337                 'fncychap' not in self.config.latex_elements):
338             # use Sonny style if any language specified (except English)
339             self.elements['fncychap'] = (r'\usepackage[Sonny]{fncychap}' + CR +
340                                          r'\ChNameVar{\Large\normalfont\sffamily}' + CR +
341                                          r'\ChTitleVar{\Large\normalfont\sffamily}')
342 
343         self.babel = self.builder.babel
344         if self.config.language and not self.babel.is_supported_language():
345             # emit warning if specified language is invalid
346             # (only emitting, nothing changed to processing)
347             logger.warning(__('no Babel option known for language %r'),
348                            self.config.language)
349 
350         minsecnumdepth = self.secnumdepth  # 2 from legacy sphinx manual/howto
351         if self.document.get('tocdepth'):
352             # reduce tocdepth if `part` or `chapter` is used for top_sectionlevel
353             #   tocdepth = -1: show only parts
354             #   tocdepth =  0: show parts and chapters
355             #   tocdepth =  1: show parts, chapters and sections
356             #   tocdepth =  2: show parts, chapters, sections and subsections
357             #   ...
358             tocdepth = self.document.get('tocdepth', 999) + self.top_sectionlevel - 2
359             if len(self.sectionnames) < len(LATEXSECTIONNAMES) and \
360                self.top_sectionlevel > 0:
361                 tocdepth += 1  # because top_sectionlevel is shifted by -1
362             if tocdepth > len(LATEXSECTIONNAMES) - 2:  # default is 5 <-> subparagraph
363                 logger.warning(__('too large :maxdepth:, ignored.'))
364                 tocdepth = len(LATEXSECTIONNAMES) - 2
365 
366             self.elements['tocdepth'] = r'\setcounter{tocdepth}{%d}' % tocdepth
367             minsecnumdepth = max(minsecnumdepth, tocdepth)
368 
369         if self.config.numfig and (self.config.numfig_secnum_depth > 0):
370             minsecnumdepth = max(minsecnumdepth, self.numfig_secnum_depth - 1)
371 
372         if minsecnumdepth > self.secnumdepth:
373             self.elements['secnumdepth'] = r'\setcounter{secnumdepth}{%d}' %\
374                                            minsecnumdepth
375 
376         contentsname = document.get('contentsname')
377         if contentsname:
378             self.elements['contentsname'] = self.babel_renewcommand(r'\contentsname',
379                                                                     contentsname)
380 
381         if self.elements['maxlistdepth']:
382             sphinxpkgoptions.append('maxlistdepth=%s' % self.elements['maxlistdepth'])
383         if sphinxpkgoptions:
384             self.elements['sphinxpkgoptions'] = '[,%s]' % ','.join(sphinxpkgoptions)
385         if self.elements['sphinxsetup']:
386             self.elements['sphinxsetup'] = (r'\sphinxsetup{%s}' % self.elements['sphinxsetup'])
387         if self.elements['extraclassoptions']:
388             self.elements['classoptions'] += ',' + \
389                                              self.elements['extraclassoptions']
390 
391         self.highlighter = highlighting.PygmentsBridge('latex', self.config.pygments_style,
392                                                        latex_engine=self.config.latex_engine)
393         self.context: List[Any] = []
394         self.descstack: List[str] = []
395         self.tables: List[Table] = []
396         self.next_table_colspec: str = None
397         self.bodystack: List[List[str]] = []
398         self.footnote_restricted: Element = None
399         self.pending_footnotes: List[nodes.footnote_reference] = []
400         self.curfilestack: List[str] = []
401         self.handled_abbrs: Set[str] = set()
402 
403     def pushbody(self, newbody: List[str]) -> None:
404         self.bodystack.append(self.body)
405         self.body = newbody
406 
407     def popbody(self) -> List[str]:
408         body = self.body
409         self.body = self.bodystack.pop()
410         return body
411 
412     def astext(self) -> str:
413         self.elements.update({
414             'body': ''.join(self.body),
415             'indices': self.generate_indices()
416         })
417         return self.render('latex.tex_t', self.elements)
418 
419     def hypertarget(self, id: str, withdoc: bool = True, anchor: bool = True) -> str:
420         if withdoc:
421             id = self.curfilestack[-1] + ':' + id
422         return (r'\phantomsection' if anchor else '') + r'\label{%s}' % self.idescape(id)
423 
424     def hypertarget_to(self, node: Element, anchor: bool = False) -> str:
425         labels = ''.join(self.hypertarget(node_id, anchor=False) for node_id in node['ids'])
426         if anchor:
427             return r'\phantomsection' + labels
428         else:
429             return labels
430 
431     def hyperlink(self, id: str) -> str:
432         return r'{\hyperref[%s]{' % self.idescape(id)
433 
434     def hyperpageref(self, id: str) -> str:
435         return r'\autopageref*{%s}' % self.idescape(id)
436 
437     def escape(self, s: str) -> str:
438         return texescape.escape(s, self.config.latex_engine)
439 
440     def idescape(self, id: str) -> str:
441         return r'\detokenize{%s}' % str(id).translate(tex_replace_map).\
442             encode('ascii', 'backslashreplace').decode('ascii').\
443             replace('\\', '_')
444 
445     def babel_renewcommand(self, command: str, definition: str) -> str:
446         if self.elements['multilingual']:
447             prefix = r'\addto\captions%s{' % self.babel.get_language()
448             suffix = '}'
449         else:  # babel is disabled (mainly for Japanese environment)
450             prefix = ''
451             suffix = ''
452 
453         return r'%s\renewcommand{%s}{%s}%s' % (prefix, command, definition, suffix) + CR
454 
455     def generate_indices(self) -> str:
456         def generate(content: List[Tuple[str, List[IndexEntry]]], collapsed: bool) -> None:
457             ret.append(r'\begin{sphinxtheindex}' + CR)
458             ret.append(r'\let\bigletter\sphinxstyleindexlettergroup' + CR)
459             for i, (letter, entries) in enumerate(content):
460                 if i > 0:
461                     ret.append(r'\indexspace' + CR)
462                 ret.append(r'\bigletter{%s}' % self.escape(letter) + CR)
463                 for entry in entries:
464                     if not entry[3]:
465                         continue
466                     ret.append(r'\item\relax\sphinxstyleindexentry{%s}' %
467                                self.encode(entry[0]))
468                     if entry[4]:
469                         # add "extra" info
470                         ret.append(r'\sphinxstyleindexextra{%s}' % self.encode(entry[4]))
471                     ret.append(r'\sphinxstyleindexpageref{%s:%s}' %
472                                (entry[2], self.idescape(entry[3])) + CR)
473             ret.append(r'\end{sphinxtheindex}' + CR)
474 
475         ret = []
476         # latex_domain_indices can be False/True or a list of index names
477         indices_config = self.config.latex_domain_indices
478         if indices_config:
479             for domain in self.builder.env.domains.values():
480                 for indexcls in domain.indices:
481                     indexname = '%s-%s' % (domain.name, indexcls.name)
482                     if isinstance(indices_config, list):
483                         if indexname not in indices_config:
484                             continue
485                     content, collapsed = indexcls(domain).generate(
486                         self.builder.docnames)
487                     if not content:
488                         continue
489                     ret.append(r'\renewcommand{\indexname}{%s}' % indexcls.localname + CR)
490                     generate(content, collapsed)
491 
492         return ''.join(ret)
493 
494     def render(self, template_name: str, variables: Dict) -> str:
495         renderer = LaTeXRenderer(latex_engine=self.config.latex_engine)
496         for template_dir in self.config.templates_path:
497             template = path.join(self.builder.confdir, template_dir,
498                                  template_name)
499             if path.exists(template):
500                 return renderer.render(template, variables)
501 
502         return renderer.render(template_name, variables)
503 
504     @property
505     def table(self) -> Table:
506         """Get current table."""
507         if self.tables:
508             return self.tables[-1]
509         else:
510             return None
511 
512     def visit_document(self, node: Element) -> None:
513         self.curfilestack.append(node.get('docname', ''))
514         if self.first_document == 1:
515             # the first document is all the regular content ...
516             self.first_document = 0
517         elif self.first_document == 0:
518             # ... and all others are the appendices
519             self.body.append(CR + r'\appendix' + CR)
520             self.first_document = -1
521         if 'docname' in node:
522             self.body.append(self.hypertarget(':doc'))
523         # "- 1" because the level is increased before the title is visited
524         self.sectionlevel = self.top_sectionlevel - 1
525 
526     def depart_document(self, node: Element) -> None:
527         pass
528 
529     def visit_start_of_file(self, node: Element) -> None:
530         self.curfilestack.append(node['docname'])
531 
532     def depart_start_of_file(self, node: Element) -> None:
533         self.curfilestack.pop()
534 
535     def visit_section(self, node: Element) -> None:
536         if not self.this_is_the_title:
537             self.sectionlevel += 1
538         self.body.append(BLANKLINE)
539 
540     def depart_section(self, node: Element) -> None:
541         self.sectionlevel = max(self.sectionlevel - 1,
542                                 self.top_sectionlevel - 1)
543 
544     def visit_problematic(self, node: Element) -> None:
545         self.body.append(r'{\color{red}\bfseries{}')
546 
547     def depart_problematic(self, node: Element) -> None:
548         self.body.append('}')
549 
550     def visit_topic(self, node: Element) -> None:
551         self.in_minipage = 1
552         self.body.append(CR + r'\begin{sphinxShadowBox}' + CR)
553 
554     def depart_topic(self, node: Element) -> None:
555         self.in_minipage = 0
556         self.body.append(r'\end{sphinxShadowBox}' + CR)
557     visit_sidebar = visit_topic
558     depart_sidebar = depart_topic
559 
560     def visit_glossary(self, node: Element) -> None:
561         pass
562 
563     def depart_glossary(self, node: Element) -> None:
564         pass
565 
566     def visit_productionlist(self, node: Element) -> None:
567         self.body.append(BLANKLINE)
568         self.body.append(r'\begin{productionlist}' + CR)
569         self.in_production_list = 1
570 
571     def depart_productionlist(self, node: Element) -> None:
572         self.body.append(r'\end{productionlist}' + BLANKLINE)
573         self.in_production_list = 0
574 
575     def visit_production(self, node: Element) -> None:
576         if node['tokenname']:
577             tn = node['tokenname']
578             self.body.append(self.hypertarget('grammar-token-' + tn))
579             self.body.append(r'\production{%s}{' % self.encode(tn))
580         else:
581             self.body.append(r'\productioncont{')
582 
583     def depart_production(self, node: Element) -> None:
584         self.body.append('}' + CR)
585 
586     def visit_transition(self, node: Element) -> None:
587         self.body.append(self.elements['transition'])
588 
589     def depart_transition(self, node: Element) -> None:
590         pass
591 
592     def visit_title(self, node: Element) -> None:
593         parent = node.parent
594         if isinstance(parent, addnodes.seealso):
595             # the environment already handles this
596             raise nodes.SkipNode
597         elif isinstance(parent, nodes.section):
598             if self.this_is_the_title:
599                 if len(node.children) != 1 and not isinstance(node.children[0],
600                                                               nodes.Text):
601                     logger.warning(__('document title is not a single Text node'),
602                                    location=node)
603                 if not self.elements['title']:
604                     # text needs to be escaped since it is inserted into
605                     # the output literally
606                     self.elements['title'] = self.escape(node.astext())
607                 self.this_is_the_title = 0
608                 raise nodes.SkipNode
609             else:
610                 short = ''
611                 if list(node.traverse(nodes.image)):
612                     short = ('[%s]' % self.escape(' '.join(clean_astext(node).split())))
613 
614                 try:
615                     self.body.append(r'\%s%s{' % (self.sectionnames[self.sectionlevel], short))
616                 except IndexError:
617                     # just use "subparagraph", it's not numbered anyway
618                     self.body.append(r'\%s%s{' % (self.sectionnames[-1], short))
619                 self.context.append('}' + CR + self.hypertarget_to(node.parent))
620         elif isinstance(parent, nodes.topic):
621             self.body.append(r'\sphinxstyletopictitle{')
622             self.context.append('}' + CR)
623         elif isinstance(parent, nodes.sidebar):
624             self.body.append(r'\sphinxstylesidebartitle{')
625             self.context.append('}' + CR)
626         elif isinstance(parent, nodes.Admonition):
627             self.body.append('{')
628             self.context.append('}' + CR)
629         elif isinstance(parent, nodes.table):
630             # Redirect body output until title is finished.
631             self.pushbody([])
632         else:
633             logger.warning(__('encountered title node not in section, topic, table, '
634                               'admonition or sidebar'),
635                            location=node)
636             self.body.append(r'\sphinxstyleothertitle{')
637             self.context.append('}' + CR)
638         self.in_title = 1
639 
640     def depart_title(self, node: Element) -> None:
641         self.in_title = 0
642         if isinstance(node.parent, nodes.table):
643             self.table.caption = self.popbody()
644         else:
645             self.body.append(self.context.pop())
646 
647     def visit_subtitle(self, node: Element) -> None:
648         if isinstance(node.parent, nodes.sidebar):
649             self.body.append(r'\sphinxstylesidebarsubtitle{')
650             self.context.append('}' + CR)
651         else:
652             self.context.append('')
653 
654     def depart_subtitle(self, node: Element) -> None:
655         self.body.append(self.context.pop())
656 
657     #############################################################
658     # Domain-specific object descriptions
659     #############################################################
660 
661     # Top-level nodes for descriptions
662     ##################################
663 
664     def visit_desc(self, node: Element) -> None:
665         if self.config.latex_show_urls == 'footnote':
666             self.body.append(BLANKLINE)
667             self.body.append(r'\begin{savenotes}\begin{fulllineitems}' + CR)
668         else:
669             self.body.append(BLANKLINE)
670             self.body.append(r'\begin{fulllineitems}' + CR)
671         if self.table:
672             self.table.has_problematic = True
673 
674     def depart_desc(self, node: Element) -> None:
675         if self.config.latex_show_urls == 'footnote':
676             self.body.append(CR + r'\end{fulllineitems}\end{savenotes}' + BLANKLINE)
677         else:
678             self.body.append(CR + r'\end{fulllineitems}' + BLANKLINE)
679 
680     def _visit_signature_line(self, node: Element) -> None:
681         for child in node:
682             if isinstance(child, addnodes.desc_parameterlist):
683                 self.body.append(r'\pysiglinewithargsret{')
684                 break
685         else:
686             self.body.append(r'\pysigline{')
687 
688     def _depart_signature_line(self, node: Element) -> None:
689         self.body.append('}')
690 
691     def visit_desc_signature(self, node: Element) -> None:
692         if node.parent['objtype'] != 'describe' and node['ids']:
693             hyper = self.hypertarget(node['ids'][0])
694         else:
695             hyper = ''
696         self.body.append(hyper)
697         if not node.get('is_multiline'):
698             self._visit_signature_line(node)
699         else:
700             self.body.append('%' + CR)
701             self.body.append(r'\pysigstartmultiline' + CR)
702 
703     def depart_desc_signature(self, node: Element) -> None:
704         if not node.get('is_multiline'):
705             self._depart_signature_line(node)
706         else:
707             self.body.append('%' + CR)
708             self.body.append(r'\pysigstopmultiline')
709 
710     def visit_desc_signature_line(self, node: Element) -> None:
711         self._visit_signature_line(node)
712 
713     def depart_desc_signature_line(self, node: Element) -> None:
714         self._depart_signature_line(node)
715 
716     def visit_desc_content(self, node: Element) -> None:
717         pass
718 
719     def depart_desc_content(self, node: Element) -> None:
720         pass
721 
722     def visit_desc_inline(self, node: Element) -> None:
723         self.body.append(r'\sphinxcode{\sphinxupquote{')
724 
725     def depart_desc_inline(self, node: Element) -> None:
726         self.body.append('}}')
727 
728     # Nodes for high-level structure in signatures
729     ##############################################
730 
731     def visit_desc_name(self, node: Element) -> None:
732         self.body.append(r'\sphinxbfcode{\sphinxupquote{')
733         self.literal_whitespace += 1
734 
735     def depart_desc_name(self, node: Element) -> None:
736         self.body.append('}}')
737         self.literal_whitespace -= 1
738 
739     def visit_desc_addname(self, node: Element) -> None:
740         self.body.append(r'\sphinxcode{\sphinxupquote{')
741         self.literal_whitespace += 1
742 
743     def depart_desc_addname(self, node: Element) -> None:
744         self.body.append('}}')
745         self.literal_whitespace -= 1
746 
747     def visit_desc_type(self, node: Element) -> None:
748         pass
749 
750     def depart_desc_type(self, node: Element) -> None:
751         pass
752 
753     def visit_desc_returns(self, node: Element) -> None:
754         self.body.append(r'{ $\rightarrow$ ')
755 
756     def depart_desc_returns(self, node: Element) -> None:
757         self.body.append(r'}')
758 
759     def visit_desc_parameterlist(self, node: Element) -> None:
760         # close name, open parameterlist
761         self.body.append('}{')
762         self.first_param = 1
763 
764     def depart_desc_parameterlist(self, node: Element) -> None:
765         # close parameterlist, open return annotation
766         self.body.append('}{')
767 
768     def visit_desc_parameter(self, node: Element) -> None:
769         if not self.first_param:
770             self.body.append(', ')
771         else:
772             self.first_param = 0
773         if not node.hasattr('noemph'):
774             self.body.append(r'\emph{')
775 
776     def depart_desc_parameter(self, node: Element) -> None:
777         if not node.hasattr('noemph'):
778             self.body.append('}')
779 
780     def visit_desc_optional(self, node: Element) -> None:
781         self.body.append(r'\sphinxoptional{')
782 
783     def depart_desc_optional(self, node: Element) -> None:
784         self.body.append('}')
785 
786     def visit_desc_annotation(self, node: Element) -> None:
787         self.body.append(r'\sphinxbfcode{\sphinxupquote{')
788 
789     def depart_desc_annotation(self, node: Element) -> None:
790         self.body.append('}}')
791 
792     ##############################################
793 
794     def visit_seealso(self, node: Element) -> None:
795         self.body.append(BLANKLINE)
796         self.body.append(r'\sphinxstrong{%s:}' % admonitionlabels['seealso'] + CR)
797         self.body.append(r'\nopagebreak' + BLANKLINE)
798 
799     def depart_seealso(self, node: Element) -> None:
800         self.body.append(BLANKLINE)
801 
802     def visit_rubric(self, node: Element) -> None:
803         if len(node) == 1 and node.astext() in ('Footnotes', _('Footnotes')):
804             raise nodes.SkipNode
805         self.body.append(r'\subsubsection*{')
806         self.context.append('}' + CR)
807         self.in_title = 1
808 
809     def depart_rubric(self, node: Element) -> None:
810         self.in_title = 0
811         self.body.append(self.context.pop())
812 
813     def visit_footnote(self, node: Element) -> None:
814         self.in_footnote += 1
815         label = cast(nodes.label, node[0])
816         if 'auto' not in node:
817             self.body.append(r'\sphinxstepexplicit ')
818         if self.in_parsed_literal:
819             self.body.append(r'\begin{footnote}[%s]' % label.astext())
820         else:
821             self.body.append('%' + CR)
822             self.body.append(r'\begin{footnote}[%s]' % label.astext())
823         if 'auto' not in node:
824             self.body.append(r'\phantomsection'
825                              r'\label{\thesphinxscope.%s}%%' % label.astext() + CR)
826         self.body.append(r'\sphinxAtStartFootnote' + CR)
827 
828     def depart_footnote(self, node: Element) -> None:
829         if self.in_parsed_literal:
830             self.body.append(r'\end{footnote}')
831         else:
832             self.body.append('%' + CR)
833             self.body.append(r'\end{footnote}')
834         self.in_footnote -= 1
835 
836     def visit_label(self, node: Element) -> None:
837         raise nodes.SkipNode
838 
839     def visit_tabular_col_spec(self, node: Element) -> None:
840         self.next_table_colspec = node['spec']
841         raise nodes.SkipNode
842 
843     def visit_table(self, node: Element) -> None:
844         if len(self.tables) == 1:
845             if self.table.get_table_type() == 'longtable':
846                 raise UnsupportedError(
847                     '%s:%s: longtable does not support nesting a table.' %
848                     (self.curfilestack[-1], node.line or ''))
849             else:
850                 # change type of parent table to tabular
851                 # see https://groups.google.com/d/msg/sphinx-users/7m3NeOBixeo/9LKP2B4WBQAJ
852                 self.table.has_problematic = True
853         elif len(self.tables) > 2:
854             raise UnsupportedError(
855                 '%s:%s: deeply nested tables are not implemented.' %
856                 (self.curfilestack[-1], node.line or ''))
857 
858         self.tables.append(Table(node))
859         if self.next_table_colspec:
860             self.table.colspec = '{%s}' % self.next_table_colspec + CR
861             if 'colwidths-given' in node.get('classes', []):
862                 logger.info(__('both tabularcolumns and :widths: option are given. '
863                                ':widths: is ignored.'), location=node)
864         self.next_table_colspec = None
865 
866     def depart_table(self, node: Element) -> None:
867         labels = self.hypertarget_to(node)
868         table_type = self.table.get_table_type()
869         table = self.render(table_type + '.tex_t',
870                             dict(table=self.table, labels=labels))
871         self.body.append(BLANKLINE)
872         self.body.append(table)
873         self.body.append(CR)
874 
875         self.tables.pop()
876 
877     def visit_colspec(self, node: Element) -> None:
878         self.table.colcount += 1
879         if 'colwidth' in node:
880             self.table.colwidths.append(node['colwidth'])
881         if 'stub' in node:
882             self.table.stubs.append(self.table.colcount - 1)
883 
884     def depart_colspec(self, node: Element) -> None:
885         pass
886 
887     def visit_tgroup(self, node: Element) -> None:
888         pass
889 
890     def depart_tgroup(self, node: Element) -> None:
891         pass
892 
893     def visit_thead(self, node: Element) -> None:
894         # Redirect head output until header is finished.
895         self.pushbody(self.table.header)
896 
897     def depart_thead(self, node: Element) -> None:
898         self.popbody()
899 
900     def visit_tbody(self, node: Element) -> None:
901         # Redirect body output until table is finished.
902         self.pushbody(self.table.body)
903 
904     def depart_tbody(self, node: Element) -> None:
905         self.popbody()
906 
907     def visit_row(self, node: Element) -> None:
908         self.table.col = 0
909 
910         # fill columns if the row starts with the bottom of multirow cell
911         while True:
912             cell = self.table.cell(self.table.row, self.table.col)
913             if cell is None:  # not a bottom of multirow cell
914                 break
915             else:  # a bottom of multirow cell
916                 self.table.col += cell.width
917                 if cell.col:
918                     self.body.append('&')
919                 if cell.width == 1:
920                     # insert suitable strut for equalizing row heights in given multirow
921                     self.body.append(r'\sphinxtablestrut{%d}' % cell.cell_id)
922                 else:  # use \multicolumn for wide multirow cell
923                     self.body.append(r'\multicolumn{%d}{|l|}{\sphinxtablestrut{%d}}' %
924                                      (cell.width, cell.cell_id))
925 
926     def depart_row(self, node: Element) -> None:
927         self.body.append(r'\\' + CR)
928         cells = [self.table.cell(self.table.row, i) for i in range(self.table.colcount)]
929         underlined = [cell.row + cell.height == self.table.row + 1 for cell in cells]
930         if all(underlined):
931             self.body.append(r'\hline')
932         else:
933             i = 0
934             underlined.extend([False])  # sentinel
935             while i < len(underlined):
936                 if underlined[i] is True:
937                     j = underlined[i:].index(False)
938                     self.body.append(r'\cline{%d-%d}' % (i + 1, i + j))
939                     i += j
940                 i += 1
941         self.table.row += 1
942 
943     def visit_entry(self, node: Element) -> None:
944         if self.table.col > 0:
945             self.body.append('&')
946         self.table.add_cell(node.get('morerows', 0) + 1, node.get('morecols', 0) + 1)
947         cell = self.table.cell()
948         context = ''
949         if cell.width > 1:
950             if self.config.latex_use_latex_multicolumn:
951                 if self.table.col == 0:
952                     self.body.append(r'\multicolumn{%d}{|l|}{%%' % cell.width + CR)
953                 else:
954                     self.body.append(r'\multicolumn{%d}{l|}{%%' % cell.width + CR)
955                 context = '}%' + CR
956             else:
957                 self.body.append(r'\sphinxstartmulticolumn{%d}%%' % cell.width + CR)
958                 context = r'\sphinxstopmulticolumn' + CR
959         if cell.height > 1:
960             # \sphinxmultirow 2nd arg "cell_id" will serve as id for LaTeX macros as well
961             self.body.append(r'\sphinxmultirow{%d}{%d}{%%' % (cell.height, cell.cell_id) + CR)
962             context = '}%' + CR + context
963         if cell.width > 1 or cell.height > 1:
964             self.body.append(r'\begin{varwidth}[t]{\sphinxcolwidth{%d}{%d}}'
965                              % (cell.width, self.table.colcount) + CR)
966             context = (r'\par' + CR + r'\vskip-\baselineskip'
967                        r'\vbox{\hbox{\strut}}\end{varwidth}%' + CR + context)
968             self.needs_linetrimming = 1
969         if len(list(node.traverse(nodes.paragraph))) >= 2:
970             self.table.has_oldproblematic = True
971         if isinstance(node.parent.parent, nodes.thead) or (cell.col in self.table.stubs):
972             if len(node) == 1 and isinstance(node[0], nodes.paragraph) and node.astext() == '':
973                 pass
974             else:
975                 self.body.append(r'\sphinxstyletheadfamily ')
976         if self.needs_linetrimming:
977             self.pushbody([])
978         self.context.append(context)
979 
980     def depart_entry(self, node: Element) -> None:
981         if self.needs_linetrimming:
982             self.needs_linetrimming = 0
983             body = self.popbody()
984 
985             # Remove empty lines from top of merged cell
986             while body and body[0] == CR:
987                 body.pop(0)
988             self.body.extend(body)
989 
990         self.body.append(self.context.pop())
991 
992         cell = self.table.cell()
993         self.table.col += cell.width
994 
995         # fill columns if next ones are a bottom of wide-multirow cell
996         while True:
997             nextcell = self.table.cell()
998             if nextcell is None:  # not a bottom of multirow cell
999                 break
1000             else:  # a bottom part of multirow cell
1001                 self.table.col += nextcell.width
1002                 self.body.append('&')
1003                 if nextcell.width == 1:
1004                     # insert suitable strut for equalizing row heights in multirow
1005                     # they also serve to clear colour panels which would hide the text
1006                     self.body.append(r'\sphinxtablestrut{%d}' % nextcell.cell_id)
1007                 else:
1008                     # use \multicolumn for wide multirow cell
1009                     self.body.append(r'\multicolumn{%d}{l|}{\sphinxtablestrut{%d}}' %
1010                                      (nextcell.width, nextcell.cell_id))
1011 
1012     def visit_acks(self, node: Element) -> None:
1013         # this is a list in the source, but should be rendered as a
1014         # comma-separated list here
1015         bullet_list = cast(nodes.bullet_list, node[0])
1016         list_items = cast(Iterable[nodes.list_item], bullet_list)
1017         self.body.append(BLANKLINE)
1018         self.body.append(', '.join(n.astext() for n in list_items) + '.')
1019         self.body.append(BLANKLINE)
1020         raise nodes.SkipNode
1021 
1022     def visit_bullet_list(self, node: Element) -> None:
1023         if not self.compact_list:
1024             self.body.append(r'\begin{itemize}' + CR)
1025         if self.table:
1026             self.table.has_problematic = True
1027 
1028     def depart_bullet_list(self, node: Element) -> None:
1029         if not self.compact_list:
1030             self.body.append(r'\end{itemize}' + CR)
1031 
1032     def visit_enumerated_list(self, node: Element) -> None:
1033         def get_enumtype(node: Element) -> str:
1034             enumtype = node.get('enumtype', 'arabic')
1035             if 'alpha' in enumtype and 26 < node.get('start', 0) + len(node):
1036                 # fallback to arabic if alphabet counter overflows
1037                 enumtype = 'arabic'
1038 
1039             return enumtype
1040 
1041         def get_nested_level(node: Element) -> int:
1042             if node is None:
1043                 return 0
1044             elif isinstance(node, nodes.enumerated_list):
1045                 return get_nested_level(node.parent) + 1
1046             else:
1047                 return get_nested_level(node.parent)
1048 
1049         enum = "enum%s" % toRoman(get_nested_level(node)).lower()
1050         enumnext = "enum%s" % toRoman(get_nested_level(node) + 1).lower()
1051         style = ENUMERATE_LIST_STYLE.get(get_enumtype(node))
1052         prefix = node.get('prefix', '')
1053         suffix = node.get('suffix', '.')
1054 
1055         self.body.append(r'\begin{enumerate}' + CR)
1056         self.body.append(r'\sphinxsetlistlabels{%s}{%s}{%s}{%s}{%s}%%' %
1057                          (style, enum, enumnext, prefix, suffix) + CR)
1058         if 'start' in node:
1059             self.body.append(r'\setcounter{%s}{%d}' % (enum, node['start'] - 1) + CR)
1060         if self.table:
1061             self.table.has_problematic = True
1062 
1063     def depart_enumerated_list(self, node: Element) -> None:
1064         self.body.append(r'\end{enumerate}' + CR)
1065 
1066     def visit_list_item(self, node: Element) -> None:
1067         # Append "{}" in case the next character is "[", which would break
1068         # LaTeX's list environment (no numbering and the "[" is not printed).
1069         self.body.append(r'\item {} ')
1070 
1071     def depart_list_item(self, node: Element) -> None:
1072         self.body.append(CR)
1073 
1074     def visit_definition_list(self, node: Element) -> None:
1075         self.body.append(r'\begin{description}' + CR)
1076         if self.table:
1077             self.table.has_problematic = True
1078 
1079     def depart_definition_list(self, node: Element) -> None:
1080         self.body.append(r'\end{description}' + CR)
1081 
1082     def visit_definition_list_item(self, node: Element) -> None:
1083         pass
1084 
1085     def depart_definition_list_item(self, node: Element) -> None:
1086         pass
1087 
1088     def visit_term(self, node: Element) -> None:
1089         self.in_term += 1
1090         ctx = ''
1091         if node.get('ids'):
1092             ctx = r'\phantomsection'
1093             for node_id in node['ids']:
1094                 ctx += self.hypertarget(node_id, anchor=False)
1095         ctx += r'}] \leavevmode'
1096         self.body.append(r'\item[{')
1097         self.context.append(ctx)
1098 
1099     def depart_term(self, node: Element) -> None:
1100         self.body.append(self.context.pop())
1101         self.in_term -= 1
1102 
1103     def visit_classifier(self, node: Element) -> None:
1104         self.body.append('{[}')
1105 
1106     def depart_classifier(self, node: Element) -> None:
1107         self.body.append('{]}')
1108 
1109     def visit_definition(self, node: Element) -> None:
1110         pass
1111 
1112     def depart_definition(self, node: Element) -> None:
1113         self.body.append(CR)
1114 
1115     def visit_field_list(self, node: Element) -> None:
1116         self.body.append(r'\begin{quote}\begin{description}' + CR)
1117         if self.table:
1118             self.table.has_problematic = True
1119 
1120     def depart_field_list(self, node: Element) -> None:
1121         self.body.append(r'\end{description}\end{quote}' + CR)
1122 
1123     def visit_field(self, node: Element) -> None:
1124         pass
1125 
1126     def depart_field(self, node: Element) -> None:
1127         pass
1128 
1129     visit_field_name = visit_term
1130     depart_field_name = depart_term
1131 
1132     visit_field_body = visit_definition
1133     depart_field_body = depart_definition
1134 
1135     def visit_paragraph(self, node: Element) -> None:
1136         index = node.parent.index(node)
1137         if (index > 0 and isinstance(node.parent, nodes.compound) and
1138                 not isinstance(node.parent[index - 1], nodes.paragraph) and
1139                 not isinstance(node.parent[index - 1], nodes.compound)):
1140             # insert blank line, if the paragraph follows a non-paragraph node in a compound
1141             self.body.append(r'\noindent' + CR)
1142         elif index == 1 and isinstance(node.parent, (nodes.footnote, footnotetext)):
1143             # don't insert blank line, if the paragraph is second child of a footnote
1144             # (first one is label node)
1145             pass
1146         else:
1147             # the \sphinxAtStartPar is to allow hyphenation of first word of
1148             # a paragraph in narrow contexts such as in a table cell
1149             # added as two items (cf. line trimming in depart_entry())
1150             self.body.extend([CR, r'\sphinxAtStartPar' + CR])
1151 
1152     def depart_paragraph(self, node: Element) -> None:
1153         self.body.append(CR)
1154 
1155     def visit_centered(self, node: Element) -> None:
1156         self.body.append(CR + r'\begin{center}')
1157         if self.table:
1158             self.table.has_problematic = True
1159 
1160     def depart_centered(self, node: Element) -> None:
1161         self.body.append(CR + r'\end{center}')
1162 
1163     def visit_hlist(self, node: Element) -> None:
1164         self.compact_list += 1
1165         ncolumns = node['ncolumns']
1166         if self.compact_list > 1:
1167             self.body.append(r'\setlength{\multicolsep}{0pt}' + CR)
1168         self.body.append(r'\begin{multicols}{' + ncolumns + r'}\raggedright' + CR)
1169         self.body.append(r'\begin{itemize}\setlength{\itemsep}{0pt}'
1170                          r'\setlength{\parskip}{0pt}' + CR)
1171         if self.table:
1172             self.table.has_problematic = True
1173 
1174     def depart_hlist(self, node: Element) -> None:
1175         self.compact_list -= 1
1176         self.body.append(r'\end{itemize}\raggedcolumns\end{multicols}' + CR)
1177 
1178     def visit_hlistcol(self, node: Element) -> None:
1179         pass
1180 
1181     def depart_hlistcol(self, node: Element) -> None:
1182         # \columnbreak would guarantee same columns as in html output.  But
1183         # some testing with long items showed that columns may be too uneven.
1184         # And in case only of short items, the automatic column breaks should
1185         # match the ones pre-computed by the hlist() directive.
1186         # self.body.append(r'\columnbreak\n')
1187         pass
1188 
1189     def latex_image_length(self, width_str: str, scale: int = 100) -> str:
1190         try:
1191             return rstdim_to_latexdim(width_str, scale)
1192         except ValueError:
1193             logger.warning(__('dimension unit %s is invalid. Ignored.'), width_str)
1194             return None
1195 
1196     def is_inline(self, node: Element) -> bool:
1197         """Check whether a node represents an inline element."""
1198         return isinstance(node.parent, nodes.TextElement)
1199 
1200     def visit_image(self, node: Element) -> None:
1201         pre: List[str] = []  # in reverse order
1202         post: List[str] = []
1203         include_graphics_options = []
1204         has_hyperlink = isinstance(node.parent, nodes.reference)
1205         if has_hyperlink:
1206             is_inline = self.is_inline(node.parent)
1207         else:
1208             is_inline = self.is_inline(node)
1209         if 'width' in node:
1210             if 'scale' in node:
1211                 w = self.latex_image_length(node['width'], node['scale'])
1212             else:
1213                 w = self.latex_image_length(node['width'])
1214             if w:
1215                 include_graphics_options.append('width=%s' % w)
1216         if 'height' in node:
1217             if 'scale' in node:
1218                 h = self.latex_image_length(node['height'], node['scale'])
1219             else:
1220                 h = self.latex_image_length(node['height'])
1221             if h:
1222                 include_graphics_options.append('height=%s' % h)
1223         if 'scale' in node:
1224             if not include_graphics_options:
1225                 # if no "width" nor "height", \sphinxincludegraphics will fit
1226                 # to the available text width if oversized after rescaling.
1227                 include_graphics_options.append('scale=%s'
1228                                                 % (float(node['scale']) / 100.0))
1229         if 'align' in node:
1230             align_prepost = {
1231                 # By default latex aligns the top of an image.
1232                 (1, 'top'): ('', ''),
1233                 (1, 'middle'): (r'\raisebox{-0.5\height}{', '}'),
1234                 (1, 'bottom'): (r'\raisebox{-\height}{', '}'),
1235                 (0, 'center'): (r'{\hspace*{\fill}', r'\hspace*{\fill}}'),
1236                 # These 2 don't exactly do the right thing.  The image should
1237                 # be floated alongside the paragraph.  See
1238                 # https://www.w3.org/TR/html4/struct/objects.html#adef-align-IMG
1239                 (0, 'left'): ('{', r'\hspace*{\fill}}'),
1240                 (0, 'right'): (r'{\hspace*{\fill}', '}'),
1241             }
1242             try:
1243                 pre.append(align_prepost[is_inline, node['align']][0])
1244                 post.append(align_prepost[is_inline, node['align']][1])
1245             except KeyError:
1246                 pass
1247         if self.in_parsed_literal:
1248             pre.append(r'{\sphinxunactivateextrasandspace ')
1249             post.append('}')
1250         if not is_inline and not has_hyperlink:
1251             pre.append(CR + r'\noindent')
1252             post.append(CR)
1253         pre.reverse()
1254         if node['uri'] in self.builder.images:
1255             uri = self.builder.images[node['uri']]
1256         else:
1257             # missing image!
1258             if self.ignore_missing_images:
1259                 return
1260             uri = node['uri']
1261         if uri.find('://') != -1:
1262             # ignore remote images
1263             return
1264         self.body.extend(pre)
1265         options = ''
1266         if include_graphics_options:
1267             options = '[%s]' % ','.join(include_graphics_options)
1268         base, ext = path.splitext(uri)
1269         if self.in_title and base:
1270             # Lowercase tokens forcely because some fncychap themes capitalize
1271             # the options of \sphinxincludegraphics unexpectedly (ex. WIDTH=...).
1272             self.body.append(r'\lowercase{\sphinxincludegraphics%s}{{%s}%s}' %
1273                              (options, base, ext))
1274         else:
1275             self.body.append(r'\sphinxincludegraphics%s{{%s}%s}' %
1276                              (options, base, ext))
1277         self.body.extend(post)
1278 
1279     def depart_image(self, node: Element) -> None:
1280         pass
1281 
1282     def visit_figure(self, node: Element) -> None:
1283         align = self.elements['figure_align']
1284         if self.no_latex_floats:
1285             align = "H"
1286         if self.table:
1287             # TODO: support align option
1288             if 'width' in node:
1289                 length = self.latex_image_length(node['width'])
1290                 if length:
1291                     self.body.append(r'\begin{sphinxfigure-in-table}[%s]' % length + CR)
1292                     self.body.append(r'\centering' + CR)
1293             else:
1294                 self.body.append(r'\begin{sphinxfigure-in-table}' + CR)
1295                 self.body.append(r'\centering' + CR)
1296             if any(isinstance(child, nodes.caption) for child in node):
1297                 self.body.append(r'\capstart')
1298             self.context.append(r'\end{sphinxfigure-in-table}\relax' + CR)
1299         elif node.get('align', '') in ('left', 'right'):
1300             length = None
1301             if 'width' in node:
1302                 length = self.latex_image_length(node['width'])
1303             elif isinstance(node[0], nodes.image) and 'width' in node[0]:
1304                 length = self.latex_image_length(node[0]['width'])
1305             self.body.append(BLANKLINE)     # Insert a blank line to prevent infinite loop
1306                                             # https://github.com/sphinx-doc/sphinx/issues/7059
1307             self.body.append(r'\begin{wrapfigure}{%s}{%s}' %
1308                              ('r' if node['align'] == 'right' else 'l', length or '0pt') + CR)
1309             self.body.append(r'\centering')
1310             self.context.append(r'\end{wrapfigure}' + CR)
1311         elif self.in_minipage:
1312             self.body.append(CR + r'\begin{center}')
1313             self.context.append(r'\end{center}' + CR)
1314         else:
1315             self.body.append(CR + r'\begin{figure}[%s]' % align + CR)
1316             self.body.append(r'\centering' + CR)
1317             if any(isinstance(child, nodes.caption) for child in node):
1318                 self.body.append(r'\capstart' + CR)
1319             self.context.append(r'\end{figure}' + CR)
1320 
1321     def depart_figure(self, node: Element) -> None:
1322         self.body.append(self.context.pop())
1323 
1324     def visit_caption(self, node: Element) -> None:
1325         self.in_caption += 1
1326         if isinstance(node.parent, captioned_literal_block):
1327             self.body.append(r'\sphinxSetupCaptionForVerbatim{')
1328         elif self.in_minipage and isinstance(node.parent, nodes.figure):
1329             self.body.append(r'\captionof{figure}{')
1330         elif self.table and node.parent.tagname == 'figure':
1331             self.body.append(r'\sphinxfigcaption{')
1332         else:
1333             self.body.append(r'\caption{')
1334 
1335     def depart_caption(self, node: Element) -> None:
1336         self.body.append('}')
1337         if isinstance(node.parent, nodes.figure):
1338             labels = self.hypertarget_to(node.parent)
1339             self.body.append(labels)
1340         self.in_caption -= 1
1341 
1342     def visit_legend(self, node: Element) -> None:
1343         self.body.append(CR + r'\begin{sphinxlegend}')
1344 
1345     def depart_legend(self, node: Element) -> None:
1346         self.body.append(r'\end{sphinxlegend}' + CR)
1347 
1348     def visit_admonition(self, node: Element) -> None:
1349         self.body.append(CR + r'\begin{sphinxadmonition}{note}')
1350         self.no_latex_floats += 1
1351 
1352     def depart_admonition(self, node: Element) -> None:
1353         self.body.append(r'\end{sphinxadmonition}' + CR)
1354         self.no_latex_floats -= 1
1355 
1356     def _visit_named_admonition(self, node: Element) -> None:
1357         label = admonitionlabels[node.tagname]
1358         self.body.append(CR + r'\begin{sphinxadmonition}{%s}{%s:}' %
1359                          (node.tagname, label))
1360         self.no_latex_floats += 1
1361 
1362     def _depart_named_admonition(self, node: Element) -> None:
1363         self.body.append(r'\end{sphinxadmonition}' + CR)
1364         self.no_latex_floats -= 1
1365 
1366     visit_attention = _visit_named_admonition
1367     depart_attention = _depart_named_admonition
1368     visit_caution = _visit_named_admonition
1369     depart_caution = _depart_named_admonition
1370     visit_danger = _visit_named_admonition
1371     depart_danger = _depart_named_admonition
1372     visit_error = _visit_named_admonition
1373     depart_error = _depart_named_admonition
1374     visit_hint = _visit_named_admonition
1375     depart_hint = _depart_named_admonition
1376     visit_important = _visit_named_admonition
1377     depart_important = _depart_named_admonition
1378     visit_note = _visit_named_admonition
1379     depart_note = _depart_named_admonition
1380     visit_tip = _visit_named_admonition
1381     depart_tip = _depart_named_admonition
1382     visit_warning = _visit_named_admonition
1383     depart_warning = _depart_named_admonition
1384 
1385     def visit_versionmodified(self, node: Element) -> None:
1386         pass
1387 
1388     def depart_versionmodified(self, node: Element) -> None:
1389         pass
1390 
1391     def visit_target(self, node: Element) -> None:
1392         def add_target(id: str) -> None:
1393             # indexing uses standard LaTeX index markup, so the targets
1394             # will be generated differently
1395             if id.startswith('index-'):
1396                 return
1397 
1398             # equations also need no extra blank line nor hypertarget
1399             # TODO: fix this dependency on mathbase extension internals
1400             if id.startswith('equation-'):
1401                 return
1402 
1403             # insert blank line, if the target follows a paragraph node
1404             index = node.parent.index(node)
1405             if index > 0 and isinstance(node.parent[index - 1], nodes.paragraph):
1406                 self.body.append(CR)
1407 
1408             # do not generate \phantomsection in \section{}
1409             anchor = not self.in_title
1410             self.body.append(self.hypertarget(id, anchor=anchor))
1411 
1412         # skip if visitor for next node supports hyperlink
1413         next_node: Node = node
1414         while isinstance(next_node, nodes.target):
1415             next_node = next_node.next_node(ascend=True)
1416 
1417         domain = cast(StandardDomain, self.builder.env.get_domain('std'))
1418         if isinstance(next_node, HYPERLINK_SUPPORT_NODES):
1419             return
1420         elif domain.get_enumerable_node_type(next_node) and domain.get_numfig_title(next_node):
1421             return
1422 
1423         if 'refuri' in node:
1424             return
1425         if 'anonymous' in node:
1426             return
1427         if node.get('refid'):
1428             prev_node = get_prev_node(node)
1429             if isinstance(prev_node, nodes.reference) and node['refid'] == prev_node['refid']:
1430                 # a target for a hyperlink reference having alias
1431                 pass
1432             else:
1433                 add_target(node['refid'])
1434         for id in node['ids']:
1435             add_target(id)
1436 
1437     def depart_target(self, node: Element) -> None:
1438         pass
1439 
1440     def visit_attribution(self, node: Element) -> None:
1441         self.body.append(CR + r'\begin{flushright}' + CR)
1442         self.body.append('---')
1443 
1444     def depart_attribution(self, node: Element) -> None:
1445         self.body.append(CR + r'\end{flushright}' + CR)
1446 
1447     def visit_index(self, node: Element) -> None:
1448         def escape(value: str) -> str:
1449             value = self.encode(value)
1450             value = value.replace(r'\{', r'\sphinxleftcurlybrace{}')
1451             value = value.replace(r'\}', r'\sphinxrightcurlybrace{}')
1452             value = value.replace('"', '""')
1453             value = value.replace('@', '"@')
1454             value = value.replace('!', '"!')
1455             value = value.replace('|', r'\textbar{}')
1456             return value
1457 
1458         def style(string: str) -> str:
1459             match = EXTRA_RE.match(string)
1460             if match:
1461                 return match.expand(r'\\spxentry{\1}\\spxextra{\2}')
1462             else:
1463                 return r'\spxentry{%s}' % string
1464 
1465         if not node.get('inline', True):
1466             self.body.append(CR)
1467         entries = node['entries']
1468         for type, string, tid, ismain, key_ in entries:
1469             m = ''
1470             if ismain:
1471                 m = '|spxpagem'
1472             try:
1473                 if type == 'single':
1474                     try:
1475                         p1, p2 = [escape(x) for x in split_into(2, 'single', string)]
1476                         P1, P2 = style(p1), style(p2)
1477                         self.body.append(r'\index{%s@%s!%s@%s%s}' % (p1, P1, p2, P2, m))
1478                     except ValueError:
1479                         p = escape(split_into(1, 'single', string)[0])
1480                         P = style(p)
1481                         self.body.append(r'\index{%s@%s%s}' % (p, P, m))
1482                 elif type == 'pair':
1483                     p1, p2 = [escape(x) for x in split_into(2, 'pair', string)]
1484                     P1, P2 = style(p1), style(p2)
1485                     self.body.append(r'\index{%s@%s!%s@%s%s}\index{%s@%s!%s@%s%s}' %
1486                                      (p1, P1, p2, P2, m, p2, P2, p1, P1, m))
1487                 elif type == 'triple':
1488                     p1, p2, p3 = [escape(x) for x in split_into(3, 'triple', string)]
1489                     P1, P2, P3 = style(p1), style(p2), style(p3)
1490                     self.body.append(
1491                         r'\index{%s@%s!%s %s@%s %s%s}'
1492                         r'\index{%s@%s!%s, %s@%s, %s%s}'
1493                         r'\index{%s@%s!%s %s@%s %s%s}' %
1494                         (p1, P1, p2, p3, P2, P3, m,
1495                          p2, P2, p3, p1, P3, P1, m,
1496                          p3, P3, p1, p2, P1, P2, m))
1497                 elif type == 'see':
1498                     p1, p2 = [escape(x) for x in split_into(2, 'see', string)]
1499                     P1 = style(p1)
1500                     self.body.append(r'\index{%s@%s|see{%s}}' % (p1, P1, p2))
1501                 elif type == 'seealso':
1502                     p1, p2 = [escape(x) for x in split_into(2, 'seealso', string)]
1503                     P1 = style(p1)
1504                     self.body.append(r'\index{%s@%s|see{%s}}' % (p1, P1, p2))
1505                 else:
1506                     logger.warning(__('unknown index entry type %s found'), type)
1507             except ValueError as err:
1508                 logger.warning(str(err))
1509         if not node.get('inline', True):
1510             self.body.append(r'\ignorespaces ')
1511         raise nodes.SkipNode
1512 
1513     def visit_raw(self, node: Element) -> None:
1514         if not self.is_inline(node):
1515             self.body.append(CR)
1516         if 'latex' in node.get('format', '').split():
1517             self.body.append(node.astext())
1518         if not self.is_inline(node):
1519             self.body.append(CR)
1520         raise nodes.SkipNode
1521 
1522     def visit_reference(self, node: Element) -> None:
1523         if not self.in_title:
1524             for id in node.get('ids'):
1525                 anchor = not self.in_caption
1526                 self.body += self.hypertarget(id, anchor=anchor)
1527         if not self.is_inline(node):
1528             self.body.append(CR)
1529         uri = node.get('refuri', '')
1530         if not uri and node.get('refid'):
1531             uri = '%' + self.curfilestack[-1] + '#' + node['refid']
1532         if self.in_title or not uri:
1533             self.context.append('')
1534         elif uri.startswith('#'):
1535             # references to labels in the same document
1536             id = self.curfilestack[-1] + ':' + uri[1:]
1537             self.body.append(self.hyperlink(id))
1538             self.body.append(r'\emph{')
1539             if self.config.latex_show_pagerefs and not \
1540                     self.in_production_list:
1541                 self.context.append('}}} (%s)' % self.hyperpageref(id))
1542             else:
1543                 self.context.append('}}}')
1544         elif uri.startswith('%'):
1545             # references to documents or labels inside documents
1546             hashindex = uri.find('#')
1547             if hashindex == -1:
1548                 # reference to the document
1549                 id = uri[1:] + '::doc'
1550             else:
1551                 # reference to a label
1552                 id = uri[1:].replace('#', ':')
1553             self.body.append(self.hyperlink(id))
1554             if (len(node) and
1555                     isinstance(node[0], nodes.Element) and
1556                     'std-term' in node[0].get('classes', [])):
1557                 # don't add a pageref for glossary terms
1558                 self.context.append('}}}')
1559                 # mark up as termreference
1560                 self.body.append(r'\sphinxtermref{')
1561             else:
1562                 self.body.append(r'\sphinxcrossref{')
1563                 if self.config.latex_show_pagerefs and not self.in_production_list:
1564                     self.context.append('}}} (%s)' % self.hyperpageref(id))
1565                 else:
1566                     self.context.append('}}}')
1567         else:
1568             if len(node) == 1 and uri == node[0]:
1569                 if node.get('nolinkurl'):
1570                     self.body.append(r'\sphinxnolinkurl{%s}' % self.encode_uri(uri))
1571                 else:
1572                     self.body.append(r'\sphinxurl{%s}' % self.encode_uri(uri))
1573                 raise nodes.SkipNode
1574             else:
1575                 self.body.append(r'\sphinxhref{%s}{' % self.encode_uri(uri))
1576                 self.context.append('}')
1577 
1578     def depart_reference(self, node: Element) -> None:
1579         self.body.append(self.context.pop())
1580         if not self.is_inline(node):
1581             self.body.append(CR)
1582 
1583     def visit_number_reference(self, node: Element) -> None:
1584         if node.get('refid'):
1585             id = self.curfilestack[-1] + ':' + node['refid']
1586         else:
1587             id = node.get('refuri', '')[1:].replace('#', ':')
1588 
1589         title = self.escape(node.get('title', '%s')).replace(r'\%s', '%s')
1590         if r'\{name\}' in title or r'\{number\}' in title:
1591             # new style format (cf. "Fig.%{number}")
1592             title = title.replace(r'\{name\}', '{name}').replace(r'\{number\}', '{number}')
1593             text = escape_abbr(title).format(name=r'\nameref{%s}' % self.idescape(id),
1594                                              number=r'\ref{%s}' % self.idescape(id))
1595         else:
1596             # old style format (cf. "Fig.%{number}")
1597             text = escape_abbr(title) % (r'\ref{%s}' % self.idescape(id))
1598         hyperref = r'\hyperref[%s]{%s}' % (self.idescape(id), text)
1599         self.body.append(hyperref)
1600 
1601         raise nodes.SkipNode
1602 
1603     def visit_download_reference(self, node: Element) -> None:
1604         pass
1605 
1606     def depart_download_reference(self, node: Element) -> None:
1607         pass
1608 
1609     def visit_pending_xref(self, node: Element) -> None:
1610         pass
1611 
1612     def depart_pending_xref(self, node: Element) -> None:
1613         pass
1614 
1615     def visit_emphasis(self, node: Element) -> None:
1616         self.body.append(r'\sphinxstyleemphasis{')
1617 
1618     def depart_emphasis(self, node: Element) -> None:
1619         self.body.append('}')
1620 
1621     def visit_literal_emphasis(self, node: Element) -> None:
1622         self.body.append(r'\sphinxstyleliteralemphasis{\sphinxupquote{')
1623 
1624     def depart_literal_emphasis(self, node: Element) -> None:
1625         self.body.append('}}')
1626 
1627     def visit_strong(self, node: Element) -> None:
1628         self.body.append(r'\sphinxstylestrong{')
1629 
1630     def depart_strong(self, node: Element) -> None:
1631         self.body.append('}')
1632 
1633     def visit_literal_strong(self, node: Element) -> None:
1634         self.body.append(r'\sphinxstyleliteralstrong{\sphinxupquote{')
1635 
1636     def depart_literal_strong(self, node: Element) -> None:
1637         self.body.append('}}')
1638 
1639     def visit_abbreviation(self, node: Element) -> None:
1640         abbr = node.astext()
1641         self.body.append(r'\sphinxstyleabbreviation{')
1642         # spell out the explanation once
1643         if node.hasattr('explanation') and abbr not in self.handled_abbrs:
1644             self.context.append('} (%s)' % self.encode(node['explanation']))
1645             self.handled_abbrs.add(abbr)
1646         else:
1647             self.context.append('}')
1648 
1649     def depart_abbreviation(self, node: Element) -> None:
1650         self.body.append(self.context.pop())
1651 
1652     def visit_manpage(self, node: Element) -> None:
1653         return self.visit_literal_emphasis(node)
1654 
1655     def depart_manpage(self, node: Element) -> None:
1656         return self.depart_literal_emphasis(node)
1657 
1658     def visit_title_reference(self, node: Element) -> None:
1659         self.body.append(r'\sphinxtitleref{')
1660 
1661     def depart_title_reference(self, node: Element) -> None:
1662         self.body.append('}')
1663 
1664     def visit_thebibliography(self, node: Element) -> None:
1665         citations = cast(Iterable[nodes.citation], node)
1666         labels = (cast(nodes.label, citation[0]) for citation in citations)
1667         longest_label = max((label.astext() for label in labels), key=len)
1668         if len(longest_label) > MAX_CITATION_LABEL_LENGTH:
1669             # adjust max width of citation labels not to break the layout
1670             longest_label = longest_label[:MAX_CITATION_LABEL_LENGTH]
1671 
1672         self.body.append(CR + r'\begin{sphinxthebibliography}{%s}' %
1673                          self.encode(longest_label) + CR)
1674 
1675     def depart_thebibliography(self, node: Element) -> None:
1676         self.body.append(r'\end{sphinxthebibliography}' + CR)
1677 
1678     def visit_citation(self, node: Element) -> None:
1679         label = cast(nodes.label, node[0])
1680         self.body.append(r'\bibitem[%s]{%s:%s}' % (self.encode(label.astext()),
1681                                                    node['docname'], node['ids'][0]))
1682 
1683     def depart_citation(self, node: Element) -> None:
1684         pass
1685 
1686     def visit_citation_reference(self, node: Element) -> None:
1687         if self.in_title:
1688             pass
1689         else:
1690             self.body.append(r'\sphinxcite{%s:%s}' % (node['docname'], node['refname']))
1691             raise nodes.SkipNode
1692 
1693     def depart_citation_reference(self, node: Element) -> None:
1694         pass
1695 
1696     def visit_literal(self, node: Element) -> None:
1697         if self.in_title:
1698             self.body.append(r'\sphinxstyleliteralintitle{\sphinxupquote{')
1699         elif 'kbd' in node['classes']:
1700             self.body.append(r'\sphinxkeyboard{\sphinxupquote{')
1701         else:
1702             self.body.append(r'\sphinxcode{\sphinxupquote{')
1703 
1704     def depart_literal(self, node: Element) -> None:
1705         self.body.append('}}')
1706 
1707     def visit_footnote_reference(self, node: Element) -> None:
1708         raise nodes.SkipNode
1709 
1710     def visit_footnotemark(self, node: Element) -> None:
1711         self.body.append(r'\sphinxfootnotemark[')
1712 
1713     def depart_footnotemark(self, node: Element) -> None:
1714         self.body.append(']')
1715 
1716     def visit_footnotetext(self, node: Element) -> None:
1717         label = cast(nodes.label, node[0])
1718         self.body.append('%' + CR)
1719         self.body.append(r'\begin{footnotetext}[%s]'
1720                          r'\phantomsection\label{\thesphinxscope.%s}%%'
1721                          % (label.astext(), label.astext()) + CR)
1722         self.body.append(r'\sphinxAtStartFootnote' + CR)
1723 
1724     def depart_footnotetext(self, node: Element) -> None:
1725         # the \ignorespaces in particular for after table header use
1726         self.body.append('%' + CR)
1727         self.body.append(r'\end{footnotetext}\ignorespaces ')
1728 
1729     def visit_captioned_literal_block(self, node: Element) -> None:
1730         pass
1731 
1732     def depart_captioned_literal_block(self, node: Element) -> None:
1733         pass
1734 
1735     def visit_literal_block(self, node: Element) -> None:
1736         if node.rawsource != node.astext():
1737             # most probably a parsed-literal block -- don't highlight
1738             self.in_parsed_literal += 1
1739             self.body.append(r'\begin{sphinxalltt}' + CR)
1740         else:
1741             labels = self.hypertarget_to(node)
1742             if isinstance(node.parent, captioned_literal_block):
1743                 labels += self.hypertarget_to(node.parent)
1744             if labels and not self.in_footnote:
1745                 self.body.append(CR + r'\def\sphinxLiteralBlockLabel{' + labels + '}')
1746 
1747             lang = node.get('language', 'default')
1748             linenos = node.get('linenos', False)
1749             highlight_args = node.get('highlight_args', {})
1750             highlight_args['force'] = node.get('force', False)
1751             opts = self.config.highlight_options.get(lang, {})
1752 
1753             hlcode = self.highlighter.highlight_block(
1754                 node.rawsource, lang, opts=opts, linenos=linenos,
1755                 location=node, **highlight_args
1756             )
1757             if self.in_footnote:
1758                 self.body.append(CR + r'\sphinxSetupCodeBlockInFootnote')
1759                 hlcode = hlcode.replace(r'\begin{Verbatim}',
1760                                         r'\begin{sphinxVerbatim}')
1761             # if in table raise verbatim flag to avoid "tabulary" environment
1762             # and opt for sphinxVerbatimintable to handle caption & long lines
1763             elif self.table:
1764                 self.table.has_problematic = True
1765                 self.table.has_verbatim = True
1766                 hlcode = hlcode.replace(r'\begin{Verbatim}',
1767                                         r'\begin{sphinxVerbatimintable}')
1768             else:
1769                 hlcode = hlcode.replace(r'\begin{Verbatim}',
1770                                         r'\begin{sphinxVerbatim}')
1771             # get consistent trailer
1772             hlcode = hlcode.rstrip()[:-14]  # strip \end{Verbatim}
1773             if self.table and not self.in_footnote:
1774                 hlcode += r'\end{sphinxVerbatimintable}'
1775             else:
1776                 hlcode += r'\end{sphinxVerbatim}'
1777 
1778             hllines = str(highlight_args.get('hl_lines', []))[1:-1]
1779             if hllines:
1780                 self.body.append(CR + r'\fvset{hllines={, %s,}}%%' % hllines)
1781             self.body.append(CR + hlcode + CR)
1782             if hllines:
1783                 self.body.append(r'\sphinxresetverbatimhllines' + CR)
1784             raise nodes.SkipNode
1785 
1786     def depart_literal_block(self, node: Element) -> None:
1787         self.body.append(CR + r'\end{sphinxalltt}' + CR)
1788         self.in_parsed_literal -= 1
1789     visit_doctest_block = visit_literal_block
1790     depart_doctest_block = depart_literal_block
1791 
1792     def visit_line(self, node: Element) -> None:
1793         self.body.append(r'\item[] ')
1794 
1795     def depart_line(self, node: Element) -> None:
1796         self.body.append(CR)
1797 
1798     def visit_line_block(self, node: Element) -> None:
1799         if isinstance(node.parent, nodes.line_block):
1800             self.body.append(r'\item[]' + CR)
1801             self.body.append(r'\begin{DUlineblock}{\DUlineblockindent}' + CR)
1802         else:
1803             self.body.append(CR + r'\begin{DUlineblock}{0em}' + CR)
1804         if self.table:
1805             self.table.has_problematic = True
1806 
1807     def depart_line_block(self, node: Element) -> None:
1808         self.body.append(r'\end{DUlineblock}' + CR)
1809 
1810     def visit_block_quote(self, node: Element) -> None:
1811         # If the block quote contains a single object and that object
1812         # is a list, then generate a list not a block quote.
1813         # This lets us indent lists.
1814         done = 0
1815         if len(node.children) == 1:
1816             child = node.children[0]
1817             if isinstance(child, nodes.bullet_list) or \
1818                     isinstance(child, nodes.enumerated_list):
1819                 done = 1
1820         if not done:
1821             self.body.append(r'\begin{quote}' + CR)
1822             if self.table:
1823                 self.table.has_problematic = True
1824 
1825     def depart_block_quote(self, node: Element) -> None:
1826         done = 0
1827         if len(node.children) == 1:
1828             child = node.children[0]
1829             if isinstance(child, nodes.bullet_list) or \
1830                     isinstance(child, nodes.enumerated_list):
1831                 done = 1
1832         if not done:
1833             self.body.append(r'\end{quote}' + CR)
1834 
1835     # option node handling copied from docutils' latex writer
1836 
1837     def visit_option(self, node: Element) -> None:
1838         if self.context[-1]:
1839             # this is not the first option
1840             self.body.append(', ')
1841 
1842     def depart_option(self, node: Element) -> None:
1843         # flag that the first option is done.
1844         self.context[-1] += 1
1845 
1846     def visit_option_argument(self, node: Element) -> None:
1847         """The delimiter between an option and its argument."""
1848         self.body.append(node.get('delimiter', ' '))
1849 
1850     def depart_option_argument(self, node: Element) -> None:
1851         pass
1852 
1853     def visit_option_group(self, node: Element) -> None:
1854         self.body.append(r'\item [')
1855         # flag for first option
1856         self.context.append(0)
1857 
1858     def depart_option_group(self, node: Element) -> None:
1859         self.context.pop()  # the flag
1860         self.body.append('] ')
1861 
1862     def visit_option_list(self, node: Element) -> None:
1863         self.body.append(r'\begin{optionlist}{3cm}' + CR)
1864         if self.table:
1865             self.table.has_problematic = True
1866 
1867     def depart_option_list(self, node: Element) -> None:
1868         self.body.append(r'\end{optionlist}' + CR)
1869 
1870     def visit_option_list_item(self, node: Element) -> None:
1871         pass
1872 
1873     def depart_option_list_item(self, node: Element) -> None:
1874         pass
1875 
1876     def visit_option_string(self, node: Element) -> None:
1877         ostring = node.astext()
1878         self.body.append(self.encode(ostring))
1879         raise nodes.SkipNode
1880 
1881     def visit_description(self, node: Element) -> None:
1882         self.body.append(' ')
1883 
1884     def depart_description(self, node: Element) -> None:
1885         pass
1886 
1887     def visit_superscript(self, node: Element) -> None:
1888         self.body.append(r'$^{\text{')
1889 
1890     def depart_superscript(self, node: Element) -> None:
1891         self.body.append('}}$')
1892 
1893     def visit_subscript(self, node: Element) -> None:
1894         self.body.append(r'$_{\text{')
1895 
1896     def depart_subscript(self, node: Element) -> None:
1897         self.body.append('}}$')
1898 
1899     def visit_inline(self, node: Element) -> None:
1900         classes = node.get('classes', [])
1901         if classes in [['menuselection']]:
1902             self.body.append(r'\sphinxmenuselection{')
1903             self.context.append('}')
1904         elif classes in [['guilabel']]:
1905             self.body.append(r'\sphinxguilabel{')
1906             self.context.append('}')
1907         elif classes in [['accelerator']]:
1908             self.body.append(r'\sphinxaccelerator{')
1909             self.context.append('}')
1910         elif classes and not self.in_title:
1911             self.body.append(r'\DUrole{%s}{' % ','.join(classes))
1912             self.context.append('}')
1913         else:
1914             self.context.append('')
1915 
1916     def depart_inline(self, node: Element) -> None:
1917         self.body.append(self.context.pop())
1918 
1919     def visit_generated(self, node: Element) -> None:
1920         pass
1921 
1922     def depart_generated(self, node: Element) -> None:
1923         pass
1924 
1925     def visit_compound(self, node: Element) -> None:
1926         pass
1927 
1928     def depart_compound(self, node: Element) -> None:
1929         pass
1930 
1931     def visit_container(self, node: Element) -> None:
1932         classes = node.get('classes', [])
1933         for c in classes:
1934             self.body.append('\n\\begin{sphinxuseclass}{%s}' % c)
1935 
1936     def depart_container(self, node: Element) -> None:
1937         classes = node.get('classes', [])
1938         for c in classes:
1939             self.body.append('\n\\end{sphinxuseclass}')
1940 
1941     def visit_decoration(self, node: Element) -> None:
1942         pass
1943 
1944     def depart_decoration(self, node: Element) -> None:
1945         pass
1946 
1947     # docutils-generated elements that we don't support
1948 
1949     def visit_header(self, node: Element) -> None:
1950         raise nodes.SkipNode
1951 
1952     def visit_footer(self, node: Element) -> None:
1953         raise nodes.SkipNode
1954 
1955     def visit_docinfo(self, node: Element) -> None:
1956         raise nodes.SkipNode
1957 
1958     # text handling
1959 
1960     def encode(self, text: str) -> str:
1961         text = self.escape(text)
1962         if self.literal_whitespace:
1963             # Insert a blank before the newline, to avoid
1964             # ! LaTeX Error: There's no line here to end.
1965             text = text.replace(CR, r'~\\' + CR).replace(' ', '~')
1966         return text
1967 
1968     def encode_uri(self, text: str) -> str:
1969         # TODO: it is probably wrong that this uses texescape.escape()
1970         #       this must be checked against hyperref package exact dealings
1971         #       mainly, %, #, {, } and \ need escaping via a \ escape
1972         # in \href, the tilde is allowed and must be represented literally
1973         return self.encode(text).replace(r'\textasciitilde{}', '~').\
1974             replace(r'\sphinxhyphen{}', '-').\
1975             replace(r'\textquotesingle{}', "'")
1976 
1977     def visit_Text(self, node: Text) -> None:
1978         text = self.encode(node.astext())
1979         self.body.append(text)
1980 
1981     def depart_Text(self, node: Text) -> None:
1982         pass
1983 
1984     def visit_comment(self, node: Element) -> None:
1985         raise nodes.SkipNode
1986 
1987     def visit_meta(self, node: Element) -> None:
1988         # only valid for HTML
1989         raise nodes.SkipNode
1990 
1991     def visit_system_message(self, node: Element) -> None:
1992         pass
1993 
1994     def depart_system_message(self, node: Element) -> None:
1995         self.body.append(CR)
1996 
1997     def visit_math(self, node: Element) -> None:
1998         if self.in_title:
1999             self.body.append(r'\protect\(%s\protect\)' % node.astext())
2000         else:
2001             self.body.append(r'\(%s\)' % node.astext())
2002         raise nodes.SkipNode
2003 
2004     def visit_math_block(self, node: Element) -> None:
2005         if node.get('label'):
2006             label = "equation:%s:%s" % (node['docname'], node['label'])
2007         else:
2008             label = None
2009 
2010         if node.get('nowrap'):
2011             if label:
2012                 self.body.append(r'\label{%s}' % label)
2013             self.body.append(node.astext())
2014         else:
2015             from sphinx.util.math import wrap_displaymath
2016             self.body.append(wrap_displaymath(node.astext(), label,
2017                                               self.config.math_number_all))
2018         raise nodes.SkipNode
2019 
2020     def visit_math_reference(self, node: Element) -> None:
2021         label = "equation:%s:%s" % (node['docname'], node['target'])
2022         eqref_format = self.config.math_eqref_format
2023         if eqref_format:
2024             try:
2025                 ref = r'\ref{%s}' % label
2026                 self.body.append(eqref_format.format(number=ref))
2027             except KeyError as exc:
2028                 logger.warning(__('Invalid math_eqref_format: %r'), exc,
2029                                location=node)
2030                 self.body.append(r'\eqref{%s}' % label)
2031         else:
2032             self.body.append(r'\eqref{%s}' % label)
2033 
2034     def depart_math_reference(self, node: Element) -> None:
2035         pass
2036 
2037     def unknown_visit(self, node: Node) -> None:
2038         raise NotImplementedError('Unknown node: ' + node.__class__.__name__)
2039 
2040     @property
2041     def docclasses(self) -> Tuple[str, str]:
2042         """Prepends prefix to sphinx document classes"""
2043         warnings.warn('LaTeXWriter.docclasses() is deprecated.',
2044                       RemovedInSphinx70Warning, stacklevel=2)
2045         return ('howto', 'manual')
2046 
2047 
2048 # FIXME: Workaround to avoid circular import
2049 # refs: https://github.com/sphinx-doc/sphinx/issues/5433
2050 from sphinx.builders.latex.nodes import ( # NOQA isort:skip
2051     HYPERLINK_SUPPORT_NODES, captioned_literal_block, footnotetext,
2052 )

</code><intended_behavior>This file should include a method or modify an existing method to ensure that glossary terms and similarly formatted items are separated by appropriate LaTeX commands to enforce a newline where expected. The intended behavior is to preserve glossary term separations in such a way that when converted to LaTeX, the output mimics the separation seen in HTML and other formats, without introducing undue vertical whitespace for grouped terms. This could involve checking for glossary term definitions and applying a LaTeX newline command (\ or \par) at the correct places while preserving existing functionality for handling other elements within .rst files. The code should ensure no unintended side effects on the rest of the LaTeX document's formatting.</intended_behavior>, <file>sphinx/domains/std.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2     sphinx.domains.std
3     ~~~~~~~~~~~~~~~~~~
4 
5     The standard domain.
6 
7     :copyright: Copyright 2007-2021 by the Sphinx team, see AUTHORS.
8     :license: BSD, see LICENSE for details.
9 """
10 
11 import re
12 import unicodedata
13 from copy import copy
14 from typing import (TYPE_CHECKING, Any, Callable, Dict, Iterable, Iterator, List, Optional,
15                     Tuple, Type, Union, cast)
16 
17 from docutils import nodes
18 from docutils.nodes import Element, Node, system_message
19 from docutils.parsers.rst import Directive, directives
20 from docutils.statemachine import StringList
21 
22 from sphinx import addnodes
23 from sphinx.addnodes import desc_signature, pending_xref
24 from sphinx.directives import ObjectDescription
25 from sphinx.domains import Domain, ObjType
26 from sphinx.locale import _, __
27 from sphinx.roles import XRefRole
28 from sphinx.util import docname_join, logging, ws_re
29 from sphinx.util.docutils import SphinxDirective
30 from sphinx.util.nodes import clean_astext, make_id, make_refnode
31 from sphinx.util.typing import OptionSpec, RoleFunction
32 
33 if TYPE_CHECKING:
34     from sphinx.application import Sphinx
35     from sphinx.builders import Builder
36     from sphinx.environment import BuildEnvironment
37 
38 logger = logging.getLogger(__name__)
39 
40 
41 # RE for option descriptions
42 option_desc_re = re.compile(r'((?:/|--|-|\+)?[^\s=]+)(=?\s*.*)')
43 # RE for grammar tokens
44 token_re = re.compile(r'`((~?\w*:)?\w+)`', re.U)
45 
46 
47 class GenericObject(ObjectDescription[str]):
48     """
49     A generic x-ref directive registered with Sphinx.add_object_type().
50     """
51     indextemplate: str = ''
52     parse_node: Callable[["GenericObject", "BuildEnvironment", str, desc_signature], str] = None  # NOQA
53 
54     def handle_signature(self, sig: str, signode: desc_signature) -> str:
55         if self.parse_node:
56             name = self.parse_node(self.env, sig, signode)
57         else:
58             signode.clear()
59             signode += addnodes.desc_name(sig, sig)
60             # normalize whitespace like XRefRole does
61             name = ws_re.sub(' ', sig)
62         return name
63 
64     def add_target_and_index(self, name: str, sig: str, signode: desc_signature) -> None:
65         node_id = make_id(self.env, self.state.document, self.objtype, name)
66         signode['ids'].append(node_id)
67 
68         # Assign old styled node_id not to break old hyperlinks (if possible)
69         # Note: Will be removed in Sphinx-5.0 (RemovedInSphinx50Warning)
70         old_node_id = self.make_old_id(name)
71         if old_node_id not in self.state.document.ids and old_node_id not in signode['ids']:
72             signode['ids'].append(old_node_id)
73 
74         self.state.document.note_explicit_target(signode)
75 
76         if self.indextemplate:
77             colon = self.indextemplate.find(':')
78             if colon != -1:
79                 indextype = self.indextemplate[:colon].strip()
80                 indexentry = self.indextemplate[colon + 1:].strip() % (name,)
81             else:
82                 indextype = 'single'
83                 indexentry = self.indextemplate % (name,)
84             self.indexnode['entries'].append((indextype, indexentry, node_id, '', None))
85 
86         std = cast(StandardDomain, self.env.get_domain('std'))
87         std.note_object(self.objtype, name, node_id, location=signode)
88 
89     def make_old_id(self, name: str) -> str:
90         """Generate old styled node_id for generic objects.
91 
92         .. note:: Old Styled node_id was used until Sphinx-3.0.
93                   This will be removed in Sphinx-5.0.
94         """
95         return self.objtype + '-' + name
96 
97 
98 class EnvVar(GenericObject):
99     indextemplate = _('environment variable; %s')
100 
101 
102 class EnvVarXRefRole(XRefRole):
103     """
104     Cross-referencing role for environment variables (adds an index entry).
105     """
106 
107     def result_nodes(self, document: nodes.document, env: "BuildEnvironment", node: Element,
108                      is_ref: bool) -> Tuple[List[Node], List[system_message]]:
109         if not is_ref:
110             return [node], []
111         varname = node['reftarget']
112         tgtid = 'index-%s' % env.new_serialno('index')
113         indexnode = addnodes.index()
114         indexnode['entries'] = [
115             ('single', varname, tgtid, '', None),
116             ('single', _('environment variable; %s') % varname, tgtid, '', None)
117         ]
118         targetnode = nodes.target('', '', ids=[tgtid])
119         document.note_explicit_target(targetnode)
120         return [indexnode, targetnode, node], []
121 
122 
123 class Target(SphinxDirective):
124     """
125     Generic target for user-defined cross-reference types.
126     """
127     indextemplate = ''
128 
129     has_content = False
130     required_arguments = 1
131     optional_arguments = 0
132     final_argument_whitespace = True
133     option_spec: OptionSpec = {}
134 
135     def run(self) -> List[Node]:
136         # normalize whitespace in fullname like XRefRole does
137         fullname = ws_re.sub(' ', self.arguments[0].strip())
138         node_id = make_id(self.env, self.state.document, self.name, fullname)
139         node = nodes.target('', '', ids=[node_id])
140         self.set_source_info(node)
141 
142         # Assign old styled node_id not to break old hyperlinks (if possible)
143         # Note: Will be removed in Sphinx-5.0 (RemovedInSphinx50Warning)
144         old_node_id = self.make_old_id(fullname)
145         if old_node_id not in self.state.document.ids and old_node_id not in node['ids']:
146             node['ids'].append(old_node_id)
147 
148         self.state.document.note_explicit_target(node)
149         ret: List[Node] = [node]
150         if self.indextemplate:
151             indexentry = self.indextemplate % (fullname,)
152             indextype = 'single'
153             colon = indexentry.find(':')
154             if colon != -1:
155                 indextype = indexentry[:colon].strip()
156                 indexentry = indexentry[colon + 1:].strip()
157             inode = addnodes.index(entries=[(indextype, indexentry, node_id, '', None)])
158             ret.insert(0, inode)
159         name = self.name
160         if ':' in self.name:
161             _, name = self.name.split(':', 1)
162 
163         std = cast(StandardDomain, self.env.get_domain('std'))
164         std.note_object(name, fullname, node_id, location=node)
165 
166         return ret
167 
168     def make_old_id(self, name: str) -> str:
169         """Generate old styled node_id for targets.
170 
171         .. note:: Old Styled node_id was used until Sphinx-3.0.
172                   This will be removed in Sphinx-5.0.
173         """
174         return self.name + '-' + name
175 
176 
177 class Cmdoption(ObjectDescription[str]):
178     """
179     Description of a command-line option (.. option).
180     """
181 
182     def handle_signature(self, sig: str, signode: desc_signature) -> str:
183         """Transform an option description into RST nodes."""
184         count = 0
185         firstname = ''
186         for potential_option in sig.split(', '):
187             potential_option = potential_option.strip()
188             m = option_desc_re.match(potential_option)
189             if not m:
190                 logger.warning(__('Malformed option description %r, should '
191                                   'look like "opt", "-opt args", "--opt args", '
192                                   '"/opt args" or "+opt args"'), potential_option,
193                                location=signode)
194                 continue
195             optname, args = m.groups()
196             if optname.endswith('[') and args.endswith(']'):
197                 # optional value surrounded by brackets (ex. foo[=bar])
198                 optname = optname[:-1]
199                 args = '[' + args
200 
201             if count:
202                 signode += addnodes.desc_addname(', ', ', ')
203             signode += addnodes.desc_name(optname, optname)
204             signode += addnodes.desc_addname(args, args)
205             if not count:
206                 firstname = optname
207                 signode['allnames'] = [optname]
208             else:
209                 signode['allnames'].append(optname)
210             count += 1
211         if not firstname:
212             raise ValueError
213         return firstname
214 
215     def add_target_and_index(self, firstname: str, sig: str, signode: desc_signature) -> None:
216         currprogram = self.env.ref_context.get('std:program')
217         for optname in signode.get('allnames', []):
218             prefixes = ['cmdoption']
219             if currprogram:
220                 prefixes.append(currprogram)
221             if not optname.startswith(('-', '/')):
222                 prefixes.append('arg')
223             prefix = '-'.join(prefixes)
224             node_id = make_id(self.env, self.state.document, prefix, optname)
225             signode['ids'].append(node_id)
226 
227             old_node_id = self.make_old_id(prefix, optname)
228             if old_node_id not in self.state.document.ids and \
229                old_node_id not in signode['ids']:
230                 signode['ids'].append(old_node_id)
231 
232         self.state.document.note_explicit_target(signode)
233 
234         domain = cast(StandardDomain, self.env.get_domain('std'))
235         for optname in signode.get('allnames', []):
236             domain.add_program_option(currprogram, optname,
237                                       self.env.docname, signode['ids'][0])
238 
239         # create an index entry
240         if currprogram:
241             descr = _('%s command line option') % currprogram
242         else:
243             descr = _('command line option')
244         for option in sig.split(', '):
245             entry = '; '.join([descr, option])
246             self.indexnode['entries'].append(('pair', entry, signode['ids'][0], '', None))
247 
248     def make_old_id(self, prefix: str, optname: str) -> str:
249         """Generate old styled node_id for cmdoption.
250 
251         .. note:: Old Styled node_id was used until Sphinx-3.0.
252                   This will be removed in Sphinx-5.0.
253         """
254         return nodes.make_id(prefix + '-' + optname)
255 
256 
257 class Program(SphinxDirective):
258     """
259     Directive to name the program for which options are documented.
260     """
261 
262     has_content = False
263     required_arguments = 1
264     optional_arguments = 0
265     final_argument_whitespace = True
266     option_spec: OptionSpec = {}
267 
268     def run(self) -> List[Node]:
269         program = ws_re.sub('-', self.arguments[0].strip())
270         if program == 'None':
271             self.env.ref_context.pop('std:program', None)
272         else:
273             self.env.ref_context['std:program'] = program
274         return []
275 
276 
277 class OptionXRefRole(XRefRole):
278     def process_link(self, env: "BuildEnvironment", refnode: Element, has_explicit_title: bool,
279                      title: str, target: str) -> Tuple[str, str]:
280         refnode['std:program'] = env.ref_context.get('std:program')
281         return title, target
282 
283 
284 def split_term_classifiers(line: str) -> List[Optional[str]]:
285     # split line into a term and classifiers. if no classifier, None is used..
286     parts: List[Optional[str]] = re.split(' +: +', line) + [None]
287     return parts
288 
289 
290 def make_glossary_term(env: "BuildEnvironment", textnodes: Iterable[Node], index_key: str,
291                        source: str, lineno: int, node_id: str, document: nodes.document
292                        ) -> nodes.term:
293     # get a text-only representation of the term and register it
294     # as a cross-reference target
295     term = nodes.term('', '', *textnodes)
296     term.source = source
297     term.line = lineno
298     termtext = term.astext()
299 
300     if node_id:
301         # node_id is given from outside (mainly i18n module), use it forcedly
302         term['ids'].append(node_id)
303     else:
304         node_id = make_id(env, document, 'term', termtext)
305         term['ids'].append(node_id)
306         document.note_explicit_target(term)
307 
308     std = cast(StandardDomain, env.get_domain('std'))
309     std._note_term(termtext, node_id, location=term)
310 
311     # add an index entry too
312     indexnode = addnodes.index()
313     indexnode['entries'] = [('single', termtext, node_id, 'main', index_key)]
314     indexnode.source, indexnode.line = term.source, term.line
315     term.append(indexnode)
316 
317     return term
318 
319 
320 class Glossary(SphinxDirective):
321     """
322     Directive to create a glossary with cross-reference targets for :term:
323     roles.
324     """
325 
326     has_content = True
327     required_arguments = 0
328     optional_arguments = 0
329     final_argument_whitespace = False
330     option_spec: OptionSpec = {
331         'sorted': directives.flag,
332     }
333 
334     def run(self) -> List[Node]:
335         node = addnodes.glossary()
336         node.document = self.state.document
337 
338         # This directive implements a custom format of the reST definition list
339         # that allows multiple lines of terms before the definition.  This is
340         # easy to parse since we know that the contents of the glossary *must
341         # be* a definition list.
342 
343         # first, collect single entries
344         entries: List[Tuple[List[Tuple[str, str, int]], StringList]] = []
345         in_definition = True
346         in_comment = False
347         was_empty = True
348         messages: List[Node] = []
349         for line, (source, lineno) in zip(self.content, self.content.items):
350             # empty line -> add to last definition
351             if not line:
352                 if in_definition and entries:
353                     entries[-1][1].append('', source, lineno)
354                 was_empty = True
355                 continue
356             # unindented line -> a term
357             if line and not line[0].isspace():
358                 # enable comments
359                 if line.startswith('.. '):
360                     in_comment = True
361                     continue
362                 else:
363                     in_comment = False
364 
365                 # first term of definition
366                 if in_definition:
367                     if not was_empty:
368                         messages.append(self.state.reporter.warning(
369                             _('glossary term must be preceded by empty line'),
370                             source=source, line=lineno))
371                     entries.append(([(line, source, lineno)], StringList()))
372                     in_definition = False
373                 # second term and following
374                 else:
375                     if was_empty:
376                         messages.append(self.state.reporter.warning(
377                             _('glossary terms must not be separated by empty lines'),
378                             source=source, line=lineno))
379                     if entries:
380                         entries[-1][0].append((line, source, lineno))
381                     else:
382                         messages.append(self.state.reporter.warning(
383                             _('glossary seems to be misformatted, check indentation'),
384                             source=source, line=lineno))
385             elif in_comment:
386                 pass
387             else:
388                 if not in_definition:
389                     # first line of definition, determines indentation
390                     in_definition = True
391                     indent_len = len(line) - len(line.lstrip())
392                 if entries:
393                     entries[-1][1].append(line[indent_len:], source, lineno)
394                 else:
395                     messages.append(self.state.reporter.warning(
396                         _('glossary seems to be misformatted, check indentation'),
397                         source=source, line=lineno))
398             was_empty = False
399 
400         # now, parse all the entries into a big definition list
401         items = []
402         for terms, definition in entries:
403             termtexts: List[str] = []
404             termnodes: List[Node] = []
405             system_messages: List[Node] = []
406             for line, source, lineno in terms:
407                 parts = split_term_classifiers(line)
408                 # parse the term with inline markup
409                 # classifiers (parts[1:]) will not be shown on doctree
410                 textnodes, sysmsg = self.state.inline_text(parts[0], lineno)
411 
412                 # use first classifier as a index key
413                 term = make_glossary_term(self.env, textnodes, parts[1], source, lineno,
414                                           node_id=None, document=self.state.document)
415                 term.rawsource = line
416                 system_messages.extend(sysmsg)
417                 termtexts.append(term.astext())
418                 termnodes.append(term)
419 
420             termnodes.extend(system_messages)
421 
422             defnode = nodes.definition()
423             if definition:
424                 self.state.nested_parse(definition, definition.items[0][1],
425                                         defnode)
426             termnodes.append(defnode)
427             items.append((termtexts,
428                           nodes.definition_list_item('', *termnodes)))
429 
430         if 'sorted' in self.options:
431             items.sort(key=lambda x:
432                        unicodedata.normalize('NFD', x[0][0].lower()))
433 
434         dlist = nodes.definition_list()
435         dlist['classes'].append('glossary')
436         dlist.extend(item[1] for item in items)
437         node += dlist
438         return messages + [node]
439 
440 
441 def token_xrefs(text: str, productionGroup: str = '') -> List[Node]:
442     if len(productionGroup) != 0:
443         productionGroup += ':'
444     retnodes: List[Node] = []
445     pos = 0
446     for m in token_re.finditer(text):
447         if m.start() > pos:
448             txt = text[pos:m.start()]
449             retnodes.append(nodes.Text(txt, txt))
450         token = m.group(1)
451         if ':' in token:
452             if token[0] == '~':
453                 _, title = token.split(':')
454                 target = token[1:]
455             elif token[0] == ':':
456                 title = token[1:]
457                 target = title
458             else:
459                 title = token
460                 target = token
461         else:
462             title = token
463             target = productionGroup + token
464         refnode = pending_xref(title, reftype='token', refdomain='std',
465                                reftarget=target)
466         refnode += nodes.literal(token, title, classes=['xref'])
467         retnodes.append(refnode)
468         pos = m.end()
469     if pos < len(text):
470         retnodes.append(nodes.Text(text[pos:], text[pos:]))
471     return retnodes
472 
473 
474 class ProductionList(SphinxDirective):
475     """
476     Directive to list grammar productions.
477     """
478 
479     has_content = False
480     required_arguments = 1
481     optional_arguments = 0
482     final_argument_whitespace = True
483     option_spec: OptionSpec = {}
484 
485     def run(self) -> List[Node]:
486         domain = cast(StandardDomain, self.env.get_domain('std'))
487         node: Element = addnodes.productionlist()
488         self.set_source_info(node)
489         # The backslash handling is from ObjectDescription.get_signatures
490         nl_escape_re = re.compile(r'\\\n')
491         lines = nl_escape_re.sub('', self.arguments[0]).split('\n')
492 
493         productionGroup = ""
494         i = 0
495         for rule in lines:
496             if i == 0 and ':' not in rule:
497                 productionGroup = rule.strip()
498                 continue
499             i += 1
500             try:
501                 name, tokens = rule.split(':', 1)
502             except ValueError:
503                 break
504             subnode = addnodes.production(rule)
505             name = name.strip()
506             subnode['tokenname'] = name
507             if subnode['tokenname']:
508                 prefix = 'grammar-token-%s' % productionGroup
509                 node_id = make_id(self.env, self.state.document, prefix, name)
510                 subnode['ids'].append(node_id)
511 
512                 # Assign old styled node_id not to break old hyperlinks (if possible)
513                 # Note: Will be removed in Sphinx-5.0 (RemovedInSphinx50Warning)
514                 old_node_id = self.make_old_id(name)
515                 if (old_node_id not in self.state.document.ids and
516                         old_node_id not in subnode['ids']):
517                     subnode['ids'].append(old_node_id)
518 
519                 self.state.document.note_implicit_target(subnode, subnode)
520 
521                 if len(productionGroup) != 0:
522                     objName = "%s:%s" % (productionGroup, name)
523                 else:
524                     objName = name
525                 domain.note_object('token', objName, node_id, location=node)
526             subnode.extend(token_xrefs(tokens, productionGroup))
527             node.append(subnode)
528         return [node]
529 
530     def make_old_id(self, token: str) -> str:
531         """Generate old styled node_id for tokens.
532 
533         .. note:: Old Styled node_id was used until Sphinx-3.0.
534                   This will be removed in Sphinx-5.0.
535         """
536         return nodes.make_id('grammar-token-' + token)
537 
538 
539 class TokenXRefRole(XRefRole):
540     def process_link(self, env: "BuildEnvironment", refnode: Element, has_explicit_title: bool,
541                      title: str, target: str) -> Tuple[str, str]:
542         target = target.lstrip('~')  # a title-specific thing
543         if not self.has_explicit_title and title[0] == '~':
544             if ':' in title:
545                 _, title = title.split(':')
546             else:
547                 title = title[1:]
548         return title, target
549 
550 
551 class StandardDomain(Domain):
552     """
553     Domain for all objects that don't fit into another domain or are added
554     via the application interface.
555     """
556 
557     name = 'std'
558     label = 'Default'
559 
560     object_types: Dict[str, ObjType] = {
561         'term': ObjType(_('glossary term'), 'term', searchprio=-1),
562         'token': ObjType(_('grammar token'), 'token', searchprio=-1),
563         'label': ObjType(_('reference label'), 'ref', 'keyword',
564                          searchprio=-1),
565         'envvar': ObjType(_('environment variable'), 'envvar'),
566         'cmdoption': ObjType(_('program option'), 'option'),
567         'doc': ObjType(_('document'), 'doc', searchprio=-1)
568     }
569 
570     directives: Dict[str, Type[Directive]] = {
571         'program': Program,
572         'cmdoption': Cmdoption,  # old name for backwards compatibility
573         'option': Cmdoption,
574         'envvar': EnvVar,
575         'glossary': Glossary,
576         'productionlist': ProductionList,
577     }
578     roles: Dict[str, Union[RoleFunction, XRefRole]] = {
579         'option':  OptionXRefRole(warn_dangling=True),
580         'envvar':  EnvVarXRefRole(),
581         # links to tokens in grammar productions
582         'token':   TokenXRefRole(),
583         # links to terms in glossary
584         'term':    XRefRole(innernodeclass=nodes.inline,
585                             warn_dangling=True),
586         # links to headings or arbitrary labels
587         'ref':     XRefRole(lowercase=True, innernodeclass=nodes.inline,
588                             warn_dangling=True),
589         # links to labels of numbered figures, tables and code-blocks
590         'numref':  XRefRole(lowercase=True,
591                             warn_dangling=True),
592         # links to labels, without a different title
593         'keyword': XRefRole(warn_dangling=True),
594         # links to documents
595         'doc':     XRefRole(warn_dangling=True, innernodeclass=nodes.inline),
596     }
597 
598     initial_data = {
599         'progoptions': {},      # (program, name) -> docname, labelid
600         'objects': {},          # (type, name) -> docname, labelid
601         'labels': {             # labelname -> docname, labelid, sectionname
602             'genindex': ('genindex', '', _('Index')),
603             'modindex': ('py-modindex', '', _('Module Index')),
604             'search':   ('search', '', _('Search Page')),
605         },
606         'anonlabels': {         # labelname -> docname, labelid
607             'genindex': ('genindex', ''),
608             'modindex': ('py-modindex', ''),
609             'search':   ('search', ''),
610         },
611     }
612 
613     dangling_warnings = {
614         'term': 'term not in glossary: %(target)s',
615         'numref':  'undefined label: %(target)s',
616         'keyword': 'unknown keyword: %(target)s',
617         'doc': 'unknown document: %(target)s',
618         'option': 'unknown option: %(target)s',
619     }
620 
621     # node_class -> (figtype, title_getter)
622     enumerable_nodes: Dict[Type[Node], Tuple[str, Optional[Callable]]] = {
623         nodes.figure: ('figure', None),
624         nodes.table: ('table', None),
625         nodes.container: ('code-block', None),
626     }
627 
628     def __init__(self, env: "BuildEnvironment") -> None:
629         super().__init__(env)
630 
631         # set up enumerable nodes
632         self.enumerable_nodes = copy(self.enumerable_nodes)  # create a copy for this instance
633         for node, settings in env.app.registry.enumerable_nodes.items():
634             self.enumerable_nodes[node] = settings
635 
636     def note_hyperlink_target(self, name: str, docname: str, node_id: str,
637                               title: str = '') -> None:
638         """Add a hyperlink target for cross reference.
639 
640         .. warning::
641 
642            This is only for internal use.  Please don't use this from your extension.
643            ``document.note_explicit_target()`` or ``note_implicit_target()`` are recommended to
644            add a hyperlink target to the document.
645 
646            This only adds a hyperlink target to the StandardDomain.  And this does not add a
647            node_id to node.  Therefore, it is very fragile to calling this without
648            understanding hyperlink target framework in both docutils and Sphinx.
649 
650         .. versionadded:: 3.0
651         """
652         if name in self.anonlabels and self.anonlabels[name] != (docname, node_id):
653             logger.warning(__('duplicate label %s, other instance in %s'),
654                            name, self.env.doc2path(self.anonlabels[name][0]))
655 
656         self.anonlabels[name] = (docname, node_id)
657         if title:
658             self.labels[name] = (docname, node_id, title)
659 
660     @property
661     def objects(self) -> Dict[Tuple[str, str], Tuple[str, str]]:
662         return self.data.setdefault('objects', {})  # (objtype, name) -> docname, labelid
663 
664     def note_object(self, objtype: str, name: str, labelid: str, location: Any = None
665                     ) -> None:
666         """Note a generic object for cross reference.
667 
668         .. versionadded:: 3.0
669         """
670         if (objtype, name) in self.objects:
671             docname = self.objects[objtype, name][0]
672             logger.warning(__('duplicate %s description of %s, other instance in %s'),
673                            objtype, name, docname, location=location)
674         self.objects[objtype, name] = (self.env.docname, labelid)
675 
676     @property
677     def _terms(self) -> Dict[str, Tuple[str, str]]:
678         """.. note:: Will be removed soon. internal use only."""
679         return self.data.setdefault('terms', {})  # (name) -> docname, labelid
680 
681     def _note_term(self, term: str, labelid: str, location: Any = None) -> None:
682         """Note a term for cross reference.
683 
684         .. note:: Will be removed soon. internal use only.
685         """
686         self.note_object('term', term, labelid, location)
687 
688         self._terms[term.lower()] = (self.env.docname, labelid)
689 
690     @property
691     def progoptions(self) -> Dict[Tuple[str, str], Tuple[str, str]]:
692         return self.data.setdefault('progoptions', {})  # (program, name) -> docname, labelid
693 
694     @property
695     def labels(self) -> Dict[str, Tuple[str, str, str]]:
696         return self.data.setdefault('labels', {})  # labelname -> docname, labelid, sectionname
697 
698     @property
699     def anonlabels(self) -> Dict[str, Tuple[str, str]]:
700         return self.data.setdefault('anonlabels', {})  # labelname -> docname, labelid
701 
702     def clear_doc(self, docname: str) -> None:
703         key: Any = None
704         for key, (fn, _l) in list(self.progoptions.items()):
705             if fn == docname:
706                 del self.progoptions[key]
707         for key, (fn, _l) in list(self.objects.items()):
708             if fn == docname:
709                 del self.objects[key]
710         for key, (fn, _l) in list(self._terms.items()):
711             if fn == docname:
712                 del self._terms[key]
713         for key, (fn, _l, _l) in list(self.labels.items()):
714             if fn == docname:
715                 del self.labels[key]
716         for key, (fn, _l) in list(self.anonlabels.items()):
717             if fn == docname:
718                 del self.anonlabels[key]
719 
720     def merge_domaindata(self, docnames: List[str], otherdata: Dict) -> None:
721         # XXX duplicates?
722         for key, data in otherdata['progoptions'].items():
723             if data[0] in docnames:
724                 self.progoptions[key] = data
725         for key, data in otherdata['objects'].items():
726             if data[0] in docnames:
727                 self.objects[key] = data
728         for key, data in otherdata['terms'].items():
729             if data[0] in docnames:
730                 self._terms[key] = data
731         for key, data in otherdata['labels'].items():
732             if data[0] in docnames:
733                 self.labels[key] = data
734         for key, data in otherdata['anonlabels'].items():
735             if data[0] in docnames:
736                 self.anonlabels[key] = data
737 
738     def process_doc(self, env: "BuildEnvironment", docname: str, document: nodes.document) -> None:  # NOQA
739         for name, explicit in document.nametypes.items():
740             if not explicit:
741                 continue
742             labelid = document.nameids[name]
743             if labelid is None:
744                 continue
745             node = document.ids[labelid]
746             if isinstance(node, nodes.target) and 'refid' in node:
747                 # indirect hyperlink targets
748                 node = document.ids.get(node['refid'])
749                 labelid = node['names'][0]
750             if (node.tagname == 'footnote' or
751                     'refuri' in node or
752                     node.tagname.startswith('desc_')):
753                 # ignore footnote labels, labels automatically generated from a
754                 # link and object descriptions
755                 continue
756             if name in self.labels:
757                 logger.warning(__('duplicate label %s, other instance in %s'),
758                                name, env.doc2path(self.labels[name][0]),
759                                location=node)
760             self.anonlabels[name] = docname, labelid
761             if node.tagname == 'section':
762                 title = cast(nodes.title, node[0])
763                 sectname = clean_astext(title)
764             elif node.tagname == 'rubric':
765                 sectname = clean_astext(node)
766             elif node.tagname == 'target' and len(node) > 0:
767                 # inline target (ex: blah _`blah` blah)
768                 sectname = clean_astext(node)
769             elif self.is_enumerable_node(node):
770                 sectname = self.get_numfig_title(node)
771             else:
772                 toctree = next(iter(node.traverse(addnodes.toctree)), None)
773                 if toctree and toctree.get('caption'):
774                     sectname = toctree.get('caption')
775                 else:
776                     # anonymous-only labels
777                     continue
778             if sectname:
779                 self.labels[name] = docname, labelid, sectname
780 
781     def add_program_option(self, program: str, name: str, docname: str, labelid: str) -> None:
782         self.progoptions[program, name] = (docname, labelid)
783 
784     def build_reference_node(self, fromdocname: str, builder: "Builder", docname: str,
785                              labelid: str, sectname: str, rolename: str, **options: Any
786                              ) -> Element:
787         nodeclass = options.pop('nodeclass', nodes.reference)
788         newnode = nodeclass('', '', internal=True, **options)
789         innernode = nodes.inline(sectname, sectname)
790         if innernode.get('classes') is not None:
791             innernode['classes'].append('std')
792             innernode['classes'].append('std-' + rolename)
793         if docname == fromdocname:
794             newnode['refid'] = labelid
795         else:
796             # set more info in contnode; in case the
797             # get_relative_uri call raises NoUri,
798             # the builder will then have to resolve these
799             contnode = pending_xref('')
800             contnode['refdocname'] = docname
801             contnode['refsectname'] = sectname
802             newnode['refuri'] = builder.get_relative_uri(
803                 fromdocname, docname)
804             if labelid:
805                 newnode['refuri'] += '#' + labelid
806         newnode.append(innernode)
807         return newnode
808 
809     def resolve_xref(self, env: "BuildEnvironment", fromdocname: str, builder: "Builder",
810                      typ: str, target: str, node: pending_xref, contnode: Element
811                      ) -> Optional[Element]:
812         if typ == 'ref':
813             resolver = self._resolve_ref_xref
814         elif typ == 'numref':
815             resolver = self._resolve_numref_xref
816         elif typ == 'keyword':
817             resolver = self._resolve_keyword_xref
818         elif typ == 'doc':
819             resolver = self._resolve_doc_xref
820         elif typ == 'option':
821             resolver = self._resolve_option_xref
822         elif typ == 'term':
823             resolver = self._resolve_term_xref
824         else:
825             resolver = self._resolve_obj_xref
826 
827         return resolver(env, fromdocname, builder, typ, target, node, contnode)
828 
829     def _resolve_ref_xref(self, env: "BuildEnvironment", fromdocname: str,
830                           builder: "Builder", typ: str, target: str, node: pending_xref,
831                           contnode: Element) -> Optional[Element]:
832         if node['refexplicit']:
833             # reference to anonymous label; the reference uses
834             # the supplied link caption
835             docname, labelid = self.anonlabels.get(target, ('', ''))
836             sectname = node.astext()
837         else:
838             # reference to named label; the final node will
839             # contain the section name after the label
840             docname, labelid, sectname = self.labels.get(target, ('', '', ''))
841         if not docname:
842             return None
843 
844         return self.build_reference_node(fromdocname, builder,
845                                          docname, labelid, sectname, 'ref')
846 
847     def _resolve_numref_xref(self, env: "BuildEnvironment", fromdocname: str,
848                              builder: "Builder", typ: str, target: str,
849                              node: pending_xref, contnode: Element) -> Optional[Element]:
850         if target in self.labels:
851             docname, labelid, figname = self.labels.get(target, ('', '', ''))
852         else:
853             docname, labelid = self.anonlabels.get(target, ('', ''))
854             figname = None
855 
856         if not docname:
857             return None
858 
859         target_node = env.get_doctree(docname).ids.get(labelid)
860         figtype = self.get_enumerable_node_type(target_node)
861         if figtype is None:
862             return None
863 
864         if figtype != 'section' and env.config.numfig is False:
865             logger.warning(__('numfig is disabled. :numref: is ignored.'), location=node)
866             return contnode
867 
868         try:
869             fignumber = self.get_fignumber(env, builder, figtype, docname, target_node)
870             if fignumber is None:
871                 return contnode
872         except ValueError:
873             logger.warning(__("Failed to create a cross reference. Any number is not "
874                               "assigned: %s"),
875                            labelid, location=node)
876             return contnode
877 
878         try:
879             if node['refexplicit']:
880                 title = contnode.astext()
881             else:
882                 title = env.config.numfig_format.get(figtype, '')
883 
884             if figname is None and '{name}' in title:
885                 logger.warning(__('the link has no caption: %s'), title, location=node)
886                 return contnode
887             else:
888                 fignum = '.'.join(map(str, fignumber))
889                 if '{name}' in title or 'number' in title:
890                     # new style format (cf. "Fig.{number}")
891                     if figname:
892                         newtitle = title.format(name=figname, number=fignum)
893                     else:
894                         newtitle = title.format(number=fignum)
895                 else:
896                     # old style format (cf. "Fig.%s")
897                     newtitle = title % fignum
898         except KeyError as exc:
899             logger.warning(__('invalid numfig_format: %s (%r)'), title, exc, location=node)
900             return contnode
901         except TypeError:
902             logger.warning(__('invalid numfig_format: %s'), title, location=node)
903             return contnode
904 
905         return self.build_reference_node(fromdocname, builder,
906                                          docname, labelid, newtitle, 'numref',
907                                          nodeclass=addnodes.number_reference,
908                                          title=title)
909 
910     def _resolve_keyword_xref(self, env: "BuildEnvironment", fromdocname: str,
911                               builder: "Builder", typ: str, target: str,
912                               node: pending_xref, contnode: Element) -> Optional[Element]:
913         # keywords are oddballs: they are referenced by named labels
914         docname, labelid, _ = self.labels.get(target, ('', '', ''))
915         if not docname:
916             return None
917         return make_refnode(builder, fromdocname, docname,
918                             labelid, contnode)
919 
920     def _resolve_doc_xref(self, env: "BuildEnvironment", fromdocname: str,
921                           builder: "Builder", typ: str, target: str,
922                           node: pending_xref, contnode: Element) -> Optional[Element]:
923         # directly reference to document by source name; can be absolute or relative
924         refdoc = node.get('refdoc', fromdocname)
925         docname = docname_join(refdoc, node['reftarget'])
926         if docname not in env.all_docs:
927             return None
928         else:
929             if node['refexplicit']:
930                 # reference with explicit title
931                 caption = node.astext()
932             else:
933                 caption = clean_astext(env.titles[docname])
934             innernode = nodes.inline(caption, caption, classes=['doc'])
935             return make_refnode(builder, fromdocname, docname, None, innernode)
936 
937     def _resolve_option_xref(self, env: "BuildEnvironment", fromdocname: str,
938                              builder: "Builder", typ: str, target: str,
939                              node: pending_xref, contnode: Element) -> Optional[Element]:
940         progname = node.get('std:program')
941         target = target.strip()
942         docname, labelid = self.progoptions.get((progname, target), ('', ''))
943         if not docname:
944             commands = []
945             while ws_re.search(target):
946                 subcommand, target = ws_re.split(target, 1)
947                 commands.append(subcommand)
948                 progname = "-".join(commands)
949 
950                 docname, labelid = self.progoptions.get((progname, target), ('', ''))
951                 if docname:
952                     break
953             else:
954                 return None
955 
956         return make_refnode(builder, fromdocname, docname,
957                             labelid, contnode)
958 
959     def _resolve_term_xref(self, env: "BuildEnvironment", fromdocname: str,
960                            builder: "Builder", typ: str, target: str,
961                            node: pending_xref, contnode: Element) -> Element:
962         result = self._resolve_obj_xref(env, fromdocname, builder, typ,
963                                         target, node, contnode)
964         if result:
965             return result
966         else:
967             # fallback to case insentive match
968             if target.lower() in self._terms:
969                 docname, labelid = self._terms[target.lower()]
970                 return make_refnode(builder, fromdocname, docname, labelid, contnode)
971             else:
972                 return None
973 
974     def _resolve_obj_xref(self, env: "BuildEnvironment", fromdocname: str,
975                           builder: "Builder", typ: str, target: str,
976                           node: pending_xref, contnode: Element) -> Optional[Element]:
977         objtypes = self.objtypes_for_role(typ) or []
978         for objtype in objtypes:
979             if (objtype, target) in self.objects:
980                 docname, labelid = self.objects[objtype, target]
981                 break
982         else:
983             docname, labelid = '', ''
984         if not docname:
985             return None
986         return make_refnode(builder, fromdocname, docname,
987                             labelid, contnode)
988 
989     def resolve_any_xref(self, env: "BuildEnvironment", fromdocname: str,
990                          builder: "Builder", target: str, node: pending_xref,
991                          contnode: Element) -> List[Tuple[str, Element]]:
992         results: List[Tuple[str, Element]] = []
993         ltarget = target.lower()  # :ref: lowercases its target automatically
994         for role in ('ref', 'option'):  # do not try "keyword"
995             res = self.resolve_xref(env, fromdocname, builder, role,
996                                     ltarget if role == 'ref' else target,
997                                     node, contnode)
998             if res:
999                 results.append(('std:' + role, res))
1000         # all others
1001         for objtype in self.object_types:
1002             key = (objtype, target)
1003             if objtype == 'term':
1004                 key = (objtype, ltarget)
1005             if key in self.objects:
1006                 docname, labelid = self.objects[key]
1007                 results.append(('std:' + self.role_for_objtype(objtype),
1008                                 make_refnode(builder, fromdocname, docname,
1009                                              labelid, contnode)))
1010         return results
1011 
1012     def get_objects(self) -> Iterator[Tuple[str, str, str, str, str, int]]:
1013         # handle the special 'doc' reference here
1014         for doc in self.env.all_docs:
1015             yield (doc, clean_astext(self.env.titles[doc]), 'doc', doc, '', -1)
1016         for (prog, option), info in self.progoptions.items():
1017             if prog:
1018                 fullname = ".".join([prog, option])
1019                 yield (fullname, fullname, 'cmdoption', info[0], info[1], 1)
1020             else:
1021                 yield (option, option, 'cmdoption', info[0], info[1], 1)
1022         for (type, name), info in self.objects.items():
1023             yield (name, name, type, info[0], info[1],
1024                    self.object_types[type].attrs['searchprio'])
1025         for name, (docname, labelid, sectionname) in self.labels.items():
1026             yield (name, sectionname, 'label', docname, labelid, -1)
1027         # add anonymous-only labels as well
1028         non_anon_labels = set(self.labels)
1029         for name, (docname, labelid) in self.anonlabels.items():
1030             if name not in non_anon_labels:
1031                 yield (name, name, 'label', docname, labelid, -1)
1032 
1033     def get_type_name(self, type: ObjType, primary: bool = False) -> str:
1034         # never prepend "Default"
1035         return type.lname
1036 
1037     def is_enumerable_node(self, node: Node) -> bool:
1038         return node.__class__ in self.enumerable_nodes
1039 
1040     def get_numfig_title(self, node: Node) -> Optional[str]:
1041         """Get the title of enumerable nodes to refer them using its title"""
1042         if self.is_enumerable_node(node):
1043             elem = cast(Element, node)
1044             _, title_getter = self.enumerable_nodes.get(elem.__class__, (None, None))
1045             if title_getter:
1046                 return title_getter(elem)
1047             else:
1048                 for subnode in elem:
1049                     if isinstance(subnode, (nodes.caption, nodes.title)):
1050                         return clean_astext(subnode)
1051 
1052         return None
1053 
1054     def get_enumerable_node_type(self, node: Node) -> Optional[str]:
1055         """Get type of enumerable nodes."""
1056         def has_child(node: Element, cls: Type) -> bool:
1057             return any(isinstance(child, cls) for child in node)
1058 
1059         if isinstance(node, nodes.section):
1060             return 'section'
1061         elif (isinstance(node, nodes.container) and
1062               'literal_block' in node and
1063               has_child(node, nodes.literal_block)):
1064             # given node is a code-block having caption
1065             return 'code-block'
1066         else:
1067             figtype, _ = self.enumerable_nodes.get(node.__class__, (None, None))
1068             return figtype
1069 
1070     def get_fignumber(self, env: "BuildEnvironment", builder: "Builder",
1071                       figtype: str, docname: str, target_node: Element) -> Tuple[int, ...]:
1072         if figtype == 'section':
1073             if builder.name == 'latex':
1074                 return tuple()
1075             elif docname not in env.toc_secnumbers:
1076                 raise ValueError  # no number assigned
1077             else:
1078                 anchorname = '#' + target_node['ids'][0]
1079                 if anchorname not in env.toc_secnumbers[docname]:
1080                     # try first heading which has no anchor
1081                     return env.toc_secnumbers[docname].get('')
1082                 else:
1083                     return env.toc_secnumbers[docname].get(anchorname)
1084         else:
1085             try:
1086                 figure_id = target_node['ids'][0]
1087                 return env.toc_fignumbers[docname][figtype][figure_id]
1088             except (KeyError, IndexError) as exc:
1089                 # target_node is found, but fignumber is not assigned.
1090                 # Maybe it is defined in orphaned document.
1091                 raise ValueError from exc
1092 
1093     def get_full_qualified_name(self, node: Element) -> Optional[str]:
1094         if node.get('reftype') == 'option':
1095             progname = node.get('std:program')
1096             command = ws_re.split(node.get('reftarget'))
1097             if progname:
1098                 command.insert(0, progname)
1099             option = command.pop()
1100             if command:
1101                 return '.'.join(['-'.join(command), option])
1102             else:
1103                 return None
1104         else:
1105             return None
1106 
1107 
1108 def warn_missing_reference(app: "Sphinx", domain: Domain, node: pending_xref
1109                            ) -> Optional[bool]:
1110     if (domain and domain.name != 'std') or node['reftype'] != 'ref':
1111         return None
1112     else:
1113         target = node['reftarget']
1114         if target not in domain.anonlabels:  # type: ignore
1115             msg = __('undefined label: %s')
1116         else:
1117             msg = __('Failed to create a cross reference. A title or caption not found: %s')
1118 
1119         logger.warning(msg % target, location=node, type='ref', subtype=node['reftype'])
1120         return True
1121 
1122 
1123 def setup(app: "Sphinx") -> Dict[str, Any]:
1124     app.add_domain(StandardDomain)
1125     app.connect('warn-missing-reference', warn_missing_reference)
1126 
1127     return {
1128         'version': 'builtin',
1129         'env_version': 2,
1130         'parallel_read_safe': True,
1131         'parallel_write_safe': True,
1132     }

</code><intended_behavior>This file likely handles the logical structuring or interpretation of standard domain elements, including glossaries. The intended behavior here is to ensure that data structure passed from this processing step to the LaTeX writer (sphinx/writers/latex.py) is correctly formatted or tagged in a way that facilitates the appropriate LaTeX separation of glossary terms. If issues stem from how glossary terms are aggregated or passed along, adjusting this to support clearer separation in LaTeX output is necessary. This might not require adding new methods but rather adjusting existing logic to ensure that groupings of glossary terms are maintained or appropriately flagged for the LaTeX output stage.</intended_behavior>]
2025-10-18 06:18:11.472 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-18 06:18:11.472 | INFO     | Search-only: skipping patch selection
2025-10-18 06:18:11.546 | INFO     | Task sphinx-doc__sphinx-9999 completed successfully.
2025-10-18 06:18:11.547 | INFO     | No patch generated. You can try running ACR again.
