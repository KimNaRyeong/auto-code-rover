2025-10-18 04:40:09.846 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-18 04:40:11.697 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=826, output_tokens=12, cost=0.008620
2025-10-18 04:40:11.698 | INFO     | Test agent decides that the issue statement does not contain reproduction steps; skipping reproducer tracing
2025-10-18 04:40:11.702 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 04:40:18.698 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1123, output_tokens=307, cost=0.020440
2025-10-18 04:40:18.703 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 04:40:23.257 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=661, output_tokens=84, cost=0.009130
2025-10-18 04:40:23.259 | DEBUG    | Extracted a valid json.
2025-10-18 04:40:23.259 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_class(\"Logger\")",
        "search_method_in_class(\"initialize\", \"core\")",
        "search_code(\"class Logger\")",
        "search_code(\"core.initialize\")",
        "search_method(\"message\")",
        "search_code_in_file(\"import pmxbot.logging\", \"tests/unit/test_commands.py\")"
    ],
    "bug_locations": []
}
2025-10-18 04:40:23.291 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 04:40:23.292 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 04:40:33.153 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1675, output_tokens=451, cost=0.030280
2025-10-18 04:40:33.165 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 04:40:44.445 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2342, output_tokens=515, cost=0.038870
2025-10-18 04:40:44.454 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 04:40:51.792 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=869, output_tokens=200, cost=0.014690
2025-10-18 04:40:51.793 | DEBUG    | Extracted a valid json.
2025-10-18 04:40:51.793 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "pmxbot/logging.py",
            "class": "",
            "method": "",
            "intended_behavior": "Ensure that the Logger.store is initialized in a way that it is consistent across different parts of the application, reflecting any changes across namespaces. This might involve ensuring that when core.initialize() configures Logger.store, it does so in a manner that is acknowledged universally by all parts of the application, preventing the duplication of the pmxbot.logging module in sys.modules."
        },
        {
            "file": "",
            "class": "",
            "method": "initialize",
            "intended_behavior": "The initialize function should properly handle PEP 420 namespace packages such that only one instance of each module is loaded and recognized application-wide. This may involve ensuring importlib uses the correct loader or invoking hooks that manage namespaces consistently with the rest of the Python runtime."
        }
    ]
}
2025-10-18 04:40:51.797 | DEBUG    | Failed to retrieve code from all bug locations. Asking search agent to re-generate response.
2025-10-18 04:40:51.798 | DEBUG    | <Agent search> Downstream could not consume our last response. Will retry.
2025-10-18 04:40:51.798 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 04:41:02.493 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2891, output_tokens=436, cost=0.041990
2025-10-18 04:41:02.501 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 04:41:04.809 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=790, output_tokens=14, cost=0.008320
2025-10-18 04:41:04.810 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-18 04:41:04.810 | DEBUG    | Trying to convert API calls/bug locations into json. Try 2 of 5.
2025-10-18 04:41:06.772 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=790, output_tokens=14, cost=0.008320
2025-10-18 04:41:06.773 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-18 04:41:06.773 | DEBUG    | Trying to convert API calls/bug locations into json. Try 3 of 5.
2025-10-18 04:41:07.996 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=790, output_tokens=14, cost=0.008320
2025-10-18 04:41:07.997 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-18 04:41:07.997 | DEBUG    | Trying to convert API calls/bug locations into json. Try 4 of 5.
2025-10-18 04:41:09.560 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=790, output_tokens=14, cost=0.008320
2025-10-18 04:41:09.561 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-18 04:41:09.561 | DEBUG    | Trying to convert API calls/bug locations into json. Try 5 of 5.
2025-10-18 04:41:11.872 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=790, output_tokens=14, cost=0.008320
2025-10-18 04:41:11.873 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-18 04:41:11.873 | DEBUG    | Agent proxy return the following json: None
2025-10-18 04:41:11.874 | DEBUG    | Could not extract API calls from agent search response, asking search agent to re-generate response.
2025-10-18 04:41:11.875 | DEBUG    | <Agent search> Downstream could not consume our last response. Will retry.
2025-10-18 04:41:11.875 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 04:41:20.354 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3354, output_tokens=331, cost=0.043470
2025-10-18 04:41:20.361 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 04:41:23.127 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=685, output_tokens=56, cost=0.008530
2025-10-18 04:41:23.129 | DEBUG    | Extracted a valid json.
2025-10-18 04:41:23.129 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_code(\"importlib\")",
        "search_code(\"import pmxbot\")",
        "search_code(\"Logger.store\")",
        "search_code(\"ConfigDict.from_yaml\")"
    ],
    "bug_locations": []
}
2025-10-18 04:41:23.243 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 04:41:23.244 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 04:41:37.217 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=4216, output_tokens=639, cost=0.061330
2025-10-18 04:41:37.223 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 04:41:47.663 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=5071, output_tokens=434, cost=0.063730
2025-10-18 04:41:47.669 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 04:41:54.306 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=788, output_tokens=231, cost=0.014810
2025-10-18 04:41:54.307 | DEBUG    | Extracted a valid json.
2025-10-18 04:41:54.307 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "src/_pytest/config/__init__.py",
            "class": "",
            "method": "",
            "intended_behavior": "Ensure that when modules are loaded, particularly those related to `pmxbot`, they are loaded in a manner that recognizes and respects the PEP 420 namespace packages, preventing duplicate instances. This may involve checking the configuration logic to ensure it does not inadvertently cause a module to be re-imported or re-initialized in a manner that creates two separate instances of what should be a single module in `sys.modules`."
        },
        {
            "file": "src/_pytest/pathlib.py",
            "class": "",
            "method": "",
            "intended_behavior": "These files should correctly handle the resolution and import of modules in a way that's consistent with Python's expected behavior for namespace packages. This ensures that only one instance of each module exists within the application's runtime, specifically avoiding issues where one instance is used to set a configuration and another separate instance is checked for that configuration."
        }
    ]
}
2025-10-18 04:41:54.318 | DEBUG    | Bug location extracted successfully: [<file>src/_pytest/config/__init__.py</file>
<class>None</class>
<method>None</method>
<code>
1 """Command line options, ini-file and conftest.py processing."""
2 import argparse
3 import collections.abc
4 import copy
5 import dataclasses
6 import enum
7 import glob
8 import importlib.metadata
9 import inspect
10 import os
11 import re
12 import shlex
13 import sys
14 import types
15 import warnings
16 from functools import lru_cache
17 from pathlib import Path
18 from textwrap import dedent
19 from types import FunctionType
20 from types import TracebackType
21 from typing import Any
22 from typing import Callable
23 from typing import cast
24 from typing import Dict
25 from typing import final
26 from typing import Generator
27 from typing import IO
28 from typing import Iterable
29 from typing import Iterator
30 from typing import List
31 from typing import Optional
32 from typing import Sequence
33 from typing import Set
34 from typing import TextIO
35 from typing import Tuple
36 from typing import Type
37 from typing import TYPE_CHECKING
38 from typing import Union
39 
40 from pluggy import HookimplMarker
41 from pluggy import HookspecMarker
42 from pluggy import PluginManager
43 
44 import _pytest._code
45 import _pytest.deprecated
46 import _pytest.hookspec
47 from .exceptions import PrintHelp as PrintHelp
48 from .exceptions import UsageError as UsageError
49 from .findpaths import determine_setup
50 from _pytest._code import ExceptionInfo
51 from _pytest._code import filter_traceback
52 from _pytest._io import TerminalWriter
53 from _pytest.outcomes import fail
54 from _pytest.outcomes import Skipped
55 from _pytest.pathlib import absolutepath
56 from _pytest.pathlib import bestrelpath
57 from _pytest.pathlib import import_path
58 from _pytest.pathlib import ImportMode
59 from _pytest.pathlib import resolve_package_path
60 from _pytest.stash import Stash
61 from _pytest.warning_types import PytestConfigWarning
62 from _pytest.warning_types import warn_explicit_for
63 
64 if TYPE_CHECKING:
65     from _pytest._code.code import _TracebackStyle
66     from _pytest.terminal import TerminalReporter
67     from .argparsing import Argument
68 
69 
70 _PluggyPlugin = object
71 """A type to represent plugin objects.
72 
73 Plugins can be any namespace, so we can't narrow it down much, but we use an
74 alias to make the intent clear.
75 
76 Ideally this type would be provided by pluggy itself.
77 """
78 
79 
80 hookimpl = HookimplMarker("pytest")
81 hookspec = HookspecMarker("pytest")
82 
83 
84 @final
85 class ExitCode(enum.IntEnum):
86     """Encodes the valid exit codes by pytest.
87 
88     Currently users and plugins may supply other exit codes as well.
89 
90     .. versionadded:: 5.0
91     """
92 
93     #: Tests passed.
94     OK = 0
95     #: Tests failed.
96     TESTS_FAILED = 1
97     #: pytest was interrupted.
98     INTERRUPTED = 2
99     #: An internal error got in the way.
100     INTERNAL_ERROR = 3
101     #: pytest was misused.
102     USAGE_ERROR = 4
103     #: pytest couldn't find tests.
104     NO_TESTS_COLLECTED = 5
105 
106 
107 class ConftestImportFailure(Exception):
108     def __init__(
109         self,
110         path: Path,
111         excinfo: Tuple[Type[Exception], Exception, TracebackType],
112     ) -> None:
113         super().__init__(path, excinfo)
114         self.path = path
115         self.excinfo = excinfo
116 
117     def __str__(self) -> str:
118         return "{}: {} (from {})".format(
119             self.excinfo[0].__name__, self.excinfo[1], self.path
120         )
121 
122 
123 def filter_traceback_for_conftest_import_failure(
124     entry: _pytest._code.TracebackEntry,
125 ) -> bool:
126     """Filter tracebacks entries which point to pytest internals or importlib.
127 
128     Make a special case for importlib because we use it to import test modules and conftest files
129     in _pytest.pathlib.import_path.
130     """
131     return filter_traceback(entry) and "importlib" not in str(entry.path).split(os.sep)
132 
133 
134 def main(
135     args: Optional[Union[List[str], "os.PathLike[str]"]] = None,
136     plugins: Optional[Sequence[Union[str, _PluggyPlugin]]] = None,
137 ) -> Union[int, ExitCode]:
138     """Perform an in-process test run.
139 
140     :param args: List of command line arguments.
141     :param plugins: List of plugin objects to be auto-registered during initialization.
142 
143     :returns: An exit code.
144     """
145     try:
146         try:
147             config = _prepareconfig(args, plugins)
148         except ConftestImportFailure as e:
149             exc_info = ExceptionInfo.from_exc_info(e.excinfo)
150             tw = TerminalWriter(sys.stderr)
151             tw.line(f"ImportError while loading conftest '{e.path}'.", red=True)
152             exc_info.traceback = exc_info.traceback.filter(
153                 filter_traceback_for_conftest_import_failure
154             )
155             exc_repr = (
156                 exc_info.getrepr(style="short", chain=False)
157                 if exc_info.traceback
158                 else exc_info.exconly()
159             )
160             formatted_tb = str(exc_repr)
161             for line in formatted_tb.splitlines():
162                 tw.line(line.rstrip(), red=True)
163             return ExitCode.USAGE_ERROR
164         else:
165             try:
166                 ret: Union[ExitCode, int] = config.hook.pytest_cmdline_main(
167                     config=config
168                 )
169                 try:
170                     return ExitCode(ret)
171                 except ValueError:
172                     return ret
173             finally:
174                 config._ensure_unconfigure()
175     except UsageError as e:
176         tw = TerminalWriter(sys.stderr)
177         for msg in e.args:
178             tw.line(f"ERROR: {msg}\n", red=True)
179         return ExitCode.USAGE_ERROR
180 
181 
182 def console_main() -> int:
183     """The CLI entry point of pytest.
184 
185     This function is not meant for programmable use; use `main()` instead.
186     """
187     # https://docs.python.org/3/library/signal.html#note-on-sigpipe
188     try:
189         code = main()
190         sys.stdout.flush()
191         return code
192     except BrokenPipeError:
193         # Python flushes standard streams on exit; redirect remaining output
194         # to devnull to avoid another BrokenPipeError at shutdown
195         devnull = os.open(os.devnull, os.O_WRONLY)
196         os.dup2(devnull, sys.stdout.fileno())
197         return 1  # Python exits with error code 1 on EPIPE
198 
199 
200 class cmdline:  # compatibility namespace
201     main = staticmethod(main)
202 
203 
204 def filename_arg(path: str, optname: str) -> str:
205     """Argparse type validator for filename arguments.
206 
207     :path: Path of filename.
208     :optname: Name of the option.
209     """
210     if os.path.isdir(path):
211         raise UsageError(f"{optname} must be a filename, given: {path}")
212     return path
213 
214 
215 def directory_arg(path: str, optname: str) -> str:
216     """Argparse type validator for directory arguments.
217 
218     :path: Path of directory.
219     :optname: Name of the option.
220     """
221     if not os.path.isdir(path):
222         raise UsageError(f"{optname} must be a directory, given: {path}")
223     return path
224 
225 
226 # Plugins that cannot be disabled via "-p no:X" currently.
227 essential_plugins = (
228     "mark",
229     "main",
230     "runner",
231     "fixtures",
232     "helpconfig",  # Provides -p.
233 )
234 
235 default_plugins = essential_plugins + (
236     "python",
237     "terminal",
238     "debugging",
239     "unittest",
240     "capture",
241     "skipping",
242     "legacypath",
243     "tmpdir",
244     "monkeypatch",
245     "recwarn",
246     "pastebin",
247     "nose",
248     "assertion",
249     "junitxml",
250     "doctest",
251     "cacheprovider",
252     "freeze_support",
253     "setuponly",
254     "setupplan",
255     "stepwise",
256     "warnings",
257     "logging",
258     "reports",
259     "python_path",
260     "unraisableexception",
261     "threadexception",
262     "faulthandler",
263 )
264 
265 builtin_plugins = set(default_plugins)
266 builtin_plugins.add("pytester")
267 builtin_plugins.add("pytester_assertions")
268 
269 
270 def get_config(
271     args: Optional[List[str]] = None,
272     plugins: Optional[Sequence[Union[str, _PluggyPlugin]]] = None,
273 ) -> "Config":
274     # subsequent calls to main will create a fresh instance
275     pluginmanager = PytestPluginManager()
276     config = Config(
277         pluginmanager,
278         invocation_params=Config.InvocationParams(
279             args=args or (),
280             plugins=plugins,
281             dir=Path.cwd(),
282         ),
283     )
284 
285     if args is not None:
286         # Handle any "-p no:plugin" args.
287         pluginmanager.consider_preparse(args, exclude_only=True)
288 
289     for spec in default_plugins:
290         pluginmanager.import_plugin(spec)
291 
292     return config
293 
294 
295 def get_plugin_manager() -> "PytestPluginManager":
296     """Obtain a new instance of the
297     :py:class:`pytest.PytestPluginManager`, with default plugins
298     already loaded.
299 
300     This function can be used by integration with other tools, like hooking
301     into pytest to run tests into an IDE.
302     """
303     return get_config().pluginmanager
304 
305 
306 def _prepareconfig(
307     args: Optional[Union[List[str], "os.PathLike[str]"]] = None,
308     plugins: Optional[Sequence[Union[str, _PluggyPlugin]]] = None,
309 ) -> "Config":
310     if args is None:
311         args = sys.argv[1:]
312     elif isinstance(args, os.PathLike):
313         args = [os.fspath(args)]
314     elif not isinstance(args, list):
315         msg = (  # type:ignore[unreachable]
316             "`args` parameter expected to be a list of strings, got: {!r} (type: {})"
317         )
318         raise TypeError(msg.format(args, type(args)))
319 
320     config = get_config(args, plugins)
321     pluginmanager = config.pluginmanager
322     try:
323         if plugins:
324             for plugin in plugins:
325                 if isinstance(plugin, str):
326                     pluginmanager.consider_pluginarg(plugin)
327                 else:
328                     pluginmanager.register(plugin)
329         config = pluginmanager.hook.pytest_cmdline_parse(
330             pluginmanager=pluginmanager, args=args
331         )
332         return config
333     except BaseException:
334         config._ensure_unconfigure()
335         raise
336 
337 
338 def _get_directory(path: Path) -> Path:
339     """Get the directory of a path - itself if already a directory."""
340     if path.is_file():
341         return path.parent
342     else:
343         return path
344 
345 
346 def _get_legacy_hook_marks(
347     method: Any,
348     hook_type: str,
349     opt_names: Tuple[str, ...],
350 ) -> Dict[str, bool]:
351     if TYPE_CHECKING:
352         # abuse typeguard from importlib to avoid massive method type union thats lacking a alias
353         assert inspect.isroutine(method)
354     known_marks: set[str] = {m.name for m in getattr(method, "pytestmark", [])}
355     must_warn: list[str] = []
356     opts: dict[str, bool] = {}
357     for opt_name in opt_names:
358         opt_attr = getattr(method, opt_name, AttributeError)
359         if opt_attr is not AttributeError:
360             must_warn.append(f"{opt_name}={opt_attr}")
361             opts[opt_name] = True
362         elif opt_name in known_marks:
363             must_warn.append(f"{opt_name}=True")
364             opts[opt_name] = True
365         else:
366             opts[opt_name] = False
367     if must_warn:
368         hook_opts = ", ".join(must_warn)
369         message = _pytest.deprecated.HOOK_LEGACY_MARKING.format(
370             type=hook_type,
371             fullname=method.__qualname__,
372             hook_opts=hook_opts,
373         )
374         warn_explicit_for(cast(FunctionType, method), message)
375     return opts
376 
377 
378 @final
379 class PytestPluginManager(PluginManager):
380     """A :py:class:`pluggy.PluginManager <pluggy.PluginManager>` with
381     additional pytest-specific functionality:
382 
383     * Loading plugins from the command line, ``PYTEST_PLUGINS`` env variable and
384       ``pytest_plugins`` global variables found in plugins being loaded.
385     * ``conftest.py`` loading during start-up.
386     """
387 
388     def __init__(self) -> None:
389         import _pytest.assertion
390 
391         super().__init__("pytest")
392 
393         # -- State related to local conftest plugins.
394         # All loaded conftest modules.
395         self._conftest_plugins: Set[types.ModuleType] = set()
396         # All conftest modules applicable for a directory.
397         # This includes the directory's own conftest modules as well
398         # as those of its parent directories.
399         self._dirpath2confmods: Dict[Path, List[types.ModuleType]] = {}
400         # Cutoff directory above which conftests are no longer discovered.
401         self._confcutdir: Optional[Path] = None
402         # If set, conftest loading is skipped.
403         self._noconftest = False
404 
405         # _getconftestmodules()'s call to _get_directory() causes a stat
406         # storm when it's called potentially thousands of times in a test
407         # session (#9478), often with the same path, so cache it.
408         self._get_directory = lru_cache(256)(_get_directory)
409 
410         self._duplicatepaths: Set[Path] = set()
411 
412         # plugins that were explicitly skipped with pytest.skip
413         # list of (module name, skip reason)
414         # previously we would issue a warning when a plugin was skipped, but
415         # since we refactored warnings as first citizens of Config, they are
416         # just stored here to be used later.
417         self.skipped_plugins: List[Tuple[str, str]] = []
418 
419         self.add_hookspecs(_pytest.hookspec)
420         self.register(self)
421         if os.environ.get("PYTEST_DEBUG"):
422             err: IO[str] = sys.stderr
423             encoding: str = getattr(err, "encoding", "utf8")
424             try:
425                 err = open(
426                     os.dup(err.fileno()),
427                     mode=err.mode,
428                     buffering=1,
429                     encoding=encoding,
430                 )
431             except Exception:
432                 pass
433             self.trace.root.setwriter(err.write)
434             self.enable_tracing()
435 
436         # Config._consider_importhook will set a real object if required.
437         self.rewrite_hook = _pytest.assertion.DummyRewriteHook()
438         # Used to know when we are importing conftests after the pytest_configure stage.
439         self._configured = False
440 
441     def parse_hookimpl_opts(self, plugin: _PluggyPlugin, name: str):
442         # pytest hooks are always prefixed with "pytest_",
443         # so we avoid accessing possibly non-readable attributes
444         # (see issue #1073).
445         if not name.startswith("pytest_"):
446             return
447         # Ignore names which can not be hooks.
448         if name == "pytest_plugins":
449             return
450 
451         opts = super().parse_hookimpl_opts(plugin, name)
452         if opts is not None:
453             return opts
454 
455         method = getattr(plugin, name)
456         # Consider only actual functions for hooks (#3775).
457         if not inspect.isroutine(method):
458             return
459         # Collect unmarked hooks as long as they have the `pytest_' prefix.
460         return _get_legacy_hook_marks(
461             method, "impl", ("tryfirst", "trylast", "optionalhook", "hookwrapper")
462         )
463 
464     def parse_hookspec_opts(self, module_or_class, name: str):
465         opts = super().parse_hookspec_opts(module_or_class, name)
466         if opts is None:
467             method = getattr(module_or_class, name)
468             if name.startswith("pytest_"):
469                 opts = _get_legacy_hook_marks(
470                     method,
471                     "spec",
472                     ("firstresult", "historic"),
473                 )
474         return opts
475 
476     def register(
477         self, plugin: _PluggyPlugin, name: Optional[str] = None
478     ) -> Optional[str]:
479         if name in _pytest.deprecated.DEPRECATED_EXTERNAL_PLUGINS:
480             warnings.warn(
481                 PytestConfigWarning(
482                     "{} plugin has been merged into the core, "
483                     "please remove it from your requirements.".format(
484                         name.replace("_", "-")
485                     )
486                 )
487             )
488             return None
489         ret: Optional[str] = super().register(plugin, name)
490         if ret:
491             self.hook.pytest_plugin_registered.call_historic(
492                 kwargs=dict(plugin=plugin, manager=self)
493             )
494 
495             if isinstance(plugin, types.ModuleType):
496                 self.consider_module(plugin)
497         return ret
498 
499     def getplugin(self, name: str):
500         # Support deprecated naming because plugins (xdist e.g.) use it.
501         plugin: Optional[_PluggyPlugin] = self.get_plugin(name)
502         return plugin
503 
504     def hasplugin(self, name: str) -> bool:
505         """Return whether a plugin with the given name is registered."""
506         return bool(self.get_plugin(name))
507 
508     def pytest_configure(self, config: "Config") -> None:
509         """:meta private:"""
510         # XXX now that the pluginmanager exposes hookimpl(tryfirst...)
511         # we should remove tryfirst/trylast as markers.
512         config.addinivalue_line(
513             "markers",
514             "tryfirst: mark a hook implementation function such that the "
515             "plugin machinery will try to call it first/as early as possible. "
516             "DEPRECATED, use @pytest.hookimpl(tryfirst=True) instead.",
517         )
518         config.addinivalue_line(
519             "markers",
520             "trylast: mark a hook implementation function such that the "
521             "plugin machinery will try to call it last/as late as possible. "
522             "DEPRECATED, use @pytest.hookimpl(trylast=True) instead.",
523         )
524         self._configured = True
525 
526     #
527     # Internal API for local conftest plugin handling.
528     #
529     def _set_initial_conftests(
530         self,
531         args: Sequence[Union[str, Path]],
532         pyargs: bool,
533         noconftest: bool,
534         rootpath: Path,
535         confcutdir: Optional[Path],
536         importmode: Union[ImportMode, str],
537     ) -> None:
538         """Load initial conftest files given a preparsed "namespace".
539 
540         As conftest files may add their own command line options which have
541         arguments ('--my-opt somepath') we might get some false positives.
542         All builtin and 3rd party plugins will have been loaded, however, so
543         common options will not confuse our logic here.
544         """
545         current = Path.cwd()
546         self._confcutdir = absolutepath(current / confcutdir) if confcutdir else None
547         self._noconftest = noconftest
548         self._using_pyargs = pyargs
549         foundanchor = False
550         for intitial_path in args:
551             path = str(intitial_path)
552             # remove node-id syntax
553             i = path.find("::")
554             if i != -1:
555                 path = path[:i]
556             anchor = absolutepath(current / path)
557 
558             # Ensure we do not break if what appears to be an anchor
559             # is in fact a very long option (#10169).
560             try:
561                 anchor_exists = anchor.exists()
562             except OSError:  # pragma: no cover
563                 anchor_exists = False
564             if anchor_exists:
565                 self._try_load_conftest(anchor, importmode, rootpath)
566                 foundanchor = True
567         if not foundanchor:
568             self._try_load_conftest(current, importmode, rootpath)
569 
570     def _is_in_confcutdir(self, path: Path) -> bool:
571         """Whether a path is within the confcutdir.
572 
573         When false, should not load conftest.
574         """
575         if self._confcutdir is None:
576             return True
577         return path not in self._confcutdir.parents
578 
579     def _try_load_conftest(
580         self, anchor: Path, importmode: Union[str, ImportMode], rootpath: Path
581     ) -> None:
582         self._getconftestmodules(anchor, importmode, rootpath)
583         # let's also consider test* subdirs
584         if anchor.is_dir():
585             for x in anchor.glob("test*"):
586                 if x.is_dir():
587                     self._getconftestmodules(x, importmode, rootpath)
588 
589     def _getconftestmodules(
590         self, path: Path, importmode: Union[str, ImportMode], rootpath: Path
591     ) -> Sequence[types.ModuleType]:
592         if self._noconftest:
593             return []
594 
595         directory = self._get_directory(path)
596 
597         # Optimization: avoid repeated searches in the same directory.
598         # Assumes always called with same importmode and rootpath.
599         existing_clist = self._dirpath2confmods.get(directory)
600         if existing_clist is not None:
601             return existing_clist
602 
603         # XXX these days we may rather want to use config.rootpath
604         # and allow users to opt into looking into the rootdir parent
605         # directories instead of requiring to specify confcutdir.
606         clist = []
607         for parent in reversed((directory, *directory.parents)):
608             if self._is_in_confcutdir(parent):
609                 conftestpath = parent / "conftest.py"
610                 if conftestpath.is_file():
611                     mod = self._importconftest(conftestpath, importmode, rootpath)
612                     clist.append(mod)
613         self._dirpath2confmods[directory] = clist
614         return clist
615 
616     def _rget_with_confmod(
617         self,
618         name: str,
619         path: Path,
620         importmode: Union[str, ImportMode],
621         rootpath: Path,
622     ) -> Tuple[types.ModuleType, Any]:
623         modules = self._getconftestmodules(path, importmode, rootpath=rootpath)
624         for mod in reversed(modules):
625             try:
626                 return mod, getattr(mod, name)
627             except AttributeError:
628                 continue
629         raise KeyError(name)
630 
631     def _importconftest(
632         self, conftestpath: Path, importmode: Union[str, ImportMode], rootpath: Path
633     ) -> types.ModuleType:
634         existing = self.get_plugin(str(conftestpath))
635         if existing is not None:
636             return cast(types.ModuleType, existing)
637 
638         pkgpath = resolve_package_path(conftestpath)
639         if pkgpath is None:
640             _ensure_removed_sysmodule(conftestpath.stem)
641 
642         try:
643             mod = import_path(conftestpath, mode=importmode, root=rootpath)
644         except Exception as e:
645             assert e.__traceback__ is not None
646             exc_info = (type(e), e, e.__traceback__)
647             raise ConftestImportFailure(conftestpath, exc_info) from e
648 
649         self._check_non_top_pytest_plugins(mod, conftestpath)
650 
651         self._conftest_plugins.add(mod)
652         dirpath = conftestpath.parent
653         if dirpath in self._dirpath2confmods:
654             for path, mods in self._dirpath2confmods.items():
655                 if dirpath in path.parents or path == dirpath:
656                     assert mod not in mods
657                     mods.append(mod)
658         self.trace(f"loading conftestmodule {mod!r}")
659         self.consider_conftest(mod)
660         return mod
661 
662     def _check_non_top_pytest_plugins(
663         self,
664         mod: types.ModuleType,
665         conftestpath: Path,
666     ) -> None:
667         if (
668             hasattr(mod, "pytest_plugins")
669             and self._configured
670             and not self._using_pyargs
671         ):
672             msg = (
673                 "Defining 'pytest_plugins' in a non-top-level conftest is no longer supported:\n"
674                 "It affects the entire test suite instead of just below the conftest as expected.\n"
675                 "  {}\n"
676                 "Please move it to a top level conftest file at the rootdir:\n"
677                 "  {}\n"
678                 "For more information, visit:\n"
679                 "  https://docs.pytest.org/en/stable/deprecations.html#pytest-plugins-in-non-top-level-conftest-files"
680             )
681             fail(msg.format(conftestpath, self._confcutdir), pytrace=False)
682 
683     #
684     # API for bootstrapping plugin loading
685     #
686     #
687 
688     def consider_preparse(
689         self, args: Sequence[str], *, exclude_only: bool = False
690     ) -> None:
691         """:meta private:"""
692         i = 0
693         n = len(args)
694         while i < n:
695             opt = args[i]
696             i += 1
697             if isinstance(opt, str):
698                 if opt == "-p":
699                     try:
700                         parg = args[i]
701                     except IndexError:
702                         return
703                     i += 1
704                 elif opt.startswith("-p"):
705                     parg = opt[2:]
706                 else:
707                     continue
708                 parg = parg.strip()
709                 if exclude_only and not parg.startswith("no:"):
710                     continue
711                 self.consider_pluginarg(parg)
712 
713     def consider_pluginarg(self, arg: str) -> None:
714         """:meta private:"""
715         if arg.startswith("no:"):
716             name = arg[3:]
717             if name in essential_plugins:
718                 raise UsageError("plugin %s cannot be disabled" % name)
719 
720             # PR #4304: remove stepwise if cacheprovider is blocked.
721             if name == "cacheprovider":
722                 self.set_blocked("stepwise")
723                 self.set_blocked("pytest_stepwise")
724 
725             self.set_blocked(name)
726             if not name.startswith("pytest_"):
727                 self.set_blocked("pytest_" + name)
728         else:
729             name = arg
730             # Unblock the plugin.  None indicates that it has been blocked.
731             # There is no interface with pluggy for this.
732             if self._name2plugin.get(name, -1) is None:
733                 del self._name2plugin[name]
734             if not name.startswith("pytest_"):
735                 if self._name2plugin.get("pytest_" + name, -1) is None:
736                     del self._name2plugin["pytest_" + name]
737             self.import_plugin(arg, consider_entry_points=True)
738 
739     def consider_conftest(self, conftestmodule: types.ModuleType) -> None:
740         """:meta private:"""
741         self.register(conftestmodule, name=conftestmodule.__file__)
742 
743     def consider_env(self) -> None:
744         """:meta private:"""
745         self._import_plugin_specs(os.environ.get("PYTEST_PLUGINS"))
746 
747     def consider_module(self, mod: types.ModuleType) -> None:
748         """:meta private:"""
749         self._import_plugin_specs(getattr(mod, "pytest_plugins", []))
750 
751     def _import_plugin_specs(
752         self, spec: Union[None, types.ModuleType, str, Sequence[str]]
753     ) -> None:
754         plugins = _get_plugin_specs_as_list(spec)
755         for import_spec in plugins:
756             self.import_plugin(import_spec)
757 
758     def import_plugin(self, modname: str, consider_entry_points: bool = False) -> None:
759         """Import a plugin with ``modname``.
760 
761         If ``consider_entry_points`` is True, entry point names are also
762         considered to find a plugin.
763         """
764         # Most often modname refers to builtin modules, e.g. "pytester",
765         # "terminal" or "capture".  Those plugins are registered under their
766         # basename for historic purposes but must be imported with the
767         # _pytest prefix.
768         assert isinstance(modname, str), (
769             "module name as text required, got %r" % modname
770         )
771         if self.is_blocked(modname) or self.get_plugin(modname) is not None:
772             return
773 
774         importspec = "_pytest." + modname if modname in builtin_plugins else modname
775         self.rewrite_hook.mark_rewrite(importspec)
776 
777         if consider_entry_points:
778             loaded = self.load_setuptools_entrypoints("pytest11", name=modname)
779             if loaded:
780                 return
781 
782         try:
783             __import__(importspec)
784         except ImportError as e:
785             raise ImportError(
786                 f'Error importing plugin "{modname}": {e.args[0]}'
787             ).with_traceback(e.__traceback__) from e
788 
789         except Skipped as e:
790             self.skipped_plugins.append((modname, e.msg or ""))
791         else:
792             mod = sys.modules[importspec]
793             self.register(mod, modname)
794 
795 
796 def _get_plugin_specs_as_list(
797     specs: Union[None, types.ModuleType, str, Sequence[str]]
798 ) -> List[str]:
799     """Parse a plugins specification into a list of plugin names."""
800     # None means empty.
801     if specs is None:
802         return []
803     # Workaround for #3899 - a submodule which happens to be called "pytest_plugins".
804     if isinstance(specs, types.ModuleType):
805         return []
806     # Comma-separated list.
807     if isinstance(specs, str):
808         return specs.split(",") if specs else []
809     # Direct specification.
810     if isinstance(specs, collections.abc.Sequence):
811         return list(specs)
812     raise UsageError(
813         "Plugins may be specified as a sequence or a ','-separated string of plugin names. Got: %r"
814         % specs
815     )
816 
817 
818 def _ensure_removed_sysmodule(modname: str) -> None:
819     try:
820         del sys.modules[modname]
821     except KeyError:
822         pass
823 
824 
825 class Notset:
826     def __repr__(self):
827         return "<NOTSET>"
828 
829 
830 notset = Notset()
831 
832 
833 def _iter_rewritable_modules(package_files: Iterable[str]) -> Iterator[str]:
834     """Given an iterable of file names in a source distribution, return the "names" that should
835     be marked for assertion rewrite.
836 
837     For example the package "pytest_mock/__init__.py" should be added as "pytest_mock" in
838     the assertion rewrite mechanism.
839 
840     This function has to deal with dist-info based distributions and egg based distributions
841     (which are still very much in use for "editable" installs).
842 
843     Here are the file names as seen in a dist-info based distribution:
844 
845         pytest_mock/__init__.py
846         pytest_mock/_version.py
847         pytest_mock/plugin.py
848         pytest_mock.egg-info/PKG-INFO
849 
850     Here are the file names as seen in an egg based distribution:
851 
852         src/pytest_mock/__init__.py
853         src/pytest_mock/_version.py
854         src/pytest_mock/plugin.py
855         src/pytest_mock.egg-info/PKG-INFO
856         LICENSE
857         setup.py
858 
859     We have to take in account those two distribution flavors in order to determine which
860     names should be considered for assertion rewriting.
861 
862     More information:
863         https://github.com/pytest-dev/pytest-mock/issues/167
864     """
865     package_files = list(package_files)
866     seen_some = False
867     for fn in package_files:
868         is_simple_module = "/" not in fn and fn.endswith(".py")
869         is_package = fn.count("/") == 1 and fn.endswith("__init__.py")
870         if is_simple_module:
871             module_name, _ = os.path.splitext(fn)
872             # we ignore "setup.py" at the root of the distribution
873             # as well as editable installation finder modules made by setuptools
874             if module_name != "setup" and not module_name.startswith("__editable__"):
875                 seen_some = True
876                 yield module_name
877         elif is_package:
878             package_name = os.path.dirname(fn)
879             seen_some = True
880             yield package_name
881 
882     if not seen_some:
883         # At this point we did not find any packages or modules suitable for assertion
884         # rewriting, so we try again by stripping the first path component (to account for
885         # "src" based source trees for example).
886         # This approach lets us have the common case continue to be fast, as egg-distributions
887         # are rarer.
888         new_package_files = []
889         for fn in package_files:
890             parts = fn.split("/")
891             new_fn = "/".join(parts[1:])
892             if new_fn:
893                 new_package_files.append(new_fn)
894         if new_package_files:
895             yield from _iter_rewritable_modules(new_package_files)
896 
897 
898 @final
899 class Config:
900     """Access to configuration values, pluginmanager and plugin hooks.
901 
902     :param PytestPluginManager pluginmanager:
903         A pytest PluginManager.
904 
905     :param InvocationParams invocation_params:
906         Object containing parameters regarding the :func:`pytest.main`
907         invocation.
908     """
909 
910     @final
911     @dataclasses.dataclass(frozen=True)
912     class InvocationParams:
913         """Holds parameters passed during :func:`pytest.main`.
914 
915         The object attributes are read-only.
916 
917         .. versionadded:: 5.1
918 
919         .. note::
920 
921             Note that the environment variable ``PYTEST_ADDOPTS`` and the ``addopts``
922             ini option are handled by pytest, not being included in the ``args`` attribute.
923 
924             Plugins accessing ``InvocationParams`` must be aware of that.
925         """
926 
927         args: Tuple[str, ...]
928         """The command-line arguments as passed to :func:`pytest.main`."""
929         plugins: Optional[Sequence[Union[str, _PluggyPlugin]]]
930         """Extra plugins, might be `None`."""
931         dir: Path
932         """The directory from which :func:`pytest.main` was invoked."""
933 
934         def __init__(
935             self,
936             *,
937             args: Iterable[str],
938             plugins: Optional[Sequence[Union[str, _PluggyPlugin]]],
939             dir: Path,
940         ) -> None:
941             object.__setattr__(self, "args", tuple(args))
942             object.__setattr__(self, "plugins", plugins)
943             object.__setattr__(self, "dir", dir)
944 
945     class ArgsSource(enum.Enum):
946         """Indicates the source of the test arguments.
947 
948         .. versionadded:: 7.2
949         """
950 
951         #: Command line arguments.
952         ARGS = enum.auto()
953         #: Invocation directory.
954         INCOVATION_DIR = enum.auto()
955         #: 'testpaths' configuration value.
956         TESTPATHS = enum.auto()
957 
958     def __init__(
959         self,
960         pluginmanager: PytestPluginManager,
961         *,
962         invocation_params: Optional[InvocationParams] = None,
963     ) -> None:
964         from .argparsing import Parser, FILE_OR_DIR
965 
966         if invocation_params is None:
967             invocation_params = self.InvocationParams(
968                 args=(), plugins=None, dir=Path.cwd()
969             )
970 
971         self.option = argparse.Namespace()
972         """Access to command line option as attributes.
973 
974         :type: argparse.Namespace
975         """
976 
977         self.invocation_params = invocation_params
978         """The parameters with which pytest was invoked.
979 
980         :type: InvocationParams
981         """
982 
983         _a = FILE_OR_DIR
984         self._parser = Parser(
985             usage=f"%(prog)s [options] [{_a}] [{_a}] [...]",
986             processopt=self._processopt,
987             _ispytest=True,
988         )
989         self.pluginmanager = pluginmanager
990         """The plugin manager handles plugin registration and hook invocation.
991 
992         :type: PytestPluginManager
993         """
994 
995         self.stash = Stash()
996         """A place where plugins can store information on the config for their
997         own use.
998 
999         :type: Stash
1000         """
1001         # Deprecated alias. Was never public. Can be removed in a few releases.
1002         self._store = self.stash
1003 
1004         from .compat import PathAwareHookProxy
1005 
1006         self.trace = self.pluginmanager.trace.root.get("config")
1007         self.hook = PathAwareHookProxy(self.pluginmanager.hook)
1008         self._inicache: Dict[str, Any] = {}
1009         self._override_ini: Sequence[str] = ()
1010         self._opt2dest: Dict[str, str] = {}
1011         self._cleanup: List[Callable[[], None]] = []
1012         self.pluginmanager.register(self, "pytestconfig")
1013         self._configured = False
1014         self.hook.pytest_addoption.call_historic(
1015             kwargs=dict(parser=self._parser, pluginmanager=self.pluginmanager)
1016         )
1017         self.args_source = Config.ArgsSource.ARGS
1018         self.args: List[str] = []
1019 
1020         if TYPE_CHECKING:
1021             from _pytest.cacheprovider import Cache
1022 
1023             self.cache: Optional[Cache] = None
1024 
1025     @property
1026     def rootpath(self) -> Path:
1027         """The path to the :ref:`rootdir <rootdir>`.
1028 
1029         :type: pathlib.Path
1030 
1031         .. versionadded:: 6.1
1032         """
1033         return self._rootpath
1034 
1035     @property
1036     def inipath(self) -> Optional[Path]:
1037         """The path to the :ref:`configfile <configfiles>`.
1038 
1039         :type: Optional[pathlib.Path]
1040 
1041         .. versionadded:: 6.1
1042         """
1043         return self._inipath
1044 
1045     def add_cleanup(self, func: Callable[[], None]) -> None:
1046         """Add a function to be called when the config object gets out of
1047         use (usually coinciding with pytest_unconfigure)."""
1048         self._cleanup.append(func)
1049 
1050     def _do_configure(self) -> None:
1051         assert not self._configured
1052         self._configured = True
1053         with warnings.catch_warnings():
1054             warnings.simplefilter("default")
1055             self.hook.pytest_configure.call_historic(kwargs=dict(config=self))
1056 
1057     def _ensure_unconfigure(self) -> None:
1058         if self._configured:
1059             self._configured = False
1060             self.hook.pytest_unconfigure(config=self)
1061             self.hook.pytest_configure._call_history = []
1062         while self._cleanup:
1063             fin = self._cleanup.pop()
1064             fin()
1065 
1066     def get_terminal_writer(self) -> TerminalWriter:
1067         terminalreporter: TerminalReporter = self.pluginmanager.get_plugin(
1068             "terminalreporter"
1069         )
1070         return terminalreporter._tw
1071 
1072     def pytest_cmdline_parse(
1073         self, pluginmanager: PytestPluginManager, args: List[str]
1074     ) -> "Config":
1075         try:
1076             self.parse(args)
1077         except UsageError:
1078             # Handle --version and --help here in a minimal fashion.
1079             # This gets done via helpconfig normally, but its
1080             # pytest_cmdline_main is not called in case of errors.
1081             if getattr(self.option, "version", False) or "--version" in args:
1082                 from _pytest.helpconfig import showversion
1083 
1084                 showversion(self)
1085             elif (
1086                 getattr(self.option, "help", False) or "--help" in args or "-h" in args
1087             ):
1088                 self._parser._getparser().print_help()
1089                 sys.stdout.write(
1090                     "\nNOTE: displaying only minimal help due to UsageError.\n\n"
1091                 )
1092 
1093             raise
1094 
1095         return self
1096 
1097     def notify_exception(
1098         self,
1099         excinfo: ExceptionInfo[BaseException],
1100         option: Optional[argparse.Namespace] = None,
1101     ) -> None:
1102         if option and getattr(option, "fulltrace", False):
1103             style: _TracebackStyle = "long"
1104         else:
1105             style = "native"
1106         excrepr = excinfo.getrepr(
1107             funcargs=True, showlocals=getattr(option, "showlocals", False), style=style
1108         )
1109         res = self.hook.pytest_internalerror(excrepr=excrepr, excinfo=excinfo)
1110         if not any(res):
1111             for line in str(excrepr).split("\n"):
1112                 sys.stderr.write("INTERNALERROR> %s\n" % line)
1113                 sys.stderr.flush()
1114 
1115     def cwd_relative_nodeid(self, nodeid: str) -> str:
1116         # nodeid's are relative to the rootpath, compute relative to cwd.
1117         if self.invocation_params.dir != self.rootpath:
1118             fullpath = self.rootpath / nodeid
1119             nodeid = bestrelpath(self.invocation_params.dir, fullpath)
1120         return nodeid
1121 
1122     @classmethod
1123     def fromdictargs(cls, option_dict, args) -> "Config":
1124         """Constructor usable for subprocesses."""
1125         config = get_config(args)
1126         config.option.__dict__.update(option_dict)
1127         config.parse(args, addopts=False)
1128         for x in config.option.plugins:
1129             config.pluginmanager.consider_pluginarg(x)
1130         return config
1131 
1132     def _processopt(self, opt: "Argument") -> None:
1133         for name in opt._short_opts + opt._long_opts:
1134             self._opt2dest[name] = opt.dest
1135 
1136         if hasattr(opt, "default"):
1137             if not hasattr(self.option, opt.dest):
1138                 setattr(self.option, opt.dest, opt.default)
1139 
1140     @hookimpl(trylast=True)
1141     def pytest_load_initial_conftests(self, early_config: "Config") -> None:
1142         # We haven't fully parsed the command line arguments yet, so
1143         # early_config.args it not set yet. But we need it for
1144         # discovering the initial conftests. So "pre-run" the logic here.
1145         # It will be done for real in `parse()`.
1146         args, args_source = early_config._decide_args(
1147             args=early_config.known_args_namespace.file_or_dir,
1148             pyargs=early_config.known_args_namespace.pyargs,
1149             testpaths=early_config.getini("testpaths"),
1150             invocation_dir=early_config.invocation_params.dir,
1151             rootpath=early_config.rootpath,
1152             warn=False,
1153         )
1154         self.pluginmanager._set_initial_conftests(
1155             args=args,
1156             pyargs=early_config.known_args_namespace.pyargs,
1157             noconftest=early_config.known_args_namespace.noconftest,
1158             rootpath=early_config.rootpath,
1159             confcutdir=early_config.known_args_namespace.confcutdir,
1160             importmode=early_config.known_args_namespace.importmode,
1161         )
1162 
1163     def _initini(self, args: Sequence[str]) -> None:
1164         ns, unknown_args = self._parser.parse_known_and_unknown_args(
1165             args, namespace=copy.copy(self.option)
1166         )
1167         rootpath, inipath, inicfg = determine_setup(
1168             ns.inifilename,
1169             ns.file_or_dir + unknown_args,
1170             rootdir_cmd_arg=ns.rootdir or None,
1171             config=self,
1172         )
1173         self._rootpath = rootpath
1174         self._inipath = inipath
1175         self.inicfg = inicfg
1176         self._parser.extra_info["rootdir"] = str(self.rootpath)
1177         self._parser.extra_info["inifile"] = str(self.inipath)
1178         self._parser.addini("addopts", "Extra command line options", "args")
1179         self._parser.addini("minversion", "Minimally required pytest version")
1180         self._parser.addini(
1181             "required_plugins",
1182             "Plugins that must be present for pytest to run",
1183             type="args",
1184             default=[],
1185         )
1186         self._override_ini = ns.override_ini or ()
1187 
1188     def _consider_importhook(self, args: Sequence[str]) -> None:
1189         """Install the PEP 302 import hook if using assertion rewriting.
1190 
1191         Needs to parse the --assert=<mode> option from the commandline
1192         and find all the installed plugins to mark them for rewriting
1193         by the importhook.
1194         """
1195         ns, unknown_args = self._parser.parse_known_and_unknown_args(args)
1196         mode = getattr(ns, "assertmode", "plain")
1197         if mode == "rewrite":
1198             import _pytest.assertion
1199 
1200             try:
1201                 hook = _pytest.assertion.install_importhook(self)
1202             except SystemError:
1203                 mode = "plain"
1204             else:
1205                 self._mark_plugins_for_rewrite(hook)
1206         self._warn_about_missing_assertion(mode)
1207 
1208     def _mark_plugins_for_rewrite(self, hook) -> None:
1209         """Given an importhook, mark for rewrite any top-level
1210         modules or packages in the distribution package for
1211         all pytest plugins."""
1212         self.pluginmanager.rewrite_hook = hook
1213 
1214         if os.environ.get("PYTEST_DISABLE_PLUGIN_AUTOLOAD"):
1215             # We don't autoload from setuptools entry points, no need to continue.
1216             return
1217 
1218         package_files = (
1219             str(file)
1220             for dist in importlib.metadata.distributions()
1221             if any(ep.group == "pytest11" for ep in dist.entry_points)
1222             for file in dist.files or []
1223         )
1224 
1225         for name in _iter_rewritable_modules(package_files):
1226             hook.mark_rewrite(name)
1227 
1228     def _validate_args(self, args: List[str], via: str) -> List[str]:
1229         """Validate known args."""
1230         self._parser._config_source_hint = via  # type: ignore
1231         try:
1232             self._parser.parse_known_and_unknown_args(
1233                 args, namespace=copy.copy(self.option)
1234             )
1235         finally:
1236             del self._parser._config_source_hint  # type: ignore
1237 
1238         return args
1239 
1240     def _decide_args(
1241         self,
1242         *,
1243         args: List[str],
1244         pyargs: List[str],
1245         testpaths: List[str],
1246         invocation_dir: Path,
1247         rootpath: Path,
1248         warn: bool,
1249     ) -> Tuple[List[str], ArgsSource]:
1250         """Decide the args (initial paths/nodeids) to use given the relevant inputs.
1251 
1252         :param warn: Whether can issue warnings.
1253         """
1254         if args:
1255             source = Config.ArgsSource.ARGS
1256             result = args
1257         else:
1258             if invocation_dir == rootpath:
1259                 source = Config.ArgsSource.TESTPATHS
1260                 if pyargs:
1261                     result = testpaths
1262                 else:
1263                     result = []
1264                     for path in testpaths:
1265                         result.extend(sorted(glob.iglob(path, recursive=True)))
1266                     if testpaths and not result:
1267                         if warn:
1268                             warning_text = (
1269                                 "No files were found in testpaths; "
1270                                 "consider removing or adjusting your testpaths configuration. "
1271                                 "Searching recursively from the current directory instead."
1272                             )
1273                             self.issue_config_time_warning(
1274                                 PytestConfigWarning(warning_text), stacklevel=3
1275                             )
1276             else:
1277                 result = []
1278             if not result:
1279                 source = Config.ArgsSource.INCOVATION_DIR
1280                 result = [str(invocation_dir)]
1281         return result, source
1282 
1283     def _preparse(self, args: List[str], addopts: bool = True) -> None:
1284         if addopts:
1285             env_addopts = os.environ.get("PYTEST_ADDOPTS", "")
1286             if len(env_addopts):
1287                 args[:] = (
1288                     self._validate_args(shlex.split(env_addopts), "via PYTEST_ADDOPTS")
1289                     + args
1290                 )
1291         self._initini(args)
1292         if addopts:
1293             args[:] = (
1294                 self._validate_args(self.getini("addopts"), "via addopts config") + args
1295             )
1296 
1297         self.known_args_namespace = self._parser.parse_known_args(
1298             args, namespace=copy.copy(self.option)
1299         )
1300         self._checkversion()
1301         self._consider_importhook(args)
1302         self.pluginmanager.consider_preparse(args, exclude_only=False)
1303         if not os.environ.get("PYTEST_DISABLE_PLUGIN_AUTOLOAD"):
1304             # Don't autoload from setuptools entry point. Only explicitly specified
1305             # plugins are going to be loaded.
1306             self.pluginmanager.load_setuptools_entrypoints("pytest11")
1307         self.pluginmanager.consider_env()
1308 
1309         self.known_args_namespace = self._parser.parse_known_args(
1310             args, namespace=copy.copy(self.known_args_namespace)
1311         )
1312 
1313         self._validate_plugins()
1314         self._warn_about_skipped_plugins()
1315 
1316         if self.known_args_namespace.strict:
1317             self.issue_config_time_warning(
1318                 _pytest.deprecated.STRICT_OPTION, stacklevel=2
1319             )
1320 
1321         if self.known_args_namespace.confcutdir is None:
1322             if self.inipath is not None:
1323                 confcutdir = str(self.inipath.parent)
1324             else:
1325                 confcutdir = str(self.rootpath)
1326             self.known_args_namespace.confcutdir = confcutdir
1327         try:
1328             self.hook.pytest_load_initial_conftests(
1329                 early_config=self, args=args, parser=self._parser
1330             )
1331         except ConftestImportFailure as e:
1332             if self.known_args_namespace.help or self.known_args_namespace.version:
1333                 # we don't want to prevent --help/--version to work
1334                 # so just let is pass and print a warning at the end
1335                 self.issue_config_time_warning(
1336                     PytestConfigWarning(f"could not load initial conftests: {e.path}"),
1337                     stacklevel=2,
1338                 )
1339             else:
1340                 raise
1341 
1342     @hookimpl(hookwrapper=True)
1343     def pytest_collection(self) -> Generator[None, None, None]:
1344         # Validate invalid ini keys after collection is done so we take in account
1345         # options added by late-loading conftest files.
1346         yield
1347         self._validate_config_options()
1348 
1349     def _checkversion(self) -> None:
1350         import pytest
1351 
1352         minver = self.inicfg.get("minversion", None)
1353         if minver:
1354             # Imported lazily to improve start-up time.
1355             from packaging.version import Version
1356 
1357             if not isinstance(minver, str):
1358                 raise pytest.UsageError(
1359                     "%s: 'minversion' must be a single value" % self.inipath
1360                 )
1361 
1362             if Version(minver) > Version(pytest.__version__):
1363                 raise pytest.UsageError(
1364                     "%s: 'minversion' requires pytest-%s, actual pytest-%s'"
1365                     % (
1366                         self.inipath,
1367                         minver,
1368                         pytest.__version__,
1369                     )
1370                 )
1371 
1372     def _validate_config_options(self) -> None:
1373         for key in sorted(self._get_unknown_ini_keys()):
1374             self._warn_or_fail_if_strict(f"Unknown config option: {key}\n")
1375 
1376     def _validate_plugins(self) -> None:
1377         required_plugins = sorted(self.getini("required_plugins"))
1378         if not required_plugins:
1379             return
1380 
1381         # Imported lazily to improve start-up time.
1382         from packaging.version import Version
1383         from packaging.requirements import InvalidRequirement, Requirement
1384 
1385         plugin_info = self.pluginmanager.list_plugin_distinfo()
1386         plugin_dist_info = {dist.project_name: dist.version for _, dist in plugin_info}
1387 
1388         missing_plugins = []
1389         for required_plugin in required_plugins:
1390             try:
1391                 req = Requirement(required_plugin)
1392             except InvalidRequirement:
1393                 missing_plugins.append(required_plugin)
1394                 continue
1395 
1396             if req.name not in plugin_dist_info:
1397                 missing_plugins.append(required_plugin)
1398             elif not req.specifier.contains(
1399                 Version(plugin_dist_info[req.name]), prereleases=True
1400             ):
1401                 missing_plugins.append(required_plugin)
1402 
1403         if missing_plugins:
1404             raise UsageError(
1405                 "Missing required plugins: {}".format(", ".join(missing_plugins)),
1406             )
1407 
1408     def _warn_or_fail_if_strict(self, message: str) -> None:
1409         if self.known_args_namespace.strict_config:
1410             raise UsageError(message)
1411 
1412         self.issue_config_time_warning(PytestConfigWarning(message), stacklevel=3)
1413 
1414     def _get_unknown_ini_keys(self) -> List[str]:
1415         parser_inicfg = self._parser._inidict
1416         return [name for name in self.inicfg if name not in parser_inicfg]
1417 
1418     def parse(self, args: List[str], addopts: bool = True) -> None:
1419         # Parse given cmdline arguments into this config object.
1420         assert (
1421             self.args == []
1422         ), "can only parse cmdline args at most once per Config object"
1423         self.hook.pytest_addhooks.call_historic(
1424             kwargs=dict(pluginmanager=self.pluginmanager)
1425         )
1426         self._preparse(args, addopts=addopts)
1427         # XXX deprecated hook:
1428         self.hook.pytest_cmdline_preparse(config=self, args=args)
1429         self._parser.after_preparse = True  # type: ignore
1430         try:
1431             args = self._parser.parse_setoption(
1432                 args, self.option, namespace=self.option
1433             )
1434             self.args, self.args_source = self._decide_args(
1435                 args=args,
1436                 pyargs=self.known_args_namespace.pyargs,
1437                 testpaths=self.getini("testpaths"),
1438                 invocation_dir=self.invocation_params.dir,
1439                 rootpath=self.rootpath,
1440                 warn=True,
1441             )
1442         except PrintHelp:
1443             pass
1444 
1445     def issue_config_time_warning(self, warning: Warning, stacklevel: int) -> None:
1446         """Issue and handle a warning during the "configure" stage.
1447 
1448         During ``pytest_configure`` we can't capture warnings using the ``catch_warnings_for_item``
1449         function because it is not possible to have hookwrappers around ``pytest_configure``.
1450 
1451         This function is mainly intended for plugins that need to issue warnings during
1452         ``pytest_configure`` (or similar stages).
1453 
1454         :param warning: The warning instance.
1455         :param stacklevel: stacklevel forwarded to warnings.warn.
1456         """
1457         if self.pluginmanager.is_blocked("warnings"):
1458             return
1459 
1460         cmdline_filters = self.known_args_namespace.pythonwarnings or []
1461         config_filters = self.getini("filterwarnings")
1462 
1463         with warnings.catch_warnings(record=True) as records:
1464             warnings.simplefilter("always", type(warning))
1465             apply_warning_filters(config_filters, cmdline_filters)
1466             warnings.warn(warning, stacklevel=stacklevel)
1467 
1468         if records:
1469             frame = sys._getframe(stacklevel - 1)
1470             location = frame.f_code.co_filename, frame.f_lineno, frame.f_code.co_name
1471             self.hook.pytest_warning_recorded.call_historic(
1472                 kwargs=dict(
1473                     warning_message=records[0],
1474                     when="config",
1475                     nodeid="",
1476                     location=location,
1477                 )
1478             )
1479 
1480     def addinivalue_line(self, name: str, line: str) -> None:
1481         """Add a line to an ini-file option. The option must have been
1482         declared but might not yet be set in which case the line becomes
1483         the first line in its value."""
1484         x = self.getini(name)
1485         assert isinstance(x, list)
1486         x.append(line)  # modifies the cached list inline
1487 
1488     def getini(self, name: str):
1489         """Return configuration value from an :ref:`ini file <configfiles>`.
1490 
1491         If the specified name hasn't been registered through a prior
1492         :func:`parser.addini <pytest.Parser.addini>` call (usually from a
1493         plugin), a ValueError is raised.
1494         """
1495         try:
1496             return self._inicache[name]
1497         except KeyError:
1498             self._inicache[name] = val = self._getini(name)
1499             return val
1500 
1501     # Meant for easy monkeypatching by legacypath plugin.
1502     # Can be inlined back (with no cover removed) once legacypath is gone.
1503     def _getini_unknown_type(self, name: str, type: str, value: Union[str, List[str]]):
1504         msg = f"unknown configuration type: {type}"
1505         raise ValueError(msg, value)  # pragma: no cover
1506 
1507     def _getini(self, name: str):
1508         try:
1509             description, type, default = self._parser._inidict[name]
1510         except KeyError as e:
1511             raise ValueError(f"unknown configuration value: {name!r}") from e
1512         override_value = self._get_override_ini_value(name)
1513         if override_value is None:
1514             try:
1515                 value = self.inicfg[name]
1516             except KeyError:
1517                 if default is not None:
1518                     return default
1519                 if type is None:
1520                     return ""
1521                 return []
1522         else:
1523             value = override_value
1524         # Coerce the values based on types.
1525         #
1526         # Note: some coercions are only required if we are reading from .ini files, because
1527         # the file format doesn't contain type information, but when reading from toml we will
1528         # get either str or list of str values (see _parse_ini_config_from_pyproject_toml).
1529         # For example:
1530         #
1531         #   ini:
1532         #     a_line_list = "tests acceptance"
1533         #   in this case, we need to split the string to obtain a list of strings.
1534         #
1535         #   toml:
1536         #     a_line_list = ["tests", "acceptance"]
1537         #   in this case, we already have a list ready to use.
1538         #
1539         if type == "paths":
1540             # TODO: This assert is probably not valid in all cases.
1541             assert self.inipath is not None
1542             dp = self.inipath.parent
1543             input_values = shlex.split(value) if isinstance(value, str) else value
1544             return [dp / x for x in input_values]
1545         elif type == "args":
1546             return shlex.split(value) if isinstance(value, str) else value
1547         elif type == "linelist":
1548             if isinstance(value, str):
1549                 return [t for t in map(lambda x: x.strip(), value.split("\n")) if t]
1550             else:
1551                 return value
1552         elif type == "bool":
1553             return _strtobool(str(value).strip())
1554         elif type == "string":
1555             return value
1556         elif type is None:
1557             return value
1558         else:
1559             return self._getini_unknown_type(name, type, value)
1560 
1561     def _getconftest_pathlist(
1562         self, name: str, path: Path, rootpath: Path
1563     ) -> Optional[List[Path]]:
1564         try:
1565             mod, relroots = self.pluginmanager._rget_with_confmod(
1566                 name, path, self.getoption("importmode"), rootpath
1567             )
1568         except KeyError:
1569             return None
1570         assert mod.__file__ is not None
1571         modpath = Path(mod.__file__).parent
1572         values: List[Path] = []
1573         for relroot in relroots:
1574             if isinstance(relroot, os.PathLike):
1575                 relroot = Path(relroot)
1576             else:
1577                 relroot = relroot.replace("/", os.sep)
1578                 relroot = absolutepath(modpath / relroot)
1579             values.append(relroot)
1580         return values
1581 
1582     def _get_override_ini_value(self, name: str) -> Optional[str]:
1583         value = None
1584         # override_ini is a list of "ini=value" options.
1585         # Always use the last item if multiple values are set for same ini-name,
1586         # e.g. -o foo=bar1 -o foo=bar2 will set foo to bar2.
1587         for ini_config in self._override_ini:
1588             try:
1589                 key, user_ini_value = ini_config.split("=", 1)
1590             except ValueError as e:
1591                 raise UsageError(
1592                     "-o/--override-ini expects option=value style (got: {!r}).".format(
1593                         ini_config
1594                     )
1595                 ) from e
1596             else:
1597                 if key == name:
1598                     value = user_ini_value
1599         return value
1600 
1601     def getoption(self, name: str, default=notset, skip: bool = False):
1602         """Return command line option value.
1603 
1604         :param name: Name of the option.  You may also specify
1605             the literal ``--OPT`` option instead of the "dest" option name.
1606         :param default: Default value if no option of that name exists.
1607         :param skip: If True, raise pytest.skip if option does not exists
1608             or has a None value.
1609         """
1610         name = self._opt2dest.get(name, name)
1611         try:
1612             val = getattr(self.option, name)
1613             if val is None and skip:
1614                 raise AttributeError(name)
1615             return val
1616         except AttributeError as e:
1617             if default is not notset:
1618                 return default
1619             if skip:
1620                 import pytest
1621 
1622                 pytest.skip(f"no {name!r} option found")
1623             raise ValueError(f"no option named {name!r}") from e
1624 
1625     def getvalue(self, name: str, path=None):
1626         """Deprecated, use getoption() instead."""
1627         return self.getoption(name)
1628 
1629     def getvalueorskip(self, name: str, path=None):
1630         """Deprecated, use getoption(skip=True) instead."""
1631         return self.getoption(name, skip=True)
1632 
1633     def _warn_about_missing_assertion(self, mode: str) -> None:
1634         if not _assertion_supported():
1635             if mode == "plain":
1636                 warning_text = (
1637                     "ASSERTIONS ARE NOT EXECUTED"
1638                     " and FAILING TESTS WILL PASS.  Are you"
1639                     " using python -O?"
1640                 )
1641             else:
1642                 warning_text = (
1643                     "assertions not in test modules or"
1644                     " plugins will be ignored"
1645                     " because assert statements are not executed "
1646                     "by the underlying Python interpreter "
1647                     "(are you using python -O?)\n"
1648                 )
1649             self.issue_config_time_warning(
1650                 PytestConfigWarning(warning_text),
1651                 stacklevel=3,
1652             )
1653 
1654     def _warn_about_skipped_plugins(self) -> None:
1655         for module_name, msg in self.pluginmanager.skipped_plugins:
1656             self.issue_config_time_warning(
1657                 PytestConfigWarning(f"skipped plugin {module_name!r}: {msg}"),
1658                 stacklevel=2,
1659             )
1660 
1661 
1662 def _assertion_supported() -> bool:
1663     try:
1664         assert False
1665     except AssertionError:
1666         return True
1667     else:
1668         return False  # type: ignore[unreachable]
1669 
1670 
1671 def create_terminal_writer(
1672     config: Config, file: Optional[TextIO] = None
1673 ) -> TerminalWriter:
1674     """Create a TerminalWriter instance configured according to the options
1675     in the config object.
1676 
1677     Every code which requires a TerminalWriter object and has access to a
1678     config object should use this function.
1679     """
1680     tw = TerminalWriter(file=file)
1681 
1682     if config.option.color == "yes":
1683         tw.hasmarkup = True
1684     elif config.option.color == "no":
1685         tw.hasmarkup = False
1686 
1687     if config.option.code_highlight == "yes":
1688         tw.code_highlight = True
1689     elif config.option.code_highlight == "no":
1690         tw.code_highlight = False
1691 
1692     return tw
1693 
1694 
1695 def _strtobool(val: str) -> bool:
1696     """Convert a string representation of truth to True or False.
1697 
1698     True values are 'y', 'yes', 't', 'true', 'on', and '1'; false values
1699     are 'n', 'no', 'f', 'false', 'off', and '0'.  Raises ValueError if
1700     'val' is anything else.
1701 
1702     .. note:: Copied from distutils.util.
1703     """
1704     val = val.lower()
1705     if val in ("y", "yes", "t", "true", "on", "1"):
1706         return True
1707     elif val in ("n", "no", "f", "false", "off", "0"):
1708         return False
1709     else:
1710         raise ValueError(f"invalid truth value {val!r}")
1711 
1712 
1713 @lru_cache(maxsize=50)
1714 def parse_warning_filter(
1715     arg: str, *, escape: bool
1716 ) -> Tuple["warnings._ActionKind", str, Type[Warning], str, int]:
1717     """Parse a warnings filter string.
1718 
1719     This is copied from warnings._setoption with the following changes:
1720 
1721     * Does not apply the filter.
1722     * Escaping is optional.
1723     * Raises UsageError so we get nice error messages on failure.
1724     """
1725     __tracebackhide__ = True
1726     error_template = dedent(
1727         f"""\
1728         while parsing the following warning configuration:
1729 
1730           {arg}
1731 
1732         This error occurred:
1733 
1734         {{error}}
1735         """
1736     )
1737 
1738     parts = arg.split(":")
1739     if len(parts) > 5:
1740         doc_url = (
1741             "https://docs.python.org/3/library/warnings.html#describing-warning-filters"
1742         )
1743         error = dedent(
1744             f"""\
1745             Too many fields ({len(parts)}), expected at most 5 separated by colons:
1746 
1747               action:message:category:module:line
1748 
1749             For more information please consult: {doc_url}
1750             """
1751         )
1752         raise UsageError(error_template.format(error=error))
1753 
1754     while len(parts) < 5:
1755         parts.append("")
1756     action_, message, category_, module, lineno_ = (s.strip() for s in parts)
1757     try:
1758         action: "warnings._ActionKind" = warnings._getaction(action_)  # type: ignore[attr-defined]
1759     except warnings._OptionError as e:
1760         raise UsageError(error_template.format(error=str(e)))
1761     try:
1762         category: Type[Warning] = _resolve_warning_category(category_)
1763     except Exception:
1764         exc_info = ExceptionInfo.from_current()
1765         exception_text = exc_info.getrepr(style="native")
1766         raise UsageError(error_template.format(error=exception_text))
1767     if message and escape:
1768         message = re.escape(message)
1769     if module and escape:
1770         module = re.escape(module) + r"\Z"
1771     if lineno_:
1772         try:
1773             lineno = int(lineno_)
1774             if lineno < 0:
1775                 raise ValueError("number is negative")
1776         except ValueError as e:
1777             raise UsageError(
1778                 error_template.format(error=f"invalid lineno {lineno_!r}: {e}")
1779             )
1780     else:
1781         lineno = 0
1782     return action, message, category, module, lineno
1783 
1784 
1785 def _resolve_warning_category(category: str) -> Type[Warning]:
1786     """
1787     Copied from warnings._getcategory, but changed so it lets exceptions (specially ImportErrors)
1788     propagate so we can get access to their tracebacks (#9218).
1789     """
1790     __tracebackhide__ = True
1791     if not category:
1792         return Warning
1793 
1794     if "." not in category:
1795         import builtins as m
1796 
1797         klass = category
1798     else:
1799         module, _, klass = category.rpartition(".")
1800         m = __import__(module, None, None, [klass])
1801     cat = getattr(m, klass)
1802     if not issubclass(cat, Warning):
1803         raise UsageError(f"{cat} is not a Warning subclass")
1804     return cast(Type[Warning], cat)
1805 
1806 
1807 def apply_warning_filters(
1808     config_filters: Iterable[str], cmdline_filters: Iterable[str]
1809 ) -> None:
1810     """Applies pytest-configured filters to the warnings module"""
1811     # Filters should have this precedence: cmdline options, config.
1812     # Filters should be applied in the inverse order of precedence.
1813     for arg in config_filters:
1814         warnings.filterwarnings(*parse_warning_filter(arg, escape=False))
1815 
1816     for arg in cmdline_filters:
1817         warnings.filterwarnings(*parse_warning_filter(arg, escape=True))

</code><intended_behavior>Ensure that when modules are loaded, particularly those related to `pmxbot`, they are loaded in a manner that recognizes and respects the PEP 420 namespace packages, preventing duplicate instances. This may involve checking the configuration logic to ensure it does not inadvertently cause a module to be re-imported or re-initialized in a manner that creates two separate instances of what should be a single module in `sys.modules`.</intended_behavior>, <file>src/_pytest/pathlib.py</file>
<class>None</class>
<method>None</method>
<code>
1 import atexit
2 import contextlib
3 import fnmatch
4 import importlib.util
5 import itertools
6 import os
7 import shutil
8 import sys
9 import types
10 import uuid
11 import warnings
12 from enum import Enum
13 from errno import EBADF
14 from errno import ELOOP
15 from errno import ENOENT
16 from errno import ENOTDIR
17 from functools import partial
18 from os.path import expanduser
19 from os.path import expandvars
20 from os.path import isabs
21 from os.path import sep
22 from pathlib import Path
23 from pathlib import PurePath
24 from posixpath import sep as posix_sep
25 from types import ModuleType
26 from typing import Callable
27 from typing import Dict
28 from typing import Iterable
29 from typing import Iterator
30 from typing import List
31 from typing import Optional
32 from typing import Set
33 from typing import Tuple
34 from typing import Type
35 from typing import TypeVar
36 from typing import Union
37 
38 from _pytest.compat import assert_never
39 from _pytest.outcomes import skip
40 from _pytest.warning_types import PytestWarning
41 
42 LOCK_TIMEOUT = 60 * 60 * 24 * 3
43 
44 
45 _AnyPurePath = TypeVar("_AnyPurePath", bound=PurePath)
46 
47 # The following function, variables and comments were
48 # copied from cpython 3.9 Lib/pathlib.py file.
49 
50 # EBADF - guard against macOS `stat` throwing EBADF
51 _IGNORED_ERRORS = (ENOENT, ENOTDIR, EBADF, ELOOP)
52 
53 _IGNORED_WINERRORS = (
54     21,  # ERROR_NOT_READY - drive exists but is not accessible
55     1921,  # ERROR_CANT_RESOLVE_FILENAME - fix for broken symlink pointing to itself
56 )
57 
58 
59 def _ignore_error(exception):
60     return (
61         getattr(exception, "errno", None) in _IGNORED_ERRORS
62         or getattr(exception, "winerror", None) in _IGNORED_WINERRORS
63     )
64 
65 
66 def get_lock_path(path: _AnyPurePath) -> _AnyPurePath:
67     return path.joinpath(".lock")
68 
69 
70 def on_rm_rf_error(
71     func,
72     path: str,
73     excinfo: Union[
74         BaseException,
75         Tuple[Type[BaseException], BaseException, Optional[types.TracebackType]],
76     ],
77     *,
78     start_path: Path,
79 ) -> bool:
80     """Handle known read-only errors during rmtree.
81 
82     The returned value is used only by our own tests.
83     """
84     if isinstance(excinfo, BaseException):
85         exc = excinfo
86     else:
87         exc = excinfo[1]
88 
89     # Another process removed the file in the middle of the "rm_rf" (xdist for example).
90     # More context: https://github.com/pytest-dev/pytest/issues/5974#issuecomment-543799018
91     if isinstance(exc, FileNotFoundError):
92         return False
93 
94     if not isinstance(exc, PermissionError):
95         warnings.warn(
96             PytestWarning(f"(rm_rf) error removing {path}\n{type(exc)}: {exc}")
97         )
98         return False
99 
100     if func not in (os.rmdir, os.remove, os.unlink):
101         if func not in (os.open,):
102             warnings.warn(
103                 PytestWarning(
104                     "(rm_rf) unknown function {} when removing {}:\n{}: {}".format(
105                         func, path, type(exc), exc
106                     )
107                 )
108             )
109         return False
110 
111     # Chmod + retry.
112     import stat
113 
114     def chmod_rw(p: str) -> None:
115         mode = os.stat(p).st_mode
116         os.chmod(p, mode | stat.S_IRUSR | stat.S_IWUSR)
117 
118     # For files, we need to recursively go upwards in the directories to
119     # ensure they all are also writable.
120     p = Path(path)
121     if p.is_file():
122         for parent in p.parents:
123             chmod_rw(str(parent))
124             # Stop when we reach the original path passed to rm_rf.
125             if parent == start_path:
126                 break
127     chmod_rw(str(path))
128 
129     func(path)
130     return True
131 
132 
133 def ensure_extended_length_path(path: Path) -> Path:
134     """Get the extended-length version of a path (Windows).
135 
136     On Windows, by default, the maximum length of a path (MAX_PATH) is 260
137     characters, and operations on paths longer than that fail. But it is possible
138     to overcome this by converting the path to "extended-length" form before
139     performing the operation:
140     https://docs.microsoft.com/en-us/windows/win32/fileio/naming-a-file#maximum-path-length-limitation
141 
142     On Windows, this function returns the extended-length absolute version of path.
143     On other platforms it returns path unchanged.
144     """
145     if sys.platform.startswith("win32"):
146         path = path.resolve()
147         path = Path(get_extended_length_path_str(str(path)))
148     return path
149 
150 
151 def get_extended_length_path_str(path: str) -> str:
152     """Convert a path to a Windows extended length path."""
153     long_path_prefix = "\\\\?\\"
154     unc_long_path_prefix = "\\\\?\\UNC\\"
155     if path.startswith((long_path_prefix, unc_long_path_prefix)):
156         return path
157     # UNC
158     if path.startswith("\\\\"):
159         return unc_long_path_prefix + path[2:]
160     return long_path_prefix + path
161 
162 
163 def rm_rf(path: Path) -> None:
164     """Remove the path contents recursively, even if some elements
165     are read-only."""
166     path = ensure_extended_length_path(path)
167     onerror = partial(on_rm_rf_error, start_path=path)
168     if sys.version_info >= (3, 12):
169         shutil.rmtree(str(path), onexc=onerror)
170     else:
171         shutil.rmtree(str(path), onerror=onerror)
172 
173 
174 def find_prefixed(root: Path, prefix: str) -> Iterator[Path]:
175     """Find all elements in root that begin with the prefix, case insensitive."""
176     l_prefix = prefix.lower()
177     for x in root.iterdir():
178         if x.name.lower().startswith(l_prefix):
179             yield x
180 
181 
182 def extract_suffixes(iter: Iterable[PurePath], prefix: str) -> Iterator[str]:
183     """Return the parts of the paths following the prefix.
184 
185     :param iter: Iterator over path names.
186     :param prefix: Expected prefix of the path names.
187     """
188     p_len = len(prefix)
189     for p in iter:
190         yield p.name[p_len:]
191 
192 
193 def find_suffixes(root: Path, prefix: str) -> Iterator[str]:
194     """Combine find_prefixes and extract_suffixes."""
195     return extract_suffixes(find_prefixed(root, prefix), prefix)
196 
197 
198 def parse_num(maybe_num) -> int:
199     """Parse number path suffixes, returns -1 on error."""
200     try:
201         return int(maybe_num)
202     except ValueError:
203         return -1
204 
205 
206 def _force_symlink(
207     root: Path, target: Union[str, PurePath], link_to: Union[str, Path]
208 ) -> None:
209     """Helper to create the current symlink.
210 
211     It's full of race conditions that are reasonably OK to ignore
212     for the context of best effort linking to the latest test run.
213 
214     The presumption being that in case of much parallelism
215     the inaccuracy is going to be acceptable.
216     """
217     current_symlink = root.joinpath(target)
218     try:
219         current_symlink.unlink()
220     except OSError:
221         pass
222     try:
223         current_symlink.symlink_to(link_to)
224     except Exception:
225         pass
226 
227 
228 def make_numbered_dir(root: Path, prefix: str, mode: int = 0o700) -> Path:
229     """Create a directory with an increased number as suffix for the given prefix."""
230     for i in range(10):
231         # try up to 10 times to create the folder
232         max_existing = max(map(parse_num, find_suffixes(root, prefix)), default=-1)
233         new_number = max_existing + 1
234         new_path = root.joinpath(f"{prefix}{new_number}")
235         try:
236             new_path.mkdir(mode=mode)
237         except Exception:
238             pass
239         else:
240             _force_symlink(root, prefix + "current", new_path)
241             return new_path
242     else:
243         raise OSError(
244             "could not create numbered dir with prefix "
245             "{prefix} in {root} after 10 tries".format(prefix=prefix, root=root)
246         )
247 
248 
249 def create_cleanup_lock(p: Path) -> Path:
250     """Create a lock to prevent premature folder cleanup."""
251     lock_path = get_lock_path(p)
252     try:
253         fd = os.open(str(lock_path), os.O_WRONLY | os.O_CREAT | os.O_EXCL, 0o644)
254     except FileExistsError as e:
255         raise OSError(f"cannot create lockfile in {p}") from e
256     else:
257         pid = os.getpid()
258         spid = str(pid).encode()
259         os.write(fd, spid)
260         os.close(fd)
261         if not lock_path.is_file():
262             raise OSError("lock path got renamed after successful creation")
263         return lock_path
264 
265 
266 def register_cleanup_lock_removal(lock_path: Path, register=atexit.register):
267     """Register a cleanup function for removing a lock, by default on atexit."""
268     pid = os.getpid()
269 
270     def cleanup_on_exit(lock_path: Path = lock_path, original_pid: int = pid) -> None:
271         current_pid = os.getpid()
272         if current_pid != original_pid:
273             # fork
274             return
275         try:
276             lock_path.unlink()
277         except OSError:
278             pass
279 
280     return register(cleanup_on_exit)
281 
282 
283 def maybe_delete_a_numbered_dir(path: Path) -> None:
284     """Remove a numbered directory if its lock can be obtained and it does
285     not seem to be in use."""
286     path = ensure_extended_length_path(path)
287     lock_path = None
288     try:
289         lock_path = create_cleanup_lock(path)
290         parent = path.parent
291 
292         garbage = parent.joinpath(f"garbage-{uuid.uuid4()}")
293         path.rename(garbage)
294         rm_rf(garbage)
295     except OSError:
296         #  known races:
297         #  * other process did a cleanup at the same time
298         #  * deletable folder was found
299         #  * process cwd (Windows)
300         return
301     finally:
302         # If we created the lock, ensure we remove it even if we failed
303         # to properly remove the numbered dir.
304         if lock_path is not None:
305             try:
306                 lock_path.unlink()
307             except OSError:
308                 pass
309 
310 
311 def ensure_deletable(path: Path, consider_lock_dead_if_created_before: float) -> bool:
312     """Check if `path` is deletable based on whether the lock file is expired."""
313     if path.is_symlink():
314         return False
315     lock = get_lock_path(path)
316     try:
317         if not lock.is_file():
318             return True
319     except OSError:
320         # we might not have access to the lock file at all, in this case assume
321         # we don't have access to the entire directory (#7491).
322         return False
323     try:
324         lock_time = lock.stat().st_mtime
325     except Exception:
326         return False
327     else:
328         if lock_time < consider_lock_dead_if_created_before:
329             # We want to ignore any errors while trying to remove the lock such as:
330             # - PermissionDenied, like the file permissions have changed since the lock creation;
331             # - FileNotFoundError, in case another pytest process got here first;
332             # and any other cause of failure.
333             with contextlib.suppress(OSError):
334                 lock.unlink()
335                 return True
336         return False
337 
338 
339 def try_cleanup(path: Path, consider_lock_dead_if_created_before: float) -> None:
340     """Try to cleanup a folder if we can ensure it's deletable."""
341     if ensure_deletable(path, consider_lock_dead_if_created_before):
342         maybe_delete_a_numbered_dir(path)
343 
344 
345 def cleanup_candidates(root: Path, prefix: str, keep: int) -> Iterator[Path]:
346     """List candidates for numbered directories to be removed - follows py.path."""
347     max_existing = max(map(parse_num, find_suffixes(root, prefix)), default=-1)
348     max_delete = max_existing - keep
349     paths = find_prefixed(root, prefix)
350     paths, paths2 = itertools.tee(paths)
351     numbers = map(parse_num, extract_suffixes(paths2, prefix))
352     for path, number in zip(paths, numbers):
353         if number <= max_delete:
354             yield path
355 
356 
357 def cleanup_dead_symlinks(root: Path):
358     for left_dir in root.iterdir():
359         if left_dir.is_symlink():
360             if not left_dir.resolve().exists():
361                 left_dir.unlink()
362 
363 
364 def cleanup_numbered_dir(
365     root: Path, prefix: str, keep: int, consider_lock_dead_if_created_before: float
366 ) -> None:
367     """Cleanup for lock driven numbered directories."""
368     if not root.exists():
369         return
370     for path in cleanup_candidates(root, prefix, keep):
371         try_cleanup(path, consider_lock_dead_if_created_before)
372     for path in root.glob("garbage-*"):
373         try_cleanup(path, consider_lock_dead_if_created_before)
374 
375     cleanup_dead_symlinks(root)
376 
377 
378 def make_numbered_dir_with_cleanup(
379     root: Path,
380     prefix: str,
381     keep: int,
382     lock_timeout: float,
383     mode: int,
384 ) -> Path:
385     """Create a numbered dir with a cleanup lock and remove old ones."""
386     e = None
387     for i in range(10):
388         try:
389             p = make_numbered_dir(root, prefix, mode)
390             # Only lock the current dir when keep is not 0
391             if keep != 0:
392                 lock_path = create_cleanup_lock(p)
393                 register_cleanup_lock_removal(lock_path)
394         except Exception as exc:
395             e = exc
396         else:
397             consider_lock_dead_if_created_before = p.stat().st_mtime - lock_timeout
398             # Register a cleanup for program exit
399             atexit.register(
400                 cleanup_numbered_dir,
401                 root,
402                 prefix,
403                 keep,
404                 consider_lock_dead_if_created_before,
405             )
406             return p
407     assert e is not None
408     raise e
409 
410 
411 def resolve_from_str(input: str, rootpath: Path) -> Path:
412     input = expanduser(input)
413     input = expandvars(input)
414     if isabs(input):
415         return Path(input)
416     else:
417         return rootpath.joinpath(input)
418 
419 
420 def fnmatch_ex(pattern: str, path: Union[str, "os.PathLike[str]"]) -> bool:
421     """A port of FNMatcher from py.path.common which works with PurePath() instances.
422 
423     The difference between this algorithm and PurePath.match() is that the
424     latter matches "**" glob expressions for each part of the path, while
425     this algorithm uses the whole path instead.
426 
427     For example:
428         "tests/foo/bar/doc/test_foo.py" matches pattern "tests/**/doc/test*.py"
429         with this algorithm, but not with PurePath.match().
430 
431     This algorithm was ported to keep backward-compatibility with existing
432     settings which assume paths match according this logic.
433 
434     References:
435     * https://bugs.python.org/issue29249
436     * https://bugs.python.org/issue34731
437     """
438     path = PurePath(path)
439     iswin32 = sys.platform.startswith("win")
440 
441     if iswin32 and sep not in pattern and posix_sep in pattern:
442         # Running on Windows, the pattern has no Windows path separators,
443         # and the pattern has one or more Posix path separators. Replace
444         # the Posix path separators with the Windows path separator.
445         pattern = pattern.replace(posix_sep, sep)
446 
447     if sep not in pattern:
448         name = path.name
449     else:
450         name = str(path)
451         if path.is_absolute() and not os.path.isabs(pattern):
452             pattern = f"*{os.sep}{pattern}"
453     return fnmatch.fnmatch(name, pattern)
454 
455 
456 def parts(s: str) -> Set[str]:
457     parts = s.split(sep)
458     return {sep.join(parts[: i + 1]) or sep for i in range(len(parts))}
459 
460 
461 def symlink_or_skip(src, dst, **kwargs):
462     """Make a symlink, or skip the test in case symlinks are not supported."""
463     try:
464         os.symlink(str(src), str(dst), **kwargs)
465     except OSError as e:
466         skip(f"symlinks not supported: {e}")
467 
468 
469 class ImportMode(Enum):
470     """Possible values for `mode` parameter of `import_path`."""
471 
472     prepend = "prepend"
473     append = "append"
474     importlib = "importlib"
475 
476 
477 class ImportPathMismatchError(ImportError):
478     """Raised on import_path() if there is a mismatch of __file__'s.
479 
480     This can happen when `import_path` is called multiple times with different filenames that has
481     the same basename but reside in packages
482     (for example "/tests1/test_foo.py" and "/tests2/test_foo.py").
483     """
484 
485 
486 def import_path(
487     p: Union[str, "os.PathLike[str]"],
488     *,
489     mode: Union[str, ImportMode] = ImportMode.prepend,
490     root: Path,
491 ) -> ModuleType:
492     """Import and return a module from the given path, which can be a file (a module) or
493     a directory (a package).
494 
495     The import mechanism used is controlled by the `mode` parameter:
496 
497     * `mode == ImportMode.prepend`: the directory containing the module (or package, taking
498       `__init__.py` files into account) will be put at the *start* of `sys.path` before
499       being imported with `importlib.import_module`.
500 
501     * `mode == ImportMode.append`: same as `prepend`, but the directory will be appended
502       to the end of `sys.path`, if not already in `sys.path`.
503 
504     * `mode == ImportMode.importlib`: uses more fine control mechanisms provided by `importlib`
505       to import the module, which avoids having to muck with `sys.path` at all. It effectively
506       allows having same-named test modules in different places.
507 
508     :param root:
509         Used as an anchor when mode == ImportMode.importlib to obtain
510         a unique name for the module being imported so it can safely be stored
511         into ``sys.modules``.
512 
513     :raises ImportPathMismatchError:
514         If after importing the given `path` and the module `__file__`
515         are different. Only raised in `prepend` and `append` modes.
516     """
517     mode = ImportMode(mode)
518 
519     path = Path(p)
520 
521     if not path.exists():
522         raise ImportError(path)
523 
524     if mode is ImportMode.importlib:
525         module_name = module_name_from_path(path, root)
526 
527         for meta_importer in sys.meta_path:
528             spec = meta_importer.find_spec(module_name, [str(path.parent)])
529             if spec is not None:
530                 break
531         else:
532             spec = importlib.util.spec_from_file_location(module_name, str(path))
533 
534         if spec is None:
535             raise ImportError(f"Can't find module {module_name} at location {path}")
536         mod = importlib.util.module_from_spec(spec)
537         sys.modules[module_name] = mod
538         spec.loader.exec_module(mod)  # type: ignore[union-attr]
539         insert_missing_modules(sys.modules, module_name)
540         return mod
541 
542     pkg_path = resolve_package_path(path)
543     if pkg_path is not None:
544         pkg_root = pkg_path.parent
545         names = list(path.with_suffix("").relative_to(pkg_root).parts)
546         if names[-1] == "__init__":
547             names.pop()
548         module_name = ".".join(names)
549     else:
550         pkg_root = path.parent
551         module_name = path.stem
552 
553     # Change sys.path permanently: restoring it at the end of this function would cause surprising
554     # problems because of delayed imports: for example, a conftest.py file imported by this function
555     # might have local imports, which would fail at runtime if we restored sys.path.
556     if mode is ImportMode.append:
557         if str(pkg_root) not in sys.path:
558             sys.path.append(str(pkg_root))
559     elif mode is ImportMode.prepend:
560         if str(pkg_root) != sys.path[0]:
561             sys.path.insert(0, str(pkg_root))
562     else:
563         assert_never(mode)
564 
565     importlib.import_module(module_name)
566 
567     mod = sys.modules[module_name]
568     if path.name == "__init__.py":
569         return mod
570 
571     ignore = os.environ.get("PY_IGNORE_IMPORTMISMATCH", "")
572     if ignore != "1":
573         module_file = mod.__file__
574         if module_file is None:
575             raise ImportPathMismatchError(module_name, module_file, path)
576 
577         if module_file.endswith((".pyc", ".pyo")):
578             module_file = module_file[:-1]
579         if module_file.endswith(os.sep + "__init__.py"):
580             module_file = module_file[: -(len(os.sep + "__init__.py"))]
581 
582         try:
583             is_same = _is_same(str(path), module_file)
584         except FileNotFoundError:
585             is_same = False
586 
587         if not is_same:
588             raise ImportPathMismatchError(module_name, module_file, path)
589 
590     return mod
591 
592 
593 # Implement a special _is_same function on Windows which returns True if the two filenames
594 # compare equal, to circumvent os.path.samefile returning False for mounts in UNC (#7678).
595 if sys.platform.startswith("win"):
596 
597     def _is_same(f1: str, f2: str) -> bool:
598         return Path(f1) == Path(f2) or os.path.samefile(f1, f2)
599 
600 else:
601 
602     def _is_same(f1: str, f2: str) -> bool:
603         return os.path.samefile(f1, f2)
604 
605 
606 def module_name_from_path(path: Path, root: Path) -> str:
607     """
608     Return a dotted module name based on the given path, anchored on root.
609 
610     For example: path="projects/src/tests/test_foo.py" and root="/projects", the
611     resulting module name will be "src.tests.test_foo".
612     """
613     path = path.with_suffix("")
614     try:
615         relative_path = path.relative_to(root)
616     except ValueError:
617         # If we can't get a relative path to root, use the full path, except
618         # for the first part ("d:\\" or "/" depending on the platform, for example).
619         path_parts = path.parts[1:]
620     else:
621         # Use the parts for the relative path to the root path.
622         path_parts = relative_path.parts
623 
624     return ".".join(path_parts)
625 
626 
627 def insert_missing_modules(modules: Dict[str, ModuleType], module_name: str) -> None:
628     """
629     Used by ``import_path`` to create intermediate modules when using mode=importlib.
630 
631     When we want to import a module as "src.tests.test_foo" for example, we need
632     to create empty modules "src" and "src.tests" after inserting "src.tests.test_foo",
633     otherwise "src.tests.test_foo" is not importable by ``__import__``.
634     """
635     module_parts = module_name.split(".")
636     child_module: Union[ModuleType, None] = None
637     module: Union[ModuleType, None] = None
638     child_name: str = ""
639     while module_name:
640         if module_name not in modules:
641             try:
642                 # If sys.meta_path is empty, calling import_module will issue
643                 # a warning and raise ModuleNotFoundError. To avoid the
644                 # warning, we check sys.meta_path explicitly and raise the error
645                 # ourselves to fall back to creating a dummy module.
646                 if not sys.meta_path:
647                     raise ModuleNotFoundError
648                 module = importlib.import_module(module_name)
649             except ModuleNotFoundError:
650                 module = ModuleType(
651                     module_name,
652                     doc="Empty module created by pytest's importmode=importlib.",
653                 )
654         else:
655             module = modules[module_name]
656         if child_module:
657             # Add child attribute to the parent that can reference the child
658             # modules.
659             if not hasattr(module, child_name):
660                 setattr(module, child_name, child_module)
661                 modules[module_name] = module
662         # Keep track of the child module while moving up the tree.
663         child_module, child_name = module, module_name.rpartition(".")[-1]
664         module_parts.pop(-1)
665         module_name = ".".join(module_parts)
666 
667 
668 def resolve_package_path(path: Path) -> Optional[Path]:
669     """Return the Python package path by looking for the last
670     directory upwards which still contains an __init__.py.
671 
672     Returns None if it can not be determined.
673     """
674     result = None
675     for parent in itertools.chain((path,), path.parents):
676         if parent.is_dir():
677             if not parent.joinpath("__init__.py").is_file():
678                 break
679             if not parent.name.isidentifier():
680                 break
681             result = parent
682     return result
683 
684 
685 def scandir(path: Union[str, "os.PathLike[str]"]) -> List["os.DirEntry[str]"]:
686     """Scan a directory recursively, in breadth-first order.
687 
688     The returned entries are sorted.
689     """
690     entries = []
691     with os.scandir(path) as s:
692         # Skip entries with symlink loops and other brokenness, so the caller
693         # doesn't have to deal with it.
694         for entry in s:
695             try:
696                 entry.is_file()
697             except OSError as err:
698                 if _ignore_error(err):
699                     continue
700                 raise
701             entries.append(entry)
702     entries.sort(key=lambda entry: entry.name)
703     return entries
704 
705 
706 def visit(
707     path: Union[str, "os.PathLike[str]"], recurse: Callable[["os.DirEntry[str]"], bool]
708 ) -> Iterator["os.DirEntry[str]"]:
709     """Walk a directory recursively, in breadth-first order.
710 
711     The `recurse` predicate determines whether a directory is recursed.
712 
713     Entries at each directory level are sorted.
714     """
715     entries = scandir(path)
716     yield from entries
717     for entry in entries:
718         if entry.is_dir() and recurse(entry):
719             yield from visit(entry.path, recurse)
720 
721 
722 def absolutepath(path: Union[Path, str]) -> Path:
723     """Convert a path to an absolute path using os.path.abspath.
724 
725     Prefer this over Path.resolve() (see #6523).
726     Prefer this over Path.absolute() (not public, doesn't normalize).
727     """
728     return Path(os.path.abspath(str(path)))
729 
730 
731 def commonpath(path1: Path, path2: Path) -> Optional[Path]:
732     """Return the common part shared with the other path, or None if there is
733     no common part.
734 
735     If one path is relative and one is absolute, returns None.
736     """
737     try:
738         return Path(os.path.commonpath((str(path1), str(path2))))
739     except ValueError:
740         return None
741 
742 
743 def bestrelpath(directory: Path, dest: Path) -> str:
744     """Return a string which is a relative path from directory to dest such
745     that directory/bestrelpath == dest.
746 
747     The paths must be either both absolute or both relative.
748 
749     If no such path can be determined, returns dest.
750     """
751     assert isinstance(directory, Path)
752     assert isinstance(dest, Path)
753     if dest == directory:
754         return os.curdir
755     # Find the longest common directory.
756     base = commonpath(directory, dest)
757     # Can be the case on Windows for two absolute paths on different drives.
758     # Can be the case for two relative paths without common prefix.
759     # Can be the case for a relative path and an absolute path.
760     if not base:
761         return str(dest)
762     reldirectory = directory.relative_to(base)
763     reldest = dest.relative_to(base)
764     return os.path.join(
765         # Back from directory to base.
766         *([os.pardir] * len(reldirectory.parts)),
767         # Forward from base to dest.
768         *reldest.parts,
769     )
770 
771 
772 # Originates from py. path.local.copy(), with siginficant trims and adjustments.
773 # TODO(py38): Replace with shutil.copytree(..., symlinks=True, dirs_exist_ok=True)
774 def copytree(source: Path, target: Path) -> None:
775     """Recursively copy a source directory to target."""
776     assert source.is_dir()
777     for entry in visit(source, recurse=lambda entry: not entry.is_symlink()):
778         x = Path(entry)
779         relpath = x.relative_to(source)
780         newx = target / relpath
781         newx.parent.mkdir(exist_ok=True)
782         if x.is_symlink():
783             newx.symlink_to(os.readlink(x))
784         elif x.is_file():
785             shutil.copyfile(x, newx)
786         elif x.is_dir():
787             newx.mkdir(exist_ok=True)

</code><intended_behavior>These files should correctly handle the resolution and import of modules in a way that's consistent with Python's expected behavior for namespace packages. This ensures that only one instance of each module exists within the application's runtime, specifically avoiding issues where one instance is used to set a configuration and another separate instance is checked for that configuration.</intended_behavior>]
2025-10-18 04:41:54.318 | INFO     | Search completed. Bug locations: [<file>src/_pytest/config/__init__.py</file>
<class>None</class>
<method>None</method>
<code>
1 """Command line options, ini-file and conftest.py processing."""
2 import argparse
3 import collections.abc
4 import copy
5 import dataclasses
6 import enum
7 import glob
8 import importlib.metadata
9 import inspect
10 import os
11 import re
12 import shlex
13 import sys
14 import types
15 import warnings
16 from functools import lru_cache
17 from pathlib import Path
18 from textwrap import dedent
19 from types import FunctionType
20 from types import TracebackType
21 from typing import Any
22 from typing import Callable
23 from typing import cast
24 from typing import Dict
25 from typing import final
26 from typing import Generator
27 from typing import IO
28 from typing import Iterable
29 from typing import Iterator
30 from typing import List
31 from typing import Optional
32 from typing import Sequence
33 from typing import Set
34 from typing import TextIO
35 from typing import Tuple
36 from typing import Type
37 from typing import TYPE_CHECKING
38 from typing import Union
39 
40 from pluggy import HookimplMarker
41 from pluggy import HookspecMarker
42 from pluggy import PluginManager
43 
44 import _pytest._code
45 import _pytest.deprecated
46 import _pytest.hookspec
47 from .exceptions import PrintHelp as PrintHelp
48 from .exceptions import UsageError as UsageError
49 from .findpaths import determine_setup
50 from _pytest._code import ExceptionInfo
51 from _pytest._code import filter_traceback
52 from _pytest._io import TerminalWriter
53 from _pytest.outcomes import fail
54 from _pytest.outcomes import Skipped
55 from _pytest.pathlib import absolutepath
56 from _pytest.pathlib import bestrelpath
57 from _pytest.pathlib import import_path
58 from _pytest.pathlib import ImportMode
59 from _pytest.pathlib import resolve_package_path
60 from _pytest.stash import Stash
61 from _pytest.warning_types import PytestConfigWarning
62 from _pytest.warning_types import warn_explicit_for
63 
64 if TYPE_CHECKING:
65     from _pytest._code.code import _TracebackStyle
66     from _pytest.terminal import TerminalReporter
67     from .argparsing import Argument
68 
69 
70 _PluggyPlugin = object
71 """A type to represent plugin objects.
72 
73 Plugins can be any namespace, so we can't narrow it down much, but we use an
74 alias to make the intent clear.
75 
76 Ideally this type would be provided by pluggy itself.
77 """
78 
79 
80 hookimpl = HookimplMarker("pytest")
81 hookspec = HookspecMarker("pytest")
82 
83 
84 @final
85 class ExitCode(enum.IntEnum):
86     """Encodes the valid exit codes by pytest.
87 
88     Currently users and plugins may supply other exit codes as well.
89 
90     .. versionadded:: 5.0
91     """
92 
93     #: Tests passed.
94     OK = 0
95     #: Tests failed.
96     TESTS_FAILED = 1
97     #: pytest was interrupted.
98     INTERRUPTED = 2
99     #: An internal error got in the way.
100     INTERNAL_ERROR = 3
101     #: pytest was misused.
102     USAGE_ERROR = 4
103     #: pytest couldn't find tests.
104     NO_TESTS_COLLECTED = 5
105 
106 
107 class ConftestImportFailure(Exception):
108     def __init__(
109         self,
110         path: Path,
111         excinfo: Tuple[Type[Exception], Exception, TracebackType],
112     ) -> None:
113         super().__init__(path, excinfo)
114         self.path = path
115         self.excinfo = excinfo
116 
117     def __str__(self) -> str:
118         return "{}: {} (from {})".format(
119             self.excinfo[0].__name__, self.excinfo[1], self.path
120         )
121 
122 
123 def filter_traceback_for_conftest_import_failure(
124     entry: _pytest._code.TracebackEntry,
125 ) -> bool:
126     """Filter tracebacks entries which point to pytest internals or importlib.
127 
128     Make a special case for importlib because we use it to import test modules and conftest files
129     in _pytest.pathlib.import_path.
130     """
131     return filter_traceback(entry) and "importlib" not in str(entry.path).split(os.sep)
132 
133 
134 def main(
135     args: Optional[Union[List[str], "os.PathLike[str]"]] = None,
136     plugins: Optional[Sequence[Union[str, _PluggyPlugin]]] = None,
137 ) -> Union[int, ExitCode]:
138     """Perform an in-process test run.
139 
140     :param args: List of command line arguments.
141     :param plugins: List of plugin objects to be auto-registered during initialization.
142 
143     :returns: An exit code.
144     """
145     try:
146         try:
147             config = _prepareconfig(args, plugins)
148         except ConftestImportFailure as e:
149             exc_info = ExceptionInfo.from_exc_info(e.excinfo)
150             tw = TerminalWriter(sys.stderr)
151             tw.line(f"ImportError while loading conftest '{e.path}'.", red=True)
152             exc_info.traceback = exc_info.traceback.filter(
153                 filter_traceback_for_conftest_import_failure
154             )
155             exc_repr = (
156                 exc_info.getrepr(style="short", chain=False)
157                 if exc_info.traceback
158                 else exc_info.exconly()
159             )
160             formatted_tb = str(exc_repr)
161             for line in formatted_tb.splitlines():
162                 tw.line(line.rstrip(), red=True)
163             return ExitCode.USAGE_ERROR
164         else:
165             try:
166                 ret: Union[ExitCode, int] = config.hook.pytest_cmdline_main(
167                     config=config
168                 )
169                 try:
170                     return ExitCode(ret)
171                 except ValueError:
172                     return ret
173             finally:
174                 config._ensure_unconfigure()
175     except UsageError as e:
176         tw = TerminalWriter(sys.stderr)
177         for msg in e.args:
178             tw.line(f"ERROR: {msg}\n", red=True)
179         return ExitCode.USAGE_ERROR
180 
181 
182 def console_main() -> int:
183     """The CLI entry point of pytest.
184 
185     This function is not meant for programmable use; use `main()` instead.
186     """
187     # https://docs.python.org/3/library/signal.html#note-on-sigpipe
188     try:
189         code = main()
190         sys.stdout.flush()
191         return code
192     except BrokenPipeError:
193         # Python flushes standard streams on exit; redirect remaining output
194         # to devnull to avoid another BrokenPipeError at shutdown
195         devnull = os.open(os.devnull, os.O_WRONLY)
196         os.dup2(devnull, sys.stdout.fileno())
197         return 1  # Python exits with error code 1 on EPIPE
198 
199 
200 class cmdline:  # compatibility namespace
201     main = staticmethod(main)
202 
203 
204 def filename_arg(path: str, optname: str) -> str:
205     """Argparse type validator for filename arguments.
206 
207     :path: Path of filename.
208     :optname: Name of the option.
209     """
210     if os.path.isdir(path):
211         raise UsageError(f"{optname} must be a filename, given: {path}")
212     return path
213 
214 
215 def directory_arg(path: str, optname: str) -> str:
216     """Argparse type validator for directory arguments.
217 
218     :path: Path of directory.
219     :optname: Name of the option.
220     """
221     if not os.path.isdir(path):
222         raise UsageError(f"{optname} must be a directory, given: {path}")
223     return path
224 
225 
226 # Plugins that cannot be disabled via "-p no:X" currently.
227 essential_plugins = (
228     "mark",
229     "main",
230     "runner",
231     "fixtures",
232     "helpconfig",  # Provides -p.
233 )
234 
235 default_plugins = essential_plugins + (
236     "python",
237     "terminal",
238     "debugging",
239     "unittest",
240     "capture",
241     "skipping",
242     "legacypath",
243     "tmpdir",
244     "monkeypatch",
245     "recwarn",
246     "pastebin",
247     "nose",
248     "assertion",
249     "junitxml",
250     "doctest",
251     "cacheprovider",
252     "freeze_support",
253     "setuponly",
254     "setupplan",
255     "stepwise",
256     "warnings",
257     "logging",
258     "reports",
259     "python_path",
260     "unraisableexception",
261     "threadexception",
262     "faulthandler",
263 )
264 
265 builtin_plugins = set(default_plugins)
266 builtin_plugins.add("pytester")
267 builtin_plugins.add("pytester_assertions")
268 
269 
270 def get_config(
271     args: Optional[List[str]] = None,
272     plugins: Optional[Sequence[Union[str, _PluggyPlugin]]] = None,
273 ) -> "Config":
274     # subsequent calls to main will create a fresh instance
275     pluginmanager = PytestPluginManager()
276     config = Config(
277         pluginmanager,
278         invocation_params=Config.InvocationParams(
279             args=args or (),
280             plugins=plugins,
281             dir=Path.cwd(),
282         ),
283     )
284 
285     if args is not None:
286         # Handle any "-p no:plugin" args.
287         pluginmanager.consider_preparse(args, exclude_only=True)
288 
289     for spec in default_plugins:
290         pluginmanager.import_plugin(spec)
291 
292     return config
293 
294 
295 def get_plugin_manager() -> "PytestPluginManager":
296     """Obtain a new instance of the
297     :py:class:`pytest.PytestPluginManager`, with default plugins
298     already loaded.
299 
300     This function can be used by integration with other tools, like hooking
301     into pytest to run tests into an IDE.
302     """
303     return get_config().pluginmanager
304 
305 
306 def _prepareconfig(
307     args: Optional[Union[List[str], "os.PathLike[str]"]] = None,
308     plugins: Optional[Sequence[Union[str, _PluggyPlugin]]] = None,
309 ) -> "Config":
310     if args is None:
311         args = sys.argv[1:]
312     elif isinstance(args, os.PathLike):
313         args = [os.fspath(args)]
314     elif not isinstance(args, list):
315         msg = (  # type:ignore[unreachable]
316             "`args` parameter expected to be a list of strings, got: {!r} (type: {})"
317         )
318         raise TypeError(msg.format(args, type(args)))
319 
320     config = get_config(args, plugins)
321     pluginmanager = config.pluginmanager
322     try:
323         if plugins:
324             for plugin in plugins:
325                 if isinstance(plugin, str):
326                     pluginmanager.consider_pluginarg(plugin)
327                 else:
328                     pluginmanager.register(plugin)
329         config = pluginmanager.hook.pytest_cmdline_parse(
330             pluginmanager=pluginmanager, args=args
331         )
332         return config
333     except BaseException:
334         config._ensure_unconfigure()
335         raise
336 
337 
338 def _get_directory(path: Path) -> Path:
339     """Get the directory of a path - itself if already a directory."""
340     if path.is_file():
341         return path.parent
342     else:
343         return path
344 
345 
346 def _get_legacy_hook_marks(
347     method: Any,
348     hook_type: str,
349     opt_names: Tuple[str, ...],
350 ) -> Dict[str, bool]:
351     if TYPE_CHECKING:
352         # abuse typeguard from importlib to avoid massive method type union thats lacking a alias
353         assert inspect.isroutine(method)
354     known_marks: set[str] = {m.name for m in getattr(method, "pytestmark", [])}
355     must_warn: list[str] = []
356     opts: dict[str, bool] = {}
357     for opt_name in opt_names:
358         opt_attr = getattr(method, opt_name, AttributeError)
359         if opt_attr is not AttributeError:
360             must_warn.append(f"{opt_name}={opt_attr}")
361             opts[opt_name] = True
362         elif opt_name in known_marks:
363             must_warn.append(f"{opt_name}=True")
364             opts[opt_name] = True
365         else:
366             opts[opt_name] = False
367     if must_warn:
368         hook_opts = ", ".join(must_warn)
369         message = _pytest.deprecated.HOOK_LEGACY_MARKING.format(
370             type=hook_type,
371             fullname=method.__qualname__,
372             hook_opts=hook_opts,
373         )
374         warn_explicit_for(cast(FunctionType, method), message)
375     return opts
376 
377 
378 @final
379 class PytestPluginManager(PluginManager):
380     """A :py:class:`pluggy.PluginManager <pluggy.PluginManager>` with
381     additional pytest-specific functionality:
382 
383     * Loading plugins from the command line, ``PYTEST_PLUGINS`` env variable and
384       ``pytest_plugins`` global variables found in plugins being loaded.
385     * ``conftest.py`` loading during start-up.
386     """
387 
388     def __init__(self) -> None:
389         import _pytest.assertion
390 
391         super().__init__("pytest")
392 
393         # -- State related to local conftest plugins.
394         # All loaded conftest modules.
395         self._conftest_plugins: Set[types.ModuleType] = set()
396         # All conftest modules applicable for a directory.
397         # This includes the directory's own conftest modules as well
398         # as those of its parent directories.
399         self._dirpath2confmods: Dict[Path, List[types.ModuleType]] = {}
400         # Cutoff directory above which conftests are no longer discovered.
401         self._confcutdir: Optional[Path] = None
402         # If set, conftest loading is skipped.
403         self._noconftest = False
404 
405         # _getconftestmodules()'s call to _get_directory() causes a stat
406         # storm when it's called potentially thousands of times in a test
407         # session (#9478), often with the same path, so cache it.
408         self._get_directory = lru_cache(256)(_get_directory)
409 
410         self._duplicatepaths: Set[Path] = set()
411 
412         # plugins that were explicitly skipped with pytest.skip
413         # list of (module name, skip reason)
414         # previously we would issue a warning when a plugin was skipped, but
415         # since we refactored warnings as first citizens of Config, they are
416         # just stored here to be used later.
417         self.skipped_plugins: List[Tuple[str, str]] = []
418 
419         self.add_hookspecs(_pytest.hookspec)
420         self.register(self)
421         if os.environ.get("PYTEST_DEBUG"):
422             err: IO[str] = sys.stderr
423             encoding: str = getattr(err, "encoding", "utf8")
424             try:
425                 err = open(
426                     os.dup(err.fileno()),
427                     mode=err.mode,
428                     buffering=1,
429                     encoding=encoding,
430                 )
431             except Exception:
432                 pass
433             self.trace.root.setwriter(err.write)
434             self.enable_tracing()
435 
436         # Config._consider_importhook will set a real object if required.
437         self.rewrite_hook = _pytest.assertion.DummyRewriteHook()
438         # Used to know when we are importing conftests after the pytest_configure stage.
439         self._configured = False
440 
441     def parse_hookimpl_opts(self, plugin: _PluggyPlugin, name: str):
442         # pytest hooks are always prefixed with "pytest_",
443         # so we avoid accessing possibly non-readable attributes
444         # (see issue #1073).
445         if not name.startswith("pytest_"):
446             return
447         # Ignore names which can not be hooks.
448         if name == "pytest_plugins":
449             return
450 
451         opts = super().parse_hookimpl_opts(plugin, name)
452         if opts is not None:
453             return opts
454 
455         method = getattr(plugin, name)
456         # Consider only actual functions for hooks (#3775).
457         if not inspect.isroutine(method):
458             return
459         # Collect unmarked hooks as long as they have the `pytest_' prefix.
460         return _get_legacy_hook_marks(
461             method, "impl", ("tryfirst", "trylast", "optionalhook", "hookwrapper")
462         )
463 
464     def parse_hookspec_opts(self, module_or_class, name: str):
465         opts = super().parse_hookspec_opts(module_or_class, name)
466         if opts is None:
467             method = getattr(module_or_class, name)
468             if name.startswith("pytest_"):
469                 opts = _get_legacy_hook_marks(
470                     method,
471                     "spec",
472                     ("firstresult", "historic"),
473                 )
474         return opts
475 
476     def register(
477         self, plugin: _PluggyPlugin, name: Optional[str] = None
478     ) -> Optional[str]:
479         if name in _pytest.deprecated.DEPRECATED_EXTERNAL_PLUGINS:
480             warnings.warn(
481                 PytestConfigWarning(
482                     "{} plugin has been merged into the core, "
483                     "please remove it from your requirements.".format(
484                         name.replace("_", "-")
485                     )
486                 )
487             )
488             return None
489         ret: Optional[str] = super().register(plugin, name)
490         if ret:
491             self.hook.pytest_plugin_registered.call_historic(
492                 kwargs=dict(plugin=plugin, manager=self)
493             )
494 
495             if isinstance(plugin, types.ModuleType):
496                 self.consider_module(plugin)
497         return ret
498 
499     def getplugin(self, name: str):
500         # Support deprecated naming because plugins (xdist e.g.) use it.
501         plugin: Optional[_PluggyPlugin] = self.get_plugin(name)
502         return plugin
503 
504     def hasplugin(self, name: str) -> bool:
505         """Return whether a plugin with the given name is registered."""
506         return bool(self.get_plugin(name))
507 
508     def pytest_configure(self, config: "Config") -> None:
509         """:meta private:"""
510         # XXX now that the pluginmanager exposes hookimpl(tryfirst...)
511         # we should remove tryfirst/trylast as markers.
512         config.addinivalue_line(
513             "markers",
514             "tryfirst: mark a hook implementation function such that the "
515             "plugin machinery will try to call it first/as early as possible. "
516             "DEPRECATED, use @pytest.hookimpl(tryfirst=True) instead.",
517         )
518         config.addinivalue_line(
519             "markers",
520             "trylast: mark a hook implementation function such that the "
521             "plugin machinery will try to call it last/as late as possible. "
522             "DEPRECATED, use @pytest.hookimpl(trylast=True) instead.",
523         )
524         self._configured = True
525 
526     #
527     # Internal API for local conftest plugin handling.
528     #
529     def _set_initial_conftests(
530         self,
531         args: Sequence[Union[str, Path]],
532         pyargs: bool,
533         noconftest: bool,
534         rootpath: Path,
535         confcutdir: Optional[Path],
536         importmode: Union[ImportMode, str],
537     ) -> None:
538         """Load initial conftest files given a preparsed "namespace".
539 
540         As conftest files may add their own command line options which have
541         arguments ('--my-opt somepath') we might get some false positives.
542         All builtin and 3rd party plugins will have been loaded, however, so
543         common options will not confuse our logic here.
544         """
545         current = Path.cwd()
546         self._confcutdir = absolutepath(current / confcutdir) if confcutdir else None
547         self._noconftest = noconftest
548         self._using_pyargs = pyargs
549         foundanchor = False
550         for intitial_path in args:
551             path = str(intitial_path)
552             # remove node-id syntax
553             i = path.find("::")
554             if i != -1:
555                 path = path[:i]
556             anchor = absolutepath(current / path)
557 
558             # Ensure we do not break if what appears to be an anchor
559             # is in fact a very long option (#10169).
560             try:
561                 anchor_exists = anchor.exists()
562             except OSError:  # pragma: no cover
563                 anchor_exists = False
564             if anchor_exists:
565                 self._try_load_conftest(anchor, importmode, rootpath)
566                 foundanchor = True
567         if not foundanchor:
568             self._try_load_conftest(current, importmode, rootpath)
569 
570     def _is_in_confcutdir(self, path: Path) -> bool:
571         """Whether a path is within the confcutdir.
572 
573         When false, should not load conftest.
574         """
575         if self._confcutdir is None:
576             return True
577         return path not in self._confcutdir.parents
578 
579     def _try_load_conftest(
580         self, anchor: Path, importmode: Union[str, ImportMode], rootpath: Path
581     ) -> None:
582         self._getconftestmodules(anchor, importmode, rootpath)
583         # let's also consider test* subdirs
584         if anchor.is_dir():
585             for x in anchor.glob("test*"):
586                 if x.is_dir():
587                     self._getconftestmodules(x, importmode, rootpath)
588 
589     def _getconftestmodules(
590         self, path: Path, importmode: Union[str, ImportMode], rootpath: Path
591     ) -> Sequence[types.ModuleType]:
592         if self._noconftest:
593             return []
594 
595         directory = self._get_directory(path)
596 
597         # Optimization: avoid repeated searches in the same directory.
598         # Assumes always called with same importmode and rootpath.
599         existing_clist = self._dirpath2confmods.get(directory)
600         if existing_clist is not None:
601             return existing_clist
602 
603         # XXX these days we may rather want to use config.rootpath
604         # and allow users to opt into looking into the rootdir parent
605         # directories instead of requiring to specify confcutdir.
606         clist = []
607         for parent in reversed((directory, *directory.parents)):
608             if self._is_in_confcutdir(parent):
609                 conftestpath = parent / "conftest.py"
610                 if conftestpath.is_file():
611                     mod = self._importconftest(conftestpath, importmode, rootpath)
612                     clist.append(mod)
613         self._dirpath2confmods[directory] = clist
614         return clist
615 
616     def _rget_with_confmod(
617         self,
618         name: str,
619         path: Path,
620         importmode: Union[str, ImportMode],
621         rootpath: Path,
622     ) -> Tuple[types.ModuleType, Any]:
623         modules = self._getconftestmodules(path, importmode, rootpath=rootpath)
624         for mod in reversed(modules):
625             try:
626                 return mod, getattr(mod, name)
627             except AttributeError:
628                 continue
629         raise KeyError(name)
630 
631     def _importconftest(
632         self, conftestpath: Path, importmode: Union[str, ImportMode], rootpath: Path
633     ) -> types.ModuleType:
634         existing = self.get_plugin(str(conftestpath))
635         if existing is not None:
636             return cast(types.ModuleType, existing)
637 
638         pkgpath = resolve_package_path(conftestpath)
639         if pkgpath is None:
640             _ensure_removed_sysmodule(conftestpath.stem)
641 
642         try:
643             mod = import_path(conftestpath, mode=importmode, root=rootpath)
644         except Exception as e:
645             assert e.__traceback__ is not None
646             exc_info = (type(e), e, e.__traceback__)
647             raise ConftestImportFailure(conftestpath, exc_info) from e
648 
649         self._check_non_top_pytest_plugins(mod, conftestpath)
650 
651         self._conftest_plugins.add(mod)
652         dirpath = conftestpath.parent
653         if dirpath in self._dirpath2confmods:
654             for path, mods in self._dirpath2confmods.items():
655                 if dirpath in path.parents or path == dirpath:
656                     assert mod not in mods
657                     mods.append(mod)
658         self.trace(f"loading conftestmodule {mod!r}")
659         self.consider_conftest(mod)
660         return mod
661 
662     def _check_non_top_pytest_plugins(
663         self,
664         mod: types.ModuleType,
665         conftestpath: Path,
666     ) -> None:
667         if (
668             hasattr(mod, "pytest_plugins")
669             and self._configured
670             and not self._using_pyargs
671         ):
672             msg = (
673                 "Defining 'pytest_plugins' in a non-top-level conftest is no longer supported:\n"
674                 "It affects the entire test suite instead of just below the conftest as expected.\n"
675                 "  {}\n"
676                 "Please move it to a top level conftest file at the rootdir:\n"
677                 "  {}\n"
678                 "For more information, visit:\n"
679                 "  https://docs.pytest.org/en/stable/deprecations.html#pytest-plugins-in-non-top-level-conftest-files"
680             )
681             fail(msg.format(conftestpath, self._confcutdir), pytrace=False)
682 
683     #
684     # API for bootstrapping plugin loading
685     #
686     #
687 
688     def consider_preparse(
689         self, args: Sequence[str], *, exclude_only: bool = False
690     ) -> None:
691         """:meta private:"""
692         i = 0
693         n = len(args)
694         while i < n:
695             opt = args[i]
696             i += 1
697             if isinstance(opt, str):
698                 if opt == "-p":
699                     try:
700                         parg = args[i]
701                     except IndexError:
702                         return
703                     i += 1
704                 elif opt.startswith("-p"):
705                     parg = opt[2:]
706                 else:
707                     continue
708                 parg = parg.strip()
709                 if exclude_only and not parg.startswith("no:"):
710                     continue
711                 self.consider_pluginarg(parg)
712 
713     def consider_pluginarg(self, arg: str) -> None:
714         """:meta private:"""
715         if arg.startswith("no:"):
716             name = arg[3:]
717             if name in essential_plugins:
718                 raise UsageError("plugin %s cannot be disabled" % name)
719 
720             # PR #4304: remove stepwise if cacheprovider is blocked.
721             if name == "cacheprovider":
722                 self.set_blocked("stepwise")
723                 self.set_blocked("pytest_stepwise")
724 
725             self.set_blocked(name)
726             if not name.startswith("pytest_"):
727                 self.set_blocked("pytest_" + name)
728         else:
729             name = arg
730             # Unblock the plugin.  None indicates that it has been blocked.
731             # There is no interface with pluggy for this.
732             if self._name2plugin.get(name, -1) is None:
733                 del self._name2plugin[name]
734             if not name.startswith("pytest_"):
735                 if self._name2plugin.get("pytest_" + name, -1) is None:
736                     del self._name2plugin["pytest_" + name]
737             self.import_plugin(arg, consider_entry_points=True)
738 
739     def consider_conftest(self, conftestmodule: types.ModuleType) -> None:
740         """:meta private:"""
741         self.register(conftestmodule, name=conftestmodule.__file__)
742 
743     def consider_env(self) -> None:
744         """:meta private:"""
745         self._import_plugin_specs(os.environ.get("PYTEST_PLUGINS"))
746 
747     def consider_module(self, mod: types.ModuleType) -> None:
748         """:meta private:"""
749         self._import_plugin_specs(getattr(mod, "pytest_plugins", []))
750 
751     def _import_plugin_specs(
752         self, spec: Union[None, types.ModuleType, str, Sequence[str]]
753     ) -> None:
754         plugins = _get_plugin_specs_as_list(spec)
755         for import_spec in plugins:
756             self.import_plugin(import_spec)
757 
758     def import_plugin(self, modname: str, consider_entry_points: bool = False) -> None:
759         """Import a plugin with ``modname``.
760 
761         If ``consider_entry_points`` is True, entry point names are also
762         considered to find a plugin.
763         """
764         # Most often modname refers to builtin modules, e.g. "pytester",
765         # "terminal" or "capture".  Those plugins are registered under their
766         # basename for historic purposes but must be imported with the
767         # _pytest prefix.
768         assert isinstance(modname, str), (
769             "module name as text required, got %r" % modname
770         )
771         if self.is_blocked(modname) or self.get_plugin(modname) is not None:
772             return
773 
774         importspec = "_pytest." + modname if modname in builtin_plugins else modname
775         self.rewrite_hook.mark_rewrite(importspec)
776 
777         if consider_entry_points:
778             loaded = self.load_setuptools_entrypoints("pytest11", name=modname)
779             if loaded:
780                 return
781 
782         try:
783             __import__(importspec)
784         except ImportError as e:
785             raise ImportError(
786                 f'Error importing plugin "{modname}": {e.args[0]}'
787             ).with_traceback(e.__traceback__) from e
788 
789         except Skipped as e:
790             self.skipped_plugins.append((modname, e.msg or ""))
791         else:
792             mod = sys.modules[importspec]
793             self.register(mod, modname)
794 
795 
796 def _get_plugin_specs_as_list(
797     specs: Union[None, types.ModuleType, str, Sequence[str]]
798 ) -> List[str]:
799     """Parse a plugins specification into a list of plugin names."""
800     # None means empty.
801     if specs is None:
802         return []
803     # Workaround for #3899 - a submodule which happens to be called "pytest_plugins".
804     if isinstance(specs, types.ModuleType):
805         return []
806     # Comma-separated list.
807     if isinstance(specs, str):
808         return specs.split(",") if specs else []
809     # Direct specification.
810     if isinstance(specs, collections.abc.Sequence):
811         return list(specs)
812     raise UsageError(
813         "Plugins may be specified as a sequence or a ','-separated string of plugin names. Got: %r"
814         % specs
815     )
816 
817 
818 def _ensure_removed_sysmodule(modname: str) -> None:
819     try:
820         del sys.modules[modname]
821     except KeyError:
822         pass
823 
824 
825 class Notset:
826     def __repr__(self):
827         return "<NOTSET>"
828 
829 
830 notset = Notset()
831 
832 
833 def _iter_rewritable_modules(package_files: Iterable[str]) -> Iterator[str]:
834     """Given an iterable of file names in a source distribution, return the "names" that should
835     be marked for assertion rewrite.
836 
837     For example the package "pytest_mock/__init__.py" should be added as "pytest_mock" in
838     the assertion rewrite mechanism.
839 
840     This function has to deal with dist-info based distributions and egg based distributions
841     (which are still very much in use for "editable" installs).
842 
843     Here are the file names as seen in a dist-info based distribution:
844 
845         pytest_mock/__init__.py
846         pytest_mock/_version.py
847         pytest_mock/plugin.py
848         pytest_mock.egg-info/PKG-INFO
849 
850     Here are the file names as seen in an egg based distribution:
851 
852         src/pytest_mock/__init__.py
853         src/pytest_mock/_version.py
854         src/pytest_mock/plugin.py
855         src/pytest_mock.egg-info/PKG-INFO
856         LICENSE
857         setup.py
858 
859     We have to take in account those two distribution flavors in order to determine which
860     names should be considered for assertion rewriting.
861 
862     More information:
863         https://github.com/pytest-dev/pytest-mock/issues/167
864     """
865     package_files = list(package_files)
866     seen_some = False
867     for fn in package_files:
868         is_simple_module = "/" not in fn and fn.endswith(".py")
869         is_package = fn.count("/") == 1 and fn.endswith("__init__.py")
870         if is_simple_module:
871             module_name, _ = os.path.splitext(fn)
872             # we ignore "setup.py" at the root of the distribution
873             # as well as editable installation finder modules made by setuptools
874             if module_name != "setup" and not module_name.startswith("__editable__"):
875                 seen_some = True
876                 yield module_name
877         elif is_package:
878             package_name = os.path.dirname(fn)
879             seen_some = True
880             yield package_name
881 
882     if not seen_some:
883         # At this point we did not find any packages or modules suitable for assertion
884         # rewriting, so we try again by stripping the first path component (to account for
885         # "src" based source trees for example).
886         # This approach lets us have the common case continue to be fast, as egg-distributions
887         # are rarer.
888         new_package_files = []
889         for fn in package_files:
890             parts = fn.split("/")
891             new_fn = "/".join(parts[1:])
892             if new_fn:
893                 new_package_files.append(new_fn)
894         if new_package_files:
895             yield from _iter_rewritable_modules(new_package_files)
896 
897 
898 @final
899 class Config:
900     """Access to configuration values, pluginmanager and plugin hooks.
901 
902     :param PytestPluginManager pluginmanager:
903         A pytest PluginManager.
904 
905     :param InvocationParams invocation_params:
906         Object containing parameters regarding the :func:`pytest.main`
907         invocation.
908     """
909 
910     @final
911     @dataclasses.dataclass(frozen=True)
912     class InvocationParams:
913         """Holds parameters passed during :func:`pytest.main`.
914 
915         The object attributes are read-only.
916 
917         .. versionadded:: 5.1
918 
919         .. note::
920 
921             Note that the environment variable ``PYTEST_ADDOPTS`` and the ``addopts``
922             ini option are handled by pytest, not being included in the ``args`` attribute.
923 
924             Plugins accessing ``InvocationParams`` must be aware of that.
925         """
926 
927         args: Tuple[str, ...]
928         """The command-line arguments as passed to :func:`pytest.main`."""
929         plugins: Optional[Sequence[Union[str, _PluggyPlugin]]]
930         """Extra plugins, might be `None`."""
931         dir: Path
932         """The directory from which :func:`pytest.main` was invoked."""
933 
934         def __init__(
935             self,
936             *,
937             args: Iterable[str],
938             plugins: Optional[Sequence[Union[str, _PluggyPlugin]]],
939             dir: Path,
940         ) -> None:
941             object.__setattr__(self, "args", tuple(args))
942             object.__setattr__(self, "plugins", plugins)
943             object.__setattr__(self, "dir", dir)
944 
945     class ArgsSource(enum.Enum):
946         """Indicates the source of the test arguments.
947 
948         .. versionadded:: 7.2
949         """
950 
951         #: Command line arguments.
952         ARGS = enum.auto()
953         #: Invocation directory.
954         INCOVATION_DIR = enum.auto()
955         #: 'testpaths' configuration value.
956         TESTPATHS = enum.auto()
957 
958     def __init__(
959         self,
960         pluginmanager: PytestPluginManager,
961         *,
962         invocation_params: Optional[InvocationParams] = None,
963     ) -> None:
964         from .argparsing import Parser, FILE_OR_DIR
965 
966         if invocation_params is None:
967             invocation_params = self.InvocationParams(
968                 args=(), plugins=None, dir=Path.cwd()
969             )
970 
971         self.option = argparse.Namespace()
972         """Access to command line option as attributes.
973 
974         :type: argparse.Namespace
975         """
976 
977         self.invocation_params = invocation_params
978         """The parameters with which pytest was invoked.
979 
980         :type: InvocationParams
981         """
982 
983         _a = FILE_OR_DIR
984         self._parser = Parser(
985             usage=f"%(prog)s [options] [{_a}] [{_a}] [...]",
986             processopt=self._processopt,
987             _ispytest=True,
988         )
989         self.pluginmanager = pluginmanager
990         """The plugin manager handles plugin registration and hook invocation.
991 
992         :type: PytestPluginManager
993         """
994 
995         self.stash = Stash()
996         """A place where plugins can store information on the config for their
997         own use.
998 
999         :type: Stash
1000         """
1001         # Deprecated alias. Was never public. Can be removed in a few releases.
1002         self._store = self.stash
1003 
1004         from .compat import PathAwareHookProxy
1005 
1006         self.trace = self.pluginmanager.trace.root.get("config")
1007         self.hook = PathAwareHookProxy(self.pluginmanager.hook)
1008         self._inicache: Dict[str, Any] = {}
1009         self._override_ini: Sequence[str] = ()
1010         self._opt2dest: Dict[str, str] = {}
1011         self._cleanup: List[Callable[[], None]] = []
1012         self.pluginmanager.register(self, "pytestconfig")
1013         self._configured = False
1014         self.hook.pytest_addoption.call_historic(
1015             kwargs=dict(parser=self._parser, pluginmanager=self.pluginmanager)
1016         )
1017         self.args_source = Config.ArgsSource.ARGS
1018         self.args: List[str] = []
1019 
1020         if TYPE_CHECKING:
1021             from _pytest.cacheprovider import Cache
1022 
1023             self.cache: Optional[Cache] = None
1024 
1025     @property
1026     def rootpath(self) -> Path:
1027         """The path to the :ref:`rootdir <rootdir>`.
1028 
1029         :type: pathlib.Path
1030 
1031         .. versionadded:: 6.1
1032         """
1033         return self._rootpath
1034 
1035     @property
1036     def inipath(self) -> Optional[Path]:
1037         """The path to the :ref:`configfile <configfiles>`.
1038 
1039         :type: Optional[pathlib.Path]
1040 
1041         .. versionadded:: 6.1
1042         """
1043         return self._inipath
1044 
1045     def add_cleanup(self, func: Callable[[], None]) -> None:
1046         """Add a function to be called when the config object gets out of
1047         use (usually coinciding with pytest_unconfigure)."""
1048         self._cleanup.append(func)
1049 
1050     def _do_configure(self) -> None:
1051         assert not self._configured
1052         self._configured = True
1053         with warnings.catch_warnings():
1054             warnings.simplefilter("default")
1055             self.hook.pytest_configure.call_historic(kwargs=dict(config=self))
1056 
1057     def _ensure_unconfigure(self) -> None:
1058         if self._configured:
1059             self._configured = False
1060             self.hook.pytest_unconfigure(config=self)
1061             self.hook.pytest_configure._call_history = []
1062         while self._cleanup:
1063             fin = self._cleanup.pop()
1064             fin()
1065 
1066     def get_terminal_writer(self) -> TerminalWriter:
1067         terminalreporter: TerminalReporter = self.pluginmanager.get_plugin(
1068             "terminalreporter"
1069         )
1070         return terminalreporter._tw
1071 
1072     def pytest_cmdline_parse(
1073         self, pluginmanager: PytestPluginManager, args: List[str]
1074     ) -> "Config":
1075         try:
1076             self.parse(args)
1077         except UsageError:
1078             # Handle --version and --help here in a minimal fashion.
1079             # This gets done via helpconfig normally, but its
1080             # pytest_cmdline_main is not called in case of errors.
1081             if getattr(self.option, "version", False) or "--version" in args:
1082                 from _pytest.helpconfig import showversion
1083 
1084                 showversion(self)
1085             elif (
1086                 getattr(self.option, "help", False) or "--help" in args or "-h" in args
1087             ):
1088                 self._parser._getparser().print_help()
1089                 sys.stdout.write(
1090                     "\nNOTE: displaying only minimal help due to UsageError.\n\n"
1091                 )
1092 
1093             raise
1094 
1095         return self
1096 
1097     def notify_exception(
1098         self,
1099         excinfo: ExceptionInfo[BaseException],
1100         option: Optional[argparse.Namespace] = None,
1101     ) -> None:
1102         if option and getattr(option, "fulltrace", False):
1103             style: _TracebackStyle = "long"
1104         else:
1105             style = "native"
1106         excrepr = excinfo.getrepr(
1107             funcargs=True, showlocals=getattr(option, "showlocals", False), style=style
1108         )
1109         res = self.hook.pytest_internalerror(excrepr=excrepr, excinfo=excinfo)
1110         if not any(res):
1111             for line in str(excrepr).split("\n"):
1112                 sys.stderr.write("INTERNALERROR> %s\n" % line)
1113                 sys.stderr.flush()
1114 
1115     def cwd_relative_nodeid(self, nodeid: str) -> str:
1116         # nodeid's are relative to the rootpath, compute relative to cwd.
1117         if self.invocation_params.dir != self.rootpath:
1118             fullpath = self.rootpath / nodeid
1119             nodeid = bestrelpath(self.invocation_params.dir, fullpath)
1120         return nodeid
1121 
1122     @classmethod
1123     def fromdictargs(cls, option_dict, args) -> "Config":
1124         """Constructor usable for subprocesses."""
1125         config = get_config(args)
1126         config.option.__dict__.update(option_dict)
1127         config.parse(args, addopts=False)
1128         for x in config.option.plugins:
1129             config.pluginmanager.consider_pluginarg(x)
1130         return config
1131 
1132     def _processopt(self, opt: "Argument") -> None:
1133         for name in opt._short_opts + opt._long_opts:
1134             self._opt2dest[name] = opt.dest
1135 
1136         if hasattr(opt, "default"):
1137             if not hasattr(self.option, opt.dest):
1138                 setattr(self.option, opt.dest, opt.default)
1139 
1140     @hookimpl(trylast=True)
1141     def pytest_load_initial_conftests(self, early_config: "Config") -> None:
1142         # We haven't fully parsed the command line arguments yet, so
1143         # early_config.args it not set yet. But we need it for
1144         # discovering the initial conftests. So "pre-run" the logic here.
1145         # It will be done for real in `parse()`.
1146         args, args_source = early_config._decide_args(
1147             args=early_config.known_args_namespace.file_or_dir,
1148             pyargs=early_config.known_args_namespace.pyargs,
1149             testpaths=early_config.getini("testpaths"),
1150             invocation_dir=early_config.invocation_params.dir,
1151             rootpath=early_config.rootpath,
1152             warn=False,
1153         )
1154         self.pluginmanager._set_initial_conftests(
1155             args=args,
1156             pyargs=early_config.known_args_namespace.pyargs,
1157             noconftest=early_config.known_args_namespace.noconftest,
1158             rootpath=early_config.rootpath,
1159             confcutdir=early_config.known_args_namespace.confcutdir,
1160             importmode=early_config.known_args_namespace.importmode,
1161         )
1162 
1163     def _initini(self, args: Sequence[str]) -> None:
1164         ns, unknown_args = self._parser.parse_known_and_unknown_args(
1165             args, namespace=copy.copy(self.option)
1166         )
1167         rootpath, inipath, inicfg = determine_setup(
1168             ns.inifilename,
1169             ns.file_or_dir + unknown_args,
1170             rootdir_cmd_arg=ns.rootdir or None,
1171             config=self,
1172         )
1173         self._rootpath = rootpath
1174         self._inipath = inipath
1175         self.inicfg = inicfg
1176         self._parser.extra_info["rootdir"] = str(self.rootpath)
1177         self._parser.extra_info["inifile"] = str(self.inipath)
1178         self._parser.addini("addopts", "Extra command line options", "args")
1179         self._parser.addini("minversion", "Minimally required pytest version")
1180         self._parser.addini(
1181             "required_plugins",
1182             "Plugins that must be present for pytest to run",
1183             type="args",
1184             default=[],
1185         )
1186         self._override_ini = ns.override_ini or ()
1187 
1188     def _consider_importhook(self, args: Sequence[str]) -> None:
1189         """Install the PEP 302 import hook if using assertion rewriting.
1190 
1191         Needs to parse the --assert=<mode> option from the commandline
1192         and find all the installed plugins to mark them for rewriting
1193         by the importhook.
1194         """
1195         ns, unknown_args = self._parser.parse_known_and_unknown_args(args)
1196         mode = getattr(ns, "assertmode", "plain")
1197         if mode == "rewrite":
1198             import _pytest.assertion
1199 
1200             try:
1201                 hook = _pytest.assertion.install_importhook(self)
1202             except SystemError:
1203                 mode = "plain"
1204             else:
1205                 self._mark_plugins_for_rewrite(hook)
1206         self._warn_about_missing_assertion(mode)
1207 
1208     def _mark_plugins_for_rewrite(self, hook) -> None:
1209         """Given an importhook, mark for rewrite any top-level
1210         modules or packages in the distribution package for
1211         all pytest plugins."""
1212         self.pluginmanager.rewrite_hook = hook
1213 
1214         if os.environ.get("PYTEST_DISABLE_PLUGIN_AUTOLOAD"):
1215             # We don't autoload from setuptools entry points, no need to continue.
1216             return
1217 
1218         package_files = (
1219             str(file)
1220             for dist in importlib.metadata.distributions()
1221             if any(ep.group == "pytest11" for ep in dist.entry_points)
1222             for file in dist.files or []
1223         )
1224 
1225         for name in _iter_rewritable_modules(package_files):
1226             hook.mark_rewrite(name)
1227 
1228     def _validate_args(self, args: List[str], via: str) -> List[str]:
1229         """Validate known args."""
1230         self._parser._config_source_hint = via  # type: ignore
1231         try:
1232             self._parser.parse_known_and_unknown_args(
1233                 args, namespace=copy.copy(self.option)
1234             )
1235         finally:
1236             del self._parser._config_source_hint  # type: ignore
1237 
1238         return args
1239 
1240     def _decide_args(
1241         self,
1242         *,
1243         args: List[str],
1244         pyargs: List[str],
1245         testpaths: List[str],
1246         invocation_dir: Path,
1247         rootpath: Path,
1248         warn: bool,
1249     ) -> Tuple[List[str], ArgsSource]:
1250         """Decide the args (initial paths/nodeids) to use given the relevant inputs.
1251 
1252         :param warn: Whether can issue warnings.
1253         """
1254         if args:
1255             source = Config.ArgsSource.ARGS
1256             result = args
1257         else:
1258             if invocation_dir == rootpath:
1259                 source = Config.ArgsSource.TESTPATHS
1260                 if pyargs:
1261                     result = testpaths
1262                 else:
1263                     result = []
1264                     for path in testpaths:
1265                         result.extend(sorted(glob.iglob(path, recursive=True)))
1266                     if testpaths and not result:
1267                         if warn:
1268                             warning_text = (
1269                                 "No files were found in testpaths; "
1270                                 "consider removing or adjusting your testpaths configuration. "
1271                                 "Searching recursively from the current directory instead."
1272                             )
1273                             self.issue_config_time_warning(
1274                                 PytestConfigWarning(warning_text), stacklevel=3
1275                             )
1276             else:
1277                 result = []
1278             if not result:
1279                 source = Config.ArgsSource.INCOVATION_DIR
1280                 result = [str(invocation_dir)]
1281         return result, source
1282 
1283     def _preparse(self, args: List[str], addopts: bool = True) -> None:
1284         if addopts:
1285             env_addopts = os.environ.get("PYTEST_ADDOPTS", "")
1286             if len(env_addopts):
1287                 args[:] = (
1288                     self._validate_args(shlex.split(env_addopts), "via PYTEST_ADDOPTS")
1289                     + args
1290                 )
1291         self._initini(args)
1292         if addopts:
1293             args[:] = (
1294                 self._validate_args(self.getini("addopts"), "via addopts config") + args
1295             )
1296 
1297         self.known_args_namespace = self._parser.parse_known_args(
1298             args, namespace=copy.copy(self.option)
1299         )
1300         self._checkversion()
1301         self._consider_importhook(args)
1302         self.pluginmanager.consider_preparse(args, exclude_only=False)
1303         if not os.environ.get("PYTEST_DISABLE_PLUGIN_AUTOLOAD"):
1304             # Don't autoload from setuptools entry point. Only explicitly specified
1305             # plugins are going to be loaded.
1306             self.pluginmanager.load_setuptools_entrypoints("pytest11")
1307         self.pluginmanager.consider_env()
1308 
1309         self.known_args_namespace = self._parser.parse_known_args(
1310             args, namespace=copy.copy(self.known_args_namespace)
1311         )
1312 
1313         self._validate_plugins()
1314         self._warn_about_skipped_plugins()
1315 
1316         if self.known_args_namespace.strict:
1317             self.issue_config_time_warning(
1318                 _pytest.deprecated.STRICT_OPTION, stacklevel=2
1319             )
1320 
1321         if self.known_args_namespace.confcutdir is None:
1322             if self.inipath is not None:
1323                 confcutdir = str(self.inipath.parent)
1324             else:
1325                 confcutdir = str(self.rootpath)
1326             self.known_args_namespace.confcutdir = confcutdir
1327         try:
1328             self.hook.pytest_load_initial_conftests(
1329                 early_config=self, args=args, parser=self._parser
1330             )
1331         except ConftestImportFailure as e:
1332             if self.known_args_namespace.help or self.known_args_namespace.version:
1333                 # we don't want to prevent --help/--version to work
1334                 # so just let is pass and print a warning at the end
1335                 self.issue_config_time_warning(
1336                     PytestConfigWarning(f"could not load initial conftests: {e.path}"),
1337                     stacklevel=2,
1338                 )
1339             else:
1340                 raise
1341 
1342     @hookimpl(hookwrapper=True)
1343     def pytest_collection(self) -> Generator[None, None, None]:
1344         # Validate invalid ini keys after collection is done so we take in account
1345         # options added by late-loading conftest files.
1346         yield
1347         self._validate_config_options()
1348 
1349     def _checkversion(self) -> None:
1350         import pytest
1351 
1352         minver = self.inicfg.get("minversion", None)
1353         if minver:
1354             # Imported lazily to improve start-up time.
1355             from packaging.version import Version
1356 
1357             if not isinstance(minver, str):
1358                 raise pytest.UsageError(
1359                     "%s: 'minversion' must be a single value" % self.inipath
1360                 )
1361 
1362             if Version(minver) > Version(pytest.__version__):
1363                 raise pytest.UsageError(
1364                     "%s: 'minversion' requires pytest-%s, actual pytest-%s'"
1365                     % (
1366                         self.inipath,
1367                         minver,
1368                         pytest.__version__,
1369                     )
1370                 )
1371 
1372     def _validate_config_options(self) -> None:
1373         for key in sorted(self._get_unknown_ini_keys()):
1374             self._warn_or_fail_if_strict(f"Unknown config option: {key}\n")
1375 
1376     def _validate_plugins(self) -> None:
1377         required_plugins = sorted(self.getini("required_plugins"))
1378         if not required_plugins:
1379             return
1380 
1381         # Imported lazily to improve start-up time.
1382         from packaging.version import Version
1383         from packaging.requirements import InvalidRequirement, Requirement
1384 
1385         plugin_info = self.pluginmanager.list_plugin_distinfo()
1386         plugin_dist_info = {dist.project_name: dist.version for _, dist in plugin_info}
1387 
1388         missing_plugins = []
1389         for required_plugin in required_plugins:
1390             try:
1391                 req = Requirement(required_plugin)
1392             except InvalidRequirement:
1393                 missing_plugins.append(required_plugin)
1394                 continue
1395 
1396             if req.name not in plugin_dist_info:
1397                 missing_plugins.append(required_plugin)
1398             elif not req.specifier.contains(
1399                 Version(plugin_dist_info[req.name]), prereleases=True
1400             ):
1401                 missing_plugins.append(required_plugin)
1402 
1403         if missing_plugins:
1404             raise UsageError(
1405                 "Missing required plugins: {}".format(", ".join(missing_plugins)),
1406             )
1407 
1408     def _warn_or_fail_if_strict(self, message: str) -> None:
1409         if self.known_args_namespace.strict_config:
1410             raise UsageError(message)
1411 
1412         self.issue_config_time_warning(PytestConfigWarning(message), stacklevel=3)
1413 
1414     def _get_unknown_ini_keys(self) -> List[str]:
1415         parser_inicfg = self._parser._inidict
1416         return [name for name in self.inicfg if name not in parser_inicfg]
1417 
1418     def parse(self, args: List[str], addopts: bool = True) -> None:
1419         # Parse given cmdline arguments into this config object.
1420         assert (
1421             self.args == []
1422         ), "can only parse cmdline args at most once per Config object"
1423         self.hook.pytest_addhooks.call_historic(
1424             kwargs=dict(pluginmanager=self.pluginmanager)
1425         )
1426         self._preparse(args, addopts=addopts)
1427         # XXX deprecated hook:
1428         self.hook.pytest_cmdline_preparse(config=self, args=args)
1429         self._parser.after_preparse = True  # type: ignore
1430         try:
1431             args = self._parser.parse_setoption(
1432                 args, self.option, namespace=self.option
1433             )
1434             self.args, self.args_source = self._decide_args(
1435                 args=args,
1436                 pyargs=self.known_args_namespace.pyargs,
1437                 testpaths=self.getini("testpaths"),
1438                 invocation_dir=self.invocation_params.dir,
1439                 rootpath=self.rootpath,
1440                 warn=True,
1441             )
1442         except PrintHelp:
1443             pass
1444 
1445     def issue_config_time_warning(self, warning: Warning, stacklevel: int) -> None:
1446         """Issue and handle a warning during the "configure" stage.
1447 
1448         During ``pytest_configure`` we can't capture warnings using the ``catch_warnings_for_item``
1449         function because it is not possible to have hookwrappers around ``pytest_configure``.
1450 
1451         This function is mainly intended for plugins that need to issue warnings during
1452         ``pytest_configure`` (or similar stages).
1453 
1454         :param warning: The warning instance.
1455         :param stacklevel: stacklevel forwarded to warnings.warn.
1456         """
1457         if self.pluginmanager.is_blocked("warnings"):
1458             return
1459 
1460         cmdline_filters = self.known_args_namespace.pythonwarnings or []
1461         config_filters = self.getini("filterwarnings")
1462 
1463         with warnings.catch_warnings(record=True) as records:
1464             warnings.simplefilter("always", type(warning))
1465             apply_warning_filters(config_filters, cmdline_filters)
1466             warnings.warn(warning, stacklevel=stacklevel)
1467 
1468         if records:
1469             frame = sys._getframe(stacklevel - 1)
1470             location = frame.f_code.co_filename, frame.f_lineno, frame.f_code.co_name
1471             self.hook.pytest_warning_recorded.call_historic(
1472                 kwargs=dict(
1473                     warning_message=records[0],
1474                     when="config",
1475                     nodeid="",
1476                     location=location,
1477                 )
1478             )
1479 
1480     def addinivalue_line(self, name: str, line: str) -> None:
1481         """Add a line to an ini-file option. The option must have been
1482         declared but might not yet be set in which case the line becomes
1483         the first line in its value."""
1484         x = self.getini(name)
1485         assert isinstance(x, list)
1486         x.append(line)  # modifies the cached list inline
1487 
1488     def getini(self, name: str):
1489         """Return configuration value from an :ref:`ini file <configfiles>`.
1490 
1491         If the specified name hasn't been registered through a prior
1492         :func:`parser.addini <pytest.Parser.addini>` call (usually from a
1493         plugin), a ValueError is raised.
1494         """
1495         try:
1496             return self._inicache[name]
1497         except KeyError:
1498             self._inicache[name] = val = self._getini(name)
1499             return val
1500 
1501     # Meant for easy monkeypatching by legacypath plugin.
1502     # Can be inlined back (with no cover removed) once legacypath is gone.
1503     def _getini_unknown_type(self, name: str, type: str, value: Union[str, List[str]]):
1504         msg = f"unknown configuration type: {type}"
1505         raise ValueError(msg, value)  # pragma: no cover
1506 
1507     def _getini(self, name: str):
1508         try:
1509             description, type, default = self._parser._inidict[name]
1510         except KeyError as e:
1511             raise ValueError(f"unknown configuration value: {name!r}") from e
1512         override_value = self._get_override_ini_value(name)
1513         if override_value is None:
1514             try:
1515                 value = self.inicfg[name]
1516             except KeyError:
1517                 if default is not None:
1518                     return default
1519                 if type is None:
1520                     return ""
1521                 return []
1522         else:
1523             value = override_value
1524         # Coerce the values based on types.
1525         #
1526         # Note: some coercions are only required if we are reading from .ini files, because
1527         # the file format doesn't contain type information, but when reading from toml we will
1528         # get either str or list of str values (see _parse_ini_config_from_pyproject_toml).
1529         # For example:
1530         #
1531         #   ini:
1532         #     a_line_list = "tests acceptance"
1533         #   in this case, we need to split the string to obtain a list of strings.
1534         #
1535         #   toml:
1536         #     a_line_list = ["tests", "acceptance"]
1537         #   in this case, we already have a list ready to use.
1538         #
1539         if type == "paths":
1540             # TODO: This assert is probably not valid in all cases.
1541             assert self.inipath is not None
1542             dp = self.inipath.parent
1543             input_values = shlex.split(value) if isinstance(value, str) else value
1544             return [dp / x for x in input_values]
1545         elif type == "args":
1546             return shlex.split(value) if isinstance(value, str) else value
1547         elif type == "linelist":
1548             if isinstance(value, str):
1549                 return [t for t in map(lambda x: x.strip(), value.split("\n")) if t]
1550             else:
1551                 return value
1552         elif type == "bool":
1553             return _strtobool(str(value).strip())
1554         elif type == "string":
1555             return value
1556         elif type is None:
1557             return value
1558         else:
1559             return self._getini_unknown_type(name, type, value)
1560 
1561     def _getconftest_pathlist(
1562         self, name: str, path: Path, rootpath: Path
1563     ) -> Optional[List[Path]]:
1564         try:
1565             mod, relroots = self.pluginmanager._rget_with_confmod(
1566                 name, path, self.getoption("importmode"), rootpath
1567             )
1568         except KeyError:
1569             return None
1570         assert mod.__file__ is not None
1571         modpath = Path(mod.__file__).parent
1572         values: List[Path] = []
1573         for relroot in relroots:
1574             if isinstance(relroot, os.PathLike):
1575                 relroot = Path(relroot)
1576             else:
1577                 relroot = relroot.replace("/", os.sep)
1578                 relroot = absolutepath(modpath / relroot)
1579             values.append(relroot)
1580         return values
1581 
1582     def _get_override_ini_value(self, name: str) -> Optional[str]:
1583         value = None
1584         # override_ini is a list of "ini=value" options.
1585         # Always use the last item if multiple values are set for same ini-name,
1586         # e.g. -o foo=bar1 -o foo=bar2 will set foo to bar2.
1587         for ini_config in self._override_ini:
1588             try:
1589                 key, user_ini_value = ini_config.split("=", 1)
1590             except ValueError as e:
1591                 raise UsageError(
1592                     "-o/--override-ini expects option=value style (got: {!r}).".format(
1593                         ini_config
1594                     )
1595                 ) from e
1596             else:
1597                 if key == name:
1598                     value = user_ini_value
1599         return value
1600 
1601     def getoption(self, name: str, default=notset, skip: bool = False):
1602         """Return command line option value.
1603 
1604         :param name: Name of the option.  You may also specify
1605             the literal ``--OPT`` option instead of the "dest" option name.
1606         :param default: Default value if no option of that name exists.
1607         :param skip: If True, raise pytest.skip if option does not exists
1608             or has a None value.
1609         """
1610         name = self._opt2dest.get(name, name)
1611         try:
1612             val = getattr(self.option, name)
1613             if val is None and skip:
1614                 raise AttributeError(name)
1615             return val
1616         except AttributeError as e:
1617             if default is not notset:
1618                 return default
1619             if skip:
1620                 import pytest
1621 
1622                 pytest.skip(f"no {name!r} option found")
1623             raise ValueError(f"no option named {name!r}") from e
1624 
1625     def getvalue(self, name: str, path=None):
1626         """Deprecated, use getoption() instead."""
1627         return self.getoption(name)
1628 
1629     def getvalueorskip(self, name: str, path=None):
1630         """Deprecated, use getoption(skip=True) instead."""
1631         return self.getoption(name, skip=True)
1632 
1633     def _warn_about_missing_assertion(self, mode: str) -> None:
1634         if not _assertion_supported():
1635             if mode == "plain":
1636                 warning_text = (
1637                     "ASSERTIONS ARE NOT EXECUTED"
1638                     " and FAILING TESTS WILL PASS.  Are you"
1639                     " using python -O?"
1640                 )
1641             else:
1642                 warning_text = (
1643                     "assertions not in test modules or"
1644                     " plugins will be ignored"
1645                     " because assert statements are not executed "
1646                     "by the underlying Python interpreter "
1647                     "(are you using python -O?)\n"
1648                 )
1649             self.issue_config_time_warning(
1650                 PytestConfigWarning(warning_text),
1651                 stacklevel=3,
1652             )
1653 
1654     def _warn_about_skipped_plugins(self) -> None:
1655         for module_name, msg in self.pluginmanager.skipped_plugins:
1656             self.issue_config_time_warning(
1657                 PytestConfigWarning(f"skipped plugin {module_name!r}: {msg}"),
1658                 stacklevel=2,
1659             )
1660 
1661 
1662 def _assertion_supported() -> bool:
1663     try:
1664         assert False
1665     except AssertionError:
1666         return True
1667     else:
1668         return False  # type: ignore[unreachable]
1669 
1670 
1671 def create_terminal_writer(
1672     config: Config, file: Optional[TextIO] = None
1673 ) -> TerminalWriter:
1674     """Create a TerminalWriter instance configured according to the options
1675     in the config object.
1676 
1677     Every code which requires a TerminalWriter object and has access to a
1678     config object should use this function.
1679     """
1680     tw = TerminalWriter(file=file)
1681 
1682     if config.option.color == "yes":
1683         tw.hasmarkup = True
1684     elif config.option.color == "no":
1685         tw.hasmarkup = False
1686 
1687     if config.option.code_highlight == "yes":
1688         tw.code_highlight = True
1689     elif config.option.code_highlight == "no":
1690         tw.code_highlight = False
1691 
1692     return tw
1693 
1694 
1695 def _strtobool(val: str) -> bool:
1696     """Convert a string representation of truth to True or False.
1697 
1698     True values are 'y', 'yes', 't', 'true', 'on', and '1'; false values
1699     are 'n', 'no', 'f', 'false', 'off', and '0'.  Raises ValueError if
1700     'val' is anything else.
1701 
1702     .. note:: Copied from distutils.util.
1703     """
1704     val = val.lower()
1705     if val in ("y", "yes", "t", "true", "on", "1"):
1706         return True
1707     elif val in ("n", "no", "f", "false", "off", "0"):
1708         return False
1709     else:
1710         raise ValueError(f"invalid truth value {val!r}")
1711 
1712 
1713 @lru_cache(maxsize=50)
1714 def parse_warning_filter(
1715     arg: str, *, escape: bool
1716 ) -> Tuple["warnings._ActionKind", str, Type[Warning], str, int]:
1717     """Parse a warnings filter string.
1718 
1719     This is copied from warnings._setoption with the following changes:
1720 
1721     * Does not apply the filter.
1722     * Escaping is optional.
1723     * Raises UsageError so we get nice error messages on failure.
1724     """
1725     __tracebackhide__ = True
1726     error_template = dedent(
1727         f"""\
1728         while parsing the following warning configuration:
1729 
1730           {arg}
1731 
1732         This error occurred:
1733 
1734         {{error}}
1735         """
1736     )
1737 
1738     parts = arg.split(":")
1739     if len(parts) > 5:
1740         doc_url = (
1741             "https://docs.python.org/3/library/warnings.html#describing-warning-filters"
1742         )
1743         error = dedent(
1744             f"""\
1745             Too many fields ({len(parts)}), expected at most 5 separated by colons:
1746 
1747               action:message:category:module:line
1748 
1749             For more information please consult: {doc_url}
1750             """
1751         )
1752         raise UsageError(error_template.format(error=error))
1753 
1754     while len(parts) < 5:
1755         parts.append("")
1756     action_, message, category_, module, lineno_ = (s.strip() for s in parts)
1757     try:
1758         action: "warnings._ActionKind" = warnings._getaction(action_)  # type: ignore[attr-defined]
1759     except warnings._OptionError as e:
1760         raise UsageError(error_template.format(error=str(e)))
1761     try:
1762         category: Type[Warning] = _resolve_warning_category(category_)
1763     except Exception:
1764         exc_info = ExceptionInfo.from_current()
1765         exception_text = exc_info.getrepr(style="native")
1766         raise UsageError(error_template.format(error=exception_text))
1767     if message and escape:
1768         message = re.escape(message)
1769     if module and escape:
1770         module = re.escape(module) + r"\Z"
1771     if lineno_:
1772         try:
1773             lineno = int(lineno_)
1774             if lineno < 0:
1775                 raise ValueError("number is negative")
1776         except ValueError as e:
1777             raise UsageError(
1778                 error_template.format(error=f"invalid lineno {lineno_!r}: {e}")
1779             )
1780     else:
1781         lineno = 0
1782     return action, message, category, module, lineno
1783 
1784 
1785 def _resolve_warning_category(category: str) -> Type[Warning]:
1786     """
1787     Copied from warnings._getcategory, but changed so it lets exceptions (specially ImportErrors)
1788     propagate so we can get access to their tracebacks (#9218).
1789     """
1790     __tracebackhide__ = True
1791     if not category:
1792         return Warning
1793 
1794     if "." not in category:
1795         import builtins as m
1796 
1797         klass = category
1798     else:
1799         module, _, klass = category.rpartition(".")
1800         m = __import__(module, None, None, [klass])
1801     cat = getattr(m, klass)
1802     if not issubclass(cat, Warning):
1803         raise UsageError(f"{cat} is not a Warning subclass")
1804     return cast(Type[Warning], cat)
1805 
1806 
1807 def apply_warning_filters(
1808     config_filters: Iterable[str], cmdline_filters: Iterable[str]
1809 ) -> None:
1810     """Applies pytest-configured filters to the warnings module"""
1811     # Filters should have this precedence: cmdline options, config.
1812     # Filters should be applied in the inverse order of precedence.
1813     for arg in config_filters:
1814         warnings.filterwarnings(*parse_warning_filter(arg, escape=False))
1815 
1816     for arg in cmdline_filters:
1817         warnings.filterwarnings(*parse_warning_filter(arg, escape=True))

</code><intended_behavior>Ensure that when modules are loaded, particularly those related to `pmxbot`, they are loaded in a manner that recognizes and respects the PEP 420 namespace packages, preventing duplicate instances. This may involve checking the configuration logic to ensure it does not inadvertently cause a module to be re-imported or re-initialized in a manner that creates two separate instances of what should be a single module in `sys.modules`.</intended_behavior>, <file>src/_pytest/pathlib.py</file>
<class>None</class>
<method>None</method>
<code>
1 import atexit
2 import contextlib
3 import fnmatch
4 import importlib.util
5 import itertools
6 import os
7 import shutil
8 import sys
9 import types
10 import uuid
11 import warnings
12 from enum import Enum
13 from errno import EBADF
14 from errno import ELOOP
15 from errno import ENOENT
16 from errno import ENOTDIR
17 from functools import partial
18 from os.path import expanduser
19 from os.path import expandvars
20 from os.path import isabs
21 from os.path import sep
22 from pathlib import Path
23 from pathlib import PurePath
24 from posixpath import sep as posix_sep
25 from types import ModuleType
26 from typing import Callable
27 from typing import Dict
28 from typing import Iterable
29 from typing import Iterator
30 from typing import List
31 from typing import Optional
32 from typing import Set
33 from typing import Tuple
34 from typing import Type
35 from typing import TypeVar
36 from typing import Union
37 
38 from _pytest.compat import assert_never
39 from _pytest.outcomes import skip
40 from _pytest.warning_types import PytestWarning
41 
42 LOCK_TIMEOUT = 60 * 60 * 24 * 3
43 
44 
45 _AnyPurePath = TypeVar("_AnyPurePath", bound=PurePath)
46 
47 # The following function, variables and comments were
48 # copied from cpython 3.9 Lib/pathlib.py file.
49 
50 # EBADF - guard against macOS `stat` throwing EBADF
51 _IGNORED_ERRORS = (ENOENT, ENOTDIR, EBADF, ELOOP)
52 
53 _IGNORED_WINERRORS = (
54     21,  # ERROR_NOT_READY - drive exists but is not accessible
55     1921,  # ERROR_CANT_RESOLVE_FILENAME - fix for broken symlink pointing to itself
56 )
57 
58 
59 def _ignore_error(exception):
60     return (
61         getattr(exception, "errno", None) in _IGNORED_ERRORS
62         or getattr(exception, "winerror", None) in _IGNORED_WINERRORS
63     )
64 
65 
66 def get_lock_path(path: _AnyPurePath) -> _AnyPurePath:
67     return path.joinpath(".lock")
68 
69 
70 def on_rm_rf_error(
71     func,
72     path: str,
73     excinfo: Union[
74         BaseException,
75         Tuple[Type[BaseException], BaseException, Optional[types.TracebackType]],
76     ],
77     *,
78     start_path: Path,
79 ) -> bool:
80     """Handle known read-only errors during rmtree.
81 
82     The returned value is used only by our own tests.
83     """
84     if isinstance(excinfo, BaseException):
85         exc = excinfo
86     else:
87         exc = excinfo[1]
88 
89     # Another process removed the file in the middle of the "rm_rf" (xdist for example).
90     # More context: https://github.com/pytest-dev/pytest/issues/5974#issuecomment-543799018
91     if isinstance(exc, FileNotFoundError):
92         return False
93 
94     if not isinstance(exc, PermissionError):
95         warnings.warn(
96             PytestWarning(f"(rm_rf) error removing {path}\n{type(exc)}: {exc}")
97         )
98         return False
99 
100     if func not in (os.rmdir, os.remove, os.unlink):
101         if func not in (os.open,):
102             warnings.warn(
103                 PytestWarning(
104                     "(rm_rf) unknown function {} when removing {}:\n{}: {}".format(
105                         func, path, type(exc), exc
106                     )
107                 )
108             )
109         return False
110 
111     # Chmod + retry.
112     import stat
113 
114     def chmod_rw(p: str) -> None:
115         mode = os.stat(p).st_mode
116         os.chmod(p, mode | stat.S_IRUSR | stat.S_IWUSR)
117 
118     # For files, we need to recursively go upwards in the directories to
119     # ensure they all are also writable.
120     p = Path(path)
121     if p.is_file():
122         for parent in p.parents:
123             chmod_rw(str(parent))
124             # Stop when we reach the original path passed to rm_rf.
125             if parent == start_path:
126                 break
127     chmod_rw(str(path))
128 
129     func(path)
130     return True
131 
132 
133 def ensure_extended_length_path(path: Path) -> Path:
134     """Get the extended-length version of a path (Windows).
135 
136     On Windows, by default, the maximum length of a path (MAX_PATH) is 260
137     characters, and operations on paths longer than that fail. But it is possible
138     to overcome this by converting the path to "extended-length" form before
139     performing the operation:
140     https://docs.microsoft.com/en-us/windows/win32/fileio/naming-a-file#maximum-path-length-limitation
141 
142     On Windows, this function returns the extended-length absolute version of path.
143     On other platforms it returns path unchanged.
144     """
145     if sys.platform.startswith("win32"):
146         path = path.resolve()
147         path = Path(get_extended_length_path_str(str(path)))
148     return path
149 
150 
151 def get_extended_length_path_str(path: str) -> str:
152     """Convert a path to a Windows extended length path."""
153     long_path_prefix = "\\\\?\\"
154     unc_long_path_prefix = "\\\\?\\UNC\\"
155     if path.startswith((long_path_prefix, unc_long_path_prefix)):
156         return path
157     # UNC
158     if path.startswith("\\\\"):
159         return unc_long_path_prefix + path[2:]
160     return long_path_prefix + path
161 
162 
163 def rm_rf(path: Path) -> None:
164     """Remove the path contents recursively, even if some elements
165     are read-only."""
166     path = ensure_extended_length_path(path)
167     onerror = partial(on_rm_rf_error, start_path=path)
168     if sys.version_info >= (3, 12):
169         shutil.rmtree(str(path), onexc=onerror)
170     else:
171         shutil.rmtree(str(path), onerror=onerror)
172 
173 
174 def find_prefixed(root: Path, prefix: str) -> Iterator[Path]:
175     """Find all elements in root that begin with the prefix, case insensitive."""
176     l_prefix = prefix.lower()
177     for x in root.iterdir():
178         if x.name.lower().startswith(l_prefix):
179             yield x
180 
181 
182 def extract_suffixes(iter: Iterable[PurePath], prefix: str) -> Iterator[str]:
183     """Return the parts of the paths following the prefix.
184 
185     :param iter: Iterator over path names.
186     :param prefix: Expected prefix of the path names.
187     """
188     p_len = len(prefix)
189     for p in iter:
190         yield p.name[p_len:]
191 
192 
193 def find_suffixes(root: Path, prefix: str) -> Iterator[str]:
194     """Combine find_prefixes and extract_suffixes."""
195     return extract_suffixes(find_prefixed(root, prefix), prefix)
196 
197 
198 def parse_num(maybe_num) -> int:
199     """Parse number path suffixes, returns -1 on error."""
200     try:
201         return int(maybe_num)
202     except ValueError:
203         return -1
204 
205 
206 def _force_symlink(
207     root: Path, target: Union[str, PurePath], link_to: Union[str, Path]
208 ) -> None:
209     """Helper to create the current symlink.
210 
211     It's full of race conditions that are reasonably OK to ignore
212     for the context of best effort linking to the latest test run.
213 
214     The presumption being that in case of much parallelism
215     the inaccuracy is going to be acceptable.
216     """
217     current_symlink = root.joinpath(target)
218     try:
219         current_symlink.unlink()
220     except OSError:
221         pass
222     try:
223         current_symlink.symlink_to(link_to)
224     except Exception:
225         pass
226 
227 
228 def make_numbered_dir(root: Path, prefix: str, mode: int = 0o700) -> Path:
229     """Create a directory with an increased number as suffix for the given prefix."""
230     for i in range(10):
231         # try up to 10 times to create the folder
232         max_existing = max(map(parse_num, find_suffixes(root, prefix)), default=-1)
233         new_number = max_existing + 1
234         new_path = root.joinpath(f"{prefix}{new_number}")
235         try:
236             new_path.mkdir(mode=mode)
237         except Exception:
238             pass
239         else:
240             _force_symlink(root, prefix + "current", new_path)
241             return new_path
242     else:
243         raise OSError(
244             "could not create numbered dir with prefix "
245             "{prefix} in {root} after 10 tries".format(prefix=prefix, root=root)
246         )
247 
248 
249 def create_cleanup_lock(p: Path) -> Path:
250     """Create a lock to prevent premature folder cleanup."""
251     lock_path = get_lock_path(p)
252     try:
253         fd = os.open(str(lock_path), os.O_WRONLY | os.O_CREAT | os.O_EXCL, 0o644)
254     except FileExistsError as e:
255         raise OSError(f"cannot create lockfile in {p}") from e
256     else:
257         pid = os.getpid()
258         spid = str(pid).encode()
259         os.write(fd, spid)
260         os.close(fd)
261         if not lock_path.is_file():
262             raise OSError("lock path got renamed after successful creation")
263         return lock_path
264 
265 
266 def register_cleanup_lock_removal(lock_path: Path, register=atexit.register):
267     """Register a cleanup function for removing a lock, by default on atexit."""
268     pid = os.getpid()
269 
270     def cleanup_on_exit(lock_path: Path = lock_path, original_pid: int = pid) -> None:
271         current_pid = os.getpid()
272         if current_pid != original_pid:
273             # fork
274             return
275         try:
276             lock_path.unlink()
277         except OSError:
278             pass
279 
280     return register(cleanup_on_exit)
281 
282 
283 def maybe_delete_a_numbered_dir(path: Path) -> None:
284     """Remove a numbered directory if its lock can be obtained and it does
285     not seem to be in use."""
286     path = ensure_extended_length_path(path)
287     lock_path = None
288     try:
289         lock_path = create_cleanup_lock(path)
290         parent = path.parent
291 
292         garbage = parent.joinpath(f"garbage-{uuid.uuid4()}")
293         path.rename(garbage)
294         rm_rf(garbage)
295     except OSError:
296         #  known races:
297         #  * other process did a cleanup at the same time
298         #  * deletable folder was found
299         #  * process cwd (Windows)
300         return
301     finally:
302         # If we created the lock, ensure we remove it even if we failed
303         # to properly remove the numbered dir.
304         if lock_path is not None:
305             try:
306                 lock_path.unlink()
307             except OSError:
308                 pass
309 
310 
311 def ensure_deletable(path: Path, consider_lock_dead_if_created_before: float) -> bool:
312     """Check if `path` is deletable based on whether the lock file is expired."""
313     if path.is_symlink():
314         return False
315     lock = get_lock_path(path)
316     try:
317         if not lock.is_file():
318             return True
319     except OSError:
320         # we might not have access to the lock file at all, in this case assume
321         # we don't have access to the entire directory (#7491).
322         return False
323     try:
324         lock_time = lock.stat().st_mtime
325     except Exception:
326         return False
327     else:
328         if lock_time < consider_lock_dead_if_created_before:
329             # We want to ignore any errors while trying to remove the lock such as:
330             # - PermissionDenied, like the file permissions have changed since the lock creation;
331             # - FileNotFoundError, in case another pytest process got here first;
332             # and any other cause of failure.
333             with contextlib.suppress(OSError):
334                 lock.unlink()
335                 return True
336         return False
337 
338 
339 def try_cleanup(path: Path, consider_lock_dead_if_created_before: float) -> None:
340     """Try to cleanup a folder if we can ensure it's deletable."""
341     if ensure_deletable(path, consider_lock_dead_if_created_before):
342         maybe_delete_a_numbered_dir(path)
343 
344 
345 def cleanup_candidates(root: Path, prefix: str, keep: int) -> Iterator[Path]:
346     """List candidates for numbered directories to be removed - follows py.path."""
347     max_existing = max(map(parse_num, find_suffixes(root, prefix)), default=-1)
348     max_delete = max_existing - keep
349     paths = find_prefixed(root, prefix)
350     paths, paths2 = itertools.tee(paths)
351     numbers = map(parse_num, extract_suffixes(paths2, prefix))
352     for path, number in zip(paths, numbers):
353         if number <= max_delete:
354             yield path
355 
356 
357 def cleanup_dead_symlinks(root: Path):
358     for left_dir in root.iterdir():
359         if left_dir.is_symlink():
360             if not left_dir.resolve().exists():
361                 left_dir.unlink()
362 
363 
364 def cleanup_numbered_dir(
365     root: Path, prefix: str, keep: int, consider_lock_dead_if_created_before: float
366 ) -> None:
367     """Cleanup for lock driven numbered directories."""
368     if not root.exists():
369         return
370     for path in cleanup_candidates(root, prefix, keep):
371         try_cleanup(path, consider_lock_dead_if_created_before)
372     for path in root.glob("garbage-*"):
373         try_cleanup(path, consider_lock_dead_if_created_before)
374 
375     cleanup_dead_symlinks(root)
376 
377 
378 def make_numbered_dir_with_cleanup(
379     root: Path,
380     prefix: str,
381     keep: int,
382     lock_timeout: float,
383     mode: int,
384 ) -> Path:
385     """Create a numbered dir with a cleanup lock and remove old ones."""
386     e = None
387     for i in range(10):
388         try:
389             p = make_numbered_dir(root, prefix, mode)
390             # Only lock the current dir when keep is not 0
391             if keep != 0:
392                 lock_path = create_cleanup_lock(p)
393                 register_cleanup_lock_removal(lock_path)
394         except Exception as exc:
395             e = exc
396         else:
397             consider_lock_dead_if_created_before = p.stat().st_mtime - lock_timeout
398             # Register a cleanup for program exit
399             atexit.register(
400                 cleanup_numbered_dir,
401                 root,
402                 prefix,
403                 keep,
404                 consider_lock_dead_if_created_before,
405             )
406             return p
407     assert e is not None
408     raise e
409 
410 
411 def resolve_from_str(input: str, rootpath: Path) -> Path:
412     input = expanduser(input)
413     input = expandvars(input)
414     if isabs(input):
415         return Path(input)
416     else:
417         return rootpath.joinpath(input)
418 
419 
420 def fnmatch_ex(pattern: str, path: Union[str, "os.PathLike[str]"]) -> bool:
421     """A port of FNMatcher from py.path.common which works with PurePath() instances.
422 
423     The difference between this algorithm and PurePath.match() is that the
424     latter matches "**" glob expressions for each part of the path, while
425     this algorithm uses the whole path instead.
426 
427     For example:
428         "tests/foo/bar/doc/test_foo.py" matches pattern "tests/**/doc/test*.py"
429         with this algorithm, but not with PurePath.match().
430 
431     This algorithm was ported to keep backward-compatibility with existing
432     settings which assume paths match according this logic.
433 
434     References:
435     * https://bugs.python.org/issue29249
436     * https://bugs.python.org/issue34731
437     """
438     path = PurePath(path)
439     iswin32 = sys.platform.startswith("win")
440 
441     if iswin32 and sep not in pattern and posix_sep in pattern:
442         # Running on Windows, the pattern has no Windows path separators,
443         # and the pattern has one or more Posix path separators. Replace
444         # the Posix path separators with the Windows path separator.
445         pattern = pattern.replace(posix_sep, sep)
446 
447     if sep not in pattern:
448         name = path.name
449     else:
450         name = str(path)
451         if path.is_absolute() and not os.path.isabs(pattern):
452             pattern = f"*{os.sep}{pattern}"
453     return fnmatch.fnmatch(name, pattern)
454 
455 
456 def parts(s: str) -> Set[str]:
457     parts = s.split(sep)
458     return {sep.join(parts[: i + 1]) or sep for i in range(len(parts))}
459 
460 
461 def symlink_or_skip(src, dst, **kwargs):
462     """Make a symlink, or skip the test in case symlinks are not supported."""
463     try:
464         os.symlink(str(src), str(dst), **kwargs)
465     except OSError as e:
466         skip(f"symlinks not supported: {e}")
467 
468 
469 class ImportMode(Enum):
470     """Possible values for `mode` parameter of `import_path`."""
471 
472     prepend = "prepend"
473     append = "append"
474     importlib = "importlib"
475 
476 
477 class ImportPathMismatchError(ImportError):
478     """Raised on import_path() if there is a mismatch of __file__'s.
479 
480     This can happen when `import_path` is called multiple times with different filenames that has
481     the same basename but reside in packages
482     (for example "/tests1/test_foo.py" and "/tests2/test_foo.py").
483     """
484 
485 
486 def import_path(
487     p: Union[str, "os.PathLike[str]"],
488     *,
489     mode: Union[str, ImportMode] = ImportMode.prepend,
490     root: Path,
491 ) -> ModuleType:
492     """Import and return a module from the given path, which can be a file (a module) or
493     a directory (a package).
494 
495     The import mechanism used is controlled by the `mode` parameter:
496 
497     * `mode == ImportMode.prepend`: the directory containing the module (or package, taking
498       `__init__.py` files into account) will be put at the *start* of `sys.path` before
499       being imported with `importlib.import_module`.
500 
501     * `mode == ImportMode.append`: same as `prepend`, but the directory will be appended
502       to the end of `sys.path`, if not already in `sys.path`.
503 
504     * `mode == ImportMode.importlib`: uses more fine control mechanisms provided by `importlib`
505       to import the module, which avoids having to muck with `sys.path` at all. It effectively
506       allows having same-named test modules in different places.
507 
508     :param root:
509         Used as an anchor when mode == ImportMode.importlib to obtain
510         a unique name for the module being imported so it can safely be stored
511         into ``sys.modules``.
512 
513     :raises ImportPathMismatchError:
514         If after importing the given `path` and the module `__file__`
515         are different. Only raised in `prepend` and `append` modes.
516     """
517     mode = ImportMode(mode)
518 
519     path = Path(p)
520 
521     if not path.exists():
522         raise ImportError(path)
523 
524     if mode is ImportMode.importlib:
525         module_name = module_name_from_path(path, root)
526 
527         for meta_importer in sys.meta_path:
528             spec = meta_importer.find_spec(module_name, [str(path.parent)])
529             if spec is not None:
530                 break
531         else:
532             spec = importlib.util.spec_from_file_location(module_name, str(path))
533 
534         if spec is None:
535             raise ImportError(f"Can't find module {module_name} at location {path}")
536         mod = importlib.util.module_from_spec(spec)
537         sys.modules[module_name] = mod
538         spec.loader.exec_module(mod)  # type: ignore[union-attr]
539         insert_missing_modules(sys.modules, module_name)
540         return mod
541 
542     pkg_path = resolve_package_path(path)
543     if pkg_path is not None:
544         pkg_root = pkg_path.parent
545         names = list(path.with_suffix("").relative_to(pkg_root).parts)
546         if names[-1] == "__init__":
547             names.pop()
548         module_name = ".".join(names)
549     else:
550         pkg_root = path.parent
551         module_name = path.stem
552 
553     # Change sys.path permanently: restoring it at the end of this function would cause surprising
554     # problems because of delayed imports: for example, a conftest.py file imported by this function
555     # might have local imports, which would fail at runtime if we restored sys.path.
556     if mode is ImportMode.append:
557         if str(pkg_root) not in sys.path:
558             sys.path.append(str(pkg_root))
559     elif mode is ImportMode.prepend:
560         if str(pkg_root) != sys.path[0]:
561             sys.path.insert(0, str(pkg_root))
562     else:
563         assert_never(mode)
564 
565     importlib.import_module(module_name)
566 
567     mod = sys.modules[module_name]
568     if path.name == "__init__.py":
569         return mod
570 
571     ignore = os.environ.get("PY_IGNORE_IMPORTMISMATCH", "")
572     if ignore != "1":
573         module_file = mod.__file__
574         if module_file is None:
575             raise ImportPathMismatchError(module_name, module_file, path)
576 
577         if module_file.endswith((".pyc", ".pyo")):
578             module_file = module_file[:-1]
579         if module_file.endswith(os.sep + "__init__.py"):
580             module_file = module_file[: -(len(os.sep + "__init__.py"))]
581 
582         try:
583             is_same = _is_same(str(path), module_file)
584         except FileNotFoundError:
585             is_same = False
586 
587         if not is_same:
588             raise ImportPathMismatchError(module_name, module_file, path)
589 
590     return mod
591 
592 
593 # Implement a special _is_same function on Windows which returns True if the two filenames
594 # compare equal, to circumvent os.path.samefile returning False for mounts in UNC (#7678).
595 if sys.platform.startswith("win"):
596 
597     def _is_same(f1: str, f2: str) -> bool:
598         return Path(f1) == Path(f2) or os.path.samefile(f1, f2)
599 
600 else:
601 
602     def _is_same(f1: str, f2: str) -> bool:
603         return os.path.samefile(f1, f2)
604 
605 
606 def module_name_from_path(path: Path, root: Path) -> str:
607     """
608     Return a dotted module name based on the given path, anchored on root.
609 
610     For example: path="projects/src/tests/test_foo.py" and root="/projects", the
611     resulting module name will be "src.tests.test_foo".
612     """
613     path = path.with_suffix("")
614     try:
615         relative_path = path.relative_to(root)
616     except ValueError:
617         # If we can't get a relative path to root, use the full path, except
618         # for the first part ("d:\\" or "/" depending on the platform, for example).
619         path_parts = path.parts[1:]
620     else:
621         # Use the parts for the relative path to the root path.
622         path_parts = relative_path.parts
623 
624     return ".".join(path_parts)
625 
626 
627 def insert_missing_modules(modules: Dict[str, ModuleType], module_name: str) -> None:
628     """
629     Used by ``import_path`` to create intermediate modules when using mode=importlib.
630 
631     When we want to import a module as "src.tests.test_foo" for example, we need
632     to create empty modules "src" and "src.tests" after inserting "src.tests.test_foo",
633     otherwise "src.tests.test_foo" is not importable by ``__import__``.
634     """
635     module_parts = module_name.split(".")
636     child_module: Union[ModuleType, None] = None
637     module: Union[ModuleType, None] = None
638     child_name: str = ""
639     while module_name:
640         if module_name not in modules:
641             try:
642                 # If sys.meta_path is empty, calling import_module will issue
643                 # a warning and raise ModuleNotFoundError. To avoid the
644                 # warning, we check sys.meta_path explicitly and raise the error
645                 # ourselves to fall back to creating a dummy module.
646                 if not sys.meta_path:
647                     raise ModuleNotFoundError
648                 module = importlib.import_module(module_name)
649             except ModuleNotFoundError:
650                 module = ModuleType(
651                     module_name,
652                     doc="Empty module created by pytest's importmode=importlib.",
653                 )
654         else:
655             module = modules[module_name]
656         if child_module:
657             # Add child attribute to the parent that can reference the child
658             # modules.
659             if not hasattr(module, child_name):
660                 setattr(module, child_name, child_module)
661                 modules[module_name] = module
662         # Keep track of the child module while moving up the tree.
663         child_module, child_name = module, module_name.rpartition(".")[-1]
664         module_parts.pop(-1)
665         module_name = ".".join(module_parts)
666 
667 
668 def resolve_package_path(path: Path) -> Optional[Path]:
669     """Return the Python package path by looking for the last
670     directory upwards which still contains an __init__.py.
671 
672     Returns None if it can not be determined.
673     """
674     result = None
675     for parent in itertools.chain((path,), path.parents):
676         if parent.is_dir():
677             if not parent.joinpath("__init__.py").is_file():
678                 break
679             if not parent.name.isidentifier():
680                 break
681             result = parent
682     return result
683 
684 
685 def scandir(path: Union[str, "os.PathLike[str]"]) -> List["os.DirEntry[str]"]:
686     """Scan a directory recursively, in breadth-first order.
687 
688     The returned entries are sorted.
689     """
690     entries = []
691     with os.scandir(path) as s:
692         # Skip entries with symlink loops and other brokenness, so the caller
693         # doesn't have to deal with it.
694         for entry in s:
695             try:
696                 entry.is_file()
697             except OSError as err:
698                 if _ignore_error(err):
699                     continue
700                 raise
701             entries.append(entry)
702     entries.sort(key=lambda entry: entry.name)
703     return entries
704 
705 
706 def visit(
707     path: Union[str, "os.PathLike[str]"], recurse: Callable[["os.DirEntry[str]"], bool]
708 ) -> Iterator["os.DirEntry[str]"]:
709     """Walk a directory recursively, in breadth-first order.
710 
711     The `recurse` predicate determines whether a directory is recursed.
712 
713     Entries at each directory level are sorted.
714     """
715     entries = scandir(path)
716     yield from entries
717     for entry in entries:
718         if entry.is_dir() and recurse(entry):
719             yield from visit(entry.path, recurse)
720 
721 
722 def absolutepath(path: Union[Path, str]) -> Path:
723     """Convert a path to an absolute path using os.path.abspath.
724 
725     Prefer this over Path.resolve() (see #6523).
726     Prefer this over Path.absolute() (not public, doesn't normalize).
727     """
728     return Path(os.path.abspath(str(path)))
729 
730 
731 def commonpath(path1: Path, path2: Path) -> Optional[Path]:
732     """Return the common part shared with the other path, or None if there is
733     no common part.
734 
735     If one path is relative and one is absolute, returns None.
736     """
737     try:
738         return Path(os.path.commonpath((str(path1), str(path2))))
739     except ValueError:
740         return None
741 
742 
743 def bestrelpath(directory: Path, dest: Path) -> str:
744     """Return a string which is a relative path from directory to dest such
745     that directory/bestrelpath == dest.
746 
747     The paths must be either both absolute or both relative.
748 
749     If no such path can be determined, returns dest.
750     """
751     assert isinstance(directory, Path)
752     assert isinstance(dest, Path)
753     if dest == directory:
754         return os.curdir
755     # Find the longest common directory.
756     base = commonpath(directory, dest)
757     # Can be the case on Windows for two absolute paths on different drives.
758     # Can be the case for two relative paths without common prefix.
759     # Can be the case for a relative path and an absolute path.
760     if not base:
761         return str(dest)
762     reldirectory = directory.relative_to(base)
763     reldest = dest.relative_to(base)
764     return os.path.join(
765         # Back from directory to base.
766         *([os.pardir] * len(reldirectory.parts)),
767         # Forward from base to dest.
768         *reldest.parts,
769     )
770 
771 
772 # Originates from py. path.local.copy(), with siginficant trims and adjustments.
773 # TODO(py38): Replace with shutil.copytree(..., symlinks=True, dirs_exist_ok=True)
774 def copytree(source: Path, target: Path) -> None:
775     """Recursively copy a source directory to target."""
776     assert source.is_dir()
777     for entry in visit(source, recurse=lambda entry: not entry.is_symlink()):
778         x = Path(entry)
779         relpath = x.relative_to(source)
780         newx = target / relpath
781         newx.parent.mkdir(exist_ok=True)
782         if x.is_symlink():
783             newx.symlink_to(os.readlink(x))
784         elif x.is_file():
785             shutil.copyfile(x, newx)
786         elif x.is_dir():
787             newx.mkdir(exist_ok=True)

</code><intended_behavior>These files should correctly handle the resolution and import of modules in a way that's consistent with Python's expected behavior for namespace packages. This ensures that only one instance of each module exists within the application's runtime, specifically avoiding issues where one instance is used to set a configuration and another separate instance is checked for that configuration.</intended_behavior>]
2025-10-18 04:41:54.319 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-18 04:41:54.319 | INFO     | Search-only: skipping patch selection
2025-10-18 04:41:54.389 | INFO     | Task pytest-dev__pytest-11148 completed successfully.
2025-10-18 04:41:54.390 | INFO     | No patch generated. You can try running ACR again.
