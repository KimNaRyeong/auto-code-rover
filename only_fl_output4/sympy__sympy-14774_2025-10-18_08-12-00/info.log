2025-10-18 08:12:01.167 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-18 08:12:14.124 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=264, output_tokens=12, cost=0.003000
2025-10-18 08:12:23.237 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=444, output_tokens=394, cost=0.016260
2025-10-18 08:12:24.790 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 08:12:28.474 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=572, output_tokens=102, cost=0.008780
2025-10-18 08:12:28.482 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 08:12:32.694 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=456, output_tokens=85, cost=0.007110
2025-10-18 08:12:32.696 | INFO     | Refactored invocation argument parsing gives different result on 'get_code_around_line("sympy/printing/latex.py", 743, 10)': old result is ['sympy/printing/latex.py', '743', '10'], new result  is ['sympy/printing/latex.py', 743, 10]
2025-10-18 08:12:32.697 | DEBUG    | Extracted a valid json.
2025-10-18 08:12:32.697 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_code_in_file(\"inv_trig_table = [\\\"asin\\\", \\\"acos\\\", \\\"atan\\\", \\\"acot\\\"]\", \"sympy/printing/latex.py\")",
        "get_code_around_line(\"sympy/printing/latex.py\", 743, 10)"
    ],
    "bug_locations": []
}
2025-10-18 08:12:32.704 | INFO     | Refactored invocation argument parsing gives different result on 'get_code_around_line("sympy/printing/latex.py", 743, 10)': old result is ['sympy/printing/latex.py', '743', '10'], new result  is ['sympy/printing/latex.py', 743, 10]
2025-10-18 08:12:32.719 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 08:12:32.720 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 08:12:44.746 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1295, output_tokens=586, cost=0.030530
2025-10-18 08:12:44.759 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 08:12:51.291 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2097, output_tokens=244, cost=0.028290
2025-10-18 08:12:51.296 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 08:13:00.461 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=598, output_tokens=261, cost=0.013810
2025-10-18 08:13:00.462 | DEBUG    | Extracted a valid json.
2025-10-18 08:13:00.462 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "sympy/printing/latex.py",
            "class": "LatexPrinter",
            "method": "_print_Function",
            "intended_behavior": "The `_print_Function` method is meant to handle the printing of functions to LaTeX format correctly, adhering to the `inv_trig_style` specified by the user. To resolve the issue, the `inv_trig_table` within this method should be extended to include `acsc` and `asec`. By adding these to the `inv_trig_table`, the method should recognize `acsc(x)` and `asec(x)` as inverse trigonometric functions that, when `inv_trig_style=\"full\"` is used, are transformed to `'\\arccsc{\\left (x \\right )}'` and `'\\arcsec{\\left (x \\right )}'`. This change preserves the existing functionality for inverse trigonometric functions already covered (`asin`, `acos`, `atan`, `acot`) and extends it to the previously unsupported `acsc` and `asec`, aligning the behavior with user expectations and the documented or implied behavior of the setting."
        }
    ]
}
2025-10-18 08:13:00.473 | DEBUG    | Bug location extracted successfully: [<file>sympy/printing/latex.py</file>
<class>LatexPrinter</class>
<method>_print_Function</method>
<code>
715     def _print_Function(self, expr, exp=None):
716         r'''
717         Render functions to LaTeX, handling functions that LaTeX knows about
718         e.g., sin, cos, ... by using the proper LaTeX command (\sin, \cos, ...).
719         For single-letter function names, render them as regular LaTeX math
720         symbols. For multi-letter function names that LaTeX does not know
721         about, (e.g., Li, sech) use \operatorname{} so that the function name
722         is rendered in Roman font and LaTeX handles spacing properly.
723 
724         expr is the expression involving the function
725         exp is an exponent
726         '''
727         func = expr.func.__name__
728         if hasattr(self, '_print_' + func) and \
729             not isinstance(expr.func, UndefinedFunction):
730             return getattr(self, '_print_' + func)(expr, exp)
731         else:
732             args = [ str(self._print(arg)) for arg in expr.args ]
733             # How inverse trig functions should be displayed, formats are:
734             # abbreviated: asin, full: arcsin, power: sin^-1
735             inv_trig_style = self._settings['inv_trig_style']
736             # If we are dealing with a power-style inverse trig function
737             inv_trig_power_case = False
738             # If it is applicable to fold the argument brackets
739             can_fold_brackets = self._settings['fold_func_brackets'] and \
740                 len(args) == 1 and \
741                 not self._needs_function_brackets(expr.args[0])
742 
743             inv_trig_table = ["asin", "acos", "atan", "acot"]
744 
745             # If the function is an inverse trig function, handle the style
746             if func in inv_trig_table:
747                 if inv_trig_style == "abbreviated":
748                     func = func
749                 elif inv_trig_style == "full":
750                     func = "arc" + func[1:]
751                 elif inv_trig_style == "power":
752                     func = func[1:]
753                     inv_trig_power_case = True
754 
755                     # Can never fold brackets if we're raised to a power
756                     if exp is not None:
757                         can_fold_brackets = False
758 
759             if inv_trig_power_case:
760                 if func in accepted_latex_functions:
761                     name = r"\%s^{-1}" % func
762                 else:
763                     name = r"\operatorname{%s}^{-1}" % func
764             elif exp is not None:
765                 name = r'%s^{%s}' % (self._hprint_Function(func), exp)
766             else:
767                 name = self._hprint_Function(func)
768 
769             if can_fold_brackets:
770                 if func in accepted_latex_functions:
771                     # Wrap argument safely to avoid parse-time conflicts
772                     # with the function name itself
773                     name += r" {%s}"
774                 else:
775                     name += r"%s"
776             else:
777                 name += r"{\left (%s \right )}"
778 
779             if inv_trig_power_case and exp is not None:
780                 name += r"^{%s}" % exp
781 
782             return name % ",".join(args)

</code><intended_behavior>The `_print_Function` method is meant to handle the printing of functions to LaTeX format correctly, adhering to the `inv_trig_style` specified by the user. To resolve the issue, the `inv_trig_table` within this method should be extended to include `acsc` and `asec`. By adding these to the `inv_trig_table`, the method should recognize `acsc(x)` and `asec(x)` as inverse trigonometric functions that, when `inv_trig_style="full"` is used, are transformed to `'\arccsc{\left (x \right )}'` and `'\arcsec{\left (x \right )}'`. This change preserves the existing functionality for inverse trigonometric functions already covered (`asin`, `acos`, `atan`, `acot`) and extends it to the previously unsupported `acsc` and `asec`, aligning the behavior with user expectations and the documented or implied behavior of the setting.</intended_behavior>, <file>sympy/printing/latex.py</file>
<class>LatexPrinter</class>
<method>None</method>
<code>
121 class LatexPrinter(Printer):
122     printmethod = "_latex"
123 
124     _default_settings = {
125         "order": None,
126         "mode": "plain",
127         "itex": False,
128         "fold_frac_powers": False,
129         "fold_func_brackets": False,
130         "fold_short_frac": None,
131         "long_frac_ratio": None,
132         "mul_symbol": None,
133         "inv_trig_style": "abbreviated",
134         "mat_str": None,
135         "mat_delim": "[",
136         "symbol_names": {},
137         "ln_notation": False,
138     }
139 
140     def __init__(self, settings=None):
141         Printer.__init__(self, settings)
142 
143         if 'mode' in self._settings:
144             valid_modes = ['inline', 'plain', 'equation',
145                            'equation*']
146             if self._settings['mode'] not in valid_modes:
147                 raise ValueError("'mode' must be one of 'inline', 'plain', "
148                     "'equation' or 'equation*'")
149 
150         if self._settings['fold_short_frac'] is None and \
151                 self._settings['mode'] == 'inline':
152             self._settings['fold_short_frac'] = True
153 
154         mul_symbol_table = {
155             None: r" ",
156             "ldot": r" \,.\, ",
157             "dot": r" \cdot ",
158             "times": r" \times "
159         }
160         try:
161             self._settings['mul_symbol_latex'] = \
162                 mul_symbol_table[self._settings['mul_symbol']]
163         except KeyError:
164             self._settings['mul_symbol_latex'] = \
165                 self._settings['mul_symbol']
166         try:
167             self._settings['mul_symbol_latex_numbers'] = \
168                 mul_symbol_table[self._settings['mul_symbol'] or 'dot']
169         except KeyError:
170             if (self._settings['mul_symbol'].strip() in
171                     ['', ' ', '\\', '\\,', '\\:', '\\;', '\\quad']):
172                 self._settings['mul_symbol_latex_numbers'] = \
173                     mul_symbol_table['dot']
174             else:
175                 self._settings['mul_symbol_latex_numbers'] = \
176                     self._settings['mul_symbol']
177 
178         self._delim_dict = {'(': ')', '[': ']'}
179 
180     def parenthesize(self, item, level, strict=False):
181         prec_val = precedence_traditional(item)
182         if (prec_val < level) or ((not strict) and prec_val <= level):
183             return r"\left(%s\right)" % self._print(item)
184         else:
185             return self._print(item)
186 
187     def doprint(self, expr):
188         tex = Printer.doprint(self, expr)
189 
190         if self._settings['mode'] == 'plain':
191             return tex
192         elif self._settings['mode'] == 'inline':
193             return r"$%s$" % tex
194         elif self._settings['itex']:
195             return r"$$%s$$" % tex
196         else:
197             env_str = self._settings['mode']
198             return r"\begin{%s}%s\end{%s}" % (env_str, tex, env_str)
199 
200     def _needs_brackets(self, expr):
201         """
202         Returns True if the expression needs to be wrapped in brackets when
203         printed, False otherwise. For example: a + b => True; a => False;
204         10 => False; -10 => True.
205         """
206         return not ((expr.is_Integer and expr.is_nonnegative)
207                     or (expr.is_Atom and (expr is not S.NegativeOne
208                                           and expr.is_Rational is False)))
209 
210     def _needs_function_brackets(self, expr):
211         """
212         Returns True if the expression needs to be wrapped in brackets when
213         passed as an argument to a function, False otherwise. This is a more
214         liberal version of _needs_brackets, in that many expressions which need
215         to be wrapped in brackets when added/subtracted/raised to a power do
216         not need them when passed to a function. Such an example is a*b.
217         """
218         if not self._needs_brackets(expr):
219             return False
220         else:
221             # Muls of the form a*b*c... can be folded
222             if expr.is_Mul and not self._mul_is_clean(expr):
223                 return True
224             # Pows which don't need brackets can be folded
225             elif expr.is_Pow and not self._pow_is_clean(expr):
226                 return True
227             # Add and Function always need brackets
228             elif expr.is_Add or expr.is_Function:
229                 return True
230             else:
231                 return False
232 
233     def _needs_mul_brackets(self, expr, first=False, last=False):
234         """
235         Returns True if the expression needs to be wrapped in brackets when
236         printed as part of a Mul, False otherwise. This is True for Add,
237         but also for some container objects that would not need brackets
238         when appearing last in a Mul, e.g. an Integral. ``last=True``
239         specifies that this expr is the last to appear in a Mul.
240         ``first=True`` specifies that this expr is the first to appear in a Mul.
241         """
242         from sympy import Integral, Piecewise, Product, Sum
243 
244         if expr.is_Mul:
245             if not first and _coeff_isneg(expr):
246                 return True
247         elif precedence_traditional(expr) < PRECEDENCE["Mul"]:
248             return True
249         elif expr.is_Relational:
250             return True
251         if expr.is_Piecewise:
252             return True
253         if any([expr.has(x) for x in (Mod,)]):
254             return True
255         if (not last and
256             any([expr.has(x) for x in (Integral, Product, Sum)])):
257             return True
258 
259         return False
260 
261 
262     def _needs_add_brackets(self, expr):
263         """
264         Returns True if the expression needs to be wrapped in brackets when
265         printed as part of an Add, False otherwise.  This is False for most
266         things.
267         """
268         if expr.is_Relational:
269             return True
270         if any([expr.has(x) for x in (Mod,)]):
271             return True
272         if expr.is_Add:
273             return True
274         return False
275 
276 
277     def _mul_is_clean(self, expr):
278         for arg in expr.args:
279             if arg.is_Function:
280                 return False
281         return True
282 
283     def _pow_is_clean(self, expr):
284         return not self._needs_brackets(expr.base)
285 
286     def _do_exponent(self, expr, exp):
287         if exp is not None:
288             return r"\left(%s\right)^{%s}" % (expr, exp)
289         else:
290             return expr
291 
292     def _print_bool(self, e):
293         return r"\mathrm{%s}" % e
294 
295     _print_BooleanTrue = _print_bool
296     _print_BooleanFalse = _print_bool
297 
298     def _print_NoneType(self, e):
299         return r"\mathrm{%s}" % e
300 
301 
302     def _print_Add(self, expr, order=None):
303         if self.order == 'none':
304             terms = list(expr.args)
305         else:
306             terms = self._as_ordered_terms(expr, order=order)
307 
308         tex = ""
309         for i, term in enumerate(terms):
310             if i == 0:
311                 pass
312             elif _coeff_isneg(term):
313                 tex += " - "
314                 term = -term
315             else:
316                 tex += " + "
317             term_tex = self._print(term)
318             if self._needs_add_brackets(term):
319                 term_tex = r"\left(%s\right)" % term_tex
320             tex += term_tex
321 
322         return tex
323 
324     def _print_Cycle(self, expr):
325         from sympy.combinatorics.permutations import Permutation
326         if expr.size == 0:
327             return r"\left( \right)"
328         expr = Permutation(expr)
329         expr_perm = expr.cyclic_form
330         siz = expr.size
331         if expr.array_form[-1] == siz - 1:
332             expr_perm = expr_perm + [[siz - 1]]
333         term_tex = ''
334         for i in expr_perm:
335             term_tex += str(i).replace(',', r"\;")
336         term_tex = term_tex.replace('[', r"\left( ")
337         term_tex = term_tex.replace(']', r"\right)")
338         return term_tex
339 
340     _print_Permutation = _print_Cycle
341 
342     def _print_Float(self, expr):
343         # Based off of that in StrPrinter
344         dps = prec_to_dps(expr._prec)
345         str_real = mlib.to_str(expr._mpf_, dps, strip_zeros=True)
346 
347         # Must always have a mul symbol (as 2.5 10^{20} just looks odd)
348         # thus we use the number separator
349         separator = self._settings['mul_symbol_latex_numbers']
350 
351         if 'e' in str_real:
352             (mant, exp) = str_real.split('e')
353 
354             if exp[0] == '+':
355                 exp = exp[1:]
356 
357             return r"%s%s10^{%s}" % (mant, separator, exp)
358         elif str_real == "+inf":
359             return r"\infty"
360         elif str_real == "-inf":
361             return r"- \infty"
362         else:
363             return str_real
364 
365     def _print_Cross(self, expr):
366         vec1 = expr._expr1
367         vec2 = expr._expr2
368         return r"%s \times %s" % (self.parenthesize(vec1, PRECEDENCE['Mul']),
369                                   self.parenthesize(vec2, PRECEDENCE['Mul']))
370 
371     def _print_Curl(self, expr):
372         vec = expr._expr
373         return r"\nabla\times %s" % self.parenthesize(vec, PRECEDENCE['Mul'])
374 
375     def _print_Divergence(self, expr):
376         vec = expr._expr
377         return r"\nabla\cdot %s" % self.parenthesize(vec, PRECEDENCE['Mul'])
378 
379     def _print_Dot(self, expr):
380         vec1 = expr._expr1
381         vec2 = expr._expr2
382         return r"%s \cdot %s" % (self.parenthesize(vec1, PRECEDENCE['Mul']),
383                                   self.parenthesize(vec2, PRECEDENCE['Mul']))
384 
385     def _print_Gradient(self, expr):
386         func = expr._expr
387         return r"\nabla\cdot %s" % self.parenthesize(func, PRECEDENCE['Mul'])
388 
389     def _print_Mul(self, expr):
390         from sympy.core.power import Pow
391         from sympy.physics.units import Quantity
392         include_parens = False
393         if _coeff_isneg(expr):
394             expr = -expr
395             tex = "- "
396             if expr.is_Add:
397                 tex += "("
398                 include_parens = True
399         else:
400             tex = ""
401 
402         from sympy.simplify import fraction
403         numer, denom = fraction(expr, exact=True)
404         separator = self._settings['mul_symbol_latex']
405         numbersep = self._settings['mul_symbol_latex_numbers']
406 
407         def convert(expr):
408             if not expr.is_Mul:
409                 return str(self._print(expr))
410             else:
411                 _tex = last_term_tex = ""
412 
413                 if self.order not in ('old', 'none'):
414                     args = expr.as_ordered_factors()
415                 else:
416                     args = list(expr.args)
417 
418                 # If quantities are present append them at the back
419                 args = sorted(args, key=lambda x: isinstance(x, Quantity) or
420                              (isinstance(x, Pow) and isinstance(x.base, Quantity)))
421 
422                 for i, term in enumerate(args):
423                     term_tex = self._print(term)
424 
425                     if self._needs_mul_brackets(term, first=(i == 0),
426                                                 last=(i == len(args) - 1)):
427                         term_tex = r"\left(%s\right)" % term_tex
428 
429                     if _between_two_numbers_p[0].search(last_term_tex) and \
430                             _between_two_numbers_p[1].match(term_tex):
431                         # between two numbers
432                         _tex += numbersep
433                     elif _tex:
434                         _tex += separator
435 
436                     _tex += term_tex
437                     last_term_tex = term_tex
438                 return _tex
439 
440         if denom is S.One and Pow(1, -1, evaluate=False) not in expr.args:
441             # use the original expression here, since fraction() may have
442             # altered it when producing numer and denom
443             tex += convert(expr)
444 
445         else:
446             snumer = convert(numer)
447             sdenom = convert(denom)
448             ldenom = len(sdenom.split())
449             ratio = self._settings['long_frac_ratio']
450             if self._settings['fold_short_frac'] \
451                    and ldenom <= 2 and not "^" in sdenom:
452                 # handle short fractions
453                 if self._needs_mul_brackets(numer, last=False):
454                     tex += r"\left(%s\right) / %s" % (snumer, sdenom)
455                 else:
456                     tex += r"%s / %s" % (snumer, sdenom)
457             elif ratio is not None and \
458                     len(snumer.split()) > ratio*ldenom:
459                 # handle long fractions
460                 if self._needs_mul_brackets(numer, last=True):
461                     tex += r"\frac{1}{%s}%s\left(%s\right)" \
462                         % (sdenom, separator, snumer)
463                 elif numer.is_Mul:
464                     # split a long numerator
465                     a = S.One
466                     b = S.One
467                     for x in numer.args:
468                         if self._needs_mul_brackets(x, last=False) or \
469                                 len(convert(a*x).split()) > ratio*ldenom or \
470                                 (b.is_commutative is x.is_commutative is False):
471                             b *= x
472                         else:
473                             a *= x
474                     if self._needs_mul_brackets(b, last=True):
475                         tex += r"\frac{%s}{%s}%s\left(%s\right)" \
476                             % (convert(a), sdenom, separator, convert(b))
477                     else:
478                         tex += r"\frac{%s}{%s}%s%s" \
479                             % (convert(a), sdenom, separator, convert(b))
480                 else:
481                     tex += r"\frac{1}{%s}%s%s" % (sdenom, separator, snumer)
482             else:
483                 tex += r"\frac{%s}{%s}" % (snumer, sdenom)
484 
485         if include_parens:
486             tex += ")"
487         return tex
488 
489     def _print_Pow(self, expr):
490         # Treat x**Rational(1,n) as special case
491         if expr.exp.is_Rational and abs(expr.exp.p) == 1 and expr.exp.q != 1:
492             base = self._print(expr.base)
493             expq = expr.exp.q
494 
495             if expq == 2:
496                 tex = r"\sqrt{%s}" % base
497             elif self._settings['itex']:
498                 tex = r"\root{%d}{%s}" % (expq, base)
499             else:
500                 tex = r"\sqrt[%d]{%s}" % (expq, base)
501 
502             if expr.exp.is_negative:
503                 return r"\frac{1}{%s}" % tex
504             else:
505                 return tex
506         elif self._settings['fold_frac_powers'] \
507             and expr.exp.is_Rational \
508                 and expr.exp.q != 1:
509             base, p, q = self.parenthesize(expr.base, PRECEDENCE['Pow']), expr.exp.p, expr.exp.q
510             #fixes issue #12886, adds parentheses before superscripts raised to powers
511             if '^' in base and expr.base.is_Symbol:
512                 base = r"\left(%s\right)" % base
513             if expr.base.is_Function:
514                 return self._print(expr.base, "%s/%s" % (p, q))
515             return r"%s^{%s/%s}" % (base, p, q)
516         elif expr.exp.is_Rational and expr.exp.is_negative and expr.base.is_commutative:
517             # Things like 1/x
518             return self._print_Mul(expr)
519         else:
520             if expr.base.is_Function:
521                 return self._print(expr.base, self._print(expr.exp))
522             else:
523                 if expr.is_commutative and expr.exp == -1:
524                     #solves issue 4129
525                     #As Mul always simplify 1/x to x**-1
526                     #The objective is achieved with this hack
527                     #first we get the latex for -1 * expr,
528                     #which is a Mul expression
529                     tex = self._print(S.NegativeOne * expr).strip()
530                     #the result comes with a minus and a space, so we remove
531                     if tex[:1] == "-":
532                         return tex[1:].strip()
533                 tex = r"%s^{%s}"
534                 #fixes issue #12886, adds parentheses before superscripts raised to powers
535                 base = self.parenthesize(expr.base, PRECEDENCE['Pow'])
536                 if '^' in base and expr.base.is_Symbol:
537                     base = r"\left(%s\right)" % base
538                 exp = self._print(expr.exp)
539 
540                 return tex % (base, exp)
541 
542     def _print_UnevaluatedExpr(self, expr):
543         return self._print(expr.args[0])
544 
545     def _print_Sum(self, expr):
546         if len(expr.limits) == 1:
547             tex = r"\sum_{%s=%s}^{%s} " % \
548                 tuple([ self._print(i) for i in expr.limits[0] ])
549         else:
550             def _format_ineq(l):
551                 return r"%s \leq %s \leq %s" % \
552                     tuple([self._print(s) for s in (l[1], l[0], l[2])])
553 
554             tex = r"\sum_{\substack{%s}} " % \
555                 str.join('\\\\', [ _format_ineq(l) for l in expr.limits ])
556 
557         if isinstance(expr.function, Add):
558             tex += r"\left(%s\right)" % self._print(expr.function)
559         else:
560             tex += self._print(expr.function)
561 
562         return tex
563 
564     def _print_Product(self, expr):
565         if len(expr.limits) == 1:
566             tex = r"\prod_{%s=%s}^{%s} " % \
567                 tuple([ self._print(i) for i in expr.limits[0] ])
568         else:
569             def _format_ineq(l):
570                 return r"%s \leq %s \leq %s" % \
571                     tuple([self._print(s) for s in (l[1], l[0], l[2])])
572 
573             tex = r"\prod_{\substack{%s}} " % \
574                 str.join('\\\\', [ _format_ineq(l) for l in expr.limits ])
575 
576         if isinstance(expr.function, Add):
577             tex += r"\left(%s\right)" % self._print(expr.function)
578         else:
579             tex += self._print(expr.function)
580 
581         return tex
582 
583     def _print_BasisDependent(self, expr):
584         from sympy.vector import Vector
585 
586         o1 = []
587         if expr == expr.zero:
588             return expr.zero._latex_form
589         if isinstance(expr, Vector):
590             items = expr.separate().items()
591         else:
592             items = [(0, expr)]
593 
594         for system, vect in items:
595             inneritems = list(vect.components.items())
596             inneritems.sort(key = lambda x:x[0].__str__())
597             for k, v in inneritems:
598                 if v == 1:
599                     o1.append(' + ' + k._latex_form)
600                 elif v == -1:
601                     o1.append(' - ' + k._latex_form)
602                 else:
603                     arg_str = '(' + LatexPrinter().doprint(v) + ')'
604                     o1.append(' + ' + arg_str + k._latex_form)
605 
606         outstr = (''.join(o1))
607         if outstr[1] != '-':
608             outstr = outstr[3:]
609         else:
610             outstr = outstr[1:]
611         return outstr
612 
613     def _print_Indexed(self, expr):
614         tex = self._print(expr.base)+'_{%s}' % ','.join(
615             map(self._print, expr.indices))
616         return tex
617 
618     def _print_IndexedBase(self, expr):
619         return self._print(expr.label)
620 
621     def _print_Derivative(self, expr):
622         if requires_partial(expr):
623             diff_symbol = r'\partial'
624         else:
625             diff_symbol = r'd'
626 
627         tex = ""
628         dim = 0
629         for x, num in reversed(expr.variable_count):
630             dim += num
631             if num == 1:
632                 tex += r"%s %s" % (diff_symbol, self._print(x))
633             else:
634                 tex += r"%s %s^{%s}" % (diff_symbol, self._print(x), num)
635 
636         if dim == 1:
637             tex = r"\frac{%s}{%s}" % (diff_symbol, tex)
638         else:
639             tex = r"\frac{%s^{%s}}{%s}" % (diff_symbol, dim, tex)
640 
641         return r"%s %s" % (tex, self.parenthesize(expr.expr, PRECEDENCE["Mul"], strict=True))
642 
643     def _print_Subs(self, subs):
644         expr, old, new = subs.args
645         latex_expr = self._print(expr)
646         latex_old = (self._print(e) for e in old)
647         latex_new = (self._print(e) for e in new)
648         latex_subs = r'\\ '.join(
649             e[0] + '=' + e[1] for e in zip(latex_old, latex_new))
650         return r'\left. %s \right|_{\substack{ %s }}' % (latex_expr, latex_subs)
651 
652     def _print_Integral(self, expr):
653         tex, symbols = "", []
654 
655         # Only up to \iiiint exists
656         if len(expr.limits) <= 4 and all(len(lim) == 1 for lim in expr.limits):
657             # Use len(expr.limits)-1 so that syntax highlighters don't think
658             # \" is an escaped quote
659             tex = r"\i" + "i"*(len(expr.limits) - 1) + "nt"
660             symbols = [r"\, d%s" % self._print(symbol[0])
661                        for symbol in expr.limits]
662 
663         else:
664             for lim in reversed(expr.limits):
665                 symbol = lim[0]
666                 tex += r"\int"
667 
668                 if len(lim) > 1:
669                     if self._settings['mode'] in ['equation', 'equation*'] \
670                             and not self._settings['itex']:
671                         tex += r"\limits"
672 
673                     if len(lim) == 3:
674                         tex += "_{%s}^{%s}" % (self._print(lim[1]),
675                                                self._print(lim[2]))
676                     if len(lim) == 2:
677                         tex += "^{%s}" % (self._print(lim[1]))
678 
679                 symbols.insert(0, r"\, d%s" % self._print(symbol))
680 
681         return r"%s %s%s" % (tex,
682             self.parenthesize(expr.function, PRECEDENCE["Mul"], strict=True), "".join(symbols))
683 
684     def _print_Limit(self, expr):
685         e, z, z0, dir = expr.args
686 
687         tex = r"\lim_{%s \to " % self._print(z)
688         if str(dir) == '+-' or z0 in (S.Infinity, S.NegativeInfinity):
689             tex += r"%s}" % self._print(z0)
690         else:
691             tex += r"%s^%s}" % (self._print(z0), self._print(dir))
692 
693         if isinstance(e, AssocOp):
694             return r"%s\left(%s\right)" % (tex, self._print(e))
695         else:
696             return r"%s %s" % (tex, self._print(e))
697 
698     def _hprint_Function(self, func):
699         r'''
700         Logic to decide how to render a function to latex
701           - if it is a recognized latex name, use the appropriate latex command
702           - if it is a single letter, just use that letter
703           - if it is a longer name, then put \operatorname{} around it and be
704             mindful of undercores in the name
705         '''
706         func = self._deal_with_super_sub(func)
707         if func in accepted_latex_functions:
708             name = r"\%s" % func
709         elif len(func) == 1 or func.startswith('\\'):
710             name = func
711         else:
712             name = r"\operatorname{%s}" % func
713         return name
714 
715     def _print_Function(self, expr, exp=None):
716         r'''
717         Render functions to LaTeX, handling functions that LaTeX knows about
718         e.g., sin, cos, ... by using the proper LaTeX command (\sin, \cos, ...).
719         For single-letter function names, render them as regular LaTeX math
720         symbols. For multi-letter function names that LaTeX does not know
721         about, (e.g., Li, sech) use \operatorname{} so that the function name
722         is rendered in Roman font and LaTeX handles spacing properly.
723 
724         expr is the expression involving the function
725         exp is an exponent
726         '''
727         func = expr.func.__name__
728         if hasattr(self, '_print_' + func) and \
729             not isinstance(expr.func, UndefinedFunction):
730             return getattr(self, '_print_' + func)(expr, exp)
731         else:
732             args = [ str(self._print(arg)) for arg in expr.args ]
733             # How inverse trig functions should be displayed, formats are:
734             # abbreviated: asin, full: arcsin, power: sin^-1
735             inv_trig_style = self._settings['inv_trig_style']
736             # If we are dealing with a power-style inverse trig function
737             inv_trig_power_case = False
738             # If it is applicable to fold the argument brackets
739             can_fold_brackets = self._settings['fold_func_brackets'] and \
740                 len(args) == 1 and \
741                 not self._needs_function_brackets(expr.args[0])
742 
743             inv_trig_table = ["asin", "acos", "atan", "acot"]
744 
745             # If the function is an inverse trig function, handle the style
746             if func in inv_trig_table:
747                 if inv_trig_style == "abbreviated":
748                     func = func
749                 elif inv_trig_style == "full":
750                     func = "arc" + func[1:]
751                 elif inv_trig_style == "power":
752                     func = func[1:]
753                     inv_trig_power_case = True
754 
755                     # Can never fold brackets if we're raised to a power
756                     if exp is not None:
757                         can_fold_brackets = False
758 
759             if inv_trig_power_case:
760                 if func in accepted_latex_functions:
761                     name = r"\%s^{-1}" % func
762                 else:
763                     name = r"\operatorname{%s}^{-1}" % func
764             elif exp is not None:
765                 name = r'%s^{%s}' % (self._hprint_Function(func), exp)
766             else:
767                 name = self._hprint_Function(func)
768 
769             if can_fold_brackets:
770                 if func in accepted_latex_functions:
771                     # Wrap argument safely to avoid parse-time conflicts
772                     # with the function name itself
773                     name += r" {%s}"
774                 else:
775                     name += r"%s"
776             else:
777                 name += r"{\left (%s \right )}"
778 
779             if inv_trig_power_case and exp is not None:
780                 name += r"^{%s}" % exp
781 
782             return name % ",".join(args)
783 
784     def _print_UndefinedFunction(self, expr):
785         return self._hprint_Function(str(expr))
786 
787     @property
788     def _special_function_classes(self):
789         from sympy.functions.special.tensor_functions import KroneckerDelta
790         from sympy.functions.special.gamma_functions import gamma, lowergamma
791         from sympy.functions.special.beta_functions import beta
792         from sympy.functions.special.delta_functions import DiracDelta
793         from sympy.functions.special.error_functions import Chi
794         return {KroneckerDelta: r'\delta',
795                 gamma:  r'\Gamma',
796                 lowergamma: r'\gamma',
797                 beta: r'\operatorname{B}',
798                 DiracDelta: r'\delta',
799                 Chi: r'\operatorname{Chi}'}
800 
801     def _print_FunctionClass(self, expr):
802         for cls in self._special_function_classes:
803             if issubclass(expr, cls) and expr.__name__ == cls.__name__:
804                 return self._special_function_classes[cls]
805         return self._hprint_Function(str(expr))
806 
807     def _print_Lambda(self, expr):
808         symbols, expr = expr.args
809 
810         if len(symbols) == 1:
811             symbols = self._print(symbols[0])
812         else:
813             symbols = self._print(tuple(symbols))
814 
815         args = (symbols, self._print(expr))
816         tex = r"\left( %s \mapsto %s \right)" % (symbols, self._print(expr))
817 
818         return tex
819 
820     def _print_Min(self, expr, exp=None):
821         args = sorted(expr.args, key=default_sort_key)
822         texargs = [r"%s" % self._print(symbol) for symbol in args]
823         tex = r"\min\left(%s\right)" % ", ".join(texargs)
824 
825         if exp is not None:
826             return r"%s^{%s}" % (tex, exp)
827         else:
828             return tex
829 
830     def _print_Max(self, expr, exp=None):
831         args = sorted(expr.args, key=default_sort_key)
832         texargs = [r"%s" % self._print(symbol) for symbol in args]
833         tex = r"\max\left(%s\right)" % ", ".join(texargs)
834 
835         if exp is not None:
836             return r"%s^{%s}" % (tex, exp)
837         else:
838             return tex
839 
840     def _print_floor(self, expr, exp=None):
841         tex = r"\lfloor{%s}\rfloor" % self._print(expr.args[0])
842 
843         if exp is not None:
844             return r"%s^{%s}" % (tex, exp)
845         else:
846             return tex
847 
848     def _print_ceiling(self, expr, exp=None):
849         tex = r"\lceil{%s}\rceil" % self._print(expr.args[0])
850 
851         if exp is not None:
852             return r"%s^{%s}" % (tex, exp)
853         else:
854             return tex
855 
856     def _print_log(self, expr, exp=None):
857         if not self._settings["ln_notation"]:
858             tex = r"\log{\left (%s \right )}" % self._print(expr.args[0])
859         else:
860             tex = r"\ln{\left (%s \right )}" % self._print(expr.args[0])
861 
862         if exp is not None:
863             return r"%s^{%s}" % (tex, exp)
864         else:
865             return tex
866 
867     def _print_Abs(self, expr, exp=None):
868         tex = r"\left|{%s}\right|" % self._print(expr.args[0])
869 
870         if exp is not None:
871             return r"%s^{%s}" % (tex, exp)
872         else:
873             return tex
874     _print_Determinant = _print_Abs
875 
876     def _print_re(self, expr, exp=None):
877         tex = r"\Re{%s}" % self.parenthesize(expr.args[0], PRECEDENCE['Atom'])
878 
879         return self._do_exponent(tex, exp)
880 
881     def _print_im(self, expr, exp=None):
882         tex = r"\Im{%s}" % self.parenthesize(expr.args[0], PRECEDENCE['Func'])
883 
884         return self._do_exponent(tex, exp)
885 
886     def _print_Not(self, e):
887         from sympy import Equivalent, Implies
888         if isinstance(e.args[0], Equivalent):
889             return self._print_Equivalent(e.args[0], r"\not\Leftrightarrow")
890         if isinstance(e.args[0], Implies):
891             return self._print_Implies(e.args[0], r"\not\Rightarrow")
892         if (e.args[0].is_Boolean):
893             return r"\neg (%s)" % self._print(e.args[0])
894         else:
895             return r"\neg %s" % self._print(e.args[0])
896 
897     def _print_LogOp(self, args, char):
898         arg = args[0]
899         if arg.is_Boolean and not arg.is_Not:
900             tex = r"\left(%s\right)" % self._print(arg)
901         else:
902             tex = r"%s" % self._print(arg)
903 
904         for arg in args[1:]:
905             if arg.is_Boolean and not arg.is_Not:
906                 tex += r" %s \left(%s\right)" % (char, self._print(arg))
907             else:
908                 tex += r" %s %s" % (char, self._print(arg))
909 
910         return tex
911 
912     def _print_And(self, e):
913         args = sorted(e.args, key=default_sort_key)
914         return self._print_LogOp(args, r"\wedge")
915 
916     def _print_Or(self, e):
917         args = sorted(e.args, key=default_sort_key)
918         return self._print_LogOp(args, r"\vee")
919 
920     def _print_Xor(self, e):
921         args = sorted(e.args, key=default_sort_key)
922         return self._print_LogOp(args, r"\veebar")
923 
924     def _print_Implies(self, e, altchar=None):
925         return self._print_LogOp(e.args, altchar or r"\Rightarrow")
926 
927     def _print_Equivalent(self, e, altchar=None):
928         args = sorted(e.args, key=default_sort_key)
929         return self._print_LogOp(args, altchar or r"\Leftrightarrow")
930 
931     def _print_conjugate(self, expr, exp=None):
932         tex = r"\overline{%s}" % self._print(expr.args[0])
933 
934         if exp is not None:
935             return r"%s^{%s}" % (tex, exp)
936         else:
937             return tex
938 
939     def _print_polar_lift(self, expr, exp=None):
940         func = r"\operatorname{polar\_lift}"
941         arg = r"{\left (%s \right )}" % self._print(expr.args[0])
942 
943         if exp is not None:
944             return r"%s^{%s}%s" % (func, exp, arg)
945         else:
946             return r"%s%s" % (func, arg)
947 
948     def _print_ExpBase(self, expr, exp=None):
949         # TODO should exp_polar be printed differently?
950         #      what about exp_polar(0), exp_polar(1)?
951         tex = r"e^{%s}" % self._print(expr.args[0])
952         return self._do_exponent(tex, exp)
953 
954     def _print_elliptic_k(self, expr, exp=None):
955         tex = r"\left(%s\right)" % self._print(expr.args[0])
956         if exp is not None:
957             return r"K^{%s}%s" % (exp, tex)
958         else:
959             return r"K%s" % tex
960 
961     def _print_elliptic_f(self, expr, exp=None):
962         tex = r"\left(%s\middle| %s\right)" % \
963             (self._print(expr.args[0]), self._print(expr.args[1]))
964         if exp is not None:
965             return r"F^{%s}%s" % (exp, tex)
966         else:
967             return r"F%s" % tex
968 
969     def _print_elliptic_e(self, expr, exp=None):
970         if len(expr.args) == 2:
971             tex = r"\left(%s\middle| %s\right)" % \
972                 (self._print(expr.args[0]), self._print(expr.args[1]))
973         else:
974             tex = r"\left(%s\right)" % self._print(expr.args[0])
975         if exp is not None:
976             return r"E^{%s}%s" % (exp, tex)
977         else:
978             return r"E%s" % tex
979 
980     def _print_elliptic_pi(self, expr, exp=None):
981         if len(expr.args) == 3:
982             tex = r"\left(%s; %s\middle| %s\right)" % \
983                 (self._print(expr.args[0]), self._print(expr.args[1]), \
984                  self._print(expr.args[2]))
985         else:
986             tex = r"\left(%s\middle| %s\right)" % \
987                 (self._print(expr.args[0]), self._print(expr.args[1]))
988         if exp is not None:
989             return r"\Pi^{%s}%s" % (exp, tex)
990         else:
991             return r"\Pi%s" % tex
992 
993     def _print_beta(self, expr, exp=None):
994         tex = r"\left(%s, %s\right)" % (self._print(expr.args[0]),
995                                         self._print(expr.args[1]))
996 
997         if exp is not None:
998             return r"\operatorname{B}^{%s}%s" % (exp, tex)
999         else:
1000             return r"\operatorname{B}%s" % tex
1001 
1002     def _print_gamma(self, expr, exp=None):
1003         tex = r"\left(%s\right)" % self._print(expr.args[0])
1004 
1005         if exp is not None:
1006             return r"\Gamma^{%s}%s" % (exp, tex)
1007         else:
1008             return r"\Gamma%s" % tex
1009 
1010     def _print_uppergamma(self, expr, exp=None):
1011         tex = r"\left(%s, %s\right)" % (self._print(expr.args[0]),
1012                                         self._print(expr.args[1]))
1013 
1014         if exp is not None:
1015             return r"\Gamma^{%s}%s" % (exp, tex)
1016         else:
1017             return r"\Gamma%s" % tex
1018 
1019     def _print_lowergamma(self, expr, exp=None):
1020         tex = r"\left(%s, %s\right)" % (self._print(expr.args[0]),
1021                                         self._print(expr.args[1]))
1022 
1023         if exp is not None:
1024             return r"\gamma^{%s}%s" % (exp, tex)
1025         else:
1026             return r"\gamma%s" % tex
1027 
1028     def _print_Chi(self, expr, exp=None):
1029         tex = r"\left(%s\right)" % self._print(expr.args[0])
1030 
1031         if exp is not None:
1032             return r"\operatorname{Chi}^{%s}%s" % (exp, tex)
1033         else:
1034             return r"\operatorname{Chi}%s" % tex
1035 
1036     def _print_expint(self, expr, exp=None):
1037         tex = r"\left(%s\right)" % self._print(expr.args[1])
1038         nu = self._print(expr.args[0])
1039 
1040         if exp is not None:
1041             return r"\operatorname{E}_{%s}^{%s}%s" % (nu, exp, tex)
1042         else:
1043             return r"\operatorname{E}_{%s}%s" % (nu, tex)
1044 
1045     def _print_fresnels(self, expr, exp=None):
1046         tex = r"\left(%s\right)" % self._print(expr.args[0])
1047 
1048         if exp is not None:
1049             return r"S^{%s}%s" % (exp, tex)
1050         else:
1051             return r"S%s" % tex
1052 
1053     def _print_fresnelc(self, expr, exp=None):
1054         tex = r"\left(%s\right)" % self._print(expr.args[0])
1055 
1056         if exp is not None:
1057             return r"C^{%s}%s" % (exp, tex)
1058         else:
1059             return r"C%s" % tex
1060 
1061     def _print_subfactorial(self, expr, exp=None):
1062         tex = r"!%s" % self.parenthesize(expr.args[0], PRECEDENCE["Func"])
1063 
1064         if exp is not None:
1065             return r"%s^{%s}" % (tex, exp)
1066         else:
1067             return tex
1068 
1069     def _print_factorial(self, expr, exp=None):
1070         tex = r"%s!" % self.parenthesize(expr.args[0], PRECEDENCE["Func"])
1071 
1072         if exp is not None:
1073             return r"%s^{%s}" % (tex, exp)
1074         else:
1075             return tex
1076 
1077     def _print_factorial2(self, expr, exp=None):
1078         tex = r"%s!!" % self.parenthesize(expr.args[0], PRECEDENCE["Func"])
1079 
1080         if exp is not None:
1081             return r"%s^{%s}" % (tex, exp)
1082         else:
1083             return tex
1084 
1085     def _print_binomial(self, expr, exp=None):
1086         tex = r"{\binom{%s}{%s}}" % (self._print(expr.args[0]),
1087                                      self._print(expr.args[1]))
1088 
1089         if exp is not None:
1090             return r"%s^{%s}" % (tex, exp)
1091         else:
1092             return tex
1093 
1094     def _print_RisingFactorial(self, expr, exp=None):
1095         n, k = expr.args
1096         base = r"%s" % self.parenthesize(n, PRECEDENCE['Func'])
1097 
1098         tex = r"{%s}^{\left(%s\right)}" % (base, self._print(k))
1099 
1100         return self._do_exponent(tex, exp)
1101 
1102     def _print_FallingFactorial(self, expr, exp=None):
1103         n, k = expr.args
1104         sub = r"%s" % self.parenthesize(k, PRECEDENCE['Func'])
1105 
1106         tex = r"{\left(%s\right)}_{%s}" % (self._print(n), sub)
1107 
1108         return self._do_exponent(tex, exp)
1109 
1110     def _hprint_BesselBase(self, expr, exp, sym):
1111         tex = r"%s" % (sym)
1112 
1113         need_exp = False
1114         if exp is not None:
1115             if tex.find('^') == -1:
1116                 tex = r"%s^{%s}" % (tex, self._print(exp))
1117             else:
1118                 need_exp = True
1119 
1120         tex = r"%s_{%s}\left(%s\right)" % (tex, self._print(expr.order),
1121                                            self._print(expr.argument))
1122 
1123         if need_exp:
1124             tex = self._do_exponent(tex, exp)
1125         return tex
1126 
1127     def _hprint_vec(self, vec):
1128         if len(vec) == 0:
1129             return ""
1130         s = ""
1131         for i in vec[:-1]:
1132             s += "%s, " % self._print(i)
1133         s += self._print(vec[-1])
1134         return s
1135 
1136     def _print_besselj(self, expr, exp=None):
1137         return self._hprint_BesselBase(expr, exp, 'J')
1138 
1139     def _print_besseli(self, expr, exp=None):
1140         return self._hprint_BesselBase(expr, exp, 'I')
1141 
1142     def _print_besselk(self, expr, exp=None):
1143         return self._hprint_BesselBase(expr, exp, 'K')
1144 
1145     def _print_bessely(self, expr, exp=None):
1146         return self._hprint_BesselBase(expr, exp, 'Y')
1147 
1148     def _print_yn(self, expr, exp=None):
1149         return self._hprint_BesselBase(expr, exp, 'y')
1150 
1151     def _print_jn(self, expr, exp=None):
1152         return self._hprint_BesselBase(expr, exp, 'j')
1153 
1154     def _print_hankel1(self, expr, exp=None):
1155         return self._hprint_BesselBase(expr, exp, 'H^{(1)}')
1156 
1157     def _print_hankel2(self, expr, exp=None):
1158         return self._hprint_BesselBase(expr, exp, 'H^{(2)}')
1159 
1160     def _print_hn1(self, expr, exp=None):
1161         return self._hprint_BesselBase(expr, exp, 'h^{(1)}')
1162 
1163     def _print_hn2(self, expr, exp=None):
1164         return self._hprint_BesselBase(expr, exp, 'h^{(2)}')
1165 
1166     def _hprint_airy(self, expr, exp=None, notation=""):
1167         tex = r"\left(%s\right)" % self._print(expr.args[0])
1168 
1169         if exp is not None:
1170             return r"%s^{%s}%s" % (notation, exp, tex)
1171         else:
1172             return r"%s%s" % (notation, tex)
1173 
1174     def _hprint_airy_prime(self, expr, exp=None, notation=""):
1175         tex = r"\left(%s\right)" % self._print(expr.args[0])
1176 
1177         if exp is not None:
1178             return r"{%s^\prime}^{%s}%s" % (notation, exp, tex)
1179         else:
1180             return r"%s^\prime%s" % (notation, tex)
1181 
1182     def _print_airyai(self, expr, exp=None):
1183         return self._hprint_airy(expr, exp, 'Ai')
1184 
1185     def _print_airybi(self, expr, exp=None):
1186         return self._hprint_airy(expr, exp, 'Bi')
1187 
1188     def _print_airyaiprime(self, expr, exp=None):
1189         return self._hprint_airy_prime(expr, exp, 'Ai')
1190 
1191     def _print_airybiprime(self, expr, exp=None):
1192         return self._hprint_airy_prime(expr, exp, 'Bi')
1193 
1194     def _print_hyper(self, expr, exp=None):
1195         tex = r"{{}_{%s}F_{%s}\left(\begin{matrix} %s \\ %s \end{matrix}" \
1196               r"\middle| {%s} \right)}" % \
1197             (self._print(len(expr.ap)), self._print(len(expr.bq)),
1198               self._hprint_vec(expr.ap), self._hprint_vec(expr.bq),
1199               self._print(expr.argument))
1200 
1201         if exp is not None:
1202             tex = r"{%s}^{%s}" % (tex, self._print(exp))
1203         return tex
1204 
1205     def _print_meijerg(self, expr, exp=None):
1206         tex = r"{G_{%s, %s}^{%s, %s}\left(\begin{matrix} %s & %s \\" \
1207               r"%s & %s \end{matrix} \middle| {%s} \right)}" % \
1208             (self._print(len(expr.ap)), self._print(len(expr.bq)),
1209               self._print(len(expr.bm)), self._print(len(expr.an)),
1210               self._hprint_vec(expr.an), self._hprint_vec(expr.aother),
1211               self._hprint_vec(expr.bm), self._hprint_vec(expr.bother),
1212               self._print(expr.argument))
1213 
1214         if exp is not None:
1215             tex = r"{%s}^{%s}" % (tex, self._print(exp))
1216         return tex
1217 
1218     def _print_dirichlet_eta(self, expr, exp=None):
1219         tex = r"\left(%s\right)" % self._print(expr.args[0])
1220         if exp is not None:
1221             return r"\eta^{%s}%s" % (self._print(exp), tex)
1222         return r"\eta%s" % tex
1223 
1224     def _print_zeta(self, expr, exp=None):
1225         if len(expr.args) == 2:
1226             tex = r"\left(%s, %s\right)" % tuple(map(self._print, expr.args))
1227         else:
1228             tex = r"\left(%s\right)" % self._print(expr.args[0])
1229         if exp is not None:
1230             return r"\zeta^{%s}%s" % (self._print(exp), tex)
1231         return r"\zeta%s" % tex
1232 
1233     def _print_lerchphi(self, expr, exp=None):
1234         tex = r"\left(%s, %s, %s\right)" % tuple(map(self._print, expr.args))
1235         if exp is None:
1236             return r"\Phi%s" % tex
1237         return r"\Phi^{%s}%s" % (self._print(exp), tex)
1238 
1239     def _print_polylog(self, expr, exp=None):
1240         s, z = map(self._print, expr.args)
1241         tex = r"\left(%s\right)" % z
1242         if exp is None:
1243             return r"\operatorname{Li}_{%s}%s" % (s, tex)
1244         return r"\operatorname{Li}_{%s}^{%s}%s" % (s, self._print(exp), tex)
1245 
1246     def _print_jacobi(self, expr, exp=None):
1247         n, a, b, x = map(self._print, expr.args)
1248         tex = r"P_{%s}^{\left(%s,%s\right)}\left(%s\right)" % (n, a, b, x)
1249         if exp is not None:
1250             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1251         return tex
1252 
1253     def _print_gegenbauer(self, expr, exp=None):
1254         n, a, x = map(self._print, expr.args)
1255         tex = r"C_{%s}^{\left(%s\right)}\left(%s\right)" % (n, a, x)
1256         if exp is not None:
1257             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1258         return tex
1259 
1260     def _print_chebyshevt(self, expr, exp=None):
1261         n, x = map(self._print, expr.args)
1262         tex = r"T_{%s}\left(%s\right)" % (n, x)
1263         if exp is not None:
1264             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1265         return tex
1266 
1267     def _print_chebyshevu(self, expr, exp=None):
1268         n, x = map(self._print, expr.args)
1269         tex = r"U_{%s}\left(%s\right)" % (n, x)
1270         if exp is not None:
1271             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1272         return tex
1273 
1274     def _print_legendre(self, expr, exp=None):
1275         n, x = map(self._print, expr.args)
1276         tex = r"P_{%s}\left(%s\right)" % (n, x)
1277         if exp is not None:
1278             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1279         return tex
1280 
1281     def _print_assoc_legendre(self, expr, exp=None):
1282         n, a, x = map(self._print, expr.args)
1283         tex = r"P_{%s}^{\left(%s\right)}\left(%s\right)" % (n, a, x)
1284         if exp is not None:
1285             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1286         return tex
1287 
1288     def _print_hermite(self, expr, exp=None):
1289         n, x = map(self._print, expr.args)
1290         tex = r"H_{%s}\left(%s\right)" % (n, x)
1291         if exp is not None:
1292             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1293         return tex
1294 
1295     def _print_laguerre(self, expr, exp=None):
1296         n, x = map(self._print, expr.args)
1297         tex = r"L_{%s}\left(%s\right)" % (n, x)
1298         if exp is not None:
1299             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1300         return tex
1301 
1302     def _print_assoc_laguerre(self, expr, exp=None):
1303         n, a, x = map(self._print, expr.args)
1304         tex = r"L_{%s}^{\left(%s\right)}\left(%s\right)" % (n, a, x)
1305         if exp is not None:
1306             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1307         return tex
1308 
1309     def _print_Ynm(self, expr, exp=None):
1310         n, m, theta, phi = map(self._print, expr.args)
1311         tex = r"Y_{%s}^{%s}\left(%s,%s\right)" % (n, m, theta, phi)
1312         if exp is not None:
1313             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1314         return tex
1315 
1316     def _print_Znm(self, expr, exp=None):
1317         n, m, theta, phi = map(self._print, expr.args)
1318         tex = r"Z_{%s}^{%s}\left(%s,%s\right)" % (n, m, theta, phi)
1319         if exp is not None:
1320             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1321         return tex
1322 
1323     def _print_Rational(self, expr):
1324         if expr.q != 1:
1325             sign = ""
1326             p = expr.p
1327             if expr.p < 0:
1328                 sign = "- "
1329                 p = -p
1330             if self._settings['fold_short_frac']:
1331                 return r"%s%d / %d" % (sign, p, expr.q)
1332             return r"%s\frac{%d}{%d}" % (sign, p, expr.q)
1333         else:
1334             return self._print(expr.p)
1335 
1336     def _print_Order(self, expr):
1337         s = self._print(expr.expr)
1338         if expr.point and any(p != S.Zero for p in expr.point) or \
1339            len(expr.variables) > 1:
1340             s += '; '
1341             if len(expr.variables) > 1:
1342                 s += self._print(expr.variables)
1343             elif len(expr.variables):
1344                 s += self._print(expr.variables[0])
1345             s += r'\rightarrow '
1346             if len(expr.point) > 1:
1347                 s += self._print(expr.point)
1348             else:
1349                 s += self._print(expr.point[0])
1350         return r"O\left(%s\right)" % s
1351 
1352     def _print_Symbol(self, expr):
1353         if expr in self._settings['symbol_names']:
1354             return self._settings['symbol_names'][expr]
1355 
1356         return self._deal_with_super_sub(expr.name) if \
1357             '\\' not in expr.name else expr.name
1358 
1359     _print_RandomSymbol = _print_Symbol
1360     _print_MatrixSymbol = _print_Symbol
1361 
1362     def _deal_with_super_sub(self, string):
1363         if '{' in string:
1364             return string
1365 
1366         name, supers, subs = split_super_sub(string)
1367 
1368         name = translate(name)
1369         supers = [translate(sup) for sup in supers]
1370         subs = [translate(sub) for sub in subs]
1371 
1372         # glue all items together:
1373         if len(supers) > 0:
1374             name += "^{%s}" % " ".join(supers)
1375         if len(subs) > 0:
1376             name += "_{%s}" % " ".join(subs)
1377 
1378         return name
1379 
1380     def _print_Relational(self, expr):
1381         if self._settings['itex']:
1382             gt = r"\gt"
1383             lt = r"\lt"
1384         else:
1385             gt = ">"
1386             lt = "<"
1387 
1388         charmap = {
1389             "==": "=",
1390             ">": gt,
1391             "<": lt,
1392             ">=": r"\geq",
1393             "<=": r"\leq",
1394             "!=": r"\neq",
1395         }
1396 
1397         return "%s %s %s" % (self._print(expr.lhs),
1398             charmap[expr.rel_op], self._print(expr.rhs))
1399 
1400     def _print_Piecewise(self, expr):
1401         ecpairs = [r"%s & \text{for}\: %s" % (self._print(e), self._print(c))
1402                    for e, c in expr.args[:-1]]
1403         if expr.args[-1].cond == true:
1404             ecpairs.append(r"%s & \text{otherwise}" %
1405                            self._print(expr.args[-1].expr))
1406         else:
1407             ecpairs.append(r"%s & \text{for}\: %s" %
1408                            (self._print(expr.args[-1].expr),
1409                             self._print(expr.args[-1].cond)))
1410         tex = r"\begin{cases} %s \end{cases}"
1411         return tex % r" \\".join(ecpairs)
1412 
1413     def _print_MatrixBase(self, expr):
1414         lines = []
1415 
1416         for line in range(expr.rows):  # horrible, should be 'rows'
1417             lines.append(" & ".join([ self._print(i) for i in expr[line, :] ]))
1418 
1419         mat_str = self._settings['mat_str']
1420         if mat_str is None:
1421             if self._settings['mode'] == 'inline':
1422                 mat_str = 'smallmatrix'
1423             else:
1424                 if (expr.cols <= 10) is True:
1425                     mat_str = 'matrix'
1426                 else:
1427                     mat_str = 'array'
1428 
1429         out_str = r'\begin{%MATSTR%}%s\end{%MATSTR%}'
1430         out_str = out_str.replace('%MATSTR%', mat_str)
1431         if mat_str == 'array':
1432             out_str = out_str.replace('%s', '{' + 'c'*expr.cols + '}%s')
1433         if self._settings['mat_delim']:
1434             left_delim = self._settings['mat_delim']
1435             right_delim = self._delim_dict[left_delim]
1436             out_str = r'\left' + left_delim + out_str + \
1437                       r'\right' + right_delim
1438         return out_str % r"\\".join(lines)
1439     _print_ImmutableMatrix = _print_ImmutableDenseMatrix \
1440                            = _print_Matrix \
1441                            = _print_MatrixBase
1442 
1443     def _print_MatrixElement(self, expr):
1444         return self.parenthesize(expr.parent, PRECEDENCE["Atom"], strict=True) \
1445             + '_{%s, %s}' % (expr.i, expr.j)
1446 
1447     def _print_MatrixSlice(self, expr):
1448         def latexslice(x):
1449             x = list(x)
1450             if x[2] == 1:
1451                 del x[2]
1452             if x[1] == x[0] + 1:
1453                 del x[1]
1454             if x[0] == 0:
1455                 x[0] = ''
1456             return ':'.join(map(self._print, x))
1457         return (self._print(expr.parent) + r'\left[' +
1458                 latexslice(expr.rowslice) + ', ' +
1459                 latexslice(expr.colslice) + r'\right]')
1460 
1461     def _print_BlockMatrix(self, expr):
1462         return self._print(expr.blocks)
1463 
1464     def _print_Transpose(self, expr):
1465         mat = expr.arg
1466         from sympy.matrices import MatrixSymbol
1467         if not isinstance(mat, MatrixSymbol):
1468             return r"\left(%s\right)^T" % self._print(mat)
1469         else:
1470             return "%s^T" % self._print(mat)
1471 
1472     def _print_Adjoint(self, expr):
1473         mat = expr.arg
1474         from sympy.matrices import MatrixSymbol
1475         if not isinstance(mat, MatrixSymbol):
1476             return r"\left(%s\right)^\dagger" % self._print(mat)
1477         else:
1478             return r"%s^\dagger" % self._print(mat)
1479 
1480     def _print_MatAdd(self, expr):
1481         terms = [self._print(t) for t in expr.args]
1482         l = []
1483         for t in terms:
1484             if t.startswith('-'):
1485                 sign = "-"
1486                 t = t[1:]
1487             else:
1488                 sign = "+"
1489             l.extend([sign, t])
1490         sign = l.pop(0)
1491         if sign == '+':
1492             sign = ""
1493         return sign + ' '.join(l)
1494 
1495     def _print_MatMul(self, expr):
1496         from sympy import Add, MatAdd, HadamardProduct, MatMul, Mul
1497 
1498         def parens(x):
1499             if isinstance(x, (Add, MatAdd, HadamardProduct)):
1500                 return r"\left(%s\right)" % self._print(x)
1501             return self._print(x)
1502 
1503         if isinstance(expr, MatMul) and expr.args[0].is_Number and expr.args[0]<0:
1504             expr = Mul(-1*expr.args[0], MatMul(*expr.args[1:]))
1505             return '-' + ' '.join(map(parens, expr.args))
1506         else:
1507             return ' '.join(map(parens, expr.args))
1508 
1509     def _print_Mod(self, expr, exp=None):
1510         if exp is not None:
1511             return r'\left(%s\bmod{%s}\right)^{%s}' % (self.parenthesize(expr.args[0],
1512                     PRECEDENCE['Mul'], strict=True), self._print(expr.args[1]), self._print(exp))
1513         return r'%s\bmod{%s}' % (self.parenthesize(expr.args[0],
1514                 PRECEDENCE['Mul'], strict=True), self._print(expr.args[1]))
1515 
1516     def _print_HadamardProduct(self, expr):
1517         from sympy import Add, MatAdd, MatMul
1518 
1519         def parens(x):
1520             if isinstance(x, (Add, MatAdd, MatMul)):
1521                 return r"\left(%s\right)" % self._print(x)
1522             return self._print(x)
1523         return r' \circ '.join(map(parens, expr.args))
1524 
1525     def _print_KroneckerProduct(self, expr):
1526         from sympy import Add, MatAdd, MatMul
1527 
1528         def parens(x):
1529             if isinstance(x, (Add, MatAdd, MatMul)):
1530                 return r"\left(%s\right)" % self._print(x)
1531             return self._print(x)
1532         return r' \otimes '.join(map(parens, expr.args))
1533 
1534     def _print_MatPow(self, expr):
1535         base, exp = expr.base, expr.exp
1536         from sympy.matrices import MatrixSymbol
1537         if not isinstance(base, MatrixSymbol):
1538             return r"\left(%s\right)^{%s}" % (self._print(base), self._print(exp))
1539         else:
1540             return "%s^{%s}" % (self._print(base), self._print(exp))
1541 
1542     def _print_ZeroMatrix(self, Z):
1543         return r"\mathbb{0}"
1544 
1545     def _print_Identity(self, I):
1546         return r"\mathbb{I}"
1547 
1548     def _print_NDimArray(self, expr):
1549 
1550         if expr.rank() == 0:
1551             return self._print(expr[()])
1552 
1553         mat_str = self._settings['mat_str']
1554         if mat_str is None:
1555             if self._settings['mode'] == 'inline':
1556                 mat_str = 'smallmatrix'
1557             else:
1558                 if (expr.rank() == 0) or (expr.shape[-1] <= 10):
1559                     mat_str = 'matrix'
1560                 else:
1561                     mat_str = 'array'
1562         block_str = r'\begin{%MATSTR%}%s\end{%MATSTR%}'
1563         block_str = block_str.replace('%MATSTR%', mat_str)
1564         if self._settings['mat_delim']:
1565             left_delim = self._settings['mat_delim']
1566             right_delim = self._delim_dict[left_delim]
1567             block_str = r'\left' + left_delim + block_str + \
1568                       r'\right' + right_delim
1569 
1570         if expr.rank() == 0:
1571             return block_str % ""
1572 
1573         level_str = [[]] + [[] for i in range(expr.rank())]
1574         shape_ranges = [list(range(i)) for i in expr.shape]
1575         for outer_i in itertools.product(*shape_ranges):
1576             level_str[-1].append(self._print(expr[outer_i]))
1577             even = True
1578             for back_outer_i in range(expr.rank()-1, -1, -1):
1579                 if len(level_str[back_outer_i+1]) < expr.shape[back_outer_i]:
1580                     break
1581                 if even:
1582                     level_str[back_outer_i].append(r" & ".join(level_str[back_outer_i+1]))
1583                 else:
1584                     level_str[back_outer_i].append(block_str % (r"\\".join(level_str[back_outer_i+1])))
1585                     if len(level_str[back_outer_i+1]) == 1:
1586                         level_str[back_outer_i][-1] = r"\left[" + level_str[back_outer_i][-1] + r"\right]"
1587                 even = not even
1588                 level_str[back_outer_i+1] = []
1589 
1590         out_str = level_str[0][0]
1591 
1592         if expr.rank() % 2 == 1:
1593             out_str = block_str % out_str
1594 
1595         return out_str
1596 
1597     _print_ImmutableDenseNDimArray = _print_NDimArray
1598     _print_ImmutableSparseNDimArray = _print_NDimArray
1599     _print_MutableDenseNDimArray = _print_NDimArray
1600     _print_MutableSparseNDimArray = _print_NDimArray
1601 
1602     def _print_tuple(self, expr):
1603         return r"\left ( %s\right )" % \
1604             r", \quad ".join([ self._print(i) for i in expr ])
1605 
1606     def _print_TensorProduct(self, expr):
1607         elements = [self._print(a) for a in expr.args]
1608         return r' \otimes '.join(elements)
1609 
1610     def _print_WedgeProduct(self, expr):
1611         elements = [self._print(a) for a in expr.args]
1612         return r' \wedge '.join(elements)
1613 
1614     def _print_Tuple(self, expr):
1615         return self._print_tuple(expr)
1616 
1617     def _print_list(self, expr):
1618         return r"\left [ %s\right ]" % \
1619             r", \quad ".join([ self._print(i) for i in expr ])
1620 
1621     def _print_dict(self, d):
1622         keys = sorted(d.keys(), key=default_sort_key)
1623         items = []
1624 
1625         for key in keys:
1626             val = d[key]
1627             items.append("%s : %s" % (self._print(key), self._print(val)))
1628 
1629         return r"\left \{ %s\right \}" % r", \quad ".join(items)
1630 
1631     def _print_Dict(self, expr):
1632         return self._print_dict(expr)
1633 
1634     def _print_DiracDelta(self, expr, exp=None):
1635         if len(expr.args) == 1 or expr.args[1] == 0:
1636             tex = r"\delta\left(%s\right)" % self._print(expr.args[0])
1637         else:
1638             tex = r"\delta^{\left( %s \right)}\left( %s \right)" % (
1639                 self._print(expr.args[1]), self._print(expr.args[0]))
1640         if exp:
1641             tex = r"\left(%s\right)^{%s}" % (tex, exp)
1642         return tex
1643 
1644     def _print_SingularityFunction(self, expr):
1645         shift = self._print(expr.args[0] - expr.args[1])
1646         power = self._print(expr.args[2])
1647         tex = r"{\langle %s \rangle}^{%s}" % (shift, power)
1648         return tex
1649 
1650     def _print_Heaviside(self, expr, exp=None):
1651         tex = r"\theta\left(%s\right)" % self._print(expr.args[0])
1652         if exp:
1653             tex = r"\left(%s\right)^{%s}" % (tex, exp)
1654         return tex
1655 
1656     def _print_KroneckerDelta(self, expr, exp=None):
1657         i = self._print(expr.args[0])
1658         j = self._print(expr.args[1])
1659         if expr.args[0].is_Atom and expr.args[1].is_Atom:
1660             tex = r'\delta_{%s %s}' % (i, j)
1661         else:
1662             tex = r'\delta_{%s, %s}' % (i, j)
1663         if exp:
1664             tex = r'\left(%s\right)^{%s}' % (tex, exp)
1665         return tex
1666 
1667     def _print_LeviCivita(self, expr, exp=None):
1668         indices = map(self._print, expr.args)
1669         if all(x.is_Atom for x in expr.args):
1670             tex = r'\varepsilon_{%s}' % " ".join(indices)
1671         else:
1672             tex = r'\varepsilon_{%s}' % ", ".join(indices)
1673         if exp:
1674             tex = r'\left(%s\right)^{%s}' % (tex, exp)
1675         return tex
1676 
1677     def _print_ProductSet(self, p):
1678         if len(p.sets) > 1 and not has_variety(p.sets):
1679             return self._print(p.sets[0]) + "^%d" % len(p.sets)
1680         else:
1681             return r" \times ".join(self._print(set) for set in p.sets)
1682 
1683     def _print_RandomDomain(self, d):
1684         if hasattr(d, 'as_boolean'):
1685             return 'Domain: ' + self._print(d.as_boolean())
1686         elif hasattr(d, 'set'):
1687             return ('Domain: ' + self._print(d.symbols) + ' in ' +
1688                     self._print(d.set))
1689         elif hasattr(d, 'symbols'):
1690             return 'Domain on ' + self._print(d.symbols)
1691         else:
1692             return self._print(None)
1693 
1694     def _print_FiniteSet(self, s):
1695         items = sorted(s.args, key=default_sort_key)
1696         return self._print_set(items)
1697 
1698     def _print_set(self, s):
1699         items = sorted(s, key=default_sort_key)
1700         items = ", ".join(map(self._print, items))
1701         return r"\left\{%s\right\}" % items
1702 
1703     _print_frozenset = _print_set
1704 
1705     def _print_Range(self, s):
1706         dots = r'\ldots'
1707 
1708         if s.start.is_infinite:
1709             printset = s.start, dots, s[-1] - s.step, s[-1]
1710         elif s.stop.is_infinite or len(s) > 4:
1711             it = iter(s)
1712             printset = next(it), next(it), dots, s[-1]
1713         else:
1714             printset = tuple(s)
1715 
1716         return (r"\left\{"
1717               + r", ".join(self._print(el) for el in printset)
1718               + r"\right\}")
1719 
1720     def _print_SeqFormula(self, s):
1721         if s.start is S.NegativeInfinity:
1722             stop = s.stop
1723             printset = (r'\ldots', s.coeff(stop - 3), s.coeff(stop - 2),
1724                 s.coeff(stop - 1), s.coeff(stop))
1725         elif s.stop is S.Infinity or s.length > 4:
1726             printset = s[:4]
1727             printset.append(r'\ldots')
1728         else:
1729             printset = tuple(s)
1730 
1731         return (r"\left["
1732               + r", ".join(self._print(el) for el in printset)
1733               + r"\right]")
1734 
1735     _print_SeqPer = _print_SeqFormula
1736     _print_SeqAdd = _print_SeqFormula
1737     _print_SeqMul = _print_SeqFormula
1738 
1739     def _print_Interval(self, i):
1740         if i.start == i.end:
1741             return r"\left\{%s\right\}" % self._print(i.start)
1742 
1743         else:
1744             if i.left_open:
1745                 left = '('
1746             else:
1747                 left = '['
1748 
1749             if i.right_open:
1750                 right = ')'
1751             else:
1752                 right = ']'
1753 
1754             return r"\left%s%s, %s\right%s" % \
1755                    (left, self._print(i.start), self._print(i.end), right)
1756 
1757     def _print_AccumulationBounds(self, i):
1758         return r"\langle %s, %s\rangle" % \
1759                 (self._print(i.min), self._print(i.max))
1760 
1761     def _print_Union(self, u):
1762         return r" \cup ".join([self._print(i) for i in u.args])
1763 
1764     def _print_Complement(self, u):
1765         return r" \setminus ".join([self._print(i) for i in u.args])
1766 
1767     def _print_Intersection(self, u):
1768         return r" \cap ".join([self._print(i) for i in u.args])
1769 
1770     def _print_SymmetricDifference(self, u):
1771         return r" \triangle ".join([self._print(i) for i in u.args])
1772 
1773     def _print_EmptySet(self, e):
1774         return r"\emptyset"
1775 
1776     def _print_Naturals(self, n):
1777         return r"\mathbb{N}"
1778 
1779     def _print_Naturals0(self, n):
1780         return r"\mathbb{N}_0"
1781 
1782     def _print_Integers(self, i):
1783         return r"\mathbb{Z}"
1784 
1785     def _print_Reals(self, i):
1786         return r"\mathbb{R}"
1787 
1788     def _print_Complexes(self, i):
1789         return r"\mathbb{C}"
1790 
1791     def _print_ImageSet(self, s):
1792         sets = s.args[1:]
1793         varsets = [r"%s \in %s" % (self._print(var), self._print(setv))
1794             for var, setv in zip(s.lamda.variables, sets)]
1795         return r"\left\{%s\; |\; %s\right\}" % (
1796             self._print(s.lamda.expr),
1797             ', '.join(varsets))
1798 
1799     def _print_ConditionSet(self, s):
1800         vars_print = ', '.join([self._print(var) for var in Tuple(s.sym)])
1801         if s.base_set is S.UniversalSet:
1802             return r"\left\{%s \mid %s \right\}" % (
1803             vars_print,
1804             self._print(s.condition.as_expr()))
1805 
1806         return r"\left\{%s \mid %s \in %s \wedge %s \right\}" % (
1807             vars_print,
1808             vars_print,
1809             self._print(s.base_set),
1810             self._print(s.condition.as_expr()))
1811 
1812     def _print_ComplexRegion(self, s):
1813         vars_print = ', '.join([self._print(var) for var in s.variables])
1814         return r"\left\{%s\; |\; %s \in %s \right\}" % (
1815             self._print(s.expr),
1816             vars_print,
1817             self._print(s.sets))
1818 
1819     def _print_Contains(self, e):
1820         return r"%s \in %s" % tuple(self._print(a) for a in e.args)
1821 
1822     def _print_FourierSeries(self, s):
1823         return self._print_Add(s.truncate()) + self._print(r' + \ldots')
1824 
1825     def _print_FormalPowerSeries(self, s):
1826         return self._print_Add(s.infinite)
1827 
1828     def _print_FiniteField(self, expr):
1829         return r"\mathbb{F}_{%s}" % expr.mod
1830 
1831     def _print_IntegerRing(self, expr):
1832         return r"\mathbb{Z}"
1833 
1834     def _print_RationalField(self, expr):
1835         return r"\mathbb{Q}"
1836 
1837     def _print_RealField(self, expr):
1838         return r"\mathbb{R}"
1839 
1840     def _print_ComplexField(self, expr):
1841         return r"\mathbb{C}"
1842 
1843     def _print_PolynomialRing(self, expr):
1844         domain = self._print(expr.domain)
1845         symbols = ", ".join(map(self._print, expr.symbols))
1846         return r"%s\left[%s\right]" % (domain, symbols)
1847 
1848     def _print_FractionField(self, expr):
1849         domain = self._print(expr.domain)
1850         symbols = ", ".join(map(self._print, expr.symbols))
1851         return r"%s\left(%s\right)" % (domain, symbols)
1852 
1853     def _print_PolynomialRingBase(self, expr):
1854         domain = self._print(expr.domain)
1855         symbols = ", ".join(map(self._print, expr.symbols))
1856         inv = ""
1857         if not expr.is_Poly:
1858             inv = r"S_<^{-1}"
1859         return r"%s%s\left[%s\right]" % (inv, domain, symbols)
1860 
1861     def _print_Poly(self, poly):
1862         cls = poly.__class__.__name__
1863         terms = []
1864         for monom, coeff in poly.terms():
1865             s_monom = ''
1866             for i, exp in enumerate(monom):
1867                 if exp > 0:
1868                     if exp == 1:
1869                         s_monom += self._print(poly.gens[i])
1870                     else:
1871                         s_monom += self._print(pow(poly.gens[i], exp))
1872 
1873             if coeff.is_Add:
1874                 if s_monom:
1875                     s_coeff = r"\left(%s\right)" % self._print(coeff)
1876                 else:
1877                     s_coeff = self._print(coeff)
1878             else:
1879                 if s_monom:
1880                     if coeff is S.One:
1881                         terms.extend(['+', s_monom])
1882                         continue
1883 
1884                     if coeff is S.NegativeOne:
1885                         terms.extend(['-', s_monom])
1886                         continue
1887 
1888                 s_coeff = self._print(coeff)
1889 
1890             if not s_monom:
1891                 s_term = s_coeff
1892             else:
1893                 s_term = s_coeff + " " + s_monom
1894 
1895             if s_term.startswith('-'):
1896                 terms.extend(['-', s_term[1:]])
1897             else:
1898                 terms.extend(['+', s_term])
1899 
1900         if terms[0] in ['-', '+']:
1901             modifier = terms.pop(0)
1902 
1903             if modifier == '-':
1904                 terms[0] = '-' + terms[0]
1905 
1906         expr = ' '.join(terms)
1907         gens = list(map(self._print, poly.gens))
1908         domain = "domain=%s" % self._print(poly.get_domain())
1909 
1910         args = ", ".join([expr] + gens + [domain])
1911         if cls in accepted_latex_functions:
1912             tex = r"\%s {\left (%s \right )}" % (cls, args)
1913         else:
1914             tex = r"\operatorname{%s}{\left( %s \right)}" % (cls, args)
1915 
1916         return tex
1917 
1918     def _print_ComplexRootOf(self, root):
1919         cls = root.__class__.__name__
1920         if cls == "ComplexRootOf":
1921             cls = "CRootOf"
1922         expr = self._print(root.expr)
1923         index = root.index
1924         if cls in accepted_latex_functions:
1925             return r"\%s {\left(%s, %d\right)}" % (cls, expr, index)
1926         else:
1927             return r"\operatorname{%s} {\left(%s, %d\right)}" % (cls, expr, index)
1928 
1929     def _print_RootSum(self, expr):
1930         cls = expr.__class__.__name__
1931         args = [self._print(expr.expr)]
1932 
1933         if expr.fun is not S.IdentityFunction:
1934             args.append(self._print(expr.fun))
1935 
1936         if cls in accepted_latex_functions:
1937             return r"\%s {\left(%s\right)}" % (cls, ", ".join(args))
1938         else:
1939             return r"\operatorname{%s} {\left(%s\right)}" % (cls, ", ".join(args))
1940 
1941     def _print_PolyElement(self, poly):
1942         mul_symbol = self._settings['mul_symbol_latex']
1943         return poly.str(self, PRECEDENCE, "{%s}^{%d}", mul_symbol)
1944 
1945     def _print_FracElement(self, frac):
1946         if frac.denom == 1:
1947             return self._print(frac.numer)
1948         else:
1949             numer = self._print(frac.numer)
1950             denom = self._print(frac.denom)
1951             return r"\frac{%s}{%s}" % (numer, denom)
1952 
1953     def _print_euler(self, expr, exp=None):
1954         m, x = (expr.args[0], None) if len(expr.args) == 1 else expr.args
1955         tex = r"E_{%s}" % self._print(m)
1956         if exp is not None:
1957             tex = r"%s^{%s}" % (tex, self._print(exp))
1958         if x is not None:
1959             tex = r"%s\left(%s\right)" % (tex, self._print(x))
1960         return tex
1961 
1962     def _print_catalan(self, expr, exp=None):
1963         tex = r"C_{%s}" % self._print(expr.args[0])
1964         if exp is not None:
1965             tex = r"%s^{%s}" % (tex, self._print(exp))
1966         return tex
1967 
1968     def _print_MellinTransform(self, expr):
1969         return r"\mathcal{M}_{%s}\left[%s\right]\left(%s\right)" % (self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))
1970 
1971     def _print_InverseMellinTransform(self, expr):
1972         return r"\mathcal{M}^{-1}_{%s}\left[%s\right]\left(%s\right)" % (self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))
1973 
1974     def _print_LaplaceTransform(self, expr):
1975         return r"\mathcal{L}_{%s}\left[%s\right]\left(%s\right)" % (self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))
1976 
1977     def _print_InverseLaplaceTransform(self, expr):
1978         return r"\mathcal{L}^{-1}_{%s}\left[%s\right]\left(%s\right)" % (self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))
1979 
1980     def _print_FourierTransform(self, expr):
1981         return r"\mathcal{F}_{%s}\left[%s\right]\left(%s\right)" % (self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))
1982 
1983     def _print_InverseFourierTransform(self, expr):
1984         return r"\mathcal{F}^{-1}_{%s}\left[%s\right]\left(%s\right)" % (self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))
1985 
1986     def _print_SineTransform(self, expr):
1987         return r"\mathcal{SIN}_{%s}\left[%s\right]\left(%s\right)" % (self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))
1988 
1989     def _print_InverseSineTransform(self, expr):
1990         return r"\mathcal{SIN}^{-1}_{%s}\left[%s\right]\left(%s\right)" % (self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))
1991 
1992     def _print_CosineTransform(self, expr):
1993         return r"\mathcal{COS}_{%s}\left[%s\right]\left(%s\right)" % (self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))
1994 
1995     def _print_InverseCosineTransform(self, expr):
1996         return r"\mathcal{COS}^{-1}_{%s}\left[%s\right]\left(%s\right)" % (self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))
1997 
1998     def _print_DMP(self, p):
1999         try:
2000             if p.ring is not None:
2001                 # TODO incorporate order
2002                 return self._print(p.ring.to_sympy(p))
2003         except SympifyError:
2004             pass
2005         return self._print(repr(p))
2006 
2007     def _print_DMF(self, p):
2008         return self._print_DMP(p)
2009 
2010     def _print_Object(self, object):
2011         return self._print(Symbol(object.name))
2012 
2013     def _print_Morphism(self, morphism):
2014         domain = self._print(morphism.domain)
2015         codomain = self._print(morphism.codomain)
2016         return "%s\\rightarrow %s" % (domain, codomain)
2017 
2018     def _print_NamedMorphism(self, morphism):
2019         pretty_name = self._print(Symbol(morphism.name))
2020         pretty_morphism = self._print_Morphism(morphism)
2021         return "%s:%s" % (pretty_name, pretty_morphism)
2022 
2023     def _print_IdentityMorphism(self, morphism):
2024         from sympy.categories import NamedMorphism
2025         return self._print_NamedMorphism(NamedMorphism(
2026             morphism.domain, morphism.codomain, "id"))
2027 
2028     def _print_CompositeMorphism(self, morphism):
2029         # All components of the morphism have names and it is thus
2030         # possible to build the name of the composite.
2031         component_names_list = [self._print(Symbol(component.name)) for
2032                                 component in morphism.components]
2033         component_names_list.reverse()
2034         component_names = "\\circ ".join(component_names_list) + ":"
2035 
2036         pretty_morphism = self._print_Morphism(morphism)
2037         return component_names + pretty_morphism
2038 
2039     def _print_Category(self, morphism):
2040         return "\\mathbf{%s}" % self._print(Symbol(morphism.name))
2041 
2042     def _print_Diagram(self, diagram):
2043         if not diagram.premises:
2044             # This is an empty diagram.
2045             return self._print(S.EmptySet)
2046 
2047         latex_result = self._print(diagram.premises)
2048         if diagram.conclusions:
2049             latex_result += "\\Longrightarrow %s" % \
2050                             self._print(diagram.conclusions)
2051 
2052         return latex_result
2053 
2054     def _print_DiagramGrid(self, grid):
2055         latex_result = "\\begin{array}{%s}\n" % ("c" * grid.width)
2056 
2057         for i in range(grid.height):
2058             for j in range(grid.width):
2059                 if grid[i, j]:
2060                     latex_result += latex(grid[i, j])
2061                 latex_result += " "
2062                 if j != grid.width - 1:
2063                     latex_result += "& "
2064 
2065             if i != grid.height - 1:
2066                 latex_result += "\\\\"
2067             latex_result += "\n"
2068 
2069         latex_result += "\\end{array}\n"
2070         return latex_result
2071 
2072     def _print_FreeModule(self, M):
2073         return '{%s}^{%s}' % (self._print(M.ring), self._print(M.rank))
2074 
2075     def _print_FreeModuleElement(self, m):
2076         # Print as row vector for convenience, for now.
2077         return r"\left[ %s \right]" % ",".join(
2078             '{' + self._print(x) + '}' for x in m)
2079 
2080     def _print_SubModule(self, m):
2081         return r"\left< %s \right>" % ",".join(
2082             '{' + self._print(x) + '}' for x in m.gens)
2083 
2084     def _print_ModuleImplementedIdeal(self, m):
2085         return r"\left< %s \right>" % ",".join(
2086             '{' + self._print(x) + '}' for [x] in m._module.gens)
2087 
2088     def _print_Quaternion(self, expr):
2089         # TODO: This expression is potentially confusing,
2090         # shall we print it as `Quaternion( ... )`?
2091         s = [self.parenthesize(i, PRECEDENCE["Mul"], strict=True) for i in expr.args]
2092         a = [s[0]] + [i+" "+j for i, j in zip(s[1:], "ijk")]
2093         return " + ".join(a)
2094 
2095     def _print_QuotientRing(self, R):
2096         # TODO nicer fractions for few generators...
2097         return r"\frac{%s}{%s}" % (self._print(R.ring), self._print(R.base_ideal))
2098 
2099     def _print_QuotientRingElement(self, x):
2100         return r"{%s} + {%s}" % (self._print(x.data), self._print(x.ring.base_ideal))
2101 
2102     def _print_QuotientModuleElement(self, m):
2103         return r"{%s} + {%s}" % (self._print(m.data),
2104                                  self._print(m.module.killed_module))
2105 
2106     def _print_QuotientModule(self, M):
2107         # TODO nicer fractions for few generators...
2108         return r"\frac{%s}{%s}" % (self._print(M.base),
2109                                    self._print(M.killed_module))
2110 
2111     def _print_MatrixHomomorphism(self, h):
2112         return r"{%s} : {%s} \to {%s}" % (self._print(h._sympy_matrix()),
2113             self._print(h.domain), self._print(h.codomain))
2114 
2115     def _print_BaseScalarField(self, field):
2116         string = field._coord_sys._names[field._index]
2117         return r'\boldsymbol{\mathrm{%s}}' % self._print(Symbol(string))
2118 
2119     def _print_BaseVectorField(self, field):
2120         string = field._coord_sys._names[field._index]
2121         return r'\partial_{%s}' % self._print(Symbol(string))
2122 
2123     def _print_Differential(self, diff):
2124         field = diff._form_field
2125         if hasattr(field, '_coord_sys'):
2126             string = field._coord_sys._names[field._index]
2127             return r'\mathrm{d}%s' % self._print(Symbol(string))
2128         else:
2129             return 'd(%s)' % self._print(field)
2130             string = self._print(field)
2131             return r'\mathrm{d}\left(%s\right)' % string
2132 
2133     def _print_Tr(self, p):
2134         #Todo: Handle indices
2135         contents = self._print(p.args[0])
2136         return r'\mbox{Tr}\left(%s\right)' % (contents)
2137 
2138     def _print_totient(self, expr, exp=None):
2139         if exp is not None:
2140             return r'\left(\phi\left(%s\right)\right)^{%s}' % (self._print(expr.args[0]),
2141                     self._print(exp))
2142         return r'\phi\left(%s\right)' % self._print(expr.args[0])
2143 
2144     def _print_reduced_totient(self, expr, exp=None):
2145         if exp is not None:
2146             return r'\left(\lambda\left(%s\right)\right)^{%s}' % (self._print(expr.args[0]),
2147                     self._print(exp))
2148         return r'\lambda\left(%s\right)' % self._print(expr.args[0])
2149 
2150     def _print_divisor_sigma(self, expr, exp=None):
2151         if len(expr.args) == 2:
2152             tex = r"_%s\left(%s\right)" % tuple(map(self._print,
2153                                                 (expr.args[1], expr.args[0])))
2154         else:
2155             tex = r"\left(%s\right)" % self._print(expr.args[0])
2156         if exp is not None:
2157             return r"\sigma^{%s}%s" % (self._print(exp), tex)
2158         return r"\sigma%s" % tex
2159 
2160     def _print_udivisor_sigma(self, expr, exp=None):
2161         if len(expr.args) == 2:
2162             tex = r"_%s\left(%s\right)" % tuple(map(self._print,
2163                                                 (expr.args[1], expr.args[0])))
2164         else:
2165             tex = r"\left(%s\right)" % self._print(expr.args[0])
2166         if exp is not None:
2167             return r"\sigma^*^{%s}%s" % (self._print(exp), tex)
2168         return r"\sigma^*%s" % tex
2169 
2170     def _print_primenu(self, expr, exp=None):
2171         if exp is not None:
2172             return r'\left(\nu\left(%s\right)\right)^{%s}' % (self._print(expr.args[0]),
2173                     self._print(exp))
2174         return r'\nu\left(%s\right)' % self._print(expr.args[0])
2175 
2176     def _print_primeomega(self, expr, exp=None):
2177         if exp is not None:
2178             return r'\left(\Omega\left(%s\right)\right)^{%s}' % (self._print(expr.args[0]),
2179                     self._print(exp))
2180         return r'\Omega\left(%s\right)' % self._print(expr.args[0])

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>]
2025-10-18 08:13:00.474 | INFO     | Search completed. Bug locations: [<file>sympy/printing/latex.py</file>
<class>LatexPrinter</class>
<method>_print_Function</method>
<code>
715     def _print_Function(self, expr, exp=None):
716         r'''
717         Render functions to LaTeX, handling functions that LaTeX knows about
718         e.g., sin, cos, ... by using the proper LaTeX command (\sin, \cos, ...).
719         For single-letter function names, render them as regular LaTeX math
720         symbols. For multi-letter function names that LaTeX does not know
721         about, (e.g., Li, sech) use \operatorname{} so that the function name
722         is rendered in Roman font and LaTeX handles spacing properly.
723 
724         expr is the expression involving the function
725         exp is an exponent
726         '''
727         func = expr.func.__name__
728         if hasattr(self, '_print_' + func) and \
729             not isinstance(expr.func, UndefinedFunction):
730             return getattr(self, '_print_' + func)(expr, exp)
731         else:
732             args = [ str(self._print(arg)) for arg in expr.args ]
733             # How inverse trig functions should be displayed, formats are:
734             # abbreviated: asin, full: arcsin, power: sin^-1
735             inv_trig_style = self._settings['inv_trig_style']
736             # If we are dealing with a power-style inverse trig function
737             inv_trig_power_case = False
738             # If it is applicable to fold the argument brackets
739             can_fold_brackets = self._settings['fold_func_brackets'] and \
740                 len(args) == 1 and \
741                 not self._needs_function_brackets(expr.args[0])
742 
743             inv_trig_table = ["asin", "acos", "atan", "acot"]
744 
745             # If the function is an inverse trig function, handle the style
746             if func in inv_trig_table:
747                 if inv_trig_style == "abbreviated":
748                     func = func
749                 elif inv_trig_style == "full":
750                     func = "arc" + func[1:]
751                 elif inv_trig_style == "power":
752                     func = func[1:]
753                     inv_trig_power_case = True
754 
755                     # Can never fold brackets if we're raised to a power
756                     if exp is not None:
757                         can_fold_brackets = False
758 
759             if inv_trig_power_case:
760                 if func in accepted_latex_functions:
761                     name = r"\%s^{-1}" % func
762                 else:
763                     name = r"\operatorname{%s}^{-1}" % func
764             elif exp is not None:
765                 name = r'%s^{%s}' % (self._hprint_Function(func), exp)
766             else:
767                 name = self._hprint_Function(func)
768 
769             if can_fold_brackets:
770                 if func in accepted_latex_functions:
771                     # Wrap argument safely to avoid parse-time conflicts
772                     # with the function name itself
773                     name += r" {%s}"
774                 else:
775                     name += r"%s"
776             else:
777                 name += r"{\left (%s \right )}"
778 
779             if inv_trig_power_case and exp is not None:
780                 name += r"^{%s}" % exp
781 
782             return name % ",".join(args)

</code><intended_behavior>The `_print_Function` method is meant to handle the printing of functions to LaTeX format correctly, adhering to the `inv_trig_style` specified by the user. To resolve the issue, the `inv_trig_table` within this method should be extended to include `acsc` and `asec`. By adding these to the `inv_trig_table`, the method should recognize `acsc(x)` and `asec(x)` as inverse trigonometric functions that, when `inv_trig_style="full"` is used, are transformed to `'\arccsc{\left (x \right )}'` and `'\arcsec{\left (x \right )}'`. This change preserves the existing functionality for inverse trigonometric functions already covered (`asin`, `acos`, `atan`, `acot`) and extends it to the previously unsupported `acsc` and `asec`, aligning the behavior with user expectations and the documented or implied behavior of the setting.</intended_behavior>, <file>sympy/printing/latex.py</file>
<class>LatexPrinter</class>
<method>None</method>
<code>
121 class LatexPrinter(Printer):
122     printmethod = "_latex"
123 
124     _default_settings = {
125         "order": None,
126         "mode": "plain",
127         "itex": False,
128         "fold_frac_powers": False,
129         "fold_func_brackets": False,
130         "fold_short_frac": None,
131         "long_frac_ratio": None,
132         "mul_symbol": None,
133         "inv_trig_style": "abbreviated",
134         "mat_str": None,
135         "mat_delim": "[",
136         "symbol_names": {},
137         "ln_notation": False,
138     }
139 
140     def __init__(self, settings=None):
141         Printer.__init__(self, settings)
142 
143         if 'mode' in self._settings:
144             valid_modes = ['inline', 'plain', 'equation',
145                            'equation*']
146             if self._settings['mode'] not in valid_modes:
147                 raise ValueError("'mode' must be one of 'inline', 'plain', "
148                     "'equation' or 'equation*'")
149 
150         if self._settings['fold_short_frac'] is None and \
151                 self._settings['mode'] == 'inline':
152             self._settings['fold_short_frac'] = True
153 
154         mul_symbol_table = {
155             None: r" ",
156             "ldot": r" \,.\, ",
157             "dot": r" \cdot ",
158             "times": r" \times "
159         }
160         try:
161             self._settings['mul_symbol_latex'] = \
162                 mul_symbol_table[self._settings['mul_symbol']]
163         except KeyError:
164             self._settings['mul_symbol_latex'] = \
165                 self._settings['mul_symbol']
166         try:
167             self._settings['mul_symbol_latex_numbers'] = \
168                 mul_symbol_table[self._settings['mul_symbol'] or 'dot']
169         except KeyError:
170             if (self._settings['mul_symbol'].strip() in
171                     ['', ' ', '\\', '\\,', '\\:', '\\;', '\\quad']):
172                 self._settings['mul_symbol_latex_numbers'] = \
173                     mul_symbol_table['dot']
174             else:
175                 self._settings['mul_symbol_latex_numbers'] = \
176                     self._settings['mul_symbol']
177 
178         self._delim_dict = {'(': ')', '[': ']'}
179 
180     def parenthesize(self, item, level, strict=False):
181         prec_val = precedence_traditional(item)
182         if (prec_val < level) or ((not strict) and prec_val <= level):
183             return r"\left(%s\right)" % self._print(item)
184         else:
185             return self._print(item)
186 
187     def doprint(self, expr):
188         tex = Printer.doprint(self, expr)
189 
190         if self._settings['mode'] == 'plain':
191             return tex
192         elif self._settings['mode'] == 'inline':
193             return r"$%s$" % tex
194         elif self._settings['itex']:
195             return r"$$%s$$" % tex
196         else:
197             env_str = self._settings['mode']
198             return r"\begin{%s}%s\end{%s}" % (env_str, tex, env_str)
199 
200     def _needs_brackets(self, expr):
201         """
202         Returns True if the expression needs to be wrapped in brackets when
203         printed, False otherwise. For example: a + b => True; a => False;
204         10 => False; -10 => True.
205         """
206         return not ((expr.is_Integer and expr.is_nonnegative)
207                     or (expr.is_Atom and (expr is not S.NegativeOne
208                                           and expr.is_Rational is False)))
209 
210     def _needs_function_brackets(self, expr):
211         """
212         Returns True if the expression needs to be wrapped in brackets when
213         passed as an argument to a function, False otherwise. This is a more
214         liberal version of _needs_brackets, in that many expressions which need
215         to be wrapped in brackets when added/subtracted/raised to a power do
216         not need them when passed to a function. Such an example is a*b.
217         """
218         if not self._needs_brackets(expr):
219             return False
220         else:
221             # Muls of the form a*b*c... can be folded
222             if expr.is_Mul and not self._mul_is_clean(expr):
223                 return True
224             # Pows which don't need brackets can be folded
225             elif expr.is_Pow and not self._pow_is_clean(expr):
226                 return True
227             # Add and Function always need brackets
228             elif expr.is_Add or expr.is_Function:
229                 return True
230             else:
231                 return False
232 
233     def _needs_mul_brackets(self, expr, first=False, last=False):
234         """
235         Returns True if the expression needs to be wrapped in brackets when
236         printed as part of a Mul, False otherwise. This is True for Add,
237         but also for some container objects that would not need brackets
238         when appearing last in a Mul, e.g. an Integral. ``last=True``
239         specifies that this expr is the last to appear in a Mul.
240         ``first=True`` specifies that this expr is the first to appear in a Mul.
241         """
242         from sympy import Integral, Piecewise, Product, Sum
243 
244         if expr.is_Mul:
245             if not first and _coeff_isneg(expr):
246                 return True
247         elif precedence_traditional(expr) < PRECEDENCE["Mul"]:
248             return True
249         elif expr.is_Relational:
250             return True
251         if expr.is_Piecewise:
252             return True
253         if any([expr.has(x) for x in (Mod,)]):
254             return True
255         if (not last and
256             any([expr.has(x) for x in (Integral, Product, Sum)])):
257             return True
258 
259         return False
260 
261 
262     def _needs_add_brackets(self, expr):
263         """
264         Returns True if the expression needs to be wrapped in brackets when
265         printed as part of an Add, False otherwise.  This is False for most
266         things.
267         """
268         if expr.is_Relational:
269             return True
270         if any([expr.has(x) for x in (Mod,)]):
271             return True
272         if expr.is_Add:
273             return True
274         return False
275 
276 
277     def _mul_is_clean(self, expr):
278         for arg in expr.args:
279             if arg.is_Function:
280                 return False
281         return True
282 
283     def _pow_is_clean(self, expr):
284         return not self._needs_brackets(expr.base)
285 
286     def _do_exponent(self, expr, exp):
287         if exp is not None:
288             return r"\left(%s\right)^{%s}" % (expr, exp)
289         else:
290             return expr
291 
292     def _print_bool(self, e):
293         return r"\mathrm{%s}" % e
294 
295     _print_BooleanTrue = _print_bool
296     _print_BooleanFalse = _print_bool
297 
298     def _print_NoneType(self, e):
299         return r"\mathrm{%s}" % e
300 
301 
302     def _print_Add(self, expr, order=None):
303         if self.order == 'none':
304             terms = list(expr.args)
305         else:
306             terms = self._as_ordered_terms(expr, order=order)
307 
308         tex = ""
309         for i, term in enumerate(terms):
310             if i == 0:
311                 pass
312             elif _coeff_isneg(term):
313                 tex += " - "
314                 term = -term
315             else:
316                 tex += " + "
317             term_tex = self._print(term)
318             if self._needs_add_brackets(term):
319                 term_tex = r"\left(%s\right)" % term_tex
320             tex += term_tex
321 
322         return tex
323 
324     def _print_Cycle(self, expr):
325         from sympy.combinatorics.permutations import Permutation
326         if expr.size == 0:
327             return r"\left( \right)"
328         expr = Permutation(expr)
329         expr_perm = expr.cyclic_form
330         siz = expr.size
331         if expr.array_form[-1] == siz - 1:
332             expr_perm = expr_perm + [[siz - 1]]
333         term_tex = ''
334         for i in expr_perm:
335             term_tex += str(i).replace(',', r"\;")
336         term_tex = term_tex.replace('[', r"\left( ")
337         term_tex = term_tex.replace(']', r"\right)")
338         return term_tex
339 
340     _print_Permutation = _print_Cycle
341 
342     def _print_Float(self, expr):
343         # Based off of that in StrPrinter
344         dps = prec_to_dps(expr._prec)
345         str_real = mlib.to_str(expr._mpf_, dps, strip_zeros=True)
346 
347         # Must always have a mul symbol (as 2.5 10^{20} just looks odd)
348         # thus we use the number separator
349         separator = self._settings['mul_symbol_latex_numbers']
350 
351         if 'e' in str_real:
352             (mant, exp) = str_real.split('e')
353 
354             if exp[0] == '+':
355                 exp = exp[1:]
356 
357             return r"%s%s10^{%s}" % (mant, separator, exp)
358         elif str_real == "+inf":
359             return r"\infty"
360         elif str_real == "-inf":
361             return r"- \infty"
362         else:
363             return str_real
364 
365     def _print_Cross(self, expr):
366         vec1 = expr._expr1
367         vec2 = expr._expr2
368         return r"%s \times %s" % (self.parenthesize(vec1, PRECEDENCE['Mul']),
369                                   self.parenthesize(vec2, PRECEDENCE['Mul']))
370 
371     def _print_Curl(self, expr):
372         vec = expr._expr
373         return r"\nabla\times %s" % self.parenthesize(vec, PRECEDENCE['Mul'])
374 
375     def _print_Divergence(self, expr):
376         vec = expr._expr
377         return r"\nabla\cdot %s" % self.parenthesize(vec, PRECEDENCE['Mul'])
378 
379     def _print_Dot(self, expr):
380         vec1 = expr._expr1
381         vec2 = expr._expr2
382         return r"%s \cdot %s" % (self.parenthesize(vec1, PRECEDENCE['Mul']),
383                                   self.parenthesize(vec2, PRECEDENCE['Mul']))
384 
385     def _print_Gradient(self, expr):
386         func = expr._expr
387         return r"\nabla\cdot %s" % self.parenthesize(func, PRECEDENCE['Mul'])
388 
389     def _print_Mul(self, expr):
390         from sympy.core.power import Pow
391         from sympy.physics.units import Quantity
392         include_parens = False
393         if _coeff_isneg(expr):
394             expr = -expr
395             tex = "- "
396             if expr.is_Add:
397                 tex += "("
398                 include_parens = True
399         else:
400             tex = ""
401 
402         from sympy.simplify import fraction
403         numer, denom = fraction(expr, exact=True)
404         separator = self._settings['mul_symbol_latex']
405         numbersep = self._settings['mul_symbol_latex_numbers']
406 
407         def convert(expr):
408             if not expr.is_Mul:
409                 return str(self._print(expr))
410             else:
411                 _tex = last_term_tex = ""
412 
413                 if self.order not in ('old', 'none'):
414                     args = expr.as_ordered_factors()
415                 else:
416                     args = list(expr.args)
417 
418                 # If quantities are present append them at the back
419                 args = sorted(args, key=lambda x: isinstance(x, Quantity) or
420                              (isinstance(x, Pow) and isinstance(x.base, Quantity)))
421 
422                 for i, term in enumerate(args):
423                     term_tex = self._print(term)
424 
425                     if self._needs_mul_brackets(term, first=(i == 0),
426                                                 last=(i == len(args) - 1)):
427                         term_tex = r"\left(%s\right)" % term_tex
428 
429                     if _between_two_numbers_p[0].search(last_term_tex) and \
430                             _between_two_numbers_p[1].match(term_tex):
431                         # between two numbers
432                         _tex += numbersep
433                     elif _tex:
434                         _tex += separator
435 
436                     _tex += term_tex
437                     last_term_tex = term_tex
438                 return _tex
439 
440         if denom is S.One and Pow(1, -1, evaluate=False) not in expr.args:
441             # use the original expression here, since fraction() may have
442             # altered it when producing numer and denom
443             tex += convert(expr)
444 
445         else:
446             snumer = convert(numer)
447             sdenom = convert(denom)
448             ldenom = len(sdenom.split())
449             ratio = self._settings['long_frac_ratio']
450             if self._settings['fold_short_frac'] \
451                    and ldenom <= 2 and not "^" in sdenom:
452                 # handle short fractions
453                 if self._needs_mul_brackets(numer, last=False):
454                     tex += r"\left(%s\right) / %s" % (snumer, sdenom)
455                 else:
456                     tex += r"%s / %s" % (snumer, sdenom)
457             elif ratio is not None and \
458                     len(snumer.split()) > ratio*ldenom:
459                 # handle long fractions
460                 if self._needs_mul_brackets(numer, last=True):
461                     tex += r"\frac{1}{%s}%s\left(%s\right)" \
462                         % (sdenom, separator, snumer)
463                 elif numer.is_Mul:
464                     # split a long numerator
465                     a = S.One
466                     b = S.One
467                     for x in numer.args:
468                         if self._needs_mul_brackets(x, last=False) or \
469                                 len(convert(a*x).split()) > ratio*ldenom or \
470                                 (b.is_commutative is x.is_commutative is False):
471                             b *= x
472                         else:
473                             a *= x
474                     if self._needs_mul_brackets(b, last=True):
475                         tex += r"\frac{%s}{%s}%s\left(%s\right)" \
476                             % (convert(a), sdenom, separator, convert(b))
477                     else:
478                         tex += r"\frac{%s}{%s}%s%s" \
479                             % (convert(a), sdenom, separator, convert(b))
480                 else:
481                     tex += r"\frac{1}{%s}%s%s" % (sdenom, separator, snumer)
482             else:
483                 tex += r"\frac{%s}{%s}" % (snumer, sdenom)
484 
485         if include_parens:
486             tex += ")"
487         return tex
488 
489     def _print_Pow(self, expr):
490         # Treat x**Rational(1,n) as special case
491         if expr.exp.is_Rational and abs(expr.exp.p) == 1 and expr.exp.q != 1:
492             base = self._print(expr.base)
493             expq = expr.exp.q
494 
495             if expq == 2:
496                 tex = r"\sqrt{%s}" % base
497             elif self._settings['itex']:
498                 tex = r"\root{%d}{%s}" % (expq, base)
499             else:
500                 tex = r"\sqrt[%d]{%s}" % (expq, base)
501 
502             if expr.exp.is_negative:
503                 return r"\frac{1}{%s}" % tex
504             else:
505                 return tex
506         elif self._settings['fold_frac_powers'] \
507             and expr.exp.is_Rational \
508                 and expr.exp.q != 1:
509             base, p, q = self.parenthesize(expr.base, PRECEDENCE['Pow']), expr.exp.p, expr.exp.q
510             #fixes issue #12886, adds parentheses before superscripts raised to powers
511             if '^' in base and expr.base.is_Symbol:
512                 base = r"\left(%s\right)" % base
513             if expr.base.is_Function:
514                 return self._print(expr.base, "%s/%s" % (p, q))
515             return r"%s^{%s/%s}" % (base, p, q)
516         elif expr.exp.is_Rational and expr.exp.is_negative and expr.base.is_commutative:
517             # Things like 1/x
518             return self._print_Mul(expr)
519         else:
520             if expr.base.is_Function:
521                 return self._print(expr.base, self._print(expr.exp))
522             else:
523                 if expr.is_commutative and expr.exp == -1:
524                     #solves issue 4129
525                     #As Mul always simplify 1/x to x**-1
526                     #The objective is achieved with this hack
527                     #first we get the latex for -1 * expr,
528                     #which is a Mul expression
529                     tex = self._print(S.NegativeOne * expr).strip()
530                     #the result comes with a minus and a space, so we remove
531                     if tex[:1] == "-":
532                         return tex[1:].strip()
533                 tex = r"%s^{%s}"
534                 #fixes issue #12886, adds parentheses before superscripts raised to powers
535                 base = self.parenthesize(expr.base, PRECEDENCE['Pow'])
536                 if '^' in base and expr.base.is_Symbol:
537                     base = r"\left(%s\right)" % base
538                 exp = self._print(expr.exp)
539 
540                 return tex % (base, exp)
541 
542     def _print_UnevaluatedExpr(self, expr):
543         return self._print(expr.args[0])
544 
545     def _print_Sum(self, expr):
546         if len(expr.limits) == 1:
547             tex = r"\sum_{%s=%s}^{%s} " % \
548                 tuple([ self._print(i) for i in expr.limits[0] ])
549         else:
550             def _format_ineq(l):
551                 return r"%s \leq %s \leq %s" % \
552                     tuple([self._print(s) for s in (l[1], l[0], l[2])])
553 
554             tex = r"\sum_{\substack{%s}} " % \
555                 str.join('\\\\', [ _format_ineq(l) for l in expr.limits ])
556 
557         if isinstance(expr.function, Add):
558             tex += r"\left(%s\right)" % self._print(expr.function)
559         else:
560             tex += self._print(expr.function)
561 
562         return tex
563 
564     def _print_Product(self, expr):
565         if len(expr.limits) == 1:
566             tex = r"\prod_{%s=%s}^{%s} " % \
567                 tuple([ self._print(i) for i in expr.limits[0] ])
568         else:
569             def _format_ineq(l):
570                 return r"%s \leq %s \leq %s" % \
571                     tuple([self._print(s) for s in (l[1], l[0], l[2])])
572 
573             tex = r"\prod_{\substack{%s}} " % \
574                 str.join('\\\\', [ _format_ineq(l) for l in expr.limits ])
575 
576         if isinstance(expr.function, Add):
577             tex += r"\left(%s\right)" % self._print(expr.function)
578         else:
579             tex += self._print(expr.function)
580 
581         return tex
582 
583     def _print_BasisDependent(self, expr):
584         from sympy.vector import Vector
585 
586         o1 = []
587         if expr == expr.zero:
588             return expr.zero._latex_form
589         if isinstance(expr, Vector):
590             items = expr.separate().items()
591         else:
592             items = [(0, expr)]
593 
594         for system, vect in items:
595             inneritems = list(vect.components.items())
596             inneritems.sort(key = lambda x:x[0].__str__())
597             for k, v in inneritems:
598                 if v == 1:
599                     o1.append(' + ' + k._latex_form)
600                 elif v == -1:
601                     o1.append(' - ' + k._latex_form)
602                 else:
603                     arg_str = '(' + LatexPrinter().doprint(v) + ')'
604                     o1.append(' + ' + arg_str + k._latex_form)
605 
606         outstr = (''.join(o1))
607         if outstr[1] != '-':
608             outstr = outstr[3:]
609         else:
610             outstr = outstr[1:]
611         return outstr
612 
613     def _print_Indexed(self, expr):
614         tex = self._print(expr.base)+'_{%s}' % ','.join(
615             map(self._print, expr.indices))
616         return tex
617 
618     def _print_IndexedBase(self, expr):
619         return self._print(expr.label)
620 
621     def _print_Derivative(self, expr):
622         if requires_partial(expr):
623             diff_symbol = r'\partial'
624         else:
625             diff_symbol = r'd'
626 
627         tex = ""
628         dim = 0
629         for x, num in reversed(expr.variable_count):
630             dim += num
631             if num == 1:
632                 tex += r"%s %s" % (diff_symbol, self._print(x))
633             else:
634                 tex += r"%s %s^{%s}" % (diff_symbol, self._print(x), num)
635 
636         if dim == 1:
637             tex = r"\frac{%s}{%s}" % (diff_symbol, tex)
638         else:
639             tex = r"\frac{%s^{%s}}{%s}" % (diff_symbol, dim, tex)
640 
641         return r"%s %s" % (tex, self.parenthesize(expr.expr, PRECEDENCE["Mul"], strict=True))
642 
643     def _print_Subs(self, subs):
644         expr, old, new = subs.args
645         latex_expr = self._print(expr)
646         latex_old = (self._print(e) for e in old)
647         latex_new = (self._print(e) for e in new)
648         latex_subs = r'\\ '.join(
649             e[0] + '=' + e[1] for e in zip(latex_old, latex_new))
650         return r'\left. %s \right|_{\substack{ %s }}' % (latex_expr, latex_subs)
651 
652     def _print_Integral(self, expr):
653         tex, symbols = "", []
654 
655         # Only up to \iiiint exists
656         if len(expr.limits) <= 4 and all(len(lim) == 1 for lim in expr.limits):
657             # Use len(expr.limits)-1 so that syntax highlighters don't think
658             # \" is an escaped quote
659             tex = r"\i" + "i"*(len(expr.limits) - 1) + "nt"
660             symbols = [r"\, d%s" % self._print(symbol[0])
661                        for symbol in expr.limits]
662 
663         else:
664             for lim in reversed(expr.limits):
665                 symbol = lim[0]
666                 tex += r"\int"
667 
668                 if len(lim) > 1:
669                     if self._settings['mode'] in ['equation', 'equation*'] \
670                             and not self._settings['itex']:
671                         tex += r"\limits"
672 
673                     if len(lim) == 3:
674                         tex += "_{%s}^{%s}" % (self._print(lim[1]),
675                                                self._print(lim[2]))
676                     if len(lim) == 2:
677                         tex += "^{%s}" % (self._print(lim[1]))
678 
679                 symbols.insert(0, r"\, d%s" % self._print(symbol))
680 
681         return r"%s %s%s" % (tex,
682             self.parenthesize(expr.function, PRECEDENCE["Mul"], strict=True), "".join(symbols))
683 
684     def _print_Limit(self, expr):
685         e, z, z0, dir = expr.args
686 
687         tex = r"\lim_{%s \to " % self._print(z)
688         if str(dir) == '+-' or z0 in (S.Infinity, S.NegativeInfinity):
689             tex += r"%s}" % self._print(z0)
690         else:
691             tex += r"%s^%s}" % (self._print(z0), self._print(dir))
692 
693         if isinstance(e, AssocOp):
694             return r"%s\left(%s\right)" % (tex, self._print(e))
695         else:
696             return r"%s %s" % (tex, self._print(e))
697 
698     def _hprint_Function(self, func):
699         r'''
700         Logic to decide how to render a function to latex
701           - if it is a recognized latex name, use the appropriate latex command
702           - if it is a single letter, just use that letter
703           - if it is a longer name, then put \operatorname{} around it and be
704             mindful of undercores in the name
705         '''
706         func = self._deal_with_super_sub(func)
707         if func in accepted_latex_functions:
708             name = r"\%s" % func
709         elif len(func) == 1 or func.startswith('\\'):
710             name = func
711         else:
712             name = r"\operatorname{%s}" % func
713         return name
714 
715     def _print_Function(self, expr, exp=None):
716         r'''
717         Render functions to LaTeX, handling functions that LaTeX knows about
718         e.g., sin, cos, ... by using the proper LaTeX command (\sin, \cos, ...).
719         For single-letter function names, render them as regular LaTeX math
720         symbols. For multi-letter function names that LaTeX does not know
721         about, (e.g., Li, sech) use \operatorname{} so that the function name
722         is rendered in Roman font and LaTeX handles spacing properly.
723 
724         expr is the expression involving the function
725         exp is an exponent
726         '''
727         func = expr.func.__name__
728         if hasattr(self, '_print_' + func) and \
729             not isinstance(expr.func, UndefinedFunction):
730             return getattr(self, '_print_' + func)(expr, exp)
731         else:
732             args = [ str(self._print(arg)) for arg in expr.args ]
733             # How inverse trig functions should be displayed, formats are:
734             # abbreviated: asin, full: arcsin, power: sin^-1
735             inv_trig_style = self._settings['inv_trig_style']
736             # If we are dealing with a power-style inverse trig function
737             inv_trig_power_case = False
738             # If it is applicable to fold the argument brackets
739             can_fold_brackets = self._settings['fold_func_brackets'] and \
740                 len(args) == 1 and \
741                 not self._needs_function_brackets(expr.args[0])
742 
743             inv_trig_table = ["asin", "acos", "atan", "acot"]
744 
745             # If the function is an inverse trig function, handle the style
746             if func in inv_trig_table:
747                 if inv_trig_style == "abbreviated":
748                     func = func
749                 elif inv_trig_style == "full":
750                     func = "arc" + func[1:]
751                 elif inv_trig_style == "power":
752                     func = func[1:]
753                     inv_trig_power_case = True
754 
755                     # Can never fold brackets if we're raised to a power
756                     if exp is not None:
757                         can_fold_brackets = False
758 
759             if inv_trig_power_case:
760                 if func in accepted_latex_functions:
761                     name = r"\%s^{-1}" % func
762                 else:
763                     name = r"\operatorname{%s}^{-1}" % func
764             elif exp is not None:
765                 name = r'%s^{%s}' % (self._hprint_Function(func), exp)
766             else:
767                 name = self._hprint_Function(func)
768 
769             if can_fold_brackets:
770                 if func in accepted_latex_functions:
771                     # Wrap argument safely to avoid parse-time conflicts
772                     # with the function name itself
773                     name += r" {%s}"
774                 else:
775                     name += r"%s"
776             else:
777                 name += r"{\left (%s \right )}"
778 
779             if inv_trig_power_case and exp is not None:
780                 name += r"^{%s}" % exp
781 
782             return name % ",".join(args)
783 
784     def _print_UndefinedFunction(self, expr):
785         return self._hprint_Function(str(expr))
786 
787     @property
788     def _special_function_classes(self):
789         from sympy.functions.special.tensor_functions import KroneckerDelta
790         from sympy.functions.special.gamma_functions import gamma, lowergamma
791         from sympy.functions.special.beta_functions import beta
792         from sympy.functions.special.delta_functions import DiracDelta
793         from sympy.functions.special.error_functions import Chi
794         return {KroneckerDelta: r'\delta',
795                 gamma:  r'\Gamma',
796                 lowergamma: r'\gamma',
797                 beta: r'\operatorname{B}',
798                 DiracDelta: r'\delta',
799                 Chi: r'\operatorname{Chi}'}
800 
801     def _print_FunctionClass(self, expr):
802         for cls in self._special_function_classes:
803             if issubclass(expr, cls) and expr.__name__ == cls.__name__:
804                 return self._special_function_classes[cls]
805         return self._hprint_Function(str(expr))
806 
807     def _print_Lambda(self, expr):
808         symbols, expr = expr.args
809 
810         if len(symbols) == 1:
811             symbols = self._print(symbols[0])
812         else:
813             symbols = self._print(tuple(symbols))
814 
815         args = (symbols, self._print(expr))
816         tex = r"\left( %s \mapsto %s \right)" % (symbols, self._print(expr))
817 
818         return tex
819 
820     def _print_Min(self, expr, exp=None):
821         args = sorted(expr.args, key=default_sort_key)
822         texargs = [r"%s" % self._print(symbol) for symbol in args]
823         tex = r"\min\left(%s\right)" % ", ".join(texargs)
824 
825         if exp is not None:
826             return r"%s^{%s}" % (tex, exp)
827         else:
828             return tex
829 
830     def _print_Max(self, expr, exp=None):
831         args = sorted(expr.args, key=default_sort_key)
832         texargs = [r"%s" % self._print(symbol) for symbol in args]
833         tex = r"\max\left(%s\right)" % ", ".join(texargs)
834 
835         if exp is not None:
836             return r"%s^{%s}" % (tex, exp)
837         else:
838             return tex
839 
840     def _print_floor(self, expr, exp=None):
841         tex = r"\lfloor{%s}\rfloor" % self._print(expr.args[0])
842 
843         if exp is not None:
844             return r"%s^{%s}" % (tex, exp)
845         else:
846             return tex
847 
848     def _print_ceiling(self, expr, exp=None):
849         tex = r"\lceil{%s}\rceil" % self._print(expr.args[0])
850 
851         if exp is not None:
852             return r"%s^{%s}" % (tex, exp)
853         else:
854             return tex
855 
856     def _print_log(self, expr, exp=None):
857         if not self._settings["ln_notation"]:
858             tex = r"\log{\left (%s \right )}" % self._print(expr.args[0])
859         else:
860             tex = r"\ln{\left (%s \right )}" % self._print(expr.args[0])
861 
862         if exp is not None:
863             return r"%s^{%s}" % (tex, exp)
864         else:
865             return tex
866 
867     def _print_Abs(self, expr, exp=None):
868         tex = r"\left|{%s}\right|" % self._print(expr.args[0])
869 
870         if exp is not None:
871             return r"%s^{%s}" % (tex, exp)
872         else:
873             return tex
874     _print_Determinant = _print_Abs
875 
876     def _print_re(self, expr, exp=None):
877         tex = r"\Re{%s}" % self.parenthesize(expr.args[0], PRECEDENCE['Atom'])
878 
879         return self._do_exponent(tex, exp)
880 
881     def _print_im(self, expr, exp=None):
882         tex = r"\Im{%s}" % self.parenthesize(expr.args[0], PRECEDENCE['Func'])
883 
884         return self._do_exponent(tex, exp)
885 
886     def _print_Not(self, e):
887         from sympy import Equivalent, Implies
888         if isinstance(e.args[0], Equivalent):
889             return self._print_Equivalent(e.args[0], r"\not\Leftrightarrow")
890         if isinstance(e.args[0], Implies):
891             return self._print_Implies(e.args[0], r"\not\Rightarrow")
892         if (e.args[0].is_Boolean):
893             return r"\neg (%s)" % self._print(e.args[0])
894         else:
895             return r"\neg %s" % self._print(e.args[0])
896 
897     def _print_LogOp(self, args, char):
898         arg = args[0]
899         if arg.is_Boolean and not arg.is_Not:
900             tex = r"\left(%s\right)" % self._print(arg)
901         else:
902             tex = r"%s" % self._print(arg)
903 
904         for arg in args[1:]:
905             if arg.is_Boolean and not arg.is_Not:
906                 tex += r" %s \left(%s\right)" % (char, self._print(arg))
907             else:
908                 tex += r" %s %s" % (char, self._print(arg))
909 
910         return tex
911 
912     def _print_And(self, e):
913         args = sorted(e.args, key=default_sort_key)
914         return self._print_LogOp(args, r"\wedge")
915 
916     def _print_Or(self, e):
917         args = sorted(e.args, key=default_sort_key)
918         return self._print_LogOp(args, r"\vee")
919 
920     def _print_Xor(self, e):
921         args = sorted(e.args, key=default_sort_key)
922         return self._print_LogOp(args, r"\veebar")
923 
924     def _print_Implies(self, e, altchar=None):
925         return self._print_LogOp(e.args, altchar or r"\Rightarrow")
926 
927     def _print_Equivalent(self, e, altchar=None):
928         args = sorted(e.args, key=default_sort_key)
929         return self._print_LogOp(args, altchar or r"\Leftrightarrow")
930 
931     def _print_conjugate(self, expr, exp=None):
932         tex = r"\overline{%s}" % self._print(expr.args[0])
933 
934         if exp is not None:
935             return r"%s^{%s}" % (tex, exp)
936         else:
937             return tex
938 
939     def _print_polar_lift(self, expr, exp=None):
940         func = r"\operatorname{polar\_lift}"
941         arg = r"{\left (%s \right )}" % self._print(expr.args[0])
942 
943         if exp is not None:
944             return r"%s^{%s}%s" % (func, exp, arg)
945         else:
946             return r"%s%s" % (func, arg)
947 
948     def _print_ExpBase(self, expr, exp=None):
949         # TODO should exp_polar be printed differently?
950         #      what about exp_polar(0), exp_polar(1)?
951         tex = r"e^{%s}" % self._print(expr.args[0])
952         return self._do_exponent(tex, exp)
953 
954     def _print_elliptic_k(self, expr, exp=None):
955         tex = r"\left(%s\right)" % self._print(expr.args[0])
956         if exp is not None:
957             return r"K^{%s}%s" % (exp, tex)
958         else:
959             return r"K%s" % tex
960 
961     def _print_elliptic_f(self, expr, exp=None):
962         tex = r"\left(%s\middle| %s\right)" % \
963             (self._print(expr.args[0]), self._print(expr.args[1]))
964         if exp is not None:
965             return r"F^{%s}%s" % (exp, tex)
966         else:
967             return r"F%s" % tex
968 
969     def _print_elliptic_e(self, expr, exp=None):
970         if len(expr.args) == 2:
971             tex = r"\left(%s\middle| %s\right)" % \
972                 (self._print(expr.args[0]), self._print(expr.args[1]))
973         else:
974             tex = r"\left(%s\right)" % self._print(expr.args[0])
975         if exp is not None:
976             return r"E^{%s}%s" % (exp, tex)
977         else:
978             return r"E%s" % tex
979 
980     def _print_elliptic_pi(self, expr, exp=None):
981         if len(expr.args) == 3:
982             tex = r"\left(%s; %s\middle| %s\right)" % \
983                 (self._print(expr.args[0]), self._print(expr.args[1]), \
984                  self._print(expr.args[2]))
985         else:
986             tex = r"\left(%s\middle| %s\right)" % \
987                 (self._print(expr.args[0]), self._print(expr.args[1]))
988         if exp is not None:
989             return r"\Pi^{%s}%s" % (exp, tex)
990         else:
991             return r"\Pi%s" % tex
992 
993     def _print_beta(self, expr, exp=None):
994         tex = r"\left(%s, %s\right)" % (self._print(expr.args[0]),
995                                         self._print(expr.args[1]))
996 
997         if exp is not None:
998             return r"\operatorname{B}^{%s}%s" % (exp, tex)
999         else:
1000             return r"\operatorname{B}%s" % tex
1001 
1002     def _print_gamma(self, expr, exp=None):
1003         tex = r"\left(%s\right)" % self._print(expr.args[0])
1004 
1005         if exp is not None:
1006             return r"\Gamma^{%s}%s" % (exp, tex)
1007         else:
1008             return r"\Gamma%s" % tex
1009 
1010     def _print_uppergamma(self, expr, exp=None):
1011         tex = r"\left(%s, %s\right)" % (self._print(expr.args[0]),
1012                                         self._print(expr.args[1]))
1013 
1014         if exp is not None:
1015             return r"\Gamma^{%s}%s" % (exp, tex)
1016         else:
1017             return r"\Gamma%s" % tex
1018 
1019     def _print_lowergamma(self, expr, exp=None):
1020         tex = r"\left(%s, %s\right)" % (self._print(expr.args[0]),
1021                                         self._print(expr.args[1]))
1022 
1023         if exp is not None:
1024             return r"\gamma^{%s}%s" % (exp, tex)
1025         else:
1026             return r"\gamma%s" % tex
1027 
1028     def _print_Chi(self, expr, exp=None):
1029         tex = r"\left(%s\right)" % self._print(expr.args[0])
1030 
1031         if exp is not None:
1032             return r"\operatorname{Chi}^{%s}%s" % (exp, tex)
1033         else:
1034             return r"\operatorname{Chi}%s" % tex
1035 
1036     def _print_expint(self, expr, exp=None):
1037         tex = r"\left(%s\right)" % self._print(expr.args[1])
1038         nu = self._print(expr.args[0])
1039 
1040         if exp is not None:
1041             return r"\operatorname{E}_{%s}^{%s}%s" % (nu, exp, tex)
1042         else:
1043             return r"\operatorname{E}_{%s}%s" % (nu, tex)
1044 
1045     def _print_fresnels(self, expr, exp=None):
1046         tex = r"\left(%s\right)" % self._print(expr.args[0])
1047 
1048         if exp is not None:
1049             return r"S^{%s}%s" % (exp, tex)
1050         else:
1051             return r"S%s" % tex
1052 
1053     def _print_fresnelc(self, expr, exp=None):
1054         tex = r"\left(%s\right)" % self._print(expr.args[0])
1055 
1056         if exp is not None:
1057             return r"C^{%s}%s" % (exp, tex)
1058         else:
1059             return r"C%s" % tex
1060 
1061     def _print_subfactorial(self, expr, exp=None):
1062         tex = r"!%s" % self.parenthesize(expr.args[0], PRECEDENCE["Func"])
1063 
1064         if exp is not None:
1065             return r"%s^{%s}" % (tex, exp)
1066         else:
1067             return tex
1068 
1069     def _print_factorial(self, expr, exp=None):
1070         tex = r"%s!" % self.parenthesize(expr.args[0], PRECEDENCE["Func"])
1071 
1072         if exp is not None:
1073             return r"%s^{%s}" % (tex, exp)
1074         else:
1075             return tex
1076 
1077     def _print_factorial2(self, expr, exp=None):
1078         tex = r"%s!!" % self.parenthesize(expr.args[0], PRECEDENCE["Func"])
1079 
1080         if exp is not None:
1081             return r"%s^{%s}" % (tex, exp)
1082         else:
1083             return tex
1084 
1085     def _print_binomial(self, expr, exp=None):
1086         tex = r"{\binom{%s}{%s}}" % (self._print(expr.args[0]),
1087                                      self._print(expr.args[1]))
1088 
1089         if exp is not None:
1090             return r"%s^{%s}" % (tex, exp)
1091         else:
1092             return tex
1093 
1094     def _print_RisingFactorial(self, expr, exp=None):
1095         n, k = expr.args
1096         base = r"%s" % self.parenthesize(n, PRECEDENCE['Func'])
1097 
1098         tex = r"{%s}^{\left(%s\right)}" % (base, self._print(k))
1099 
1100         return self._do_exponent(tex, exp)
1101 
1102     def _print_FallingFactorial(self, expr, exp=None):
1103         n, k = expr.args
1104         sub = r"%s" % self.parenthesize(k, PRECEDENCE['Func'])
1105 
1106         tex = r"{\left(%s\right)}_{%s}" % (self._print(n), sub)
1107 
1108         return self._do_exponent(tex, exp)
1109 
1110     def _hprint_BesselBase(self, expr, exp, sym):
1111         tex = r"%s" % (sym)
1112 
1113         need_exp = False
1114         if exp is not None:
1115             if tex.find('^') == -1:
1116                 tex = r"%s^{%s}" % (tex, self._print(exp))
1117             else:
1118                 need_exp = True
1119 
1120         tex = r"%s_{%s}\left(%s\right)" % (tex, self._print(expr.order),
1121                                            self._print(expr.argument))
1122 
1123         if need_exp:
1124             tex = self._do_exponent(tex, exp)
1125         return tex
1126 
1127     def _hprint_vec(self, vec):
1128         if len(vec) == 0:
1129             return ""
1130         s = ""
1131         for i in vec[:-1]:
1132             s += "%s, " % self._print(i)
1133         s += self._print(vec[-1])
1134         return s
1135 
1136     def _print_besselj(self, expr, exp=None):
1137         return self._hprint_BesselBase(expr, exp, 'J')
1138 
1139     def _print_besseli(self, expr, exp=None):
1140         return self._hprint_BesselBase(expr, exp, 'I')
1141 
1142     def _print_besselk(self, expr, exp=None):
1143         return self._hprint_BesselBase(expr, exp, 'K')
1144 
1145     def _print_bessely(self, expr, exp=None):
1146         return self._hprint_BesselBase(expr, exp, 'Y')
1147 
1148     def _print_yn(self, expr, exp=None):
1149         return self._hprint_BesselBase(expr, exp, 'y')
1150 
1151     def _print_jn(self, expr, exp=None):
1152         return self._hprint_BesselBase(expr, exp, 'j')
1153 
1154     def _print_hankel1(self, expr, exp=None):
1155         return self._hprint_BesselBase(expr, exp, 'H^{(1)}')
1156 
1157     def _print_hankel2(self, expr, exp=None):
1158         return self._hprint_BesselBase(expr, exp, 'H^{(2)}')
1159 
1160     def _print_hn1(self, expr, exp=None):
1161         return self._hprint_BesselBase(expr, exp, 'h^{(1)}')
1162 
1163     def _print_hn2(self, expr, exp=None):
1164         return self._hprint_BesselBase(expr, exp, 'h^{(2)}')
1165 
1166     def _hprint_airy(self, expr, exp=None, notation=""):
1167         tex = r"\left(%s\right)" % self._print(expr.args[0])
1168 
1169         if exp is not None:
1170             return r"%s^{%s}%s" % (notation, exp, tex)
1171         else:
1172             return r"%s%s" % (notation, tex)
1173 
1174     def _hprint_airy_prime(self, expr, exp=None, notation=""):
1175         tex = r"\left(%s\right)" % self._print(expr.args[0])
1176 
1177         if exp is not None:
1178             return r"{%s^\prime}^{%s}%s" % (notation, exp, tex)
1179         else:
1180             return r"%s^\prime%s" % (notation, tex)
1181 
1182     def _print_airyai(self, expr, exp=None):
1183         return self._hprint_airy(expr, exp, 'Ai')
1184 
1185     def _print_airybi(self, expr, exp=None):
1186         return self._hprint_airy(expr, exp, 'Bi')
1187 
1188     def _print_airyaiprime(self, expr, exp=None):
1189         return self._hprint_airy_prime(expr, exp, 'Ai')
1190 
1191     def _print_airybiprime(self, expr, exp=None):
1192         return self._hprint_airy_prime(expr, exp, 'Bi')
1193 
1194     def _print_hyper(self, expr, exp=None):
1195         tex = r"{{}_{%s}F_{%s}\left(\begin{matrix} %s \\ %s \end{matrix}" \
1196               r"\middle| {%s} \right)}" % \
1197             (self._print(len(expr.ap)), self._print(len(expr.bq)),
1198               self._hprint_vec(expr.ap), self._hprint_vec(expr.bq),
1199               self._print(expr.argument))
1200 
1201         if exp is not None:
1202             tex = r"{%s}^{%s}" % (tex, self._print(exp))
1203         return tex
1204 
1205     def _print_meijerg(self, expr, exp=None):
1206         tex = r"{G_{%s, %s}^{%s, %s}\left(\begin{matrix} %s & %s \\" \
1207               r"%s & %s \end{matrix} \middle| {%s} \right)}" % \
1208             (self._print(len(expr.ap)), self._print(len(expr.bq)),
1209               self._print(len(expr.bm)), self._print(len(expr.an)),
1210               self._hprint_vec(expr.an), self._hprint_vec(expr.aother),
1211               self._hprint_vec(expr.bm), self._hprint_vec(expr.bother),
1212               self._print(expr.argument))
1213 
1214         if exp is not None:
1215             tex = r"{%s}^{%s}" % (tex, self._print(exp))
1216         return tex
1217 
1218     def _print_dirichlet_eta(self, expr, exp=None):
1219         tex = r"\left(%s\right)" % self._print(expr.args[0])
1220         if exp is not None:
1221             return r"\eta^{%s}%s" % (self._print(exp), tex)
1222         return r"\eta%s" % tex
1223 
1224     def _print_zeta(self, expr, exp=None):
1225         if len(expr.args) == 2:
1226             tex = r"\left(%s, %s\right)" % tuple(map(self._print, expr.args))
1227         else:
1228             tex = r"\left(%s\right)" % self._print(expr.args[0])
1229         if exp is not None:
1230             return r"\zeta^{%s}%s" % (self._print(exp), tex)
1231         return r"\zeta%s" % tex
1232 
1233     def _print_lerchphi(self, expr, exp=None):
1234         tex = r"\left(%s, %s, %s\right)" % tuple(map(self._print, expr.args))
1235         if exp is None:
1236             return r"\Phi%s" % tex
1237         return r"\Phi^{%s}%s" % (self._print(exp), tex)
1238 
1239     def _print_polylog(self, expr, exp=None):
1240         s, z = map(self._print, expr.args)
1241         tex = r"\left(%s\right)" % z
1242         if exp is None:
1243             return r"\operatorname{Li}_{%s}%s" % (s, tex)
1244         return r"\operatorname{Li}_{%s}^{%s}%s" % (s, self._print(exp), tex)
1245 
1246     def _print_jacobi(self, expr, exp=None):
1247         n, a, b, x = map(self._print, expr.args)
1248         tex = r"P_{%s}^{\left(%s,%s\right)}\left(%s\right)" % (n, a, b, x)
1249         if exp is not None:
1250             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1251         return tex
1252 
1253     def _print_gegenbauer(self, expr, exp=None):
1254         n, a, x = map(self._print, expr.args)
1255         tex = r"C_{%s}^{\left(%s\right)}\left(%s\right)" % (n, a, x)
1256         if exp is not None:
1257             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1258         return tex
1259 
1260     def _print_chebyshevt(self, expr, exp=None):
1261         n, x = map(self._print, expr.args)
1262         tex = r"T_{%s}\left(%s\right)" % (n, x)
1263         if exp is not None:
1264             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1265         return tex
1266 
1267     def _print_chebyshevu(self, expr, exp=None):
1268         n, x = map(self._print, expr.args)
1269         tex = r"U_{%s}\left(%s\right)" % (n, x)
1270         if exp is not None:
1271             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1272         return tex
1273 
1274     def _print_legendre(self, expr, exp=None):
1275         n, x = map(self._print, expr.args)
1276         tex = r"P_{%s}\left(%s\right)" % (n, x)
1277         if exp is not None:
1278             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1279         return tex
1280 
1281     def _print_assoc_legendre(self, expr, exp=None):
1282         n, a, x = map(self._print, expr.args)
1283         tex = r"P_{%s}^{\left(%s\right)}\left(%s\right)" % (n, a, x)
1284         if exp is not None:
1285             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1286         return tex
1287 
1288     def _print_hermite(self, expr, exp=None):
1289         n, x = map(self._print, expr.args)
1290         tex = r"H_{%s}\left(%s\right)" % (n, x)
1291         if exp is not None:
1292             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1293         return tex
1294 
1295     def _print_laguerre(self, expr, exp=None):
1296         n, x = map(self._print, expr.args)
1297         tex = r"L_{%s}\left(%s\right)" % (n, x)
1298         if exp is not None:
1299             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1300         return tex
1301 
1302     def _print_assoc_laguerre(self, expr, exp=None):
1303         n, a, x = map(self._print, expr.args)
1304         tex = r"L_{%s}^{\left(%s\right)}\left(%s\right)" % (n, a, x)
1305         if exp is not None:
1306             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1307         return tex
1308 
1309     def _print_Ynm(self, expr, exp=None):
1310         n, m, theta, phi = map(self._print, expr.args)
1311         tex = r"Y_{%s}^{%s}\left(%s,%s\right)" % (n, m, theta, phi)
1312         if exp is not None:
1313             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1314         return tex
1315 
1316     def _print_Znm(self, expr, exp=None):
1317         n, m, theta, phi = map(self._print, expr.args)
1318         tex = r"Z_{%s}^{%s}\left(%s,%s\right)" % (n, m, theta, phi)
1319         if exp is not None:
1320             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1321         return tex
1322 
1323     def _print_Rational(self, expr):
1324         if expr.q != 1:
1325             sign = ""
1326             p = expr.p
1327             if expr.p < 0:
1328                 sign = "- "
1329                 p = -p
1330             if self._settings['fold_short_frac']:
1331                 return r"%s%d / %d" % (sign, p, expr.q)
1332             return r"%s\frac{%d}{%d}" % (sign, p, expr.q)
1333         else:
1334             return self._print(expr.p)
1335 
1336     def _print_Order(self, expr):
1337         s = self._print(expr.expr)
1338         if expr.point and any(p != S.Zero for p in expr.point) or \
1339            len(expr.variables) > 1:
1340             s += '; '
1341             if len(expr.variables) > 1:
1342                 s += self._print(expr.variables)
1343             elif len(expr.variables):
1344                 s += self._print(expr.variables[0])
1345             s += r'\rightarrow '
1346             if len(expr.point) > 1:
1347                 s += self._print(expr.point)
1348             else:
1349                 s += self._print(expr.point[0])
1350         return r"O\left(%s\right)" % s
1351 
1352     def _print_Symbol(self, expr):
1353         if expr in self._settings['symbol_names']:
1354             return self._settings['symbol_names'][expr]
1355 
1356         return self._deal_with_super_sub(expr.name) if \
1357             '\\' not in expr.name else expr.name
1358 
1359     _print_RandomSymbol = _print_Symbol
1360     _print_MatrixSymbol = _print_Symbol
1361 
1362     def _deal_with_super_sub(self, string):
1363         if '{' in string:
1364             return string
1365 
1366         name, supers, subs = split_super_sub(string)
1367 
1368         name = translate(name)
1369         supers = [translate(sup) for sup in supers]
1370         subs = [translate(sub) for sub in subs]
1371 
1372         # glue all items together:
1373         if len(supers) > 0:
1374             name += "^{%s}" % " ".join(supers)
1375         if len(subs) > 0:
1376             name += "_{%s}" % " ".join(subs)
1377 
1378         return name
1379 
1380     def _print_Relational(self, expr):
1381         if self._settings['itex']:
1382             gt = r"\gt"
1383             lt = r"\lt"
1384         else:
1385             gt = ">"
1386             lt = "<"
1387 
1388         charmap = {
1389             "==": "=",
1390             ">": gt,
1391             "<": lt,
1392             ">=": r"\geq",
1393             "<=": r"\leq",
1394             "!=": r"\neq",
1395         }
1396 
1397         return "%s %s %s" % (self._print(expr.lhs),
1398             charmap[expr.rel_op], self._print(expr.rhs))
1399 
1400     def _print_Piecewise(self, expr):
1401         ecpairs = [r"%s & \text{for}\: %s" % (self._print(e), self._print(c))
1402                    for e, c in expr.args[:-1]]
1403         if expr.args[-1].cond == true:
1404             ecpairs.append(r"%s & \text{otherwise}" %
1405                            self._print(expr.args[-1].expr))
1406         else:
1407             ecpairs.append(r"%s & \text{for}\: %s" %
1408                            (self._print(expr.args[-1].expr),
1409                             self._print(expr.args[-1].cond)))
1410         tex = r"\begin{cases} %s \end{cases}"
1411         return tex % r" \\".join(ecpairs)
1412 
1413     def _print_MatrixBase(self, expr):
1414         lines = []
1415 
1416         for line in range(expr.rows):  # horrible, should be 'rows'
1417             lines.append(" & ".join([ self._print(i) for i in expr[line, :] ]))
1418 
1419         mat_str = self._settings['mat_str']
1420         if mat_str is None:
1421             if self._settings['mode'] == 'inline':
1422                 mat_str = 'smallmatrix'
1423             else:
1424                 if (expr.cols <= 10) is True:
1425                     mat_str = 'matrix'
1426                 else:
1427                     mat_str = 'array'
1428 
1429         out_str = r'\begin{%MATSTR%}%s\end{%MATSTR%}'
1430         out_str = out_str.replace('%MATSTR%', mat_str)
1431         if mat_str == 'array':
1432             out_str = out_str.replace('%s', '{' + 'c'*expr.cols + '}%s')
1433         if self._settings['mat_delim']:
1434             left_delim = self._settings['mat_delim']
1435             right_delim = self._delim_dict[left_delim]
1436             out_str = r'\left' + left_delim + out_str + \
1437                       r'\right' + right_delim
1438         return out_str % r"\\".join(lines)
1439     _print_ImmutableMatrix = _print_ImmutableDenseMatrix \
1440                            = _print_Matrix \
1441                            = _print_MatrixBase
1442 
1443     def _print_MatrixElement(self, expr):
1444         return self.parenthesize(expr.parent, PRECEDENCE["Atom"], strict=True) \
1445             + '_{%s, %s}' % (expr.i, expr.j)
1446 
1447     def _print_MatrixSlice(self, expr):
1448         def latexslice(x):
1449             x = list(x)
1450             if x[2] == 1:
1451                 del x[2]
1452             if x[1] == x[0] + 1:
1453                 del x[1]
1454             if x[0] == 0:
1455                 x[0] = ''
1456             return ':'.join(map(self._print, x))
1457         return (self._print(expr.parent) + r'\left[' +
1458                 latexslice(expr.rowslice) + ', ' +
1459                 latexslice(expr.colslice) + r'\right]')
1460 
1461     def _print_BlockMatrix(self, expr):
1462         return self._print(expr.blocks)
1463 
1464     def _print_Transpose(self, expr):
1465         mat = expr.arg
1466         from sympy.matrices import MatrixSymbol
1467         if not isinstance(mat, MatrixSymbol):
1468             return r"\left(%s\right)^T" % self._print(mat)
1469         else:
1470             return "%s^T" % self._print(mat)
1471 
1472     def _print_Adjoint(self, expr):
1473         mat = expr.arg
1474         from sympy.matrices import MatrixSymbol
1475         if not isinstance(mat, MatrixSymbol):
1476             return r"\left(%s\right)^\dagger" % self._print(mat)
1477         else:
1478             return r"%s^\dagger" % self._print(mat)
1479 
1480     def _print_MatAdd(self, expr):
1481         terms = [self._print(t) for t in expr.args]
1482         l = []
1483         for t in terms:
1484             if t.startswith('-'):
1485                 sign = "-"
1486                 t = t[1:]
1487             else:
1488                 sign = "+"
1489             l.extend([sign, t])
1490         sign = l.pop(0)
1491         if sign == '+':
1492             sign = ""
1493         return sign + ' '.join(l)
1494 
1495     def _print_MatMul(self, expr):
1496         from sympy import Add, MatAdd, HadamardProduct, MatMul, Mul
1497 
1498         def parens(x):
1499             if isinstance(x, (Add, MatAdd, HadamardProduct)):
1500                 return r"\left(%s\right)" % self._print(x)
1501             return self._print(x)
1502 
1503         if isinstance(expr, MatMul) and expr.args[0].is_Number and expr.args[0]<0:
1504             expr = Mul(-1*expr.args[0], MatMul(*expr.args[1:]))
1505             return '-' + ' '.join(map(parens, expr.args))
1506         else:
1507             return ' '.join(map(parens, expr.args))
1508 
1509     def _print_Mod(self, expr, exp=None):
1510         if exp is not None:
1511             return r'\left(%s\bmod{%s}\right)^{%s}' % (self.parenthesize(expr.args[0],
1512                     PRECEDENCE['Mul'], strict=True), self._print(expr.args[1]), self._print(exp))
1513         return r'%s\bmod{%s}' % (self.parenthesize(expr.args[0],
1514                 PRECEDENCE['Mul'], strict=True), self._print(expr.args[1]))
1515 
1516     def _print_HadamardProduct(self, expr):
1517         from sympy import Add, MatAdd, MatMul
1518 
1519         def parens(x):
1520             if isinstance(x, (Add, MatAdd, MatMul)):
1521                 return r"\left(%s\right)" % self._print(x)
1522             return self._print(x)
1523         return r' \circ '.join(map(parens, expr.args))
1524 
1525     def _print_KroneckerProduct(self, expr):
1526         from sympy import Add, MatAdd, MatMul
1527 
1528         def parens(x):
1529             if isinstance(x, (Add, MatAdd, MatMul)):
1530                 return r"\left(%s\right)" % self._print(x)
1531             return self._print(x)
1532         return r' \otimes '.join(map(parens, expr.args))
1533 
1534     def _print_MatPow(self, expr):
1535         base, exp = expr.base, expr.exp
1536         from sympy.matrices import MatrixSymbol
1537         if not isinstance(base, MatrixSymbol):
1538             return r"\left(%s\right)^{%s}" % (self._print(base), self._print(exp))
1539         else:
1540             return "%s^{%s}" % (self._print(base), self._print(exp))
1541 
1542     def _print_ZeroMatrix(self, Z):
1543         return r"\mathbb{0}"
1544 
1545     def _print_Identity(self, I):
1546         return r"\mathbb{I}"
1547 
1548     def _print_NDimArray(self, expr):
1549 
1550         if expr.rank() == 0:
1551             return self._print(expr[()])
1552 
1553         mat_str = self._settings['mat_str']
1554         if mat_str is None:
1555             if self._settings['mode'] == 'inline':
1556                 mat_str = 'smallmatrix'
1557             else:
1558                 if (expr.rank() == 0) or (expr.shape[-1] <= 10):
1559                     mat_str = 'matrix'
1560                 else:
1561                     mat_str = 'array'
1562         block_str = r'\begin{%MATSTR%}%s\end{%MATSTR%}'
1563         block_str = block_str.replace('%MATSTR%', mat_str)
1564         if self._settings['mat_delim']:
1565             left_delim = self._settings['mat_delim']
1566             right_delim = self._delim_dict[left_delim]
1567             block_str = r'\left' + left_delim + block_str + \
1568                       r'\right' + right_delim
1569 
1570         if expr.rank() == 0:
1571             return block_str % ""
1572 
1573         level_str = [[]] + [[] for i in range(expr.rank())]
1574         shape_ranges = [list(range(i)) for i in expr.shape]
1575         for outer_i in itertools.product(*shape_ranges):
1576             level_str[-1].append(self._print(expr[outer_i]))
1577             even = True
1578             for back_outer_i in range(expr.rank()-1, -1, -1):
1579                 if len(level_str[back_outer_i+1]) < expr.shape[back_outer_i]:
1580                     break
1581                 if even:
1582                     level_str[back_outer_i].append(r" & ".join(level_str[back_outer_i+1]))
1583                 else:
1584                     level_str[back_outer_i].append(block_str % (r"\\".join(level_str[back_outer_i+1])))
1585                     if len(level_str[back_outer_i+1]) == 1:
1586                         level_str[back_outer_i][-1] = r"\left[" + level_str[back_outer_i][-1] + r"\right]"
1587                 even = not even
1588                 level_str[back_outer_i+1] = []
1589 
1590         out_str = level_str[0][0]
1591 
1592         if expr.rank() % 2 == 1:
1593             out_str = block_str % out_str
1594 
1595         return out_str
1596 
1597     _print_ImmutableDenseNDimArray = _print_NDimArray
1598     _print_ImmutableSparseNDimArray = _print_NDimArray
1599     _print_MutableDenseNDimArray = _print_NDimArray
1600     _print_MutableSparseNDimArray = _print_NDimArray
1601 
1602     def _print_tuple(self, expr):
1603         return r"\left ( %s\right )" % \
1604             r", \quad ".join([ self._print(i) for i in expr ])
1605 
1606     def _print_TensorProduct(self, expr):
1607         elements = [self._print(a) for a in expr.args]
1608         return r' \otimes '.join(elements)
1609 
1610     def _print_WedgeProduct(self, expr):
1611         elements = [self._print(a) for a in expr.args]
1612         return r' \wedge '.join(elements)
1613 
1614     def _print_Tuple(self, expr):
1615         return self._print_tuple(expr)
1616 
1617     def _print_list(self, expr):
1618         return r"\left [ %s\right ]" % \
1619             r", \quad ".join([ self._print(i) for i in expr ])
1620 
1621     def _print_dict(self, d):
1622         keys = sorted(d.keys(), key=default_sort_key)
1623         items = []
1624 
1625         for key in keys:
1626             val = d[key]
1627             items.append("%s : %s" % (self._print(key), self._print(val)))
1628 
1629         return r"\left \{ %s\right \}" % r", \quad ".join(items)
1630 
1631     def _print_Dict(self, expr):
1632         return self._print_dict(expr)
1633 
1634     def _print_DiracDelta(self, expr, exp=None):
1635         if len(expr.args) == 1 or expr.args[1] == 0:
1636             tex = r"\delta\left(%s\right)" % self._print(expr.args[0])
1637         else:
1638             tex = r"\delta^{\left( %s \right)}\left( %s \right)" % (
1639                 self._print(expr.args[1]), self._print(expr.args[0]))
1640         if exp:
1641             tex = r"\left(%s\right)^{%s}" % (tex, exp)
1642         return tex
1643 
1644     def _print_SingularityFunction(self, expr):
1645         shift = self._print(expr.args[0] - expr.args[1])
1646         power = self._print(expr.args[2])
1647         tex = r"{\langle %s \rangle}^{%s}" % (shift, power)
1648         return tex
1649 
1650     def _print_Heaviside(self, expr, exp=None):
1651         tex = r"\theta\left(%s\right)" % self._print(expr.args[0])
1652         if exp:
1653             tex = r"\left(%s\right)^{%s}" % (tex, exp)
1654         return tex
1655 
1656     def _print_KroneckerDelta(self, expr, exp=None):
1657         i = self._print(expr.args[0])
1658         j = self._print(expr.args[1])
1659         if expr.args[0].is_Atom and expr.args[1].is_Atom:
1660             tex = r'\delta_{%s %s}' % (i, j)
1661         else:
1662             tex = r'\delta_{%s, %s}' % (i, j)
1663         if exp:
1664             tex = r'\left(%s\right)^{%s}' % (tex, exp)
1665         return tex
1666 
1667     def _print_LeviCivita(self, expr, exp=None):
1668         indices = map(self._print, expr.args)
1669         if all(x.is_Atom for x in expr.args):
1670             tex = r'\varepsilon_{%s}' % " ".join(indices)
1671         else:
1672             tex = r'\varepsilon_{%s}' % ", ".join(indices)
1673         if exp:
1674             tex = r'\left(%s\right)^{%s}' % (tex, exp)
1675         return tex
1676 
1677     def _print_ProductSet(self, p):
1678         if len(p.sets) > 1 and not has_variety(p.sets):
1679             return self._print(p.sets[0]) + "^%d" % len(p.sets)
1680         else:
1681             return r" \times ".join(self._print(set) for set in p.sets)
1682 
1683     def _print_RandomDomain(self, d):
1684         if hasattr(d, 'as_boolean'):
1685             return 'Domain: ' + self._print(d.as_boolean())
1686         elif hasattr(d, 'set'):
1687             return ('Domain: ' + self._print(d.symbols) + ' in ' +
1688                     self._print(d.set))
1689         elif hasattr(d, 'symbols'):
1690             return 'Domain on ' + self._print(d.symbols)
1691         else:
1692             return self._print(None)
1693 
1694     def _print_FiniteSet(self, s):
1695         items = sorted(s.args, key=default_sort_key)
1696         return self._print_set(items)
1697 
1698     def _print_set(self, s):
1699         items = sorted(s, key=default_sort_key)
1700         items = ", ".join(map(self._print, items))
1701         return r"\left\{%s\right\}" % items
1702 
1703     _print_frozenset = _print_set
1704 
1705     def _print_Range(self, s):
1706         dots = r'\ldots'
1707 
1708         if s.start.is_infinite:
1709             printset = s.start, dots, s[-1] - s.step, s[-1]
1710         elif s.stop.is_infinite or len(s) > 4:
1711             it = iter(s)
1712             printset = next(it), next(it), dots, s[-1]
1713         else:
1714             printset = tuple(s)
1715 
1716         return (r"\left\{"
1717               + r", ".join(self._print(el) for el in printset)
1718               + r"\right\}")
1719 
1720     def _print_SeqFormula(self, s):
1721         if s.start is S.NegativeInfinity:
1722             stop = s.stop
1723             printset = (r'\ldots', s.coeff(stop - 3), s.coeff(stop - 2),
1724                 s.coeff(stop - 1), s.coeff(stop))
1725         elif s.stop is S.Infinity or s.length > 4:
1726             printset = s[:4]
1727             printset.append(r'\ldots')
1728         else:
1729             printset = tuple(s)
1730 
1731         return (r"\left["
1732               + r", ".join(self._print(el) for el in printset)
1733               + r"\right]")
1734 
1735     _print_SeqPer = _print_SeqFormula
1736     _print_SeqAdd = _print_SeqFormula
1737     _print_SeqMul = _print_SeqFormula
1738 
1739     def _print_Interval(self, i):
1740         if i.start == i.end:
1741             return r"\left\{%s\right\}" % self._print(i.start)
1742 
1743         else:
1744             if i.left_open:
1745                 left = '('
1746             else:
1747                 left = '['
1748 
1749             if i.right_open:
1750                 right = ')'
1751             else:
1752                 right = ']'
1753 
1754             return r"\left%s%s, %s\right%s" % \
1755                    (left, self._print(i.start), self._print(i.end), right)
1756 
1757     def _print_AccumulationBounds(self, i):
1758         return r"\langle %s, %s\rangle" % \
1759                 (self._print(i.min), self._print(i.max))
1760 
1761     def _print_Union(self, u):
1762         return r" \cup ".join([self._print(i) for i in u.args])
1763 
1764     def _print_Complement(self, u):
1765         return r" \setminus ".join([self._print(i) for i in u.args])
1766 
1767     def _print_Intersection(self, u):
1768         return r" \cap ".join([self._print(i) for i in u.args])
1769 
1770     def _print_SymmetricDifference(self, u):
1771         return r" \triangle ".join([self._print(i) for i in u.args])
1772 
1773     def _print_EmptySet(self, e):
1774         return r"\emptyset"
1775 
1776     def _print_Naturals(self, n):
1777         return r"\mathbb{N}"
1778 
1779     def _print_Naturals0(self, n):
1780         return r"\mathbb{N}_0"
1781 
1782     def _print_Integers(self, i):
1783         return r"\mathbb{Z}"
1784 
1785     def _print_Reals(self, i):
1786         return r"\mathbb{R}"
1787 
1788     def _print_Complexes(self, i):
1789         return r"\mathbb{C}"
1790 
1791     def _print_ImageSet(self, s):
1792         sets = s.args[1:]
1793         varsets = [r"%s \in %s" % (self._print(var), self._print(setv))
1794             for var, setv in zip(s.lamda.variables, sets)]
1795         return r"\left\{%s\; |\; %s\right\}" % (
1796             self._print(s.lamda.expr),
1797             ', '.join(varsets))
1798 
1799     def _print_ConditionSet(self, s):
1800         vars_print = ', '.join([self._print(var) for var in Tuple(s.sym)])
1801         if s.base_set is S.UniversalSet:
1802             return r"\left\{%s \mid %s \right\}" % (
1803             vars_print,
1804             self._print(s.condition.as_expr()))
1805 
1806         return r"\left\{%s \mid %s \in %s \wedge %s \right\}" % (
1807             vars_print,
1808             vars_print,
1809             self._print(s.base_set),
1810             self._print(s.condition.as_expr()))
1811 
1812     def _print_ComplexRegion(self, s):
1813         vars_print = ', '.join([self._print(var) for var in s.variables])
1814         return r"\left\{%s\; |\; %s \in %s \right\}" % (
1815             self._print(s.expr),
1816             vars_print,
1817             self._print(s.sets))
1818 
1819     def _print_Contains(self, e):
1820         return r"%s \in %s" % tuple(self._print(a) for a in e.args)
1821 
1822     def _print_FourierSeries(self, s):
1823         return self._print_Add(s.truncate()) + self._print(r' + \ldots')
1824 
1825     def _print_FormalPowerSeries(self, s):
1826         return self._print_Add(s.infinite)
1827 
1828     def _print_FiniteField(self, expr):
1829         return r"\mathbb{F}_{%s}" % expr.mod
1830 
1831     def _print_IntegerRing(self, expr):
1832         return r"\mathbb{Z}"
1833 
1834     def _print_RationalField(self, expr):
1835         return r"\mathbb{Q}"
1836 
1837     def _print_RealField(self, expr):
1838         return r"\mathbb{R}"
1839 
1840     def _print_ComplexField(self, expr):
1841         return r"\mathbb{C}"
1842 
1843     def _print_PolynomialRing(self, expr):
1844         domain = self._print(expr.domain)
1845         symbols = ", ".join(map(self._print, expr.symbols))
1846         return r"%s\left[%s\right]" % (domain, symbols)
1847 
1848     def _print_FractionField(self, expr):
1849         domain = self._print(expr.domain)
1850         symbols = ", ".join(map(self._print, expr.symbols))
1851         return r"%s\left(%s\right)" % (domain, symbols)
1852 
1853     def _print_PolynomialRingBase(self, expr):
1854         domain = self._print(expr.domain)
1855         symbols = ", ".join(map(self._print, expr.symbols))
1856         inv = ""
1857         if not expr.is_Poly:
1858             inv = r"S_<^{-1}"
1859         return r"%s%s\left[%s\right]" % (inv, domain, symbols)
1860 
1861     def _print_Poly(self, poly):
1862         cls = poly.__class__.__name__
1863         terms = []
1864         for monom, coeff in poly.terms():
1865             s_monom = ''
1866             for i, exp in enumerate(monom):
1867                 if exp > 0:
1868                     if exp == 1:
1869                         s_monom += self._print(poly.gens[i])
1870                     else:
1871                         s_monom += self._print(pow(poly.gens[i], exp))
1872 
1873             if coeff.is_Add:
1874                 if s_monom:
1875                     s_coeff = r"\left(%s\right)" % self._print(coeff)
1876                 else:
1877                     s_coeff = self._print(coeff)
1878             else:
1879                 if s_monom:
1880                     if coeff is S.One:
1881                         terms.extend(['+', s_monom])
1882                         continue
1883 
1884                     if coeff is S.NegativeOne:
1885                         terms.extend(['-', s_monom])
1886                         continue
1887 
1888                 s_coeff = self._print(coeff)
1889 
1890             if not s_monom:
1891                 s_term = s_coeff
1892             else:
1893                 s_term = s_coeff + " " + s_monom
1894 
1895             if s_term.startswith('-'):
1896                 terms.extend(['-', s_term[1:]])
1897             else:
1898                 terms.extend(['+', s_term])
1899 
1900         if terms[0] in ['-', '+']:
1901             modifier = terms.pop(0)
1902 
1903             if modifier == '-':
1904                 terms[0] = '-' + terms[0]
1905 
1906         expr = ' '.join(terms)
1907         gens = list(map(self._print, poly.gens))
1908         domain = "domain=%s" % self._print(poly.get_domain())
1909 
1910         args = ", ".join([expr] + gens + [domain])
1911         if cls in accepted_latex_functions:
1912             tex = r"\%s {\left (%s \right )}" % (cls, args)
1913         else:
1914             tex = r"\operatorname{%s}{\left( %s \right)}" % (cls, args)
1915 
1916         return tex
1917 
1918     def _print_ComplexRootOf(self, root):
1919         cls = root.__class__.__name__
1920         if cls == "ComplexRootOf":
1921             cls = "CRootOf"
1922         expr = self._print(root.expr)
1923         index = root.index
1924         if cls in accepted_latex_functions:
1925             return r"\%s {\left(%s, %d\right)}" % (cls, expr, index)
1926         else:
1927             return r"\operatorname{%s} {\left(%s, %d\right)}" % (cls, expr, index)
1928 
1929     def _print_RootSum(self, expr):
1930         cls = expr.__class__.__name__
1931         args = [self._print(expr.expr)]
1932 
1933         if expr.fun is not S.IdentityFunction:
1934             args.append(self._print(expr.fun))
1935 
1936         if cls in accepted_latex_functions:
1937             return r"\%s {\left(%s\right)}" % (cls, ", ".join(args))
1938         else:
1939             return r"\operatorname{%s} {\left(%s\right)}" % (cls, ", ".join(args))
1940 
1941     def _print_PolyElement(self, poly):
1942         mul_symbol = self._settings['mul_symbol_latex']
1943         return poly.str(self, PRECEDENCE, "{%s}^{%d}", mul_symbol)
1944 
1945     def _print_FracElement(self, frac):
1946         if frac.denom == 1:
1947             return self._print(frac.numer)
1948         else:
1949             numer = self._print(frac.numer)
1950             denom = self._print(frac.denom)
1951             return r"\frac{%s}{%s}" % (numer, denom)
1952 
1953     def _print_euler(self, expr, exp=None):
1954         m, x = (expr.args[0], None) if len(expr.args) == 1 else expr.args
1955         tex = r"E_{%s}" % self._print(m)
1956         if exp is not None:
1957             tex = r"%s^{%s}" % (tex, self._print(exp))
1958         if x is not None:
1959             tex = r"%s\left(%s\right)" % (tex, self._print(x))
1960         return tex
1961 
1962     def _print_catalan(self, expr, exp=None):
1963         tex = r"C_{%s}" % self._print(expr.args[0])
1964         if exp is not None:
1965             tex = r"%s^{%s}" % (tex, self._print(exp))
1966         return tex
1967 
1968     def _print_MellinTransform(self, expr):
1969         return r"\mathcal{M}_{%s}\left[%s\right]\left(%s\right)" % (self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))
1970 
1971     def _print_InverseMellinTransform(self, expr):
1972         return r"\mathcal{M}^{-1}_{%s}\left[%s\right]\left(%s\right)" % (self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))
1973 
1974     def _print_LaplaceTransform(self, expr):
1975         return r"\mathcal{L}_{%s}\left[%s\right]\left(%s\right)" % (self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))
1976 
1977     def _print_InverseLaplaceTransform(self, expr):
1978         return r"\mathcal{L}^{-1}_{%s}\left[%s\right]\left(%s\right)" % (self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))
1979 
1980     def _print_FourierTransform(self, expr):
1981         return r"\mathcal{F}_{%s}\left[%s\right]\left(%s\right)" % (self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))
1982 
1983     def _print_InverseFourierTransform(self, expr):
1984         return r"\mathcal{F}^{-1}_{%s}\left[%s\right]\left(%s\right)" % (self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))
1985 
1986     def _print_SineTransform(self, expr):
1987         return r"\mathcal{SIN}_{%s}\left[%s\right]\left(%s\right)" % (self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))
1988 
1989     def _print_InverseSineTransform(self, expr):
1990         return r"\mathcal{SIN}^{-1}_{%s}\left[%s\right]\left(%s\right)" % (self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))
1991 
1992     def _print_CosineTransform(self, expr):
1993         return r"\mathcal{COS}_{%s}\left[%s\right]\left(%s\right)" % (self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))
1994 
1995     def _print_InverseCosineTransform(self, expr):
1996         return r"\mathcal{COS}^{-1}_{%s}\left[%s\right]\left(%s\right)" % (self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))
1997 
1998     def _print_DMP(self, p):
1999         try:
2000             if p.ring is not None:
2001                 # TODO incorporate order
2002                 return self._print(p.ring.to_sympy(p))
2003         except SympifyError:
2004             pass
2005         return self._print(repr(p))
2006 
2007     def _print_DMF(self, p):
2008         return self._print_DMP(p)
2009 
2010     def _print_Object(self, object):
2011         return self._print(Symbol(object.name))
2012 
2013     def _print_Morphism(self, morphism):
2014         domain = self._print(morphism.domain)
2015         codomain = self._print(morphism.codomain)
2016         return "%s\\rightarrow %s" % (domain, codomain)
2017 
2018     def _print_NamedMorphism(self, morphism):
2019         pretty_name = self._print(Symbol(morphism.name))
2020         pretty_morphism = self._print_Morphism(morphism)
2021         return "%s:%s" % (pretty_name, pretty_morphism)
2022 
2023     def _print_IdentityMorphism(self, morphism):
2024         from sympy.categories import NamedMorphism
2025         return self._print_NamedMorphism(NamedMorphism(
2026             morphism.domain, morphism.codomain, "id"))
2027 
2028     def _print_CompositeMorphism(self, morphism):
2029         # All components of the morphism have names and it is thus
2030         # possible to build the name of the composite.
2031         component_names_list = [self._print(Symbol(component.name)) for
2032                                 component in morphism.components]
2033         component_names_list.reverse()
2034         component_names = "\\circ ".join(component_names_list) + ":"
2035 
2036         pretty_morphism = self._print_Morphism(morphism)
2037         return component_names + pretty_morphism
2038 
2039     def _print_Category(self, morphism):
2040         return "\\mathbf{%s}" % self._print(Symbol(morphism.name))
2041 
2042     def _print_Diagram(self, diagram):
2043         if not diagram.premises:
2044             # This is an empty diagram.
2045             return self._print(S.EmptySet)
2046 
2047         latex_result = self._print(diagram.premises)
2048         if diagram.conclusions:
2049             latex_result += "\\Longrightarrow %s" % \
2050                             self._print(diagram.conclusions)
2051 
2052         return latex_result
2053 
2054     def _print_DiagramGrid(self, grid):
2055         latex_result = "\\begin{array}{%s}\n" % ("c" * grid.width)
2056 
2057         for i in range(grid.height):
2058             for j in range(grid.width):
2059                 if grid[i, j]:
2060                     latex_result += latex(grid[i, j])
2061                 latex_result += " "
2062                 if j != grid.width - 1:
2063                     latex_result += "& "
2064 
2065             if i != grid.height - 1:
2066                 latex_result += "\\\\"
2067             latex_result += "\n"
2068 
2069         latex_result += "\\end{array}\n"
2070         return latex_result
2071 
2072     def _print_FreeModule(self, M):
2073         return '{%s}^{%s}' % (self._print(M.ring), self._print(M.rank))
2074 
2075     def _print_FreeModuleElement(self, m):
2076         # Print as row vector for convenience, for now.
2077         return r"\left[ %s \right]" % ",".join(
2078             '{' + self._print(x) + '}' for x in m)
2079 
2080     def _print_SubModule(self, m):
2081         return r"\left< %s \right>" % ",".join(
2082             '{' + self._print(x) + '}' for x in m.gens)
2083 
2084     def _print_ModuleImplementedIdeal(self, m):
2085         return r"\left< %s \right>" % ",".join(
2086             '{' + self._print(x) + '}' for [x] in m._module.gens)
2087 
2088     def _print_Quaternion(self, expr):
2089         # TODO: This expression is potentially confusing,
2090         # shall we print it as `Quaternion( ... )`?
2091         s = [self.parenthesize(i, PRECEDENCE["Mul"], strict=True) for i in expr.args]
2092         a = [s[0]] + [i+" "+j for i, j in zip(s[1:], "ijk")]
2093         return " + ".join(a)
2094 
2095     def _print_QuotientRing(self, R):
2096         # TODO nicer fractions for few generators...
2097         return r"\frac{%s}{%s}" % (self._print(R.ring), self._print(R.base_ideal))
2098 
2099     def _print_QuotientRingElement(self, x):
2100         return r"{%s} + {%s}" % (self._print(x.data), self._print(x.ring.base_ideal))
2101 
2102     def _print_QuotientModuleElement(self, m):
2103         return r"{%s} + {%s}" % (self._print(m.data),
2104                                  self._print(m.module.killed_module))
2105 
2106     def _print_QuotientModule(self, M):
2107         # TODO nicer fractions for few generators...
2108         return r"\frac{%s}{%s}" % (self._print(M.base),
2109                                    self._print(M.killed_module))
2110 
2111     def _print_MatrixHomomorphism(self, h):
2112         return r"{%s} : {%s} \to {%s}" % (self._print(h._sympy_matrix()),
2113             self._print(h.domain), self._print(h.codomain))
2114 
2115     def _print_BaseScalarField(self, field):
2116         string = field._coord_sys._names[field._index]
2117         return r'\boldsymbol{\mathrm{%s}}' % self._print(Symbol(string))
2118 
2119     def _print_BaseVectorField(self, field):
2120         string = field._coord_sys._names[field._index]
2121         return r'\partial_{%s}' % self._print(Symbol(string))
2122 
2123     def _print_Differential(self, diff):
2124         field = diff._form_field
2125         if hasattr(field, '_coord_sys'):
2126             string = field._coord_sys._names[field._index]
2127             return r'\mathrm{d}%s' % self._print(Symbol(string))
2128         else:
2129             return 'd(%s)' % self._print(field)
2130             string = self._print(field)
2131             return r'\mathrm{d}\left(%s\right)' % string
2132 
2133     def _print_Tr(self, p):
2134         #Todo: Handle indices
2135         contents = self._print(p.args[0])
2136         return r'\mbox{Tr}\left(%s\right)' % (contents)
2137 
2138     def _print_totient(self, expr, exp=None):
2139         if exp is not None:
2140             return r'\left(\phi\left(%s\right)\right)^{%s}' % (self._print(expr.args[0]),
2141                     self._print(exp))
2142         return r'\phi\left(%s\right)' % self._print(expr.args[0])
2143 
2144     def _print_reduced_totient(self, expr, exp=None):
2145         if exp is not None:
2146             return r'\left(\lambda\left(%s\right)\right)^{%s}' % (self._print(expr.args[0]),
2147                     self._print(exp))
2148         return r'\lambda\left(%s\right)' % self._print(expr.args[0])
2149 
2150     def _print_divisor_sigma(self, expr, exp=None):
2151         if len(expr.args) == 2:
2152             tex = r"_%s\left(%s\right)" % tuple(map(self._print,
2153                                                 (expr.args[1], expr.args[0])))
2154         else:
2155             tex = r"\left(%s\right)" % self._print(expr.args[0])
2156         if exp is not None:
2157             return r"\sigma^{%s}%s" % (self._print(exp), tex)
2158         return r"\sigma%s" % tex
2159 
2160     def _print_udivisor_sigma(self, expr, exp=None):
2161         if len(expr.args) == 2:
2162             tex = r"_%s\left(%s\right)" % tuple(map(self._print,
2163                                                 (expr.args[1], expr.args[0])))
2164         else:
2165             tex = r"\left(%s\right)" % self._print(expr.args[0])
2166         if exp is not None:
2167             return r"\sigma^*^{%s}%s" % (self._print(exp), tex)
2168         return r"\sigma^*%s" % tex
2169 
2170     def _print_primenu(self, expr, exp=None):
2171         if exp is not None:
2172             return r'\left(\nu\left(%s\right)\right)^{%s}' % (self._print(expr.args[0]),
2173                     self._print(exp))
2174         return r'\nu\left(%s\right)' % self._print(expr.args[0])
2175 
2176     def _print_primeomega(self, expr, exp=None):
2177         if exp is not None:
2178             return r'\left(\Omega\left(%s\right)\right)^{%s}' % (self._print(expr.args[0]),
2179                     self._print(exp))
2180         return r'\Omega\left(%s\right)' % self._print(expr.args[0])

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>]
2025-10-18 08:13:00.474 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-18 08:13:00.474 | INFO     | Search-only: skipping patch selection
2025-10-18 08:13:00.578 | INFO     | Task sympy__sympy-14774 completed successfully.
2025-10-18 08:13:00.579 | INFO     | No patch generated. You can try running ACR again.
