2025-10-18 09:15:27.188 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-18 09:15:37.596 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=125, output_tokens=12, cost=0.001610
2025-10-18 09:15:48.367 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=305, output_tokens=441, cost=0.016280
2025-10-18 09:15:50.092 | INFO     | registered non reproducing test 0
2025-10-18 09:16:01.702 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1025, output_tokens=530, cost=0.026150
2025-10-18 09:16:03.024 | INFO     | registered non reproducing test 1
2025-10-18 09:16:14.976 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1119, output_tokens=564, cost=0.028110
2025-10-18 09:16:16.299 | INFO     | registered non reproducing test 2
2025-10-18 09:16:16.299 | WARNING  | Failed to write a reproducer test; skipping reproducer tracing
2025-10-18 09:16:16.306 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 09:16:23.079 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=434, output_tokens=273, cost=0.012530
2025-10-18 09:16:23.088 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 09:16:26.451 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=627, output_tokens=40, cost=0.007470
2025-10-18 09:16:26.453 | DEBUG    | Extracted a valid json.
2025-10-18 09:16:26.453 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_class('Mul')",
        "search_method('latex')",
        "search_code('evaluate=False')"
    ],
    "bug_locations": []
}
2025-10-18 09:16:27.402 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 09:16:27.403 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 09:16:44.049 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=6481, output_tokens=758, cost=0.087550
2025-10-18 09:16:44.056 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 09:16:51.712 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=7455, output_tokens=348, cost=0.084990
2025-10-18 09:16:51.720 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 09:17:00.841 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=702, output_tokens=329, cost=0.016890
2025-10-18 09:17:00.842 | DEBUG    | Extracted a valid json.
2025-10-18 09:17:00.842 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "sympy/printing/latex.py",
            "class": "",
            "method": "latex",
            "intended_behavior": "The `latex` method should include additional handling for `Mul` expressions where `evaluate=False`. Specifically, it needs to ensure that when converting these expressions to LaTeX, appropriate spacing or multiplication symbols are inserted between terms to reflect the mathematical intention accurately. This modification must preserve all other functionality, such as formatting options and handling of other expression types. The update should not disrupt the custom formatting settings provided by the user and should only augment the handling of unevaluated `Mul` expressions to produce correct LaTeX output."
        },
        {
            "file": "sympy/core/mul.py",
            "class": "Mul",
            "method": "",
            "intended_behavior": "While the primary issue seems related to the LaTeX printing functionality, ensuring that the `Mul` class correctly represents the unevaluated multiplication in a manner consistent with LaTeX printing requirements may also be necessary. If `Mul`â€™s internal representation or methods that contribute to printing, such as `_latex` (if present) or related utilities, do not appropriately flag or structure unevaluated expressions, these should be adjusted. The adjustment should allow for clear differentiation between evaluated and unevaluated states in a way that the LaTeX printer can accurately render them. This may involve enriching the `Mul` object with metadata concerning its evaluated state or providing helper methods that the LaTeX printer can utilize to decide formatting."
        }
    ]
}
2025-10-18 09:17:00.855 | DEBUG    | Bug location extracted successfully: [<file>sympy/printing/latex.py</file>
<class>None</class>
<method>latex</method>
<code>
2746 def latex(expr, **settings):
2747     r"""Convert the given expression to LaTeX string representation.
2748 
2749     Parameters
2750     ==========
2751     full_prec: boolean, optional
2752         If set to True, a floating point number is printed with full precision.
2753     fold_frac_powers : boolean, optional
2754         Emit ``^{p/q}`` instead of ``^{\frac{p}{q}}`` for fractional powers.
2755     fold_func_brackets : boolean, optional
2756         Fold function brackets where applicable.
2757     fold_short_frac : boolean, optional
2758         Emit ``p / q`` instead of ``\frac{p}{q}`` when the denominator is
2759         simple enough (at most two terms and no powers). The default value is
2760         ``True`` for inline mode, ``False`` otherwise.
2761     inv_trig_style : string, optional
2762         How inverse trig functions should be displayed. Can be one of
2763         ``abbreviated``, ``full``, or ``power``. Defaults to ``abbreviated``.
2764     itex : boolean, optional
2765         Specifies if itex-specific syntax is used, including emitting
2766         ``$$...$$``.
2767     ln_notation : boolean, optional
2768         If set to ``True``, ``\ln`` is used instead of default ``\log``.
2769     long_frac_ratio : float or None, optional
2770         The allowed ratio of the width of the numerator to the width of the
2771         denominator before the printer breaks off long fractions. If ``None``
2772         (the default value), long fractions are not broken up.
2773     mat_delim : string, optional
2774         The delimiter to wrap around matrices. Can be one of ``[``, ``(``, or
2775         the empty string. Defaults to ``[``.
2776     mat_str : string, optional
2777         Which matrix environment string to emit. ``smallmatrix``, ``matrix``,
2778         ``array``, etc. Defaults to ``smallmatrix`` for inline mode, ``matrix``
2779         for matrices of no more than 10 columns, and ``array`` otherwise.
2780     mode: string, optional
2781         Specifies how the generated code will be delimited. ``mode`` can be one
2782         of ``plain``, ``inline``, ``equation`` or ``equation*``.  If ``mode``
2783         is set to ``plain``, then the resulting code will not be delimited at
2784         all (this is the default). If ``mode`` is set to ``inline`` then inline
2785         LaTeX ``$...$`` will be used. If ``mode`` is set to ``equation`` or
2786         ``equation*``, the resulting code will be enclosed in the ``equation``
2787         or ``equation*`` environment (remember to import ``amsmath`` for
2788         ``equation*``), unless the ``itex`` option is set. In the latter case,
2789         the ``$$...$$`` syntax is used.
2790     mul_symbol : string or None, optional
2791         The symbol to use for multiplication. Can be one of ``None``, ``ldot``,
2792         ``dot``, or ``times``.
2793     order: string, optional
2794         Any of the supported monomial orderings (currently ``lex``, ``grlex``,
2795         or ``grevlex``), ``old``, and ``none``. This parameter does nothing for
2796         Mul objects. Setting order to ``old`` uses the compatibility ordering
2797         for Add defined in Printer. For very large expressions, set the
2798         ``order`` keyword to ``none`` if speed is a concern.
2799     symbol_names : dictionary of strings mapped to symbols, optional
2800         Dictionary of symbols and the custom strings they should be emitted as.
2801     root_notation : boolean, optional
2802         If set to ``False``, exponents of the form 1/n are printed in fractonal
2803         form. Default is ``True``, to print exponent in root form.
2804     mat_symbol_style : string, optional
2805         Can be either ``plain`` (default) or ``bold``. If set to ``bold``,
2806         a MatrixSymbol A will be printed as ``\mathbf{A}``, otherwise as ``A``.
2807     imaginary_unit : string, optional
2808         String to use for the imaginary unit. Defined options are "i" (default)
2809         and "j". Adding "r" or "t" in front gives ``\mathrm`` or ``\text``, so
2810         "ri" leads to ``\mathrm{i}`` which gives `\mathrm{i}`.
2811     gothic_re_im : boolean, optional
2812         If set to ``True``, `\Re` and `\Im` is used for ``re`` and ``im``, respectively.
2813         The default is ``False`` leading to `\operatorname{re}` and `\operatorname{im}`.
2814     decimal_separator : string, optional
2815         Specifies what separator to use to separate the whole and fractional parts of a
2816         floating point number as in `2.5` for the default, ``period`` or `2{,}5`
2817         when ``comma`` is specified. Lists, sets, and tuple are printed with semicolon
2818         separating the elements when ``comma`` is chosen. For example, [1; 2; 3] when
2819         ``comma`` is chosen and [1,2,3] for when ``period`` is chosen.
2820     parenthesize_super : boolean, optional
2821         If set to ``False``, superscripted expressions will not be parenthesized when
2822         powered. Default is ``True``, which parenthesizes the expression when powered.
2823     min: Integer or None, optional
2824         Sets the lower bound for the exponent to print floating point numbers in
2825         fixed-point format.
2826     max: Integer or None, optional
2827         Sets the upper bound for the exponent to print floating point numbers in
2828         fixed-point format.
2829 
2830     Notes
2831     =====
2832 
2833     Not using a print statement for printing, results in double backslashes for
2834     latex commands since that's the way Python escapes backslashes in strings.
2835 
2836     >>> from sympy import latex, Rational
2837     >>> from sympy.abc import tau
2838     >>> latex((2*tau)**Rational(7,2))
2839     '8 \\sqrt{2} \\tau^{\\frac{7}{2}}'
2840     >>> print(latex((2*tau)**Rational(7,2)))
2841     8 \sqrt{2} \tau^{\frac{7}{2}}
2842 
2843     Examples
2844     ========
2845 
2846     >>> from sympy import latex, pi, sin, asin, Integral, Matrix, Rational, log
2847     >>> from sympy.abc import x, y, mu, r, tau
2848 
2849     Basic usage:
2850 
2851     >>> print(latex((2*tau)**Rational(7,2)))
2852     8 \sqrt{2} \tau^{\frac{7}{2}}
2853 
2854     ``mode`` and ``itex`` options:
2855 
2856     >>> print(latex((2*mu)**Rational(7,2), mode='plain'))
2857     8 \sqrt{2} \mu^{\frac{7}{2}}
2858     >>> print(latex((2*tau)**Rational(7,2), mode='inline'))
2859     $8 \sqrt{2} \tau^{7 / 2}$
2860     >>> print(latex((2*mu)**Rational(7,2), mode='equation*'))
2861     \begin{equation*}8 \sqrt{2} \mu^{\frac{7}{2}}\end{equation*}
2862     >>> print(latex((2*mu)**Rational(7,2), mode='equation'))
2863     \begin{equation}8 \sqrt{2} \mu^{\frac{7}{2}}\end{equation}
2864     >>> print(latex((2*mu)**Rational(7,2), mode='equation', itex=True))
2865     $$8 \sqrt{2} \mu^{\frac{7}{2}}$$
2866     >>> print(latex((2*mu)**Rational(7,2), mode='plain'))
2867     8 \sqrt{2} \mu^{\frac{7}{2}}
2868     >>> print(latex((2*tau)**Rational(7,2), mode='inline'))
2869     $8 \sqrt{2} \tau^{7 / 2}$
2870     >>> print(latex((2*mu)**Rational(7,2), mode='equation*'))
2871     \begin{equation*}8 \sqrt{2} \mu^{\frac{7}{2}}\end{equation*}
2872     >>> print(latex((2*mu)**Rational(7,2), mode='equation'))
2873     \begin{equation}8 \sqrt{2} \mu^{\frac{7}{2}}\end{equation}
2874     >>> print(latex((2*mu)**Rational(7,2), mode='equation', itex=True))
2875     $$8 \sqrt{2} \mu^{\frac{7}{2}}$$
2876 
2877     Fraction options:
2878 
2879     >>> print(latex((2*tau)**Rational(7,2), fold_frac_powers=True))
2880     8 \sqrt{2} \tau^{7/2}
2881     >>> print(latex((2*tau)**sin(Rational(7,2))))
2882     \left(2 \tau\right)^{\sin{\left(\frac{7}{2} \right)}}
2883     >>> print(latex((2*tau)**sin(Rational(7,2)), fold_func_brackets=True))
2884     \left(2 \tau\right)^{\sin {\frac{7}{2}}}
2885     >>> print(latex(3*x**2/y))
2886     \frac{3 x^{2}}{y}
2887     >>> print(latex(3*x**2/y, fold_short_frac=True))
2888     3 x^{2} / y
2889     >>> print(latex(Integral(r, r)/2/pi, long_frac_ratio=2))
2890     \frac{\int r\, dr}{2 \pi}
2891     >>> print(latex(Integral(r, r)/2/pi, long_frac_ratio=0))
2892     \frac{1}{2 \pi} \int r\, dr
2893 
2894     Multiplication options:
2895 
2896     >>> print(latex((2*tau)**sin(Rational(7,2)), mul_symbol="times"))
2897     \left(2 \times \tau\right)^{\sin{\left(\frac{7}{2} \right)}}
2898 
2899     Trig options:
2900 
2901     >>> print(latex(asin(Rational(7,2))))
2902     \operatorname{asin}{\left(\frac{7}{2} \right)}
2903     >>> print(latex(asin(Rational(7,2)), inv_trig_style="full"))
2904     \arcsin{\left(\frac{7}{2} \right)}
2905     >>> print(latex(asin(Rational(7,2)), inv_trig_style="power"))
2906     \sin^{-1}{\left(\frac{7}{2} \right)}
2907 
2908     Matrix options:
2909 
2910     >>> print(latex(Matrix(2, 1, [x, y])))
2911     \left[\begin{matrix}x\\y\end{matrix}\right]
2912     >>> print(latex(Matrix(2, 1, [x, y]), mat_str = "array"))
2913     \left[\begin{array}{c}x\\y\end{array}\right]
2914     >>> print(latex(Matrix(2, 1, [x, y]), mat_delim="("))
2915     \left(\begin{matrix}x\\y\end{matrix}\right)
2916 
2917     Custom printing of symbols:
2918 
2919     >>> print(latex(x**2, symbol_names={x: 'x_i'}))
2920     x_i^{2}
2921 
2922     Logarithms:
2923 
2924     >>> print(latex(log(10)))
2925     \log{\left(10 \right)}
2926     >>> print(latex(log(10), ln_notation=True))
2927     \ln{\left(10 \right)}
2928 
2929     ``latex()`` also supports the builtin container types :class:`list`,
2930     :class:`tuple`, and :class:`dict`:
2931 
2932     >>> print(latex([2/x, y], mode='inline'))
2933     $\left[ 2 / x, \  y\right]$
2934 
2935     Unsupported types are rendered as monospaced plaintext:
2936 
2937     >>> print(latex(int))
2938     \mathtt{\text{<class 'int'>}}
2939     >>> print(latex("plain % text"))
2940     \mathtt{\text{plain \% text}}
2941 
2942     See :ref:`printer_method_example` for an example of how to override
2943     this behavior for your own types by implementing ``_latex``.
2944 
2945     .. versionchanged:: 1.7.0
2946         Unsupported types no longer have their ``str`` representation treated as valid latex.
2947 
2948     """
2949     return LatexPrinter(settings).doprint(expr)

</code><intended_behavior>The `latex` method should include additional handling for `Mul` expressions where `evaluate=False`. Specifically, it needs to ensure that when converting these expressions to LaTeX, appropriate spacing or multiplication symbols are inserted between terms to reflect the mathematical intention accurately. This modification must preserve all other functionality, such as formatting options and handling of other expression types. The update should not disrupt the custom formatting settings provided by the user and should only augment the handling of unevaluated `Mul` expressions to produce correct LaTeX output.</intended_behavior>, <file>sympy/core/mul.py</file>
<class>Mul</class>
<method>None</method>
<code>
88 class Mul(Expr, AssocOp):
89     """
90     Expression representing multiplication operation for algebraic field.
91 
92     Every argument of ``Mul()`` must be ``Expr``. Infix operator ``*``
93     on most scalar objects in SymPy calls this class.
94 
95     Another use of ``Mul()`` is to represent the structure of abstract
96     multiplication so that its arguments can be substituted to return
97     different class. Refer to examples section for this.
98 
99     ``Mul()`` evaluates the argument unless ``evaluate=False`` is passed.
100     The evaluation logic includes:
101 
102     1. Flattening
103         ``Mul(x, Mul(y, z))`` -> ``Mul(x, y, z)``
104 
105     2. Identity removing
106         ``Mul(x, 1, y)`` -> ``Mul(x, y)``
107 
108     3. Exponent collecting by ``.as_base_exp()``
109         ``Mul(x, x**2)`` -> ``Pow(x, 3)``
110 
111     4. Term sorting
112         ``Mul(y, x, 2)`` -> ``Mul(2, x, y)``
113 
114     Since multiplication can be vector space operation, arguments may
115     have the different :obj:`sympy.core.kind.Kind()`. Kind of the
116     resulting object is automatically inferred.
117 
118     Examples
119     ========
120 
121     >>> from sympy import Mul
122     >>> from sympy.abc import x, y
123     >>> Mul(x, 1)
124     x
125     >>> Mul(x, x)
126     x**2
127 
128     If ``evaluate=False`` is passed, result is not evaluated.
129 
130     >>> Mul(1, 2, evaluate=False)
131     1*2
132     >>> Mul(x, x, evaluate=False)
133     x*x
134 
135     ``Mul()`` also represents the general structure of multiplication
136     operation.
137 
138     >>> from sympy import MatrixSymbol
139     >>> A = MatrixSymbol('A', 2,2)
140     >>> expr = Mul(x,y).subs({y:A})
141     >>> expr
142     x*A
143     >>> type(expr)
144     <class 'sympy.matrices.expressions.matmul.MatMul'>
145 
146     See Also
147     ========
148 
149     MatMul
150 
151     """
152     __slots__ = ()
153 
154     is_Mul = True
155 
156     _args_type = Expr
157     _kind_dispatcher = KindDispatcher("Mul_kind_dispatcher", commutative=True)
158 
159     @property
160     def kind(self):
161         arg_kinds = (a.kind for a in self.args)
162         return self._kind_dispatcher(*arg_kinds)
163 
164     def __neg__(self):
165         c, args = self.as_coeff_mul()
166         c = -c
167         if c is not S.One:
168             if args[0].is_Number:
169                 args = list(args)
170                 if c is S.NegativeOne:
171                     args[0] = -args[0]
172                 else:
173                     args[0] *= c
174             else:
175                 args = (c,) + args
176         return self._from_args(args, self.is_commutative)
177 
178     @classmethod
179     def flatten(cls, seq):
180         """Return commutative, noncommutative and order arguments by
181         combining related terms.
182 
183         Notes
184         =====
185             * In an expression like ``a*b*c``, python process this through sympy
186               as ``Mul(Mul(a, b), c)``. This can have undesirable consequences.
187 
188               -  Sometimes terms are not combined as one would like:
189                  {c.f. https://github.com/sympy/sympy/issues/4596}
190 
191                 >>> from sympy import Mul, sqrt
192                 >>> from sympy.abc import x, y, z
193                 >>> 2*(x + 1) # this is the 2-arg Mul behavior
194                 2*x + 2
195                 >>> y*(x + 1)*2
196                 2*y*(x + 1)
197                 >>> 2*(x + 1)*y # 2-arg result will be obtained first
198                 y*(2*x + 2)
199                 >>> Mul(2, x + 1, y) # all 3 args simultaneously processed
200                 2*y*(x + 1)
201                 >>> 2*((x + 1)*y) # parentheses can control this behavior
202                 2*y*(x + 1)
203 
204                 Powers with compound bases may not find a single base to
205                 combine with unless all arguments are processed at once.
206                 Post-processing may be necessary in such cases.
207                 {c.f. https://github.com/sympy/sympy/issues/5728}
208 
209                 >>> a = sqrt(x*sqrt(y))
210                 >>> a**3
211                 (x*sqrt(y))**(3/2)
212                 >>> Mul(a,a,a)
213                 (x*sqrt(y))**(3/2)
214                 >>> a*a*a
215                 x*sqrt(y)*sqrt(x*sqrt(y))
216                 >>> _.subs(a.base, z).subs(z, a.base)
217                 (x*sqrt(y))**(3/2)
218 
219               -  If more than two terms are being multiplied then all the
220                  previous terms will be re-processed for each new argument.
221                  So if each of ``a``, ``b`` and ``c`` were :class:`Mul`
222                  expression, then ``a*b*c`` (or building up the product
223                  with ``*=``) will process all the arguments of ``a`` and
224                  ``b`` twice: once when ``a*b`` is computed and again when
225                  ``c`` is multiplied.
226 
227                  Using ``Mul(a, b, c)`` will process all arguments once.
228 
229             * The results of Mul are cached according to arguments, so flatten
230               will only be called once for ``Mul(a, b, c)``. If you can
231               structure a calculation so the arguments are most likely to be
232               repeats then this can save time in computing the answer. For
233               example, say you had a Mul, M, that you wished to divide by ``d[i]``
234               and multiply by ``n[i]`` and you suspect there are many repeats
235               in ``n``. It would be better to compute ``M*n[i]/d[i]`` rather
236               than ``M/d[i]*n[i]`` since every time n[i] is a repeat, the
237               product, ``M*n[i]`` will be returned without flattening -- the
238               cached value will be returned. If you divide by the ``d[i]``
239               first (and those are more unique than the ``n[i]``) then that will
240               create a new Mul, ``M/d[i]`` the args of which will be traversed
241               again when it is multiplied by ``n[i]``.
242 
243               {c.f. https://github.com/sympy/sympy/issues/5706}
244 
245               This consideration is moot if the cache is turned off.
246 
247             NB
248             --
249               The validity of the above notes depends on the implementation
250               details of Mul and flatten which may change at any time. Therefore,
251               you should only consider them when your code is highly performance
252               sensitive.
253 
254               Removal of 1 from the sequence is already handled by AssocOp.__new__.
255         """
256 
257         from sympy.calculus.util import AccumBounds
258         from sympy.matrices.expressions import MatrixExpr
259         rv = None
260         if len(seq) == 2:
261             a, b = seq
262             if b.is_Rational:
263                 a, b = b, a
264                 seq = [a, b]
265             assert not a is S.One
266             if not a.is_zero and a.is_Rational:
267                 r, b = b.as_coeff_Mul()
268                 if b.is_Add:
269                     if r is not S.One:  # 2-arg hack
270                         # leave the Mul as a Mul?
271                         ar = a*r
272                         if ar is S.One:
273                             arb = b
274                         else:
275                             arb = cls(a*r, b, evaluate=False)
276                         rv = [arb], [], None
277                     elif global_parameters.distribute and b.is_commutative:
278                         r, b = b.as_coeff_Add()
279                         bargs = [_keep_coeff(a, bi) for bi in Add.make_args(b)]
280                         _addsort(bargs)
281                         ar = a*r
282                         if ar:
283                             bargs.insert(0, ar)
284                         bargs = [Add._from_args(bargs)]
285                         rv = bargs, [], None
286             if rv:
287                 return rv
288 
289         # apply associativity, separate commutative part of seq
290         c_part = []         # out: commutative factors
291         nc_part = []        # out: non-commutative factors
292 
293         nc_seq = []
294 
295         coeff = S.One       # standalone term
296                             # e.g. 3 * ...
297 
298         c_powers = []       # (base,exp)      n
299                             # e.g. (x,n) for x
300 
301         num_exp = []        # (num-base, exp)           y
302                             # e.g.  (3, y)  for  ... * 3  * ...
303 
304         neg1e = S.Zero      # exponent on -1 extracted from Number-based Pow and I
305 
306         pnum_rat = {}       # (num-base, Rat-exp)          1/2
307                             # e.g.  (3, 1/2)  for  ... * 3     * ...
308 
309         order_symbols = None
310 
311         # --- PART 1 ---
312         #
313         # "collect powers and coeff":
314         #
315         # o coeff
316         # o c_powers
317         # o num_exp
318         # o neg1e
319         # o pnum_rat
320         #
321         # NOTE: this is optimized for all-objects-are-commutative case
322         for o in seq:
323             # O(x)
324             if o.is_Order:
325                 o, order_symbols = o.as_expr_variables(order_symbols)
326 
327             # Mul([...])
328             if o.is_Mul:
329                 if o.is_commutative:
330                     seq.extend(o.args)    # XXX zerocopy?
331 
332                 else:
333                     # NCMul can have commutative parts as well
334                     for q in o.args:
335                         if q.is_commutative:
336                             seq.append(q)
337                         else:
338                             nc_seq.append(q)
339 
340                     # append non-commutative marker, so we don't forget to
341                     # process scheduled non-commutative objects
342                     seq.append(NC_Marker)
343 
344                 continue
345 
346             # 3
347             elif o.is_Number:
348                 if o is S.NaN or coeff is S.ComplexInfinity and o.is_zero:
349                     # we know for sure the result will be nan
350                     return [S.NaN], [], None
351                 elif coeff.is_Number or isinstance(coeff, AccumBounds):  # it could be zoo
352                     coeff *= o
353                     if coeff is S.NaN:
354                         # we know for sure the result will be nan
355                         return [S.NaN], [], None
356                 continue
357 
358             elif isinstance(o, AccumBounds):
359                 coeff = o.__mul__(coeff)
360                 continue
361 
362             elif o is S.ComplexInfinity:
363                 if not coeff:
364                     # 0 * zoo = NaN
365                     return [S.NaN], [], None
366                 coeff = S.ComplexInfinity
367                 continue
368 
369             elif o is S.ImaginaryUnit:
370                 neg1e += S.Half
371                 continue
372 
373             elif o.is_commutative:
374                 #      e
375                 # o = b
376                 b, e = o.as_base_exp()
377 
378                 #  y
379                 # 3
380                 if o.is_Pow:
381                     if b.is_Number:
382 
383                         # get all the factors with numeric base so they can be
384                         # combined below, but don't combine negatives unless
385                         # the exponent is an integer
386                         if e.is_Rational:
387                             if e.is_Integer:
388                                 coeff *= Pow(b, e)  # it is an unevaluated power
389                                 continue
390                             elif e.is_negative:    # also a sign of an unevaluated power
391                                 seq.append(Pow(b, e))
392                                 continue
393                             elif b.is_negative:
394                                 neg1e += e
395                                 b = -b
396                             if b is not S.One:
397                                 pnum_rat.setdefault(b, []).append(e)
398                             continue
399                         elif b.is_positive or e.is_integer:
400                             num_exp.append((b, e))
401                             continue
402 
403                 c_powers.append((b, e))
404 
405             # NON-COMMUTATIVE
406             # TODO: Make non-commutative exponents not combine automatically
407             else:
408                 if o is not NC_Marker:
409                     nc_seq.append(o)
410 
411                 # process nc_seq (if any)
412                 while nc_seq:
413                     o = nc_seq.pop(0)
414                     if not nc_part:
415                         nc_part.append(o)
416                         continue
417 
418                     #                             b    c       b+c
419                     # try to combine last terms: a  * a   ->  a
420                     o1 = nc_part.pop()
421                     b1, e1 = o1.as_base_exp()
422                     b2, e2 = o.as_base_exp()
423                     new_exp = e1 + e2
424                     # Only allow powers to combine if the new exponent is
425                     # not an Add. This allow things like a**2*b**3 == a**5
426                     # if a.is_commutative == False, but prohibits
427                     # a**x*a**y and x**a*x**b from combining (x,y commute).
428                     if b1 == b2 and (not new_exp.is_Add):
429                         o12 = b1 ** new_exp
430 
431                         # now o12 could be a commutative object
432                         if o12.is_commutative:
433                             seq.append(o12)
434                             continue
435                         else:
436                             nc_seq.insert(0, o12)
437 
438                     else:
439                         nc_part.append(o1)
440                         nc_part.append(o)
441 
442         # We do want a combined exponent if it would not be an Add, such as
443         #  y    2y     3y
444         # x  * x   -> x
445         # We determine if two exponents have the same term by using
446         # as_coeff_Mul.
447         #
448         # Unfortunately, this isn't smart enough to consider combining into
449         # exponents that might already be adds, so things like:
450         #  z - y    y
451         # x      * x  will be left alone.  This is because checking every possible
452         # combination can slow things down.
453 
454         # gather exponents of common bases...
455         def _gather(c_powers):
456             common_b = {}  # b:e
457             for b, e in c_powers:
458                 co = e.as_coeff_Mul()
459                 common_b.setdefault(b, {}).setdefault(
460                     co[1], []).append(co[0])
461             for b, d in common_b.items():
462                 for di, li in d.items():
463                     d[di] = Add(*li)
464             new_c_powers = []
465             for b, e in common_b.items():
466                 new_c_powers.extend([(b, c*t) for t, c in e.items()])
467             return new_c_powers
468 
469         # in c_powers
470         c_powers = _gather(c_powers)
471 
472         # and in num_exp
473         num_exp = _gather(num_exp)
474 
475         # --- PART 2 ---
476         #
477         # o process collected powers  (x**0 -> 1; x**1 -> x; otherwise Pow)
478         # o combine collected powers  (2**x * 3**x -> 6**x)
479         #   with numeric base
480 
481         # ................................
482         # now we have:
483         # - coeff:
484         # - c_powers:    (b, e)
485         # - num_exp:     (2, e)
486         # - pnum_rat:    {(1/3, [1/3, 2/3, 1/4])}
487 
488         #  0             1
489         # x  -> 1       x  -> x
490 
491         # this should only need to run twice; if it fails because
492         # it needs to be run more times, perhaps this should be
493         # changed to a "while True" loop -- the only reason it
494         # isn't such now is to allow a less-than-perfect result to
495         # be obtained rather than raising an error or entering an
496         # infinite loop
497         for i in range(2):
498             new_c_powers = []
499             changed = False
500             for b, e in c_powers:
501                 if e.is_zero:
502                     # canceling out infinities yields NaN
503                     if (b.is_Add or b.is_Mul) and any(infty in b.args
504                         for infty in (S.ComplexInfinity, S.Infinity,
505                                       S.NegativeInfinity)):
506                         return [S.NaN], [], None
507                     continue
508                 if e is S.One:
509                     if b.is_Number:
510                         coeff *= b
511                         continue
512                     p = b
513                 if e is not S.One:
514                     p = Pow(b, e)
515                     # check to make sure that the base doesn't change
516                     # after exponentiation; to allow for unevaluated
517                     # Pow, we only do so if b is not already a Pow
518                     if p.is_Pow and not b.is_Pow:
519                         bi = b
520                         b, e = p.as_base_exp()
521                         if b != bi:
522                             changed = True
523                 c_part.append(p)
524                 new_c_powers.append((b, e))
525             # there might have been a change, but unless the base
526             # matches some other base, there is nothing to do
527             if changed and len({
528                     b for b, e in new_c_powers}) != len(new_c_powers):
529                 # start over again
530                 c_part = []
531                 c_powers = _gather(new_c_powers)
532             else:
533                 break
534 
535         #  x    x     x
536         # 2  * 3  -> 6
537         inv_exp_dict = {}   # exp:Mul(num-bases)     x    x
538                             # e.g.  x:6  for  ... * 2  * 3  * ...
539         for b, e in num_exp:
540             inv_exp_dict.setdefault(e, []).append(b)
541         for e, b in inv_exp_dict.items():
542             inv_exp_dict[e] = cls(*b)
543         c_part.extend([Pow(b, e) for e, b in inv_exp_dict.items() if e])
544 
545         # b, e -> e' = sum(e), b
546         # {(1/5, [1/3]), (1/2, [1/12, 1/4]} -> {(1/3, [1/5, 1/2])}
547         comb_e = {}
548         for b, e in pnum_rat.items():
549             comb_e.setdefault(Add(*e), []).append(b)
550         del pnum_rat
551         # process them, reducing exponents to values less than 1
552         # and updating coeff if necessary else adding them to
553         # num_rat for further processing
554         num_rat = []
555         for e, b in comb_e.items():
556             b = cls(*b)
557             if e.q == 1:
558                 coeff *= Pow(b, e)
559                 continue
560             if e.p > e.q:
561                 e_i, ep = divmod(e.p, e.q)
562                 coeff *= Pow(b, e_i)
563                 e = Rational(ep, e.q)
564             num_rat.append((b, e))
565         del comb_e
566 
567         # extract gcd of bases in num_rat
568         # 2**(1/3)*6**(1/4) -> 2**(1/3+1/4)*3**(1/4)
569         pnew = defaultdict(list)
570         i = 0  # steps through num_rat which may grow
571         while i < len(num_rat):
572             bi, ei = num_rat[i]
573             grow = []
574             for j in range(i + 1, len(num_rat)):
575                 bj, ej = num_rat[j]
576                 g = bi.gcd(bj)
577                 if g is not S.One:
578                     # 4**r1*6**r2 -> 2**(r1+r2)  *  2**r1 *  3**r2
579                     # this might have a gcd with something else
580                     e = ei + ej
581                     if e.q == 1:
582                         coeff *= Pow(g, e)
583                     else:
584                         if e.p > e.q:
585                             e_i, ep = divmod(e.p, e.q)  # change e in place
586                             coeff *= Pow(g, e_i)
587                             e = Rational(ep, e.q)
588                         grow.append((g, e))
589                     # update the jth item
590                     num_rat[j] = (bj/g, ej)
591                     # update bi that we are checking with
592                     bi = bi/g
593                     if bi is S.One:
594                         break
595             if bi is not S.One:
596                 obj = Pow(bi, ei)
597                 if obj.is_Number:
598                     coeff *= obj
599                 else:
600                     # changes like sqrt(12) -> 2*sqrt(3)
601                     for obj in Mul.make_args(obj):
602                         if obj.is_Number:
603                             coeff *= obj
604                         else:
605                             assert obj.is_Pow
606                             bi, ei = obj.args
607                             pnew[ei].append(bi)
608 
609             num_rat.extend(grow)
610             i += 1
611 
612         # combine bases of the new powers
613         for e, b in pnew.items():
614             pnew[e] = cls(*b)
615 
616         # handle -1 and I
617         if neg1e:
618             # treat I as (-1)**(1/2) and compute -1's total exponent
619             p, q =  neg1e.as_numer_denom()
620             # if the integer part is odd, extract -1
621             n, p = divmod(p, q)
622             if n % 2:
623                 coeff = -coeff
624             # if it's a multiple of 1/2 extract I
625             if q == 2:
626                 c_part.append(S.ImaginaryUnit)
627             elif p:
628                 # see if there is any positive base this power of
629                 # -1 can join
630                 neg1e = Rational(p, q)
631                 for e, b in pnew.items():
632                     if e == neg1e and b.is_positive:
633                         pnew[e] = -b
634                         break
635                 else:
636                     # keep it separate; we've already evaluated it as
637                     # much as possible so evaluate=False
638                     c_part.append(Pow(S.NegativeOne, neg1e, evaluate=False))
639 
640         # add all the pnew powers
641         c_part.extend([Pow(b, e) for e, b in pnew.items()])
642 
643         # oo, -oo
644         if (coeff is S.Infinity) or (coeff is S.NegativeInfinity):
645             def _handle_for_oo(c_part, coeff_sign):
646                 new_c_part = []
647                 for t in c_part:
648                     if t.is_extended_positive:
649                         continue
650                     if t.is_extended_negative:
651                         coeff_sign *= -1
652                         continue
653                     new_c_part.append(t)
654                 return new_c_part, coeff_sign
655             c_part, coeff_sign = _handle_for_oo(c_part, 1)
656             nc_part, coeff_sign = _handle_for_oo(nc_part, coeff_sign)
657             coeff *= coeff_sign
658 
659         # zoo
660         if coeff is S.ComplexInfinity:
661             # zoo might be
662             #   infinite_real + bounded_im
663             #   bounded_real + infinite_im
664             #   infinite_real + infinite_im
665             # and non-zero real or imaginary will not change that status.
666             c_part = [c for c in c_part if not (fuzzy_not(c.is_zero) and
667                                                 c.is_extended_real is not None)]
668             nc_part = [c for c in nc_part if not (fuzzy_not(c.is_zero) and
669                                                   c.is_extended_real is not None)]
670 
671         # 0
672         elif coeff.is_zero:
673             # we know for sure the result will be 0 except the multiplicand
674             # is infinity or a matrix
675             if any(isinstance(c, MatrixExpr) for c in nc_part):
676                 return [coeff], nc_part, order_symbols
677             if any(c.is_finite == False for c in c_part):
678                 return [S.NaN], [], order_symbols
679             return [coeff], [], order_symbols
680 
681         # check for straggling Numbers that were produced
682         _new = []
683         for i in c_part:
684             if i.is_Number:
685                 coeff *= i
686             else:
687                 _new.append(i)
688         c_part = _new
689 
690         # order commutative part canonically
691         _mulsort(c_part)
692 
693         # current code expects coeff to be always in slot-0
694         if coeff is not S.One:
695             c_part.insert(0, coeff)
696 
697         # we are done
698         if (global_parameters.distribute and not nc_part and len(c_part) == 2 and
699                 c_part[0].is_Number and c_part[0].is_finite and c_part[1].is_Add):
700             # 2*(1+a) -> 2 + 2 * a
701             coeff = c_part[0]
702             c_part = [Add(*[coeff*f for f in c_part[1].args])]
703 
704         return c_part, nc_part, order_symbols
705 
706     def _eval_power(self, e):
707 
708         # don't break up NC terms: (A*B)**3 != A**3*B**3, it is A*B*A*B*A*B
709         cargs, nc = self.args_cnc(split_1=False)
710 
711         if e.is_Integer:
712             return Mul(*[Pow(b, e, evaluate=False) for b in cargs]) * \
713                 Pow(Mul._from_args(nc), e, evaluate=False)
714         if e.is_Rational and e.q == 2:
715             from sympy.core.power import integer_nthroot
716             from sympy.functions.elementary.complexes import sign
717             if self.is_imaginary:
718                 a = self.as_real_imag()[1]
719                 if a.is_Rational:
720                     n, d = abs(a/2).as_numer_denom()
721                     n, t = integer_nthroot(n, 2)
722                     if t:
723                         d, t = integer_nthroot(d, 2)
724                         if t:
725                             r = sympify(n)/d
726                             return _unevaluated_Mul(r**e.p, (1 + sign(a)*S.ImaginaryUnit)**e.p)
727 
728         p = Pow(self, e, evaluate=False)
729 
730         if e.is_Rational or e.is_Float:
731             return p._eval_expand_power_base()
732 
733         return p
734 
735     @classmethod
736     def class_key(cls):
737         return 3, 0, cls.__name__
738 
739     def _eval_evalf(self, prec):
740         c, m = self.as_coeff_Mul()
741         if c is S.NegativeOne:
742             if m.is_Mul:
743                 rv = -AssocOp._eval_evalf(m, prec)
744             else:
745                 mnew = m._eval_evalf(prec)
746                 if mnew is not None:
747                     m = mnew
748                 rv = -m
749         else:
750             rv = AssocOp._eval_evalf(self, prec)
751         if rv.is_number:
752             return rv.expand()
753         return rv
754 
755     @property
756     def _mpc_(self):
757         """
758         Convert self to an mpmath mpc if possible
759         """
760         from sympy.core.numbers import I, Float
761         im_part, imag_unit = self.as_coeff_Mul()
762         if not imag_unit == I:
763             # ValueError may seem more reasonable but since it's a @property,
764             # we need to use AttributeError to keep from confusing things like
765             # hasattr.
766             raise AttributeError("Cannot convert Mul to mpc. Must be of the form Number*I")
767 
768         return (Float(0)._mpf_, Float(im_part)._mpf_)
769 
770     @cacheit
771     def as_two_terms(self):
772         """Return head and tail of self.
773 
774         This is the most efficient way to get the head and tail of an
775         expression.
776 
777         - if you want only the head, use self.args[0];
778         - if you want to process the arguments of the tail then use
779           self.as_coef_mul() which gives the head and a tuple containing
780           the arguments of the tail when treated as a Mul.
781         - if you want the coefficient when self is treated as an Add
782           then use self.as_coeff_add()[0]
783 
784         Examples
785         ========
786 
787         >>> from sympy.abc import x, y
788         >>> (3*x*y).as_two_terms()
789         (3, x*y)
790         """
791         args = self.args
792 
793         if len(args) == 1:
794             return S.One, self
795         elif len(args) == 2:
796             return args
797 
798         else:
799             return args[0], self._new_rawargs(*args[1:])
800 
801     @cacheit
802     def as_coefficients_dict(self):
803         """Return a dictionary mapping terms to their coefficient.
804         Since the dictionary is a defaultdict, inquiries about terms which
805         were not present will return a coefficient of 0. The dictionary
806         is considered to have a single term.
807 
808         Examples
809         ========
810 
811         >>> from sympy.abc import a, x
812         >>> (3*a*x).as_coefficients_dict()
813         {a*x: 3}
814         >>> _[a]
815         0
816         """
817 
818         d = defaultdict(int)
819         args = self.args
820 
821         if len(args) == 1 or not args[0].is_Number:
822             d[self] = S.One
823         else:
824             d[self._new_rawargs(*args[1:])] = args[0]
825 
826         return d
827 
828     @cacheit
829     def as_coeff_mul(self, *deps, rational=True, **kwargs):
830         if deps:
831             from sympy.utilities.iterables import sift
832             l1, l2 = sift(self.args, lambda x: x.has(*deps), binary=True)
833             return self._new_rawargs(*l2), tuple(l1)
834         args = self.args
835         if args[0].is_Number:
836             if not rational or args[0].is_Rational:
837                 return args[0], args[1:]
838             elif args[0].is_extended_negative:
839                 return S.NegativeOne, (-args[0],) + args[1:]
840         return S.One, args
841 
842     def as_coeff_Mul(self, rational=False):
843         """
844         Efficiently extract the coefficient of a product.
845         """
846         coeff, args = self.args[0], self.args[1:]
847 
848         if coeff.is_Number:
849             if not rational or coeff.is_Rational:
850                 if len(args) == 1:
851                     return coeff, args[0]
852                 else:
853                     return coeff, self._new_rawargs(*args)
854             elif coeff.is_extended_negative:
855                 return S.NegativeOne, self._new_rawargs(*((-coeff,) + args))
856         return S.One, self
857 
858     def as_real_imag(self, deep=True, **hints):
859         from sympy import Abs, expand_mul, im, re
860         other = []
861         coeffr = []
862         coeffi = []
863         addterms = S.One
864         for a in self.args:
865             r, i = a.as_real_imag()
866             if i.is_zero:
867                 coeffr.append(r)
868             elif r.is_zero:
869                 coeffi.append(i*S.ImaginaryUnit)
870             elif a.is_commutative:
871                 # search for complex conjugate pairs:
872                 for i, x in enumerate(other):
873                     if x == a.conjugate():
874                         coeffr.append(Abs(x)**2)
875                         del other[i]
876                         break
877                 else:
878                     if a.is_Add:
879                         addterms *= a
880                     else:
881                         other.append(a)
882             else:
883                 other.append(a)
884         m = self.func(*other)
885         if hints.get('ignore') == m:
886             return
887         if len(coeffi) % 2:
888             imco = im(coeffi.pop(0))
889             # all other pairs make a real factor; they will be
890             # put into reco below
891         else:
892             imco = S.Zero
893         reco = self.func(*(coeffr + coeffi))
894         r, i = (reco*re(m), reco*im(m))
895         if addterms == 1:
896             if m == 1:
897                 if imco.is_zero:
898                     return (reco, S.Zero)
899                 else:
900                     return (S.Zero, reco*imco)
901             if imco is S.Zero:
902                 return (r, i)
903             return (-imco*i, imco*r)
904         addre, addim = expand_mul(addterms, deep=False).as_real_imag()
905         if imco is S.Zero:
906             return (r*addre - i*addim, i*addre + r*addim)
907         else:
908             r, i = -imco*i, imco*r
909             return (r*addre - i*addim, r*addim + i*addre)
910 
911     @staticmethod
912     def _expandsums(sums):
913         """
914         Helper function for _eval_expand_mul.
915 
916         sums must be a list of instances of Basic.
917         """
918 
919         L = len(sums)
920         if L == 1:
921             return sums[0].args
922         terms = []
923         left = Mul._expandsums(sums[:L//2])
924         right = Mul._expandsums(sums[L//2:])
925 
926         terms = [Mul(a, b) for a in left for b in right]
927         added = Add(*terms)
928         return Add.make_args(added)  # it may have collapsed down to one term
929 
930     def _eval_expand_mul(self, **hints):
931         from sympy import fraction
932 
933         # Handle things like 1/(x*(x + 1)), which are automatically converted
934         # to 1/x*1/(x + 1)
935         expr = self
936         n, d = fraction(expr)
937         if d.is_Mul:
938             n, d = [i._eval_expand_mul(**hints) if i.is_Mul else i
939                 for i in (n, d)]
940         expr = n/d
941         if not expr.is_Mul:
942             return expr
943 
944         plain, sums, rewrite = [], [], False
945         for factor in expr.args:
946             if factor.is_Add:
947                 sums.append(factor)
948                 rewrite = True
949             else:
950                 if factor.is_commutative:
951                     plain.append(factor)
952                 else:
953                     sums.append(Basic(factor))  # Wrapper
954 
955         if not rewrite:
956             return expr
957         else:
958             plain = self.func(*plain)
959             if sums:
960                 deep = hints.get("deep", False)
961                 terms = self.func._expandsums(sums)
962                 args = []
963                 for term in terms:
964                     t = self.func(plain, term)
965                     if t.is_Mul and any(a.is_Add for a in t.args) and deep:
966                         t = t._eval_expand_mul()
967                     args.append(t)
968                 return Add(*args)
969             else:
970                 return plain
971 
972     @cacheit
973     def _eval_derivative(self, s):
974         args = list(self.args)
975         terms = []
976         for i in range(len(args)):
977             d = args[i].diff(s)
978             if d:
979                 # Note: reduce is used in step of Mul as Mul is unable to
980                 # handle subtypes and operation priority:
981                 terms.append(reduce(lambda x, y: x*y, (args[:i] + [d] + args[i + 1:]), S.One))
982         return Add.fromiter(terms)
983 
984     @cacheit
985     def _eval_derivative_n_times(self, s, n):
986         from sympy import Integer, factorial, prod, Sum, Max
987         from sympy.ntheory.multinomial import multinomial_coefficients_iterator
988         from .function import AppliedUndef
989         from .symbol import Symbol, symbols, Dummy
990         if not isinstance(s, AppliedUndef) and not isinstance(s, Symbol):
991             # other types of s may not be well behaved, e.g.
992             # (cos(x)*sin(y)).diff([[x, y, z]])
993             return super()._eval_derivative_n_times(s, n)
994         args = self.args
995         m = len(args)
996         if isinstance(n, (int, Integer)):
997             # https://en.wikipedia.org/wiki/General_Leibniz_rule#More_than_two_factors
998             terms = []
999             for kvals, c in multinomial_coefficients_iterator(m, n):
1000                 p = prod([arg.diff((s, k)) for k, arg in zip(kvals, args)])
1001                 terms.append(c * p)
1002             return Add(*terms)
1003         kvals = symbols("k1:%i" % m, cls=Dummy)
1004         klast = n - sum(kvals)
1005         nfact = factorial(n)
1006         e, l = (# better to use the multinomial?
1007             nfact/prod(map(factorial, kvals))/factorial(klast)*\
1008             prod([args[t].diff((s, kvals[t])) for t in range(m-1)])*\
1009             args[-1].diff((s, Max(0, klast))),
1010             [(k, 0, n) for k in kvals])
1011         return Sum(e, *l)
1012 
1013     def _eval_difference_delta(self, n, step):
1014         from sympy.series.limitseq import difference_delta as dd
1015         arg0 = self.args[0]
1016         rest = Mul(*self.args[1:])
1017         return (arg0.subs(n, n + step) * dd(rest, n, step) + dd(arg0, n, step) *
1018                 rest)
1019 
1020     def _matches_simple(self, expr, repl_dict):
1021         # handle (w*3).matches('x*5') -> {w: x*5/3}
1022         coeff, terms = self.as_coeff_Mul()
1023         terms = Mul.make_args(terms)
1024         if len(terms) == 1:
1025             newexpr = self.__class__._combine_inverse(expr, coeff)
1026             return terms[0].matches(newexpr, repl_dict)
1027         return
1028 
1029     def matches(self, expr, repl_dict={}, old=False):
1030         expr = sympify(expr)
1031         repl_dict = repl_dict.copy()
1032         if self.is_commutative and expr.is_commutative:
1033             return self._matches_commutative(expr, repl_dict, old)
1034         elif self.is_commutative is not expr.is_commutative:
1035             return None
1036 
1037         # Proceed only if both both expressions are non-commutative
1038         c1, nc1 = self.args_cnc()
1039         c2, nc2 = expr.args_cnc()
1040         c1, c2 = [c or [1] for c in [c1, c2]]
1041 
1042         # TODO: Should these be self.func?
1043         comm_mul_self = Mul(*c1)
1044         comm_mul_expr = Mul(*c2)
1045 
1046         repl_dict = comm_mul_self.matches(comm_mul_expr, repl_dict, old)
1047 
1048         # If the commutative arguments didn't match and aren't equal, then
1049         # then the expression as a whole doesn't match
1050         if repl_dict is None and c1 != c2:
1051             return None
1052 
1053         # Now match the non-commutative arguments, expanding powers to
1054         # multiplications
1055         nc1 = Mul._matches_expand_pows(nc1)
1056         nc2 = Mul._matches_expand_pows(nc2)
1057 
1058         repl_dict = Mul._matches_noncomm(nc1, nc2, repl_dict)
1059 
1060         return repl_dict or None
1061 
1062     @staticmethod
1063     def _matches_expand_pows(arg_list):
1064         new_args = []
1065         for arg in arg_list:
1066             if arg.is_Pow and arg.exp > 0:
1067                 new_args.extend([arg.base] * arg.exp)
1068             else:
1069                 new_args.append(arg)
1070         return new_args
1071 
1072     @staticmethod
1073     def _matches_noncomm(nodes, targets, repl_dict={}):
1074         """Non-commutative multiplication matcher.
1075 
1076         `nodes` is a list of symbols within the matcher multiplication
1077         expression, while `targets` is a list of arguments in the
1078         multiplication expression being matched against.
1079         """
1080         repl_dict = repl_dict.copy()
1081         # List of possible future states to be considered
1082         agenda = []
1083         # The current matching state, storing index in nodes and targets
1084         state = (0, 0)
1085         node_ind, target_ind = state
1086         # Mapping between wildcard indices and the index ranges they match
1087         wildcard_dict = {}
1088         repl_dict = repl_dict.copy()
1089 
1090         while target_ind < len(targets) and node_ind < len(nodes):
1091             node = nodes[node_ind]
1092 
1093             if node.is_Wild:
1094                 Mul._matches_add_wildcard(wildcard_dict, state)
1095 
1096             states_matches = Mul._matches_new_states(wildcard_dict, state,
1097                                                      nodes, targets)
1098             if states_matches:
1099                 new_states, new_matches = states_matches
1100                 agenda.extend(new_states)
1101                 if new_matches:
1102                     for match in new_matches:
1103                         repl_dict[match] = new_matches[match]
1104             if not agenda:
1105                 return None
1106             else:
1107                 state = agenda.pop()
1108                 node_ind, target_ind = state
1109 
1110         return repl_dict
1111 
1112     @staticmethod
1113     def _matches_add_wildcard(dictionary, state):
1114         node_ind, target_ind = state
1115         if node_ind in dictionary:
1116             begin, end = dictionary[node_ind]
1117             dictionary[node_ind] = (begin, target_ind)
1118         else:
1119             dictionary[node_ind] = (target_ind, target_ind)
1120 
1121     @staticmethod
1122     def _matches_new_states(dictionary, state, nodes, targets):
1123         node_ind, target_ind = state
1124         node = nodes[node_ind]
1125         target = targets[target_ind]
1126 
1127         # Don't advance at all if we've exhausted the targets but not the nodes
1128         if target_ind >= len(targets) - 1 and node_ind < len(nodes) - 1:
1129             return None
1130 
1131         if node.is_Wild:
1132             match_attempt = Mul._matches_match_wilds(dictionary, node_ind,
1133                                                      nodes, targets)
1134             if match_attempt:
1135                 # If the same node has been matched before, don't return
1136                 # anything if the current match is diverging from the previous
1137                 # match
1138                 other_node_inds = Mul._matches_get_other_nodes(dictionary,
1139                                                                nodes, node_ind)
1140                 for ind in other_node_inds:
1141                     other_begin, other_end = dictionary[ind]
1142                     curr_begin, curr_end = dictionary[node_ind]
1143 
1144                     other_targets = targets[other_begin:other_end + 1]
1145                     current_targets = targets[curr_begin:curr_end + 1]
1146 
1147                     for curr, other in zip(current_targets, other_targets):
1148                         if curr != other:
1149                             return None
1150 
1151                 # A wildcard node can match more than one target, so only the
1152                 # target index is advanced
1153                 new_state = [(node_ind, target_ind + 1)]
1154                 # Only move on to the next node if there is one
1155                 if node_ind < len(nodes) - 1:
1156                     new_state.append((node_ind + 1, target_ind + 1))
1157                 return new_state, match_attempt
1158         else:
1159             # If we're not at a wildcard, then make sure we haven't exhausted
1160             # nodes but not targets, since in this case one node can only match
1161             # one target
1162             if node_ind >= len(nodes) - 1 and target_ind < len(targets) - 1:
1163                 return None
1164 
1165             match_attempt = node.matches(target)
1166 
1167             if match_attempt:
1168                 return [(node_ind + 1, target_ind + 1)], match_attempt
1169             elif node == target:
1170                 return [(node_ind + 1, target_ind + 1)], None
1171             else:
1172                 return None
1173 
1174     @staticmethod
1175     def _matches_match_wilds(dictionary, wildcard_ind, nodes, targets):
1176         """Determine matches of a wildcard with sub-expression in `target`."""
1177         wildcard = nodes[wildcard_ind]
1178         begin, end = dictionary[wildcard_ind]
1179         terms = targets[begin:end + 1]
1180         # TODO: Should this be self.func?
1181         mul = Mul(*terms) if len(terms) > 1 else terms[0]
1182         return wildcard.matches(mul)
1183 
1184     @staticmethod
1185     def _matches_get_other_nodes(dictionary, nodes, node_ind):
1186         """Find other wildcards that may have already been matched."""
1187         other_node_inds = []
1188         for ind in dictionary:
1189             if nodes[ind] == nodes[node_ind]:
1190                 other_node_inds.append(ind)
1191         return other_node_inds
1192 
1193     @staticmethod
1194     def _combine_inverse(lhs, rhs):
1195         """
1196         Returns lhs/rhs, but treats arguments like symbols, so things
1197         like oo/oo return 1 (instead of a nan) and ``I`` behaves like
1198         a symbol instead of sqrt(-1).
1199         """
1200         from sympy.simplify.simplify import signsimp
1201         from .symbol import Dummy
1202         if lhs == rhs:
1203             return S.One
1204 
1205         def check(l, r):
1206             if l.is_Float and r.is_comparable:
1207                 # if both objects are added to 0 they will share the same "normalization"
1208                 # and are more likely to compare the same. Since Add(foo, 0) will not allow
1209                 # the 0 to pass, we use __add__ directly.
1210                 return l.__add__(0) == r.evalf().__add__(0)
1211             return False
1212         if check(lhs, rhs) or check(rhs, lhs):
1213             return S.One
1214         if any(i.is_Pow or i.is_Mul for i in (lhs, rhs)):
1215             # gruntz and limit wants a literal I to not combine
1216             # with a power of -1
1217             d = Dummy('I')
1218             _i = {S.ImaginaryUnit: d}
1219             i_ = {d: S.ImaginaryUnit}
1220             a = lhs.xreplace(_i).as_powers_dict()
1221             b = rhs.xreplace(_i).as_powers_dict()
1222             blen = len(b)
1223             for bi in tuple(b.keys()):
1224                 if bi in a:
1225                     a[bi] -= b.pop(bi)
1226                     if not a[bi]:
1227                         a.pop(bi)
1228             if len(b) != blen:
1229                 lhs = Mul(*[k**v for k, v in a.items()]).xreplace(i_)
1230                 rhs = Mul(*[k**v for k, v in b.items()]).xreplace(i_)
1231         return signsimp(lhs/rhs)
1232 
1233     def as_powers_dict(self):
1234         d = defaultdict(int)
1235         for term in self.args:
1236             for b, e in term.as_powers_dict().items():
1237                 d[b] += e
1238         return d
1239 
1240     def as_numer_denom(self):
1241         # don't use _from_args to rebuild the numerators and denominators
1242         # as the order is not guaranteed to be the same once they have
1243         # been separated from each other
1244         numers, denoms = list(zip(*[f.as_numer_denom() for f in self.args]))
1245         return self.func(*numers), self.func(*denoms)
1246 
1247     def as_base_exp(self):
1248         e1 = None
1249         bases = []
1250         nc = 0
1251         for m in self.args:
1252             b, e = m.as_base_exp()
1253             if not b.is_commutative:
1254                 nc += 1
1255             if e1 is None:
1256                 e1 = e
1257             elif e != e1 or nc > 1:
1258                 return self, S.One
1259             bases.append(b)
1260         return self.func(*bases), e1
1261 
1262     def _eval_is_polynomial(self, syms):
1263         return all(term._eval_is_polynomial(syms) for term in self.args)
1264 
1265     def _eval_is_rational_function(self, syms):
1266         return all(term._eval_is_rational_function(syms) for term in self.args)
1267 
1268     def _eval_is_meromorphic(self, x, a):
1269         return _fuzzy_group((arg.is_meromorphic(x, a) for arg in self.args),
1270                             quick_exit=True)
1271 
1272     def _eval_is_algebraic_expr(self, syms):
1273         return all(term._eval_is_algebraic_expr(syms) for term in self.args)
1274 
1275     _eval_is_commutative = lambda self: _fuzzy_group(
1276         a.is_commutative for a in self.args)
1277 
1278     def _eval_is_complex(self):
1279         comp = _fuzzy_group(a.is_complex for a in self.args)
1280         if comp is False:
1281             if any(a.is_infinite for a in self.args):
1282                 if any(a.is_zero is not False for a in self.args):
1283                     return None
1284                 return False
1285         return comp
1286 
1287     def _eval_is_finite(self):
1288         if all(a.is_finite for a in self.args):
1289             return True
1290         if any(a.is_infinite for a in self.args):
1291             if all(a.is_zero is False for a in self.args):
1292                 return False
1293 
1294     def _eval_is_infinite(self):
1295         if any(a.is_infinite for a in self.args):
1296             if any(a.is_zero for a in self.args):
1297                 return S.NaN.is_infinite
1298             if any(a.is_zero is None for a in self.args):
1299                 return None
1300             return True
1301 
1302     def _eval_is_rational(self):
1303         r = _fuzzy_group((a.is_rational for a in self.args), quick_exit=True)
1304         if r:
1305             return r
1306         elif r is False:
1307             return self.is_zero
1308 
1309     def _eval_is_algebraic(self):
1310         r = _fuzzy_group((a.is_algebraic for a in self.args), quick_exit=True)
1311         if r:
1312             return r
1313         elif r is False:
1314             return self.is_zero
1315 
1316     def _eval_is_zero(self):
1317         zero = infinite = False
1318         for a in self.args:
1319             z = a.is_zero
1320             if z:
1321                 if infinite:
1322                     return  # 0*oo is nan and nan.is_zero is None
1323                 zero = True
1324             else:
1325                 if not a.is_finite:
1326                     if zero:
1327                         return  # 0*oo is nan and nan.is_zero is None
1328                     infinite = True
1329                 if zero is False and z is None:  # trap None
1330                     zero = None
1331         return zero
1332 
1333     # without involving odd/even checks this code would suffice:
1334     #_eval_is_integer = lambda self: _fuzzy_group(
1335     #    (a.is_integer for a in self.args), quick_exit=True)
1336     def _eval_is_integer(self):
1337         is_rational = self._eval_is_rational()
1338         if is_rational is False:
1339             return False
1340 
1341         numerators = []
1342         denominators = []
1343         for a in self.args:
1344             if a.is_integer:
1345                 numerators.append(a)
1346             elif a.is_Rational:
1347                 n, d = a.as_numer_denom()
1348                 numerators.append(n)
1349                 denominators.append(d)
1350             elif a.is_Pow:
1351                 b, e = a.as_base_exp()
1352                 if not b.is_integer or not e.is_integer: return
1353                 if e.is_negative:
1354                     denominators.append(b)
1355                 else:
1356                     # for integer b and positive integer e: a = b**e would be integer
1357                     assert not e.is_positive
1358                     # for self being rational and e equal to zero: a = b**e would be 1
1359                     assert not e.is_zero
1360                     return # sign of e unknown -> self.is_integer cannot be decided
1361             else:
1362                 return
1363 
1364         if not denominators:
1365             return True
1366 
1367         odd = lambda ints: all(i.is_odd for i in ints)
1368         even = lambda ints: any(i.is_even for i in ints)
1369 
1370         if odd(numerators) and even(denominators):
1371             return False
1372         elif even(numerators) and denominators == [2]:
1373             return True
1374 
1375     def _eval_is_polar(self):
1376         has_polar = any(arg.is_polar for arg in self.args)
1377         return has_polar and \
1378             all(arg.is_polar or arg.is_positive for arg in self.args)
1379 
1380     def _eval_is_extended_real(self):
1381         return self._eval_real_imag(True)
1382 
1383     def _eval_real_imag(self, real):
1384         zero = False
1385         t_not_re_im = None
1386 
1387         for t in self.args:
1388             if (t.is_complex or t.is_infinite) is False and t.is_extended_real is False:
1389                 return False
1390             elif t.is_imaginary:  # I
1391                 real = not real
1392             elif t.is_extended_real:  # 2
1393                 if not zero:
1394                     z = t.is_zero
1395                     if not z and zero is False:
1396                         zero = z
1397                     elif z:
1398                         if all(a.is_finite for a in self.args):
1399                             return True
1400                         return
1401             elif t.is_extended_real is False:
1402                 # symbolic or literal like `2 + I` or symbolic imaginary
1403                 if t_not_re_im:
1404                     return  # complex terms might cancel
1405                 t_not_re_im = t
1406             elif t.is_imaginary is False:  # symbolic like `2` or `2 + I`
1407                 if t_not_re_im:
1408                     return  # complex terms might cancel
1409                 t_not_re_im = t
1410             else:
1411                 return
1412 
1413         if t_not_re_im:
1414             if t_not_re_im.is_extended_real is False:
1415                 if real:  # like 3
1416                     return zero  # 3*(smthng like 2 + I or i) is not real
1417             if t_not_re_im.is_imaginary is False:  # symbolic 2 or 2 + I
1418                 if not real:  # like I
1419                     return zero  # I*(smthng like 2 or 2 + I) is not real
1420         elif zero is False:
1421             return real  # can't be trumped by 0
1422         elif real:
1423             return real  # doesn't matter what zero is
1424 
1425     def _eval_is_imaginary(self):
1426         z = self.is_zero
1427         if z:
1428             return False
1429         if self.is_finite is False:
1430             return False
1431         elif z is False and self.is_finite is True:
1432             return self._eval_real_imag(False)
1433 
1434     def _eval_is_hermitian(self):
1435         return self._eval_herm_antiherm(True)
1436 
1437     def _eval_herm_antiherm(self, real):
1438         one_nc = zero = one_neither = False
1439 
1440         for t in self.args:
1441             if not t.is_commutative:
1442                 if one_nc:
1443                     return
1444                 one_nc = True
1445 
1446             if t.is_antihermitian:
1447                 real = not real
1448             elif t.is_hermitian:
1449                 if not zero:
1450                     z = t.is_zero
1451                     if not z and zero is False:
1452                         zero = z
1453                     elif z:
1454                         if all(a.is_finite for a in self.args):
1455                             return True
1456                         return
1457             elif t.is_hermitian is False:
1458                 if one_neither:
1459                     return
1460                 one_neither = True
1461             else:
1462                 return
1463 
1464         if one_neither:
1465             if real:
1466                 return zero
1467         elif zero is False or real:
1468             return real
1469 
1470     def _eval_is_antihermitian(self):
1471         z = self.is_zero
1472         if z:
1473             return False
1474         elif z is False:
1475             return self._eval_herm_antiherm(False)
1476 
1477     def _eval_is_irrational(self):
1478         for t in self.args:
1479             a = t.is_irrational
1480             if a:
1481                 others = list(self.args)
1482                 others.remove(t)
1483                 if all((x.is_rational and fuzzy_not(x.is_zero)) is True for x in others):
1484                     return True
1485                 return
1486             if a is None:
1487                 return
1488         if all(x.is_real for x in self.args):
1489             return False
1490 
1491     def _eval_is_extended_positive(self):
1492         """Return True if self is positive, False if not, and None if it
1493         cannot be determined.
1494 
1495         Explanation
1496         ===========
1497 
1498         This algorithm is non-recursive and works by keeping track of the
1499         sign which changes when a negative or nonpositive is encountered.
1500         Whether a nonpositive or nonnegative is seen is also tracked since
1501         the presence of these makes it impossible to return True, but
1502         possible to return False if the end result is nonpositive. e.g.
1503 
1504             pos * neg * nonpositive -> pos or zero -> None is returned
1505             pos * neg * nonnegative -> neg or zero -> False is returned
1506         """
1507         return self._eval_pos_neg(1)
1508 
1509     def _eval_pos_neg(self, sign):
1510         saw_NON = saw_NOT = False
1511         for t in self.args:
1512             if t.is_extended_positive:
1513                 continue
1514             elif t.is_extended_negative:
1515                 sign = -sign
1516             elif t.is_zero:
1517                 if all(a.is_finite for a in self.args):
1518                     return False
1519                 return
1520             elif t.is_extended_nonpositive:
1521                 sign = -sign
1522                 saw_NON = True
1523             elif t.is_extended_nonnegative:
1524                 saw_NON = True
1525             # FIXME: is_positive/is_negative is False doesn't take account of
1526             # Symbol('x', infinite=True, extended_real=True) which has
1527             # e.g. is_positive is False but has uncertain sign.
1528             elif t.is_positive is False:
1529                 sign = -sign
1530                 if saw_NOT:
1531                     return
1532                 saw_NOT = True
1533             elif t.is_negative is False:
1534                 if saw_NOT:
1535                     return
1536                 saw_NOT = True
1537             else:
1538                 return
1539         if sign == 1 and saw_NON is False and saw_NOT is False:
1540             return True
1541         if sign < 0:
1542             return False
1543 
1544     def _eval_is_extended_negative(self):
1545         return self._eval_pos_neg(-1)
1546 
1547     def _eval_is_odd(self):
1548         is_integer = self.is_integer
1549 
1550         if is_integer:
1551             r, acc = True, 1
1552             for t in self.args:
1553                 if not t.is_integer:
1554                     return None
1555                 elif t.is_even:
1556                     r = False
1557                 elif t.is_integer:
1558                     if r is False:
1559                         pass
1560                     elif acc != 1 and (acc + t).is_odd:
1561                         r = False
1562                     elif t.is_odd is None:
1563                         r = None
1564                 acc = t
1565             return r
1566 
1567         # !integer -> !odd
1568         elif is_integer is False:
1569             return False
1570 
1571     def _eval_is_even(self):
1572         is_integer = self.is_integer
1573 
1574         if is_integer:
1575             return fuzzy_not(self.is_odd)
1576 
1577         elif is_integer is False:
1578             return False
1579 
1580     def _eval_is_composite(self):
1581         """
1582         Here we count the number of arguments that have a minimum value
1583         greater than two.
1584         If there are more than one of such a symbol then the result is composite.
1585         Else, the result cannot be determined.
1586         """
1587         number_of_args = 0 # count of symbols with minimum value greater than one
1588         for arg in self.args:
1589             if not (arg.is_integer and arg.is_positive):
1590                 return None
1591             if (arg-1).is_positive:
1592                 number_of_args += 1
1593 
1594         if number_of_args > 1:
1595             return True
1596 
1597     def _eval_subs(self, old, new):
1598         from sympy.functions.elementary.complexes import sign
1599         from sympy.ntheory.factor_ import multiplicity
1600         from sympy.simplify.powsimp import powdenest
1601         from sympy.simplify.radsimp import fraction
1602 
1603         if not old.is_Mul:
1604             return None
1605 
1606         # try keep replacement literal so -2*x doesn't replace 4*x
1607         if old.args[0].is_Number and old.args[0] < 0:
1608             if self.args[0].is_Number:
1609                 if self.args[0] < 0:
1610                     return self._subs(-old, -new)
1611                 return None
1612 
1613         def base_exp(a):
1614             # if I and -1 are in a Mul, they get both end up with
1615             # a -1 base (see issue 6421); all we want here are the
1616             # true Pow or exp separated into base and exponent
1617             from sympy import exp
1618             if a.is_Pow or isinstance(a, exp):
1619                 return a.as_base_exp()
1620             return a, S.One
1621 
1622         def breakup(eq):
1623             """break up powers of eq when treated as a Mul:
1624                    b**(Rational*e) -> b**e, Rational
1625                 commutatives come back as a dictionary {b**e: Rational}
1626                 noncommutatives come back as a list [(b**e, Rational)]
1627             """
1628 
1629             (c, nc) = (defaultdict(int), list())
1630             for a in Mul.make_args(eq):
1631                 a = powdenest(a)
1632                 (b, e) = base_exp(a)
1633                 if e is not S.One:
1634                     (co, _) = e.as_coeff_mul()
1635                     b = Pow(b, e/co)
1636                     e = co
1637                 if a.is_commutative:
1638                     c[b] += e
1639                 else:
1640                     nc.append([b, e])
1641             return (c, nc)
1642 
1643         def rejoin(b, co):
1644             """
1645             Put rational back with exponent; in general this is not ok, but
1646             since we took it from the exponent for analysis, it's ok to put
1647             it back.
1648             """
1649 
1650             (b, e) = base_exp(b)
1651             return Pow(b, e*co)
1652 
1653         def ndiv(a, b):
1654             """if b divides a in an extractive way (like 1/4 divides 1/2
1655             but not vice versa, and 2/5 does not divide 1/3) then return
1656             the integer number of times it divides, else return 0.
1657             """
1658             if not b.q % a.q or not a.q % b.q:
1659                 return int(a/b)
1660             return 0
1661 
1662         # give Muls in the denominator a chance to be changed (see issue 5651)
1663         # rv will be the default return value
1664         rv = None
1665         n, d = fraction(self)
1666         self2 = self
1667         if d is not S.One:
1668             self2 = n._subs(old, new)/d._subs(old, new)
1669             if not self2.is_Mul:
1670                 return self2._subs(old, new)
1671             if self2 != self:
1672                 rv = self2
1673 
1674         # Now continue with regular substitution.
1675 
1676         # handle the leading coefficient and use it to decide if anything
1677         # should even be started; we always know where to find the Rational
1678         # so it's a quick test
1679 
1680         co_self = self2.args[0]
1681         co_old = old.args[0]
1682         co_xmul = None
1683         if co_old.is_Rational and co_self.is_Rational:
1684             # if coeffs are the same there will be no updating to do
1685             # below after breakup() step; so skip (and keep co_xmul=None)
1686             if co_old != co_self:
1687                 co_xmul = co_self.extract_multiplicatively(co_old)
1688         elif co_old.is_Rational:
1689             return rv
1690 
1691         # break self and old into factors
1692 
1693         (c, nc) = breakup(self2)
1694         (old_c, old_nc) = breakup(old)
1695 
1696         # update the coefficients if we had an extraction
1697         # e.g. if co_self were 2*(3/35*x)**2 and co_old = 3/5
1698         # then co_self in c is replaced by (3/5)**2 and co_residual
1699         # is 2*(1/7)**2
1700 
1701         if co_xmul and co_xmul.is_Rational and abs(co_old) != 1:
1702             mult = S(multiplicity(abs(co_old), co_self))
1703             c.pop(co_self)
1704             if co_old in c:
1705                 c[co_old] += mult
1706             else:
1707                 c[co_old] = mult
1708             co_residual = co_self/co_old**mult
1709         else:
1710             co_residual = 1
1711 
1712         # do quick tests to see if we can't succeed
1713 
1714         ok = True
1715         if len(old_nc) > len(nc):
1716             # more non-commutative terms
1717             ok = False
1718         elif len(old_c) > len(c):
1719             # more commutative terms
1720             ok = False
1721         elif {i[0] for i in old_nc}.difference({i[0] for i in nc}):
1722             # unmatched non-commutative bases
1723             ok = False
1724         elif set(old_c).difference(set(c)):
1725             # unmatched commutative terms
1726             ok = False
1727         elif any(sign(c[b]) != sign(old_c[b]) for b in old_c):
1728             # differences in sign
1729             ok = False
1730         if not ok:
1731             return rv
1732 
1733         if not old_c:
1734             cdid = None
1735         else:
1736             rat = []
1737             for (b, old_e) in old_c.items():
1738                 c_e = c[b]
1739                 rat.append(ndiv(c_e, old_e))
1740                 if not rat[-1]:
1741                     return rv
1742             cdid = min(rat)
1743 
1744         if not old_nc:
1745             ncdid = None
1746             for i in range(len(nc)):
1747                 nc[i] = rejoin(*nc[i])
1748         else:
1749             ncdid = 0  # number of nc replacements we did
1750             take = len(old_nc)  # how much to look at each time
1751             limit = cdid or S.Infinity  # max number that we can take
1752             failed = []  # failed terms will need subs if other terms pass
1753             i = 0
1754             while limit and i + take <= len(nc):
1755                 hit = False
1756 
1757                 # the bases must be equivalent in succession, and
1758                 # the powers must be extractively compatible on the
1759                 # first and last factor but equal in between.
1760 
1761                 rat = []
1762                 for j in range(take):
1763                     if nc[i + j][0] != old_nc[j][0]:
1764                         break
1765                     elif j == 0:
1766                         rat.append(ndiv(nc[i + j][1], old_nc[j][1]))
1767                     elif j == take - 1:
1768                         rat.append(ndiv(nc[i + j][1], old_nc[j][1]))
1769                     elif nc[i + j][1] != old_nc[j][1]:
1770                         break
1771                     else:
1772                         rat.append(1)
1773                     j += 1
1774                 else:
1775                     ndo = min(rat)
1776                     if ndo:
1777                         if take == 1:
1778                             if cdid:
1779                                 ndo = min(cdid, ndo)
1780                             nc[i] = Pow(new, ndo)*rejoin(nc[i][0],
1781                                     nc[i][1] - ndo*old_nc[0][1])
1782                         else:
1783                             ndo = 1
1784 
1785                             # the left residual
1786 
1787                             l = rejoin(nc[i][0], nc[i][1] - ndo*
1788                                     old_nc[0][1])
1789 
1790                             # eliminate all middle terms
1791 
1792                             mid = new
1793 
1794                             # the right residual (which may be the same as the middle if take == 2)
1795 
1796                             ir = i + take - 1
1797                             r = (nc[ir][0], nc[ir][1] - ndo*
1798                                  old_nc[-1][1])
1799                             if r[1]:
1800                                 if i + take < len(nc):
1801                                     nc[i:i + take] = [l*mid, r]
1802                                 else:
1803                                     r = rejoin(*r)
1804                                     nc[i:i + take] = [l*mid*r]
1805                             else:
1806 
1807                                 # there was nothing left on the right
1808 
1809                                 nc[i:i + take] = [l*mid]
1810 
1811                         limit -= ndo
1812                         ncdid += ndo
1813                         hit = True
1814                 if not hit:
1815 
1816                     # do the subs on this failing factor
1817 
1818                     failed.append(i)
1819                 i += 1
1820             else:
1821 
1822                 if not ncdid:
1823                     return rv
1824 
1825                 # although we didn't fail, certain nc terms may have
1826                 # failed so we rebuild them after attempting a partial
1827                 # subs on them
1828 
1829                 failed.extend(range(i, len(nc)))
1830                 for i in failed:
1831                     nc[i] = rejoin(*nc[i]).subs(old, new)
1832 
1833         # rebuild the expression
1834 
1835         if cdid is None:
1836             do = ncdid
1837         elif ncdid is None:
1838             do = cdid
1839         else:
1840             do = min(ncdid, cdid)
1841 
1842         margs = []
1843         for b in c:
1844             if b in old_c:
1845 
1846                 # calculate the new exponent
1847 
1848                 e = c[b] - old_c[b]*do
1849                 margs.append(rejoin(b, e))
1850             else:
1851                 margs.append(rejoin(b.subs(old, new), c[b]))
1852         if cdid and not ncdid:
1853 
1854             # in case we are replacing commutative with non-commutative,
1855             # we want the new term to come at the front just like the
1856             # rest of this routine
1857 
1858             margs = [Pow(new, cdid)] + margs
1859         return co_residual*self2.func(*margs)*self2.func(*nc)
1860 
1861     def _eval_nseries(self, x, n, logx, cdir=0):
1862         from sympy import degree, Mul, Order, ceiling, powsimp, PolynomialError
1863         from itertools import product
1864 
1865         def coeff_exp(term, x):
1866             coeff, exp = S.One, S.Zero
1867             for factor in Mul.make_args(term):
1868                 if factor.has(x):
1869                     base, exp = factor.as_base_exp()
1870                     if base != x:
1871                         try:
1872                             return term.leadterm(x)
1873                         except ValueError:
1874                             return term, S.Zero
1875                 else:
1876                     coeff *= factor
1877             return coeff, exp
1878 
1879         ords = []
1880 
1881         try:
1882             for t in self.args:
1883                 coeff, exp = t.leadterm(x)
1884                 if not coeff.has(x):
1885                     ords.append((t, exp))
1886                 else:
1887                     raise ValueError
1888 
1889             n0 = sum(t[1] for t in ords)
1890             facs = []
1891             for t, m in ords:
1892                 n1 = ceiling(n - n0 + m)
1893                 s = t.nseries(x, n=n1, logx=logx, cdir=cdir)
1894                 ns = s.getn()
1895                 if ns is not None:
1896                     if ns < n1:  # less than expected
1897                         n -= n1 - ns    # reduce n
1898                 facs.append(s.removeO())
1899 
1900         except (ValueError, NotImplementedError, TypeError, AttributeError):
1901             facs = [t.nseries(x, n=n, logx=logx, cdir=cdir) for t in self.args]
1902             res = powsimp(self.func(*facs).expand(), combine='exp', deep=True)
1903             if res.has(Order):
1904                 res += Order(x**n, x)
1905             return res
1906 
1907         res = 0
1908         ords2 = [Add.make_args(factor) for factor in facs]
1909 
1910         for fac in product(*ords2):
1911             ords3 = [coeff_exp(term, x) for term in fac]
1912             coeffs, powers = zip(*ords3)
1913             power = sum(powers)
1914             if power < n:
1915                 res += Mul(*coeffs)*(x**power)
1916 
1917         if self.is_polynomial(x):
1918             try:
1919                 if degree(self, x) != degree(res, x):
1920                     res += Order(x**n, x)
1921             except PolynomialError:
1922                 pass
1923             else:
1924                 return res
1925 
1926         for i in (1, 2, 3):
1927             if (res - self).subs(x, i) is not S.Zero:
1928                 res += Order(x**n, x)
1929                 break
1930         return res
1931 
1932     def _eval_as_leading_term(self, x, cdir=0):
1933         return self.func(*[t.as_leading_term(x, cdir=cdir) for t in self.args])
1934 
1935     def _eval_conjugate(self):
1936         return self.func(*[t.conjugate() for t in self.args])
1937 
1938     def _eval_transpose(self):
1939         return self.func(*[t.transpose() for t in self.args[::-1]])
1940 
1941     def _eval_adjoint(self):
1942         return self.func(*[t.adjoint() for t in self.args[::-1]])
1943 
1944     def _sage_(self):
1945         s = 1
1946         for x in self.args:
1947             s *= x._sage_()
1948         return s
1949 
1950     def as_content_primitive(self, radical=False, clear=True):
1951         """Return the tuple (R, self/R) where R is the positive Rational
1952         extracted from self.
1953 
1954         Examples
1955         ========
1956 
1957         >>> from sympy import sqrt
1958         >>> (-3*sqrt(2)*(2 - 2*sqrt(2))).as_content_primitive()
1959         (6, -sqrt(2)*(1 - sqrt(2)))
1960 
1961         See docstring of Expr.as_content_primitive for more examples.
1962         """
1963 
1964         coef = S.One
1965         args = []
1966         for i, a in enumerate(self.args):
1967             c, p = a.as_content_primitive(radical=radical, clear=clear)
1968             coef *= c
1969             if p is not S.One:
1970                 args.append(p)
1971         # don't use self._from_args here to reconstruct args
1972         # since there may be identical args now that should be combined
1973         # e.g. (2+2*x)*(3+3*x) should be (6, (1 + x)**2) not (6, (1+x)*(1+x))
1974         return coef, self.func(*args)
1975 
1976     def as_ordered_factors(self, order=None):
1977         """Transform an expression into an ordered list of factors.
1978 
1979         Examples
1980         ========
1981 
1982         >>> from sympy import sin, cos
1983         >>> from sympy.abc import x, y
1984 
1985         >>> (2*x*y*sin(x)*cos(x)).as_ordered_factors()
1986         [2, x, y, sin(x), cos(x)]
1987 
1988         """
1989         cpart, ncpart = self.args_cnc()
1990         cpart.sort(key=lambda expr: expr.sort_key(order=order))
1991         return cpart + ncpart
1992 
1993     @property
1994     def _sorted_args(self):
1995         return tuple(self.as_ordered_factors())

</code><intended_behavior>While the primary issue seems related to the LaTeX printing functionality, ensuring that the `Mul` class correctly represents the unevaluated multiplication in a manner consistent with LaTeX printing requirements may also be necessary. If `Mul`â€™s internal representation or methods that contribute to printing, such as `_latex` (if present) or related utilities, do not appropriately flag or structure unevaluated expressions, these should be adjusted. The adjustment should allow for clear differentiation between evaluated and unevaluated states in a way that the LaTeX printer can accurately render them. This may involve enriching the `Mul` object with metadata concerning its evaluated state or providing helper methods that the LaTeX printer can utilize to decide formatting.</intended_behavior>]
2025-10-18 09:17:00.855 | INFO     | Search completed. Bug locations: [<file>sympy/printing/latex.py</file>
<class>None</class>
<method>latex</method>
<code>
2746 def latex(expr, **settings):
2747     r"""Convert the given expression to LaTeX string representation.
2748 
2749     Parameters
2750     ==========
2751     full_prec: boolean, optional
2752         If set to True, a floating point number is printed with full precision.
2753     fold_frac_powers : boolean, optional
2754         Emit ``^{p/q}`` instead of ``^{\frac{p}{q}}`` for fractional powers.
2755     fold_func_brackets : boolean, optional
2756         Fold function brackets where applicable.
2757     fold_short_frac : boolean, optional
2758         Emit ``p / q`` instead of ``\frac{p}{q}`` when the denominator is
2759         simple enough (at most two terms and no powers). The default value is
2760         ``True`` for inline mode, ``False`` otherwise.
2761     inv_trig_style : string, optional
2762         How inverse trig functions should be displayed. Can be one of
2763         ``abbreviated``, ``full``, or ``power``. Defaults to ``abbreviated``.
2764     itex : boolean, optional
2765         Specifies if itex-specific syntax is used, including emitting
2766         ``$$...$$``.
2767     ln_notation : boolean, optional
2768         If set to ``True``, ``\ln`` is used instead of default ``\log``.
2769     long_frac_ratio : float or None, optional
2770         The allowed ratio of the width of the numerator to the width of the
2771         denominator before the printer breaks off long fractions. If ``None``
2772         (the default value), long fractions are not broken up.
2773     mat_delim : string, optional
2774         The delimiter to wrap around matrices. Can be one of ``[``, ``(``, or
2775         the empty string. Defaults to ``[``.
2776     mat_str : string, optional
2777         Which matrix environment string to emit. ``smallmatrix``, ``matrix``,
2778         ``array``, etc. Defaults to ``smallmatrix`` for inline mode, ``matrix``
2779         for matrices of no more than 10 columns, and ``array`` otherwise.
2780     mode: string, optional
2781         Specifies how the generated code will be delimited. ``mode`` can be one
2782         of ``plain``, ``inline``, ``equation`` or ``equation*``.  If ``mode``
2783         is set to ``plain``, then the resulting code will not be delimited at
2784         all (this is the default). If ``mode`` is set to ``inline`` then inline
2785         LaTeX ``$...$`` will be used. If ``mode`` is set to ``equation`` or
2786         ``equation*``, the resulting code will be enclosed in the ``equation``
2787         or ``equation*`` environment (remember to import ``amsmath`` for
2788         ``equation*``), unless the ``itex`` option is set. In the latter case,
2789         the ``$$...$$`` syntax is used.
2790     mul_symbol : string or None, optional
2791         The symbol to use for multiplication. Can be one of ``None``, ``ldot``,
2792         ``dot``, or ``times``.
2793     order: string, optional
2794         Any of the supported monomial orderings (currently ``lex``, ``grlex``,
2795         or ``grevlex``), ``old``, and ``none``. This parameter does nothing for
2796         Mul objects. Setting order to ``old`` uses the compatibility ordering
2797         for Add defined in Printer. For very large expressions, set the
2798         ``order`` keyword to ``none`` if speed is a concern.
2799     symbol_names : dictionary of strings mapped to symbols, optional
2800         Dictionary of symbols and the custom strings they should be emitted as.
2801     root_notation : boolean, optional
2802         If set to ``False``, exponents of the form 1/n are printed in fractonal
2803         form. Default is ``True``, to print exponent in root form.
2804     mat_symbol_style : string, optional
2805         Can be either ``plain`` (default) or ``bold``. If set to ``bold``,
2806         a MatrixSymbol A will be printed as ``\mathbf{A}``, otherwise as ``A``.
2807     imaginary_unit : string, optional
2808         String to use for the imaginary unit. Defined options are "i" (default)
2809         and "j". Adding "r" or "t" in front gives ``\mathrm`` or ``\text``, so
2810         "ri" leads to ``\mathrm{i}`` which gives `\mathrm{i}`.
2811     gothic_re_im : boolean, optional
2812         If set to ``True``, `\Re` and `\Im` is used for ``re`` and ``im``, respectively.
2813         The default is ``False`` leading to `\operatorname{re}` and `\operatorname{im}`.
2814     decimal_separator : string, optional
2815         Specifies what separator to use to separate the whole and fractional parts of a
2816         floating point number as in `2.5` for the default, ``period`` or `2{,}5`
2817         when ``comma`` is specified. Lists, sets, and tuple are printed with semicolon
2818         separating the elements when ``comma`` is chosen. For example, [1; 2; 3] when
2819         ``comma`` is chosen and [1,2,3] for when ``period`` is chosen.
2820     parenthesize_super : boolean, optional
2821         If set to ``False``, superscripted expressions will not be parenthesized when
2822         powered. Default is ``True``, which parenthesizes the expression when powered.
2823     min: Integer or None, optional
2824         Sets the lower bound for the exponent to print floating point numbers in
2825         fixed-point format.
2826     max: Integer or None, optional
2827         Sets the upper bound for the exponent to print floating point numbers in
2828         fixed-point format.
2829 
2830     Notes
2831     =====
2832 
2833     Not using a print statement for printing, results in double backslashes for
2834     latex commands since that's the way Python escapes backslashes in strings.
2835 
2836     >>> from sympy import latex, Rational
2837     >>> from sympy.abc import tau
2838     >>> latex((2*tau)**Rational(7,2))
2839     '8 \\sqrt{2} \\tau^{\\frac{7}{2}}'
2840     >>> print(latex((2*tau)**Rational(7,2)))
2841     8 \sqrt{2} \tau^{\frac{7}{2}}
2842 
2843     Examples
2844     ========
2845 
2846     >>> from sympy import latex, pi, sin, asin, Integral, Matrix, Rational, log
2847     >>> from sympy.abc import x, y, mu, r, tau
2848 
2849     Basic usage:
2850 
2851     >>> print(latex((2*tau)**Rational(7,2)))
2852     8 \sqrt{2} \tau^{\frac{7}{2}}
2853 
2854     ``mode`` and ``itex`` options:
2855 
2856     >>> print(latex((2*mu)**Rational(7,2), mode='plain'))
2857     8 \sqrt{2} \mu^{\frac{7}{2}}
2858     >>> print(latex((2*tau)**Rational(7,2), mode='inline'))
2859     $8 \sqrt{2} \tau^{7 / 2}$
2860     >>> print(latex((2*mu)**Rational(7,2), mode='equation*'))
2861     \begin{equation*}8 \sqrt{2} \mu^{\frac{7}{2}}\end{equation*}
2862     >>> print(latex((2*mu)**Rational(7,2), mode='equation'))
2863     \begin{equation}8 \sqrt{2} \mu^{\frac{7}{2}}\end{equation}
2864     >>> print(latex((2*mu)**Rational(7,2), mode='equation', itex=True))
2865     $$8 \sqrt{2} \mu^{\frac{7}{2}}$$
2866     >>> print(latex((2*mu)**Rational(7,2), mode='plain'))
2867     8 \sqrt{2} \mu^{\frac{7}{2}}
2868     >>> print(latex((2*tau)**Rational(7,2), mode='inline'))
2869     $8 \sqrt{2} \tau^{7 / 2}$
2870     >>> print(latex((2*mu)**Rational(7,2), mode='equation*'))
2871     \begin{equation*}8 \sqrt{2} \mu^{\frac{7}{2}}\end{equation*}
2872     >>> print(latex((2*mu)**Rational(7,2), mode='equation'))
2873     \begin{equation}8 \sqrt{2} \mu^{\frac{7}{2}}\end{equation}
2874     >>> print(latex((2*mu)**Rational(7,2), mode='equation', itex=True))
2875     $$8 \sqrt{2} \mu^{\frac{7}{2}}$$
2876 
2877     Fraction options:
2878 
2879     >>> print(latex((2*tau)**Rational(7,2), fold_frac_powers=True))
2880     8 \sqrt{2} \tau^{7/2}
2881     >>> print(latex((2*tau)**sin(Rational(7,2))))
2882     \left(2 \tau\right)^{\sin{\left(\frac{7}{2} \right)}}
2883     >>> print(latex((2*tau)**sin(Rational(7,2)), fold_func_brackets=True))
2884     \left(2 \tau\right)^{\sin {\frac{7}{2}}}
2885     >>> print(latex(3*x**2/y))
2886     \frac{3 x^{2}}{y}
2887     >>> print(latex(3*x**2/y, fold_short_frac=True))
2888     3 x^{2} / y
2889     >>> print(latex(Integral(r, r)/2/pi, long_frac_ratio=2))
2890     \frac{\int r\, dr}{2 \pi}
2891     >>> print(latex(Integral(r, r)/2/pi, long_frac_ratio=0))
2892     \frac{1}{2 \pi} \int r\, dr
2893 
2894     Multiplication options:
2895 
2896     >>> print(latex((2*tau)**sin(Rational(7,2)), mul_symbol="times"))
2897     \left(2 \times \tau\right)^{\sin{\left(\frac{7}{2} \right)}}
2898 
2899     Trig options:
2900 
2901     >>> print(latex(asin(Rational(7,2))))
2902     \operatorname{asin}{\left(\frac{7}{2} \right)}
2903     >>> print(latex(asin(Rational(7,2)), inv_trig_style="full"))
2904     \arcsin{\left(\frac{7}{2} \right)}
2905     >>> print(latex(asin(Rational(7,2)), inv_trig_style="power"))
2906     \sin^{-1}{\left(\frac{7}{2} \right)}
2907 
2908     Matrix options:
2909 
2910     >>> print(latex(Matrix(2, 1, [x, y])))
2911     \left[\begin{matrix}x\\y\end{matrix}\right]
2912     >>> print(latex(Matrix(2, 1, [x, y]), mat_str = "array"))
2913     \left[\begin{array}{c}x\\y\end{array}\right]
2914     >>> print(latex(Matrix(2, 1, [x, y]), mat_delim="("))
2915     \left(\begin{matrix}x\\y\end{matrix}\right)
2916 
2917     Custom printing of symbols:
2918 
2919     >>> print(latex(x**2, symbol_names={x: 'x_i'}))
2920     x_i^{2}
2921 
2922     Logarithms:
2923 
2924     >>> print(latex(log(10)))
2925     \log{\left(10 \right)}
2926     >>> print(latex(log(10), ln_notation=True))
2927     \ln{\left(10 \right)}
2928 
2929     ``latex()`` also supports the builtin container types :class:`list`,
2930     :class:`tuple`, and :class:`dict`:
2931 
2932     >>> print(latex([2/x, y], mode='inline'))
2933     $\left[ 2 / x, \  y\right]$
2934 
2935     Unsupported types are rendered as monospaced plaintext:
2936 
2937     >>> print(latex(int))
2938     \mathtt{\text{<class 'int'>}}
2939     >>> print(latex("plain % text"))
2940     \mathtt{\text{plain \% text}}
2941 
2942     See :ref:`printer_method_example` for an example of how to override
2943     this behavior for your own types by implementing ``_latex``.
2944 
2945     .. versionchanged:: 1.7.0
2946         Unsupported types no longer have their ``str`` representation treated as valid latex.
2947 
2948     """
2949     return LatexPrinter(settings).doprint(expr)

</code><intended_behavior>The `latex` method should include additional handling for `Mul` expressions where `evaluate=False`. Specifically, it needs to ensure that when converting these expressions to LaTeX, appropriate spacing or multiplication symbols are inserted between terms to reflect the mathematical intention accurately. This modification must preserve all other functionality, such as formatting options and handling of other expression types. The update should not disrupt the custom formatting settings provided by the user and should only augment the handling of unevaluated `Mul` expressions to produce correct LaTeX output.</intended_behavior>, <file>sympy/core/mul.py</file>
<class>Mul</class>
<method>None</method>
<code>
88 class Mul(Expr, AssocOp):
89     """
90     Expression representing multiplication operation for algebraic field.
91 
92     Every argument of ``Mul()`` must be ``Expr``. Infix operator ``*``
93     on most scalar objects in SymPy calls this class.
94 
95     Another use of ``Mul()`` is to represent the structure of abstract
96     multiplication so that its arguments can be substituted to return
97     different class. Refer to examples section for this.
98 
99     ``Mul()`` evaluates the argument unless ``evaluate=False`` is passed.
100     The evaluation logic includes:
101 
102     1. Flattening
103         ``Mul(x, Mul(y, z))`` -> ``Mul(x, y, z)``
104 
105     2. Identity removing
106         ``Mul(x, 1, y)`` -> ``Mul(x, y)``
107 
108     3. Exponent collecting by ``.as_base_exp()``
109         ``Mul(x, x**2)`` -> ``Pow(x, 3)``
110 
111     4. Term sorting
112         ``Mul(y, x, 2)`` -> ``Mul(2, x, y)``
113 
114     Since multiplication can be vector space operation, arguments may
115     have the different :obj:`sympy.core.kind.Kind()`. Kind of the
116     resulting object is automatically inferred.
117 
118     Examples
119     ========
120 
121     >>> from sympy import Mul
122     >>> from sympy.abc import x, y
123     >>> Mul(x, 1)
124     x
125     >>> Mul(x, x)
126     x**2
127 
128     If ``evaluate=False`` is passed, result is not evaluated.
129 
130     >>> Mul(1, 2, evaluate=False)
131     1*2
132     >>> Mul(x, x, evaluate=False)
133     x*x
134 
135     ``Mul()`` also represents the general structure of multiplication
136     operation.
137 
138     >>> from sympy import MatrixSymbol
139     >>> A = MatrixSymbol('A', 2,2)
140     >>> expr = Mul(x,y).subs({y:A})
141     >>> expr
142     x*A
143     >>> type(expr)
144     <class 'sympy.matrices.expressions.matmul.MatMul'>
145 
146     See Also
147     ========
148 
149     MatMul
150 
151     """
152     __slots__ = ()
153 
154     is_Mul = True
155 
156     _args_type = Expr
157     _kind_dispatcher = KindDispatcher("Mul_kind_dispatcher", commutative=True)
158 
159     @property
160     def kind(self):
161         arg_kinds = (a.kind for a in self.args)
162         return self._kind_dispatcher(*arg_kinds)
163 
164     def __neg__(self):
165         c, args = self.as_coeff_mul()
166         c = -c
167         if c is not S.One:
168             if args[0].is_Number:
169                 args = list(args)
170                 if c is S.NegativeOne:
171                     args[0] = -args[0]
172                 else:
173                     args[0] *= c
174             else:
175                 args = (c,) + args
176         return self._from_args(args, self.is_commutative)
177 
178     @classmethod
179     def flatten(cls, seq):
180         """Return commutative, noncommutative and order arguments by
181         combining related terms.
182 
183         Notes
184         =====
185             * In an expression like ``a*b*c``, python process this through sympy
186               as ``Mul(Mul(a, b), c)``. This can have undesirable consequences.
187 
188               -  Sometimes terms are not combined as one would like:
189                  {c.f. https://github.com/sympy/sympy/issues/4596}
190 
191                 >>> from sympy import Mul, sqrt
192                 >>> from sympy.abc import x, y, z
193                 >>> 2*(x + 1) # this is the 2-arg Mul behavior
194                 2*x + 2
195                 >>> y*(x + 1)*2
196                 2*y*(x + 1)
197                 >>> 2*(x + 1)*y # 2-arg result will be obtained first
198                 y*(2*x + 2)
199                 >>> Mul(2, x + 1, y) # all 3 args simultaneously processed
200                 2*y*(x + 1)
201                 >>> 2*((x + 1)*y) # parentheses can control this behavior
202                 2*y*(x + 1)
203 
204                 Powers with compound bases may not find a single base to
205                 combine with unless all arguments are processed at once.
206                 Post-processing may be necessary in such cases.
207                 {c.f. https://github.com/sympy/sympy/issues/5728}
208 
209                 >>> a = sqrt(x*sqrt(y))
210                 >>> a**3
211                 (x*sqrt(y))**(3/2)
212                 >>> Mul(a,a,a)
213                 (x*sqrt(y))**(3/2)
214                 >>> a*a*a
215                 x*sqrt(y)*sqrt(x*sqrt(y))
216                 >>> _.subs(a.base, z).subs(z, a.base)
217                 (x*sqrt(y))**(3/2)
218 
219               -  If more than two terms are being multiplied then all the
220                  previous terms will be re-processed for each new argument.
221                  So if each of ``a``, ``b`` and ``c`` were :class:`Mul`
222                  expression, then ``a*b*c`` (or building up the product
223                  with ``*=``) will process all the arguments of ``a`` and
224                  ``b`` twice: once when ``a*b`` is computed and again when
225                  ``c`` is multiplied.
226 
227                  Using ``Mul(a, b, c)`` will process all arguments once.
228 
229             * The results of Mul are cached according to arguments, so flatten
230               will only be called once for ``Mul(a, b, c)``. If you can
231               structure a calculation so the arguments are most likely to be
232               repeats then this can save time in computing the answer. For
233               example, say you had a Mul, M, that you wished to divide by ``d[i]``
234               and multiply by ``n[i]`` and you suspect there are many repeats
235               in ``n``. It would be better to compute ``M*n[i]/d[i]`` rather
236               than ``M/d[i]*n[i]`` since every time n[i] is a repeat, the
237               product, ``M*n[i]`` will be returned without flattening -- the
238               cached value will be returned. If you divide by the ``d[i]``
239               first (and those are more unique than the ``n[i]``) then that will
240               create a new Mul, ``M/d[i]`` the args of which will be traversed
241               again when it is multiplied by ``n[i]``.
242 
243               {c.f. https://github.com/sympy/sympy/issues/5706}
244 
245               This consideration is moot if the cache is turned off.
246 
247             NB
248             --
249               The validity of the above notes depends on the implementation
250               details of Mul and flatten which may change at any time. Therefore,
251               you should only consider them when your code is highly performance
252               sensitive.
253 
254               Removal of 1 from the sequence is already handled by AssocOp.__new__.
255         """
256 
257         from sympy.calculus.util import AccumBounds
258         from sympy.matrices.expressions import MatrixExpr
259         rv = None
260         if len(seq) == 2:
261             a, b = seq
262             if b.is_Rational:
263                 a, b = b, a
264                 seq = [a, b]
265             assert not a is S.One
266             if not a.is_zero and a.is_Rational:
267                 r, b = b.as_coeff_Mul()
268                 if b.is_Add:
269                     if r is not S.One:  # 2-arg hack
270                         # leave the Mul as a Mul?
271                         ar = a*r
272                         if ar is S.One:
273                             arb = b
274                         else:
275                             arb = cls(a*r, b, evaluate=False)
276                         rv = [arb], [], None
277                     elif global_parameters.distribute and b.is_commutative:
278                         r, b = b.as_coeff_Add()
279                         bargs = [_keep_coeff(a, bi) for bi in Add.make_args(b)]
280                         _addsort(bargs)
281                         ar = a*r
282                         if ar:
283                             bargs.insert(0, ar)
284                         bargs = [Add._from_args(bargs)]
285                         rv = bargs, [], None
286             if rv:
287                 return rv
288 
289         # apply associativity, separate commutative part of seq
290         c_part = []         # out: commutative factors
291         nc_part = []        # out: non-commutative factors
292 
293         nc_seq = []
294 
295         coeff = S.One       # standalone term
296                             # e.g. 3 * ...
297 
298         c_powers = []       # (base,exp)      n
299                             # e.g. (x,n) for x
300 
301         num_exp = []        # (num-base, exp)           y
302                             # e.g.  (3, y)  for  ... * 3  * ...
303 
304         neg1e = S.Zero      # exponent on -1 extracted from Number-based Pow and I
305 
306         pnum_rat = {}       # (num-base, Rat-exp)          1/2
307                             # e.g.  (3, 1/2)  for  ... * 3     * ...
308 
309         order_symbols = None
310 
311         # --- PART 1 ---
312         #
313         # "collect powers and coeff":
314         #
315         # o coeff
316         # o c_powers
317         # o num_exp
318         # o neg1e
319         # o pnum_rat
320         #
321         # NOTE: this is optimized for all-objects-are-commutative case
322         for o in seq:
323             # O(x)
324             if o.is_Order:
325                 o, order_symbols = o.as_expr_variables(order_symbols)
326 
327             # Mul([...])
328             if o.is_Mul:
329                 if o.is_commutative:
330                     seq.extend(o.args)    # XXX zerocopy?
331 
332                 else:
333                     # NCMul can have commutative parts as well
334                     for q in o.args:
335                         if q.is_commutative:
336                             seq.append(q)
337                         else:
338                             nc_seq.append(q)
339 
340                     # append non-commutative marker, so we don't forget to
341                     # process scheduled non-commutative objects
342                     seq.append(NC_Marker)
343 
344                 continue
345 
346             # 3
347             elif o.is_Number:
348                 if o is S.NaN or coeff is S.ComplexInfinity and o.is_zero:
349                     # we know for sure the result will be nan
350                     return [S.NaN], [], None
351                 elif coeff.is_Number or isinstance(coeff, AccumBounds):  # it could be zoo
352                     coeff *= o
353                     if coeff is S.NaN:
354                         # we know for sure the result will be nan
355                         return [S.NaN], [], None
356                 continue
357 
358             elif isinstance(o, AccumBounds):
359                 coeff = o.__mul__(coeff)
360                 continue
361 
362             elif o is S.ComplexInfinity:
363                 if not coeff:
364                     # 0 * zoo = NaN
365                     return [S.NaN], [], None
366                 coeff = S.ComplexInfinity
367                 continue
368 
369             elif o is S.ImaginaryUnit:
370                 neg1e += S.Half
371                 continue
372 
373             elif o.is_commutative:
374                 #      e
375                 # o = b
376                 b, e = o.as_base_exp()
377 
378                 #  y
379                 # 3
380                 if o.is_Pow:
381                     if b.is_Number:
382 
383                         # get all the factors with numeric base so they can be
384                         # combined below, but don't combine negatives unless
385                         # the exponent is an integer
386                         if e.is_Rational:
387                             if e.is_Integer:
388                                 coeff *= Pow(b, e)  # it is an unevaluated power
389                                 continue
390                             elif e.is_negative:    # also a sign of an unevaluated power
391                                 seq.append(Pow(b, e))
392                                 continue
393                             elif b.is_negative:
394                                 neg1e += e
395                                 b = -b
396                             if b is not S.One:
397                                 pnum_rat.setdefault(b, []).append(e)
398                             continue
399                         elif b.is_positive or e.is_integer:
400                             num_exp.append((b, e))
401                             continue
402 
403                 c_powers.append((b, e))
404 
405             # NON-COMMUTATIVE
406             # TODO: Make non-commutative exponents not combine automatically
407             else:
408                 if o is not NC_Marker:
409                     nc_seq.append(o)
410 
411                 # process nc_seq (if any)
412                 while nc_seq:
413                     o = nc_seq.pop(0)
414                     if not nc_part:
415                         nc_part.append(o)
416                         continue
417 
418                     #                             b    c       b+c
419                     # try to combine last terms: a  * a   ->  a
420                     o1 = nc_part.pop()
421                     b1, e1 = o1.as_base_exp()
422                     b2, e2 = o.as_base_exp()
423                     new_exp = e1 + e2
424                     # Only allow powers to combine if the new exponent is
425                     # not an Add. This allow things like a**2*b**3 == a**5
426                     # if a.is_commutative == False, but prohibits
427                     # a**x*a**y and x**a*x**b from combining (x,y commute).
428                     if b1 == b2 and (not new_exp.is_Add):
429                         o12 = b1 ** new_exp
430 
431                         # now o12 could be a commutative object
432                         if o12.is_commutative:
433                             seq.append(o12)
434                             continue
435                         else:
436                             nc_seq.insert(0, o12)
437 
438                     else:
439                         nc_part.append(o1)
440                         nc_part.append(o)
441 
442         # We do want a combined exponent if it would not be an Add, such as
443         #  y    2y     3y
444         # x  * x   -> x
445         # We determine if two exponents have the same term by using
446         # as_coeff_Mul.
447         #
448         # Unfortunately, this isn't smart enough to consider combining into
449         # exponents that might already be adds, so things like:
450         #  z - y    y
451         # x      * x  will be left alone.  This is because checking every possible
452         # combination can slow things down.
453 
454         # gather exponents of common bases...
455         def _gather(c_powers):
456             common_b = {}  # b:e
457             for b, e in c_powers:
458                 co = e.as_coeff_Mul()
459                 common_b.setdefault(b, {}).setdefault(
460                     co[1], []).append(co[0])
461             for b, d in common_b.items():
462                 for di, li in d.items():
463                     d[di] = Add(*li)
464             new_c_powers = []
465             for b, e in common_b.items():
466                 new_c_powers.extend([(b, c*t) for t, c in e.items()])
467             return new_c_powers
468 
469         # in c_powers
470         c_powers = _gather(c_powers)
471 
472         # and in num_exp
473         num_exp = _gather(num_exp)
474 
475         # --- PART 2 ---
476         #
477         # o process collected powers  (x**0 -> 1; x**1 -> x; otherwise Pow)
478         # o combine collected powers  (2**x * 3**x -> 6**x)
479         #   with numeric base
480 
481         # ................................
482         # now we have:
483         # - coeff:
484         # - c_powers:    (b, e)
485         # - num_exp:     (2, e)
486         # - pnum_rat:    {(1/3, [1/3, 2/3, 1/4])}
487 
488         #  0             1
489         # x  -> 1       x  -> x
490 
491         # this should only need to run twice; if it fails because
492         # it needs to be run more times, perhaps this should be
493         # changed to a "while True" loop -- the only reason it
494         # isn't such now is to allow a less-than-perfect result to
495         # be obtained rather than raising an error or entering an
496         # infinite loop
497         for i in range(2):
498             new_c_powers = []
499             changed = False
500             for b, e in c_powers:
501                 if e.is_zero:
502                     # canceling out infinities yields NaN
503                     if (b.is_Add or b.is_Mul) and any(infty in b.args
504                         for infty in (S.ComplexInfinity, S.Infinity,
505                                       S.NegativeInfinity)):
506                         return [S.NaN], [], None
507                     continue
508                 if e is S.One:
509                     if b.is_Number:
510                         coeff *= b
511                         continue
512                     p = b
513                 if e is not S.One:
514                     p = Pow(b, e)
515                     # check to make sure that the base doesn't change
516                     # after exponentiation; to allow for unevaluated
517                     # Pow, we only do so if b is not already a Pow
518                     if p.is_Pow and not b.is_Pow:
519                         bi = b
520                         b, e = p.as_base_exp()
521                         if b != bi:
522                             changed = True
523                 c_part.append(p)
524                 new_c_powers.append((b, e))
525             # there might have been a change, but unless the base
526             # matches some other base, there is nothing to do
527             if changed and len({
528                     b for b, e in new_c_powers}) != len(new_c_powers):
529                 # start over again
530                 c_part = []
531                 c_powers = _gather(new_c_powers)
532             else:
533                 break
534 
535         #  x    x     x
536         # 2  * 3  -> 6
537         inv_exp_dict = {}   # exp:Mul(num-bases)     x    x
538                             # e.g.  x:6  for  ... * 2  * 3  * ...
539         for b, e in num_exp:
540             inv_exp_dict.setdefault(e, []).append(b)
541         for e, b in inv_exp_dict.items():
542             inv_exp_dict[e] = cls(*b)
543         c_part.extend([Pow(b, e) for e, b in inv_exp_dict.items() if e])
544 
545         # b, e -> e' = sum(e), b
546         # {(1/5, [1/3]), (1/2, [1/12, 1/4]} -> {(1/3, [1/5, 1/2])}
547         comb_e = {}
548         for b, e in pnum_rat.items():
549             comb_e.setdefault(Add(*e), []).append(b)
550         del pnum_rat
551         # process them, reducing exponents to values less than 1
552         # and updating coeff if necessary else adding them to
553         # num_rat for further processing
554         num_rat = []
555         for e, b in comb_e.items():
556             b = cls(*b)
557             if e.q == 1:
558                 coeff *= Pow(b, e)
559                 continue
560             if e.p > e.q:
561                 e_i, ep = divmod(e.p, e.q)
562                 coeff *= Pow(b, e_i)
563                 e = Rational(ep, e.q)
564             num_rat.append((b, e))
565         del comb_e
566 
567         # extract gcd of bases in num_rat
568         # 2**(1/3)*6**(1/4) -> 2**(1/3+1/4)*3**(1/4)
569         pnew = defaultdict(list)
570         i = 0  # steps through num_rat which may grow
571         while i < len(num_rat):
572             bi, ei = num_rat[i]
573             grow = []
574             for j in range(i + 1, len(num_rat)):
575                 bj, ej = num_rat[j]
576                 g = bi.gcd(bj)
577                 if g is not S.One:
578                     # 4**r1*6**r2 -> 2**(r1+r2)  *  2**r1 *  3**r2
579                     # this might have a gcd with something else
580                     e = ei + ej
581                     if e.q == 1:
582                         coeff *= Pow(g, e)
583                     else:
584                         if e.p > e.q:
585                             e_i, ep = divmod(e.p, e.q)  # change e in place
586                             coeff *= Pow(g, e_i)
587                             e = Rational(ep, e.q)
588                         grow.append((g, e))
589                     # update the jth item
590                     num_rat[j] = (bj/g, ej)
591                     # update bi that we are checking with
592                     bi = bi/g
593                     if bi is S.One:
594                         break
595             if bi is not S.One:
596                 obj = Pow(bi, ei)
597                 if obj.is_Number:
598                     coeff *= obj
599                 else:
600                     # changes like sqrt(12) -> 2*sqrt(3)
601                     for obj in Mul.make_args(obj):
602                         if obj.is_Number:
603                             coeff *= obj
604                         else:
605                             assert obj.is_Pow
606                             bi, ei = obj.args
607                             pnew[ei].append(bi)
608 
609             num_rat.extend(grow)
610             i += 1
611 
612         # combine bases of the new powers
613         for e, b in pnew.items():
614             pnew[e] = cls(*b)
615 
616         # handle -1 and I
617         if neg1e:
618             # treat I as (-1)**(1/2) and compute -1's total exponent
619             p, q =  neg1e.as_numer_denom()
620             # if the integer part is odd, extract -1
621             n, p = divmod(p, q)
622             if n % 2:
623                 coeff = -coeff
624             # if it's a multiple of 1/2 extract I
625             if q == 2:
626                 c_part.append(S.ImaginaryUnit)
627             elif p:
628                 # see if there is any positive base this power of
629                 # -1 can join
630                 neg1e = Rational(p, q)
631                 for e, b in pnew.items():
632                     if e == neg1e and b.is_positive:
633                         pnew[e] = -b
634                         break
635                 else:
636                     # keep it separate; we've already evaluated it as
637                     # much as possible so evaluate=False
638                     c_part.append(Pow(S.NegativeOne, neg1e, evaluate=False))
639 
640         # add all the pnew powers
641         c_part.extend([Pow(b, e) for e, b in pnew.items()])
642 
643         # oo, -oo
644         if (coeff is S.Infinity) or (coeff is S.NegativeInfinity):
645             def _handle_for_oo(c_part, coeff_sign):
646                 new_c_part = []
647                 for t in c_part:
648                     if t.is_extended_positive:
649                         continue
650                     if t.is_extended_negative:
651                         coeff_sign *= -1
652                         continue
653                     new_c_part.append(t)
654                 return new_c_part, coeff_sign
655             c_part, coeff_sign = _handle_for_oo(c_part, 1)
656             nc_part, coeff_sign = _handle_for_oo(nc_part, coeff_sign)
657             coeff *= coeff_sign
658 
659         # zoo
660         if coeff is S.ComplexInfinity:
661             # zoo might be
662             #   infinite_real + bounded_im
663             #   bounded_real + infinite_im
664             #   infinite_real + infinite_im
665             # and non-zero real or imaginary will not change that status.
666             c_part = [c for c in c_part if not (fuzzy_not(c.is_zero) and
667                                                 c.is_extended_real is not None)]
668             nc_part = [c for c in nc_part if not (fuzzy_not(c.is_zero) and
669                                                   c.is_extended_real is not None)]
670 
671         # 0
672         elif coeff.is_zero:
673             # we know for sure the result will be 0 except the multiplicand
674             # is infinity or a matrix
675             if any(isinstance(c, MatrixExpr) for c in nc_part):
676                 return [coeff], nc_part, order_symbols
677             if any(c.is_finite == False for c in c_part):
678                 return [S.NaN], [], order_symbols
679             return [coeff], [], order_symbols
680 
681         # check for straggling Numbers that were produced
682         _new = []
683         for i in c_part:
684             if i.is_Number:
685                 coeff *= i
686             else:
687                 _new.append(i)
688         c_part = _new
689 
690         # order commutative part canonically
691         _mulsort(c_part)
692 
693         # current code expects coeff to be always in slot-0
694         if coeff is not S.One:
695             c_part.insert(0, coeff)
696 
697         # we are done
698         if (global_parameters.distribute and not nc_part and len(c_part) == 2 and
699                 c_part[0].is_Number and c_part[0].is_finite and c_part[1].is_Add):
700             # 2*(1+a) -> 2 + 2 * a
701             coeff = c_part[0]
702             c_part = [Add(*[coeff*f for f in c_part[1].args])]
703 
704         return c_part, nc_part, order_symbols
705 
706     def _eval_power(self, e):
707 
708         # don't break up NC terms: (A*B)**3 != A**3*B**3, it is A*B*A*B*A*B
709         cargs, nc = self.args_cnc(split_1=False)
710 
711         if e.is_Integer:
712             return Mul(*[Pow(b, e, evaluate=False) for b in cargs]) * \
713                 Pow(Mul._from_args(nc), e, evaluate=False)
714         if e.is_Rational and e.q == 2:
715             from sympy.core.power import integer_nthroot
716             from sympy.functions.elementary.complexes import sign
717             if self.is_imaginary:
718                 a = self.as_real_imag()[1]
719                 if a.is_Rational:
720                     n, d = abs(a/2).as_numer_denom()
721                     n, t = integer_nthroot(n, 2)
722                     if t:
723                         d, t = integer_nthroot(d, 2)
724                         if t:
725                             r = sympify(n)/d
726                             return _unevaluated_Mul(r**e.p, (1 + sign(a)*S.ImaginaryUnit)**e.p)
727 
728         p = Pow(self, e, evaluate=False)
729 
730         if e.is_Rational or e.is_Float:
731             return p._eval_expand_power_base()
732 
733         return p
734 
735     @classmethod
736     def class_key(cls):
737         return 3, 0, cls.__name__
738 
739     def _eval_evalf(self, prec):
740         c, m = self.as_coeff_Mul()
741         if c is S.NegativeOne:
742             if m.is_Mul:
743                 rv = -AssocOp._eval_evalf(m, prec)
744             else:
745                 mnew = m._eval_evalf(prec)
746                 if mnew is not None:
747                     m = mnew
748                 rv = -m
749         else:
750             rv = AssocOp._eval_evalf(self, prec)
751         if rv.is_number:
752             return rv.expand()
753         return rv
754 
755     @property
756     def _mpc_(self):
757         """
758         Convert self to an mpmath mpc if possible
759         """
760         from sympy.core.numbers import I, Float
761         im_part, imag_unit = self.as_coeff_Mul()
762         if not imag_unit == I:
763             # ValueError may seem more reasonable but since it's a @property,
764             # we need to use AttributeError to keep from confusing things like
765             # hasattr.
766             raise AttributeError("Cannot convert Mul to mpc. Must be of the form Number*I")
767 
768         return (Float(0)._mpf_, Float(im_part)._mpf_)
769 
770     @cacheit
771     def as_two_terms(self):
772         """Return head and tail of self.
773 
774         This is the most efficient way to get the head and tail of an
775         expression.
776 
777         - if you want only the head, use self.args[0];
778         - if you want to process the arguments of the tail then use
779           self.as_coef_mul() which gives the head and a tuple containing
780           the arguments of the tail when treated as a Mul.
781         - if you want the coefficient when self is treated as an Add
782           then use self.as_coeff_add()[0]
783 
784         Examples
785         ========
786 
787         >>> from sympy.abc import x, y
788         >>> (3*x*y).as_two_terms()
789         (3, x*y)
790         """
791         args = self.args
792 
793         if len(args) == 1:
794             return S.One, self
795         elif len(args) == 2:
796             return args
797 
798         else:
799             return args[0], self._new_rawargs(*args[1:])
800 
801     @cacheit
802     def as_coefficients_dict(self):
803         """Return a dictionary mapping terms to their coefficient.
804         Since the dictionary is a defaultdict, inquiries about terms which
805         were not present will return a coefficient of 0. The dictionary
806         is considered to have a single term.
807 
808         Examples
809         ========
810 
811         >>> from sympy.abc import a, x
812         >>> (3*a*x).as_coefficients_dict()
813         {a*x: 3}
814         >>> _[a]
815         0
816         """
817 
818         d = defaultdict(int)
819         args = self.args
820 
821         if len(args) == 1 or not args[0].is_Number:
822             d[self] = S.One
823         else:
824             d[self._new_rawargs(*args[1:])] = args[0]
825 
826         return d
827 
828     @cacheit
829     def as_coeff_mul(self, *deps, rational=True, **kwargs):
830         if deps:
831             from sympy.utilities.iterables import sift
832             l1, l2 = sift(self.args, lambda x: x.has(*deps), binary=True)
833             return self._new_rawargs(*l2), tuple(l1)
834         args = self.args
835         if args[0].is_Number:
836             if not rational or args[0].is_Rational:
837                 return args[0], args[1:]
838             elif args[0].is_extended_negative:
839                 return S.NegativeOne, (-args[0],) + args[1:]
840         return S.One, args
841 
842     def as_coeff_Mul(self, rational=False):
843         """
844         Efficiently extract the coefficient of a product.
845         """
846         coeff, args = self.args[0], self.args[1:]
847 
848         if coeff.is_Number:
849             if not rational or coeff.is_Rational:
850                 if len(args) == 1:
851                     return coeff, args[0]
852                 else:
853                     return coeff, self._new_rawargs(*args)
854             elif coeff.is_extended_negative:
855                 return S.NegativeOne, self._new_rawargs(*((-coeff,) + args))
856         return S.One, self
857 
858     def as_real_imag(self, deep=True, **hints):
859         from sympy import Abs, expand_mul, im, re
860         other = []
861         coeffr = []
862         coeffi = []
863         addterms = S.One
864         for a in self.args:
865             r, i = a.as_real_imag()
866             if i.is_zero:
867                 coeffr.append(r)
868             elif r.is_zero:
869                 coeffi.append(i*S.ImaginaryUnit)
870             elif a.is_commutative:
871                 # search for complex conjugate pairs:
872                 for i, x in enumerate(other):
873                     if x == a.conjugate():
874                         coeffr.append(Abs(x)**2)
875                         del other[i]
876                         break
877                 else:
878                     if a.is_Add:
879                         addterms *= a
880                     else:
881                         other.append(a)
882             else:
883                 other.append(a)
884         m = self.func(*other)
885         if hints.get('ignore') == m:
886             return
887         if len(coeffi) % 2:
888             imco = im(coeffi.pop(0))
889             # all other pairs make a real factor; they will be
890             # put into reco below
891         else:
892             imco = S.Zero
893         reco = self.func(*(coeffr + coeffi))
894         r, i = (reco*re(m), reco*im(m))
895         if addterms == 1:
896             if m == 1:
897                 if imco.is_zero:
898                     return (reco, S.Zero)
899                 else:
900                     return (S.Zero, reco*imco)
901             if imco is S.Zero:
902                 return (r, i)
903             return (-imco*i, imco*r)
904         addre, addim = expand_mul(addterms, deep=False).as_real_imag()
905         if imco is S.Zero:
906             return (r*addre - i*addim, i*addre + r*addim)
907         else:
908             r, i = -imco*i, imco*r
909             return (r*addre - i*addim, r*addim + i*addre)
910 
911     @staticmethod
912     def _expandsums(sums):
913         """
914         Helper function for _eval_expand_mul.
915 
916         sums must be a list of instances of Basic.
917         """
918 
919         L = len(sums)
920         if L == 1:
921             return sums[0].args
922         terms = []
923         left = Mul._expandsums(sums[:L//2])
924         right = Mul._expandsums(sums[L//2:])
925 
926         terms = [Mul(a, b) for a in left for b in right]
927         added = Add(*terms)
928         return Add.make_args(added)  # it may have collapsed down to one term
929 
930     def _eval_expand_mul(self, **hints):
931         from sympy import fraction
932 
933         # Handle things like 1/(x*(x + 1)), which are automatically converted
934         # to 1/x*1/(x + 1)
935         expr = self
936         n, d = fraction(expr)
937         if d.is_Mul:
938             n, d = [i._eval_expand_mul(**hints) if i.is_Mul else i
939                 for i in (n, d)]
940         expr = n/d
941         if not expr.is_Mul:
942             return expr
943 
944         plain, sums, rewrite = [], [], False
945         for factor in expr.args:
946             if factor.is_Add:
947                 sums.append(factor)
948                 rewrite = True
949             else:
950                 if factor.is_commutative:
951                     plain.append(factor)
952                 else:
953                     sums.append(Basic(factor))  # Wrapper
954 
955         if not rewrite:
956             return expr
957         else:
958             plain = self.func(*plain)
959             if sums:
960                 deep = hints.get("deep", False)
961                 terms = self.func._expandsums(sums)
962                 args = []
963                 for term in terms:
964                     t = self.func(plain, term)
965                     if t.is_Mul and any(a.is_Add for a in t.args) and deep:
966                         t = t._eval_expand_mul()
967                     args.append(t)
968                 return Add(*args)
969             else:
970                 return plain
971 
972     @cacheit
973     def _eval_derivative(self, s):
974         args = list(self.args)
975         terms = []
976         for i in range(len(args)):
977             d = args[i].diff(s)
978             if d:
979                 # Note: reduce is used in step of Mul as Mul is unable to
980                 # handle subtypes and operation priority:
981                 terms.append(reduce(lambda x, y: x*y, (args[:i] + [d] + args[i + 1:]), S.One))
982         return Add.fromiter(terms)
983 
984     @cacheit
985     def _eval_derivative_n_times(self, s, n):
986         from sympy import Integer, factorial, prod, Sum, Max
987         from sympy.ntheory.multinomial import multinomial_coefficients_iterator
988         from .function import AppliedUndef
989         from .symbol import Symbol, symbols, Dummy
990         if not isinstance(s, AppliedUndef) and not isinstance(s, Symbol):
991             # other types of s may not be well behaved, e.g.
992             # (cos(x)*sin(y)).diff([[x, y, z]])
993             return super()._eval_derivative_n_times(s, n)
994         args = self.args
995         m = len(args)
996         if isinstance(n, (int, Integer)):
997             # https://en.wikipedia.org/wiki/General_Leibniz_rule#More_than_two_factors
998             terms = []
999             for kvals, c in multinomial_coefficients_iterator(m, n):
1000                 p = prod([arg.diff((s, k)) for k, arg in zip(kvals, args)])
1001                 terms.append(c * p)
1002             return Add(*terms)
1003         kvals = symbols("k1:%i" % m, cls=Dummy)
1004         klast = n - sum(kvals)
1005         nfact = factorial(n)
1006         e, l = (# better to use the multinomial?
1007             nfact/prod(map(factorial, kvals))/factorial(klast)*\
1008             prod([args[t].diff((s, kvals[t])) for t in range(m-1)])*\
1009             args[-1].diff((s, Max(0, klast))),
1010             [(k, 0, n) for k in kvals])
1011         return Sum(e, *l)
1012 
1013     def _eval_difference_delta(self, n, step):
1014         from sympy.series.limitseq import difference_delta as dd
1015         arg0 = self.args[0]
1016         rest = Mul(*self.args[1:])
1017         return (arg0.subs(n, n + step) * dd(rest, n, step) + dd(arg0, n, step) *
1018                 rest)
1019 
1020     def _matches_simple(self, expr, repl_dict):
1021         # handle (w*3).matches('x*5') -> {w: x*5/3}
1022         coeff, terms = self.as_coeff_Mul()
1023         terms = Mul.make_args(terms)
1024         if len(terms) == 1:
1025             newexpr = self.__class__._combine_inverse(expr, coeff)
1026             return terms[0].matches(newexpr, repl_dict)
1027         return
1028 
1029     def matches(self, expr, repl_dict={}, old=False):
1030         expr = sympify(expr)
1031         repl_dict = repl_dict.copy()
1032         if self.is_commutative and expr.is_commutative:
1033             return self._matches_commutative(expr, repl_dict, old)
1034         elif self.is_commutative is not expr.is_commutative:
1035             return None
1036 
1037         # Proceed only if both both expressions are non-commutative
1038         c1, nc1 = self.args_cnc()
1039         c2, nc2 = expr.args_cnc()
1040         c1, c2 = [c or [1] for c in [c1, c2]]
1041 
1042         # TODO: Should these be self.func?
1043         comm_mul_self = Mul(*c1)
1044         comm_mul_expr = Mul(*c2)
1045 
1046         repl_dict = comm_mul_self.matches(comm_mul_expr, repl_dict, old)
1047 
1048         # If the commutative arguments didn't match and aren't equal, then
1049         # then the expression as a whole doesn't match
1050         if repl_dict is None and c1 != c2:
1051             return None
1052 
1053         # Now match the non-commutative arguments, expanding powers to
1054         # multiplications
1055         nc1 = Mul._matches_expand_pows(nc1)
1056         nc2 = Mul._matches_expand_pows(nc2)
1057 
1058         repl_dict = Mul._matches_noncomm(nc1, nc2, repl_dict)
1059 
1060         return repl_dict or None
1061 
1062     @staticmethod
1063     def _matches_expand_pows(arg_list):
1064         new_args = []
1065         for arg in arg_list:
1066             if arg.is_Pow and arg.exp > 0:
1067                 new_args.extend([arg.base] * arg.exp)
1068             else:
1069                 new_args.append(arg)
1070         return new_args
1071 
1072     @staticmethod
1073     def _matches_noncomm(nodes, targets, repl_dict={}):
1074         """Non-commutative multiplication matcher.
1075 
1076         `nodes` is a list of symbols within the matcher multiplication
1077         expression, while `targets` is a list of arguments in the
1078         multiplication expression being matched against.
1079         """
1080         repl_dict = repl_dict.copy()
1081         # List of possible future states to be considered
1082         agenda = []
1083         # The current matching state, storing index in nodes and targets
1084         state = (0, 0)
1085         node_ind, target_ind = state
1086         # Mapping between wildcard indices and the index ranges they match
1087         wildcard_dict = {}
1088         repl_dict = repl_dict.copy()
1089 
1090         while target_ind < len(targets) and node_ind < len(nodes):
1091             node = nodes[node_ind]
1092 
1093             if node.is_Wild:
1094                 Mul._matches_add_wildcard(wildcard_dict, state)
1095 
1096             states_matches = Mul._matches_new_states(wildcard_dict, state,
1097                                                      nodes, targets)
1098             if states_matches:
1099                 new_states, new_matches = states_matches
1100                 agenda.extend(new_states)
1101                 if new_matches:
1102                     for match in new_matches:
1103                         repl_dict[match] = new_matches[match]
1104             if not agenda:
1105                 return None
1106             else:
1107                 state = agenda.pop()
1108                 node_ind, target_ind = state
1109 
1110         return repl_dict
1111 
1112     @staticmethod
1113     def _matches_add_wildcard(dictionary, state):
1114         node_ind, target_ind = state
1115         if node_ind in dictionary:
1116             begin, end = dictionary[node_ind]
1117             dictionary[node_ind] = (begin, target_ind)
1118         else:
1119             dictionary[node_ind] = (target_ind, target_ind)
1120 
1121     @staticmethod
1122     def _matches_new_states(dictionary, state, nodes, targets):
1123         node_ind, target_ind = state
1124         node = nodes[node_ind]
1125         target = targets[target_ind]
1126 
1127         # Don't advance at all if we've exhausted the targets but not the nodes
1128         if target_ind >= len(targets) - 1 and node_ind < len(nodes) - 1:
1129             return None
1130 
1131         if node.is_Wild:
1132             match_attempt = Mul._matches_match_wilds(dictionary, node_ind,
1133                                                      nodes, targets)
1134             if match_attempt:
1135                 # If the same node has been matched before, don't return
1136                 # anything if the current match is diverging from the previous
1137                 # match
1138                 other_node_inds = Mul._matches_get_other_nodes(dictionary,
1139                                                                nodes, node_ind)
1140                 for ind in other_node_inds:
1141                     other_begin, other_end = dictionary[ind]
1142                     curr_begin, curr_end = dictionary[node_ind]
1143 
1144                     other_targets = targets[other_begin:other_end + 1]
1145                     current_targets = targets[curr_begin:curr_end + 1]
1146 
1147                     for curr, other in zip(current_targets, other_targets):
1148                         if curr != other:
1149                             return None
1150 
1151                 # A wildcard node can match more than one target, so only the
1152                 # target index is advanced
1153                 new_state = [(node_ind, target_ind + 1)]
1154                 # Only move on to the next node if there is one
1155                 if node_ind < len(nodes) - 1:
1156                     new_state.append((node_ind + 1, target_ind + 1))
1157                 return new_state, match_attempt
1158         else:
1159             # If we're not at a wildcard, then make sure we haven't exhausted
1160             # nodes but not targets, since in this case one node can only match
1161             # one target
1162             if node_ind >= len(nodes) - 1 and target_ind < len(targets) - 1:
1163                 return None
1164 
1165             match_attempt = node.matches(target)
1166 
1167             if match_attempt:
1168                 return [(node_ind + 1, target_ind + 1)], match_attempt
1169             elif node == target:
1170                 return [(node_ind + 1, target_ind + 1)], None
1171             else:
1172                 return None
1173 
1174     @staticmethod
1175     def _matches_match_wilds(dictionary, wildcard_ind, nodes, targets):
1176         """Determine matches of a wildcard with sub-expression in `target`."""
1177         wildcard = nodes[wildcard_ind]
1178         begin, end = dictionary[wildcard_ind]
1179         terms = targets[begin:end + 1]
1180         # TODO: Should this be self.func?
1181         mul = Mul(*terms) if len(terms) > 1 else terms[0]
1182         return wildcard.matches(mul)
1183 
1184     @staticmethod
1185     def _matches_get_other_nodes(dictionary, nodes, node_ind):
1186         """Find other wildcards that may have already been matched."""
1187         other_node_inds = []
1188         for ind in dictionary:
1189             if nodes[ind] == nodes[node_ind]:
1190                 other_node_inds.append(ind)
1191         return other_node_inds
1192 
1193     @staticmethod
1194     def _combine_inverse(lhs, rhs):
1195         """
1196         Returns lhs/rhs, but treats arguments like symbols, so things
1197         like oo/oo return 1 (instead of a nan) and ``I`` behaves like
1198         a symbol instead of sqrt(-1).
1199         """
1200         from sympy.simplify.simplify import signsimp
1201         from .symbol import Dummy
1202         if lhs == rhs:
1203             return S.One
1204 
1205         def check(l, r):
1206             if l.is_Float and r.is_comparable:
1207                 # if both objects are added to 0 they will share the same "normalization"
1208                 # and are more likely to compare the same. Since Add(foo, 0) will not allow
1209                 # the 0 to pass, we use __add__ directly.
1210                 return l.__add__(0) == r.evalf().__add__(0)
1211             return False
1212         if check(lhs, rhs) or check(rhs, lhs):
1213             return S.One
1214         if any(i.is_Pow or i.is_Mul for i in (lhs, rhs)):
1215             # gruntz and limit wants a literal I to not combine
1216             # with a power of -1
1217             d = Dummy('I')
1218             _i = {S.ImaginaryUnit: d}
1219             i_ = {d: S.ImaginaryUnit}
1220             a = lhs.xreplace(_i).as_powers_dict()
1221             b = rhs.xreplace(_i).as_powers_dict()
1222             blen = len(b)
1223             for bi in tuple(b.keys()):
1224                 if bi in a:
1225                     a[bi] -= b.pop(bi)
1226                     if not a[bi]:
1227                         a.pop(bi)
1228             if len(b) != blen:
1229                 lhs = Mul(*[k**v for k, v in a.items()]).xreplace(i_)
1230                 rhs = Mul(*[k**v for k, v in b.items()]).xreplace(i_)
1231         return signsimp(lhs/rhs)
1232 
1233     def as_powers_dict(self):
1234         d = defaultdict(int)
1235         for term in self.args:
1236             for b, e in term.as_powers_dict().items():
1237                 d[b] += e
1238         return d
1239 
1240     def as_numer_denom(self):
1241         # don't use _from_args to rebuild the numerators and denominators
1242         # as the order is not guaranteed to be the same once they have
1243         # been separated from each other
1244         numers, denoms = list(zip(*[f.as_numer_denom() for f in self.args]))
1245         return self.func(*numers), self.func(*denoms)
1246 
1247     def as_base_exp(self):
1248         e1 = None
1249         bases = []
1250         nc = 0
1251         for m in self.args:
1252             b, e = m.as_base_exp()
1253             if not b.is_commutative:
1254                 nc += 1
1255             if e1 is None:
1256                 e1 = e
1257             elif e != e1 or nc > 1:
1258                 return self, S.One
1259             bases.append(b)
1260         return self.func(*bases), e1
1261 
1262     def _eval_is_polynomial(self, syms):
1263         return all(term._eval_is_polynomial(syms) for term in self.args)
1264 
1265     def _eval_is_rational_function(self, syms):
1266         return all(term._eval_is_rational_function(syms) for term in self.args)
1267 
1268     def _eval_is_meromorphic(self, x, a):
1269         return _fuzzy_group((arg.is_meromorphic(x, a) for arg in self.args),
1270                             quick_exit=True)
1271 
1272     def _eval_is_algebraic_expr(self, syms):
1273         return all(term._eval_is_algebraic_expr(syms) for term in self.args)
1274 
1275     _eval_is_commutative = lambda self: _fuzzy_group(
1276         a.is_commutative for a in self.args)
1277 
1278     def _eval_is_complex(self):
1279         comp = _fuzzy_group(a.is_complex for a in self.args)
1280         if comp is False:
1281             if any(a.is_infinite for a in self.args):
1282                 if any(a.is_zero is not False for a in self.args):
1283                     return None
1284                 return False
1285         return comp
1286 
1287     def _eval_is_finite(self):
1288         if all(a.is_finite for a in self.args):
1289             return True
1290         if any(a.is_infinite for a in self.args):
1291             if all(a.is_zero is False for a in self.args):
1292                 return False
1293 
1294     def _eval_is_infinite(self):
1295         if any(a.is_infinite for a in self.args):
1296             if any(a.is_zero for a in self.args):
1297                 return S.NaN.is_infinite
1298             if any(a.is_zero is None for a in self.args):
1299                 return None
1300             return True
1301 
1302     def _eval_is_rational(self):
1303         r = _fuzzy_group((a.is_rational for a in self.args), quick_exit=True)
1304         if r:
1305             return r
1306         elif r is False:
1307             return self.is_zero
1308 
1309     def _eval_is_algebraic(self):
1310         r = _fuzzy_group((a.is_algebraic for a in self.args), quick_exit=True)
1311         if r:
1312             return r
1313         elif r is False:
1314             return self.is_zero
1315 
1316     def _eval_is_zero(self):
1317         zero = infinite = False
1318         for a in self.args:
1319             z = a.is_zero
1320             if z:
1321                 if infinite:
1322                     return  # 0*oo is nan and nan.is_zero is None
1323                 zero = True
1324             else:
1325                 if not a.is_finite:
1326                     if zero:
1327                         return  # 0*oo is nan and nan.is_zero is None
1328                     infinite = True
1329                 if zero is False and z is None:  # trap None
1330                     zero = None
1331         return zero
1332 
1333     # without involving odd/even checks this code would suffice:
1334     #_eval_is_integer = lambda self: _fuzzy_group(
1335     #    (a.is_integer for a in self.args), quick_exit=True)
1336     def _eval_is_integer(self):
1337         is_rational = self._eval_is_rational()
1338         if is_rational is False:
1339             return False
1340 
1341         numerators = []
1342         denominators = []
1343         for a in self.args:
1344             if a.is_integer:
1345                 numerators.append(a)
1346             elif a.is_Rational:
1347                 n, d = a.as_numer_denom()
1348                 numerators.append(n)
1349                 denominators.append(d)
1350             elif a.is_Pow:
1351                 b, e = a.as_base_exp()
1352                 if not b.is_integer or not e.is_integer: return
1353                 if e.is_negative:
1354                     denominators.append(b)
1355                 else:
1356                     # for integer b and positive integer e: a = b**e would be integer
1357                     assert not e.is_positive
1358                     # for self being rational and e equal to zero: a = b**e would be 1
1359                     assert not e.is_zero
1360                     return # sign of e unknown -> self.is_integer cannot be decided
1361             else:
1362                 return
1363 
1364         if not denominators:
1365             return True
1366 
1367         odd = lambda ints: all(i.is_odd for i in ints)
1368         even = lambda ints: any(i.is_even for i in ints)
1369 
1370         if odd(numerators) and even(denominators):
1371             return False
1372         elif even(numerators) and denominators == [2]:
1373             return True
1374 
1375     def _eval_is_polar(self):
1376         has_polar = any(arg.is_polar for arg in self.args)
1377         return has_polar and \
1378             all(arg.is_polar or arg.is_positive for arg in self.args)
1379 
1380     def _eval_is_extended_real(self):
1381         return self._eval_real_imag(True)
1382 
1383     def _eval_real_imag(self, real):
1384         zero = False
1385         t_not_re_im = None
1386 
1387         for t in self.args:
1388             if (t.is_complex or t.is_infinite) is False and t.is_extended_real is False:
1389                 return False
1390             elif t.is_imaginary:  # I
1391                 real = not real
1392             elif t.is_extended_real:  # 2
1393                 if not zero:
1394                     z = t.is_zero
1395                     if not z and zero is False:
1396                         zero = z
1397                     elif z:
1398                         if all(a.is_finite for a in self.args):
1399                             return True
1400                         return
1401             elif t.is_extended_real is False:
1402                 # symbolic or literal like `2 + I` or symbolic imaginary
1403                 if t_not_re_im:
1404                     return  # complex terms might cancel
1405                 t_not_re_im = t
1406             elif t.is_imaginary is False:  # symbolic like `2` or `2 + I`
1407                 if t_not_re_im:
1408                     return  # complex terms might cancel
1409                 t_not_re_im = t
1410             else:
1411                 return
1412 
1413         if t_not_re_im:
1414             if t_not_re_im.is_extended_real is False:
1415                 if real:  # like 3
1416                     return zero  # 3*(smthng like 2 + I or i) is not real
1417             if t_not_re_im.is_imaginary is False:  # symbolic 2 or 2 + I
1418                 if not real:  # like I
1419                     return zero  # I*(smthng like 2 or 2 + I) is not real
1420         elif zero is False:
1421             return real  # can't be trumped by 0
1422         elif real:
1423             return real  # doesn't matter what zero is
1424 
1425     def _eval_is_imaginary(self):
1426         z = self.is_zero
1427         if z:
1428             return False
1429         if self.is_finite is False:
1430             return False
1431         elif z is False and self.is_finite is True:
1432             return self._eval_real_imag(False)
1433 
1434     def _eval_is_hermitian(self):
1435         return self._eval_herm_antiherm(True)
1436 
1437     def _eval_herm_antiherm(self, real):
1438         one_nc = zero = one_neither = False
1439 
1440         for t in self.args:
1441             if not t.is_commutative:
1442                 if one_nc:
1443                     return
1444                 one_nc = True
1445 
1446             if t.is_antihermitian:
1447                 real = not real
1448             elif t.is_hermitian:
1449                 if not zero:
1450                     z = t.is_zero
1451                     if not z and zero is False:
1452                         zero = z
1453                     elif z:
1454                         if all(a.is_finite for a in self.args):
1455                             return True
1456                         return
1457             elif t.is_hermitian is False:
1458                 if one_neither:
1459                     return
1460                 one_neither = True
1461             else:
1462                 return
1463 
1464         if one_neither:
1465             if real:
1466                 return zero
1467         elif zero is False or real:
1468             return real
1469 
1470     def _eval_is_antihermitian(self):
1471         z = self.is_zero
1472         if z:
1473             return False
1474         elif z is False:
1475             return self._eval_herm_antiherm(False)
1476 
1477     def _eval_is_irrational(self):
1478         for t in self.args:
1479             a = t.is_irrational
1480             if a:
1481                 others = list(self.args)
1482                 others.remove(t)
1483                 if all((x.is_rational and fuzzy_not(x.is_zero)) is True for x in others):
1484                     return True
1485                 return
1486             if a is None:
1487                 return
1488         if all(x.is_real for x in self.args):
1489             return False
1490 
1491     def _eval_is_extended_positive(self):
1492         """Return True if self is positive, False if not, and None if it
1493         cannot be determined.
1494 
1495         Explanation
1496         ===========
1497 
1498         This algorithm is non-recursive and works by keeping track of the
1499         sign which changes when a negative or nonpositive is encountered.
1500         Whether a nonpositive or nonnegative is seen is also tracked since
1501         the presence of these makes it impossible to return True, but
1502         possible to return False if the end result is nonpositive. e.g.
1503 
1504             pos * neg * nonpositive -> pos or zero -> None is returned
1505             pos * neg * nonnegative -> neg or zero -> False is returned
1506         """
1507         return self._eval_pos_neg(1)
1508 
1509     def _eval_pos_neg(self, sign):
1510         saw_NON = saw_NOT = False
1511         for t in self.args:
1512             if t.is_extended_positive:
1513                 continue
1514             elif t.is_extended_negative:
1515                 sign = -sign
1516             elif t.is_zero:
1517                 if all(a.is_finite for a in self.args):
1518                     return False
1519                 return
1520             elif t.is_extended_nonpositive:
1521                 sign = -sign
1522                 saw_NON = True
1523             elif t.is_extended_nonnegative:
1524                 saw_NON = True
1525             # FIXME: is_positive/is_negative is False doesn't take account of
1526             # Symbol('x', infinite=True, extended_real=True) which has
1527             # e.g. is_positive is False but has uncertain sign.
1528             elif t.is_positive is False:
1529                 sign = -sign
1530                 if saw_NOT:
1531                     return
1532                 saw_NOT = True
1533             elif t.is_negative is False:
1534                 if saw_NOT:
1535                     return
1536                 saw_NOT = True
1537             else:
1538                 return
1539         if sign == 1 and saw_NON is False and saw_NOT is False:
1540             return True
1541         if sign < 0:
1542             return False
1543 
1544     def _eval_is_extended_negative(self):
1545         return self._eval_pos_neg(-1)
1546 
1547     def _eval_is_odd(self):
1548         is_integer = self.is_integer
1549 
1550         if is_integer:
1551             r, acc = True, 1
1552             for t in self.args:
1553                 if not t.is_integer:
1554                     return None
1555                 elif t.is_even:
1556                     r = False
1557                 elif t.is_integer:
1558                     if r is False:
1559                         pass
1560                     elif acc != 1 and (acc + t).is_odd:
1561                         r = False
1562                     elif t.is_odd is None:
1563                         r = None
1564                 acc = t
1565             return r
1566 
1567         # !integer -> !odd
1568         elif is_integer is False:
1569             return False
1570 
1571     def _eval_is_even(self):
1572         is_integer = self.is_integer
1573 
1574         if is_integer:
1575             return fuzzy_not(self.is_odd)
1576 
1577         elif is_integer is False:
1578             return False
1579 
1580     def _eval_is_composite(self):
1581         """
1582         Here we count the number of arguments that have a minimum value
1583         greater than two.
1584         If there are more than one of such a symbol then the result is composite.
1585         Else, the result cannot be determined.
1586         """
1587         number_of_args = 0 # count of symbols with minimum value greater than one
1588         for arg in self.args:
1589             if not (arg.is_integer and arg.is_positive):
1590                 return None
1591             if (arg-1).is_positive:
1592                 number_of_args += 1
1593 
1594         if number_of_args > 1:
1595             return True
1596 
1597     def _eval_subs(self, old, new):
1598         from sympy.functions.elementary.complexes import sign
1599         from sympy.ntheory.factor_ import multiplicity
1600         from sympy.simplify.powsimp import powdenest
1601         from sympy.simplify.radsimp import fraction
1602 
1603         if not old.is_Mul:
1604             return None
1605 
1606         # try keep replacement literal so -2*x doesn't replace 4*x
1607         if old.args[0].is_Number and old.args[0] < 0:
1608             if self.args[0].is_Number:
1609                 if self.args[0] < 0:
1610                     return self._subs(-old, -new)
1611                 return None
1612 
1613         def base_exp(a):
1614             # if I and -1 are in a Mul, they get both end up with
1615             # a -1 base (see issue 6421); all we want here are the
1616             # true Pow or exp separated into base and exponent
1617             from sympy import exp
1618             if a.is_Pow or isinstance(a, exp):
1619                 return a.as_base_exp()
1620             return a, S.One
1621 
1622         def breakup(eq):
1623             """break up powers of eq when treated as a Mul:
1624                    b**(Rational*e) -> b**e, Rational
1625                 commutatives come back as a dictionary {b**e: Rational}
1626                 noncommutatives come back as a list [(b**e, Rational)]
1627             """
1628 
1629             (c, nc) = (defaultdict(int), list())
1630             for a in Mul.make_args(eq):
1631                 a = powdenest(a)
1632                 (b, e) = base_exp(a)
1633                 if e is not S.One:
1634                     (co, _) = e.as_coeff_mul()
1635                     b = Pow(b, e/co)
1636                     e = co
1637                 if a.is_commutative:
1638                     c[b] += e
1639                 else:
1640                     nc.append([b, e])
1641             return (c, nc)
1642 
1643         def rejoin(b, co):
1644             """
1645             Put rational back with exponent; in general this is not ok, but
1646             since we took it from the exponent for analysis, it's ok to put
1647             it back.
1648             """
1649 
1650             (b, e) = base_exp(b)
1651             return Pow(b, e*co)
1652 
1653         def ndiv(a, b):
1654             """if b divides a in an extractive way (like 1/4 divides 1/2
1655             but not vice versa, and 2/5 does not divide 1/3) then return
1656             the integer number of times it divides, else return 0.
1657             """
1658             if not b.q % a.q or not a.q % b.q:
1659                 return int(a/b)
1660             return 0
1661 
1662         # give Muls in the denominator a chance to be changed (see issue 5651)
1663         # rv will be the default return value
1664         rv = None
1665         n, d = fraction(self)
1666         self2 = self
1667         if d is not S.One:
1668             self2 = n._subs(old, new)/d._subs(old, new)
1669             if not self2.is_Mul:
1670                 return self2._subs(old, new)
1671             if self2 != self:
1672                 rv = self2
1673 
1674         # Now continue with regular substitution.
1675 
1676         # handle the leading coefficient and use it to decide if anything
1677         # should even be started; we always know where to find the Rational
1678         # so it's a quick test
1679 
1680         co_self = self2.args[0]
1681         co_old = old.args[0]
1682         co_xmul = None
1683         if co_old.is_Rational and co_self.is_Rational:
1684             # if coeffs are the same there will be no updating to do
1685             # below after breakup() step; so skip (and keep co_xmul=None)
1686             if co_old != co_self:
1687                 co_xmul = co_self.extract_multiplicatively(co_old)
1688         elif co_old.is_Rational:
1689             return rv
1690 
1691         # break self and old into factors
1692 
1693         (c, nc) = breakup(self2)
1694         (old_c, old_nc) = breakup(old)
1695 
1696         # update the coefficients if we had an extraction
1697         # e.g. if co_self were 2*(3/35*x)**2 and co_old = 3/5
1698         # then co_self in c is replaced by (3/5)**2 and co_residual
1699         # is 2*(1/7)**2
1700 
1701         if co_xmul and co_xmul.is_Rational and abs(co_old) != 1:
1702             mult = S(multiplicity(abs(co_old), co_self))
1703             c.pop(co_self)
1704             if co_old in c:
1705                 c[co_old] += mult
1706             else:
1707                 c[co_old] = mult
1708             co_residual = co_self/co_old**mult
1709         else:
1710             co_residual = 1
1711 
1712         # do quick tests to see if we can't succeed
1713 
1714         ok = True
1715         if len(old_nc) > len(nc):
1716             # more non-commutative terms
1717             ok = False
1718         elif len(old_c) > len(c):
1719             # more commutative terms
1720             ok = False
1721         elif {i[0] for i in old_nc}.difference({i[0] for i in nc}):
1722             # unmatched non-commutative bases
1723             ok = False
1724         elif set(old_c).difference(set(c)):
1725             # unmatched commutative terms
1726             ok = False
1727         elif any(sign(c[b]) != sign(old_c[b]) for b in old_c):
1728             # differences in sign
1729             ok = False
1730         if not ok:
1731             return rv
1732 
1733         if not old_c:
1734             cdid = None
1735         else:
1736             rat = []
1737             for (b, old_e) in old_c.items():
1738                 c_e = c[b]
1739                 rat.append(ndiv(c_e, old_e))
1740                 if not rat[-1]:
1741                     return rv
1742             cdid = min(rat)
1743 
1744         if not old_nc:
1745             ncdid = None
1746             for i in range(len(nc)):
1747                 nc[i] = rejoin(*nc[i])
1748         else:
1749             ncdid = 0  # number of nc replacements we did
1750             take = len(old_nc)  # how much to look at each time
1751             limit = cdid or S.Infinity  # max number that we can take
1752             failed = []  # failed terms will need subs if other terms pass
1753             i = 0
1754             while limit and i + take <= len(nc):
1755                 hit = False
1756 
1757                 # the bases must be equivalent in succession, and
1758                 # the powers must be extractively compatible on the
1759                 # first and last factor but equal in between.
1760 
1761                 rat = []
1762                 for j in range(take):
1763                     if nc[i + j][0] != old_nc[j][0]:
1764                         break
1765                     elif j == 0:
1766                         rat.append(ndiv(nc[i + j][1], old_nc[j][1]))
1767                     elif j == take - 1:
1768                         rat.append(ndiv(nc[i + j][1], old_nc[j][1]))
1769                     elif nc[i + j][1] != old_nc[j][1]:
1770                         break
1771                     else:
1772                         rat.append(1)
1773                     j += 1
1774                 else:
1775                     ndo = min(rat)
1776                     if ndo:
1777                         if take == 1:
1778                             if cdid:
1779                                 ndo = min(cdid, ndo)
1780                             nc[i] = Pow(new, ndo)*rejoin(nc[i][0],
1781                                     nc[i][1] - ndo*old_nc[0][1])
1782                         else:
1783                             ndo = 1
1784 
1785                             # the left residual
1786 
1787                             l = rejoin(nc[i][0], nc[i][1] - ndo*
1788                                     old_nc[0][1])
1789 
1790                             # eliminate all middle terms
1791 
1792                             mid = new
1793 
1794                             # the right residual (which may be the same as the middle if take == 2)
1795 
1796                             ir = i + take - 1
1797                             r = (nc[ir][0], nc[ir][1] - ndo*
1798                                  old_nc[-1][1])
1799                             if r[1]:
1800                                 if i + take < len(nc):
1801                                     nc[i:i + take] = [l*mid, r]
1802                                 else:
1803                                     r = rejoin(*r)
1804                                     nc[i:i + take] = [l*mid*r]
1805                             else:
1806 
1807                                 # there was nothing left on the right
1808 
1809                                 nc[i:i + take] = [l*mid]
1810 
1811                         limit -= ndo
1812                         ncdid += ndo
1813                         hit = True
1814                 if not hit:
1815 
1816                     # do the subs on this failing factor
1817 
1818                     failed.append(i)
1819                 i += 1
1820             else:
1821 
1822                 if not ncdid:
1823                     return rv
1824 
1825                 # although we didn't fail, certain nc terms may have
1826                 # failed so we rebuild them after attempting a partial
1827                 # subs on them
1828 
1829                 failed.extend(range(i, len(nc)))
1830                 for i in failed:
1831                     nc[i] = rejoin(*nc[i]).subs(old, new)
1832 
1833         # rebuild the expression
1834 
1835         if cdid is None:
1836             do = ncdid
1837         elif ncdid is None:
1838             do = cdid
1839         else:
1840             do = min(ncdid, cdid)
1841 
1842         margs = []
1843         for b in c:
1844             if b in old_c:
1845 
1846                 # calculate the new exponent
1847 
1848                 e = c[b] - old_c[b]*do
1849                 margs.append(rejoin(b, e))
1850             else:
1851                 margs.append(rejoin(b.subs(old, new), c[b]))
1852         if cdid and not ncdid:
1853 
1854             # in case we are replacing commutative with non-commutative,
1855             # we want the new term to come at the front just like the
1856             # rest of this routine
1857 
1858             margs = [Pow(new, cdid)] + margs
1859         return co_residual*self2.func(*margs)*self2.func(*nc)
1860 
1861     def _eval_nseries(self, x, n, logx, cdir=0):
1862         from sympy import degree, Mul, Order, ceiling, powsimp, PolynomialError
1863         from itertools import product
1864 
1865         def coeff_exp(term, x):
1866             coeff, exp = S.One, S.Zero
1867             for factor in Mul.make_args(term):
1868                 if factor.has(x):
1869                     base, exp = factor.as_base_exp()
1870                     if base != x:
1871                         try:
1872                             return term.leadterm(x)
1873                         except ValueError:
1874                             return term, S.Zero
1875                 else:
1876                     coeff *= factor
1877             return coeff, exp
1878 
1879         ords = []
1880 
1881         try:
1882             for t in self.args:
1883                 coeff, exp = t.leadterm(x)
1884                 if not coeff.has(x):
1885                     ords.append((t, exp))
1886                 else:
1887                     raise ValueError
1888 
1889             n0 = sum(t[1] for t in ords)
1890             facs = []
1891             for t, m in ords:
1892                 n1 = ceiling(n - n0 + m)
1893                 s = t.nseries(x, n=n1, logx=logx, cdir=cdir)
1894                 ns = s.getn()
1895                 if ns is not None:
1896                     if ns < n1:  # less than expected
1897                         n -= n1 - ns    # reduce n
1898                 facs.append(s.removeO())
1899 
1900         except (ValueError, NotImplementedError, TypeError, AttributeError):
1901             facs = [t.nseries(x, n=n, logx=logx, cdir=cdir) for t in self.args]
1902             res = powsimp(self.func(*facs).expand(), combine='exp', deep=True)
1903             if res.has(Order):
1904                 res += Order(x**n, x)
1905             return res
1906 
1907         res = 0
1908         ords2 = [Add.make_args(factor) for factor in facs]
1909 
1910         for fac in product(*ords2):
1911             ords3 = [coeff_exp(term, x) for term in fac]
1912             coeffs, powers = zip(*ords3)
1913             power = sum(powers)
1914             if power < n:
1915                 res += Mul(*coeffs)*(x**power)
1916 
1917         if self.is_polynomial(x):
1918             try:
1919                 if degree(self, x) != degree(res, x):
1920                     res += Order(x**n, x)
1921             except PolynomialError:
1922                 pass
1923             else:
1924                 return res
1925 
1926         for i in (1, 2, 3):
1927             if (res - self).subs(x, i) is not S.Zero:
1928                 res += Order(x**n, x)
1929                 break
1930         return res
1931 
1932     def _eval_as_leading_term(self, x, cdir=0):
1933         return self.func(*[t.as_leading_term(x, cdir=cdir) for t in self.args])
1934 
1935     def _eval_conjugate(self):
1936         return self.func(*[t.conjugate() for t in self.args])
1937 
1938     def _eval_transpose(self):
1939         return self.func(*[t.transpose() for t in self.args[::-1]])
1940 
1941     def _eval_adjoint(self):
1942         return self.func(*[t.adjoint() for t in self.args[::-1]])
1943 
1944     def _sage_(self):
1945         s = 1
1946         for x in self.args:
1947             s *= x._sage_()
1948         return s
1949 
1950     def as_content_primitive(self, radical=False, clear=True):
1951         """Return the tuple (R, self/R) where R is the positive Rational
1952         extracted from self.
1953 
1954         Examples
1955         ========
1956 
1957         >>> from sympy import sqrt
1958         >>> (-3*sqrt(2)*(2 - 2*sqrt(2))).as_content_primitive()
1959         (6, -sqrt(2)*(1 - sqrt(2)))
1960 
1961         See docstring of Expr.as_content_primitive for more examples.
1962         """
1963 
1964         coef = S.One
1965         args = []
1966         for i, a in enumerate(self.args):
1967             c, p = a.as_content_primitive(radical=radical, clear=clear)
1968             coef *= c
1969             if p is not S.One:
1970                 args.append(p)
1971         # don't use self._from_args here to reconstruct args
1972         # since there may be identical args now that should be combined
1973         # e.g. (2+2*x)*(3+3*x) should be (6, (1 + x)**2) not (6, (1+x)*(1+x))
1974         return coef, self.func(*args)
1975 
1976     def as_ordered_factors(self, order=None):
1977         """Transform an expression into an ordered list of factors.
1978 
1979         Examples
1980         ========
1981 
1982         >>> from sympy import sin, cos
1983         >>> from sympy.abc import x, y
1984 
1985         >>> (2*x*y*sin(x)*cos(x)).as_ordered_factors()
1986         [2, x, y, sin(x), cos(x)]
1987 
1988         """
1989         cpart, ncpart = self.args_cnc()
1990         cpart.sort(key=lambda expr: expr.sort_key(order=order))
1991         return cpart + ncpart
1992 
1993     @property
1994     def _sorted_args(self):
1995         return tuple(self.as_ordered_factors())

</code><intended_behavior>While the primary issue seems related to the LaTeX printing functionality, ensuring that the `Mul` class correctly represents the unevaluated multiplication in a manner consistent with LaTeX printing requirements may also be necessary. If `Mul`â€™s internal representation or methods that contribute to printing, such as `_latex` (if present) or related utilities, do not appropriately flag or structure unevaluated expressions, these should be adjusted. The adjustment should allow for clear differentiation between evaluated and unevaluated states in a way that the LaTeX printer can accurately render them. This may involve enriching the `Mul` object with metadata concerning its evaluated state or providing helper methods that the LaTeX printer can utilize to decide formatting.</intended_behavior>]
2025-10-18 09:17:00.856 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-18 09:17:00.856 | INFO     | Search-only: skipping patch selection
2025-10-18 09:17:00.970 | INFO     | Task sympy__sympy-21101 completed successfully.
2025-10-18 09:17:00.970 | INFO     | No patch generated. You can try running ACR again.
