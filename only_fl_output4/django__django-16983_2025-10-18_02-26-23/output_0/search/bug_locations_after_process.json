[
    {
        "rel_file_path": "django/contrib/admin/checks.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__5.0/django/contrib/admin/checks.py",
        "start": 1,
        "end": 1354,
        "class_name": null,
        "method_name": null,
        "code": "1 import collections\n2 from itertools import chain\n3 \n4 from django.apps import apps\n5 from django.conf import settings\n6 from django.contrib.admin.utils import NotRelationField, flatten, get_fields_from_path\n7 from django.core import checks\n8 from django.core.exceptions import FieldDoesNotExist\n9 from django.db import models\n10 from django.db.models.constants import LOOKUP_SEP\n11 from django.db.models.expressions import Combinable\n12 from django.forms.models import BaseModelForm, BaseModelFormSet, _get_foreign_key\n13 from django.template import engines\n14 from django.template.backends.django import DjangoTemplates\n15 from django.utils.module_loading import import_string\n16 \n17 \n18 def _issubclass(cls, classinfo):\n19     \"\"\"\n20     issubclass() variant that doesn't raise an exception if cls isn't a\n21     class.\n22     \"\"\"\n23     try:\n24         return issubclass(cls, classinfo)\n25     except TypeError:\n26         return False\n27 \n28 \n29 def _contains_subclass(class_path, candidate_paths):\n30     \"\"\"\n31     Return whether or not a dotted class path (or a subclass of that class) is\n32     found in a list of candidate paths.\n33     \"\"\"\n34     cls = import_string(class_path)\n35     for path in candidate_paths:\n36         try:\n37             candidate_cls = import_string(path)\n38         except ImportError:\n39             # ImportErrors are raised elsewhere.\n40             continue\n41         if _issubclass(candidate_cls, cls):\n42             return True\n43     return False\n44 \n45 \n46 def check_admin_app(app_configs, **kwargs):\n47     from django.contrib.admin.sites import all_sites\n48 \n49     errors = []\n50     for site in all_sites:\n51         errors.extend(site.check(app_configs))\n52     return errors\n53 \n54 \n55 def check_dependencies(**kwargs):\n56     \"\"\"\n57     Check that the admin's dependencies are correctly installed.\n58     \"\"\"\n59     from django.contrib.admin.sites import all_sites\n60 \n61     if not apps.is_installed(\"django.contrib.admin\"):\n62         return []\n63     errors = []\n64     app_dependencies = (\n65         (\"django.contrib.contenttypes\", 401),\n66         (\"django.contrib.auth\", 405),\n67         (\"django.contrib.messages\", 406),\n68     )\n69     for app_name, error_code in app_dependencies:\n70         if not apps.is_installed(app_name):\n71             errors.append(\n72                 checks.Error(\n73                     \"'%s' must be in INSTALLED_APPS in order to use the admin \"\n74                     \"application.\" % app_name,\n75                     id=\"admin.E%d\" % error_code,\n76                 )\n77             )\n78     for engine in engines.all():\n79         if isinstance(engine, DjangoTemplates):\n80             django_templates_instance = engine.engine\n81             break\n82     else:\n83         django_templates_instance = None\n84     if not django_templates_instance:\n85         errors.append(\n86             checks.Error(\n87                 \"A 'django.template.backends.django.DjangoTemplates' instance \"\n88                 \"must be configured in TEMPLATES in order to use the admin \"\n89                 \"application.\",\n90                 id=\"admin.E403\",\n91             )\n92         )\n93     else:\n94         if (\n95             \"django.contrib.auth.context_processors.auth\"\n96             not in django_templates_instance.context_processors\n97             and _contains_subclass(\n98                 \"django.contrib.auth.backends.ModelBackend\",\n99                 settings.AUTHENTICATION_BACKENDS,\n100             )\n101         ):\n102             errors.append(\n103                 checks.Error(\n104                     \"'django.contrib.auth.context_processors.auth' must be \"\n105                     \"enabled in DjangoTemplates (TEMPLATES) if using the default \"\n106                     \"auth backend in order to use the admin application.\",\n107                     id=\"admin.E402\",\n108                 )\n109             )\n110         if (\n111             \"django.contrib.messages.context_processors.messages\"\n112             not in django_templates_instance.context_processors\n113         ):\n114             errors.append(\n115                 checks.Error(\n116                     \"'django.contrib.messages.context_processors.messages' must \"\n117                     \"be enabled in DjangoTemplates (TEMPLATES) in order to use \"\n118                     \"the admin application.\",\n119                     id=\"admin.E404\",\n120                 )\n121             )\n122         sidebar_enabled = any(site.enable_nav_sidebar for site in all_sites)\n123         if (\n124             sidebar_enabled\n125             and \"django.template.context_processors.request\"\n126             not in django_templates_instance.context_processors\n127         ):\n128             errors.append(\n129                 checks.Warning(\n130                     \"'django.template.context_processors.request' must be enabled \"\n131                     \"in DjangoTemplates (TEMPLATES) in order to use the admin \"\n132                     \"navigation sidebar.\",\n133                     id=\"admin.W411\",\n134                 )\n135             )\n136 \n137     if not _contains_subclass(\n138         \"django.contrib.auth.middleware.AuthenticationMiddleware\", settings.MIDDLEWARE\n139     ):\n140         errors.append(\n141             checks.Error(\n142                 \"'django.contrib.auth.middleware.AuthenticationMiddleware' must \"\n143                 \"be in MIDDLEWARE in order to use the admin application.\",\n144                 id=\"admin.E408\",\n145             )\n146         )\n147     if not _contains_subclass(\n148         \"django.contrib.messages.middleware.MessageMiddleware\", settings.MIDDLEWARE\n149     ):\n150         errors.append(\n151             checks.Error(\n152                 \"'django.contrib.messages.middleware.MessageMiddleware' must \"\n153                 \"be in MIDDLEWARE in order to use the admin application.\",\n154                 id=\"admin.E409\",\n155             )\n156         )\n157     if not _contains_subclass(\n158         \"django.contrib.sessions.middleware.SessionMiddleware\", settings.MIDDLEWARE\n159     ):\n160         errors.append(\n161             checks.Error(\n162                 \"'django.contrib.sessions.middleware.SessionMiddleware' must \"\n163                 \"be in MIDDLEWARE in order to use the admin application.\",\n164                 hint=(\n165                     \"Insert \"\n166                     \"'django.contrib.sessions.middleware.SessionMiddleware' \"\n167                     \"before \"\n168                     \"'django.contrib.auth.middleware.AuthenticationMiddleware'.\"\n169                 ),\n170                 id=\"admin.E410\",\n171             )\n172         )\n173     return errors\n174 \n175 \n176 class BaseModelAdminChecks:\n177     def check(self, admin_obj, **kwargs):\n178         return [\n179             *self._check_autocomplete_fields(admin_obj),\n180             *self._check_raw_id_fields(admin_obj),\n181             *self._check_fields(admin_obj),\n182             *self._check_fieldsets(admin_obj),\n183             *self._check_exclude(admin_obj),\n184             *self._check_form(admin_obj),\n185             *self._check_filter_vertical(admin_obj),\n186             *self._check_filter_horizontal(admin_obj),\n187             *self._check_radio_fields(admin_obj),\n188             *self._check_prepopulated_fields(admin_obj),\n189             *self._check_view_on_site_url(admin_obj),\n190             *self._check_ordering(admin_obj),\n191             *self._check_readonly_fields(admin_obj),\n192         ]\n193 \n194     def _check_autocomplete_fields(self, obj):\n195         \"\"\"\n196         Check that `autocomplete_fields` is a list or tuple of model fields.\n197         \"\"\"\n198         if not isinstance(obj.autocomplete_fields, (list, tuple)):\n199             return must_be(\n200                 \"a list or tuple\",\n201                 option=\"autocomplete_fields\",\n202                 obj=obj,\n203                 id=\"admin.E036\",\n204             )\n205         else:\n206             return list(\n207                 chain.from_iterable(\n208                     [\n209                         self._check_autocomplete_fields_item(\n210                             obj, field_name, \"autocomplete_fields[%d]\" % index\n211                         )\n212                         for index, field_name in enumerate(obj.autocomplete_fields)\n213                     ]\n214                 )\n215             )\n216 \n217     def _check_autocomplete_fields_item(self, obj, field_name, label):\n218         \"\"\"\n219         Check that an item in `autocomplete_fields` is a ForeignKey or a\n220         ManyToManyField and that the item has a related ModelAdmin with\n221         search_fields defined.\n222         \"\"\"\n223         try:\n224             field = obj.model._meta.get_field(field_name)\n225         except FieldDoesNotExist:\n226             return refer_to_missing_field(\n227                 field=field_name, option=label, obj=obj, id=\"admin.E037\"\n228             )\n229         else:\n230             if not field.many_to_many and not isinstance(field, models.ForeignKey):\n231                 return must_be(\n232                     \"a foreign key or a many-to-many field\",\n233                     option=label,\n234                     obj=obj,\n235                     id=\"admin.E038\",\n236                 )\n237             related_admin = obj.admin_site._registry.get(field.remote_field.model)\n238             if related_admin is None:\n239                 return [\n240                     checks.Error(\n241                         'An admin for model \"%s\" has to be registered '\n242                         \"to be referenced by %s.autocomplete_fields.\"\n243                         % (\n244                             field.remote_field.model.__name__,\n245                             type(obj).__name__,\n246                         ),\n247                         obj=obj.__class__,\n248                         id=\"admin.E039\",\n249                     )\n250                 ]\n251             elif not related_admin.search_fields:\n252                 return [\n253                     checks.Error(\n254                         '%s must define \"search_fields\", because it\\'s '\n255                         \"referenced by %s.autocomplete_fields.\"\n256                         % (\n257                             related_admin.__class__.__name__,\n258                             type(obj).__name__,\n259                         ),\n260                         obj=obj.__class__,\n261                         id=\"admin.E040\",\n262                     )\n263                 ]\n264             return []\n265 \n266     def _check_raw_id_fields(self, obj):\n267         \"\"\"Check that `raw_id_fields` only contains field names that are listed\n268         on the model.\"\"\"\n269 \n270         if not isinstance(obj.raw_id_fields, (list, tuple)):\n271             return must_be(\n272                 \"a list or tuple\", option=\"raw_id_fields\", obj=obj, id=\"admin.E001\"\n273             )\n274         else:\n275             return list(\n276                 chain.from_iterable(\n277                     self._check_raw_id_fields_item(\n278                         obj, field_name, \"raw_id_fields[%d]\" % index\n279                     )\n280                     for index, field_name in enumerate(obj.raw_id_fields)\n281                 )\n282             )\n283 \n284     def _check_raw_id_fields_item(self, obj, field_name, label):\n285         \"\"\"Check an item of `raw_id_fields`, i.e. check that field named\n286         `field_name` exists in model `model` and is a ForeignKey or a\n287         ManyToManyField.\"\"\"\n288 \n289         try:\n290             field = obj.model._meta.get_field(field_name)\n291         except FieldDoesNotExist:\n292             return refer_to_missing_field(\n293                 field=field_name, option=label, obj=obj, id=\"admin.E002\"\n294             )\n295         else:\n296             # Using attname is not supported.\n297             if field.name != field_name:\n298                 return refer_to_missing_field(\n299                     field=field_name,\n300                     option=label,\n301                     obj=obj,\n302                     id=\"admin.E002\",\n303                 )\n304             if not field.many_to_many and not isinstance(field, models.ForeignKey):\n305                 return must_be(\n306                     \"a foreign key or a many-to-many field\",\n307                     option=label,\n308                     obj=obj,\n309                     id=\"admin.E003\",\n310                 )\n311             else:\n312                 return []\n313 \n314     def _check_fields(self, obj):\n315         \"\"\"Check that `fields` only refer to existing fields, doesn't contain\n316         duplicates. Check if at most one of `fields` and `fieldsets` is defined.\n317         \"\"\"\n318 \n319         if obj.fields is None:\n320             return []\n321         elif not isinstance(obj.fields, (list, tuple)):\n322             return must_be(\"a list or tuple\", option=\"fields\", obj=obj, id=\"admin.E004\")\n323         elif obj.fieldsets:\n324             return [\n325                 checks.Error(\n326                     \"Both 'fieldsets' and 'fields' are specified.\",\n327                     obj=obj.__class__,\n328                     id=\"admin.E005\",\n329                 )\n330             ]\n331         fields = flatten(obj.fields)\n332         if len(fields) != len(set(fields)):\n333             return [\n334                 checks.Error(\n335                     \"The value of 'fields' contains duplicate field(s).\",\n336                     obj=obj.__class__,\n337                     id=\"admin.E006\",\n338                 )\n339             ]\n340 \n341         return list(\n342             chain.from_iterable(\n343                 self._check_field_spec(obj, field_name, \"fields\")\n344                 for field_name in obj.fields\n345             )\n346         )\n347 \n348     def _check_fieldsets(self, obj):\n349         \"\"\"Check that fieldsets is properly formatted and doesn't contain\n350         duplicates.\"\"\"\n351 \n352         if obj.fieldsets is None:\n353             return []\n354         elif not isinstance(obj.fieldsets, (list, tuple)):\n355             return must_be(\n356                 \"a list or tuple\", option=\"fieldsets\", obj=obj, id=\"admin.E007\"\n357             )\n358         else:\n359             seen_fields = []\n360             return list(\n361                 chain.from_iterable(\n362                     self._check_fieldsets_item(\n363                         obj, fieldset, \"fieldsets[%d]\" % index, seen_fields\n364                     )\n365                     for index, fieldset in enumerate(obj.fieldsets)\n366                 )\n367             )\n368 \n369     def _check_fieldsets_item(self, obj, fieldset, label, seen_fields):\n370         \"\"\"Check an item of `fieldsets`, i.e. check that this is a pair of a\n371         set name and a dictionary containing \"fields\" key.\"\"\"\n372 \n373         if not isinstance(fieldset, (list, tuple)):\n374             return must_be(\"a list or tuple\", option=label, obj=obj, id=\"admin.E008\")\n375         elif len(fieldset) != 2:\n376             return must_be(\"of length 2\", option=label, obj=obj, id=\"admin.E009\")\n377         elif not isinstance(fieldset[1], dict):\n378             return must_be(\n379                 \"a dictionary\", option=\"%s[1]\" % label, obj=obj, id=\"admin.E010\"\n380             )\n381         elif \"fields\" not in fieldset[1]:\n382             return [\n383                 checks.Error(\n384                     \"The value of '%s[1]' must contain the key 'fields'.\" % label,\n385                     obj=obj.__class__,\n386                     id=\"admin.E011\",\n387                 )\n388             ]\n389         elif not isinstance(fieldset[1][\"fields\"], (list, tuple)):\n390             return must_be(\n391                 \"a list or tuple\",\n392                 option=\"%s[1]['fields']\" % label,\n393                 obj=obj,\n394                 id=\"admin.E008\",\n395             )\n396 \n397         seen_fields.extend(flatten(fieldset[1][\"fields\"]))\n398         if len(seen_fields) != len(set(seen_fields)):\n399             return [\n400                 checks.Error(\n401                     \"There are duplicate field(s) in '%s[1]'.\" % label,\n402                     obj=obj.__class__,\n403                     id=\"admin.E012\",\n404                 )\n405             ]\n406         return list(\n407             chain.from_iterable(\n408                 self._check_field_spec(obj, fieldset_fields, '%s[1][\"fields\"]' % label)\n409                 for fieldset_fields in fieldset[1][\"fields\"]\n410             )\n411         )\n412 \n413     def _check_field_spec(self, obj, fields, label):\n414         \"\"\"`fields` should be an item of `fields` or an item of\n415         fieldset[1]['fields'] for any `fieldset` in `fieldsets`. It should be a\n416         field name or a tuple of field names.\"\"\"\n417 \n418         if isinstance(fields, tuple):\n419             return list(\n420                 chain.from_iterable(\n421                     self._check_field_spec_item(\n422                         obj, field_name, \"%s[%d]\" % (label, index)\n423                     )\n424                     for index, field_name in enumerate(fields)\n425                 )\n426             )\n427         else:\n428             return self._check_field_spec_item(obj, fields, label)\n429 \n430     def _check_field_spec_item(self, obj, field_name, label):\n431         if field_name in obj.readonly_fields:\n432             # Stuff can be put in fields that isn't actually a model field if\n433             # it's in readonly_fields, readonly_fields will handle the\n434             # validation of such things.\n435             return []\n436         else:\n437             try:\n438                 field = obj.model._meta.get_field(field_name)\n439             except FieldDoesNotExist:\n440                 # If we can't find a field on the model that matches, it could\n441                 # be an extra field on the form.\n442                 return []\n443             else:\n444                 if (\n445                     isinstance(field, models.ManyToManyField)\n446                     and not field.remote_field.through._meta.auto_created\n447                 ):\n448                     return [\n449                         checks.Error(\n450                             \"The value of '%s' cannot include the ManyToManyField \"\n451                             \"'%s', because that field manually specifies a \"\n452                             \"relationship model.\" % (label, field_name),\n453                             obj=obj.__class__,\n454                             id=\"admin.E013\",\n455                         )\n456                     ]\n457                 else:\n458                     return []\n459 \n460     def _check_exclude(self, obj):\n461         \"\"\"Check that exclude is a sequence without duplicates.\"\"\"\n462 \n463         if obj.exclude is None:  # default value is None\n464             return []\n465         elif not isinstance(obj.exclude, (list, tuple)):\n466             return must_be(\n467                 \"a list or tuple\", option=\"exclude\", obj=obj, id=\"admin.E014\"\n468             )\n469         elif len(obj.exclude) > len(set(obj.exclude)):\n470             return [\n471                 checks.Error(\n472                     \"The value of 'exclude' contains duplicate field(s).\",\n473                     obj=obj.__class__,\n474                     id=\"admin.E015\",\n475                 )\n476             ]\n477         else:\n478             return []\n479 \n480     def _check_form(self, obj):\n481         \"\"\"Check that form subclasses BaseModelForm.\"\"\"\n482         if not _issubclass(obj.form, BaseModelForm):\n483             return must_inherit_from(\n484                 parent=\"BaseModelForm\", option=\"form\", obj=obj, id=\"admin.E016\"\n485             )\n486         else:\n487             return []\n488 \n489     def _check_filter_vertical(self, obj):\n490         \"\"\"Check that filter_vertical is a sequence of field names.\"\"\"\n491         if not isinstance(obj.filter_vertical, (list, tuple)):\n492             return must_be(\n493                 \"a list or tuple\", option=\"filter_vertical\", obj=obj, id=\"admin.E017\"\n494             )\n495         else:\n496             return list(\n497                 chain.from_iterable(\n498                     self._check_filter_item(\n499                         obj, field_name, \"filter_vertical[%d]\" % index\n500                     )\n501                     for index, field_name in enumerate(obj.filter_vertical)\n502                 )\n503             )\n504 \n505     def _check_filter_horizontal(self, obj):\n506         \"\"\"Check that filter_horizontal is a sequence of field names.\"\"\"\n507         if not isinstance(obj.filter_horizontal, (list, tuple)):\n508             return must_be(\n509                 \"a list or tuple\", option=\"filter_horizontal\", obj=obj, id=\"admin.E018\"\n510             )\n511         else:\n512             return list(\n513                 chain.from_iterable(\n514                     self._check_filter_item(\n515                         obj, field_name, \"filter_horizontal[%d]\" % index\n516                     )\n517                     for index, field_name in enumerate(obj.filter_horizontal)\n518                 )\n519             )\n520 \n521     def _check_filter_item(self, obj, field_name, label):\n522         \"\"\"Check one item of `filter_vertical` or `filter_horizontal`, i.e.\n523         check that given field exists and is a ManyToManyField.\"\"\"\n524 \n525         try:\n526             field = obj.model._meta.get_field(field_name)\n527         except FieldDoesNotExist:\n528             return refer_to_missing_field(\n529                 field=field_name, option=label, obj=obj, id=\"admin.E019\"\n530             )\n531         else:\n532             if not field.many_to_many:\n533                 return must_be(\n534                     \"a many-to-many field\", option=label, obj=obj, id=\"admin.E020\"\n535                 )\n536             else:\n537                 return []\n538 \n539     def _check_radio_fields(self, obj):\n540         \"\"\"Check that `radio_fields` is a dictionary.\"\"\"\n541         if not isinstance(obj.radio_fields, dict):\n542             return must_be(\n543                 \"a dictionary\", option=\"radio_fields\", obj=obj, id=\"admin.E021\"\n544             )\n545         else:\n546             return list(\n547                 chain.from_iterable(\n548                     self._check_radio_fields_key(obj, field_name, \"radio_fields\")\n549                     + self._check_radio_fields_value(\n550                         obj, val, 'radio_fields[\"%s\"]' % field_name\n551                     )\n552                     for field_name, val in obj.radio_fields.items()\n553                 )\n554             )\n555 \n556     def _check_radio_fields_key(self, obj, field_name, label):\n557         \"\"\"Check that a key of `radio_fields` dictionary is name of existing\n558         field and that the field is a ForeignKey or has `choices` defined.\"\"\"\n559 \n560         try:\n561             field = obj.model._meta.get_field(field_name)\n562         except FieldDoesNotExist:\n563             return refer_to_missing_field(\n564                 field=field_name, option=label, obj=obj, id=\"admin.E022\"\n565             )\n566         else:\n567             if not (isinstance(field, models.ForeignKey) or field.choices):\n568                 return [\n569                     checks.Error(\n570                         \"The value of '%s' refers to '%s', which is not an \"\n571                         \"instance of ForeignKey, and does not have a 'choices' \"\n572                         \"definition.\" % (label, field_name),\n573                         obj=obj.__class__,\n574                         id=\"admin.E023\",\n575                     )\n576                 ]\n577             else:\n578                 return []\n579 \n580     def _check_radio_fields_value(self, obj, val, label):\n581         \"\"\"Check type of a value of `radio_fields` dictionary.\"\"\"\n582 \n583         from django.contrib.admin.options import HORIZONTAL, VERTICAL\n584 \n585         if val not in (HORIZONTAL, VERTICAL):\n586             return [\n587                 checks.Error(\n588                     \"The value of '%s' must be either admin.HORIZONTAL or \"\n589                     \"admin.VERTICAL.\" % label,\n590                     obj=obj.__class__,\n591                     id=\"admin.E024\",\n592                 )\n593             ]\n594         else:\n595             return []\n596 \n597     def _check_view_on_site_url(self, obj):\n598         if not callable(obj.view_on_site) and not isinstance(obj.view_on_site, bool):\n599             return [\n600                 checks.Error(\n601                     \"The value of 'view_on_site' must be a callable or a boolean \"\n602                     \"value.\",\n603                     obj=obj.__class__,\n604                     id=\"admin.E025\",\n605                 )\n606             ]\n607         else:\n608             return []\n609 \n610     def _check_prepopulated_fields(self, obj):\n611         \"\"\"Check that `prepopulated_fields` is a dictionary containing allowed\n612         field types.\"\"\"\n613         if not isinstance(obj.prepopulated_fields, dict):\n614             return must_be(\n615                 \"a dictionary\", option=\"prepopulated_fields\", obj=obj, id=\"admin.E026\"\n616             )\n617         else:\n618             return list(\n619                 chain.from_iterable(\n620                     self._check_prepopulated_fields_key(\n621                         obj, field_name, \"prepopulated_fields\"\n622                     )\n623                     + self._check_prepopulated_fields_value(\n624                         obj, val, 'prepopulated_fields[\"%s\"]' % field_name\n625                     )\n626                     for field_name, val in obj.prepopulated_fields.items()\n627                 )\n628             )\n629 \n630     def _check_prepopulated_fields_key(self, obj, field_name, label):\n631         \"\"\"Check a key of `prepopulated_fields` dictionary, i.e. check that it\n632         is a name of existing field and the field is one of the allowed types.\n633         \"\"\"\n634 \n635         try:\n636             field = obj.model._meta.get_field(field_name)\n637         except FieldDoesNotExist:\n638             return refer_to_missing_field(\n639                 field=field_name, option=label, obj=obj, id=\"admin.E027\"\n640             )\n641         else:\n642             if isinstance(\n643                 field, (models.DateTimeField, models.ForeignKey, models.ManyToManyField)\n644             ):\n645                 return [\n646                     checks.Error(\n647                         \"The value of '%s' refers to '%s', which must not be a \"\n648                         \"DateTimeField, a ForeignKey, a OneToOneField, or a \"\n649                         \"ManyToManyField.\" % (label, field_name),\n650                         obj=obj.__class__,\n651                         id=\"admin.E028\",\n652                     )\n653                 ]\n654             else:\n655                 return []\n656 \n657     def _check_prepopulated_fields_value(self, obj, val, label):\n658         \"\"\"Check a value of `prepopulated_fields` dictionary, i.e. it's an\n659         iterable of existing fields.\"\"\"\n660 \n661         if not isinstance(val, (list, tuple)):\n662             return must_be(\"a list or tuple\", option=label, obj=obj, id=\"admin.E029\")\n663         else:\n664             return list(\n665                 chain.from_iterable(\n666                     self._check_prepopulated_fields_value_item(\n667                         obj, subfield_name, \"%s[%r]\" % (label, index)\n668                     )\n669                     for index, subfield_name in enumerate(val)\n670                 )\n671             )\n672 \n673     def _check_prepopulated_fields_value_item(self, obj, field_name, label):\n674         \"\"\"For `prepopulated_fields` equal to {\"slug\": (\"title\",)},\n675         `field_name` is \"title\".\"\"\"\n676 \n677         try:\n678             obj.model._meta.get_field(field_name)\n679         except FieldDoesNotExist:\n680             return refer_to_missing_field(\n681                 field=field_name, option=label, obj=obj, id=\"admin.E030\"\n682             )\n683         else:\n684             return []\n685 \n686     def _check_ordering(self, obj):\n687         \"\"\"Check that ordering refers to existing fields or is random.\"\"\"\n688 \n689         # ordering = None\n690         if obj.ordering is None:  # The default value is None\n691             return []\n692         elif not isinstance(obj.ordering, (list, tuple)):\n693             return must_be(\n694                 \"a list or tuple\", option=\"ordering\", obj=obj, id=\"admin.E031\"\n695             )\n696         else:\n697             return list(\n698                 chain.from_iterable(\n699                     self._check_ordering_item(obj, field_name, \"ordering[%d]\" % index)\n700                     for index, field_name in enumerate(obj.ordering)\n701                 )\n702             )\n703 \n704     def _check_ordering_item(self, obj, field_name, label):\n705         \"\"\"Check that `ordering` refers to existing fields.\"\"\"\n706         if isinstance(field_name, (Combinable, models.OrderBy)):\n707             if not isinstance(field_name, models.OrderBy):\n708                 field_name = field_name.asc()\n709             if isinstance(field_name.expression, models.F):\n710                 field_name = field_name.expression.name\n711             else:\n712                 return []\n713         if field_name == \"?\" and len(obj.ordering) != 1:\n714             return [\n715                 checks.Error(\n716                     \"The value of 'ordering' has the random ordering marker '?', \"\n717                     \"but contains other fields as well.\",\n718                     hint='Either remove the \"?\", or remove the other fields.',\n719                     obj=obj.__class__,\n720                     id=\"admin.E032\",\n721                 )\n722             ]\n723         elif field_name == \"?\":\n724             return []\n725         elif LOOKUP_SEP in field_name:\n726             # Skip ordering in the format field1__field2 (FIXME: checking\n727             # this format would be nice, but it's a little fiddly).\n728             return []\n729         else:\n730             field_name = field_name.removeprefix(\"-\")\n731             if field_name == \"pk\":\n732                 return []\n733             try:\n734                 obj.model._meta.get_field(field_name)\n735             except FieldDoesNotExist:\n736                 return refer_to_missing_field(\n737                     field=field_name, option=label, obj=obj, id=\"admin.E033\"\n738                 )\n739             else:\n740                 return []\n741 \n742     def _check_readonly_fields(self, obj):\n743         \"\"\"Check that readonly_fields refers to proper attribute or field.\"\"\"\n744 \n745         if obj.readonly_fields == ():\n746             return []\n747         elif not isinstance(obj.readonly_fields, (list, tuple)):\n748             return must_be(\n749                 \"a list or tuple\", option=\"readonly_fields\", obj=obj, id=\"admin.E034\"\n750             )\n751         else:\n752             return list(\n753                 chain.from_iterable(\n754                     self._check_readonly_fields_item(\n755                         obj, field_name, \"readonly_fields[%d]\" % index\n756                     )\n757                     for index, field_name in enumerate(obj.readonly_fields)\n758                 )\n759             )\n760 \n761     def _check_readonly_fields_item(self, obj, field_name, label):\n762         if callable(field_name):\n763             return []\n764         elif hasattr(obj, field_name):\n765             return []\n766         elif hasattr(obj.model, field_name):\n767             return []\n768         else:\n769             try:\n770                 obj.model._meta.get_field(field_name)\n771             except FieldDoesNotExist:\n772                 return [\n773                     checks.Error(\n774                         \"The value of '%s' refers to '%s', which is not a callable, \"\n775                         \"an attribute of '%s', or an attribute of '%s'.\"\n776                         % (\n777                             label,\n778                             field_name,\n779                             obj.__class__.__name__,\n780                             obj.model._meta.label,\n781                         ),\n782                         obj=obj.__class__,\n783                         id=\"admin.E035\",\n784                     )\n785                 ]\n786             else:\n787                 return []\n788 \n789 \n790 class ModelAdminChecks(BaseModelAdminChecks):\n791     def check(self, admin_obj, **kwargs):\n792         return [\n793             *super().check(admin_obj),\n794             *self._check_save_as(admin_obj),\n795             *self._check_save_on_top(admin_obj),\n796             *self._check_inlines(admin_obj),\n797             *self._check_list_display(admin_obj),\n798             *self._check_list_display_links(admin_obj),\n799             *self._check_list_filter(admin_obj),\n800             *self._check_list_select_related(admin_obj),\n801             *self._check_list_per_page(admin_obj),\n802             *self._check_list_max_show_all(admin_obj),\n803             *self._check_list_editable(admin_obj),\n804             *self._check_search_fields(admin_obj),\n805             *self._check_date_hierarchy(admin_obj),\n806             *self._check_action_permission_methods(admin_obj),\n807             *self._check_actions_uniqueness(admin_obj),\n808         ]\n809 \n810     def _check_save_as(self, obj):\n811         \"\"\"Check save_as is a boolean.\"\"\"\n812 \n813         if not isinstance(obj.save_as, bool):\n814             return must_be(\"a boolean\", option=\"save_as\", obj=obj, id=\"admin.E101\")\n815         else:\n816             return []\n817 \n818     def _check_save_on_top(self, obj):\n819         \"\"\"Check save_on_top is a boolean.\"\"\"\n820 \n821         if not isinstance(obj.save_on_top, bool):\n822             return must_be(\"a boolean\", option=\"save_on_top\", obj=obj, id=\"admin.E102\")\n823         else:\n824             return []\n825 \n826     def _check_inlines(self, obj):\n827         \"\"\"Check all inline model admin classes.\"\"\"\n828 \n829         if not isinstance(obj.inlines, (list, tuple)):\n830             return must_be(\n831                 \"a list or tuple\", option=\"inlines\", obj=obj, id=\"admin.E103\"\n832             )\n833         else:\n834             return list(\n835                 chain.from_iterable(\n836                     self._check_inlines_item(obj, item, \"inlines[%d]\" % index)\n837                     for index, item in enumerate(obj.inlines)\n838                 )\n839             )\n840 \n841     def _check_inlines_item(self, obj, inline, label):\n842         \"\"\"Check one inline model admin.\"\"\"\n843         try:\n844             inline_label = inline.__module__ + \".\" + inline.__name__\n845         except AttributeError:\n846             return [\n847                 checks.Error(\n848                     \"'%s' must inherit from 'InlineModelAdmin'.\" % obj,\n849                     obj=obj.__class__,\n850                     id=\"admin.E104\",\n851                 )\n852             ]\n853 \n854         from django.contrib.admin.options import InlineModelAdmin\n855 \n856         if not _issubclass(inline, InlineModelAdmin):\n857             return [\n858                 checks.Error(\n859                     \"'%s' must inherit from 'InlineModelAdmin'.\" % inline_label,\n860                     obj=obj.__class__,\n861                     id=\"admin.E104\",\n862                 )\n863             ]\n864         elif not inline.model:\n865             return [\n866                 checks.Error(\n867                     \"'%s' must have a 'model' attribute.\" % inline_label,\n868                     obj=obj.__class__,\n869                     id=\"admin.E105\",\n870                 )\n871             ]\n872         elif not _issubclass(inline.model, models.Model):\n873             return must_be(\n874                 \"a Model\", option=\"%s.model\" % inline_label, obj=obj, id=\"admin.E106\"\n875             )\n876         else:\n877             return inline(obj.model, obj.admin_site).check()\n878 \n879     def _check_list_display(self, obj):\n880         \"\"\"Check that list_display only contains fields or usable attributes.\"\"\"\n881 \n882         if not isinstance(obj.list_display, (list, tuple)):\n883             return must_be(\n884                 \"a list or tuple\", option=\"list_display\", obj=obj, id=\"admin.E107\"\n885             )\n886         else:\n887             return list(\n888                 chain.from_iterable(\n889                     self._check_list_display_item(obj, item, \"list_display[%d]\" % index)\n890                     for index, item in enumerate(obj.list_display)\n891                 )\n892             )\n893 \n894     def _check_list_display_item(self, obj, item, label):\n895         if callable(item):\n896             return []\n897         elif hasattr(obj, item):\n898             return []\n899         try:\n900             field = obj.model._meta.get_field(item)\n901         except FieldDoesNotExist:\n902             try:\n903                 field = getattr(obj.model, item)\n904             except AttributeError:\n905                 return [\n906                     checks.Error(\n907                         \"The value of '%s' refers to '%s', which is not a \"\n908                         \"callable, an attribute of '%s', or an attribute or \"\n909                         \"method on '%s'.\"\n910                         % (\n911                             label,\n912                             item,\n913                             obj.__class__.__name__,\n914                             obj.model._meta.label,\n915                         ),\n916                         obj=obj.__class__,\n917                         id=\"admin.E108\",\n918                     )\n919                 ]\n920         if (\n921             getattr(field, \"is_relation\", False)\n922             and (field.many_to_many or field.one_to_many)\n923         ) or (getattr(field, \"rel\", None) and field.rel.field.many_to_one):\n924             return [\n925                 checks.Error(\n926                     f\"The value of '{label}' must not be a many-to-many field or a \"\n927                     f\"reverse foreign key.\",\n928                     obj=obj.__class__,\n929                     id=\"admin.E109\",\n930                 )\n931             ]\n932         return []\n933 \n934     def _check_list_display_links(self, obj):\n935         \"\"\"Check that list_display_links is a unique subset of list_display.\"\"\"\n936         from django.contrib.admin.options import ModelAdmin\n937 \n938         if obj.list_display_links is None:\n939             return []\n940         elif not isinstance(obj.list_display_links, (list, tuple)):\n941             return must_be(\n942                 \"a list, a tuple, or None\",\n943                 option=\"list_display_links\",\n944                 obj=obj,\n945                 id=\"admin.E110\",\n946             )\n947         # Check only if ModelAdmin.get_list_display() isn't overridden.\n948         elif obj.get_list_display.__func__ is ModelAdmin.get_list_display:\n949             return list(\n950                 chain.from_iterable(\n951                     self._check_list_display_links_item(\n952                         obj, field_name, \"list_display_links[%d]\" % index\n953                     )\n954                     for index, field_name in enumerate(obj.list_display_links)\n955                 )\n956             )\n957         return []\n958 \n959     def _check_list_display_links_item(self, obj, field_name, label):\n960         if field_name not in obj.list_display:\n961             return [\n962                 checks.Error(\n963                     \"The value of '%s' refers to '%s', which is not defined in \"\n964                     \"'list_display'.\" % (label, field_name),\n965                     obj=obj.__class__,\n966                     id=\"admin.E111\",\n967                 )\n968             ]\n969         else:\n970             return []\n971 \n972     def _check_list_filter(self, obj):\n973         if not isinstance(obj.list_filter, (list, tuple)):\n974             return must_be(\n975                 \"a list or tuple\", option=\"list_filter\", obj=obj, id=\"admin.E112\"\n976             )\n977         else:\n978             return list(\n979                 chain.from_iterable(\n980                     self._check_list_filter_item(obj, item, \"list_filter[%d]\" % index)\n981                     for index, item in enumerate(obj.list_filter)\n982                 )\n983             )\n984 \n985     def _check_list_filter_item(self, obj, item, label):\n986         \"\"\"\n987         Check one item of `list_filter`, i.e. check if it is one of three options:\n988         1. 'field' -- a basic field filter, possibly w/ relationships (e.g.\n989            'field__rel')\n990         2. ('field', SomeFieldListFilter) - a field-based list filter class\n991         3. SomeListFilter - a non-field list filter class\n992         \"\"\"\n993         from django.contrib.admin import FieldListFilter, ListFilter\n994 \n995         if callable(item) and not isinstance(item, models.Field):\n996             # If item is option 3, it should be a ListFilter...\n997             if not _issubclass(item, ListFilter):\n998                 return must_inherit_from(\n999                     parent=\"ListFilter\", option=label, obj=obj, id=\"admin.E113\"\n1000                 )\n1001             # ...  but not a FieldListFilter.\n1002             elif issubclass(item, FieldListFilter):\n1003                 return [\n1004                     checks.Error(\n1005                         \"The value of '%s' must not inherit from 'FieldListFilter'.\"\n1006                         % label,\n1007                         obj=obj.__class__,\n1008                         id=\"admin.E114\",\n1009                     )\n1010                 ]\n1011             else:\n1012                 return []\n1013         elif isinstance(item, (tuple, list)):\n1014             # item is option #2\n1015             field, list_filter_class = item\n1016             if not _issubclass(list_filter_class, FieldListFilter):\n1017                 return must_inherit_from(\n1018                     parent=\"FieldListFilter\",\n1019                     option=\"%s[1]\" % label,\n1020                     obj=obj,\n1021                     id=\"admin.E115\",\n1022                 )\n1023             else:\n1024                 return []\n1025         else:\n1026             # item is option #1\n1027             field = item\n1028 \n1029             # Validate the field string\n1030             try:\n1031                 get_fields_from_path(obj.model, field)\n1032             except (NotRelationField, FieldDoesNotExist):\n1033                 return [\n1034                     checks.Error(\n1035                         \"The value of '%s' refers to '%s', which does not refer to a \"\n1036                         \"Field.\" % (label, field),\n1037                         obj=obj.__class__,\n1038                         id=\"admin.E116\",\n1039                     )\n1040                 ]\n1041             else:\n1042                 return []\n1043 \n1044     def _check_list_select_related(self, obj):\n1045         \"\"\"Check that list_select_related is a boolean, a list or a tuple.\"\"\"\n1046 \n1047         if not isinstance(obj.list_select_related, (bool, list, tuple)):\n1048             return must_be(\n1049                 \"a boolean, tuple or list\",\n1050                 option=\"list_select_related\",\n1051                 obj=obj,\n1052                 id=\"admin.E117\",\n1053             )\n1054         else:\n1055             return []\n1056 \n1057     def _check_list_per_page(self, obj):\n1058         \"\"\"Check that list_per_page is an integer.\"\"\"\n1059 \n1060         if not isinstance(obj.list_per_page, int):\n1061             return must_be(\n1062                 \"an integer\", option=\"list_per_page\", obj=obj, id=\"admin.E118\"\n1063             )\n1064         else:\n1065             return []\n1066 \n1067     def _check_list_max_show_all(self, obj):\n1068         \"\"\"Check that list_max_show_all is an integer.\"\"\"\n1069 \n1070         if not isinstance(obj.list_max_show_all, int):\n1071             return must_be(\n1072                 \"an integer\", option=\"list_max_show_all\", obj=obj, id=\"admin.E119\"\n1073             )\n1074         else:\n1075             return []\n1076 \n1077     def _check_list_editable(self, obj):\n1078         \"\"\"Check that list_editable is a sequence of editable fields from\n1079         list_display without first element.\"\"\"\n1080 \n1081         if not isinstance(obj.list_editable, (list, tuple)):\n1082             return must_be(\n1083                 \"a list or tuple\", option=\"list_editable\", obj=obj, id=\"admin.E120\"\n1084             )\n1085         else:\n1086             return list(\n1087                 chain.from_iterable(\n1088                     self._check_list_editable_item(\n1089                         obj, item, \"list_editable[%d]\" % index\n1090                     )\n1091                     for index, item in enumerate(obj.list_editable)\n1092                 )\n1093             )\n1094 \n1095     def _check_list_editable_item(self, obj, field_name, label):\n1096         try:\n1097             field = obj.model._meta.get_field(field_name)\n1098         except FieldDoesNotExist:\n1099             return refer_to_missing_field(\n1100                 field=field_name, option=label, obj=obj, id=\"admin.E121\"\n1101             )\n1102         else:\n1103             if field_name not in obj.list_display:\n1104                 return [\n1105                     checks.Error(\n1106                         \"The value of '%s' refers to '%s', which is not \"\n1107                         \"contained in 'list_display'.\" % (label, field_name),\n1108                         obj=obj.__class__,\n1109                         id=\"admin.E122\",\n1110                     )\n1111                 ]\n1112             elif obj.list_display_links and field_name in obj.list_display_links:\n1113                 return [\n1114                     checks.Error(\n1115                         \"The value of '%s' cannot be in both 'list_editable' and \"\n1116                         \"'list_display_links'.\" % field_name,\n1117                         obj=obj.__class__,\n1118                         id=\"admin.E123\",\n1119                     )\n1120                 ]\n1121             # If list_display[0] is in list_editable, check that\n1122             # list_display_links is set. See #22792 and #26229 for use cases.\n1123             elif (\n1124                 obj.list_display[0] == field_name\n1125                 and not obj.list_display_links\n1126                 and obj.list_display_links is not None\n1127             ):\n1128                 return [\n1129                     checks.Error(\n1130                         \"The value of '%s' refers to the first field in 'list_display' \"\n1131                         \"('%s'), which cannot be used unless 'list_display_links' is \"\n1132                         \"set.\" % (label, obj.list_display[0]),\n1133                         obj=obj.__class__,\n1134                         id=\"admin.E124\",\n1135                     )\n1136                 ]\n1137             elif not field.editable or field.primary_key:\n1138                 return [\n1139                     checks.Error(\n1140                         \"The value of '%s' refers to '%s', which is not editable \"\n1141                         \"through the admin.\" % (label, field_name),\n1142                         obj=obj.__class__,\n1143                         id=\"admin.E125\",\n1144                     )\n1145                 ]\n1146             else:\n1147                 return []\n1148 \n1149     def _check_search_fields(self, obj):\n1150         \"\"\"Check search_fields is a sequence.\"\"\"\n1151 \n1152         if not isinstance(obj.search_fields, (list, tuple)):\n1153             return must_be(\n1154                 \"a list or tuple\", option=\"search_fields\", obj=obj, id=\"admin.E126\"\n1155             )\n1156         else:\n1157             return []\n1158 \n1159     def _check_date_hierarchy(self, obj):\n1160         \"\"\"Check that date_hierarchy refers to DateField or DateTimeField.\"\"\"\n1161 \n1162         if obj.date_hierarchy is None:\n1163             return []\n1164         else:\n1165             try:\n1166                 field = get_fields_from_path(obj.model, obj.date_hierarchy)[-1]\n1167             except (NotRelationField, FieldDoesNotExist):\n1168                 return [\n1169                     checks.Error(\n1170                         \"The value of 'date_hierarchy' refers to '%s', which \"\n1171                         \"does not refer to a Field.\" % obj.date_hierarchy,\n1172                         obj=obj.__class__,\n1173                         id=\"admin.E127\",\n1174                     )\n1175                 ]\n1176             else:\n1177                 if not isinstance(field, (models.DateField, models.DateTimeField)):\n1178                     return must_be(\n1179                         \"a DateField or DateTimeField\",\n1180                         option=\"date_hierarchy\",\n1181                         obj=obj,\n1182                         id=\"admin.E128\",\n1183                     )\n1184                 else:\n1185                     return []\n1186 \n1187     def _check_action_permission_methods(self, obj):\n1188         \"\"\"\n1189         Actions with an allowed_permission attribute require the ModelAdmin to\n1190         implement a has_<perm>_permission() method for each permission.\n1191         \"\"\"\n1192         actions = obj._get_base_actions()\n1193         errors = []\n1194         for func, name, _ in actions:\n1195             if not hasattr(func, \"allowed_permissions\"):\n1196                 continue\n1197             for permission in func.allowed_permissions:\n1198                 method_name = \"has_%s_permission\" % permission\n1199                 if not hasattr(obj, method_name):\n1200                     errors.append(\n1201                         checks.Error(\n1202                             \"%s must define a %s() method for the %s action.\"\n1203                             % (\n1204                                 obj.__class__.__name__,\n1205                                 method_name,\n1206                                 func.__name__,\n1207                             ),\n1208                             obj=obj.__class__,\n1209                             id=\"admin.E129\",\n1210                         )\n1211                     )\n1212         return errors\n1213 \n1214     def _check_actions_uniqueness(self, obj):\n1215         \"\"\"Check that every action has a unique __name__.\"\"\"\n1216         errors = []\n1217         names = collections.Counter(name for _, name, _ in obj._get_base_actions())\n1218         for name, count in names.items():\n1219             if count > 1:\n1220                 errors.append(\n1221                     checks.Error(\n1222                         \"__name__ attributes of actions defined in %s must be \"\n1223                         \"unique. Name %r is not unique.\"\n1224                         % (\n1225                             obj.__class__.__name__,\n1226                             name,\n1227                         ),\n1228                         obj=obj.__class__,\n1229                         id=\"admin.E130\",\n1230                     )\n1231                 )\n1232         return errors\n1233 \n1234 \n1235 class InlineModelAdminChecks(BaseModelAdminChecks):\n1236     def check(self, inline_obj, **kwargs):\n1237         parent_model = inline_obj.parent_model\n1238         return [\n1239             *super().check(inline_obj),\n1240             *self._check_relation(inline_obj, parent_model),\n1241             *self._check_exclude_of_parent_model(inline_obj, parent_model),\n1242             *self._check_extra(inline_obj),\n1243             *self._check_max_num(inline_obj),\n1244             *self._check_min_num(inline_obj),\n1245             *self._check_formset(inline_obj),\n1246         ]\n1247 \n1248     def _check_exclude_of_parent_model(self, obj, parent_model):\n1249         # Do not perform more specific checks if the base checks result in an\n1250         # error.\n1251         errors = super()._check_exclude(obj)\n1252         if errors:\n1253             return []\n1254 \n1255         # Skip if `fk_name` is invalid.\n1256         if self._check_relation(obj, parent_model):\n1257             return []\n1258 \n1259         if obj.exclude is None:\n1260             return []\n1261 \n1262         fk = _get_foreign_key(parent_model, obj.model, fk_name=obj.fk_name)\n1263         if fk.name in obj.exclude:\n1264             return [\n1265                 checks.Error(\n1266                     \"Cannot exclude the field '%s', because it is the foreign key \"\n1267                     \"to the parent model '%s'.\"\n1268                     % (\n1269                         fk.name,\n1270                         parent_model._meta.label,\n1271                     ),\n1272                     obj=obj.__class__,\n1273                     id=\"admin.E201\",\n1274                 )\n1275             ]\n1276         else:\n1277             return []\n1278 \n1279     def _check_relation(self, obj, parent_model):\n1280         try:\n1281             _get_foreign_key(parent_model, obj.model, fk_name=obj.fk_name)\n1282         except ValueError as e:\n1283             return [checks.Error(e.args[0], obj=obj.__class__, id=\"admin.E202\")]\n1284         else:\n1285             return []\n1286 \n1287     def _check_extra(self, obj):\n1288         \"\"\"Check that extra is an integer.\"\"\"\n1289 \n1290         if not isinstance(obj.extra, int):\n1291             return must_be(\"an integer\", option=\"extra\", obj=obj, id=\"admin.E203\")\n1292         else:\n1293             return []\n1294 \n1295     def _check_max_num(self, obj):\n1296         \"\"\"Check that max_num is an integer.\"\"\"\n1297 \n1298         if obj.max_num is None:\n1299             return []\n1300         elif not isinstance(obj.max_num, int):\n1301             return must_be(\"an integer\", option=\"max_num\", obj=obj, id=\"admin.E204\")\n1302         else:\n1303             return []\n1304 \n1305     def _check_min_num(self, obj):\n1306         \"\"\"Check that min_num is an integer.\"\"\"\n1307 \n1308         if obj.min_num is None:\n1309             return []\n1310         elif not isinstance(obj.min_num, int):\n1311             return must_be(\"an integer\", option=\"min_num\", obj=obj, id=\"admin.E205\")\n1312         else:\n1313             return []\n1314 \n1315     def _check_formset(self, obj):\n1316         \"\"\"Check formset is a subclass of BaseModelFormSet.\"\"\"\n1317 \n1318         if not _issubclass(obj.formset, BaseModelFormSet):\n1319             return must_inherit_from(\n1320                 parent=\"BaseModelFormSet\", option=\"formset\", obj=obj, id=\"admin.E206\"\n1321             )\n1322         else:\n1323             return []\n1324 \n1325 \n1326 def must_be(type, option, obj, id):\n1327     return [\n1328         checks.Error(\n1329             \"The value of '%s' must be %s.\" % (option, type),\n1330             obj=obj.__class__,\n1331             id=id,\n1332         ),\n1333     ]\n1334 \n1335 \n1336 def must_inherit_from(parent, option, obj, id):\n1337     return [\n1338         checks.Error(\n1339             \"The value of '%s' must inherit from '%s'.\" % (option, parent),\n1340             obj=obj.__class__,\n1341             id=id,\n1342         ),\n1343     ]\n1344 \n1345 \n1346 def refer_to_missing_field(field, option, obj, id):\n1347     return [\n1348         checks.Error(\n1349             \"The value of '%s' refers to '%s', which is not a field of '%s'.\"\n1350             % (option, field, obj.model._meta.label),\n1351             obj=obj.__class__,\n1352             id=id,\n1353         ),\n1354     ]\n",
        "intended_behavior": "The intended behavior here is to add a system check function that validates the usage of `filter_horizontal` and `filter_vertical` options within `ModelAdmin` configurations specifically for models having `ManyToManyField`s defined with a `through` parameter. This system check function would iterate through the model fields, identifying any `ManyToManyField` with a custom `through` model and check if `filter_horizontal` or `filter_vertical` is being used for such fields. If found, it should raise a warning or error, indicating that this configuration is not supported."
    },
    {
        "rel_file_path": "django/contrib/admin/options.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__5.0/django/contrib/admin/options.py",
        "start": 630,
        "end": 2303,
        "class_name": "ModelAdmin",
        "method_name": null,
        "code": "630 class ModelAdmin(BaseModelAdmin):\n631     \"\"\"Encapsulate all admin options and functionality for a given model.\"\"\"\n632 \n633     list_display = (\"__str__\",)\n634     list_display_links = ()\n635     list_filter = ()\n636     list_select_related = False\n637     list_per_page = 100\n638     list_max_show_all = 200\n639     list_editable = ()\n640     search_fields = ()\n641     search_help_text = None\n642     date_hierarchy = None\n643     save_as = False\n644     save_as_continue = True\n645     save_on_top = False\n646     paginator = Paginator\n647     preserve_filters = True\n648     show_facets = ShowFacets.ALLOW\n649     inlines = ()\n650 \n651     # Custom templates (designed to be over-ridden in subclasses)\n652     add_form_template = None\n653     change_form_template = None\n654     change_list_template = None\n655     delete_confirmation_template = None\n656     delete_selected_confirmation_template = None\n657     object_history_template = None\n658     popup_response_template = None\n659 \n660     # Actions\n661     actions = ()\n662     action_form = helpers.ActionForm\n663     actions_on_top = True\n664     actions_on_bottom = False\n665     actions_selection_counter = True\n666     checks_class = ModelAdminChecks\n667 \n668     def __init__(self, model, admin_site):\n669         self.model = model\n670         self.opts = model._meta\n671         self.admin_site = admin_site\n672         super().__init__()\n673 \n674     def __str__(self):\n675         return \"%s.%s\" % (self.opts.app_label, self.__class__.__name__)\n676 \n677     def __repr__(self):\n678         return (\n679             f\"<{self.__class__.__qualname__}: model={self.model.__qualname__} \"\n680             f\"site={self.admin_site!r}>\"\n681         )\n682 \n683     def get_inline_instances(self, request, obj=None):\n684         inline_instances = []\n685         for inline_class in self.get_inlines(request, obj):\n686             inline = inline_class(self.model, self.admin_site)\n687             if request:\n688                 if not (\n689                     inline.has_view_or_change_permission(request, obj)\n690                     or inline.has_add_permission(request, obj)\n691                     or inline.has_delete_permission(request, obj)\n692                 ):\n693                     continue\n694                 if not inline.has_add_permission(request, obj):\n695                     inline.max_num = 0\n696             inline_instances.append(inline)\n697 \n698         return inline_instances\n699 \n700     def get_urls(self):\n701         from django.urls import path\n702 \n703         def wrap(view):\n704             def wrapper(*args, **kwargs):\n705                 return self.admin_site.admin_view(view)(*args, **kwargs)\n706 \n707             wrapper.model_admin = self\n708             return update_wrapper(wrapper, view)\n709 \n710         info = self.opts.app_label, self.opts.model_name\n711 \n712         return [\n713             path(\"\", wrap(self.changelist_view), name=\"%s_%s_changelist\" % info),\n714             path(\"add/\", wrap(self.add_view), name=\"%s_%s_add\" % info),\n715             path(\n716                 \"<path:object_id>/history/\",\n717                 wrap(self.history_view),\n718                 name=\"%s_%s_history\" % info,\n719             ),\n720             path(\n721                 \"<path:object_id>/delete/\",\n722                 wrap(self.delete_view),\n723                 name=\"%s_%s_delete\" % info,\n724             ),\n725             path(\n726                 \"<path:object_id>/change/\",\n727                 wrap(self.change_view),\n728                 name=\"%s_%s_change\" % info,\n729             ),\n730             # For backwards compatibility (was the change url before 1.9)\n731             path(\n732                 \"<path:object_id>/\",\n733                 wrap(\n734                     RedirectView.as_view(\n735                         pattern_name=\"%s:%s_%s_change\"\n736                         % ((self.admin_site.name,) + info)\n737                     )\n738                 ),\n739             ),\n740         ]\n741 \n742     @property\n743     def urls(self):\n744         return self.get_urls()\n745 \n746     @property\n747     def media(self):\n748         extra = \"\" if settings.DEBUG else \".min\"\n749         js = [\n750             \"vendor/jquery/jquery%s.js\" % extra,\n751             \"jquery.init.js\",\n752             \"core.js\",\n753             \"admin/RelatedObjectLookups.js\",\n754             \"actions.js\",\n755             \"urlify.js\",\n756             \"prepopulate.js\",\n757             \"vendor/xregexp/xregexp%s.js\" % extra,\n758         ]\n759         return forms.Media(js=[\"admin/js/%s\" % url for url in js])\n760 \n761     def get_model_perms(self, request):\n762         \"\"\"\n763         Return a dict of all perms for this model. This dict has the keys\n764         ``add``, ``change``, ``delete``, and ``view`` mapping to the True/False\n765         for each of those actions.\n766         \"\"\"\n767         return {\n768             \"add\": self.has_add_permission(request),\n769             \"change\": self.has_change_permission(request),\n770             \"delete\": self.has_delete_permission(request),\n771             \"view\": self.has_view_permission(request),\n772         }\n773 \n774     def _get_form_for_get_fields(self, request, obj):\n775         return self.get_form(request, obj, fields=None)\n776 \n777     def get_form(self, request, obj=None, change=False, **kwargs):\n778         \"\"\"\n779         Return a Form class for use in the admin add view. This is used by\n780         add_view and change_view.\n781         \"\"\"\n782         if \"fields\" in kwargs:\n783             fields = kwargs.pop(\"fields\")\n784         else:\n785             fields = flatten_fieldsets(self.get_fieldsets(request, obj))\n786         excluded = self.get_exclude(request, obj)\n787         exclude = [] if excluded is None else list(excluded)\n788         readonly_fields = self.get_readonly_fields(request, obj)\n789         exclude.extend(readonly_fields)\n790         # Exclude all fields if it's a change form and the user doesn't have\n791         # the change permission.\n792         if (\n793             change\n794             and hasattr(request, \"user\")\n795             and not self.has_change_permission(request, obj)\n796         ):\n797             exclude.extend(fields)\n798         if excluded is None and hasattr(self.form, \"_meta\") and self.form._meta.exclude:\n799             # Take the custom ModelForm's Meta.exclude into account only if the\n800             # ModelAdmin doesn't define its own.\n801             exclude.extend(self.form._meta.exclude)\n802         # if exclude is an empty list we pass None to be consistent with the\n803         # default on modelform_factory\n804         exclude = exclude or None\n805 \n806         # Remove declared form fields which are in readonly_fields.\n807         new_attrs = dict.fromkeys(\n808             f for f in readonly_fields if f in self.form.declared_fields\n809         )\n810         form = type(self.form.__name__, (self.form,), new_attrs)\n811 \n812         defaults = {\n813             \"form\": form,\n814             \"fields\": fields,\n815             \"exclude\": exclude,\n816             \"formfield_callback\": partial(self.formfield_for_dbfield, request=request),\n817             **kwargs,\n818         }\n819 \n820         if defaults[\"fields\"] is None and not modelform_defines_fields(\n821             defaults[\"form\"]\n822         ):\n823             defaults[\"fields\"] = forms.ALL_FIELDS\n824 \n825         try:\n826             return modelform_factory(self.model, **defaults)\n827         except FieldError as e:\n828             raise FieldError(\n829                 \"%s. Check fields/fieldsets/exclude attributes of class %s.\"\n830                 % (e, self.__class__.__name__)\n831             )\n832 \n833     def get_changelist(self, request, **kwargs):\n834         \"\"\"\n835         Return the ChangeList class for use on the changelist page.\n836         \"\"\"\n837         from django.contrib.admin.views.main import ChangeList\n838 \n839         return ChangeList\n840 \n841     def get_changelist_instance(self, request):\n842         \"\"\"\n843         Return a `ChangeList` instance based on `request`. May raise\n844         `IncorrectLookupParameters`.\n845         \"\"\"\n846         list_display = self.get_list_display(request)\n847         list_display_links = self.get_list_display_links(request, list_display)\n848         # Add the action checkboxes if any actions are available.\n849         if self.get_actions(request):\n850             list_display = [\"action_checkbox\", *list_display]\n851         sortable_by = self.get_sortable_by(request)\n852         ChangeList = self.get_changelist(request)\n853         return ChangeList(\n854             request,\n855             self.model,\n856             list_display,\n857             list_display_links,\n858             self.get_list_filter(request),\n859             self.date_hierarchy,\n860             self.get_search_fields(request),\n861             self.get_list_select_related(request),\n862             self.list_per_page,\n863             self.list_max_show_all,\n864             self.list_editable,\n865             self,\n866             sortable_by,\n867             self.search_help_text,\n868         )\n869 \n870     def get_object(self, request, object_id, from_field=None):\n871         \"\"\"\n872         Return an instance matching the field and value provided, the primary\n873         key is used if no field is provided. Return ``None`` if no match is\n874         found or the object_id fails validation.\n875         \"\"\"\n876         queryset = self.get_queryset(request)\n877         model = queryset.model\n878         field = (\n879             model._meta.pk if from_field is None else model._meta.get_field(from_field)\n880         )\n881         try:\n882             object_id = field.to_python(object_id)\n883             return queryset.get(**{field.name: object_id})\n884         except (model.DoesNotExist, ValidationError, ValueError):\n885             return None\n886 \n887     def get_changelist_form(self, request, **kwargs):\n888         \"\"\"\n889         Return a Form class for use in the Formset on the changelist page.\n890         \"\"\"\n891         defaults = {\n892             \"formfield_callback\": partial(self.formfield_for_dbfield, request=request),\n893             **kwargs,\n894         }\n895         if defaults.get(\"fields\") is None and not modelform_defines_fields(\n896             defaults.get(\"form\")\n897         ):\n898             defaults[\"fields\"] = forms.ALL_FIELDS\n899 \n900         return modelform_factory(self.model, **defaults)\n901 \n902     def get_changelist_formset(self, request, **kwargs):\n903         \"\"\"\n904         Return a FormSet class for use on the changelist page if list_editable\n905         is used.\n906         \"\"\"\n907         defaults = {\n908             \"formfield_callback\": partial(self.formfield_for_dbfield, request=request),\n909             **kwargs,\n910         }\n911         return modelformset_factory(\n912             self.model,\n913             self.get_changelist_form(request),\n914             extra=0,\n915             fields=self.list_editable,\n916             **defaults,\n917         )\n918 \n919     def get_formsets_with_inlines(self, request, obj=None):\n920         \"\"\"\n921         Yield formsets and the corresponding inlines.\n922         \"\"\"\n923         for inline in self.get_inline_instances(request, obj):\n924             yield inline.get_formset(request, obj), inline\n925 \n926     def get_paginator(\n927         self, request, queryset, per_page, orphans=0, allow_empty_first_page=True\n928     ):\n929         return self.paginator(queryset, per_page, orphans, allow_empty_first_page)\n930 \n931     def log_addition(self, request, obj, message):\n932         \"\"\"\n933         Log that an object has been successfully added.\n934 \n935         The default implementation creates an admin LogEntry object.\n936         \"\"\"\n937         from django.contrib.admin.models import ADDITION, LogEntry\n938 \n939         return LogEntry.objects.log_action(\n940             user_id=request.user.pk,\n941             content_type_id=get_content_type_for_model(obj).pk,\n942             object_id=obj.pk,\n943             object_repr=str(obj),\n944             action_flag=ADDITION,\n945             change_message=message,\n946         )\n947 \n948     def log_change(self, request, obj, message):\n949         \"\"\"\n950         Log that an object has been successfully changed.\n951 \n952         The default implementation creates an admin LogEntry object.\n953         \"\"\"\n954         from django.contrib.admin.models import CHANGE, LogEntry\n955 \n956         return LogEntry.objects.log_action(\n957             user_id=request.user.pk,\n958             content_type_id=get_content_type_for_model(obj).pk,\n959             object_id=obj.pk,\n960             object_repr=str(obj),\n961             action_flag=CHANGE,\n962             change_message=message,\n963         )\n964 \n965     def log_deletion(self, request, obj, object_repr):\n966         \"\"\"\n967         Log that an object will be deleted. Note that this method must be\n968         called before the deletion.\n969 \n970         The default implementation creates an admin LogEntry object.\n971         \"\"\"\n972         from django.contrib.admin.models import DELETION, LogEntry\n973 \n974         return LogEntry.objects.log_action(\n975             user_id=request.user.pk,\n976             content_type_id=get_content_type_for_model(obj).pk,\n977             object_id=obj.pk,\n978             object_repr=object_repr,\n979             action_flag=DELETION,\n980         )\n981 \n982     def action_checkbox(self, obj):\n983         \"\"\"\n984         A list_display column containing a checkbox widget.\n985         \"\"\"\n986         attrs = {\n987             \"class\": \"action-select\",\n988             \"aria-label\": format_html(_(\"Select this object for an action - {}\"), obj),\n989         }\n990         checkbox = forms.CheckboxInput(attrs, lambda value: False)\n991         return checkbox.render(helpers.ACTION_CHECKBOX_NAME, str(obj.pk))\n992 \n993     @staticmethod\n994     def _get_action_description(func, name):\n995         return getattr(func, \"short_description\", capfirst(name.replace(\"_\", \" \")))\n996 \n997     def _get_base_actions(self):\n998         \"\"\"Return the list of actions, prior to any request-based filtering.\"\"\"\n999         actions = []\n1000         base_actions = (self.get_action(action) for action in self.actions or [])\n1001         # get_action might have returned None, so filter any of those out.\n1002         base_actions = [action for action in base_actions if action]\n1003         base_action_names = {name for _, name, _ in base_actions}\n1004 \n1005         # Gather actions from the admin site first\n1006         for name, func in self.admin_site.actions:\n1007             if name in base_action_names:\n1008                 continue\n1009             description = self._get_action_description(func, name)\n1010             actions.append((func, name, description))\n1011         # Add actions from this ModelAdmin.\n1012         actions.extend(base_actions)\n1013         return actions\n1014 \n1015     def _filter_actions_by_permissions(self, request, actions):\n1016         \"\"\"Filter out any actions that the user doesn't have access to.\"\"\"\n1017         filtered_actions = []\n1018         for action in actions:\n1019             callable = action[0]\n1020             if not hasattr(callable, \"allowed_permissions\"):\n1021                 filtered_actions.append(action)\n1022                 continue\n1023             permission_checks = (\n1024                 getattr(self, \"has_%s_permission\" % permission)\n1025                 for permission in callable.allowed_permissions\n1026             )\n1027             if any(has_permission(request) for has_permission in permission_checks):\n1028                 filtered_actions.append(action)\n1029         return filtered_actions\n1030 \n1031     def get_actions(self, request):\n1032         \"\"\"\n1033         Return a dictionary mapping the names of all actions for this\n1034         ModelAdmin to a tuple of (callable, name, description) for each action.\n1035         \"\"\"\n1036         # If self.actions is set to None that means actions are disabled on\n1037         # this page.\n1038         if self.actions is None or IS_POPUP_VAR in request.GET:\n1039             return {}\n1040         actions = self._filter_actions_by_permissions(request, self._get_base_actions())\n1041         return {name: (func, name, desc) for func, name, desc in actions}\n1042 \n1043     def get_action_choices(self, request, default_choices=models.BLANK_CHOICE_DASH):\n1044         \"\"\"\n1045         Return a list of choices for use in a form object.  Each choice is a\n1046         tuple (name, description).\n1047         \"\"\"\n1048         choices = [] + default_choices\n1049         for func, name, description in self.get_actions(request).values():\n1050             choice = (name, description % model_format_dict(self.opts))\n1051             choices.append(choice)\n1052         return choices\n1053 \n1054     def get_action(self, action):\n1055         \"\"\"\n1056         Return a given action from a parameter, which can either be a callable,\n1057         or the name of a method on the ModelAdmin.  Return is a tuple of\n1058         (callable, name, description).\n1059         \"\"\"\n1060         # If the action is a callable, just use it.\n1061         if callable(action):\n1062             func = action\n1063             action = action.__name__\n1064 \n1065         # Next, look for a method. Grab it off self.__class__ to get an unbound\n1066         # method instead of a bound one; this ensures that the calling\n1067         # conventions are the same for functions and methods.\n1068         elif hasattr(self.__class__, action):\n1069             func = getattr(self.__class__, action)\n1070 \n1071         # Finally, look for a named method on the admin site\n1072         else:\n1073             try:\n1074                 func = self.admin_site.get_action(action)\n1075             except KeyError:\n1076                 return None\n1077 \n1078         description = self._get_action_description(func, action)\n1079         return func, action, description\n1080 \n1081     def get_list_display(self, request):\n1082         \"\"\"\n1083         Return a sequence containing the fields to be displayed on the\n1084         changelist.\n1085         \"\"\"\n1086         return self.list_display\n1087 \n1088     def get_list_display_links(self, request, list_display):\n1089         \"\"\"\n1090         Return a sequence containing the fields to be displayed as links\n1091         on the changelist. The list_display parameter is the list of fields\n1092         returned by get_list_display().\n1093         \"\"\"\n1094         if (\n1095             self.list_display_links\n1096             or self.list_display_links is None\n1097             or not list_display\n1098         ):\n1099             return self.list_display_links\n1100         else:\n1101             # Use only the first item in list_display as link\n1102             return list(list_display)[:1]\n1103 \n1104     def get_list_filter(self, request):\n1105         \"\"\"\n1106         Return a sequence containing the fields to be displayed as filters in\n1107         the right sidebar of the changelist page.\n1108         \"\"\"\n1109         return self.list_filter\n1110 \n1111     def get_list_select_related(self, request):\n1112         \"\"\"\n1113         Return a list of fields to add to the select_related() part of the\n1114         changelist items query.\n1115         \"\"\"\n1116         return self.list_select_related\n1117 \n1118     def get_search_fields(self, request):\n1119         \"\"\"\n1120         Return a sequence containing the fields to be searched whenever\n1121         somebody submits a search query.\n1122         \"\"\"\n1123         return self.search_fields\n1124 \n1125     def get_search_results(self, request, queryset, search_term):\n1126         \"\"\"\n1127         Return a tuple containing a queryset to implement the search\n1128         and a boolean indicating if the results may contain duplicates.\n1129         \"\"\"\n1130 \n1131         # Apply keyword searches.\n1132         def construct_search(field_name):\n1133             if field_name.startswith(\"^\"):\n1134                 return \"%s__istartswith\" % field_name.removeprefix(\"^\")\n1135             elif field_name.startswith(\"=\"):\n1136                 return \"%s__iexact\" % field_name.removeprefix(\"=\")\n1137             elif field_name.startswith(\"@\"):\n1138                 return \"%s__search\" % field_name.removeprefix(\"@\")\n1139             # Use field_name if it includes a lookup.\n1140             opts = queryset.model._meta\n1141             lookup_fields = field_name.split(LOOKUP_SEP)\n1142             # Go through the fields, following all relations.\n1143             prev_field = None\n1144             for path_part in lookup_fields:\n1145                 if path_part == \"pk\":\n1146                     path_part = opts.pk.name\n1147                 try:\n1148                     field = opts.get_field(path_part)\n1149                 except FieldDoesNotExist:\n1150                     # Use valid query lookups.\n1151                     if prev_field and prev_field.get_lookup(path_part):\n1152                         return field_name\n1153                 else:\n1154                     prev_field = field\n1155                     if hasattr(field, \"path_infos\"):\n1156                         # Update opts to follow the relation.\n1157                         opts = field.path_infos[-1].to_opts\n1158             # Otherwise, use the field with icontains.\n1159             return \"%s__icontains\" % field_name\n1160 \n1161         may_have_duplicates = False\n1162         search_fields = self.get_search_fields(request)\n1163         if search_fields and search_term:\n1164             orm_lookups = [\n1165                 construct_search(str(search_field)) for search_field in search_fields\n1166             ]\n1167             term_queries = []\n1168             for bit in smart_split(search_term):\n1169                 if bit.startswith(('\"', \"'\")) and bit[0] == bit[-1]:\n1170                     bit = unescape_string_literal(bit)\n1171                 or_queries = models.Q.create(\n1172                     [(orm_lookup, bit) for orm_lookup in orm_lookups],\n1173                     connector=models.Q.OR,\n1174                 )\n1175                 term_queries.append(or_queries)\n1176             queryset = queryset.filter(models.Q.create(term_queries))\n1177             may_have_duplicates |= any(\n1178                 lookup_spawns_duplicates(self.opts, search_spec)\n1179                 for search_spec in orm_lookups\n1180             )\n1181         return queryset, may_have_duplicates\n1182 \n1183     def get_preserved_filters(self, request):\n1184         \"\"\"\n1185         Return the preserved filters querystring.\n1186         \"\"\"\n1187         match = request.resolver_match\n1188         if self.preserve_filters and match:\n1189             current_url = \"%s:%s\" % (match.app_name, match.url_name)\n1190             changelist_url = \"admin:%s_%s_changelist\" % (\n1191                 self.opts.app_label,\n1192                 self.opts.model_name,\n1193             )\n1194             if current_url == changelist_url:\n1195                 preserved_filters = request.GET.urlencode()\n1196             else:\n1197                 preserved_filters = request.GET.get(\"_changelist_filters\")\n1198 \n1199             if preserved_filters:\n1200                 return urlencode({\"_changelist_filters\": preserved_filters})\n1201         return \"\"\n1202 \n1203     def construct_change_message(self, request, form, formsets, add=False):\n1204         \"\"\"\n1205         Construct a JSON structure describing changes from a changed object.\n1206         \"\"\"\n1207         return construct_change_message(form, formsets, add)\n1208 \n1209     def message_user(\n1210         self, request, message, level=messages.INFO, extra_tags=\"\", fail_silently=False\n1211     ):\n1212         \"\"\"\n1213         Send a message to the user. The default implementation\n1214         posts a message using the django.contrib.messages backend.\n1215 \n1216         Exposes almost the same API as messages.add_message(), but accepts the\n1217         positional arguments in a different order to maintain backwards\n1218         compatibility. For convenience, it accepts the `level` argument as\n1219         a string rather than the usual level number.\n1220         \"\"\"\n1221         if not isinstance(level, int):\n1222             # attempt to get the level if passed a string\n1223             try:\n1224                 level = getattr(messages.constants, level.upper())\n1225             except AttributeError:\n1226                 levels = messages.constants.DEFAULT_TAGS.values()\n1227                 levels_repr = \", \".join(\"`%s`\" % level for level in levels)\n1228                 raise ValueError(\n1229                     \"Bad message level string: `%s`. Possible values are: %s\"\n1230                     % (level, levels_repr)\n1231                 )\n1232 \n1233         messages.add_message(\n1234             request, level, message, extra_tags=extra_tags, fail_silently=fail_silently\n1235         )\n1236 \n1237     def save_form(self, request, form, change):\n1238         \"\"\"\n1239         Given a ModelForm return an unsaved instance. ``change`` is True if\n1240         the object is being changed, and False if it's being added.\n1241         \"\"\"\n1242         return form.save(commit=False)\n1243 \n1244     def save_model(self, request, obj, form, change):\n1245         \"\"\"\n1246         Given a model instance save it to the database.\n1247         \"\"\"\n1248         obj.save()\n1249 \n1250     def delete_model(self, request, obj):\n1251         \"\"\"\n1252         Given a model instance delete it from the database.\n1253         \"\"\"\n1254         obj.delete()\n1255 \n1256     def delete_queryset(self, request, queryset):\n1257         \"\"\"Given a queryset, delete it from the database.\"\"\"\n1258         queryset.delete()\n1259 \n1260     def save_formset(self, request, form, formset, change):\n1261         \"\"\"\n1262         Given an inline formset save it to the database.\n1263         \"\"\"\n1264         formset.save()\n1265 \n1266     def save_related(self, request, form, formsets, change):\n1267         \"\"\"\n1268         Given the ``HttpRequest``, the parent ``ModelForm`` instance, the\n1269         list of inline formsets and a boolean value based on whether the\n1270         parent is being added or changed, save the related objects to the\n1271         database. Note that at this point save_form() and save_model() have\n1272         already been called.\n1273         \"\"\"\n1274         form.save_m2m()\n1275         for formset in formsets:\n1276             self.save_formset(request, form, formset, change=change)\n1277 \n1278     def render_change_form(\n1279         self, request, context, add=False, change=False, form_url=\"\", obj=None\n1280     ):\n1281         app_label = self.opts.app_label\n1282         preserved_filters = self.get_preserved_filters(request)\n1283         form_url = add_preserved_filters(\n1284             {\"preserved_filters\": preserved_filters, \"opts\": self.opts}, form_url\n1285         )\n1286         view_on_site_url = self.get_view_on_site_url(obj)\n1287         has_editable_inline_admin_formsets = False\n1288         for inline in context[\"inline_admin_formsets\"]:\n1289             if (\n1290                 inline.has_add_permission\n1291                 or inline.has_change_permission\n1292                 or inline.has_delete_permission\n1293             ):\n1294                 has_editable_inline_admin_formsets = True\n1295                 break\n1296         context.update(\n1297             {\n1298                 \"add\": add,\n1299                 \"change\": change,\n1300                 \"has_view_permission\": self.has_view_permission(request, obj),\n1301                 \"has_add_permission\": self.has_add_permission(request),\n1302                 \"has_change_permission\": self.has_change_permission(request, obj),\n1303                 \"has_delete_permission\": self.has_delete_permission(request, obj),\n1304                 \"has_editable_inline_admin_formsets\": (\n1305                     has_editable_inline_admin_formsets\n1306                 ),\n1307                 \"has_file_field\": context[\"adminform\"].form.is_multipart()\n1308                 or any(\n1309                     admin_formset.formset.is_multipart()\n1310                     for admin_formset in context[\"inline_admin_formsets\"]\n1311                 ),\n1312                 \"has_absolute_url\": view_on_site_url is not None,\n1313                 \"absolute_url\": view_on_site_url,\n1314                 \"form_url\": form_url,\n1315                 \"opts\": self.opts,\n1316                 \"content_type_id\": get_content_type_for_model(self.model).pk,\n1317                 \"save_as\": self.save_as,\n1318                 \"save_on_top\": self.save_on_top,\n1319                 \"to_field_var\": TO_FIELD_VAR,\n1320                 \"is_popup_var\": IS_POPUP_VAR,\n1321                 \"app_label\": app_label,\n1322             }\n1323         )\n1324         if add and self.add_form_template is not None:\n1325             form_template = self.add_form_template\n1326         else:\n1327             form_template = self.change_form_template\n1328 \n1329         request.current_app = self.admin_site.name\n1330 \n1331         return TemplateResponse(\n1332             request,\n1333             form_template\n1334             or [\n1335                 \"admin/%s/%s/change_form.html\" % (app_label, self.opts.model_name),\n1336                 \"admin/%s/change_form.html\" % app_label,\n1337                 \"admin/change_form.html\",\n1338             ],\n1339             context,\n1340         )\n1341 \n1342     def response_add(self, request, obj, post_url_continue=None):\n1343         \"\"\"\n1344         Determine the HttpResponse for the add_view stage.\n1345         \"\"\"\n1346         opts = obj._meta\n1347         preserved_filters = self.get_preserved_filters(request)\n1348         obj_url = reverse(\n1349             \"admin:%s_%s_change\" % (opts.app_label, opts.model_name),\n1350             args=(quote(obj.pk),),\n1351             current_app=self.admin_site.name,\n1352         )\n1353         # Add a link to the object's change form if the user can edit the obj.\n1354         if self.has_change_permission(request, obj):\n1355             obj_repr = format_html('<a href=\"{}\">{}</a>', urlquote(obj_url), obj)\n1356         else:\n1357             obj_repr = str(obj)\n1358         msg_dict = {\n1359             \"name\": opts.verbose_name,\n1360             \"obj\": obj_repr,\n1361         }\n1362         # Here, we distinguish between different save types by checking for\n1363         # the presence of keys in request.POST.\n1364 \n1365         if IS_POPUP_VAR in request.POST:\n1366             to_field = request.POST.get(TO_FIELD_VAR)\n1367             if to_field:\n1368                 attr = str(to_field)\n1369             else:\n1370                 attr = obj._meta.pk.attname\n1371             value = obj.serializable_value(attr)\n1372             popup_response_data = json.dumps(\n1373                 {\n1374                     \"value\": str(value),\n1375                     \"obj\": str(obj),\n1376                 }\n1377             )\n1378             return TemplateResponse(\n1379                 request,\n1380                 self.popup_response_template\n1381                 or [\n1382                     \"admin/%s/%s/popup_response.html\"\n1383                     % (opts.app_label, opts.model_name),\n1384                     \"admin/%s/popup_response.html\" % opts.app_label,\n1385                     \"admin/popup_response.html\",\n1386                 ],\n1387                 {\n1388                     \"popup_response_data\": popup_response_data,\n1389                 },\n1390             )\n1391 \n1392         elif \"_continue\" in request.POST or (\n1393             # Redirecting after \"Save as new\".\n1394             \"_saveasnew\" in request.POST\n1395             and self.save_as_continue\n1396             and self.has_change_permission(request, obj)\n1397         ):\n1398             msg = _(\"The {name} \u201c{obj}\u201d was added successfully.\")\n1399             if self.has_change_permission(request, obj):\n1400                 msg += \" \" + _(\"You may edit it again below.\")\n1401             self.message_user(request, format_html(msg, **msg_dict), messages.SUCCESS)\n1402             if post_url_continue is None:\n1403                 post_url_continue = obj_url\n1404             post_url_continue = add_preserved_filters(\n1405                 {\"preserved_filters\": preserved_filters, \"opts\": opts},\n1406                 post_url_continue,\n1407             )\n1408             return HttpResponseRedirect(post_url_continue)\n1409 \n1410         elif \"_addanother\" in request.POST:\n1411             msg = format_html(\n1412                 _(\n1413                     \"The {name} \u201c{obj}\u201d was added successfully. You may add another \"\n1414                     \"{name} below.\"\n1415                 ),\n1416                 **msg_dict,\n1417             )\n1418             self.message_user(request, msg, messages.SUCCESS)\n1419             redirect_url = request.path\n1420             redirect_url = add_preserved_filters(\n1421                 {\"preserved_filters\": preserved_filters, \"opts\": opts}, redirect_url\n1422             )\n1423             return HttpResponseRedirect(redirect_url)\n1424 \n1425         else:\n1426             msg = format_html(\n1427                 _(\"The {name} \u201c{obj}\u201d was added successfully.\"), **msg_dict\n1428             )\n1429             self.message_user(request, msg, messages.SUCCESS)\n1430             return self.response_post_save_add(request, obj)\n1431 \n1432     def response_change(self, request, obj):\n1433         \"\"\"\n1434         Determine the HttpResponse for the change_view stage.\n1435         \"\"\"\n1436 \n1437         if IS_POPUP_VAR in request.POST:\n1438             opts = obj._meta\n1439             to_field = request.POST.get(TO_FIELD_VAR)\n1440             attr = str(to_field) if to_field else opts.pk.attname\n1441             value = request.resolver_match.kwargs[\"object_id\"]\n1442             new_value = obj.serializable_value(attr)\n1443             popup_response_data = json.dumps(\n1444                 {\n1445                     \"action\": \"change\",\n1446                     \"value\": str(value),\n1447                     \"obj\": str(obj),\n1448                     \"new_value\": str(new_value),\n1449                 }\n1450             )\n1451             return TemplateResponse(\n1452                 request,\n1453                 self.popup_response_template\n1454                 or [\n1455                     \"admin/%s/%s/popup_response.html\"\n1456                     % (opts.app_label, opts.model_name),\n1457                     \"admin/%s/popup_response.html\" % opts.app_label,\n1458                     \"admin/popup_response.html\",\n1459                 ],\n1460                 {\n1461                     \"popup_response_data\": popup_response_data,\n1462                 },\n1463             )\n1464 \n1465         opts = self.opts\n1466         preserved_filters = self.get_preserved_filters(request)\n1467 \n1468         msg_dict = {\n1469             \"name\": opts.verbose_name,\n1470             \"obj\": format_html('<a href=\"{}\">{}</a>', urlquote(request.path), obj),\n1471         }\n1472         if \"_continue\" in request.POST:\n1473             msg = format_html(\n1474                 _(\n1475                     \"The {name} \u201c{obj}\u201d was changed successfully. You may edit it \"\n1476                     \"again below.\"\n1477                 ),\n1478                 **msg_dict,\n1479             )\n1480             self.message_user(request, msg, messages.SUCCESS)\n1481             redirect_url = request.path\n1482             redirect_url = add_preserved_filters(\n1483                 {\"preserved_filters\": preserved_filters, \"opts\": opts}, redirect_url\n1484             )\n1485             return HttpResponseRedirect(redirect_url)\n1486 \n1487         elif \"_saveasnew\" in request.POST:\n1488             msg = format_html(\n1489                 _(\n1490                     \"The {name} \u201c{obj}\u201d was added successfully. You may edit it again \"\n1491                     \"below.\"\n1492                 ),\n1493                 **msg_dict,\n1494             )\n1495             self.message_user(request, msg, messages.SUCCESS)\n1496             redirect_url = reverse(\n1497                 \"admin:%s_%s_change\" % (opts.app_label, opts.model_name),\n1498                 args=(obj.pk,),\n1499                 current_app=self.admin_site.name,\n1500             )\n1501             redirect_url = add_preserved_filters(\n1502                 {\"preserved_filters\": preserved_filters, \"opts\": opts}, redirect_url\n1503             )\n1504             return HttpResponseRedirect(redirect_url)\n1505 \n1506         elif \"_addanother\" in request.POST:\n1507             msg = format_html(\n1508                 _(\n1509                     \"The {name} \u201c{obj}\u201d was changed successfully. You may add another \"\n1510                     \"{name} below.\"\n1511                 ),\n1512                 **msg_dict,\n1513             )\n1514             self.message_user(request, msg, messages.SUCCESS)\n1515             redirect_url = reverse(\n1516                 \"admin:%s_%s_add\" % (opts.app_label, opts.model_name),\n1517                 current_app=self.admin_site.name,\n1518             )\n1519             redirect_url = add_preserved_filters(\n1520                 {\"preserved_filters\": preserved_filters, \"opts\": opts}, redirect_url\n1521             )\n1522             return HttpResponseRedirect(redirect_url)\n1523 \n1524         else:\n1525             msg = format_html(\n1526                 _(\"The {name} \u201c{obj}\u201d was changed successfully.\"), **msg_dict\n1527             )\n1528             self.message_user(request, msg, messages.SUCCESS)\n1529             return self.response_post_save_change(request, obj)\n1530 \n1531     def _response_post_save(self, request, obj):\n1532         if self.has_view_or_change_permission(request):\n1533             post_url = reverse(\n1534                 \"admin:%s_%s_changelist\" % (self.opts.app_label, self.opts.model_name),\n1535                 current_app=self.admin_site.name,\n1536             )\n1537             preserved_filters = self.get_preserved_filters(request)\n1538             post_url = add_preserved_filters(\n1539                 {\"preserved_filters\": preserved_filters, \"opts\": self.opts}, post_url\n1540             )\n1541         else:\n1542             post_url = reverse(\"admin:index\", current_app=self.admin_site.name)\n1543         return HttpResponseRedirect(post_url)\n1544 \n1545     def response_post_save_add(self, request, obj):\n1546         \"\"\"\n1547         Figure out where to redirect after the 'Save' button has been pressed\n1548         when adding a new object.\n1549         \"\"\"\n1550         return self._response_post_save(request, obj)\n1551 \n1552     def response_post_save_change(self, request, obj):\n1553         \"\"\"\n1554         Figure out where to redirect after the 'Save' button has been pressed\n1555         when editing an existing object.\n1556         \"\"\"\n1557         return self._response_post_save(request, obj)\n1558 \n1559     def response_action(self, request, queryset):\n1560         \"\"\"\n1561         Handle an admin action. This is called if a request is POSTed to the\n1562         changelist; it returns an HttpResponse if the action was handled, and\n1563         None otherwise.\n1564         \"\"\"\n1565 \n1566         # There can be multiple action forms on the page (at the top\n1567         # and bottom of the change list, for example). Get the action\n1568         # whose button was pushed.\n1569         try:\n1570             action_index = int(request.POST.get(\"index\", 0))\n1571         except ValueError:\n1572             action_index = 0\n1573 \n1574         # Construct the action form.\n1575         data = request.POST.copy()\n1576         data.pop(helpers.ACTION_CHECKBOX_NAME, None)\n1577         data.pop(\"index\", None)\n1578 \n1579         # Use the action whose button was pushed\n1580         try:\n1581             data.update({\"action\": data.getlist(\"action\")[action_index]})\n1582         except IndexError:\n1583             # If we didn't get an action from the chosen form that's invalid\n1584             # POST data, so by deleting action it'll fail the validation check\n1585             # below. So no need to do anything here\n1586             pass\n1587 \n1588         action_form = self.action_form(data, auto_id=None)\n1589         action_form.fields[\"action\"].choices = self.get_action_choices(request)\n1590 \n1591         # If the form's valid we can handle the action.\n1592         if action_form.is_valid():\n1593             action = action_form.cleaned_data[\"action\"]\n1594             select_across = action_form.cleaned_data[\"select_across\"]\n1595             func = self.get_actions(request)[action][0]\n1596 \n1597             # Get the list of selected PKs. If nothing's selected, we can't\n1598             # perform an action on it, so bail. Except we want to perform\n1599             # the action explicitly on all objects.\n1600             selected = request.POST.getlist(helpers.ACTION_CHECKBOX_NAME)\n1601             if not selected and not select_across:\n1602                 # Reminder that something needs to be selected or nothing will happen\n1603                 msg = _(\n1604                     \"Items must be selected in order to perform \"\n1605                     \"actions on them. No items have been changed.\"\n1606                 )\n1607                 self.message_user(request, msg, messages.WARNING)\n1608                 return None\n1609 \n1610             if not select_across:\n1611                 # Perform the action only on the selected objects\n1612                 queryset = queryset.filter(pk__in=selected)\n1613 \n1614             response = func(self, request, queryset)\n1615 \n1616             # Actions may return an HttpResponse-like object, which will be\n1617             # used as the response from the POST. If not, we'll be a good\n1618             # little HTTP citizen and redirect back to the changelist page.\n1619             if isinstance(response, HttpResponseBase):\n1620                 return response\n1621             else:\n1622                 return HttpResponseRedirect(request.get_full_path())\n1623         else:\n1624             msg = _(\"No action selected.\")\n1625             self.message_user(request, msg, messages.WARNING)\n1626             return None\n1627 \n1628     def response_delete(self, request, obj_display, obj_id):\n1629         \"\"\"\n1630         Determine the HttpResponse for the delete_view stage.\n1631         \"\"\"\n1632         if IS_POPUP_VAR in request.POST:\n1633             popup_response_data = json.dumps(\n1634                 {\n1635                     \"action\": \"delete\",\n1636                     \"value\": str(obj_id),\n1637                 }\n1638             )\n1639             return TemplateResponse(\n1640                 request,\n1641                 self.popup_response_template\n1642                 or [\n1643                     \"admin/%s/%s/popup_response.html\"\n1644                     % (self.opts.app_label, self.opts.model_name),\n1645                     \"admin/%s/popup_response.html\" % self.opts.app_label,\n1646                     \"admin/popup_response.html\",\n1647                 ],\n1648                 {\n1649                     \"popup_response_data\": popup_response_data,\n1650                 },\n1651             )\n1652 \n1653         self.message_user(\n1654             request,\n1655             _(\"The %(name)s \u201c%(obj)s\u201d was deleted successfully.\")\n1656             % {\n1657                 \"name\": self.opts.verbose_name,\n1658                 \"obj\": obj_display,\n1659             },\n1660             messages.SUCCESS,\n1661         )\n1662 \n1663         if self.has_change_permission(request, None):\n1664             post_url = reverse(\n1665                 \"admin:%s_%s_changelist\" % (self.opts.app_label, self.opts.model_name),\n1666                 current_app=self.admin_site.name,\n1667             )\n1668             preserved_filters = self.get_preserved_filters(request)\n1669             post_url = add_preserved_filters(\n1670                 {\"preserved_filters\": preserved_filters, \"opts\": self.opts}, post_url\n1671             )\n1672         else:\n1673             post_url = reverse(\"admin:index\", current_app=self.admin_site.name)\n1674         return HttpResponseRedirect(post_url)\n1675 \n1676     def render_delete_form(self, request, context):\n1677         app_label = self.opts.app_label\n1678 \n1679         request.current_app = self.admin_site.name\n1680         context.update(\n1681             to_field_var=TO_FIELD_VAR,\n1682             is_popup_var=IS_POPUP_VAR,\n1683             media=self.media,\n1684         )\n1685 \n1686         return TemplateResponse(\n1687             request,\n1688             self.delete_confirmation_template\n1689             or [\n1690                 \"admin/{}/{}/delete_confirmation.html\".format(\n1691                     app_label, self.opts.model_name\n1692                 ),\n1693                 \"admin/{}/delete_confirmation.html\".format(app_label),\n1694                 \"admin/delete_confirmation.html\",\n1695             ],\n1696             context,\n1697         )\n1698 \n1699     def get_inline_formsets(self, request, formsets, inline_instances, obj=None):\n1700         # Edit permissions on parent model are required for editable inlines.\n1701         can_edit_parent = (\n1702             self.has_change_permission(request, obj)\n1703             if obj\n1704             else self.has_add_permission(request)\n1705         )\n1706         inline_admin_formsets = []\n1707         for inline, formset in zip(inline_instances, formsets):\n1708             fieldsets = list(inline.get_fieldsets(request, obj))\n1709             readonly = list(inline.get_readonly_fields(request, obj))\n1710             if can_edit_parent:\n1711                 has_add_permission = inline.has_add_permission(request, obj)\n1712                 has_change_permission = inline.has_change_permission(request, obj)\n1713                 has_delete_permission = inline.has_delete_permission(request, obj)\n1714             else:\n1715                 # Disable all edit-permissions, and override formset settings.\n1716                 has_add_permission = (\n1717                     has_change_permission\n1718                 ) = has_delete_permission = False\n1719                 formset.extra = formset.max_num = 0\n1720             has_view_permission = inline.has_view_permission(request, obj)\n1721             prepopulated = dict(inline.get_prepopulated_fields(request, obj))\n1722             inline_admin_formset = helpers.InlineAdminFormSet(\n1723                 inline,\n1724                 formset,\n1725                 fieldsets,\n1726                 prepopulated,\n1727                 readonly,\n1728                 model_admin=self,\n1729                 has_add_permission=has_add_permission,\n1730                 has_change_permission=has_change_permission,\n1731                 has_delete_permission=has_delete_permission,\n1732                 has_view_permission=has_view_permission,\n1733             )\n1734             inline_admin_formsets.append(inline_admin_formset)\n1735         return inline_admin_formsets\n1736 \n1737     def get_changeform_initial_data(self, request):\n1738         \"\"\"\n1739         Get the initial form data from the request's GET params.\n1740         \"\"\"\n1741         initial = dict(request.GET.items())\n1742         for k in initial:\n1743             try:\n1744                 f = self.opts.get_field(k)\n1745             except FieldDoesNotExist:\n1746                 continue\n1747             # We have to special-case M2Ms as a list of comma-separated PKs.\n1748             if isinstance(f, models.ManyToManyField):\n1749                 initial[k] = initial[k].split(\",\")\n1750         return initial\n1751 \n1752     def _get_obj_does_not_exist_redirect(self, request, opts, object_id):\n1753         \"\"\"\n1754         Create a message informing the user that the object doesn't exist\n1755         and return a redirect to the admin index page.\n1756         \"\"\"\n1757         msg = _(\"%(name)s with ID \u201c%(key)s\u201d doesn\u2019t exist. Perhaps it was deleted?\") % {\n1758             \"name\": opts.verbose_name,\n1759             \"key\": unquote(object_id),\n1760         }\n1761         self.message_user(request, msg, messages.WARNING)\n1762         url = reverse(\"admin:index\", current_app=self.admin_site.name)\n1763         return HttpResponseRedirect(url)\n1764 \n1765     @csrf_protect_m\n1766     def changeform_view(self, request, object_id=None, form_url=\"\", extra_context=None):\n1767         with transaction.atomic(using=router.db_for_write(self.model)):\n1768             return self._changeform_view(request, object_id, form_url, extra_context)\n1769 \n1770     def _changeform_view(self, request, object_id, form_url, extra_context):\n1771         to_field = request.POST.get(TO_FIELD_VAR, request.GET.get(TO_FIELD_VAR))\n1772         if to_field and not self.to_field_allowed(request, to_field):\n1773             raise DisallowedModelAdminToField(\n1774                 \"The field %s cannot be referenced.\" % to_field\n1775             )\n1776 \n1777         if request.method == \"POST\" and \"_saveasnew\" in request.POST:\n1778             object_id = None\n1779 \n1780         add = object_id is None\n1781 \n1782         if add:\n1783             if not self.has_add_permission(request):\n1784                 raise PermissionDenied\n1785             obj = None\n1786 \n1787         else:\n1788             obj = self.get_object(request, unquote(object_id), to_field)\n1789 \n1790             if request.method == \"POST\":\n1791                 if not self.has_change_permission(request, obj):\n1792                     raise PermissionDenied\n1793             else:\n1794                 if not self.has_view_or_change_permission(request, obj):\n1795                     raise PermissionDenied\n1796 \n1797             if obj is None:\n1798                 return self._get_obj_does_not_exist_redirect(\n1799                     request, self.opts, object_id\n1800                 )\n1801 \n1802         fieldsets = self.get_fieldsets(request, obj)\n1803         ModelForm = self.get_form(\n1804             request, obj, change=not add, fields=flatten_fieldsets(fieldsets)\n1805         )\n1806         if request.method == \"POST\":\n1807             form = ModelForm(request.POST, request.FILES, instance=obj)\n1808             formsets, inline_instances = self._create_formsets(\n1809                 request,\n1810                 form.instance,\n1811                 change=not add,\n1812             )\n1813             form_validated = form.is_valid()\n1814             if form_validated:\n1815                 new_object = self.save_form(request, form, change=not add)\n1816             else:\n1817                 new_object = form.instance\n1818             if all_valid(formsets) and form_validated:\n1819                 self.save_model(request, new_object, form, not add)\n1820                 self.save_related(request, form, formsets, not add)\n1821                 change_message = self.construct_change_message(\n1822                     request, form, formsets, add\n1823                 )\n1824                 if add:\n1825                     self.log_addition(request, new_object, change_message)\n1826                     return self.response_add(request, new_object)\n1827                 else:\n1828                     self.log_change(request, new_object, change_message)\n1829                     return self.response_change(request, new_object)\n1830             else:\n1831                 form_validated = False\n1832         else:\n1833             if add:\n1834                 initial = self.get_changeform_initial_data(request)\n1835                 form = ModelForm(initial=initial)\n1836                 formsets, inline_instances = self._create_formsets(\n1837                     request, form.instance, change=False\n1838                 )\n1839             else:\n1840                 form = ModelForm(instance=obj)\n1841                 formsets, inline_instances = self._create_formsets(\n1842                     request, obj, change=True\n1843                 )\n1844 \n1845         if not add and not self.has_change_permission(request, obj):\n1846             readonly_fields = flatten_fieldsets(fieldsets)\n1847         else:\n1848             readonly_fields = self.get_readonly_fields(request, obj)\n1849         admin_form = helpers.AdminForm(\n1850             form,\n1851             list(fieldsets),\n1852             # Clear prepopulated fields on a view-only form to avoid a crash.\n1853             self.get_prepopulated_fields(request, obj)\n1854             if add or self.has_change_permission(request, obj)\n1855             else {},\n1856             readonly_fields,\n1857             model_admin=self,\n1858         )\n1859         media = self.media + admin_form.media\n1860 \n1861         inline_formsets = self.get_inline_formsets(\n1862             request, formsets, inline_instances, obj\n1863         )\n1864         for inline_formset in inline_formsets:\n1865             media += inline_formset.media\n1866 \n1867         if add:\n1868             title = _(\"Add %s\")\n1869         elif self.has_change_permission(request, obj):\n1870             title = _(\"Change %s\")\n1871         else:\n1872             title = _(\"View %s\")\n1873         context = {\n1874             **self.admin_site.each_context(request),\n1875             \"title\": title % self.opts.verbose_name,\n1876             \"subtitle\": str(obj) if obj else None,\n1877             \"adminform\": admin_form,\n1878             \"object_id\": object_id,\n1879             \"original\": obj,\n1880             \"is_popup\": IS_POPUP_VAR in request.POST or IS_POPUP_VAR in request.GET,\n1881             \"to_field\": to_field,\n1882             \"media\": media,\n1883             \"inline_admin_formsets\": inline_formsets,\n1884             \"errors\": helpers.AdminErrorList(form, formsets),\n1885             \"preserved_filters\": self.get_preserved_filters(request),\n1886         }\n1887 \n1888         # Hide the \"Save\" and \"Save and continue\" buttons if \"Save as New\" was\n1889         # previously chosen to prevent the interface from getting confusing.\n1890         if (\n1891             request.method == \"POST\"\n1892             and not form_validated\n1893             and \"_saveasnew\" in request.POST\n1894         ):\n1895             context[\"show_save\"] = False\n1896             context[\"show_save_and_continue\"] = False\n1897             # Use the change template instead of the add template.\n1898             add = False\n1899 \n1900         context.update(extra_context or {})\n1901 \n1902         return self.render_change_form(\n1903             request, context, add=add, change=not add, obj=obj, form_url=form_url\n1904         )\n1905 \n1906     def add_view(self, request, form_url=\"\", extra_context=None):\n1907         return self.changeform_view(request, None, form_url, extra_context)\n1908 \n1909     def change_view(self, request, object_id, form_url=\"\", extra_context=None):\n1910         return self.changeform_view(request, object_id, form_url, extra_context)\n1911 \n1912     def _get_edited_object_pks(self, request, prefix):\n1913         \"\"\"Return POST data values of list_editable primary keys.\"\"\"\n1914         pk_pattern = re.compile(\n1915             r\"{}-\\d+-{}$\".format(re.escape(prefix), self.opts.pk.name)\n1916         )\n1917         return [value for key, value in request.POST.items() if pk_pattern.match(key)]\n1918 \n1919     def _get_list_editable_queryset(self, request, prefix):\n1920         \"\"\"\n1921         Based on POST data, return a queryset of the objects that were edited\n1922         via list_editable.\n1923         \"\"\"\n1924         object_pks = self._get_edited_object_pks(request, prefix)\n1925         queryset = self.get_queryset(request)\n1926         validate = queryset.model._meta.pk.to_python\n1927         try:\n1928             for pk in object_pks:\n1929                 validate(pk)\n1930         except ValidationError:\n1931             # Disable the optimization if the POST data was tampered with.\n1932             return queryset\n1933         return queryset.filter(pk__in=object_pks)\n1934 \n1935     @csrf_protect_m\n1936     def changelist_view(self, request, extra_context=None):\n1937         \"\"\"\n1938         The 'change list' admin view for this model.\n1939         \"\"\"\n1940         from django.contrib.admin.views.main import ERROR_FLAG\n1941 \n1942         app_label = self.opts.app_label\n1943         if not self.has_view_or_change_permission(request):\n1944             raise PermissionDenied\n1945 \n1946         try:\n1947             cl = self.get_changelist_instance(request)\n1948         except IncorrectLookupParameters:\n1949             # Wacky lookup parameters were given, so redirect to the main\n1950             # changelist page, without parameters, and pass an 'invalid=1'\n1951             # parameter via the query string. If wacky parameters were given\n1952             # and the 'invalid=1' parameter was already in the query string,\n1953             # something is screwed up with the database, so display an error\n1954             # page.\n1955             if ERROR_FLAG in request.GET:\n1956                 return SimpleTemplateResponse(\n1957                     \"admin/invalid_setup.html\",\n1958                     {\n1959                         \"title\": _(\"Database error\"),\n1960                     },\n1961                 )\n1962             return HttpResponseRedirect(request.path + \"?\" + ERROR_FLAG + \"=1\")\n1963 \n1964         # If the request was POSTed, this might be a bulk action or a bulk\n1965         # edit. Try to look up an action or confirmation first, but if this\n1966         # isn't an action the POST will fall through to the bulk edit check,\n1967         # below.\n1968         action_failed = False\n1969         selected = request.POST.getlist(helpers.ACTION_CHECKBOX_NAME)\n1970 \n1971         actions = self.get_actions(request)\n1972         # Actions with no confirmation\n1973         if (\n1974             actions\n1975             and request.method == \"POST\"\n1976             and \"index\" in request.POST\n1977             and \"_save\" not in request.POST\n1978         ):\n1979             if selected:\n1980                 response = self.response_action(\n1981                     request, queryset=cl.get_queryset(request)\n1982                 )\n1983                 if response:\n1984                     return response\n1985                 else:\n1986                     action_failed = True\n1987             else:\n1988                 msg = _(\n1989                     \"Items must be selected in order to perform \"\n1990                     \"actions on them. No items have been changed.\"\n1991                 )\n1992                 self.message_user(request, msg, messages.WARNING)\n1993                 action_failed = True\n1994 \n1995         # Actions with confirmation\n1996         if (\n1997             actions\n1998             and request.method == \"POST\"\n1999             and helpers.ACTION_CHECKBOX_NAME in request.POST\n2000             and \"index\" not in request.POST\n2001             and \"_save\" not in request.POST\n2002         ):\n2003             if selected:\n2004                 response = self.response_action(\n2005                     request, queryset=cl.get_queryset(request)\n2006                 )\n2007                 if response:\n2008                     return response\n2009                 else:\n2010                     action_failed = True\n2011 \n2012         if action_failed:\n2013             # Redirect back to the changelist page to avoid resubmitting the\n2014             # form if the user refreshes the browser or uses the \"No, take\n2015             # me back\" button on the action confirmation page.\n2016             return HttpResponseRedirect(request.get_full_path())\n2017 \n2018         # If we're allowing changelist editing, we need to construct a formset\n2019         # for the changelist given all the fields to be edited. Then we'll\n2020         # use the formset to validate/process POSTed data.\n2021         formset = cl.formset = None\n2022 \n2023         # Handle POSTed bulk-edit data.\n2024         if request.method == \"POST\" and cl.list_editable and \"_save\" in request.POST:\n2025             if not self.has_change_permission(request):\n2026                 raise PermissionDenied\n2027             FormSet = self.get_changelist_formset(request)\n2028             modified_objects = self._get_list_editable_queryset(\n2029                 request, FormSet.get_default_prefix()\n2030             )\n2031             formset = cl.formset = FormSet(\n2032                 request.POST, request.FILES, queryset=modified_objects\n2033             )\n2034             if formset.is_valid():\n2035                 changecount = 0\n2036                 with transaction.atomic(using=router.db_for_write(self.model)):\n2037                     for form in formset.forms:\n2038                         if form.has_changed():\n2039                             obj = self.save_form(request, form, change=True)\n2040                             self.save_model(request, obj, form, change=True)\n2041                             self.save_related(request, form, formsets=[], change=True)\n2042                             change_msg = self.construct_change_message(\n2043                                 request, form, None\n2044                             )\n2045                             self.log_change(request, obj, change_msg)\n2046                             changecount += 1\n2047                 if changecount:\n2048                     msg = ngettext(\n2049                         \"%(count)s %(name)s was changed successfully.\",\n2050                         \"%(count)s %(name)s were changed successfully.\",\n2051                         changecount,\n2052                     ) % {\n2053                         \"count\": changecount,\n2054                         \"name\": model_ngettext(self.opts, changecount),\n2055                     }\n2056                     self.message_user(request, msg, messages.SUCCESS)\n2057 \n2058                 return HttpResponseRedirect(request.get_full_path())\n2059 \n2060         # Handle GET -- construct a formset for display.\n2061         elif cl.list_editable and self.has_change_permission(request):\n2062             FormSet = self.get_changelist_formset(request)\n2063             formset = cl.formset = FormSet(queryset=cl.result_list)\n2064 \n2065         # Build the list of media to be used by the formset.\n2066         if formset:\n2067             media = self.media + formset.media\n2068         else:\n2069             media = self.media\n2070 \n2071         # Build the action form and populate it with available actions.\n2072         if actions:\n2073             action_form = self.action_form(auto_id=None)\n2074             action_form.fields[\"action\"].choices = self.get_action_choices(request)\n2075             media += action_form.media\n2076         else:\n2077             action_form = None\n2078 \n2079         selection_note_all = ngettext(\n2080             \"%(total_count)s selected\", \"All %(total_count)s selected\", cl.result_count\n2081         )\n2082 \n2083         context = {\n2084             **self.admin_site.each_context(request),\n2085             \"module_name\": str(self.opts.verbose_name_plural),\n2086             \"selection_note\": _(\"0 of %(cnt)s selected\") % {\"cnt\": len(cl.result_list)},\n2087             \"selection_note_all\": selection_note_all % {\"total_count\": cl.result_count},\n2088             \"title\": cl.title,\n2089             \"subtitle\": None,\n2090             \"is_popup\": cl.is_popup,\n2091             \"to_field\": cl.to_field,\n2092             \"cl\": cl,\n2093             \"media\": media,\n2094             \"has_add_permission\": self.has_add_permission(request),\n2095             \"opts\": cl.opts,\n2096             \"action_form\": action_form,\n2097             \"actions_on_top\": self.actions_on_top,\n2098             \"actions_on_bottom\": self.actions_on_bottom,\n2099             \"actions_selection_counter\": self.actions_selection_counter,\n2100             \"preserved_filters\": self.get_preserved_filters(request),\n2101             **(extra_context or {}),\n2102         }\n2103 \n2104         request.current_app = self.admin_site.name\n2105 \n2106         return TemplateResponse(\n2107             request,\n2108             self.change_list_template\n2109             or [\n2110                 \"admin/%s/%s/change_list.html\" % (app_label, self.opts.model_name),\n2111                 \"admin/%s/change_list.html\" % app_label,\n2112                 \"admin/change_list.html\",\n2113             ],\n2114             context,\n2115         )\n2116 \n2117     def get_deleted_objects(self, objs, request):\n2118         \"\"\"\n2119         Hook for customizing the delete process for the delete view and the\n2120         \"delete selected\" action.\n2121         \"\"\"\n2122         return get_deleted_objects(objs, request, self.admin_site)\n2123 \n2124     @csrf_protect_m\n2125     def delete_view(self, request, object_id, extra_context=None):\n2126         with transaction.atomic(using=router.db_for_write(self.model)):\n2127             return self._delete_view(request, object_id, extra_context)\n2128 \n2129     def _delete_view(self, request, object_id, extra_context):\n2130         \"The 'delete' admin view for this model.\"\n2131         app_label = self.opts.app_label\n2132 \n2133         to_field = request.POST.get(TO_FIELD_VAR, request.GET.get(TO_FIELD_VAR))\n2134         if to_field and not self.to_field_allowed(request, to_field):\n2135             raise DisallowedModelAdminToField(\n2136                 \"The field %s cannot be referenced.\" % to_field\n2137             )\n2138 \n2139         obj = self.get_object(request, unquote(object_id), to_field)\n2140 \n2141         if not self.has_delete_permission(request, obj):\n2142             raise PermissionDenied\n2143 \n2144         if obj is None:\n2145             return self._get_obj_does_not_exist_redirect(request, self.opts, object_id)\n2146 \n2147         # Populate deleted_objects, a data structure of all related objects that\n2148         # will also be deleted.\n2149         (\n2150             deleted_objects,\n2151             model_count,\n2152             perms_needed,\n2153             protected,\n2154         ) = self.get_deleted_objects([obj], request)\n2155 \n2156         if request.POST and not protected:  # The user has confirmed the deletion.\n2157             if perms_needed:\n2158                 raise PermissionDenied\n2159             obj_display = str(obj)\n2160             attr = str(to_field) if to_field else self.opts.pk.attname\n2161             obj_id = obj.serializable_value(attr)\n2162             self.log_deletion(request, obj, obj_display)\n2163             self.delete_model(request, obj)\n2164 \n2165             return self.response_delete(request, obj_display, obj_id)\n2166 \n2167         object_name = str(self.opts.verbose_name)\n2168 \n2169         if perms_needed or protected:\n2170             title = _(\"Cannot delete %(name)s\") % {\"name\": object_name}\n2171         else:\n2172             title = _(\"Are you sure?\")\n2173 \n2174         context = {\n2175             **self.admin_site.each_context(request),\n2176             \"title\": title,\n2177             \"subtitle\": None,\n2178             \"object_name\": object_name,\n2179             \"object\": obj,\n2180             \"deleted_objects\": deleted_objects,\n2181             \"model_count\": dict(model_count).items(),\n2182             \"perms_lacking\": perms_needed,\n2183             \"protected\": protected,\n2184             \"opts\": self.opts,\n2185             \"app_label\": app_label,\n2186             \"preserved_filters\": self.get_preserved_filters(request),\n2187             \"is_popup\": IS_POPUP_VAR in request.POST or IS_POPUP_VAR in request.GET,\n2188             \"to_field\": to_field,\n2189             **(extra_context or {}),\n2190         }\n2191 \n2192         return self.render_delete_form(request, context)\n2193 \n2194     def history_view(self, request, object_id, extra_context=None):\n2195         \"The 'history' admin view for this model.\"\n2196         from django.contrib.admin.models import LogEntry\n2197         from django.contrib.admin.views.main import PAGE_VAR\n2198 \n2199         # First check if the user can see this history.\n2200         model = self.model\n2201         obj = self.get_object(request, unquote(object_id))\n2202         if obj is None:\n2203             return self._get_obj_does_not_exist_redirect(\n2204                 request, model._meta, object_id\n2205             )\n2206 \n2207         if not self.has_view_or_change_permission(request, obj):\n2208             raise PermissionDenied\n2209 \n2210         # Then get the history for this object.\n2211         app_label = self.opts.app_label\n2212         action_list = (\n2213             LogEntry.objects.filter(\n2214                 object_id=unquote(object_id),\n2215                 content_type=get_content_type_for_model(model),\n2216             )\n2217             .select_related()\n2218             .order_by(\"action_time\")\n2219         )\n2220 \n2221         paginator = self.get_paginator(request, action_list, 100)\n2222         page_number = request.GET.get(PAGE_VAR, 1)\n2223         page_obj = paginator.get_page(page_number)\n2224         page_range = paginator.get_elided_page_range(page_obj.number)\n2225 \n2226         context = {\n2227             **self.admin_site.each_context(request),\n2228             \"title\": _(\"Change history: %s\") % obj,\n2229             \"subtitle\": None,\n2230             \"action_list\": page_obj,\n2231             \"page_range\": page_range,\n2232             \"page_var\": PAGE_VAR,\n2233             \"pagination_required\": paginator.count > 100,\n2234             \"module_name\": str(capfirst(self.opts.verbose_name_plural)),\n2235             \"object\": obj,\n2236             \"opts\": self.opts,\n2237             \"preserved_filters\": self.get_preserved_filters(request),\n2238             **(extra_context or {}),\n2239         }\n2240 \n2241         request.current_app = self.admin_site.name\n2242 \n2243         return TemplateResponse(\n2244             request,\n2245             self.object_history_template\n2246             or [\n2247                 \"admin/%s/%s/object_history.html\" % (app_label, self.opts.model_name),\n2248                 \"admin/%s/object_history.html\" % app_label,\n2249                 \"admin/object_history.html\",\n2250             ],\n2251             context,\n2252         )\n2253 \n2254     def get_formset_kwargs(self, request, obj, inline, prefix):\n2255         formset_params = {\n2256             \"instance\": obj,\n2257             \"prefix\": prefix,\n2258             \"queryset\": inline.get_queryset(request),\n2259         }\n2260         if request.method == \"POST\":\n2261             formset_params.update(\n2262                 {\n2263                     \"data\": request.POST.copy(),\n2264                     \"files\": request.FILES,\n2265                     \"save_as_new\": \"_saveasnew\" in request.POST,\n2266                 }\n2267             )\n2268         return formset_params\n2269 \n2270     def _create_formsets(self, request, obj, change):\n2271         \"Helper function to generate formsets for add/change_view.\"\n2272         formsets = []\n2273         inline_instances = []\n2274         prefixes = {}\n2275         get_formsets_args = [request]\n2276         if change:\n2277             get_formsets_args.append(obj)\n2278         for FormSet, inline in self.get_formsets_with_inlines(*get_formsets_args):\n2279             prefix = FormSet.get_default_prefix()\n2280             prefixes[prefix] = prefixes.get(prefix, 0) + 1\n2281             if prefixes[prefix] != 1 or not prefix:\n2282                 prefix = \"%s-%s\" % (prefix, prefixes[prefix])\n2283             formset_params = self.get_formset_kwargs(request, obj, inline, prefix)\n2284             formset = FormSet(**formset_params)\n2285 \n2286             def user_deleted_form(request, obj, formset, index, inline):\n2287                 \"\"\"Return whether or not the user deleted the form.\"\"\"\n2288                 return (\n2289                     inline.has_delete_permission(request, obj)\n2290                     and \"{}-{}-DELETE\".format(formset.prefix, index) in request.POST\n2291                 )\n2292 \n2293             # Bypass validation of each view-only inline form (since the form's\n2294             # data won't be in request.POST), unless the form was deleted.\n2295             if not inline.has_change_permission(request, obj if change else None):\n2296                 for index, form in enumerate(formset.initial_forms):\n2297                     if user_deleted_form(request, obj, formset, index, inline):\n2298                         continue\n2299                     form._errors = {}\n2300                     form.cleaned_data = form.initial\n2301             formsets.append(formset)\n2302             inline_instances.append(inline)\n2303         return formsets, inline_instances\n",
        "intended_behavior": "Although no direct changes might be needed in the `ModelAdmin` class based on the current context, enhancing the documentation or inline comments to clearly state that `filter_horizontal` and `filter_vertical` cannot be used with `ManyToManyField` instances that specify a `through` model could improve developer experience and clarity. If the system check is implemented as suggested above, a reference to this check could also be included here as part of the documentation."
    }
]