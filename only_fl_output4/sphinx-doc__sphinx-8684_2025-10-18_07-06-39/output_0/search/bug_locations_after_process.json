[
    {
        "rel_file_path": "sphinx/directives/code.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__3.5/sphinx/directives/code.py",
        "start": 107,
        "end": 187,
        "class_name": "CodeBlock",
        "method_name": null,
        "code": "107 class CodeBlock(SphinxDirective):\n108     \"\"\"\n109     Directive for a code block with special highlighting or line numbering\n110     settings.\n111     \"\"\"\n112 \n113     has_content = True\n114     required_arguments = 0\n115     optional_arguments = 1\n116     final_argument_whitespace = False\n117     option_spec = {\n118         'force': directives.flag,\n119         'linenos': directives.flag,\n120         'dedent': int,\n121         'lineno-start': int,\n122         'emphasize-lines': directives.unchanged_required,\n123         'caption': directives.unchanged_required,\n124         'class': directives.class_option,\n125         'name': directives.unchanged,\n126     }\n127 \n128     def run(self) -> List[Node]:\n129         document = self.state.document\n130         code = '\\n'.join(self.content)\n131         location = self.state_machine.get_source_and_line(self.lineno)\n132 \n133         linespec = self.options.get('emphasize-lines')\n134         if linespec:\n135             try:\n136                 nlines = len(self.content)\n137                 hl_lines = parselinenos(linespec, nlines)\n138                 if any(i >= nlines for i in hl_lines):\n139                     logger.warning(__('line number spec is out of range(1-%d): %r') %\n140                                    (nlines, self.options['emphasize-lines']),\n141                                    location=location)\n142 \n143                 hl_lines = [x + 1 for x in hl_lines if x < nlines]\n144             except ValueError as err:\n145                 return [document.reporter.warning(err, line=self.lineno)]\n146         else:\n147             hl_lines = None\n148 \n149         if 'dedent' in self.options:\n150             location = self.state_machine.get_source_and_line(self.lineno)\n151             lines = code.split('\\n')\n152             lines = dedent_lines(lines, self.options['dedent'], location=location)\n153             code = '\\n'.join(lines)\n154 \n155         literal = nodes.literal_block(code, code)  # type: Element\n156         if 'linenos' in self.options or 'lineno-start' in self.options:\n157             literal['linenos'] = True\n158         literal['classes'] += self.options.get('class', [])\n159         literal['force'] = 'force' in self.options\n160         if self.arguments:\n161             # highlight language specified\n162             literal['language'] = self.arguments[0]\n163         else:\n164             # no highlight language specified.  Then this directive refers the current\n165             # highlight setting via ``highlight`` directive or ``highlight_language``\n166             # configuration.\n167             literal['language'] = self.env.temp_data.get('highlight_language',\n168                                                          self.config.highlight_language)\n169         extra_args = literal['highlight_args'] = {}\n170         if hl_lines is not None:\n171             extra_args['hl_lines'] = hl_lines\n172         if 'lineno-start' in self.options:\n173             extra_args['linenostart'] = self.options['lineno-start']\n174         self.set_source_info(literal)\n175 \n176         caption = self.options.get('caption')\n177         if caption:\n178             try:\n179                 literal = container_wrapper(self, literal, caption)\n180             except ValueError as exc:\n181                 return [document.reporter.warning(exc, line=self.lineno)]\n182 \n183         # literal will be note_implicit_target that is linked from caption and numref.\n184         # when options['name'] is provided, it should be primary ID.\n185         self.add_name(literal)\n186 \n187         return [literal]\n",
        "intended_behavior": "Update or extend the `CodeBlock` class to automatically dedent the content of the code block if the `:dedent:` option is provided without a specific value. This dedentation should remove an amount of leading whitespace from each line equal to the smallest indentation level found among all lines in the block. This behavior should mimic Python's `textwrap.dedent`, ensuring that the code within the documentation is as readable as possible without unnecessary indentation."
    },
    {
        "rel_file_path": "sphinx/directives/code.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__3.5/sphinx/directives/code.py",
        "start": 382,
        "end": 466,
        "class_name": "LiteralInclude",
        "method_name": null,
        "code": "382 class LiteralInclude(SphinxDirective):\n383     \"\"\"\n384     Like ``.. include:: :literal:``, but only warns if the include file is\n385     not found, and does not raise errors.  Also has several options for\n386     selecting what to include.\n387     \"\"\"\n388 \n389     has_content = False\n390     required_arguments = 1\n391     optional_arguments = 0\n392     final_argument_whitespace = True\n393     option_spec = {\n394         'dedent': int,\n395         'linenos': directives.flag,\n396         'lineno-start': int,\n397         'lineno-match': directives.flag,\n398         'tab-width': int,\n399         'language': directives.unchanged_required,\n400         'force': directives.flag,\n401         'encoding': directives.encoding,\n402         'pyobject': directives.unchanged_required,\n403         'lines': directives.unchanged_required,\n404         'start-after': directives.unchanged_required,\n405         'end-before': directives.unchanged_required,\n406         'start-at': directives.unchanged_required,\n407         'end-at': directives.unchanged_required,\n408         'prepend': directives.unchanged_required,\n409         'append': directives.unchanged_required,\n410         'emphasize-lines': directives.unchanged_required,\n411         'caption': directives.unchanged,\n412         'class': directives.class_option,\n413         'name': directives.unchanged,\n414         'diff': directives.unchanged_required,\n415     }\n416 \n417     def run(self) -> List[Node]:\n418         document = self.state.document\n419         if not document.settings.file_insertion_enabled:\n420             return [document.reporter.warning('File insertion disabled',\n421                                               line=self.lineno)]\n422         # convert options['diff'] to absolute path\n423         if 'diff' in self.options:\n424             _, path = self.env.relfn2path(self.options['diff'])\n425             self.options['diff'] = path\n426 \n427         try:\n428             location = self.state_machine.get_source_and_line(self.lineno)\n429             rel_filename, filename = self.env.relfn2path(self.arguments[0])\n430             self.env.note_dependency(rel_filename)\n431 \n432             reader = LiteralIncludeReader(filename, self.options, self.config)\n433             text, lines = reader.read(location=location)\n434 \n435             retnode = nodes.literal_block(text, text, source=filename)  # type: Element\n436             retnode['force'] = 'force' in self.options\n437             self.set_source_info(retnode)\n438             if self.options.get('diff'):  # if diff is set, set udiff\n439                 retnode['language'] = 'udiff'\n440             elif 'language' in self.options:\n441                 retnode['language'] = self.options['language']\n442             if ('linenos' in self.options or 'lineno-start' in self.options or\n443                     'lineno-match' in self.options):\n444                 retnode['linenos'] = True\n445             retnode['classes'] += self.options.get('class', [])\n446             extra_args = retnode['highlight_args'] = {}\n447             if 'emphasize-lines' in self.options:\n448                 hl_lines = parselinenos(self.options['emphasize-lines'], lines)\n449                 if any(i >= lines for i in hl_lines):\n450                     logger.warning(__('line number spec is out of range(1-%d): %r') %\n451                                    (lines, self.options['emphasize-lines']),\n452                                    location=location)\n453                 extra_args['hl_lines'] = [x + 1 for x in hl_lines if x < lines]\n454             extra_args['linenostart'] = reader.lineno_start\n455 \n456             if 'caption' in self.options:\n457                 caption = self.options['caption'] or self.arguments[0]\n458                 retnode = container_wrapper(self, retnode, caption)\n459 \n460             # retnode will be note_implicit_target that is linked from caption and numref.\n461             # when options['name'] is provided, it should be primary ID.\n462             self.add_name(retnode)\n463 \n464             return [retnode]\n465         except Exception as exc:\n466             return [document.reporter.warning(exc, line=self.lineno)]\n",
        "intended_behavior": "Similarly, modify the `LiteralInclude` class to support automatic dedentation when the `:dedent:` option is utilized without an explicit value. The logic should analyze the indentation of the included file or code snippet, dedent based on the least indented line, and apply this uniformly across the included content. This enhancement will make externally included code snippets align neatly with the documentation's formatting standards, enhancing readability."
    }
]