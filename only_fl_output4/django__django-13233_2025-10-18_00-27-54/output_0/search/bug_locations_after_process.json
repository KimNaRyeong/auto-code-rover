[
    {
        "rel_file_path": "django/db/models/fields/files.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.2/django/db/models/fields/files.py",
        "start": 1,
        "end": 473,
        "class_name": null,
        "method_name": null,
        "code": "1 import datetime\n2 import posixpath\n3 \n4 from django import forms\n5 from django.core import checks\n6 from django.core.files.base import File\n7 from django.core.files.images import ImageFile\n8 from django.core.files.storage import Storage, default_storage\n9 from django.db.models import signals\n10 from django.db.models.fields import Field\n11 from django.db.models.query_utils import DeferredAttribute\n12 from django.utils.translation import gettext_lazy as _\n13 \n14 \n15 class FieldFile(File):\n16     def __init__(self, instance, field, name):\n17         super().__init__(None, name)\n18         self.instance = instance\n19         self.field = field\n20         self.storage = field.storage\n21         self._committed = True\n22 \n23     def __eq__(self, other):\n24         # Older code may be expecting FileField values to be simple strings.\n25         # By overriding the == operator, it can remain backwards compatibility.\n26         if hasattr(other, 'name'):\n27             return self.name == other.name\n28         return self.name == other\n29 \n30     def __hash__(self):\n31         return hash(self.name)\n32 \n33     # The standard File contains most of the necessary properties, but\n34     # FieldFiles can be instantiated without a name, so that needs to\n35     # be checked for here.\n36 \n37     def _require_file(self):\n38         if not self:\n39             raise ValueError(\"The '%s' attribute has no file associated with it.\" % self.field.name)\n40 \n41     def _get_file(self):\n42         self._require_file()\n43         if getattr(self, '_file', None) is None:\n44             self._file = self.storage.open(self.name, 'rb')\n45         return self._file\n46 \n47     def _set_file(self, file):\n48         self._file = file\n49 \n50     def _del_file(self):\n51         del self._file\n52 \n53     file = property(_get_file, _set_file, _del_file)\n54 \n55     @property\n56     def path(self):\n57         self._require_file()\n58         return self.storage.path(self.name)\n59 \n60     @property\n61     def url(self):\n62         self._require_file()\n63         return self.storage.url(self.name)\n64 \n65     @property\n66     def size(self):\n67         self._require_file()\n68         if not self._committed:\n69             return self.file.size\n70         return self.storage.size(self.name)\n71 \n72     def open(self, mode='rb'):\n73         self._require_file()\n74         if getattr(self, '_file', None) is None:\n75             self.file = self.storage.open(self.name, mode)\n76         else:\n77             self.file.open(mode)\n78         return self\n79     # open() doesn't alter the file's contents, but it does reset the pointer\n80     open.alters_data = True\n81 \n82     # In addition to the standard File API, FieldFiles have extra methods\n83     # to further manipulate the underlying file, as well as update the\n84     # associated model instance.\n85 \n86     def save(self, name, content, save=True):\n87         name = self.field.generate_filename(self.instance, name)\n88         self.name = self.storage.save(name, content, max_length=self.field.max_length)\n89         setattr(self.instance, self.field.name, self.name)\n90         self._committed = True\n91 \n92         # Save the object because it has changed, unless save is False\n93         if save:\n94             self.instance.save()\n95     save.alters_data = True\n96 \n97     def delete(self, save=True):\n98         if not self:\n99             return\n100         # Only close the file if it's already open, which we know by the\n101         # presence of self._file\n102         if hasattr(self, '_file'):\n103             self.close()\n104             del self.file\n105 \n106         self.storage.delete(self.name)\n107 \n108         self.name = None\n109         setattr(self.instance, self.field.name, self.name)\n110         self._committed = False\n111 \n112         if save:\n113             self.instance.save()\n114     delete.alters_data = True\n115 \n116     @property\n117     def closed(self):\n118         file = getattr(self, '_file', None)\n119         return file is None or file.closed\n120 \n121     def close(self):\n122         file = getattr(self, '_file', None)\n123         if file is not None:\n124             file.close()\n125 \n126     def __getstate__(self):\n127         # FieldFile needs access to its associated model field, an instance and\n128         # the file's name. Everything else will be restored later, by\n129         # FileDescriptor below.\n130         return {\n131             'name': self.name,\n132             'closed': False,\n133             '_committed': True,\n134             '_file': None,\n135             'instance': self.instance,\n136             'field': self.field,\n137         }\n138 \n139     def __setstate__(self, state):\n140         self.__dict__.update(state)\n141         self.storage = self.field.storage\n142 \n143 \n144 class FileDescriptor(DeferredAttribute):\n145     \"\"\"\n146     The descriptor for the file attribute on the model instance. Return a\n147     FieldFile when accessed so you can write code like::\n148 \n149         >>> from myapp.models import MyModel\n150         >>> instance = MyModel.objects.get(pk=1)\n151         >>> instance.file.size\n152 \n153     Assign a file object on assignment so you can do::\n154 \n155         >>> with open('/path/to/hello.world') as f:\n156         ...     instance.file = File(f)\n157     \"\"\"\n158     def __get__(self, instance, cls=None):\n159         if instance is None:\n160             return self\n161 \n162         # This is slightly complicated, so worth an explanation.\n163         # instance.file`needs to ultimately return some instance of `File`,\n164         # probably a subclass. Additionally, this returned object needs to have\n165         # the FieldFile API so that users can easily do things like\n166         # instance.file.path and have that delegated to the file storage engine.\n167         # Easy enough if we're strict about assignment in __set__, but if you\n168         # peek below you can see that we're not. So depending on the current\n169         # value of the field we have to dynamically construct some sort of\n170         # \"thing\" to return.\n171 \n172         # The instance dict contains whatever was originally assigned\n173         # in __set__.\n174         file = super().__get__(instance, cls)\n175 \n176         # If this value is a string (instance.file = \"path/to/file\") or None\n177         # then we simply wrap it with the appropriate attribute class according\n178         # to the file field. [This is FieldFile for FileFields and\n179         # ImageFieldFile for ImageFields; it's also conceivable that user\n180         # subclasses might also want to subclass the attribute class]. This\n181         # object understands how to convert a path to a file, and also how to\n182         # handle None.\n183         if isinstance(file, str) or file is None:\n184             attr = self.field.attr_class(instance, self.field, file)\n185             instance.__dict__[self.field.attname] = attr\n186 \n187         # Other types of files may be assigned as well, but they need to have\n188         # the FieldFile interface added to them. Thus, we wrap any other type of\n189         # File inside a FieldFile (well, the field's attr_class, which is\n190         # usually FieldFile).\n191         elif isinstance(file, File) and not isinstance(file, FieldFile):\n192             file_copy = self.field.attr_class(instance, self.field, file.name)\n193             file_copy.file = file\n194             file_copy._committed = False\n195             instance.__dict__[self.field.attname] = file_copy\n196 \n197         # Finally, because of the (some would say boneheaded) way pickle works,\n198         # the underlying FieldFile might not actually itself have an associated\n199         # file. So we need to reset the details of the FieldFile in those cases.\n200         elif isinstance(file, FieldFile) and not hasattr(file, 'field'):\n201             file.instance = instance\n202             file.field = self.field\n203             file.storage = self.field.storage\n204 \n205         # Make sure that the instance is correct.\n206         elif isinstance(file, FieldFile) and instance is not file.instance:\n207             file.instance = instance\n208 \n209         # That was fun, wasn't it?\n210         return instance.__dict__[self.field.attname]\n211 \n212     def __set__(self, instance, value):\n213         instance.__dict__[self.field.attname] = value\n214 \n215 \n216 class FileField(Field):\n217 \n218     # The class to wrap instance attributes in. Accessing the file object off\n219     # the instance will always return an instance of attr_class.\n220     attr_class = FieldFile\n221 \n222     # The descriptor to use for accessing the attribute off of the class.\n223     descriptor_class = FileDescriptor\n224 \n225     description = _(\"File\")\n226 \n227     def __init__(self, verbose_name=None, name=None, upload_to='', storage=None, **kwargs):\n228         self._primary_key_set_explicitly = 'primary_key' in kwargs\n229 \n230         self.storage = storage or default_storage\n231         if callable(self.storage):\n232             self.storage = self.storage()\n233             if not isinstance(self.storage, Storage):\n234                 raise TypeError(\n235                     \"%s.storage must be a subclass/instance of %s.%s\"\n236                     % (self.__class__.__qualname__, Storage.__module__, Storage.__qualname__)\n237                 )\n238         self.upload_to = upload_to\n239 \n240         kwargs.setdefault('max_length', 100)\n241         super().__init__(verbose_name, name, **kwargs)\n242 \n243     def check(self, **kwargs):\n244         return [\n245             *super().check(**kwargs),\n246             *self._check_primary_key(),\n247             *self._check_upload_to(),\n248         ]\n249 \n250     def _check_primary_key(self):\n251         if self._primary_key_set_explicitly:\n252             return [\n253                 checks.Error(\n254                     \"'primary_key' is not a valid argument for a %s.\" % self.__class__.__name__,\n255                     obj=self,\n256                     id='fields.E201',\n257                 )\n258             ]\n259         else:\n260             return []\n261 \n262     def _check_upload_to(self):\n263         if isinstance(self.upload_to, str) and self.upload_to.startswith('/'):\n264             return [\n265                 checks.Error(\n266                     \"%s's 'upload_to' argument must be a relative path, not an \"\n267                     \"absolute path.\" % self.__class__.__name__,\n268                     obj=self,\n269                     id='fields.E202',\n270                     hint='Remove the leading slash.',\n271                 )\n272             ]\n273         else:\n274             return []\n275 \n276     def deconstruct(self):\n277         name, path, args, kwargs = super().deconstruct()\n278         if kwargs.get(\"max_length\") == 100:\n279             del kwargs[\"max_length\"]\n280         kwargs['upload_to'] = self.upload_to\n281         if self.storage is not default_storage:\n282             kwargs['storage'] = self.storage\n283         return name, path, args, kwargs\n284 \n285     def get_internal_type(self):\n286         return \"FileField\"\n287 \n288     def get_prep_value(self, value):\n289         value = super().get_prep_value(value)\n290         # Need to convert File objects provided via a form to string for database insertion\n291         if value is None:\n292             return None\n293         return str(value)\n294 \n295     def pre_save(self, model_instance, add):\n296         file = super().pre_save(model_instance, add)\n297         if file and not file._committed:\n298             # Commit the file to storage prior to saving the model\n299             file.save(file.name, file.file, save=False)\n300         return file\n301 \n302     def generate_filename(self, instance, filename):\n303         \"\"\"\n304         Apply (if callable) or prepend (if a string) upload_to to the filename,\n305         then delegate further processing of the name to the storage backend.\n306         Until the storage layer, all file paths are expected to be Unix style\n307         (with forward slashes).\n308         \"\"\"\n309         if callable(self.upload_to):\n310             filename = self.upload_to(instance, filename)\n311         else:\n312             dirname = datetime.datetime.now().strftime(str(self.upload_to))\n313             filename = posixpath.join(dirname, filename)\n314         return self.storage.generate_filename(filename)\n315 \n316     def save_form_data(self, instance, data):\n317         # Important: None means \"no change\", other false value means \"clear\"\n318         # This subtle distinction (rather than a more explicit marker) is\n319         # needed because we need to consume values that are also sane for a\n320         # regular (non Model-) Form to find in its cleaned_data dictionary.\n321         if data is not None:\n322             # This value will be converted to str and stored in the\n323             # database, so leaving False as-is is not acceptable.\n324             setattr(instance, self.name, data or '')\n325 \n326     def formfield(self, **kwargs):\n327         return super().formfield(**{\n328             'form_class': forms.FileField,\n329             'max_length': self.max_length,\n330             **kwargs,\n331         })\n332 \n333 \n334 class ImageFileDescriptor(FileDescriptor):\n335     \"\"\"\n336     Just like the FileDescriptor, but for ImageFields. The only difference is\n337     assigning the width/height to the width_field/height_field, if appropriate.\n338     \"\"\"\n339     def __set__(self, instance, value):\n340         previous_file = instance.__dict__.get(self.field.attname)\n341         super().__set__(instance, value)\n342 \n343         # To prevent recalculating image dimensions when we are instantiating\n344         # an object from the database (bug #11084), only update dimensions if\n345         # the field had a value before this assignment.  Since the default\n346         # value for FileField subclasses is an instance of field.attr_class,\n347         # previous_file will only be None when we are called from\n348         # Model.__init__().  The ImageField.update_dimension_fields method\n349         # hooked up to the post_init signal handles the Model.__init__() cases.\n350         # Assignment happening outside of Model.__init__() will trigger the\n351         # update right here.\n352         if previous_file is not None:\n353             self.field.update_dimension_fields(instance, force=True)\n354 \n355 \n356 class ImageFieldFile(ImageFile, FieldFile):\n357     def delete(self, save=True):\n358         # Clear the image dimensions cache\n359         if hasattr(self, '_dimensions_cache'):\n360             del self._dimensions_cache\n361         super().delete(save)\n362 \n363 \n364 class ImageField(FileField):\n365     attr_class = ImageFieldFile\n366     descriptor_class = ImageFileDescriptor\n367     description = _(\"Image\")\n368 \n369     def __init__(self, verbose_name=None, name=None, width_field=None, height_field=None, **kwargs):\n370         self.width_field, self.height_field = width_field, height_field\n371         super().__init__(verbose_name, name, **kwargs)\n372 \n373     def check(self, **kwargs):\n374         return [\n375             *super().check(**kwargs),\n376             *self._check_image_library_installed(),\n377         ]\n378 \n379     def _check_image_library_installed(self):\n380         try:\n381             from PIL import Image  # NOQA\n382         except ImportError:\n383             return [\n384                 checks.Error(\n385                     'Cannot use ImageField because Pillow is not installed.',\n386                     hint=('Get Pillow at https://pypi.org/project/Pillow/ '\n387                           'or run command \"python -m pip install Pillow\".'),\n388                     obj=self,\n389                     id='fields.E210',\n390                 )\n391             ]\n392         else:\n393             return []\n394 \n395     def deconstruct(self):\n396         name, path, args, kwargs = super().deconstruct()\n397         if self.width_field:\n398             kwargs['width_field'] = self.width_field\n399         if self.height_field:\n400             kwargs['height_field'] = self.height_field\n401         return name, path, args, kwargs\n402 \n403     def contribute_to_class(self, cls, name, **kwargs):\n404         super().contribute_to_class(cls, name, **kwargs)\n405         # Attach update_dimension_fields so that dimension fields declared\n406         # after their corresponding image field don't stay cleared by\n407         # Model.__init__, see bug #11196.\n408         # Only run post-initialization dimension update on non-abstract models\n409         if not cls._meta.abstract:\n410             signals.post_init.connect(self.update_dimension_fields, sender=cls)\n411 \n412     def update_dimension_fields(self, instance, force=False, *args, **kwargs):\n413         \"\"\"\n414         Update field's width and height fields, if defined.\n415 \n416         This method is hooked up to model's post_init signal to update\n417         dimensions after instantiating a model instance.  However, dimensions\n418         won't be updated if the dimensions fields are already populated.  This\n419         avoids unnecessary recalculation when loading an object from the\n420         database.\n421 \n422         Dimensions can be forced to update with force=True, which is how\n423         ImageFileDescriptor.__set__ calls this method.\n424         \"\"\"\n425         # Nothing to update if the field doesn't have dimension fields or if\n426         # the field is deferred.\n427         has_dimension_fields = self.width_field or self.height_field\n428         if not has_dimension_fields or self.attname not in instance.__dict__:\n429             return\n430 \n431         # getattr will call the ImageFileDescriptor's __get__ method, which\n432         # coerces the assigned value into an instance of self.attr_class\n433         # (ImageFieldFile in this case).\n434         file = getattr(instance, self.attname)\n435 \n436         # Nothing to update if we have no file and not being forced to update.\n437         if not file and not force:\n438             return\n439 \n440         dimension_fields_filled = not(\n441             (self.width_field and not getattr(instance, self.width_field)) or\n442             (self.height_field and not getattr(instance, self.height_field))\n443         )\n444         # When both dimension fields have values, we are most likely loading\n445         # data from the database or updating an image field that already had\n446         # an image stored.  In the first case, we don't want to update the\n447         # dimension fields because we are already getting their values from the\n448         # database.  In the second case, we do want to update the dimensions\n449         # fields and will skip this return because force will be True since we\n450         # were called from ImageFileDescriptor.__set__.\n451         if dimension_fields_filled and not force:\n452             return\n453 \n454         # file should be an instance of ImageFieldFile or should be None.\n455         if file:\n456             width = file.width\n457             height = file.height\n458         else:\n459             # No file, so clear dimensions fields.\n460             width = None\n461             height = None\n462 \n463         # Update the width and height fields.\n464         if self.width_field:\n465             setattr(instance, self.width_field, width)\n466         if self.height_field:\n467             setattr(instance, self.height_field, height)\n468 \n469     def formfield(self, **kwargs):\n470         return super().formfield(**{\n471             'form_class': forms.ImageField,\n472             **kwargs,\n473         })\n",
        "intended_behavior": "Ensure that the `model` attribute on the `ImageField` (or `FileField`, if the inheritance structure is where the change impacted the `ImageField`) correctly reflects the concrete model it is attached to. This might involve re-establishing a direct or indirect linkage between the field and its parent model during field initialization or through some form of model-field registration mechanism that was affected by the Django 3.2 update. The exact change would depend on how Django intended to handle this relationship post the changes in 3.2 and ensuring that any workarounds or fixes do not break existing functionality or introspection capabilities that rely on accessing `model` from image fields."
    }
]