[
    {
        "rel_file_path": "sphinx/ext/napoleon/docstring.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__3.1/sphinx/ext/napoleon/docstring.py",
        "start": 1,
        "end": 1039,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2     sphinx.ext.napoleon.docstring\n3     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n4 \n5 \n6     Classes for docstring parsing and formatting.\n7 \n8 \n9     :copyright: Copyright 2007-2020 by the Sphinx team, see AUTHORS.\n10     :license: BSD, see LICENSE for details.\n11 \"\"\"\n12 \n13 import inspect\n14 import re\n15 from functools import partial\n16 from typing import Any, Callable, Dict, List, Tuple, Union\n17 \n18 from sphinx.application import Sphinx\n19 from sphinx.config import Config as SphinxConfig\n20 from sphinx.ext.napoleon.iterators import modify_iter\n21 from sphinx.locale import _\n22 \n23 if False:\n24     # For type annotation\n25     from typing import Type  # for python3.5.1\n26 \n27 \n28 _directive_regex = re.compile(r'\\.\\. \\S+::')\n29 _google_section_regex = re.compile(r'^(\\s|\\w)+:\\s*$')\n30 _google_typed_arg_regex = re.compile(r'\\s*(.+?)\\s*\\(\\s*(.*[^\\s]+)\\s*\\)')\n31 _numpy_section_regex = re.compile(r'^[=\\-`:\\'\"~^_*+#<>]{2,}\\s*$')\n32 _single_colon_regex = re.compile(r'(?<!:):(?!:)')\n33 _xref_or_code_regex = re.compile(\n34     r'((?::(?:[a-zA-Z0-9]+[\\-_+:.])*[a-zA-Z0-9]+:`.+?`)|'\n35     r'(?:``.+``))')\n36 _bullet_list_regex = re.compile(r'^(\\*|\\+|\\-)(\\s+\\S|\\s*$)')\n37 _enumerated_list_regex = re.compile(\n38     r'^(?P<paren>\\()?'\n39     r'(\\d+|#|[ivxlcdm]+|[IVXLCDM]+|[a-zA-Z])'\n40     r'(?(paren)\\)|\\.)(\\s+\\S|\\s*$)')\n41 \n42 \n43 class GoogleDocstring:\n44     \"\"\"Convert Google style docstrings to reStructuredText.\n45 \n46     Parameters\n47     ----------\n48     docstring : :obj:`str` or :obj:`list` of :obj:`str`\n49         The docstring to parse, given either as a string or split into\n50         individual lines.\n51     config: :obj:`sphinx.ext.napoleon.Config` or :obj:`sphinx.config.Config`\n52         The configuration settings to use. If not given, defaults to the\n53         config object on `app`; or if `app` is not given defaults to the\n54         a new :class:`sphinx.ext.napoleon.Config` object.\n55 \n56 \n57     Other Parameters\n58     ----------------\n59     app : :class:`sphinx.application.Sphinx`, optional\n60         Application object representing the Sphinx process.\n61     what : :obj:`str`, optional\n62         A string specifying the type of the object to which the docstring\n63         belongs. Valid values: \"module\", \"class\", \"exception\", \"function\",\n64         \"method\", \"attribute\".\n65     name : :obj:`str`, optional\n66         The fully qualified name of the object.\n67     obj : module, class, exception, function, method, or attribute\n68         The object to which the docstring belongs.\n69     options : :class:`sphinx.ext.autodoc.Options`, optional\n70         The options given to the directive: an object with attributes\n71         inherited_members, undoc_members, show_inheritance and noindex that\n72         are True if the flag option of same name was given to the auto\n73         directive.\n74 \n75 \n76     Example\n77     -------\n78     >>> from sphinx.ext.napoleon import Config\n79     >>> config = Config(napoleon_use_param=True, napoleon_use_rtype=True)\n80     >>> docstring = '''One line summary.\n81     ...\n82     ... Extended description.\n83     ...\n84     ... Args:\n85     ...   arg1(int): Description of `arg1`\n86     ...   arg2(str): Description of `arg2`\n87     ... Returns:\n88     ...   str: Description of return value.\n89     ... '''\n90     >>> print(GoogleDocstring(docstring, config))\n91     One line summary.\n92     <BLANKLINE>\n93     Extended description.\n94     <BLANKLINE>\n95     :param arg1: Description of `arg1`\n96     :type arg1: int\n97     :param arg2: Description of `arg2`\n98     :type arg2: str\n99     <BLANKLINE>\n100     :returns: Description of return value.\n101     :rtype: str\n102     <BLANKLINE>\n103 \n104     \"\"\"\n105 \n106     _name_rgx = re.compile(r\"^\\s*((?::(?P<role>\\S+):)?`(?P<name>~?[a-zA-Z0-9_.-]+)`|\"\n107                            r\" (?P<name2>~?[a-zA-Z0-9_.-]+))\\s*\", re.X)\n108 \n109     def __init__(self, docstring: Union[str, List[str]], config: SphinxConfig = None,\n110                  app: Sphinx = None, what: str = '', name: str = '',\n111                  obj: Any = None, options: Any = None) -> None:\n112         self._config = config\n113         self._app = app\n114 \n115         if not self._config:\n116             from sphinx.ext.napoleon import Config\n117             self._config = self._app.config if self._app else Config()  # type: ignore\n118 \n119         if not what:\n120             if inspect.isclass(obj):\n121                 what = 'class'\n122             elif inspect.ismodule(obj):\n123                 what = 'module'\n124             elif callable(obj):\n125                 what = 'function'\n126             else:\n127                 what = 'object'\n128 \n129         self._what = what\n130         self._name = name\n131         self._obj = obj\n132         self._opt = options\n133         if isinstance(docstring, str):\n134             lines = docstring.splitlines()\n135         else:\n136             lines = docstring\n137         self._line_iter = modify_iter(lines, modifier=lambda s: s.rstrip())\n138         self._parsed_lines = []  # type: List[str]\n139         self._is_in_section = False\n140         self._section_indent = 0\n141         if not hasattr(self, '_directive_sections'):\n142             self._directive_sections = []  # type: List[str]\n143         if not hasattr(self, '_sections'):\n144             self._sections = {\n145                 'args': self._parse_parameters_section,\n146                 'arguments': self._parse_parameters_section,\n147                 'attention': partial(self._parse_admonition, 'attention'),\n148                 'attributes': self._parse_attributes_section,\n149                 'caution': partial(self._parse_admonition, 'caution'),\n150                 'danger': partial(self._parse_admonition, 'danger'),\n151                 'error': partial(self._parse_admonition, 'error'),\n152                 'example': self._parse_examples_section,\n153                 'examples': self._parse_examples_section,\n154                 'hint': partial(self._parse_admonition, 'hint'),\n155                 'important': partial(self._parse_admonition, 'important'),\n156                 'keyword args': self._parse_keyword_arguments_section,\n157                 'keyword arguments': self._parse_keyword_arguments_section,\n158                 'methods': self._parse_methods_section,\n159                 'note': partial(self._parse_admonition, 'note'),\n160                 'notes': self._parse_notes_section,\n161                 'other parameters': self._parse_other_parameters_section,\n162                 'parameters': self._parse_parameters_section,\n163                 'return': self._parse_returns_section,\n164                 'returns': self._parse_returns_section,\n165                 'raises': self._parse_raises_section,\n166                 'references': self._parse_references_section,\n167                 'see also': self._parse_see_also_section,\n168                 'tip': partial(self._parse_admonition, 'tip'),\n169                 'todo': partial(self._parse_admonition, 'todo'),\n170                 'warning': partial(self._parse_admonition, 'warning'),\n171                 'warnings': partial(self._parse_admonition, 'warning'),\n172                 'warns': self._parse_warns_section,\n173                 'yield': self._parse_yields_section,\n174                 'yields': self._parse_yields_section,\n175             }  # type: Dict[str, Callable]\n176 \n177         self._load_custom_sections()\n178 \n179         self._parse()\n180 \n181     def __str__(self) -> str:\n182         \"\"\"Return the parsed docstring in reStructuredText format.\n183 \n184         Returns\n185         -------\n186         unicode\n187             Unicode version of the docstring.\n188 \n189         \"\"\"\n190         return '\\n'.join(self.lines())\n191 \n192     def lines(self) -> List[str]:\n193         \"\"\"Return the parsed lines of the docstring in reStructuredText format.\n194 \n195         Returns\n196         -------\n197         list(str)\n198             The lines of the docstring in a list.\n199 \n200         \"\"\"\n201         return self._parsed_lines\n202 \n203     def _consume_indented_block(self, indent: int = 1) -> List[str]:\n204         lines = []\n205         line = self._line_iter.peek()\n206         while(not self._is_section_break() and\n207               (not line or self._is_indented(line, indent))):\n208             lines.append(next(self._line_iter))\n209             line = self._line_iter.peek()\n210         return lines\n211 \n212     def _consume_contiguous(self) -> List[str]:\n213         lines = []\n214         while (self._line_iter.has_next() and\n215                self._line_iter.peek() and\n216                not self._is_section_header()):\n217             lines.append(next(self._line_iter))\n218         return lines\n219 \n220     def _consume_empty(self) -> List[str]:\n221         lines = []\n222         line = self._line_iter.peek()\n223         while self._line_iter.has_next() and not line:\n224             lines.append(next(self._line_iter))\n225             line = self._line_iter.peek()\n226         return lines\n227 \n228     def _consume_field(self, parse_type: bool = True, prefer_type: bool = False\n229                        ) -> Tuple[str, str, List[str]]:\n230         line = next(self._line_iter)\n231 \n232         before, colon, after = self._partition_field_on_colon(line)\n233         _name, _type, _desc = before, '', after\n234 \n235         if parse_type:\n236             match = _google_typed_arg_regex.match(before)\n237             if match:\n238                 _name = match.group(1)\n239                 _type = match.group(2)\n240 \n241         _name = self._escape_args_and_kwargs(_name)\n242 \n243         if prefer_type and not _type:\n244             _type, _name = _name, _type\n245         indent = self._get_indent(line) + 1\n246         _descs = [_desc] + self._dedent(self._consume_indented_block(indent))\n247         _descs = self.__class__(_descs, self._config).lines()\n248         return _name, _type, _descs\n249 \n250     def _consume_fields(self, parse_type: bool = True, prefer_type: bool = False\n251                         ) -> List[Tuple[str, str, List[str]]]:\n252         self._consume_empty()\n253         fields = []\n254         while not self._is_section_break():\n255             _name, _type, _desc = self._consume_field(parse_type, prefer_type)\n256             if _name or _type or _desc:\n257                 fields.append((_name, _type, _desc,))\n258         return fields\n259 \n260     def _consume_inline_attribute(self) -> Tuple[str, List[str]]:\n261         line = next(self._line_iter)\n262         _type, colon, _desc = self._partition_field_on_colon(line)\n263         if not colon or not _desc:\n264             _type, _desc = _desc, _type\n265             _desc += colon\n266         _descs = [_desc] + self._dedent(self._consume_to_end())\n267         _descs = self.__class__(_descs, self._config).lines()\n268         return _type, _descs\n269 \n270     def _consume_returns_section(self) -> List[Tuple[str, str, List[str]]]:\n271         lines = self._dedent(self._consume_to_next_section())\n272         if lines:\n273             before, colon, after = self._partition_field_on_colon(lines[0])\n274             _name, _type, _desc = '', '', lines\n275 \n276             if colon:\n277                 if after:\n278                     _desc = [after] + lines[1:]\n279                 else:\n280                     _desc = lines[1:]\n281 \n282                 _type = before\n283 \n284             _desc = self.__class__(_desc, self._config).lines()\n285             return [(_name, _type, _desc,)]\n286         else:\n287             return []\n288 \n289     def _consume_usage_section(self) -> List[str]:\n290         lines = self._dedent(self._consume_to_next_section())\n291         return lines\n292 \n293     def _consume_section_header(self) -> str:\n294         section = next(self._line_iter)\n295         stripped_section = section.strip(':')\n296         if stripped_section.lower() in self._sections:\n297             section = stripped_section\n298         return section\n299 \n300     def _consume_to_end(self) -> List[str]:\n301         lines = []\n302         while self._line_iter.has_next():\n303             lines.append(next(self._line_iter))\n304         return lines\n305 \n306     def _consume_to_next_section(self) -> List[str]:\n307         self._consume_empty()\n308         lines = []\n309         while not self._is_section_break():\n310             lines.append(next(self._line_iter))\n311         return lines + self._consume_empty()\n312 \n313     def _dedent(self, lines: List[str], full: bool = False) -> List[str]:\n314         if full:\n315             return [line.lstrip() for line in lines]\n316         else:\n317             min_indent = self._get_min_indent(lines)\n318             return [line[min_indent:] for line in lines]\n319 \n320     def _escape_args_and_kwargs(self, name: str) -> str:\n321         if name.endswith('_'):\n322             name = name[:-1] + r'\\_'\n323 \n324         if name[:2] == '**':\n325             return r'\\*\\*' + name[2:]\n326         elif name[:1] == '*':\n327             return r'\\*' + name[1:]\n328         else:\n329             return name\n330 \n331     def _fix_field_desc(self, desc: List[str]) -> List[str]:\n332         if self._is_list(desc):\n333             desc = [''] + desc\n334         elif desc[0].endswith('::'):\n335             desc_block = desc[1:]\n336             indent = self._get_indent(desc[0])\n337             block_indent = self._get_initial_indent(desc_block)\n338             if block_indent > indent:\n339                 desc = [''] + desc\n340             else:\n341                 desc = ['', desc[0]] + self._indent(desc_block, 4)\n342         return desc\n343 \n344     def _format_admonition(self, admonition: str, lines: List[str]) -> List[str]:\n345         lines = self._strip_empty(lines)\n346         if len(lines) == 1:\n347             return ['.. %s:: %s' % (admonition, lines[0].strip()), '']\n348         elif lines:\n349             lines = self._indent(self._dedent(lines), 3)\n350             return ['.. %s::' % admonition, ''] + lines + ['']\n351         else:\n352             return ['.. %s::' % admonition, '']\n353 \n354     def _format_block(self, prefix: str, lines: List[str], padding: str = None) -> List[str]:\n355         if lines:\n356             if padding is None:\n357                 padding = ' ' * len(prefix)\n358             result_lines = []\n359             for i, line in enumerate(lines):\n360                 if i == 0:\n361                     result_lines.append((prefix + line).rstrip())\n362                 elif line:\n363                     result_lines.append(padding + line)\n364                 else:\n365                     result_lines.append('')\n366             return result_lines\n367         else:\n368             return [prefix]\n369 \n370     def _format_docutils_params(self, fields: List[Tuple[str, str, List[str]]],\n371                                 field_role: str = 'param', type_role: str = 'type'\n372                                 ) -> List[str]:\n373         lines = []\n374         for _name, _type, _desc in fields:\n375             _desc = self._strip_empty(_desc)\n376             if any(_desc):\n377                 _desc = self._fix_field_desc(_desc)\n378                 field = ':%s %s: ' % (field_role, _name)\n379                 lines.extend(self._format_block(field, _desc))\n380             else:\n381                 lines.append(':%s %s:' % (field_role, _name))\n382 \n383             if _type:\n384                 lines.append(':%s %s: %s' % (type_role, _name, _type))\n385         return lines + ['']\n386 \n387     def _format_field(self, _name: str, _type: str, _desc: List[str]) -> List[str]:\n388         _desc = self._strip_empty(_desc)\n389         has_desc = any(_desc)\n390         separator = ' -- ' if has_desc else ''\n391         if _name:\n392             if _type:\n393                 if '`' in _type:\n394                     field = '**%s** (%s)%s' % (_name, _type, separator)\n395                 else:\n396                     field = '**%s** (*%s*)%s' % (_name, _type, separator)\n397             else:\n398                 field = '**%s**%s' % (_name, separator)\n399         elif _type:\n400             if '`' in _type:\n401                 field = '%s%s' % (_type, separator)\n402             else:\n403                 field = '*%s*%s' % (_type, separator)\n404         else:\n405             field = ''\n406 \n407         if has_desc:\n408             _desc = self._fix_field_desc(_desc)\n409             if _desc[0]:\n410                 return [field + _desc[0]] + _desc[1:]\n411             else:\n412                 return [field] + _desc\n413         else:\n414             return [field]\n415 \n416     def _format_fields(self, field_type: str, fields: List[Tuple[str, str, List[str]]]\n417                        ) -> List[str]:\n418         field_type = ':%s:' % field_type.strip()\n419         padding = ' ' * len(field_type)\n420         multi = len(fields) > 1\n421         lines = []  # type: List[str]\n422         for _name, _type, _desc in fields:\n423             field = self._format_field(_name, _type, _desc)\n424             if multi:\n425                 if lines:\n426                     lines.extend(self._format_block(padding + ' * ', field))\n427                 else:\n428                     lines.extend(self._format_block(field_type + ' * ', field))\n429             else:\n430                 lines.extend(self._format_block(field_type + ' ', field))\n431         if lines and lines[-1]:\n432             lines.append('')\n433         return lines\n434 \n435     def _get_current_indent(self, peek_ahead: int = 0) -> int:\n436         line = self._line_iter.peek(peek_ahead + 1)[peek_ahead]\n437         while line != self._line_iter.sentinel:\n438             if line:\n439                 return self._get_indent(line)\n440             peek_ahead += 1\n441             line = self._line_iter.peek(peek_ahead + 1)[peek_ahead]\n442         return 0\n443 \n444     def _get_indent(self, line: str) -> int:\n445         for i, s in enumerate(line):\n446             if not s.isspace():\n447                 return i\n448         return len(line)\n449 \n450     def _get_initial_indent(self, lines: List[str]) -> int:\n451         for line in lines:\n452             if line:\n453                 return self._get_indent(line)\n454         return 0\n455 \n456     def _get_min_indent(self, lines: List[str]) -> int:\n457         min_indent = None\n458         for line in lines:\n459             if line:\n460                 indent = self._get_indent(line)\n461                 if min_indent is None:\n462                     min_indent = indent\n463                 elif indent < min_indent:\n464                     min_indent = indent\n465         return min_indent or 0\n466 \n467     def _indent(self, lines: List[str], n: int = 4) -> List[str]:\n468         return [(' ' * n) + line for line in lines]\n469 \n470     def _is_indented(self, line: str, indent: int = 1) -> bool:\n471         for i, s in enumerate(line):\n472             if i >= indent:\n473                 return True\n474             elif not s.isspace():\n475                 return False\n476         return False\n477 \n478     def _is_list(self, lines: List[str]) -> bool:\n479         if not lines:\n480             return False\n481         if _bullet_list_regex.match(lines[0]):\n482             return True\n483         if _enumerated_list_regex.match(lines[0]):\n484             return True\n485         if len(lines) < 2 or lines[0].endswith('::'):\n486             return False\n487         indent = self._get_indent(lines[0])\n488         next_indent = indent\n489         for line in lines[1:]:\n490             if line:\n491                 next_indent = self._get_indent(line)\n492                 break\n493         return next_indent > indent\n494 \n495     def _is_section_header(self) -> bool:\n496         section = self._line_iter.peek().lower()\n497         match = _google_section_regex.match(section)\n498         if match and section.strip(':') in self._sections:\n499             header_indent = self._get_indent(section)\n500             section_indent = self._get_current_indent(peek_ahead=1)\n501             return section_indent > header_indent\n502         elif self._directive_sections:\n503             if _directive_regex.match(section):\n504                 for directive_section in self._directive_sections:\n505                     if section.startswith(directive_section):\n506                         return True\n507         return False\n508 \n509     def _is_section_break(self) -> bool:\n510         line = self._line_iter.peek()\n511         return (not self._line_iter.has_next() or\n512                 self._is_section_header() or\n513                 (self._is_in_section and\n514                     line and\n515                     not self._is_indented(line, self._section_indent)))\n516 \n517     def _load_custom_sections(self) -> None:\n518         if self._config.napoleon_custom_sections is not None:\n519             for entry in self._config.napoleon_custom_sections:\n520                 if isinstance(entry, str):\n521                     # if entry is just a label, add to sections list,\n522                     # using generic section logic.\n523                     self._sections[entry.lower()] = self._parse_custom_generic_section\n524                 else:\n525                     # otherwise, assume entry is container;\n526                     # [0] is new section, [1] is the section to alias.\n527                     # in the case of key mismatch, just handle as generic section.\n528                     self._sections[entry[0].lower()] = \\\n529                         self._sections.get(entry[1].lower(),\n530                                            self._parse_custom_generic_section)\n531 \n532     def _parse(self) -> None:\n533         self._parsed_lines = self._consume_empty()\n534 \n535         if self._name and self._what in ('attribute', 'data', 'property'):\n536             # Implicit stop using StopIteration no longer allowed in\n537             # Python 3.7; see PEP 479\n538             res = []  # type: List[str]\n539             try:\n540                 res = self._parse_attribute_docstring()\n541             except StopIteration:\n542                 pass\n543             self._parsed_lines.extend(res)\n544             return\n545 \n546         while self._line_iter.has_next():\n547             if self._is_section_header():\n548                 try:\n549                     section = self._consume_section_header()\n550                     self._is_in_section = True\n551                     self._section_indent = self._get_current_indent()\n552                     if _directive_regex.match(section):\n553                         lines = [section] + self._consume_to_next_section()\n554                     else:\n555                         lines = self._sections[section.lower()](section)\n556                 finally:\n557                     self._is_in_section = False\n558                     self._section_indent = 0\n559             else:\n560                 if not self._parsed_lines:\n561                     lines = self._consume_contiguous() + self._consume_empty()\n562                 else:\n563                     lines = self._consume_to_next_section()\n564             self._parsed_lines.extend(lines)\n565 \n566     def _parse_admonition(self, admonition: str, section: str) -> List[str]:\n567         # type (str, str) -> List[str]\n568         lines = self._consume_to_next_section()\n569         return self._format_admonition(admonition, lines)\n570 \n571     def _parse_attribute_docstring(self) -> List[str]:\n572         _type, _desc = self._consume_inline_attribute()\n573         lines = self._format_field('', '', _desc)\n574         if _type:\n575             lines.extend(['', ':type: %s' % _type])\n576         return lines\n577 \n578     def _parse_attributes_section(self, section: str) -> List[str]:\n579         lines = []\n580         for _name, _type, _desc in self._consume_fields():\n581             if self._config.napoleon_use_ivar:\n582                 _name = self._qualify_name(_name, self._obj)\n583                 field = ':ivar %s: ' % _name\n584                 lines.extend(self._format_block(field, _desc))\n585                 if _type:\n586                     lines.append(':vartype %s: %s' % (_name, _type))\n587             else:\n588                 lines.append('.. attribute:: ' + _name)\n589                 if self._opt and 'noindex' in self._opt:\n590                     lines.append('   :noindex:')\n591                 if _type:\n592                     lines.extend(self._indent([':type: %s' % _type], 3))\n593                 lines.append('')\n594 \n595                 fields = self._format_field('', '', _desc)\n596                 lines.extend(self._indent(fields, 3))\n597                 lines.append('')\n598         if self._config.napoleon_use_ivar:\n599             lines.append('')\n600         return lines\n601 \n602     def _parse_examples_section(self, section: str) -> List[str]:\n603         labels = {\n604             'example': _('Example'),\n605             'examples': _('Examples'),\n606         }\n607         use_admonition = self._config.napoleon_use_admonition_for_examples\n608         label = labels.get(section.lower(), section)\n609         return self._parse_generic_section(label, use_admonition)\n610 \n611     def _parse_custom_generic_section(self, section: str) -> List[str]:\n612         # for now, no admonition for simple custom sections\n613         return self._parse_generic_section(section, False)\n614 \n615     def _parse_usage_section(self, section: str) -> List[str]:\n616         header = ['.. rubric:: Usage:', '']\n617         block = ['.. code-block:: python', '']\n618         lines = self._consume_usage_section()\n619         lines = self._indent(lines, 3)\n620         return header + block + lines + ['']\n621 \n622     def _parse_generic_section(self, section: str, use_admonition: bool) -> List[str]:\n623         lines = self._strip_empty(self._consume_to_next_section())\n624         lines = self._dedent(lines)\n625         if use_admonition:\n626             header = '.. admonition:: %s' % section\n627             lines = self._indent(lines, 3)\n628         else:\n629             header = '.. rubric:: %s' % section\n630         if lines:\n631             return [header, ''] + lines + ['']\n632         else:\n633             return [header, '']\n634 \n635     def _parse_keyword_arguments_section(self, section: str) -> List[str]:\n636         fields = self._consume_fields()\n637         if self._config.napoleon_use_keyword:\n638             return self._format_docutils_params(\n639                 fields,\n640                 field_role=\"keyword\",\n641                 type_role=\"kwtype\")\n642         else:\n643             return self._format_fields(_('Keyword Arguments'), fields)\n644 \n645     def _parse_methods_section(self, section: str) -> List[str]:\n646         lines = []  # type: List[str]\n647         for _name, _type, _desc in self._consume_fields(parse_type=False):\n648             lines.append('.. method:: %s' % _name)\n649             if self._opt and 'noindex' in self._opt:\n650                 lines.append('   :noindex:')\n651             if _desc:\n652                 lines.extend([''] + self._indent(_desc, 3))\n653             lines.append('')\n654         return lines\n655 \n656     def _parse_notes_section(self, section: str) -> List[str]:\n657         use_admonition = self._config.napoleon_use_admonition_for_notes\n658         return self._parse_generic_section(_('Notes'), use_admonition)\n659 \n660     def _parse_other_parameters_section(self, section: str) -> List[str]:\n661         return self._format_fields(_('Other Parameters'), self._consume_fields())\n662 \n663     def _parse_parameters_section(self, section: str) -> List[str]:\n664         fields = self._consume_fields()\n665         if self._config.napoleon_use_param:\n666             return self._format_docutils_params(fields)\n667         else:\n668             return self._format_fields(_('Parameters'), fields)\n669 \n670     def _parse_raises_section(self, section: str) -> List[str]:\n671         fields = self._consume_fields(parse_type=False, prefer_type=True)\n672         lines = []  # type: List[str]\n673         for _name, _type, _desc in fields:\n674             m = self._name_rgx.match(_type)\n675             if m and m.group('name'):\n676                 _type = m.group('name')\n677             _type = ' ' + _type if _type else ''\n678             _desc = self._strip_empty(_desc)\n679             _descs = ' ' + '\\n    '.join(_desc) if any(_desc) else ''\n680             lines.append(':raises%s:%s' % (_type, _descs))\n681         if lines:\n682             lines.append('')\n683         return lines\n684 \n685     def _parse_references_section(self, section: str) -> List[str]:\n686         use_admonition = self._config.napoleon_use_admonition_for_references\n687         return self._parse_generic_section(_('References'), use_admonition)\n688 \n689     def _parse_returns_section(self, section: str) -> List[str]:\n690         fields = self._consume_returns_section()\n691         multi = len(fields) > 1\n692         if multi:\n693             use_rtype = False\n694         else:\n695             use_rtype = self._config.napoleon_use_rtype\n696 \n697         lines = []  # type: List[str]\n698         for _name, _type, _desc in fields:\n699             if use_rtype:\n700                 field = self._format_field(_name, '', _desc)\n701             else:\n702                 field = self._format_field(_name, _type, _desc)\n703 \n704             if multi:\n705                 if lines:\n706                     lines.extend(self._format_block('          * ', field))\n707                 else:\n708                     lines.extend(self._format_block(':returns: * ', field))\n709             else:\n710                 lines.extend(self._format_block(':returns: ', field))\n711                 if _type and use_rtype:\n712                     lines.extend([':rtype: %s' % _type, ''])\n713         if lines and lines[-1]:\n714             lines.append('')\n715         return lines\n716 \n717     def _parse_see_also_section(self, section: str) -> List[str]:\n718         return self._parse_admonition('seealso', section)\n719 \n720     def _parse_warns_section(self, section: str) -> List[str]:\n721         return self._format_fields(_('Warns'), self._consume_fields())\n722 \n723     def _parse_yields_section(self, section: str) -> List[str]:\n724         fields = self._consume_returns_section()\n725         return self._format_fields(_('Yields'), fields)\n726 \n727     def _partition_field_on_colon(self, line: str) -> Tuple[str, str, str]:\n728         before_colon = []\n729         after_colon = []\n730         colon = ''\n731         found_colon = False\n732         for i, source in enumerate(_xref_or_code_regex.split(line)):\n733             if found_colon:\n734                 after_colon.append(source)\n735             else:\n736                 m = _single_colon_regex.search(source)\n737                 if (i % 2) == 0 and m:\n738                     found_colon = True\n739                     colon = source[m.start(): m.end()]\n740                     before_colon.append(source[:m.start()])\n741                     after_colon.append(source[m.end():])\n742                 else:\n743                     before_colon.append(source)\n744 \n745         return (\"\".join(before_colon).strip(),\n746                 colon,\n747                 \"\".join(after_colon).strip())\n748 \n749     def _qualify_name(self, attr_name: str, klass: \"Type\") -> str:\n750         if klass and '.' not in attr_name:\n751             if attr_name.startswith('~'):\n752                 attr_name = attr_name[1:]\n753             try:\n754                 q = klass.__qualname__\n755             except AttributeError:\n756                 q = klass.__name__\n757             return '~%s.%s' % (q, attr_name)\n758         return attr_name\n759 \n760     def _strip_empty(self, lines: List[str]) -> List[str]:\n761         if lines:\n762             start = -1\n763             for i, line in enumerate(lines):\n764                 if line:\n765                     start = i\n766                     break\n767             if start == -1:\n768                 lines = []\n769             end = -1\n770             for i in reversed(range(len(lines))):\n771                 line = lines[i]\n772                 if line:\n773                     end = i\n774                     break\n775             if start > 0 or end + 1 < len(lines):\n776                 lines = lines[start:end + 1]\n777         return lines\n778 \n779 \n780 class NumpyDocstring(GoogleDocstring):\n781     \"\"\"Convert NumPy style docstrings to reStructuredText.\n782 \n783     Parameters\n784     ----------\n785     docstring : :obj:`str` or :obj:`list` of :obj:`str`\n786         The docstring to parse, given either as a string or split into\n787         individual lines.\n788     config: :obj:`sphinx.ext.napoleon.Config` or :obj:`sphinx.config.Config`\n789         The configuration settings to use. If not given, defaults to the\n790         config object on `app`; or if `app` is not given defaults to the\n791         a new :class:`sphinx.ext.napoleon.Config` object.\n792 \n793 \n794     Other Parameters\n795     ----------------\n796     app : :class:`sphinx.application.Sphinx`, optional\n797         Application object representing the Sphinx process.\n798     what : :obj:`str`, optional\n799         A string specifying the type of the object to which the docstring\n800         belongs. Valid values: \"module\", \"class\", \"exception\", \"function\",\n801         \"method\", \"attribute\".\n802     name : :obj:`str`, optional\n803         The fully qualified name of the object.\n804     obj : module, class, exception, function, method, or attribute\n805         The object to which the docstring belongs.\n806     options : :class:`sphinx.ext.autodoc.Options`, optional\n807         The options given to the directive: an object with attributes\n808         inherited_members, undoc_members, show_inheritance and noindex that\n809         are True if the flag option of same name was given to the auto\n810         directive.\n811 \n812 \n813     Example\n814     -------\n815     >>> from sphinx.ext.napoleon import Config\n816     >>> config = Config(napoleon_use_param=True, napoleon_use_rtype=True)\n817     >>> docstring = '''One line summary.\n818     ...\n819     ... Extended description.\n820     ...\n821     ... Parameters\n822     ... ----------\n823     ... arg1 : int\n824     ...     Description of `arg1`\n825     ... arg2 : str\n826     ...     Description of `arg2`\n827     ... Returns\n828     ... -------\n829     ... str\n830     ...     Description of return value.\n831     ... '''\n832     >>> print(NumpyDocstring(docstring, config))\n833     One line summary.\n834     <BLANKLINE>\n835     Extended description.\n836     <BLANKLINE>\n837     :param arg1: Description of `arg1`\n838     :type arg1: int\n839     :param arg2: Description of `arg2`\n840     :type arg2: str\n841     <BLANKLINE>\n842     :returns: Description of return value.\n843     :rtype: str\n844     <BLANKLINE>\n845 \n846     Methods\n847     -------\n848     __str__()\n849         Return the parsed docstring in reStructuredText format.\n850 \n851         Returns\n852         -------\n853         str\n854             UTF-8 encoded version of the docstring.\n855 \n856     __unicode__()\n857         Return the parsed docstring in reStructuredText format.\n858 \n859         Returns\n860         -------\n861         unicode\n862             Unicode version of the docstring.\n863 \n864     lines()\n865         Return the parsed lines of the docstring in reStructuredText format.\n866 \n867         Returns\n868         -------\n869         list(str)\n870             The lines of the docstring in a list.\n871 \n872     \"\"\"\n873     def __init__(self, docstring: Union[str, List[str]], config: SphinxConfig = None,\n874                  app: Sphinx = None, what: str = '', name: str = '',\n875                  obj: Any = None, options: Any = None) -> None:\n876         self._directive_sections = ['.. index::']\n877         super().__init__(docstring, config, app, what, name, obj, options)\n878 \n879     def _consume_field(self, parse_type: bool = True, prefer_type: bool = False\n880                        ) -> Tuple[str, str, List[str]]:\n881         line = next(self._line_iter)\n882         if parse_type:\n883             _name, _, _type = self._partition_field_on_colon(line)\n884         else:\n885             _name, _type = line, ''\n886         _name, _type = _name.strip(), _type.strip()\n887         _name = self._escape_args_and_kwargs(_name)\n888 \n889         if prefer_type and not _type:\n890             _type, _name = _name, _type\n891         indent = self._get_indent(line) + 1\n892         _desc = self._dedent(self._consume_indented_block(indent))\n893         _desc = self.__class__(_desc, self._config).lines()\n894         return _name, _type, _desc\n895 \n896     def _consume_returns_section(self) -> List[Tuple[str, str, List[str]]]:\n897         return self._consume_fields(prefer_type=True)\n898 \n899     def _consume_section_header(self) -> str:\n900         section = next(self._line_iter)\n901         if not _directive_regex.match(section):\n902             # Consume the header underline\n903             next(self._line_iter)\n904         return section\n905 \n906     def _is_section_break(self) -> bool:\n907         line1, line2 = self._line_iter.peek(2)\n908         return (not self._line_iter.has_next() or\n909                 self._is_section_header() or\n910                 ['', ''] == [line1, line2] or\n911                 (self._is_in_section and\n912                     line1 and\n913                     not self._is_indented(line1, self._section_indent)))\n914 \n915     def _is_section_header(self) -> bool:\n916         section, underline = self._line_iter.peek(2)\n917         section = section.lower()\n918         if section in self._sections and isinstance(underline, str):\n919             return bool(_numpy_section_regex.match(underline))\n920         elif self._directive_sections:\n921             if _directive_regex.match(section):\n922                 for directive_section in self._directive_sections:\n923                     if section.startswith(directive_section):\n924                         return True\n925         return False\n926 \n927     def _parse_see_also_section(self, section: str) -> List[str]:\n928         lines = self._consume_to_next_section()\n929         try:\n930             return self._parse_numpydoc_see_also_section(lines)\n931         except ValueError:\n932             return self._format_admonition('seealso', lines)\n933 \n934     def _parse_numpydoc_see_also_section(self, content: List[str]) -> List[str]:\n935         \"\"\"\n936         Derived from the NumpyDoc implementation of _parse_see_also.\n937 \n938         See Also\n939         --------\n940         func_name : Descriptive text\n941             continued text\n942         another_func_name : Descriptive text\n943         func_name1, func_name2, :meth:`func_name`, func_name3\n944 \n945         \"\"\"\n946         items = []\n947 \n948         def parse_item_name(text: str) -> Tuple[str, str]:\n949             \"\"\"Match ':role:`name`' or 'name'\"\"\"\n950             m = self._name_rgx.match(text)\n951             if m:\n952                 g = m.groups()\n953                 if g[1] is None:\n954                     return g[3], None\n955                 else:\n956                     return g[2], g[1]\n957             raise ValueError(\"%s is not a item name\" % text)\n958 \n959         def push_item(name: str, rest: List[str]) -> None:\n960             if not name:\n961                 return\n962             name, role = parse_item_name(name)\n963             items.append((name, list(rest), role))\n964             del rest[:]\n965 \n966         current_func = None\n967         rest = []  # type: List[str]\n968 \n969         for line in content:\n970             if not line.strip():\n971                 continue\n972 \n973             m = self._name_rgx.match(line)\n974             if m and line[m.end():].strip().startswith(':'):\n975                 push_item(current_func, rest)\n976                 current_func, line = line[:m.end()], line[m.end():]\n977                 rest = [line.split(':', 1)[1].strip()]\n978                 if not rest[0]:\n979                     rest = []\n980             elif not line.startswith(' '):\n981                 push_item(current_func, rest)\n982                 current_func = None\n983                 if ',' in line:\n984                     for func in line.split(','):\n985                         if func.strip():\n986                             push_item(func, [])\n987                 elif line.strip():\n988                     current_func = line\n989             elif current_func is not None:\n990                 rest.append(line.strip())\n991         push_item(current_func, rest)\n992 \n993         if not items:\n994             return []\n995 \n996         roles = {\n997             'method': 'meth',\n998             'meth': 'meth',\n999             'function': 'func',\n1000             'func': 'func',\n1001             'class': 'class',\n1002             'exception': 'exc',\n1003             'exc': 'exc',\n1004             'object': 'obj',\n1005             'obj': 'obj',\n1006             'module': 'mod',\n1007             'mod': 'mod',\n1008             'data': 'data',\n1009             'constant': 'const',\n1010             'const': 'const',\n1011             'attribute': 'attr',\n1012             'attr': 'attr'\n1013         }\n1014         if self._what is None:\n1015             func_role = 'obj'\n1016         else:\n1017             func_role = roles.get(self._what, '')\n1018         lines = []  # type: List[str]\n1019         last_had_desc = True\n1020         for func, desc, role in items:\n1021             if role:\n1022                 link = ':%s:`%s`' % (role, func)\n1023             elif func_role:\n1024                 link = ':%s:`%s`' % (func_role, func)\n1025             else:\n1026                 link = \"`%s`_\" % func\n1027             if desc or last_had_desc:\n1028                 lines += ['']\n1029                 lines += [link]\n1030             else:\n1031                 lines[-1] += \", %s\" % link\n1032             if desc:\n1033                 lines += self._indent([' '.join(desc)])\n1034                 last_had_desc = True\n1035             else:\n1036                 last_had_desc = False\n1037         lines += ['']\n1038 \n1039         return self._format_admonition('seealso', lines)\n",
        "intended_behavior": "This file should process attribute docstrings in a way that trailing underscores in attribute names are recognized as part of the identifier and not as characters requiring escape sequences in the generated HTML. The intended behavior is to ensure that when Napoleon parses attribute sections, it correctly formats attribute names, preserving trailing underscores without adding a backslash for the HTML output. This preserves the existing functionality for document generation while fixing the issue with attribute name representation."
    },
    {
        "rel_file_path": "sphinx/ext/autodoc/__init__.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__3.1/sphinx/ext/autodoc/__init__.py",
        "start": 1,
        "end": 1824,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2     sphinx.ext.autodoc\n3     ~~~~~~~~~~~~~~~~~~\n4 \n5     Automatically insert docstrings for functions, classes or whole modules into\n6     the doctree, thus avoiding duplication between docstrings and documentation\n7     for those who like elaborate docstrings.\n8 \n9     :copyright: Copyright 2007-2020 by the Sphinx team, see AUTHORS.\n10     :license: BSD, see LICENSE for details.\n11 \"\"\"\n12 \n13 import importlib\n14 import re\n15 import warnings\n16 from inspect import Parameter\n17 from types import ModuleType\n18 from typing import (\n19     Any, Callable, Dict, Iterator, List, Optional, Sequence, Set, Tuple, Type, Union\n20 )\n21 \n22 from docutils.statemachine import StringList\n23 \n24 import sphinx\n25 from sphinx.application import Sphinx\n26 from sphinx.config import Config, ENUM\n27 from sphinx.deprecation import RemovedInSphinx40Warning, RemovedInSphinx50Warning\n28 from sphinx.environment import BuildEnvironment\n29 from sphinx.ext.autodoc.importer import import_object, get_module_members, get_object_members\n30 from sphinx.ext.autodoc.mock import mock\n31 from sphinx.locale import _, __\n32 from sphinx.pycode import ModuleAnalyzer, PycodeError\n33 from sphinx.util import inspect\n34 from sphinx.util import logging\n35 from sphinx.util import split_full_qualified_name\n36 from sphinx.util.docstrings import extract_metadata, prepare_docstring\n37 from sphinx.util.inspect import getdoc, object_description, safe_getattr, stringify_signature\n38 from sphinx.util.typing import stringify as stringify_typehint\n39 \n40 if False:\n41     # For type annotation\n42     from typing import Type  # NOQA # for python3.5.1\n43     from sphinx.ext.autodoc.directive import DocumenterBridge\n44 \n45 \n46 logger = logging.getLogger(__name__)\n47 \n48 \n49 # This type isn't exposed directly in any modules, but can be found\n50 # here in most Python versions\n51 MethodDescriptorType = type(type.__subclasses__)\n52 \n53 \n54 #: extended signature RE: with explicit module name separated by ::\n55 py_ext_sig_re = re.compile(\n56     r'''^ ([\\w.]+::)?            # explicit module name\n57           ([\\w.]+\\.)?            # module and/or class name(s)\n58           (\\w+)  \\s*             # thing name\n59           (?: \\((.*)\\)           # optional: arguments\n60            (?:\\s* -> \\s* (.*))?  #           return annotation\n61           )? $                   # and nothing more\n62           ''', re.VERBOSE)\n63 \n64 \n65 def identity(x: Any) -> Any:\n66     return x\n67 \n68 \n69 ALL = object()\n70 UNINITIALIZED_ATTR = object()\n71 INSTANCEATTR = object()\n72 SLOTSATTR = object()\n73 \n74 \n75 def members_option(arg: Any) -> Union[object, List[str]]:\n76     \"\"\"Used to convert the :members: option to auto directives.\"\"\"\n77     if arg is None or arg is True:\n78         return ALL\n79     return [x.strip() for x in arg.split(',') if x.strip()]\n80 \n81 \n82 def members_set_option(arg: Any) -> Union[object, Set[str]]:\n83     \"\"\"Used to convert the :members: option to auto directives.\"\"\"\n84     if arg is None:\n85         return ALL\n86     return {x.strip() for x in arg.split(',') if x.strip()}\n87 \n88 \n89 def inherited_members_option(arg: Any) -> Union[object, Set[str]]:\n90     \"\"\"Used to convert the :members: option to auto directives.\"\"\"\n91     if arg is None:\n92         return 'object'\n93     else:\n94         return arg\n95 \n96 \n97 def member_order_option(arg: Any) -> Optional[str]:\n98     \"\"\"Used to convert the :members: option to auto directives.\"\"\"\n99     if arg is None:\n100         return None\n101     elif arg in ('alphabetical', 'bysource', 'groupwise'):\n102         return arg\n103     else:\n104         raise ValueError(__('invalid value for member-order option: %s') % arg)\n105 \n106 \n107 SUPPRESS = object()\n108 \n109 \n110 def annotation_option(arg: Any) -> Any:\n111     if arg is None:\n112         # suppress showing the representation of the object\n113         return SUPPRESS\n114     else:\n115         return arg\n116 \n117 \n118 def bool_option(arg: Any) -> bool:\n119     \"\"\"Used to convert flag options to auto directives.  (Instead of\n120     directives.flag(), which returns None).\n121     \"\"\"\n122     return True\n123 \n124 \n125 def merge_special_members_option(options: Dict) -> None:\n126     \"\"\"Merge :special-members: option to :members: option.\"\"\"\n127     if 'special-members' in options and options['special-members'] is not ALL:\n128         if options.get('members') is ALL:\n129             pass\n130         elif options.get('members'):\n131             for member in options['special-members']:\n132                 if member not in options['members']:\n133                     options['members'].append(member)\n134         else:\n135             options['members'] = options['special-members']\n136 \n137 \n138 # Some useful event listener factories for autodoc-process-docstring.\n139 \n140 def cut_lines(pre: int, post: int = 0, what: str = None) -> Callable:\n141     \"\"\"Return a listener that removes the first *pre* and last *post*\n142     lines of every docstring.  If *what* is a sequence of strings,\n143     only docstrings of a type in *what* will be processed.\n144 \n145     Use like this (e.g. in the ``setup()`` function of :file:`conf.py`)::\n146 \n147        from sphinx.ext.autodoc import cut_lines\n148        app.connect('autodoc-process-docstring', cut_lines(4, what=['module']))\n149 \n150     This can (and should) be used in place of :confval:`automodule_skip_lines`.\n151     \"\"\"\n152     def process(app: Sphinx, what_: str, name: str, obj: Any, options: Any, lines: List[str]\n153                 ) -> None:\n154         if what and what_ not in what:\n155             return\n156         del lines[:pre]\n157         if post:\n158             # remove one trailing blank line.\n159             if lines and not lines[-1]:\n160                 lines.pop(-1)\n161             del lines[-post:]\n162         # make sure there is a blank line at the end\n163         if lines and lines[-1]:\n164             lines.append('')\n165     return process\n166 \n167 \n168 def between(marker: str, what: Sequence[str] = None, keepempty: bool = False,\n169             exclude: bool = False) -> Callable:\n170     \"\"\"Return a listener that either keeps, or if *exclude* is True excludes,\n171     lines between lines that match the *marker* regular expression.  If no line\n172     matches, the resulting docstring would be empty, so no change will be made\n173     unless *keepempty* is true.\n174 \n175     If *what* is a sequence of strings, only docstrings of a type in *what* will\n176     be processed.\n177     \"\"\"\n178     marker_re = re.compile(marker)\n179 \n180     def process(app: Sphinx, what_: str, name: str, obj: Any, options: Any, lines: List[str]\n181                 ) -> None:\n182         if what and what_ not in what:\n183             return\n184         deleted = 0\n185         delete = not exclude\n186         orig_lines = lines[:]\n187         for i, line in enumerate(orig_lines):\n188             if delete:\n189                 lines.pop(i - deleted)\n190                 deleted += 1\n191             if marker_re.match(line):\n192                 delete = not delete\n193                 if delete:\n194                     lines.pop(i - deleted)\n195                     deleted += 1\n196         if not lines and not keepempty:\n197             lines[:] = orig_lines\n198         # make sure there is a blank line at the end\n199         if lines and lines[-1]:\n200             lines.append('')\n201     return process\n202 \n203 \n204 # This class is used only in ``sphinx.ext.autodoc.directive``,\n205 # But we define this class here to keep compatibility (see #4538)\n206 class Options(dict):\n207     \"\"\"A dict/attribute hybrid that returns None on nonexisting keys.\"\"\"\n208     def __getattr__(self, name: str) -> Any:\n209         try:\n210             return self[name.replace('_', '-')]\n211         except KeyError:\n212             return None\n213 \n214 \n215 class Documenter:\n216     \"\"\"\n217     A Documenter knows how to autodocument a single object type.  When\n218     registered with the AutoDirective, it will be used to document objects\n219     of that type when needed by autodoc.\n220 \n221     Its *objtype* attribute selects what auto directive it is assigned to\n222     (the directive name is 'auto' + objtype), and what directive it generates\n223     by default, though that can be overridden by an attribute called\n224     *directivetype*.\n225 \n226     A Documenter has an *option_spec* that works like a docutils directive's;\n227     in fact, it will be used to parse an auto directive's options that matches\n228     the documenter.\n229     \"\"\"\n230     #: name by which the directive is called (auto...) and the default\n231     #: generated directive name\n232     objtype = 'object'\n233     #: indentation by which to indent the directive content\n234     content_indent = '   '\n235     #: priority if multiple documenters return True from can_document_member\n236     priority = 0\n237     #: order if autodoc_member_order is set to 'groupwise'\n238     member_order = 0\n239     #: true if the generated content may contain titles\n240     titles_allowed = False\n241 \n242     option_spec = {'noindex': bool_option}  # type: Dict[str, Callable]\n243 \n244     def get_attr(self, obj: Any, name: str, *defargs: Any) -> Any:\n245         \"\"\"getattr() override for types such as Zope interfaces.\"\"\"\n246         return autodoc_attrgetter(self.env.app, obj, name, *defargs)\n247 \n248     @classmethod\n249     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n250                             ) -> bool:\n251         \"\"\"Called to see if a member can be documented by this documenter.\"\"\"\n252         raise NotImplementedError('must be implemented in subclasses')\n253 \n254     def __init__(self, directive: \"DocumenterBridge\", name: str, indent: str = '') -> None:\n255         self.directive = directive\n256         self.env = directive.env    # type: BuildEnvironment\n257         self.options = directive.genopt\n258         self.name = name\n259         self.indent = indent\n260         # the module and object path within the module, and the fully\n261         # qualified name (all set after resolve_name succeeds)\n262         self.modname = None         # type: str\n263         self.module = None          # type: ModuleType\n264         self.objpath = None         # type: List[str]\n265         self.fullname = None        # type: str\n266         # extra signature items (arguments and return annotation,\n267         # also set after resolve_name succeeds)\n268         self.args = None            # type: str\n269         self.retann = None          # type: str\n270         # the object to document (set after import_object succeeds)\n271         self.object = None          # type: Any\n272         self.object_name = None     # type: str\n273         # the parent/owner of the object to document\n274         self.parent = None          # type: Any\n275         # the module analyzer to get at attribute docs, or None\n276         self.analyzer = None        # type: ModuleAnalyzer\n277 \n278     @property\n279     def documenters(self) -> Dict[str, \"Type[Documenter]\"]:\n280         \"\"\"Returns registered Documenter classes\"\"\"\n281         return self.env.app.registry.documenters\n282 \n283     def add_line(self, line: str, source: str, *lineno: int) -> None:\n284         \"\"\"Append one line of generated reST to the output.\"\"\"\n285         if line.strip():  # not a blank line\n286             self.directive.result.append(self.indent + line, source, *lineno)\n287         else:\n288             self.directive.result.append('', source, *lineno)\n289 \n290     def resolve_name(self, modname: str, parents: Any, path: str, base: Any\n291                      ) -> Tuple[str, List[str]]:\n292         \"\"\"Resolve the module and name of the object to document given by the\n293         arguments and the current module/class.\n294 \n295         Must return a pair of the module name and a chain of attributes; for\n296         example, it would return ``('zipfile', ['ZipFile', 'open'])`` for the\n297         ``zipfile.ZipFile.open`` method.\n298         \"\"\"\n299         raise NotImplementedError('must be implemented in subclasses')\n300 \n301     def parse_name(self) -> bool:\n302         \"\"\"Determine what module to import and what attribute to document.\n303 \n304         Returns True and sets *self.modname*, *self.objpath*, *self.fullname*,\n305         *self.args* and *self.retann* if parsing and resolving was successful.\n306         \"\"\"\n307         # first, parse the definition -- auto directives for classes and\n308         # functions can contain a signature which is then used instead of\n309         # an autogenerated one\n310         try:\n311             explicit_modname, path, base, args, retann = \\\n312                 py_ext_sig_re.match(self.name).groups()\n313         except AttributeError:\n314             logger.warning(__('invalid signature for auto%s (%r)') % (self.objtype, self.name),\n315                            type='autodoc')\n316             return False\n317 \n318         # support explicit module and class name separation via ::\n319         if explicit_modname is not None:\n320             modname = explicit_modname[:-2]\n321             parents = path.rstrip('.').split('.') if path else []\n322         else:\n323             modname = None\n324             parents = []\n325 \n326         with mock(self.env.config.autodoc_mock_imports):\n327             self.modname, self.objpath = self.resolve_name(modname, parents, path, base)\n328 \n329         if not self.modname:\n330             return False\n331 \n332         self.args = args\n333         self.retann = retann\n334         self.fullname = (self.modname or '') + \\\n335                         ('.' + '.'.join(self.objpath) if self.objpath else '')\n336         return True\n337 \n338     def import_object(self) -> bool:\n339         \"\"\"Import the object given by *self.modname* and *self.objpath* and set\n340         it as *self.object*.\n341 \n342         Returns True if successful, False if an error occurred.\n343         \"\"\"\n344         with mock(self.env.config.autodoc_mock_imports):\n345             try:\n346                 ret = import_object(self.modname, self.objpath, self.objtype,\n347                                     attrgetter=self.get_attr,\n348                                     warningiserror=self.env.config.autodoc_warningiserror)\n349                 self.module, self.parent, self.object_name, self.object = ret\n350                 return True\n351             except ImportError as exc:\n352                 logger.warning(exc.args[0], type='autodoc', subtype='import_object')\n353                 self.env.note_reread()\n354                 return False\n355 \n356     def get_real_modname(self) -> str:\n357         \"\"\"Get the real module name of an object to document.\n358 \n359         It can differ from the name of the module through which the object was\n360         imported.\n361         \"\"\"\n362         return self.get_attr(self.object, '__module__', None) or self.modname\n363 \n364     def check_module(self) -> bool:\n365         \"\"\"Check if *self.object* is really defined in the module given by\n366         *self.modname*.\n367         \"\"\"\n368         if self.options.imported_members:\n369             return True\n370 \n371         subject = inspect.unpartial(self.object)\n372         modname = self.get_attr(subject, '__module__', None)\n373         if modname and modname != self.modname:\n374             return False\n375         return True\n376 \n377     def format_args(self, **kwargs: Any) -> str:\n378         \"\"\"Format the argument signature of *self.object*.\n379 \n380         Should return None if the object does not have a signature.\n381         \"\"\"\n382         return None\n383 \n384     def format_name(self) -> str:\n385         \"\"\"Format the name of *self.object*.\n386 \n387         This normally should be something that can be parsed by the generated\n388         directive, but doesn't need to be (Sphinx will display it unparsed\n389         then).\n390         \"\"\"\n391         # normally the name doesn't contain the module (except for module\n392         # directives of course)\n393         return '.'.join(self.objpath) or self.modname\n394 \n395     def format_signature(self, **kwargs: Any) -> str:\n396         \"\"\"Format the signature (arguments and return annotation) of the object.\n397 \n398         Let the user process it via the ``autodoc-process-signature`` event.\n399         \"\"\"\n400         if self.args is not None:\n401             # signature given explicitly\n402             args = \"(%s)\" % self.args\n403             retann = self.retann\n404         else:\n405             # try to introspect the signature\n406             try:\n407                 retann = None\n408                 try:\n409                     args = self.format_args(**kwargs)\n410                 except TypeError:\n411                     # retry without arguments for old documenters\n412                     args = self.format_args()\n413 \n414                 if args:\n415                     matched = re.match(r'^(\\(.*\\))\\s+->\\s+(.*)$', args)\n416                     if matched:\n417                         args = matched.group(1)\n418                         retann = matched.group(2)\n419             except Exception:\n420                 logger.warning(__('error while formatting arguments for %s:') %\n421                                self.fullname, type='autodoc', exc_info=True)\n422                 args = None\n423 \n424         result = self.env.events.emit_firstresult('autodoc-process-signature',\n425                                                   self.objtype, self.fullname,\n426                                                   self.object, self.options, args, retann)\n427         if result:\n428             args, retann = result\n429 \n430         if args is not None:\n431             return args + ((' -> %s' % retann) if retann else '')\n432         else:\n433             return ''\n434 \n435     def add_directive_header(self, sig: str) -> None:\n436         \"\"\"Add the directive header and options to the generated content.\"\"\"\n437         domain = getattr(self, 'domain', 'py')\n438         directive = getattr(self, 'directivetype', self.objtype)\n439         name = self.format_name()\n440         sourcename = self.get_sourcename()\n441 \n442         # one signature per line, indented by column\n443         prefix = '.. %s:%s:: ' % (domain, directive)\n444         for i, sig_line in enumerate(sig.split(\"\\n\")):\n445             self.add_line('%s%s%s' % (prefix, name, sig_line),\n446                           sourcename)\n447             if i == 0:\n448                 prefix = \" \" * len(prefix)\n449 \n450         if self.options.noindex:\n451             self.add_line('   :noindex:', sourcename)\n452         if self.objpath:\n453             # Be explicit about the module, this is necessary since .. class::\n454             # etc. don't support a prepended module name\n455             self.add_line('   :module: %s' % self.modname, sourcename)\n456 \n457     def get_doc(self, encoding: str = None, ignore: int = None) -> List[List[str]]:\n458         \"\"\"Decode and return lines of the docstring(s) for the object.\"\"\"\n459         if encoding is not None:\n460             warnings.warn(\"The 'encoding' argument to autodoc.%s.get_doc() is deprecated.\"\n461                           % self.__class__.__name__,\n462                           RemovedInSphinx40Warning, stacklevel=2)\n463         if ignore is not None:\n464             warnings.warn(\"The 'ignore' argument to autodoc.%s.get_doc() is deprecated.\"\n465                           % self.__class__.__name__,\n466                           RemovedInSphinx50Warning, stacklevel=2)\n467         docstring = getdoc(self.object, self.get_attr,\n468                            self.env.config.autodoc_inherit_docstrings,\n469                            self.parent, self.object_name)\n470         if docstring:\n471             tab_width = self.directive.state.document.settings.tab_width\n472             return [prepare_docstring(docstring, ignore, tab_width)]\n473         return []\n474 \n475     def process_doc(self, docstrings: List[List[str]]) -> Iterator[str]:\n476         \"\"\"Let the user process the docstrings before adding them.\"\"\"\n477         for docstringlines in docstrings:\n478             if self.env.app:\n479                 # let extensions preprocess docstrings\n480                 self.env.app.emit('autodoc-process-docstring',\n481                                   self.objtype, self.fullname, self.object,\n482                                   self.options, docstringlines)\n483             yield from docstringlines\n484 \n485     def get_sourcename(self) -> str:\n486         if self.analyzer:\n487             return '%s:docstring of %s' % (self.analyzer.srcname, self.fullname)\n488         return 'docstring of %s' % self.fullname\n489 \n490     def add_content(self, more_content: Any, no_docstring: bool = False) -> None:\n491         \"\"\"Add content from docstrings, attribute documentation and user.\"\"\"\n492         # set sourcename and add content from attribute documentation\n493         sourcename = self.get_sourcename()\n494         if self.analyzer:\n495             attr_docs = self.analyzer.find_attr_docs()\n496             if self.objpath:\n497                 key = ('.'.join(self.objpath[:-1]), self.objpath[-1])\n498                 if key in attr_docs:\n499                     no_docstring = True\n500                     # make a copy of docstring for attributes to avoid cache\n501                     # the change of autodoc-process-docstring event.\n502                     docstrings = [list(attr_docs[key])]\n503 \n504                     for i, line in enumerate(self.process_doc(docstrings)):\n505                         self.add_line(line, sourcename, i)\n506 \n507         # add content from docstrings\n508         if not no_docstring:\n509             docstrings = self.get_doc()\n510             if not docstrings:\n511                 # append at least a dummy docstring, so that the event\n512                 # autodoc-process-docstring is fired and can add some\n513                 # content if desired\n514                 docstrings.append([])\n515             for i, line in enumerate(self.process_doc(docstrings)):\n516                 self.add_line(line, sourcename, i)\n517 \n518         # add additional content (e.g. from document), if present\n519         if more_content:\n520             for line, src in zip(more_content.data, more_content.items):\n521                 self.add_line(line, src[0], src[1])\n522 \n523     def get_object_members(self, want_all: bool) -> Tuple[bool, List[Tuple[str, Any]]]:\n524         \"\"\"Return `(members_check_module, members)` where `members` is a\n525         list of `(membername, member)` pairs of the members of *self.object*.\n526 \n527         If *want_all* is True, return all members.  Else, only return those\n528         members given by *self.options.members* (which may also be none).\n529         \"\"\"\n530         members = get_object_members(self.object, self.objpath, self.get_attr, self.analyzer)\n531         if not want_all:\n532             if not self.options.members:\n533                 return False, []\n534             # specific members given\n535             selected = []\n536             for name in self.options.members:\n537                 if name in members:\n538                     selected.append((name, members[name].value))\n539                 else:\n540                     logger.warning(__('missing attribute %s in object %s') %\n541                                    (name, self.fullname), type='autodoc')\n542             return False, selected\n543         elif self.options.inherited_members:\n544             return False, [(m.name, m.value) for m in members.values()]\n545         else:\n546             return False, [(m.name, m.value) for m in members.values()\n547                            if m.directly_defined]\n548 \n549     def filter_members(self, members: List[Tuple[str, Any]], want_all: bool\n550                        ) -> List[Tuple[str, Any, bool]]:\n551         \"\"\"Filter the given member list.\n552 \n553         Members are skipped if\n554 \n555         - they are private (except if given explicitly or the private-members\n556           option is set)\n557         - they are special methods (except if given explicitly or the\n558           special-members option is set)\n559         - they are undocumented (except if the undoc-members option is set)\n560 \n561         The user can override the skipping decision by connecting to the\n562         ``autodoc-skip-member`` event.\n563         \"\"\"\n564         def is_filtered_inherited_member(name: str) -> bool:\n565             if inspect.isclass(self.object):\n566                 for cls in self.object.__mro__:\n567                     if cls.__name__ == self.options.inherited_members and cls != self.object:\n568                         # given member is a member of specified *super class*\n569                         return True\n570                     elif name in cls.__dict__:\n571                         return False\n572 \n573             return False\n574 \n575         ret = []\n576 \n577         # search for members in source code too\n578         namespace = '.'.join(self.objpath)  # will be empty for modules\n579 \n580         if self.analyzer:\n581             attr_docs = self.analyzer.find_attr_docs()\n582         else:\n583             attr_docs = {}\n584 \n585         # process members and determine which to skip\n586         for (membername, member) in members:\n587             # if isattr is True, the member is documented as an attribute\n588             if member is INSTANCEATTR:\n589                 isattr = True\n590             else:\n591                 isattr = False\n592 \n593             doc = getdoc(member, self.get_attr, self.env.config.autodoc_inherit_docstrings,\n594                          self.parent, self.object_name)\n595             if not isinstance(doc, str):\n596                 # Ignore non-string __doc__\n597                 doc = None\n598 \n599             # if the member __doc__ is the same as self's __doc__, it's just\n600             # inherited and therefore not the member's doc\n601             cls = self.get_attr(member, '__class__', None)\n602             if cls:\n603                 cls_doc = self.get_attr(cls, '__doc__', None)\n604                 if cls_doc == doc:\n605                     doc = None\n606             has_doc = bool(doc)\n607 \n608             metadata = extract_metadata(doc)\n609             if 'private' in metadata:\n610                 # consider a member private if docstring has \"private\" metadata\n611                 isprivate = True\n612             elif 'public' in metadata:\n613                 # consider a member public if docstring has \"public\" metadata\n614                 isprivate = False\n615             else:\n616                 isprivate = membername.startswith('_')\n617 \n618             keep = False\n619             if safe_getattr(member, '__sphinx_mock__', False):\n620                 # mocked module or object\n621                 pass\n622             elif want_all and membername.startswith('__') and \\\n623                     membername.endswith('__') and len(membername) > 4:\n624                 # special __methods__\n625                 if self.options.special_members is ALL:\n626                     if membername == '__doc__':\n627                         keep = False\n628                     elif is_filtered_inherited_member(membername):\n629                         keep = False\n630                     else:\n631                         keep = has_doc or self.options.undoc_members\n632                 elif self.options.special_members:\n633                     if membername in self.options.special_members:\n634                         keep = has_doc or self.options.undoc_members\n635             elif (namespace, membername) in attr_docs:\n636                 if want_all and isprivate:\n637                     # ignore members whose name starts with _ by default\n638                     keep = self.options.private_members\n639                 else:\n640                     # keep documented attributes\n641                     keep = True\n642                 isattr = True\n643             elif want_all and isprivate:\n644                 # ignore members whose name starts with _ by default\n645                 keep = self.options.private_members and \\\n646                     (has_doc or self.options.undoc_members)\n647             else:\n648                 if self.options.members is ALL and is_filtered_inherited_member(membername):\n649                     keep = False\n650                 else:\n651                     # ignore undocumented members if :undoc-members: is not given\n652                     keep = has_doc or self.options.undoc_members\n653 \n654             # give the user a chance to decide whether this member\n655             # should be skipped\n656             if self.env.app:\n657                 # let extensions preprocess docstrings\n658                 try:\n659                     skip_user = self.env.app.emit_firstresult(\n660                         'autodoc-skip-member', self.objtype, membername, member,\n661                         not keep, self.options)\n662                     if skip_user is not None:\n663                         keep = not skip_user\n664                 except Exception as exc:\n665                     logger.warning(__('autodoc: failed to determine %r to be documented, '\n666                                       'the following exception was raised:\\n%s'),\n667                                    member, exc, type='autodoc')\n668                     keep = False\n669 \n670             if keep:\n671                 ret.append((membername, member, isattr))\n672 \n673         return ret\n674 \n675     def document_members(self, all_members: bool = False) -> None:\n676         \"\"\"Generate reST for member documentation.\n677 \n678         If *all_members* is True, do all members, else those given by\n679         *self.options.members*.\n680         \"\"\"\n681         # set current namespace for finding members\n682         self.env.temp_data['autodoc:module'] = self.modname\n683         if self.objpath:\n684             self.env.temp_data['autodoc:class'] = self.objpath[0]\n685 \n686         want_all = all_members or self.options.inherited_members or \\\n687             self.options.members is ALL\n688         # find out which members are documentable\n689         members_check_module, members = self.get_object_members(want_all)\n690 \n691         # remove members given by exclude-members\n692         if self.options.exclude_members:\n693             members = [\n694                 (membername, member) for (membername, member) in members\n695                 if (\n696                     self.options.exclude_members is ALL or\n697                     membername not in self.options.exclude_members\n698                 )\n699             ]\n700 \n701         # document non-skipped members\n702         memberdocumenters = []  # type: List[Tuple[Documenter, bool]]\n703         for (mname, member, isattr) in self.filter_members(members, want_all):\n704             classes = [cls for cls in self.documenters.values()\n705                        if cls.can_document_member(member, mname, isattr, self)]\n706             if not classes:\n707                 # don't know how to document this member\n708                 continue\n709             # prefer the documenter with the highest priority\n710             classes.sort(key=lambda cls: cls.priority)\n711             # give explicitly separated module name, so that members\n712             # of inner classes can be documented\n713             full_mname = self.modname + '::' + \\\n714                 '.'.join(self.objpath + [mname])\n715             documenter = classes[-1](self.directive, full_mname, self.indent)\n716             memberdocumenters.append((documenter, isattr))\n717         member_order = self.options.member_order or \\\n718             self.env.config.autodoc_member_order\n719         if member_order == 'groupwise':\n720             # sort by group; alphabetically within groups\n721             memberdocumenters.sort(key=lambda e: (e[0].member_order, e[0].name))\n722         elif member_order == 'bysource':\n723             if self.analyzer:\n724                 # sort by source order, by virtue of the module analyzer\n725                 tagorder = self.analyzer.tagorder\n726 \n727                 def keyfunc(entry: Tuple[Documenter, bool]) -> int:\n728                     fullname = entry[0].name.split('::')[1]\n729                     return tagorder.get(fullname, len(tagorder))\n730                 memberdocumenters.sort(key=keyfunc)\n731             else:\n732                 # Assume that member discovery order matches source order.\n733                 # This is a reasonable assumption in Python 3.6 and up, where\n734                 # module.__dict__ is insertion-ordered.\n735                 pass\n736         else:  # alphabetical\n737             memberdocumenters.sort(key=lambda e: e[0].name)\n738 \n739         for documenter, isattr in memberdocumenters:\n740             documenter.generate(\n741                 all_members=True, real_modname=self.real_modname,\n742                 check_module=members_check_module and not isattr)\n743 \n744         # reset current objects\n745         self.env.temp_data['autodoc:module'] = None\n746         self.env.temp_data['autodoc:class'] = None\n747 \n748     def generate(self, more_content: Any = None, real_modname: str = None,\n749                  check_module: bool = False, all_members: bool = False) -> None:\n750         \"\"\"Generate reST for the object given by *self.name*, and possibly for\n751         its members.\n752 \n753         If *more_content* is given, include that content. If *real_modname* is\n754         given, use that module name to find attribute docs. If *check_module* is\n755         True, only generate if the object is defined in the module name it is\n756         imported from. If *all_members* is True, document all members.\n757         \"\"\"\n758         if not self.parse_name():\n759             # need a module to import\n760             logger.warning(\n761                 __('don\\'t know which module to import for autodocumenting '\n762                    '%r (try placing a \"module\" or \"currentmodule\" directive '\n763                    'in the document, or giving an explicit module name)') %\n764                 self.name, type='autodoc')\n765             return\n766 \n767         # now, import the module and get object to document\n768         if not self.import_object():\n769             return\n770 \n771         # If there is no real module defined, figure out which to use.\n772         # The real module is used in the module analyzer to look up the module\n773         # where the attribute documentation would actually be found in.\n774         # This is used for situations where you have a module that collects the\n775         # functions and classes of internal submodules.\n776         guess_modname = self.get_real_modname()\n777         self.real_modname = real_modname or guess_modname\n778 \n779         # try to also get a source code analyzer for attribute docs\n780         try:\n781             self.analyzer = ModuleAnalyzer.for_module(self.real_modname)\n782             # parse right now, to get PycodeErrors on parsing (results will\n783             # be cached anyway)\n784             self.analyzer.find_attr_docs()\n785         except PycodeError:\n786             logger.debug('[autodoc] module analyzer failed:', exc_info=True)\n787             # no source file -- e.g. for builtin and C modules\n788             self.analyzer = None\n789             # at least add the module.__file__ as a dependency\n790             if hasattr(self.module, '__file__') and self.module.__file__:\n791                 self.directive.filename_set.add(self.module.__file__)\n792         else:\n793             self.directive.filename_set.add(self.analyzer.srcname)\n794 \n795         if self.real_modname != guess_modname:\n796             # Add module to dependency list if target object is defined in other module.\n797             try:\n798                 analyzer = ModuleAnalyzer.for_module(guess_modname)\n799                 self.directive.filename_set.add(analyzer.srcname)\n800             except PycodeError:\n801                 pass\n802 \n803         # check __module__ of object (for members not given explicitly)\n804         if check_module:\n805             if not self.check_module():\n806                 return\n807 \n808         sourcename = self.get_sourcename()\n809 \n810         # make sure that the result starts with an empty line.  This is\n811         # necessary for some situations where another directive preprocesses\n812         # reST and no starting newline is present\n813         self.add_line('', sourcename)\n814 \n815         # format the object's signature, if any\n816         sig = self.format_signature()\n817 \n818         # generate the directive header and options, if applicable\n819         self.add_directive_header(sig)\n820         self.add_line('', sourcename)\n821 \n822         # e.g. the module directive doesn't have content\n823         self.indent += self.content_indent\n824 \n825         # add all content (from docstrings, attribute docs etc.)\n826         self.add_content(more_content)\n827 \n828         # document members, if possible\n829         self.document_members(all_members)\n830 \n831 \n832 class ModuleDocumenter(Documenter):\n833     \"\"\"\n834     Specialized Documenter subclass for modules.\n835     \"\"\"\n836     objtype = 'module'\n837     content_indent = ''\n838     titles_allowed = True\n839 \n840     option_spec = {\n841         'members': members_option, 'undoc-members': bool_option,\n842         'noindex': bool_option, 'inherited-members': inherited_members_option,\n843         'show-inheritance': bool_option, 'synopsis': identity,\n844         'platform': identity, 'deprecated': bool_option,\n845         'member-order': member_order_option, 'exclude-members': members_set_option,\n846         'private-members': bool_option, 'special-members': members_option,\n847         'imported-members': bool_option, 'ignore-module-all': bool_option\n848     }  # type: Dict[str, Callable]\n849 \n850     def __init__(self, *args: Any) -> None:\n851         super().__init__(*args)\n852         merge_special_members_option(self.options)\n853 \n854     @classmethod\n855     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n856                             ) -> bool:\n857         # don't document submodules automatically\n858         return False\n859 \n860     def resolve_name(self, modname: str, parents: Any, path: str, base: Any\n861                      ) -> Tuple[str, List[str]]:\n862         if modname is not None:\n863             logger.warning(__('\"::\" in automodule name doesn\\'t make sense'),\n864                            type='autodoc')\n865         return (path or '') + base, []\n866 \n867     def parse_name(self) -> bool:\n868         ret = super().parse_name()\n869         if self.args or self.retann:\n870             logger.warning(__('signature arguments or return annotation '\n871                               'given for automodule %s') % self.fullname,\n872                            type='autodoc')\n873         return ret\n874 \n875     def add_directive_header(self, sig: str) -> None:\n876         Documenter.add_directive_header(self, sig)\n877 \n878         sourcename = self.get_sourcename()\n879 \n880         # add some module-specific options\n881         if self.options.synopsis:\n882             self.add_line('   :synopsis: ' + self.options.synopsis, sourcename)\n883         if self.options.platform:\n884             self.add_line('   :platform: ' + self.options.platform, sourcename)\n885         if self.options.deprecated:\n886             self.add_line('   :deprecated:', sourcename)\n887 \n888     def get_object_members(self, want_all: bool) -> Tuple[bool, List[Tuple[str, Any]]]:\n889         if want_all:\n890             if (self.options.ignore_module_all or not\n891                     hasattr(self.object, '__all__')):\n892                 # for implicit module members, check __module__ to avoid\n893                 # documenting imported objects\n894                 return True, get_module_members(self.object)\n895             else:\n896                 memberlist = self.object.__all__\n897                 # Sometimes __all__ is broken...\n898                 if not isinstance(memberlist, (list, tuple)) or not \\\n899                    all(isinstance(entry, str) for entry in memberlist):\n900                     logger.warning(\n901                         __('__all__ should be a list of strings, not %r '\n902                            '(in module %s) -- ignoring __all__') %\n903                         (memberlist, self.fullname),\n904                         type='autodoc'\n905                     )\n906                     # fall back to all members\n907                     return True, get_module_members(self.object)\n908         else:\n909             memberlist = self.options.members or []\n910         ret = []\n911         for mname in memberlist:\n912             try:\n913                 ret.append((mname, safe_getattr(self.object, mname)))\n914             except AttributeError:\n915                 logger.warning(\n916                     __('missing attribute mentioned in :members: or __all__: '\n917                        'module %s, attribute %s') %\n918                     (safe_getattr(self.object, '__name__', '???'), mname),\n919                     type='autodoc'\n920                 )\n921         return False, ret\n922 \n923 \n924 class ModuleLevelDocumenter(Documenter):\n925     \"\"\"\n926     Specialized Documenter subclass for objects on module level (functions,\n927     classes, data/constants).\n928     \"\"\"\n929     def resolve_name(self, modname: str, parents: Any, path: str, base: Any\n930                      ) -> Tuple[str, List[str]]:\n931         if modname is None:\n932             if path:\n933                 stripped = path.rstrip('.')\n934                 modname, qualname = split_full_qualified_name(stripped)\n935                 if qualname:\n936                     parents = qualname.split(\".\")\n937                 else:\n938                     parents = []\n939 \n940             if modname is None:\n941                 # if documenting a toplevel object without explicit module,\n942                 # it can be contained in another auto directive ...\n943                 modname = self.env.temp_data.get('autodoc:module')\n944                 # ... or in the scope of a module directive\n945                 if not modname:\n946                     modname = self.env.ref_context.get('py:module')\n947                 # ... else, it stays None, which means invalid\n948         return modname, parents + [base]\n949 \n950 \n951 class ClassLevelDocumenter(Documenter):\n952     \"\"\"\n953     Specialized Documenter subclass for objects on class level (methods,\n954     attributes).\n955     \"\"\"\n956     def resolve_name(self, modname: str, parents: Any, path: str, base: Any\n957                      ) -> Tuple[str, List[str]]:\n958         if modname is None:\n959             if path:\n960                 mod_cls = path.rstrip('.')\n961             else:\n962                 mod_cls = None\n963                 # if documenting a class-level object without path,\n964                 # there must be a current class, either from a parent\n965                 # auto directive ...\n966                 mod_cls = self.env.temp_data.get('autodoc:class')\n967                 # ... or from a class directive\n968                 if mod_cls is None:\n969                     mod_cls = self.env.ref_context.get('py:class')\n970                 # ... if still None, there's no way to know\n971                 if mod_cls is None:\n972                     return None, []\n973 \n974             try:\n975                 modname, qualname = split_full_qualified_name(mod_cls)\n976                 parents = qualname.split(\".\") if qualname else []\n977             except ImportError:\n978                 parents = mod_cls.split(\".\")\n979 \n980             # if the module name is still missing, get it like above\n981             if not modname:\n982                 modname = self.env.temp_data.get('autodoc:module')\n983             if not modname:\n984                 modname = self.env.ref_context.get('py:module')\n985             # ... else, it stays None, which means invalid\n986         return modname, parents + [base]\n987 \n988 \n989 class DocstringSignatureMixin:\n990     \"\"\"\n991     Mixin for FunctionDocumenter and MethodDocumenter to provide the\n992     feature of reading the signature from the docstring.\n993     \"\"\"\n994 \n995     def _find_signature(self, encoding: str = None) -> Tuple[str, str]:\n996         if encoding is not None:\n997             warnings.warn(\"The 'encoding' argument to autodoc.%s._find_signature() is \"\n998                           \"deprecated.\" % self.__class__.__name__,\n999                           RemovedInSphinx40Warning, stacklevel=2)\n1000         docstrings = self.get_doc()\n1001         self._new_docstrings = docstrings[:]\n1002         result = None\n1003         for i, doclines in enumerate(docstrings):\n1004             # no lines in docstring, no match\n1005             if not doclines:\n1006                 continue\n1007             # match first line of docstring against signature RE\n1008             match = py_ext_sig_re.match(doclines[0])\n1009             if not match:\n1010                 continue\n1011             exmod, path, base, args, retann = match.groups()\n1012             # the base name must match ours\n1013             valid_names = [self.objpath[-1]]  # type: ignore\n1014             if isinstance(self, ClassDocumenter):\n1015                 valid_names.append('__init__')\n1016                 if hasattr(self.object, '__mro__'):\n1017                     valid_names.extend(cls.__name__ for cls in self.object.__mro__)\n1018             if base not in valid_names:\n1019                 continue\n1020             # re-prepare docstring to ignore more leading indentation\n1021             tab_width = self.directive.state.document.settings.tab_width  # type: ignore\n1022             self._new_docstrings[i] = prepare_docstring('\\n'.join(doclines[1:]),\n1023                                                         tabsize=tab_width)\n1024             result = args, retann\n1025             # don't look any further\n1026             break\n1027         return result\n1028 \n1029     def get_doc(self, encoding: str = None, ignore: int = None) -> List[List[str]]:\n1030         if encoding is not None:\n1031             warnings.warn(\"The 'encoding' argument to autodoc.%s.get_doc() is deprecated.\"\n1032                           % self.__class__.__name__,\n1033                           RemovedInSphinx40Warning, stacklevel=2)\n1034         lines = getattr(self, '_new_docstrings', None)\n1035         if lines is not None:\n1036             return lines\n1037         return super().get_doc(None, ignore)  # type: ignore\n1038 \n1039     def format_signature(self, **kwargs: Any) -> str:\n1040         if self.args is None and self.env.config.autodoc_docstring_signature:  # type: ignore\n1041             # only act if a signature is not explicitly given already, and if\n1042             # the feature is enabled\n1043             result = self._find_signature()\n1044             if result is not None:\n1045                 self.args, self.retann = result\n1046         return super().format_signature(**kwargs)  # type: ignore\n1047 \n1048 \n1049 class DocstringStripSignatureMixin(DocstringSignatureMixin):\n1050     \"\"\"\n1051     Mixin for AttributeDocumenter to provide the\n1052     feature of stripping any function signature from the docstring.\n1053     \"\"\"\n1054     def format_signature(self, **kwargs: Any) -> str:\n1055         if self.args is None and self.env.config.autodoc_docstring_signature:  # type: ignore\n1056             # only act if a signature is not explicitly given already, and if\n1057             # the feature is enabled\n1058             result = self._find_signature()\n1059             if result is not None:\n1060                 # Discarding _args is a only difference with\n1061                 # DocstringSignatureMixin.format_signature.\n1062                 # Documenter.format_signature use self.args value to format.\n1063                 _args, self.retann = result\n1064         return super().format_signature(**kwargs)\n1065 \n1066 \n1067 class FunctionDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type: ignore\n1068     \"\"\"\n1069     Specialized Documenter subclass for functions.\n1070     \"\"\"\n1071     objtype = 'function'\n1072     member_order = 30\n1073 \n1074     @classmethod\n1075     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n1076                             ) -> bool:\n1077         # supports functions, builtins and bound methods exported at the module level\n1078         return (inspect.isfunction(member) or inspect.isbuiltin(member) or\n1079                 (inspect.isroutine(member) and isinstance(parent, ModuleDocumenter)))\n1080 \n1081     def format_args(self, **kwargs: Any) -> str:\n1082         if self.env.config.autodoc_typehints in ('none', 'description'):\n1083             kwargs.setdefault('show_annotation', False)\n1084 \n1085         try:\n1086             self.env.app.emit('autodoc-before-process-signature', self.object, False)\n1087             if inspect.is_singledispatch_function(self.object):\n1088                 sig = inspect.signature(self.object, follow_wrapped=True)\n1089             else:\n1090                 sig = inspect.signature(self.object)\n1091             args = stringify_signature(sig, **kwargs)\n1092         except TypeError as exc:\n1093             logger.warning(__(\"Failed to get a function signature for %s: %s\"),\n1094                            self.fullname, exc)\n1095             return None\n1096         except ValueError:\n1097             args = ''\n1098 \n1099         if self.env.config.strip_signature_backslash:\n1100             # escape backslashes for reST\n1101             args = args.replace('\\\\', '\\\\\\\\')\n1102         return args\n1103 \n1104     def document_members(self, all_members: bool = False) -> None:\n1105         pass\n1106 \n1107     def add_directive_header(self, sig: str) -> None:\n1108         sourcename = self.get_sourcename()\n1109         super().add_directive_header(sig)\n1110 \n1111         if inspect.iscoroutinefunction(self.object):\n1112             self.add_line('   :async:', sourcename)\n1113 \n1114     def format_signature(self, **kwargs: Any) -> str:\n1115         sig = super().format_signature(**kwargs)\n1116         sigs = [sig]\n1117 \n1118         if inspect.is_singledispatch_function(self.object):\n1119             # append signature of singledispatch'ed functions\n1120             for typ, func in self.object.registry.items():\n1121                 if typ is object:\n1122                     pass  # default implementation. skipped.\n1123                 else:\n1124                     self.annotate_to_first_argument(func, typ)\n1125 \n1126                     documenter = FunctionDocumenter(self.directive, '')\n1127                     documenter.object = func\n1128                     sigs.append(documenter.format_signature())\n1129 \n1130         return \"\\n\".join(sigs)\n1131 \n1132     def annotate_to_first_argument(self, func: Callable, typ: Type) -> None:\n1133         \"\"\"Annotate type hint to the first argument of function if needed.\"\"\"\n1134         sig = inspect.signature(func)\n1135         if len(sig.parameters) == 0:\n1136             return\n1137 \n1138         params = list(sig.parameters.values())\n1139         if params[0].annotation is Parameter.empty:\n1140             params[0] = params[0].replace(annotation=typ)\n1141             func.__signature__ = sig.replace(parameters=params)  # type: ignore\n1142 \n1143 \n1144 class SingledispatchFunctionDocumenter(FunctionDocumenter):\n1145     \"\"\"\n1146     Used to be a specialized Documenter subclass for singledispatch'ed functions.\n1147 \n1148     Retained for backwards compatibility, now does the same as the FunctionDocumenter\n1149     \"\"\"\n1150 \n1151 \n1152 class DecoratorDocumenter(FunctionDocumenter):\n1153     \"\"\"\n1154     Specialized Documenter subclass for decorator functions.\n1155     \"\"\"\n1156     objtype = 'decorator'\n1157 \n1158     # must be lower than FunctionDocumenter\n1159     priority = -1\n1160 \n1161     def format_args(self, **kwargs: Any) -> Any:\n1162         args = super().format_args(**kwargs)\n1163         if ',' in args:\n1164             return args\n1165         else:\n1166             return None\n1167 \n1168 \n1169 class ClassDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type: ignore\n1170     \"\"\"\n1171     Specialized Documenter subclass for classes.\n1172     \"\"\"\n1173     objtype = 'class'\n1174     member_order = 20\n1175     option_spec = {\n1176         'members': members_option, 'undoc-members': bool_option,\n1177         'noindex': bool_option, 'inherited-members': inherited_members_option,\n1178         'show-inheritance': bool_option, 'member-order': member_order_option,\n1179         'exclude-members': members_set_option,\n1180         'private-members': bool_option, 'special-members': members_option,\n1181     }  # type: Dict[str, Callable]\n1182 \n1183     def __init__(self, *args: Any) -> None:\n1184         super().__init__(*args)\n1185         merge_special_members_option(self.options)\n1186 \n1187     @classmethod\n1188     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n1189                             ) -> bool:\n1190         return isinstance(member, type)\n1191 \n1192     def import_object(self) -> Any:\n1193         ret = super().import_object()\n1194         # if the class is documented under another name, document it\n1195         # as data/attribute\n1196         if ret:\n1197             if hasattr(self.object, '__name__'):\n1198                 self.doc_as_attr = (self.objpath[-1] != self.object.__name__)\n1199             else:\n1200                 self.doc_as_attr = True\n1201         return ret\n1202 \n1203     def format_args(self, **kwargs: Any) -> str:\n1204         if self.env.config.autodoc_typehints in ('none', 'description'):\n1205             kwargs.setdefault('show_annotation', False)\n1206 \n1207         # for classes, the relevant signature is the __init__ method's\n1208         initmeth = self.get_attr(self.object, '__init__', None)\n1209         # classes without __init__ method, default __init__ or\n1210         # __init__ written in C?\n1211         if initmeth is None or \\\n1212                 inspect.is_builtin_class_method(self.object, '__init__') or \\\n1213                 not(inspect.ismethod(initmeth) or inspect.isfunction(initmeth)):\n1214             return None\n1215         try:\n1216             self.env.app.emit('autodoc-before-process-signature', initmeth, True)\n1217             sig = inspect.signature(initmeth, bound_method=True)\n1218             return stringify_signature(sig, show_return_annotation=False, **kwargs)\n1219         except TypeError:\n1220             # still not possible: happens e.g. for old-style classes\n1221             # with __init__ in C\n1222             return None\n1223 \n1224     def format_signature(self, **kwargs: Any) -> str:\n1225         if self.doc_as_attr:\n1226             return ''\n1227 \n1228         return super().format_signature(**kwargs)\n1229 \n1230     def add_directive_header(self, sig: str) -> None:\n1231         sourcename = self.get_sourcename()\n1232 \n1233         if self.doc_as_attr:\n1234             self.directivetype = 'attribute'\n1235         super().add_directive_header(sig)\n1236 \n1237         if self.analyzer and '.'.join(self.objpath) in self.analyzer.finals:\n1238             self.add_line('   :final:', sourcename)\n1239 \n1240         # add inheritance info, if wanted\n1241         if not self.doc_as_attr and self.options.show_inheritance:\n1242             sourcename = self.get_sourcename()\n1243             self.add_line('', sourcename)\n1244             if hasattr(self.object, '__bases__') and len(self.object.__bases__):\n1245                 bases = [':class:`%s`' % b.__name__\n1246                          if b.__module__ in ('__builtin__', 'builtins')\n1247                          else ':class:`%s.%s`' % (b.__module__, b.__qualname__)\n1248                          for b in self.object.__bases__]\n1249                 self.add_line('   ' + _('Bases: %s') % ', '.join(bases),\n1250                               sourcename)\n1251 \n1252     def get_doc(self, encoding: str = None, ignore: int = None) -> List[List[str]]:\n1253         if encoding is not None:\n1254             warnings.warn(\"The 'encoding' argument to autodoc.%s.get_doc() is deprecated.\"\n1255                           % self.__class__.__name__,\n1256                           RemovedInSphinx40Warning, stacklevel=2)\n1257         lines = getattr(self, '_new_docstrings', None)\n1258         if lines is not None:\n1259             return lines\n1260 \n1261         content = self.env.config.autoclass_content\n1262 \n1263         docstrings = []\n1264         attrdocstring = self.get_attr(self.object, '__doc__', None)\n1265         if attrdocstring:\n1266             docstrings.append(attrdocstring)\n1267 \n1268         # for classes, what the \"docstring\" is can be controlled via a\n1269         # config value; the default is only the class docstring\n1270         if content in ('both', 'init'):\n1271             __init__ = self.get_attr(self.object, '__init__', None)\n1272             initdocstring = getdoc(__init__, self.get_attr,\n1273                                    self.env.config.autodoc_inherit_docstrings,\n1274                                    self.parent, self.object_name)\n1275             # for new-style classes, no __init__ means default __init__\n1276             if (initdocstring is not None and\n1277                 (initdocstring == object.__init__.__doc__ or  # for pypy\n1278                  initdocstring.strip() == object.__init__.__doc__)):  # for !pypy\n1279                 initdocstring = None\n1280             if not initdocstring:\n1281                 # try __new__\n1282                 __new__ = self.get_attr(self.object, '__new__', None)\n1283                 initdocstring = getdoc(__new__, self.get_attr,\n1284                                        self.env.config.autodoc_inherit_docstrings,\n1285                                        self.parent, self.object_name)\n1286                 # for new-style classes, no __new__ means default __new__\n1287                 if (initdocstring is not None and\n1288                     (initdocstring == object.__new__.__doc__ or  # for pypy\n1289                      initdocstring.strip() == object.__new__.__doc__)):  # for !pypy\n1290                     initdocstring = None\n1291             if initdocstring:\n1292                 if content == 'init':\n1293                     docstrings = [initdocstring]\n1294                 else:\n1295                     docstrings.append(initdocstring)\n1296 \n1297         tab_width = self.directive.state.document.settings.tab_width\n1298         return [prepare_docstring(docstring, ignore, tab_width) for docstring in docstrings]\n1299 \n1300     def add_content(self, more_content: Any, no_docstring: bool = False) -> None:\n1301         if self.doc_as_attr:\n1302             classname = safe_getattr(self.object, '__qualname__', None)\n1303             if not classname:\n1304                 classname = safe_getattr(self.object, '__name__', None)\n1305             if classname:\n1306                 module = safe_getattr(self.object, '__module__', None)\n1307                 parentmodule = safe_getattr(self.parent, '__module__', None)\n1308                 if module and module != parentmodule:\n1309                     classname = str(module) + '.' + str(classname)\n1310                 content = StringList([_('alias of :class:`%s`') % classname], source='')\n1311                 super().add_content(content, no_docstring=True)\n1312         else:\n1313             super().add_content(more_content)\n1314 \n1315     def document_members(self, all_members: bool = False) -> None:\n1316         if self.doc_as_attr:\n1317             return\n1318         super().document_members(all_members)\n1319 \n1320     def generate(self, more_content: Any = None, real_modname: str = None,\n1321                  check_module: bool = False, all_members: bool = False) -> None:\n1322         # Do not pass real_modname and use the name from the __module__\n1323         # attribute of the class.\n1324         # If a class gets imported into the module real_modname\n1325         # the analyzer won't find the source of the class, if\n1326         # it looks in real_modname.\n1327         return super().generate(more_content=more_content,\n1328                                 check_module=check_module,\n1329                                 all_members=all_members)\n1330 \n1331 \n1332 class ExceptionDocumenter(ClassDocumenter):\n1333     \"\"\"\n1334     Specialized ClassDocumenter subclass for exceptions.\n1335     \"\"\"\n1336     objtype = 'exception'\n1337     member_order = 10\n1338 \n1339     # needs a higher priority than ClassDocumenter\n1340     priority = 10\n1341 \n1342     @classmethod\n1343     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n1344                             ) -> bool:\n1345         return isinstance(member, type) and issubclass(member, BaseException)\n1346 \n1347 \n1348 class DataDocumenter(ModuleLevelDocumenter):\n1349     \"\"\"\n1350     Specialized Documenter subclass for data items.\n1351     \"\"\"\n1352     objtype = 'data'\n1353     member_order = 40\n1354     priority = -10\n1355     option_spec = dict(ModuleLevelDocumenter.option_spec)\n1356     option_spec[\"annotation\"] = annotation_option\n1357 \n1358     @classmethod\n1359     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n1360                             ) -> bool:\n1361         return isinstance(parent, ModuleDocumenter) and isattr\n1362 \n1363     def add_directive_header(self, sig: str) -> None:\n1364         super().add_directive_header(sig)\n1365         sourcename = self.get_sourcename()\n1366         if not self.options.annotation:\n1367             # obtain annotation for this data\n1368             annotations = getattr(self.parent, '__annotations__', {})\n1369             if annotations and self.objpath[-1] in annotations:\n1370                 objrepr = stringify_typehint(annotations.get(self.objpath[-1]))\n1371                 self.add_line('   :type: ' + objrepr, sourcename)\n1372             else:\n1373                 key = ('.'.join(self.objpath[:-1]), self.objpath[-1])\n1374                 if self.analyzer and key in self.analyzer.annotations:\n1375                     self.add_line('   :type: ' + self.analyzer.annotations[key],\n1376                                   sourcename)\n1377 \n1378             try:\n1379                 if self.object is UNINITIALIZED_ATTR:\n1380                     pass\n1381                 else:\n1382                     objrepr = object_description(self.object)\n1383                     self.add_line('   :value: ' + objrepr, sourcename)\n1384             except ValueError:\n1385                 pass\n1386         elif self.options.annotation is SUPPRESS:\n1387             pass\n1388         else:\n1389             self.add_line('   :annotation: %s' % self.options.annotation,\n1390                           sourcename)\n1391 \n1392     def document_members(self, all_members: bool = False) -> None:\n1393         pass\n1394 \n1395     def get_real_modname(self) -> str:\n1396         return self.get_attr(self.parent or self.object, '__module__', None) \\\n1397             or self.modname\n1398 \n1399 \n1400 class DataDeclarationDocumenter(DataDocumenter):\n1401     \"\"\"\n1402     Specialized Documenter subclass for data that cannot be imported\n1403     because they are declared without initial value (refs: PEP-526).\n1404     \"\"\"\n1405     objtype = 'datadecl'\n1406     directivetype = 'data'\n1407     member_order = 60\n1408 \n1409     # must be higher than AttributeDocumenter\n1410     priority = 11\n1411 \n1412     @classmethod\n1413     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n1414                             ) -> bool:\n1415         \"\"\"This documents only INSTANCEATTR members.\"\"\"\n1416         return (isinstance(parent, ModuleDocumenter) and\n1417                 isattr and\n1418                 member is INSTANCEATTR)\n1419 \n1420     def import_object(self) -> bool:\n1421         \"\"\"Never import anything.\"\"\"\n1422         # disguise as a data\n1423         self.objtype = 'data'\n1424         self.object = UNINITIALIZED_ATTR\n1425         try:\n1426             # import module to obtain type annotation\n1427             self.parent = importlib.import_module(self.modname)\n1428         except ImportError:\n1429             pass\n1430 \n1431         return True\n1432 \n1433     def add_content(self, more_content: Any, no_docstring: bool = False) -> None:\n1434         \"\"\"Never try to get a docstring from the object.\"\"\"\n1435         super().add_content(more_content, no_docstring=True)\n1436 \n1437 \n1438 class MethodDocumenter(DocstringSignatureMixin, ClassLevelDocumenter):  # type: ignore\n1439     \"\"\"\n1440     Specialized Documenter subclass for methods (normal, static and class).\n1441     \"\"\"\n1442     objtype = 'method'\n1443     directivetype = 'method'\n1444     member_order = 50\n1445     priority = 1  # must be more than FunctionDocumenter\n1446 \n1447     @classmethod\n1448     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n1449                             ) -> bool:\n1450         return inspect.isroutine(member) and \\\n1451             not isinstance(parent, ModuleDocumenter)\n1452 \n1453     def import_object(self) -> Any:\n1454         ret = super().import_object()\n1455         if not ret:\n1456             return ret\n1457 \n1458         # to distinguish classmethod/staticmethod\n1459         obj = self.parent.__dict__.get(self.object_name)\n1460         if obj is None:\n1461             obj = self.object\n1462 \n1463         if (inspect.isclassmethod(obj) or\n1464                 inspect.isstaticmethod(obj, cls=self.parent, name=self.object_name)):\n1465             # document class and static members before ordinary ones\n1466             self.member_order = self.member_order - 1\n1467 \n1468         return ret\n1469 \n1470     def format_args(self, **kwargs: Any) -> str:\n1471         if self.env.config.autodoc_typehints in ('none', 'description'):\n1472             kwargs.setdefault('show_annotation', False)\n1473 \n1474         try:\n1475             if self.object == object.__init__ and self.parent != object:\n1476                 # Classes not having own __init__() method are shown as no arguments.\n1477                 #\n1478                 # Note: The signature of object.__init__() is (self, /, *args, **kwargs).\n1479                 #       But it makes users confused.\n1480                 args = '()'\n1481             else:\n1482                 if inspect.isstaticmethod(self.object, cls=self.parent, name=self.object_name):\n1483                     self.env.app.emit('autodoc-before-process-signature', self.object, False)\n1484                     sig = inspect.signature(self.object, bound_method=False)\n1485                 else:\n1486                     self.env.app.emit('autodoc-before-process-signature', self.object, True)\n1487 \n1488                     meth = self.parent.__dict__.get(self.objpath[-1], None)\n1489                     if meth and inspect.is_singledispatch_method(meth):\n1490                         sig = inspect.signature(self.object, bound_method=True,\n1491                                                 follow_wrapped=True)\n1492                     else:\n1493                         sig = inspect.signature(self.object, bound_method=True)\n1494                 args = stringify_signature(sig, **kwargs)\n1495         except TypeError as exc:\n1496             logger.warning(__(\"Failed to get a method signature for %s: %s\"),\n1497                            self.fullname, exc)\n1498             return None\n1499         except ValueError:\n1500             args = ''\n1501 \n1502         if self.env.config.strip_signature_backslash:\n1503             # escape backslashes for reST\n1504             args = args.replace('\\\\', '\\\\\\\\')\n1505         return args\n1506 \n1507     def add_directive_header(self, sig: str) -> None:\n1508         super().add_directive_header(sig)\n1509 \n1510         sourcename = self.get_sourcename()\n1511         obj = self.parent.__dict__.get(self.object_name, self.object)\n1512         if inspect.isabstractmethod(obj):\n1513             self.add_line('   :abstractmethod:', sourcename)\n1514         if inspect.iscoroutinefunction(obj):\n1515             self.add_line('   :async:', sourcename)\n1516         if inspect.isclassmethod(obj):\n1517             self.add_line('   :classmethod:', sourcename)\n1518         if inspect.isstaticmethod(obj, cls=self.parent, name=self.object_name):\n1519             self.add_line('   :staticmethod:', sourcename)\n1520         if self.analyzer and '.'.join(self.objpath) in self.analyzer.finals:\n1521             self.add_line('   :final:', sourcename)\n1522 \n1523     def document_members(self, all_members: bool = False) -> None:\n1524         pass\n1525 \n1526     def format_signature(self, **kwargs: Any) -> str:\n1527         sig = super().format_signature(**kwargs)\n1528         sigs = [sig]\n1529 \n1530         meth = self.parent.__dict__.get(self.objpath[-1])\n1531         if inspect.is_singledispatch_method(meth):\n1532             # append signature of singledispatch'ed functions\n1533             for typ, func in meth.dispatcher.registry.items():\n1534                 if typ is object:\n1535                     pass  # default implementation. skipped.\n1536                 else:\n1537                     self.annotate_to_first_argument(func, typ)\n1538 \n1539                     documenter = MethodDocumenter(self.directive, '')\n1540                     documenter.parent = self.parent\n1541                     documenter.object = func\n1542                     documenter.objpath = [None]\n1543                     sigs.append(documenter.format_signature())\n1544 \n1545         return \"\\n\".join(sigs)\n1546 \n1547     def annotate_to_first_argument(self, func: Callable, typ: Type) -> None:\n1548         \"\"\"Annotate type hint to the first argument of function if needed.\"\"\"\n1549         sig = inspect.signature(func)\n1550         if len(sig.parameters) == 1:\n1551             return\n1552 \n1553         params = list(sig.parameters.values())\n1554         if params[1].annotation is Parameter.empty:\n1555             params[1] = params[1].replace(annotation=typ)\n1556             func.__signature__ = sig.replace(parameters=params)  # type: ignore\n1557 \n1558 \n1559 class SingledispatchMethodDocumenter(MethodDocumenter):\n1560     \"\"\"\n1561     Used to be a specialized Documenter subclass for singledispatch'ed methods.\n1562 \n1563     Retained for backwards compatibility, now does the same as the MethodDocumenter\n1564     \"\"\"\n1565 \n1566 \n1567 class AttributeDocumenter(DocstringStripSignatureMixin, ClassLevelDocumenter):  # type: ignore\n1568     \"\"\"\n1569     Specialized Documenter subclass for attributes.\n1570     \"\"\"\n1571     objtype = 'attribute'\n1572     member_order = 60\n1573     option_spec = dict(ModuleLevelDocumenter.option_spec)\n1574     option_spec[\"annotation\"] = annotation_option\n1575 \n1576     # must be higher than the MethodDocumenter, else it will recognize\n1577     # some non-data descriptors as methods\n1578     priority = 10\n1579 \n1580     @staticmethod\n1581     def is_function_or_method(obj: Any) -> bool:\n1582         return inspect.isfunction(obj) or inspect.isbuiltin(obj) or inspect.ismethod(obj)\n1583 \n1584     @classmethod\n1585     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n1586                             ) -> bool:\n1587         if inspect.isattributedescriptor(member):\n1588             return True\n1589         elif (not isinstance(parent, ModuleDocumenter) and\n1590               not inspect.isroutine(member) and\n1591               not isinstance(member, type)):\n1592             return True\n1593         else:\n1594             return False\n1595 \n1596     def document_members(self, all_members: bool = False) -> None:\n1597         pass\n1598 \n1599     def import_object(self) -> Any:\n1600         ret = super().import_object()\n1601         if inspect.isenumattribute(self.object):\n1602             self.object = self.object.value\n1603         if inspect.isattributedescriptor(self.object):\n1604             self._datadescriptor = True\n1605         else:\n1606             # if it's not a data descriptor\n1607             self._datadescriptor = False\n1608         return ret\n1609 \n1610     def get_real_modname(self) -> str:\n1611         return self.get_attr(self.parent or self.object, '__module__', None) \\\n1612             or self.modname\n1613 \n1614     def add_directive_header(self, sig: str) -> None:\n1615         super().add_directive_header(sig)\n1616         sourcename = self.get_sourcename()\n1617         if not self.options.annotation:\n1618             # obtain type annotation for this attribute\n1619             annotations = getattr(self.parent, '__annotations__', {})\n1620             if annotations and self.objpath[-1] in annotations:\n1621                 objrepr = stringify_typehint(annotations.get(self.objpath[-1]))\n1622                 self.add_line('   :type: ' + objrepr, sourcename)\n1623             else:\n1624                 key = ('.'.join(self.objpath[:-1]), self.objpath[-1])\n1625                 if self.analyzer and key in self.analyzer.annotations:\n1626                     self.add_line('   :type: ' + self.analyzer.annotations[key],\n1627                                   sourcename)\n1628 \n1629             # data descriptors do not have useful values\n1630             if not self._datadescriptor:\n1631                 try:\n1632                     if self.object is INSTANCEATTR:\n1633                         pass\n1634                     else:\n1635                         objrepr = object_description(self.object)\n1636                         self.add_line('   :value: ' + objrepr, sourcename)\n1637                 except ValueError:\n1638                     pass\n1639         elif self.options.annotation is SUPPRESS:\n1640             pass\n1641         else:\n1642             self.add_line('   :annotation: %s' % self.options.annotation, sourcename)\n1643 \n1644     def add_content(self, more_content: Any, no_docstring: bool = False) -> None:\n1645         if not self._datadescriptor:\n1646             # if it's not a data descriptor, its docstring is very probably the\n1647             # wrong thing to display\n1648             no_docstring = True\n1649         super().add_content(more_content, no_docstring)\n1650 \n1651 \n1652 class PropertyDocumenter(DocstringStripSignatureMixin, ClassLevelDocumenter):  # type: ignore\n1653     \"\"\"\n1654     Specialized Documenter subclass for properties.\n1655     \"\"\"\n1656     objtype = 'property'\n1657     directivetype = 'method'\n1658     member_order = 60\n1659 \n1660     # before AttributeDocumenter\n1661     priority = AttributeDocumenter.priority + 1\n1662 \n1663     @classmethod\n1664     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n1665                             ) -> bool:\n1666         return inspect.isproperty(member) and isinstance(parent, ClassDocumenter)\n1667 \n1668     def document_members(self, all_members: bool = False) -> None:\n1669         pass\n1670 \n1671     def get_real_modname(self) -> str:\n1672         return self.get_attr(self.parent or self.object, '__module__', None) \\\n1673             or self.modname\n1674 \n1675     def add_directive_header(self, sig: str) -> None:\n1676         super().add_directive_header(sig)\n1677         sourcename = self.get_sourcename()\n1678         if inspect.isabstractmethod(self.object):\n1679             self.add_line('   :abstractmethod:', sourcename)\n1680         self.add_line('   :property:', sourcename)\n1681 \n1682 \n1683 class InstanceAttributeDocumenter(AttributeDocumenter):\n1684     \"\"\"\n1685     Specialized Documenter subclass for attributes that cannot be imported\n1686     because they are instance attributes (e.g. assigned in __init__).\n1687     \"\"\"\n1688     objtype = 'instanceattribute'\n1689     directivetype = 'attribute'\n1690     member_order = 60\n1691 \n1692     # must be higher than AttributeDocumenter\n1693     priority = 11\n1694 \n1695     @classmethod\n1696     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n1697                             ) -> bool:\n1698         \"\"\"This documents only INSTANCEATTR members.\"\"\"\n1699         return (not isinstance(parent, ModuleDocumenter) and\n1700                 isattr and\n1701                 member is INSTANCEATTR)\n1702 \n1703     def import_object(self) -> bool:\n1704         \"\"\"Never import anything.\"\"\"\n1705         # disguise as an attribute\n1706         self.objtype = 'attribute'\n1707         self.object = INSTANCEATTR\n1708         self._datadescriptor = False\n1709         return True\n1710 \n1711     def add_content(self, more_content: Any, no_docstring: bool = False) -> None:\n1712         \"\"\"Never try to get a docstring from the object.\"\"\"\n1713         super().add_content(more_content, no_docstring=True)\n1714 \n1715 \n1716 class SlotsAttributeDocumenter(AttributeDocumenter):\n1717     \"\"\"\n1718     Specialized Documenter subclass for attributes that cannot be imported\n1719     because they are attributes in __slots__.\n1720     \"\"\"\n1721     objtype = 'slotsattribute'\n1722     directivetype = 'attribute'\n1723     member_order = 60\n1724 \n1725     # must be higher than AttributeDocumenter\n1726     priority = 11\n1727 \n1728     @classmethod\n1729     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n1730                             ) -> bool:\n1731         \"\"\"This documents only SLOTSATTR members.\"\"\"\n1732         return member is SLOTSATTR\n1733 \n1734     def import_object(self) -> Any:\n1735         \"\"\"Never import anything.\"\"\"\n1736         # disguise as an attribute\n1737         self.objtype = 'attribute'\n1738         self._datadescriptor = True\n1739 \n1740         with mock(self.env.config.autodoc_mock_imports):\n1741             try:\n1742                 ret = import_object(self.modname, self.objpath[:-1], 'class',\n1743                                     attrgetter=self.get_attr,\n1744                                     warningiserror=self.env.config.autodoc_warningiserror)\n1745                 self.module, _, _, self.parent = ret\n1746                 return True\n1747             except ImportError as exc:\n1748                 logger.warning(exc.args[0], type='autodoc', subtype='import_object')\n1749                 self.env.note_reread()\n1750                 return False\n1751 \n1752     def get_doc(self, encoding: str = None, ignore: int = None) -> List[List[str]]:\n1753         \"\"\"Decode and return lines of the docstring(s) for the object.\"\"\"\n1754         if ignore is not None:\n1755             warnings.warn(\"The 'ignore' argument to autodoc.%s.get_doc() is deprecated.\"\n1756                           % self.__class__.__name__,\n1757                           RemovedInSphinx50Warning, stacklevel=2)\n1758         name = self.objpath[-1]\n1759         __slots__ = safe_getattr(self.parent, '__slots__', [])\n1760         if isinstance(__slots__, dict) and isinstance(__slots__.get(name), str):\n1761             docstring = prepare_docstring(__slots__[name])\n1762             return [docstring]\n1763         else:\n1764             return []\n1765 \n1766 \n1767 def get_documenters(app: Sphinx) -> Dict[str, \"Type[Documenter]\"]:\n1768     \"\"\"Returns registered Documenter classes\"\"\"\n1769     warnings.warn(\"get_documenters() is deprecated.\", RemovedInSphinx50Warning, stacklevel=2)\n1770     return app.registry.documenters\n1771 \n1772 \n1773 def autodoc_attrgetter(app: Sphinx, obj: Any, name: str, *defargs: Any) -> Any:\n1774     \"\"\"Alternative getattr() for types\"\"\"\n1775     for typ, func in app.registry.autodoc_attrgettrs.items():\n1776         if isinstance(obj, typ):\n1777             return func(obj, name, *defargs)\n1778 \n1779     return safe_getattr(obj, name, *defargs)\n1780 \n1781 \n1782 def migrate_autodoc_member_order(app: Sphinx, config: Config) -> None:\n1783     if config.autodoc_member_order == 'alphabetic':\n1784         # RemovedInSphinx50Warning\n1785         logger.warning(__('autodoc_member_order now accepts \"alphabetical\" '\n1786                           'instead of \"alphabetic\". Please update your setting.'))\n1787         config.autodoc_member_order = 'alphabetical'  # type: ignore\n1788 \n1789 \n1790 def setup(app: Sphinx) -> Dict[str, Any]:\n1791     app.add_autodocumenter(ModuleDocumenter)\n1792     app.add_autodocumenter(ClassDocumenter)\n1793     app.add_autodocumenter(ExceptionDocumenter)\n1794     app.add_autodocumenter(DataDocumenter)\n1795     app.add_autodocumenter(DataDeclarationDocumenter)\n1796     app.add_autodocumenter(FunctionDocumenter)\n1797     app.add_autodocumenter(DecoratorDocumenter)\n1798     app.add_autodocumenter(MethodDocumenter)\n1799     app.add_autodocumenter(AttributeDocumenter)\n1800     app.add_autodocumenter(PropertyDocumenter)\n1801     app.add_autodocumenter(InstanceAttributeDocumenter)\n1802     app.add_autodocumenter(SlotsAttributeDocumenter)\n1803 \n1804     app.add_config_value('autoclass_content', 'class', True, ENUM('both', 'class', 'init'))\n1805     app.add_config_value('autodoc_member_order', 'alphabetical', True,\n1806                          ENUM('alphabetic', 'alphabetical', 'bysource', 'groupwise'))\n1807     app.add_config_value('autodoc_default_options', {}, True)\n1808     app.add_config_value('autodoc_docstring_signature', True, True)\n1809     app.add_config_value('autodoc_mock_imports', [], True)\n1810     app.add_config_value('autodoc_typehints', \"signature\", True,\n1811                          ENUM(\"signature\", \"description\", \"none\"))\n1812     app.add_config_value('autodoc_warningiserror', True, True)\n1813     app.add_config_value('autodoc_inherit_docstrings', True, True)\n1814     app.add_event('autodoc-before-process-signature')\n1815     app.add_event('autodoc-process-docstring')\n1816     app.add_event('autodoc-process-signature')\n1817     app.add_event('autodoc-skip-member')\n1818 \n1819     app.connect('config-inited', migrate_autodoc_member_order, priority=800)\n1820 \n1821     app.setup_extension('sphinx.ext.autodoc.type_comment')\n1822     app.setup_extension('sphinx.ext.autodoc.typehints')\n1823 \n1824     return {'version': sphinx.__display_version__, 'parallel_read_safe': True}\n",
        "intended_behavior": "In the context of rendering docstrings to HTML, this file should ensure that attribute names with trailing underscores are not incorrectly escaped. If the problem lies within Autodoc's handling of docstring content post-Napoleon processing, ensuring that underscores at the end of attribute names are properly handled will resolve the issue. Autodoc's rendering process needs to recognize these cases and treat them accordingly, maintaining the integrity of identifier names including their trailing underscores in the final HTML documentation."
    }
]