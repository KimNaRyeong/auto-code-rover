[
    {
        "rel_file_path": "django/core/management/commands/inspectdb.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__4.1/django/core/management/commands/inspectdb.py",
        "start": 1,
        "end": 299,
        "class_name": null,
        "method_name": null,
        "code": "1 import keyword\n2 import re\n3 \n4 from django.core.management.base import BaseCommand, CommandError\n5 from django.db import DEFAULT_DB_ALIAS, connections\n6 from django.db.models.constants import LOOKUP_SEP\n7 \n8 \n9 class Command(BaseCommand):\n10     help = \"Introspects the database tables in the given database and outputs a Django model module.\"\n11     requires_system_checks = []\n12     stealth_options = ('table_name_filter',)\n13     db_module = 'django.db'\n14 \n15     def add_arguments(self, parser):\n16         parser.add_argument(\n17             'table', nargs='*', type=str,\n18             help='Selects what tables or views should be introspected.',\n19         )\n20         parser.add_argument(\n21             '--database', default=DEFAULT_DB_ALIAS,\n22             help='Nominates a database to introspect. Defaults to using the \"default\" database.',\n23         )\n24         parser.add_argument(\n25             '--include-partitions', action='store_true', help='Also output models for partition tables.',\n26         )\n27         parser.add_argument(\n28             '--include-views', action='store_true', help='Also output models for database views.',\n29         )\n30 \n31     def handle(self, **options):\n32         try:\n33             for line in self.handle_inspection(options):\n34                 self.stdout.write(line)\n35         except NotImplementedError:\n36             raise CommandError(\"Database inspection isn't supported for the currently selected database backend.\")\n37 \n38     def handle_inspection(self, options):\n39         connection = connections[options['database']]\n40         # 'table_name_filter' is a stealth option\n41         table_name_filter = options.get('table_name_filter')\n42 \n43         def table2model(table_name):\n44             return re.sub(r'[^a-zA-Z0-9]', '', table_name.title())\n45 \n46         with connection.cursor() as cursor:\n47             yield \"# This is an auto-generated Django model module.\"\n48             yield \"# You'll have to do the following manually to clean this up:\"\n49             yield \"#   * Rearrange models' order\"\n50             yield \"#   * Make sure each model has one field with primary_key=True\"\n51             yield \"#   * Make sure each ForeignKey and OneToOneField has `on_delete` set to the desired behavior\"\n52             yield (\n53                 \"#   * Remove `managed = False` lines if you wish to allow \"\n54                 \"Django to create, modify, and delete the table\"\n55             )\n56             yield \"# Feel free to rename the models, but don't rename db_table values or field names.\"\n57             yield 'from %s import models' % self.db_module\n58             known_models = []\n59             table_info = connection.introspection.get_table_list(cursor)\n60 \n61             # Determine types of tables and/or views to be introspected.\n62             types = {'t'}\n63             if options['include_partitions']:\n64                 types.add('p')\n65             if options['include_views']:\n66                 types.add('v')\n67 \n68             for table_name in (options['table'] or sorted(info.name for info in table_info if info.type in types)):\n69                 if table_name_filter is not None and callable(table_name_filter):\n70                     if not table_name_filter(table_name):\n71                         continue\n72                 try:\n73                     try:\n74                         relations = connection.introspection.get_relations(cursor, table_name)\n75                     except NotImplementedError:\n76                         relations = {}\n77                     try:\n78                         constraints = connection.introspection.get_constraints(cursor, table_name)\n79                     except NotImplementedError:\n80                         constraints = {}\n81                     primary_key_column = connection.introspection.get_primary_key_column(cursor, table_name)\n82                     unique_columns = [\n83                         c['columns'][0] for c in constraints.values()\n84                         if c['unique'] and len(c['columns']) == 1\n85                     ]\n86                     table_description = connection.introspection.get_table_description(cursor, table_name)\n87                 except Exception as e:\n88                     yield \"# Unable to inspect table '%s'\" % table_name\n89                     yield \"# The error was: %s\" % e\n90                     continue\n91 \n92                 yield ''\n93                 yield ''\n94                 yield 'class %s(models.Model):' % table2model(table_name)\n95                 known_models.append(table2model(table_name))\n96                 used_column_names = []  # Holds column names used in the table so far\n97                 column_to_field_name = {}  # Maps column names to names of model fields\n98                 for row in table_description:\n99                     comment_notes = []  # Holds Field notes, to be displayed in a Python comment.\n100                     extra_params = {}  # Holds Field parameters such as 'db_column'.\n101                     column_name = row.name\n102                     is_relation = column_name in relations\n103 \n104                     att_name, params, notes = self.normalize_col_name(\n105                         column_name, used_column_names, is_relation)\n106                     extra_params.update(params)\n107                     comment_notes.extend(notes)\n108 \n109                     used_column_names.append(att_name)\n110                     column_to_field_name[column_name] = att_name\n111 \n112                     # Add primary_key and unique, if necessary.\n113                     if column_name == primary_key_column:\n114                         extra_params['primary_key'] = True\n115                     elif column_name in unique_columns:\n116                         extra_params['unique'] = True\n117 \n118                     if is_relation:\n119                         if extra_params.pop('unique', False) or extra_params.get('primary_key'):\n120                             rel_type = 'OneToOneField'\n121                         else:\n122                             rel_type = 'ForeignKey'\n123                         rel_to = (\n124                             \"self\" if relations[column_name][1] == table_name\n125                             else table2model(relations[column_name][1])\n126                         )\n127                         if rel_to in known_models:\n128                             field_type = '%s(%s' % (rel_type, rel_to)\n129                         else:\n130                             field_type = \"%s('%s'\" % (rel_type, rel_to)\n131                     else:\n132                         # Calling `get_field_type` to get the field type string and any\n133                         # additional parameters and notes.\n134                         field_type, field_params, field_notes = self.get_field_type(connection, table_name, row)\n135                         extra_params.update(field_params)\n136                         comment_notes.extend(field_notes)\n137 \n138                         field_type += '('\n139 \n140                     # Don't output 'id = meta.AutoField(primary_key=True)', because\n141                     # that's assumed if it doesn't exist.\n142                     if att_name == 'id' and extra_params == {'primary_key': True}:\n143                         if field_type == 'AutoField(':\n144                             continue\n145                         elif field_type == connection.features.introspected_field_types['AutoField'] + '(':\n146                             comment_notes.append('AutoField?')\n147 \n148                     # Add 'null' and 'blank', if the 'null_ok' flag was present in the\n149                     # table description.\n150                     if row.null_ok:  # If it's NULL...\n151                         extra_params['blank'] = True\n152                         extra_params['null'] = True\n153 \n154                     field_desc = '%s = %s%s' % (\n155                         att_name,\n156                         # Custom fields will have a dotted path\n157                         '' if '.' in field_type else 'models.',\n158                         field_type,\n159                     )\n160                     if field_type.startswith(('ForeignKey(', 'OneToOneField(')):\n161                         field_desc += ', models.DO_NOTHING'\n162 \n163                     if extra_params:\n164                         if not field_desc.endswith('('):\n165                             field_desc += ', '\n166                         field_desc += ', '.join('%s=%r' % (k, v) for k, v in extra_params.items())\n167                     field_desc += ')'\n168                     if comment_notes:\n169                         field_desc += '  # ' + ' '.join(comment_notes)\n170                     yield '    %s' % field_desc\n171                 is_view = any(info.name == table_name and info.type == 'v' for info in table_info)\n172                 is_partition = any(info.name == table_name and info.type == 'p' for info in table_info)\n173                 yield from self.get_meta(table_name, constraints, column_to_field_name, is_view, is_partition)\n174 \n175     def normalize_col_name(self, col_name, used_column_names, is_relation):\n176         \"\"\"\n177         Modify the column name to make it Python-compatible as a field name\n178         \"\"\"\n179         field_params = {}\n180         field_notes = []\n181 \n182         new_name = col_name.lower()\n183         if new_name != col_name:\n184             field_notes.append('Field name made lowercase.')\n185 \n186         if is_relation:\n187             if new_name.endswith('_id'):\n188                 new_name = new_name[:-3]\n189             else:\n190                 field_params['db_column'] = col_name\n191 \n192         new_name, num_repl = re.subn(r'\\W', '_', new_name)\n193         if num_repl > 0:\n194             field_notes.append('Field renamed to remove unsuitable characters.')\n195 \n196         if new_name.find(LOOKUP_SEP) >= 0:\n197             while new_name.find(LOOKUP_SEP) >= 0:\n198                 new_name = new_name.replace(LOOKUP_SEP, '_')\n199             if col_name.lower().find(LOOKUP_SEP) >= 0:\n200                 # Only add the comment if the double underscore was in the original name\n201                 field_notes.append(\"Field renamed because it contained more than one '_' in a row.\")\n202 \n203         if new_name.startswith('_'):\n204             new_name = 'field%s' % new_name\n205             field_notes.append(\"Field renamed because it started with '_'.\")\n206 \n207         if new_name.endswith('_'):\n208             new_name = '%sfield' % new_name\n209             field_notes.append(\"Field renamed because it ended with '_'.\")\n210 \n211         if keyword.iskeyword(new_name):\n212             new_name += '_field'\n213             field_notes.append('Field renamed because it was a Python reserved word.')\n214 \n215         if new_name[0].isdigit():\n216             new_name = 'number_%s' % new_name\n217             field_notes.append(\"Field renamed because it wasn't a valid Python identifier.\")\n218 \n219         if new_name in used_column_names:\n220             num = 0\n221             while '%s_%d' % (new_name, num) in used_column_names:\n222                 num += 1\n223             new_name = '%s_%d' % (new_name, num)\n224             field_notes.append('Field renamed because of name conflict.')\n225 \n226         if col_name != new_name and field_notes:\n227             field_params['db_column'] = col_name\n228 \n229         return new_name, field_params, field_notes\n230 \n231     def get_field_type(self, connection, table_name, row):\n232         \"\"\"\n233         Given the database connection, the table name, and the cursor row\n234         description, this routine will return the given field type name, as\n235         well as any additional keyword parameters and notes for the field.\n236         \"\"\"\n237         field_params = {}\n238         field_notes = []\n239 \n240         try:\n241             field_type = connection.introspection.get_field_type(row.type_code, row)\n242         except KeyError:\n243             field_type = 'TextField'\n244             field_notes.append('This field type is a guess.')\n245 \n246         # Add max_length for all CharFields.\n247         if field_type == 'CharField' and row.internal_size:\n248             field_params['max_length'] = int(row.internal_size)\n249 \n250         if field_type in {'CharField', 'TextField'} and row.collation:\n251             field_params['db_collation'] = row.collation\n252 \n253         if field_type == 'DecimalField':\n254             if row.precision is None or row.scale is None:\n255                 field_notes.append(\n256                     'max_digits and decimal_places have been guessed, as this '\n257                     'database handles decimal fields as float')\n258                 field_params['max_digits'] = row.precision if row.precision is not None else 10\n259                 field_params['decimal_places'] = row.scale if row.scale is not None else 5\n260             else:\n261                 field_params['max_digits'] = row.precision\n262                 field_params['decimal_places'] = row.scale\n263 \n264         return field_type, field_params, field_notes\n265 \n266     def get_meta(self, table_name, constraints, column_to_field_name, is_view, is_partition):\n267         \"\"\"\n268         Return a sequence comprising the lines of code necessary\n269         to construct the inner Meta class for the model corresponding\n270         to the given database table name.\n271         \"\"\"\n272         unique_together = []\n273         has_unsupported_constraint = False\n274         for params in constraints.values():\n275             if params['unique']:\n276                 columns = params['columns']\n277                 if None in columns:\n278                     has_unsupported_constraint = True\n279                 columns = [x for x in columns if x is not None]\n280                 if len(columns) > 1:\n281                     unique_together.append(str(tuple(column_to_field_name[c] for c in columns)))\n282         if is_view:\n283             managed_comment = \"  # Created from a view. Don't remove.\"\n284         elif is_partition:\n285             managed_comment = \"  # Created from a partition. Don't remove.\"\n286         else:\n287             managed_comment = ''\n288         meta = ['']\n289         if has_unsupported_constraint:\n290             meta.append('    # A unique constraint could not be introspected.')\n291         meta += [\n292             '    class Meta:',\n293             '        managed = False%s' % managed_comment,\n294             '        db_table = %r' % table_name\n295         ]\n296         if unique_together:\n297             tup = '(' + ', '.join(unique_together) + ',)'\n298             meta += [\"        unique_together = %s\" % tup]\n299         return meta\n",
        "intended_behavior": "Modify or enhance the logic that generates foreign key relationships in the Django models, ensuring that when inspectdb is run, it correctly interprets and outputs a foreign key that references a unique field as such. This includes possibly passing additional context from the introspection layer about unique constraints on fields that are also referenced by foreign keys, and then ensuring the generated model field accurately represents these constraints."
    },
    {
        "rel_file_path": "django/db/backends/postgresql/introspection.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__4.1/django/db/backends/postgresql/introspection.py",
        "start": 1,
        "end": 234,
        "class_name": null,
        "method_name": null,
        "code": "1 from django.db.backends.base.introspection import (\n2     BaseDatabaseIntrospection, FieldInfo, TableInfo,\n3 )\n4 from django.db.models import Index\n5 \n6 \n7 class DatabaseIntrospection(BaseDatabaseIntrospection):\n8     # Maps type codes to Django Field types.\n9     data_types_reverse = {\n10         16: 'BooleanField',\n11         17: 'BinaryField',\n12         20: 'BigIntegerField',\n13         21: 'SmallIntegerField',\n14         23: 'IntegerField',\n15         25: 'TextField',\n16         700: 'FloatField',\n17         701: 'FloatField',\n18         869: 'GenericIPAddressField',\n19         1042: 'CharField',  # blank-padded\n20         1043: 'CharField',\n21         1082: 'DateField',\n22         1083: 'TimeField',\n23         1114: 'DateTimeField',\n24         1184: 'DateTimeField',\n25         1186: 'DurationField',\n26         1266: 'TimeField',\n27         1700: 'DecimalField',\n28         2950: 'UUIDField',\n29         3802: 'JSONField',\n30     }\n31     # A hook for subclasses.\n32     index_default_access_method = 'btree'\n33 \n34     ignored_tables = []\n35 \n36     def get_field_type(self, data_type, description):\n37         field_type = super().get_field_type(data_type, description)\n38         if description.default and 'nextval' in description.default:\n39             if field_type == 'IntegerField':\n40                 return 'AutoField'\n41             elif field_type == 'BigIntegerField':\n42                 return 'BigAutoField'\n43             elif field_type == 'SmallIntegerField':\n44                 return 'SmallAutoField'\n45         return field_type\n46 \n47     def get_table_list(self, cursor):\n48         \"\"\"Return a list of table and view names in the current database.\"\"\"\n49         cursor.execute(\"\"\"\n50             SELECT c.relname,\n51             CASE WHEN c.relispartition THEN 'p' WHEN c.relkind IN ('m', 'v') THEN 'v' ELSE 't' END\n52             FROM pg_catalog.pg_class c\n53             LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace\n54             WHERE c.relkind IN ('f', 'm', 'p', 'r', 'v')\n55                 AND n.nspname NOT IN ('pg_catalog', 'pg_toast')\n56                 AND pg_catalog.pg_table_is_visible(c.oid)\n57         \"\"\")\n58         return [TableInfo(*row) for row in cursor.fetchall() if row[0] not in self.ignored_tables]\n59 \n60     def get_table_description(self, cursor, table_name):\n61         \"\"\"\n62         Return a description of the table with the DB-API cursor.description\n63         interface.\n64         \"\"\"\n65         # Query the pg_catalog tables as cursor.description does not reliably\n66         # return the nullable property and information_schema.columns does not\n67         # contain details of materialized views.\n68         cursor.execute(\"\"\"\n69             SELECT\n70                 a.attname AS column_name,\n71                 NOT (a.attnotnull OR (t.typtype = 'd' AND t.typnotnull)) AS is_nullable,\n72                 pg_get_expr(ad.adbin, ad.adrelid) AS column_default,\n73                 CASE WHEN collname = 'default' THEN NULL ELSE collname END AS collation\n74             FROM pg_attribute a\n75             LEFT JOIN pg_attrdef ad ON a.attrelid = ad.adrelid AND a.attnum = ad.adnum\n76             LEFT JOIN pg_collation co ON a.attcollation = co.oid\n77             JOIN pg_type t ON a.atttypid = t.oid\n78             JOIN pg_class c ON a.attrelid = c.oid\n79             JOIN pg_namespace n ON c.relnamespace = n.oid\n80             WHERE c.relkind IN ('f', 'm', 'p', 'r', 'v')\n81                 AND c.relname = %s\n82                 AND n.nspname NOT IN ('pg_catalog', 'pg_toast')\n83                 AND pg_catalog.pg_table_is_visible(c.oid)\n84         \"\"\", [table_name])\n85         field_map = {line[0]: line[1:] for line in cursor.fetchall()}\n86         cursor.execute(\"SELECT * FROM %s LIMIT 1\" % self.connection.ops.quote_name(table_name))\n87         return [\n88             FieldInfo(\n89                 line.name,\n90                 line.type_code,\n91                 line.display_size,\n92                 line.internal_size,\n93                 line.precision,\n94                 line.scale,\n95                 *field_map[line.name],\n96             )\n97             for line in cursor.description\n98         ]\n99 \n100     def get_sequences(self, cursor, table_name, table_fields=()):\n101         cursor.execute(\"\"\"\n102             SELECT s.relname as sequence_name, col.attname\n103             FROM pg_class s\n104                 JOIN pg_namespace sn ON sn.oid = s.relnamespace\n105                 JOIN pg_depend d ON d.refobjid = s.oid AND d.refclassid = 'pg_class'::regclass\n106                 JOIN pg_attrdef ad ON ad.oid = d.objid AND d.classid = 'pg_attrdef'::regclass\n107                 JOIN pg_attribute col ON col.attrelid = ad.adrelid AND col.attnum = ad.adnum\n108                 JOIN pg_class tbl ON tbl.oid = ad.adrelid\n109             WHERE s.relkind = 'S'\n110               AND d.deptype in ('a', 'n')\n111               AND pg_catalog.pg_table_is_visible(tbl.oid)\n112               AND tbl.relname = %s\n113         \"\"\", [table_name])\n114         return [\n115             {'name': row[0], 'table': table_name, 'column': row[1]}\n116             for row in cursor.fetchall()\n117         ]\n118 \n119     def get_relations(self, cursor, table_name):\n120         \"\"\"\n121         Return a dictionary of {field_name: (field_name_other_table, other_table)}\n122         representing all relationships to the given table.\n123         \"\"\"\n124         return {row[0]: (row[2], row[1]) for row in self.get_key_columns(cursor, table_name)}\n125 \n126     def get_key_columns(self, cursor, table_name):\n127         cursor.execute(\"\"\"\n128             SELECT a1.attname, c2.relname, a2.attname\n129             FROM pg_constraint con\n130             LEFT JOIN pg_class c1 ON con.conrelid = c1.oid\n131             LEFT JOIN pg_class c2 ON con.confrelid = c2.oid\n132             LEFT JOIN pg_attribute a1 ON c1.oid = a1.attrelid AND a1.attnum = con.conkey[1]\n133             LEFT JOIN pg_attribute a2 ON c2.oid = a2.attrelid AND a2.attnum = con.confkey[1]\n134             WHERE\n135                 c1.relname = %s AND\n136                 con.contype = 'f' AND\n137                 c1.relnamespace = c2.relnamespace AND\n138                 pg_catalog.pg_table_is_visible(c1.oid)\n139         \"\"\", [table_name])\n140         return cursor.fetchall()\n141 \n142     def get_constraints(self, cursor, table_name):\n143         \"\"\"\n144         Retrieve any constraints or keys (unique, pk, fk, check, index) across\n145         one or more columns. Also retrieve the definition of expression-based\n146         indexes.\n147         \"\"\"\n148         constraints = {}\n149         # Loop over the key table, collecting things as constraints. The column\n150         # array must return column names in the same order in which they were\n151         # created.\n152         cursor.execute(\"\"\"\n153             SELECT\n154                 c.conname,\n155                 array(\n156                     SELECT attname\n157                     FROM unnest(c.conkey) WITH ORDINALITY cols(colid, arridx)\n158                     JOIN pg_attribute AS ca ON cols.colid = ca.attnum\n159                     WHERE ca.attrelid = c.conrelid\n160                     ORDER BY cols.arridx\n161                 ),\n162                 c.contype,\n163                 (SELECT fkc.relname || '.' || fka.attname\n164                 FROM pg_attribute AS fka\n165                 JOIN pg_class AS fkc ON fka.attrelid = fkc.oid\n166                 WHERE fka.attrelid = c.confrelid AND fka.attnum = c.confkey[1]),\n167                 cl.reloptions\n168             FROM pg_constraint AS c\n169             JOIN pg_class AS cl ON c.conrelid = cl.oid\n170             WHERE cl.relname = %s AND pg_catalog.pg_table_is_visible(cl.oid)\n171         \"\"\", [table_name])\n172         for constraint, columns, kind, used_cols, options in cursor.fetchall():\n173             constraints[constraint] = {\n174                 \"columns\": columns,\n175                 \"primary_key\": kind == \"p\",\n176                 \"unique\": kind in [\"p\", \"u\"],\n177                 \"foreign_key\": tuple(used_cols.split(\".\", 1)) if kind == \"f\" else None,\n178                 \"check\": kind == \"c\",\n179                 \"index\": False,\n180                 \"definition\": None,\n181                 \"options\": options,\n182             }\n183         # Now get indexes\n184         cursor.execute(\"\"\"\n185             SELECT\n186                 indexname, array_agg(attname ORDER BY arridx), indisunique, indisprimary,\n187                 array_agg(ordering ORDER BY arridx), amname, exprdef, s2.attoptions\n188             FROM (\n189                 SELECT\n190                     c2.relname as indexname, idx.*, attr.attname, am.amname,\n191                     CASE\n192                         WHEN idx.indexprs IS NOT NULL THEN\n193                             pg_get_indexdef(idx.indexrelid)\n194                     END AS exprdef,\n195                     CASE am.amname\n196                         WHEN %s THEN\n197                             CASE (option & 1)\n198                                 WHEN 1 THEN 'DESC' ELSE 'ASC'\n199                             END\n200                     END as ordering,\n201                     c2.reloptions as attoptions\n202                 FROM (\n203                     SELECT *\n204                     FROM pg_index i, unnest(i.indkey, i.indoption) WITH ORDINALITY koi(key, option, arridx)\n205                 ) idx\n206                 LEFT JOIN pg_class c ON idx.indrelid = c.oid\n207                 LEFT JOIN pg_class c2 ON idx.indexrelid = c2.oid\n208                 LEFT JOIN pg_am am ON c2.relam = am.oid\n209                 LEFT JOIN pg_attribute attr ON attr.attrelid = c.oid AND attr.attnum = idx.key\n210                 WHERE c.relname = %s AND pg_catalog.pg_table_is_visible(c.oid)\n211             ) s2\n212             GROUP BY indexname, indisunique, indisprimary, amname, exprdef, attoptions;\n213         \"\"\", [self.index_default_access_method, table_name])\n214         for index, columns, unique, primary, orders, type_, definition, options in cursor.fetchall():\n215             if index not in constraints:\n216                 basic_index = (\n217                     type_ == self.index_default_access_method and\n218                     # '_btree' references\n219                     # django.contrib.postgres.indexes.BTreeIndex.suffix.\n220                     not index.endswith('_btree') and options is None\n221                 )\n222                 constraints[index] = {\n223                     \"columns\": columns if columns != [None] else [],\n224                     \"orders\": orders if orders != [None] else [],\n225                     \"primary_key\": primary,\n226                     \"unique\": unique,\n227                     \"foreign_key\": None,\n228                     \"check\": False,\n229                     \"index\": True,\n230                     \"type\": Index.suffix if basic_index else type_,\n231                     \"definition\": definition,\n232                     \"options\": options,\n233                 }\n234         return constraints\n",
        "intended_behavior": "Ensure that the get_relations or a similar method within this file is capable of correctly identifying and passing along information about foreign keys that reference unique fields. The enhancement here should allow for the distinction between a traditional foreign key relation (referencing primary keys) and one that references a unique field, enabling the ORM to accurately represent this in the models it generates."
    },
    {
        "rel_file_path": "django/db/backends/base/introspection.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__4.1/django/db/backends/base/introspection.py",
        "start": 1,
        "end": 194,
        "class_name": null,
        "method_name": null,
        "code": "1 from collections import namedtuple\n2 \n3 # Structure returned by DatabaseIntrospection.get_table_list()\n4 TableInfo = namedtuple('TableInfo', ['name', 'type'])\n5 \n6 # Structure returned by the DB-API cursor.description interface (PEP 249)\n7 FieldInfo = namedtuple(\n8     'FieldInfo',\n9     'name type_code display_size internal_size precision scale null_ok '\n10     'default collation'\n11 )\n12 \n13 \n14 class BaseDatabaseIntrospection:\n15     \"\"\"Encapsulate backend-specific introspection utilities.\"\"\"\n16     data_types_reverse = {}\n17 \n18     def __init__(self, connection):\n19         self.connection = connection\n20 \n21     def get_field_type(self, data_type, description):\n22         \"\"\"\n23         Hook for a database backend to use the cursor description to\n24         match a Django field type to a database column.\n25 \n26         For Oracle, the column data_type on its own is insufficient to\n27         distinguish between a FloatField and IntegerField, for example.\n28         \"\"\"\n29         return self.data_types_reverse[data_type]\n30 \n31     def identifier_converter(self, name):\n32         \"\"\"\n33         Apply a conversion to the identifier for the purposes of comparison.\n34 \n35         The default identifier converter is for case sensitive comparison.\n36         \"\"\"\n37         return name\n38 \n39     def table_names(self, cursor=None, include_views=False):\n40         \"\"\"\n41         Return a list of names of all tables that exist in the database.\n42         Sort the returned table list by Python's default sorting. Do NOT use\n43         the database's ORDER BY here to avoid subtle differences in sorting\n44         order between databases.\n45         \"\"\"\n46         def get_names(cursor):\n47             return sorted(ti.name for ti in self.get_table_list(cursor)\n48                           if include_views or ti.type == 't')\n49         if cursor is None:\n50             with self.connection.cursor() as cursor:\n51                 return get_names(cursor)\n52         return get_names(cursor)\n53 \n54     def get_table_list(self, cursor):\n55         \"\"\"\n56         Return an unsorted list of TableInfo named tuples of all tables and\n57         views that exist in the database.\n58         \"\"\"\n59         raise NotImplementedError('subclasses of BaseDatabaseIntrospection may require a get_table_list() method')\n60 \n61     def get_table_description(self, cursor, table_name):\n62         \"\"\"\n63         Return a description of the table with the DB-API cursor.description\n64         interface.\n65         \"\"\"\n66         raise NotImplementedError(\n67             'subclasses of BaseDatabaseIntrospection may require a '\n68             'get_table_description() method.'\n69         )\n70 \n71     def get_migratable_models(self):\n72         from django.apps import apps\n73         from django.db import router\n74         return (\n75             model\n76             for app_config in apps.get_app_configs()\n77             for model in router.get_migratable_models(app_config, self.connection.alias)\n78             if model._meta.can_migrate(self.connection)\n79         )\n80 \n81     def django_table_names(self, only_existing=False, include_views=True):\n82         \"\"\"\n83         Return a list of all table names that have associated Django models and\n84         are in INSTALLED_APPS.\n85 \n86         If only_existing is True, include only the tables in the database.\n87         \"\"\"\n88         tables = set()\n89         for model in self.get_migratable_models():\n90             if not model._meta.managed:\n91                 continue\n92             tables.add(model._meta.db_table)\n93             tables.update(\n94                 f.m2m_db_table() for f in model._meta.local_many_to_many\n95                 if f.remote_field.through._meta.managed\n96             )\n97         tables = list(tables)\n98         if only_existing:\n99             existing_tables = set(self.table_names(include_views=include_views))\n100             tables = [\n101                 t\n102                 for t in tables\n103                 if self.identifier_converter(t) in existing_tables\n104             ]\n105         return tables\n106 \n107     def installed_models(self, tables):\n108         \"\"\"\n109         Return a set of all models represented by the provided list of table\n110         names.\n111         \"\"\"\n112         tables = set(map(self.identifier_converter, tables))\n113         return {\n114             m for m in self.get_migratable_models()\n115             if self.identifier_converter(m._meta.db_table) in tables\n116         }\n117 \n118     def sequence_list(self):\n119         \"\"\"\n120         Return a list of information about all DB sequences for all models in\n121         all apps.\n122         \"\"\"\n123         sequence_list = []\n124         with self.connection.cursor() as cursor:\n125             for model in self.get_migratable_models():\n126                 if not model._meta.managed:\n127                     continue\n128                 if model._meta.swapped:\n129                     continue\n130                 sequence_list.extend(self.get_sequences(cursor, model._meta.db_table, model._meta.local_fields))\n131                 for f in model._meta.local_many_to_many:\n132                     # If this is an m2m using an intermediate table,\n133                     # we don't need to reset the sequence.\n134                     if f.remote_field.through._meta.auto_created:\n135                         sequence = self.get_sequences(cursor, f.m2m_db_table())\n136                         sequence_list.extend(sequence or [{'table': f.m2m_db_table(), 'column': None}])\n137         return sequence_list\n138 \n139     def get_sequences(self, cursor, table_name, table_fields=()):\n140         \"\"\"\n141         Return a list of introspected sequences for table_name. Each sequence\n142         is a dict: {'table': <table_name>, 'column': <column_name>}. An optional\n143         'name' key can be added if the backend supports named sequences.\n144         \"\"\"\n145         raise NotImplementedError('subclasses of BaseDatabaseIntrospection may require a get_sequences() method')\n146 \n147     def get_relations(self, cursor, table_name):\n148         \"\"\"\n149         Return a dictionary of\n150         {field_name: (field_name_other_table, other_table)} representing all\n151         relationships to the given table.\n152         \"\"\"\n153         raise NotImplementedError(\n154             'subclasses of BaseDatabaseIntrospection may require a '\n155             'get_relations() method.'\n156         )\n157 \n158     def get_key_columns(self, cursor, table_name):\n159         \"\"\"\n160         Backends can override this to return a list of:\n161             (column_name, referenced_table_name, referenced_column_name)\n162         for all key columns in given table.\n163         \"\"\"\n164         raise NotImplementedError('subclasses of BaseDatabaseIntrospection may require a get_key_columns() method')\n165 \n166     def get_primary_key_column(self, cursor, table_name):\n167         \"\"\"\n168         Return the name of the primary key column for the given table.\n169         \"\"\"\n170         for constraint in self.get_constraints(cursor, table_name).values():\n171             if constraint['primary_key']:\n172                 return constraint['columns'][0]\n173         return None\n174 \n175     def get_constraints(self, cursor, table_name):\n176         \"\"\"\n177         Retrieve any constraints or keys (unique, pk, fk, check, index)\n178         across one or more columns.\n179 \n180         Return a dict mapping constraint names to their attributes,\n181         where attributes is a dict with keys:\n182          * columns: List of columns this covers\n183          * primary_key: True if primary key, False otherwise\n184          * unique: True if this is a unique constraint, False otherwise\n185          * foreign_key: (table, column) of target, or None\n186          * check: True if check constraint, False otherwise\n187          * index: True if index, False otherwise.\n188          * orders: The order (ASC/DESC) defined for the columns of indexes\n189          * type: The type of the index (btree, hash, etc.)\n190 \n191         Some backends may return special constraint names that don't exist\n192         if they don't name constraints of a certain type (e.g. SQLite)\n193         \"\"\"\n194         raise NotImplementedError('subclasses of BaseDatabaseIntrospection may require a get_constraints() method')\n",
        "intended_behavior": "If necessary, abstract introspection methods such as get_relations in this file may require adjustment to ensure they provide enough information for the inspectdb command to generate accurate models. This might involve either enhancing existing methods or introducing new ones to convey details about unique constraints that act as foreign key targets."
    }
]