2025-10-18 09:27:56.447 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-18 09:28:07.682 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=380, output_tokens=12, cost=0.004160
2025-10-18 09:28:16.347 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=560, output_tokens=318, cost=0.015140
2025-10-18 09:28:17.843 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 09:28:21.555 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=687, output_tokens=164, cost=0.011790
2025-10-18 09:28:21.560 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 09:28:25.727 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=518, output_tokens=63, cost=0.007070
2025-10-18 09:28:25.728 | DEBUG    | Extracted a valid json.
2025-10-18 09:28:25.728 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_class(\"Partition\")",
        "search_class(\"Permutation\")",
        "search_method_in_class(\"__str__\", \"Partition\")",
        "search_method_in_class(\"__repr__\", \"Partition\")"
    ],
    "bug_locations": []
}
2025-10-18 09:28:25.773 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 09:28:25.774 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 09:28:41.645 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1929, output_tokens=693, cost=0.040080
2025-10-18 09:28:41.659 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 09:28:47.826 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2838, output_tokens=256, cost=0.036060
2025-10-18 09:28:47.831 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 09:28:53.206 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=610, output_tokens=218, cost=0.012640
2025-10-18 09:28:53.207 | DEBUG    | Extracted a valid json.
2025-10-18 09:28:53.207 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations":[
        {
            "file": "sympy/combinatorics/partitions.py",
            "class": "Partition",
            "method": "",
            "intended_behavior": "A new `__str__` or `__repr__` method should be added or modified to make the string representation of `Partition` instances less verbose, displaying elements as a simple list or set notation (`Partition({1, 2})` or `Partition([1, 2])`) without the unnecessary inclusion of `FiniteSet`."
        },
        {
            "file": "sympy/combinatorics/permutations.py",
            "class": "Permutation",
            "method": "",
            "intended_behavior": "The `__repr__` method might need modifications, and a `__str__` method could be added or modified to make the string representation of `Permutation` instances more user-friendly and less verbose, clearly conveying the permutation in a concise and understandable way."
        }
    ]
}
2025-10-18 09:28:53.219 | DEBUG    | Bug location extracted successfully: [<file>sympy/combinatorics/partitions.py</file>
<class>Partition</class>
<method>None</method>
<code>
12 class Partition(FiniteSet):
13     """
14     This class represents an abstract partition.
15 
16     A partition is a set of disjoint sets whose union equals a given set.
17 
18     See Also
19     ========
20 
21     sympy.utilities.iterables.partitions,
22     sympy.utilities.iterables.multiset_partitions
23     """
24 
25     _rank = None
26     _partition = None
27 
28     def __new__(cls, *partition):
29         """
30         Generates a new partition object.
31 
32         This method also verifies if the arguments passed are
33         valid and raises a ValueError if they are not.
34 
35         Examples
36         ========
37 
38         Creating Partition from Python lists:
39 
40         >>> from sympy.combinatorics.partitions import Partition
41         >>> a = Partition([1, 2], [3])
42         >>> a
43         Partition(FiniteSet(1, 2), FiniteSet(3))
44         >>> a.partition
45         [[1, 2], [3]]
46         >>> len(a)
47         2
48         >>> a.members
49         (1, 2, 3)
50 
51         Creating Partition from Python sets:
52 
53         >>> Partition({1, 2, 3}, {4, 5})
54         Partition(FiniteSet(1, 2, 3), FiniteSet(4, 5))
55 
56         Creating Partition from SymPy finite sets:
57 
58         >>> from sympy.sets.sets import FiniteSet
59         >>> a = FiniteSet(1, 2, 3)
60         >>> b = FiniteSet(4, 5)
61         >>> Partition(a, b)
62         Partition(FiniteSet(1, 2, 3), FiniteSet(4, 5))
63         """
64         args = []
65         dups = False
66         for arg in partition:
67             if isinstance(arg, list):
68                 as_set = set(arg)
69                 if len(as_set) < len(arg):
70                     dups = True
71                     break  # error below
72                 arg = as_set
73             args.append(_sympify(arg))
74 
75         if not all(isinstance(part, FiniteSet) for part in args):
76             raise ValueError(
77                 "Each argument to Partition should be " \
78                 "a list, set, or a FiniteSet")
79 
80         # sort so we have a canonical reference for RGS
81         U = Union(*args)
82         if dups or len(U) < sum(len(arg) for arg in args):
83             raise ValueError("Partition contained duplicate elements.")
84 
85         obj = FiniteSet.__new__(cls, *args)
86         obj.members = tuple(U)
87         obj.size = len(U)
88         return obj
89 
90     def sort_key(self, order=None):
91         """Return a canonical key that can be used for sorting.
92 
93         Ordering is based on the size and sorted elements of the partition
94         and ties are broken with the rank.
95 
96         Examples
97         ========
98 
99         >>> from sympy.utilities.iterables import default_sort_key
100         >>> from sympy.combinatorics.partitions import Partition
101         >>> from sympy.abc import x
102         >>> a = Partition([1, 2])
103         >>> b = Partition([3, 4])
104         >>> c = Partition([1, x])
105         >>> d = Partition(list(range(4)))
106         >>> l = [d, b, a + 1, a, c]
107         >>> l.sort(key=default_sort_key); l
108         [Partition(FiniteSet(1, 2)), Partition(FiniteSet(1), FiniteSet(2)), Partition(FiniteSet(1, x)), Partition(FiniteSet(3, 4)), Partition(FiniteSet(0, 1, 2, 3))]
109         """
110         if order is None:
111             members = self.members
112         else:
113             members = tuple(sorted(self.members,
114                              key=lambda w: default_sort_key(w, order)))
115         return tuple(map(default_sort_key, (self.size, members, self.rank)))
116 
117     @property
118     def partition(self):
119         """Return partition as a sorted list of lists.
120 
121         Examples
122         ========
123 
124         >>> from sympy.combinatorics.partitions import Partition
125         >>> Partition([1], [2, 3]).partition
126         [[1], [2, 3]]
127         """
128         if self._partition is None:
129             self._partition = sorted([sorted(p, key=default_sort_key)
130                                       for p in self.args])
131         return self._partition
132 
133     def __add__(self, other):
134         """
135         Return permutation whose rank is ``other`` greater than current rank,
136         (mod the maximum rank for the set).
137 
138         Examples
139         ========
140 
141         >>> from sympy.combinatorics.partitions import Partition
142         >>> a = Partition([1, 2], [3])
143         >>> a.rank
144         1
145         >>> (a + 1).rank
146         2
147         >>> (a + 100).rank
148         1
149         """
150         other = as_int(other)
151         offset = self.rank + other
152         result = RGS_unrank((offset) %
153                             RGS_enum(self.size),
154                             self.size)
155         return Partition.from_rgs(result, self.members)
156 
157     def __sub__(self, other):
158         """
159         Return permutation whose rank is ``other`` less than current rank,
160         (mod the maximum rank for the set).
161 
162         Examples
163         ========
164 
165         >>> from sympy.combinatorics.partitions import Partition
166         >>> a = Partition([1, 2], [3])
167         >>> a.rank
168         1
169         >>> (a - 1).rank
170         0
171         >>> (a - 100).rank
172         1
173         """
174         return self.__add__(-other)
175 
176     def __le__(self, other):
177         """
178         Checks if a partition is less than or equal to
179         the other based on rank.
180 
181         Examples
182         ========
183 
184         >>> from sympy.combinatorics.partitions import Partition
185         >>> a = Partition([1, 2], [3, 4, 5])
186         >>> b = Partition([1], [2, 3], [4], [5])
187         >>> a.rank, b.rank
188         (9, 34)
189         >>> a <= a
190         True
191         >>> a <= b
192         True
193         """
194         return self.sort_key() <= sympify(other).sort_key()
195 
196     def __lt__(self, other):
197         """
198         Checks if a partition is less than the other.
199 
200         Examples
201         ========
202 
203         >>> from sympy.combinatorics.partitions import Partition
204         >>> a = Partition([1, 2], [3, 4, 5])
205         >>> b = Partition([1], [2, 3], [4], [5])
206         >>> a.rank, b.rank
207         (9, 34)
208         >>> a < b
209         True
210         """
211         return self.sort_key() < sympify(other).sort_key()
212 
213     @property
214     def rank(self):
215         """
216         Gets the rank of a partition.
217 
218         Examples
219         ========
220 
221         >>> from sympy.combinatorics.partitions import Partition
222         >>> a = Partition([1, 2], [3], [4, 5])
223         >>> a.rank
224         13
225         """
226         if self._rank is not None:
227             return self._rank
228         self._rank = RGS_rank(self.RGS)
229         return self._rank
230 
231     @property
232     def RGS(self):
233         """
234         Returns the "restricted growth string" of the partition.
235 
236         Explanation
237         ===========
238 
239         The RGS is returned as a list of indices, L, where L[i] indicates
240         the block in which element i appears. For example, in a partition
241         of 3 elements (a, b, c) into 2 blocks ([c], [a, b]) the RGS is
242         [1, 1, 0]: "a" is in block 1, "b" is in block 1 and "c" is in block 0.
243 
244         Examples
245         ========
246 
247         >>> from sympy.combinatorics.partitions import Partition
248         >>> a = Partition([1, 2], [3], [4, 5])
249         >>> a.members
250         (1, 2, 3, 4, 5)
251         >>> a.RGS
252         (0, 0, 1, 2, 2)
253         >>> a + 1
254         Partition(FiniteSet(1, 2), FiniteSet(3), FiniteSet(4), FiniteSet(5))
255         >>> _.RGS
256         (0, 0, 1, 2, 3)
257         """
258         rgs = {}
259         partition = self.partition
260         for i, part in enumerate(partition):
261             for j in part:
262                 rgs[j] = i
263         return tuple([rgs[i] for i in sorted(
264             [i for p in partition for i in p], key=default_sort_key)])
265 
266     @classmethod
267     def from_rgs(self, rgs, elements):
268         """
269         Creates a set partition from a restricted growth string.
270 
271         Explanation
272         ===========
273 
274         The indices given in rgs are assumed to be the index
275         of the element as given in elements *as provided* (the
276         elements are not sorted by this routine). Block numbering
277         starts from 0. If any block was not referenced in ``rgs``
278         an error will be raised.
279 
280         Examples
281         ========
282 
283         >>> from sympy.combinatorics.partitions import Partition
284         >>> Partition.from_rgs([0, 1, 2, 0, 1], list('abcde'))
285         Partition(FiniteSet(c), FiniteSet(a, d), FiniteSet(b, e))
286         >>> Partition.from_rgs([0, 1, 2, 0, 1], list('cbead'))
287         Partition(FiniteSet(e), FiniteSet(a, c), FiniteSet(b, d))
288         >>> a = Partition([1, 4], [2], [3, 5])
289         >>> Partition.from_rgs(a.RGS, a.members)
290         Partition(FiniteSet(1, 4), FiniteSet(2), FiniteSet(3, 5))
291         """
292         if len(rgs) != len(elements):
293             raise ValueError('mismatch in rgs and element lengths')
294         max_elem = max(rgs) + 1
295         partition = [[] for i in range(max_elem)]
296         j = 0
297         for i in rgs:
298             partition[i].append(elements[j])
299             j += 1
300         if not all(p for p in partition):
301             raise ValueError('some blocks of the partition were empty.')
302         return Partition(*partition)

</code><intended_behavior>A new `__str__` or `__repr__` method should be added or modified to make the string representation of `Partition` instances less verbose, displaying elements as a simple list or set notation (`Partition({1, 2})` or `Partition([1, 2])`) without the unnecessary inclusion of `FiniteSet`.</intended_behavior>, <file>sympy/combinatorics/permutations.py</file>
<class>Permutation</class>
<method>None</method>
<code>
471 class Permutation(Atom):
472     """
473     A permutation, alternatively known as an 'arrangement number' or 'ordering'
474     is an arrangement of the elements of an ordered list into a one-to-one
475     mapping with itself. The permutation of a given arrangement is given by
476     indicating the positions of the elements after re-arrangement [2]_. For
477     example, if one started with elements [x, y, a, b] (in that order) and
478     they were reordered as [x, y, b, a] then the permutation would be
479     [0, 1, 3, 2]. Notice that (in SymPy) the first element is always referred
480     to as 0 and the permutation uses the indices of the elements in the
481     original ordering, not the elements (a, b, etc...) themselves.
482 
483     >>> from sympy.combinatorics import Permutation
484     >>> from sympy.interactive import init_printing
485     >>> init_printing(perm_cyclic=False, pretty_print=False)
486 
487     Permutations Notation
488     =====================
489 
490     Permutations are commonly represented in disjoint cycle or array forms.
491 
492     Array Notation and 2-line Form
493     ------------------------------------
494 
495     In the 2-line form, the elements and their final positions are shown
496     as a matrix with 2 rows:
497 
498     [0    1    2     ... n-1]
499     [p(0) p(1) p(2)  ... p(n-1)]
500 
501     Since the first line is always range(n), where n is the size of p,
502     it is sufficient to represent the permutation by the second line,
503     referred to as the "array form" of the permutation. This is entered
504     in brackets as the argument to the Permutation class:
505 
506     >>> p = Permutation([0, 2, 1]); p
507     Permutation([0, 2, 1])
508 
509     Given i in range(p.size), the permutation maps i to i^p
510 
511     >>> [i^p for i in range(p.size)]
512     [0, 2, 1]
513 
514     The composite of two permutations p*q means first apply p, then q, so
515     i^(p*q) = (i^p)^q which is i^p^q according to Python precedence rules:
516 
517     >>> q = Permutation([2, 1, 0])
518     >>> [i^p^q for i in range(3)]
519     [2, 0, 1]
520     >>> [i^(p*q) for i in range(3)]
521     [2, 0, 1]
522 
523     One can use also the notation p(i) = i^p, but then the composition
524     rule is (p*q)(i) = q(p(i)), not p(q(i)):
525 
526     >>> [(p*q)(i) for i in range(p.size)]
527     [2, 0, 1]
528     >>> [q(p(i)) for i in range(p.size)]
529     [2, 0, 1]
530     >>> [p(q(i)) for i in range(p.size)]
531     [1, 2, 0]
532 
533     Disjoint Cycle Notation
534     -----------------------
535 
536     In disjoint cycle notation, only the elements that have shifted are
537     indicated. In the above case, the 2 and 1 switched places. This can
538     be entered in two ways:
539 
540     >>> Permutation(1, 2) == Permutation([[1, 2]]) == p
541     True
542 
543     Only the relative ordering of elements in a cycle matter:
544 
545     >>> Permutation(1,2,3) == Permutation(2,3,1) == Permutation(3,1,2)
546     True
547 
548     The disjoint cycle notation is convenient when representing
549     permutations that have several cycles in them:
550 
551     >>> Permutation(1, 2)(3, 5) == Permutation([[1, 2], [3, 5]])
552     True
553 
554     It also provides some economy in entry when computing products of
555     permutations that are written in disjoint cycle notation:
556 
557     >>> Permutation(1, 2)(1, 3)(2, 3)
558     Permutation([0, 3, 2, 1])
559     >>> _ == Permutation([[1, 2]])*Permutation([[1, 3]])*Permutation([[2, 3]])
560     True
561 
562         Caution: when the cycles have common elements
563         between them then the order in which the
564         permutations are applied matters. The
565         convention is that the permutations are
566         applied from *right to left*. In the following, the
567         transposition of elements 2 and 3 is followed
568         by the transposition of elements 1 and 2:
569 
570         >>> Permutation(1, 2)(2, 3) == Permutation([(1, 2), (2, 3)])
571         True
572         >>> Permutation(1, 2)(2, 3).list()
573         [0, 3, 1, 2]
574 
575         If the first and second elements had been
576         swapped first, followed by the swapping of the second
577         and third, the result would have been [0, 2, 3, 1].
578         If, for some reason, you want to apply the cycles
579         in the order they are entered, you can simply reverse
580         the order of cycles:
581 
582         >>> Permutation([(1, 2), (2, 3)][::-1]).list()
583         [0, 2, 3, 1]
584 
585     Entering a singleton in a permutation is a way to indicate the size of the
586     permutation. The ``size`` keyword can also be used.
587 
588     Array-form entry:
589 
590     >>> Permutation([[1, 2], [9]])
591     Permutation([0, 2, 1], size=10)
592     >>> Permutation([[1, 2]], size=10)
593     Permutation([0, 2, 1], size=10)
594 
595     Cyclic-form entry:
596 
597     >>> Permutation(1, 2, size=10)
598     Permutation([0, 2, 1], size=10)
599     >>> Permutation(9)(1, 2)
600     Permutation([0, 2, 1], size=10)
601 
602     Caution: no singleton containing an element larger than the largest
603     in any previous cycle can be entered. This is an important difference
604     in how Permutation and Cycle handle the __call__ syntax. A singleton
605     argument at the start of a Permutation performs instantiation of the
606     Permutation and is permitted:
607 
608     >>> Permutation(5)
609     Permutation([], size=6)
610 
611     A singleton entered after instantiation is a call to the permutation
612     -- a function call -- and if the argument is out of range it will
613     trigger an error. For this reason, it is better to start the cycle
614     with the singleton:
615 
616     The following fails because there is no element 3:
617 
618     >>> Permutation(1, 2)(3)
619     Traceback (most recent call last):
620     ...
621     IndexError: list index out of range
622 
623     This is ok: only the call to an out of range singleton is prohibited;
624     otherwise the permutation autosizes:
625 
626     >>> Permutation(3)(1, 2)
627     Permutation([0, 2, 1, 3])
628     >>> Permutation(1, 2)(3, 4) == Permutation(3, 4)(1, 2)
629     True
630 
631 
632     Equality testing
633     ----------------
634 
635     The array forms must be the same in order for permutations to be equal:
636 
637     >>> Permutation([1, 0, 2, 3]) == Permutation([1, 0])
638     False
639 
640 
641     Identity Permutation
642     --------------------
643 
644     The identity permutation is a permutation in which no element is out of
645     place. It can be entered in a variety of ways. All the following create
646     an identity permutation of size 4:
647 
648     >>> I = Permutation([0, 1, 2, 3])
649     >>> all(p == I for p in [
650     ... Permutation(3),
651     ... Permutation(range(4)),
652     ... Permutation([], size=4),
653     ... Permutation(size=4)])
654     True
655 
656     Watch out for entering the range *inside* a set of brackets (which is
657     cycle notation):
658 
659     >>> I == Permutation([range(4)])
660     False
661 
662 
663     Permutation Printing
664     ====================
665 
666     There are a few things to note about how Permutations are printed.
667 
668     1) If you prefer one form (array or cycle) over another, you can set
669     ``init_printing`` with the ``perm_cyclic`` flag.
670 
671     >>> from sympy import init_printing
672     >>> p = Permutation(1, 2)(4, 5)(3, 4)
673     >>> p
674     Permutation([0, 2, 1, 4, 5, 3])
675 
676     >>> init_printing(perm_cyclic=True, pretty_print=False)
677     >>> p
678     (1 2)(3 4 5)
679 
680     2) Regardless of the setting, a list of elements in the array for cyclic
681     form can be obtained and either of those can be copied and supplied as
682     the argument to Permutation:
683 
684     >>> p.array_form
685     [0, 2, 1, 4, 5, 3]
686     >>> p.cyclic_form
687     [[1, 2], [3, 4, 5]]
688     >>> Permutation(_) == p
689     True
690 
691     3) Printing is economical in that as little as possible is printed while
692     retaining all information about the size of the permutation:
693 
694     >>> init_printing(perm_cyclic=False, pretty_print=False)
695     >>> Permutation([1, 0, 2, 3])
696     Permutation([1, 0, 2, 3])
697     >>> Permutation([1, 0, 2, 3], size=20)
698     Permutation([1, 0], size=20)
699     >>> Permutation([1, 0, 2, 4, 3, 5, 6], size=20)
700     Permutation([1, 0, 2, 4, 3], size=20)
701 
702     >>> p = Permutation([1, 0, 2, 3])
703     >>> init_printing(perm_cyclic=True, pretty_print=False)
704     >>> p
705     (3)(0 1)
706     >>> init_printing(perm_cyclic=False, pretty_print=False)
707 
708     The 2 was not printed but it is still there as can be seen with the
709     array_form and size methods:
710 
711     >>> p.array_form
712     [1, 0, 2, 3]
713     >>> p.size
714     4
715 
716     Short introduction to other methods
717     ===================================
718 
719     The permutation can act as a bijective function, telling what element is
720     located at a given position
721 
722     >>> q = Permutation([5, 2, 3, 4, 1, 0])
723     >>> q.array_form[1] # the hard way
724     2
725     >>> q(1) # the easy way
726     2
727     >>> {i: q(i) for i in range(q.size)} # showing the bijection
728     {0: 5, 1: 2, 2: 3, 3: 4, 4: 1, 5: 0}
729 
730     The full cyclic form (including singletons) can be obtained:
731 
732     >>> p.full_cyclic_form
733     [[0, 1], [2], [3]]
734 
735     Any permutation can be factored into transpositions of pairs of elements:
736 
737     >>> Permutation([[1, 2], [3, 4, 5]]).transpositions()
738     [(1, 2), (3, 5), (3, 4)]
739     >>> Permutation.rmul(*[Permutation([ti], size=6) for ti in _]).cyclic_form
740     [[1, 2], [3, 4, 5]]
741 
742     The number of permutations on a set of n elements is given by n! and is
743     called the cardinality.
744 
745     >>> p.size
746     4
747     >>> p.cardinality
748     24
749 
750     A given permutation has a rank among all the possible permutations of the
751     same elements, but what that rank is depends on how the permutations are
752     enumerated. (There are a number of different methods of doing so.) The
753     lexicographic rank is given by the rank method and this rank is used to
754     increment a permutation with addition/subtraction:
755 
756     >>> p.rank()
757     6
758     >>> p + 1
759     Permutation([1, 0, 3, 2])
760     >>> p.next_lex()
761     Permutation([1, 0, 3, 2])
762     >>> _.rank()
763     7
764     >>> p.unrank_lex(p.size, rank=7)
765     Permutation([1, 0, 3, 2])
766 
767     The product of two permutations p and q is defined as their composition as
768     functions, (p*q)(i) = q(p(i)) [6]_.
769 
770     >>> p = Permutation([1, 0, 2, 3])
771     >>> q = Permutation([2, 3, 1, 0])
772     >>> list(q*p)
773     [2, 3, 0, 1]
774     >>> list(p*q)
775     [3, 2, 1, 0]
776     >>> [q(p(i)) for i in range(p.size)]
777     [3, 2, 1, 0]
778 
779     The permutation can be 'applied' to any list-like object, not only
780     Permutations:
781 
782     >>> p(['zero', 'one', 'four', 'two'])
783     ['one', 'zero', 'four', 'two']
784     >>> p('zo42')
785     ['o', 'z', '4', '2']
786 
787     If you have a list of arbitrary elements, the corresponding permutation
788     can be found with the from_sequence method:
789 
790     >>> Permutation.from_sequence('SymPy')
791     Permutation([1, 3, 2, 0, 4])
792 
793     Checking if a Permutation is contained in a Group
794     =================================================
795 
796     Generally if you have a group of permutations G on n symbols, and
797     you're checking if a permutation on less than n symbols is part
798     of that group, the check will fail.
799 
800     Here is an example for n=5 and we check if the cycle
801     (1,2,3) is in G:
802 
803     >>> from sympy import init_printing
804     >>> init_printing(perm_cyclic=True, pretty_print=False)
805     >>> from sympy.combinatorics import Cycle, Permutation
806     >>> from sympy.combinatorics.perm_groups import PermutationGroup
807     >>> G = PermutationGroup(Cycle(2, 3)(4, 5), Cycle(1, 2, 3, 4, 5))
808     >>> p1 = Permutation(Cycle(2, 5, 3))
809     >>> p2 = Permutation(Cycle(1, 2, 3))
810     >>> a1 = Permutation(Cycle(1, 2, 3).list(6))
811     >>> a2 = Permutation(Cycle(1, 2, 3)(5))
812     >>> a3 = Permutation(Cycle(1, 2, 3),size=6)
813     >>> for p in [p1,p2,a1,a2,a3]: p, G.contains(p)
814     ((2 5 3), True)
815     ((1 2 3), False)
816     ((5)(1 2 3), True)
817     ((5)(1 2 3), True)
818     ((5)(1 2 3), True)
819 
820     The check for p2 above will fail.
821 
822     Checking if p1 is in G works because SymPy knows
823     G is a group on 5 symbols, and p1 is also on 5 symbols
824     (its largest element is 5).
825 
826     For ``a1``, the ``.list(6)`` call will extend the permutation to 5
827     symbols, so the test will work as well. In the case of ``a2`` the
828     permutation is being extended to 5 symbols by using a singleton,
829     and in the case of ``a3`` it's extended through the constructor
830     argument ``size=6``.
831 
832     There is another way to do this, which is to tell the ``contains``
833     method that the number of symbols the group is on doesn't need to
834     match perfectly the number of symbols for the permutation:
835 
836     >>> G.contains(p2,strict=False)
837     True
838 
839     This can be via the ``strict`` argument to the ``contains`` method,
840     and SymPy will try to extend the permutation on its own and then
841     perform the containment check.
842 
843     See Also
844     ========
845 
846     Cycle
847 
848     References
849     ==========
850 
851     .. [1] Skiena, S. 'Permutations.' 1.1 in Implementing Discrete Mathematics
852            Combinatorics and Graph Theory with Mathematica.  Reading, MA:
853            Addison-Wesley, pp. 3-16, 1990.
854 
855     .. [2] Knuth, D. E. The Art of Computer Programming, Vol. 4: Combinatorial
856            Algorithms, 1st ed. Reading, MA: Addison-Wesley, 2011.
857 
858     .. [3] Wendy Myrvold and Frank Ruskey. 2001. Ranking and unranking
859            permutations in linear time. Inf. Process. Lett. 79, 6 (September 2001),
860            281-284. DOI=10.1016/S0020-0190(01)00141-7
861 
862     .. [4] D. L. Kreher, D. R. Stinson 'Combinatorial Algorithms'
863            CRC Press, 1999
864 
865     .. [5] Graham, R. L.; Knuth, D. E.; and Patashnik, O.
866            Concrete Mathematics: A Foundation for Computer Science, 2nd ed.
867            Reading, MA: Addison-Wesley, 1994.
868 
869     .. [6] https://en.wikipedia.org/wiki/Permutation#Product_and_inverse
870 
871     .. [7] https://en.wikipedia.org/wiki/Lehmer_code
872 
873     """
874 
875     is_Permutation = True
876 
877     _array_form = None
878     _cyclic_form = None
879     _cycle_structure = None
880     _size = None
881     _rank = None
882 
883     def __new__(cls, *args, size=None, **kwargs):
884         """
885         Constructor for the Permutation object from a list or a
886         list of lists in which all elements of the permutation may
887         appear only once.
888 
889         Examples
890         ========
891 
892         >>> from sympy.combinatorics.permutations import Permutation
893         >>> from sympy.interactive import init_printing
894         >>> init_printing(perm_cyclic=False, pretty_print=False)
895 
896         Permutations entered in array-form are left unaltered:
897 
898         >>> Permutation([0, 2, 1])
899         Permutation([0, 2, 1])
900 
901         Permutations entered in cyclic form are converted to array form;
902         singletons need not be entered, but can be entered to indicate the
903         largest element:
904 
905         >>> Permutation([[4, 5, 6], [0, 1]])
906         Permutation([1, 0, 2, 3, 5, 6, 4])
907         >>> Permutation([[4, 5, 6], [0, 1], [19]])
908         Permutation([1, 0, 2, 3, 5, 6, 4], size=20)
909 
910         All manipulation of permutations assumes that the smallest element
911         is 0 (in keeping with 0-based indexing in Python) so if the 0 is
912         missing when entering a permutation in array form, an error will be
913         raised:
914 
915         >>> Permutation([2, 1])
916         Traceback (most recent call last):
917         ...
918         ValueError: Integers 0 through 2 must be present.
919 
920         If a permutation is entered in cyclic form, it can be entered without
921         singletons and the ``size`` specified so those values can be filled
922         in, otherwise the array form will only extend to the maximum value
923         in the cycles:
924 
925         >>> Permutation([[1, 4], [3, 5, 2]], size=10)
926         Permutation([0, 4, 3, 5, 1, 2], size=10)
927         >>> _.array_form
928         [0, 4, 3, 5, 1, 2, 6, 7, 8, 9]
929         """
930         if size is not None:
931             size = int(size)
932 
933         #a) ()
934         #b) (1) = identity
935         #c) (1, 2) = cycle
936         #d) ([1, 2, 3]) = array form
937         #e) ([[1, 2]]) = cyclic form
938         #f) (Cycle) = conversion to permutation
939         #g) (Permutation) = adjust size or return copy
940         ok = True
941         if not args:  # a
942             return cls._af_new(list(range(size or 0)))
943         elif len(args) > 1:  # c
944             return cls._af_new(Cycle(*args).list(size))
945         if len(args) == 1:
946             a = args[0]
947             if isinstance(a, cls):  # g
948                 if size is None or size == a.size:
949                     return a
950                 return cls(a.array_form, size=size)
951             if isinstance(a, Cycle):  # f
952                 return cls._af_new(a.list(size))
953             if not is_sequence(a):  # b
954                 if size is not None and a + 1 > size:
955                     raise ValueError('size is too small when max is %s' % a)
956                 return cls._af_new(list(range(a + 1)))
957             if has_variety(is_sequence(ai) for ai in a):
958                 ok = False
959         else:
960             ok = False
961         if not ok:
962             raise ValueError("Permutation argument must be a list of ints, "
963                              "a list of lists, Permutation or Cycle.")
964 
965         # safe to assume args are valid; this also makes a copy
966         # of the args
967         args = list(args[0])
968 
969         is_cycle = args and is_sequence(args[0])
970         if is_cycle:  # e
971             args = [[int(i) for i in c] for c in args]
972         else:  # d
973             args = [int(i) for i in args]
974 
975         # if there are n elements present, 0, 1, ..., n-1 should be present
976         # unless a cycle notation has been provided. A 0 will be added
977         # for convenience in case one wants to enter permutations where
978         # counting starts from 1.
979 
980         temp = flatten(args)
981         if has_dups(temp) and not is_cycle:
982             raise ValueError('there were repeated elements.')
983         temp = set(temp)
984 
985         if not is_cycle:
986             if any(i not in temp for i in range(len(temp))):
987                 raise ValueError('Integers 0 through %s must be present.' %
988                 max(temp))
989             if size is not None and temp and max(temp) + 1 > size:
990                 raise ValueError('max element should not exceed %s' % (size - 1))
991 
992         if is_cycle:
993             # it's not necessarily canonical so we won't store
994             # it -- use the array form instead
995             c = Cycle()
996             for ci in args:
997                 c = c(*ci)
998             aform = c.list()
999         else:
1000             aform = list(args)
1001         if size and size > len(aform):
1002             # don't allow for truncation of permutation which
1003             # might split a cycle and lead to an invalid aform
1004             # but do allow the permutation size to be increased
1005             aform.extend(list(range(len(aform), size)))
1006 
1007         return cls._af_new(aform)
1008 
1009     @classmethod
1010     def _af_new(cls, perm):
1011         """A method to produce a Permutation object from a list;
1012         the list is bound to the _array_form attribute, so it must
1013         not be modified; this method is meant for internal use only;
1014         the list ``a`` is supposed to be generated as a temporary value
1015         in a method, so p = Perm._af_new(a) is the only object
1016         to hold a reference to ``a``::
1017 
1018         Examples
1019         ========
1020 
1021         >>> from sympy.combinatorics.permutations import Perm
1022         >>> from sympy.interactive import init_printing
1023         >>> init_printing(perm_cyclic=False, pretty_print=False)
1024         >>> a = [2, 1, 3, 0]
1025         >>> p = Perm._af_new(a)
1026         >>> p
1027         Permutation([2, 1, 3, 0])
1028 
1029         """
1030         p = super().__new__(cls)
1031         p._array_form = perm
1032         p._size = len(perm)
1033         return p
1034 
1035     def _hashable_content(self):
1036         # the array_form (a list) is the Permutation arg, so we need to
1037         # return a tuple, instead
1038         return tuple(self.array_form)
1039 
1040     @property
1041     def array_form(self):
1042         """
1043         Return a copy of the attribute _array_form
1044         Examples
1045         ========
1046 
1047         >>> from sympy.combinatorics.permutations import Permutation
1048         >>> p = Permutation([[2, 0], [3, 1]])
1049         >>> p.array_form
1050         [2, 3, 0, 1]
1051         >>> Permutation([[2, 0, 3, 1]]).array_form
1052         [3, 2, 0, 1]
1053         >>> Permutation([2, 0, 3, 1]).array_form
1054         [2, 0, 3, 1]
1055         >>> Permutation([[1, 2], [4, 5]]).array_form
1056         [0, 2, 1, 3, 5, 4]
1057         """
1058         return self._array_form[:]
1059 
1060     def list(self, size=None):
1061         """Return the permutation as an explicit list, possibly
1062         trimming unmoved elements if size is less than the maximum
1063         element in the permutation; if this is desired, setting
1064         ``size=-1`` will guarantee such trimming.
1065 
1066         Examples
1067         ========
1068 
1069         >>> from sympy.combinatorics.permutations import Permutation
1070         >>> p = Permutation(2, 3)(4, 5)
1071         >>> p.list()
1072         [0, 1, 3, 2, 5, 4]
1073         >>> p.list(10)
1074         [0, 1, 3, 2, 5, 4, 6, 7, 8, 9]
1075 
1076         Passing a length too small will trim trailing, unchanged elements
1077         in the permutation:
1078 
1079         >>> Permutation(2, 4)(1, 2, 4).list(-1)
1080         [0, 2, 1]
1081         >>> Permutation(3).list(-1)
1082         []
1083         """
1084         if not self and size is None:
1085             raise ValueError('must give size for empty Cycle')
1086         rv = self.array_form
1087         if size is not None:
1088             if size > self.size:
1089                 rv.extend(list(range(self.size, size)))
1090             else:
1091                 # find first value from rhs where rv[i] != i
1092                 i = self.size - 1
1093                 while rv:
1094                     if rv[-1] != i:
1095                         break
1096                     rv.pop()
1097                     i -= 1
1098         return rv
1099 
1100     @property
1101     def cyclic_form(self):
1102         """
1103         This is used to convert to the cyclic notation
1104         from the canonical notation. Singletons are omitted.
1105 
1106         Examples
1107         ========
1108 
1109         >>> from sympy.combinatorics.permutations import Permutation
1110         >>> p = Permutation([0, 3, 1, 2])
1111         >>> p.cyclic_form
1112         [[1, 3, 2]]
1113         >>> Permutation([1, 0, 2, 4, 3, 5]).cyclic_form
1114         [[0, 1], [3, 4]]
1115 
1116         See Also
1117         ========
1118 
1119         array_form, full_cyclic_form
1120         """
1121         if self._cyclic_form is not None:
1122             return list(self._cyclic_form)
1123         array_form = self.array_form
1124         unchecked = [True] * len(array_form)
1125         cyclic_form = []
1126         for i in range(len(array_form)):
1127             if unchecked[i]:
1128                 cycle = []
1129                 cycle.append(i)
1130                 unchecked[i] = False
1131                 j = i
1132                 while unchecked[array_form[j]]:
1133                     j = array_form[j]
1134                     cycle.append(j)
1135                     unchecked[j] = False
1136                 if len(cycle) > 1:
1137                     cyclic_form.append(cycle)
1138                     assert cycle == list(minlex(cycle))
1139         cyclic_form.sort()
1140         self._cyclic_form = cyclic_form[:]
1141         return cyclic_form
1142 
1143     @property
1144     def full_cyclic_form(self):
1145         """Return permutation in cyclic form including singletons.
1146 
1147         Examples
1148         ========
1149 
1150         >>> from sympy.combinatorics.permutations import Permutation
1151         >>> Permutation([0, 2, 1]).full_cyclic_form
1152         [[0], [1, 2]]
1153         """
1154         need = set(range(self.size)) - set(flatten(self.cyclic_form))
1155         rv = self.cyclic_form
1156         rv.extend([[i] for i in need])
1157         rv.sort()
1158         return rv
1159 
1160     @property
1161     def size(self):
1162         """
1163         Returns the number of elements in the permutation.
1164 
1165         Examples
1166         ========
1167 
1168         >>> from sympy.combinatorics import Permutation
1169         >>> Permutation([[3, 2], [0, 1]]).size
1170         4
1171 
1172         See Also
1173         ========
1174 
1175         cardinality, length, order, rank
1176         """
1177         return self._size
1178 
1179     def support(self):
1180         """Return the elements in permutation, P, for which P[i] != i.
1181 
1182         Examples
1183         ========
1184 
1185         >>> from sympy.combinatorics import Permutation
1186         >>> p = Permutation([[3, 2], [0, 1], [4]])
1187         >>> p.array_form
1188         [1, 0, 3, 2, 4]
1189         >>> p.support()
1190         [0, 1, 2, 3]
1191         """
1192         a = self.array_form
1193         return [i for i, e in enumerate(a) if a[i] != i]
1194 
1195     def __add__(self, other):
1196         """Return permutation that is other higher in rank than self.
1197 
1198         The rank is the lexicographical rank, with the identity permutation
1199         having rank of 0.
1200 
1201         Examples
1202         ========
1203 
1204         >>> from sympy.combinatorics.permutations import Permutation
1205         >>> I = Permutation([0, 1, 2, 3])
1206         >>> a = Permutation([2, 1, 3, 0])
1207         >>> I + a.rank() == a
1208         True
1209 
1210         See Also
1211         ========
1212 
1213         __sub__, inversion_vector
1214 
1215         """
1216         rank = (self.rank() + other) % self.cardinality
1217         rv = self.unrank_lex(self.size, rank)
1218         rv._rank = rank
1219         return rv
1220 
1221     def __sub__(self, other):
1222         """Return the permutation that is other lower in rank than self.
1223 
1224         See Also
1225         ========
1226 
1227         __add__
1228         """
1229         return self.__add__(-other)
1230 
1231     @staticmethod
1232     def rmul(*args):
1233         """
1234         Return product of Permutations [a, b, c, ...] as the Permutation whose
1235         ith value is a(b(c(i))).
1236 
1237         a, b, c, ... can be Permutation objects or tuples.
1238 
1239         Examples
1240         ========
1241 
1242         >>> from sympy.combinatorics.permutations import Permutation
1243 
1244         >>> a, b = [1, 0, 2], [0, 2, 1]
1245         >>> a = Permutation(a); b = Permutation(b)
1246         >>> list(Permutation.rmul(a, b))
1247         [1, 2, 0]
1248         >>> [a(b(i)) for i in range(3)]
1249         [1, 2, 0]
1250 
1251         This handles the operands in reverse order compared to the ``*`` operator:
1252 
1253         >>> a = Permutation(a); b = Permutation(b)
1254         >>> list(a*b)
1255         [2, 0, 1]
1256         >>> [b(a(i)) for i in range(3)]
1257         [2, 0, 1]
1258 
1259         Notes
1260         =====
1261 
1262         All items in the sequence will be parsed by Permutation as
1263         necessary as long as the first item is a Permutation:
1264 
1265         >>> Permutation.rmul(a, [0, 2, 1]) == Permutation.rmul(a, b)
1266         True
1267 
1268         The reverse order of arguments will raise a TypeError.
1269 
1270         """
1271         rv = args[0]
1272         for i in range(1, len(args)):
1273             rv = args[i]*rv
1274         return rv
1275 
1276     @classmethod
1277     def rmul_with_af(cls, *args):
1278         """
1279         same as rmul, but the elements of args are Permutation objects
1280         which have _array_form
1281         """
1282         a = [x._array_form for x in args]
1283         rv = cls._af_new(_af_rmuln(*a))
1284         return rv
1285 
1286     def mul_inv(self, other):
1287         """
1288         other*~self, self and other have _array_form
1289         """
1290         a = _af_invert(self._array_form)
1291         b = other._array_form
1292         return self._af_new(_af_rmul(a, b))
1293 
1294     def __rmul__(self, other):
1295         """This is needed to coerce other to Permutation in rmul."""
1296         cls = type(self)
1297         return cls(other)*self
1298 
1299     def __mul__(self, other):
1300         """
1301         Return the product a*b as a Permutation; the ith value is b(a(i)).
1302 
1303         Examples
1304         ========
1305 
1306         >>> from sympy.combinatorics.permutations import _af_rmul, Permutation
1307 
1308         >>> a, b = [1, 0, 2], [0, 2, 1]
1309         >>> a = Permutation(a); b = Permutation(b)
1310         >>> list(a*b)
1311         [2, 0, 1]
1312         >>> [b(a(i)) for i in range(3)]
1313         [2, 0, 1]
1314 
1315         This handles operands in reverse order compared to _af_rmul and rmul:
1316 
1317         >>> al = list(a); bl = list(b)
1318         >>> _af_rmul(al, bl)
1319         [1, 2, 0]
1320         >>> [al[bl[i]] for i in range(3)]
1321         [1, 2, 0]
1322 
1323         It is acceptable for the arrays to have different lengths; the shorter
1324         one will be padded to match the longer one:
1325 
1326         >>> from sympy.interactive import init_printing
1327         >>> init_printing(perm_cyclic=False, pretty_print=False)
1328         >>> b*Permutation([1, 0])
1329         Permutation([1, 2, 0])
1330         >>> Permutation([1, 0])*b
1331         Permutation([2, 0, 1])
1332 
1333         It is also acceptable to allow coercion to handle conversion of a
1334         single list to the left of a Permutation:
1335 
1336         >>> [0, 1]*a # no change: 2-element identity
1337         Permutation([1, 0, 2])
1338         >>> [[0, 1]]*a # exchange first two elements
1339         Permutation([0, 1, 2])
1340 
1341         You cannot use more than 1 cycle notation in a product of cycles
1342         since coercion can only handle one argument to the left. To handle
1343         multiple cycles it is convenient to use Cycle instead of Permutation:
1344 
1345         >>> [[1, 2]]*[[2, 3]]*Permutation([]) # doctest: +SKIP
1346         >>> from sympy.combinatorics.permutations import Cycle
1347         >>> Cycle(1, 2)(2, 3)
1348         (1 3 2)
1349 
1350         """
1351         from sympy.combinatorics.perm_groups import PermutationGroup, Coset
1352         if isinstance(other, PermutationGroup):
1353             return Coset(self, other, dir='-')
1354         a = self.array_form
1355         # __rmul__ makes sure the other is a Permutation
1356         b = other.array_form
1357         if not b:
1358             perm = a
1359         else:
1360             b.extend(list(range(len(b), len(a))))
1361             perm = [b[i] for i in a] + b[len(a):]
1362         return self._af_new(perm)
1363 
1364     def commutes_with(self, other):
1365         """
1366         Checks if the elements are commuting.
1367 
1368         Examples
1369         ========
1370 
1371         >>> from sympy.combinatorics.permutations import Permutation
1372         >>> a = Permutation([1, 4, 3, 0, 2, 5])
1373         >>> b = Permutation([0, 1, 2, 3, 4, 5])
1374         >>> a.commutes_with(b)
1375         True
1376         >>> b = Permutation([2, 3, 5, 4, 1, 0])
1377         >>> a.commutes_with(b)
1378         False
1379         """
1380         a = self.array_form
1381         b = other.array_form
1382         return _af_commutes_with(a, b)
1383 
1384     def __pow__(self, n):
1385         """
1386         Routine for finding powers of a permutation.
1387 
1388         Examples
1389         ========
1390 
1391         >>> from sympy.combinatorics.permutations import Permutation
1392         >>> from sympy.interactive import init_printing
1393         >>> init_printing(perm_cyclic=False, pretty_print=False)
1394         >>> p = Permutation([2, 0, 3, 1])
1395         >>> p.order()
1396         4
1397         >>> p**4
1398         Permutation([0, 1, 2, 3])
1399         """
1400         if isinstance(n, Permutation):
1401             raise NotImplementedError(
1402                 'p**p is not defined; do you mean p^p (conjugate)?')
1403         n = int(n)
1404         return self._af_new(_af_pow(self.array_form, n))
1405 
1406     def __rxor__(self, i):
1407         """Return self(i) when ``i`` is an int.
1408 
1409         Examples
1410         ========
1411 
1412         >>> from sympy.combinatorics import Permutation
1413         >>> p = Permutation(1, 2, 9)
1414         >>> 2^p == p(2) == 9
1415         True
1416         """
1417         if int(i) == i:
1418             return self(i)
1419         else:
1420             raise NotImplementedError(
1421                 "i^p = p(i) when i is an integer, not %s." % i)
1422 
1423     def __xor__(self, h):
1424         """Return the conjugate permutation ``~h*self*h` `.
1425 
1426         Explanation
1427         ===========
1428 
1429         If ``a`` and ``b`` are conjugates, ``a = h*b*~h`` and
1430         ``b = ~h*a*h`` and both have the same cycle structure.
1431 
1432         Examples
1433         ========
1434 
1435         >>> from sympy.combinatorics.permutations import Permutation
1436         >>> p = Permutation(1, 2, 9)
1437         >>> q = Permutation(6, 9, 8)
1438         >>> p*q != q*p
1439         True
1440 
1441         Calculate and check properties of the conjugate:
1442 
1443         >>> c = p^q
1444         >>> c == ~q*p*q and p == q*c*~q
1445         True
1446 
1447         The expression q^p^r is equivalent to q^(p*r):
1448 
1449         >>> r = Permutation(9)(4, 6, 8)
1450         >>> q^p^r == q^(p*r)
1451         True
1452 
1453         If the term to the left of the conjugate operator, i, is an integer
1454         then this is interpreted as selecting the ith element from the
1455         permutation to the right:
1456 
1457         >>> all(i^p == p(i) for i in range(p.size))
1458         True
1459 
1460         Note that the * operator as higher precedence than the ^ operator:
1461 
1462         >>> q^r*p^r == q^(r*p)^r == Permutation(9)(1, 6, 4)
1463         True
1464 
1465         Notes
1466         =====
1467 
1468         In Python the precedence rule is p^q^r = (p^q)^r which differs
1469         in general from p^(q^r)
1470 
1471         >>> q^p^r
1472         (9)(1 4 8)
1473         >>> q^(p^r)
1474         (9)(1 8 6)
1475 
1476         For a given r and p, both of the following are conjugates of p:
1477         ~r*p*r and r*p*~r. But these are not necessarily the same:
1478 
1479         >>> ~r*p*r == r*p*~r
1480         True
1481 
1482         >>> p = Permutation(1, 2, 9)(5, 6)
1483         >>> ~r*p*r == r*p*~r
1484         False
1485 
1486         The conjugate ~r*p*r was chosen so that ``p^q^r`` would be equivalent
1487         to ``p^(q*r)`` rather than ``p^(r*q)``. To obtain r*p*~r, pass ~r to
1488         this method:
1489 
1490         >>> p^~r == r*p*~r
1491         True
1492         """
1493 
1494         if self.size != h.size:
1495             raise ValueError("The permutations must be of equal size.")
1496         a = [None]*self.size
1497         h = h._array_form
1498         p = self._array_form
1499         for i in range(self.size):
1500             a[h[i]] = h[p[i]]
1501         return self._af_new(a)
1502 
1503     def transpositions(self):
1504         """
1505         Return the permutation decomposed into a list of transpositions.
1506 
1507         Explanation
1508         ===========
1509 
1510         It is always possible to express a permutation as the product of
1511         transpositions, see [1]
1512 
1513         Examples
1514         ========
1515 
1516         >>> from sympy.combinatorics.permutations import Permutation
1517         >>> p = Permutation([[1, 2, 3], [0, 4, 5, 6, 7]])
1518         >>> t = p.transpositions()
1519         >>> t
1520         [(0, 7), (0, 6), (0, 5), (0, 4), (1, 3), (1, 2)]
1521         >>> print(''.join(str(c) for c in t))
1522         (0, 7)(0, 6)(0, 5)(0, 4)(1, 3)(1, 2)
1523         >>> Permutation.rmul(*[Permutation([ti], size=p.size) for ti in t]) == p
1524         True
1525 
1526         References
1527         ==========
1528 
1529         .. [1] https://en.wikipedia.org/wiki/Transposition_%28mathematics%29#Properties
1530 
1531         """
1532         a = self.cyclic_form
1533         res = []
1534         for x in a:
1535             nx = len(x)
1536             if nx == 2:
1537                 res.append(tuple(x))
1538             elif nx > 2:
1539                 first = x[0]
1540                 for y in x[nx - 1:0:-1]:
1541                     res.append((first, y))
1542         return res
1543 
1544     @classmethod
1545     def from_sequence(self, i, key=None):
1546         """Return the permutation needed to obtain ``i`` from the sorted
1547         elements of ``i``. If custom sorting is desired, a key can be given.
1548 
1549         Examples
1550         ========
1551 
1552         >>> from sympy.combinatorics import Permutation
1553 
1554         >>> Permutation.from_sequence('SymPy')
1555         (4)(0 1 3)
1556         >>> _(sorted("SymPy"))
1557         ['S', 'y', 'm', 'P', 'y']
1558         >>> Permutation.from_sequence('SymPy', key=lambda x: x.lower())
1559         (4)(0 2)(1 3)
1560         """
1561         ic = list(zip(i, list(range(len(i)))))
1562         if key:
1563             ic.sort(key=lambda x: key(x[0]))
1564         else:
1565             ic.sort()
1566         return ~Permutation([i[1] for i in ic])
1567 
1568     def __invert__(self):
1569         """
1570         Return the inverse of the permutation.
1571 
1572         A permutation multiplied by its inverse is the identity permutation.
1573 
1574         Examples
1575         ========
1576 
1577         >>> from sympy.combinatorics.permutations import Permutation
1578         >>> from sympy.interactive import init_printing
1579         >>> init_printing(perm_cyclic=False, pretty_print=False)
1580         >>> p = Permutation([[2, 0], [3, 1]])
1581         >>> ~p
1582         Permutation([2, 3, 0, 1])
1583         >>> _ == p**-1
1584         True
1585         >>> p*~p == ~p*p == Permutation([0, 1, 2, 3])
1586         True
1587         """
1588         return self._af_new(_af_invert(self._array_form))
1589 
1590     def __iter__(self):
1591         """Yield elements from array form.
1592 
1593         Examples
1594         ========
1595 
1596         >>> from sympy.combinatorics import Permutation
1597         >>> list(Permutation(range(3)))
1598         [0, 1, 2]
1599         """
1600         yield from self.array_form
1601 
1602     def __repr__(self):
1603         from sympy.printing.repr import srepr
1604         return srepr(self)
1605 
1606     def __call__(self, *i):
1607         """
1608         Allows applying a permutation instance as a bijective function.
1609 
1610         Examples
1611         ========
1612 
1613         >>> from sympy.combinatorics.permutations import Permutation
1614         >>> p = Permutation([[2, 0], [3, 1]])
1615         >>> p.array_form
1616         [2, 3, 0, 1]
1617         >>> [p(i) for i in range(4)]
1618         [2, 3, 0, 1]
1619 
1620         If an array is given then the permutation selects the items
1621         from the array (i.e. the permutation is applied to the array):
1622 
1623         >>> from sympy.abc import x
1624         >>> p([x, 1, 0, x**2])
1625         [0, x**2, x, 1]
1626         """
1627         # list indices can be Integer or int; leave this
1628         # as it is (don't test or convert it) because this
1629         # gets called a lot and should be fast
1630         if len(i) == 1:
1631             i = i[0]
1632             if not isinstance(i, Iterable):
1633                 i = as_int(i)
1634                 if i < 0 or i > self.size:
1635                     raise TypeError(
1636                         "{} should be an integer between 0 and {}"
1637                         .format(i, self.size-1))
1638                 return self._array_form[i]
1639             # P([a, b, c])
1640             if len(i) != self.size:
1641                 raise TypeError(
1642                     "{} should have the length {}.".format(i, self.size))
1643             return [i[j] for j in self._array_form]
1644         # P(1, 2, 3)
1645         return self*Permutation(Cycle(*i), size=self.size)
1646 
1647     def atoms(self):
1648         """
1649         Returns all the elements of a permutation
1650 
1651         Examples
1652         ========
1653 
1654         >>> from sympy.combinatorics import Permutation
1655         >>> Permutation([0, 1, 2, 3, 4, 5]).atoms()
1656         {0, 1, 2, 3, 4, 5}
1657         >>> Permutation([[0, 1], [2, 3], [4, 5]]).atoms()
1658         {0, 1, 2, 3, 4, 5}
1659         """
1660         return set(self.array_form)
1661 
1662     def apply(self, i):
1663         r"""Apply the permutation to an expression.
1664 
1665         Parameters
1666         ==========
1667 
1668         i : Expr
1669             It should be an integer between $0$ and $n-1$ where $n$
1670             is the size of the permutation.
1671 
1672             If it is a symbol or a symbolic expression that can
1673             have integer values, an ``AppliedPermutation`` object
1674             will be returned which can represent an unevaluated
1675             function.
1676 
1677         Notes
1678         =====
1679 
1680         Any permutation can be defined as a bijective function
1681         $\sigma : \{ 0, 1, ..., n-1 \} \rightarrow \{ 0, 1, ..., n-1 \}$
1682         where $n$ denotes the size of the permutation.
1683 
1684         The definition may even be extended for any set with distinctive
1685         elements, such that the permutation can even be applied for
1686         real numbers or such, however, it is not implemented for now for
1687         computational reasons and the integrity with the group theory
1688         module.
1689 
1690         This function is similar to the ``__call__`` magic, however,
1691         ``__call__`` magic already has some other applications like
1692         permuting an array or attatching new cycles, which would
1693         not always be mathematically consistent.
1694 
1695         This also guarantees that the return type is a SymPy integer,
1696         which guarantees the safety to use assumptions.
1697         """
1698         i = _sympify(i)
1699         if i.is_integer is False:
1700             raise NotImplementedError("{} should be an integer.".format(i))
1701 
1702         n = self.size
1703         if (i < 0) == True or (i >= n) == True:
1704             raise NotImplementedError(
1705                 "{} should be an integer between 0 and {}".format(i, n-1))
1706 
1707         if i.is_Integer:
1708             return Integer(self._array_form[i])
1709         return AppliedPermutation(self, i)
1710 
1711     def next_lex(self):
1712         """
1713         Returns the next permutation in lexicographical order.
1714         If self is the last permutation in lexicographical order
1715         it returns None.
1716         See [4] section 2.4.
1717 
1718 
1719         Examples
1720         ========
1721 
1722         >>> from sympy.combinatorics.permutations import Permutation
1723         >>> p = Permutation([2, 3, 1, 0])
1724         >>> p = Permutation([2, 3, 1, 0]); p.rank()
1725         17
1726         >>> p = p.next_lex(); p.rank()
1727         18
1728 
1729         See Also
1730         ========
1731 
1732         rank, unrank_lex
1733         """
1734         perm = self.array_form[:]
1735         n = len(perm)
1736         i = n - 2
1737         while perm[i + 1] < perm[i]:
1738             i -= 1
1739         if i == -1:
1740             return None
1741         else:
1742             j = n - 1
1743             while perm[j] < perm[i]:
1744                 j -= 1
1745             perm[j], perm[i] = perm[i], perm[j]
1746             i += 1
1747             j = n - 1
1748             while i < j:
1749                 perm[j], perm[i] = perm[i], perm[j]
1750                 i += 1
1751                 j -= 1
1752         return self._af_new(perm)
1753 
1754     @classmethod
1755     def unrank_nonlex(self, n, r):
1756         """
1757         This is a linear time unranking algorithm that does not
1758         respect lexicographic order [3].
1759 
1760         Examples
1761         ========
1762 
1763         >>> from sympy.combinatorics.permutations import Permutation
1764         >>> from sympy.interactive import init_printing
1765         >>> init_printing(perm_cyclic=False, pretty_print=False)
1766         >>> Permutation.unrank_nonlex(4, 5)
1767         Permutation([2, 0, 3, 1])
1768         >>> Permutation.unrank_nonlex(4, -1)
1769         Permutation([0, 1, 2, 3])
1770 
1771         See Also
1772         ========
1773 
1774         next_nonlex, rank_nonlex
1775         """
1776         def _unrank1(n, r, a):
1777             if n > 0:
1778                 a[n - 1], a[r % n] = a[r % n], a[n - 1]
1779                 _unrank1(n - 1, r//n, a)
1780 
1781         id_perm = list(range(n))
1782         n = int(n)
1783         r = r % ifac(n)
1784         _unrank1(n, r, id_perm)
1785         return self._af_new(id_perm)
1786 
1787     def rank_nonlex(self, inv_perm=None):
1788         """
1789         This is a linear time ranking algorithm that does not
1790         enforce lexicographic order [3].
1791 
1792 
1793         Examples
1794         ========
1795 
1796         >>> from sympy.combinatorics.permutations import Permutation
1797         >>> p = Permutation([0, 1, 2, 3])
1798         >>> p.rank_nonlex()
1799         23
1800 
1801         See Also
1802         ========
1803 
1804         next_nonlex, unrank_nonlex
1805         """
1806         def _rank1(n, perm, inv_perm):
1807             if n == 1:
1808                 return 0
1809             s = perm[n - 1]
1810             t = inv_perm[n - 1]
1811             perm[n - 1], perm[t] = perm[t], s
1812             inv_perm[n - 1], inv_perm[s] = inv_perm[s], t
1813             return s + n*_rank1(n - 1, perm, inv_perm)
1814 
1815         if inv_perm is None:
1816             inv_perm = (~self).array_form
1817         if not inv_perm:
1818             return 0
1819         perm = self.array_form[:]
1820         r = _rank1(len(perm), perm, inv_perm)
1821         return r
1822 
1823     def next_nonlex(self):
1824         """
1825         Returns the next permutation in nonlex order [3].
1826         If self is the last permutation in this order it returns None.
1827 
1828         Examples
1829         ========
1830 
1831         >>> from sympy.combinatorics.permutations import Permutation
1832         >>> from sympy.interactive import init_printing
1833         >>> init_printing(perm_cyclic=False, pretty_print=False)
1834         >>> p = Permutation([2, 0, 3, 1]); p.rank_nonlex()
1835         5
1836         >>> p = p.next_nonlex(); p
1837         Permutation([3, 0, 1, 2])
1838         >>> p.rank_nonlex()
1839         6
1840 
1841         See Also
1842         ========
1843 
1844         rank_nonlex, unrank_nonlex
1845         """
1846         r = self.rank_nonlex()
1847         if r == ifac(self.size) - 1:
1848             return None
1849         return self.unrank_nonlex(self.size, r + 1)
1850 
1851     def rank(self):
1852         """
1853         Returns the lexicographic rank of the permutation.
1854 
1855         Examples
1856         ========
1857 
1858         >>> from sympy.combinatorics.permutations import Permutation
1859         >>> p = Permutation([0, 1, 2, 3])
1860         >>> p.rank()
1861         0
1862         >>> p = Permutation([3, 2, 1, 0])
1863         >>> p.rank()
1864         23
1865 
1866         See Also
1867         ========
1868 
1869         next_lex, unrank_lex, cardinality, length, order, size
1870         """
1871         if not self._rank is None:
1872             return self._rank
1873         rank = 0
1874         rho = self.array_form[:]
1875         n = self.size - 1
1876         size = n + 1
1877         psize = int(ifac(n))
1878         for j in range(size - 1):
1879             rank += rho[j]*psize
1880             for i in range(j + 1, size):
1881                 if rho[i] > rho[j]:
1882                     rho[i] -= 1
1883             psize //= n
1884             n -= 1
1885         self._rank = rank
1886         return rank
1887 
1888     @property
1889     def cardinality(self):
1890         """
1891         Returns the number of all possible permutations.
1892 
1893         Examples
1894         ========
1895 
1896         >>> from sympy.combinatorics.permutations import Permutation
1897         >>> p = Permutation([0, 1, 2, 3])
1898         >>> p.cardinality
1899         24
1900 
1901         See Also
1902         ========
1903 
1904         length, order, rank, size
1905         """
1906         return int(ifac(self.size))
1907 
1908     def parity(self):
1909         """
1910         Computes the parity of a permutation.
1911 
1912         Explanation
1913         ===========
1914 
1915         The parity of a permutation reflects the parity of the
1916         number of inversions in the permutation, i.e., the
1917         number of pairs of x and y such that ``x > y`` but ``p[x] < p[y]``.
1918 
1919         Examples
1920         ========
1921 
1922         >>> from sympy.combinatorics.permutations import Permutation
1923         >>> p = Permutation([0, 1, 2, 3])
1924         >>> p.parity()
1925         0
1926         >>> p = Permutation([3, 2, 0, 1])
1927         >>> p.parity()
1928         1
1929 
1930         See Also
1931         ========
1932 
1933         _af_parity
1934         """
1935         if self._cyclic_form is not None:
1936             return (self.size - self.cycles) % 2
1937 
1938         return _af_parity(self.array_form)
1939 
1940     @property
1941     def is_even(self):
1942         """
1943         Checks if a permutation is even.
1944 
1945         Examples
1946         ========
1947 
1948         >>> from sympy.combinatorics.permutations import Permutation
1949         >>> p = Permutation([0, 1, 2, 3])
1950         >>> p.is_even
1951         True
1952         >>> p = Permutation([3, 2, 1, 0])
1953         >>> p.is_even
1954         True
1955 
1956         See Also
1957         ========
1958 
1959         is_odd
1960         """
1961         return not self.is_odd
1962 
1963     @property
1964     def is_odd(self):
1965         """
1966         Checks if a permutation is odd.
1967 
1968         Examples
1969         ========
1970 
1971         >>> from sympy.combinatorics.permutations import Permutation
1972         >>> p = Permutation([0, 1, 2, 3])
1973         >>> p.is_odd
1974         False
1975         >>> p = Permutation([3, 2, 0, 1])
1976         >>> p.is_odd
1977         True
1978 
1979         See Also
1980         ========
1981 
1982         is_even
1983         """
1984         return bool(self.parity() % 2)
1985 
1986     @property
1987     def is_Singleton(self):
1988         """
1989         Checks to see if the permutation contains only one number and is
1990         thus the only possible permutation of this set of numbers
1991 
1992         Examples
1993         ========
1994 
1995         >>> from sympy.combinatorics import Permutation
1996         >>> Permutation([0]).is_Singleton
1997         True
1998         >>> Permutation([0, 1]).is_Singleton
1999         False
2000 
2001         See Also
2002         ========
2003 
2004         is_Empty
2005         """
2006         return self.size == 1
2007 
2008     @property
2009     def is_Empty(self):
2010         """
2011         Checks to see if the permutation is a set with zero elements
2012 
2013         Examples
2014         ========
2015 
2016         >>> from sympy.combinatorics import Permutation
2017         >>> Permutation([]).is_Empty
2018         True
2019         >>> Permutation([0]).is_Empty
2020         False
2021 
2022         See Also
2023         ========
2024 
2025         is_Singleton
2026         """
2027         return self.size == 0
2028 
2029     @property
2030     def is_identity(self):
2031         return self.is_Identity
2032 
2033     @property
2034     def is_Identity(self):
2035         """
2036         Returns True if the Permutation is an identity permutation.
2037 
2038         Examples
2039         ========
2040 
2041         >>> from sympy.combinatorics.permutations import Permutation
2042         >>> p = Permutation([])
2043         >>> p.is_Identity
2044         True
2045         >>> p = Permutation([[0], [1], [2]])
2046         >>> p.is_Identity
2047         True
2048         >>> p = Permutation([0, 1, 2])
2049         >>> p.is_Identity
2050         True
2051         >>> p = Permutation([0, 2, 1])
2052         >>> p.is_Identity
2053         False
2054 
2055         See Also
2056         ========
2057 
2058         order
2059         """
2060         af = self.array_form
2061         return not af or all(i == af[i] for i in range(self.size))
2062 
2063     def ascents(self):
2064         """
2065         Returns the positions of ascents in a permutation, ie, the location
2066         where p[i] < p[i+1]
2067 
2068         Examples
2069         ========
2070 
2071         >>> from sympy.combinatorics.permutations import Permutation
2072         >>> p = Permutation([4, 0, 1, 3, 2])
2073         >>> p.ascents()
2074         [1, 2]
2075 
2076         See Also
2077         ========
2078 
2079         descents, inversions, min, max
2080         """
2081         a = self.array_form
2082         pos = [i for i in range(len(a) - 1) if a[i] < a[i + 1]]
2083         return pos
2084 
2085     def descents(self):
2086         """
2087         Returns the positions of descents in a permutation, ie, the location
2088         where p[i] > p[i+1]
2089 
2090         Examples
2091         ========
2092 
2093         >>> from sympy.combinatorics.permutations import Permutation
2094         >>> p = Permutation([4, 0, 1, 3, 2])
2095         >>> p.descents()
2096         [0, 3]
2097 
2098         See Also
2099         ========
2100 
2101         ascents, inversions, min, max
2102         """
2103         a = self.array_form
2104         pos = [i for i in range(len(a) - 1) if a[i] > a[i + 1]]
2105         return pos
2106 
2107     def max(self):
2108         """
2109         The maximum element moved by the permutation.
2110 
2111         Examples
2112         ========
2113 
2114         >>> from sympy.combinatorics.permutations import Permutation
2115         >>> p = Permutation([1, 0, 2, 3, 4])
2116         >>> p.max()
2117         1
2118 
2119         See Also
2120         ========
2121 
2122         min, descents, ascents, inversions
2123         """
2124         max = 0
2125         a = self.array_form
2126         for i in range(len(a)):
2127             if a[i] != i and a[i] > max:
2128                 max = a[i]
2129         return max
2130 
2131     def min(self):
2132         """
2133         The minimum element moved by the permutation.
2134 
2135         Examples
2136         ========
2137 
2138         >>> from sympy.combinatorics.permutations import Permutation
2139         >>> p = Permutation([0, 1, 4, 3, 2])
2140         >>> p.min()
2141         2
2142 
2143         See Also
2144         ========
2145 
2146         max, descents, ascents, inversions
2147         """
2148         a = self.array_form
2149         min = len(a)
2150         for i in range(len(a)):
2151             if a[i] != i and a[i] < min:
2152                 min = a[i]
2153         return min
2154 
2155     def inversions(self):
2156         """
2157         Computes the number of inversions of a permutation.
2158 
2159         Explanation
2160         ===========
2161 
2162         An inversion is where i > j but p[i] < p[j].
2163 
2164         For small length of p, it iterates over all i and j
2165         values and calculates the number of inversions.
2166         For large length of p, it uses a variation of merge
2167         sort to calculate the number of inversions.
2168 
2169         Examples
2170         ========
2171 
2172         >>> from sympy.combinatorics.permutations import Permutation
2173         >>> p = Permutation([0, 1, 2, 3, 4, 5])
2174         >>> p.inversions()
2175         0
2176         >>> Permutation([3, 2, 1, 0]).inversions()
2177         6
2178 
2179         See Also
2180         ========
2181 
2182         descents, ascents, min, max
2183 
2184         References
2185         ==========
2186 
2187         .. [1] http://www.cp.eng.chula.ac.th/~piak/teaching/algo/algo2008/count-inv.htm
2188 
2189         """
2190         inversions = 0
2191         a = self.array_form
2192         n = len(a)
2193         if n < 130:
2194             for i in range(n - 1):
2195                 b = a[i]
2196                 for c in a[i + 1:]:
2197                     if b > c:
2198                         inversions += 1
2199         else:
2200             k = 1
2201             right = 0
2202             arr = a[:]
2203             temp = a[:]
2204             while k < n:
2205                 i = 0
2206                 while i + k < n:
2207                     right = i + k * 2 - 1
2208                     if right >= n:
2209                         right = n - 1
2210                     inversions += _merge(arr, temp, i, i + k, right)
2211                     i = i + k * 2
2212                 k = k * 2
2213         return inversions
2214 
2215     def commutator(self, x):
2216         """Return the commutator of ``self`` and ``x``: ``~x*~self*x*self``
2217 
2218         If f and g are part of a group, G, then the commutator of f and g
2219         is the group identity iff f and g commute, i.e. fg == gf.
2220 
2221         Examples
2222         ========
2223 
2224         >>> from sympy.combinatorics.permutations import Permutation
2225         >>> from sympy.interactive import init_printing
2226         >>> init_printing(perm_cyclic=False, pretty_print=False)
2227         >>> p = Permutation([0, 2, 3, 1])
2228         >>> x = Permutation([2, 0, 3, 1])
2229         >>> c = p.commutator(x); c
2230         Permutation([2, 1, 3, 0])
2231         >>> c == ~x*~p*x*p
2232         True
2233 
2234         >>> I = Permutation(3)
2235         >>> p = [I + i for i in range(6)]
2236         >>> for i in range(len(p)):
2237         ...     for j in range(len(p)):
2238         ...         c = p[i].commutator(p[j])
2239         ...         if p[i]*p[j] == p[j]*p[i]:
2240         ...             assert c == I
2241         ...         else:
2242         ...             assert c != I
2243         ...
2244 
2245         References
2246         ==========
2247 
2248         https://en.wikipedia.org/wiki/Commutator
2249         """
2250 
2251         a = self.array_form
2252         b = x.array_form
2253         n = len(a)
2254         if len(b) != n:
2255             raise ValueError("The permutations must be of equal size.")
2256         inva = [None]*n
2257         for i in range(n):
2258             inva[a[i]] = i
2259         invb = [None]*n
2260         for i in range(n):
2261             invb[b[i]] = i
2262         return self._af_new([a[b[inva[i]]] for i in invb])
2263 
2264     def signature(self):
2265         """
2266         Gives the signature of the permutation needed to place the
2267         elements of the permutation in canonical order.
2268 
2269         The signature is calculated as (-1)^<number of inversions>
2270 
2271         Examples
2272         ========
2273 
2274         >>> from sympy.combinatorics.permutations import Permutation
2275         >>> p = Permutation([0, 1, 2])
2276         >>> p.inversions()
2277         0
2278         >>> p.signature()
2279         1
2280         >>> q = Permutation([0,2,1])
2281         >>> q.inversions()
2282         1
2283         >>> q.signature()
2284         -1
2285 
2286         See Also
2287         ========
2288 
2289         inversions
2290         """
2291         if self.is_even:
2292             return 1
2293         return -1
2294 
2295     def order(self):
2296         """
2297         Computes the order of a permutation.
2298 
2299         When the permutation is raised to the power of its
2300         order it equals the identity permutation.
2301 
2302         Examples
2303         ========
2304 
2305         >>> from sympy.combinatorics.permutations import Permutation
2306         >>> from sympy.interactive import init_printing
2307         >>> init_printing(perm_cyclic=False, pretty_print=False)
2308         >>> p = Permutation([3, 1, 5, 2, 4, 0])
2309         >>> p.order()
2310         4
2311         >>> (p**(p.order()))
2312         Permutation([], size=6)
2313 
2314         See Also
2315         ========
2316 
2317         identity, cardinality, length, rank, size
2318         """
2319 
2320         return reduce(lcm, [len(cycle) for cycle in self.cyclic_form], 1)
2321 
2322     def length(self):
2323         """
2324         Returns the number of integers moved by a permutation.
2325 
2326         Examples
2327         ========
2328 
2329         >>> from sympy.combinatorics import Permutation
2330         >>> Permutation([0, 3, 2, 1]).length()
2331         2
2332         >>> Permutation([[0, 1], [2, 3]]).length()
2333         4
2334 
2335         See Also
2336         ========
2337 
2338         min, max, support, cardinality, order, rank, size
2339         """
2340 
2341         return len(self.support())
2342 
2343     @property
2344     def cycle_structure(self):
2345         """Return the cycle structure of the permutation as a dictionary
2346         indicating the multiplicity of each cycle length.
2347 
2348         Examples
2349         ========
2350 
2351         >>> from sympy.combinatorics import Permutation
2352         >>> Permutation(3).cycle_structure
2353         {1: 4}
2354         >>> Permutation(0, 4, 3)(1, 2)(5, 6).cycle_structure
2355         {2: 2, 3: 1}
2356         """
2357         if self._cycle_structure:
2358             rv = self._cycle_structure
2359         else:
2360             rv = defaultdict(int)
2361             singletons = self.size
2362             for c in self.cyclic_form:
2363                 rv[len(c)] += 1
2364                 singletons -= len(c)
2365             if singletons:
2366                 rv[1] = singletons
2367             self._cycle_structure = rv
2368         return dict(rv)  # make a copy
2369 
2370     @property
2371     def cycles(self):
2372         """
2373         Returns the number of cycles contained in the permutation
2374         (including singletons).
2375 
2376         Examples
2377         ========
2378 
2379         >>> from sympy.combinatorics import Permutation
2380         >>> Permutation([0, 1, 2]).cycles
2381         3
2382         >>> Permutation([0, 1, 2]).full_cyclic_form
2383         [[0], [1], [2]]
2384         >>> Permutation(0, 1)(2, 3).cycles
2385         2
2386 
2387         See Also
2388         ========
2389         sympy.functions.combinatorial.numbers.stirling
2390         """
2391         return len(self.full_cyclic_form)
2392 
2393     def index(self):
2394         """
2395         Returns the index of a permutation.
2396 
2397         The index of a permutation is the sum of all subscripts j such
2398         that p[j] is greater than p[j+1].
2399 
2400         Examples
2401         ========
2402 
2403         >>> from sympy.combinatorics.permutations import Permutation
2404         >>> p = Permutation([3, 0, 2, 1, 4])
2405         >>> p.index()
2406         2
2407         """
2408         a = self.array_form
2409 
2410         return sum([j for j in range(len(a) - 1) if a[j] > a[j + 1]])
2411 
2412     def runs(self):
2413         """
2414         Returns the runs of a permutation.
2415 
2416         An ascending sequence in a permutation is called a run [5].
2417 
2418 
2419         Examples
2420         ========
2421 
2422         >>> from sympy.combinatorics.permutations import Permutation
2423         >>> p = Permutation([2, 5, 7, 3, 6, 0, 1, 4, 8])
2424         >>> p.runs()
2425         [[2, 5, 7], [3, 6], [0, 1, 4, 8]]
2426         >>> q = Permutation([1,3,2,0])
2427         >>> q.runs()
2428         [[1, 3], [2], [0]]
2429         """
2430         return runs(self.array_form)
2431 
2432     def inversion_vector(self):
2433         """Return the inversion vector of the permutation.
2434 
2435         The inversion vector consists of elements whose value
2436         indicates the number of elements in the permutation
2437         that are lesser than it and lie on its right hand side.
2438 
2439         The inversion vector is the same as the Lehmer encoding of a
2440         permutation.
2441 
2442         Examples
2443         ========
2444 
2445         >>> from sympy.combinatorics.permutations import Permutation
2446         >>> p = Permutation([4, 8, 0, 7, 1, 5, 3, 6, 2])
2447         >>> p.inversion_vector()
2448         [4, 7, 0, 5, 0, 2, 1, 1]
2449         >>> p = Permutation([3, 2, 1, 0])
2450         >>> p.inversion_vector()
2451         [3, 2, 1]
2452 
2453         The inversion vector increases lexicographically with the rank
2454         of the permutation, the -ith element cycling through 0..i.
2455 
2456         >>> p = Permutation(2)
2457         >>> while p:
2458         ...     print('%s %s %s' % (p, p.inversion_vector(), p.rank()))
2459         ...     p = p.next_lex()
2460         (2) [0, 0] 0
2461         (1 2) [0, 1] 1
2462         (2)(0 1) [1, 0] 2
2463         (0 1 2) [1, 1] 3
2464         (0 2 1) [2, 0] 4
2465         (0 2) [2, 1] 5
2466 
2467         See Also
2468         ========
2469 
2470         from_inversion_vector
2471         """
2472         self_array_form = self.array_form
2473         n = len(self_array_form)
2474         inversion_vector = [0] * (n - 1)
2475 
2476         for i in range(n - 1):
2477             val = 0
2478             for j in range(i + 1, n):
2479                 if self_array_form[j] < self_array_form[i]:
2480                     val += 1
2481             inversion_vector[i] = val
2482         return inversion_vector
2483 
2484     def rank_trotterjohnson(self):
2485         """
2486         Returns the Trotter Johnson rank, which we get from the minimal
2487         change algorithm. See [4] section 2.4.
2488 
2489         Examples
2490         ========
2491 
2492         >>> from sympy.combinatorics.permutations import Permutation
2493         >>> p = Permutation([0, 1, 2, 3])
2494         >>> p.rank_trotterjohnson()
2495         0
2496         >>> p = Permutation([0, 2, 1, 3])
2497         >>> p.rank_trotterjohnson()
2498         7
2499 
2500         See Also
2501         ========
2502 
2503         unrank_trotterjohnson, next_trotterjohnson
2504         """
2505         if self.array_form == [] or self.is_Identity:
2506             return 0
2507         if self.array_form == [1, 0]:
2508             return 1
2509         perm = self.array_form
2510         n = self.size
2511         rank = 0
2512         for j in range(1, n):
2513             k = 1
2514             i = 0
2515             while perm[i] != j:
2516                 if perm[i] < j:
2517                     k += 1
2518                 i += 1
2519             j1 = j + 1
2520             if rank % 2 == 0:
2521                 rank = j1*rank + j1 - k
2522             else:
2523                 rank = j1*rank + k - 1
2524         return rank
2525 
2526     @classmethod
2527     def unrank_trotterjohnson(cls, size, rank):
2528         """
2529         Trotter Johnson permutation unranking. See [4] section 2.4.
2530 
2531         Examples
2532         ========
2533 
2534         >>> from sympy.combinatorics.permutations import Permutation
2535         >>> from sympy.interactive import init_printing
2536         >>> init_printing(perm_cyclic=False, pretty_print=False)
2537         >>> Permutation.unrank_trotterjohnson(5, 10)
2538         Permutation([0, 3, 1, 2, 4])
2539 
2540         See Also
2541         ========
2542 
2543         rank_trotterjohnson, next_trotterjohnson
2544         """
2545         perm = [0]*size
2546         r2 = 0
2547         n = ifac(size)
2548         pj = 1
2549         for j in range(2, size + 1):
2550             pj *= j
2551             r1 = (rank * pj) // n
2552             k = r1 - j*r2
2553             if r2 % 2 == 0:
2554                 for i in range(j - 1, j - k - 1, -1):
2555                     perm[i] = perm[i - 1]
2556                 perm[j - k - 1] = j - 1
2557             else:
2558                 for i in range(j - 1, k, -1):
2559                     perm[i] = perm[i - 1]
2560                 perm[k] = j - 1
2561             r2 = r1
2562         return cls._af_new(perm)
2563 
2564     def next_trotterjohnson(self):
2565         """
2566         Returns the next permutation in Trotter-Johnson order.
2567         If self is the last permutation it returns None.
2568         See [4] section 2.4. If it is desired to generate all such
2569         permutations, they can be generated in order more quickly
2570         with the ``generate_bell`` function.
2571 
2572         Examples
2573         ========
2574 
2575         >>> from sympy.combinatorics.permutations import Permutation
2576         >>> from sympy.interactive import init_printing
2577         >>> init_printing(perm_cyclic=False, pretty_print=False)
2578         >>> p = Permutation([3, 0, 2, 1])
2579         >>> p.rank_trotterjohnson()
2580         4
2581         >>> p = p.next_trotterjohnson(); p
2582         Permutation([0, 3, 2, 1])
2583         >>> p.rank_trotterjohnson()
2584         5
2585 
2586         See Also
2587         ========
2588 
2589         rank_trotterjohnson, unrank_trotterjohnson, sympy.utilities.iterables.generate_bell
2590         """
2591         pi = self.array_form[:]
2592         n = len(pi)
2593         st = 0
2594         rho = pi[:]
2595         done = False
2596         m = n-1
2597         while m > 0 and not done:
2598             d = rho.index(m)
2599             for i in range(d, m):
2600                 rho[i] = rho[i + 1]
2601             par = _af_parity(rho[:m])
2602             if par == 1:
2603                 if d == m:
2604                     m -= 1
2605                 else:
2606                     pi[st + d], pi[st + d + 1] = pi[st + d + 1], pi[st + d]
2607                     done = True
2608             else:
2609                 if d == 0:
2610                     m -= 1
2611                     st += 1
2612                 else:
2613                     pi[st + d], pi[st + d - 1] = pi[st + d - 1], pi[st + d]
2614                     done = True
2615         if m == 0:
2616             return None
2617         return self._af_new(pi)
2618 
2619     def get_precedence_matrix(self):
2620         """
2621         Gets the precedence matrix. This is used for computing the
2622         distance between two permutations.
2623 
2624         Examples
2625         ========
2626 
2627         >>> from sympy.combinatorics.permutations import Permutation
2628         >>> from sympy.interactive import init_printing
2629         >>> init_printing(perm_cyclic=False, pretty_print=False)
2630         >>> p = Permutation.josephus(3, 6, 1)
2631         >>> p
2632         Permutation([2, 5, 3, 1, 4, 0])
2633         >>> p.get_precedence_matrix()
2634         Matrix([
2635         [0, 0, 0, 0, 0, 0],
2636         [1, 0, 0, 0, 1, 0],
2637         [1, 1, 0, 1, 1, 1],
2638         [1, 1, 0, 0, 1, 0],
2639         [1, 0, 0, 0, 0, 0],
2640         [1, 1, 0, 1, 1, 0]])
2641 
2642         See Also
2643         ========
2644 
2645         get_precedence_distance, get_adjacency_matrix, get_adjacency_distance
2646         """
2647         m = zeros(self.size)
2648         perm = self.array_form
2649         for i in range(m.rows):
2650             for j in range(i + 1, m.cols):
2651                 m[perm[i], perm[j]] = 1
2652         return m
2653 
2654     def get_precedence_distance(self, other):
2655         """
2656         Computes the precedence distance between two permutations.
2657 
2658         Explanation
2659         ===========
2660 
2661         Suppose p and p' represent n jobs. The precedence metric
2662         counts the number of times a job j is preceded by job i
2663         in both p and p'. This metric is commutative.
2664 
2665         Examples
2666         ========
2667 
2668         >>> from sympy.combinatorics.permutations import Permutation
2669         >>> p = Permutation([2, 0, 4, 3, 1])
2670         >>> q = Permutation([3, 1, 2, 4, 0])
2671         >>> p.get_precedence_distance(q)
2672         7
2673         >>> q.get_precedence_distance(p)
2674         7
2675 
2676         See Also
2677         ========
2678 
2679         get_precedence_matrix, get_adjacency_matrix, get_adjacency_distance
2680         """
2681         if self.size != other.size:
2682             raise ValueError("The permutations must be of equal size.")
2683         self_prec_mat = self.get_precedence_matrix()
2684         other_prec_mat = other.get_precedence_matrix()
2685         n_prec = 0
2686         for i in range(self.size):
2687             for j in range(self.size):
2688                 if i == j:
2689                     continue
2690                 if self_prec_mat[i, j] * other_prec_mat[i, j] == 1:
2691                     n_prec += 1
2692         d = self.size * (self.size - 1)//2 - n_prec
2693         return d
2694 
2695     def get_adjacency_matrix(self):
2696         """
2697         Computes the adjacency matrix of a permutation.
2698 
2699         Explanation
2700         ===========
2701 
2702         If job i is adjacent to job j in a permutation p
2703         then we set m[i, j] = 1 where m is the adjacency
2704         matrix of p.
2705 
2706         Examples
2707         ========
2708 
2709         >>> from sympy.combinatorics.permutations import Permutation
2710         >>> p = Permutation.josephus(3, 6, 1)
2711         >>> p.get_adjacency_matrix()
2712         Matrix([
2713         [0, 0, 0, 0, 0, 0],
2714         [0, 0, 0, 0, 1, 0],
2715         [0, 0, 0, 0, 0, 1],
2716         [0, 1, 0, 0, 0, 0],
2717         [1, 0, 0, 0, 0, 0],
2718         [0, 0, 0, 1, 0, 0]])
2719         >>> q = Permutation([0, 1, 2, 3])
2720         >>> q.get_adjacency_matrix()
2721         Matrix([
2722         [0, 1, 0, 0],
2723         [0, 0, 1, 0],
2724         [0, 0, 0, 1],
2725         [0, 0, 0, 0]])
2726 
2727         See Also
2728         ========
2729 
2730         get_precedence_matrix, get_precedence_distance, get_adjacency_distance
2731         """
2732         m = zeros(self.size)
2733         perm = self.array_form
2734         for i in range(self.size - 1):
2735             m[perm[i], perm[i + 1]] = 1
2736         return m
2737 
2738     def get_adjacency_distance(self, other):
2739         """
2740         Computes the adjacency distance between two permutations.
2741 
2742         Explanation
2743         ===========
2744 
2745         This metric counts the number of times a pair i,j of jobs is
2746         adjacent in both p and p'. If n_adj is this quantity then
2747         the adjacency distance is n - n_adj - 1 [1]
2748 
2749         [1] Reeves, Colin R. Landscapes, Operators and Heuristic search, Annals
2750         of Operational Research, 86, pp 473-490. (1999)
2751 
2752 
2753         Examples
2754         ========
2755 
2756         >>> from sympy.combinatorics.permutations import Permutation
2757         >>> p = Permutation([0, 3, 1, 2, 4])
2758         >>> q = Permutation.josephus(4, 5, 2)
2759         >>> p.get_adjacency_distance(q)
2760         3
2761         >>> r = Permutation([0, 2, 1, 4, 3])
2762         >>> p.get_adjacency_distance(r)
2763         4
2764 
2765         See Also
2766         ========
2767 
2768         get_precedence_matrix, get_precedence_distance, get_adjacency_matrix
2769         """
2770         if self.size != other.size:
2771             raise ValueError("The permutations must be of the same size.")
2772         self_adj_mat = self.get_adjacency_matrix()
2773         other_adj_mat = other.get_adjacency_matrix()
2774         n_adj = 0
2775         for i in range(self.size):
2776             for j in range(self.size):
2777                 if i == j:
2778                     continue
2779                 if self_adj_mat[i, j] * other_adj_mat[i, j] == 1:
2780                     n_adj += 1
2781         d = self.size - n_adj - 1
2782         return d
2783 
2784     def get_positional_distance(self, other):
2785         """
2786         Computes the positional distance between two permutations.
2787 
2788         Examples
2789         ========
2790 
2791         >>> from sympy.combinatorics.permutations import Permutation
2792         >>> p = Permutation([0, 3, 1, 2, 4])
2793         >>> q = Permutation.josephus(4, 5, 2)
2794         >>> r = Permutation([3, 1, 4, 0, 2])
2795         >>> p.get_positional_distance(q)
2796         12
2797         >>> p.get_positional_distance(r)
2798         12
2799 
2800         See Also
2801         ========
2802 
2803         get_precedence_distance, get_adjacency_distance
2804         """
2805         a = self.array_form
2806         b = other.array_form
2807         if len(a) != len(b):
2808             raise ValueError("The permutations must be of the same size.")
2809         return sum([abs(a[i] - b[i]) for i in range(len(a))])
2810 
2811     @classmethod
2812     def josephus(cls, m, n, s=1):
2813         """Return as a permutation the shuffling of range(n) using the Josephus
2814         scheme in which every m-th item is selected until all have been chosen.
2815         The returned permutation has elements listed by the order in which they
2816         were selected.
2817 
2818         The parameter ``s`` stops the selection process when there are ``s``
2819         items remaining and these are selected by continuing the selection,
2820         counting by 1 rather than by ``m``.
2821 
2822         Consider selecting every 3rd item from 6 until only 2 remain::
2823 
2824             choices    chosen
2825             ========   ======
2826               012345
2827               01 345   2
2828               01 34    25
2829               01  4    253
2830               0   4    2531
2831               0        25314
2832                        253140
2833 
2834         Examples
2835         ========
2836 
2837         >>> from sympy.combinatorics import Permutation
2838         >>> Permutation.josephus(3, 6, 2).array_form
2839         [2, 5, 3, 1, 4, 0]
2840 
2841         References
2842         ==========
2843 
2844         .. [1] https://en.wikipedia.org/wiki/Flavius_Josephus
2845         .. [2] https://en.wikipedia.org/wiki/Josephus_problem
2846         .. [3] http://www.wou.edu/~burtonl/josephus.html
2847 
2848         """
2849         from collections import deque
2850         m -= 1
2851         Q = deque(list(range(n)))
2852         perm = []
2853         while len(Q) > max(s, 1):
2854             for dp in range(m):
2855                 Q.append(Q.popleft())
2856             perm.append(Q.popleft())
2857         perm.extend(list(Q))
2858         return cls(perm)
2859 
2860     @classmethod
2861     def from_inversion_vector(cls, inversion):
2862         """
2863         Calculates the permutation from the inversion vector.
2864 
2865         Examples
2866         ========
2867 
2868         >>> from sympy.combinatorics.permutations import Permutation
2869         >>> from sympy.interactive import init_printing
2870         >>> init_printing(perm_cyclic=False, pretty_print=False)
2871         >>> Permutation.from_inversion_vector([3, 2, 1, 0, 0])
2872         Permutation([3, 2, 1, 0, 4, 5])
2873 
2874         """
2875         size = len(inversion)
2876         N = list(range(size + 1))
2877         perm = []
2878         try:
2879             for k in range(size):
2880                 val = N[inversion[k]]
2881                 perm.append(val)
2882                 N.remove(val)
2883         except IndexError:
2884             raise ValueError("The inversion vector is not valid.")
2885         perm.extend(N)
2886         return cls._af_new(perm)
2887 
2888     @classmethod
2889     def random(cls, n):
2890         """
2891         Generates a random permutation of length ``n``.
2892 
2893         Uses the underlying Python pseudo-random number generator.
2894 
2895         Examples
2896         ========
2897 
2898         >>> from sympy.combinatorics.permutations import Permutation
2899         >>> Permutation.random(2) in (Permutation([1, 0]), Permutation([0, 1]))
2900         True
2901 
2902         """
2903         perm_array = list(range(n))
2904         random.shuffle(perm_array)
2905         return cls._af_new(perm_array)
2906 
2907     @classmethod
2908     def unrank_lex(cls, size, rank):
2909         """
2910         Lexicographic permutation unranking.
2911 
2912         Examples
2913         ========
2914 
2915         >>> from sympy.combinatorics.permutations import Permutation
2916         >>> from sympy.interactive import init_printing
2917         >>> init_printing(perm_cyclic=False, pretty_print=False)
2918         >>> a = Permutation.unrank_lex(5, 10)
2919         >>> a.rank()
2920         10
2921         >>> a
2922         Permutation([0, 2, 4, 1, 3])
2923 
2924         See Also
2925         ========
2926 
2927         rank, next_lex
2928         """
2929         perm_array = [0] * size
2930         psize = 1
2931         for i in range(size):
2932             new_psize = psize*(i + 1)
2933             d = (rank % new_psize) // psize
2934             rank -= d*psize
2935             perm_array[size - i - 1] = d
2936             for j in range(size - i, size):
2937                 if perm_array[j] > d - 1:
2938                     perm_array[j] += 1
2939             psize = new_psize
2940         return cls._af_new(perm_array)
2941 
2942     def resize(self, n):
2943         """Resize the permutation to the new size ``n``.
2944 
2945         Parameters
2946         ==========
2947 
2948         n : int
2949             The new size of the permutation.
2950 
2951         Raises
2952         ======
2953 
2954         ValueError
2955             If the permutation cannot be resized to the given size.
2956             This may only happen when resized to a smaller size than
2957             the original.
2958 
2959         Examples
2960         ========
2961 
2962         >>> from sympy.combinatorics.permutations import Permutation
2963 
2964         Increasing the size of a permutation:
2965 
2966         >>> p = Permutation(0, 1, 2)
2967         >>> p = p.resize(5)
2968         >>> p
2969         (4)(0 1 2)
2970 
2971         Decreasing the size of the permutation:
2972 
2973         >>> p = p.resize(4)
2974         >>> p
2975         (3)(0 1 2)
2976 
2977         If resizing to the specific size breaks the cycles:
2978 
2979         >>> p.resize(2)
2980         Traceback (most recent call last):
2981         ...
2982         ValueError: The permutation can not be resized to 2 because the
2983         cycle (0, 1, 2) may break.
2984         """
2985         aform = self.array_form
2986         l = len(aform)
2987         if n > l:
2988             aform += list(range(l, n))
2989             return Permutation._af_new(aform)
2990 
2991         elif n < l:
2992             cyclic_form = self.full_cyclic_form
2993             new_cyclic_form = []
2994             for cycle in cyclic_form:
2995                 cycle_min = min(cycle)
2996                 cycle_max = max(cycle)
2997                 if cycle_min <= n-1:
2998                     if cycle_max > n-1:
2999                         raise ValueError(
3000                             "The permutation can not be resized to {} "
3001                             "because the cycle {} may break."
3002                             .format(n, tuple(cycle)))
3003 
3004                     new_cyclic_form.append(cycle)
3005             return Permutation(new_cyclic_form)
3006 
3007         return self
3008 
3009     # XXX Deprecated flag
3010     print_cyclic = None

</code><intended_behavior>The `__repr__` method might need modifications, and a `__str__` method could be added or modified to make the string representation of `Permutation` instances more user-friendly and less verbose, clearly conveying the permutation in a concise and understandable way.</intended_behavior>]
2025-10-18 09:28:53.219 | INFO     | Search completed. Bug locations: [<file>sympy/combinatorics/partitions.py</file>
<class>Partition</class>
<method>None</method>
<code>
12 class Partition(FiniteSet):
13     """
14     This class represents an abstract partition.
15 
16     A partition is a set of disjoint sets whose union equals a given set.
17 
18     See Also
19     ========
20 
21     sympy.utilities.iterables.partitions,
22     sympy.utilities.iterables.multiset_partitions
23     """
24 
25     _rank = None
26     _partition = None
27 
28     def __new__(cls, *partition):
29         """
30         Generates a new partition object.
31 
32         This method also verifies if the arguments passed are
33         valid and raises a ValueError if they are not.
34 
35         Examples
36         ========
37 
38         Creating Partition from Python lists:
39 
40         >>> from sympy.combinatorics.partitions import Partition
41         >>> a = Partition([1, 2], [3])
42         >>> a
43         Partition(FiniteSet(1, 2), FiniteSet(3))
44         >>> a.partition
45         [[1, 2], [3]]
46         >>> len(a)
47         2
48         >>> a.members
49         (1, 2, 3)
50 
51         Creating Partition from Python sets:
52 
53         >>> Partition({1, 2, 3}, {4, 5})
54         Partition(FiniteSet(1, 2, 3), FiniteSet(4, 5))
55 
56         Creating Partition from SymPy finite sets:
57 
58         >>> from sympy.sets.sets import FiniteSet
59         >>> a = FiniteSet(1, 2, 3)
60         >>> b = FiniteSet(4, 5)
61         >>> Partition(a, b)
62         Partition(FiniteSet(1, 2, 3), FiniteSet(4, 5))
63         """
64         args = []
65         dups = False
66         for arg in partition:
67             if isinstance(arg, list):
68                 as_set = set(arg)
69                 if len(as_set) < len(arg):
70                     dups = True
71                     break  # error below
72                 arg = as_set
73             args.append(_sympify(arg))
74 
75         if not all(isinstance(part, FiniteSet) for part in args):
76             raise ValueError(
77                 "Each argument to Partition should be " \
78                 "a list, set, or a FiniteSet")
79 
80         # sort so we have a canonical reference for RGS
81         U = Union(*args)
82         if dups or len(U) < sum(len(arg) for arg in args):
83             raise ValueError("Partition contained duplicate elements.")
84 
85         obj = FiniteSet.__new__(cls, *args)
86         obj.members = tuple(U)
87         obj.size = len(U)
88         return obj
89 
90     def sort_key(self, order=None):
91         """Return a canonical key that can be used for sorting.
92 
93         Ordering is based on the size and sorted elements of the partition
94         and ties are broken with the rank.
95 
96         Examples
97         ========
98 
99         >>> from sympy.utilities.iterables import default_sort_key
100         >>> from sympy.combinatorics.partitions import Partition
101         >>> from sympy.abc import x
102         >>> a = Partition([1, 2])
103         >>> b = Partition([3, 4])
104         >>> c = Partition([1, x])
105         >>> d = Partition(list(range(4)))
106         >>> l = [d, b, a + 1, a, c]
107         >>> l.sort(key=default_sort_key); l
108         [Partition(FiniteSet(1, 2)), Partition(FiniteSet(1), FiniteSet(2)), Partition(FiniteSet(1, x)), Partition(FiniteSet(3, 4)), Partition(FiniteSet(0, 1, 2, 3))]
109         """
110         if order is None:
111             members = self.members
112         else:
113             members = tuple(sorted(self.members,
114                              key=lambda w: default_sort_key(w, order)))
115         return tuple(map(default_sort_key, (self.size, members, self.rank)))
116 
117     @property
118     def partition(self):
119         """Return partition as a sorted list of lists.
120 
121         Examples
122         ========
123 
124         >>> from sympy.combinatorics.partitions import Partition
125         >>> Partition([1], [2, 3]).partition
126         [[1], [2, 3]]
127         """
128         if self._partition is None:
129             self._partition = sorted([sorted(p, key=default_sort_key)
130                                       for p in self.args])
131         return self._partition
132 
133     def __add__(self, other):
134         """
135         Return permutation whose rank is ``other`` greater than current rank,
136         (mod the maximum rank for the set).
137 
138         Examples
139         ========
140 
141         >>> from sympy.combinatorics.partitions import Partition
142         >>> a = Partition([1, 2], [3])
143         >>> a.rank
144         1
145         >>> (a + 1).rank
146         2
147         >>> (a + 100).rank
148         1
149         """
150         other = as_int(other)
151         offset = self.rank + other
152         result = RGS_unrank((offset) %
153                             RGS_enum(self.size),
154                             self.size)
155         return Partition.from_rgs(result, self.members)
156 
157     def __sub__(self, other):
158         """
159         Return permutation whose rank is ``other`` less than current rank,
160         (mod the maximum rank for the set).
161 
162         Examples
163         ========
164 
165         >>> from sympy.combinatorics.partitions import Partition
166         >>> a = Partition([1, 2], [3])
167         >>> a.rank
168         1
169         >>> (a - 1).rank
170         0
171         >>> (a - 100).rank
172         1
173         """
174         return self.__add__(-other)
175 
176     def __le__(self, other):
177         """
178         Checks if a partition is less than or equal to
179         the other based on rank.
180 
181         Examples
182         ========
183 
184         >>> from sympy.combinatorics.partitions import Partition
185         >>> a = Partition([1, 2], [3, 4, 5])
186         >>> b = Partition([1], [2, 3], [4], [5])
187         >>> a.rank, b.rank
188         (9, 34)
189         >>> a <= a
190         True
191         >>> a <= b
192         True
193         """
194         return self.sort_key() <= sympify(other).sort_key()
195 
196     def __lt__(self, other):
197         """
198         Checks if a partition is less than the other.
199 
200         Examples
201         ========
202 
203         >>> from sympy.combinatorics.partitions import Partition
204         >>> a = Partition([1, 2], [3, 4, 5])
205         >>> b = Partition([1], [2, 3], [4], [5])
206         >>> a.rank, b.rank
207         (9, 34)
208         >>> a < b
209         True
210         """
211         return self.sort_key() < sympify(other).sort_key()
212 
213     @property
214     def rank(self):
215         """
216         Gets the rank of a partition.
217 
218         Examples
219         ========
220 
221         >>> from sympy.combinatorics.partitions import Partition
222         >>> a = Partition([1, 2], [3], [4, 5])
223         >>> a.rank
224         13
225         """
226         if self._rank is not None:
227             return self._rank
228         self._rank = RGS_rank(self.RGS)
229         return self._rank
230 
231     @property
232     def RGS(self):
233         """
234         Returns the "restricted growth string" of the partition.
235 
236         Explanation
237         ===========
238 
239         The RGS is returned as a list of indices, L, where L[i] indicates
240         the block in which element i appears. For example, in a partition
241         of 3 elements (a, b, c) into 2 blocks ([c], [a, b]) the RGS is
242         [1, 1, 0]: "a" is in block 1, "b" is in block 1 and "c" is in block 0.
243 
244         Examples
245         ========
246 
247         >>> from sympy.combinatorics.partitions import Partition
248         >>> a = Partition([1, 2], [3], [4, 5])
249         >>> a.members
250         (1, 2, 3, 4, 5)
251         >>> a.RGS
252         (0, 0, 1, 2, 2)
253         >>> a + 1
254         Partition(FiniteSet(1, 2), FiniteSet(3), FiniteSet(4), FiniteSet(5))
255         >>> _.RGS
256         (0, 0, 1, 2, 3)
257         """
258         rgs = {}
259         partition = self.partition
260         for i, part in enumerate(partition):
261             for j in part:
262                 rgs[j] = i
263         return tuple([rgs[i] for i in sorted(
264             [i for p in partition for i in p], key=default_sort_key)])
265 
266     @classmethod
267     def from_rgs(self, rgs, elements):
268         """
269         Creates a set partition from a restricted growth string.
270 
271         Explanation
272         ===========
273 
274         The indices given in rgs are assumed to be the index
275         of the element as given in elements *as provided* (the
276         elements are not sorted by this routine). Block numbering
277         starts from 0. If any block was not referenced in ``rgs``
278         an error will be raised.
279 
280         Examples
281         ========
282 
283         >>> from sympy.combinatorics.partitions import Partition
284         >>> Partition.from_rgs([0, 1, 2, 0, 1], list('abcde'))
285         Partition(FiniteSet(c), FiniteSet(a, d), FiniteSet(b, e))
286         >>> Partition.from_rgs([0, 1, 2, 0, 1], list('cbead'))
287         Partition(FiniteSet(e), FiniteSet(a, c), FiniteSet(b, d))
288         >>> a = Partition([1, 4], [2], [3, 5])
289         >>> Partition.from_rgs(a.RGS, a.members)
290         Partition(FiniteSet(1, 4), FiniteSet(2), FiniteSet(3, 5))
291         """
292         if len(rgs) != len(elements):
293             raise ValueError('mismatch in rgs and element lengths')
294         max_elem = max(rgs) + 1
295         partition = [[] for i in range(max_elem)]
296         j = 0
297         for i in rgs:
298             partition[i].append(elements[j])
299             j += 1
300         if not all(p for p in partition):
301             raise ValueError('some blocks of the partition were empty.')
302         return Partition(*partition)

</code><intended_behavior>A new `__str__` or `__repr__` method should be added or modified to make the string representation of `Partition` instances less verbose, displaying elements as a simple list or set notation (`Partition({1, 2})` or `Partition([1, 2])`) without the unnecessary inclusion of `FiniteSet`.</intended_behavior>, <file>sympy/combinatorics/permutations.py</file>
<class>Permutation</class>
<method>None</method>
<code>
471 class Permutation(Atom):
472     """
473     A permutation, alternatively known as an 'arrangement number' or 'ordering'
474     is an arrangement of the elements of an ordered list into a one-to-one
475     mapping with itself. The permutation of a given arrangement is given by
476     indicating the positions of the elements after re-arrangement [2]_. For
477     example, if one started with elements [x, y, a, b] (in that order) and
478     they were reordered as [x, y, b, a] then the permutation would be
479     [0, 1, 3, 2]. Notice that (in SymPy) the first element is always referred
480     to as 0 and the permutation uses the indices of the elements in the
481     original ordering, not the elements (a, b, etc...) themselves.
482 
483     >>> from sympy.combinatorics import Permutation
484     >>> from sympy.interactive import init_printing
485     >>> init_printing(perm_cyclic=False, pretty_print=False)
486 
487     Permutations Notation
488     =====================
489 
490     Permutations are commonly represented in disjoint cycle or array forms.
491 
492     Array Notation and 2-line Form
493     ------------------------------------
494 
495     In the 2-line form, the elements and their final positions are shown
496     as a matrix with 2 rows:
497 
498     [0    1    2     ... n-1]
499     [p(0) p(1) p(2)  ... p(n-1)]
500 
501     Since the first line is always range(n), where n is the size of p,
502     it is sufficient to represent the permutation by the second line,
503     referred to as the "array form" of the permutation. This is entered
504     in brackets as the argument to the Permutation class:
505 
506     >>> p = Permutation([0, 2, 1]); p
507     Permutation([0, 2, 1])
508 
509     Given i in range(p.size), the permutation maps i to i^p
510 
511     >>> [i^p for i in range(p.size)]
512     [0, 2, 1]
513 
514     The composite of two permutations p*q means first apply p, then q, so
515     i^(p*q) = (i^p)^q which is i^p^q according to Python precedence rules:
516 
517     >>> q = Permutation([2, 1, 0])
518     >>> [i^p^q for i in range(3)]
519     [2, 0, 1]
520     >>> [i^(p*q) for i in range(3)]
521     [2, 0, 1]
522 
523     One can use also the notation p(i) = i^p, but then the composition
524     rule is (p*q)(i) = q(p(i)), not p(q(i)):
525 
526     >>> [(p*q)(i) for i in range(p.size)]
527     [2, 0, 1]
528     >>> [q(p(i)) for i in range(p.size)]
529     [2, 0, 1]
530     >>> [p(q(i)) for i in range(p.size)]
531     [1, 2, 0]
532 
533     Disjoint Cycle Notation
534     -----------------------
535 
536     In disjoint cycle notation, only the elements that have shifted are
537     indicated. In the above case, the 2 and 1 switched places. This can
538     be entered in two ways:
539 
540     >>> Permutation(1, 2) == Permutation([[1, 2]]) == p
541     True
542 
543     Only the relative ordering of elements in a cycle matter:
544 
545     >>> Permutation(1,2,3) == Permutation(2,3,1) == Permutation(3,1,2)
546     True
547 
548     The disjoint cycle notation is convenient when representing
549     permutations that have several cycles in them:
550 
551     >>> Permutation(1, 2)(3, 5) == Permutation([[1, 2], [3, 5]])
552     True
553 
554     It also provides some economy in entry when computing products of
555     permutations that are written in disjoint cycle notation:
556 
557     >>> Permutation(1, 2)(1, 3)(2, 3)
558     Permutation([0, 3, 2, 1])
559     >>> _ == Permutation([[1, 2]])*Permutation([[1, 3]])*Permutation([[2, 3]])
560     True
561 
562         Caution: when the cycles have common elements
563         between them then the order in which the
564         permutations are applied matters. The
565         convention is that the permutations are
566         applied from *right to left*. In the following, the
567         transposition of elements 2 and 3 is followed
568         by the transposition of elements 1 and 2:
569 
570         >>> Permutation(1, 2)(2, 3) == Permutation([(1, 2), (2, 3)])
571         True
572         >>> Permutation(1, 2)(2, 3).list()
573         [0, 3, 1, 2]
574 
575         If the first and second elements had been
576         swapped first, followed by the swapping of the second
577         and third, the result would have been [0, 2, 3, 1].
578         If, for some reason, you want to apply the cycles
579         in the order they are entered, you can simply reverse
580         the order of cycles:
581 
582         >>> Permutation([(1, 2), (2, 3)][::-1]).list()
583         [0, 2, 3, 1]
584 
585     Entering a singleton in a permutation is a way to indicate the size of the
586     permutation. The ``size`` keyword can also be used.
587 
588     Array-form entry:
589 
590     >>> Permutation([[1, 2], [9]])
591     Permutation([0, 2, 1], size=10)
592     >>> Permutation([[1, 2]], size=10)
593     Permutation([0, 2, 1], size=10)
594 
595     Cyclic-form entry:
596 
597     >>> Permutation(1, 2, size=10)
598     Permutation([0, 2, 1], size=10)
599     >>> Permutation(9)(1, 2)
600     Permutation([0, 2, 1], size=10)
601 
602     Caution: no singleton containing an element larger than the largest
603     in any previous cycle can be entered. This is an important difference
604     in how Permutation and Cycle handle the __call__ syntax. A singleton
605     argument at the start of a Permutation performs instantiation of the
606     Permutation and is permitted:
607 
608     >>> Permutation(5)
609     Permutation([], size=6)
610 
611     A singleton entered after instantiation is a call to the permutation
612     -- a function call -- and if the argument is out of range it will
613     trigger an error. For this reason, it is better to start the cycle
614     with the singleton:
615 
616     The following fails because there is no element 3:
617 
618     >>> Permutation(1, 2)(3)
619     Traceback (most recent call last):
620     ...
621     IndexError: list index out of range
622 
623     This is ok: only the call to an out of range singleton is prohibited;
624     otherwise the permutation autosizes:
625 
626     >>> Permutation(3)(1, 2)
627     Permutation([0, 2, 1, 3])
628     >>> Permutation(1, 2)(3, 4) == Permutation(3, 4)(1, 2)
629     True
630 
631 
632     Equality testing
633     ----------------
634 
635     The array forms must be the same in order for permutations to be equal:
636 
637     >>> Permutation([1, 0, 2, 3]) == Permutation([1, 0])
638     False
639 
640 
641     Identity Permutation
642     --------------------
643 
644     The identity permutation is a permutation in which no element is out of
645     place. It can be entered in a variety of ways. All the following create
646     an identity permutation of size 4:
647 
648     >>> I = Permutation([0, 1, 2, 3])
649     >>> all(p == I for p in [
650     ... Permutation(3),
651     ... Permutation(range(4)),
652     ... Permutation([], size=4),
653     ... Permutation(size=4)])
654     True
655 
656     Watch out for entering the range *inside* a set of brackets (which is
657     cycle notation):
658 
659     >>> I == Permutation([range(4)])
660     False
661 
662 
663     Permutation Printing
664     ====================
665 
666     There are a few things to note about how Permutations are printed.
667 
668     1) If you prefer one form (array or cycle) over another, you can set
669     ``init_printing`` with the ``perm_cyclic`` flag.
670 
671     >>> from sympy import init_printing
672     >>> p = Permutation(1, 2)(4, 5)(3, 4)
673     >>> p
674     Permutation([0, 2, 1, 4, 5, 3])
675 
676     >>> init_printing(perm_cyclic=True, pretty_print=False)
677     >>> p
678     (1 2)(3 4 5)
679 
680     2) Regardless of the setting, a list of elements in the array for cyclic
681     form can be obtained and either of those can be copied and supplied as
682     the argument to Permutation:
683 
684     >>> p.array_form
685     [0, 2, 1, 4, 5, 3]
686     >>> p.cyclic_form
687     [[1, 2], [3, 4, 5]]
688     >>> Permutation(_) == p
689     True
690 
691     3) Printing is economical in that as little as possible is printed while
692     retaining all information about the size of the permutation:
693 
694     >>> init_printing(perm_cyclic=False, pretty_print=False)
695     >>> Permutation([1, 0, 2, 3])
696     Permutation([1, 0, 2, 3])
697     >>> Permutation([1, 0, 2, 3], size=20)
698     Permutation([1, 0], size=20)
699     >>> Permutation([1, 0, 2, 4, 3, 5, 6], size=20)
700     Permutation([1, 0, 2, 4, 3], size=20)
701 
702     >>> p = Permutation([1, 0, 2, 3])
703     >>> init_printing(perm_cyclic=True, pretty_print=False)
704     >>> p
705     (3)(0 1)
706     >>> init_printing(perm_cyclic=False, pretty_print=False)
707 
708     The 2 was not printed but it is still there as can be seen with the
709     array_form and size methods:
710 
711     >>> p.array_form
712     [1, 0, 2, 3]
713     >>> p.size
714     4
715 
716     Short introduction to other methods
717     ===================================
718 
719     The permutation can act as a bijective function, telling what element is
720     located at a given position
721 
722     >>> q = Permutation([5, 2, 3, 4, 1, 0])
723     >>> q.array_form[1] # the hard way
724     2
725     >>> q(1) # the easy way
726     2
727     >>> {i: q(i) for i in range(q.size)} # showing the bijection
728     {0: 5, 1: 2, 2: 3, 3: 4, 4: 1, 5: 0}
729 
730     The full cyclic form (including singletons) can be obtained:
731 
732     >>> p.full_cyclic_form
733     [[0, 1], [2], [3]]
734 
735     Any permutation can be factored into transpositions of pairs of elements:
736 
737     >>> Permutation([[1, 2], [3, 4, 5]]).transpositions()
738     [(1, 2), (3, 5), (3, 4)]
739     >>> Permutation.rmul(*[Permutation([ti], size=6) for ti in _]).cyclic_form
740     [[1, 2], [3, 4, 5]]
741 
742     The number of permutations on a set of n elements is given by n! and is
743     called the cardinality.
744 
745     >>> p.size
746     4
747     >>> p.cardinality
748     24
749 
750     A given permutation has a rank among all the possible permutations of the
751     same elements, but what that rank is depends on how the permutations are
752     enumerated. (There are a number of different methods of doing so.) The
753     lexicographic rank is given by the rank method and this rank is used to
754     increment a permutation with addition/subtraction:
755 
756     >>> p.rank()
757     6
758     >>> p + 1
759     Permutation([1, 0, 3, 2])
760     >>> p.next_lex()
761     Permutation([1, 0, 3, 2])
762     >>> _.rank()
763     7
764     >>> p.unrank_lex(p.size, rank=7)
765     Permutation([1, 0, 3, 2])
766 
767     The product of two permutations p and q is defined as their composition as
768     functions, (p*q)(i) = q(p(i)) [6]_.
769 
770     >>> p = Permutation([1, 0, 2, 3])
771     >>> q = Permutation([2, 3, 1, 0])
772     >>> list(q*p)
773     [2, 3, 0, 1]
774     >>> list(p*q)
775     [3, 2, 1, 0]
776     >>> [q(p(i)) for i in range(p.size)]
777     [3, 2, 1, 0]
778 
779     The permutation can be 'applied' to any list-like object, not only
780     Permutations:
781 
782     >>> p(['zero', 'one', 'four', 'two'])
783     ['one', 'zero', 'four', 'two']
784     >>> p('zo42')
785     ['o', 'z', '4', '2']
786 
787     If you have a list of arbitrary elements, the corresponding permutation
788     can be found with the from_sequence method:
789 
790     >>> Permutation.from_sequence('SymPy')
791     Permutation([1, 3, 2, 0, 4])
792 
793     Checking if a Permutation is contained in a Group
794     =================================================
795 
796     Generally if you have a group of permutations G on n symbols, and
797     you're checking if a permutation on less than n symbols is part
798     of that group, the check will fail.
799 
800     Here is an example for n=5 and we check if the cycle
801     (1,2,3) is in G:
802 
803     >>> from sympy import init_printing
804     >>> init_printing(perm_cyclic=True, pretty_print=False)
805     >>> from sympy.combinatorics import Cycle, Permutation
806     >>> from sympy.combinatorics.perm_groups import PermutationGroup
807     >>> G = PermutationGroup(Cycle(2, 3)(4, 5), Cycle(1, 2, 3, 4, 5))
808     >>> p1 = Permutation(Cycle(2, 5, 3))
809     >>> p2 = Permutation(Cycle(1, 2, 3))
810     >>> a1 = Permutation(Cycle(1, 2, 3).list(6))
811     >>> a2 = Permutation(Cycle(1, 2, 3)(5))
812     >>> a3 = Permutation(Cycle(1, 2, 3),size=6)
813     >>> for p in [p1,p2,a1,a2,a3]: p, G.contains(p)
814     ((2 5 3), True)
815     ((1 2 3), False)
816     ((5)(1 2 3), True)
817     ((5)(1 2 3), True)
818     ((5)(1 2 3), True)
819 
820     The check for p2 above will fail.
821 
822     Checking if p1 is in G works because SymPy knows
823     G is a group on 5 symbols, and p1 is also on 5 symbols
824     (its largest element is 5).
825 
826     For ``a1``, the ``.list(6)`` call will extend the permutation to 5
827     symbols, so the test will work as well. In the case of ``a2`` the
828     permutation is being extended to 5 symbols by using a singleton,
829     and in the case of ``a3`` it's extended through the constructor
830     argument ``size=6``.
831 
832     There is another way to do this, which is to tell the ``contains``
833     method that the number of symbols the group is on doesn't need to
834     match perfectly the number of symbols for the permutation:
835 
836     >>> G.contains(p2,strict=False)
837     True
838 
839     This can be via the ``strict`` argument to the ``contains`` method,
840     and SymPy will try to extend the permutation on its own and then
841     perform the containment check.
842 
843     See Also
844     ========
845 
846     Cycle
847 
848     References
849     ==========
850 
851     .. [1] Skiena, S. 'Permutations.' 1.1 in Implementing Discrete Mathematics
852            Combinatorics and Graph Theory with Mathematica.  Reading, MA:
853            Addison-Wesley, pp. 3-16, 1990.
854 
855     .. [2] Knuth, D. E. The Art of Computer Programming, Vol. 4: Combinatorial
856            Algorithms, 1st ed. Reading, MA: Addison-Wesley, 2011.
857 
858     .. [3] Wendy Myrvold and Frank Ruskey. 2001. Ranking and unranking
859            permutations in linear time. Inf. Process. Lett. 79, 6 (September 2001),
860            281-284. DOI=10.1016/S0020-0190(01)00141-7
861 
862     .. [4] D. L. Kreher, D. R. Stinson 'Combinatorial Algorithms'
863            CRC Press, 1999
864 
865     .. [5] Graham, R. L.; Knuth, D. E.; and Patashnik, O.
866            Concrete Mathematics: A Foundation for Computer Science, 2nd ed.
867            Reading, MA: Addison-Wesley, 1994.
868 
869     .. [6] https://en.wikipedia.org/wiki/Permutation#Product_and_inverse
870 
871     .. [7] https://en.wikipedia.org/wiki/Lehmer_code
872 
873     """
874 
875     is_Permutation = True
876 
877     _array_form = None
878     _cyclic_form = None
879     _cycle_structure = None
880     _size = None
881     _rank = None
882 
883     def __new__(cls, *args, size=None, **kwargs):
884         """
885         Constructor for the Permutation object from a list or a
886         list of lists in which all elements of the permutation may
887         appear only once.
888 
889         Examples
890         ========
891 
892         >>> from sympy.combinatorics.permutations import Permutation
893         >>> from sympy.interactive import init_printing
894         >>> init_printing(perm_cyclic=False, pretty_print=False)
895 
896         Permutations entered in array-form are left unaltered:
897 
898         >>> Permutation([0, 2, 1])
899         Permutation([0, 2, 1])
900 
901         Permutations entered in cyclic form are converted to array form;
902         singletons need not be entered, but can be entered to indicate the
903         largest element:
904 
905         >>> Permutation([[4, 5, 6], [0, 1]])
906         Permutation([1, 0, 2, 3, 5, 6, 4])
907         >>> Permutation([[4, 5, 6], [0, 1], [19]])
908         Permutation([1, 0, 2, 3, 5, 6, 4], size=20)
909 
910         All manipulation of permutations assumes that the smallest element
911         is 0 (in keeping with 0-based indexing in Python) so if the 0 is
912         missing when entering a permutation in array form, an error will be
913         raised:
914 
915         >>> Permutation([2, 1])
916         Traceback (most recent call last):
917         ...
918         ValueError: Integers 0 through 2 must be present.
919 
920         If a permutation is entered in cyclic form, it can be entered without
921         singletons and the ``size`` specified so those values can be filled
922         in, otherwise the array form will only extend to the maximum value
923         in the cycles:
924 
925         >>> Permutation([[1, 4], [3, 5, 2]], size=10)
926         Permutation([0, 4, 3, 5, 1, 2], size=10)
927         >>> _.array_form
928         [0, 4, 3, 5, 1, 2, 6, 7, 8, 9]
929         """
930         if size is not None:
931             size = int(size)
932 
933         #a) ()
934         #b) (1) = identity
935         #c) (1, 2) = cycle
936         #d) ([1, 2, 3]) = array form
937         #e) ([[1, 2]]) = cyclic form
938         #f) (Cycle) = conversion to permutation
939         #g) (Permutation) = adjust size or return copy
940         ok = True
941         if not args:  # a
942             return cls._af_new(list(range(size or 0)))
943         elif len(args) > 1:  # c
944             return cls._af_new(Cycle(*args).list(size))
945         if len(args) == 1:
946             a = args[0]
947             if isinstance(a, cls):  # g
948                 if size is None or size == a.size:
949                     return a
950                 return cls(a.array_form, size=size)
951             if isinstance(a, Cycle):  # f
952                 return cls._af_new(a.list(size))
953             if not is_sequence(a):  # b
954                 if size is not None and a + 1 > size:
955                     raise ValueError('size is too small when max is %s' % a)
956                 return cls._af_new(list(range(a + 1)))
957             if has_variety(is_sequence(ai) for ai in a):
958                 ok = False
959         else:
960             ok = False
961         if not ok:
962             raise ValueError("Permutation argument must be a list of ints, "
963                              "a list of lists, Permutation or Cycle.")
964 
965         # safe to assume args are valid; this also makes a copy
966         # of the args
967         args = list(args[0])
968 
969         is_cycle = args and is_sequence(args[0])
970         if is_cycle:  # e
971             args = [[int(i) for i in c] for c in args]
972         else:  # d
973             args = [int(i) for i in args]
974 
975         # if there are n elements present, 0, 1, ..., n-1 should be present
976         # unless a cycle notation has been provided. A 0 will be added
977         # for convenience in case one wants to enter permutations where
978         # counting starts from 1.
979 
980         temp = flatten(args)
981         if has_dups(temp) and not is_cycle:
982             raise ValueError('there were repeated elements.')
983         temp = set(temp)
984 
985         if not is_cycle:
986             if any(i not in temp for i in range(len(temp))):
987                 raise ValueError('Integers 0 through %s must be present.' %
988                 max(temp))
989             if size is not None and temp and max(temp) + 1 > size:
990                 raise ValueError('max element should not exceed %s' % (size - 1))
991 
992         if is_cycle:
993             # it's not necessarily canonical so we won't store
994             # it -- use the array form instead
995             c = Cycle()
996             for ci in args:
997                 c = c(*ci)
998             aform = c.list()
999         else:
1000             aform = list(args)
1001         if size and size > len(aform):
1002             # don't allow for truncation of permutation which
1003             # might split a cycle and lead to an invalid aform
1004             # but do allow the permutation size to be increased
1005             aform.extend(list(range(len(aform), size)))
1006 
1007         return cls._af_new(aform)
1008 
1009     @classmethod
1010     def _af_new(cls, perm):
1011         """A method to produce a Permutation object from a list;
1012         the list is bound to the _array_form attribute, so it must
1013         not be modified; this method is meant for internal use only;
1014         the list ``a`` is supposed to be generated as a temporary value
1015         in a method, so p = Perm._af_new(a) is the only object
1016         to hold a reference to ``a``::
1017 
1018         Examples
1019         ========
1020 
1021         >>> from sympy.combinatorics.permutations import Perm
1022         >>> from sympy.interactive import init_printing
1023         >>> init_printing(perm_cyclic=False, pretty_print=False)
1024         >>> a = [2, 1, 3, 0]
1025         >>> p = Perm._af_new(a)
1026         >>> p
1027         Permutation([2, 1, 3, 0])
1028 
1029         """
1030         p = super().__new__(cls)
1031         p._array_form = perm
1032         p._size = len(perm)
1033         return p
1034 
1035     def _hashable_content(self):
1036         # the array_form (a list) is the Permutation arg, so we need to
1037         # return a tuple, instead
1038         return tuple(self.array_form)
1039 
1040     @property
1041     def array_form(self):
1042         """
1043         Return a copy of the attribute _array_form
1044         Examples
1045         ========
1046 
1047         >>> from sympy.combinatorics.permutations import Permutation
1048         >>> p = Permutation([[2, 0], [3, 1]])
1049         >>> p.array_form
1050         [2, 3, 0, 1]
1051         >>> Permutation([[2, 0, 3, 1]]).array_form
1052         [3, 2, 0, 1]
1053         >>> Permutation([2, 0, 3, 1]).array_form
1054         [2, 0, 3, 1]
1055         >>> Permutation([[1, 2], [4, 5]]).array_form
1056         [0, 2, 1, 3, 5, 4]
1057         """
1058         return self._array_form[:]
1059 
1060     def list(self, size=None):
1061         """Return the permutation as an explicit list, possibly
1062         trimming unmoved elements if size is less than the maximum
1063         element in the permutation; if this is desired, setting
1064         ``size=-1`` will guarantee such trimming.
1065 
1066         Examples
1067         ========
1068 
1069         >>> from sympy.combinatorics.permutations import Permutation
1070         >>> p = Permutation(2, 3)(4, 5)
1071         >>> p.list()
1072         [0, 1, 3, 2, 5, 4]
1073         >>> p.list(10)
1074         [0, 1, 3, 2, 5, 4, 6, 7, 8, 9]
1075 
1076         Passing a length too small will trim trailing, unchanged elements
1077         in the permutation:
1078 
1079         >>> Permutation(2, 4)(1, 2, 4).list(-1)
1080         [0, 2, 1]
1081         >>> Permutation(3).list(-1)
1082         []
1083         """
1084         if not self and size is None:
1085             raise ValueError('must give size for empty Cycle')
1086         rv = self.array_form
1087         if size is not None:
1088             if size > self.size:
1089                 rv.extend(list(range(self.size, size)))
1090             else:
1091                 # find first value from rhs where rv[i] != i
1092                 i = self.size - 1
1093                 while rv:
1094                     if rv[-1] != i:
1095                         break
1096                     rv.pop()
1097                     i -= 1
1098         return rv
1099 
1100     @property
1101     def cyclic_form(self):
1102         """
1103         This is used to convert to the cyclic notation
1104         from the canonical notation. Singletons are omitted.
1105 
1106         Examples
1107         ========
1108 
1109         >>> from sympy.combinatorics.permutations import Permutation
1110         >>> p = Permutation([0, 3, 1, 2])
1111         >>> p.cyclic_form
1112         [[1, 3, 2]]
1113         >>> Permutation([1, 0, 2, 4, 3, 5]).cyclic_form
1114         [[0, 1], [3, 4]]
1115 
1116         See Also
1117         ========
1118 
1119         array_form, full_cyclic_form
1120         """
1121         if self._cyclic_form is not None:
1122             return list(self._cyclic_form)
1123         array_form = self.array_form
1124         unchecked = [True] * len(array_form)
1125         cyclic_form = []
1126         for i in range(len(array_form)):
1127             if unchecked[i]:
1128                 cycle = []
1129                 cycle.append(i)
1130                 unchecked[i] = False
1131                 j = i
1132                 while unchecked[array_form[j]]:
1133                     j = array_form[j]
1134                     cycle.append(j)
1135                     unchecked[j] = False
1136                 if len(cycle) > 1:
1137                     cyclic_form.append(cycle)
1138                     assert cycle == list(minlex(cycle))
1139         cyclic_form.sort()
1140         self._cyclic_form = cyclic_form[:]
1141         return cyclic_form
1142 
1143     @property
1144     def full_cyclic_form(self):
1145         """Return permutation in cyclic form including singletons.
1146 
1147         Examples
1148         ========
1149 
1150         >>> from sympy.combinatorics.permutations import Permutation
1151         >>> Permutation([0, 2, 1]).full_cyclic_form
1152         [[0], [1, 2]]
1153         """
1154         need = set(range(self.size)) - set(flatten(self.cyclic_form))
1155         rv = self.cyclic_form
1156         rv.extend([[i] for i in need])
1157         rv.sort()
1158         return rv
1159 
1160     @property
1161     def size(self):
1162         """
1163         Returns the number of elements in the permutation.
1164 
1165         Examples
1166         ========
1167 
1168         >>> from sympy.combinatorics import Permutation
1169         >>> Permutation([[3, 2], [0, 1]]).size
1170         4
1171 
1172         See Also
1173         ========
1174 
1175         cardinality, length, order, rank
1176         """
1177         return self._size
1178 
1179     def support(self):
1180         """Return the elements in permutation, P, for which P[i] != i.
1181 
1182         Examples
1183         ========
1184 
1185         >>> from sympy.combinatorics import Permutation
1186         >>> p = Permutation([[3, 2], [0, 1], [4]])
1187         >>> p.array_form
1188         [1, 0, 3, 2, 4]
1189         >>> p.support()
1190         [0, 1, 2, 3]
1191         """
1192         a = self.array_form
1193         return [i for i, e in enumerate(a) if a[i] != i]
1194 
1195     def __add__(self, other):
1196         """Return permutation that is other higher in rank than self.
1197 
1198         The rank is the lexicographical rank, with the identity permutation
1199         having rank of 0.
1200 
1201         Examples
1202         ========
1203 
1204         >>> from sympy.combinatorics.permutations import Permutation
1205         >>> I = Permutation([0, 1, 2, 3])
1206         >>> a = Permutation([2, 1, 3, 0])
1207         >>> I + a.rank() == a
1208         True
1209 
1210         See Also
1211         ========
1212 
1213         __sub__, inversion_vector
1214 
1215         """
1216         rank = (self.rank() + other) % self.cardinality
1217         rv = self.unrank_lex(self.size, rank)
1218         rv._rank = rank
1219         return rv
1220 
1221     def __sub__(self, other):
1222         """Return the permutation that is other lower in rank than self.
1223 
1224         See Also
1225         ========
1226 
1227         __add__
1228         """
1229         return self.__add__(-other)
1230 
1231     @staticmethod
1232     def rmul(*args):
1233         """
1234         Return product of Permutations [a, b, c, ...] as the Permutation whose
1235         ith value is a(b(c(i))).
1236 
1237         a, b, c, ... can be Permutation objects or tuples.
1238 
1239         Examples
1240         ========
1241 
1242         >>> from sympy.combinatorics.permutations import Permutation
1243 
1244         >>> a, b = [1, 0, 2], [0, 2, 1]
1245         >>> a = Permutation(a); b = Permutation(b)
1246         >>> list(Permutation.rmul(a, b))
1247         [1, 2, 0]
1248         >>> [a(b(i)) for i in range(3)]
1249         [1, 2, 0]
1250 
1251         This handles the operands in reverse order compared to the ``*`` operator:
1252 
1253         >>> a = Permutation(a); b = Permutation(b)
1254         >>> list(a*b)
1255         [2, 0, 1]
1256         >>> [b(a(i)) for i in range(3)]
1257         [2, 0, 1]
1258 
1259         Notes
1260         =====
1261 
1262         All items in the sequence will be parsed by Permutation as
1263         necessary as long as the first item is a Permutation:
1264 
1265         >>> Permutation.rmul(a, [0, 2, 1]) == Permutation.rmul(a, b)
1266         True
1267 
1268         The reverse order of arguments will raise a TypeError.
1269 
1270         """
1271         rv = args[0]
1272         for i in range(1, len(args)):
1273             rv = args[i]*rv
1274         return rv
1275 
1276     @classmethod
1277     def rmul_with_af(cls, *args):
1278         """
1279         same as rmul, but the elements of args are Permutation objects
1280         which have _array_form
1281         """
1282         a = [x._array_form for x in args]
1283         rv = cls._af_new(_af_rmuln(*a))
1284         return rv
1285 
1286     def mul_inv(self, other):
1287         """
1288         other*~self, self and other have _array_form
1289         """
1290         a = _af_invert(self._array_form)
1291         b = other._array_form
1292         return self._af_new(_af_rmul(a, b))
1293 
1294     def __rmul__(self, other):
1295         """This is needed to coerce other to Permutation in rmul."""
1296         cls = type(self)
1297         return cls(other)*self
1298 
1299     def __mul__(self, other):
1300         """
1301         Return the product a*b as a Permutation; the ith value is b(a(i)).
1302 
1303         Examples
1304         ========
1305 
1306         >>> from sympy.combinatorics.permutations import _af_rmul, Permutation
1307 
1308         >>> a, b = [1, 0, 2], [0, 2, 1]
1309         >>> a = Permutation(a); b = Permutation(b)
1310         >>> list(a*b)
1311         [2, 0, 1]
1312         >>> [b(a(i)) for i in range(3)]
1313         [2, 0, 1]
1314 
1315         This handles operands in reverse order compared to _af_rmul and rmul:
1316 
1317         >>> al = list(a); bl = list(b)
1318         >>> _af_rmul(al, bl)
1319         [1, 2, 0]
1320         >>> [al[bl[i]] for i in range(3)]
1321         [1, 2, 0]
1322 
1323         It is acceptable for the arrays to have different lengths; the shorter
1324         one will be padded to match the longer one:
1325 
1326         >>> from sympy.interactive import init_printing
1327         >>> init_printing(perm_cyclic=False, pretty_print=False)
1328         >>> b*Permutation([1, 0])
1329         Permutation([1, 2, 0])
1330         >>> Permutation([1, 0])*b
1331         Permutation([2, 0, 1])
1332 
1333         It is also acceptable to allow coercion to handle conversion of a
1334         single list to the left of a Permutation:
1335 
1336         >>> [0, 1]*a # no change: 2-element identity
1337         Permutation([1, 0, 2])
1338         >>> [[0, 1]]*a # exchange first two elements
1339         Permutation([0, 1, 2])
1340 
1341         You cannot use more than 1 cycle notation in a product of cycles
1342         since coercion can only handle one argument to the left. To handle
1343         multiple cycles it is convenient to use Cycle instead of Permutation:
1344 
1345         >>> [[1, 2]]*[[2, 3]]*Permutation([]) # doctest: +SKIP
1346         >>> from sympy.combinatorics.permutations import Cycle
1347         >>> Cycle(1, 2)(2, 3)
1348         (1 3 2)
1349 
1350         """
1351         from sympy.combinatorics.perm_groups import PermutationGroup, Coset
1352         if isinstance(other, PermutationGroup):
1353             return Coset(self, other, dir='-')
1354         a = self.array_form
1355         # __rmul__ makes sure the other is a Permutation
1356         b = other.array_form
1357         if not b:
1358             perm = a
1359         else:
1360             b.extend(list(range(len(b), len(a))))
1361             perm = [b[i] for i in a] + b[len(a):]
1362         return self._af_new(perm)
1363 
1364     def commutes_with(self, other):
1365         """
1366         Checks if the elements are commuting.
1367 
1368         Examples
1369         ========
1370 
1371         >>> from sympy.combinatorics.permutations import Permutation
1372         >>> a = Permutation([1, 4, 3, 0, 2, 5])
1373         >>> b = Permutation([0, 1, 2, 3, 4, 5])
1374         >>> a.commutes_with(b)
1375         True
1376         >>> b = Permutation([2, 3, 5, 4, 1, 0])
1377         >>> a.commutes_with(b)
1378         False
1379         """
1380         a = self.array_form
1381         b = other.array_form
1382         return _af_commutes_with(a, b)
1383 
1384     def __pow__(self, n):
1385         """
1386         Routine for finding powers of a permutation.
1387 
1388         Examples
1389         ========
1390 
1391         >>> from sympy.combinatorics.permutations import Permutation
1392         >>> from sympy.interactive import init_printing
1393         >>> init_printing(perm_cyclic=False, pretty_print=False)
1394         >>> p = Permutation([2, 0, 3, 1])
1395         >>> p.order()
1396         4
1397         >>> p**4
1398         Permutation([0, 1, 2, 3])
1399         """
1400         if isinstance(n, Permutation):
1401             raise NotImplementedError(
1402                 'p**p is not defined; do you mean p^p (conjugate)?')
1403         n = int(n)
1404         return self._af_new(_af_pow(self.array_form, n))
1405 
1406     def __rxor__(self, i):
1407         """Return self(i) when ``i`` is an int.
1408 
1409         Examples
1410         ========
1411 
1412         >>> from sympy.combinatorics import Permutation
1413         >>> p = Permutation(1, 2, 9)
1414         >>> 2^p == p(2) == 9
1415         True
1416         """
1417         if int(i) == i:
1418             return self(i)
1419         else:
1420             raise NotImplementedError(
1421                 "i^p = p(i) when i is an integer, not %s." % i)
1422 
1423     def __xor__(self, h):
1424         """Return the conjugate permutation ``~h*self*h` `.
1425 
1426         Explanation
1427         ===========
1428 
1429         If ``a`` and ``b`` are conjugates, ``a = h*b*~h`` and
1430         ``b = ~h*a*h`` and both have the same cycle structure.
1431 
1432         Examples
1433         ========
1434 
1435         >>> from sympy.combinatorics.permutations import Permutation
1436         >>> p = Permutation(1, 2, 9)
1437         >>> q = Permutation(6, 9, 8)
1438         >>> p*q != q*p
1439         True
1440 
1441         Calculate and check properties of the conjugate:
1442 
1443         >>> c = p^q
1444         >>> c == ~q*p*q and p == q*c*~q
1445         True
1446 
1447         The expression q^p^r is equivalent to q^(p*r):
1448 
1449         >>> r = Permutation(9)(4, 6, 8)
1450         >>> q^p^r == q^(p*r)
1451         True
1452 
1453         If the term to the left of the conjugate operator, i, is an integer
1454         then this is interpreted as selecting the ith element from the
1455         permutation to the right:
1456 
1457         >>> all(i^p == p(i) for i in range(p.size))
1458         True
1459 
1460         Note that the * operator as higher precedence than the ^ operator:
1461 
1462         >>> q^r*p^r == q^(r*p)^r == Permutation(9)(1, 6, 4)
1463         True
1464 
1465         Notes
1466         =====
1467 
1468         In Python the precedence rule is p^q^r = (p^q)^r which differs
1469         in general from p^(q^r)
1470 
1471         >>> q^p^r
1472         (9)(1 4 8)
1473         >>> q^(p^r)
1474         (9)(1 8 6)
1475 
1476         For a given r and p, both of the following are conjugates of p:
1477         ~r*p*r and r*p*~r. But these are not necessarily the same:
1478 
1479         >>> ~r*p*r == r*p*~r
1480         True
1481 
1482         >>> p = Permutation(1, 2, 9)(5, 6)
1483         >>> ~r*p*r == r*p*~r
1484         False
1485 
1486         The conjugate ~r*p*r was chosen so that ``p^q^r`` would be equivalent
1487         to ``p^(q*r)`` rather than ``p^(r*q)``. To obtain r*p*~r, pass ~r to
1488         this method:
1489 
1490         >>> p^~r == r*p*~r
1491         True
1492         """
1493 
1494         if self.size != h.size:
1495             raise ValueError("The permutations must be of equal size.")
1496         a = [None]*self.size
1497         h = h._array_form
1498         p = self._array_form
1499         for i in range(self.size):
1500             a[h[i]] = h[p[i]]
1501         return self._af_new(a)
1502 
1503     def transpositions(self):
1504         """
1505         Return the permutation decomposed into a list of transpositions.
1506 
1507         Explanation
1508         ===========
1509 
1510         It is always possible to express a permutation as the product of
1511         transpositions, see [1]
1512 
1513         Examples
1514         ========
1515 
1516         >>> from sympy.combinatorics.permutations import Permutation
1517         >>> p = Permutation([[1, 2, 3], [0, 4, 5, 6, 7]])
1518         >>> t = p.transpositions()
1519         >>> t
1520         [(0, 7), (0, 6), (0, 5), (0, 4), (1, 3), (1, 2)]
1521         >>> print(''.join(str(c) for c in t))
1522         (0, 7)(0, 6)(0, 5)(0, 4)(1, 3)(1, 2)
1523         >>> Permutation.rmul(*[Permutation([ti], size=p.size) for ti in t]) == p
1524         True
1525 
1526         References
1527         ==========
1528 
1529         .. [1] https://en.wikipedia.org/wiki/Transposition_%28mathematics%29#Properties
1530 
1531         """
1532         a = self.cyclic_form
1533         res = []
1534         for x in a:
1535             nx = len(x)
1536             if nx == 2:
1537                 res.append(tuple(x))
1538             elif nx > 2:
1539                 first = x[0]
1540                 for y in x[nx - 1:0:-1]:
1541                     res.append((first, y))
1542         return res
1543 
1544     @classmethod
1545     def from_sequence(self, i, key=None):
1546         """Return the permutation needed to obtain ``i`` from the sorted
1547         elements of ``i``. If custom sorting is desired, a key can be given.
1548 
1549         Examples
1550         ========
1551 
1552         >>> from sympy.combinatorics import Permutation
1553 
1554         >>> Permutation.from_sequence('SymPy')
1555         (4)(0 1 3)
1556         >>> _(sorted("SymPy"))
1557         ['S', 'y', 'm', 'P', 'y']
1558         >>> Permutation.from_sequence('SymPy', key=lambda x: x.lower())
1559         (4)(0 2)(1 3)
1560         """
1561         ic = list(zip(i, list(range(len(i)))))
1562         if key:
1563             ic.sort(key=lambda x: key(x[0]))
1564         else:
1565             ic.sort()
1566         return ~Permutation([i[1] for i in ic])
1567 
1568     def __invert__(self):
1569         """
1570         Return the inverse of the permutation.
1571 
1572         A permutation multiplied by its inverse is the identity permutation.
1573 
1574         Examples
1575         ========
1576 
1577         >>> from sympy.combinatorics.permutations import Permutation
1578         >>> from sympy.interactive import init_printing
1579         >>> init_printing(perm_cyclic=False, pretty_print=False)
1580         >>> p = Permutation([[2, 0], [3, 1]])
1581         >>> ~p
1582         Permutation([2, 3, 0, 1])
1583         >>> _ == p**-1
1584         True
1585         >>> p*~p == ~p*p == Permutation([0, 1, 2, 3])
1586         True
1587         """
1588         return self._af_new(_af_invert(self._array_form))
1589 
1590     def __iter__(self):
1591         """Yield elements from array form.
1592 
1593         Examples
1594         ========
1595 
1596         >>> from sympy.combinatorics import Permutation
1597         >>> list(Permutation(range(3)))
1598         [0, 1, 2]
1599         """
1600         yield from self.array_form
1601 
1602     def __repr__(self):
1603         from sympy.printing.repr import srepr
1604         return srepr(self)
1605 
1606     def __call__(self, *i):
1607         """
1608         Allows applying a permutation instance as a bijective function.
1609 
1610         Examples
1611         ========
1612 
1613         >>> from sympy.combinatorics.permutations import Permutation
1614         >>> p = Permutation([[2, 0], [3, 1]])
1615         >>> p.array_form
1616         [2, 3, 0, 1]
1617         >>> [p(i) for i in range(4)]
1618         [2, 3, 0, 1]
1619 
1620         If an array is given then the permutation selects the items
1621         from the array (i.e. the permutation is applied to the array):
1622 
1623         >>> from sympy.abc import x
1624         >>> p([x, 1, 0, x**2])
1625         [0, x**2, x, 1]
1626         """
1627         # list indices can be Integer or int; leave this
1628         # as it is (don't test or convert it) because this
1629         # gets called a lot and should be fast
1630         if len(i) == 1:
1631             i = i[0]
1632             if not isinstance(i, Iterable):
1633                 i = as_int(i)
1634                 if i < 0 or i > self.size:
1635                     raise TypeError(
1636                         "{} should be an integer between 0 and {}"
1637                         .format(i, self.size-1))
1638                 return self._array_form[i]
1639             # P([a, b, c])
1640             if len(i) != self.size:
1641                 raise TypeError(
1642                     "{} should have the length {}.".format(i, self.size))
1643             return [i[j] for j in self._array_form]
1644         # P(1, 2, 3)
1645         return self*Permutation(Cycle(*i), size=self.size)
1646 
1647     def atoms(self):
1648         """
1649         Returns all the elements of a permutation
1650 
1651         Examples
1652         ========
1653 
1654         >>> from sympy.combinatorics import Permutation
1655         >>> Permutation([0, 1, 2, 3, 4, 5]).atoms()
1656         {0, 1, 2, 3, 4, 5}
1657         >>> Permutation([[0, 1], [2, 3], [4, 5]]).atoms()
1658         {0, 1, 2, 3, 4, 5}
1659         """
1660         return set(self.array_form)
1661 
1662     def apply(self, i):
1663         r"""Apply the permutation to an expression.
1664 
1665         Parameters
1666         ==========
1667 
1668         i : Expr
1669             It should be an integer between $0$ and $n-1$ where $n$
1670             is the size of the permutation.
1671 
1672             If it is a symbol or a symbolic expression that can
1673             have integer values, an ``AppliedPermutation`` object
1674             will be returned which can represent an unevaluated
1675             function.
1676 
1677         Notes
1678         =====
1679 
1680         Any permutation can be defined as a bijective function
1681         $\sigma : \{ 0, 1, ..., n-1 \} \rightarrow \{ 0, 1, ..., n-1 \}$
1682         where $n$ denotes the size of the permutation.
1683 
1684         The definition may even be extended for any set with distinctive
1685         elements, such that the permutation can even be applied for
1686         real numbers or such, however, it is not implemented for now for
1687         computational reasons and the integrity with the group theory
1688         module.
1689 
1690         This function is similar to the ``__call__`` magic, however,
1691         ``__call__`` magic already has some other applications like
1692         permuting an array or attatching new cycles, which would
1693         not always be mathematically consistent.
1694 
1695         This also guarantees that the return type is a SymPy integer,
1696         which guarantees the safety to use assumptions.
1697         """
1698         i = _sympify(i)
1699         if i.is_integer is False:
1700             raise NotImplementedError("{} should be an integer.".format(i))
1701 
1702         n = self.size
1703         if (i < 0) == True or (i >= n) == True:
1704             raise NotImplementedError(
1705                 "{} should be an integer between 0 and {}".format(i, n-1))
1706 
1707         if i.is_Integer:
1708             return Integer(self._array_form[i])
1709         return AppliedPermutation(self, i)
1710 
1711     def next_lex(self):
1712         """
1713         Returns the next permutation in lexicographical order.
1714         If self is the last permutation in lexicographical order
1715         it returns None.
1716         See [4] section 2.4.
1717 
1718 
1719         Examples
1720         ========
1721 
1722         >>> from sympy.combinatorics.permutations import Permutation
1723         >>> p = Permutation([2, 3, 1, 0])
1724         >>> p = Permutation([2, 3, 1, 0]); p.rank()
1725         17
1726         >>> p = p.next_lex(); p.rank()
1727         18
1728 
1729         See Also
1730         ========
1731 
1732         rank, unrank_lex
1733         """
1734         perm = self.array_form[:]
1735         n = len(perm)
1736         i = n - 2
1737         while perm[i + 1] < perm[i]:
1738             i -= 1
1739         if i == -1:
1740             return None
1741         else:
1742             j = n - 1
1743             while perm[j] < perm[i]:
1744                 j -= 1
1745             perm[j], perm[i] = perm[i], perm[j]
1746             i += 1
1747             j = n - 1
1748             while i < j:
1749                 perm[j], perm[i] = perm[i], perm[j]
1750                 i += 1
1751                 j -= 1
1752         return self._af_new(perm)
1753 
1754     @classmethod
1755     def unrank_nonlex(self, n, r):
1756         """
1757         This is a linear time unranking algorithm that does not
1758         respect lexicographic order [3].
1759 
1760         Examples
1761         ========
1762 
1763         >>> from sympy.combinatorics.permutations import Permutation
1764         >>> from sympy.interactive import init_printing
1765         >>> init_printing(perm_cyclic=False, pretty_print=False)
1766         >>> Permutation.unrank_nonlex(4, 5)
1767         Permutation([2, 0, 3, 1])
1768         >>> Permutation.unrank_nonlex(4, -1)
1769         Permutation([0, 1, 2, 3])
1770 
1771         See Also
1772         ========
1773 
1774         next_nonlex, rank_nonlex
1775         """
1776         def _unrank1(n, r, a):
1777             if n > 0:
1778                 a[n - 1], a[r % n] = a[r % n], a[n - 1]
1779                 _unrank1(n - 1, r//n, a)
1780 
1781         id_perm = list(range(n))
1782         n = int(n)
1783         r = r % ifac(n)
1784         _unrank1(n, r, id_perm)
1785         return self._af_new(id_perm)
1786 
1787     def rank_nonlex(self, inv_perm=None):
1788         """
1789         This is a linear time ranking algorithm that does not
1790         enforce lexicographic order [3].
1791 
1792 
1793         Examples
1794         ========
1795 
1796         >>> from sympy.combinatorics.permutations import Permutation
1797         >>> p = Permutation([0, 1, 2, 3])
1798         >>> p.rank_nonlex()
1799         23
1800 
1801         See Also
1802         ========
1803 
1804         next_nonlex, unrank_nonlex
1805         """
1806         def _rank1(n, perm, inv_perm):
1807             if n == 1:
1808                 return 0
1809             s = perm[n - 1]
1810             t = inv_perm[n - 1]
1811             perm[n - 1], perm[t] = perm[t], s
1812             inv_perm[n - 1], inv_perm[s] = inv_perm[s], t
1813             return s + n*_rank1(n - 1, perm, inv_perm)
1814 
1815         if inv_perm is None:
1816             inv_perm = (~self).array_form
1817         if not inv_perm:
1818             return 0
1819         perm = self.array_form[:]
1820         r = _rank1(len(perm), perm, inv_perm)
1821         return r
1822 
1823     def next_nonlex(self):
1824         """
1825         Returns the next permutation in nonlex order [3].
1826         If self is the last permutation in this order it returns None.
1827 
1828         Examples
1829         ========
1830 
1831         >>> from sympy.combinatorics.permutations import Permutation
1832         >>> from sympy.interactive import init_printing
1833         >>> init_printing(perm_cyclic=False, pretty_print=False)
1834         >>> p = Permutation([2, 0, 3, 1]); p.rank_nonlex()
1835         5
1836         >>> p = p.next_nonlex(); p
1837         Permutation([3, 0, 1, 2])
1838         >>> p.rank_nonlex()
1839         6
1840 
1841         See Also
1842         ========
1843 
1844         rank_nonlex, unrank_nonlex
1845         """
1846         r = self.rank_nonlex()
1847         if r == ifac(self.size) - 1:
1848             return None
1849         return self.unrank_nonlex(self.size, r + 1)
1850 
1851     def rank(self):
1852         """
1853         Returns the lexicographic rank of the permutation.
1854 
1855         Examples
1856         ========
1857 
1858         >>> from sympy.combinatorics.permutations import Permutation
1859         >>> p = Permutation([0, 1, 2, 3])
1860         >>> p.rank()
1861         0
1862         >>> p = Permutation([3, 2, 1, 0])
1863         >>> p.rank()
1864         23
1865 
1866         See Also
1867         ========
1868 
1869         next_lex, unrank_lex, cardinality, length, order, size
1870         """
1871         if not self._rank is None:
1872             return self._rank
1873         rank = 0
1874         rho = self.array_form[:]
1875         n = self.size - 1
1876         size = n + 1
1877         psize = int(ifac(n))
1878         for j in range(size - 1):
1879             rank += rho[j]*psize
1880             for i in range(j + 1, size):
1881                 if rho[i] > rho[j]:
1882                     rho[i] -= 1
1883             psize //= n
1884             n -= 1
1885         self._rank = rank
1886         return rank
1887 
1888     @property
1889     def cardinality(self):
1890         """
1891         Returns the number of all possible permutations.
1892 
1893         Examples
1894         ========
1895 
1896         >>> from sympy.combinatorics.permutations import Permutation
1897         >>> p = Permutation([0, 1, 2, 3])
1898         >>> p.cardinality
1899         24
1900 
1901         See Also
1902         ========
1903 
1904         length, order, rank, size
1905         """
1906         return int(ifac(self.size))
1907 
1908     def parity(self):
1909         """
1910         Computes the parity of a permutation.
1911 
1912         Explanation
1913         ===========
1914 
1915         The parity of a permutation reflects the parity of the
1916         number of inversions in the permutation, i.e., the
1917         number of pairs of x and y such that ``x > y`` but ``p[x] < p[y]``.
1918 
1919         Examples
1920         ========
1921 
1922         >>> from sympy.combinatorics.permutations import Permutation
1923         >>> p = Permutation([0, 1, 2, 3])
1924         >>> p.parity()
1925         0
1926         >>> p = Permutation([3, 2, 0, 1])
1927         >>> p.parity()
1928         1
1929 
1930         See Also
1931         ========
1932 
1933         _af_parity
1934         """
1935         if self._cyclic_form is not None:
1936             return (self.size - self.cycles) % 2
1937 
1938         return _af_parity(self.array_form)
1939 
1940     @property
1941     def is_even(self):
1942         """
1943         Checks if a permutation is even.
1944 
1945         Examples
1946         ========
1947 
1948         >>> from sympy.combinatorics.permutations import Permutation
1949         >>> p = Permutation([0, 1, 2, 3])
1950         >>> p.is_even
1951         True
1952         >>> p = Permutation([3, 2, 1, 0])
1953         >>> p.is_even
1954         True
1955 
1956         See Also
1957         ========
1958 
1959         is_odd
1960         """
1961         return not self.is_odd
1962 
1963     @property
1964     def is_odd(self):
1965         """
1966         Checks if a permutation is odd.
1967 
1968         Examples
1969         ========
1970 
1971         >>> from sympy.combinatorics.permutations import Permutation
1972         >>> p = Permutation([0, 1, 2, 3])
1973         >>> p.is_odd
1974         False
1975         >>> p = Permutation([3, 2, 0, 1])
1976         >>> p.is_odd
1977         True
1978 
1979         See Also
1980         ========
1981 
1982         is_even
1983         """
1984         return bool(self.parity() % 2)
1985 
1986     @property
1987     def is_Singleton(self):
1988         """
1989         Checks to see if the permutation contains only one number and is
1990         thus the only possible permutation of this set of numbers
1991 
1992         Examples
1993         ========
1994 
1995         >>> from sympy.combinatorics import Permutation
1996         >>> Permutation([0]).is_Singleton
1997         True
1998         >>> Permutation([0, 1]).is_Singleton
1999         False
2000 
2001         See Also
2002         ========
2003 
2004         is_Empty
2005         """
2006         return self.size == 1
2007 
2008     @property
2009     def is_Empty(self):
2010         """
2011         Checks to see if the permutation is a set with zero elements
2012 
2013         Examples
2014         ========
2015 
2016         >>> from sympy.combinatorics import Permutation
2017         >>> Permutation([]).is_Empty
2018         True
2019         >>> Permutation([0]).is_Empty
2020         False
2021 
2022         See Also
2023         ========
2024 
2025         is_Singleton
2026         """
2027         return self.size == 0
2028 
2029     @property
2030     def is_identity(self):
2031         return self.is_Identity
2032 
2033     @property
2034     def is_Identity(self):
2035         """
2036         Returns True if the Permutation is an identity permutation.
2037 
2038         Examples
2039         ========
2040 
2041         >>> from sympy.combinatorics.permutations import Permutation
2042         >>> p = Permutation([])
2043         >>> p.is_Identity
2044         True
2045         >>> p = Permutation([[0], [1], [2]])
2046         >>> p.is_Identity
2047         True
2048         >>> p = Permutation([0, 1, 2])
2049         >>> p.is_Identity
2050         True
2051         >>> p = Permutation([0, 2, 1])
2052         >>> p.is_Identity
2053         False
2054 
2055         See Also
2056         ========
2057 
2058         order
2059         """
2060         af = self.array_form
2061         return not af or all(i == af[i] for i in range(self.size))
2062 
2063     def ascents(self):
2064         """
2065         Returns the positions of ascents in a permutation, ie, the location
2066         where p[i] < p[i+1]
2067 
2068         Examples
2069         ========
2070 
2071         >>> from sympy.combinatorics.permutations import Permutation
2072         >>> p = Permutation([4, 0, 1, 3, 2])
2073         >>> p.ascents()
2074         [1, 2]
2075 
2076         See Also
2077         ========
2078 
2079         descents, inversions, min, max
2080         """
2081         a = self.array_form
2082         pos = [i for i in range(len(a) - 1) if a[i] < a[i + 1]]
2083         return pos
2084 
2085     def descents(self):
2086         """
2087         Returns the positions of descents in a permutation, ie, the location
2088         where p[i] > p[i+1]
2089 
2090         Examples
2091         ========
2092 
2093         >>> from sympy.combinatorics.permutations import Permutation
2094         >>> p = Permutation([4, 0, 1, 3, 2])
2095         >>> p.descents()
2096         [0, 3]
2097 
2098         See Also
2099         ========
2100 
2101         ascents, inversions, min, max
2102         """
2103         a = self.array_form
2104         pos = [i for i in range(len(a) - 1) if a[i] > a[i + 1]]
2105         return pos
2106 
2107     def max(self):
2108         """
2109         The maximum element moved by the permutation.
2110 
2111         Examples
2112         ========
2113 
2114         >>> from sympy.combinatorics.permutations import Permutation
2115         >>> p = Permutation([1, 0, 2, 3, 4])
2116         >>> p.max()
2117         1
2118 
2119         See Also
2120         ========
2121 
2122         min, descents, ascents, inversions
2123         """
2124         max = 0
2125         a = self.array_form
2126         for i in range(len(a)):
2127             if a[i] != i and a[i] > max:
2128                 max = a[i]
2129         return max
2130 
2131     def min(self):
2132         """
2133         The minimum element moved by the permutation.
2134 
2135         Examples
2136         ========
2137 
2138         >>> from sympy.combinatorics.permutations import Permutation
2139         >>> p = Permutation([0, 1, 4, 3, 2])
2140         >>> p.min()
2141         2
2142 
2143         See Also
2144         ========
2145 
2146         max, descents, ascents, inversions
2147         """
2148         a = self.array_form
2149         min = len(a)
2150         for i in range(len(a)):
2151             if a[i] != i and a[i] < min:
2152                 min = a[i]
2153         return min
2154 
2155     def inversions(self):
2156         """
2157         Computes the number of inversions of a permutation.
2158 
2159         Explanation
2160         ===========
2161 
2162         An inversion is where i > j but p[i] < p[j].
2163 
2164         For small length of p, it iterates over all i and j
2165         values and calculates the number of inversions.
2166         For large length of p, it uses a variation of merge
2167         sort to calculate the number of inversions.
2168 
2169         Examples
2170         ========
2171 
2172         >>> from sympy.combinatorics.permutations import Permutation
2173         >>> p = Permutation([0, 1, 2, 3, 4, 5])
2174         >>> p.inversions()
2175         0
2176         >>> Permutation([3, 2, 1, 0]).inversions()
2177         6
2178 
2179         See Also
2180         ========
2181 
2182         descents, ascents, min, max
2183 
2184         References
2185         ==========
2186 
2187         .. [1] http://www.cp.eng.chula.ac.th/~piak/teaching/algo/algo2008/count-inv.htm
2188 
2189         """
2190         inversions = 0
2191         a = self.array_form
2192         n = len(a)
2193         if n < 130:
2194             for i in range(n - 1):
2195                 b = a[i]
2196                 for c in a[i + 1:]:
2197                     if b > c:
2198                         inversions += 1
2199         else:
2200             k = 1
2201             right = 0
2202             arr = a[:]
2203             temp = a[:]
2204             while k < n:
2205                 i = 0
2206                 while i + k < n:
2207                     right = i + k * 2 - 1
2208                     if right >= n:
2209                         right = n - 1
2210                     inversions += _merge(arr, temp, i, i + k, right)
2211                     i = i + k * 2
2212                 k = k * 2
2213         return inversions
2214 
2215     def commutator(self, x):
2216         """Return the commutator of ``self`` and ``x``: ``~x*~self*x*self``
2217 
2218         If f and g are part of a group, G, then the commutator of f and g
2219         is the group identity iff f and g commute, i.e. fg == gf.
2220 
2221         Examples
2222         ========
2223 
2224         >>> from sympy.combinatorics.permutations import Permutation
2225         >>> from sympy.interactive import init_printing
2226         >>> init_printing(perm_cyclic=False, pretty_print=False)
2227         >>> p = Permutation([0, 2, 3, 1])
2228         >>> x = Permutation([2, 0, 3, 1])
2229         >>> c = p.commutator(x); c
2230         Permutation([2, 1, 3, 0])
2231         >>> c == ~x*~p*x*p
2232         True
2233 
2234         >>> I = Permutation(3)
2235         >>> p = [I + i for i in range(6)]
2236         >>> for i in range(len(p)):
2237         ...     for j in range(len(p)):
2238         ...         c = p[i].commutator(p[j])
2239         ...         if p[i]*p[j] == p[j]*p[i]:
2240         ...             assert c == I
2241         ...         else:
2242         ...             assert c != I
2243         ...
2244 
2245         References
2246         ==========
2247 
2248         https://en.wikipedia.org/wiki/Commutator
2249         """
2250 
2251         a = self.array_form
2252         b = x.array_form
2253         n = len(a)
2254         if len(b) != n:
2255             raise ValueError("The permutations must be of equal size.")
2256         inva = [None]*n
2257         for i in range(n):
2258             inva[a[i]] = i
2259         invb = [None]*n
2260         for i in range(n):
2261             invb[b[i]] = i
2262         return self._af_new([a[b[inva[i]]] for i in invb])
2263 
2264     def signature(self):
2265         """
2266         Gives the signature of the permutation needed to place the
2267         elements of the permutation in canonical order.
2268 
2269         The signature is calculated as (-1)^<number of inversions>
2270 
2271         Examples
2272         ========
2273 
2274         >>> from sympy.combinatorics.permutations import Permutation
2275         >>> p = Permutation([0, 1, 2])
2276         >>> p.inversions()
2277         0
2278         >>> p.signature()
2279         1
2280         >>> q = Permutation([0,2,1])
2281         >>> q.inversions()
2282         1
2283         >>> q.signature()
2284         -1
2285 
2286         See Also
2287         ========
2288 
2289         inversions
2290         """
2291         if self.is_even:
2292             return 1
2293         return -1
2294 
2295     def order(self):
2296         """
2297         Computes the order of a permutation.
2298 
2299         When the permutation is raised to the power of its
2300         order it equals the identity permutation.
2301 
2302         Examples
2303         ========
2304 
2305         >>> from sympy.combinatorics.permutations import Permutation
2306         >>> from sympy.interactive import init_printing
2307         >>> init_printing(perm_cyclic=False, pretty_print=False)
2308         >>> p = Permutation([3, 1, 5, 2, 4, 0])
2309         >>> p.order()
2310         4
2311         >>> (p**(p.order()))
2312         Permutation([], size=6)
2313 
2314         See Also
2315         ========
2316 
2317         identity, cardinality, length, rank, size
2318         """
2319 
2320         return reduce(lcm, [len(cycle) for cycle in self.cyclic_form], 1)
2321 
2322     def length(self):
2323         """
2324         Returns the number of integers moved by a permutation.
2325 
2326         Examples
2327         ========
2328 
2329         >>> from sympy.combinatorics import Permutation
2330         >>> Permutation([0, 3, 2, 1]).length()
2331         2
2332         >>> Permutation([[0, 1], [2, 3]]).length()
2333         4
2334 
2335         See Also
2336         ========
2337 
2338         min, max, support, cardinality, order, rank, size
2339         """
2340 
2341         return len(self.support())
2342 
2343     @property
2344     def cycle_structure(self):
2345         """Return the cycle structure of the permutation as a dictionary
2346         indicating the multiplicity of each cycle length.
2347 
2348         Examples
2349         ========
2350 
2351         >>> from sympy.combinatorics import Permutation
2352         >>> Permutation(3).cycle_structure
2353         {1: 4}
2354         >>> Permutation(0, 4, 3)(1, 2)(5, 6).cycle_structure
2355         {2: 2, 3: 1}
2356         """
2357         if self._cycle_structure:
2358             rv = self._cycle_structure
2359         else:
2360             rv = defaultdict(int)
2361             singletons = self.size
2362             for c in self.cyclic_form:
2363                 rv[len(c)] += 1
2364                 singletons -= len(c)
2365             if singletons:
2366                 rv[1] = singletons
2367             self._cycle_structure = rv
2368         return dict(rv)  # make a copy
2369 
2370     @property
2371     def cycles(self):
2372         """
2373         Returns the number of cycles contained in the permutation
2374         (including singletons).
2375 
2376         Examples
2377         ========
2378 
2379         >>> from sympy.combinatorics import Permutation
2380         >>> Permutation([0, 1, 2]).cycles
2381         3
2382         >>> Permutation([0, 1, 2]).full_cyclic_form
2383         [[0], [1], [2]]
2384         >>> Permutation(0, 1)(2, 3).cycles
2385         2
2386 
2387         See Also
2388         ========
2389         sympy.functions.combinatorial.numbers.stirling
2390         """
2391         return len(self.full_cyclic_form)
2392 
2393     def index(self):
2394         """
2395         Returns the index of a permutation.
2396 
2397         The index of a permutation is the sum of all subscripts j such
2398         that p[j] is greater than p[j+1].
2399 
2400         Examples
2401         ========
2402 
2403         >>> from sympy.combinatorics.permutations import Permutation
2404         >>> p = Permutation([3, 0, 2, 1, 4])
2405         >>> p.index()
2406         2
2407         """
2408         a = self.array_form
2409 
2410         return sum([j for j in range(len(a) - 1) if a[j] > a[j + 1]])
2411 
2412     def runs(self):
2413         """
2414         Returns the runs of a permutation.
2415 
2416         An ascending sequence in a permutation is called a run [5].
2417 
2418 
2419         Examples
2420         ========
2421 
2422         >>> from sympy.combinatorics.permutations import Permutation
2423         >>> p = Permutation([2, 5, 7, 3, 6, 0, 1, 4, 8])
2424         >>> p.runs()
2425         [[2, 5, 7], [3, 6], [0, 1, 4, 8]]
2426         >>> q = Permutation([1,3,2,0])
2427         >>> q.runs()
2428         [[1, 3], [2], [0]]
2429         """
2430         return runs(self.array_form)
2431 
2432     def inversion_vector(self):
2433         """Return the inversion vector of the permutation.
2434 
2435         The inversion vector consists of elements whose value
2436         indicates the number of elements in the permutation
2437         that are lesser than it and lie on its right hand side.
2438 
2439         The inversion vector is the same as the Lehmer encoding of a
2440         permutation.
2441 
2442         Examples
2443         ========
2444 
2445         >>> from sympy.combinatorics.permutations import Permutation
2446         >>> p = Permutation([4, 8, 0, 7, 1, 5, 3, 6, 2])
2447         >>> p.inversion_vector()
2448         [4, 7, 0, 5, 0, 2, 1, 1]
2449         >>> p = Permutation([3, 2, 1, 0])
2450         >>> p.inversion_vector()
2451         [3, 2, 1]
2452 
2453         The inversion vector increases lexicographically with the rank
2454         of the permutation, the -ith element cycling through 0..i.
2455 
2456         >>> p = Permutation(2)
2457         >>> while p:
2458         ...     print('%s %s %s' % (p, p.inversion_vector(), p.rank()))
2459         ...     p = p.next_lex()
2460         (2) [0, 0] 0
2461         (1 2) [0, 1] 1
2462         (2)(0 1) [1, 0] 2
2463         (0 1 2) [1, 1] 3
2464         (0 2 1) [2, 0] 4
2465         (0 2) [2, 1] 5
2466 
2467         See Also
2468         ========
2469 
2470         from_inversion_vector
2471         """
2472         self_array_form = self.array_form
2473         n = len(self_array_form)
2474         inversion_vector = [0] * (n - 1)
2475 
2476         for i in range(n - 1):
2477             val = 0
2478             for j in range(i + 1, n):
2479                 if self_array_form[j] < self_array_form[i]:
2480                     val += 1
2481             inversion_vector[i] = val
2482         return inversion_vector
2483 
2484     def rank_trotterjohnson(self):
2485         """
2486         Returns the Trotter Johnson rank, which we get from the minimal
2487         change algorithm. See [4] section 2.4.
2488 
2489         Examples
2490         ========
2491 
2492         >>> from sympy.combinatorics.permutations import Permutation
2493         >>> p = Permutation([0, 1, 2, 3])
2494         >>> p.rank_trotterjohnson()
2495         0
2496         >>> p = Permutation([0, 2, 1, 3])
2497         >>> p.rank_trotterjohnson()
2498         7
2499 
2500         See Also
2501         ========
2502 
2503         unrank_trotterjohnson, next_trotterjohnson
2504         """
2505         if self.array_form == [] or self.is_Identity:
2506             return 0
2507         if self.array_form == [1, 0]:
2508             return 1
2509         perm = self.array_form
2510         n = self.size
2511         rank = 0
2512         for j in range(1, n):
2513             k = 1
2514             i = 0
2515             while perm[i] != j:
2516                 if perm[i] < j:
2517                     k += 1
2518                 i += 1
2519             j1 = j + 1
2520             if rank % 2 == 0:
2521                 rank = j1*rank + j1 - k
2522             else:
2523                 rank = j1*rank + k - 1
2524         return rank
2525 
2526     @classmethod
2527     def unrank_trotterjohnson(cls, size, rank):
2528         """
2529         Trotter Johnson permutation unranking. See [4] section 2.4.
2530 
2531         Examples
2532         ========
2533 
2534         >>> from sympy.combinatorics.permutations import Permutation
2535         >>> from sympy.interactive import init_printing
2536         >>> init_printing(perm_cyclic=False, pretty_print=False)
2537         >>> Permutation.unrank_trotterjohnson(5, 10)
2538         Permutation([0, 3, 1, 2, 4])
2539 
2540         See Also
2541         ========
2542 
2543         rank_trotterjohnson, next_trotterjohnson
2544         """
2545         perm = [0]*size
2546         r2 = 0
2547         n = ifac(size)
2548         pj = 1
2549         for j in range(2, size + 1):
2550             pj *= j
2551             r1 = (rank * pj) // n
2552             k = r1 - j*r2
2553             if r2 % 2 == 0:
2554                 for i in range(j - 1, j - k - 1, -1):
2555                     perm[i] = perm[i - 1]
2556                 perm[j - k - 1] = j - 1
2557             else:
2558                 for i in range(j - 1, k, -1):
2559                     perm[i] = perm[i - 1]
2560                 perm[k] = j - 1
2561             r2 = r1
2562         return cls._af_new(perm)
2563 
2564     def next_trotterjohnson(self):
2565         """
2566         Returns the next permutation in Trotter-Johnson order.
2567         If self is the last permutation it returns None.
2568         See [4] section 2.4. If it is desired to generate all such
2569         permutations, they can be generated in order more quickly
2570         with the ``generate_bell`` function.
2571 
2572         Examples
2573         ========
2574 
2575         >>> from sympy.combinatorics.permutations import Permutation
2576         >>> from sympy.interactive import init_printing
2577         >>> init_printing(perm_cyclic=False, pretty_print=False)
2578         >>> p = Permutation([3, 0, 2, 1])
2579         >>> p.rank_trotterjohnson()
2580         4
2581         >>> p = p.next_trotterjohnson(); p
2582         Permutation([0, 3, 2, 1])
2583         >>> p.rank_trotterjohnson()
2584         5
2585 
2586         See Also
2587         ========
2588 
2589         rank_trotterjohnson, unrank_trotterjohnson, sympy.utilities.iterables.generate_bell
2590         """
2591         pi = self.array_form[:]
2592         n = len(pi)
2593         st = 0
2594         rho = pi[:]
2595         done = False
2596         m = n-1
2597         while m > 0 and not done:
2598             d = rho.index(m)
2599             for i in range(d, m):
2600                 rho[i] = rho[i + 1]
2601             par = _af_parity(rho[:m])
2602             if par == 1:
2603                 if d == m:
2604                     m -= 1
2605                 else:
2606                     pi[st + d], pi[st + d + 1] = pi[st + d + 1], pi[st + d]
2607                     done = True
2608             else:
2609                 if d == 0:
2610                     m -= 1
2611                     st += 1
2612                 else:
2613                     pi[st + d], pi[st + d - 1] = pi[st + d - 1], pi[st + d]
2614                     done = True
2615         if m == 0:
2616             return None
2617         return self._af_new(pi)
2618 
2619     def get_precedence_matrix(self):
2620         """
2621         Gets the precedence matrix. This is used for computing the
2622         distance between two permutations.
2623 
2624         Examples
2625         ========
2626 
2627         >>> from sympy.combinatorics.permutations import Permutation
2628         >>> from sympy.interactive import init_printing
2629         >>> init_printing(perm_cyclic=False, pretty_print=False)
2630         >>> p = Permutation.josephus(3, 6, 1)
2631         >>> p
2632         Permutation([2, 5, 3, 1, 4, 0])
2633         >>> p.get_precedence_matrix()
2634         Matrix([
2635         [0, 0, 0, 0, 0, 0],
2636         [1, 0, 0, 0, 1, 0],
2637         [1, 1, 0, 1, 1, 1],
2638         [1, 1, 0, 0, 1, 0],
2639         [1, 0, 0, 0, 0, 0],
2640         [1, 1, 0, 1, 1, 0]])
2641 
2642         See Also
2643         ========
2644 
2645         get_precedence_distance, get_adjacency_matrix, get_adjacency_distance
2646         """
2647         m = zeros(self.size)
2648         perm = self.array_form
2649         for i in range(m.rows):
2650             for j in range(i + 1, m.cols):
2651                 m[perm[i], perm[j]] = 1
2652         return m
2653 
2654     def get_precedence_distance(self, other):
2655         """
2656         Computes the precedence distance between two permutations.
2657 
2658         Explanation
2659         ===========
2660 
2661         Suppose p and p' represent n jobs. The precedence metric
2662         counts the number of times a job j is preceded by job i
2663         in both p and p'. This metric is commutative.
2664 
2665         Examples
2666         ========
2667 
2668         >>> from sympy.combinatorics.permutations import Permutation
2669         >>> p = Permutation([2, 0, 4, 3, 1])
2670         >>> q = Permutation([3, 1, 2, 4, 0])
2671         >>> p.get_precedence_distance(q)
2672         7
2673         >>> q.get_precedence_distance(p)
2674         7
2675 
2676         See Also
2677         ========
2678 
2679         get_precedence_matrix, get_adjacency_matrix, get_adjacency_distance
2680         """
2681         if self.size != other.size:
2682             raise ValueError("The permutations must be of equal size.")
2683         self_prec_mat = self.get_precedence_matrix()
2684         other_prec_mat = other.get_precedence_matrix()
2685         n_prec = 0
2686         for i in range(self.size):
2687             for j in range(self.size):
2688                 if i == j:
2689                     continue
2690                 if self_prec_mat[i, j] * other_prec_mat[i, j] == 1:
2691                     n_prec += 1
2692         d = self.size * (self.size - 1)//2 - n_prec
2693         return d
2694 
2695     def get_adjacency_matrix(self):
2696         """
2697         Computes the adjacency matrix of a permutation.
2698 
2699         Explanation
2700         ===========
2701 
2702         If job i is adjacent to job j in a permutation p
2703         then we set m[i, j] = 1 where m is the adjacency
2704         matrix of p.
2705 
2706         Examples
2707         ========
2708 
2709         >>> from sympy.combinatorics.permutations import Permutation
2710         >>> p = Permutation.josephus(3, 6, 1)
2711         >>> p.get_adjacency_matrix()
2712         Matrix([
2713         [0, 0, 0, 0, 0, 0],
2714         [0, 0, 0, 0, 1, 0],
2715         [0, 0, 0, 0, 0, 1],
2716         [0, 1, 0, 0, 0, 0],
2717         [1, 0, 0, 0, 0, 0],
2718         [0, 0, 0, 1, 0, 0]])
2719         >>> q = Permutation([0, 1, 2, 3])
2720         >>> q.get_adjacency_matrix()
2721         Matrix([
2722         [0, 1, 0, 0],
2723         [0, 0, 1, 0],
2724         [0, 0, 0, 1],
2725         [0, 0, 0, 0]])
2726 
2727         See Also
2728         ========
2729 
2730         get_precedence_matrix, get_precedence_distance, get_adjacency_distance
2731         """
2732         m = zeros(self.size)
2733         perm = self.array_form
2734         for i in range(self.size - 1):
2735             m[perm[i], perm[i + 1]] = 1
2736         return m
2737 
2738     def get_adjacency_distance(self, other):
2739         """
2740         Computes the adjacency distance between two permutations.
2741 
2742         Explanation
2743         ===========
2744 
2745         This metric counts the number of times a pair i,j of jobs is
2746         adjacent in both p and p'. If n_adj is this quantity then
2747         the adjacency distance is n - n_adj - 1 [1]
2748 
2749         [1] Reeves, Colin R. Landscapes, Operators and Heuristic search, Annals
2750         of Operational Research, 86, pp 473-490. (1999)
2751 
2752 
2753         Examples
2754         ========
2755 
2756         >>> from sympy.combinatorics.permutations import Permutation
2757         >>> p = Permutation([0, 3, 1, 2, 4])
2758         >>> q = Permutation.josephus(4, 5, 2)
2759         >>> p.get_adjacency_distance(q)
2760         3
2761         >>> r = Permutation([0, 2, 1, 4, 3])
2762         >>> p.get_adjacency_distance(r)
2763         4
2764 
2765         See Also
2766         ========
2767 
2768         get_precedence_matrix, get_precedence_distance, get_adjacency_matrix
2769         """
2770         if self.size != other.size:
2771             raise ValueError("The permutations must be of the same size.")
2772         self_adj_mat = self.get_adjacency_matrix()
2773         other_adj_mat = other.get_adjacency_matrix()
2774         n_adj = 0
2775         for i in range(self.size):
2776             for j in range(self.size):
2777                 if i == j:
2778                     continue
2779                 if self_adj_mat[i, j] * other_adj_mat[i, j] == 1:
2780                     n_adj += 1
2781         d = self.size - n_adj - 1
2782         return d
2783 
2784     def get_positional_distance(self, other):
2785         """
2786         Computes the positional distance between two permutations.
2787 
2788         Examples
2789         ========
2790 
2791         >>> from sympy.combinatorics.permutations import Permutation
2792         >>> p = Permutation([0, 3, 1, 2, 4])
2793         >>> q = Permutation.josephus(4, 5, 2)
2794         >>> r = Permutation([3, 1, 4, 0, 2])
2795         >>> p.get_positional_distance(q)
2796         12
2797         >>> p.get_positional_distance(r)
2798         12
2799 
2800         See Also
2801         ========
2802 
2803         get_precedence_distance, get_adjacency_distance
2804         """
2805         a = self.array_form
2806         b = other.array_form
2807         if len(a) != len(b):
2808             raise ValueError("The permutations must be of the same size.")
2809         return sum([abs(a[i] - b[i]) for i in range(len(a))])
2810 
2811     @classmethod
2812     def josephus(cls, m, n, s=1):
2813         """Return as a permutation the shuffling of range(n) using the Josephus
2814         scheme in which every m-th item is selected until all have been chosen.
2815         The returned permutation has elements listed by the order in which they
2816         were selected.
2817 
2818         The parameter ``s`` stops the selection process when there are ``s``
2819         items remaining and these are selected by continuing the selection,
2820         counting by 1 rather than by ``m``.
2821 
2822         Consider selecting every 3rd item from 6 until only 2 remain::
2823 
2824             choices    chosen
2825             ========   ======
2826               012345
2827               01 345   2
2828               01 34    25
2829               01  4    253
2830               0   4    2531
2831               0        25314
2832                        253140
2833 
2834         Examples
2835         ========
2836 
2837         >>> from sympy.combinatorics import Permutation
2838         >>> Permutation.josephus(3, 6, 2).array_form
2839         [2, 5, 3, 1, 4, 0]
2840 
2841         References
2842         ==========
2843 
2844         .. [1] https://en.wikipedia.org/wiki/Flavius_Josephus
2845         .. [2] https://en.wikipedia.org/wiki/Josephus_problem
2846         .. [3] http://www.wou.edu/~burtonl/josephus.html
2847 
2848         """
2849         from collections import deque
2850         m -= 1
2851         Q = deque(list(range(n)))
2852         perm = []
2853         while len(Q) > max(s, 1):
2854             for dp in range(m):
2855                 Q.append(Q.popleft())
2856             perm.append(Q.popleft())
2857         perm.extend(list(Q))
2858         return cls(perm)
2859 
2860     @classmethod
2861     def from_inversion_vector(cls, inversion):
2862         """
2863         Calculates the permutation from the inversion vector.
2864 
2865         Examples
2866         ========
2867 
2868         >>> from sympy.combinatorics.permutations import Permutation
2869         >>> from sympy.interactive import init_printing
2870         >>> init_printing(perm_cyclic=False, pretty_print=False)
2871         >>> Permutation.from_inversion_vector([3, 2, 1, 0, 0])
2872         Permutation([3, 2, 1, 0, 4, 5])
2873 
2874         """
2875         size = len(inversion)
2876         N = list(range(size + 1))
2877         perm = []
2878         try:
2879             for k in range(size):
2880                 val = N[inversion[k]]
2881                 perm.append(val)
2882                 N.remove(val)
2883         except IndexError:
2884             raise ValueError("The inversion vector is not valid.")
2885         perm.extend(N)
2886         return cls._af_new(perm)
2887 
2888     @classmethod
2889     def random(cls, n):
2890         """
2891         Generates a random permutation of length ``n``.
2892 
2893         Uses the underlying Python pseudo-random number generator.
2894 
2895         Examples
2896         ========
2897 
2898         >>> from sympy.combinatorics.permutations import Permutation
2899         >>> Permutation.random(2) in (Permutation([1, 0]), Permutation([0, 1]))
2900         True
2901 
2902         """
2903         perm_array = list(range(n))
2904         random.shuffle(perm_array)
2905         return cls._af_new(perm_array)
2906 
2907     @classmethod
2908     def unrank_lex(cls, size, rank):
2909         """
2910         Lexicographic permutation unranking.
2911 
2912         Examples
2913         ========
2914 
2915         >>> from sympy.combinatorics.permutations import Permutation
2916         >>> from sympy.interactive import init_printing
2917         >>> init_printing(perm_cyclic=False, pretty_print=False)
2918         >>> a = Permutation.unrank_lex(5, 10)
2919         >>> a.rank()
2920         10
2921         >>> a
2922         Permutation([0, 2, 4, 1, 3])
2923 
2924         See Also
2925         ========
2926 
2927         rank, next_lex
2928         """
2929         perm_array = [0] * size
2930         psize = 1
2931         for i in range(size):
2932             new_psize = psize*(i + 1)
2933             d = (rank % new_psize) // psize
2934             rank -= d*psize
2935             perm_array[size - i - 1] = d
2936             for j in range(size - i, size):
2937                 if perm_array[j] > d - 1:
2938                     perm_array[j] += 1
2939             psize = new_psize
2940         return cls._af_new(perm_array)
2941 
2942     def resize(self, n):
2943         """Resize the permutation to the new size ``n``.
2944 
2945         Parameters
2946         ==========
2947 
2948         n : int
2949             The new size of the permutation.
2950 
2951         Raises
2952         ======
2953 
2954         ValueError
2955             If the permutation cannot be resized to the given size.
2956             This may only happen when resized to a smaller size than
2957             the original.
2958 
2959         Examples
2960         ========
2961 
2962         >>> from sympy.combinatorics.permutations import Permutation
2963 
2964         Increasing the size of a permutation:
2965 
2966         >>> p = Permutation(0, 1, 2)
2967         >>> p = p.resize(5)
2968         >>> p
2969         (4)(0 1 2)
2970 
2971         Decreasing the size of the permutation:
2972 
2973         >>> p = p.resize(4)
2974         >>> p
2975         (3)(0 1 2)
2976 
2977         If resizing to the specific size breaks the cycles:
2978 
2979         >>> p.resize(2)
2980         Traceback (most recent call last):
2981         ...
2982         ValueError: The permutation can not be resized to 2 because the
2983         cycle (0, 1, 2) may break.
2984         """
2985         aform = self.array_form
2986         l = len(aform)
2987         if n > l:
2988             aform += list(range(l, n))
2989             return Permutation._af_new(aform)
2990 
2991         elif n < l:
2992             cyclic_form = self.full_cyclic_form
2993             new_cyclic_form = []
2994             for cycle in cyclic_form:
2995                 cycle_min = min(cycle)
2996                 cycle_max = max(cycle)
2997                 if cycle_min <= n-1:
2998                     if cycle_max > n-1:
2999                         raise ValueError(
3000                             "The permutation can not be resized to {} "
3001                             "because the cycle {} may break."
3002                             .format(n, tuple(cycle)))
3003 
3004                     new_cyclic_form.append(cycle)
3005             return Permutation(new_cyclic_form)
3006 
3007         return self
3008 
3009     # XXX Deprecated flag
3010     print_cyclic = None

</code><intended_behavior>The `__repr__` method might need modifications, and a `__str__` method could be added or modified to make the string representation of `Permutation` instances more user-friendly and less verbose, clearly conveying the permutation in a concise and understandable way.</intended_behavior>]
2025-10-18 09:28:53.219 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-18 09:28:53.220 | INFO     | Search-only: skipping patch selection
2025-10-18 09:28:53.320 | INFO     | Task sympy__sympy-21931 completed successfully.
2025-10-18 09:28:53.321 | INFO     | No patch generated. You can try running ACR again.
