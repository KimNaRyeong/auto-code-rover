2025-10-18 06:25:15.673 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-18 06:25:18.829 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=382, output_tokens=12, cost=0.004180
2025-10-18 06:25:38.369 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=562, output_tokens=862, cost=0.031480
2025-10-18 06:25:39.576 | INFO     | registered non reproducing test 0
2025-10-18 06:25:57.115 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2444, output_tokens=835, cost=0.049490
2025-10-18 06:25:58.309 | INFO     | registered non reproducing test 1
2025-10-18 06:26:16.650 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2367, output_tokens=890, cost=0.050370
2025-10-18 06:26:17.840 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 06:26:29.121 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=684, output_tokens=529, cost=0.022710
2025-10-18 06:26:29.130 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 06:26:33.560 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=882, output_tokens=122, cost=0.012480
2025-10-18 06:26:33.562 | DEBUG    | Extracted a valid json.
2025-10-18 06:26:33.562 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_method(\"TocTree\")",
        "search_code(\".. toctree::\")",
        "search_method(\"config\")",
        "search_code(\"extension\")"
    ],
    "bug_locations": [
        {
            "file": "",
            "class": "",
            "method": "",
            "intended_behavior": "Sphinx should correctly handle files with the same base name but different extensions, particularly favoring the intended extension (like `.md` over `.rst`) when specified or inferred through configuration or directive handling."
        }
    ]
}
2025-10-18 06:26:33.688 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 06:26:33.688 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 06:26:50.329 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2189, output_tokens=704, cost=0.043010
2025-10-18 06:26:50.336 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 06:26:58.630 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3109, output_tokens=330, cost=0.040990
2025-10-18 06:26:58.637 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 06:27:05.870 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=684, output_tokens=273, cost=0.015030
2025-10-18 06:27:05.871 | DEBUG    | Extracted a valid json.
2025-10-18 06:27:05.871 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations":[
        {
            "file": "sphinx/application.py",
            "class": "",
            "method": "",
            "intended_behavior": "The application layer, which initializes and configures extensions, should include logic to prioritize file extensions when multiple sources with the same name but different extensions exist. This could be implemented either by enhancing existing methods or introducing a new method to filter and sort files based on a configurable priority list before including them in the build process. This priority list could be configured through the existing Sphinx configuration mechanisms, allowing users to specify their preference for `.md` over `.rst` or vice versa. It's essential that this change does not disrupt the current functionality for projects not requiring this feature."
        },
        {
            "file": "sphinx/config.py",
            "class": "",
            "method": "",
            "intended_behavior": "This file is responsible for handling Sphinx configuration. An update here should introduce a new configuration option, e.g., `file_extension_priority`, which allows users to specify an ordered list of file extensions according to their priorities. This new configuration option should be documented and have default behavior that preserves the current functionality (e.g., an empty list or a list favoring Sphinx's default file extension handling), ensuring backward compatibility."
        }
    ]
}
2025-10-18 06:27:05.878 | DEBUG    | Bug location extracted successfully: [<file>sphinx/application.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2     sphinx.application
3     ~~~~~~~~~~~~~~~~~~
4 
5     Sphinx application class and extensibility interface.
6 
7     Gracefully adapted from the TextPress system by Armin.
8 
9     :copyright: Copyright 2007-2020 by the Sphinx team, see AUTHORS.
10     :license: BSD, see LICENSE for details.
11 """
12 
13 import os
14 import pickle
15 import platform
16 import sys
17 import warnings
18 from collections import deque
19 from io import StringIO
20 from os import path
21 from typing import Any, Callable, Dict, IO, List, Tuple, Union
22 
23 from docutils import nodes
24 from docutils.nodes import Element, TextElement
25 from docutils.parsers.rst import Directive, roles
26 from docutils.transforms import Transform
27 from pygments.lexer import Lexer
28 
29 import sphinx
30 from sphinx import package_dir, locale
31 from sphinx.config import Config
32 from sphinx.deprecation import RemovedInSphinx40Warning
33 from sphinx.domains import Domain, Index
34 from sphinx.environment import BuildEnvironment
35 from sphinx.environment.collectors import EnvironmentCollector
36 from sphinx.errors import ApplicationError, ConfigError, VersionRequirementError
37 from sphinx.events import EventManager
38 from sphinx.extension import Extension
39 from sphinx.highlighting import lexer_classes, lexers
40 from sphinx.locale import __
41 from sphinx.project import Project
42 from sphinx.registry import SphinxComponentRegistry
43 from sphinx.roles import XRefRole
44 from sphinx.theming import Theme
45 from sphinx.util import docutils
46 from sphinx.util import logging
47 from sphinx.util import progress_message
48 from sphinx.util.build_phase import BuildPhase
49 from sphinx.util.console import bold  # type: ignore
50 from sphinx.util.i18n import CatalogRepository
51 from sphinx.util.logging import prefixed_warnings
52 from sphinx.util.osutil import abspath, ensuredir, relpath
53 from sphinx.util.tags import Tags
54 from sphinx.util.typing import RoleFunction, TitleGetter
55 
56 if False:
57     # For type annotation
58     from docutils.nodes import Node  # NOQA
59     from typing import Type  # for python3.5.1
60     from sphinx.builders import Builder
61 
62 
63 builtin_extensions = (
64     'sphinx.addnodes',
65     'sphinx.builders.changes',
66     'sphinx.builders.epub3',
67     'sphinx.builders.dirhtml',
68     'sphinx.builders.dummy',
69     'sphinx.builders.gettext',
70     'sphinx.builders.html',
71     'sphinx.builders.latex',
72     'sphinx.builders.linkcheck',
73     'sphinx.builders.manpage',
74     'sphinx.builders.singlehtml',
75     'sphinx.builders.texinfo',
76     'sphinx.builders.text',
77     'sphinx.builders.xml',
78     'sphinx.config',
79     'sphinx.domains.c',
80     'sphinx.domains.changeset',
81     'sphinx.domains.citation',
82     'sphinx.domains.cpp',
83     'sphinx.domains.index',
84     'sphinx.domains.javascript',
85     'sphinx.domains.math',
86     'sphinx.domains.python',
87     'sphinx.domains.rst',
88     'sphinx.domains.std',
89     'sphinx.directives',
90     'sphinx.directives.code',
91     'sphinx.directives.other',
92     'sphinx.directives.patches',
93     'sphinx.extension',
94     'sphinx.parsers',
95     'sphinx.registry',
96     'sphinx.roles',
97     'sphinx.transforms',
98     'sphinx.transforms.compact_bullet_list',
99     'sphinx.transforms.i18n',
100     'sphinx.transforms.references',
101     'sphinx.transforms.post_transforms',
102     'sphinx.transforms.post_transforms.code',
103     'sphinx.transforms.post_transforms.images',
104     'sphinx.util.compat',
105     'sphinx.versioning',
106     # collectors should be loaded by specific order
107     'sphinx.environment.collectors.dependencies',
108     'sphinx.environment.collectors.asset',
109     'sphinx.environment.collectors.metadata',
110     'sphinx.environment.collectors.title',
111     'sphinx.environment.collectors.toctree',
112     # 1st party extensions
113     'sphinxcontrib.applehelp',
114     'sphinxcontrib.devhelp',
115     'sphinxcontrib.htmlhelp',
116     'sphinxcontrib.serializinghtml',
117     'sphinxcontrib.qthelp',
118     # Strictly, alabaster theme is not a builtin extension,
119     # but it is loaded automatically to use it as default theme.
120     'alabaster',
121 )
122 
123 ENV_PICKLE_FILENAME = 'environment.pickle'
124 
125 logger = logging.getLogger(__name__)
126 
127 
128 class Sphinx:
129     """The main application class and extensibility interface.
130 
131     :ivar srcdir: Directory containing source.
132     :ivar confdir: Directory containing ``conf.py``.
133     :ivar doctreedir: Directory for storing pickled doctrees.
134     :ivar outdir: Directory for storing build documents.
135     """
136 
137     def __init__(self, srcdir: str, confdir: str, outdir: str, doctreedir: str,
138                  buildername: str, confoverrides: Dict = None,
139                  status: IO = sys.stdout, warning: IO = sys.stderr,
140                  freshenv: bool = False, warningiserror: bool = False, tags: List[str] = None,
141                  verbosity: int = 0, parallel: int = 0, keep_going: bool = False) -> None:
142         self.phase = BuildPhase.INITIALIZATION
143         self.verbosity = verbosity
144         self.extensions = {}                    # type: Dict[str, Extension]
145         self.builder = None                     # type: Builder
146         self.env = None                         # type: BuildEnvironment
147         self.project = None                     # type: Project
148         self.registry = SphinxComponentRegistry()
149         self.html_themes = {}                   # type: Dict[str, str]
150 
151         # validate provided directories
152         self.srcdir = abspath(srcdir)
153         self.outdir = abspath(outdir)
154         self.doctreedir = abspath(doctreedir)
155         self.confdir = confdir
156         if self.confdir:  # confdir is optional
157             self.confdir = abspath(self.confdir)
158             if not path.isfile(path.join(self.confdir, 'conf.py')):
159                 raise ApplicationError(__("config directory doesn't contain a "
160                                           "conf.py file (%s)") % confdir)
161 
162         if not path.isdir(self.srcdir):
163             raise ApplicationError(__('Cannot find source directory (%s)') %
164                                    self.srcdir)
165 
166         if path.exists(self.outdir) and not path.isdir(self.outdir):
167             raise ApplicationError(__('Output directory (%s) is not a directory') %
168                                    self.srcdir)
169 
170         if self.srcdir == self.outdir:
171             raise ApplicationError(__('Source directory and destination '
172                                       'directory cannot be identical'))
173 
174         self.parallel = parallel
175 
176         if status is None:
177             self._status = StringIO()      # type: IO
178             self.quiet = True
179         else:
180             self._status = status
181             self.quiet = False
182 
183         if warning is None:
184             self._warning = StringIO()     # type: IO
185         else:
186             self._warning = warning
187         self._warncount = 0
188         self.keep_going = warningiserror and keep_going
189         if self.keep_going:
190             self.warningiserror = False
191         else:
192             self.warningiserror = warningiserror
193         logging.setup(self, self._status, self._warning)
194 
195         self.events = EventManager(self)
196 
197         # keep last few messages for traceback
198         # This will be filled by sphinx.util.logging.LastMessagesWriter
199         self.messagelog = deque(maxlen=10)  # type: deque
200 
201         # say hello to the world
202         logger.info(bold(__('Running Sphinx v%s') % sphinx.__display_version__))
203 
204         # notice for parallel build on macOS and py38+
205         if sys.version_info > (3, 8) and platform.system() == 'Darwin' and parallel > 1:
206             logger.info(bold(__("For security reason, parallel mode is disabled on macOS and "
207                                 "python3.8 and above.  For more details, please read "
208                                 "https://github.com/sphinx-doc/sphinx/issues/6803")))
209 
210         # status code for command-line application
211         self.statuscode = 0
212 
213         # read config
214         self.tags = Tags(tags)
215         if self.confdir is None:
216             self.config = Config({}, confoverrides or {})
217         else:
218             self.config = Config.read(self.confdir, confoverrides or {}, self.tags)
219 
220         # initialize some limited config variables before initialize i18n and loading
221         # extensions
222         self.config.pre_init_values()
223 
224         # set up translation infrastructure
225         self._init_i18n()
226 
227         # check the Sphinx version if requested
228         if self.config.needs_sphinx and self.config.needs_sphinx > sphinx.__display_version__:
229             raise VersionRequirementError(
230                 __('This project needs at least Sphinx v%s and therefore cannot '
231                    'be built with this version.') % self.config.needs_sphinx)
232 
233         # set confdir to srcdir if -C given (!= no confdir); a few pieces
234         # of code expect a confdir to be set
235         if self.confdir is None:
236             self.confdir = self.srcdir
237 
238         # load all built-in extension modules
239         for extension in builtin_extensions:
240             self.setup_extension(extension)
241 
242         # load all user-given extension modules
243         for extension in self.config.extensions:
244             self.setup_extension(extension)
245 
246         # preload builder module (before init config values)
247         self.preload_builder(buildername)
248 
249         if not path.isdir(outdir):
250             with progress_message(__('making output directory')):
251                 ensuredir(outdir)
252 
253         # the config file itself can be an extension
254         if self.config.setup:
255             prefix = __('while setting up extension %s:') % "conf.py"
256             with prefixed_warnings(prefix):
257                 if callable(self.config.setup):
258                     self.config.setup(self)
259                 else:
260                     raise ConfigError(
261                         __("'setup' as currently defined in conf.py isn't a Python callable. "
262                            "Please modify its definition to make it a callable function. "
263                            "This is needed for conf.py to behave as a Sphinx extension.")
264                     )
265 
266         # now that we know all config values, collect them from conf.py
267         self.config.init_values()
268         self.events.emit('config-inited', self.config)
269 
270         # create the project
271         self.project = Project(self.srcdir, self.config.source_suffix)
272         # create the builder
273         self.builder = self.create_builder(buildername)
274         # set up the build environment
275         self._init_env(freshenv)
276         # set up the builder
277         self._init_builder()
278 
279     def _init_i18n(self) -> None:
280         """Load translated strings from the configured localedirs if enabled in
281         the configuration.
282         """
283         if self.config.language is None:
284             self.translator, has_translation = locale.init([], None)
285         else:
286             logger.info(bold(__('loading translations [%s]... ') % self.config.language),
287                         nonl=True)
288 
289             # compile mo files if sphinx.po file in user locale directories are updated
290             repo = CatalogRepository(self.srcdir, self.config.locale_dirs,
291                                      self.config.language, self.config.source_encoding)
292             for catalog in repo.catalogs:
293                 if catalog.domain == 'sphinx' and catalog.is_outdated():
294                     catalog.write_mo(self.config.language)
295 
296             locale_dirs = [None, path.join(package_dir, 'locale')] + list(repo.locale_dirs)
297             self.translator, has_translation = locale.init(locale_dirs, self.config.language)
298             if has_translation or self.config.language == 'en':
299                 # "en" never needs to be translated
300                 logger.info(__('done'))
301             else:
302                 logger.info(__('not available for built-in messages'))
303 
304     def _init_env(self, freshenv: bool) -> None:
305         filename = path.join(self.doctreedir, ENV_PICKLE_FILENAME)
306         if freshenv or not os.path.exists(filename):
307             self.env = BuildEnvironment()
308             self.env.setup(self)
309             self.env.find_files(self.config, self.builder)
310         else:
311             try:
312                 with progress_message(__('loading pickled environment')):
313                     with open(filename, 'rb') as f:
314                         self.env = pickle.load(f)
315                         self.env.setup(self)
316             except Exception as err:
317                 logger.info(__('failed: %s'), err)
318                 self._init_env(freshenv=True)
319 
320     def preload_builder(self, name: str) -> None:
321         self.registry.preload_builder(self, name)
322 
323     def create_builder(self, name: str) -> "Builder":
324         if name is None:
325             logger.info(__('No builder selected, using default: html'))
326             name = 'html'
327 
328         return self.registry.create_builder(self, name)
329 
330     def _init_builder(self) -> None:
331         self.builder.set_environment(self.env)
332         self.builder.init()
333         self.events.emit('builder-inited')
334 
335     # ---- main "build" method -------------------------------------------------
336 
337     def build(self, force_all: bool = False, filenames: List[str] = None) -> None:
338         self.phase = BuildPhase.READING
339         try:
340             if force_all:
341                 self.builder.compile_all_catalogs()
342                 self.builder.build_all()
343             elif filenames:
344                 self.builder.compile_specific_catalogs(filenames)
345                 self.builder.build_specific(filenames)
346             else:
347                 self.builder.compile_update_catalogs()
348                 self.builder.build_update()
349 
350             if self._warncount and self.keep_going:
351                 self.statuscode = 1
352 
353             status = (__('succeeded') if self.statuscode == 0
354                       else __('finished with problems'))
355             if self._warncount:
356                 if self.warningiserror:
357                     if self._warncount == 1:
358                         msg = __('build %s, %s warning (with warnings treated as errors).')
359                     else:
360                         msg = __('build %s, %s warnings (with warnings treated as errors).')
361                 else:
362                     if self._warncount == 1:
363                         msg = __('build %s, %s warning.')
364                     else:
365                         msg = __('build %s, %s warnings.')
366 
367                 logger.info(bold(msg % (status, self._warncount)))
368             else:
369                 logger.info(bold(__('build %s.') % status))
370 
371             if self.statuscode == 0 and self.builder.epilog:
372                 logger.info('')
373                 logger.info(self.builder.epilog % {
374                     'outdir': relpath(self.outdir),
375                     'project': self.config.project
376                 })
377         except Exception as err:
378             # delete the saved env to force a fresh build next time
379             envfile = path.join(self.doctreedir, ENV_PICKLE_FILENAME)
380             if path.isfile(envfile):
381                 os.unlink(envfile)
382             self.events.emit('build-finished', err)
383             raise
384         else:
385             self.events.emit('build-finished', None)
386         self.builder.cleanup()
387 
388     # ---- general extensibility interface -------------------------------------
389 
390     def setup_extension(self, extname: str) -> None:
391         """Import and setup a Sphinx extension module.
392 
393         Load the extension given by the module *name*.  Use this if your
394         extension needs the features provided by another extension.  No-op if
395         called twice.
396         """
397         logger.debug('[app] setting up extension: %r', extname)
398         self.registry.load_extension(self, extname)
399 
400     def require_sphinx(self, version: str) -> None:
401         """Check the Sphinx version if requested.
402 
403         Compare *version* (which must be a ``major.minor`` version string, e.g.
404         ``'1.1'``) with the version of the running Sphinx, and abort the build
405         when it is too old.
406 
407         .. versionadded:: 1.0
408         """
409         if version > sphinx.__display_version__[:3]:
410             raise VersionRequirementError(version)
411 
412     # event interface
413     def connect(self, event: str, callback: Callable, priority: int = 500) -> int:
414         """Register *callback* to be called when *event* is emitted.
415 
416         For details on available core events and the arguments of callback
417         functions, please see :ref:`events`.
418 
419         Registered callbacks will be invoked on event in the order of *priority* and
420         registration.  The priority is ascending order.
421 
422         The method returns a "listener ID" that can be used as an argument to
423         :meth:`disconnect`.
424 
425         .. versionchanged:: 3.0
426 
427            Support *priority*
428         """
429         listener_id = self.events.connect(event, callback, priority)
430         logger.debug('[app] connecting event %r (%d): %r [id=%s]',
431                      event, priority, callback, listener_id)
432         return listener_id
433 
434     def disconnect(self, listener_id: int) -> None:
435         """Unregister callback by *listener_id*."""
436         logger.debug('[app] disconnecting event: [id=%s]', listener_id)
437         self.events.disconnect(listener_id)
438 
439     def emit(self, event: str, *args: Any) -> List:
440         """Emit *event* and pass *arguments* to the callback functions.
441 
442         Return the return values of all callbacks as a list.  Do not emit core
443         Sphinx events in extensions!
444         """
445         return self.events.emit(event, *args)
446 
447     def emit_firstresult(self, event: str, *args: Any) -> Any:
448         """Emit *event* and pass *arguments* to the callback functions.
449 
450         Return the result of the first callback that doesn't return ``None``.
451 
452         .. versionadded:: 0.5
453         """
454         return self.events.emit_firstresult(event, *args)
455 
456     # registering addon parts
457 
458     def add_builder(self, builder: "Type[Builder]", override: bool = False) -> None:
459         """Register a new builder.
460 
461         *builder* must be a class that inherits from
462         :class:`~sphinx.builders.Builder`.
463 
464         .. versionchanged:: 1.8
465            Add *override* keyword.
466         """
467         self.registry.add_builder(builder, override=override)
468 
469     # TODO(stephenfin): Describe 'types' parameter
470     def add_config_value(self, name: str, default: Any, rebuild: Union[bool, str],
471                          types: Any = ()) -> None:
472         """Register a configuration value.
473 
474         This is necessary for Sphinx to recognize new values and set default
475         values accordingly.  The *name* should be prefixed with the extension
476         name, to avoid clashes.  The *default* value can be any Python object.
477         The string value *rebuild* must be one of those values:
478 
479         * ``'env'`` if a change in the setting only takes effect when a
480           document is parsed -- this means that the whole environment must be
481           rebuilt.
482         * ``'html'`` if a change in the setting needs a full rebuild of HTML
483           documents.
484         * ``''`` if a change in the setting will not need any special rebuild.
485 
486         .. versionchanged:: 0.6
487            Changed *rebuild* from a simple boolean (equivalent to ``''`` or
488            ``'env'``) to a string.  However, booleans are still accepted and
489            converted internally.
490 
491         .. versionchanged:: 0.4
492            If the *default* value is a callable, it will be called with the
493            config object as its argument in order to get the default value.
494            This can be used to implement config values whose default depends on
495            other values.
496         """
497         logger.debug('[app] adding config value: %r',
498                      (name, default, rebuild) + ((types,) if types else ()))
499         if rebuild in (False, True):
500             rebuild = 'env' if rebuild else ''
501         self.config.add(name, default, rebuild, types)
502 
503     def add_event(self, name: str) -> None:
504         """Register an event called *name*.
505 
506         This is needed to be able to emit it.
507         """
508         logger.debug('[app] adding event: %r', name)
509         self.events.add(name)
510 
511     def set_translator(self, name: str, translator_class: "Type[nodes.NodeVisitor]",
512                        override: bool = False) -> None:
513         """Register or override a Docutils translator class.
514 
515         This is used to register a custom output translator or to replace a
516         builtin translator.  This allows extensions to use custom translator
517         and define custom nodes for the translator (see :meth:`add_node`).
518 
519         .. versionadded:: 1.3
520         .. versionchanged:: 1.8
521            Add *override* keyword.
522         """
523         self.registry.add_translator(name, translator_class, override=override)
524 
525     def add_node(self, node: "Type[Element]", override: bool = False,
526                  **kwargs: Tuple[Callable, Callable]) -> None:
527         """Register a Docutils node class.
528 
529         This is necessary for Docutils internals.  It may also be used in the
530         future to validate nodes in the parsed documents.
531 
532         Node visitor functions for the Sphinx HTML, LaTeX, text and manpage
533         writers can be given as keyword arguments: the keyword should be one or
534         more of ``'html'``, ``'latex'``, ``'text'``, ``'man'``, ``'texinfo'``
535         or any other supported translators, the value a 2-tuple of ``(visit,
536         depart)`` methods.  ``depart`` can be ``None`` if the ``visit``
537         function raises :exc:`docutils.nodes.SkipNode`.  Example:
538 
539         .. code-block:: python
540 
541            class math(docutils.nodes.Element): pass
542 
543            def visit_math_html(self, node):
544                self.body.append(self.starttag(node, 'math'))
545            def depart_math_html(self, node):
546                self.body.append('</math>')
547 
548            app.add_node(math, html=(visit_math_html, depart_math_html))
549 
550         Obviously, translators for which you don't specify visitor methods will
551         choke on the node when encountered in a document to translate.
552 
553         .. versionchanged:: 0.5
554            Added the support for keyword arguments giving visit functions.
555         """
556         logger.debug('[app] adding node: %r', (node, kwargs))
557         if not override and docutils.is_node_registered(node):
558             logger.warning(__('node class %r is already registered, '
559                               'its visitors will be overridden'),
560                            node.__name__, type='app', subtype='add_node')
561         docutils.register_node(node)
562         self.registry.add_translation_handlers(node, **kwargs)
563 
564     def add_enumerable_node(self, node: "Type[Element]", figtype: str,
565                             title_getter: TitleGetter = None, override: bool = False,
566                             **kwargs: Tuple[Callable, Callable]) -> None:
567         """Register a Docutils node class as a numfig target.
568 
569         Sphinx numbers the node automatically. And then the users can refer it
570         using :rst:role:`numref`.
571 
572         *figtype* is a type of enumerable nodes.  Each figtypes have individual
573         numbering sequences.  As a system figtypes, ``figure``, ``table`` and
574         ``code-block`` are defined.  It is able to add custom nodes to these
575         default figtypes.  It is also able to define new custom figtype if new
576         figtype is given.
577 
578         *title_getter* is a getter function to obtain the title of node.  It
579         takes an instance of the enumerable node, and it must return its title
580         as string.  The title is used to the default title of references for
581         :rst:role:`ref`.  By default, Sphinx searches
582         ``docutils.nodes.caption`` or ``docutils.nodes.title`` from the node as
583         a title.
584 
585         Other keyword arguments are used for node visitor functions. See the
586         :meth:`.Sphinx.add_node` for details.
587 
588         .. versionadded:: 1.4
589         """
590         self.registry.add_enumerable_node(node, figtype, title_getter, override=override)
591         self.add_node(node, override=override, **kwargs)
592 
593     def add_directive(self, name: str, cls: "Type[Directive]", override: bool = False) -> None:
594         """Register a Docutils directive.
595 
596         *name* must be the prospective directive name.  *cls* is a directive
597         class which inherits ``docutils.parsers.rst.Directive``.  For more
598         details, see `the Docutils docs
599         <http://docutils.sourceforge.net/docs/howto/rst-directives.html>`_ .
600 
601         For example, the (already existing) :rst:dir:`literalinclude` directive
602         would be added like this:
603 
604         .. code-block:: python
605 
606            from docutils.parsers.rst import Directive, directives
607 
608            class LiteralIncludeDirective(Directive):
609                has_content = True
610                required_arguments = 1
611                optional_arguments = 0
612                final_argument_whitespace = True
613                option_spec = {
614                    'class': directives.class_option,
615                    'name': directives.unchanged,
616                }
617 
618                def run(self):
619                    ...
620 
621            add_directive('literalinclude', LiteralIncludeDirective)
622 
623         .. versionchanged:: 0.6
624            Docutils 0.5-style directive classes are now supported.
625         .. deprecated:: 1.8
626            Docutils 0.4-style (function based) directives support is deprecated.
627         .. versionchanged:: 1.8
628            Add *override* keyword.
629         """
630         logger.debug('[app] adding directive: %r', (name, cls))
631         if not override and docutils.is_directive_registered(name):
632             logger.warning(__('directive %r is already registered, it will be overridden'),
633                            name, type='app', subtype='add_directive')
634 
635         docutils.register_directive(name, cls)
636 
637     def add_role(self, name: str, role: Any, override: bool = False) -> None:
638         """Register a Docutils role.
639 
640         *name* must be the role name that occurs in the source, *role* the role
641         function. Refer to the `Docutils documentation
642         <http://docutils.sourceforge.net/docs/howto/rst-roles.html>`_ for
643         more information.
644 
645         .. versionchanged:: 1.8
646            Add *override* keyword.
647         """
648         logger.debug('[app] adding role: %r', (name, role))
649         if not override and docutils.is_role_registered(name):
650             logger.warning(__('role %r is already registered, it will be overridden'),
651                            name, type='app', subtype='add_role')
652         docutils.register_role(name, role)
653 
654     def add_generic_role(self, name: str, nodeclass: Any, override: bool = False) -> None:
655         """Register a generic Docutils role.
656 
657         Register a Docutils role that does nothing but wrap its contents in the
658         node given by *nodeclass*.
659 
660         .. versionadded:: 0.6
661         .. versionchanged:: 1.8
662            Add *override* keyword.
663         """
664         # Don't use ``roles.register_generic_role`` because it uses
665         # ``register_canonical_role``.
666         logger.debug('[app] adding generic role: %r', (name, nodeclass))
667         if not override and docutils.is_role_registered(name):
668             logger.warning(__('role %r is already registered, it will be overridden'),
669                            name, type='app', subtype='add_generic_role')
670         role = roles.GenericRole(name, nodeclass)
671         docutils.register_role(name, role)
672 
673     def add_domain(self, domain: "Type[Domain]", override: bool = False) -> None:
674         """Register a domain.
675 
676         Make the given *domain* (which must be a class; more precisely, a
677         subclass of :class:`~sphinx.domains.Domain`) known to Sphinx.
678 
679         .. versionadded:: 1.0
680         .. versionchanged:: 1.8
681            Add *override* keyword.
682         """
683         self.registry.add_domain(domain, override=override)
684 
685     def add_directive_to_domain(self, domain: str, name: str,
686                                 cls: "Type[Directive]", override: bool = False) -> None:
687         """Register a Docutils directive in a domain.
688 
689         Like :meth:`add_directive`, but the directive is added to the domain
690         named *domain*.
691 
692         .. versionadded:: 1.0
693         .. versionchanged:: 1.8
694            Add *override* keyword.
695         """
696         self.registry.add_directive_to_domain(domain, name, cls, override=override)
697 
698     def add_role_to_domain(self, domain: str, name: str, role: Union[RoleFunction, XRefRole],
699                            override: bool = False) -> None:
700         """Register a Docutils role in a domain.
701 
702         Like :meth:`add_role`, but the role is added to the domain named
703         *domain*.
704 
705         .. versionadded:: 1.0
706         .. versionchanged:: 1.8
707            Add *override* keyword.
708         """
709         self.registry.add_role_to_domain(domain, name, role, override=override)
710 
711     def add_index_to_domain(self, domain: str, index: "Type[Index]", override: bool = False
712                             ) -> None:
713         """Register a custom index for a domain.
714 
715         Add a custom *index* class to the domain named *domain*.  *index* must
716         be a subclass of :class:`~sphinx.domains.Index`.
717 
718         .. versionadded:: 1.0
719         .. versionchanged:: 1.8
720            Add *override* keyword.
721         """
722         self.registry.add_index_to_domain(domain, index)
723 
724     def add_object_type(self, directivename: str, rolename: str, indextemplate: str = '',
725                         parse_node: Callable = None, ref_nodeclass: "Type[TextElement]" = None,
726                         objname: str = '', doc_field_types: List = [], override: bool = False
727                         ) -> None:
728         """Register a new object type.
729 
730         This method is a very convenient way to add a new :term:`object` type
731         that can be cross-referenced.  It will do this:
732 
733         - Create a new directive (called *directivename*) for documenting an
734           object.  It will automatically add index entries if *indextemplate*
735           is nonempty; if given, it must contain exactly one instance of
736           ``%s``.  See the example below for how the template will be
737           interpreted.
738         - Create a new role (called *rolename*) to cross-reference to these
739           object descriptions.
740         - If you provide *parse_node*, it must be a function that takes a
741           string and a docutils node, and it must populate the node with
742           children parsed from the string.  It must then return the name of the
743           item to be used in cross-referencing and index entries.  See the
744           :file:`conf.py` file in the source for this documentation for an
745           example.
746         - The *objname* (if not given, will default to *directivename*) names
747           the type of object.  It is used when listing objects, e.g. in search
748           results.
749 
750         For example, if you have this call in a custom Sphinx extension::
751 
752            app.add_object_type('directive', 'dir', 'pair: %s; directive')
753 
754         you can use this markup in your documents::
755 
756            .. rst:directive:: function
757 
758               Document a function.
759 
760            <...>
761 
762            See also the :rst:dir:`function` directive.
763 
764         For the directive, an index entry will be generated as if you had prepended ::
765 
766            .. index:: pair: function; directive
767 
768         The reference node will be of class ``literal`` (so it will be rendered
769         in a proportional font, as appropriate for code) unless you give the
770         *ref_nodeclass* argument, which must be a docutils node class.  Most
771         useful are ``docutils.nodes.emphasis`` or ``docutils.nodes.strong`` --
772         you can also use ``docutils.nodes.generated`` if you want no further
773         text decoration.  If the text should be treated as literal (e.g. no
774         smart quote replacement), but not have typewriter styling, use
775         ``sphinx.addnodes.literal_emphasis`` or
776         ``sphinx.addnodes.literal_strong``.
777 
778         For the role content, you have the same syntactical possibilities as
779         for standard Sphinx roles (see :ref:`xref-syntax`).
780 
781         .. versionchanged:: 1.8
782            Add *override* keyword.
783         """
784         self.registry.add_object_type(directivename, rolename, indextemplate, parse_node,
785                                       ref_nodeclass, objname, doc_field_types,
786                                       override=override)
787 
788     def add_crossref_type(self, directivename: str, rolename: str, indextemplate: str = '',
789                           ref_nodeclass: "Type[TextElement]" = None, objname: str = '',
790                           override: bool = False) -> None:
791         """Register a new crossref object type.
792 
793         This method is very similar to :meth:`add_object_type` except that the
794         directive it generates must be empty, and will produce no output.
795 
796         That means that you can add semantic targets to your sources, and refer
797         to them using custom roles instead of generic ones (like
798         :rst:role:`ref`).  Example call::
799 
800            app.add_crossref_type('topic', 'topic', 'single: %s',
801                                  docutils.nodes.emphasis)
802 
803         Example usage::
804 
805            .. topic:: application API
806 
807            The application API
808            -------------------
809 
810            Some random text here.
811 
812            See also :topic:`this section <application API>`.
813 
814         (Of course, the element following the ``topic`` directive needn't be a
815         section.)
816 
817         .. versionchanged:: 1.8
818            Add *override* keyword.
819         """
820         self.registry.add_crossref_type(directivename, rolename,
821                                         indextemplate, ref_nodeclass, objname,
822                                         override=override)
823 
824     def add_transform(self, transform: "Type[Transform]") -> None:
825         """Register a Docutils transform to be applied after parsing.
826 
827         Add the standard docutils :class:`Transform` subclass *transform* to
828         the list of transforms that are applied after Sphinx parses a reST
829         document.
830 
831         .. list-table:: priority range categories for Sphinx transforms
832            :widths: 20,80
833 
834            * - Priority
835              - Main purpose in Sphinx
836            * - 0-99
837              - Fix invalid nodes by docutils. Translate a doctree.
838            * - 100-299
839              - Preparation
840            * - 300-399
841              - early
842            * - 400-699
843              - main
844            * - 700-799
845              - Post processing. Deadline to modify text and referencing.
846            * - 800-899
847              - Collect referencing and referenced nodes. Domain processing.
848            * - 900-999
849              - Finalize and clean up.
850 
851         refs: `Transform Priority Range Categories`__
852 
853         __ http://docutils.sourceforge.net/docs/ref/transforms.html#transform-priority-range-categories
854         """  # NOQA
855         self.registry.add_transform(transform)
856 
857     def add_post_transform(self, transform: "Type[Transform]") -> None:
858         """Register a Docutils transform to be applied before writing.
859 
860         Add the standard docutils :class:`Transform` subclass *transform* to
861         the list of transforms that are applied before Sphinx writes a
862         document.
863         """
864         self.registry.add_post_transform(transform)
865 
866     def add_javascript(self, filename: str, **kwargs: str) -> None:
867         """An alias of :meth:`add_js_file`."""
868         warnings.warn('The app.add_javascript() is deprecated. '
869                       'Please use app.add_js_file() instead.',
870                       RemovedInSphinx40Warning, stacklevel=2)
871         self.add_js_file(filename, **kwargs)
872 
873     def add_js_file(self, filename: str, **kwargs: str) -> None:
874         """Register a JavaScript file to include in the HTML output.
875 
876         Add *filename* to the list of JavaScript files that the default HTML
877         template will include.  The filename must be relative to the HTML
878         static path , or a full URI with scheme.  If the keyword argument
879         ``body`` is given, its value will be added between the
880         ``<script>`` tags. Extra keyword arguments are included as
881         attributes of the ``<script>`` tag.
882 
883         Example::
884 
885             app.add_js_file('example.js')
886             # => <script src="_static/example.js"></script>
887 
888             app.add_js_file('example.js', async="async")
889             # => <script src="_static/example.js" async="async"></script>
890 
891             app.add_js_file(None, body="var myVariable = 'foo';")
892             # => <script>var myVariable = 'foo';</script>
893 
894         .. versionadded:: 0.5
895 
896         .. versionchanged:: 1.8
897            Renamed from ``app.add_javascript()``.
898            And it allows keyword arguments as attributes of script tag.
899         """
900         self.registry.add_js_file(filename, **kwargs)
901         if hasattr(self.builder, 'add_js_file'):
902             self.builder.add_js_file(filename, **kwargs)  # type: ignore
903 
904     def add_css_file(self, filename: str, **kwargs: str) -> None:
905         """Register a stylesheet to include in the HTML output.
906 
907         Add *filename* to the list of CSS files that the default HTML template
908         will include.  The filename must be relative to the HTML static path,
909         or a full URI with scheme.  The keyword arguments are also accepted for
910         attributes of ``<link>`` tag.
911 
912         Example::
913 
914             app.add_css_file('custom.css')
915             # => <link rel="stylesheet" href="_static/custom.css" type="text/css" />
916 
917             app.add_css_file('print.css', media='print')
918             # => <link rel="stylesheet" href="_static/print.css"
919             #          type="text/css" media="print" />
920 
921             app.add_css_file('fancy.css', rel='alternate stylesheet', title='fancy')
922             # => <link rel="alternate stylesheet" href="_static/fancy.css"
923             #          type="text/css" title="fancy" />
924 
925         .. versionadded:: 1.0
926 
927         .. versionchanged:: 1.6
928            Optional ``alternate`` and/or ``title`` attributes can be supplied
929            with the *alternate* (of boolean type) and *title* (a string)
930            arguments. The default is no title and *alternate* = ``False``. For
931            more information, refer to the `documentation
932            <https://mdn.io/Web/CSS/Alternative_style_sheets>`__.
933 
934         .. versionchanged:: 1.8
935            Renamed from ``app.add_stylesheet()``.
936            And it allows keyword arguments as attributes of link tag.
937         """
938         logger.debug('[app] adding stylesheet: %r', filename)
939         self.registry.add_css_files(filename, **kwargs)
940         if hasattr(self.builder, 'add_css_file'):
941             self.builder.add_css_file(filename, **kwargs)  # type: ignore
942 
943     def add_stylesheet(self, filename: str, alternate: bool = False, title: str = None
944                        ) -> None:
945         """An alias of :meth:`add_css_file`."""
946         warnings.warn('The app.add_stylesheet() is deprecated. '
947                       'Please use app.add_css_file() instead.',
948                       RemovedInSphinx40Warning, stacklevel=2)
949 
950         attributes = {}  # type: Dict[str, str]
951         if alternate:
952             attributes['rel'] = 'alternate stylesheet'
953         else:
954             attributes['rel'] = 'stylesheet'
955 
956         if title:
957             attributes['title'] = title
958 
959         self.add_css_file(filename, **attributes)
960 
961     def add_latex_package(self, packagename: str, options: str = None) -> None:
962         r"""Register a package to include in the LaTeX source code.
963 
964         Add *packagename* to the list of packages that LaTeX source code will
965         include.  If you provide *options*, it will be taken to `\usepackage`
966         declaration.
967 
968         .. code-block:: python
969 
970            app.add_latex_package('mypackage')
971            # => \usepackage{mypackage}
972            app.add_latex_package('mypackage', 'foo,bar')
973            # => \usepackage[foo,bar]{mypackage}
974 
975         .. versionadded:: 1.3
976         """
977         self.registry.add_latex_package(packagename, options)
978 
979     def add_lexer(self, alias: str, lexer: Union[Lexer, "Type[Lexer]"]) -> None:
980         """Register a new lexer for source code.
981 
982         Use *lexer* to highlight code blocks with the given language *alias*.
983 
984         .. versionadded:: 0.6
985         .. versionchanged:: 2.1
986            Take a lexer class as an argument.  An instance of lexers are
987            still supported until Sphinx-3.x.
988         """
989         logger.debug('[app] adding lexer: %r', (alias, lexer))
990         if isinstance(lexer, Lexer):
991             warnings.warn('app.add_lexer() API changed; '
992                           'Please give lexer class instead instance',
993                           RemovedInSphinx40Warning)
994             lexers[alias] = lexer
995         else:
996             lexer_classes[alias] = lexer
997 
998     def add_autodocumenter(self, cls: Any, override: bool = False) -> None:
999         """Register a new documenter class for the autodoc extension.
1000 
1001         Add *cls* as a new documenter class for the :mod:`sphinx.ext.autodoc`
1002         extension.  It must be a subclass of
1003         :class:`sphinx.ext.autodoc.Documenter`.  This allows to auto-document
1004         new types of objects.  See the source of the autodoc module for
1005         examples on how to subclass :class:`Documenter`.
1006 
1007         .. todo:: Add real docs for Documenter and subclassing
1008 
1009         .. versionadded:: 0.6
1010         .. versionchanged:: 2.2
1011            Add *override* keyword.
1012         """
1013         logger.debug('[app] adding autodocumenter: %r', cls)
1014         from sphinx.ext.autodoc.directive import AutodocDirective
1015         self.registry.add_documenter(cls.objtype, cls)
1016         self.add_directive('auto' + cls.objtype, AutodocDirective, override=override)
1017 
1018     def add_autodoc_attrgetter(self, typ: "Type", getter: Callable[[Any, str, Any], Any]
1019                                ) -> None:
1020         """Register a new ``getattr``-like function for the autodoc extension.
1021 
1022         Add *getter*, which must be a function with an interface compatible to
1023         the :func:`getattr` builtin, as the autodoc attribute getter for
1024         objects that are instances of *typ*.  All cases where autodoc needs to
1025         get an attribute of a type are then handled by this function instead of
1026         :func:`getattr`.
1027 
1028         .. versionadded:: 0.6
1029         """
1030         logger.debug('[app] adding autodoc attrgetter: %r', (typ, getter))
1031         self.registry.add_autodoc_attrgetter(typ, getter)
1032 
1033     def add_search_language(self, cls: Any) -> None:
1034         """Register a new language for the HTML search index.
1035 
1036         Add *cls*, which must be a subclass of
1037         :class:`sphinx.search.SearchLanguage`, as a support language for
1038         building the HTML full-text search index.  The class must have a *lang*
1039         attribute that indicates the language it should be used for.  See
1040         :confval:`html_search_language`.
1041 
1042         .. versionadded:: 1.1
1043         """
1044         logger.debug('[app] adding search language: %r', cls)
1045         from sphinx.search import languages, SearchLanguage
1046         assert issubclass(cls, SearchLanguage)
1047         languages[cls.lang] = cls
1048 
1049     def add_source_suffix(self, suffix: str, filetype: str, override: bool = False) -> None:
1050         """Register a suffix of source files.
1051 
1052         Same as :confval:`source_suffix`.  The users can override this
1053         using the setting.
1054 
1055         .. versionadded:: 1.8
1056         """
1057         self.registry.add_source_suffix(suffix, filetype, override=override)
1058 
1059     def add_source_parser(self, *args: Any, **kwargs: Any) -> None:
1060         """Register a parser class.
1061 
1062         .. versionadded:: 1.4
1063         .. versionchanged:: 1.8
1064            *suffix* argument is deprecated.  It only accepts *parser* argument.
1065            Use :meth:`add_source_suffix` API to register suffix instead.
1066         .. versionchanged:: 1.8
1067            Add *override* keyword.
1068         """
1069         self.registry.add_source_parser(*args, **kwargs)
1070 
1071     def add_env_collector(self, collector: "Type[EnvironmentCollector]") -> None:
1072         """Register an environment collector class.
1073 
1074         Refer to :ref:`collector-api`.
1075 
1076         .. versionadded:: 1.6
1077         """
1078         logger.debug('[app] adding environment collector: %r', collector)
1079         collector().enable(self)
1080 
1081     def add_html_theme(self, name: str, theme_path: str) -> None:
1082         """Register a HTML Theme.
1083 
1084         The *name* is a name of theme, and *path* is a full path to the theme
1085         (refs: :ref:`distribute-your-theme`).
1086 
1087         .. versionadded:: 1.6
1088         """
1089         logger.debug('[app] adding HTML theme: %r, %r', name, theme_path)
1090         self.html_themes[name] = theme_path
1091 
1092     def add_html_math_renderer(self, name: str,
1093                                inline_renderers: Tuple[Callable, Callable] = None,
1094                                block_renderers: Tuple[Callable, Callable] = None) -> None:
1095         """Register a math renderer for HTML.
1096 
1097         The *name* is a name of math renderer.  Both *inline_renderers* and
1098         *block_renderers* are used as visitor functions for the HTML writer:
1099         the former for inline math node (``nodes.math``), the latter for
1100         block math node (``nodes.math_block``).  Regarding visitor functions,
1101         see :meth:`add_node` for details.
1102 
1103         .. versionadded:: 1.8
1104 
1105         """
1106         self.registry.add_html_math_renderer(name, inline_renderers, block_renderers)
1107 
1108     def add_message_catalog(self, catalog: str, locale_dir: str) -> None:
1109         """Register a message catalog.
1110 
1111         The *catalog* is a name of catalog, and *locale_dir* is a base path
1112         of message catalog.  For more details, see
1113         :func:`sphinx.locale.get_translation()`.
1114 
1115         .. versionadded:: 1.8
1116         """
1117         locale.init([locale_dir], self.config.language, catalog)
1118         locale.init_console(locale_dir, catalog)
1119 
1120     # ---- other methods -------------------------------------------------
1121     def is_parallel_allowed(self, typ: str) -> bool:
1122         """Check parallel processing is allowed or not.
1123 
1124         ``typ`` is a type of processing; ``'read'`` or ``'write'``.
1125         """
1126         if typ == 'read':
1127             attrname = 'parallel_read_safe'
1128             message_not_declared = __("the %s extension does not declare if it "
1129                                       "is safe for parallel reading, assuming "
1130                                       "it isn't - please ask the extension author "
1131                                       "to check and make it explicit")
1132             message_not_safe = __("the %s extension is not safe for parallel reading")
1133         elif typ == 'write':
1134             attrname = 'parallel_write_safe'
1135             message_not_declared = __("the %s extension does not declare if it "
1136                                       "is safe for parallel writing, assuming "
1137                                       "it isn't - please ask the extension author "
1138                                       "to check and make it explicit")
1139             message_not_safe = __("the %s extension is not safe for parallel writing")
1140         else:
1141             raise ValueError('parallel type %s is not supported' % typ)
1142 
1143         for ext in self.extensions.values():
1144             allowed = getattr(ext, attrname, None)
1145             if allowed is None:
1146                 logger.warning(message_not_declared, ext.name)
1147                 logger.warning(__('doing serial %s'), typ)
1148                 return False
1149             elif not allowed:
1150                 logger.warning(message_not_safe, ext.name)
1151                 logger.warning(__('doing serial %s'), typ)
1152                 return False
1153 
1154         return True
1155 
1156 
1157 class TemplateBridge:
1158     """
1159     This class defines the interface for a "template bridge", that is, a class
1160     that renders templates given a template name and a context.
1161     """
1162 
1163     def init(self, builder: "Builder", theme: Theme = None, dirs: List[str] = None) -> None:
1164         """Called by the builder to initialize the template system.
1165 
1166         *builder* is the builder object; you'll probably want to look at the
1167         value of ``builder.config.templates_path``.
1168 
1169         *theme* is a :class:`sphinx.theming.Theme` object or None; in the latter
1170         case, *dirs* can be list of fixed directories to look for templates.
1171         """
1172         raise NotImplementedError('must be implemented in subclasses')
1173 
1174     def newest_template_mtime(self) -> float:
1175         """Called by the builder to determine if output files are outdated
1176         because of template changes.  Return the mtime of the newest template
1177         file that was changed.  The default implementation returns ``0``.
1178         """
1179         return 0
1180 
1181     def render(self, template: str, context: Dict) -> None:
1182         """Called by the builder to render a template given as a filename with
1183         a specified context (a Python dictionary).
1184         """
1185         raise NotImplementedError('must be implemented in subclasses')
1186 
1187     def render_string(self, template: str, context: Dict) -> str:
1188         """Called by the builder to render a template given as a string with a
1189         specified context (a Python dictionary).
1190         """
1191         raise NotImplementedError('must be implemented in subclasses')

</code><intended_behavior>The application layer, which initializes and configures extensions, should include logic to prioritize file extensions when multiple sources with the same name but different extensions exist. This could be implemented either by enhancing existing methods or introducing a new method to filter and sort files based on a configurable priority list before including them in the build process. This priority list could be configured through the existing Sphinx configuration mechanisms, allowing users to specify their preference for `.md` over `.rst` or vice versa. It's essential that this change does not disrupt the current functionality for projects not requiring this feature.</intended_behavior>, <file>sphinx/config.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2     sphinx.config
3     ~~~~~~~~~~~~~
4 
5     Build configuration file handling.
6 
7     :copyright: Copyright 2007-2020 by the Sphinx team, see AUTHORS.
8     :license: BSD, see LICENSE for details.
9 """
10 
11 import re
12 import traceback
13 import types
14 import warnings
15 from collections import OrderedDict
16 from os import path, getenv
17 from typing import (
18     Any, Callable, Dict, Generator, Iterator, List, NamedTuple, Set, Tuple, Union
19 )
20 
21 from sphinx.deprecation import RemovedInSphinx40Warning
22 from sphinx.errors import ConfigError, ExtensionError
23 from sphinx.locale import _, __
24 from sphinx.util import logging
25 from sphinx.util.i18n import format_date
26 from sphinx.util.osutil import cd
27 from sphinx.util.pycompat import execfile_
28 from sphinx.util.tags import Tags
29 from sphinx.util.typing import NoneType
30 
31 if False:
32     # For type annotation
33     from sphinx.application import Sphinx
34     from sphinx.environment import BuildEnvironment
35 
36 logger = logging.getLogger(__name__)
37 
38 CONFIG_FILENAME = 'conf.py'
39 UNSERIALIZABLE_TYPES = (type, types.ModuleType, types.FunctionType)
40 copyright_year_re = re.compile(r'^((\d{4}-)?)(\d{4})(?=[ ,])')
41 
42 ConfigValue = NamedTuple('ConfigValue', [('name', str),
43                                          ('value', Any),
44                                          ('rebuild', Union[bool, str])])
45 
46 
47 def is_serializable(obj: Any) -> bool:
48     """Check if object is serializable or not."""
49     if isinstance(obj, UNSERIALIZABLE_TYPES):
50         return False
51     elif isinstance(obj, dict):
52         for key, value in obj.items():
53             if not is_serializable(key) or not is_serializable(value):
54                 return False
55     elif isinstance(obj, (list, tuple, set)):
56         return all(is_serializable(i) for i in obj)
57 
58     return True
59 
60 
61 class ENUM:
62     """represents the config value should be a one of candidates.
63 
64     Example:
65         app.add_config_value('latex_show_urls', 'no', None, ENUM('no', 'footnote', 'inline'))
66     """
67     def __init__(self, *candidates: str) -> None:
68         self.candidates = candidates
69 
70     def match(self, value: Union[str, List, Tuple]) -> bool:
71         if isinstance(value, (list, tuple)):
72             return all(item in self.candidates for item in value)
73         else:
74             return value in self.candidates
75 
76 
77 # RemovedInSphinx40Warning
78 string_classes = [str]  # type: List
79 
80 
81 class Config:
82     """Configuration file abstraction.
83 
84     The config object makes the values of all config values available as
85     attributes.
86 
87     It is exposed via the :py:attr:`sphinx.application.Application.config` and
88     :py:attr:`sphinx.environment.Environment.config` attributes. For example,
89     to get the value of :confval:`language`, use either ``app.config.language``
90     or ``env.config.language``.
91     """
92 
93     # the values are: (default, what needs to be rebuilt if changed)
94 
95     # If you add a value here, don't forget to include it in the
96     # quickstart.py file template as well as in the docs!
97 
98     config_values = {
99         # general options
100         'project': ('Python', 'env', []),
101         'author': ('unknown', 'env', []),
102         'copyright': ('', 'html', []),
103         'version': ('', 'env', []),
104         'release': ('', 'env', []),
105         'today': ('', 'env', []),
106         # the real default is locale-dependent
107         'today_fmt': (None, 'env', [str]),
108 
109         'language': (None, 'env', [str]),
110         'locale_dirs': (['locales'], 'env', []),
111         'figure_language_filename': ('{root}.{language}{ext}', 'env', [str]),
112 
113         'master_doc': ('index', 'env', []),
114         'source_suffix': ({'.rst': 'restructuredtext'}, 'env', Any),
115         'source_encoding': ('utf-8-sig', 'env', []),
116         'source_parsers': ({}, 'env', []),
117         'exclude_patterns': ([], 'env', []),
118         'default_role': (None, 'env', [str]),
119         'add_function_parentheses': (True, 'env', []),
120         'add_module_names': (True, 'env', []),
121         'trim_footnote_reference_space': (False, 'env', []),
122         'show_authors': (False, 'env', []),
123         'pygments_style': (None, 'html', [str]),
124         'highlight_language': ('default', 'env', []),
125         'highlight_options': ({}, 'env', []),
126         'templates_path': ([], 'html', []),
127         'template_bridge': (None, 'html', [str]),
128         'keep_warnings': (False, 'env', []),
129         'suppress_warnings': ([], 'env', []),
130         'modindex_common_prefix': ([], 'html', []),
131         'rst_epilog': (None, 'env', [str]),
132         'rst_prolog': (None, 'env', [str]),
133         'trim_doctest_flags': (True, 'env', []),
134         'primary_domain': ('py', 'env', [NoneType]),   # type: ignore
135         'needs_sphinx': (None, None, [str]),
136         'needs_extensions': ({}, None, []),
137         'manpages_url': (None, 'env', []),
138         'nitpicky': (False, None, []),
139         'nitpick_ignore': ([], None, []),
140         'numfig': (False, 'env', []),
141         'numfig_secnum_depth': (1, 'env', []),
142         'numfig_format': ({}, 'env', []),  # will be initialized in init_numfig_format()
143 
144         'math_number_all': (False, 'env', []),
145         'math_eqref_format': (None, 'env', [str]),
146         'math_numfig': (True, 'env', []),
147         'tls_verify': (True, 'env', []),
148         'tls_cacerts': (None, 'env', []),
149         'user_agent': (None, 'env', [str]),
150         'smartquotes': (True, 'env', []),
151         'smartquotes_action': ('qDe', 'env', []),
152         'smartquotes_excludes': ({'languages': ['ja'],
153                                   'builders': ['man', 'text']},
154                                  'env', []),
155     }  # type: Dict[str, Tuple]
156 
157     def __init__(self, config: Dict[str, Any] = {}, overrides: Dict[str, Any] = {}) -> None:
158         self.overrides = dict(overrides)
159         self.values = Config.config_values.copy()
160         self._raw_config = config
161         self.setup = config.get('setup', None)  # type: Callable
162 
163         if 'extensions' in self.overrides:
164             if isinstance(self.overrides['extensions'], str):
165                 config['extensions'] = self.overrides.pop('extensions').split(',')
166             else:
167                 config['extensions'] = self.overrides.pop('extensions')
168         self.extensions = config.get('extensions', [])  # type: List[str]
169 
170     @classmethod
171     def read(cls, confdir: str, overrides: Dict = None, tags: Tags = None) -> "Config":
172         """Create a Config object from configuration file."""
173         filename = path.join(confdir, CONFIG_FILENAME)
174         namespace = eval_config_file(filename, tags)
175         return cls(namespace, overrides or {})
176 
177     def convert_overrides(self, name: str, value: Any) -> Any:
178         if not isinstance(value, str):
179             return value
180         else:
181             defvalue = self.values[name][0]
182             if self.values[name][2] == Any:
183                 return value
184             elif type(defvalue) is bool or self.values[name][2] == [bool]:
185                 if value == '0':
186                     # given falsy string from command line option
187                     return False
188                 else:
189                     return bool(value)
190             elif isinstance(defvalue, dict):
191                 raise ValueError(__('cannot override dictionary config setting %r, '
192                                     'ignoring (use %r to set individual elements)') %
193                                  (name, name + '.key=value'))
194             elif isinstance(defvalue, list):
195                 return value.split(',')
196             elif isinstance(defvalue, int):
197                 try:
198                     return int(value)
199                 except ValueError:
200                     raise ValueError(__('invalid number %r for config value %r, ignoring') %
201                                      (value, name))
202             elif hasattr(defvalue, '__call__'):
203                 return value
204             elif defvalue is not None and not isinstance(defvalue, str):
205                 raise ValueError(__('cannot override config setting %r with unsupported '
206                                     'type, ignoring') % name)
207             else:
208                 return value
209 
210     def pre_init_values(self) -> None:
211         """
212         Initialize some limited config variables before initialize i18n and loading extensions
213         """
214         variables = ['needs_sphinx', 'suppress_warnings', 'language', 'locale_dirs']
215         for name in variables:
216             try:
217                 if name in self.overrides:
218                     self.__dict__[name] = self.convert_overrides(name, self.overrides[name])
219                 elif name in self._raw_config:
220                     self.__dict__[name] = self._raw_config[name]
221             except ValueError as exc:
222                 logger.warning("%s", exc)
223 
224     def init_values(self) -> None:
225         config = self._raw_config
226         for valname, value in self.overrides.items():
227             try:
228                 if '.' in valname:
229                     realvalname, key = valname.split('.', 1)
230                     config.setdefault(realvalname, {})[key] = value
231                     continue
232                 elif valname not in self.values:
233                     logger.warning(__('unknown config value %r in override, ignoring'),
234                                    valname)
235                     continue
236                 if isinstance(value, str):
237                     config[valname] = self.convert_overrides(valname, value)
238                 else:
239                     config[valname] = value
240             except ValueError as exc:
241                 logger.warning("%s", exc)
242         for name in config:
243             if name in self.values:
244                 self.__dict__[name] = config[name]
245 
246     def __getattr__(self, name: str) -> Any:
247         if name.startswith('_'):
248             raise AttributeError(name)
249         if name not in self.values:
250             raise AttributeError(__('No such config value: %s') % name)
251         default = self.values[name][0]
252         if hasattr(default, '__call__'):
253             return default(self)
254         return default
255 
256     def __getitem__(self, name: str) -> str:
257         return getattr(self, name)
258 
259     def __setitem__(self, name: str, value: Any) -> None:
260         setattr(self, name, value)
261 
262     def __delitem__(self, name: str) -> None:
263         delattr(self, name)
264 
265     def __contains__(self, name: str) -> bool:
266         return name in self.values
267 
268     def __iter__(self) -> Generator[ConfigValue, None, None]:
269         for name, value in self.values.items():
270             yield ConfigValue(name, getattr(self, name), value[1])
271 
272     def add(self, name: str, default: Any, rebuild: Union[bool, str], types: Any) -> None:
273         if name in self.values:
274             raise ExtensionError(__('Config value %r already present') % name)
275         else:
276             self.values[name] = (default, rebuild, types)
277 
278     def filter(self, rebuild: Union[str, List[str]]) -> Iterator[ConfigValue]:
279         if isinstance(rebuild, str):
280             rebuild = [rebuild]
281         return (value for value in self if value.rebuild in rebuild)
282 
283     def __getstate__(self) -> Dict:
284         """Obtains serializable data for pickling."""
285         # remove potentially pickling-problematic values from config
286         __dict__ = {}
287         for key, value in self.__dict__.items():
288             if key.startswith('_') or not is_serializable(value):
289                 pass
290             else:
291                 __dict__[key] = value
292 
293         # create a picklable copy of values list
294         __dict__['values'] = {}
295         for key, value in self.values.items():
296             real_value = getattr(self, key)
297             if not is_serializable(real_value):
298                 # omit unserializable value
299                 real_value = None
300 
301             # types column is also omitted
302             __dict__['values'][key] = (real_value, value[1], None)
303 
304         return __dict__
305 
306     def __setstate__(self, state: Dict) -> None:
307         self.__dict__.update(state)
308 
309 
310 def eval_config_file(filename: str, tags: Tags) -> Dict[str, Any]:
311     """Evaluate a config file."""
312     namespace = {}  # type: Dict[str, Any]
313     namespace['__file__'] = filename
314     namespace['tags'] = tags
315 
316     with cd(path.dirname(filename)):
317         # during executing config file, current dir is changed to ``confdir``.
318         try:
319             execfile_(filename, namespace)
320         except SyntaxError as err:
321             msg = __("There is a syntax error in your configuration file: %s\n")
322             raise ConfigError(msg % err)
323         except SystemExit:
324             msg = __("The configuration file (or one of the modules it imports) "
325                      "called sys.exit()")
326             raise ConfigError(msg)
327         except ConfigError:
328             # pass through ConfigError from conf.py as is.  It will be shown in console.
329             raise
330         except Exception:
331             msg = __("There is a programmable error in your configuration file:\n\n%s")
332             raise ConfigError(msg % traceback.format_exc())
333 
334     return namespace
335 
336 
337 def convert_source_suffix(app: "Sphinx", config: Config) -> None:
338     """This converts old styled source_suffix to new styled one.
339 
340     * old style: str or list
341     * new style: a dict which maps from fileext to filetype
342     """
343     source_suffix = config.source_suffix
344     if isinstance(source_suffix, str):
345         # if str, considers as default filetype (None)
346         #
347         # The default filetype is determined on later step.
348         # By default, it is considered as restructuredtext.
349         config.source_suffix = OrderedDict({source_suffix: None})  # type: ignore
350     elif isinstance(source_suffix, (list, tuple)):
351         # if list, considers as all of them are default filetype
352         config.source_suffix = OrderedDict([(s, None) for s in source_suffix])  # type: ignore  # NOQA
353     elif isinstance(source_suffix, dict):
354         # if dict, convert it to OrderedDict
355         config.source_suffix = OrderedDict(config.source_suffix)  # type: ignore
356     else:
357         logger.warning(__("The config value `source_suffix' expects "
358                           "a string, list of strings, or dictionary. "
359                           "But `%r' is given." % source_suffix))
360 
361 
362 def init_numfig_format(app: "Sphinx", config: Config) -> None:
363     """Initialize :confval:`numfig_format`."""
364     numfig_format = {'section': _('Section %s'),
365                      'figure': _('Fig. %s'),
366                      'table': _('Table %s'),
367                      'code-block': _('Listing %s')}
368 
369     # override default labels by configuration
370     numfig_format.update(config.numfig_format)
371     config.numfig_format = numfig_format  # type: ignore
372 
373 
374 def correct_copyright_year(app: "Sphinx", config: Config) -> None:
375     """correct values of copyright year that are not coherent with
376     the SOURCE_DATE_EPOCH environment variable (if set)
377 
378     See https://reproducible-builds.org/specs/source-date-epoch/
379     """
380     if getenv('SOURCE_DATE_EPOCH') is not None:
381         for k in ('copyright', 'epub_copyright'):
382             if k in config:
383                 replace = r'\g<1>%s' % format_date('%Y')
384                 config[k] = copyright_year_re.sub(replace, config[k])
385 
386 
387 def check_confval_types(app: "Sphinx", config: Config) -> None:
388     """check all values for deviation from the default value's type, since
389     that can result in TypeErrors all over the place NB.
390     """
391     for confval in config:
392         default, rebuild, annotations = config.values[confval.name]
393 
394         if hasattr(default, '__call__'):
395             default = default(config)  # evaluate default value
396         if default is None and not annotations:
397             continue  # neither inferrable nor expliclitly annotated types
398 
399         if annotations is Any:
400             # any type of value is accepted
401             pass
402         elif isinstance(annotations, ENUM):
403             if not annotations.match(confval.value):
404                 msg = __("The config value `{name}` has to be a one of {candidates}, "
405                          "but `{current}` is given.")
406                 logger.warning(msg.format(name=confval.name,
407                                           current=confval.value,
408                                           candidates=annotations.candidates))
409         else:
410             if type(confval.value) is type(default):
411                 continue
412             if type(confval.value) in annotations:
413                 continue
414 
415             common_bases = (set(type(confval.value).__bases__ + (type(confval.value),)) &
416                             set(type(default).__bases__))
417             common_bases.discard(object)
418             if common_bases:
419                 continue  # at least we share a non-trivial base class
420 
421             if annotations:
422                 msg = __("The config value `{name}' has type `{current.__name__}'; "
423                          "expected {permitted}.")
424                 wrapped_annotations = ["`{}'".format(c.__name__) for c in annotations]
425                 if len(wrapped_annotations) > 2:
426                     permitted = "{}, or {}".format(
427                         ", ".join(wrapped_annotations[:-1]),
428                         wrapped_annotations[-1])
429                 else:
430                     permitted = " or ".join(wrapped_annotations)
431                 logger.warning(msg.format(name=confval.name,
432                                           current=type(confval.value),
433                                           permitted=permitted))
434             else:
435                 msg = __("The config value `{name}' has type `{current.__name__}', "
436                          "defaults to `{default.__name__}'.")
437                 logger.warning(msg.format(name=confval.name,
438                                           current=type(confval.value),
439                                           default=type(default)))
440 
441 
442 def check_unicode(config: Config) -> None:
443     """check all string values for non-ASCII characters in bytestrings,
444     since that can result in UnicodeErrors all over the place
445     """
446     warnings.warn('sphinx.config.check_unicode() is deprecated.',
447                   RemovedInSphinx40Warning)
448 
449     nonascii_re = re.compile(br'[\x80-\xff]')
450 
451     for name, value in config._raw_config.items():
452         if isinstance(value, bytes) and nonascii_re.search(value):
453             logger.warning(__('the config value %r is set to a string with non-ASCII '
454                               'characters; this can lead to Unicode errors occurring. '
455                               'Please use Unicode strings, e.g. %r.'), name, 'Content')
456 
457 
458 def check_primary_domain(app: "Sphinx", config: Config) -> None:
459     primary_domain = config.primary_domain
460     if primary_domain and not app.registry.has_domain(primary_domain):
461         logger.warning(__('primary_domain %r not found, ignored.'), primary_domain)
462         config.primary_domain = None  # type: ignore
463 
464 
465 def check_master_doc(app: "Sphinx", env: "BuildEnvironment", added: Set[str],
466                      changed: Set[str], removed: Set[str]) -> Set[str]:
467     """Adjust master_doc to 'contents' to support an old project which does not have
468     no master_doc setting.
469     """
470     if (app.config.master_doc == 'index' and
471             'index' not in app.project.docnames and
472             'contents' in app.project.docnames):
473         logger.warning(__('Since v2.0, Sphinx uses "index" as master_doc by default. '
474                           'Please add "master_doc = \'contents\'" to your conf.py.'))
475         app.config.master_doc = "contents"  # type: ignore
476 
477     return changed
478 
479 
480 def setup(app: "Sphinx") -> Dict[str, Any]:
481     app.connect('config-inited', convert_source_suffix)
482     app.connect('config-inited', init_numfig_format)
483     app.connect('config-inited', correct_copyright_year)
484     app.connect('config-inited', check_confval_types)
485     app.connect('config-inited', check_primary_domain)
486     app.connect('env-get-outdated', check_master_doc)
487 
488     return {
489         'version': 'builtin',
490         'parallel_read_safe': True,
491         'parallel_write_safe': True,
492     }

</code><intended_behavior>This file is responsible for handling Sphinx configuration. An update here should introduce a new configuration option, e.g., `file_extension_priority`, which allows users to specify an ordered list of file extensions according to their priorities. This new configuration option should be documented and have default behavior that preserves the current functionality (e.g., an empty list or a list favoring Sphinx's default file extension handling), ensuring backward compatibility.</intended_behavior>]
2025-10-18 06:27:05.879 | INFO     | Search completed. Bug locations: [<file>sphinx/application.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2     sphinx.application
3     ~~~~~~~~~~~~~~~~~~
4 
5     Sphinx application class and extensibility interface.
6 
7     Gracefully adapted from the TextPress system by Armin.
8 
9     :copyright: Copyright 2007-2020 by the Sphinx team, see AUTHORS.
10     :license: BSD, see LICENSE for details.
11 """
12 
13 import os
14 import pickle
15 import platform
16 import sys
17 import warnings
18 from collections import deque
19 from io import StringIO
20 from os import path
21 from typing import Any, Callable, Dict, IO, List, Tuple, Union
22 
23 from docutils import nodes
24 from docutils.nodes import Element, TextElement
25 from docutils.parsers.rst import Directive, roles
26 from docutils.transforms import Transform
27 from pygments.lexer import Lexer
28 
29 import sphinx
30 from sphinx import package_dir, locale
31 from sphinx.config import Config
32 from sphinx.deprecation import RemovedInSphinx40Warning
33 from sphinx.domains import Domain, Index
34 from sphinx.environment import BuildEnvironment
35 from sphinx.environment.collectors import EnvironmentCollector
36 from sphinx.errors import ApplicationError, ConfigError, VersionRequirementError
37 from sphinx.events import EventManager
38 from sphinx.extension import Extension
39 from sphinx.highlighting import lexer_classes, lexers
40 from sphinx.locale import __
41 from sphinx.project import Project
42 from sphinx.registry import SphinxComponentRegistry
43 from sphinx.roles import XRefRole
44 from sphinx.theming import Theme
45 from sphinx.util import docutils
46 from sphinx.util import logging
47 from sphinx.util import progress_message
48 from sphinx.util.build_phase import BuildPhase
49 from sphinx.util.console import bold  # type: ignore
50 from sphinx.util.i18n import CatalogRepository
51 from sphinx.util.logging import prefixed_warnings
52 from sphinx.util.osutil import abspath, ensuredir, relpath
53 from sphinx.util.tags import Tags
54 from sphinx.util.typing import RoleFunction, TitleGetter
55 
56 if False:
57     # For type annotation
58     from docutils.nodes import Node  # NOQA
59     from typing import Type  # for python3.5.1
60     from sphinx.builders import Builder
61 
62 
63 builtin_extensions = (
64     'sphinx.addnodes',
65     'sphinx.builders.changes',
66     'sphinx.builders.epub3',
67     'sphinx.builders.dirhtml',
68     'sphinx.builders.dummy',
69     'sphinx.builders.gettext',
70     'sphinx.builders.html',
71     'sphinx.builders.latex',
72     'sphinx.builders.linkcheck',
73     'sphinx.builders.manpage',
74     'sphinx.builders.singlehtml',
75     'sphinx.builders.texinfo',
76     'sphinx.builders.text',
77     'sphinx.builders.xml',
78     'sphinx.config',
79     'sphinx.domains.c',
80     'sphinx.domains.changeset',
81     'sphinx.domains.citation',
82     'sphinx.domains.cpp',
83     'sphinx.domains.index',
84     'sphinx.domains.javascript',
85     'sphinx.domains.math',
86     'sphinx.domains.python',
87     'sphinx.domains.rst',
88     'sphinx.domains.std',
89     'sphinx.directives',
90     'sphinx.directives.code',
91     'sphinx.directives.other',
92     'sphinx.directives.patches',
93     'sphinx.extension',
94     'sphinx.parsers',
95     'sphinx.registry',
96     'sphinx.roles',
97     'sphinx.transforms',
98     'sphinx.transforms.compact_bullet_list',
99     'sphinx.transforms.i18n',
100     'sphinx.transforms.references',
101     'sphinx.transforms.post_transforms',
102     'sphinx.transforms.post_transforms.code',
103     'sphinx.transforms.post_transforms.images',
104     'sphinx.util.compat',
105     'sphinx.versioning',
106     # collectors should be loaded by specific order
107     'sphinx.environment.collectors.dependencies',
108     'sphinx.environment.collectors.asset',
109     'sphinx.environment.collectors.metadata',
110     'sphinx.environment.collectors.title',
111     'sphinx.environment.collectors.toctree',
112     # 1st party extensions
113     'sphinxcontrib.applehelp',
114     'sphinxcontrib.devhelp',
115     'sphinxcontrib.htmlhelp',
116     'sphinxcontrib.serializinghtml',
117     'sphinxcontrib.qthelp',
118     # Strictly, alabaster theme is not a builtin extension,
119     # but it is loaded automatically to use it as default theme.
120     'alabaster',
121 )
122 
123 ENV_PICKLE_FILENAME = 'environment.pickle'
124 
125 logger = logging.getLogger(__name__)
126 
127 
128 class Sphinx:
129     """The main application class and extensibility interface.
130 
131     :ivar srcdir: Directory containing source.
132     :ivar confdir: Directory containing ``conf.py``.
133     :ivar doctreedir: Directory for storing pickled doctrees.
134     :ivar outdir: Directory for storing build documents.
135     """
136 
137     def __init__(self, srcdir: str, confdir: str, outdir: str, doctreedir: str,
138                  buildername: str, confoverrides: Dict = None,
139                  status: IO = sys.stdout, warning: IO = sys.stderr,
140                  freshenv: bool = False, warningiserror: bool = False, tags: List[str] = None,
141                  verbosity: int = 0, parallel: int = 0, keep_going: bool = False) -> None:
142         self.phase = BuildPhase.INITIALIZATION
143         self.verbosity = verbosity
144         self.extensions = {}                    # type: Dict[str, Extension]
145         self.builder = None                     # type: Builder
146         self.env = None                         # type: BuildEnvironment
147         self.project = None                     # type: Project
148         self.registry = SphinxComponentRegistry()
149         self.html_themes = {}                   # type: Dict[str, str]
150 
151         # validate provided directories
152         self.srcdir = abspath(srcdir)
153         self.outdir = abspath(outdir)
154         self.doctreedir = abspath(doctreedir)
155         self.confdir = confdir
156         if self.confdir:  # confdir is optional
157             self.confdir = abspath(self.confdir)
158             if not path.isfile(path.join(self.confdir, 'conf.py')):
159                 raise ApplicationError(__("config directory doesn't contain a "
160                                           "conf.py file (%s)") % confdir)
161 
162         if not path.isdir(self.srcdir):
163             raise ApplicationError(__('Cannot find source directory (%s)') %
164                                    self.srcdir)
165 
166         if path.exists(self.outdir) and not path.isdir(self.outdir):
167             raise ApplicationError(__('Output directory (%s) is not a directory') %
168                                    self.srcdir)
169 
170         if self.srcdir == self.outdir:
171             raise ApplicationError(__('Source directory and destination '
172                                       'directory cannot be identical'))
173 
174         self.parallel = parallel
175 
176         if status is None:
177             self._status = StringIO()      # type: IO
178             self.quiet = True
179         else:
180             self._status = status
181             self.quiet = False
182 
183         if warning is None:
184             self._warning = StringIO()     # type: IO
185         else:
186             self._warning = warning
187         self._warncount = 0
188         self.keep_going = warningiserror and keep_going
189         if self.keep_going:
190             self.warningiserror = False
191         else:
192             self.warningiserror = warningiserror
193         logging.setup(self, self._status, self._warning)
194 
195         self.events = EventManager(self)
196 
197         # keep last few messages for traceback
198         # This will be filled by sphinx.util.logging.LastMessagesWriter
199         self.messagelog = deque(maxlen=10)  # type: deque
200 
201         # say hello to the world
202         logger.info(bold(__('Running Sphinx v%s') % sphinx.__display_version__))
203 
204         # notice for parallel build on macOS and py38+
205         if sys.version_info > (3, 8) and platform.system() == 'Darwin' and parallel > 1:
206             logger.info(bold(__("For security reason, parallel mode is disabled on macOS and "
207                                 "python3.8 and above.  For more details, please read "
208                                 "https://github.com/sphinx-doc/sphinx/issues/6803")))
209 
210         # status code for command-line application
211         self.statuscode = 0
212 
213         # read config
214         self.tags = Tags(tags)
215         if self.confdir is None:
216             self.config = Config({}, confoverrides or {})
217         else:
218             self.config = Config.read(self.confdir, confoverrides or {}, self.tags)
219 
220         # initialize some limited config variables before initialize i18n and loading
221         # extensions
222         self.config.pre_init_values()
223 
224         # set up translation infrastructure
225         self._init_i18n()
226 
227         # check the Sphinx version if requested
228         if self.config.needs_sphinx and self.config.needs_sphinx > sphinx.__display_version__:
229             raise VersionRequirementError(
230                 __('This project needs at least Sphinx v%s and therefore cannot '
231                    'be built with this version.') % self.config.needs_sphinx)
232 
233         # set confdir to srcdir if -C given (!= no confdir); a few pieces
234         # of code expect a confdir to be set
235         if self.confdir is None:
236             self.confdir = self.srcdir
237 
238         # load all built-in extension modules
239         for extension in builtin_extensions:
240             self.setup_extension(extension)
241 
242         # load all user-given extension modules
243         for extension in self.config.extensions:
244             self.setup_extension(extension)
245 
246         # preload builder module (before init config values)
247         self.preload_builder(buildername)
248 
249         if not path.isdir(outdir):
250             with progress_message(__('making output directory')):
251                 ensuredir(outdir)
252 
253         # the config file itself can be an extension
254         if self.config.setup:
255             prefix = __('while setting up extension %s:') % "conf.py"
256             with prefixed_warnings(prefix):
257                 if callable(self.config.setup):
258                     self.config.setup(self)
259                 else:
260                     raise ConfigError(
261                         __("'setup' as currently defined in conf.py isn't a Python callable. "
262                            "Please modify its definition to make it a callable function. "
263                            "This is needed for conf.py to behave as a Sphinx extension.")
264                     )
265 
266         # now that we know all config values, collect them from conf.py
267         self.config.init_values()
268         self.events.emit('config-inited', self.config)
269 
270         # create the project
271         self.project = Project(self.srcdir, self.config.source_suffix)
272         # create the builder
273         self.builder = self.create_builder(buildername)
274         # set up the build environment
275         self._init_env(freshenv)
276         # set up the builder
277         self._init_builder()
278 
279     def _init_i18n(self) -> None:
280         """Load translated strings from the configured localedirs if enabled in
281         the configuration.
282         """
283         if self.config.language is None:
284             self.translator, has_translation = locale.init([], None)
285         else:
286             logger.info(bold(__('loading translations [%s]... ') % self.config.language),
287                         nonl=True)
288 
289             # compile mo files if sphinx.po file in user locale directories are updated
290             repo = CatalogRepository(self.srcdir, self.config.locale_dirs,
291                                      self.config.language, self.config.source_encoding)
292             for catalog in repo.catalogs:
293                 if catalog.domain == 'sphinx' and catalog.is_outdated():
294                     catalog.write_mo(self.config.language)
295 
296             locale_dirs = [None, path.join(package_dir, 'locale')] + list(repo.locale_dirs)
297             self.translator, has_translation = locale.init(locale_dirs, self.config.language)
298             if has_translation or self.config.language == 'en':
299                 # "en" never needs to be translated
300                 logger.info(__('done'))
301             else:
302                 logger.info(__('not available for built-in messages'))
303 
304     def _init_env(self, freshenv: bool) -> None:
305         filename = path.join(self.doctreedir, ENV_PICKLE_FILENAME)
306         if freshenv or not os.path.exists(filename):
307             self.env = BuildEnvironment()
308             self.env.setup(self)
309             self.env.find_files(self.config, self.builder)
310         else:
311             try:
312                 with progress_message(__('loading pickled environment')):
313                     with open(filename, 'rb') as f:
314                         self.env = pickle.load(f)
315                         self.env.setup(self)
316             except Exception as err:
317                 logger.info(__('failed: %s'), err)
318                 self._init_env(freshenv=True)
319 
320     def preload_builder(self, name: str) -> None:
321         self.registry.preload_builder(self, name)
322 
323     def create_builder(self, name: str) -> "Builder":
324         if name is None:
325             logger.info(__('No builder selected, using default: html'))
326             name = 'html'
327 
328         return self.registry.create_builder(self, name)
329 
330     def _init_builder(self) -> None:
331         self.builder.set_environment(self.env)
332         self.builder.init()
333         self.events.emit('builder-inited')
334 
335     # ---- main "build" method -------------------------------------------------
336 
337     def build(self, force_all: bool = False, filenames: List[str] = None) -> None:
338         self.phase = BuildPhase.READING
339         try:
340             if force_all:
341                 self.builder.compile_all_catalogs()
342                 self.builder.build_all()
343             elif filenames:
344                 self.builder.compile_specific_catalogs(filenames)
345                 self.builder.build_specific(filenames)
346             else:
347                 self.builder.compile_update_catalogs()
348                 self.builder.build_update()
349 
350             if self._warncount and self.keep_going:
351                 self.statuscode = 1
352 
353             status = (__('succeeded') if self.statuscode == 0
354                       else __('finished with problems'))
355             if self._warncount:
356                 if self.warningiserror:
357                     if self._warncount == 1:
358                         msg = __('build %s, %s warning (with warnings treated as errors).')
359                     else:
360                         msg = __('build %s, %s warnings (with warnings treated as errors).')
361                 else:
362                     if self._warncount == 1:
363                         msg = __('build %s, %s warning.')
364                     else:
365                         msg = __('build %s, %s warnings.')
366 
367                 logger.info(bold(msg % (status, self._warncount)))
368             else:
369                 logger.info(bold(__('build %s.') % status))
370 
371             if self.statuscode == 0 and self.builder.epilog:
372                 logger.info('')
373                 logger.info(self.builder.epilog % {
374                     'outdir': relpath(self.outdir),
375                     'project': self.config.project
376                 })
377         except Exception as err:
378             # delete the saved env to force a fresh build next time
379             envfile = path.join(self.doctreedir, ENV_PICKLE_FILENAME)
380             if path.isfile(envfile):
381                 os.unlink(envfile)
382             self.events.emit('build-finished', err)
383             raise
384         else:
385             self.events.emit('build-finished', None)
386         self.builder.cleanup()
387 
388     # ---- general extensibility interface -------------------------------------
389 
390     def setup_extension(self, extname: str) -> None:
391         """Import and setup a Sphinx extension module.
392 
393         Load the extension given by the module *name*.  Use this if your
394         extension needs the features provided by another extension.  No-op if
395         called twice.
396         """
397         logger.debug('[app] setting up extension: %r', extname)
398         self.registry.load_extension(self, extname)
399 
400     def require_sphinx(self, version: str) -> None:
401         """Check the Sphinx version if requested.
402 
403         Compare *version* (which must be a ``major.minor`` version string, e.g.
404         ``'1.1'``) with the version of the running Sphinx, and abort the build
405         when it is too old.
406 
407         .. versionadded:: 1.0
408         """
409         if version > sphinx.__display_version__[:3]:
410             raise VersionRequirementError(version)
411 
412     # event interface
413     def connect(self, event: str, callback: Callable, priority: int = 500) -> int:
414         """Register *callback* to be called when *event* is emitted.
415 
416         For details on available core events and the arguments of callback
417         functions, please see :ref:`events`.
418 
419         Registered callbacks will be invoked on event in the order of *priority* and
420         registration.  The priority is ascending order.
421 
422         The method returns a "listener ID" that can be used as an argument to
423         :meth:`disconnect`.
424 
425         .. versionchanged:: 3.0
426 
427            Support *priority*
428         """
429         listener_id = self.events.connect(event, callback, priority)
430         logger.debug('[app] connecting event %r (%d): %r [id=%s]',
431                      event, priority, callback, listener_id)
432         return listener_id
433 
434     def disconnect(self, listener_id: int) -> None:
435         """Unregister callback by *listener_id*."""
436         logger.debug('[app] disconnecting event: [id=%s]', listener_id)
437         self.events.disconnect(listener_id)
438 
439     def emit(self, event: str, *args: Any) -> List:
440         """Emit *event* and pass *arguments* to the callback functions.
441 
442         Return the return values of all callbacks as a list.  Do not emit core
443         Sphinx events in extensions!
444         """
445         return self.events.emit(event, *args)
446 
447     def emit_firstresult(self, event: str, *args: Any) -> Any:
448         """Emit *event* and pass *arguments* to the callback functions.
449 
450         Return the result of the first callback that doesn't return ``None``.
451 
452         .. versionadded:: 0.5
453         """
454         return self.events.emit_firstresult(event, *args)
455 
456     # registering addon parts
457 
458     def add_builder(self, builder: "Type[Builder]", override: bool = False) -> None:
459         """Register a new builder.
460 
461         *builder* must be a class that inherits from
462         :class:`~sphinx.builders.Builder`.
463 
464         .. versionchanged:: 1.8
465            Add *override* keyword.
466         """
467         self.registry.add_builder(builder, override=override)
468 
469     # TODO(stephenfin): Describe 'types' parameter
470     def add_config_value(self, name: str, default: Any, rebuild: Union[bool, str],
471                          types: Any = ()) -> None:
472         """Register a configuration value.
473 
474         This is necessary for Sphinx to recognize new values and set default
475         values accordingly.  The *name* should be prefixed with the extension
476         name, to avoid clashes.  The *default* value can be any Python object.
477         The string value *rebuild* must be one of those values:
478 
479         * ``'env'`` if a change in the setting only takes effect when a
480           document is parsed -- this means that the whole environment must be
481           rebuilt.
482         * ``'html'`` if a change in the setting needs a full rebuild of HTML
483           documents.
484         * ``''`` if a change in the setting will not need any special rebuild.
485 
486         .. versionchanged:: 0.6
487            Changed *rebuild* from a simple boolean (equivalent to ``''`` or
488            ``'env'``) to a string.  However, booleans are still accepted and
489            converted internally.
490 
491         .. versionchanged:: 0.4
492            If the *default* value is a callable, it will be called with the
493            config object as its argument in order to get the default value.
494            This can be used to implement config values whose default depends on
495            other values.
496         """
497         logger.debug('[app] adding config value: %r',
498                      (name, default, rebuild) + ((types,) if types else ()))
499         if rebuild in (False, True):
500             rebuild = 'env' if rebuild else ''
501         self.config.add(name, default, rebuild, types)
502 
503     def add_event(self, name: str) -> None:
504         """Register an event called *name*.
505 
506         This is needed to be able to emit it.
507         """
508         logger.debug('[app] adding event: %r', name)
509         self.events.add(name)
510 
511     def set_translator(self, name: str, translator_class: "Type[nodes.NodeVisitor]",
512                        override: bool = False) -> None:
513         """Register or override a Docutils translator class.
514 
515         This is used to register a custom output translator or to replace a
516         builtin translator.  This allows extensions to use custom translator
517         and define custom nodes for the translator (see :meth:`add_node`).
518 
519         .. versionadded:: 1.3
520         .. versionchanged:: 1.8
521            Add *override* keyword.
522         """
523         self.registry.add_translator(name, translator_class, override=override)
524 
525     def add_node(self, node: "Type[Element]", override: bool = False,
526                  **kwargs: Tuple[Callable, Callable]) -> None:
527         """Register a Docutils node class.
528 
529         This is necessary for Docutils internals.  It may also be used in the
530         future to validate nodes in the parsed documents.
531 
532         Node visitor functions for the Sphinx HTML, LaTeX, text and manpage
533         writers can be given as keyword arguments: the keyword should be one or
534         more of ``'html'``, ``'latex'``, ``'text'``, ``'man'``, ``'texinfo'``
535         or any other supported translators, the value a 2-tuple of ``(visit,
536         depart)`` methods.  ``depart`` can be ``None`` if the ``visit``
537         function raises :exc:`docutils.nodes.SkipNode`.  Example:
538 
539         .. code-block:: python
540 
541            class math(docutils.nodes.Element): pass
542 
543            def visit_math_html(self, node):
544                self.body.append(self.starttag(node, 'math'))
545            def depart_math_html(self, node):
546                self.body.append('</math>')
547 
548            app.add_node(math, html=(visit_math_html, depart_math_html))
549 
550         Obviously, translators for which you don't specify visitor methods will
551         choke on the node when encountered in a document to translate.
552 
553         .. versionchanged:: 0.5
554            Added the support for keyword arguments giving visit functions.
555         """
556         logger.debug('[app] adding node: %r', (node, kwargs))
557         if not override and docutils.is_node_registered(node):
558             logger.warning(__('node class %r is already registered, '
559                               'its visitors will be overridden'),
560                            node.__name__, type='app', subtype='add_node')
561         docutils.register_node(node)
562         self.registry.add_translation_handlers(node, **kwargs)
563 
564     def add_enumerable_node(self, node: "Type[Element]", figtype: str,
565                             title_getter: TitleGetter = None, override: bool = False,
566                             **kwargs: Tuple[Callable, Callable]) -> None:
567         """Register a Docutils node class as a numfig target.
568 
569         Sphinx numbers the node automatically. And then the users can refer it
570         using :rst:role:`numref`.
571 
572         *figtype* is a type of enumerable nodes.  Each figtypes have individual
573         numbering sequences.  As a system figtypes, ``figure``, ``table`` and
574         ``code-block`` are defined.  It is able to add custom nodes to these
575         default figtypes.  It is also able to define new custom figtype if new
576         figtype is given.
577 
578         *title_getter* is a getter function to obtain the title of node.  It
579         takes an instance of the enumerable node, and it must return its title
580         as string.  The title is used to the default title of references for
581         :rst:role:`ref`.  By default, Sphinx searches
582         ``docutils.nodes.caption`` or ``docutils.nodes.title`` from the node as
583         a title.
584 
585         Other keyword arguments are used for node visitor functions. See the
586         :meth:`.Sphinx.add_node` for details.
587 
588         .. versionadded:: 1.4
589         """
590         self.registry.add_enumerable_node(node, figtype, title_getter, override=override)
591         self.add_node(node, override=override, **kwargs)
592 
593     def add_directive(self, name: str, cls: "Type[Directive]", override: bool = False) -> None:
594         """Register a Docutils directive.
595 
596         *name* must be the prospective directive name.  *cls* is a directive
597         class which inherits ``docutils.parsers.rst.Directive``.  For more
598         details, see `the Docutils docs
599         <http://docutils.sourceforge.net/docs/howto/rst-directives.html>`_ .
600 
601         For example, the (already existing) :rst:dir:`literalinclude` directive
602         would be added like this:
603 
604         .. code-block:: python
605 
606            from docutils.parsers.rst import Directive, directives
607 
608            class LiteralIncludeDirective(Directive):
609                has_content = True
610                required_arguments = 1
611                optional_arguments = 0
612                final_argument_whitespace = True
613                option_spec = {
614                    'class': directives.class_option,
615                    'name': directives.unchanged,
616                }
617 
618                def run(self):
619                    ...
620 
621            add_directive('literalinclude', LiteralIncludeDirective)
622 
623         .. versionchanged:: 0.6
624            Docutils 0.5-style directive classes are now supported.
625         .. deprecated:: 1.8
626            Docutils 0.4-style (function based) directives support is deprecated.
627         .. versionchanged:: 1.8
628            Add *override* keyword.
629         """
630         logger.debug('[app] adding directive: %r', (name, cls))
631         if not override and docutils.is_directive_registered(name):
632             logger.warning(__('directive %r is already registered, it will be overridden'),
633                            name, type='app', subtype='add_directive')
634 
635         docutils.register_directive(name, cls)
636 
637     def add_role(self, name: str, role: Any, override: bool = False) -> None:
638         """Register a Docutils role.
639 
640         *name* must be the role name that occurs in the source, *role* the role
641         function. Refer to the `Docutils documentation
642         <http://docutils.sourceforge.net/docs/howto/rst-roles.html>`_ for
643         more information.
644 
645         .. versionchanged:: 1.8
646            Add *override* keyword.
647         """
648         logger.debug('[app] adding role: %r', (name, role))
649         if not override and docutils.is_role_registered(name):
650             logger.warning(__('role %r is already registered, it will be overridden'),
651                            name, type='app', subtype='add_role')
652         docutils.register_role(name, role)
653 
654     def add_generic_role(self, name: str, nodeclass: Any, override: bool = False) -> None:
655         """Register a generic Docutils role.
656 
657         Register a Docutils role that does nothing but wrap its contents in the
658         node given by *nodeclass*.
659 
660         .. versionadded:: 0.6
661         .. versionchanged:: 1.8
662            Add *override* keyword.
663         """
664         # Don't use ``roles.register_generic_role`` because it uses
665         # ``register_canonical_role``.
666         logger.debug('[app] adding generic role: %r', (name, nodeclass))
667         if not override and docutils.is_role_registered(name):
668             logger.warning(__('role %r is already registered, it will be overridden'),
669                            name, type='app', subtype='add_generic_role')
670         role = roles.GenericRole(name, nodeclass)
671         docutils.register_role(name, role)
672 
673     def add_domain(self, domain: "Type[Domain]", override: bool = False) -> None:
674         """Register a domain.
675 
676         Make the given *domain* (which must be a class; more precisely, a
677         subclass of :class:`~sphinx.domains.Domain`) known to Sphinx.
678 
679         .. versionadded:: 1.0
680         .. versionchanged:: 1.8
681            Add *override* keyword.
682         """
683         self.registry.add_domain(domain, override=override)
684 
685     def add_directive_to_domain(self, domain: str, name: str,
686                                 cls: "Type[Directive]", override: bool = False) -> None:
687         """Register a Docutils directive in a domain.
688 
689         Like :meth:`add_directive`, but the directive is added to the domain
690         named *domain*.
691 
692         .. versionadded:: 1.0
693         .. versionchanged:: 1.8
694            Add *override* keyword.
695         """
696         self.registry.add_directive_to_domain(domain, name, cls, override=override)
697 
698     def add_role_to_domain(self, domain: str, name: str, role: Union[RoleFunction, XRefRole],
699                            override: bool = False) -> None:
700         """Register a Docutils role in a domain.
701 
702         Like :meth:`add_role`, but the role is added to the domain named
703         *domain*.
704 
705         .. versionadded:: 1.0
706         .. versionchanged:: 1.8
707            Add *override* keyword.
708         """
709         self.registry.add_role_to_domain(domain, name, role, override=override)
710 
711     def add_index_to_domain(self, domain: str, index: "Type[Index]", override: bool = False
712                             ) -> None:
713         """Register a custom index for a domain.
714 
715         Add a custom *index* class to the domain named *domain*.  *index* must
716         be a subclass of :class:`~sphinx.domains.Index`.
717 
718         .. versionadded:: 1.0
719         .. versionchanged:: 1.8
720            Add *override* keyword.
721         """
722         self.registry.add_index_to_domain(domain, index)
723 
724     def add_object_type(self, directivename: str, rolename: str, indextemplate: str = '',
725                         parse_node: Callable = None, ref_nodeclass: "Type[TextElement]" = None,
726                         objname: str = '', doc_field_types: List = [], override: bool = False
727                         ) -> None:
728         """Register a new object type.
729 
730         This method is a very convenient way to add a new :term:`object` type
731         that can be cross-referenced.  It will do this:
732 
733         - Create a new directive (called *directivename*) for documenting an
734           object.  It will automatically add index entries if *indextemplate*
735           is nonempty; if given, it must contain exactly one instance of
736           ``%s``.  See the example below for how the template will be
737           interpreted.
738         - Create a new role (called *rolename*) to cross-reference to these
739           object descriptions.
740         - If you provide *parse_node*, it must be a function that takes a
741           string and a docutils node, and it must populate the node with
742           children parsed from the string.  It must then return the name of the
743           item to be used in cross-referencing and index entries.  See the
744           :file:`conf.py` file in the source for this documentation for an
745           example.
746         - The *objname* (if not given, will default to *directivename*) names
747           the type of object.  It is used when listing objects, e.g. in search
748           results.
749 
750         For example, if you have this call in a custom Sphinx extension::
751 
752            app.add_object_type('directive', 'dir', 'pair: %s; directive')
753 
754         you can use this markup in your documents::
755 
756            .. rst:directive:: function
757 
758               Document a function.
759 
760            <...>
761 
762            See also the :rst:dir:`function` directive.
763 
764         For the directive, an index entry will be generated as if you had prepended ::
765 
766            .. index:: pair: function; directive
767 
768         The reference node will be of class ``literal`` (so it will be rendered
769         in a proportional font, as appropriate for code) unless you give the
770         *ref_nodeclass* argument, which must be a docutils node class.  Most
771         useful are ``docutils.nodes.emphasis`` or ``docutils.nodes.strong`` --
772         you can also use ``docutils.nodes.generated`` if you want no further
773         text decoration.  If the text should be treated as literal (e.g. no
774         smart quote replacement), but not have typewriter styling, use
775         ``sphinx.addnodes.literal_emphasis`` or
776         ``sphinx.addnodes.literal_strong``.
777 
778         For the role content, you have the same syntactical possibilities as
779         for standard Sphinx roles (see :ref:`xref-syntax`).
780 
781         .. versionchanged:: 1.8
782            Add *override* keyword.
783         """
784         self.registry.add_object_type(directivename, rolename, indextemplate, parse_node,
785                                       ref_nodeclass, objname, doc_field_types,
786                                       override=override)
787 
788     def add_crossref_type(self, directivename: str, rolename: str, indextemplate: str = '',
789                           ref_nodeclass: "Type[TextElement]" = None, objname: str = '',
790                           override: bool = False) -> None:
791         """Register a new crossref object type.
792 
793         This method is very similar to :meth:`add_object_type` except that the
794         directive it generates must be empty, and will produce no output.
795 
796         That means that you can add semantic targets to your sources, and refer
797         to them using custom roles instead of generic ones (like
798         :rst:role:`ref`).  Example call::
799 
800            app.add_crossref_type('topic', 'topic', 'single: %s',
801                                  docutils.nodes.emphasis)
802 
803         Example usage::
804 
805            .. topic:: application API
806 
807            The application API
808            -------------------
809 
810            Some random text here.
811 
812            See also :topic:`this section <application API>`.
813 
814         (Of course, the element following the ``topic`` directive needn't be a
815         section.)
816 
817         .. versionchanged:: 1.8
818            Add *override* keyword.
819         """
820         self.registry.add_crossref_type(directivename, rolename,
821                                         indextemplate, ref_nodeclass, objname,
822                                         override=override)
823 
824     def add_transform(self, transform: "Type[Transform]") -> None:
825         """Register a Docutils transform to be applied after parsing.
826 
827         Add the standard docutils :class:`Transform` subclass *transform* to
828         the list of transforms that are applied after Sphinx parses a reST
829         document.
830 
831         .. list-table:: priority range categories for Sphinx transforms
832            :widths: 20,80
833 
834            * - Priority
835              - Main purpose in Sphinx
836            * - 0-99
837              - Fix invalid nodes by docutils. Translate a doctree.
838            * - 100-299
839              - Preparation
840            * - 300-399
841              - early
842            * - 400-699
843              - main
844            * - 700-799
845              - Post processing. Deadline to modify text and referencing.
846            * - 800-899
847              - Collect referencing and referenced nodes. Domain processing.
848            * - 900-999
849              - Finalize and clean up.
850 
851         refs: `Transform Priority Range Categories`__
852 
853         __ http://docutils.sourceforge.net/docs/ref/transforms.html#transform-priority-range-categories
854         """  # NOQA
855         self.registry.add_transform(transform)
856 
857     def add_post_transform(self, transform: "Type[Transform]") -> None:
858         """Register a Docutils transform to be applied before writing.
859 
860         Add the standard docutils :class:`Transform` subclass *transform* to
861         the list of transforms that are applied before Sphinx writes a
862         document.
863         """
864         self.registry.add_post_transform(transform)
865 
866     def add_javascript(self, filename: str, **kwargs: str) -> None:
867         """An alias of :meth:`add_js_file`."""
868         warnings.warn('The app.add_javascript() is deprecated. '
869                       'Please use app.add_js_file() instead.',
870                       RemovedInSphinx40Warning, stacklevel=2)
871         self.add_js_file(filename, **kwargs)
872 
873     def add_js_file(self, filename: str, **kwargs: str) -> None:
874         """Register a JavaScript file to include in the HTML output.
875 
876         Add *filename* to the list of JavaScript files that the default HTML
877         template will include.  The filename must be relative to the HTML
878         static path , or a full URI with scheme.  If the keyword argument
879         ``body`` is given, its value will be added between the
880         ``<script>`` tags. Extra keyword arguments are included as
881         attributes of the ``<script>`` tag.
882 
883         Example::
884 
885             app.add_js_file('example.js')
886             # => <script src="_static/example.js"></script>
887 
888             app.add_js_file('example.js', async="async")
889             # => <script src="_static/example.js" async="async"></script>
890 
891             app.add_js_file(None, body="var myVariable = 'foo';")
892             # => <script>var myVariable = 'foo';</script>
893 
894         .. versionadded:: 0.5
895 
896         .. versionchanged:: 1.8
897            Renamed from ``app.add_javascript()``.
898            And it allows keyword arguments as attributes of script tag.
899         """
900         self.registry.add_js_file(filename, **kwargs)
901         if hasattr(self.builder, 'add_js_file'):
902             self.builder.add_js_file(filename, **kwargs)  # type: ignore
903 
904     def add_css_file(self, filename: str, **kwargs: str) -> None:
905         """Register a stylesheet to include in the HTML output.
906 
907         Add *filename* to the list of CSS files that the default HTML template
908         will include.  The filename must be relative to the HTML static path,
909         or a full URI with scheme.  The keyword arguments are also accepted for
910         attributes of ``<link>`` tag.
911 
912         Example::
913 
914             app.add_css_file('custom.css')
915             # => <link rel="stylesheet" href="_static/custom.css" type="text/css" />
916 
917             app.add_css_file('print.css', media='print')
918             # => <link rel="stylesheet" href="_static/print.css"
919             #          type="text/css" media="print" />
920 
921             app.add_css_file('fancy.css', rel='alternate stylesheet', title='fancy')
922             # => <link rel="alternate stylesheet" href="_static/fancy.css"
923             #          type="text/css" title="fancy" />
924 
925         .. versionadded:: 1.0
926 
927         .. versionchanged:: 1.6
928            Optional ``alternate`` and/or ``title`` attributes can be supplied
929            with the *alternate* (of boolean type) and *title* (a string)
930            arguments. The default is no title and *alternate* = ``False``. For
931            more information, refer to the `documentation
932            <https://mdn.io/Web/CSS/Alternative_style_sheets>`__.
933 
934         .. versionchanged:: 1.8
935            Renamed from ``app.add_stylesheet()``.
936            And it allows keyword arguments as attributes of link tag.
937         """
938         logger.debug('[app] adding stylesheet: %r', filename)
939         self.registry.add_css_files(filename, **kwargs)
940         if hasattr(self.builder, 'add_css_file'):
941             self.builder.add_css_file(filename, **kwargs)  # type: ignore
942 
943     def add_stylesheet(self, filename: str, alternate: bool = False, title: str = None
944                        ) -> None:
945         """An alias of :meth:`add_css_file`."""
946         warnings.warn('The app.add_stylesheet() is deprecated. '
947                       'Please use app.add_css_file() instead.',
948                       RemovedInSphinx40Warning, stacklevel=2)
949 
950         attributes = {}  # type: Dict[str, str]
951         if alternate:
952             attributes['rel'] = 'alternate stylesheet'
953         else:
954             attributes['rel'] = 'stylesheet'
955 
956         if title:
957             attributes['title'] = title
958 
959         self.add_css_file(filename, **attributes)
960 
961     def add_latex_package(self, packagename: str, options: str = None) -> None:
962         r"""Register a package to include in the LaTeX source code.
963 
964         Add *packagename* to the list of packages that LaTeX source code will
965         include.  If you provide *options*, it will be taken to `\usepackage`
966         declaration.
967 
968         .. code-block:: python
969 
970            app.add_latex_package('mypackage')
971            # => \usepackage{mypackage}
972            app.add_latex_package('mypackage', 'foo,bar')
973            # => \usepackage[foo,bar]{mypackage}
974 
975         .. versionadded:: 1.3
976         """
977         self.registry.add_latex_package(packagename, options)
978 
979     def add_lexer(self, alias: str, lexer: Union[Lexer, "Type[Lexer]"]) -> None:
980         """Register a new lexer for source code.
981 
982         Use *lexer* to highlight code blocks with the given language *alias*.
983 
984         .. versionadded:: 0.6
985         .. versionchanged:: 2.1
986            Take a lexer class as an argument.  An instance of lexers are
987            still supported until Sphinx-3.x.
988         """
989         logger.debug('[app] adding lexer: %r', (alias, lexer))
990         if isinstance(lexer, Lexer):
991             warnings.warn('app.add_lexer() API changed; '
992                           'Please give lexer class instead instance',
993                           RemovedInSphinx40Warning)
994             lexers[alias] = lexer
995         else:
996             lexer_classes[alias] = lexer
997 
998     def add_autodocumenter(self, cls: Any, override: bool = False) -> None:
999         """Register a new documenter class for the autodoc extension.
1000 
1001         Add *cls* as a new documenter class for the :mod:`sphinx.ext.autodoc`
1002         extension.  It must be a subclass of
1003         :class:`sphinx.ext.autodoc.Documenter`.  This allows to auto-document
1004         new types of objects.  See the source of the autodoc module for
1005         examples on how to subclass :class:`Documenter`.
1006 
1007         .. todo:: Add real docs for Documenter and subclassing
1008 
1009         .. versionadded:: 0.6
1010         .. versionchanged:: 2.2
1011            Add *override* keyword.
1012         """
1013         logger.debug('[app] adding autodocumenter: %r', cls)
1014         from sphinx.ext.autodoc.directive import AutodocDirective
1015         self.registry.add_documenter(cls.objtype, cls)
1016         self.add_directive('auto' + cls.objtype, AutodocDirective, override=override)
1017 
1018     def add_autodoc_attrgetter(self, typ: "Type", getter: Callable[[Any, str, Any], Any]
1019                                ) -> None:
1020         """Register a new ``getattr``-like function for the autodoc extension.
1021 
1022         Add *getter*, which must be a function with an interface compatible to
1023         the :func:`getattr` builtin, as the autodoc attribute getter for
1024         objects that are instances of *typ*.  All cases where autodoc needs to
1025         get an attribute of a type are then handled by this function instead of
1026         :func:`getattr`.
1027 
1028         .. versionadded:: 0.6
1029         """
1030         logger.debug('[app] adding autodoc attrgetter: %r', (typ, getter))
1031         self.registry.add_autodoc_attrgetter(typ, getter)
1032 
1033     def add_search_language(self, cls: Any) -> None:
1034         """Register a new language for the HTML search index.
1035 
1036         Add *cls*, which must be a subclass of
1037         :class:`sphinx.search.SearchLanguage`, as a support language for
1038         building the HTML full-text search index.  The class must have a *lang*
1039         attribute that indicates the language it should be used for.  See
1040         :confval:`html_search_language`.
1041 
1042         .. versionadded:: 1.1
1043         """
1044         logger.debug('[app] adding search language: %r', cls)
1045         from sphinx.search import languages, SearchLanguage
1046         assert issubclass(cls, SearchLanguage)
1047         languages[cls.lang] = cls
1048 
1049     def add_source_suffix(self, suffix: str, filetype: str, override: bool = False) -> None:
1050         """Register a suffix of source files.
1051 
1052         Same as :confval:`source_suffix`.  The users can override this
1053         using the setting.
1054 
1055         .. versionadded:: 1.8
1056         """
1057         self.registry.add_source_suffix(suffix, filetype, override=override)
1058 
1059     def add_source_parser(self, *args: Any, **kwargs: Any) -> None:
1060         """Register a parser class.
1061 
1062         .. versionadded:: 1.4
1063         .. versionchanged:: 1.8
1064            *suffix* argument is deprecated.  It only accepts *parser* argument.
1065            Use :meth:`add_source_suffix` API to register suffix instead.
1066         .. versionchanged:: 1.8
1067            Add *override* keyword.
1068         """
1069         self.registry.add_source_parser(*args, **kwargs)
1070 
1071     def add_env_collector(self, collector: "Type[EnvironmentCollector]") -> None:
1072         """Register an environment collector class.
1073 
1074         Refer to :ref:`collector-api`.
1075 
1076         .. versionadded:: 1.6
1077         """
1078         logger.debug('[app] adding environment collector: %r', collector)
1079         collector().enable(self)
1080 
1081     def add_html_theme(self, name: str, theme_path: str) -> None:
1082         """Register a HTML Theme.
1083 
1084         The *name* is a name of theme, and *path* is a full path to the theme
1085         (refs: :ref:`distribute-your-theme`).
1086 
1087         .. versionadded:: 1.6
1088         """
1089         logger.debug('[app] adding HTML theme: %r, %r', name, theme_path)
1090         self.html_themes[name] = theme_path
1091 
1092     def add_html_math_renderer(self, name: str,
1093                                inline_renderers: Tuple[Callable, Callable] = None,
1094                                block_renderers: Tuple[Callable, Callable] = None) -> None:
1095         """Register a math renderer for HTML.
1096 
1097         The *name* is a name of math renderer.  Both *inline_renderers* and
1098         *block_renderers* are used as visitor functions for the HTML writer:
1099         the former for inline math node (``nodes.math``), the latter for
1100         block math node (``nodes.math_block``).  Regarding visitor functions,
1101         see :meth:`add_node` for details.
1102 
1103         .. versionadded:: 1.8
1104 
1105         """
1106         self.registry.add_html_math_renderer(name, inline_renderers, block_renderers)
1107 
1108     def add_message_catalog(self, catalog: str, locale_dir: str) -> None:
1109         """Register a message catalog.
1110 
1111         The *catalog* is a name of catalog, and *locale_dir* is a base path
1112         of message catalog.  For more details, see
1113         :func:`sphinx.locale.get_translation()`.
1114 
1115         .. versionadded:: 1.8
1116         """
1117         locale.init([locale_dir], self.config.language, catalog)
1118         locale.init_console(locale_dir, catalog)
1119 
1120     # ---- other methods -------------------------------------------------
1121     def is_parallel_allowed(self, typ: str) -> bool:
1122         """Check parallel processing is allowed or not.
1123 
1124         ``typ`` is a type of processing; ``'read'`` or ``'write'``.
1125         """
1126         if typ == 'read':
1127             attrname = 'parallel_read_safe'
1128             message_not_declared = __("the %s extension does not declare if it "
1129                                       "is safe for parallel reading, assuming "
1130                                       "it isn't - please ask the extension author "
1131                                       "to check and make it explicit")
1132             message_not_safe = __("the %s extension is not safe for parallel reading")
1133         elif typ == 'write':
1134             attrname = 'parallel_write_safe'
1135             message_not_declared = __("the %s extension does not declare if it "
1136                                       "is safe for parallel writing, assuming "
1137                                       "it isn't - please ask the extension author "
1138                                       "to check and make it explicit")
1139             message_not_safe = __("the %s extension is not safe for parallel writing")
1140         else:
1141             raise ValueError('parallel type %s is not supported' % typ)
1142 
1143         for ext in self.extensions.values():
1144             allowed = getattr(ext, attrname, None)
1145             if allowed is None:
1146                 logger.warning(message_not_declared, ext.name)
1147                 logger.warning(__('doing serial %s'), typ)
1148                 return False
1149             elif not allowed:
1150                 logger.warning(message_not_safe, ext.name)
1151                 logger.warning(__('doing serial %s'), typ)
1152                 return False
1153 
1154         return True
1155 
1156 
1157 class TemplateBridge:
1158     """
1159     This class defines the interface for a "template bridge", that is, a class
1160     that renders templates given a template name and a context.
1161     """
1162 
1163     def init(self, builder: "Builder", theme: Theme = None, dirs: List[str] = None) -> None:
1164         """Called by the builder to initialize the template system.
1165 
1166         *builder* is the builder object; you'll probably want to look at the
1167         value of ``builder.config.templates_path``.
1168 
1169         *theme* is a :class:`sphinx.theming.Theme` object or None; in the latter
1170         case, *dirs* can be list of fixed directories to look for templates.
1171         """
1172         raise NotImplementedError('must be implemented in subclasses')
1173 
1174     def newest_template_mtime(self) -> float:
1175         """Called by the builder to determine if output files are outdated
1176         because of template changes.  Return the mtime of the newest template
1177         file that was changed.  The default implementation returns ``0``.
1178         """
1179         return 0
1180 
1181     def render(self, template: str, context: Dict) -> None:
1182         """Called by the builder to render a template given as a filename with
1183         a specified context (a Python dictionary).
1184         """
1185         raise NotImplementedError('must be implemented in subclasses')
1186 
1187     def render_string(self, template: str, context: Dict) -> str:
1188         """Called by the builder to render a template given as a string with a
1189         specified context (a Python dictionary).
1190         """
1191         raise NotImplementedError('must be implemented in subclasses')

</code><intended_behavior>The application layer, which initializes and configures extensions, should include logic to prioritize file extensions when multiple sources with the same name but different extensions exist. This could be implemented either by enhancing existing methods or introducing a new method to filter and sort files based on a configurable priority list before including them in the build process. This priority list could be configured through the existing Sphinx configuration mechanisms, allowing users to specify their preference for `.md` over `.rst` or vice versa. It's essential that this change does not disrupt the current functionality for projects not requiring this feature.</intended_behavior>, <file>sphinx/config.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2     sphinx.config
3     ~~~~~~~~~~~~~
4 
5     Build configuration file handling.
6 
7     :copyright: Copyright 2007-2020 by the Sphinx team, see AUTHORS.
8     :license: BSD, see LICENSE for details.
9 """
10 
11 import re
12 import traceback
13 import types
14 import warnings
15 from collections import OrderedDict
16 from os import path, getenv
17 from typing import (
18     Any, Callable, Dict, Generator, Iterator, List, NamedTuple, Set, Tuple, Union
19 )
20 
21 from sphinx.deprecation import RemovedInSphinx40Warning
22 from sphinx.errors import ConfigError, ExtensionError
23 from sphinx.locale import _, __
24 from sphinx.util import logging
25 from sphinx.util.i18n import format_date
26 from sphinx.util.osutil import cd
27 from sphinx.util.pycompat import execfile_
28 from sphinx.util.tags import Tags
29 from sphinx.util.typing import NoneType
30 
31 if False:
32     # For type annotation
33     from sphinx.application import Sphinx
34     from sphinx.environment import BuildEnvironment
35 
36 logger = logging.getLogger(__name__)
37 
38 CONFIG_FILENAME = 'conf.py'
39 UNSERIALIZABLE_TYPES = (type, types.ModuleType, types.FunctionType)
40 copyright_year_re = re.compile(r'^((\d{4}-)?)(\d{4})(?=[ ,])')
41 
42 ConfigValue = NamedTuple('ConfigValue', [('name', str),
43                                          ('value', Any),
44                                          ('rebuild', Union[bool, str])])
45 
46 
47 def is_serializable(obj: Any) -> bool:
48     """Check if object is serializable or not."""
49     if isinstance(obj, UNSERIALIZABLE_TYPES):
50         return False
51     elif isinstance(obj, dict):
52         for key, value in obj.items():
53             if not is_serializable(key) or not is_serializable(value):
54                 return False
55     elif isinstance(obj, (list, tuple, set)):
56         return all(is_serializable(i) for i in obj)
57 
58     return True
59 
60 
61 class ENUM:
62     """represents the config value should be a one of candidates.
63 
64     Example:
65         app.add_config_value('latex_show_urls', 'no', None, ENUM('no', 'footnote', 'inline'))
66     """
67     def __init__(self, *candidates: str) -> None:
68         self.candidates = candidates
69 
70     def match(self, value: Union[str, List, Tuple]) -> bool:
71         if isinstance(value, (list, tuple)):
72             return all(item in self.candidates for item in value)
73         else:
74             return value in self.candidates
75 
76 
77 # RemovedInSphinx40Warning
78 string_classes = [str]  # type: List
79 
80 
81 class Config:
82     """Configuration file abstraction.
83 
84     The config object makes the values of all config values available as
85     attributes.
86 
87     It is exposed via the :py:attr:`sphinx.application.Application.config` and
88     :py:attr:`sphinx.environment.Environment.config` attributes. For example,
89     to get the value of :confval:`language`, use either ``app.config.language``
90     or ``env.config.language``.
91     """
92 
93     # the values are: (default, what needs to be rebuilt if changed)
94 
95     # If you add a value here, don't forget to include it in the
96     # quickstart.py file template as well as in the docs!
97 
98     config_values = {
99         # general options
100         'project': ('Python', 'env', []),
101         'author': ('unknown', 'env', []),
102         'copyright': ('', 'html', []),
103         'version': ('', 'env', []),
104         'release': ('', 'env', []),
105         'today': ('', 'env', []),
106         # the real default is locale-dependent
107         'today_fmt': (None, 'env', [str]),
108 
109         'language': (None, 'env', [str]),
110         'locale_dirs': (['locales'], 'env', []),
111         'figure_language_filename': ('{root}.{language}{ext}', 'env', [str]),
112 
113         'master_doc': ('index', 'env', []),
114         'source_suffix': ({'.rst': 'restructuredtext'}, 'env', Any),
115         'source_encoding': ('utf-8-sig', 'env', []),
116         'source_parsers': ({}, 'env', []),
117         'exclude_patterns': ([], 'env', []),
118         'default_role': (None, 'env', [str]),
119         'add_function_parentheses': (True, 'env', []),
120         'add_module_names': (True, 'env', []),
121         'trim_footnote_reference_space': (False, 'env', []),
122         'show_authors': (False, 'env', []),
123         'pygments_style': (None, 'html', [str]),
124         'highlight_language': ('default', 'env', []),
125         'highlight_options': ({}, 'env', []),
126         'templates_path': ([], 'html', []),
127         'template_bridge': (None, 'html', [str]),
128         'keep_warnings': (False, 'env', []),
129         'suppress_warnings': ([], 'env', []),
130         'modindex_common_prefix': ([], 'html', []),
131         'rst_epilog': (None, 'env', [str]),
132         'rst_prolog': (None, 'env', [str]),
133         'trim_doctest_flags': (True, 'env', []),
134         'primary_domain': ('py', 'env', [NoneType]),   # type: ignore
135         'needs_sphinx': (None, None, [str]),
136         'needs_extensions': ({}, None, []),
137         'manpages_url': (None, 'env', []),
138         'nitpicky': (False, None, []),
139         'nitpick_ignore': ([], None, []),
140         'numfig': (False, 'env', []),
141         'numfig_secnum_depth': (1, 'env', []),
142         'numfig_format': ({}, 'env', []),  # will be initialized in init_numfig_format()
143 
144         'math_number_all': (False, 'env', []),
145         'math_eqref_format': (None, 'env', [str]),
146         'math_numfig': (True, 'env', []),
147         'tls_verify': (True, 'env', []),
148         'tls_cacerts': (None, 'env', []),
149         'user_agent': (None, 'env', [str]),
150         'smartquotes': (True, 'env', []),
151         'smartquotes_action': ('qDe', 'env', []),
152         'smartquotes_excludes': ({'languages': ['ja'],
153                                   'builders': ['man', 'text']},
154                                  'env', []),
155     }  # type: Dict[str, Tuple]
156 
157     def __init__(self, config: Dict[str, Any] = {}, overrides: Dict[str, Any] = {}) -> None:
158         self.overrides = dict(overrides)
159         self.values = Config.config_values.copy()
160         self._raw_config = config
161         self.setup = config.get('setup', None)  # type: Callable
162 
163         if 'extensions' in self.overrides:
164             if isinstance(self.overrides['extensions'], str):
165                 config['extensions'] = self.overrides.pop('extensions').split(',')
166             else:
167                 config['extensions'] = self.overrides.pop('extensions')
168         self.extensions = config.get('extensions', [])  # type: List[str]
169 
170     @classmethod
171     def read(cls, confdir: str, overrides: Dict = None, tags: Tags = None) -> "Config":
172         """Create a Config object from configuration file."""
173         filename = path.join(confdir, CONFIG_FILENAME)
174         namespace = eval_config_file(filename, tags)
175         return cls(namespace, overrides or {})
176 
177     def convert_overrides(self, name: str, value: Any) -> Any:
178         if not isinstance(value, str):
179             return value
180         else:
181             defvalue = self.values[name][0]
182             if self.values[name][2] == Any:
183                 return value
184             elif type(defvalue) is bool or self.values[name][2] == [bool]:
185                 if value == '0':
186                     # given falsy string from command line option
187                     return False
188                 else:
189                     return bool(value)
190             elif isinstance(defvalue, dict):
191                 raise ValueError(__('cannot override dictionary config setting %r, '
192                                     'ignoring (use %r to set individual elements)') %
193                                  (name, name + '.key=value'))
194             elif isinstance(defvalue, list):
195                 return value.split(',')
196             elif isinstance(defvalue, int):
197                 try:
198                     return int(value)
199                 except ValueError:
200                     raise ValueError(__('invalid number %r for config value %r, ignoring') %
201                                      (value, name))
202             elif hasattr(defvalue, '__call__'):
203                 return value
204             elif defvalue is not None and not isinstance(defvalue, str):
205                 raise ValueError(__('cannot override config setting %r with unsupported '
206                                     'type, ignoring') % name)
207             else:
208                 return value
209 
210     def pre_init_values(self) -> None:
211         """
212         Initialize some limited config variables before initialize i18n and loading extensions
213         """
214         variables = ['needs_sphinx', 'suppress_warnings', 'language', 'locale_dirs']
215         for name in variables:
216             try:
217                 if name in self.overrides:
218                     self.__dict__[name] = self.convert_overrides(name, self.overrides[name])
219                 elif name in self._raw_config:
220                     self.__dict__[name] = self._raw_config[name]
221             except ValueError as exc:
222                 logger.warning("%s", exc)
223 
224     def init_values(self) -> None:
225         config = self._raw_config
226         for valname, value in self.overrides.items():
227             try:
228                 if '.' in valname:
229                     realvalname, key = valname.split('.', 1)
230                     config.setdefault(realvalname, {})[key] = value
231                     continue
232                 elif valname not in self.values:
233                     logger.warning(__('unknown config value %r in override, ignoring'),
234                                    valname)
235                     continue
236                 if isinstance(value, str):
237                     config[valname] = self.convert_overrides(valname, value)
238                 else:
239                     config[valname] = value
240             except ValueError as exc:
241                 logger.warning("%s", exc)
242         for name in config:
243             if name in self.values:
244                 self.__dict__[name] = config[name]
245 
246     def __getattr__(self, name: str) -> Any:
247         if name.startswith('_'):
248             raise AttributeError(name)
249         if name not in self.values:
250             raise AttributeError(__('No such config value: %s') % name)
251         default = self.values[name][0]
252         if hasattr(default, '__call__'):
253             return default(self)
254         return default
255 
256     def __getitem__(self, name: str) -> str:
257         return getattr(self, name)
258 
259     def __setitem__(self, name: str, value: Any) -> None:
260         setattr(self, name, value)
261 
262     def __delitem__(self, name: str) -> None:
263         delattr(self, name)
264 
265     def __contains__(self, name: str) -> bool:
266         return name in self.values
267 
268     def __iter__(self) -> Generator[ConfigValue, None, None]:
269         for name, value in self.values.items():
270             yield ConfigValue(name, getattr(self, name), value[1])
271 
272     def add(self, name: str, default: Any, rebuild: Union[bool, str], types: Any) -> None:
273         if name in self.values:
274             raise ExtensionError(__('Config value %r already present') % name)
275         else:
276             self.values[name] = (default, rebuild, types)
277 
278     def filter(self, rebuild: Union[str, List[str]]) -> Iterator[ConfigValue]:
279         if isinstance(rebuild, str):
280             rebuild = [rebuild]
281         return (value for value in self if value.rebuild in rebuild)
282 
283     def __getstate__(self) -> Dict:
284         """Obtains serializable data for pickling."""
285         # remove potentially pickling-problematic values from config
286         __dict__ = {}
287         for key, value in self.__dict__.items():
288             if key.startswith('_') or not is_serializable(value):
289                 pass
290             else:
291                 __dict__[key] = value
292 
293         # create a picklable copy of values list
294         __dict__['values'] = {}
295         for key, value in self.values.items():
296             real_value = getattr(self, key)
297             if not is_serializable(real_value):
298                 # omit unserializable value
299                 real_value = None
300 
301             # types column is also omitted
302             __dict__['values'][key] = (real_value, value[1], None)
303 
304         return __dict__
305 
306     def __setstate__(self, state: Dict) -> None:
307         self.__dict__.update(state)
308 
309 
310 def eval_config_file(filename: str, tags: Tags) -> Dict[str, Any]:
311     """Evaluate a config file."""
312     namespace = {}  # type: Dict[str, Any]
313     namespace['__file__'] = filename
314     namespace['tags'] = tags
315 
316     with cd(path.dirname(filename)):
317         # during executing config file, current dir is changed to ``confdir``.
318         try:
319             execfile_(filename, namespace)
320         except SyntaxError as err:
321             msg = __("There is a syntax error in your configuration file: %s\n")
322             raise ConfigError(msg % err)
323         except SystemExit:
324             msg = __("The configuration file (or one of the modules it imports) "
325                      "called sys.exit()")
326             raise ConfigError(msg)
327         except ConfigError:
328             # pass through ConfigError from conf.py as is.  It will be shown in console.
329             raise
330         except Exception:
331             msg = __("There is a programmable error in your configuration file:\n\n%s")
332             raise ConfigError(msg % traceback.format_exc())
333 
334     return namespace
335 
336 
337 def convert_source_suffix(app: "Sphinx", config: Config) -> None:
338     """This converts old styled source_suffix to new styled one.
339 
340     * old style: str or list
341     * new style: a dict which maps from fileext to filetype
342     """
343     source_suffix = config.source_suffix
344     if isinstance(source_suffix, str):
345         # if str, considers as default filetype (None)
346         #
347         # The default filetype is determined on later step.
348         # By default, it is considered as restructuredtext.
349         config.source_suffix = OrderedDict({source_suffix: None})  # type: ignore
350     elif isinstance(source_suffix, (list, tuple)):
351         # if list, considers as all of them are default filetype
352         config.source_suffix = OrderedDict([(s, None) for s in source_suffix])  # type: ignore  # NOQA
353     elif isinstance(source_suffix, dict):
354         # if dict, convert it to OrderedDict
355         config.source_suffix = OrderedDict(config.source_suffix)  # type: ignore
356     else:
357         logger.warning(__("The config value `source_suffix' expects "
358                           "a string, list of strings, or dictionary. "
359                           "But `%r' is given." % source_suffix))
360 
361 
362 def init_numfig_format(app: "Sphinx", config: Config) -> None:
363     """Initialize :confval:`numfig_format`."""
364     numfig_format = {'section': _('Section %s'),
365                      'figure': _('Fig. %s'),
366                      'table': _('Table %s'),
367                      'code-block': _('Listing %s')}
368 
369     # override default labels by configuration
370     numfig_format.update(config.numfig_format)
371     config.numfig_format = numfig_format  # type: ignore
372 
373 
374 def correct_copyright_year(app: "Sphinx", config: Config) -> None:
375     """correct values of copyright year that are not coherent with
376     the SOURCE_DATE_EPOCH environment variable (if set)
377 
378     See https://reproducible-builds.org/specs/source-date-epoch/
379     """
380     if getenv('SOURCE_DATE_EPOCH') is not None:
381         for k in ('copyright', 'epub_copyright'):
382             if k in config:
383                 replace = r'\g<1>%s' % format_date('%Y')
384                 config[k] = copyright_year_re.sub(replace, config[k])
385 
386 
387 def check_confval_types(app: "Sphinx", config: Config) -> None:
388     """check all values for deviation from the default value's type, since
389     that can result in TypeErrors all over the place NB.
390     """
391     for confval in config:
392         default, rebuild, annotations = config.values[confval.name]
393 
394         if hasattr(default, '__call__'):
395             default = default(config)  # evaluate default value
396         if default is None and not annotations:
397             continue  # neither inferrable nor expliclitly annotated types
398 
399         if annotations is Any:
400             # any type of value is accepted
401             pass
402         elif isinstance(annotations, ENUM):
403             if not annotations.match(confval.value):
404                 msg = __("The config value `{name}` has to be a one of {candidates}, "
405                          "but `{current}` is given.")
406                 logger.warning(msg.format(name=confval.name,
407                                           current=confval.value,
408                                           candidates=annotations.candidates))
409         else:
410             if type(confval.value) is type(default):
411                 continue
412             if type(confval.value) in annotations:
413                 continue
414 
415             common_bases = (set(type(confval.value).__bases__ + (type(confval.value),)) &
416                             set(type(default).__bases__))
417             common_bases.discard(object)
418             if common_bases:
419                 continue  # at least we share a non-trivial base class
420 
421             if annotations:
422                 msg = __("The config value `{name}' has type `{current.__name__}'; "
423                          "expected {permitted}.")
424                 wrapped_annotations = ["`{}'".format(c.__name__) for c in annotations]
425                 if len(wrapped_annotations) > 2:
426                     permitted = "{}, or {}".format(
427                         ", ".join(wrapped_annotations[:-1]),
428                         wrapped_annotations[-1])
429                 else:
430                     permitted = " or ".join(wrapped_annotations)
431                 logger.warning(msg.format(name=confval.name,
432                                           current=type(confval.value),
433                                           permitted=permitted))
434             else:
435                 msg = __("The config value `{name}' has type `{current.__name__}', "
436                          "defaults to `{default.__name__}'.")
437                 logger.warning(msg.format(name=confval.name,
438                                           current=type(confval.value),
439                                           default=type(default)))
440 
441 
442 def check_unicode(config: Config) -> None:
443     """check all string values for non-ASCII characters in bytestrings,
444     since that can result in UnicodeErrors all over the place
445     """
446     warnings.warn('sphinx.config.check_unicode() is deprecated.',
447                   RemovedInSphinx40Warning)
448 
449     nonascii_re = re.compile(br'[\x80-\xff]')
450 
451     for name, value in config._raw_config.items():
452         if isinstance(value, bytes) and nonascii_re.search(value):
453             logger.warning(__('the config value %r is set to a string with non-ASCII '
454                               'characters; this can lead to Unicode errors occurring. '
455                               'Please use Unicode strings, e.g. %r.'), name, 'Content')
456 
457 
458 def check_primary_domain(app: "Sphinx", config: Config) -> None:
459     primary_domain = config.primary_domain
460     if primary_domain and not app.registry.has_domain(primary_domain):
461         logger.warning(__('primary_domain %r not found, ignored.'), primary_domain)
462         config.primary_domain = None  # type: ignore
463 
464 
465 def check_master_doc(app: "Sphinx", env: "BuildEnvironment", added: Set[str],
466                      changed: Set[str], removed: Set[str]) -> Set[str]:
467     """Adjust master_doc to 'contents' to support an old project which does not have
468     no master_doc setting.
469     """
470     if (app.config.master_doc == 'index' and
471             'index' not in app.project.docnames and
472             'contents' in app.project.docnames):
473         logger.warning(__('Since v2.0, Sphinx uses "index" as master_doc by default. '
474                           'Please add "master_doc = \'contents\'" to your conf.py.'))
475         app.config.master_doc = "contents"  # type: ignore
476 
477     return changed
478 
479 
480 def setup(app: "Sphinx") -> Dict[str, Any]:
481     app.connect('config-inited', convert_source_suffix)
482     app.connect('config-inited', init_numfig_format)
483     app.connect('config-inited', correct_copyright_year)
484     app.connect('config-inited', check_confval_types)
485     app.connect('config-inited', check_primary_domain)
486     app.connect('env-get-outdated', check_master_doc)
487 
488     return {
489         'version': 'builtin',
490         'parallel_read_safe': True,
491         'parallel_write_safe': True,
492     }

</code><intended_behavior>This file is responsible for handling Sphinx configuration. An update here should introduce a new configuration option, e.g., `file_extension_priority`, which allows users to specify an ordered list of file extensions according to their priorities. This new configuration option should be documented and have default behavior that preserves the current functionality (e.g., an empty list or a list favoring Sphinx's default file extension handling), ensuring backward compatibility.</intended_behavior>]
2025-10-18 06:27:05.879 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-18 06:27:05.879 | INFO     | Search-only: skipping patch selection
2025-10-18 06:27:05.954 | INFO     | Task sphinx-doc__sphinx-7351 completed successfully.
2025-10-18 06:27:05.955 | INFO     | No patch generated. You can try running ACR again.
