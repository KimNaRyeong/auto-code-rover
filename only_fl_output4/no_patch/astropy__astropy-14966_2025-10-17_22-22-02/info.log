2025-10-17 22:22:02.880 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-17 22:22:06.786 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=441, output_tokens=12, cost=0.004770
2025-10-17 22:22:19.307 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=621, output_tokens=517, cost=0.021720
2025-10-17 22:22:20.336 | INFO     | registered non reproducing test 0
2025-10-17 22:22:32.768 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1927, output_tokens=594, cost=0.037090
2025-10-17 22:22:33.766 | INFO     | registered non reproducing test 1
2025-10-17 22:22:45.276 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1964, output_tokens=546, cost=0.036020
2025-10-17 22:22:46.265 | INFO     | registered non reproducing test 2
2025-10-17 22:22:46.265 | WARNING  | Failed to write a reproducer test; skipping reproducer tracing
2025-10-17 22:22:46.268 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 22:22:50.753 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=736, output_tokens=203, cost=0.013450
2025-10-17 22:22:50.760 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 22:22:52.844 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=557, output_tokens=49, cost=0.007040
2025-10-17 22:22:52.846 | DEBUG    | Extracted a valid json.
2025-10-17 22:22:52.846 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_class(\"QTable\")",
        "search_method_in_class(\"group_by\", \"QTable\")",
        "search_method(\"group_keys\")"
    ],
    "bug_locations": []
}
2025-10-17 22:22:52.875 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-17 22:22:52.876 | DEBUG    | <Agent search> Analyzing search results.
2025-10-17 22:23:02.086 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1180, output_tokens=402, cost=0.023860
2025-10-17 22:23:02.098 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 22:23:03.512 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1798, output_tokens=28, cost=0.018820
2025-10-17 22:23:03.515 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 22:23:05.955 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=382, output_tokens=47, cost=0.005230
2025-10-17 22:23:05.957 | DEBUG    | Extracted a valid json.
2025-10-17 22:23:05.957 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_class(\"Table\")",
        "search_method_in_class(\"group_by\", \"Table\")",
        "search_code(\"group_by\")"
    ],
    "bug_locations": []
}
2025-10-17 22:23:06.084 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-17 22:23:06.085 | DEBUG    | <Agent search> Analyzing search results.
2025-10-17 22:23:18.338 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=4906, output_tokens=551, cost=0.065590
2025-10-17 22:23:18.351 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 22:23:25.105 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=5673, output_tokens=270, cost=0.064830
2025-10-17 22:23:25.112 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 22:23:33.026 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=624, output_tokens=248, cost=0.013680
2025-10-17 22:23:33.027 | DEBUG    | Extracted a valid json.
2025-10-17 22:23:33.027 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations":[
        {
            "file": "astropy/table/table.py",
            "class": "Table",
            "method": "group_by",
            "intended_behavior": "Modify the `group_by` method to ensure that when grouping is performed on columns containing quantities, the resulting group keys still preserve their unit information. This may involve changes to how the grouping keys are generated, such that they include both the value and the unit of quantities. This change must ensure that for non-quantity columns, the existing functionality remains unchanged, maintaining backward compatibility and preserving the method's current behavior for all other data types."
        },
        {
            "file": "astropy/table/groups.py",
            "class": "",
            "method": "table_group_by",
            "intended_behavior": "This function should be modified or enhanced to correctly handle quantity columns by ensuring that units are not discarded during the process of grouping. To resolve the issue, this function needs to identify columns with quantity data and treat them such that their units are preserved in the group keys. This may require a mechanism to explicitly check and retain units when forming group keys from quantity columns."
        }
    ]
}
2025-10-17 22:23:33.044 | DEBUG    | Bug location extracted successfully: [<file>astropy/table/table.py</file>
<class>Table</class>
<method>group_by</method>
<code>
3822     def group_by(self, keys):
3823         """
3824         Group this table by the specified ``keys``.
3825 
3826         This effectively splits the table into groups which correspond to unique
3827         values of the ``keys`` grouping object.  The output is a new
3828         `~astropy.table.TableGroups` which contains a copy of this table but
3829         sorted by row according to ``keys``.
3830 
3831         The ``keys`` input to `group_by` can be specified in different ways:
3832 
3833           - String or list of strings corresponding to table column name(s)
3834           - Numpy array (homogeneous or structured) with same length as this table
3835           - `~astropy.table.Table` with same length as this table
3836 
3837         Parameters
3838         ----------
3839         keys : str, list of str, numpy array, or `~astropy.table.Table`
3840             Key grouping object
3841 
3842         Returns
3843         -------
3844         out : `~astropy.table.Table`
3845             New table with groups set
3846         """
3847         return groups.table_group_by(self, keys)

</code><intended_behavior>Modify the `group_by` method to ensure that when grouping is performed on columns containing quantities, the resulting group keys still preserve their unit information. This may involve changes to how the grouping keys are generated, such that they include both the value and the unit of quantities. This change must ensure that for non-quantity columns, the existing functionality remains unchanged, maintaining backward compatibility and preserving the method's current behavior for all other data types.</intended_behavior>, <file>astropy/table/table.py</file>
<class>Table</class>
<method>None</method>
<code>
566 class Table:
567     """A class to represent tables of heterogeneous data.
568 
569     `~astropy.table.Table` provides a class for heterogeneous tabular data.
570     A key enhancement provided by the `~astropy.table.Table` class over
571     e.g. a `numpy` structured array is the ability to easily modify the
572     structure of the table by adding or removing columns, or adding new
573     rows of data.  In addition table and column metadata are fully supported.
574 
575     `~astropy.table.Table` differs from `~astropy.nddata.NDData` by the
576     assumption that the input data consists of columns of homogeneous data,
577     where each column has a unique identifier and may contain additional
578     metadata such as the data unit, format, and description.
579 
580     See also: https://docs.astropy.org/en/stable/table/
581 
582     Parameters
583     ----------
584     data : numpy ndarray, dict, list, table-like object, optional
585         Data to initialize table.
586     masked : bool, optional
587         Specify whether the table is masked.
588     names : list, optional
589         Specify column names.
590     dtype : list, optional
591         Specify column data types.
592     meta : dict, optional
593         Metadata associated with the table.
594     copy : bool, optional
595         Copy the input data. If the input is a Table the ``meta`` is always
596         copied regardless of the ``copy`` parameter.
597         Default is True.
598     rows : numpy ndarray, list of list, optional
599         Row-oriented data for table instead of ``data`` argument.
600     copy_indices : bool, optional
601         Copy any indices in the input data. Default is True.
602     units : list, dict, optional
603         List or dict of units to apply to columns.
604     descriptions : list, dict, optional
605         List or dict of descriptions to apply to columns.
606     **kwargs : dict, optional
607         Additional keyword args when converting table-like object.
608     """
609 
610     meta = MetaData(copy=False)
611 
612     # Define class attributes for core container objects to allow for subclass
613     # customization.
614     Row = Row
615     Column = Column
616     MaskedColumn = MaskedColumn
617     TableColumns = TableColumns
618     TableFormatter = TableFormatter
619 
620     # Unified I/O read and write methods from .connect
621     read = UnifiedReadWriteMethod(TableRead)
622     write = UnifiedReadWriteMethod(TableWrite)
623 
624     pprint_exclude_names = PprintIncludeExclude()
625     pprint_include_names = PprintIncludeExclude()
626 
627     def as_array(self, keep_byteorder=False, names=None):
628         """
629         Return a new copy of the table in the form of a structured np.ndarray or
630         np.ma.MaskedArray object (as appropriate).
631 
632         Parameters
633         ----------
634         keep_byteorder : bool, optional
635             By default the returned array has all columns in native byte
636             order.  However, if this option is `True` this preserves the
637             byte order of all columns (if any are non-native).
638 
639         names : list, optional:
640             List of column names to include for returned structured array.
641             Default is to include all table columns.
642 
643         Returns
644         -------
645         table_array : array or `~numpy.ma.MaskedArray`
646             Copy of table as a numpy structured array.
647             ndarray for unmasked or `~numpy.ma.MaskedArray` for masked.
648         """
649         masked = self.masked or self.has_masked_columns or self.has_masked_values
650         empty_init = ma.empty if masked else np.empty
651         if len(self.columns) == 0:
652             return empty_init(0, dtype=None)
653 
654         dtype = []
655 
656         cols = self.columns.values()
657 
658         if names is not None:
659             cols = [col for col in cols if col.info.name in names]
660 
661         for col in cols:
662             col_descr = descr(col)
663 
664             if not (col.info.dtype.isnative or keep_byteorder):
665                 new_dt = np.dtype(col_descr[1]).newbyteorder("=")
666                 col_descr = (col_descr[0], new_dt, col_descr[2])
667 
668             dtype.append(col_descr)
669 
670         data = empty_init(len(self), dtype=dtype)
671         for col in cols:
672             # When assigning from one array into a field of a structured array,
673             # Numpy will automatically swap those columns to their destination
674             # byte order where applicable
675             data[col.info.name] = col
676 
677             # For masked out, masked mixin columns need to set output mask attribute.
678             if masked and has_info_class(col, MixinInfo) and hasattr(col, "mask"):
679                 data[col.info.name].mask = col.mask
680 
681         return data
682 
683     def __init__(
684         self,
685         data=None,
686         masked=False,
687         names=None,
688         dtype=None,
689         meta=None,
690         copy=True,
691         rows=None,
692         copy_indices=True,
693         units=None,
694         descriptions=None,
695         **kwargs,
696     ):
697         # Set up a placeholder empty table
698         self._set_masked(masked)
699         self.columns = self.TableColumns()
700         self.formatter = self.TableFormatter()
701         self._copy_indices = True  # copy indices from this Table by default
702         self._init_indices = copy_indices  # whether to copy indices in init
703         self.primary_key = None
704 
705         # Must copy if dtype are changing
706         if not copy and dtype is not None:
707             raise ValueError("Cannot specify dtype when copy=False")
708 
709         # Specifies list of names found for the case of initializing table with
710         # a list of dict. If data are not list of dict then this is None.
711         names_from_list_of_dict = None
712 
713         # Row-oriented input, e.g. list of lists or list of tuples, list of
714         # dict, Row instance.  Set data to something that the subsequent code
715         # will parse correctly.
716         if rows is not None:
717             if data is not None:
718                 raise ValueError("Cannot supply both `data` and `rows` values")
719             if isinstance(rows, types.GeneratorType):
720                 # Without this then the all(..) test below uses up the generator
721                 rows = list(rows)
722 
723             # Get column names if `rows` is a list of dict, otherwise this is None
724             names_from_list_of_dict = _get_names_from_list_of_dict(rows)
725             if names_from_list_of_dict:
726                 data = rows
727             elif isinstance(rows, self.Row):
728                 data = rows
729             else:
730                 data = list(zip(*rows))
731 
732         # Infer the type of the input data and set up the initialization
733         # function, number of columns, and potentially the default col names
734 
735         default_names = None
736 
737         # Handle custom (subclass) table attributes that are stored in meta.
738         # These are defined as class attributes using the TableAttribute
739         # descriptor.  Any such attributes get removed from kwargs here and
740         # stored for use after the table is otherwise initialized. Any values
741         # provided via kwargs will have precedence over existing values from
742         # meta (e.g. from data as a Table or meta via kwargs).
743         meta_table_attrs = {}
744         if kwargs:
745             for attr in list(kwargs):
746                 descr = getattr(self.__class__, attr, None)
747                 if isinstance(descr, TableAttribute):
748                     meta_table_attrs[attr] = kwargs.pop(attr)
749 
750         if hasattr(data, "__astropy_table__"):
751             # Data object implements the __astropy_table__ interface method.
752             # Calling that method returns an appropriate instance of
753             # self.__class__ and respects the `copy` arg.  The returned
754             # Table object should NOT then be copied.
755             data = data.__astropy_table__(self.__class__, copy, **kwargs)
756             copy = False
757         elif kwargs:
758             raise TypeError(
759                 f"__init__() got unexpected keyword argument {list(kwargs.keys())[0]!r}"
760             )
761 
762         if isinstance(data, np.ndarray) and data.shape == (0,) and not data.dtype.names:
763             data = None
764 
765         if isinstance(data, self.Row):
766             data = data._table[data._index : data._index + 1]
767 
768         if isinstance(data, (list, tuple)):
769             # Get column names from `data` if it is a list of dict, otherwise this is None.
770             # This might be previously defined if `rows` was supplied as an init arg.
771             names_from_list_of_dict = (
772                 names_from_list_of_dict or _get_names_from_list_of_dict(data)
773             )
774             if names_from_list_of_dict:
775                 init_func = self._init_from_list_of_dicts
776                 n_cols = len(names_from_list_of_dict)
777             else:
778                 init_func = self._init_from_list
779                 n_cols = len(data)
780 
781         elif isinstance(data, np.ndarray):
782             if data.dtype.names:
783                 init_func = self._init_from_ndarray  # _struct
784                 n_cols = len(data.dtype.names)
785                 default_names = data.dtype.names
786             else:
787                 init_func = self._init_from_ndarray  # _homog
788                 if data.shape == ():
789                     raise ValueError("Can not initialize a Table with a scalar")
790                 elif len(data.shape) == 1:
791                     data = data[np.newaxis, :]
792                 n_cols = data.shape[1]
793 
794         elif isinstance(data, Mapping):
795             init_func = self._init_from_dict
796             default_names = list(data)
797             n_cols = len(default_names)
798 
799         elif isinstance(data, Table):
800             # If user-input meta is None then use data.meta (if non-trivial)
801             if meta is None and data.meta:
802                 # At this point do NOT deepcopy data.meta as this will happen after
803                 # table init_func() is called.  But for table input the table meta
804                 # gets a key copy here if copy=False because later a direct object ref
805                 # is used.
806                 meta = data.meta if copy else data.meta.copy()
807 
808             # Handle indices on input table. Copy primary key and don't copy indices
809             # if the input Table is in non-copy mode.
810             self.primary_key = data.primary_key
811             self._init_indices = self._init_indices and data._copy_indices
812 
813             # Extract default names, n_cols, and then overwrite ``data`` to be the
814             # table columns so we can use _init_from_list.
815             default_names = data.colnames
816             n_cols = len(default_names)
817             data = list(data.columns.values())
818 
819             init_func = self._init_from_list
820 
821         elif data is None:
822             if names is None:
823                 if dtype is None:
824                     # Table was initialized as `t = Table()`. Set up for empty
825                     # table with names=[], data=[], and n_cols=0.
826                     # self._init_from_list() will simply return, giving the
827                     # expected empty table.
828                     names = []
829                 else:
830                     try:
831                         # No data nor names but dtype is available.  This must be
832                         # valid to initialize a structured array.
833                         dtype = np.dtype(dtype)
834                         names = dtype.names
835                         dtype = [dtype[name] for name in names]
836                     except Exception:
837                         raise ValueError(
838                             "dtype was specified but could not be "
839                             "parsed for column names"
840                         )
841             # names is guaranteed to be set at this point
842             init_func = self._init_from_list
843             n_cols = len(names)
844             data = [[]] * n_cols
845 
846         else:
847             raise ValueError(f"Data type {type(data)} not allowed to init Table")
848 
849         # Set up defaults if names and/or dtype are not specified.
850         # A value of None means the actual value will be inferred
851         # within the appropriate initialization routine, either from
852         # existing specification or auto-generated.
853 
854         if dtype is None:
855             dtype = [None] * n_cols
856         elif isinstance(dtype, np.dtype):
857             if default_names is None:
858                 default_names = dtype.names
859             # Convert a numpy dtype input to a list of dtypes for later use.
860             dtype = [dtype[name] for name in dtype.names]
861 
862         if names is None:
863             names = default_names or [None] * n_cols
864 
865         names = [None if name is None else str(name) for name in names]
866 
867         self._check_names_dtype(names, dtype, n_cols)
868 
869         # Finally do the real initialization
870         init_func(data, names, dtype, n_cols, copy)
871 
872         # Set table meta.  If copy=True then deepcopy meta otherwise use the
873         # user-supplied meta directly.
874         if meta is not None:
875             self.meta = deepcopy(meta) if copy else meta
876 
877         # Update meta with TableAttributes supplied as kwargs in Table init.
878         # This takes precedence over previously-defined meta.
879         if meta_table_attrs:
880             for attr, value in meta_table_attrs.items():
881                 setattr(self, attr, value)
882 
883         # Whatever happens above, the masked property should be set to a boolean
884         if self.masked not in (None, True, False):
885             raise TypeError("masked property must be None, True or False")
886 
887         self._set_column_attribute("unit", units)
888         self._set_column_attribute("description", descriptions)
889 
890     def _set_column_attribute(self, attr, values):
891         """Set ``attr`` for columns to ``values``, which can be either a dict (keyed by column
892         name) or a dict of name: value pairs.  This is used for handling the ``units`` and
893         ``descriptions`` kwargs to ``__init__``.
894         """
895         if not values:
896             return
897 
898         if isinstance(values, Row):
899             # For a Row object transform to an equivalent dict.
900             values = {name: values[name] for name in values.colnames}
901 
902         if not isinstance(values, Mapping):
903             # If not a dict map, assume iterable and map to dict if the right length
904             if len(values) != len(self.columns):
905                 raise ValueError(
906                     f"sequence of {attr} values must match number of columns"
907                 )
908             values = dict(zip(self.colnames, values))
909 
910         for name, value in values.items():
911             if name not in self.columns:
912                 raise ValueError(
913                     f"invalid column name {name} for setting {attr} attribute"
914                 )
915 
916             # Special case: ignore unit if it is an empty or blank string
917             if attr == "unit" and isinstance(value, str):
918                 if value.strip() == "":
919                     value = None
920 
921             if value not in (np.ma.masked, None):
922                 col = self[name]
923                 if attr == "unit" and isinstance(col, Quantity):
924                     # Update the Quantity unit in-place
925                     col <<= value
926                 else:
927                     setattr(col.info, attr, value)
928 
929     def __getstate__(self):
930         columns = OrderedDict(
931             (key, col if isinstance(col, BaseColumn) else col_copy(col))
932             for key, col in self.columns.items()
933         )
934         return (columns, self.meta)
935 
936     def __setstate__(self, state):
937         columns, meta = state
938         self.__init__(columns, meta=meta)
939 
940     @property
941     def mask(self):
942         # Dynamic view of available masks
943         if self.masked or self.has_masked_columns or self.has_masked_values:
944             mask_table = Table(
945                 [
946                     getattr(col, "mask", FalseArray(col.shape))
947                     for col in self.itercols()
948                 ],
949                 names=self.colnames,
950                 copy=False,
951             )
952 
953             # Set hidden attribute to force inplace setitem so that code like
954             # t.mask['a'] = [1, 0, 1] will correctly set the underlying mask.
955             # See #5556 for discussion.
956             mask_table._setitem_inplace = True
957         else:
958             mask_table = None
959 
960         return mask_table
961 
962     @mask.setter
963     def mask(self, val):
964         self.mask[:] = val
965 
966     @property
967     def _mask(self):
968         """This is needed so that comparison of a masked Table and a
969         MaskedArray works.  The requirement comes from numpy.ma.core
970         so don't remove this property.
971         """
972         return self.as_array().mask
973 
974     def filled(self, fill_value=None):
975         """Return copy of self, with masked values filled.
976 
977         If input ``fill_value`` supplied then that value is used for all
978         masked entries in the table.  Otherwise the individual
979         ``fill_value`` defined for each table column is used.
980 
981         Parameters
982         ----------
983         fill_value : str
984             If supplied, this ``fill_value`` is used for all masked entries
985             in the entire table.
986 
987         Returns
988         -------
989         filled_table : `~astropy.table.Table`
990             New table with masked values filled
991         """
992         if self.masked or self.has_masked_columns or self.has_masked_values:
993             # Get new columns with masked values filled, then create Table with those
994             # new cols (copy=False) but deepcopy the meta.
995             data = [
996                 col.filled(fill_value) if hasattr(col, "filled") else col
997                 for col in self.itercols()
998             ]
999             return self.__class__(data, meta=deepcopy(self.meta), copy=False)
1000         else:
1001             # Return copy of the original object.
1002             return self.copy()
1003 
1004     @property
1005     def indices(self):
1006         """
1007         Return the indices associated with columns of the table
1008         as a TableIndices object.
1009         """
1010         lst = []
1011         for column in self.columns.values():
1012             for index in column.info.indices:
1013                 if sum(index is x for x in lst) == 0:  # ensure uniqueness
1014                     lst.append(index)
1015         return TableIndices(lst)
1016 
1017     @property
1018     def loc(self):
1019         """
1020         Return a TableLoc object that can be used for retrieving
1021         rows by index in a given data range. Note that both loc
1022         and iloc work only with single-column indices.
1023         """
1024         return TableLoc(self)
1025 
1026     @property
1027     def loc_indices(self):
1028         """
1029         Return a TableLocIndices object that can be used for retrieving
1030         the row indices corresponding to given table index key value or values.
1031         """
1032         return TableLocIndices(self)
1033 
1034     @property
1035     def iloc(self):
1036         """
1037         Return a TableILoc object that can be used for retrieving
1038         indexed rows in the order they appear in the index.
1039         """
1040         return TableILoc(self)
1041 
1042     def add_index(self, colnames, engine=None, unique=False):
1043         """
1044         Insert a new index among one or more columns.
1045         If there are no indices, make this index the
1046         primary table index.
1047 
1048         Parameters
1049         ----------
1050         colnames : str or list
1051             List of column names (or a single column name) to index
1052         engine : type or None
1053             Indexing engine class to use, either `~astropy.table.SortedArray`,
1054             `~astropy.table.BST`, or `~astropy.table.SCEngine`. If the supplied
1055             argument is None (by default), use `~astropy.table.SortedArray`.
1056         unique : bool
1057             Whether the values of the index must be unique. Default is False.
1058         """
1059         if isinstance(colnames, str):
1060             colnames = (colnames,)
1061         columns = self.columns[tuple(colnames)].values()
1062 
1063         # make sure all columns support indexing
1064         for col in columns:
1065             if not getattr(col.info, "_supports_indexing", False):
1066                 raise ValueError(
1067                     'Cannot create an index on column "{}", of type "{}"'.format(
1068                         col.info.name, type(col)
1069                     )
1070                 )
1071 
1072         is_primary = not self.indices
1073         index = Index(columns, engine=engine, unique=unique)
1074         sliced_index = SlicedIndex(index, slice(0, 0, None), original=True)
1075         if is_primary:
1076             self.primary_key = colnames
1077         for col in columns:
1078             col.info.indices.append(sliced_index)
1079 
1080     def remove_indices(self, colname):
1081         """
1082         Remove all indices involving the given column.
1083         If the primary index is removed, the new primary
1084         index will be the most recently added remaining
1085         index.
1086 
1087         Parameters
1088         ----------
1089         colname : str
1090             Name of column
1091         """
1092         col = self.columns[colname]
1093         for index in self.indices:
1094             try:
1095                 index.col_position(col.info.name)
1096             except ValueError:
1097                 pass
1098             else:
1099                 for c in index.columns:
1100                     c.info.indices.remove(index)
1101 
1102     def index_mode(self, mode):
1103         """
1104         Return a context manager for an indexing mode.
1105 
1106         Parameters
1107         ----------
1108         mode : str
1109             Either 'freeze', 'copy_on_getitem', or 'discard_on_copy'.
1110             In 'discard_on_copy' mode,
1111             indices are not copied whenever columns or tables are copied.
1112             In 'freeze' mode, indices are not modified whenever columns are
1113             modified; at the exit of the context, indices refresh themselves
1114             based on column values. This mode is intended for scenarios in
1115             which one intends to make many additions or modifications in an
1116             indexed column.
1117             In 'copy_on_getitem' mode, indices are copied when taking column
1118             slices as well as table slices, so col[i0:i1] will preserve
1119             indices.
1120         """
1121         return _IndexModeContext(self, mode)
1122 
1123     def __array__(self, dtype=None):
1124         """Support converting Table to np.array via np.array(table).
1125 
1126         Coercion to a different dtype via np.array(table, dtype) is not
1127         supported and will raise a ValueError.
1128         """
1129         if dtype is not None:
1130             if np.dtype(dtype) != object:
1131                 raise ValueError("Datatype coercion is not allowed")
1132 
1133             out = np.array(None, dtype=object)
1134             out[()] = self
1135             return out
1136 
1137         # This limitation is because of the following unexpected result that
1138         # should have made a table copy while changing the column names.
1139         #
1140         # >>> d = astropy.table.Table([[1,2],[3,4]])
1141         # >>> np.array(d, dtype=[('a', 'i8'), ('b', 'i8')])
1142         # array([(0, 0), (0, 0)],
1143         #       dtype=[('a', '<i8'), ('b', '<i8')])
1144 
1145         out = self.as_array()
1146         return out.data if isinstance(out, np.ma.MaskedArray) else out
1147 
1148     def _check_names_dtype(self, names, dtype, n_cols):
1149         """Make sure that names and dtype are both iterable and have
1150         the same length as data.
1151         """
1152         for inp_list, inp_str in ((dtype, "dtype"), (names, "names")):
1153             if not isiterable(inp_list):
1154                 raise ValueError(f"{inp_str} must be a list or None")
1155 
1156         if len(names) != n_cols or len(dtype) != n_cols:
1157             raise ValueError(
1158                 'Arguments "names" and "dtype" must match number of columns'
1159             )
1160 
1161     def _init_from_list_of_dicts(self, data, names, dtype, n_cols, copy):
1162         """Initialize table from a list of dictionaries representing rows."""
1163         # Define placeholder for missing values as a unique object that cannot
1164         # every occur in user data.
1165         MISSING = object()
1166 
1167         # Gather column names that exist in the input `data`.
1168         names_from_data = set()
1169         for row in data:
1170             names_from_data.update(row)
1171 
1172         if set(data[0].keys()) == names_from_data:
1173             names_from_data = list(data[0].keys())
1174         else:
1175             names_from_data = sorted(names_from_data)
1176 
1177         # Note: if set(data[0].keys()) != names_from_data, this will give an
1178         # exception later, so NO need to catch here.
1179 
1180         # Convert list of dict into dict of list (cols), keep track of missing
1181         # indexes and put in MISSING placeholders in the `cols` lists.
1182         cols = {}
1183         missing_indexes = defaultdict(list)
1184         for name in names_from_data:
1185             cols[name] = []
1186             for ii, row in enumerate(data):
1187                 try:
1188                     val = row[name]
1189                 except KeyError:
1190                     missing_indexes[name].append(ii)
1191                     val = MISSING
1192                 cols[name].append(val)
1193 
1194         # Fill the missing entries with first values
1195         if missing_indexes:
1196             for name, indexes in missing_indexes.items():
1197                 col = cols[name]
1198                 first_val = next(val for val in col if val is not MISSING)
1199                 for index in indexes:
1200                     col[index] = first_val
1201 
1202         # prepare initialization
1203         if all(name is None for name in names):
1204             names = names_from_data
1205 
1206         self._init_from_dict(cols, names, dtype, n_cols, copy)
1207 
1208         # Mask the missing values if necessary, converting columns to MaskedColumn
1209         # as needed.
1210         if missing_indexes:
1211             for name, indexes in missing_indexes.items():
1212                 col = self[name]
1213                 # Ensure that any Column subclasses with MISSING values can support
1214                 # setting masked values. As of astropy 4.0 the test condition below is
1215                 # always True since _init_from_dict cannot result in mixin columns.
1216                 if isinstance(col, Column) and not isinstance(col, MaskedColumn):
1217                     self[name] = self.MaskedColumn(col, copy=False)
1218 
1219                 # Finally do the masking in a mixin-safe way.
1220                 self[name][indexes] = np.ma.masked
1221 
1222     def _init_from_list(self, data, names, dtype, n_cols, copy):
1223         """Initialize table from a list of column data.  A column can be a
1224         Column object, np.ndarray, mixin, or any other iterable object.
1225         """
1226         # Special case of initializing an empty table like `t = Table()`. No
1227         # action required at this point.
1228         if n_cols == 0:
1229             return
1230 
1231         cols = []
1232         default_names = _auto_names(n_cols)
1233 
1234         for col, name, default_name, dt in zip(data, names, default_names, dtype):
1235             col = self._convert_data_to_col(col, copy, default_name, dt, name)
1236 
1237             cols.append(col)
1238 
1239         self._init_from_cols(cols)
1240 
1241     def _convert_data_to_col(
1242         self, data, copy=True, default_name=None, dtype=None, name=None
1243     ):
1244         """
1245         Convert any allowed sequence data ``col`` to a column object that can be used
1246         directly in the self.columns dict.  This could be a Column, MaskedColumn,
1247         or mixin column.
1248 
1249         The final column name is determined by::
1250 
1251             name or data.info.name or def_name
1252 
1253         If ``data`` has no ``info`` then ``name = name or def_name``.
1254 
1255         The behavior of ``copy`` for Column objects is:
1256         - copy=True: new class instance with a copy of data and deep copy of meta
1257         - copy=False: new class instance with same data and a key-only copy of meta
1258 
1259         For mixin columns:
1260         - copy=True: new class instance with copy of data and deep copy of meta
1261         - copy=False: original instance (no copy at all)
1262 
1263         Parameters
1264         ----------
1265         data : object (column-like sequence)
1266             Input column data
1267         copy : bool
1268             Make a copy
1269         default_name : str
1270             Default name
1271         dtype : np.dtype or None
1272             Data dtype
1273         name : str or None
1274             Column name
1275 
1276         Returns
1277         -------
1278         col : Column, MaskedColumn, mixin-column type
1279             Object that can be used as a column in self
1280         """
1281         data_is_mixin = self._is_mixin_for_table(data)
1282         masked_col_cls = (
1283             self.ColumnClass
1284             if issubclass(self.ColumnClass, self.MaskedColumn)
1285             else self.MaskedColumn
1286         )
1287 
1288         try:
1289             data0_is_mixin = self._is_mixin_for_table(data[0])
1290         except Exception:
1291             # Need broad exception, cannot predict what data[0] raises for arbitrary data
1292             data0_is_mixin = False
1293 
1294         # If the data is not an instance of Column or a mixin class, we can
1295         # check the registry of mixin 'handlers' to see if the column can be
1296         # converted to a mixin class
1297         if (handler := get_mixin_handler(data)) is not None:
1298             original_data = data
1299             data = handler(data)
1300             if not (data_is_mixin := self._is_mixin_for_table(data)):
1301                 fully_qualified_name = (
1302                     original_data.__class__.__module__
1303                     + "."
1304                     + original_data.__class__.__name__
1305                 )
1306                 raise TypeError(
1307                     "Mixin handler for object of type "
1308                     f"{fully_qualified_name} "
1309                     "did not return a valid mixin column"
1310                 )
1311 
1312         # Get the final column name using precedence.  Some objects may not
1313         # have an info attribute. Also avoid creating info as a side effect.
1314         if not name:
1315             if isinstance(data, Column):
1316                 name = data.name or default_name
1317             elif "info" in getattr(data, "__dict__", ()):
1318                 name = data.info.name or default_name
1319             else:
1320                 name = default_name
1321 
1322         if isinstance(data, Column):
1323             # If self.ColumnClass is a subclass of col, then "upgrade" to ColumnClass,
1324             # otherwise just use the original class.  The most common case is a
1325             # table with masked=True and ColumnClass=MaskedColumn.  Then a Column
1326             # gets upgraded to MaskedColumn, but the converse (pre-4.0) behavior
1327             # of downgrading from MaskedColumn to Column (for non-masked table)
1328             # does not happen.
1329             col_cls = self._get_col_cls_for_table(data)
1330 
1331         elif data_is_mixin:
1332             # Copy the mixin column attributes if they exist since the copy below
1333             # may not get this attribute. If not copying, take a slice
1334             # to ensure we get a new instance and we do not share metadata
1335             # like info.
1336             col = col_copy(data, copy_indices=self._init_indices) if copy else data[:]
1337             col.info.name = name
1338             return col
1339 
1340         elif data0_is_mixin:
1341             # Handle case of a sequence of a mixin, e.g. [1*u.m, 2*u.m].
1342             try:
1343                 col = data[0].__class__(data)
1344                 col.info.name = name
1345                 return col
1346             except Exception:
1347                 # If that didn't work for some reason, just turn it into np.array of object
1348                 data = np.array(data, dtype=object)
1349                 col_cls = self.ColumnClass
1350 
1351         elif isinstance(data, (np.ma.MaskedArray, Masked)):
1352             # Require that col_cls be a subclass of MaskedColumn, remembering
1353             # that ColumnClass could be a user-defined subclass (though more-likely
1354             # could be MaskedColumn).
1355             col_cls = masked_col_cls
1356 
1357         elif data is None:
1358             # Special case for data passed as the None object (for broadcasting
1359             # to an object column). Need to turn data into numpy `None` scalar
1360             # object, otherwise `Column` interprets data=None as no data instead
1361             # of a object column of `None`.
1362             data = np.array(None)
1363             col_cls = self.ColumnClass
1364 
1365         elif not hasattr(data, "dtype"):
1366             # `data` is none of the above, convert to numpy array or MaskedArray
1367             # assuming only that it is a scalar or sequence or N-d nested
1368             # sequence. This function is relatively intricate and tries to
1369             # maintain performance for common cases while handling things like
1370             # list input with embedded np.ma.masked entries. If `data` is a
1371             # scalar then it gets returned unchanged so the original object gets
1372             # passed to `Column` later.
1373             data = _convert_sequence_data_to_array(data, dtype)
1374             copy = False  # Already made a copy above
1375             col_cls = (
1376                 masked_col_cls
1377                 if isinstance(data, np.ma.MaskedArray)
1378                 else self.ColumnClass
1379             )
1380 
1381         else:
1382             col_cls = self.ColumnClass
1383 
1384         try:
1385             col = col_cls(
1386                 name=name,
1387                 data=data,
1388                 dtype=dtype,
1389                 copy=copy,
1390                 copy_indices=self._init_indices,
1391             )
1392         except Exception:
1393             # Broad exception class since we don't know what might go wrong
1394             raise ValueError("unable to convert data to Column for Table")
1395 
1396         col = self._convert_col_for_table(col)
1397 
1398         return col
1399 
1400     def _init_from_ndarray(self, data, names, dtype, n_cols, copy):
1401         """Initialize table from an ndarray structured array."""
1402         data_names = data.dtype.names or _auto_names(n_cols)
1403         struct = data.dtype.names is not None
1404         names = [name or data_names[i] for i, name in enumerate(names)]
1405 
1406         cols = (
1407             [data[name] for name in data_names]
1408             if struct
1409             else [data[:, i] for i in range(n_cols)]
1410         )
1411 
1412         self._init_from_list(cols, names, dtype, n_cols, copy)
1413 
1414     def _init_from_dict(self, data, names, dtype, n_cols, copy):
1415         """Initialize table from a dictionary of columns."""
1416         data_list = [data[name] for name in names]
1417         self._init_from_list(data_list, names, dtype, n_cols, copy)
1418 
1419     def _get_col_cls_for_table(self, col):
1420         """Get the correct column class to use for upgrading any Column-like object.
1421 
1422         For a masked table, ensure any Column-like object is a subclass
1423         of the table MaskedColumn.
1424 
1425         For unmasked table, ensure any MaskedColumn-like object is a subclass
1426         of the table MaskedColumn.  If not a MaskedColumn, then ensure that any
1427         Column-like object is a subclass of the table Column.
1428         """
1429         col_cls = col.__class__
1430 
1431         if self.masked:
1432             if isinstance(col, Column) and not isinstance(col, self.MaskedColumn):
1433                 col_cls = self.MaskedColumn
1434         else:
1435             if isinstance(col, MaskedColumn):
1436                 if not isinstance(col, self.MaskedColumn):
1437                     col_cls = self.MaskedColumn
1438             elif isinstance(col, Column) and not isinstance(col, self.Column):
1439                 col_cls = self.Column
1440 
1441         return col_cls
1442 
1443     def _convert_col_for_table(self, col):
1444         """
1445         Make sure that all Column objects have correct base class for this type of
1446         Table.  For a base Table this most commonly means setting to
1447         MaskedColumn if the table is masked.  Table subclasses like QTable
1448         override this method.
1449         """
1450         if isinstance(col, Column) and not isinstance(col, self.ColumnClass):
1451             col_cls = self._get_col_cls_for_table(col)
1452             if col_cls is not col.__class__:
1453                 col = col_cls(col, copy=False)
1454 
1455         return col
1456 
1457     def _init_from_cols(self, cols):
1458         """Initialize table from a list of Column or mixin objects."""
1459         lengths = {len(col) for col in cols}
1460         if len(lengths) > 1:
1461             raise ValueError(f"Inconsistent data column lengths: {lengths}")
1462 
1463         # Make sure that all Column-based objects have correct class.  For
1464         # plain Table this is self.ColumnClass, but for instance QTable will
1465         # convert columns with units to a Quantity mixin.
1466         newcols = [self._convert_col_for_table(col) for col in cols]
1467         self._make_table_from_cols(self, newcols)
1468 
1469         # Deduplicate indices.  It may happen that after pickling or when
1470         # initing from an existing table that column indices which had been
1471         # references to a single index object got *copied* into an independent
1472         # object.  This results in duplicates which will cause downstream problems.
1473         index_dict = {}
1474         for col in self.itercols():
1475             for i, index in enumerate(col.info.indices or []):
1476                 names = tuple(ind_col.info.name for ind_col in index.columns)
1477                 if names in index_dict:
1478                     col.info.indices[i] = index_dict[names]
1479                 else:
1480                     index_dict[names] = index
1481 
1482     def _new_from_slice(self, slice_):
1483         """Create a new table as a referenced slice from self."""
1484         table = self.__class__(masked=self.masked)
1485         if self.meta:
1486             table.meta = self.meta.copy()  # Shallow copy for slice
1487         table.primary_key = self.primary_key
1488 
1489         newcols = []
1490         for col in self.columns.values():
1491             newcol = col[slice_]
1492 
1493             # Note in line below, use direct attribute access to col.indices for Column
1494             # instances instead of the generic col.info.indices.  This saves about 4 usec
1495             # per column.
1496             if (col if isinstance(col, Column) else col.info).indices:
1497                 # TODO : as far as I can tell the only purpose of setting _copy_indices
1498                 # here is to communicate that to the initial test in `slice_indices`.
1499                 # Why isn't that just sent as an arg to the function?
1500                 col.info._copy_indices = self._copy_indices
1501                 newcol = col.info.slice_indices(newcol, slice_, len(col))
1502 
1503                 # Don't understand why this is forcing a value on the original column.
1504                 # Normally col.info does not even have a _copy_indices attribute.  Tests
1505                 # still pass if this line is deleted.  (Each col.info attribute access
1506                 # is expensive).
1507                 col.info._copy_indices = True
1508 
1509             newcols.append(newcol)
1510 
1511         self._make_table_from_cols(
1512             table, newcols, verify=False, names=self.columns.keys()
1513         )
1514         return table
1515 
1516     @staticmethod
1517     def _make_table_from_cols(table, cols, verify=True, names=None):
1518         """
1519         Make ``table`` in-place so that it represents the given list of ``cols``.
1520         """
1521         if names is None:
1522             names = [col.info.name for col in cols]
1523 
1524         # Note: we do not test for len(names) == len(cols) if names is not None.  In that
1525         # case the function is being called by from "trusted" source (e.g. right above here)
1526         # that is assumed to provide valid inputs.  In that case verify=False.
1527 
1528         if verify:
1529             if None in names:
1530                 raise TypeError("Cannot have None for column name")
1531             if len(set(names)) != len(names):
1532                 raise ValueError("Duplicate column names")
1533 
1534         table.columns = table.TableColumns(
1535             (name, col) for name, col in zip(names, cols)
1536         )
1537 
1538         for col in cols:
1539             table._set_col_parent_table_and_mask(col)
1540 
1541     def _set_col_parent_table_and_mask(self, col):
1542         """
1543         Set ``col.parent_table = self`` and force ``col`` to have ``mask``
1544         attribute if the table is masked and ``col.mask`` does not exist.
1545         """
1546         # For Column instances it is much faster to do direct attribute access
1547         # instead of going through .info
1548         col_info = col if isinstance(col, Column) else col.info
1549         col_info.parent_table = self
1550 
1551         # Legacy behavior for masked table
1552         if self.masked and not hasattr(col, "mask"):
1553             col.mask = FalseArray(col.shape)
1554 
1555     def itercols(self):
1556         """
1557         Iterate over the columns of this table.
1558 
1559         Examples
1560         --------
1561         To iterate over the columns of a table::
1562 
1563             >>> t = Table([[1], [2]])
1564             >>> for col in t.itercols():
1565             ...     print(col)
1566             col0
1567             ----
1568                1
1569             col1
1570             ----
1571                2
1572 
1573         Using ``itercols()`` is similar to  ``for col in t.columns.values()``
1574         but is syntactically preferred.
1575         """
1576         for colname in self.columns:
1577             yield self[colname]
1578 
1579     def _base_repr_(
1580         self,
1581         html=False,
1582         descr_vals=None,
1583         max_width=None,
1584         tableid=None,
1585         show_dtype=True,
1586         max_lines=None,
1587         tableclass=None,
1588     ):
1589         if descr_vals is None:
1590             descr_vals = [self.__class__.__name__]
1591             if self.masked:
1592                 descr_vals.append("masked=True")
1593             descr_vals.append(f"length={len(self)}")
1594 
1595         descr = " ".join(descr_vals)
1596         if html:
1597             from astropy.utils.xml.writer import xml_escape
1598 
1599             descr = f"<i>{xml_escape(descr)}</i>\n"
1600         else:
1601             descr = f"<{descr}>\n"
1602 
1603         if tableid is None:
1604             tableid = f"table{id(self)}"
1605 
1606         data_lines, outs = self.formatter._pformat_table(
1607             self,
1608             tableid=tableid,
1609             html=html,
1610             max_width=max_width,
1611             show_name=True,
1612             show_unit=None,
1613             show_dtype=show_dtype,
1614             max_lines=max_lines,
1615             tableclass=tableclass,
1616         )
1617 
1618         out = descr + "\n".join(data_lines)
1619 
1620         return out
1621 
1622     def _repr_html_(self):
1623         out = self._base_repr_(
1624             html=True, max_width=-1, tableclass=conf.default_notebook_table_class
1625         )
1626         # Wrap <table> in <div>. This follows the pattern in pandas and allows
1627         # table to be scrollable horizontally in VS Code notebook display.
1628         out = f"<div>{out}</div>"
1629         return out
1630 
1631     def __repr__(self):
1632         return self._base_repr_(html=False, max_width=None)
1633 
1634     def __str__(self):
1635         return "\n".join(self.pformat())
1636 
1637     def __bytes__(self):
1638         return str(self).encode("utf-8")
1639 
1640     @property
1641     def has_mixin_columns(self):
1642         """
1643         True if table has any mixin columns (defined as columns that are not Column
1644         subclasses).
1645         """
1646         return any(has_info_class(col, MixinInfo) for col in self.columns.values())
1647 
1648     @property
1649     def has_masked_columns(self):
1650         """True if table has any ``MaskedColumn`` columns.
1651 
1652         This does not check for mixin columns that may have masked values, use the
1653         ``has_masked_values`` property in that case.
1654 
1655         """
1656         return any(isinstance(col, MaskedColumn) for col in self.itercols())
1657 
1658     @property
1659     def has_masked_values(self):
1660         """True if column in the table has values which are masked.
1661 
1662         This may be relatively slow for large tables as it requires checking the mask
1663         values of each column.
1664         """
1665         return any(hasattr(col, "mask") and np.any(col.mask) for col in self.itercols())
1666 
1667     def _is_mixin_for_table(self, col):
1668         """
1669         Determine if ``col`` should be added to the table directly as
1670         a mixin column.
1671         """
1672         if isinstance(col, BaseColumn):
1673             return False
1674 
1675         # Is it a mixin but not [Masked]Quantity (which gets converted to
1676         # [Masked]Column with unit set).
1677         return has_info_class(col, MixinInfo) and not has_info_class(col, QuantityInfo)
1678 
1679     @format_doc(_pprint_docs)
1680     def pprint(
1681         self,
1682         max_lines=None,
1683         max_width=None,
1684         show_name=True,
1685         show_unit=None,
1686         show_dtype=False,
1687         align=None,
1688     ):
1689         """Print a formatted string representation of the table.
1690 
1691         If no value of ``max_lines`` is supplied then the height of the
1692         screen terminal is used to set ``max_lines``.  If the terminal
1693         height cannot be determined then the default is taken from the
1694         configuration item ``astropy.conf.max_lines``.  If a negative
1695         value of ``max_lines`` is supplied then there is no line limit
1696         applied.
1697 
1698         The same applies for max_width except the configuration item is
1699         ``astropy.conf.max_width``.
1700 
1701         """
1702         lines, outs = self.formatter._pformat_table(
1703             self,
1704             max_lines,
1705             max_width,
1706             show_name=show_name,
1707             show_unit=show_unit,
1708             show_dtype=show_dtype,
1709             align=align,
1710         )
1711         if outs["show_length"]:
1712             lines.append(f"Length = {len(self)} rows")
1713 
1714         n_header = outs["n_header"]
1715 
1716         for i, line in enumerate(lines):
1717             if i < n_header:
1718                 color_print(line, "red")
1719             else:
1720                 print(line)
1721 
1722     @format_doc(_pprint_docs)
1723     def pprint_all(
1724         self,
1725         max_lines=-1,
1726         max_width=-1,
1727         show_name=True,
1728         show_unit=None,
1729         show_dtype=False,
1730         align=None,
1731     ):
1732         """Print a formatted string representation of the entire table.
1733 
1734         This method is the same as `astropy.table.Table.pprint` except that
1735         the default ``max_lines`` and ``max_width`` are both -1 so that by
1736         default the entire table is printed instead of restricting to the size
1737         of the screen terminal.
1738 
1739         """
1740         return self.pprint(
1741             max_lines, max_width, show_name, show_unit, show_dtype, align
1742         )
1743 
1744     def _make_index_row_display_table(self, index_row_name):
1745         if index_row_name not in self.columns:
1746             idx_col = self.ColumnClass(name=index_row_name, data=np.arange(len(self)))
1747             return self.__class__([idx_col] + list(self.columns.values()), copy=False)
1748         else:
1749             return self
1750 
1751     def show_in_notebook(
1752         self,
1753         tableid=None,
1754         css=None,
1755         display_length=50,
1756         table_class="astropy-default",
1757         show_row_index="idx",
1758     ):
1759         """Render the table in HTML and show it in the IPython notebook.
1760 
1761         Parameters
1762         ----------
1763         tableid : str or None
1764             An html ID tag for the table.  Default is ``table{id}-XXX``, where
1765             id is the unique integer id of the table object, id(self), and XXX
1766             is a random number to avoid conflicts when printing the same table
1767             multiple times.
1768         table_class : str or None
1769             A string with a list of HTML classes used to style the table.
1770             The special default string ('astropy-default') means that the string
1771             will be retrieved from the configuration item
1772             ``astropy.table.default_notebook_table_class``. Note that these
1773             table classes may make use of bootstrap, as this is loaded with the
1774             notebook.  See `this page <https://getbootstrap.com/css/#tables>`_
1775             for the list of classes.
1776         css : str
1777             A valid CSS string declaring the formatting for the table. Defaults
1778             to ``astropy.table.jsviewer.DEFAULT_CSS_NB``.
1779         display_length : int, optional
1780             Number or rows to show. Defaults to 50.
1781         show_row_index : str or False
1782             If this does not evaluate to False, a column with the given name
1783             will be added to the version of the table that gets displayed.
1784             This new column shows the index of the row in the table itself,
1785             even when the displayed table is re-sorted by another column. Note
1786             that if a column with this name already exists, this option will be
1787             ignored. Defaults to "idx".
1788 
1789         Notes
1790         -----
1791         Currently, unlike `show_in_browser` (with ``jsviewer=True``), this
1792         method needs to access online javascript code repositories.  This is due
1793         to modern browsers' limitations on accessing local files.  Hence, if you
1794         call this method while offline (and don't have a cached version of
1795         jquery and jquery.dataTables), you will not get the jsviewer features.
1796         """
1797         from IPython.display import HTML
1798 
1799         from .jsviewer import JSViewer
1800 
1801         if tableid is None:
1802             tableid = f"table{id(self)}-{np.random.randint(1, 1e6)}"
1803 
1804         jsv = JSViewer(display_length=display_length)
1805         if show_row_index:
1806             display_table = self._make_index_row_display_table(show_row_index)
1807         else:
1808             display_table = self
1809         if table_class == "astropy-default":
1810             table_class = conf.default_notebook_table_class
1811         html = display_table._base_repr_(
1812             html=True,
1813             max_width=-1,
1814             tableid=tableid,
1815             max_lines=-1,
1816             show_dtype=False,
1817             tableclass=table_class,
1818         )
1819 
1820         columns = display_table.columns.values()
1821         sortable_columns = [
1822             i for i, col in enumerate(columns) if col.info.dtype.kind in "iufc"
1823         ]
1824         html += jsv.ipynb(tableid, css=css, sort_columns=sortable_columns)
1825         return HTML(html)
1826 
1827     def show_in_browser(
1828         self,
1829         max_lines=5000,
1830         jsviewer=False,
1831         browser="default",
1832         jskwargs={"use_local_files": True},
1833         tableid=None,
1834         table_class="display compact",
1835         css=None,
1836         show_row_index="idx",
1837     ):
1838         """Render the table in HTML and show it in a web browser.
1839 
1840         Parameters
1841         ----------
1842         max_lines : int
1843             Maximum number of rows to export to the table (set low by default
1844             to avoid memory issues, since the browser view requires duplicating
1845             the table in memory).  A negative value of ``max_lines`` indicates
1846             no row limit.
1847         jsviewer : bool
1848             If `True`, prepends some javascript headers so that the table is
1849             rendered as a `DataTables <https://datatables.net>`_ data table.
1850             This allows in-browser searching & sorting.
1851         browser : str
1852             Any legal browser name, e.g. ``'firefox'``, ``'chrome'``,
1853             ``'safari'`` (for mac, you may need to use ``'open -a
1854             "/Applications/Google Chrome.app" {}'`` for Chrome).  If
1855             ``'default'``, will use the system default browser.
1856         jskwargs : dict
1857             Passed to the `astropy.table.JSViewer` init. Defaults to
1858             ``{'use_local_files': True}`` which means that the JavaScript
1859             libraries will be served from local copies.
1860         tableid : str or None
1861             An html ID tag for the table.  Default is ``table{id}``, where id
1862             is the unique integer id of the table object, id(self).
1863         table_class : str or None
1864             A string with a list of HTML classes used to style the table.
1865             Default is "display compact", and other possible values can be
1866             found in https://www.datatables.net/manual/styling/classes
1867         css : str
1868             A valid CSS string declaring the formatting for the table. Defaults
1869             to ``astropy.table.jsviewer.DEFAULT_CSS``.
1870         show_row_index : str or False
1871             If this does not evaluate to False, a column with the given name
1872             will be added to the version of the table that gets displayed.
1873             This new column shows the index of the row in the table itself,
1874             even when the displayed table is re-sorted by another column. Note
1875             that if a column with this name already exists, this option will be
1876             ignored. Defaults to "idx".
1877         """
1878         import os
1879         import tempfile
1880         import webbrowser
1881         from urllib.parse import urljoin
1882         from urllib.request import pathname2url
1883 
1884         from .jsviewer import DEFAULT_CSS
1885 
1886         if css is None:
1887             css = DEFAULT_CSS
1888 
1889         # We can't use NamedTemporaryFile here because it gets deleted as
1890         # soon as it gets garbage collected.
1891         tmpdir = tempfile.mkdtemp()
1892         path = os.path.join(tmpdir, "table.html")
1893 
1894         with open(path, "w") as tmp:
1895             if jsviewer:
1896                 if show_row_index:
1897                     display_table = self._make_index_row_display_table(show_row_index)
1898                 else:
1899                     display_table = self
1900                 display_table.write(
1901                     tmp,
1902                     format="jsviewer",
1903                     css=css,
1904                     max_lines=max_lines,
1905                     jskwargs=jskwargs,
1906                     table_id=tableid,
1907                     table_class=table_class,
1908                 )
1909             else:
1910                 self.write(tmp, format="html")
1911 
1912         try:
1913             br = webbrowser.get(None if browser == "default" else browser)
1914         except webbrowser.Error:
1915             log.error(f"Browser '{browser}' not found.")
1916         else:
1917             br.open(urljoin("file:", pathname2url(path)))
1918 
1919     @format_doc(_pformat_docs, id="{id}")
1920     def pformat(
1921         self,
1922         max_lines=None,
1923         max_width=None,
1924         show_name=True,
1925         show_unit=None,
1926         show_dtype=False,
1927         html=False,
1928         tableid=None,
1929         align=None,
1930         tableclass=None,
1931     ):
1932         """Return a list of lines for the formatted string representation of
1933         the table.
1934 
1935         If no value of ``max_lines`` is supplied then the height of the
1936         screen terminal is used to set ``max_lines``.  If the terminal
1937         height cannot be determined then the default is taken from the
1938         configuration item ``astropy.conf.max_lines``.  If a negative
1939         value of ``max_lines`` is supplied then there is no line limit
1940         applied.
1941 
1942         The same applies for ``max_width`` except the configuration item  is
1943         ``astropy.conf.max_width``.
1944 
1945         """
1946         lines, outs = self.formatter._pformat_table(
1947             self,
1948             max_lines,
1949             max_width,
1950             show_name=show_name,
1951             show_unit=show_unit,
1952             show_dtype=show_dtype,
1953             html=html,
1954             tableid=tableid,
1955             tableclass=tableclass,
1956             align=align,
1957         )
1958 
1959         if outs["show_length"]:
1960             lines.append(f"Length = {len(self)} rows")
1961 
1962         return lines
1963 
1964     @format_doc(_pformat_docs, id="{id}")
1965     def pformat_all(
1966         self,
1967         max_lines=-1,
1968         max_width=-1,
1969         show_name=True,
1970         show_unit=None,
1971         show_dtype=False,
1972         html=False,
1973         tableid=None,
1974         align=None,
1975         tableclass=None,
1976     ):
1977         """Return a list of lines for the formatted string representation of
1978         the entire table.
1979 
1980         If no value of ``max_lines`` is supplied then the height of the
1981         screen terminal is used to set ``max_lines``.  If the terminal
1982         height cannot be determined then the default is taken from the
1983         configuration item ``astropy.conf.max_lines``.  If a negative
1984         value of ``max_lines`` is supplied then there is no line limit
1985         applied.
1986 
1987         The same applies for ``max_width`` except the configuration item  is
1988         ``astropy.conf.max_width``.
1989 
1990         """
1991         return self.pformat(
1992             max_lines,
1993             max_width,
1994             show_name,
1995             show_unit,
1996             show_dtype,
1997             html,
1998             tableid,
1999             align,
2000             tableclass,
2001         )
2002 
2003     def more(
2004         self,
2005         max_lines=None,
2006         max_width=None,
2007         show_name=True,
2008         show_unit=None,
2009         show_dtype=False,
2010     ):
2011         """Interactively browse table with a paging interface.
2012 
2013         Supported keys::
2014 
2015           f, <space> : forward one page
2016           b : back one page
2017           r : refresh same page
2018           n : next row
2019           p : previous row
2020           < : go to beginning
2021           > : go to end
2022           q : quit browsing
2023           h : print this help
2024 
2025         Parameters
2026         ----------
2027         max_lines : int
2028             Maximum number of lines in table output
2029 
2030         max_width : int or None
2031             Maximum character width of output
2032 
2033         show_name : bool
2034             Include a header row for column names. Default is True.
2035 
2036         show_unit : bool
2037             Include a header row for unit.  Default is to show a row
2038             for units only if one or more columns has a defined value
2039             for the unit.
2040 
2041         show_dtype : bool
2042             Include a header row for column dtypes. Default is False.
2043         """
2044         self.formatter._more_tabcol(
2045             self,
2046             max_lines,
2047             max_width,
2048             show_name=show_name,
2049             show_unit=show_unit,
2050             show_dtype=show_dtype,
2051         )
2052 
2053     def __getitem__(self, item):
2054         if isinstance(item, str):
2055             return self.columns[item]
2056         elif isinstance(item, (int, np.integer)):
2057             return self.Row(self, item)
2058         elif (
2059             isinstance(item, np.ndarray) and item.shape == () and item.dtype.kind == "i"
2060         ):
2061             return self.Row(self, item.item())
2062         elif self._is_list_or_tuple_of_str(item):
2063             out = self.__class__(
2064                 [self[x] for x in item], copy_indices=self._copy_indices
2065             )
2066             out._groups = groups.TableGroups(
2067                 out, indices=self.groups._indices, keys=self.groups._keys
2068             )
2069             out.meta = self.meta.copy()  # Shallow copy for meta
2070             return out
2071         elif (isinstance(item, np.ndarray) and item.size == 0) or (
2072             isinstance(item, (tuple, list)) and not item
2073         ):
2074             # If item is an empty array/list/tuple then return the table with no rows
2075             return self._new_from_slice([])
2076         elif (
2077             isinstance(item, (slice, np.ndarray, list))
2078             or isinstance(item, tuple)
2079             and all(isinstance(x, np.ndarray) for x in item)
2080         ):
2081             # here for the many ways to give a slice; a tuple of ndarray
2082             # is produced by np.where, as in t[np.where(t['a'] > 2)]
2083             # For all, a new table is constructed with slice of all columns
2084             return self._new_from_slice(item)
2085         else:
2086             raise ValueError(f"Illegal type {type(item)} for table item access")
2087 
2088     def __setitem__(self, item, value):
2089         # If the item is a string then it must be the name of a column.
2090         # If that column doesn't already exist then create it now.
2091         if isinstance(item, str) and item not in self.colnames:
2092             self.add_column(value, name=item, copy=True)
2093 
2094         else:
2095             n_cols = len(self.columns)
2096 
2097             if isinstance(item, str):
2098                 # Set an existing column by first trying to replace, and if
2099                 # this fails do an in-place update.  See definition of mask
2100                 # property for discussion of the _setitem_inplace attribute.
2101                 if (
2102                     not getattr(self, "_setitem_inplace", False)
2103                     and not conf.replace_inplace
2104                 ):
2105                     try:
2106                         self._replace_column_warnings(item, value)
2107                         return
2108                     except Exception:
2109                         pass
2110                 self.columns[item][:] = value
2111 
2112             elif isinstance(item, (int, np.integer)):
2113                 self._set_row(idx=item, colnames=self.colnames, vals=value)
2114 
2115             elif (
2116                 isinstance(item, (slice, np.ndarray, list))
2117                 or isinstance(item, tuple)
2118                 and all(isinstance(x, np.ndarray) for x in item)
2119             ):
2120                 if isinstance(value, Table):
2121                     vals = (col for col in value.columns.values())
2122 
2123                 elif isinstance(value, np.ndarray) and value.dtype.names:
2124                     vals = (value[name] for name in value.dtype.names)
2125 
2126                 elif np.isscalar(value):
2127                     vals = itertools.repeat(value, n_cols)
2128 
2129                 else:  # Assume this is an iterable that will work
2130                     if len(value) != n_cols:
2131                         raise ValueError(
2132                             "Right side value needs {} elements (one for each column)".format(
2133                                 n_cols
2134                             )
2135                         )
2136                     vals = value
2137 
2138                 for col, val in zip(self.columns.values(), vals):
2139                     col[item] = val
2140 
2141             else:
2142                 raise ValueError(f"Illegal type {type(item)} for table item access")
2143 
2144     def __delitem__(self, item):
2145         if isinstance(item, str):
2146             self.remove_column(item)
2147         elif isinstance(item, (int, np.integer)):
2148             self.remove_row(item)
2149         elif isinstance(item, (list, tuple, np.ndarray)) and all(
2150             isinstance(x, str) for x in item
2151         ):
2152             self.remove_columns(item)
2153         elif (
2154             isinstance(item, (list, np.ndarray)) and np.asarray(item).dtype.kind == "i"
2155         ):
2156             self.remove_rows(item)
2157         elif isinstance(item, slice):
2158             self.remove_rows(item)
2159         else:
2160             raise IndexError("illegal key or index value")
2161 
2162     def _ipython_key_completions_(self):
2163         return self.colnames
2164 
2165     def field(self, item):
2166         """Return column[item] for recarray compatibility."""
2167         return self.columns[item]
2168 
2169     @property
2170     def masked(self):
2171         return self._masked
2172 
2173     @masked.setter
2174     def masked(self, masked):
2175         raise Exception(
2176             "Masked attribute is read-only (use t = Table(t, masked=True)"
2177             " to convert to a masked table)"
2178         )
2179 
2180     def _set_masked(self, masked):
2181         """
2182         Set the table masked property.
2183 
2184         Parameters
2185         ----------
2186         masked : bool
2187             State of table masking (`True` or `False`)
2188         """
2189         if masked in [True, False, None]:
2190             self._masked = masked
2191         else:
2192             raise ValueError("masked should be one of True, False, None")
2193 
2194         self._column_class = self.MaskedColumn if self._masked else self.Column
2195 
2196     @property
2197     def ColumnClass(self):
2198         if self._column_class is None:
2199             return self.Column
2200         else:
2201             return self._column_class
2202 
2203     @property
2204     def dtype(self):
2205         return np.dtype([descr(col) for col in self.columns.values()])
2206 
2207     @property
2208     def colnames(self):
2209         return list(self.columns.keys())
2210 
2211     @staticmethod
2212     def _is_list_or_tuple_of_str(names):
2213         """Check that ``names`` is a tuple or list of strings."""
2214         return (
2215             isinstance(names, (tuple, list))
2216             and names
2217             and all(isinstance(x, str) for x in names)
2218         )
2219 
2220     def keys(self):
2221         return list(self.columns.keys())
2222 
2223     def values(self):
2224         return self.columns.values()
2225 
2226     def items(self):
2227         return self.columns.items()
2228 
2229     def __len__(self):
2230         # For performance reasons (esp. in Row) cache the first column name
2231         # and use that subsequently for the table length.  If might not be
2232         # available yet or the column might be gone now, in which case
2233         # try again in the except block.
2234         try:
2235             return len(OrderedDict.__getitem__(self.columns, self._first_colname))
2236         except (AttributeError, KeyError):
2237             if len(self.columns) == 0:
2238                 return 0
2239 
2240             # Get the first column name
2241             self._first_colname = next(iter(self.columns))
2242             return len(self.columns[self._first_colname])
2243 
2244     def __or__(self, other):
2245         if isinstance(other, Table):
2246             updated_table = self.copy()
2247             updated_table.update(other)
2248             return updated_table
2249         else:
2250             return NotImplemented
2251 
2252     def __ior__(self, other):
2253         try:
2254             self.update(other)
2255             return self
2256         except TypeError:
2257             return NotImplemented
2258 
2259     def index_column(self, name):
2260         """
2261         Return the positional index of column ``name``.
2262 
2263         Parameters
2264         ----------
2265         name : str
2266             column name
2267 
2268         Returns
2269         -------
2270         index : int
2271             Positional index of column ``name``.
2272 
2273         Examples
2274         --------
2275         Create a table with three columns 'a', 'b' and 'c'::
2276 
2277             >>> t = Table([[1, 2, 3], [0.1, 0.2, 0.3], ['x', 'y', 'z']],
2278             ...           names=('a', 'b', 'c'))
2279             >>> print(t)
2280              a   b   c
2281             --- --- ---
2282               1 0.1   x
2283               2 0.2   y
2284               3 0.3   z
2285 
2286         Get index of column 'b' of the table::
2287 
2288             >>> t.index_column('b')
2289             1
2290         """
2291         try:
2292             return self.colnames.index(name)
2293         except ValueError:
2294             raise ValueError(f"Column {name} does not exist")
2295 
2296     def add_column(
2297         self,
2298         col,
2299         index=None,
2300         name=None,
2301         rename_duplicate=False,
2302         copy=True,
2303         default_name=None,
2304     ):
2305         """
2306         Add a new column to the table using ``col`` as input.  If ``index``
2307         is supplied then insert column before ``index`` position
2308         in the list of columns, otherwise append column to the end
2309         of the list.
2310 
2311         The ``col`` input can be any data object which is acceptable as a
2312         `~astropy.table.Table` column object or can be converted.  This includes
2313         mixin columns and scalar or length=1 objects which get broadcast to match
2314         the table length.
2315 
2316         To add several columns at once use ``add_columns()`` or simply call
2317         ``add_column()`` for each one.  There is very little performance difference
2318         in the two approaches.
2319 
2320         Parameters
2321         ----------
2322         col : object
2323             Data object for the new column
2324         index : int or None
2325             Insert column before this position or at end (default).
2326         name : str
2327             Column name
2328         rename_duplicate : bool
2329             Uniquify column name if it already exist. Default is False.
2330         copy : bool
2331             Make a copy of the new column. Default is True.
2332         default_name : str or None
2333             Name to use if both ``name`` and ``col.info.name`` are not available.
2334             Defaults to ``col{number_of_columns}``.
2335 
2336         Examples
2337         --------
2338         Create a table with two columns 'a' and 'b', then create a third column 'c'
2339         and append it to the end of the table::
2340 
2341             >>> t = Table([[1, 2], [0.1, 0.2]], names=('a', 'b'))
2342             >>> col_c = Column(name='c', data=['x', 'y'])
2343             >>> t.add_column(col_c)
2344             >>> print(t)
2345              a   b   c
2346             --- --- ---
2347               1 0.1   x
2348               2 0.2   y
2349 
2350         Add column 'd' at position 1. Note that the column is inserted
2351         before the given index::
2352 
2353             >>> t.add_column(['a', 'b'], name='d', index=1)
2354             >>> print(t)
2355              a   d   b   c
2356             --- --- --- ---
2357               1   a 0.1   x
2358               2   b 0.2   y
2359 
2360         Add second column named 'b' with rename_duplicate::
2361 
2362             >>> t = Table([[1, 2], [0.1, 0.2]], names=('a', 'b'))
2363             >>> t.add_column(1.1, name='b', rename_duplicate=True)
2364             >>> print(t)
2365              a   b  b_1
2366             --- --- ---
2367               1 0.1 1.1
2368               2 0.2 1.1
2369 
2370         Add an unnamed column or mixin object in the table using a default name
2371         or by specifying an explicit name with ``name``. Name can also be overridden::
2372 
2373             >>> t = Table([[1, 2], [0.1, 0.2]], names=('a', 'b'))
2374             >>> t.add_column(['a', 'b'])
2375             >>> t.add_column(col_c, name='d')
2376             >>> print(t)
2377              a   b  col2  d
2378             --- --- ---- ---
2379               1 0.1    a   x
2380               2 0.2    b   y
2381         """
2382         if default_name is None:
2383             default_name = f"col{len(self.columns)}"
2384 
2385         # Convert col data to acceptable object for insertion into self.columns.
2386         # Note that along with the lines above and below, this allows broadcasting
2387         # of scalars to the correct shape for adding to table.
2388         col = self._convert_data_to_col(
2389             col, name=name, copy=copy, default_name=default_name
2390         )
2391 
2392         # Assigning a scalar column to an empty table should result in an
2393         # exception (see #3811).
2394         if col.shape == () and len(self) == 0:
2395             raise TypeError("Empty table cannot have column set to scalar value")
2396         # Make col data shape correct for scalars.  The second test is to allow
2397         # broadcasting an N-d element to a column, e.g. t['new'] = [[1, 2]].
2398         elif (col.shape == () or col.shape[0] == 1) and len(self) > 0:
2399             new_shape = (len(self),) + getattr(col, "shape", ())[1:]
2400             if isinstance(col, np.ndarray):
2401                 col = np.broadcast_to(col, shape=new_shape, subok=True)
2402             elif isinstance(col, ShapedLikeNDArray):
2403                 col = col._apply(np.broadcast_to, shape=new_shape, subok=True)
2404 
2405             # broadcast_to() results in a read-only array.  Apparently it only changes
2406             # the view to look like the broadcasted array.  So copy.
2407             col = col_copy(col)
2408 
2409         name = col.info.name
2410 
2411         # Ensure that new column is the right length
2412         if len(self.columns) > 0 and len(col) != len(self):
2413             raise ValueError("Inconsistent data column lengths")
2414 
2415         if rename_duplicate:
2416             orig_name = name
2417             i = 1
2418             while name in self.columns:
2419                 # Iterate until a unique name is found
2420                 name = orig_name + "_" + str(i)
2421                 i += 1
2422             col.info.name = name
2423 
2424         # Set col parent_table weakref and ensure col has mask attribute if table.masked
2425         self._set_col_parent_table_and_mask(col)
2426 
2427         # Add new column as last column
2428         self.columns[name] = col
2429 
2430         if index is not None:
2431             # Move the other cols to the right of the new one
2432             move_names = self.colnames[index:-1]
2433             for move_name in move_names:
2434                 self.columns.move_to_end(move_name, last=True)
2435 
2436     def add_columns(
2437         self, cols, indexes=None, names=None, copy=True, rename_duplicate=False
2438     ):
2439         """
2440         Add a list of new columns the table using ``cols`` data objects.  If a
2441         corresponding list of ``indexes`` is supplied then insert column
2442         before each ``index`` position in the *original* list of columns,
2443         otherwise append columns to the end of the list.
2444 
2445         The ``cols`` input can include any data objects which are acceptable as
2446         `~astropy.table.Table` column objects or can be converted.  This includes
2447         mixin columns and scalar or length=1 objects which get broadcast to match
2448         the table length.
2449 
2450         From a performance perspective there is little difference between calling
2451         this method once or looping over the new columns and calling ``add_column()``
2452         for each column.
2453 
2454         Parameters
2455         ----------
2456         cols : list of object
2457             List of data objects for the new columns
2458         indexes : list of int or None
2459             Insert column before this position or at end (default).
2460         names : list of str
2461             Column names
2462         copy : bool
2463             Make a copy of the new columns. Default is True.
2464         rename_duplicate : bool
2465             Uniquify new column names if they duplicate the existing ones.
2466             Default is False.
2467 
2468         See Also
2469         --------
2470         astropy.table.hstack, update, replace_column
2471 
2472         Examples
2473         --------
2474         Create a table with two columns 'a' and 'b', then create columns 'c' and 'd'
2475         and append them to the end of the table::
2476 
2477             >>> t = Table([[1, 2], [0.1, 0.2]], names=('a', 'b'))
2478             >>> col_c = Column(name='c', data=['x', 'y'])
2479             >>> col_d = Column(name='d', data=['u', 'v'])
2480             >>> t.add_columns([col_c, col_d])
2481             >>> print(t)
2482              a   b   c   d
2483             --- --- --- ---
2484               1 0.1   x   u
2485               2 0.2   y   v
2486 
2487         Add column 'c' at position 0 and column 'd' at position 1. Note that
2488         the columns are inserted before the given position::
2489 
2490             >>> t = Table([[1, 2], [0.1, 0.2]], names=('a', 'b'))
2491             >>> t.add_columns([['x', 'y'], ['u', 'v']], names=['c', 'd'],
2492             ...               indexes=[0, 1])
2493             >>> print(t)
2494              c   a   d   b
2495             --- --- --- ---
2496               x   1   u 0.1
2497               y   2   v 0.2
2498 
2499         Add second column 'b' and column 'c' with ``rename_duplicate``::
2500 
2501             >>> t = Table([[1, 2], [0.1, 0.2]], names=('a', 'b'))
2502             >>> t.add_columns([[1.1, 1.2], ['x', 'y']], names=('b', 'c'),
2503             ...               rename_duplicate=True)
2504             >>> print(t)
2505              a   b  b_1  c
2506             --- --- --- ---
2507               1 0.1 1.1  x
2508               2 0.2 1.2  y
2509 
2510         Add unnamed columns or mixin objects in the table using default names
2511         or by specifying explicit names with ``names``. Names can also be overridden::
2512 
2513             >>> t = Table()
2514             >>> col_b = Column(name='b', data=['u', 'v'])
2515             >>> t.add_columns([[1, 2], col_b])
2516             >>> t.add_columns([[3, 4], col_b], names=['c', 'd'])
2517             >>> print(t)
2518             col0  b   c   d
2519             ---- --- --- ---
2520                1   u   3   u
2521                2   v   4   v
2522         """
2523         if indexes is None:
2524             indexes = [len(self.columns)] * len(cols)
2525         elif len(indexes) != len(cols):
2526             raise ValueError("Number of indexes must match number of cols")
2527 
2528         if names is None:
2529             names = (None,) * len(cols)
2530         elif len(names) != len(cols):
2531             raise ValueError("Number of names must match number of cols")
2532 
2533         default_names = [f"col{ii + len(self.columns)}" for ii in range(len(cols))]
2534 
2535         for ii in reversed(np.argsort(indexes, kind="stable")):
2536             self.add_column(
2537                 cols[ii],
2538                 index=indexes[ii],
2539                 name=names[ii],
2540                 default_name=default_names[ii],
2541                 rename_duplicate=rename_duplicate,
2542                 copy=copy,
2543             )
2544 
2545     def _replace_column_warnings(self, name, col):
2546         """
2547         Same as replace_column but issues warnings under various circumstances.
2548         """
2549         warns = conf.replace_warnings
2550         refcount = None
2551         old_col = None
2552 
2553         # sys.getrefcount is CPython specific and not on PyPy.
2554         if (
2555             "refcount" in warns
2556             and name in self.colnames
2557             and hasattr(sys, "getrefcount")
2558         ):
2559             refcount = sys.getrefcount(self[name])
2560 
2561         if name in self.colnames:
2562             old_col = self[name]
2563 
2564         # This may raise an exception (e.g. t['a'] = 1) in which case none of
2565         # the downstream code runs.
2566         self.replace_column(name, col)
2567 
2568         if "always" in warns:
2569             warnings.warn(
2570                 f"replaced column '{name}'", TableReplaceWarning, stacklevel=3
2571             )
2572 
2573         if "slice" in warns:
2574             try:
2575                 # Check for ndarray-subclass slice.  An unsliced instance
2576                 # has an ndarray for the base while sliced has the same class
2577                 # as parent.
2578                 if isinstance(old_col.base, old_col.__class__):
2579                     msg = (
2580                         "replaced column '{}' which looks like an array slice. "
2581                         "The new column no longer shares memory with the "
2582                         "original array.".format(name)
2583                     )
2584                     warnings.warn(msg, TableReplaceWarning, stacklevel=3)
2585             except AttributeError:
2586                 pass
2587 
2588         # sys.getrefcount is CPython specific and not on PyPy.
2589         if "refcount" in warns and hasattr(sys, "getrefcount"):
2590             # Did reference count change?
2591             new_refcount = sys.getrefcount(self[name])
2592             if refcount != new_refcount:
2593                 msg = (
2594                     "replaced column '{}' and the number of references "
2595                     "to the column changed.".format(name)
2596                 )
2597                 warnings.warn(msg, TableReplaceWarning, stacklevel=3)
2598 
2599         if "attributes" in warns:
2600             # Any of the standard column attributes changed?
2601             changed_attrs = []
2602             new_col = self[name]
2603             # Check base DataInfo attributes that any column will have
2604             for attr in DataInfo.attr_names:
2605                 if getattr(old_col.info, attr) != getattr(new_col.info, attr):
2606                     changed_attrs.append(attr)
2607 
2608             if changed_attrs:
2609                 msg = "replaced column '{}' and column attributes {} changed.".format(
2610                     name, changed_attrs
2611                 )
2612                 warnings.warn(msg, TableReplaceWarning, stacklevel=3)
2613 
2614     def replace_column(self, name, col, copy=True):
2615         """
2616         Replace column ``name`` with the new ``col`` object.
2617 
2618         The behavior of ``copy`` for Column objects is:
2619         - copy=True: new class instance with a copy of data and deep copy of meta
2620         - copy=False: new class instance with same data and a key-only copy of meta
2621 
2622         For mixin columns:
2623         - copy=True: new class instance with copy of data and deep copy of meta
2624         - copy=False: original instance (no copy at all)
2625 
2626         Parameters
2627         ----------
2628         name : str
2629             Name of column to replace
2630         col : `~astropy.table.Column` or `~numpy.ndarray` or sequence
2631             New column object to replace the existing column.
2632         copy : bool
2633             Make copy of the input ``col``, default=True
2634 
2635         See Also
2636         --------
2637         add_columns, astropy.table.hstack, update
2638 
2639         Examples
2640         --------
2641         Replace column 'a' with a float version of itself::
2642 
2643             >>> t = Table([[1, 2, 3], [0.1, 0.2, 0.3]], names=('a', 'b'))
2644             >>> float_a = t['a'].astype(float)
2645             >>> t.replace_column('a', float_a)
2646         """
2647         if name not in self.colnames:
2648             raise ValueError(f"column name {name} is not in the table")
2649 
2650         if self[name].info.indices:
2651             raise ValueError("cannot replace a table index column")
2652 
2653         col = self._convert_data_to_col(col, name=name, copy=copy)
2654         self._set_col_parent_table_and_mask(col)
2655 
2656         # Ensure that new column is the right length, unless it is the only column
2657         # in which case re-sizing is allowed.
2658         if len(self.columns) > 1 and len(col) != len(self[name]):
2659             raise ValueError("length of new column must match table length")
2660 
2661         self.columns.__setitem__(name, col, validated=True)
2662 
2663     def remove_row(self, index):
2664         """
2665         Remove a row from the table.
2666 
2667         Parameters
2668         ----------
2669         index : int
2670             Index of row to remove
2671 
2672         Examples
2673         --------
2674         Create a table with three columns 'a', 'b' and 'c'::
2675 
2676             >>> t = Table([[1, 2, 3], [0.1, 0.2, 0.3], ['x', 'y', 'z']],
2677             ...           names=('a', 'b', 'c'))
2678             >>> print(t)
2679              a   b   c
2680             --- --- ---
2681               1 0.1   x
2682               2 0.2   y
2683               3 0.3   z
2684 
2685         Remove row 1 from the table::
2686 
2687             >>> t.remove_row(1)
2688             >>> print(t)
2689              a   b   c
2690             --- --- ---
2691               1 0.1   x
2692               3 0.3   z
2693 
2694         To remove several rows at the same time use remove_rows.
2695         """
2696         # check the index against the types that work with np.delete
2697         if not isinstance(index, (int, np.integer)):
2698             raise TypeError("Row index must be an integer")
2699         self.remove_rows(index)
2700 
2701     def remove_rows(self, row_specifier):
2702         """
2703         Remove rows from the table.
2704 
2705         Parameters
2706         ----------
2707         row_specifier : slice or int or array of int
2708             Specification for rows to remove
2709 
2710         Examples
2711         --------
2712         Create a table with three columns 'a', 'b' and 'c'::
2713 
2714             >>> t = Table([[1, 2, 3], [0.1, 0.2, 0.3], ['x', 'y', 'z']],
2715             ...           names=('a', 'b', 'c'))
2716             >>> print(t)
2717              a   b   c
2718             --- --- ---
2719               1 0.1   x
2720               2 0.2   y
2721               3 0.3   z
2722 
2723         Remove rows 0 and 2 from the table::
2724 
2725             >>> t.remove_rows([0, 2])
2726             >>> print(t)
2727              a   b   c
2728             --- --- ---
2729               2 0.2   y
2730 
2731 
2732         Note that there are no warnings if the slice operator extends
2733         outside the data::
2734 
2735             >>> t = Table([[1, 2, 3], [0.1, 0.2, 0.3], ['x', 'y', 'z']],
2736             ...           names=('a', 'b', 'c'))
2737             >>> t.remove_rows(slice(10, 20, 1))
2738             >>> print(t)
2739              a   b   c
2740             --- --- ---
2741               1 0.1   x
2742               2 0.2   y
2743               3 0.3   z
2744         """
2745         # Update indices
2746         for index in self.indices:
2747             index.remove_rows(row_specifier)
2748 
2749         keep_mask = np.ones(len(self), dtype=bool)
2750         keep_mask[row_specifier] = False
2751 
2752         columns = self.TableColumns()
2753         for name, col in self.columns.items():
2754             newcol = col[keep_mask]
2755             newcol.info.parent_table = self
2756             columns[name] = newcol
2757 
2758         self._replace_cols(columns)
2759 
2760         # Revert groups to default (ungrouped) state
2761         if hasattr(self, "_groups"):
2762             del self._groups
2763 
2764     def iterrows(self, *names):
2765         """
2766         Iterate over rows of table returning a tuple of values for each row.
2767 
2768         This method is especially useful when only a subset of columns are needed.
2769 
2770         The ``iterrows`` method can be substantially faster than using the standard
2771         Table row iteration (e.g. ``for row in tbl:``), since that returns a new
2772         ``~astropy.table.Row`` object for each row and accessing a column in that
2773         row (e.g. ``row['col0']``) is slower than tuple access.
2774 
2775         Parameters
2776         ----------
2777         names : list
2778             List of column names (default to all columns if no names provided)
2779 
2780         Returns
2781         -------
2782         rows : iterable
2783             Iterator returns tuples of row values
2784 
2785         Examples
2786         --------
2787         Create a table with three columns 'a', 'b' and 'c'::
2788 
2789             >>> t = Table({'a': [1, 2, 3],
2790             ...            'b': [1.0, 2.5, 3.0],
2791             ...            'c': ['x', 'y', 'z']})
2792 
2793         To iterate row-wise using column names::
2794 
2795             >>> for a, c in t.iterrows('a', 'c'):
2796             ...     print(a, c)
2797             1 x
2798             2 y
2799             3 z
2800 
2801         """
2802         if len(names) == 0:
2803             names = self.colnames
2804         else:
2805             for name in names:
2806                 if name not in self.colnames:
2807                     raise ValueError(f"{name} is not a valid column name")
2808 
2809         cols = (self[name] for name in names)
2810         out = zip(*cols)
2811         return out
2812 
2813     def _set_of_names_in_colnames(self, names):
2814         """Return ``names`` as a set if valid, or raise a `KeyError`.
2815 
2816         ``names`` is valid if all elements in it are in ``self.colnames``.
2817         If ``names`` is a string then it is interpreted as a single column
2818         name.
2819         """
2820         names = {names} if isinstance(names, str) else set(names)
2821         invalid_names = names.difference(self.colnames)
2822         if len(invalid_names) == 1:
2823             raise KeyError(f'column "{invalid_names.pop()}" does not exist')
2824         elif len(invalid_names) > 1:
2825             raise KeyError(f"columns {invalid_names} do not exist")
2826         return names
2827 
2828     def remove_column(self, name):
2829         """
2830         Remove a column from the table.
2831 
2832         This can also be done with::
2833 
2834           del table[name]
2835 
2836         Parameters
2837         ----------
2838         name : str
2839             Name of column to remove
2840 
2841         Examples
2842         --------
2843         Create a table with three columns 'a', 'b' and 'c'::
2844 
2845             >>> t = Table([[1, 2, 3], [0.1, 0.2, 0.3], ['x', 'y', 'z']],
2846             ...           names=('a', 'b', 'c'))
2847             >>> print(t)
2848              a   b   c
2849             --- --- ---
2850               1 0.1   x
2851               2 0.2   y
2852               3 0.3   z
2853 
2854         Remove column 'b' from the table::
2855 
2856             >>> t.remove_column('b')
2857             >>> print(t)
2858              a   c
2859             --- ---
2860               1   x
2861               2   y
2862               3   z
2863 
2864         To remove several columns at the same time use remove_columns.
2865         """
2866         self.remove_columns([name])
2867 
2868     def remove_columns(self, names):
2869         """
2870         Remove several columns from the table.
2871 
2872         Parameters
2873         ----------
2874         names : str or iterable of str
2875             Names of the columns to remove
2876 
2877         Examples
2878         --------
2879         Create a table with three columns 'a', 'b' and 'c'::
2880 
2881             >>> t = Table([[1, 2, 3], [0.1, 0.2, 0.3], ['x', 'y', 'z']],
2882             ...     names=('a', 'b', 'c'))
2883             >>> print(t)
2884              a   b   c
2885             --- --- ---
2886               1 0.1   x
2887               2 0.2   y
2888               3 0.3   z
2889 
2890         Remove columns 'b' and 'c' from the table::
2891 
2892             >>> t.remove_columns(['b', 'c'])
2893             >>> print(t)
2894              a
2895             ---
2896               1
2897               2
2898               3
2899 
2900         Specifying only a single column also works. Remove column 'b' from the table::
2901 
2902             >>> t = Table([[1, 2, 3], [0.1, 0.2, 0.3], ['x', 'y', 'z']],
2903             ...     names=('a', 'b', 'c'))
2904             >>> t.remove_columns('b')
2905             >>> print(t)
2906              a   c
2907             --- ---
2908               1   x
2909               2   y
2910               3   z
2911 
2912         This gives the same as using remove_column.
2913         """
2914         for name in self._set_of_names_in_colnames(names):
2915             del self.columns[name]
2916 
2917     def _convert_string_dtype(self, in_kind, out_kind, encode_decode_func):
2918         """
2919         Convert string-like columns to/from bytestring and unicode (internal only).
2920 
2921         Parameters
2922         ----------
2923         in_kind : str
2924             Input dtype.kind
2925         out_kind : str
2926             Output dtype.kind
2927         """
2928         for col in self.itercols():
2929             if col.dtype.kind == in_kind:
2930                 try:
2931                     # This requires ASCII and is faster by a factor of up to ~8, so
2932                     # try that first.
2933                     newcol = col.__class__(col, dtype=out_kind)
2934                 except (UnicodeEncodeError, UnicodeDecodeError):
2935                     newcol = col.__class__(encode_decode_func(col, "utf-8"))
2936 
2937                     # Quasi-manually copy info attributes.  Unfortunately
2938                     # DataInfo.__set__ does not do the right thing in this case
2939                     # so newcol.info = col.info does not get the old info attributes.
2940                     for attr in (
2941                         col.info.attr_names - col.info._attrs_no_copy - {"dtype"}
2942                     ):
2943                         value = deepcopy(getattr(col.info, attr))
2944                         setattr(newcol.info, attr, value)
2945 
2946                 self[col.name] = newcol
2947 
2948     def convert_bytestring_to_unicode(self):
2949         """
2950         Convert bytestring columns (dtype.kind='S') to unicode (dtype.kind='U')
2951         using UTF-8 encoding.
2952 
2953         Internally this changes string columns to represent each character
2954         in the string with a 4-byte UCS-4 equivalent, so it is inefficient
2955         for memory but allows scripts to manipulate string arrays with
2956         natural syntax.
2957         """
2958         self._convert_string_dtype("S", "U", np.char.decode)
2959 
2960     def convert_unicode_to_bytestring(self):
2961         """
2962         Convert unicode columns (dtype.kind='U') to bytestring (dtype.kind='S')
2963         using UTF-8 encoding.
2964 
2965         When exporting a unicode string array to a file, it may be desirable
2966         to encode unicode columns as bytestrings.
2967         """
2968         self._convert_string_dtype("U", "S", np.char.encode)
2969 
2970     def keep_columns(self, names):
2971         """
2972         Keep only the columns specified (remove the others).
2973 
2974         Parameters
2975         ----------
2976         names : str or iterable of str
2977             The columns to keep. All other columns will be removed.
2978 
2979         Examples
2980         --------
2981         Create a table with three columns 'a', 'b' and 'c'::
2982 
2983             >>> t = Table([[1, 2, 3],[0.1, 0.2, 0.3],['x', 'y', 'z']],
2984             ...           names=('a', 'b', 'c'))
2985             >>> print(t)
2986              a   b   c
2987             --- --- ---
2988               1 0.1   x
2989               2 0.2   y
2990               3 0.3   z
2991 
2992         Keep only column 'a' of the table::
2993 
2994             >>> t.keep_columns('a')
2995             >>> print(t)
2996              a
2997             ---
2998               1
2999               2
3000               3
3001 
3002         Keep columns 'a' and 'c' of the table::
3003 
3004             >>> t = Table([[1, 2, 3],[0.1, 0.2, 0.3],['x', 'y', 'z']],
3005             ...           names=('a', 'b', 'c'))
3006             >>> t.keep_columns(['a', 'c'])
3007             >>> print(t)
3008              a   c
3009             --- ---
3010               1   x
3011               2   y
3012               3   z
3013         """
3014         names = self._set_of_names_in_colnames(names)
3015         for colname in self.colnames:
3016             if colname not in names:
3017                 del self.columns[colname]
3018 
3019     def rename_column(self, name, new_name):
3020         """
3021         Rename a column.
3022 
3023         This can also be done directly by setting the ``name`` attribute
3024         of the ``info`` property of the column::
3025 
3026           table[name].info.name = new_name
3027 
3028         Parameters
3029         ----------
3030         name : str
3031             The current name of the column.
3032         new_name : str
3033             The new name for the column
3034 
3035         Examples
3036         --------
3037         Create a table with three columns 'a', 'b' and 'c'::
3038 
3039             >>> t = Table([[1,2],[3,4],[5,6]], names=('a','b','c'))
3040             >>> print(t)
3041              a   b   c
3042             --- --- ---
3043               1   3   5
3044               2   4   6
3045 
3046         Renaming column 'a' to 'aa'::
3047 
3048             >>> t.rename_column('a' , 'aa')
3049             >>> print(t)
3050              aa  b   c
3051             --- --- ---
3052               1   3   5
3053               2   4   6
3054         """
3055         if name not in self.keys():
3056             raise KeyError(f"Column {name} does not exist")
3057 
3058         self.columns[name].info.name = new_name
3059 
3060     def rename_columns(self, names, new_names):
3061         """
3062         Rename multiple columns.
3063 
3064         Parameters
3065         ----------
3066         names : list, tuple
3067             A list or tuple of existing column names.
3068         new_names : list, tuple
3069             A list or tuple of new column names.
3070 
3071         Examples
3072         --------
3073         Create a table with three columns 'a', 'b', 'c'::
3074 
3075             >>> t = Table([[1,2],[3,4],[5,6]], names=('a','b','c'))
3076             >>> print(t)
3077               a   b   c
3078              --- --- ---
3079               1   3   5
3080               2   4   6
3081 
3082         Renaming columns 'a' to 'aa' and 'b' to 'bb'::
3083 
3084             >>> names = ('a','b')
3085             >>> new_names = ('aa','bb')
3086             >>> t.rename_columns(names, new_names)
3087             >>> print(t)
3088              aa  bb   c
3089             --- --- ---
3090               1   3   5
3091               2   4   6
3092         """
3093         if not self._is_list_or_tuple_of_str(names):
3094             raise TypeError("input 'names' must be a tuple or a list of column names")
3095 
3096         if not self._is_list_or_tuple_of_str(new_names):
3097             raise TypeError(
3098                 "input 'new_names' must be a tuple or a list of column names"
3099             )
3100 
3101         if len(names) != len(new_names):
3102             raise ValueError(
3103                 "input 'names' and 'new_names' list arguments must be the same length"
3104             )
3105 
3106         for name, new_name in zip(names, new_names):
3107             self.rename_column(name, new_name)
3108 
3109     def _set_row(self, idx, colnames, vals):
3110         try:
3111             assert len(vals) == len(colnames)
3112         except Exception:
3113             raise ValueError(
3114                 "right hand side must be a sequence of values with "
3115                 "the same length as the number of selected columns"
3116             )
3117 
3118         # Keep track of original values before setting each column so that
3119         # setting row can be transactional.
3120         orig_vals = []
3121         cols = self.columns
3122         try:
3123             for name, val in zip(colnames, vals):
3124                 orig_vals.append(cols[name][idx])
3125                 cols[name][idx] = val
3126         except Exception:
3127             # If anything went wrong first revert the row update then raise
3128             for name, val in zip(colnames, orig_vals[:-1]):
3129                 cols[name][idx] = val
3130             raise
3131 
3132     def add_row(self, vals=None, mask=None):
3133         """Add a new row to the end of the table.
3134 
3135         The ``vals`` argument can be:
3136 
3137         sequence (e.g. tuple or list)
3138             Column values in the same order as table columns.
3139         mapping (e.g. dict)
3140             Keys corresponding to column names.  Missing values will be
3141             filled with np.zeros for the column dtype.
3142         `None`
3143             All values filled with np.zeros for the column dtype.
3144 
3145         This method requires that the Table object "owns" the underlying array
3146         data.  In particular one cannot add a row to a Table that was
3147         initialized with copy=False from an existing array.
3148 
3149         The ``mask`` attribute should give (if desired) the mask for the
3150         values. The type of the mask should match that of the values, i.e. if
3151         ``vals`` is an iterable, then ``mask`` should also be an iterable
3152         with the same length, and if ``vals`` is a mapping, then ``mask``
3153         should be a dictionary.
3154 
3155         Parameters
3156         ----------
3157         vals : tuple, list, dict or None
3158             Use the specified values in the new row
3159         mask : tuple, list, dict or None
3160             Use the specified mask values in the new row
3161 
3162         Examples
3163         --------
3164         Create a table with three columns 'a', 'b' and 'c'::
3165 
3166            >>> t = Table([[1,2],[4,5],[7,8]], names=('a','b','c'))
3167            >>> print(t)
3168             a   b   c
3169            --- --- ---
3170              1   4   7
3171              2   5   8
3172 
3173         Adding a new row with entries '3' in 'a', '6' in 'b' and '9' in 'c'::
3174 
3175            >>> t.add_row([3,6,9])
3176            >>> print(t)
3177              a   b   c
3178              --- --- ---
3179              1   4   7
3180              2   5   8
3181              3   6   9
3182         """
3183         self.insert_row(len(self), vals, mask)
3184 
3185     def insert_row(self, index, vals=None, mask=None):
3186         """Add a new row before the given ``index`` position in the table.
3187 
3188         The ``vals`` argument can be:
3189 
3190         sequence (e.g. tuple or list)
3191             Column values in the same order as table columns.
3192         mapping (e.g. dict)
3193             Keys corresponding to column names.  Missing values will be
3194             filled with np.zeros for the column dtype.
3195         `None`
3196             All values filled with np.zeros for the column dtype.
3197 
3198         The ``mask`` attribute should give (if desired) the mask for the
3199         values. The type of the mask should match that of the values, i.e. if
3200         ``vals`` is an iterable, then ``mask`` should also be an iterable
3201         with the same length, and if ``vals`` is a mapping, then ``mask``
3202         should be a dictionary.
3203 
3204         Parameters
3205         ----------
3206         vals : tuple, list, dict or None
3207             Use the specified values in the new row
3208         mask : tuple, list, dict or None
3209             Use the specified mask values in the new row
3210         """
3211         colnames = self.colnames
3212 
3213         N = len(self)
3214         if index < -N or index > N:
3215             raise IndexError(
3216                 f"Index {index} is out of bounds for table with length {N}"
3217             )
3218         if index < 0:
3219             index += N
3220 
3221         if isinstance(vals, Mapping) or vals is None:
3222             # From the vals and/or mask mappings create the corresponding lists
3223             # that have entries for each table column.
3224             if mask is not None and not isinstance(mask, Mapping):
3225                 raise TypeError("Mismatch between type of vals and mask")
3226 
3227             # Now check that the mask is specified for the same keys as the
3228             # values, otherwise things get really confusing.
3229             if mask is not None and set(vals.keys()) != set(mask.keys()):
3230                 raise ValueError("keys in mask should match keys in vals")
3231 
3232             if vals and any(name not in colnames for name in vals):
3233                 raise ValueError("Keys in vals must all be valid column names")
3234 
3235             vals_list = []
3236             mask_list = []
3237 
3238             for name in colnames:
3239                 if vals and name in vals:
3240                     vals_list.append(vals[name])
3241                     mask_list.append(False if mask is None else mask[name])
3242                 else:
3243                     col = self[name]
3244                     if hasattr(col, "dtype"):
3245                         # Make a placeholder zero element of the right type which is masked.
3246                         # This assumes the appropriate insert() method will broadcast a
3247                         # numpy scalar to the right shape.
3248                         vals_list.append(np.zeros(shape=(), dtype=col.dtype))
3249 
3250                         # For masked table any unsupplied values are masked by default.
3251                         mask_list.append(self.masked and vals is not None)
3252                     else:
3253                         raise ValueError(f"Value must be supplied for column '{name}'")
3254 
3255             vals = vals_list
3256             mask = mask_list
3257 
3258         if isiterable(vals):
3259             if mask is not None and (not isiterable(mask) or isinstance(mask, Mapping)):
3260                 raise TypeError("Mismatch between type of vals and mask")
3261 
3262             if len(self.columns) != len(vals):
3263                 raise ValueError("Mismatch between number of vals and columns")
3264 
3265             if mask is not None:
3266                 if len(self.columns) != len(mask):
3267                     raise ValueError("Mismatch between number of masks and columns")
3268             else:
3269                 mask = [False] * len(self.columns)
3270 
3271         else:
3272             raise TypeError("Vals must be an iterable or mapping or None")
3273 
3274         # Insert val at index for each column
3275         columns = self.TableColumns()
3276         for name, col, val, mask_ in zip(colnames, self.columns.values(), vals, mask):
3277             try:
3278                 # If new val is masked and the existing column does not support masking
3279                 # then upgrade the column to a mask-enabled type: either the table-level
3280                 # default ColumnClass or else MaskedColumn.
3281                 if (
3282                     mask_
3283                     and isinstance(col, Column)
3284                     and not isinstance(col, MaskedColumn)
3285                 ):
3286                     col_cls = (
3287                         self.ColumnClass
3288                         if issubclass(self.ColumnClass, self.MaskedColumn)
3289                         else self.MaskedColumn
3290                     )
3291                     col = col_cls(col, copy=False)
3292 
3293                 newcol = col.insert(index, val, axis=0)
3294 
3295                 if len(newcol) != N + 1:
3296                     raise ValueError(
3297                         "Incorrect length for column {} after inserting {}"
3298                         " (expected {}, got {})".format(name, val, len(newcol), N + 1)
3299                     )
3300                 newcol.info.parent_table = self
3301 
3302                 # Set mask if needed and possible
3303                 if mask_:
3304                     if hasattr(newcol, "mask"):
3305                         newcol[index] = np.ma.masked
3306                     else:
3307                         raise TypeError(
3308                             "mask was supplied for column '{}' but it does not "
3309                             "support masked values".format(col.info.name)
3310                         )
3311 
3312                 columns[name] = newcol
3313 
3314             except Exception as err:
3315                 raise ValueError(
3316                     "Unable to insert row because of exception in column '{}':\n{}".format(
3317                         name, err
3318                     )
3319                 ) from err
3320 
3321         for table_index in self.indices:
3322             table_index.insert_row(index, vals, self.columns.values())
3323 
3324         self._replace_cols(columns)
3325 
3326         # Revert groups to default (ungrouped) state
3327         if hasattr(self, "_groups"):
3328             del self._groups
3329 
3330     def _replace_cols(self, columns):
3331         for col, new_col in zip(self.columns.values(), columns.values()):
3332             new_col.info.indices = []
3333             for index in col.info.indices:
3334                 index.columns[index.col_position(col.info.name)] = new_col
3335                 new_col.info.indices.append(index)
3336 
3337         self.columns = columns
3338 
3339     def update(self, other, copy=True):
3340         """
3341         Perform a dictionary-style update and merge metadata.
3342 
3343         The argument ``other`` must be a |Table|, or something that can be used
3344         to initialize a table. Columns from (possibly converted) ``other`` are
3345         added to this table. In case of matching column names the column from
3346         this table is replaced with the one from ``other``. If ``other`` is a
3347         |Table| instance then ``|=`` is available as alternate syntax for in-place
3348         update and ``|`` can be used merge data to a new table.
3349 
3350         Parameters
3351         ----------
3352         other : table-like
3353             Data to update this table with.
3354         copy : bool
3355             Whether the updated columns should be copies of or references to
3356             the originals.
3357 
3358         See Also
3359         --------
3360         add_columns, astropy.table.hstack, replace_column
3361 
3362         Examples
3363         --------
3364         Update a table with another table::
3365 
3366             >>> t1 = Table({'a': ['foo', 'bar'], 'b': [0., 0.]}, meta={'i': 0})
3367             >>> t2 = Table({'b': [1., 2.], 'c': [7., 11.]}, meta={'n': 2})
3368             >>> t1.update(t2)
3369             >>> t1
3370             <Table length=2>
3371              a      b       c
3372             str3 float64 float64
3373             ---- ------- -------
3374              foo     1.0     7.0
3375              bar     2.0    11.0
3376             >>> t1.meta
3377             {'i': 0, 'n': 2}
3378 
3379         Update a table with a dictionary::
3380 
3381             >>> t = Table({'a': ['foo', 'bar'], 'b': [0., 0.]})
3382             >>> t.update({'b': [1., 2.]})
3383             >>> t
3384             <Table length=2>
3385              a      b
3386             str3 float64
3387             ---- -------
3388              foo     1.0
3389              bar     2.0
3390         """
3391         from .operations import _merge_table_meta
3392 
3393         if not isinstance(other, Table):
3394             other = self.__class__(other, copy=copy)
3395         common_cols = set(self.colnames).intersection(other.colnames)
3396         for name, col in other.items():
3397             if name in common_cols:
3398                 self.replace_column(name, col, copy=copy)
3399             else:
3400                 self.add_column(col, name=name, copy=copy)
3401         _merge_table_meta(self, [self, other], metadata_conflicts="silent")
3402 
3403     def argsort(self, keys=None, kind=None, reverse=False):
3404         """
3405         Return the indices which would sort the table according to one or
3406         more key columns.  This simply calls the `numpy.argsort` function on
3407         the table with the ``order`` parameter set to ``keys``.
3408 
3409         Parameters
3410         ----------
3411         keys : str or list of str
3412             The column name(s) to order the table by
3413         kind : {'quicksort', 'mergesort', 'heapsort', 'stable'}, optional
3414             Sorting algorithm used by ``numpy.argsort``.
3415         reverse : bool
3416             Sort in reverse order (default=False)
3417 
3418         Returns
3419         -------
3420         index_array : ndarray, int
3421             Array of indices that sorts the table by the specified key
3422             column(s).
3423         """
3424         if isinstance(keys, str):
3425             keys = [keys]
3426 
3427         # use index sorted order if possible
3428         if keys is not None:
3429             index = get_index(self, names=keys)
3430             if index is not None:
3431                 idx = np.asarray(index.sorted_data())
3432                 return idx[::-1] if reverse else idx
3433 
3434         kwargs = {}
3435         if keys:
3436             # For multiple keys return a structured array which gets sorted,
3437             # while for a single key return a single ndarray.  Sorting a
3438             # one-column structured array is slower than ndarray (e.g. a
3439             # factor of ~6 for a 10 million long random array), and much slower
3440             # for in principle sortable columns like Time, which get stored as
3441             # object arrays.
3442             if len(keys) > 1:
3443                 kwargs["order"] = keys
3444                 data = self.as_array(names=keys)
3445             else:
3446                 data = self[keys[0]]
3447         else:
3448             # No keys provided so sort on all columns.
3449             data = self.as_array()
3450 
3451         if kind:
3452             kwargs["kind"] = kind
3453 
3454         # np.argsort will look for a possible .argsort method (e.g., for Time),
3455         # and if that fails cast to an array and try sorting that way.
3456         idx = np.argsort(data, **kwargs)
3457 
3458         return idx[::-1] if reverse else idx
3459 
3460     def sort(self, keys=None, *, kind=None, reverse=False):
3461         """
3462         Sort the table according to one or more keys. This operates
3463         on the existing table and does not return a new table.
3464 
3465         Parameters
3466         ----------
3467         keys : str or list of str
3468             The key(s) to order the table by. If None, use the
3469             primary index of the Table.
3470         kind : {'quicksort', 'mergesort', 'heapsort', 'stable'}, optional
3471             Sorting algorithm used by ``numpy.argsort``.
3472         reverse : bool
3473             Sort in reverse order (default=False)
3474 
3475         Examples
3476         --------
3477         Create a table with 3 columns::
3478 
3479             >>> t = Table([['Max', 'Jo', 'John'], ['Miller', 'Miller', 'Jackson'],
3480             ...            [12, 15, 18]], names=('firstname', 'name', 'tel'))
3481             >>> print(t)
3482             firstname   name  tel
3483             --------- ------- ---
3484                   Max  Miller  12
3485                    Jo  Miller  15
3486                  John Jackson  18
3487 
3488         Sorting according to standard sorting rules, first 'name' then 'firstname'::
3489 
3490             >>> t.sort(['name', 'firstname'])
3491             >>> print(t)
3492             firstname   name  tel
3493             --------- ------- ---
3494                  John Jackson  18
3495                    Jo  Miller  15
3496                   Max  Miller  12
3497 
3498         Sorting according to standard sorting rules, first 'firstname' then 'tel',
3499         in reverse order::
3500 
3501             >>> t.sort(['firstname', 'tel'], reverse=True)
3502             >>> print(t)
3503             firstname   name  tel
3504             --------- ------- ---
3505                   Max  Miller  12
3506                  John Jackson  18
3507                    Jo  Miller  15
3508         """
3509         if keys is None:
3510             if not self.indices:
3511                 raise ValueError("Table sort requires input keys or a table index")
3512             keys = [x.info.name for x in self.indices[0].columns]
3513 
3514         if isinstance(keys, str):
3515             keys = [keys]
3516 
3517         indexes = self.argsort(keys, kind=kind, reverse=reverse)
3518 
3519         with self.index_mode("freeze"):
3520             for name, col in self.columns.items():
3521                 # Make a new sorted column.  This requires that take() also copies
3522                 # relevant info attributes for mixin columns.
3523                 new_col = col.take(indexes, axis=0)
3524 
3525                 # First statement in try: will succeed if the column supports an in-place
3526                 # update, and matches the legacy behavior of astropy Table.  However,
3527                 # some mixin classes may not support this, so in that case just drop
3528                 # in the entire new column. See #9553 and #9536 for discussion.
3529                 try:
3530                     col[:] = new_col
3531                 except Exception:
3532                     # In-place update failed for some reason, exception class not
3533                     # predictable for arbitrary mixin.
3534                     self[col.info.name] = new_col
3535 
3536     def reverse(self):
3537         """
3538         Reverse the row order of table rows.  The table is reversed
3539         in place and there are no function arguments.
3540 
3541         Examples
3542         --------
3543         Create a table with three columns::
3544 
3545             >>> t = Table([['Max', 'Jo', 'John'], ['Miller','Miller','Jackson'],
3546             ...         [12,15,18]], names=('firstname','name','tel'))
3547             >>> print(t)
3548             firstname   name  tel
3549             --------- ------- ---
3550                   Max  Miller  12
3551                    Jo  Miller  15
3552                  John Jackson  18
3553 
3554         Reversing order::
3555 
3556             >>> t.reverse()
3557             >>> print(t)
3558             firstname   name  tel
3559             --------- ------- ---
3560                  John Jackson  18
3561                    Jo  Miller  15
3562                   Max  Miller  12
3563         """
3564         for col in self.columns.values():
3565             # First statement in try: will succeed if the column supports an in-place
3566             # update, and matches the legacy behavior of astropy Table.  However,
3567             # some mixin classes may not support this, so in that case just drop
3568             # in the entire new column. See #9836, #9553, and #9536 for discussion.
3569             new_col = col[::-1]
3570             try:
3571                 col[:] = new_col
3572             except Exception:
3573                 # In-place update failed for some reason, exception class not
3574                 # predictable for arbitrary mixin.
3575                 self[col.info.name] = new_col
3576 
3577         for index in self.indices:
3578             index.reverse()
3579 
3580     def round(self, decimals=0):
3581         """
3582         Round numeric columns in-place to the specified number of decimals.
3583         Non-numeric columns will be ignored.
3584 
3585         Examples
3586         --------
3587         Create three columns with different types:
3588 
3589             >>> t = Table([[1, 4, 5], [-25.55, 12.123, 85],
3590             ...     ['a', 'b', 'c']], names=('a', 'b', 'c'))
3591             >>> print(t)
3592              a    b     c
3593             --- ------ ---
3594               1 -25.55   a
3595               4 12.123   b
3596               5   85.0   c
3597 
3598         Round them all to 0:
3599 
3600             >>> t.round(0)
3601             >>> print(t)
3602              a    b    c
3603             --- ----- ---
3604               1 -26.0   a
3605               4  12.0   b
3606               5  85.0   c
3607 
3608         Round column 'a' to -1 decimal:
3609 
3610             >>> t.round({'a':-1})
3611             >>> print(t)
3612              a    b    c
3613             --- ----- ---
3614               0 -26.0   a
3615               0  12.0   b
3616               0  85.0   c
3617 
3618         Parameters
3619         ----------
3620         decimals: int, dict
3621             Number of decimals to round the columns to. If a dict is given,
3622             the columns will be rounded to the number specified as the value.
3623             If a certain column is not in the dict given, it will remain the
3624             same.
3625         """
3626         if isinstance(decimals, Mapping):
3627             decimal_values = decimals.values()
3628             column_names = decimals.keys()
3629         elif isinstance(decimals, int):
3630             decimal_values = itertools.repeat(decimals)
3631             column_names = self.colnames
3632         else:
3633             raise ValueError("'decimals' argument must be an int or a dict")
3634 
3635         for colname, decimal in zip(column_names, decimal_values):
3636             col = self.columns[colname]
3637             if np.issubdtype(col.info.dtype, np.number):
3638                 try:
3639                     np.around(col, decimals=decimal, out=col)
3640                 except TypeError:
3641                     # Bug in numpy see https://github.com/numpy/numpy/issues/15438
3642                     col[()] = np.around(col, decimals=decimal)
3643 
3644     def copy(self, copy_data=True):
3645         """
3646         Return a copy of the table.
3647 
3648         Parameters
3649         ----------
3650         copy_data : bool
3651             If `True` (the default), copy the underlying data array.
3652             Otherwise, use the same data array. The ``meta`` is always
3653             deepcopied regardless of the value for ``copy_data``.
3654         """
3655         out = self.__class__(self, copy=copy_data)
3656 
3657         # If the current table is grouped then do the same in the copy
3658         if hasattr(self, "_groups"):
3659             out._groups = groups.TableGroups(
3660                 out, indices=self._groups._indices, keys=self._groups._keys
3661             )
3662         return out
3663 
3664     def __deepcopy__(self, memo=None):
3665         return self.copy(True)
3666 
3667     def __copy__(self):
3668         return self.copy(False)
3669 
3670     def __lt__(self, other):
3671         return super().__lt__(other)
3672 
3673     def __gt__(self, other):
3674         return super().__gt__(other)
3675 
3676     def __le__(self, other):
3677         return super().__le__(other)
3678 
3679     def __ge__(self, other):
3680         return super().__ge__(other)
3681 
3682     def __eq__(self, other):
3683         return self._rows_equal(other)
3684 
3685     def __ne__(self, other):
3686         return ~self.__eq__(other)
3687 
3688     def _rows_equal(self, other):
3689         """
3690         Row-wise comparison of table with any other object.
3691 
3692         This is actual implementation for __eq__.
3693 
3694         Returns a 1-D boolean numpy array showing result of row-wise comparison.
3695         This is the same as the ``==`` comparison for tables.
3696 
3697         Parameters
3698         ----------
3699         other : Table or DataFrame or ndarray
3700              An object to compare with table
3701 
3702         Examples
3703         --------
3704         Comparing one Table with other::
3705 
3706             >>> t1 = Table([[1,2],[4,5],[7,8]], names=('a','b','c'))
3707             >>> t2 = Table([[1,2],[4,5],[7,8]], names=('a','b','c'))
3708             >>> t1._rows_equal(t2)
3709             array([ True,  True])
3710 
3711         """
3712         if isinstance(other, Table):
3713             other = other.as_array()
3714 
3715         if self.has_masked_columns:
3716             if isinstance(other, np.ma.MaskedArray):
3717                 result = self.as_array() == other
3718             else:
3719                 # If mask is True, then by definition the row doesn't match
3720                 # because the other array is not masked.
3721                 false_mask = np.zeros(1, dtype=[(n, bool) for n in self.dtype.names])
3722                 result = (self.as_array().data == other) & (self.mask == false_mask)
3723         else:
3724             if isinstance(other, np.ma.MaskedArray):
3725                 # If mask is True, then by definition the row doesn't match
3726                 # because the other array is not masked.
3727                 false_mask = np.zeros(1, dtype=[(n, bool) for n in other.dtype.names])
3728                 result = (self.as_array() == other.data) & (other.mask == false_mask)
3729             else:
3730                 result = self.as_array() == other
3731 
3732         return result
3733 
3734     def values_equal(self, other):
3735         """
3736         Element-wise comparison of table with another table, list, or scalar.
3737 
3738         Returns a ``Table`` with the same columns containing boolean values
3739         showing result of comparison.
3740 
3741         Parameters
3742         ----------
3743         other : table-like object or list or scalar
3744              Object to compare with table
3745 
3746         Examples
3747         --------
3748         Compare one Table with other::
3749 
3750           >>> t1 = Table([[1, 2], [4, 5], [-7, 8]], names=('a', 'b', 'c'))
3751           >>> t2 = Table([[1, 2], [-4, 5], [7, 8]], names=('a', 'b', 'c'))
3752           >>> t1.values_equal(t2)
3753           <Table length=2>
3754            a     b     c
3755           bool  bool  bool
3756           ---- ----- -----
3757           True False False
3758           True  True  True
3759 
3760         """
3761         if isinstance(other, Table):
3762             names = other.colnames
3763         else:
3764             try:
3765                 other = Table(other, copy=False)
3766                 names = other.colnames
3767             except Exception:
3768                 # Broadcast other into a dict, so e.g. other = 2 will turn into
3769                 # other = {'a': 2, 'b': 2} and then equality does a
3770                 # column-by-column broadcasting.
3771                 names = self.colnames
3772                 other = {name: other for name in names}
3773 
3774         # Require column names match but do not require same column order
3775         if set(self.colnames) != set(names):
3776             raise ValueError("cannot compare tables with different column names")
3777 
3778         eqs = []
3779         for name in names:
3780             try:
3781                 np.broadcast(self[name], other[name])  # Check if broadcast-able
3782                 # Catch the numpy FutureWarning related to equality checking,
3783                 # "elementwise comparison failed; returning scalar instead, but
3784                 #  in the future will perform elementwise comparison".  Turn this
3785                 # into an exception since the scalar answer is not what we want.
3786                 with warnings.catch_warnings(record=True) as warns:
3787                     warnings.simplefilter("always")
3788                     eq = self[name] == other[name]
3789                     if (
3790                         warns
3791                         and issubclass(warns[-1].category, FutureWarning)
3792                         and "elementwise comparison failed" in str(warns[-1].message)
3793                     ):
3794                         raise FutureWarning(warns[-1].message)
3795             except Exception as err:
3796                 raise ValueError(f"unable to compare column {name}") from err
3797 
3798             # Be strict about the result from the comparison. E.g. SkyCoord __eq__ is just
3799             # broken and completely ignores that it should return an array.
3800             if not (
3801                 isinstance(eq, np.ndarray)
3802                 and eq.dtype is np.dtype("bool")
3803                 and len(eq) == len(self)
3804             ):
3805                 raise TypeError(
3806                     f"comparison for column {name} returned {eq} "
3807                     "instead of the expected boolean ndarray"
3808                 )
3809 
3810             eqs.append(eq)
3811 
3812         out = Table(eqs, names=names)
3813 
3814         return out
3815 
3816     @property
3817     def groups(self):
3818         if not hasattr(self, "_groups"):
3819             self._groups = groups.TableGroups(self)
3820         return self._groups
3821 
3822     def group_by(self, keys):
3823         """
3824         Group this table by the specified ``keys``.
3825 
3826         This effectively splits the table into groups which correspond to unique
3827         values of the ``keys`` grouping object.  The output is a new
3828         `~astropy.table.TableGroups` which contains a copy of this table but
3829         sorted by row according to ``keys``.
3830 
3831         The ``keys`` input to `group_by` can be specified in different ways:
3832 
3833           - String or list of strings corresponding to table column name(s)
3834           - Numpy array (homogeneous or structured) with same length as this table
3835           - `~astropy.table.Table` with same length as this table
3836 
3837         Parameters
3838         ----------
3839         keys : str, list of str, numpy array, or `~astropy.table.Table`
3840             Key grouping object
3841 
3842         Returns
3843         -------
3844         out : `~astropy.table.Table`
3845             New table with groups set
3846         """
3847         return groups.table_group_by(self, keys)
3848 
3849     def to_pandas(self, index=None, use_nullable_int=True):
3850         """
3851         Return a :class:`pandas.DataFrame` instance.
3852 
3853         The index of the created DataFrame is controlled by the ``index``
3854         argument.  For ``index=True`` or the default ``None``, an index will be
3855         specified for the DataFrame if there is a primary key index on the
3856         Table *and* if it corresponds to a single column.  If ``index=False``
3857         then no DataFrame index will be specified.  If ``index`` is the name of
3858         a column in the table then that will be the DataFrame index.
3859 
3860         In addition to vanilla columns or masked columns, this supports Table
3861         mixin columns like Quantity, Time, or SkyCoord.  In many cases these
3862         objects have no analog in pandas and will be converted to a "encoded"
3863         representation using only Column or MaskedColumn.  The exception is
3864         Time or TimeDelta columns, which will be converted to the corresponding
3865         representation in pandas using ``np.datetime64`` or ``np.timedelta64``.
3866         See the example below.
3867 
3868         Parameters
3869         ----------
3870         index : None, bool, str
3871             Specify DataFrame index mode
3872         use_nullable_int : bool, default=True
3873             Convert integer MaskedColumn to pandas nullable integer type.
3874             If ``use_nullable_int=False`` or the pandas version does not support
3875             nullable integer types (version < 0.24), then the column is converted
3876             to float with NaN for missing elements and a warning is issued.
3877 
3878         Returns
3879         -------
3880         dataframe : :class:`pandas.DataFrame`
3881             A pandas :class:`pandas.DataFrame` instance
3882 
3883         Raises
3884         ------
3885         ImportError
3886             If pandas is not installed
3887         ValueError
3888             If the Table has multi-dimensional columns
3889 
3890         Examples
3891         --------
3892         Here we convert a table with a few mixins to a
3893         :class:`pandas.DataFrame` instance.
3894 
3895           >>> import pandas as pd
3896           >>> from astropy.table import QTable
3897           >>> import astropy.units as u
3898           >>> from astropy.time import Time, TimeDelta
3899           >>> from astropy.coordinates import SkyCoord
3900 
3901           >>> q = [1, 2] * u.m
3902           >>> tm = Time([1998, 2002], format='jyear')
3903           >>> sc = SkyCoord([5, 6], [7, 8], unit='deg')
3904           >>> dt = TimeDelta([3, 200] * u.s)
3905 
3906           >>> t = QTable([q, tm, sc, dt], names=['q', 'tm', 'sc', 'dt'])
3907 
3908           >>> df = t.to_pandas(index='tm')
3909           >>> with pd.option_context('display.max_columns', 20):
3910           ...     print(df)
3911                         q  sc.ra  sc.dec              dt
3912           tm
3913           1998-01-01  1.0    5.0     7.0 0 days 00:00:03
3914           2002-01-01  2.0    6.0     8.0 0 days 00:03:20
3915 
3916         """
3917         from pandas import DataFrame, Series
3918 
3919         if index is not False:
3920             if index in (None, True):
3921                 # Default is to use the table primary key if available and a single column
3922                 if self.primary_key and len(self.primary_key) == 1:
3923                     index = self.primary_key[0]
3924                 else:
3925                     index = False
3926             else:
3927                 if index not in self.colnames:
3928                     raise ValueError(
3929                         "index must be None, False, True or a table column name"
3930                     )
3931 
3932         def _encode_mixins(tbl):
3933             """Encode a Table ``tbl`` that may have mixin columns to a Table with only
3934             astropy Columns + appropriate meta-data to allow subsequent decoding.
3935             """
3936             from astropy.time import TimeBase, TimeDelta
3937 
3938             from . import serialize
3939 
3940             # Convert any Time or TimeDelta columns and pay attention to masking
3941             time_cols = [col for col in tbl.itercols() if isinstance(col, TimeBase)]
3942             if time_cols:
3943                 # Make a light copy of table and clear any indices
3944                 new_cols = []
3945                 for col in tbl.itercols():
3946                     new_col = (
3947                         col_copy(col, copy_indices=False) if col.info.indices else col
3948                     )
3949                     new_cols.append(new_col)
3950                 tbl = tbl.__class__(new_cols, copy=False)
3951 
3952                 # Certain subclasses (e.g. TimeSeries) may generate new indices on
3953                 # table creation, so make sure there are no indices on the table.
3954                 for col in tbl.itercols():
3955                     col.info.indices.clear()
3956 
3957                 for col in time_cols:
3958                     if isinstance(col, TimeDelta):
3959                         # Convert to nanoseconds (matches astropy datetime64 support)
3960                         new_col = (col.sec * 1e9).astype("timedelta64[ns]")
3961                         nat = np.timedelta64("NaT")
3962                     else:
3963                         new_col = col.datetime64.copy()
3964                         nat = np.datetime64("NaT")
3965                     if col.masked:
3966                         new_col[col.mask] = nat
3967                     tbl[col.info.name] = new_col
3968 
3969             # Convert the table to one with no mixins, only Column objects.
3970             encode_tbl = serialize.represent_mixins_as_columns(tbl)
3971             return encode_tbl
3972 
3973         tbl = _encode_mixins(self)
3974 
3975         badcols = [name for name, col in self.columns.items() if len(col.shape) > 1]
3976         if badcols:
3977             # fmt: off
3978             raise ValueError(
3979                 f'Cannot convert a table with multidimensional columns to a '
3980                 f'pandas DataFrame. Offending columns are: {badcols}\n'
3981                 f'One can filter out such columns using:\n'
3982                 f'names = [name for name in tbl.colnames if len(tbl[name].shape) <= 1]\n'
3983                 f'tbl[names].to_pandas(...)'
3984             )
3985             # fmt: on
3986 
3987         out = OrderedDict()
3988 
3989         for name, column in tbl.columns.items():
3990             if getattr(column.dtype, "isnative", True):
3991                 out[name] = column
3992             else:
3993                 out[name] = column.data.byteswap().newbyteorder("=")
3994 
3995             if isinstance(column, MaskedColumn) and np.any(column.mask):
3996                 if column.dtype.kind in ["i", "u"]:
3997                     pd_dtype = column.dtype.name
3998                     if use_nullable_int:
3999                         # Convert int64 to Int64, uint32 to UInt32, etc for nullable types
4000                         pd_dtype = pd_dtype.replace("i", "I").replace("u", "U")
4001                     out[name] = Series(out[name], dtype=pd_dtype)
4002 
4003                     # If pandas is older than 0.24 the type may have turned to float
4004                     if column.dtype.kind != out[name].dtype.kind:
4005                         warnings.warn(
4006                             f"converted column '{name}' from {column.dtype} to"
4007                             f" {out[name].dtype}",
4008                             TableReplaceWarning,
4009                             stacklevel=3,
4010                         )
4011                 elif column.dtype.kind not in ["f", "c"]:
4012                     out[name] = column.astype(object).filled(np.nan)
4013 
4014         kwargs = {}
4015 
4016         if index:
4017             idx = out.pop(index)
4018 
4019             kwargs["index"] = idx
4020 
4021             # We add the table index to Series inputs (MaskedColumn with int values) to override
4022             # its default RangeIndex, see #11432
4023             for v in out.values():
4024                 if isinstance(v, Series):
4025                     v.index = idx
4026 
4027         df = DataFrame(out, **kwargs)
4028         if index:
4029             # Explicitly set the pandas DataFrame index to the original table
4030             # index name.
4031             df.index.name = idx.info.name
4032 
4033         return df
4034 
4035     @classmethod
4036     def from_pandas(cls, dataframe, index=False, units=None):
4037         """
4038         Create a `~astropy.table.Table` from a :class:`pandas.DataFrame` instance.
4039 
4040         In addition to converting generic numeric or string columns, this supports
4041         conversion of pandas Date and Time delta columns to `~astropy.time.Time`
4042         and `~astropy.time.TimeDelta` columns, respectively.
4043 
4044         Parameters
4045         ----------
4046         dataframe : :class:`pandas.DataFrame`
4047             A pandas :class:`pandas.DataFrame` instance
4048         index : bool
4049             Include the index column in the returned table (default=False)
4050         units: dict
4051             A dict mapping column names to to a `~astropy.units.Unit`.
4052             The columns will have the specified unit in the Table.
4053 
4054         Returns
4055         -------
4056         table : `~astropy.table.Table`
4057             A `~astropy.table.Table` (or subclass) instance
4058 
4059         Raises
4060         ------
4061         ImportError
4062             If pandas is not installed
4063 
4064         Examples
4065         --------
4066         Here we convert a :class:`pandas.DataFrame` instance
4067         to a `~astropy.table.QTable`.
4068 
4069           >>> import numpy as np
4070           >>> import pandas as pd
4071           >>> from astropy.table import QTable
4072 
4073           >>> time = pd.Series(['1998-01-01', '2002-01-01'], dtype='datetime64[ns]')
4074           >>> dt = pd.Series(np.array([1, 300], dtype='timedelta64[s]'))
4075           >>> df = pd.DataFrame({'time': time})
4076           >>> df['dt'] = dt
4077           >>> df['x'] = [3., 4.]
4078           >>> with pd.option_context('display.max_columns', 20):
4079           ...     print(df)
4080                   time              dt    x
4081           0 1998-01-01 0 days 00:00:01  3.0
4082           1 2002-01-01 0 days 00:05:00  4.0
4083 
4084           >>> QTable.from_pandas(df)
4085           <QTable length=2>
4086                     time              dt       x
4087                     Time          TimeDelta float64
4088           ----------------------- --------- -------
4089           1998-01-01T00:00:00.000       1.0     3.0
4090           2002-01-01T00:00:00.000     300.0     4.0
4091 
4092         """
4093         out = OrderedDict()
4094 
4095         names = list(dataframe.columns)
4096         columns = [dataframe[name] for name in names]
4097         datas = [np.array(column) for column in columns]
4098         masks = [np.array(column.isnull()) for column in columns]
4099 
4100         if index:
4101             index_name = dataframe.index.name or "index"
4102             while index_name in names:
4103                 index_name = "_" + index_name + "_"
4104             names.insert(0, index_name)
4105             columns.insert(0, dataframe.index)
4106             datas.insert(0, np.array(dataframe.index))
4107             masks.insert(0, np.zeros(len(dataframe), dtype=bool))
4108 
4109         if units is None:
4110             units = [None] * len(names)
4111         else:
4112             if not isinstance(units, Mapping):
4113                 raise TypeError('Expected a Mapping "column-name" -> "unit"')
4114 
4115             not_found = set(units.keys()) - set(names)
4116             if not_found:
4117                 warnings.warn(f"`units` contains additional columns: {not_found}")
4118 
4119             units = [units.get(name) for name in names]
4120 
4121         for name, column, data, mask, unit in zip(names, columns, datas, masks, units):
4122             if column.dtype.kind in ["u", "i"] and np.any(mask):
4123                 # Special-case support for pandas nullable int
4124                 np_dtype = str(column.dtype).lower()
4125                 data = np.zeros(shape=column.shape, dtype=np_dtype)
4126                 data[~mask] = column[~mask]
4127                 out[name] = MaskedColumn(
4128                     data=data, name=name, mask=mask, unit=unit, copy=False
4129                 )
4130                 continue
4131 
4132             if data.dtype.kind == "O":
4133                 # If all elements of an object array are string-like or np.nan
4134                 # then coerce back to a native numpy str/unicode array.
4135                 string_types = (str, bytes)
4136                 nan = np.nan
4137                 if all(isinstance(x, string_types) or x is nan for x in data):
4138                     # Force any missing (null) values to b''.  Numpy will
4139                     # upcast to str/unicode as needed.
4140                     data[mask] = b""
4141 
4142                     # When the numpy object array is represented as a list then
4143                     # numpy initializes to the correct string or unicode type.
4144                     data = np.array(list(data))
4145 
4146             # Numpy datetime64
4147             if data.dtype.kind == "M":
4148                 from astropy.time import Time
4149 
4150                 out[name] = Time(data, format="datetime64")
4151                 if np.any(mask):
4152                     out[name][mask] = np.ma.masked
4153                 out[name].format = "isot"
4154 
4155             # Numpy timedelta64
4156             elif data.dtype.kind == "m":
4157                 from astropy.time import TimeDelta
4158 
4159                 data_sec = data.astype("timedelta64[ns]").astype(np.float64) / 1e9
4160                 out[name] = TimeDelta(data_sec, format="sec")
4161                 if np.any(mask):
4162                     out[name][mask] = np.ma.masked
4163 
4164             else:
4165                 if np.any(mask):
4166                     out[name] = MaskedColumn(data=data, name=name, mask=mask, unit=unit)
4167                 else:
4168                     out[name] = Column(data=data, name=name, unit=unit)
4169 
4170         return cls(out)
4171 
4172     info = TableInfo()

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>, <file>astropy/table/groups.py</file>
<class>None</class>
<method>table_group_by</method>
<code>
15 def table_group_by(table, keys):
16     # index copies are unnecessary and slow down _table_group_by
17     with table.index_mode("discard_on_copy"):
18         return _table_group_by(table, keys)

</code><intended_behavior>This function should be modified or enhanced to correctly handle quantity columns by ensuring that units are not discarded during the process of grouping. To resolve the issue, this function needs to identify columns with quantity data and treat them such that their units are preserved in the group keys. This may require a mechanism to explicitly check and retain units when forming group keys from quantity columns.</intended_behavior>]
2025-10-17 22:23:33.045 | INFO     | Search completed. Bug locations: [<file>astropy/table/table.py</file>
<class>Table</class>
<method>group_by</method>
<code>
3822     def group_by(self, keys):
3823         """
3824         Group this table by the specified ``keys``.
3825 
3826         This effectively splits the table into groups which correspond to unique
3827         values of the ``keys`` grouping object.  The output is a new
3828         `~astropy.table.TableGroups` which contains a copy of this table but
3829         sorted by row according to ``keys``.
3830 
3831         The ``keys`` input to `group_by` can be specified in different ways:
3832 
3833           - String or list of strings corresponding to table column name(s)
3834           - Numpy array (homogeneous or structured) with same length as this table
3835           - `~astropy.table.Table` with same length as this table
3836 
3837         Parameters
3838         ----------
3839         keys : str, list of str, numpy array, or `~astropy.table.Table`
3840             Key grouping object
3841 
3842         Returns
3843         -------
3844         out : `~astropy.table.Table`
3845             New table with groups set
3846         """
3847         return groups.table_group_by(self, keys)

</code><intended_behavior>Modify the `group_by` method to ensure that when grouping is performed on columns containing quantities, the resulting group keys still preserve their unit information. This may involve changes to how the grouping keys are generated, such that they include both the value and the unit of quantities. This change must ensure that for non-quantity columns, the existing functionality remains unchanged, maintaining backward compatibility and preserving the method's current behavior for all other data types.</intended_behavior>, <file>astropy/table/table.py</file>
<class>Table</class>
<method>None</method>
<code>
566 class Table:
567     """A class to represent tables of heterogeneous data.
568 
569     `~astropy.table.Table` provides a class for heterogeneous tabular data.
570     A key enhancement provided by the `~astropy.table.Table` class over
571     e.g. a `numpy` structured array is the ability to easily modify the
572     structure of the table by adding or removing columns, or adding new
573     rows of data.  In addition table and column metadata are fully supported.
574 
575     `~astropy.table.Table` differs from `~astropy.nddata.NDData` by the
576     assumption that the input data consists of columns of homogeneous data,
577     where each column has a unique identifier and may contain additional
578     metadata such as the data unit, format, and description.
579 
580     See also: https://docs.astropy.org/en/stable/table/
581 
582     Parameters
583     ----------
584     data : numpy ndarray, dict, list, table-like object, optional
585         Data to initialize table.
586     masked : bool, optional
587         Specify whether the table is masked.
588     names : list, optional
589         Specify column names.
590     dtype : list, optional
591         Specify column data types.
592     meta : dict, optional
593         Metadata associated with the table.
594     copy : bool, optional
595         Copy the input data. If the input is a Table the ``meta`` is always
596         copied regardless of the ``copy`` parameter.
597         Default is True.
598     rows : numpy ndarray, list of list, optional
599         Row-oriented data for table instead of ``data`` argument.
600     copy_indices : bool, optional
601         Copy any indices in the input data. Default is True.
602     units : list, dict, optional
603         List or dict of units to apply to columns.
604     descriptions : list, dict, optional
605         List or dict of descriptions to apply to columns.
606     **kwargs : dict, optional
607         Additional keyword args when converting table-like object.
608     """
609 
610     meta = MetaData(copy=False)
611 
612     # Define class attributes for core container objects to allow for subclass
613     # customization.
614     Row = Row
615     Column = Column
616     MaskedColumn = MaskedColumn
617     TableColumns = TableColumns
618     TableFormatter = TableFormatter
619 
620     # Unified I/O read and write methods from .connect
621     read = UnifiedReadWriteMethod(TableRead)
622     write = UnifiedReadWriteMethod(TableWrite)
623 
624     pprint_exclude_names = PprintIncludeExclude()
625     pprint_include_names = PprintIncludeExclude()
626 
627     def as_array(self, keep_byteorder=False, names=None):
628         """
629         Return a new copy of the table in the form of a structured np.ndarray or
630         np.ma.MaskedArray object (as appropriate).
631 
632         Parameters
633         ----------
634         keep_byteorder : bool, optional
635             By default the returned array has all columns in native byte
636             order.  However, if this option is `True` this preserves the
637             byte order of all columns (if any are non-native).
638 
639         names : list, optional:
640             List of column names to include for returned structured array.
641             Default is to include all table columns.
642 
643         Returns
644         -------
645         table_array : array or `~numpy.ma.MaskedArray`
646             Copy of table as a numpy structured array.
647             ndarray for unmasked or `~numpy.ma.MaskedArray` for masked.
648         """
649         masked = self.masked or self.has_masked_columns or self.has_masked_values
650         empty_init = ma.empty if masked else np.empty
651         if len(self.columns) == 0:
652             return empty_init(0, dtype=None)
653 
654         dtype = []
655 
656         cols = self.columns.values()
657 
658         if names is not None:
659             cols = [col for col in cols if col.info.name in names]
660 
661         for col in cols:
662             col_descr = descr(col)
663 
664             if not (col.info.dtype.isnative or keep_byteorder):
665                 new_dt = np.dtype(col_descr[1]).newbyteorder("=")
666                 col_descr = (col_descr[0], new_dt, col_descr[2])
667 
668             dtype.append(col_descr)
669 
670         data = empty_init(len(self), dtype=dtype)
671         for col in cols:
672             # When assigning from one array into a field of a structured array,
673             # Numpy will automatically swap those columns to their destination
674             # byte order where applicable
675             data[col.info.name] = col
676 
677             # For masked out, masked mixin columns need to set output mask attribute.
678             if masked and has_info_class(col, MixinInfo) and hasattr(col, "mask"):
679                 data[col.info.name].mask = col.mask
680 
681         return data
682 
683     def __init__(
684         self,
685         data=None,
686         masked=False,
687         names=None,
688         dtype=None,
689         meta=None,
690         copy=True,
691         rows=None,
692         copy_indices=True,
693         units=None,
694         descriptions=None,
695         **kwargs,
696     ):
697         # Set up a placeholder empty table
698         self._set_masked(masked)
699         self.columns = self.TableColumns()
700         self.formatter = self.TableFormatter()
701         self._copy_indices = True  # copy indices from this Table by default
702         self._init_indices = copy_indices  # whether to copy indices in init
703         self.primary_key = None
704 
705         # Must copy if dtype are changing
706         if not copy and dtype is not None:
707             raise ValueError("Cannot specify dtype when copy=False")
708 
709         # Specifies list of names found for the case of initializing table with
710         # a list of dict. If data are not list of dict then this is None.
711         names_from_list_of_dict = None
712 
713         # Row-oriented input, e.g. list of lists or list of tuples, list of
714         # dict, Row instance.  Set data to something that the subsequent code
715         # will parse correctly.
716         if rows is not None:
717             if data is not None:
718                 raise ValueError("Cannot supply both `data` and `rows` values")
719             if isinstance(rows, types.GeneratorType):
720                 # Without this then the all(..) test below uses up the generator
721                 rows = list(rows)
722 
723             # Get column names if `rows` is a list of dict, otherwise this is None
724             names_from_list_of_dict = _get_names_from_list_of_dict(rows)
725             if names_from_list_of_dict:
726                 data = rows
727             elif isinstance(rows, self.Row):
728                 data = rows
729             else:
730                 data = list(zip(*rows))
731 
732         # Infer the type of the input data and set up the initialization
733         # function, number of columns, and potentially the default col names
734 
735         default_names = None
736 
737         # Handle custom (subclass) table attributes that are stored in meta.
738         # These are defined as class attributes using the TableAttribute
739         # descriptor.  Any such attributes get removed from kwargs here and
740         # stored for use after the table is otherwise initialized. Any values
741         # provided via kwargs will have precedence over existing values from
742         # meta (e.g. from data as a Table or meta via kwargs).
743         meta_table_attrs = {}
744         if kwargs:
745             for attr in list(kwargs):
746                 descr = getattr(self.__class__, attr, None)
747                 if isinstance(descr, TableAttribute):
748                     meta_table_attrs[attr] = kwargs.pop(attr)
749 
750         if hasattr(data, "__astropy_table__"):
751             # Data object implements the __astropy_table__ interface method.
752             # Calling that method returns an appropriate instance of
753             # self.__class__ and respects the `copy` arg.  The returned
754             # Table object should NOT then be copied.
755             data = data.__astropy_table__(self.__class__, copy, **kwargs)
756             copy = False
757         elif kwargs:
758             raise TypeError(
759                 f"__init__() got unexpected keyword argument {list(kwargs.keys())[0]!r}"
760             )
761 
762         if isinstance(data, np.ndarray) and data.shape == (0,) and not data.dtype.names:
763             data = None
764 
765         if isinstance(data, self.Row):
766             data = data._table[data._index : data._index + 1]
767 
768         if isinstance(data, (list, tuple)):
769             # Get column names from `data` if it is a list of dict, otherwise this is None.
770             # This might be previously defined if `rows` was supplied as an init arg.
771             names_from_list_of_dict = (
772                 names_from_list_of_dict or _get_names_from_list_of_dict(data)
773             )
774             if names_from_list_of_dict:
775                 init_func = self._init_from_list_of_dicts
776                 n_cols = len(names_from_list_of_dict)
777             else:
778                 init_func = self._init_from_list
779                 n_cols = len(data)
780 
781         elif isinstance(data, np.ndarray):
782             if data.dtype.names:
783                 init_func = self._init_from_ndarray  # _struct
784                 n_cols = len(data.dtype.names)
785                 default_names = data.dtype.names
786             else:
787                 init_func = self._init_from_ndarray  # _homog
788                 if data.shape == ():
789                     raise ValueError("Can not initialize a Table with a scalar")
790                 elif len(data.shape) == 1:
791                     data = data[np.newaxis, :]
792                 n_cols = data.shape[1]
793 
794         elif isinstance(data, Mapping):
795             init_func = self._init_from_dict
796             default_names = list(data)
797             n_cols = len(default_names)
798 
799         elif isinstance(data, Table):
800             # If user-input meta is None then use data.meta (if non-trivial)
801             if meta is None and data.meta:
802                 # At this point do NOT deepcopy data.meta as this will happen after
803                 # table init_func() is called.  But for table input the table meta
804                 # gets a key copy here if copy=False because later a direct object ref
805                 # is used.
806                 meta = data.meta if copy else data.meta.copy()
807 
808             # Handle indices on input table. Copy primary key and don't copy indices
809             # if the input Table is in non-copy mode.
810             self.primary_key = data.primary_key
811             self._init_indices = self._init_indices and data._copy_indices
812 
813             # Extract default names, n_cols, and then overwrite ``data`` to be the
814             # table columns so we can use _init_from_list.
815             default_names = data.colnames
816             n_cols = len(default_names)
817             data = list(data.columns.values())
818 
819             init_func = self._init_from_list
820 
821         elif data is None:
822             if names is None:
823                 if dtype is None:
824                     # Table was initialized as `t = Table()`. Set up for empty
825                     # table with names=[], data=[], and n_cols=0.
826                     # self._init_from_list() will simply return, giving the
827                     # expected empty table.
828                     names = []
829                 else:
830                     try:
831                         # No data nor names but dtype is available.  This must be
832                         # valid to initialize a structured array.
833                         dtype = np.dtype(dtype)
834                         names = dtype.names
835                         dtype = [dtype[name] for name in names]
836                     except Exception:
837                         raise ValueError(
838                             "dtype was specified but could not be "
839                             "parsed for column names"
840                         )
841             # names is guaranteed to be set at this point
842             init_func = self._init_from_list
843             n_cols = len(names)
844             data = [[]] * n_cols
845 
846         else:
847             raise ValueError(f"Data type {type(data)} not allowed to init Table")
848 
849         # Set up defaults if names and/or dtype are not specified.
850         # A value of None means the actual value will be inferred
851         # within the appropriate initialization routine, either from
852         # existing specification or auto-generated.
853 
854         if dtype is None:
855             dtype = [None] * n_cols
856         elif isinstance(dtype, np.dtype):
857             if default_names is None:
858                 default_names = dtype.names
859             # Convert a numpy dtype input to a list of dtypes for later use.
860             dtype = [dtype[name] for name in dtype.names]
861 
862         if names is None:
863             names = default_names or [None] * n_cols
864 
865         names = [None if name is None else str(name) for name in names]
866 
867         self._check_names_dtype(names, dtype, n_cols)
868 
869         # Finally do the real initialization
870         init_func(data, names, dtype, n_cols, copy)
871 
872         # Set table meta.  If copy=True then deepcopy meta otherwise use the
873         # user-supplied meta directly.
874         if meta is not None:
875             self.meta = deepcopy(meta) if copy else meta
876 
877         # Update meta with TableAttributes supplied as kwargs in Table init.
878         # This takes precedence over previously-defined meta.
879         if meta_table_attrs:
880             for attr, value in meta_table_attrs.items():
881                 setattr(self, attr, value)
882 
883         # Whatever happens above, the masked property should be set to a boolean
884         if self.masked not in (None, True, False):
885             raise TypeError("masked property must be None, True or False")
886 
887         self._set_column_attribute("unit", units)
888         self._set_column_attribute("description", descriptions)
889 
890     def _set_column_attribute(self, attr, values):
891         """Set ``attr`` for columns to ``values``, which can be either a dict (keyed by column
892         name) or a dict of name: value pairs.  This is used for handling the ``units`` and
893         ``descriptions`` kwargs to ``__init__``.
894         """
895         if not values:
896             return
897 
898         if isinstance(values, Row):
899             # For a Row object transform to an equivalent dict.
900             values = {name: values[name] for name in values.colnames}
901 
902         if not isinstance(values, Mapping):
903             # If not a dict map, assume iterable and map to dict if the right length
904             if len(values) != len(self.columns):
905                 raise ValueError(
906                     f"sequence of {attr} values must match number of columns"
907                 )
908             values = dict(zip(self.colnames, values))
909 
910         for name, value in values.items():
911             if name not in self.columns:
912                 raise ValueError(
913                     f"invalid column name {name} for setting {attr} attribute"
914                 )
915 
916             # Special case: ignore unit if it is an empty or blank string
917             if attr == "unit" and isinstance(value, str):
918                 if value.strip() == "":
919                     value = None
920 
921             if value not in (np.ma.masked, None):
922                 col = self[name]
923                 if attr == "unit" and isinstance(col, Quantity):
924                     # Update the Quantity unit in-place
925                     col <<= value
926                 else:
927                     setattr(col.info, attr, value)
928 
929     def __getstate__(self):
930         columns = OrderedDict(
931             (key, col if isinstance(col, BaseColumn) else col_copy(col))
932             for key, col in self.columns.items()
933         )
934         return (columns, self.meta)
935 
936     def __setstate__(self, state):
937         columns, meta = state
938         self.__init__(columns, meta=meta)
939 
940     @property
941     def mask(self):
942         # Dynamic view of available masks
943         if self.masked or self.has_masked_columns or self.has_masked_values:
944             mask_table = Table(
945                 [
946                     getattr(col, "mask", FalseArray(col.shape))
947                     for col in self.itercols()
948                 ],
949                 names=self.colnames,
950                 copy=False,
951             )
952 
953             # Set hidden attribute to force inplace setitem so that code like
954             # t.mask['a'] = [1, 0, 1] will correctly set the underlying mask.
955             # See #5556 for discussion.
956             mask_table._setitem_inplace = True
957         else:
958             mask_table = None
959 
960         return mask_table
961 
962     @mask.setter
963     def mask(self, val):
964         self.mask[:] = val
965 
966     @property
967     def _mask(self):
968         """This is needed so that comparison of a masked Table and a
969         MaskedArray works.  The requirement comes from numpy.ma.core
970         so don't remove this property.
971         """
972         return self.as_array().mask
973 
974     def filled(self, fill_value=None):
975         """Return copy of self, with masked values filled.
976 
977         If input ``fill_value`` supplied then that value is used for all
978         masked entries in the table.  Otherwise the individual
979         ``fill_value`` defined for each table column is used.
980 
981         Parameters
982         ----------
983         fill_value : str
984             If supplied, this ``fill_value`` is used for all masked entries
985             in the entire table.
986 
987         Returns
988         -------
989         filled_table : `~astropy.table.Table`
990             New table with masked values filled
991         """
992         if self.masked or self.has_masked_columns or self.has_masked_values:
993             # Get new columns with masked values filled, then create Table with those
994             # new cols (copy=False) but deepcopy the meta.
995             data = [
996                 col.filled(fill_value) if hasattr(col, "filled") else col
997                 for col in self.itercols()
998             ]
999             return self.__class__(data, meta=deepcopy(self.meta), copy=False)
1000         else:
1001             # Return copy of the original object.
1002             return self.copy()
1003 
1004     @property
1005     def indices(self):
1006         """
1007         Return the indices associated with columns of the table
1008         as a TableIndices object.
1009         """
1010         lst = []
1011         for column in self.columns.values():
1012             for index in column.info.indices:
1013                 if sum(index is x for x in lst) == 0:  # ensure uniqueness
1014                     lst.append(index)
1015         return TableIndices(lst)
1016 
1017     @property
1018     def loc(self):
1019         """
1020         Return a TableLoc object that can be used for retrieving
1021         rows by index in a given data range. Note that both loc
1022         and iloc work only with single-column indices.
1023         """
1024         return TableLoc(self)
1025 
1026     @property
1027     def loc_indices(self):
1028         """
1029         Return a TableLocIndices object that can be used for retrieving
1030         the row indices corresponding to given table index key value or values.
1031         """
1032         return TableLocIndices(self)
1033 
1034     @property
1035     def iloc(self):
1036         """
1037         Return a TableILoc object that can be used for retrieving
1038         indexed rows in the order they appear in the index.
1039         """
1040         return TableILoc(self)
1041 
1042     def add_index(self, colnames, engine=None, unique=False):
1043         """
1044         Insert a new index among one or more columns.
1045         If there are no indices, make this index the
1046         primary table index.
1047 
1048         Parameters
1049         ----------
1050         colnames : str or list
1051             List of column names (or a single column name) to index
1052         engine : type or None
1053             Indexing engine class to use, either `~astropy.table.SortedArray`,
1054             `~astropy.table.BST`, or `~astropy.table.SCEngine`. If the supplied
1055             argument is None (by default), use `~astropy.table.SortedArray`.
1056         unique : bool
1057             Whether the values of the index must be unique. Default is False.
1058         """
1059         if isinstance(colnames, str):
1060             colnames = (colnames,)
1061         columns = self.columns[tuple(colnames)].values()
1062 
1063         # make sure all columns support indexing
1064         for col in columns:
1065             if not getattr(col.info, "_supports_indexing", False):
1066                 raise ValueError(
1067                     'Cannot create an index on column "{}", of type "{}"'.format(
1068                         col.info.name, type(col)
1069                     )
1070                 )
1071 
1072         is_primary = not self.indices
1073         index = Index(columns, engine=engine, unique=unique)
1074         sliced_index = SlicedIndex(index, slice(0, 0, None), original=True)
1075         if is_primary:
1076             self.primary_key = colnames
1077         for col in columns:
1078             col.info.indices.append(sliced_index)
1079 
1080     def remove_indices(self, colname):
1081         """
1082         Remove all indices involving the given column.
1083         If the primary index is removed, the new primary
1084         index will be the most recently added remaining
1085         index.
1086 
1087         Parameters
1088         ----------
1089         colname : str
1090             Name of column
1091         """
1092         col = self.columns[colname]
1093         for index in self.indices:
1094             try:
1095                 index.col_position(col.info.name)
1096             except ValueError:
1097                 pass
1098             else:
1099                 for c in index.columns:
1100                     c.info.indices.remove(index)
1101 
1102     def index_mode(self, mode):
1103         """
1104         Return a context manager for an indexing mode.
1105 
1106         Parameters
1107         ----------
1108         mode : str
1109             Either 'freeze', 'copy_on_getitem', or 'discard_on_copy'.
1110             In 'discard_on_copy' mode,
1111             indices are not copied whenever columns or tables are copied.
1112             In 'freeze' mode, indices are not modified whenever columns are
1113             modified; at the exit of the context, indices refresh themselves
1114             based on column values. This mode is intended for scenarios in
1115             which one intends to make many additions or modifications in an
1116             indexed column.
1117             In 'copy_on_getitem' mode, indices are copied when taking column
1118             slices as well as table slices, so col[i0:i1] will preserve
1119             indices.
1120         """
1121         return _IndexModeContext(self, mode)
1122 
1123     def __array__(self, dtype=None):
1124         """Support converting Table to np.array via np.array(table).
1125 
1126         Coercion to a different dtype via np.array(table, dtype) is not
1127         supported and will raise a ValueError.
1128         """
1129         if dtype is not None:
1130             if np.dtype(dtype) != object:
1131                 raise ValueError("Datatype coercion is not allowed")
1132 
1133             out = np.array(None, dtype=object)
1134             out[()] = self
1135             return out
1136 
1137         # This limitation is because of the following unexpected result that
1138         # should have made a table copy while changing the column names.
1139         #
1140         # >>> d = astropy.table.Table([[1,2],[3,4]])
1141         # >>> np.array(d, dtype=[('a', 'i8'), ('b', 'i8')])
1142         # array([(0, 0), (0, 0)],
1143         #       dtype=[('a', '<i8'), ('b', '<i8')])
1144 
1145         out = self.as_array()
1146         return out.data if isinstance(out, np.ma.MaskedArray) else out
1147 
1148     def _check_names_dtype(self, names, dtype, n_cols):
1149         """Make sure that names and dtype are both iterable and have
1150         the same length as data.
1151         """
1152         for inp_list, inp_str in ((dtype, "dtype"), (names, "names")):
1153             if not isiterable(inp_list):
1154                 raise ValueError(f"{inp_str} must be a list or None")
1155 
1156         if len(names) != n_cols or len(dtype) != n_cols:
1157             raise ValueError(
1158                 'Arguments "names" and "dtype" must match number of columns'
1159             )
1160 
1161     def _init_from_list_of_dicts(self, data, names, dtype, n_cols, copy):
1162         """Initialize table from a list of dictionaries representing rows."""
1163         # Define placeholder for missing values as a unique object that cannot
1164         # every occur in user data.
1165         MISSING = object()
1166 
1167         # Gather column names that exist in the input `data`.
1168         names_from_data = set()
1169         for row in data:
1170             names_from_data.update(row)
1171 
1172         if set(data[0].keys()) == names_from_data:
1173             names_from_data = list(data[0].keys())
1174         else:
1175             names_from_data = sorted(names_from_data)
1176 
1177         # Note: if set(data[0].keys()) != names_from_data, this will give an
1178         # exception later, so NO need to catch here.
1179 
1180         # Convert list of dict into dict of list (cols), keep track of missing
1181         # indexes and put in MISSING placeholders in the `cols` lists.
1182         cols = {}
1183         missing_indexes = defaultdict(list)
1184         for name in names_from_data:
1185             cols[name] = []
1186             for ii, row in enumerate(data):
1187                 try:
1188                     val = row[name]
1189                 except KeyError:
1190                     missing_indexes[name].append(ii)
1191                     val = MISSING
1192                 cols[name].append(val)
1193 
1194         # Fill the missing entries with first values
1195         if missing_indexes:
1196             for name, indexes in missing_indexes.items():
1197                 col = cols[name]
1198                 first_val = next(val for val in col if val is not MISSING)
1199                 for index in indexes:
1200                     col[index] = first_val
1201 
1202         # prepare initialization
1203         if all(name is None for name in names):
1204             names = names_from_data
1205 
1206         self._init_from_dict(cols, names, dtype, n_cols, copy)
1207 
1208         # Mask the missing values if necessary, converting columns to MaskedColumn
1209         # as needed.
1210         if missing_indexes:
1211             for name, indexes in missing_indexes.items():
1212                 col = self[name]
1213                 # Ensure that any Column subclasses with MISSING values can support
1214                 # setting masked values. As of astropy 4.0 the test condition below is
1215                 # always True since _init_from_dict cannot result in mixin columns.
1216                 if isinstance(col, Column) and not isinstance(col, MaskedColumn):
1217                     self[name] = self.MaskedColumn(col, copy=False)
1218 
1219                 # Finally do the masking in a mixin-safe way.
1220                 self[name][indexes] = np.ma.masked
1221 
1222     def _init_from_list(self, data, names, dtype, n_cols, copy):
1223         """Initialize table from a list of column data.  A column can be a
1224         Column object, np.ndarray, mixin, or any other iterable object.
1225         """
1226         # Special case of initializing an empty table like `t = Table()`. No
1227         # action required at this point.
1228         if n_cols == 0:
1229             return
1230 
1231         cols = []
1232         default_names = _auto_names(n_cols)
1233 
1234         for col, name, default_name, dt in zip(data, names, default_names, dtype):
1235             col = self._convert_data_to_col(col, copy, default_name, dt, name)
1236 
1237             cols.append(col)
1238 
1239         self._init_from_cols(cols)
1240 
1241     def _convert_data_to_col(
1242         self, data, copy=True, default_name=None, dtype=None, name=None
1243     ):
1244         """
1245         Convert any allowed sequence data ``col`` to a column object that can be used
1246         directly in the self.columns dict.  This could be a Column, MaskedColumn,
1247         or mixin column.
1248 
1249         The final column name is determined by::
1250 
1251             name or data.info.name or def_name
1252 
1253         If ``data`` has no ``info`` then ``name = name or def_name``.
1254 
1255         The behavior of ``copy`` for Column objects is:
1256         - copy=True: new class instance with a copy of data and deep copy of meta
1257         - copy=False: new class instance with same data and a key-only copy of meta
1258 
1259         For mixin columns:
1260         - copy=True: new class instance with copy of data and deep copy of meta
1261         - copy=False: original instance (no copy at all)
1262 
1263         Parameters
1264         ----------
1265         data : object (column-like sequence)
1266             Input column data
1267         copy : bool
1268             Make a copy
1269         default_name : str
1270             Default name
1271         dtype : np.dtype or None
1272             Data dtype
1273         name : str or None
1274             Column name
1275 
1276         Returns
1277         -------
1278         col : Column, MaskedColumn, mixin-column type
1279             Object that can be used as a column in self
1280         """
1281         data_is_mixin = self._is_mixin_for_table(data)
1282         masked_col_cls = (
1283             self.ColumnClass
1284             if issubclass(self.ColumnClass, self.MaskedColumn)
1285             else self.MaskedColumn
1286         )
1287 
1288         try:
1289             data0_is_mixin = self._is_mixin_for_table(data[0])
1290         except Exception:
1291             # Need broad exception, cannot predict what data[0] raises for arbitrary data
1292             data0_is_mixin = False
1293 
1294         # If the data is not an instance of Column or a mixin class, we can
1295         # check the registry of mixin 'handlers' to see if the column can be
1296         # converted to a mixin class
1297         if (handler := get_mixin_handler(data)) is not None:
1298             original_data = data
1299             data = handler(data)
1300             if not (data_is_mixin := self._is_mixin_for_table(data)):
1301                 fully_qualified_name = (
1302                     original_data.__class__.__module__
1303                     + "."
1304                     + original_data.__class__.__name__
1305                 )
1306                 raise TypeError(
1307                     "Mixin handler for object of type "
1308                     f"{fully_qualified_name} "
1309                     "did not return a valid mixin column"
1310                 )
1311 
1312         # Get the final column name using precedence.  Some objects may not
1313         # have an info attribute. Also avoid creating info as a side effect.
1314         if not name:
1315             if isinstance(data, Column):
1316                 name = data.name or default_name
1317             elif "info" in getattr(data, "__dict__", ()):
1318                 name = data.info.name or default_name
1319             else:
1320                 name = default_name
1321 
1322         if isinstance(data, Column):
1323             # If self.ColumnClass is a subclass of col, then "upgrade" to ColumnClass,
1324             # otherwise just use the original class.  The most common case is a
1325             # table with masked=True and ColumnClass=MaskedColumn.  Then a Column
1326             # gets upgraded to MaskedColumn, but the converse (pre-4.0) behavior
1327             # of downgrading from MaskedColumn to Column (for non-masked table)
1328             # does not happen.
1329             col_cls = self._get_col_cls_for_table(data)
1330 
1331         elif data_is_mixin:
1332             # Copy the mixin column attributes if they exist since the copy below
1333             # may not get this attribute. If not copying, take a slice
1334             # to ensure we get a new instance and we do not share metadata
1335             # like info.
1336             col = col_copy(data, copy_indices=self._init_indices) if copy else data[:]
1337             col.info.name = name
1338             return col
1339 
1340         elif data0_is_mixin:
1341             # Handle case of a sequence of a mixin, e.g. [1*u.m, 2*u.m].
1342             try:
1343                 col = data[0].__class__(data)
1344                 col.info.name = name
1345                 return col
1346             except Exception:
1347                 # If that didn't work for some reason, just turn it into np.array of object
1348                 data = np.array(data, dtype=object)
1349                 col_cls = self.ColumnClass
1350 
1351         elif isinstance(data, (np.ma.MaskedArray, Masked)):
1352             # Require that col_cls be a subclass of MaskedColumn, remembering
1353             # that ColumnClass could be a user-defined subclass (though more-likely
1354             # could be MaskedColumn).
1355             col_cls = masked_col_cls
1356 
1357         elif data is None:
1358             # Special case for data passed as the None object (for broadcasting
1359             # to an object column). Need to turn data into numpy `None` scalar
1360             # object, otherwise `Column` interprets data=None as no data instead
1361             # of a object column of `None`.
1362             data = np.array(None)
1363             col_cls = self.ColumnClass
1364 
1365         elif not hasattr(data, "dtype"):
1366             # `data` is none of the above, convert to numpy array or MaskedArray
1367             # assuming only that it is a scalar or sequence or N-d nested
1368             # sequence. This function is relatively intricate and tries to
1369             # maintain performance for common cases while handling things like
1370             # list input with embedded np.ma.masked entries. If `data` is a
1371             # scalar then it gets returned unchanged so the original object gets
1372             # passed to `Column` later.
1373             data = _convert_sequence_data_to_array(data, dtype)
1374             copy = False  # Already made a copy above
1375             col_cls = (
1376                 masked_col_cls
1377                 if isinstance(data, np.ma.MaskedArray)
1378                 else self.ColumnClass
1379             )
1380 
1381         else:
1382             col_cls = self.ColumnClass
1383 
1384         try:
1385             col = col_cls(
1386                 name=name,
1387                 data=data,
1388                 dtype=dtype,
1389                 copy=copy,
1390                 copy_indices=self._init_indices,
1391             )
1392         except Exception:
1393             # Broad exception class since we don't know what might go wrong
1394             raise ValueError("unable to convert data to Column for Table")
1395 
1396         col = self._convert_col_for_table(col)
1397 
1398         return col
1399 
1400     def _init_from_ndarray(self, data, names, dtype, n_cols, copy):
1401         """Initialize table from an ndarray structured array."""
1402         data_names = data.dtype.names or _auto_names(n_cols)
1403         struct = data.dtype.names is not None
1404         names = [name or data_names[i] for i, name in enumerate(names)]
1405 
1406         cols = (
1407             [data[name] for name in data_names]
1408             if struct
1409             else [data[:, i] for i in range(n_cols)]
1410         )
1411 
1412         self._init_from_list(cols, names, dtype, n_cols, copy)
1413 
1414     def _init_from_dict(self, data, names, dtype, n_cols, copy):
1415         """Initialize table from a dictionary of columns."""
1416         data_list = [data[name] for name in names]
1417         self._init_from_list(data_list, names, dtype, n_cols, copy)
1418 
1419     def _get_col_cls_for_table(self, col):
1420         """Get the correct column class to use for upgrading any Column-like object.
1421 
1422         For a masked table, ensure any Column-like object is a subclass
1423         of the table MaskedColumn.
1424 
1425         For unmasked table, ensure any MaskedColumn-like object is a subclass
1426         of the table MaskedColumn.  If not a MaskedColumn, then ensure that any
1427         Column-like object is a subclass of the table Column.
1428         """
1429         col_cls = col.__class__
1430 
1431         if self.masked:
1432             if isinstance(col, Column) and not isinstance(col, self.MaskedColumn):
1433                 col_cls = self.MaskedColumn
1434         else:
1435             if isinstance(col, MaskedColumn):
1436                 if not isinstance(col, self.MaskedColumn):
1437                     col_cls = self.MaskedColumn
1438             elif isinstance(col, Column) and not isinstance(col, self.Column):
1439                 col_cls = self.Column
1440 
1441         return col_cls
1442 
1443     def _convert_col_for_table(self, col):
1444         """
1445         Make sure that all Column objects have correct base class for this type of
1446         Table.  For a base Table this most commonly means setting to
1447         MaskedColumn if the table is masked.  Table subclasses like QTable
1448         override this method.
1449         """
1450         if isinstance(col, Column) and not isinstance(col, self.ColumnClass):
1451             col_cls = self._get_col_cls_for_table(col)
1452             if col_cls is not col.__class__:
1453                 col = col_cls(col, copy=False)
1454 
1455         return col
1456 
1457     def _init_from_cols(self, cols):
1458         """Initialize table from a list of Column or mixin objects."""
1459         lengths = {len(col) for col in cols}
1460         if len(lengths) > 1:
1461             raise ValueError(f"Inconsistent data column lengths: {lengths}")
1462 
1463         # Make sure that all Column-based objects have correct class.  For
1464         # plain Table this is self.ColumnClass, but for instance QTable will
1465         # convert columns with units to a Quantity mixin.
1466         newcols = [self._convert_col_for_table(col) for col in cols]
1467         self._make_table_from_cols(self, newcols)
1468 
1469         # Deduplicate indices.  It may happen that after pickling or when
1470         # initing from an existing table that column indices which had been
1471         # references to a single index object got *copied* into an independent
1472         # object.  This results in duplicates which will cause downstream problems.
1473         index_dict = {}
1474         for col in self.itercols():
1475             for i, index in enumerate(col.info.indices or []):
1476                 names = tuple(ind_col.info.name for ind_col in index.columns)
1477                 if names in index_dict:
1478                     col.info.indices[i] = index_dict[names]
1479                 else:
1480                     index_dict[names] = index
1481 
1482     def _new_from_slice(self, slice_):
1483         """Create a new table as a referenced slice from self."""
1484         table = self.__class__(masked=self.masked)
1485         if self.meta:
1486             table.meta = self.meta.copy()  # Shallow copy for slice
1487         table.primary_key = self.primary_key
1488 
1489         newcols = []
1490         for col in self.columns.values():
1491             newcol = col[slice_]
1492 
1493             # Note in line below, use direct attribute access to col.indices for Column
1494             # instances instead of the generic col.info.indices.  This saves about 4 usec
1495             # per column.
1496             if (col if isinstance(col, Column) else col.info).indices:
1497                 # TODO : as far as I can tell the only purpose of setting _copy_indices
1498                 # here is to communicate that to the initial test in `slice_indices`.
1499                 # Why isn't that just sent as an arg to the function?
1500                 col.info._copy_indices = self._copy_indices
1501                 newcol = col.info.slice_indices(newcol, slice_, len(col))
1502 
1503                 # Don't understand why this is forcing a value on the original column.
1504                 # Normally col.info does not even have a _copy_indices attribute.  Tests
1505                 # still pass if this line is deleted.  (Each col.info attribute access
1506                 # is expensive).
1507                 col.info._copy_indices = True
1508 
1509             newcols.append(newcol)
1510 
1511         self._make_table_from_cols(
1512             table, newcols, verify=False, names=self.columns.keys()
1513         )
1514         return table
1515 
1516     @staticmethod
1517     def _make_table_from_cols(table, cols, verify=True, names=None):
1518         """
1519         Make ``table`` in-place so that it represents the given list of ``cols``.
1520         """
1521         if names is None:
1522             names = [col.info.name for col in cols]
1523 
1524         # Note: we do not test for len(names) == len(cols) if names is not None.  In that
1525         # case the function is being called by from "trusted" source (e.g. right above here)
1526         # that is assumed to provide valid inputs.  In that case verify=False.
1527 
1528         if verify:
1529             if None in names:
1530                 raise TypeError("Cannot have None for column name")
1531             if len(set(names)) != len(names):
1532                 raise ValueError("Duplicate column names")
1533 
1534         table.columns = table.TableColumns(
1535             (name, col) for name, col in zip(names, cols)
1536         )
1537 
1538         for col in cols:
1539             table._set_col_parent_table_and_mask(col)
1540 
1541     def _set_col_parent_table_and_mask(self, col):
1542         """
1543         Set ``col.parent_table = self`` and force ``col`` to have ``mask``
1544         attribute if the table is masked and ``col.mask`` does not exist.
1545         """
1546         # For Column instances it is much faster to do direct attribute access
1547         # instead of going through .info
1548         col_info = col if isinstance(col, Column) else col.info
1549         col_info.parent_table = self
1550 
1551         # Legacy behavior for masked table
1552         if self.masked and not hasattr(col, "mask"):
1553             col.mask = FalseArray(col.shape)
1554 
1555     def itercols(self):
1556         """
1557         Iterate over the columns of this table.
1558 
1559         Examples
1560         --------
1561         To iterate over the columns of a table::
1562 
1563             >>> t = Table([[1], [2]])
1564             >>> for col in t.itercols():
1565             ...     print(col)
1566             col0
1567             ----
1568                1
1569             col1
1570             ----
1571                2
1572 
1573         Using ``itercols()`` is similar to  ``for col in t.columns.values()``
1574         but is syntactically preferred.
1575         """
1576         for colname in self.columns:
1577             yield self[colname]
1578 
1579     def _base_repr_(
1580         self,
1581         html=False,
1582         descr_vals=None,
1583         max_width=None,
1584         tableid=None,
1585         show_dtype=True,
1586         max_lines=None,
1587         tableclass=None,
1588     ):
1589         if descr_vals is None:
1590             descr_vals = [self.__class__.__name__]
1591             if self.masked:
1592                 descr_vals.append("masked=True")
1593             descr_vals.append(f"length={len(self)}")
1594 
1595         descr = " ".join(descr_vals)
1596         if html:
1597             from astropy.utils.xml.writer import xml_escape
1598 
1599             descr = f"<i>{xml_escape(descr)}</i>\n"
1600         else:
1601             descr = f"<{descr}>\n"
1602 
1603         if tableid is None:
1604             tableid = f"table{id(self)}"
1605 
1606         data_lines, outs = self.formatter._pformat_table(
1607             self,
1608             tableid=tableid,
1609             html=html,
1610             max_width=max_width,
1611             show_name=True,
1612             show_unit=None,
1613             show_dtype=show_dtype,
1614             max_lines=max_lines,
1615             tableclass=tableclass,
1616         )
1617 
1618         out = descr + "\n".join(data_lines)
1619 
1620         return out
1621 
1622     def _repr_html_(self):
1623         out = self._base_repr_(
1624             html=True, max_width=-1, tableclass=conf.default_notebook_table_class
1625         )
1626         # Wrap <table> in <div>. This follows the pattern in pandas and allows
1627         # table to be scrollable horizontally in VS Code notebook display.
1628         out = f"<div>{out}</div>"
1629         return out
1630 
1631     def __repr__(self):
1632         return self._base_repr_(html=False, max_width=None)
1633 
1634     def __str__(self):
1635         return "\n".join(self.pformat())
1636 
1637     def __bytes__(self):
1638         return str(self).encode("utf-8")
1639 
1640     @property
1641     def has_mixin_columns(self):
1642         """
1643         True if table has any mixin columns (defined as columns that are not Column
1644         subclasses).
1645         """
1646         return any(has_info_class(col, MixinInfo) for col in self.columns.values())
1647 
1648     @property
1649     def has_masked_columns(self):
1650         """True if table has any ``MaskedColumn`` columns.
1651 
1652         This does not check for mixin columns that may have masked values, use the
1653         ``has_masked_values`` property in that case.
1654 
1655         """
1656         return any(isinstance(col, MaskedColumn) for col in self.itercols())
1657 
1658     @property
1659     def has_masked_values(self):
1660         """True if column in the table has values which are masked.
1661 
1662         This may be relatively slow for large tables as it requires checking the mask
1663         values of each column.
1664         """
1665         return any(hasattr(col, "mask") and np.any(col.mask) for col in self.itercols())
1666 
1667     def _is_mixin_for_table(self, col):
1668         """
1669         Determine if ``col`` should be added to the table directly as
1670         a mixin column.
1671         """
1672         if isinstance(col, BaseColumn):
1673             return False
1674 
1675         # Is it a mixin but not [Masked]Quantity (which gets converted to
1676         # [Masked]Column with unit set).
1677         return has_info_class(col, MixinInfo) and not has_info_class(col, QuantityInfo)
1678 
1679     @format_doc(_pprint_docs)
1680     def pprint(
1681         self,
1682         max_lines=None,
1683         max_width=None,
1684         show_name=True,
1685         show_unit=None,
1686         show_dtype=False,
1687         align=None,
1688     ):
1689         """Print a formatted string representation of the table.
1690 
1691         If no value of ``max_lines`` is supplied then the height of the
1692         screen terminal is used to set ``max_lines``.  If the terminal
1693         height cannot be determined then the default is taken from the
1694         configuration item ``astropy.conf.max_lines``.  If a negative
1695         value of ``max_lines`` is supplied then there is no line limit
1696         applied.
1697 
1698         The same applies for max_width except the configuration item is
1699         ``astropy.conf.max_width``.
1700 
1701         """
1702         lines, outs = self.formatter._pformat_table(
1703             self,
1704             max_lines,
1705             max_width,
1706             show_name=show_name,
1707             show_unit=show_unit,
1708             show_dtype=show_dtype,
1709             align=align,
1710         )
1711         if outs["show_length"]:
1712             lines.append(f"Length = {len(self)} rows")
1713 
1714         n_header = outs["n_header"]
1715 
1716         for i, line in enumerate(lines):
1717             if i < n_header:
1718                 color_print(line, "red")
1719             else:
1720                 print(line)
1721 
1722     @format_doc(_pprint_docs)
1723     def pprint_all(
1724         self,
1725         max_lines=-1,
1726         max_width=-1,
1727         show_name=True,
1728         show_unit=None,
1729         show_dtype=False,
1730         align=None,
1731     ):
1732         """Print a formatted string representation of the entire table.
1733 
1734         This method is the same as `astropy.table.Table.pprint` except that
1735         the default ``max_lines`` and ``max_width`` are both -1 so that by
1736         default the entire table is printed instead of restricting to the size
1737         of the screen terminal.
1738 
1739         """
1740         return self.pprint(
1741             max_lines, max_width, show_name, show_unit, show_dtype, align
1742         )
1743 
1744     def _make_index_row_display_table(self, index_row_name):
1745         if index_row_name not in self.columns:
1746             idx_col = self.ColumnClass(name=index_row_name, data=np.arange(len(self)))
1747             return self.__class__([idx_col] + list(self.columns.values()), copy=False)
1748         else:
1749             return self
1750 
1751     def show_in_notebook(
1752         self,
1753         tableid=None,
1754         css=None,
1755         display_length=50,
1756         table_class="astropy-default",
1757         show_row_index="idx",
1758     ):
1759         """Render the table in HTML and show it in the IPython notebook.
1760 
1761         Parameters
1762         ----------
1763         tableid : str or None
1764             An html ID tag for the table.  Default is ``table{id}-XXX``, where
1765             id is the unique integer id of the table object, id(self), and XXX
1766             is a random number to avoid conflicts when printing the same table
1767             multiple times.
1768         table_class : str or None
1769             A string with a list of HTML classes used to style the table.
1770             The special default string ('astropy-default') means that the string
1771             will be retrieved from the configuration item
1772             ``astropy.table.default_notebook_table_class``. Note that these
1773             table classes may make use of bootstrap, as this is loaded with the
1774             notebook.  See `this page <https://getbootstrap.com/css/#tables>`_
1775             for the list of classes.
1776         css : str
1777             A valid CSS string declaring the formatting for the table. Defaults
1778             to ``astropy.table.jsviewer.DEFAULT_CSS_NB``.
1779         display_length : int, optional
1780             Number or rows to show. Defaults to 50.
1781         show_row_index : str or False
1782             If this does not evaluate to False, a column with the given name
1783             will be added to the version of the table that gets displayed.
1784             This new column shows the index of the row in the table itself,
1785             even when the displayed table is re-sorted by another column. Note
1786             that if a column with this name already exists, this option will be
1787             ignored. Defaults to "idx".
1788 
1789         Notes
1790         -----
1791         Currently, unlike `show_in_browser` (with ``jsviewer=True``), this
1792         method needs to access online javascript code repositories.  This is due
1793         to modern browsers' limitations on accessing local files.  Hence, if you
1794         call this method while offline (and don't have a cached version of
1795         jquery and jquery.dataTables), you will not get the jsviewer features.
1796         """
1797         from IPython.display import HTML
1798 
1799         from .jsviewer import JSViewer
1800 
1801         if tableid is None:
1802             tableid = f"table{id(self)}-{np.random.randint(1, 1e6)}"
1803 
1804         jsv = JSViewer(display_length=display_length)
1805         if show_row_index:
1806             display_table = self._make_index_row_display_table(show_row_index)
1807         else:
1808             display_table = self
1809         if table_class == "astropy-default":
1810             table_class = conf.default_notebook_table_class
1811         html = display_table._base_repr_(
1812             html=True,
1813             max_width=-1,
1814             tableid=tableid,
1815             max_lines=-1,
1816             show_dtype=False,
1817             tableclass=table_class,
1818         )
1819 
1820         columns = display_table.columns.values()
1821         sortable_columns = [
1822             i for i, col in enumerate(columns) if col.info.dtype.kind in "iufc"
1823         ]
1824         html += jsv.ipynb(tableid, css=css, sort_columns=sortable_columns)
1825         return HTML(html)
1826 
1827     def show_in_browser(
1828         self,
1829         max_lines=5000,
1830         jsviewer=False,
1831         browser="default",
1832         jskwargs={"use_local_files": True},
1833         tableid=None,
1834         table_class="display compact",
1835         css=None,
1836         show_row_index="idx",
1837     ):
1838         """Render the table in HTML and show it in a web browser.
1839 
1840         Parameters
1841         ----------
1842         max_lines : int
1843             Maximum number of rows to export to the table (set low by default
1844             to avoid memory issues, since the browser view requires duplicating
1845             the table in memory).  A negative value of ``max_lines`` indicates
1846             no row limit.
1847         jsviewer : bool
1848             If `True`, prepends some javascript headers so that the table is
1849             rendered as a `DataTables <https://datatables.net>`_ data table.
1850             This allows in-browser searching & sorting.
1851         browser : str
1852             Any legal browser name, e.g. ``'firefox'``, ``'chrome'``,
1853             ``'safari'`` (for mac, you may need to use ``'open -a
1854             "/Applications/Google Chrome.app" {}'`` for Chrome).  If
1855             ``'default'``, will use the system default browser.
1856         jskwargs : dict
1857             Passed to the `astropy.table.JSViewer` init. Defaults to
1858             ``{'use_local_files': True}`` which means that the JavaScript
1859             libraries will be served from local copies.
1860         tableid : str or None
1861             An html ID tag for the table.  Default is ``table{id}``, where id
1862             is the unique integer id of the table object, id(self).
1863         table_class : str or None
1864             A string with a list of HTML classes used to style the table.
1865             Default is "display compact", and other possible values can be
1866             found in https://www.datatables.net/manual/styling/classes
1867         css : str
1868             A valid CSS string declaring the formatting for the table. Defaults
1869             to ``astropy.table.jsviewer.DEFAULT_CSS``.
1870         show_row_index : str or False
1871             If this does not evaluate to False, a column with the given name
1872             will be added to the version of the table that gets displayed.
1873             This new column shows the index of the row in the table itself,
1874             even when the displayed table is re-sorted by another column. Note
1875             that if a column with this name already exists, this option will be
1876             ignored. Defaults to "idx".
1877         """
1878         import os
1879         import tempfile
1880         import webbrowser
1881         from urllib.parse import urljoin
1882         from urllib.request import pathname2url
1883 
1884         from .jsviewer import DEFAULT_CSS
1885 
1886         if css is None:
1887             css = DEFAULT_CSS
1888 
1889         # We can't use NamedTemporaryFile here because it gets deleted as
1890         # soon as it gets garbage collected.
1891         tmpdir = tempfile.mkdtemp()
1892         path = os.path.join(tmpdir, "table.html")
1893 
1894         with open(path, "w") as tmp:
1895             if jsviewer:
1896                 if show_row_index:
1897                     display_table = self._make_index_row_display_table(show_row_index)
1898                 else:
1899                     display_table = self
1900                 display_table.write(
1901                     tmp,
1902                     format="jsviewer",
1903                     css=css,
1904                     max_lines=max_lines,
1905                     jskwargs=jskwargs,
1906                     table_id=tableid,
1907                     table_class=table_class,
1908                 )
1909             else:
1910                 self.write(tmp, format="html")
1911 
1912         try:
1913             br = webbrowser.get(None if browser == "default" else browser)
1914         except webbrowser.Error:
1915             log.error(f"Browser '{browser}' not found.")
1916         else:
1917             br.open(urljoin("file:", pathname2url(path)))
1918 
1919     @format_doc(_pformat_docs, id="{id}")
1920     def pformat(
1921         self,
1922         max_lines=None,
1923         max_width=None,
1924         show_name=True,
1925         show_unit=None,
1926         show_dtype=False,
1927         html=False,
1928         tableid=None,
1929         align=None,
1930         tableclass=None,
1931     ):
1932         """Return a list of lines for the formatted string representation of
1933         the table.
1934 
1935         If no value of ``max_lines`` is supplied then the height of the
1936         screen terminal is used to set ``max_lines``.  If the terminal
1937         height cannot be determined then the default is taken from the
1938         configuration item ``astropy.conf.max_lines``.  If a negative
1939         value of ``max_lines`` is supplied then there is no line limit
1940         applied.
1941 
1942         The same applies for ``max_width`` except the configuration item  is
1943         ``astropy.conf.max_width``.
1944 
1945         """
1946         lines, outs = self.formatter._pformat_table(
1947             self,
1948             max_lines,
1949             max_width,
1950             show_name=show_name,
1951             show_unit=show_unit,
1952             show_dtype=show_dtype,
1953             html=html,
1954             tableid=tableid,
1955             tableclass=tableclass,
1956             align=align,
1957         )
1958 
1959         if outs["show_length"]:
1960             lines.append(f"Length = {len(self)} rows")
1961 
1962         return lines
1963 
1964     @format_doc(_pformat_docs, id="{id}")
1965     def pformat_all(
1966         self,
1967         max_lines=-1,
1968         max_width=-1,
1969         show_name=True,
1970         show_unit=None,
1971         show_dtype=False,
1972         html=False,
1973         tableid=None,
1974         align=None,
1975         tableclass=None,
1976     ):
1977         """Return a list of lines for the formatted string representation of
1978         the entire table.
1979 
1980         If no value of ``max_lines`` is supplied then the height of the
1981         screen terminal is used to set ``max_lines``.  If the terminal
1982         height cannot be determined then the default is taken from the
1983         configuration item ``astropy.conf.max_lines``.  If a negative
1984         value of ``max_lines`` is supplied then there is no line limit
1985         applied.
1986 
1987         The same applies for ``max_width`` except the configuration item  is
1988         ``astropy.conf.max_width``.
1989 
1990         """
1991         return self.pformat(
1992             max_lines,
1993             max_width,
1994             show_name,
1995             show_unit,
1996             show_dtype,
1997             html,
1998             tableid,
1999             align,
2000             tableclass,
2001         )
2002 
2003     def more(
2004         self,
2005         max_lines=None,
2006         max_width=None,
2007         show_name=True,
2008         show_unit=None,
2009         show_dtype=False,
2010     ):
2011         """Interactively browse table with a paging interface.
2012 
2013         Supported keys::
2014 
2015           f, <space> : forward one page
2016           b : back one page
2017           r : refresh same page
2018           n : next row
2019           p : previous row
2020           < : go to beginning
2021           > : go to end
2022           q : quit browsing
2023           h : print this help
2024 
2025         Parameters
2026         ----------
2027         max_lines : int
2028             Maximum number of lines in table output
2029 
2030         max_width : int or None
2031             Maximum character width of output
2032 
2033         show_name : bool
2034             Include a header row for column names. Default is True.
2035 
2036         show_unit : bool
2037             Include a header row for unit.  Default is to show a row
2038             for units only if one or more columns has a defined value
2039             for the unit.
2040 
2041         show_dtype : bool
2042             Include a header row for column dtypes. Default is False.
2043         """
2044         self.formatter._more_tabcol(
2045             self,
2046             max_lines,
2047             max_width,
2048             show_name=show_name,
2049             show_unit=show_unit,
2050             show_dtype=show_dtype,
2051         )
2052 
2053     def __getitem__(self, item):
2054         if isinstance(item, str):
2055             return self.columns[item]
2056         elif isinstance(item, (int, np.integer)):
2057             return self.Row(self, item)
2058         elif (
2059             isinstance(item, np.ndarray) and item.shape == () and item.dtype.kind == "i"
2060         ):
2061             return self.Row(self, item.item())
2062         elif self._is_list_or_tuple_of_str(item):
2063             out = self.__class__(
2064                 [self[x] for x in item], copy_indices=self._copy_indices
2065             )
2066             out._groups = groups.TableGroups(
2067                 out, indices=self.groups._indices, keys=self.groups._keys
2068             )
2069             out.meta = self.meta.copy()  # Shallow copy for meta
2070             return out
2071         elif (isinstance(item, np.ndarray) and item.size == 0) or (
2072             isinstance(item, (tuple, list)) and not item
2073         ):
2074             # If item is an empty array/list/tuple then return the table with no rows
2075             return self._new_from_slice([])
2076         elif (
2077             isinstance(item, (slice, np.ndarray, list))
2078             or isinstance(item, tuple)
2079             and all(isinstance(x, np.ndarray) for x in item)
2080         ):
2081             # here for the many ways to give a slice; a tuple of ndarray
2082             # is produced by np.where, as in t[np.where(t['a'] > 2)]
2083             # For all, a new table is constructed with slice of all columns
2084             return self._new_from_slice(item)
2085         else:
2086             raise ValueError(f"Illegal type {type(item)} for table item access")
2087 
2088     def __setitem__(self, item, value):
2089         # If the item is a string then it must be the name of a column.
2090         # If that column doesn't already exist then create it now.
2091         if isinstance(item, str) and item not in self.colnames:
2092             self.add_column(value, name=item, copy=True)
2093 
2094         else:
2095             n_cols = len(self.columns)
2096 
2097             if isinstance(item, str):
2098                 # Set an existing column by first trying to replace, and if
2099                 # this fails do an in-place update.  See definition of mask
2100                 # property for discussion of the _setitem_inplace attribute.
2101                 if (
2102                     not getattr(self, "_setitem_inplace", False)
2103                     and not conf.replace_inplace
2104                 ):
2105                     try:
2106                         self._replace_column_warnings(item, value)
2107                         return
2108                     except Exception:
2109                         pass
2110                 self.columns[item][:] = value
2111 
2112             elif isinstance(item, (int, np.integer)):
2113                 self._set_row(idx=item, colnames=self.colnames, vals=value)
2114 
2115             elif (
2116                 isinstance(item, (slice, np.ndarray, list))
2117                 or isinstance(item, tuple)
2118                 and all(isinstance(x, np.ndarray) for x in item)
2119             ):
2120                 if isinstance(value, Table):
2121                     vals = (col for col in value.columns.values())
2122 
2123                 elif isinstance(value, np.ndarray) and value.dtype.names:
2124                     vals = (value[name] for name in value.dtype.names)
2125 
2126                 elif np.isscalar(value):
2127                     vals = itertools.repeat(value, n_cols)
2128 
2129                 else:  # Assume this is an iterable that will work
2130                     if len(value) != n_cols:
2131                         raise ValueError(
2132                             "Right side value needs {} elements (one for each column)".format(
2133                                 n_cols
2134                             )
2135                         )
2136                     vals = value
2137 
2138                 for col, val in zip(self.columns.values(), vals):
2139                     col[item] = val
2140 
2141             else:
2142                 raise ValueError(f"Illegal type {type(item)} for table item access")
2143 
2144     def __delitem__(self, item):
2145         if isinstance(item, str):
2146             self.remove_column(item)
2147         elif isinstance(item, (int, np.integer)):
2148             self.remove_row(item)
2149         elif isinstance(item, (list, tuple, np.ndarray)) and all(
2150             isinstance(x, str) for x in item
2151         ):
2152             self.remove_columns(item)
2153         elif (
2154             isinstance(item, (list, np.ndarray)) and np.asarray(item).dtype.kind == "i"
2155         ):
2156             self.remove_rows(item)
2157         elif isinstance(item, slice):
2158             self.remove_rows(item)
2159         else:
2160             raise IndexError("illegal key or index value")
2161 
2162     def _ipython_key_completions_(self):
2163         return self.colnames
2164 
2165     def field(self, item):
2166         """Return column[item] for recarray compatibility."""
2167         return self.columns[item]
2168 
2169     @property
2170     def masked(self):
2171         return self._masked
2172 
2173     @masked.setter
2174     def masked(self, masked):
2175         raise Exception(
2176             "Masked attribute is read-only (use t = Table(t, masked=True)"
2177             " to convert to a masked table)"
2178         )
2179 
2180     def _set_masked(self, masked):
2181         """
2182         Set the table masked property.
2183 
2184         Parameters
2185         ----------
2186         masked : bool
2187             State of table masking (`True` or `False`)
2188         """
2189         if masked in [True, False, None]:
2190             self._masked = masked
2191         else:
2192             raise ValueError("masked should be one of True, False, None")
2193 
2194         self._column_class = self.MaskedColumn if self._masked else self.Column
2195 
2196     @property
2197     def ColumnClass(self):
2198         if self._column_class is None:
2199             return self.Column
2200         else:
2201             return self._column_class
2202 
2203     @property
2204     def dtype(self):
2205         return np.dtype([descr(col) for col in self.columns.values()])
2206 
2207     @property
2208     def colnames(self):
2209         return list(self.columns.keys())
2210 
2211     @staticmethod
2212     def _is_list_or_tuple_of_str(names):
2213         """Check that ``names`` is a tuple or list of strings."""
2214         return (
2215             isinstance(names, (tuple, list))
2216             and names
2217             and all(isinstance(x, str) for x in names)
2218         )
2219 
2220     def keys(self):
2221         return list(self.columns.keys())
2222 
2223     def values(self):
2224         return self.columns.values()
2225 
2226     def items(self):
2227         return self.columns.items()
2228 
2229     def __len__(self):
2230         # For performance reasons (esp. in Row) cache the first column name
2231         # and use that subsequently for the table length.  If might not be
2232         # available yet or the column might be gone now, in which case
2233         # try again in the except block.
2234         try:
2235             return len(OrderedDict.__getitem__(self.columns, self._first_colname))
2236         except (AttributeError, KeyError):
2237             if len(self.columns) == 0:
2238                 return 0
2239 
2240             # Get the first column name
2241             self._first_colname = next(iter(self.columns))
2242             return len(self.columns[self._first_colname])
2243 
2244     def __or__(self, other):
2245         if isinstance(other, Table):
2246             updated_table = self.copy()
2247             updated_table.update(other)
2248             return updated_table
2249         else:
2250             return NotImplemented
2251 
2252     def __ior__(self, other):
2253         try:
2254             self.update(other)
2255             return self
2256         except TypeError:
2257             return NotImplemented
2258 
2259     def index_column(self, name):
2260         """
2261         Return the positional index of column ``name``.
2262 
2263         Parameters
2264         ----------
2265         name : str
2266             column name
2267 
2268         Returns
2269         -------
2270         index : int
2271             Positional index of column ``name``.
2272 
2273         Examples
2274         --------
2275         Create a table with three columns 'a', 'b' and 'c'::
2276 
2277             >>> t = Table([[1, 2, 3], [0.1, 0.2, 0.3], ['x', 'y', 'z']],
2278             ...           names=('a', 'b', 'c'))
2279             >>> print(t)
2280              a   b   c
2281             --- --- ---
2282               1 0.1   x
2283               2 0.2   y
2284               3 0.3   z
2285 
2286         Get index of column 'b' of the table::
2287 
2288             >>> t.index_column('b')
2289             1
2290         """
2291         try:
2292             return self.colnames.index(name)
2293         except ValueError:
2294             raise ValueError(f"Column {name} does not exist")
2295 
2296     def add_column(
2297         self,
2298         col,
2299         index=None,
2300         name=None,
2301         rename_duplicate=False,
2302         copy=True,
2303         default_name=None,
2304     ):
2305         """
2306         Add a new column to the table using ``col`` as input.  If ``index``
2307         is supplied then insert column before ``index`` position
2308         in the list of columns, otherwise append column to the end
2309         of the list.
2310 
2311         The ``col`` input can be any data object which is acceptable as a
2312         `~astropy.table.Table` column object or can be converted.  This includes
2313         mixin columns and scalar or length=1 objects which get broadcast to match
2314         the table length.
2315 
2316         To add several columns at once use ``add_columns()`` or simply call
2317         ``add_column()`` for each one.  There is very little performance difference
2318         in the two approaches.
2319 
2320         Parameters
2321         ----------
2322         col : object
2323             Data object for the new column
2324         index : int or None
2325             Insert column before this position or at end (default).
2326         name : str
2327             Column name
2328         rename_duplicate : bool
2329             Uniquify column name if it already exist. Default is False.
2330         copy : bool
2331             Make a copy of the new column. Default is True.
2332         default_name : str or None
2333             Name to use if both ``name`` and ``col.info.name`` are not available.
2334             Defaults to ``col{number_of_columns}``.
2335 
2336         Examples
2337         --------
2338         Create a table with two columns 'a' and 'b', then create a third column 'c'
2339         and append it to the end of the table::
2340 
2341             >>> t = Table([[1, 2], [0.1, 0.2]], names=('a', 'b'))
2342             >>> col_c = Column(name='c', data=['x', 'y'])
2343             >>> t.add_column(col_c)
2344             >>> print(t)
2345              a   b   c
2346             --- --- ---
2347               1 0.1   x
2348               2 0.2   y
2349 
2350         Add column 'd' at position 1. Note that the column is inserted
2351         before the given index::
2352 
2353             >>> t.add_column(['a', 'b'], name='d', index=1)
2354             >>> print(t)
2355              a   d   b   c
2356             --- --- --- ---
2357               1   a 0.1   x
2358               2   b 0.2   y
2359 
2360         Add second column named 'b' with rename_duplicate::
2361 
2362             >>> t = Table([[1, 2], [0.1, 0.2]], names=('a', 'b'))
2363             >>> t.add_column(1.1, name='b', rename_duplicate=True)
2364             >>> print(t)
2365              a   b  b_1
2366             --- --- ---
2367               1 0.1 1.1
2368               2 0.2 1.1
2369 
2370         Add an unnamed column or mixin object in the table using a default name
2371         or by specifying an explicit name with ``name``. Name can also be overridden::
2372 
2373             >>> t = Table([[1, 2], [0.1, 0.2]], names=('a', 'b'))
2374             >>> t.add_column(['a', 'b'])
2375             >>> t.add_column(col_c, name='d')
2376             >>> print(t)
2377              a   b  col2  d
2378             --- --- ---- ---
2379               1 0.1    a   x
2380               2 0.2    b   y
2381         """
2382         if default_name is None:
2383             default_name = f"col{len(self.columns)}"
2384 
2385         # Convert col data to acceptable object for insertion into self.columns.
2386         # Note that along with the lines above and below, this allows broadcasting
2387         # of scalars to the correct shape for adding to table.
2388         col = self._convert_data_to_col(
2389             col, name=name, copy=copy, default_name=default_name
2390         )
2391 
2392         # Assigning a scalar column to an empty table should result in an
2393         # exception (see #3811).
2394         if col.shape == () and len(self) == 0:
2395             raise TypeError("Empty table cannot have column set to scalar value")
2396         # Make col data shape correct for scalars.  The second test is to allow
2397         # broadcasting an N-d element to a column, e.g. t['new'] = [[1, 2]].
2398         elif (col.shape == () or col.shape[0] == 1) and len(self) > 0:
2399             new_shape = (len(self),) + getattr(col, "shape", ())[1:]
2400             if isinstance(col, np.ndarray):
2401                 col = np.broadcast_to(col, shape=new_shape, subok=True)
2402             elif isinstance(col, ShapedLikeNDArray):
2403                 col = col._apply(np.broadcast_to, shape=new_shape, subok=True)
2404 
2405             # broadcast_to() results in a read-only array.  Apparently it only changes
2406             # the view to look like the broadcasted array.  So copy.
2407             col = col_copy(col)
2408 
2409         name = col.info.name
2410 
2411         # Ensure that new column is the right length
2412         if len(self.columns) > 0 and len(col) != len(self):
2413             raise ValueError("Inconsistent data column lengths")
2414 
2415         if rename_duplicate:
2416             orig_name = name
2417             i = 1
2418             while name in self.columns:
2419                 # Iterate until a unique name is found
2420                 name = orig_name + "_" + str(i)
2421                 i += 1
2422             col.info.name = name
2423 
2424         # Set col parent_table weakref and ensure col has mask attribute if table.masked
2425         self._set_col_parent_table_and_mask(col)
2426 
2427         # Add new column as last column
2428         self.columns[name] = col
2429 
2430         if index is not None:
2431             # Move the other cols to the right of the new one
2432             move_names = self.colnames[index:-1]
2433             for move_name in move_names:
2434                 self.columns.move_to_end(move_name, last=True)
2435 
2436     def add_columns(
2437         self, cols, indexes=None, names=None, copy=True, rename_duplicate=False
2438     ):
2439         """
2440         Add a list of new columns the table using ``cols`` data objects.  If a
2441         corresponding list of ``indexes`` is supplied then insert column
2442         before each ``index`` position in the *original* list of columns,
2443         otherwise append columns to the end of the list.
2444 
2445         The ``cols`` input can include any data objects which are acceptable as
2446         `~astropy.table.Table` column objects or can be converted.  This includes
2447         mixin columns and scalar or length=1 objects which get broadcast to match
2448         the table length.
2449 
2450         From a performance perspective there is little difference between calling
2451         this method once or looping over the new columns and calling ``add_column()``
2452         for each column.
2453 
2454         Parameters
2455         ----------
2456         cols : list of object
2457             List of data objects for the new columns
2458         indexes : list of int or None
2459             Insert column before this position or at end (default).
2460         names : list of str
2461             Column names
2462         copy : bool
2463             Make a copy of the new columns. Default is True.
2464         rename_duplicate : bool
2465             Uniquify new column names if they duplicate the existing ones.
2466             Default is False.
2467 
2468         See Also
2469         --------
2470         astropy.table.hstack, update, replace_column
2471 
2472         Examples
2473         --------
2474         Create a table with two columns 'a' and 'b', then create columns 'c' and 'd'
2475         and append them to the end of the table::
2476 
2477             >>> t = Table([[1, 2], [0.1, 0.2]], names=('a', 'b'))
2478             >>> col_c = Column(name='c', data=['x', 'y'])
2479             >>> col_d = Column(name='d', data=['u', 'v'])
2480             >>> t.add_columns([col_c, col_d])
2481             >>> print(t)
2482              a   b   c   d
2483             --- --- --- ---
2484               1 0.1   x   u
2485               2 0.2   y   v
2486 
2487         Add column 'c' at position 0 and column 'd' at position 1. Note that
2488         the columns are inserted before the given position::
2489 
2490             >>> t = Table([[1, 2], [0.1, 0.2]], names=('a', 'b'))
2491             >>> t.add_columns([['x', 'y'], ['u', 'v']], names=['c', 'd'],
2492             ...               indexes=[0, 1])
2493             >>> print(t)
2494              c   a   d   b
2495             --- --- --- ---
2496               x   1   u 0.1
2497               y   2   v 0.2
2498 
2499         Add second column 'b' and column 'c' with ``rename_duplicate``::
2500 
2501             >>> t = Table([[1, 2], [0.1, 0.2]], names=('a', 'b'))
2502             >>> t.add_columns([[1.1, 1.2], ['x', 'y']], names=('b', 'c'),
2503             ...               rename_duplicate=True)
2504             >>> print(t)
2505              a   b  b_1  c
2506             --- --- --- ---
2507               1 0.1 1.1  x
2508               2 0.2 1.2  y
2509 
2510         Add unnamed columns or mixin objects in the table using default names
2511         or by specifying explicit names with ``names``. Names can also be overridden::
2512 
2513             >>> t = Table()
2514             >>> col_b = Column(name='b', data=['u', 'v'])
2515             >>> t.add_columns([[1, 2], col_b])
2516             >>> t.add_columns([[3, 4], col_b], names=['c', 'd'])
2517             >>> print(t)
2518             col0  b   c   d
2519             ---- --- --- ---
2520                1   u   3   u
2521                2   v   4   v
2522         """
2523         if indexes is None:
2524             indexes = [len(self.columns)] * len(cols)
2525         elif len(indexes) != len(cols):
2526             raise ValueError("Number of indexes must match number of cols")
2527 
2528         if names is None:
2529             names = (None,) * len(cols)
2530         elif len(names) != len(cols):
2531             raise ValueError("Number of names must match number of cols")
2532 
2533         default_names = [f"col{ii + len(self.columns)}" for ii in range(len(cols))]
2534 
2535         for ii in reversed(np.argsort(indexes, kind="stable")):
2536             self.add_column(
2537                 cols[ii],
2538                 index=indexes[ii],
2539                 name=names[ii],
2540                 default_name=default_names[ii],
2541                 rename_duplicate=rename_duplicate,
2542                 copy=copy,
2543             )
2544 
2545     def _replace_column_warnings(self, name, col):
2546         """
2547         Same as replace_column but issues warnings under various circumstances.
2548         """
2549         warns = conf.replace_warnings
2550         refcount = None
2551         old_col = None
2552 
2553         # sys.getrefcount is CPython specific and not on PyPy.
2554         if (
2555             "refcount" in warns
2556             and name in self.colnames
2557             and hasattr(sys, "getrefcount")
2558         ):
2559             refcount = sys.getrefcount(self[name])
2560 
2561         if name in self.colnames:
2562             old_col = self[name]
2563 
2564         # This may raise an exception (e.g. t['a'] = 1) in which case none of
2565         # the downstream code runs.
2566         self.replace_column(name, col)
2567 
2568         if "always" in warns:
2569             warnings.warn(
2570                 f"replaced column '{name}'", TableReplaceWarning, stacklevel=3
2571             )
2572 
2573         if "slice" in warns:
2574             try:
2575                 # Check for ndarray-subclass slice.  An unsliced instance
2576                 # has an ndarray for the base while sliced has the same class
2577                 # as parent.
2578                 if isinstance(old_col.base, old_col.__class__):
2579                     msg = (
2580                         "replaced column '{}' which looks like an array slice. "
2581                         "The new column no longer shares memory with the "
2582                         "original array.".format(name)
2583                     )
2584                     warnings.warn(msg, TableReplaceWarning, stacklevel=3)
2585             except AttributeError:
2586                 pass
2587 
2588         # sys.getrefcount is CPython specific and not on PyPy.
2589         if "refcount" in warns and hasattr(sys, "getrefcount"):
2590             # Did reference count change?
2591             new_refcount = sys.getrefcount(self[name])
2592             if refcount != new_refcount:
2593                 msg = (
2594                     "replaced column '{}' and the number of references "
2595                     "to the column changed.".format(name)
2596                 )
2597                 warnings.warn(msg, TableReplaceWarning, stacklevel=3)
2598 
2599         if "attributes" in warns:
2600             # Any of the standard column attributes changed?
2601             changed_attrs = []
2602             new_col = self[name]
2603             # Check base DataInfo attributes that any column will have
2604             for attr in DataInfo.attr_names:
2605                 if getattr(old_col.info, attr) != getattr(new_col.info, attr):
2606                     changed_attrs.append(attr)
2607 
2608             if changed_attrs:
2609                 msg = "replaced column '{}' and column attributes {} changed.".format(
2610                     name, changed_attrs
2611                 )
2612                 warnings.warn(msg, TableReplaceWarning, stacklevel=3)
2613 
2614     def replace_column(self, name, col, copy=True):
2615         """
2616         Replace column ``name`` with the new ``col`` object.
2617 
2618         The behavior of ``copy`` for Column objects is:
2619         - copy=True: new class instance with a copy of data and deep copy of meta
2620         - copy=False: new class instance with same data and a key-only copy of meta
2621 
2622         For mixin columns:
2623         - copy=True: new class instance with copy of data and deep copy of meta
2624         - copy=False: original instance (no copy at all)
2625 
2626         Parameters
2627         ----------
2628         name : str
2629             Name of column to replace
2630         col : `~astropy.table.Column` or `~numpy.ndarray` or sequence
2631             New column object to replace the existing column.
2632         copy : bool
2633             Make copy of the input ``col``, default=True
2634 
2635         See Also
2636         --------
2637         add_columns, astropy.table.hstack, update
2638 
2639         Examples
2640         --------
2641         Replace column 'a' with a float version of itself::
2642 
2643             >>> t = Table([[1, 2, 3], [0.1, 0.2, 0.3]], names=('a', 'b'))
2644             >>> float_a = t['a'].astype(float)
2645             >>> t.replace_column('a', float_a)
2646         """
2647         if name not in self.colnames:
2648             raise ValueError(f"column name {name} is not in the table")
2649 
2650         if self[name].info.indices:
2651             raise ValueError("cannot replace a table index column")
2652 
2653         col = self._convert_data_to_col(col, name=name, copy=copy)
2654         self._set_col_parent_table_and_mask(col)
2655 
2656         # Ensure that new column is the right length, unless it is the only column
2657         # in which case re-sizing is allowed.
2658         if len(self.columns) > 1 and len(col) != len(self[name]):
2659             raise ValueError("length of new column must match table length")
2660 
2661         self.columns.__setitem__(name, col, validated=True)
2662 
2663     def remove_row(self, index):
2664         """
2665         Remove a row from the table.
2666 
2667         Parameters
2668         ----------
2669         index : int
2670             Index of row to remove
2671 
2672         Examples
2673         --------
2674         Create a table with three columns 'a', 'b' and 'c'::
2675 
2676             >>> t = Table([[1, 2, 3], [0.1, 0.2, 0.3], ['x', 'y', 'z']],
2677             ...           names=('a', 'b', 'c'))
2678             >>> print(t)
2679              a   b   c
2680             --- --- ---
2681               1 0.1   x
2682               2 0.2   y
2683               3 0.3   z
2684 
2685         Remove row 1 from the table::
2686 
2687             >>> t.remove_row(1)
2688             >>> print(t)
2689              a   b   c
2690             --- --- ---
2691               1 0.1   x
2692               3 0.3   z
2693 
2694         To remove several rows at the same time use remove_rows.
2695         """
2696         # check the index against the types that work with np.delete
2697         if not isinstance(index, (int, np.integer)):
2698             raise TypeError("Row index must be an integer")
2699         self.remove_rows(index)
2700 
2701     def remove_rows(self, row_specifier):
2702         """
2703         Remove rows from the table.
2704 
2705         Parameters
2706         ----------
2707         row_specifier : slice or int or array of int
2708             Specification for rows to remove
2709 
2710         Examples
2711         --------
2712         Create a table with three columns 'a', 'b' and 'c'::
2713 
2714             >>> t = Table([[1, 2, 3], [0.1, 0.2, 0.3], ['x', 'y', 'z']],
2715             ...           names=('a', 'b', 'c'))
2716             >>> print(t)
2717              a   b   c
2718             --- --- ---
2719               1 0.1   x
2720               2 0.2   y
2721               3 0.3   z
2722 
2723         Remove rows 0 and 2 from the table::
2724 
2725             >>> t.remove_rows([0, 2])
2726             >>> print(t)
2727              a   b   c
2728             --- --- ---
2729               2 0.2   y
2730 
2731 
2732         Note that there are no warnings if the slice operator extends
2733         outside the data::
2734 
2735             >>> t = Table([[1, 2, 3], [0.1, 0.2, 0.3], ['x', 'y', 'z']],
2736             ...           names=('a', 'b', 'c'))
2737             >>> t.remove_rows(slice(10, 20, 1))
2738             >>> print(t)
2739              a   b   c
2740             --- --- ---
2741               1 0.1   x
2742               2 0.2   y
2743               3 0.3   z
2744         """
2745         # Update indices
2746         for index in self.indices:
2747             index.remove_rows(row_specifier)
2748 
2749         keep_mask = np.ones(len(self), dtype=bool)
2750         keep_mask[row_specifier] = False
2751 
2752         columns = self.TableColumns()
2753         for name, col in self.columns.items():
2754             newcol = col[keep_mask]
2755             newcol.info.parent_table = self
2756             columns[name] = newcol
2757 
2758         self._replace_cols(columns)
2759 
2760         # Revert groups to default (ungrouped) state
2761         if hasattr(self, "_groups"):
2762             del self._groups
2763 
2764     def iterrows(self, *names):
2765         """
2766         Iterate over rows of table returning a tuple of values for each row.
2767 
2768         This method is especially useful when only a subset of columns are needed.
2769 
2770         The ``iterrows`` method can be substantially faster than using the standard
2771         Table row iteration (e.g. ``for row in tbl:``), since that returns a new
2772         ``~astropy.table.Row`` object for each row and accessing a column in that
2773         row (e.g. ``row['col0']``) is slower than tuple access.
2774 
2775         Parameters
2776         ----------
2777         names : list
2778             List of column names (default to all columns if no names provided)
2779 
2780         Returns
2781         -------
2782         rows : iterable
2783             Iterator returns tuples of row values
2784 
2785         Examples
2786         --------
2787         Create a table with three columns 'a', 'b' and 'c'::
2788 
2789             >>> t = Table({'a': [1, 2, 3],
2790             ...            'b': [1.0, 2.5, 3.0],
2791             ...            'c': ['x', 'y', 'z']})
2792 
2793         To iterate row-wise using column names::
2794 
2795             >>> for a, c in t.iterrows('a', 'c'):
2796             ...     print(a, c)
2797             1 x
2798             2 y
2799             3 z
2800 
2801         """
2802         if len(names) == 0:
2803             names = self.colnames
2804         else:
2805             for name in names:
2806                 if name not in self.colnames:
2807                     raise ValueError(f"{name} is not a valid column name")
2808 
2809         cols = (self[name] for name in names)
2810         out = zip(*cols)
2811         return out
2812 
2813     def _set_of_names_in_colnames(self, names):
2814         """Return ``names`` as a set if valid, or raise a `KeyError`.
2815 
2816         ``names`` is valid if all elements in it are in ``self.colnames``.
2817         If ``names`` is a string then it is interpreted as a single column
2818         name.
2819         """
2820         names = {names} if isinstance(names, str) else set(names)
2821         invalid_names = names.difference(self.colnames)
2822         if len(invalid_names) == 1:
2823             raise KeyError(f'column "{invalid_names.pop()}" does not exist')
2824         elif len(invalid_names) > 1:
2825             raise KeyError(f"columns {invalid_names} do not exist")
2826         return names
2827 
2828     def remove_column(self, name):
2829         """
2830         Remove a column from the table.
2831 
2832         This can also be done with::
2833 
2834           del table[name]
2835 
2836         Parameters
2837         ----------
2838         name : str
2839             Name of column to remove
2840 
2841         Examples
2842         --------
2843         Create a table with three columns 'a', 'b' and 'c'::
2844 
2845             >>> t = Table([[1, 2, 3], [0.1, 0.2, 0.3], ['x', 'y', 'z']],
2846             ...           names=('a', 'b', 'c'))
2847             >>> print(t)
2848              a   b   c
2849             --- --- ---
2850               1 0.1   x
2851               2 0.2   y
2852               3 0.3   z
2853 
2854         Remove column 'b' from the table::
2855 
2856             >>> t.remove_column('b')
2857             >>> print(t)
2858              a   c
2859             --- ---
2860               1   x
2861               2   y
2862               3   z
2863 
2864         To remove several columns at the same time use remove_columns.
2865         """
2866         self.remove_columns([name])
2867 
2868     def remove_columns(self, names):
2869         """
2870         Remove several columns from the table.
2871 
2872         Parameters
2873         ----------
2874         names : str or iterable of str
2875             Names of the columns to remove
2876 
2877         Examples
2878         --------
2879         Create a table with three columns 'a', 'b' and 'c'::
2880 
2881             >>> t = Table([[1, 2, 3], [0.1, 0.2, 0.3], ['x', 'y', 'z']],
2882             ...     names=('a', 'b', 'c'))
2883             >>> print(t)
2884              a   b   c
2885             --- --- ---
2886               1 0.1   x
2887               2 0.2   y
2888               3 0.3   z
2889 
2890         Remove columns 'b' and 'c' from the table::
2891 
2892             >>> t.remove_columns(['b', 'c'])
2893             >>> print(t)
2894              a
2895             ---
2896               1
2897               2
2898               3
2899 
2900         Specifying only a single column also works. Remove column 'b' from the table::
2901 
2902             >>> t = Table([[1, 2, 3], [0.1, 0.2, 0.3], ['x', 'y', 'z']],
2903             ...     names=('a', 'b', 'c'))
2904             >>> t.remove_columns('b')
2905             >>> print(t)
2906              a   c
2907             --- ---
2908               1   x
2909               2   y
2910               3   z
2911 
2912         This gives the same as using remove_column.
2913         """
2914         for name in self._set_of_names_in_colnames(names):
2915             del self.columns[name]
2916 
2917     def _convert_string_dtype(self, in_kind, out_kind, encode_decode_func):
2918         """
2919         Convert string-like columns to/from bytestring and unicode (internal only).
2920 
2921         Parameters
2922         ----------
2923         in_kind : str
2924             Input dtype.kind
2925         out_kind : str
2926             Output dtype.kind
2927         """
2928         for col in self.itercols():
2929             if col.dtype.kind == in_kind:
2930                 try:
2931                     # This requires ASCII and is faster by a factor of up to ~8, so
2932                     # try that first.
2933                     newcol = col.__class__(col, dtype=out_kind)
2934                 except (UnicodeEncodeError, UnicodeDecodeError):
2935                     newcol = col.__class__(encode_decode_func(col, "utf-8"))
2936 
2937                     # Quasi-manually copy info attributes.  Unfortunately
2938                     # DataInfo.__set__ does not do the right thing in this case
2939                     # so newcol.info = col.info does not get the old info attributes.
2940                     for attr in (
2941                         col.info.attr_names - col.info._attrs_no_copy - {"dtype"}
2942                     ):
2943                         value = deepcopy(getattr(col.info, attr))
2944                         setattr(newcol.info, attr, value)
2945 
2946                 self[col.name] = newcol
2947 
2948     def convert_bytestring_to_unicode(self):
2949         """
2950         Convert bytestring columns (dtype.kind='S') to unicode (dtype.kind='U')
2951         using UTF-8 encoding.
2952 
2953         Internally this changes string columns to represent each character
2954         in the string with a 4-byte UCS-4 equivalent, so it is inefficient
2955         for memory but allows scripts to manipulate string arrays with
2956         natural syntax.
2957         """
2958         self._convert_string_dtype("S", "U", np.char.decode)
2959 
2960     def convert_unicode_to_bytestring(self):
2961         """
2962         Convert unicode columns (dtype.kind='U') to bytestring (dtype.kind='S')
2963         using UTF-8 encoding.
2964 
2965         When exporting a unicode string array to a file, it may be desirable
2966         to encode unicode columns as bytestrings.
2967         """
2968         self._convert_string_dtype("U", "S", np.char.encode)
2969 
2970     def keep_columns(self, names):
2971         """
2972         Keep only the columns specified (remove the others).
2973 
2974         Parameters
2975         ----------
2976         names : str or iterable of str
2977             The columns to keep. All other columns will be removed.
2978 
2979         Examples
2980         --------
2981         Create a table with three columns 'a', 'b' and 'c'::
2982 
2983             >>> t = Table([[1, 2, 3],[0.1, 0.2, 0.3],['x', 'y', 'z']],
2984             ...           names=('a', 'b', 'c'))
2985             >>> print(t)
2986              a   b   c
2987             --- --- ---
2988               1 0.1   x
2989               2 0.2   y
2990               3 0.3   z
2991 
2992         Keep only column 'a' of the table::
2993 
2994             >>> t.keep_columns('a')
2995             >>> print(t)
2996              a
2997             ---
2998               1
2999               2
3000               3
3001 
3002         Keep columns 'a' and 'c' of the table::
3003 
3004             >>> t = Table([[1, 2, 3],[0.1, 0.2, 0.3],['x', 'y', 'z']],
3005             ...           names=('a', 'b', 'c'))
3006             >>> t.keep_columns(['a', 'c'])
3007             >>> print(t)
3008              a   c
3009             --- ---
3010               1   x
3011               2   y
3012               3   z
3013         """
3014         names = self._set_of_names_in_colnames(names)
3015         for colname in self.colnames:
3016             if colname not in names:
3017                 del self.columns[colname]
3018 
3019     def rename_column(self, name, new_name):
3020         """
3021         Rename a column.
3022 
3023         This can also be done directly by setting the ``name`` attribute
3024         of the ``info`` property of the column::
3025 
3026           table[name].info.name = new_name
3027 
3028         Parameters
3029         ----------
3030         name : str
3031             The current name of the column.
3032         new_name : str
3033             The new name for the column
3034 
3035         Examples
3036         --------
3037         Create a table with three columns 'a', 'b' and 'c'::
3038 
3039             >>> t = Table([[1,2],[3,4],[5,6]], names=('a','b','c'))
3040             >>> print(t)
3041              a   b   c
3042             --- --- ---
3043               1   3   5
3044               2   4   6
3045 
3046         Renaming column 'a' to 'aa'::
3047 
3048             >>> t.rename_column('a' , 'aa')
3049             >>> print(t)
3050              aa  b   c
3051             --- --- ---
3052               1   3   5
3053               2   4   6
3054         """
3055         if name not in self.keys():
3056             raise KeyError(f"Column {name} does not exist")
3057 
3058         self.columns[name].info.name = new_name
3059 
3060     def rename_columns(self, names, new_names):
3061         """
3062         Rename multiple columns.
3063 
3064         Parameters
3065         ----------
3066         names : list, tuple
3067             A list or tuple of existing column names.
3068         new_names : list, tuple
3069             A list or tuple of new column names.
3070 
3071         Examples
3072         --------
3073         Create a table with three columns 'a', 'b', 'c'::
3074 
3075             >>> t = Table([[1,2],[3,4],[5,6]], names=('a','b','c'))
3076             >>> print(t)
3077               a   b   c
3078              --- --- ---
3079               1   3   5
3080               2   4   6
3081 
3082         Renaming columns 'a' to 'aa' and 'b' to 'bb'::
3083 
3084             >>> names = ('a','b')
3085             >>> new_names = ('aa','bb')
3086             >>> t.rename_columns(names, new_names)
3087             >>> print(t)
3088              aa  bb   c
3089             --- --- ---
3090               1   3   5
3091               2   4   6
3092         """
3093         if not self._is_list_or_tuple_of_str(names):
3094             raise TypeError("input 'names' must be a tuple or a list of column names")
3095 
3096         if not self._is_list_or_tuple_of_str(new_names):
3097             raise TypeError(
3098                 "input 'new_names' must be a tuple or a list of column names"
3099             )
3100 
3101         if len(names) != len(new_names):
3102             raise ValueError(
3103                 "input 'names' and 'new_names' list arguments must be the same length"
3104             )
3105 
3106         for name, new_name in zip(names, new_names):
3107             self.rename_column(name, new_name)
3108 
3109     def _set_row(self, idx, colnames, vals):
3110         try:
3111             assert len(vals) == len(colnames)
3112         except Exception:
3113             raise ValueError(
3114                 "right hand side must be a sequence of values with "
3115                 "the same length as the number of selected columns"
3116             )
3117 
3118         # Keep track of original values before setting each column so that
3119         # setting row can be transactional.
3120         orig_vals = []
3121         cols = self.columns
3122         try:
3123             for name, val in zip(colnames, vals):
3124                 orig_vals.append(cols[name][idx])
3125                 cols[name][idx] = val
3126         except Exception:
3127             # If anything went wrong first revert the row update then raise
3128             for name, val in zip(colnames, orig_vals[:-1]):
3129                 cols[name][idx] = val
3130             raise
3131 
3132     def add_row(self, vals=None, mask=None):
3133         """Add a new row to the end of the table.
3134 
3135         The ``vals`` argument can be:
3136 
3137         sequence (e.g. tuple or list)
3138             Column values in the same order as table columns.
3139         mapping (e.g. dict)
3140             Keys corresponding to column names.  Missing values will be
3141             filled with np.zeros for the column dtype.
3142         `None`
3143             All values filled with np.zeros for the column dtype.
3144 
3145         This method requires that the Table object "owns" the underlying array
3146         data.  In particular one cannot add a row to a Table that was
3147         initialized with copy=False from an existing array.
3148 
3149         The ``mask`` attribute should give (if desired) the mask for the
3150         values. The type of the mask should match that of the values, i.e. if
3151         ``vals`` is an iterable, then ``mask`` should also be an iterable
3152         with the same length, and if ``vals`` is a mapping, then ``mask``
3153         should be a dictionary.
3154 
3155         Parameters
3156         ----------
3157         vals : tuple, list, dict or None
3158             Use the specified values in the new row
3159         mask : tuple, list, dict or None
3160             Use the specified mask values in the new row
3161 
3162         Examples
3163         --------
3164         Create a table with three columns 'a', 'b' and 'c'::
3165 
3166            >>> t = Table([[1,2],[4,5],[7,8]], names=('a','b','c'))
3167            >>> print(t)
3168             a   b   c
3169            --- --- ---
3170              1   4   7
3171              2   5   8
3172 
3173         Adding a new row with entries '3' in 'a', '6' in 'b' and '9' in 'c'::
3174 
3175            >>> t.add_row([3,6,9])
3176            >>> print(t)
3177              a   b   c
3178              --- --- ---
3179              1   4   7
3180              2   5   8
3181              3   6   9
3182         """
3183         self.insert_row(len(self), vals, mask)
3184 
3185     def insert_row(self, index, vals=None, mask=None):
3186         """Add a new row before the given ``index`` position in the table.
3187 
3188         The ``vals`` argument can be:
3189 
3190         sequence (e.g. tuple or list)
3191             Column values in the same order as table columns.
3192         mapping (e.g. dict)
3193             Keys corresponding to column names.  Missing values will be
3194             filled with np.zeros for the column dtype.
3195         `None`
3196             All values filled with np.zeros for the column dtype.
3197 
3198         The ``mask`` attribute should give (if desired) the mask for the
3199         values. The type of the mask should match that of the values, i.e. if
3200         ``vals`` is an iterable, then ``mask`` should also be an iterable
3201         with the same length, and if ``vals`` is a mapping, then ``mask``
3202         should be a dictionary.
3203 
3204         Parameters
3205         ----------
3206         vals : tuple, list, dict or None
3207             Use the specified values in the new row
3208         mask : tuple, list, dict or None
3209             Use the specified mask values in the new row
3210         """
3211         colnames = self.colnames
3212 
3213         N = len(self)
3214         if index < -N or index > N:
3215             raise IndexError(
3216                 f"Index {index} is out of bounds for table with length {N}"
3217             )
3218         if index < 0:
3219             index += N
3220 
3221         if isinstance(vals, Mapping) or vals is None:
3222             # From the vals and/or mask mappings create the corresponding lists
3223             # that have entries for each table column.
3224             if mask is not None and not isinstance(mask, Mapping):
3225                 raise TypeError("Mismatch between type of vals and mask")
3226 
3227             # Now check that the mask is specified for the same keys as the
3228             # values, otherwise things get really confusing.
3229             if mask is not None and set(vals.keys()) != set(mask.keys()):
3230                 raise ValueError("keys in mask should match keys in vals")
3231 
3232             if vals and any(name not in colnames for name in vals):
3233                 raise ValueError("Keys in vals must all be valid column names")
3234 
3235             vals_list = []
3236             mask_list = []
3237 
3238             for name in colnames:
3239                 if vals and name in vals:
3240                     vals_list.append(vals[name])
3241                     mask_list.append(False if mask is None else mask[name])
3242                 else:
3243                     col = self[name]
3244                     if hasattr(col, "dtype"):
3245                         # Make a placeholder zero element of the right type which is masked.
3246                         # This assumes the appropriate insert() method will broadcast a
3247                         # numpy scalar to the right shape.
3248                         vals_list.append(np.zeros(shape=(), dtype=col.dtype))
3249 
3250                         # For masked table any unsupplied values are masked by default.
3251                         mask_list.append(self.masked and vals is not None)
3252                     else:
3253                         raise ValueError(f"Value must be supplied for column '{name}'")
3254 
3255             vals = vals_list
3256             mask = mask_list
3257 
3258         if isiterable(vals):
3259             if mask is not None and (not isiterable(mask) or isinstance(mask, Mapping)):
3260                 raise TypeError("Mismatch between type of vals and mask")
3261 
3262             if len(self.columns) != len(vals):
3263                 raise ValueError("Mismatch between number of vals and columns")
3264 
3265             if mask is not None:
3266                 if len(self.columns) != len(mask):
3267                     raise ValueError("Mismatch between number of masks and columns")
3268             else:
3269                 mask = [False] * len(self.columns)
3270 
3271         else:
3272             raise TypeError("Vals must be an iterable or mapping or None")
3273 
3274         # Insert val at index for each column
3275         columns = self.TableColumns()
3276         for name, col, val, mask_ in zip(colnames, self.columns.values(), vals, mask):
3277             try:
3278                 # If new val is masked and the existing column does not support masking
3279                 # then upgrade the column to a mask-enabled type: either the table-level
3280                 # default ColumnClass or else MaskedColumn.
3281                 if (
3282                     mask_
3283                     and isinstance(col, Column)
3284                     and not isinstance(col, MaskedColumn)
3285                 ):
3286                     col_cls = (
3287                         self.ColumnClass
3288                         if issubclass(self.ColumnClass, self.MaskedColumn)
3289                         else self.MaskedColumn
3290                     )
3291                     col = col_cls(col, copy=False)
3292 
3293                 newcol = col.insert(index, val, axis=0)
3294 
3295                 if len(newcol) != N + 1:
3296                     raise ValueError(
3297                         "Incorrect length for column {} after inserting {}"
3298                         " (expected {}, got {})".format(name, val, len(newcol), N + 1)
3299                     )
3300                 newcol.info.parent_table = self
3301 
3302                 # Set mask if needed and possible
3303                 if mask_:
3304                     if hasattr(newcol, "mask"):
3305                         newcol[index] = np.ma.masked
3306                     else:
3307                         raise TypeError(
3308                             "mask was supplied for column '{}' but it does not "
3309                             "support masked values".format(col.info.name)
3310                         )
3311 
3312                 columns[name] = newcol
3313 
3314             except Exception as err:
3315                 raise ValueError(
3316                     "Unable to insert row because of exception in column '{}':\n{}".format(
3317                         name, err
3318                     )
3319                 ) from err
3320 
3321         for table_index in self.indices:
3322             table_index.insert_row(index, vals, self.columns.values())
3323 
3324         self._replace_cols(columns)
3325 
3326         # Revert groups to default (ungrouped) state
3327         if hasattr(self, "_groups"):
3328             del self._groups
3329 
3330     def _replace_cols(self, columns):
3331         for col, new_col in zip(self.columns.values(), columns.values()):
3332             new_col.info.indices = []
3333             for index in col.info.indices:
3334                 index.columns[index.col_position(col.info.name)] = new_col
3335                 new_col.info.indices.append(index)
3336 
3337         self.columns = columns
3338 
3339     def update(self, other, copy=True):
3340         """
3341         Perform a dictionary-style update and merge metadata.
3342 
3343         The argument ``other`` must be a |Table|, or something that can be used
3344         to initialize a table. Columns from (possibly converted) ``other`` are
3345         added to this table. In case of matching column names the column from
3346         this table is replaced with the one from ``other``. If ``other`` is a
3347         |Table| instance then ``|=`` is available as alternate syntax for in-place
3348         update and ``|`` can be used merge data to a new table.
3349 
3350         Parameters
3351         ----------
3352         other : table-like
3353             Data to update this table with.
3354         copy : bool
3355             Whether the updated columns should be copies of or references to
3356             the originals.
3357 
3358         See Also
3359         --------
3360         add_columns, astropy.table.hstack, replace_column
3361 
3362         Examples
3363         --------
3364         Update a table with another table::
3365 
3366             >>> t1 = Table({'a': ['foo', 'bar'], 'b': [0., 0.]}, meta={'i': 0})
3367             >>> t2 = Table({'b': [1., 2.], 'c': [7., 11.]}, meta={'n': 2})
3368             >>> t1.update(t2)
3369             >>> t1
3370             <Table length=2>
3371              a      b       c
3372             str3 float64 float64
3373             ---- ------- -------
3374              foo     1.0     7.0
3375              bar     2.0    11.0
3376             >>> t1.meta
3377             {'i': 0, 'n': 2}
3378 
3379         Update a table with a dictionary::
3380 
3381             >>> t = Table({'a': ['foo', 'bar'], 'b': [0., 0.]})
3382             >>> t.update({'b': [1., 2.]})
3383             >>> t
3384             <Table length=2>
3385              a      b
3386             str3 float64
3387             ---- -------
3388              foo     1.0
3389              bar     2.0
3390         """
3391         from .operations import _merge_table_meta
3392 
3393         if not isinstance(other, Table):
3394             other = self.__class__(other, copy=copy)
3395         common_cols = set(self.colnames).intersection(other.colnames)
3396         for name, col in other.items():
3397             if name in common_cols:
3398                 self.replace_column(name, col, copy=copy)
3399             else:
3400                 self.add_column(col, name=name, copy=copy)
3401         _merge_table_meta(self, [self, other], metadata_conflicts="silent")
3402 
3403     def argsort(self, keys=None, kind=None, reverse=False):
3404         """
3405         Return the indices which would sort the table according to one or
3406         more key columns.  This simply calls the `numpy.argsort` function on
3407         the table with the ``order`` parameter set to ``keys``.
3408 
3409         Parameters
3410         ----------
3411         keys : str or list of str
3412             The column name(s) to order the table by
3413         kind : {'quicksort', 'mergesort', 'heapsort', 'stable'}, optional
3414             Sorting algorithm used by ``numpy.argsort``.
3415         reverse : bool
3416             Sort in reverse order (default=False)
3417 
3418         Returns
3419         -------
3420         index_array : ndarray, int
3421             Array of indices that sorts the table by the specified key
3422             column(s).
3423         """
3424         if isinstance(keys, str):
3425             keys = [keys]
3426 
3427         # use index sorted order if possible
3428         if keys is not None:
3429             index = get_index(self, names=keys)
3430             if index is not None:
3431                 idx = np.asarray(index.sorted_data())
3432                 return idx[::-1] if reverse else idx
3433 
3434         kwargs = {}
3435         if keys:
3436             # For multiple keys return a structured array which gets sorted,
3437             # while for a single key return a single ndarray.  Sorting a
3438             # one-column structured array is slower than ndarray (e.g. a
3439             # factor of ~6 for a 10 million long random array), and much slower
3440             # for in principle sortable columns like Time, which get stored as
3441             # object arrays.
3442             if len(keys) > 1:
3443                 kwargs["order"] = keys
3444                 data = self.as_array(names=keys)
3445             else:
3446                 data = self[keys[0]]
3447         else:
3448             # No keys provided so sort on all columns.
3449             data = self.as_array()
3450 
3451         if kind:
3452             kwargs["kind"] = kind
3453 
3454         # np.argsort will look for a possible .argsort method (e.g., for Time),
3455         # and if that fails cast to an array and try sorting that way.
3456         idx = np.argsort(data, **kwargs)
3457 
3458         return idx[::-1] if reverse else idx
3459 
3460     def sort(self, keys=None, *, kind=None, reverse=False):
3461         """
3462         Sort the table according to one or more keys. This operates
3463         on the existing table and does not return a new table.
3464 
3465         Parameters
3466         ----------
3467         keys : str or list of str
3468             The key(s) to order the table by. If None, use the
3469             primary index of the Table.
3470         kind : {'quicksort', 'mergesort', 'heapsort', 'stable'}, optional
3471             Sorting algorithm used by ``numpy.argsort``.
3472         reverse : bool
3473             Sort in reverse order (default=False)
3474 
3475         Examples
3476         --------
3477         Create a table with 3 columns::
3478 
3479             >>> t = Table([['Max', 'Jo', 'John'], ['Miller', 'Miller', 'Jackson'],
3480             ...            [12, 15, 18]], names=('firstname', 'name', 'tel'))
3481             >>> print(t)
3482             firstname   name  tel
3483             --------- ------- ---
3484                   Max  Miller  12
3485                    Jo  Miller  15
3486                  John Jackson  18
3487 
3488         Sorting according to standard sorting rules, first 'name' then 'firstname'::
3489 
3490             >>> t.sort(['name', 'firstname'])
3491             >>> print(t)
3492             firstname   name  tel
3493             --------- ------- ---
3494                  John Jackson  18
3495                    Jo  Miller  15
3496                   Max  Miller  12
3497 
3498         Sorting according to standard sorting rules, first 'firstname' then 'tel',
3499         in reverse order::
3500 
3501             >>> t.sort(['firstname', 'tel'], reverse=True)
3502             >>> print(t)
3503             firstname   name  tel
3504             --------- ------- ---
3505                   Max  Miller  12
3506                  John Jackson  18
3507                    Jo  Miller  15
3508         """
3509         if keys is None:
3510             if not self.indices:
3511                 raise ValueError("Table sort requires input keys or a table index")
3512             keys = [x.info.name for x in self.indices[0].columns]
3513 
3514         if isinstance(keys, str):
3515             keys = [keys]
3516 
3517         indexes = self.argsort(keys, kind=kind, reverse=reverse)
3518 
3519         with self.index_mode("freeze"):
3520             for name, col in self.columns.items():
3521                 # Make a new sorted column.  This requires that take() also copies
3522                 # relevant info attributes for mixin columns.
3523                 new_col = col.take(indexes, axis=0)
3524 
3525                 # First statement in try: will succeed if the column supports an in-place
3526                 # update, and matches the legacy behavior of astropy Table.  However,
3527                 # some mixin classes may not support this, so in that case just drop
3528                 # in the entire new column. See #9553 and #9536 for discussion.
3529                 try:
3530                     col[:] = new_col
3531                 except Exception:
3532                     # In-place update failed for some reason, exception class not
3533                     # predictable for arbitrary mixin.
3534                     self[col.info.name] = new_col
3535 
3536     def reverse(self):
3537         """
3538         Reverse the row order of table rows.  The table is reversed
3539         in place and there are no function arguments.
3540 
3541         Examples
3542         --------
3543         Create a table with three columns::
3544 
3545             >>> t = Table([['Max', 'Jo', 'John'], ['Miller','Miller','Jackson'],
3546             ...         [12,15,18]], names=('firstname','name','tel'))
3547             >>> print(t)
3548             firstname   name  tel
3549             --------- ------- ---
3550                   Max  Miller  12
3551                    Jo  Miller  15
3552                  John Jackson  18
3553 
3554         Reversing order::
3555 
3556             >>> t.reverse()
3557             >>> print(t)
3558             firstname   name  tel
3559             --------- ------- ---
3560                  John Jackson  18
3561                    Jo  Miller  15
3562                   Max  Miller  12
3563         """
3564         for col in self.columns.values():
3565             # First statement in try: will succeed if the column supports an in-place
3566             # update, and matches the legacy behavior of astropy Table.  However,
3567             # some mixin classes may not support this, so in that case just drop
3568             # in the entire new column. See #9836, #9553, and #9536 for discussion.
3569             new_col = col[::-1]
3570             try:
3571                 col[:] = new_col
3572             except Exception:
3573                 # In-place update failed for some reason, exception class not
3574                 # predictable for arbitrary mixin.
3575                 self[col.info.name] = new_col
3576 
3577         for index in self.indices:
3578             index.reverse()
3579 
3580     def round(self, decimals=0):
3581         """
3582         Round numeric columns in-place to the specified number of decimals.
3583         Non-numeric columns will be ignored.
3584 
3585         Examples
3586         --------
3587         Create three columns with different types:
3588 
3589             >>> t = Table([[1, 4, 5], [-25.55, 12.123, 85],
3590             ...     ['a', 'b', 'c']], names=('a', 'b', 'c'))
3591             >>> print(t)
3592              a    b     c
3593             --- ------ ---
3594               1 -25.55   a
3595               4 12.123   b
3596               5   85.0   c
3597 
3598         Round them all to 0:
3599 
3600             >>> t.round(0)
3601             >>> print(t)
3602              a    b    c
3603             --- ----- ---
3604               1 -26.0   a
3605               4  12.0   b
3606               5  85.0   c
3607 
3608         Round column 'a' to -1 decimal:
3609 
3610             >>> t.round({'a':-1})
3611             >>> print(t)
3612              a    b    c
3613             --- ----- ---
3614               0 -26.0   a
3615               0  12.0   b
3616               0  85.0   c
3617 
3618         Parameters
3619         ----------
3620         decimals: int, dict
3621             Number of decimals to round the columns to. If a dict is given,
3622             the columns will be rounded to the number specified as the value.
3623             If a certain column is not in the dict given, it will remain the
3624             same.
3625         """
3626         if isinstance(decimals, Mapping):
3627             decimal_values = decimals.values()
3628             column_names = decimals.keys()
3629         elif isinstance(decimals, int):
3630             decimal_values = itertools.repeat(decimals)
3631             column_names = self.colnames
3632         else:
3633             raise ValueError("'decimals' argument must be an int or a dict")
3634 
3635         for colname, decimal in zip(column_names, decimal_values):
3636             col = self.columns[colname]
3637             if np.issubdtype(col.info.dtype, np.number):
3638                 try:
3639                     np.around(col, decimals=decimal, out=col)
3640                 except TypeError:
3641                     # Bug in numpy see https://github.com/numpy/numpy/issues/15438
3642                     col[()] = np.around(col, decimals=decimal)
3643 
3644     def copy(self, copy_data=True):
3645         """
3646         Return a copy of the table.
3647 
3648         Parameters
3649         ----------
3650         copy_data : bool
3651             If `True` (the default), copy the underlying data array.
3652             Otherwise, use the same data array. The ``meta`` is always
3653             deepcopied regardless of the value for ``copy_data``.
3654         """
3655         out = self.__class__(self, copy=copy_data)
3656 
3657         # If the current table is grouped then do the same in the copy
3658         if hasattr(self, "_groups"):
3659             out._groups = groups.TableGroups(
3660                 out, indices=self._groups._indices, keys=self._groups._keys
3661             )
3662         return out
3663 
3664     def __deepcopy__(self, memo=None):
3665         return self.copy(True)
3666 
3667     def __copy__(self):
3668         return self.copy(False)
3669 
3670     def __lt__(self, other):
3671         return super().__lt__(other)
3672 
3673     def __gt__(self, other):
3674         return super().__gt__(other)
3675 
3676     def __le__(self, other):
3677         return super().__le__(other)
3678 
3679     def __ge__(self, other):
3680         return super().__ge__(other)
3681 
3682     def __eq__(self, other):
3683         return self._rows_equal(other)
3684 
3685     def __ne__(self, other):
3686         return ~self.__eq__(other)
3687 
3688     def _rows_equal(self, other):
3689         """
3690         Row-wise comparison of table with any other object.
3691 
3692         This is actual implementation for __eq__.
3693 
3694         Returns a 1-D boolean numpy array showing result of row-wise comparison.
3695         This is the same as the ``==`` comparison for tables.
3696 
3697         Parameters
3698         ----------
3699         other : Table or DataFrame or ndarray
3700              An object to compare with table
3701 
3702         Examples
3703         --------
3704         Comparing one Table with other::
3705 
3706             >>> t1 = Table([[1,2],[4,5],[7,8]], names=('a','b','c'))
3707             >>> t2 = Table([[1,2],[4,5],[7,8]], names=('a','b','c'))
3708             >>> t1._rows_equal(t2)
3709             array([ True,  True])
3710 
3711         """
3712         if isinstance(other, Table):
3713             other = other.as_array()
3714 
3715         if self.has_masked_columns:
3716             if isinstance(other, np.ma.MaskedArray):
3717                 result = self.as_array() == other
3718             else:
3719                 # If mask is True, then by definition the row doesn't match
3720                 # because the other array is not masked.
3721                 false_mask = np.zeros(1, dtype=[(n, bool) for n in self.dtype.names])
3722                 result = (self.as_array().data == other) & (self.mask == false_mask)
3723         else:
3724             if isinstance(other, np.ma.MaskedArray):
3725                 # If mask is True, then by definition the row doesn't match
3726                 # because the other array is not masked.
3727                 false_mask = np.zeros(1, dtype=[(n, bool) for n in other.dtype.names])
3728                 result = (self.as_array() == other.data) & (other.mask == false_mask)
3729             else:
3730                 result = self.as_array() == other
3731 
3732         return result
3733 
3734     def values_equal(self, other):
3735         """
3736         Element-wise comparison of table with another table, list, or scalar.
3737 
3738         Returns a ``Table`` with the same columns containing boolean values
3739         showing result of comparison.
3740 
3741         Parameters
3742         ----------
3743         other : table-like object or list or scalar
3744              Object to compare with table
3745 
3746         Examples
3747         --------
3748         Compare one Table with other::
3749 
3750           >>> t1 = Table([[1, 2], [4, 5], [-7, 8]], names=('a', 'b', 'c'))
3751           >>> t2 = Table([[1, 2], [-4, 5], [7, 8]], names=('a', 'b', 'c'))
3752           >>> t1.values_equal(t2)
3753           <Table length=2>
3754            a     b     c
3755           bool  bool  bool
3756           ---- ----- -----
3757           True False False
3758           True  True  True
3759 
3760         """
3761         if isinstance(other, Table):
3762             names = other.colnames
3763         else:
3764             try:
3765                 other = Table(other, copy=False)
3766                 names = other.colnames
3767             except Exception:
3768                 # Broadcast other into a dict, so e.g. other = 2 will turn into
3769                 # other = {'a': 2, 'b': 2} and then equality does a
3770                 # column-by-column broadcasting.
3771                 names = self.colnames
3772                 other = {name: other for name in names}
3773 
3774         # Require column names match but do not require same column order
3775         if set(self.colnames) != set(names):
3776             raise ValueError("cannot compare tables with different column names")
3777 
3778         eqs = []
3779         for name in names:
3780             try:
3781                 np.broadcast(self[name], other[name])  # Check if broadcast-able
3782                 # Catch the numpy FutureWarning related to equality checking,
3783                 # "elementwise comparison failed; returning scalar instead, but
3784                 #  in the future will perform elementwise comparison".  Turn this
3785                 # into an exception since the scalar answer is not what we want.
3786                 with warnings.catch_warnings(record=True) as warns:
3787                     warnings.simplefilter("always")
3788                     eq = self[name] == other[name]
3789                     if (
3790                         warns
3791                         and issubclass(warns[-1].category, FutureWarning)
3792                         and "elementwise comparison failed" in str(warns[-1].message)
3793                     ):
3794                         raise FutureWarning(warns[-1].message)
3795             except Exception as err:
3796                 raise ValueError(f"unable to compare column {name}") from err
3797 
3798             # Be strict about the result from the comparison. E.g. SkyCoord __eq__ is just
3799             # broken and completely ignores that it should return an array.
3800             if not (
3801                 isinstance(eq, np.ndarray)
3802                 and eq.dtype is np.dtype("bool")
3803                 and len(eq) == len(self)
3804             ):
3805                 raise TypeError(
3806                     f"comparison for column {name} returned {eq} "
3807                     "instead of the expected boolean ndarray"
3808                 )
3809 
3810             eqs.append(eq)
3811 
3812         out = Table(eqs, names=names)
3813 
3814         return out
3815 
3816     @property
3817     def groups(self):
3818         if not hasattr(self, "_groups"):
3819             self._groups = groups.TableGroups(self)
3820         return self._groups
3821 
3822     def group_by(self, keys):
3823         """
3824         Group this table by the specified ``keys``.
3825 
3826         This effectively splits the table into groups which correspond to unique
3827         values of the ``keys`` grouping object.  The output is a new
3828         `~astropy.table.TableGroups` which contains a copy of this table but
3829         sorted by row according to ``keys``.
3830 
3831         The ``keys`` input to `group_by` can be specified in different ways:
3832 
3833           - String or list of strings corresponding to table column name(s)
3834           - Numpy array (homogeneous or structured) with same length as this table
3835           - `~astropy.table.Table` with same length as this table
3836 
3837         Parameters
3838         ----------
3839         keys : str, list of str, numpy array, or `~astropy.table.Table`
3840             Key grouping object
3841 
3842         Returns
3843         -------
3844         out : `~astropy.table.Table`
3845             New table with groups set
3846         """
3847         return groups.table_group_by(self, keys)
3848 
3849     def to_pandas(self, index=None, use_nullable_int=True):
3850         """
3851         Return a :class:`pandas.DataFrame` instance.
3852 
3853         The index of the created DataFrame is controlled by the ``index``
3854         argument.  For ``index=True`` or the default ``None``, an index will be
3855         specified for the DataFrame if there is a primary key index on the
3856         Table *and* if it corresponds to a single column.  If ``index=False``
3857         then no DataFrame index will be specified.  If ``index`` is the name of
3858         a column in the table then that will be the DataFrame index.
3859 
3860         In addition to vanilla columns or masked columns, this supports Table
3861         mixin columns like Quantity, Time, or SkyCoord.  In many cases these
3862         objects have no analog in pandas and will be converted to a "encoded"
3863         representation using only Column or MaskedColumn.  The exception is
3864         Time or TimeDelta columns, which will be converted to the corresponding
3865         representation in pandas using ``np.datetime64`` or ``np.timedelta64``.
3866         See the example below.
3867 
3868         Parameters
3869         ----------
3870         index : None, bool, str
3871             Specify DataFrame index mode
3872         use_nullable_int : bool, default=True
3873             Convert integer MaskedColumn to pandas nullable integer type.
3874             If ``use_nullable_int=False`` or the pandas version does not support
3875             nullable integer types (version < 0.24), then the column is converted
3876             to float with NaN for missing elements and a warning is issued.
3877 
3878         Returns
3879         -------
3880         dataframe : :class:`pandas.DataFrame`
3881             A pandas :class:`pandas.DataFrame` instance
3882 
3883         Raises
3884         ------
3885         ImportError
3886             If pandas is not installed
3887         ValueError
3888             If the Table has multi-dimensional columns
3889 
3890         Examples
3891         --------
3892         Here we convert a table with a few mixins to a
3893         :class:`pandas.DataFrame` instance.
3894 
3895           >>> import pandas as pd
3896           >>> from astropy.table import QTable
3897           >>> import astropy.units as u
3898           >>> from astropy.time import Time, TimeDelta
3899           >>> from astropy.coordinates import SkyCoord
3900 
3901           >>> q = [1, 2] * u.m
3902           >>> tm = Time([1998, 2002], format='jyear')
3903           >>> sc = SkyCoord([5, 6], [7, 8], unit='deg')
3904           >>> dt = TimeDelta([3, 200] * u.s)
3905 
3906           >>> t = QTable([q, tm, sc, dt], names=['q', 'tm', 'sc', 'dt'])
3907 
3908           >>> df = t.to_pandas(index='tm')
3909           >>> with pd.option_context('display.max_columns', 20):
3910           ...     print(df)
3911                         q  sc.ra  sc.dec              dt
3912           tm
3913           1998-01-01  1.0    5.0     7.0 0 days 00:00:03
3914           2002-01-01  2.0    6.0     8.0 0 days 00:03:20
3915 
3916         """
3917         from pandas import DataFrame, Series
3918 
3919         if index is not False:
3920             if index in (None, True):
3921                 # Default is to use the table primary key if available and a single column
3922                 if self.primary_key and len(self.primary_key) == 1:
3923                     index = self.primary_key[0]
3924                 else:
3925                     index = False
3926             else:
3927                 if index not in self.colnames:
3928                     raise ValueError(
3929                         "index must be None, False, True or a table column name"
3930                     )
3931 
3932         def _encode_mixins(tbl):
3933             """Encode a Table ``tbl`` that may have mixin columns to a Table with only
3934             astropy Columns + appropriate meta-data to allow subsequent decoding.
3935             """
3936             from astropy.time import TimeBase, TimeDelta
3937 
3938             from . import serialize
3939 
3940             # Convert any Time or TimeDelta columns and pay attention to masking
3941             time_cols = [col for col in tbl.itercols() if isinstance(col, TimeBase)]
3942             if time_cols:
3943                 # Make a light copy of table and clear any indices
3944                 new_cols = []
3945                 for col in tbl.itercols():
3946                     new_col = (
3947                         col_copy(col, copy_indices=False) if col.info.indices else col
3948                     )
3949                     new_cols.append(new_col)
3950                 tbl = tbl.__class__(new_cols, copy=False)
3951 
3952                 # Certain subclasses (e.g. TimeSeries) may generate new indices on
3953                 # table creation, so make sure there are no indices on the table.
3954                 for col in tbl.itercols():
3955                     col.info.indices.clear()
3956 
3957                 for col in time_cols:
3958                     if isinstance(col, TimeDelta):
3959                         # Convert to nanoseconds (matches astropy datetime64 support)
3960                         new_col = (col.sec * 1e9).astype("timedelta64[ns]")
3961                         nat = np.timedelta64("NaT")
3962                     else:
3963                         new_col = col.datetime64.copy()
3964                         nat = np.datetime64("NaT")
3965                     if col.masked:
3966                         new_col[col.mask] = nat
3967                     tbl[col.info.name] = new_col
3968 
3969             # Convert the table to one with no mixins, only Column objects.
3970             encode_tbl = serialize.represent_mixins_as_columns(tbl)
3971             return encode_tbl
3972 
3973         tbl = _encode_mixins(self)
3974 
3975         badcols = [name for name, col in self.columns.items() if len(col.shape) > 1]
3976         if badcols:
3977             # fmt: off
3978             raise ValueError(
3979                 f'Cannot convert a table with multidimensional columns to a '
3980                 f'pandas DataFrame. Offending columns are: {badcols}\n'
3981                 f'One can filter out such columns using:\n'
3982                 f'names = [name for name in tbl.colnames if len(tbl[name].shape) <= 1]\n'
3983                 f'tbl[names].to_pandas(...)'
3984             )
3985             # fmt: on
3986 
3987         out = OrderedDict()
3988 
3989         for name, column in tbl.columns.items():
3990             if getattr(column.dtype, "isnative", True):
3991                 out[name] = column
3992             else:
3993                 out[name] = column.data.byteswap().newbyteorder("=")
3994 
3995             if isinstance(column, MaskedColumn) and np.any(column.mask):
3996                 if column.dtype.kind in ["i", "u"]:
3997                     pd_dtype = column.dtype.name
3998                     if use_nullable_int:
3999                         # Convert int64 to Int64, uint32 to UInt32, etc for nullable types
4000                         pd_dtype = pd_dtype.replace("i", "I").replace("u", "U")
4001                     out[name] = Series(out[name], dtype=pd_dtype)
4002 
4003                     # If pandas is older than 0.24 the type may have turned to float
4004                     if column.dtype.kind != out[name].dtype.kind:
4005                         warnings.warn(
4006                             f"converted column '{name}' from {column.dtype} to"
4007                             f" {out[name].dtype}",
4008                             TableReplaceWarning,
4009                             stacklevel=3,
4010                         )
4011                 elif column.dtype.kind not in ["f", "c"]:
4012                     out[name] = column.astype(object).filled(np.nan)
4013 
4014         kwargs = {}
4015 
4016         if index:
4017             idx = out.pop(index)
4018 
4019             kwargs["index"] = idx
4020 
4021             # We add the table index to Series inputs (MaskedColumn with int values) to override
4022             # its default RangeIndex, see #11432
4023             for v in out.values():
4024                 if isinstance(v, Series):
4025                     v.index = idx
4026 
4027         df = DataFrame(out, **kwargs)
4028         if index:
4029             # Explicitly set the pandas DataFrame index to the original table
4030             # index name.
4031             df.index.name = idx.info.name
4032 
4033         return df
4034 
4035     @classmethod
4036     def from_pandas(cls, dataframe, index=False, units=None):
4037         """
4038         Create a `~astropy.table.Table` from a :class:`pandas.DataFrame` instance.
4039 
4040         In addition to converting generic numeric or string columns, this supports
4041         conversion of pandas Date and Time delta columns to `~astropy.time.Time`
4042         and `~astropy.time.TimeDelta` columns, respectively.
4043 
4044         Parameters
4045         ----------
4046         dataframe : :class:`pandas.DataFrame`
4047             A pandas :class:`pandas.DataFrame` instance
4048         index : bool
4049             Include the index column in the returned table (default=False)
4050         units: dict
4051             A dict mapping column names to to a `~astropy.units.Unit`.
4052             The columns will have the specified unit in the Table.
4053 
4054         Returns
4055         -------
4056         table : `~astropy.table.Table`
4057             A `~astropy.table.Table` (or subclass) instance
4058 
4059         Raises
4060         ------
4061         ImportError
4062             If pandas is not installed
4063 
4064         Examples
4065         --------
4066         Here we convert a :class:`pandas.DataFrame` instance
4067         to a `~astropy.table.QTable`.
4068 
4069           >>> import numpy as np
4070           >>> import pandas as pd
4071           >>> from astropy.table import QTable
4072 
4073           >>> time = pd.Series(['1998-01-01', '2002-01-01'], dtype='datetime64[ns]')
4074           >>> dt = pd.Series(np.array([1, 300], dtype='timedelta64[s]'))
4075           >>> df = pd.DataFrame({'time': time})
4076           >>> df['dt'] = dt
4077           >>> df['x'] = [3., 4.]
4078           >>> with pd.option_context('display.max_columns', 20):
4079           ...     print(df)
4080                   time              dt    x
4081           0 1998-01-01 0 days 00:00:01  3.0
4082           1 2002-01-01 0 days 00:05:00  4.0
4083 
4084           >>> QTable.from_pandas(df)
4085           <QTable length=2>
4086                     time              dt       x
4087                     Time          TimeDelta float64
4088           ----------------------- --------- -------
4089           1998-01-01T00:00:00.000       1.0     3.0
4090           2002-01-01T00:00:00.000     300.0     4.0
4091 
4092         """
4093         out = OrderedDict()
4094 
4095         names = list(dataframe.columns)
4096         columns = [dataframe[name] for name in names]
4097         datas = [np.array(column) for column in columns]
4098         masks = [np.array(column.isnull()) for column in columns]
4099 
4100         if index:
4101             index_name = dataframe.index.name or "index"
4102             while index_name in names:
4103                 index_name = "_" + index_name + "_"
4104             names.insert(0, index_name)
4105             columns.insert(0, dataframe.index)
4106             datas.insert(0, np.array(dataframe.index))
4107             masks.insert(0, np.zeros(len(dataframe), dtype=bool))
4108 
4109         if units is None:
4110             units = [None] * len(names)
4111         else:
4112             if not isinstance(units, Mapping):
4113                 raise TypeError('Expected a Mapping "column-name" -> "unit"')
4114 
4115             not_found = set(units.keys()) - set(names)
4116             if not_found:
4117                 warnings.warn(f"`units` contains additional columns: {not_found}")
4118 
4119             units = [units.get(name) for name in names]
4120 
4121         for name, column, data, mask, unit in zip(names, columns, datas, masks, units):
4122             if column.dtype.kind in ["u", "i"] and np.any(mask):
4123                 # Special-case support for pandas nullable int
4124                 np_dtype = str(column.dtype).lower()
4125                 data = np.zeros(shape=column.shape, dtype=np_dtype)
4126                 data[~mask] = column[~mask]
4127                 out[name] = MaskedColumn(
4128                     data=data, name=name, mask=mask, unit=unit, copy=False
4129                 )
4130                 continue
4131 
4132             if data.dtype.kind == "O":
4133                 # If all elements of an object array are string-like or np.nan
4134                 # then coerce back to a native numpy str/unicode array.
4135                 string_types = (str, bytes)
4136                 nan = np.nan
4137                 if all(isinstance(x, string_types) or x is nan for x in data):
4138                     # Force any missing (null) values to b''.  Numpy will
4139                     # upcast to str/unicode as needed.
4140                     data[mask] = b""
4141 
4142                     # When the numpy object array is represented as a list then
4143                     # numpy initializes to the correct string or unicode type.
4144                     data = np.array(list(data))
4145 
4146             # Numpy datetime64
4147             if data.dtype.kind == "M":
4148                 from astropy.time import Time
4149 
4150                 out[name] = Time(data, format="datetime64")
4151                 if np.any(mask):
4152                     out[name][mask] = np.ma.masked
4153                 out[name].format = "isot"
4154 
4155             # Numpy timedelta64
4156             elif data.dtype.kind == "m":
4157                 from astropy.time import TimeDelta
4158 
4159                 data_sec = data.astype("timedelta64[ns]").astype(np.float64) / 1e9
4160                 out[name] = TimeDelta(data_sec, format="sec")
4161                 if np.any(mask):
4162                     out[name][mask] = np.ma.masked
4163 
4164             else:
4165                 if np.any(mask):
4166                     out[name] = MaskedColumn(data=data, name=name, mask=mask, unit=unit)
4167                 else:
4168                     out[name] = Column(data=data, name=name, unit=unit)
4169 
4170         return cls(out)
4171 
4172     info = TableInfo()

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>, <file>astropy/table/groups.py</file>
<class>None</class>
<method>table_group_by</method>
<code>
15 def table_group_by(table, keys):
16     # index copies are unnecessary and slow down _table_group_by
17     with table.index_mode("discard_on_copy"):
18         return _table_group_by(table, keys)

</code><intended_behavior>This function should be modified or enhanced to correctly handle quantity columns by ensuring that units are not discarded during the process of grouping. To resolve the issue, this function needs to identify columns with quantity data and treat them such that their units are preserved in the group keys. This may require a mechanism to explicitly check and retain units when forming group keys from quantity columns.</intended_behavior>]
2025-10-17 22:23:33.045 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-17 22:23:33.046 | INFO     | Search-only: skipping patch selection
2025-10-17 22:23:33.191 | INFO     | Task astropy__astropy-14966 completed successfully.
2025-10-17 22:23:33.192 | INFO     | No patch generated. You can try running ACR again.
