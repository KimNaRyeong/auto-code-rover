[
    {
        "rel_file_path": "sphinx/domains/rst.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__3.0/sphinx/domains/rst.py",
        "start": 118,
        "end": 188,
        "class_name": "ReSTDirectiveOption",
        "method_name": null,
        "code": "118 class ReSTDirectiveOption(ReSTMarkup):\n119     \"\"\"\n120     Description of an option for reST directive.\n121     \"\"\"\n122     option_spec = ReSTMarkup.option_spec.copy()\n123     option_spec.update({\n124         'type': directives.unchanged,\n125     })\n126 \n127     def handle_signature(self, sig: str, signode: desc_signature) -> str:\n128         try:\n129             name, argument = re.split(r'\\s*:\\s+', sig.strip(), 1)\n130         except ValueError:\n131             name, argument = sig, None\n132 \n133         signode += addnodes.desc_name(':%s:' % name, ':%s:' % name)\n134         if argument:\n135             signode += addnodes.desc_annotation(' ' + argument, ' ' + argument)\n136         if self.options.get('type'):\n137             text = ' (%s)' % self.options['type']\n138             signode += addnodes.desc_annotation(text, text)\n139         return name\n140 \n141     def add_target_and_index(self, name: str, sig: str, signode: desc_signature) -> None:\n142         domain = cast(ReSTDomain, self.env.get_domain('rst'))\n143 \n144         directive_name = self.current_directive\n145         if directive_name:\n146             prefix = '-'.join([self.objtype, directive_name])\n147             objname = ':'.join([directive_name, name])\n148         else:\n149             prefix = self.objtype\n150             objname = name\n151 \n152         node_id = make_id(self.env, self.state.document, prefix, name)\n153         signode['ids'].append(node_id)\n154 \n155         # Assign old styled node_id not to break old hyperlinks (if possible)\n156         # Note: Will be removed in Sphinx-5.0 (RemovedInSphinx50Warning)\n157         old_node_id = self.make_old_id(name)\n158         if old_node_id not in self.state.document.ids and old_node_id not in signode['ids']:\n159             signode['ids'].append(old_node_id)\n160 \n161         self.state.document.note_explicit_target(signode)\n162         domain.note_object(self.objtype, objname, node_id, location=signode)\n163 \n164         if directive_name:\n165             key = name[0].upper()\n166             pair = [_('%s (directive)') % directive_name,\n167                     _(':%s: (directive option)') % name]\n168             self.indexnode['entries'].append(('pair', '; '.join(pair), node_id, '', key))\n169         else:\n170             key = name[0].upper()\n171             text = _(':%s: (directive option)') % name\n172             self.indexnode['entries'].append(('single', text, node_id, '', key))\n173 \n174     @property\n175     def current_directive(self) -> str:\n176         directives = self.env.ref_context.get('rst:directives')\n177         if directives:\n178             return directives[-1]\n179         else:\n180             return ''\n181 \n182     def make_old_id(self, name: str) -> str:\n183         \"\"\"Generate old styled node_id for directive options.\n184 \n185         .. note:: Old Styled node_id was used until Sphinx-3.0.\n186                   This will be removed in Sphinx-5.0.\n187         \"\"\"\n188         return '-'.join([self.objtype, self.current_directive, name])\n",
        "intended_behavior": "Any mechanism within Sphinx that handles directives, particularly those extending the usage or implementation of directive options (like `ReSTDirectiveOption`), should ensure comprehensive parsing and application of all recognized option flags, including `:noindex:`. It should correctly flag content that is associated with `:noindex:` to be excluded from indexing processes. The existing functionality to generate identifiers or handle directive options must remain intact, but it should be extended or checked for consistent handling of all options across different directive types."
    },
    {
        "rel_file_path": "sphinx/util/docutils.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__3.0/sphinx/util/docutils.py",
        "start": 1,
        "end": 514,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2     sphinx.util.docutils\n3     ~~~~~~~~~~~~~~~~~~~~\n4 \n5     Utility functions for docutils.\n6 \n7     :copyright: Copyright 2007-2020 by the Sphinx team, see AUTHORS.\n8     :license: BSD, see LICENSE for details.\n9 \"\"\"\n10 \n11 import os\n12 import re\n13 from contextlib import contextmanager\n14 from copy import copy\n15 from distutils.version import LooseVersion\n16 from os import path\n17 from types import ModuleType\n18 from typing import Any, Callable, Dict, Generator, IO, List, Optional, Set, Tuple\n19 from typing import cast\n20 \n21 import docutils\n22 from docutils import nodes\n23 from docutils.io import FileOutput\n24 from docutils.nodes import Element, Node, system_message\n25 from docutils.parsers.rst import Directive, directives, roles\n26 from docutils.parsers.rst.states import Inliner\n27 from docutils.statemachine import StateMachine, State, StringList\n28 from docutils.utils import Reporter, unescape\n29 \n30 from sphinx.errors import SphinxError\n31 from sphinx.util import logging\n32 from sphinx.util.typing import RoleFunction\n33 \n34 logger = logging.getLogger(__name__)\n35 report_re = re.compile('^(.+?:(?:\\\\d+)?): \\\\((DEBUG|INFO|WARNING|ERROR|SEVERE)/(\\\\d+)?\\\\) ')\n36 \n37 if False:\n38     # For type annotation\n39     from typing import Type  # for python3.5.1\n40     from sphinx.builders import Builder\n41     from sphinx.config import Config\n42     from sphinx.environment import BuildEnvironment\n43 \n44 \n45 __version_info__ = tuple(LooseVersion(docutils.__version__).version)\n46 additional_nodes = set()  # type: Set[Type[nodes.Element]]\n47 \n48 \n49 @contextmanager\n50 def docutils_namespace() -> Generator[None, None, None]:\n51     \"\"\"Create namespace for reST parsers.\"\"\"\n52     try:\n53         _directives = copy(directives._directives)  # type: ignore\n54         _roles = copy(roles._roles)  # type: ignore\n55 \n56         yield\n57     finally:\n58         directives._directives = _directives  # type: ignore\n59         roles._roles = _roles  # type: ignore\n60 \n61         for node in list(additional_nodes):\n62             unregister_node(node)\n63             additional_nodes.discard(node)\n64 \n65 \n66 def is_directive_registered(name: str) -> bool:\n67     \"\"\"Check the *name* directive is already registered.\"\"\"\n68     return name in directives._directives  # type: ignore\n69 \n70 \n71 def register_directive(name: str, directive: \"Type[Directive]\") -> None:\n72     \"\"\"Register a directive to docutils.\n73 \n74     This modifies global state of docutils.  So it is better to use this\n75     inside ``docutils_namespace()`` to prevent side-effects.\n76     \"\"\"\n77     directives.register_directive(name, directive)\n78 \n79 \n80 def is_role_registered(name: str) -> bool:\n81     \"\"\"Check the *name* role is already registered.\"\"\"\n82     return name in roles._roles  # type: ignore\n83 \n84 \n85 def register_role(name: str, role: RoleFunction) -> None:\n86     \"\"\"Register a role to docutils.\n87 \n88     This modifies global state of docutils.  So it is better to use this\n89     inside ``docutils_namespace()`` to prevent side-effects.\n90     \"\"\"\n91     roles.register_local_role(name, role)\n92 \n93 \n94 def unregister_role(name: str) -> None:\n95     \"\"\"Unregister a role from docutils.\"\"\"\n96     roles._roles.pop(name, None)  # type: ignore\n97 \n98 \n99 def is_node_registered(node: \"Type[Element]\") -> bool:\n100     \"\"\"Check the *node* is already registered.\"\"\"\n101     return hasattr(nodes.GenericNodeVisitor, 'visit_' + node.__name__)\n102 \n103 \n104 def register_node(node: \"Type[Element]\") -> None:\n105     \"\"\"Register a node to docutils.\n106 \n107     This modifies global state of some visitors.  So it is better to use this\n108     inside ``docutils_namespace()`` to prevent side-effects.\n109     \"\"\"\n110     if not hasattr(nodes.GenericNodeVisitor, 'visit_' + node.__name__):\n111         nodes._add_node_class_names([node.__name__])  # type: ignore\n112         additional_nodes.add(node)\n113 \n114 \n115 def unregister_node(node: \"Type[Element]\") -> None:\n116     \"\"\"Unregister a node from docutils.\n117 \n118     This is inverse of ``nodes._add_nodes_class_names()``.\n119     \"\"\"\n120     if hasattr(nodes.GenericNodeVisitor, 'visit_' + node.__name__):\n121         delattr(nodes.GenericNodeVisitor, \"visit_\" + node.__name__)\n122         delattr(nodes.GenericNodeVisitor, \"depart_\" + node.__name__)\n123         delattr(nodes.SparseNodeVisitor, 'visit_' + node.__name__)\n124         delattr(nodes.SparseNodeVisitor, 'depart_' + node.__name__)\n125 \n126 \n127 @contextmanager\n128 def patched_get_language() -> Generator[None, None, None]:\n129     \"\"\"Patch docutils.languages.get_language() temporarily.\n130 \n131     This ignores the second argument ``reporter`` to suppress warnings.\n132     refs: https://github.com/sphinx-doc/sphinx/issues/3788\n133     \"\"\"\n134     from docutils.languages import get_language\n135 \n136     def patched_get_language(language_code: str, reporter: Reporter = None) -> Any:\n137         return get_language(language_code)\n138 \n139     try:\n140         docutils.languages.get_language = patched_get_language\n141         yield\n142     finally:\n143         # restore original implementations\n144         docutils.languages.get_language = get_language\n145 \n146 \n147 @contextmanager\n148 def using_user_docutils_conf(confdir: str) -> Generator[None, None, None]:\n149     \"\"\"Let docutils know the location of ``docutils.conf`` for Sphinx.\"\"\"\n150     try:\n151         docutilsconfig = os.environ.get('DOCUTILSCONFIG', None)\n152         if confdir:\n153             os.environ['DOCUTILSCONFIG'] = path.join(path.abspath(confdir), 'docutils.conf')\n154 \n155         yield\n156     finally:\n157         if docutilsconfig is None:\n158             os.environ.pop('DOCUTILSCONFIG', None)\n159         else:\n160             os.environ['DOCUTILSCONFIG'] = docutilsconfig\n161 \n162 \n163 @contextmanager\n164 def patch_docutils(confdir: str = None) -> Generator[None, None, None]:\n165     \"\"\"Patch to docutils temporarily.\"\"\"\n166     with patched_get_language(), using_user_docutils_conf(confdir):\n167         yield\n168 \n169 \n170 class ElementLookupError(Exception):\n171     pass\n172 \n173 \n174 class sphinx_domains:\n175     \"\"\"Monkey-patch directive and role dispatch, so that domain-specific\n176     markup takes precedence.\n177     \"\"\"\n178     def __init__(self, env: \"BuildEnvironment\") -> None:\n179         self.env = env\n180         self.directive_func = None  # type: Callable\n181         self.roles_func = None  # type: Callable\n182 \n183     def __enter__(self) -> None:\n184         self.enable()\n185 \n186     def __exit__(self, exc_type: \"Type[Exception]\", exc_value: Exception, traceback: Any) -> None:  # NOQA\n187         self.disable()\n188 \n189     def enable(self) -> None:\n190         self.directive_func = directives.directive\n191         self.role_func = roles.role\n192 \n193         directives.directive = self.lookup_directive\n194         roles.role = self.lookup_role\n195 \n196     def disable(self) -> None:\n197         directives.directive = self.directive_func\n198         roles.role = self.role_func\n199 \n200     def lookup_domain_element(self, type: str, name: str) -> Any:\n201         \"\"\"Lookup a markup element (directive or role), given its name which can\n202         be a full name (with domain).\n203         \"\"\"\n204         name = name.lower()\n205         # explicit domain given?\n206         if ':' in name:\n207             domain_name, name = name.split(':', 1)\n208             if domain_name in self.env.domains:\n209                 domain = self.env.get_domain(domain_name)\n210                 element = getattr(domain, type)(name)\n211                 if element is not None:\n212                     return element, []\n213         # else look in the default domain\n214         else:\n215             def_domain = self.env.temp_data.get('default_domain')\n216             if def_domain is not None:\n217                 element = getattr(def_domain, type)(name)\n218                 if element is not None:\n219                     return element, []\n220 \n221         # always look in the std domain\n222         element = getattr(self.env.get_domain('std'), type)(name)\n223         if element is not None:\n224             return element, []\n225 \n226         raise ElementLookupError\n227 \n228     def lookup_directive(self, directive_name: str, language_module: ModuleType, document: nodes.document) -> Tuple[Optional[\"Type[Directive]\"], List[system_message]]:  # NOQA\n229         try:\n230             return self.lookup_domain_element('directive', directive_name)\n231         except ElementLookupError:\n232             return self.directive_func(directive_name, language_module, document)\n233 \n234     def lookup_role(self, role_name: str, language_module: ModuleType, lineno: int, reporter: Reporter) -> Tuple[RoleFunction, List[system_message]]:  # NOQA\n235         try:\n236             return self.lookup_domain_element('role', role_name)\n237         except ElementLookupError:\n238             return self.role_func(role_name, language_module, lineno, reporter)\n239 \n240 \n241 class WarningStream:\n242     def write(self, text: str) -> None:\n243         matched = report_re.search(text)\n244         if not matched:\n245             logger.warning(text.rstrip(\"\\r\\n\"))\n246         else:\n247             location, type, level = matched.groups()\n248             message = report_re.sub('', text).rstrip()\n249             logger.log(type, message, location=location)\n250 \n251 \n252 class LoggingReporter(Reporter):\n253     @classmethod\n254     def from_reporter(cls, reporter: Reporter) -> \"LoggingReporter\":\n255         \"\"\"Create an instance of LoggingReporter from other reporter object.\"\"\"\n256         return cls(reporter.source, reporter.report_level, reporter.halt_level,\n257                    reporter.debug_flag, reporter.error_handler)\n258 \n259     def __init__(self, source: str, report_level: int = Reporter.WARNING_LEVEL,\n260                  halt_level: int = Reporter.SEVERE_LEVEL, debug: bool = False,\n261                  error_handler: str = 'backslashreplace') -> None:\n262         stream = cast(IO, WarningStream())\n263         super().__init__(source, report_level, halt_level,\n264                          stream, debug, error_handler=error_handler)\n265 \n266 \n267 class NullReporter(Reporter):\n268     \"\"\"A dummy reporter; write nothing.\"\"\"\n269 \n270     def __init__(self) -> None:\n271         super().__init__('', 999, 4)\n272 \n273 \n274 def is_html5_writer_available() -> bool:\n275     return __version_info__ > (0, 13, 0)\n276 \n277 \n278 @contextmanager\n279 def switch_source_input(state: State, content: StringList) -> Generator[None, None, None]:\n280     \"\"\"Switch current source input of state temporarily.\"\"\"\n281     try:\n282         # remember the original ``get_source_and_line()`` method\n283         get_source_and_line = state.memo.reporter.get_source_and_line  # type: ignore\n284 \n285         # replace it by new one\n286         state_machine = StateMachine([], None)\n287         state_machine.input_lines = content\n288         state.memo.reporter.get_source_and_line = state_machine.get_source_and_line  # type: ignore  # NOQA\n289 \n290         yield\n291     finally:\n292         # restore the method\n293         state.memo.reporter.get_source_and_line = get_source_and_line  # type: ignore\n294 \n295 \n296 class SphinxFileOutput(FileOutput):\n297     \"\"\"Better FileOutput class for Sphinx.\"\"\"\n298 \n299     def __init__(self, **kwargs: Any) -> None:\n300         self.overwrite_if_changed = kwargs.pop('overwrite_if_changed', False)\n301         super().__init__(**kwargs)\n302 \n303     def write(self, data: str) -> str:\n304         if (self.destination_path and self.autoclose and 'b' not in self.mode and\n305                 self.overwrite_if_changed and os.path.exists(self.destination_path)):\n306             with open(self.destination_path, encoding=self.encoding) as f:\n307                 # skip writing: content not changed\n308                 if f.read() == data:\n309                     return data\n310 \n311         return super().write(data)\n312 \n313 \n314 class SphinxDirective(Directive):\n315     \"\"\"A base class for Sphinx directives.\n316 \n317     This class provides helper methods for Sphinx directives.\n318 \n319     .. note:: The subclasses of this class might not work with docutils.\n320               This class is strongly coupled with Sphinx.\n321     \"\"\"\n322 \n323     @property\n324     def env(self) -> \"BuildEnvironment\":\n325         \"\"\"Reference to the :class:`.BuildEnvironment` object.\"\"\"\n326         return self.state.document.settings.env\n327 \n328     @property\n329     def config(self) -> \"Config\":\n330         \"\"\"Reference to the :class:`.Config` object.\"\"\"\n331         return self.env.config\n332 \n333     def get_source_info(self) -> Tuple[str, int]:\n334         \"\"\"Get source and line number.\"\"\"\n335         return self.state_machine.get_source_and_line(self.lineno)\n336 \n337     def set_source_info(self, node: Node) -> None:\n338         \"\"\"Set source and line number to the node.\"\"\"\n339         node.source, node.line = self.get_source_info()\n340 \n341 \n342 class SphinxRole:\n343     \"\"\"A base class for Sphinx roles.\n344 \n345     This class provides helper methods for Sphinx roles.\n346 \n347     .. note:: The subclasses of this class might not work with docutils.\n348               This class is strongly coupled with Sphinx.\n349     \"\"\"\n350     name = None     #: The role name actually used in the document.\n351     rawtext = None  #: A string containing the entire interpreted text input.\n352     text = None     #: The interpreted text content.\n353     lineno = None   #: The line number where the interpreted text begins.\n354     inliner = None  #: The ``docutils.parsers.rst.states.Inliner`` object.\n355     options = None  #: A dictionary of directive options for customization\n356                     #: (from the \"role\" directive).\n357     content = None  #: A list of strings, the directive content for customization\n358                     #: (from the \"role\" directive).\n359 \n360     def __call__(self, name: str, rawtext: str, text: str, lineno: int,\n361                  inliner: Inliner, options: Dict = {}, content: List[str] = []\n362                  ) -> Tuple[List[Node], List[system_message]]:\n363         self.rawtext = rawtext\n364         self.text = unescape(text)\n365         self.lineno = lineno\n366         self.inliner = inliner\n367         self.options = options\n368         self.content = content\n369 \n370         # guess role type\n371         if name:\n372             self.name = name.lower()\n373         else:\n374             self.name = self.env.temp_data.get('default_role')\n375             if not self.name:\n376                 self.name = self.env.config.default_role\n377             if not self.name:\n378                 raise SphinxError('cannot determine default role!')\n379 \n380         return self.run()\n381 \n382     def run(self) -> Tuple[List[Node], List[system_message]]:\n383         raise NotImplementedError\n384 \n385     @property\n386     def env(self) -> \"BuildEnvironment\":\n387         \"\"\"Reference to the :class:`.BuildEnvironment` object.\"\"\"\n388         return self.inliner.document.settings.env\n389 \n390     @property\n391     def config(self) -> \"Config\":\n392         \"\"\"Reference to the :class:`.Config` object.\"\"\"\n393         return self.env.config\n394 \n395     def get_source_info(self, lineno: int = None) -> Tuple[str, int]:\n396         if lineno is None:\n397             lineno = self.lineno\n398         return self.inliner.reporter.get_source_and_line(lineno)  # type: ignore\n399 \n400     def set_source_info(self, node: Node, lineno: int = None) -> None:\n401         node.source, node.line = self.get_source_info(lineno)\n402 \n403 \n404 class ReferenceRole(SphinxRole):\n405     \"\"\"A base class for reference roles.\n406 \n407     The reference roles can accpet ``link title <target>`` style as a text for\n408     the role.  The parsed result; link title and target will be stored to\n409     ``self.title`` and ``self.target``.\n410     \"\"\"\n411     has_explicit_title = None   #: A boolean indicates the role has explicit title or not.\n412     title = None                #: The link title for the interpreted text.\n413     target = None               #: The link target for the interpreted text.\n414 \n415     # \\x00 means the \"<\" was backslash-escaped\n416     explicit_title_re = re.compile(r'^(.+?)\\s*(?<!\\x00)<(.*?)>$', re.DOTALL)\n417 \n418     def __call__(self, name: str, rawtext: str, text: str, lineno: int,\n419                  inliner: Inliner, options: Dict = {}, content: List[str] = []\n420                  ) -> Tuple[List[Node], List[system_message]]:\n421         matched = self.explicit_title_re.match(text)\n422         if matched:\n423             self.has_explicit_title = True\n424             self.title = unescape(matched.group(1))\n425             self.target = unescape(matched.group(2))\n426         else:\n427             self.has_explicit_title = False\n428             self.title = unescape(text)\n429             self.target = unescape(text)\n430 \n431         return super().__call__(name, rawtext, text, lineno, inliner, options, content)\n432 \n433 \n434 class SphinxTranslator(nodes.NodeVisitor):\n435     \"\"\"A base class for Sphinx translators.\n436 \n437     This class adds a support for visitor/departure method for super node class\n438     if visitor/departure method for node class is not found.\n439 \n440     It also provides helper methods for Sphinx translators.\n441 \n442     .. note:: The subclasses of this class might not work with docutils.\n443               This class is strongly coupled with Sphinx.\n444     \"\"\"\n445 \n446     def __init__(self, document: nodes.document, builder: \"Builder\") -> None:\n447         super().__init__(document)\n448         self.builder = builder\n449         self.config = builder.config\n450         self.settings = document.settings\n451 \n452     def dispatch_visit(self, node: Node) -> None:\n453         \"\"\"\n454         Dispatch node to appropriate visitor method.\n455         The priority of visitor method is:\n456 \n457         1. ``self.visit_{node_class}()``\n458         2. ``self.visit_{supre_node_class}()``\n459         3. ``self.unknown_visit()``\n460         \"\"\"\n461         for node_class in node.__class__.__mro__:\n462             method = getattr(self, 'visit_%s' % (node_class.__name__), None)\n463             if method:\n464                 logger.debug('SphinxTranslator.dispatch_visit calling %s for %s',\n465                              method.__name__, node)\n466                 method(node)\n467                 break\n468         else:\n469             super().dispatch_visit(node)\n470 \n471     def dispatch_departure(self, node: Node) -> None:\n472         \"\"\"\n473         Dispatch node to appropriate departure method.\n474         The priority of departure method is:\n475 \n476         1. ``self.depart_{node_class}()``\n477         2. ``self.depart_{super_node_class}()``\n478         3. ``self.unknown_departure()``\n479         \"\"\"\n480         for node_class in node.__class__.__mro__:\n481             method = getattr(self, 'depart_%s' % (node_class.__name__), None)\n482             if method:\n483                 logger.debug('SphinxTranslator.dispatch_departure calling %s for %s',\n484                              method.__name__, node)\n485                 method(node)\n486                 break\n487         else:\n488             super().dispatch_departure(node)\n489 \n490 \n491 # cache a vanilla instance of nodes.document\n492 # Used in new_document() function\n493 __document_cache__ = None  # type: nodes.document\n494 \n495 \n496 def new_document(source_path: str, settings: Any = None) -> nodes.document:\n497     \"\"\"Return a new empty document object.  This is an alternative of docutils'.\n498 \n499     This is a simple wrapper for ``docutils.utils.new_document()``.  It\n500     caches the result of docutils' and use it on second call for instanciation.\n501     This makes an instantiation of document nodes much faster.\n502     \"\"\"\n503     global __document_cache__\n504     if __document_cache__ is None:\n505         __document_cache__ = docutils.utils.new_document(source_path)\n506 \n507     if settings is None:\n508         # Make a copy of ``settings`` from cache to accelerate instansiation\n509         settings = copy(__document_cache__.settings)\n510 \n511     # Create a new instance of nodes.document using cached reporter\n512     document = nodes.document(settings, __document_cache__.reporter, source=source_path)\n513     document.note_source(source_path, -1)\n514     return document\n",
        "intended_behavior": "The code within this file should ensure that directive options provided by users, especially those that control the inclusion or exclusion of content from the generated documentation (like `:noindex:`), are correctly parsed and applied. This involves making sure that any content or structure associated with a directive that includes `:noindex:` does not appear in the index or search results of the generated documentation. The functionality to customize directive behavior via options must be preserved, with added assurance that options are comprehensively accounted for and applied as intended."
    }
]