[
    {
        "rel_file_path": "src/_pytest/assertion/rewrite.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/pytest-dev__pytest/setup_pytest-dev__pytest__4.6/src/_pytest/assertion/rewrite.py",
        "start": 1,
        "end": 1069,
        "class_name": null,
        "method_name": null,
        "code": "1 # -*- coding: utf-8 -*-\n2 \"\"\"Rewrite assertion AST to produce nice error messages\"\"\"\n3 from __future__ import absolute_import\n4 from __future__ import division\n5 from __future__ import print_function\n6 \n7 import ast\n8 import errno\n9 import imp\n10 import itertools\n11 import marshal\n12 import os\n13 import re\n14 import string\n15 import struct\n16 import sys\n17 import types\n18 \n19 import atomicwrites\n20 import py\n21 import six\n22 \n23 from _pytest._io.saferepr import saferepr\n24 from _pytest.assertion import util\n25 from _pytest.assertion.util import (  # noqa: F401\n26     format_explanation as _format_explanation,\n27 )\n28 from _pytest.compat import spec_from_file_location\n29 from _pytest.pathlib import fnmatch_ex\n30 from _pytest.pathlib import PurePath\n31 \n32 # pytest caches rewritten pycs in __pycache__.\n33 if hasattr(imp, \"get_tag\"):\n34     PYTEST_TAG = imp.get_tag() + \"-PYTEST\"\n35 else:\n36     if hasattr(sys, \"pypy_version_info\"):\n37         impl = \"pypy\"\n38     elif sys.platform == \"java\":\n39         impl = \"jython\"\n40     else:\n41         impl = \"cpython\"\n42     ver = sys.version_info\n43     PYTEST_TAG = \"%s-%s%s-PYTEST\" % (impl, ver[0], ver[1])\n44     del ver, impl\n45 \n46 PYC_EXT = \".py\" + (__debug__ and \"c\" or \"o\")\n47 PYC_TAIL = \".\" + PYTEST_TAG + PYC_EXT\n48 \n49 ASCII_IS_DEFAULT_ENCODING = sys.version_info[0] < 3\n50 \n51 if sys.version_info >= (3, 5):\n52     ast_Call = ast.Call\n53 else:\n54 \n55     def ast_Call(a, b, c):\n56         return ast.Call(a, b, c, None, None)\n57 \n58 \n59 class AssertionRewritingHook(object):\n60     \"\"\"PEP302 Import hook which rewrites asserts.\"\"\"\n61 \n62     def __init__(self, config):\n63         self.config = config\n64         try:\n65             self.fnpats = config.getini(\"python_files\")\n66         except ValueError:\n67             self.fnpats = [\"test_*.py\", \"*_test.py\"]\n68         self.session = None\n69         self.modules = {}\n70         self._rewritten_names = set()\n71         self._must_rewrite = set()\n72         # flag to guard against trying to rewrite a pyc file while we are already writing another pyc file,\n73         # which might result in infinite recursion (#3506)\n74         self._writing_pyc = False\n75         self._basenames_to_check_rewrite = {\"conftest\"}\n76         self._marked_for_rewrite_cache = {}\n77         self._session_paths_checked = False\n78 \n79     def set_session(self, session):\n80         self.session = session\n81         self._session_paths_checked = False\n82 \n83     def _imp_find_module(self, name, path=None):\n84         \"\"\"Indirection so we can mock calls to find_module originated from the hook during testing\"\"\"\n85         return imp.find_module(name, path)\n86 \n87     def find_module(self, name, path=None):\n88         if self._writing_pyc:\n89             return None\n90         state = self.config._assertstate\n91         if self._early_rewrite_bailout(name, state):\n92             return None\n93         state.trace(\"find_module called for: %s\" % name)\n94         names = name.rsplit(\".\", 1)\n95         lastname = names[-1]\n96         pth = None\n97         if path is not None:\n98             # Starting with Python 3.3, path is a _NamespacePath(), which\n99             # causes problems if not converted to list.\n100             path = list(path)\n101             if len(path) == 1:\n102                 pth = path[0]\n103         if pth is None:\n104             try:\n105                 fd, fn, desc = self._imp_find_module(lastname, path)\n106             except ImportError:\n107                 return None\n108             if fd is not None:\n109                 fd.close()\n110             tp = desc[2]\n111             if tp == imp.PY_COMPILED:\n112                 if hasattr(imp, \"source_from_cache\"):\n113                     try:\n114                         fn = imp.source_from_cache(fn)\n115                     except ValueError:\n116                         # Python 3 doesn't like orphaned but still-importable\n117                         # .pyc files.\n118                         fn = fn[:-1]\n119                 else:\n120                     fn = fn[:-1]\n121             elif tp != imp.PY_SOURCE:\n122                 # Don't know what this is.\n123                 return None\n124         else:\n125             fn = os.path.join(pth, name.rpartition(\".\")[2] + \".py\")\n126 \n127         fn_pypath = py.path.local(fn)\n128         if not self._should_rewrite(name, fn_pypath, state):\n129             return None\n130 \n131         self._rewritten_names.add(name)\n132 \n133         # The requested module looks like a test file, so rewrite it. This is\n134         # the most magical part of the process: load the source, rewrite the\n135         # asserts, and load the rewritten source. We also cache the rewritten\n136         # module code in a special pyc. We must be aware of the possibility of\n137         # concurrent pytest processes rewriting and loading pycs. To avoid\n138         # tricky race conditions, we maintain the following invariant: The\n139         # cached pyc is always a complete, valid pyc. Operations on it must be\n140         # atomic. POSIX's atomic rename comes in handy.\n141         write = not sys.dont_write_bytecode\n142         cache_dir = os.path.join(fn_pypath.dirname, \"__pycache__\")\n143         if write:\n144             try:\n145                 os.mkdir(cache_dir)\n146             except OSError:\n147                 e = sys.exc_info()[1].errno\n148                 if e == errno.EEXIST:\n149                     # Either the __pycache__ directory already exists (the\n150                     # common case) or it's blocked by a non-dir node. In the\n151                     # latter case, we'll ignore it in _write_pyc.\n152                     pass\n153                 elif e in [errno.ENOENT, errno.ENOTDIR]:\n154                     # One of the path components was not a directory, likely\n155                     # because we're in a zip file.\n156                     write = False\n157                 elif e in [errno.EACCES, errno.EROFS, errno.EPERM]:\n158                     state.trace(\"read only directory: %r\" % fn_pypath.dirname)\n159                     write = False\n160                 else:\n161                     raise\n162         cache_name = fn_pypath.basename[:-3] + PYC_TAIL\n163         pyc = os.path.join(cache_dir, cache_name)\n164         # Notice that even if we're in a read-only directory, I'm going\n165         # to check for a cached pyc. This may not be optimal...\n166         co = _read_pyc(fn_pypath, pyc, state.trace)\n167         if co is None:\n168             state.trace(\"rewriting %r\" % (fn,))\n169             source_stat, co = _rewrite_test(self.config, fn_pypath)\n170             if co is None:\n171                 # Probably a SyntaxError in the test.\n172                 return None\n173             if write:\n174                 self._writing_pyc = True\n175                 try:\n176                     _write_pyc(state, co, source_stat, pyc)\n177                 finally:\n178                     self._writing_pyc = False\n179         else:\n180             state.trace(\"found cached rewritten pyc for %r\" % (fn,))\n181         self.modules[name] = co, pyc\n182         return self\n183 \n184     def _early_rewrite_bailout(self, name, state):\n185         \"\"\"\n186         This is a fast way to get out of rewriting modules. Profiling has\n187         shown that the call to imp.find_module (inside of the find_module\n188         from this class) is a major slowdown, so, this method tries to\n189         filter what we're sure won't be rewritten before getting to it.\n190         \"\"\"\n191         if self.session is not None and not self._session_paths_checked:\n192             self._session_paths_checked = True\n193             for path in self.session._initialpaths:\n194                 # Make something as c:/projects/my_project/path.py ->\n195                 #     ['c:', 'projects', 'my_project', 'path.py']\n196                 parts = str(path).split(os.path.sep)\n197                 # add 'path' to basenames to be checked.\n198                 self._basenames_to_check_rewrite.add(os.path.splitext(parts[-1])[0])\n199 \n200         # Note: conftest already by default in _basenames_to_check_rewrite.\n201         parts = name.split(\".\")\n202         if parts[-1] in self._basenames_to_check_rewrite:\n203             return False\n204 \n205         # For matching the name it must be as if it was a filename.\n206         path = PurePath(os.path.sep.join(parts) + \".py\")\n207 \n208         for pat in self.fnpats:\n209             # if the pattern contains subdirectories (\"tests/**.py\" for example) we can't bail out based\n210             # on the name alone because we need to match against the full path\n211             if os.path.dirname(pat):\n212                 return False\n213             if fnmatch_ex(pat, path):\n214                 return False\n215 \n216         if self._is_marked_for_rewrite(name, state):\n217             return False\n218 \n219         state.trace(\"early skip of rewriting module: %s\" % (name,))\n220         return True\n221 \n222     def _should_rewrite(self, name, fn_pypath, state):\n223         # always rewrite conftest files\n224         fn = str(fn_pypath)\n225         if fn_pypath.basename == \"conftest.py\":\n226             state.trace(\"rewriting conftest file: %r\" % (fn,))\n227             return True\n228 \n229         if self.session is not None:\n230             if self.session.isinitpath(fn):\n231                 state.trace(\"matched test file (was specified on cmdline): %r\" % (fn,))\n232                 return True\n233 \n234         # modules not passed explicitly on the command line are only\n235         # rewritten if they match the naming convention for test files\n236         for pat in self.fnpats:\n237             if fn_pypath.fnmatch(pat):\n238                 state.trace(\"matched test file %r\" % (fn,))\n239                 return True\n240 \n241         return self._is_marked_for_rewrite(name, state)\n242 \n243     def _is_marked_for_rewrite(self, name, state):\n244         try:\n245             return self._marked_for_rewrite_cache[name]\n246         except KeyError:\n247             for marked in self._must_rewrite:\n248                 if name == marked or name.startswith(marked + \".\"):\n249                     state.trace(\"matched marked file %r (from %r)\" % (name, marked))\n250                     self._marked_for_rewrite_cache[name] = True\n251                     return True\n252 \n253             self._marked_for_rewrite_cache[name] = False\n254             return False\n255 \n256     def mark_rewrite(self, *names):\n257         \"\"\"Mark import names as needing to be rewritten.\n258 \n259         The named module or package as well as any nested modules will\n260         be rewritten on import.\n261         \"\"\"\n262         already_imported = (\n263             set(names).intersection(sys.modules).difference(self._rewritten_names)\n264         )\n265         for name in already_imported:\n266             if not AssertionRewriter.is_rewrite_disabled(\n267                 sys.modules[name].__doc__ or \"\"\n268             ):\n269                 self._warn_already_imported(name)\n270         self._must_rewrite.update(names)\n271         self._marked_for_rewrite_cache.clear()\n272 \n273     def _warn_already_imported(self, name):\n274         from _pytest.warning_types import PytestAssertRewriteWarning\n275         from _pytest.warnings import _issue_warning_captured\n276 \n277         _issue_warning_captured(\n278             PytestAssertRewriteWarning(\n279                 \"Module already imported so cannot be rewritten: %s\" % name\n280             ),\n281             self.config.hook,\n282             stacklevel=5,\n283         )\n284 \n285     def load_module(self, name):\n286         co, pyc = self.modules.pop(name)\n287         if name in sys.modules:\n288             # If there is an existing module object named 'fullname' in\n289             # sys.modules, the loader must use that existing module. (Otherwise,\n290             # the reload() builtin will not work correctly.)\n291             mod = sys.modules[name]\n292         else:\n293             # I wish I could just call imp.load_compiled here, but __file__ has to\n294             # be set properly. In Python 3.2+, this all would be handled correctly\n295             # by load_compiled.\n296             mod = sys.modules[name] = imp.new_module(name)\n297         try:\n298             mod.__file__ = co.co_filename\n299             # Normally, this attribute is 3.2+.\n300             mod.__cached__ = pyc\n301             mod.__loader__ = self\n302             # Normally, this attribute is 3.4+\n303             mod.__spec__ = spec_from_file_location(name, co.co_filename, loader=self)\n304             exec(co, mod.__dict__)\n305         except:  # noqa\n306             if name in sys.modules:\n307                 del sys.modules[name]\n308             raise\n309         return sys.modules[name]\n310 \n311     def is_package(self, name):\n312         try:\n313             fd, fn, desc = self._imp_find_module(name)\n314         except ImportError:\n315             return False\n316         if fd is not None:\n317             fd.close()\n318         tp = desc[2]\n319         return tp == imp.PKG_DIRECTORY\n320 \n321     def get_data(self, pathname):\n322         \"\"\"Optional PEP302 get_data API.\n323         \"\"\"\n324         with open(pathname, \"rb\") as f:\n325             return f.read()\n326 \n327 \n328 def _write_pyc(state, co, source_stat, pyc):\n329     # Technically, we don't have to have the same pyc format as\n330     # (C)Python, since these \"pycs\" should never be seen by builtin\n331     # import. However, there's little reason deviate, and I hope\n332     # sometime to be able to use imp.load_compiled to load them. (See\n333     # the comment in load_module above.)\n334     try:\n335         with atomicwrites.atomic_write(pyc, mode=\"wb\", overwrite=True) as fp:\n336             fp.write(imp.get_magic())\n337             # as of now, bytecode header expects 32-bit numbers for size and mtime (#4903)\n338             mtime = int(source_stat.mtime) & 0xFFFFFFFF\n339             size = source_stat.size & 0xFFFFFFFF\n340             # \"<LL\" stands for 2 unsigned longs, little-ending\n341             fp.write(struct.pack(\"<LL\", mtime, size))\n342             fp.write(marshal.dumps(co))\n343     except EnvironmentError as e:\n344         state.trace(\"error writing pyc file at %s: errno=%s\" % (pyc, e.errno))\n345         # we ignore any failure to write the cache file\n346         # there are many reasons, permission-denied, __pycache__ being a\n347         # file etc.\n348         return False\n349     return True\n350 \n351 \n352 RN = \"\\r\\n\".encode(\"utf-8\")\n353 N = \"\\n\".encode(\"utf-8\")\n354 \n355 cookie_re = re.compile(r\"^[ \\t\\f]*#.*coding[:=][ \\t]*[-\\w.]+\")\n356 BOM_UTF8 = \"\\xef\\xbb\\xbf\"\n357 \n358 \n359 def _rewrite_test(config, fn):\n360     \"\"\"Try to read and rewrite *fn* and return the code object.\"\"\"\n361     state = config._assertstate\n362     try:\n363         stat = fn.stat()\n364         source = fn.read(\"rb\")\n365     except EnvironmentError:\n366         return None, None\n367     if ASCII_IS_DEFAULT_ENCODING:\n368         # ASCII is the default encoding in Python 2. Without a coding\n369         # declaration, Python 2 will complain about any bytes in the file\n370         # outside the ASCII range. Sadly, this behavior does not extend to\n371         # compile() or ast.parse(), which prefer to interpret the bytes as\n372         # latin-1. (At least they properly handle explicit coding cookies.) To\n373         # preserve this error behavior, we could force ast.parse() to use ASCII\n374         # as the encoding by inserting a coding cookie. Unfortunately, that\n375         # messes up line numbers. Thus, we have to check ourselves if anything\n376         # is outside the ASCII range in the case no encoding is explicitly\n377         # declared. For more context, see issue #269. Yay for Python 3 which\n378         # gets this right.\n379         end1 = source.find(\"\\n\")\n380         end2 = source.find(\"\\n\", end1 + 1)\n381         if (\n382             not source.startswith(BOM_UTF8)\n383             and cookie_re.match(source[0:end1]) is None\n384             and cookie_re.match(source[end1 + 1 : end2]) is None\n385         ):\n386             if hasattr(state, \"_indecode\"):\n387                 # encodings imported us again, so don't rewrite.\n388                 return None, None\n389             state._indecode = True\n390             try:\n391                 try:\n392                     source.decode(\"ascii\")\n393                 except UnicodeDecodeError:\n394                     # Let it fail in real import.\n395                     return None, None\n396             finally:\n397                 del state._indecode\n398     try:\n399         tree = ast.parse(source, filename=fn.strpath)\n400     except SyntaxError:\n401         # Let this pop up again in the real import.\n402         state.trace(\"failed to parse: %r\" % (fn,))\n403         return None, None\n404     rewrite_asserts(tree, fn, config)\n405     try:\n406         co = compile(tree, fn.strpath, \"exec\", dont_inherit=True)\n407     except SyntaxError:\n408         # It's possible that this error is from some bug in the\n409         # assertion rewriting, but I don't know of a fast way to tell.\n410         state.trace(\"failed to compile: %r\" % (fn,))\n411         return None, None\n412     return stat, co\n413 \n414 \n415 def _read_pyc(source, pyc, trace=lambda x: None):\n416     \"\"\"Possibly read a pytest pyc containing rewritten code.\n417 \n418     Return rewritten code if successful or None if not.\n419     \"\"\"\n420     try:\n421         fp = open(pyc, \"rb\")\n422     except IOError:\n423         return None\n424     with fp:\n425         try:\n426             mtime = int(source.mtime())\n427             size = source.size()\n428             data = fp.read(12)\n429         except EnvironmentError as e:\n430             trace(\"_read_pyc(%s): EnvironmentError %s\" % (source, e))\n431             return None\n432         # Check for invalid or out of date pyc file.\n433         if (\n434             len(data) != 12\n435             or data[:4] != imp.get_magic()\n436             or struct.unpack(\"<LL\", data[4:]) != (mtime & 0xFFFFFFFF, size & 0xFFFFFFFF)\n437         ):\n438             trace(\"_read_pyc(%s): invalid or out of date pyc\" % source)\n439             return None\n440         try:\n441             co = marshal.load(fp)\n442         except Exception as e:\n443             trace(\"_read_pyc(%s): marshal.load error %s\" % (source, e))\n444             return None\n445         if not isinstance(co, types.CodeType):\n446             trace(\"_read_pyc(%s): not a code object\" % source)\n447             return None\n448         return co\n449 \n450 \n451 def rewrite_asserts(mod, module_path=None, config=None):\n452     \"\"\"Rewrite the assert statements in mod.\"\"\"\n453     AssertionRewriter(module_path, config).run(mod)\n454 \n455 \n456 def _saferepr(obj):\n457     \"\"\"Get a safe repr of an object for assertion error messages.\n458 \n459     The assertion formatting (util.format_explanation()) requires\n460     newlines to be escaped since they are a special character for it.\n461     Normally assertion.util.format_explanation() does this but for a\n462     custom repr it is possible to contain one of the special escape\n463     sequences, especially '\\n{' and '\\n}' are likely to be present in\n464     JSON reprs.\n465 \n466     \"\"\"\n467     r = saferepr(obj)\n468     # only occurs in python2.x, repr must return text in python3+\n469     if isinstance(r, bytes):\n470         # Represent unprintable bytes as `\\x##`\n471         r = u\"\".join(\n472             u\"\\\\x{:x}\".format(ord(c)) if c not in string.printable else c.decode()\n473             for c in r\n474         )\n475     return r.replace(u\"\\n\", u\"\\\\n\")\n476 \n477 \n478 def _format_assertmsg(obj):\n479     \"\"\"Format the custom assertion message given.\n480 \n481     For strings this simply replaces newlines with '\\n~' so that\n482     util.format_explanation() will preserve them instead of escaping\n483     newlines.  For other objects saferepr() is used first.\n484 \n485     \"\"\"\n486     # reprlib appears to have a bug which means that if a string\n487     # contains a newline it gets escaped, however if an object has a\n488     # .__repr__() which contains newlines it does not get escaped.\n489     # However in either case we want to preserve the newline.\n490     replaces = [(u\"\\n\", u\"\\n~\"), (u\"%\", u\"%%\")]\n491     if not isinstance(obj, six.string_types):\n492         obj = saferepr(obj)\n493         replaces.append((u\"\\\\n\", u\"\\n~\"))\n494 \n495     if isinstance(obj, bytes):\n496         replaces = [(r1.encode(), r2.encode()) for r1, r2 in replaces]\n497 \n498     for r1, r2 in replaces:\n499         obj = obj.replace(r1, r2)\n500 \n501     return obj\n502 \n503 \n504 def _should_repr_global_name(obj):\n505     if callable(obj):\n506         return False\n507 \n508     try:\n509         return not hasattr(obj, \"__name__\")\n510     except Exception:\n511         return True\n512 \n513 \n514 def _format_boolop(explanations, is_or):\n515     explanation = \"(\" + (is_or and \" or \" or \" and \").join(explanations) + \")\"\n516     if isinstance(explanation, six.text_type):\n517         return explanation.replace(u\"%\", u\"%%\")\n518     else:\n519         return explanation.replace(b\"%\", b\"%%\")\n520 \n521 \n522 def _call_reprcompare(ops, results, expls, each_obj):\n523     for i, res, expl in zip(range(len(ops)), results, expls):\n524         try:\n525             done = not res\n526         except Exception:\n527             done = True\n528         if done:\n529             break\n530     if util._reprcompare is not None:\n531         custom = util._reprcompare(ops[i], each_obj[i], each_obj[i + 1])\n532         if custom is not None:\n533             return custom\n534     return expl\n535 \n536 \n537 unary_map = {ast.Not: \"not %s\", ast.Invert: \"~%s\", ast.USub: \"-%s\", ast.UAdd: \"+%s\"}\n538 \n539 binop_map = {\n540     ast.BitOr: \"|\",\n541     ast.BitXor: \"^\",\n542     ast.BitAnd: \"&\",\n543     ast.LShift: \"<<\",\n544     ast.RShift: \">>\",\n545     ast.Add: \"+\",\n546     ast.Sub: \"-\",\n547     ast.Mult: \"*\",\n548     ast.Div: \"/\",\n549     ast.FloorDiv: \"//\",\n550     ast.Mod: \"%%\",  # escaped for string formatting\n551     ast.Eq: \"==\",\n552     ast.NotEq: \"!=\",\n553     ast.Lt: \"<\",\n554     ast.LtE: \"<=\",\n555     ast.Gt: \">\",\n556     ast.GtE: \">=\",\n557     ast.Pow: \"**\",\n558     ast.Is: \"is\",\n559     ast.IsNot: \"is not\",\n560     ast.In: \"in\",\n561     ast.NotIn: \"not in\",\n562 }\n563 # Python 3.5+ compatibility\n564 try:\n565     binop_map[ast.MatMult] = \"@\"\n566 except AttributeError:\n567     pass\n568 \n569 # Python 3.4+ compatibility\n570 if hasattr(ast, \"NameConstant\"):\n571     _NameConstant = ast.NameConstant\n572 else:\n573 \n574     def _NameConstant(c):\n575         return ast.Name(str(c), ast.Load())\n576 \n577 \n578 def set_location(node, lineno, col_offset):\n579     \"\"\"Set node location information recursively.\"\"\"\n580 \n581     def _fix(node, lineno, col_offset):\n582         if \"lineno\" in node._attributes:\n583             node.lineno = lineno\n584         if \"col_offset\" in node._attributes:\n585             node.col_offset = col_offset\n586         for child in ast.iter_child_nodes(node):\n587             _fix(child, lineno, col_offset)\n588 \n589     _fix(node, lineno, col_offset)\n590     return node\n591 \n592 \n593 class AssertionRewriter(ast.NodeVisitor):\n594     \"\"\"Assertion rewriting implementation.\n595 \n596     The main entrypoint is to call .run() with an ast.Module instance,\n597     this will then find all the assert statements and rewrite them to\n598     provide intermediate values and a detailed assertion error.  See\n599     http://pybites.blogspot.be/2011/07/behind-scenes-of-pytests-new-assertion.html\n600     for an overview of how this works.\n601 \n602     The entry point here is .run() which will iterate over all the\n603     statements in an ast.Module and for each ast.Assert statement it\n604     finds call .visit() with it.  Then .visit_Assert() takes over and\n605     is responsible for creating new ast statements to replace the\n606     original assert statement: it rewrites the test of an assertion\n607     to provide intermediate values and replace it with an if statement\n608     which raises an assertion error with a detailed explanation in\n609     case the expression is false.\n610 \n611     For this .visit_Assert() uses the visitor pattern to visit all the\n612     AST nodes of the ast.Assert.test field, each visit call returning\n613     an AST node and the corresponding explanation string.  During this\n614     state is kept in several instance attributes:\n615 \n616     :statements: All the AST statements which will replace the assert\n617        statement.\n618 \n619     :variables: This is populated by .variable() with each variable\n620        used by the statements so that they can all be set to None at\n621        the end of the statements.\n622 \n623     :variable_counter: Counter to create new unique variables needed\n624        by statements.  Variables are created using .variable() and\n625        have the form of \"@py_assert0\".\n626 \n627     :on_failure: The AST statements which will be executed if the\n628        assertion test fails.  This is the code which will construct\n629        the failure message and raises the AssertionError.\n630 \n631     :explanation_specifiers: A dict filled by .explanation_param()\n632        with %-formatting placeholders and their corresponding\n633        expressions to use in the building of an assertion message.\n634        This is used by .pop_format_context() to build a message.\n635 \n636     :stack: A stack of the explanation_specifiers dicts maintained by\n637        .push_format_context() and .pop_format_context() which allows\n638        to build another %-formatted string while already building one.\n639 \n640     This state is reset on every new assert statement visited and used\n641     by the other visitors.\n642 \n643     \"\"\"\n644 \n645     def __init__(self, module_path, config):\n646         super(AssertionRewriter, self).__init__()\n647         self.module_path = module_path\n648         self.config = config\n649 \n650     def run(self, mod):\n651         \"\"\"Find all assert statements in *mod* and rewrite them.\"\"\"\n652         if not mod.body:\n653             # Nothing to do.\n654             return\n655         # Insert some special imports at the top of the module but after any\n656         # docstrings and __future__ imports.\n657         aliases = [\n658             ast.alias(six.moves.builtins.__name__, \"@py_builtins\"),\n659             ast.alias(\"_pytest.assertion.rewrite\", \"@pytest_ar\"),\n660         ]\n661         doc = getattr(mod, \"docstring\", None)\n662         expect_docstring = doc is None\n663         if doc is not None and self.is_rewrite_disabled(doc):\n664             return\n665         pos = 0\n666         lineno = 1\n667         for item in mod.body:\n668             if (\n669                 expect_docstring\n670                 and isinstance(item, ast.Expr)\n671                 and isinstance(item.value, ast.Str)\n672             ):\n673                 doc = item.value.s\n674                 if self.is_rewrite_disabled(doc):\n675                     return\n676                 expect_docstring = False\n677             elif (\n678                 not isinstance(item, ast.ImportFrom)\n679                 or item.level > 0\n680                 or item.module != \"__future__\"\n681             ):\n682                 lineno = item.lineno\n683                 break\n684             pos += 1\n685         else:\n686             lineno = item.lineno\n687         imports = [\n688             ast.Import([alias], lineno=lineno, col_offset=0) for alias in aliases\n689         ]\n690         mod.body[pos:pos] = imports\n691         # Collect asserts.\n692         nodes = [mod]\n693         while nodes:\n694             node = nodes.pop()\n695             for name, field in ast.iter_fields(node):\n696                 if isinstance(field, list):\n697                     new = []\n698                     for i, child in enumerate(field):\n699                         if isinstance(child, ast.Assert):\n700                             # Transform assert.\n701                             new.extend(self.visit(child))\n702                         else:\n703                             new.append(child)\n704                             if isinstance(child, ast.AST):\n705                                 nodes.append(child)\n706                     setattr(node, name, new)\n707                 elif (\n708                     isinstance(field, ast.AST)\n709                     # Don't recurse into expressions as they can't contain\n710                     # asserts.\n711                     and not isinstance(field, ast.expr)\n712                 ):\n713                     nodes.append(field)\n714 \n715     @staticmethod\n716     def is_rewrite_disabled(docstring):\n717         return \"PYTEST_DONT_REWRITE\" in docstring\n718 \n719     def variable(self):\n720         \"\"\"Get a new variable.\"\"\"\n721         # Use a character invalid in python identifiers to avoid clashing.\n722         name = \"@py_assert\" + str(next(self.variable_counter))\n723         self.variables.append(name)\n724         return name\n725 \n726     def assign(self, expr):\n727         \"\"\"Give *expr* a name.\"\"\"\n728         name = self.variable()\n729         self.statements.append(ast.Assign([ast.Name(name, ast.Store())], expr))\n730         return ast.Name(name, ast.Load())\n731 \n732     def display(self, expr):\n733         \"\"\"Call saferepr on the expression.\"\"\"\n734         return self.helper(\"_saferepr\", expr)\n735 \n736     def helper(self, name, *args):\n737         \"\"\"Call a helper in this module.\"\"\"\n738         py_name = ast.Name(\"@pytest_ar\", ast.Load())\n739         attr = ast.Attribute(py_name, name, ast.Load())\n740         return ast_Call(attr, list(args), [])\n741 \n742     def builtin(self, name):\n743         \"\"\"Return the builtin called *name*.\"\"\"\n744         builtin_name = ast.Name(\"@py_builtins\", ast.Load())\n745         return ast.Attribute(builtin_name, name, ast.Load())\n746 \n747     def explanation_param(self, expr):\n748         \"\"\"Return a new named %-formatting placeholder for expr.\n749 \n750         This creates a %-formatting placeholder for expr in the\n751         current formatting context, e.g. ``%(py0)s``.  The placeholder\n752         and expr are placed in the current format context so that it\n753         can be used on the next call to .pop_format_context().\n754 \n755         \"\"\"\n756         specifier = \"py\" + str(next(self.variable_counter))\n757         self.explanation_specifiers[specifier] = expr\n758         return \"%(\" + specifier + \")s\"\n759 \n760     def push_format_context(self):\n761         \"\"\"Create a new formatting context.\n762 \n763         The format context is used for when an explanation wants to\n764         have a variable value formatted in the assertion message.  In\n765         this case the value required can be added using\n766         .explanation_param().  Finally .pop_format_context() is used\n767         to format a string of %-formatted values as added by\n768         .explanation_param().\n769 \n770         \"\"\"\n771         self.explanation_specifiers = {}\n772         self.stack.append(self.explanation_specifiers)\n773 \n774     def pop_format_context(self, expl_expr):\n775         \"\"\"Format the %-formatted string with current format context.\n776 \n777         The expl_expr should be an ast.Str instance constructed from\n778         the %-placeholders created by .explanation_param().  This will\n779         add the required code to format said string to .on_failure and\n780         return the ast.Name instance of the formatted string.\n781 \n782         \"\"\"\n783         current = self.stack.pop()\n784         if self.stack:\n785             self.explanation_specifiers = self.stack[-1]\n786         keys = [ast.Str(key) for key in current.keys()]\n787         format_dict = ast.Dict(keys, list(current.values()))\n788         form = ast.BinOp(expl_expr, ast.Mod(), format_dict)\n789         name = \"@py_format\" + str(next(self.variable_counter))\n790         self.on_failure.append(ast.Assign([ast.Name(name, ast.Store())], form))\n791         return ast.Name(name, ast.Load())\n792 \n793     def generic_visit(self, node):\n794         \"\"\"Handle expressions we don't have custom code for.\"\"\"\n795         assert isinstance(node, ast.expr)\n796         res = self.assign(node)\n797         return res, self.explanation_param(self.display(res))\n798 \n799     def visit_Assert(self, assert_):\n800         \"\"\"Return the AST statements to replace the ast.Assert instance.\n801 \n802         This rewrites the test of an assertion to provide\n803         intermediate values and replace it with an if statement which\n804         raises an assertion error with a detailed explanation in case\n805         the expression is false.\n806 \n807         \"\"\"\n808         if isinstance(assert_.test, ast.Tuple) and len(assert_.test.elts) >= 1:\n809             from _pytest.warning_types import PytestAssertRewriteWarning\n810             import warnings\n811 \n812             warnings.warn_explicit(\n813                 PytestAssertRewriteWarning(\n814                     \"assertion is always true, perhaps remove parentheses?\"\n815                 ),\n816                 category=None,\n817                 filename=str(self.module_path),\n818                 lineno=assert_.lineno,\n819             )\n820 \n821         self.statements = []\n822         self.variables = []\n823         self.variable_counter = itertools.count()\n824         self.stack = []\n825         self.on_failure = []\n826         self.push_format_context()\n827         # Rewrite assert into a bunch of statements.\n828         top_condition, explanation = self.visit(assert_.test)\n829         # If in a test module, check if directly asserting None, in order to warn [Issue #3191]\n830         if self.module_path is not None:\n831             self.statements.append(\n832                 self.warn_about_none_ast(\n833                     top_condition, module_path=self.module_path, lineno=assert_.lineno\n834                 )\n835             )\n836         # Create failure message.\n837         body = self.on_failure\n838         negation = ast.UnaryOp(ast.Not(), top_condition)\n839         self.statements.append(ast.If(negation, body, []))\n840         if assert_.msg:\n841             assertmsg = self.helper(\"_format_assertmsg\", assert_.msg)\n842             explanation = \"\\n>assert \" + explanation\n843         else:\n844             assertmsg = ast.Str(\"\")\n845             explanation = \"assert \" + explanation\n846         template = ast.BinOp(assertmsg, ast.Add(), ast.Str(explanation))\n847         msg = self.pop_format_context(template)\n848         fmt = self.helper(\"_format_explanation\", msg)\n849         err_name = ast.Name(\"AssertionError\", ast.Load())\n850         exc = ast_Call(err_name, [fmt], [])\n851         if sys.version_info[0] >= 3:\n852             raise_ = ast.Raise(exc, None)\n853         else:\n854             raise_ = ast.Raise(exc, None, None)\n855         body.append(raise_)\n856         # Clear temporary variables by setting them to None.\n857         if self.variables:\n858             variables = [ast.Name(name, ast.Store()) for name in self.variables]\n859             clear = ast.Assign(variables, _NameConstant(None))\n860             self.statements.append(clear)\n861         # Fix line numbers.\n862         for stmt in self.statements:\n863             set_location(stmt, assert_.lineno, assert_.col_offset)\n864         return self.statements\n865 \n866     def warn_about_none_ast(self, node, module_path, lineno):\n867         \"\"\"\n868         Returns an AST issuing a warning if the value of node is `None`.\n869         This is used to warn the user when asserting a function that asserts\n870         internally already.\n871         See issue #3191 for more details.\n872         \"\"\"\n873 \n874         # Using parse because it is different between py2 and py3.\n875         AST_NONE = ast.parse(\"None\").body[0].value\n876         val_is_none = ast.Compare(node, [ast.Is()], [AST_NONE])\n877         send_warning = ast.parse(\n878             \"\"\"\n879 from _pytest.warning_types import PytestAssertRewriteWarning\n880 from warnings import warn_explicit\n881 warn_explicit(\n882     PytestAssertRewriteWarning('asserting the value None, please use \"assert is None\"'),\n883     category=None,\n884     filename={filename!r},\n885     lineno={lineno},\n886 )\n887             \"\"\".format(\n888                 filename=module_path.strpath, lineno=lineno\n889             )\n890         ).body\n891         return ast.If(val_is_none, send_warning, [])\n892 \n893     def visit_Name(self, name):\n894         # Display the repr of the name if it's a local variable or\n895         # _should_repr_global_name() thinks it's acceptable.\n896         locs = ast_Call(self.builtin(\"locals\"), [], [])\n897         inlocs = ast.Compare(ast.Str(name.id), [ast.In()], [locs])\n898         dorepr = self.helper(\"_should_repr_global_name\", name)\n899         test = ast.BoolOp(ast.Or(), [inlocs, dorepr])\n900         expr = ast.IfExp(test, self.display(name), ast.Str(name.id))\n901         return name, self.explanation_param(expr)\n902 \n903     def visit_BoolOp(self, boolop):\n904         res_var = self.variable()\n905         expl_list = self.assign(ast.List([], ast.Load()))\n906         app = ast.Attribute(expl_list, \"append\", ast.Load())\n907         is_or = int(isinstance(boolop.op, ast.Or))\n908         body = save = self.statements\n909         fail_save = self.on_failure\n910         levels = len(boolop.values) - 1\n911         self.push_format_context()\n912         # Process each operand, short-circuting if needed.\n913         for i, v in enumerate(boolop.values):\n914             if i:\n915                 fail_inner = []\n916                 # cond is set in a prior loop iteration below\n917                 self.on_failure.append(ast.If(cond, fail_inner, []))  # noqa\n918                 self.on_failure = fail_inner\n919             self.push_format_context()\n920             res, expl = self.visit(v)\n921             body.append(ast.Assign([ast.Name(res_var, ast.Store())], res))\n922             expl_format = self.pop_format_context(ast.Str(expl))\n923             call = ast_Call(app, [expl_format], [])\n924             self.on_failure.append(ast.Expr(call))\n925             if i < levels:\n926                 cond = res\n927                 if is_or:\n928                     cond = ast.UnaryOp(ast.Not(), cond)\n929                 inner = []\n930                 self.statements.append(ast.If(cond, inner, []))\n931                 self.statements = body = inner\n932         self.statements = save\n933         self.on_failure = fail_save\n934         expl_template = self.helper(\"_format_boolop\", expl_list, ast.Num(is_or))\n935         expl = self.pop_format_context(expl_template)\n936         return ast.Name(res_var, ast.Load()), self.explanation_param(expl)\n937 \n938     def visit_UnaryOp(self, unary):\n939         pattern = unary_map[unary.op.__class__]\n940         operand_res, operand_expl = self.visit(unary.operand)\n941         res = self.assign(ast.UnaryOp(unary.op, operand_res))\n942         return res, pattern % (operand_expl,)\n943 \n944     def visit_BinOp(self, binop):\n945         symbol = binop_map[binop.op.__class__]\n946         left_expr, left_expl = self.visit(binop.left)\n947         right_expr, right_expl = self.visit(binop.right)\n948         explanation = \"(%s %s %s)\" % (left_expl, symbol, right_expl)\n949         res = self.assign(ast.BinOp(left_expr, binop.op, right_expr))\n950         return res, explanation\n951 \n952     def visit_Call_35(self, call):\n953         \"\"\"\n954         visit `ast.Call` nodes on Python3.5 and after\n955         \"\"\"\n956         new_func, func_expl = self.visit(call.func)\n957         arg_expls = []\n958         new_args = []\n959         new_kwargs = []\n960         for arg in call.args:\n961             res, expl = self.visit(arg)\n962             arg_expls.append(expl)\n963             new_args.append(res)\n964         for keyword in call.keywords:\n965             res, expl = self.visit(keyword.value)\n966             new_kwargs.append(ast.keyword(keyword.arg, res))\n967             if keyword.arg:\n968                 arg_expls.append(keyword.arg + \"=\" + expl)\n969             else:  # **args have `arg` keywords with an .arg of None\n970                 arg_expls.append(\"**\" + expl)\n971 \n972         expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n973         new_call = ast.Call(new_func, new_args, new_kwargs)\n974         res = self.assign(new_call)\n975         res_expl = self.explanation_param(self.display(res))\n976         outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n977         return res, outer_expl\n978 \n979     def visit_Starred(self, starred):\n980         # From Python 3.5, a Starred node can appear in a function call\n981         res, expl = self.visit(starred.value)\n982         new_starred = ast.Starred(res, starred.ctx)\n983         return new_starred, \"*\" + expl\n984 \n985     def visit_Call_legacy(self, call):\n986         \"\"\"\n987         visit `ast.Call nodes on 3.4 and below`\n988         \"\"\"\n989         new_func, func_expl = self.visit(call.func)\n990         arg_expls = []\n991         new_args = []\n992         new_kwargs = []\n993         new_star = new_kwarg = None\n994         for arg in call.args:\n995             res, expl = self.visit(arg)\n996             new_args.append(res)\n997             arg_expls.append(expl)\n998         for keyword in call.keywords:\n999             res, expl = self.visit(keyword.value)\n1000             new_kwargs.append(ast.keyword(keyword.arg, res))\n1001             arg_expls.append(keyword.arg + \"=\" + expl)\n1002         if call.starargs:\n1003             new_star, expl = self.visit(call.starargs)\n1004             arg_expls.append(\"*\" + expl)\n1005         if call.kwargs:\n1006             new_kwarg, expl = self.visit(call.kwargs)\n1007             arg_expls.append(\"**\" + expl)\n1008         expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n1009         new_call = ast.Call(new_func, new_args, new_kwargs, new_star, new_kwarg)\n1010         res = self.assign(new_call)\n1011         res_expl = self.explanation_param(self.display(res))\n1012         outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n1013         return res, outer_expl\n1014 \n1015     # ast.Call signature changed on 3.5,\n1016     # conditionally change  which methods is named\n1017     # visit_Call depending on Python version\n1018     if sys.version_info >= (3, 5):\n1019         visit_Call = visit_Call_35\n1020     else:\n1021         visit_Call = visit_Call_legacy\n1022 \n1023     def visit_Attribute(self, attr):\n1024         if not isinstance(attr.ctx, ast.Load):\n1025             return self.generic_visit(attr)\n1026         value, value_expl = self.visit(attr.value)\n1027         res = self.assign(ast.Attribute(value, attr.attr, ast.Load()))\n1028         res_expl = self.explanation_param(self.display(res))\n1029         pat = \"%s\\n{%s = %s.%s\\n}\"\n1030         expl = pat % (res_expl, res_expl, value_expl, attr.attr)\n1031         return res, expl\n1032 \n1033     def visit_Compare(self, comp):\n1034         self.push_format_context()\n1035         left_res, left_expl = self.visit(comp.left)\n1036         if isinstance(comp.left, (ast.Compare, ast.BoolOp)):\n1037             left_expl = \"({})\".format(left_expl)\n1038         res_variables = [self.variable() for i in range(len(comp.ops))]\n1039         load_names = [ast.Name(v, ast.Load()) for v in res_variables]\n1040         store_names = [ast.Name(v, ast.Store()) for v in res_variables]\n1041         it = zip(range(len(comp.ops)), comp.ops, comp.comparators)\n1042         expls = []\n1043         syms = []\n1044         results = [left_res]\n1045         for i, op, next_operand in it:\n1046             next_res, next_expl = self.visit(next_operand)\n1047             if isinstance(next_operand, (ast.Compare, ast.BoolOp)):\n1048                 next_expl = \"({})\".format(next_expl)\n1049             results.append(next_res)\n1050             sym = binop_map[op.__class__]\n1051             syms.append(ast.Str(sym))\n1052             expl = \"%s %s %s\" % (left_expl, sym, next_expl)\n1053             expls.append(ast.Str(expl))\n1054             res_expr = ast.Compare(left_res, [op], [next_res])\n1055             self.statements.append(ast.Assign([store_names[i]], res_expr))\n1056             left_res, left_expl = next_res, next_expl\n1057         # Use pytest.assertion.util._reprcompare if that's available.\n1058         expl_call = self.helper(\n1059             \"_call_reprcompare\",\n1060             ast.Tuple(syms, ast.Load()),\n1061             ast.Tuple(load_names, ast.Load()),\n1062             ast.Tuple(expls, ast.Load()),\n1063             ast.Tuple(results, ast.Load()),\n1064         )\n1065         if len(comp.ops) > 1:\n1066             res = ast.BoolOp(ast.And(), load_names)\n1067         else:\n1068             res = load_names[0]\n1069         return res, self.explanation_param(self.pop_format_context(expl_call))\n",
        "intended_behavior": "Ensure that methods dealing with assertion errors properly handle Unicode characters, possibly by making sure encoding conversions are handled correctly under Python 2. This may involve explicitly encoding Unicode strings to UTF-8 (or another appropriate encoding) before they are processed or outputted."
    },
    {
        "rel_file_path": "src/_pytest/compat.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/pytest-dev__pytest/setup_pytest-dev__pytest__4.6/src/_pytest/compat.py",
        "start": 1,
        "end": 457,
        "class_name": null,
        "method_name": null,
        "code": "1 # -*- coding: utf-8 -*-\n2 \"\"\"\n3 python version compatibility code\n4 \"\"\"\n5 from __future__ import absolute_import\n6 from __future__ import division\n7 from __future__ import print_function\n8 \n9 import codecs\n10 import functools\n11 import inspect\n12 import re\n13 import sys\n14 from contextlib import contextmanager\n15 \n16 import py\n17 import six\n18 from six import text_type\n19 \n20 import _pytest\n21 from _pytest._io.saferepr import saferepr\n22 from _pytest.outcomes import fail\n23 from _pytest.outcomes import TEST_OUTCOME\n24 \n25 try:\n26     import enum\n27 except ImportError:  # pragma: no cover\n28     # Only available in Python 3.4+ or as a backport\n29     enum = None\n30 \n31 _PY3 = sys.version_info > (3, 0)\n32 _PY2 = not _PY3\n33 \n34 \n35 if _PY3:\n36     from inspect import signature, Parameter as Parameter\n37 else:\n38     from funcsigs import signature, Parameter as Parameter\n39 \n40 NOTSET = object()\n41 \n42 PY35 = sys.version_info[:2] >= (3, 5)\n43 PY36 = sys.version_info[:2] >= (3, 6)\n44 MODULE_NOT_FOUND_ERROR = \"ModuleNotFoundError\" if PY36 else \"ImportError\"\n45 \n46 \n47 if _PY3:\n48     from collections.abc import MutableMapping as MappingMixin\n49     from collections.abc import Iterable, Mapping, Sequence, Sized\n50 else:\n51     # those raise DeprecationWarnings in Python >=3.7\n52     from collections import MutableMapping as MappingMixin  # noqa\n53     from collections import Iterable, Mapping, Sequence, Sized  # noqa\n54 \n55 \n56 if sys.version_info >= (3, 4):\n57     from importlib.util import spec_from_file_location\n58 else:\n59 \n60     def spec_from_file_location(*_, **__):\n61         return None\n62 \n63 \n64 def _format_args(func):\n65     return str(signature(func))\n66 \n67 \n68 isfunction = inspect.isfunction\n69 isclass = inspect.isclass\n70 # used to work around a python2 exception info leak\n71 exc_clear = getattr(sys, \"exc_clear\", lambda: None)\n72 # The type of re.compile objects is not exposed in Python.\n73 REGEX_TYPE = type(re.compile(\"\"))\n74 \n75 \n76 def is_generator(func):\n77     genfunc = inspect.isgeneratorfunction(func)\n78     return genfunc and not iscoroutinefunction(func)\n79 \n80 \n81 def iscoroutinefunction(func):\n82     \"\"\"Return True if func is a decorated coroutine function.\n83 \n84     Note: copied and modified from Python 3.5's builtin couroutines.py to avoid import asyncio directly,\n85     which in turns also initializes the \"logging\" module as side-effect (see issue #8).\n86     \"\"\"\n87     return getattr(func, \"_is_coroutine\", False) or (\n88         hasattr(inspect, \"iscoroutinefunction\") and inspect.iscoroutinefunction(func)\n89     )\n90 \n91 \n92 def getlocation(function, curdir):\n93     function = get_real_func(function)\n94     fn = py.path.local(inspect.getfile(function))\n95     lineno = function.__code__.co_firstlineno\n96     if fn.relto(curdir):\n97         fn = fn.relto(curdir)\n98     return \"%s:%d\" % (fn, lineno + 1)\n99 \n100 \n101 def num_mock_patch_args(function):\n102     \"\"\" return number of arguments used up by mock arguments (if any) \"\"\"\n103     patchings = getattr(function, \"patchings\", None)\n104     if not patchings:\n105         return 0\n106     mock_modules = [sys.modules.get(\"mock\"), sys.modules.get(\"unittest.mock\")]\n107     if any(mock_modules):\n108         sentinels = [m.DEFAULT for m in mock_modules if m is not None]\n109         return len(\n110             [p for p in patchings if not p.attribute_name and p.new in sentinels]\n111         )\n112     return len(patchings)\n113 \n114 \n115 def getfuncargnames(function, is_method=False, cls=None):\n116     \"\"\"Returns the names of a function's mandatory arguments.\n117 \n118     This should return the names of all function arguments that:\n119         * Aren't bound to an instance or type as in instance or class methods.\n120         * Don't have default values.\n121         * Aren't bound with functools.partial.\n122         * Aren't replaced with mocks.\n123 \n124     The is_method and cls arguments indicate that the function should\n125     be treated as a bound method even though it's not unless, only in\n126     the case of cls, the function is a static method.\n127 \n128     @RonnyPfannschmidt: This function should be refactored when we\n129     revisit fixtures. The fixture mechanism should ask the node for\n130     the fixture names, and not try to obtain directly from the\n131     function object well after collection has occurred.\n132 \n133     \"\"\"\n134     # The parameters attribute of a Signature object contains an\n135     # ordered mapping of parameter names to Parameter instances.  This\n136     # creates a tuple of the names of the parameters that don't have\n137     # defaults.\n138     try:\n139         parameters = signature(function).parameters\n140     except (ValueError, TypeError) as e:\n141         fail(\n142             \"Could not determine arguments of {!r}: {}\".format(function, e),\n143             pytrace=False,\n144         )\n145 \n146     arg_names = tuple(\n147         p.name\n148         for p in parameters.values()\n149         if (\n150             p.kind is Parameter.POSITIONAL_OR_KEYWORD\n151             or p.kind is Parameter.KEYWORD_ONLY\n152         )\n153         and p.default is Parameter.empty\n154     )\n155     # If this function should be treated as a bound method even though\n156     # it's passed as an unbound method or function, remove the first\n157     # parameter name.\n158     if is_method or (\n159         cls and not isinstance(cls.__dict__.get(function.__name__, None), staticmethod)\n160     ):\n161         arg_names = arg_names[1:]\n162     # Remove any names that will be replaced with mocks.\n163     if hasattr(function, \"__wrapped__\"):\n164         arg_names = arg_names[num_mock_patch_args(function) :]\n165     return arg_names\n166 \n167 \n168 @contextmanager\n169 def dummy_context_manager():\n170     \"\"\"Context manager that does nothing, useful in situations where you might need an actual context manager or not\n171     depending on some condition. Using this allow to keep the same code\"\"\"\n172     yield\n173 \n174 \n175 def get_default_arg_names(function):\n176     # Note: this code intentionally mirrors the code at the beginning of getfuncargnames,\n177     # to get the arguments which were excluded from its result because they had default values\n178     return tuple(\n179         p.name\n180         for p in signature(function).parameters.values()\n181         if p.kind in (Parameter.POSITIONAL_OR_KEYWORD, Parameter.KEYWORD_ONLY)\n182         and p.default is not Parameter.empty\n183     )\n184 \n185 \n186 _non_printable_ascii_translate_table = {\n187     i: u\"\\\\x{:02x}\".format(i) for i in range(128) if i not in range(32, 127)\n188 }\n189 _non_printable_ascii_translate_table.update(\n190     {ord(\"\\t\"): u\"\\\\t\", ord(\"\\r\"): u\"\\\\r\", ord(\"\\n\"): u\"\\\\n\"}\n191 )\n192 \n193 \n194 def _translate_non_printable(s):\n195     return s.translate(_non_printable_ascii_translate_table)\n196 \n197 \n198 if _PY3:\n199     STRING_TYPES = bytes, str\n200     UNICODE_TYPES = six.text_type\n201 \n202     if PY35:\n203 \n204         def _bytes_to_ascii(val):\n205             return val.decode(\"ascii\", \"backslashreplace\")\n206 \n207     else:\n208 \n209         def _bytes_to_ascii(val):\n210             if val:\n211                 # source: http://goo.gl/bGsnwC\n212                 encoded_bytes, _ = codecs.escape_encode(val)\n213                 return encoded_bytes.decode(\"ascii\")\n214             else:\n215                 # empty bytes crashes codecs.escape_encode (#1087)\n216                 return \"\"\n217 \n218     def ascii_escaped(val):\n219         \"\"\"If val is pure ascii, returns it as a str().  Otherwise, escapes\n220         bytes objects into a sequence of escaped bytes:\n221 \n222         b'\\xc3\\xb4\\xc5\\xd6' -> u'\\\\xc3\\\\xb4\\\\xc5\\\\xd6'\n223 \n224         and escapes unicode objects into a sequence of escaped unicode\n225         ids, e.g.:\n226 \n227         '4\\\\nV\\\\U00043efa\\\\x0eMXWB\\\\x1e\\\\u3028\\\\u15fd\\\\xcd\\\\U0007d944'\n228 \n229         note:\n230            the obvious \"v.decode('unicode-escape')\" will return\n231            valid utf-8 unicode if it finds them in bytes, but we\n232            want to return escaped bytes for any byte, even if they match\n233            a utf-8 string.\n234 \n235         \"\"\"\n236         if isinstance(val, bytes):\n237             ret = _bytes_to_ascii(val)\n238         else:\n239             ret = val.encode(\"unicode_escape\").decode(\"ascii\")\n240         return _translate_non_printable(ret)\n241 \n242 \n243 else:\n244     STRING_TYPES = six.string_types\n245     UNICODE_TYPES = six.text_type\n246 \n247     def ascii_escaped(val):\n248         \"\"\"In py2 bytes and str are the same type, so return if it's a bytes\n249         object, return it unchanged if it is a full ascii string,\n250         otherwise escape it into its binary form.\n251 \n252         If it's a unicode string, change the unicode characters into\n253         unicode escapes.\n254 \n255         \"\"\"\n256         if isinstance(val, bytes):\n257             try:\n258                 ret = val.decode(\"ascii\")\n259             except UnicodeDecodeError:\n260                 ret = val.encode(\"string-escape\").decode(\"ascii\")\n261         else:\n262             ret = val.encode(\"unicode-escape\").decode(\"ascii\")\n263         return _translate_non_printable(ret)\n264 \n265 \n266 class _PytestWrapper(object):\n267     \"\"\"Dummy wrapper around a function object for internal use only.\n268 \n269     Used to correctly unwrap the underlying function object\n270     when we are creating fixtures, because we wrap the function object ourselves with a decorator\n271     to issue warnings when the fixture function is called directly.\n272     \"\"\"\n273 \n274     def __init__(self, obj):\n275         self.obj = obj\n276 \n277 \n278 def get_real_func(obj):\n279     \"\"\" gets the real function object of the (possibly) wrapped object by\n280     functools.wraps or functools.partial.\n281     \"\"\"\n282     start_obj = obj\n283     for i in range(100):\n284         # __pytest_wrapped__ is set by @pytest.fixture when wrapping the fixture function\n285         # to trigger a warning if it gets called directly instead of by pytest: we don't\n286         # want to unwrap further than this otherwise we lose useful wrappings like @mock.patch (#3774)\n287         new_obj = getattr(obj, \"__pytest_wrapped__\", None)\n288         if isinstance(new_obj, _PytestWrapper):\n289             obj = new_obj.obj\n290             break\n291         new_obj = getattr(obj, \"__wrapped__\", None)\n292         if new_obj is None:\n293             break\n294         obj = new_obj\n295     else:\n296         raise ValueError(\n297             (\"could not find real function of {start}\\nstopped at {current}\").format(\n298                 start=saferepr(start_obj), current=saferepr(obj)\n299             )\n300         )\n301     if isinstance(obj, functools.partial):\n302         obj = obj.func\n303     return obj\n304 \n305 \n306 def get_real_method(obj, holder):\n307     \"\"\"\n308     Attempts to obtain the real function object that might be wrapping ``obj``, while at the same time\n309     returning a bound method to ``holder`` if the original object was a bound method.\n310     \"\"\"\n311     try:\n312         is_method = hasattr(obj, \"__func__\")\n313         obj = get_real_func(obj)\n314     except Exception:\n315         return obj\n316     if is_method and hasattr(obj, \"__get__\") and callable(obj.__get__):\n317         obj = obj.__get__(holder)\n318     return obj\n319 \n320 \n321 def getfslineno(obj):\n322     # xxx let decorators etc specify a sane ordering\n323     obj = get_real_func(obj)\n324     if hasattr(obj, \"place_as\"):\n325         obj = obj.place_as\n326     fslineno = _pytest._code.getfslineno(obj)\n327     assert isinstance(fslineno[1], int), obj\n328     return fslineno\n329 \n330 \n331 def getimfunc(func):\n332     try:\n333         return func.__func__\n334     except AttributeError:\n335         return func\n336 \n337 \n338 def safe_getattr(object, name, default):\n339     \"\"\" Like getattr but return default upon any Exception or any OutcomeException.\n340 \n341     Attribute access can potentially fail for 'evil' Python objects.\n342     See issue #214.\n343     It catches OutcomeException because of #2490 (issue #580), new outcomes are derived from BaseException\n344     instead of Exception (for more details check #2707)\n345     \"\"\"\n346     try:\n347         return getattr(object, name, default)\n348     except TEST_OUTCOME:\n349         return default\n350 \n351 \n352 def safe_isclass(obj):\n353     \"\"\"Ignore any exception via isinstance on Python 3.\"\"\"\n354     try:\n355         return isclass(obj)\n356     except Exception:\n357         return False\n358 \n359 \n360 def _is_unittest_unexpected_success_a_failure():\n361     \"\"\"Return if the test suite should fail if an @expectedFailure unittest test PASSES.\n362 \n363     From https://docs.python.org/3/library/unittest.html?highlight=unittest#unittest.TestResult.wasSuccessful:\n364         Changed in version 3.4: Returns False if there were any\n365         unexpectedSuccesses from tests marked with the expectedFailure() decorator.\n366     \"\"\"\n367     return sys.version_info >= (3, 4)\n368 \n369 \n370 if _PY3:\n371 \n372     def safe_str(v):\n373         \"\"\"returns v as string\"\"\"\n374         return str(v)\n375 \n376 \n377 else:\n378 \n379     def safe_str(v):\n380         \"\"\"returns v as string, converting to utf-8 if necessary\"\"\"\n381         try:\n382             return str(v)\n383         except UnicodeError:\n384             if not isinstance(v, text_type):\n385                 v = text_type(v)\n386             errors = \"replace\"\n387             return v.encode(\"utf-8\", errors)\n388 \n389 \n390 COLLECT_FAKEMODULE_ATTRIBUTES = (\n391     \"Collector\",\n392     \"Module\",\n393     \"Function\",\n394     \"Instance\",\n395     \"Session\",\n396     \"Item\",\n397     \"Class\",\n398     \"File\",\n399     \"_fillfuncargs\",\n400 )\n401 \n402 \n403 def _setup_collect_fakemodule():\n404     from types import ModuleType\n405     import pytest\n406 \n407     pytest.collect = ModuleType(\"pytest.collect\")\n408     pytest.collect.__all__ = []  # used for setns\n409     for attr in COLLECT_FAKEMODULE_ATTRIBUTES:\n410         setattr(pytest.collect, attr, getattr(pytest, attr))\n411 \n412 \n413 if _PY2:\n414     # Without this the test_dupfile_on_textio will fail, otherwise CaptureIO could directly inherit from StringIO.\n415     from py.io import TextIO\n416 \n417     class CaptureIO(TextIO):\n418         @property\n419         def encoding(self):\n420             return getattr(self, \"_encoding\", \"UTF-8\")\n421 \n422 \n423 else:\n424     import io\n425 \n426     class CaptureIO(io.TextIOWrapper):\n427         def __init__(self):\n428             super(CaptureIO, self).__init__(\n429                 io.BytesIO(), encoding=\"UTF-8\", newline=\"\", write_through=True\n430             )\n431 \n432         def getvalue(self):\n433             return self.buffer.getvalue().decode(\"UTF-8\")\n434 \n435 \n436 class FuncargnamesCompatAttr(object):\n437     \"\"\" helper class so that Metafunc, Function and FixtureRequest\n438     don't need to each define the \"funcargnames\" compatibility attribute.\n439     \"\"\"\n440 \n441     @property\n442     def funcargnames(self):\n443         \"\"\" alias attribute for ``fixturenames`` for pre-2.3 compatibility\"\"\"\n444         return self.fixturenames\n445 \n446 \n447 if six.PY2:\n448 \n449     def lru_cache(*_, **__):\n450         def dec(fn):\n451             return fn\n452 \n453         return dec\n454 \n455 \n456 else:\n457     from functools import lru_cache  # noqa: F401\n",
        "intended_behavior": "Verify and, if necessary, adjust the encoding and decoding utilities to ensure they gracefully handle Unicode strings, especially in the context of assertions and exceptions. For example, utility functions could be designed to encode Unicode strings to a specific encoding only when running under Python 2, using `sys.version_info` checks."
    },
    {
        "rel_file_path": "testing/python/raises.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/pytest-dev__pytest/setup_pytest-dev__pytest__4.6/testing/python/raises.py",
        "start": 1,
        "end": 280,
        "class_name": null,
        "method_name": null,
        "code": "1 # -*- coding: utf-8 -*-\n2 import sys\n3 \n4 import six\n5 \n6 import pytest\n7 from _pytest.outcomes import Failed\n8 from _pytest.warning_types import PytestDeprecationWarning\n9 \n10 \n11 class TestRaises(object):\n12     def test_raises(self):\n13         source = \"int('qwe')\"\n14         with pytest.warns(PytestDeprecationWarning):\n15             excinfo = pytest.raises(ValueError, source)\n16         code = excinfo.traceback[-1].frame.code\n17         s = str(code.fullsource)\n18         assert s == source\n19 \n20     def test_raises_exec(self):\n21         with pytest.warns(PytestDeprecationWarning) as warninfo:\n22             pytest.raises(ValueError, \"a,x = []\")\n23         assert warninfo[0].filename == __file__\n24 \n25     def test_raises_exec_correct_filename(self):\n26         with pytest.warns(PytestDeprecationWarning):\n27             excinfo = pytest.raises(ValueError, 'int(\"s\")')\n28             assert __file__ in excinfo.traceback[-1].path\n29 \n30     def test_raises_syntax_error(self):\n31         with pytest.warns(PytestDeprecationWarning) as warninfo:\n32             pytest.raises(SyntaxError, \"qwe qwe qwe\")\n33         assert warninfo[0].filename == __file__\n34 \n35     def test_raises_function(self):\n36         pytest.raises(ValueError, int, \"hello\")\n37 \n38     def test_raises_callable_no_exception(self):\n39         class A(object):\n40             def __call__(self):\n41                 pass\n42 \n43         try:\n44             pytest.raises(ValueError, A())\n45         except pytest.raises.Exception:\n46             pass\n47 \n48     def test_raises_falsey_type_error(self):\n49         with pytest.raises(TypeError):\n50             with pytest.raises(AssertionError, match=0):\n51                 raise AssertionError(\"ohai\")\n52 \n53     def test_raises_repr_inflight(self):\n54         \"\"\"Ensure repr() on an exception info inside a pytest.raises with block works (#4386)\"\"\"\n55 \n56         class E(Exception):\n57             pass\n58 \n59         with pytest.raises(E) as excinfo:\n60             # this test prints the inflight uninitialized object\n61             # using repr and str as well as pprint to demonstrate\n62             # it works\n63             print(str(excinfo))\n64             print(repr(excinfo))\n65             import pprint\n66 \n67             pprint.pprint(excinfo)\n68             raise E()\n69 \n70     def test_raises_as_contextmanager(self, testdir):\n71         testdir.makepyfile(\n72             \"\"\"\n73             import pytest\n74             import _pytest._code\n75 \n76             def test_simple():\n77                 with pytest.raises(ZeroDivisionError) as excinfo:\n78                     assert isinstance(excinfo, _pytest._code.ExceptionInfo)\n79                     1/0\n80                 print(excinfo)\n81                 assert excinfo.type == ZeroDivisionError\n82                 assert isinstance(excinfo.value, ZeroDivisionError)\n83 \n84             def test_noraise():\n85                 with pytest.raises(pytest.raises.Exception):\n86                     with pytest.raises(ValueError):\n87                            int()\n88 \n89             def test_raise_wrong_exception_passes_by():\n90                 with pytest.raises(ZeroDivisionError):\n91                     with pytest.raises(ValueError):\n92                            1/0\n93         \"\"\"\n94         )\n95         result = testdir.runpytest()\n96         result.stdout.fnmatch_lines([\"*3 passed*\"])\n97 \n98     def test_does_not_raise(self, testdir):\n99         testdir.makepyfile(\n100             \"\"\"\n101             from contextlib import contextmanager\n102             import pytest\n103 \n104             @contextmanager\n105             def does_not_raise():\n106                 yield\n107 \n108             @pytest.mark.parametrize('example_input,expectation', [\n109                 (3, does_not_raise()),\n110                 (2, does_not_raise()),\n111                 (1, does_not_raise()),\n112                 (0, pytest.raises(ZeroDivisionError)),\n113             ])\n114             def test_division(example_input, expectation):\n115                 '''Test how much I know division.'''\n116                 with expectation:\n117                     assert (6 / example_input) is not None\n118         \"\"\"\n119         )\n120         result = testdir.runpytest()\n121         result.stdout.fnmatch_lines([\"*4 passed*\"])\n122 \n123     def test_does_not_raise_does_raise(self, testdir):\n124         testdir.makepyfile(\n125             \"\"\"\n126             from contextlib import contextmanager\n127             import pytest\n128 \n129             @contextmanager\n130             def does_not_raise():\n131                 yield\n132 \n133             @pytest.mark.parametrize('example_input,expectation', [\n134                 (0, does_not_raise()),\n135                 (1, pytest.raises(ZeroDivisionError)),\n136             ])\n137             def test_division(example_input, expectation):\n138                 '''Test how much I know division.'''\n139                 with expectation:\n140                     assert (6 / example_input) is not None\n141         \"\"\"\n142         )\n143         result = testdir.runpytest()\n144         result.stdout.fnmatch_lines([\"*2 failed*\"])\n145 \n146     def test_noclass(self):\n147         with pytest.raises(TypeError):\n148             pytest.raises(\"wrong\", lambda: None)\n149 \n150     def test_invalid_arguments_to_raises(self):\n151         with pytest.raises(TypeError, match=\"unknown\"):\n152             with pytest.raises(TypeError, unknown=\"bogus\"):\n153                 raise ValueError()\n154 \n155     def test_tuple(self):\n156         with pytest.raises((KeyError, ValueError)):\n157             raise KeyError(\"oops\")\n158 \n159     def test_no_raise_message(self):\n160         try:\n161             pytest.raises(ValueError, int, \"0\")\n162         except pytest.raises.Exception as e:\n163             assert e.msg == \"DID NOT RAISE {}\".format(repr(ValueError))\n164         else:\n165             assert False, \"Expected pytest.raises.Exception\"\n166 \n167         try:\n168             with pytest.raises(ValueError):\n169                 pass\n170         except pytest.raises.Exception as e:\n171             assert e.msg == \"DID NOT RAISE {}\".format(repr(ValueError))\n172         else:\n173             assert False, \"Expected pytest.raises.Exception\"\n174 \n175     def test_custom_raise_message(self):\n176         message = \"TEST_MESSAGE\"\n177         try:\n178             with pytest.warns(PytestDeprecationWarning):\n179                 with pytest.raises(ValueError, message=message):\n180                     pass\n181         except pytest.raises.Exception as e:\n182             assert e.msg == message\n183         else:\n184             assert False, \"Expected pytest.raises.Exception\"\n185 \n186     @pytest.mark.parametrize(\"method\", [\"function\", \"with\"])\n187     def test_raises_cyclic_reference(self, method):\n188         \"\"\"\n189         Ensure pytest.raises does not leave a reference cycle (#1965).\n190         \"\"\"\n191         import gc\n192 \n193         class T(object):\n194             def __call__(self):\n195                 raise ValueError\n196 \n197         t = T()\n198         if method == \"function\":\n199             pytest.raises(ValueError, t)\n200         else:\n201             with pytest.raises(ValueError):\n202                 t()\n203 \n204         # ensure both forms of pytest.raises don't leave exceptions in sys.exc_info()\n205         assert sys.exc_info() == (None, None, None)\n206 \n207         del t\n208 \n209         # ensure the t instance is not stuck in a cyclic reference\n210         for o in gc.get_objects():\n211             assert type(o) is not T\n212 \n213     def test_raises_match(self):\n214         msg = r\"with base \\d+\"\n215         with pytest.raises(ValueError, match=msg):\n216             int(\"asdf\")\n217 \n218         msg = \"with base 10\"\n219         with pytest.raises(ValueError, match=msg):\n220             int(\"asdf\")\n221 \n222         msg = \"with base 16\"\n223         expr = r\"Pattern '{}' not found in 'invalid literal for int\\(\\) with base 10: 'asdf''\".format(\n224             msg\n225         )\n226         with pytest.raises(AssertionError, match=expr):\n227             with pytest.raises(ValueError, match=msg):\n228                 int(\"asdf\", base=10)\n229 \n230     def test_raises_match_wrong_type(self):\n231         \"\"\"Raising an exception with the wrong type and match= given.\n232 \n233         pytest should throw the unexpected exception - the pattern match is not\n234         really relevant if we got a different exception.\n235         \"\"\"\n236         with pytest.raises(ValueError):\n237             with pytest.raises(IndexError, match=\"nomatch\"):\n238                 int(\"asdf\")\n239 \n240     def test_raises_exception_looks_iterable(self):\n241         from six import add_metaclass\n242 \n243         class Meta(type(object)):\n244             def __getitem__(self, item):\n245                 return 1 / 0\n246 \n247             def __len__(self):\n248                 return 1\n249 \n250         @add_metaclass(Meta)\n251         class ClassLooksIterableException(Exception):\n252             pass\n253 \n254         with pytest.raises(\n255             Failed,\n256             match=r\"DID NOT RAISE <class 'raises(\\..*)*ClassLooksIterableException'>\",\n257         ):\n258             pytest.raises(ClassLooksIterableException, lambda: None)\n259 \n260     def test_raises_with_raising_dunder_class(self):\n261         \"\"\"Test current behavior with regard to exceptions via __class__ (#4284).\"\"\"\n262 \n263         class CrappyClass(Exception):\n264             @property\n265             def __class__(self):\n266                 assert False, \"via __class__\"\n267 \n268         if six.PY2:\n269             with pytest.raises(pytest.fail.Exception) as excinfo:\n270                 with pytest.raises(CrappyClass()):\n271                     pass\n272             assert \"DID NOT RAISE\" in excinfo.value.args[0]\n273 \n274             with pytest.raises(CrappyClass) as excinfo:\n275                 raise CrappyClass()\n276         else:\n277             with pytest.raises(AssertionError) as excinfo:\n278                 with pytest.raises(CrappyClass()):\n279                     pass\n280             assert \"via __class__\" in excinfo.value.args[0]\n",
        "intended_behavior": "Ensure any test cases that use `pytest.raises` with Unicode strings are correctly designed to handle or expect Unicode characters without causing encoding errors. If this file contains custom utility functions or helpers around `pytest.raises`, verify these helpers manage Unicode strings properly under Python 2."
    }
]