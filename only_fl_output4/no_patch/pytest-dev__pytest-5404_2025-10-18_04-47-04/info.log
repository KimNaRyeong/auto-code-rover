2025-10-18 04:47:04.749 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-18 04:47:06.867 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1074, output_tokens=12, cost=0.011100
2025-10-18 04:47:23.827 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1254, output_tokens=714, cost=0.033960
2025-10-18 04:47:24.839 | INFO     | registered non reproducing test 0
2025-10-18 04:47:41.779 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2252, output_tokens=759, cost=0.045290
2025-10-18 04:47:42.755 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 04:47:51.752 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1365, output_tokens=330, cost=0.023550
2025-10-18 04:47:51.759 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 04:47:54.175 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=684, output_tokens=32, cost=0.007800
2025-10-18 04:47:54.176 | DEBUG    | Extracted a valid json.
2025-10-18 04:47:54.176 | DEBUG    | Agent proxy return the following json: {
    "API_calls": ["search_code(\"from sty import fg\")", "search_code(\"__wrapped__\")"],
    "bug_locations": []
}
2025-10-18 04:47:54.206 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 04:47:54.207 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 04:48:08.804 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1894, output_tokens=685, cost=0.039490
2025-10-18 04:48:08.819 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 04:48:16.745 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2795, output_tokens=343, cost=0.038240
2025-10-18 04:48:16.753 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 04:48:24.605 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=697, output_tokens=329, cost=0.016840
2025-10-18 04:48:24.606 | DEBUG    | Extracted a valid json.
2025-10-18 04:48:24.606 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "testing/python/integration.py",
            "class": "",
            "method": "",
            "intended_behavior": "The code that accesses `__wrapped__` should first check if the attribute exists. This could be implemented by either using `getattr` with a default value or explicitly checking the presence of the `__wrapped__` attribute on an object before accessing it. This adjustment is necessary to prevent `KeyError` when the attribute is not present on an object that is being inspected during the test collection or execution process. The existing functionality, which likely aims to introspect or modify test functions (potentially for unwrapping decorators), should be preserved while making it robust against the absence of `__wrapped__`."
        },
        {
            "file": "src/_pytest/compat.py",
            "class": "",
            "method": "",
            "intended_behavior": "The code related to function unwrapping or manipulation that uses `__wrapped__` should implement safer access patterns. As in the previous location, using `getattr(obj, '__wrapped__', default)` or a similar check will ensure that `KeyError` is not raised. This file's role in smoothing over compatibility issues suggests it might be dealing with a variety of Python versions and their nuances in handling wrapped functions. Thus, enhancing robustness here is crucial. The amendment should not alter the core functionality intended by these compatibility layers but should ensure they are fault-tolerant to differences in object attributes, particularly `__wrapped__`."
        }
    ]
}
2025-10-18 04:48:24.612 | DEBUG    | Bug location extracted successfully: [<file>testing/python/integration.py</file>
<class>None</class>
<method>None</method>
<code>
1 import pytest
2 from _pytest import python
3 from _pytest import runner
4 
5 
6 class TestOEJSKITSpecials:
7     def test_funcarg_non_pycollectobj(self, testdir):  # rough jstests usage
8         testdir.makeconftest(
9             """
10             import pytest
11             def pytest_pycollect_makeitem(collector, name, obj):
12                 if name == "MyClass":
13                     return MyCollector(name, parent=collector)
14             class MyCollector(pytest.Collector):
15                 def reportinfo(self):
16                     return self.fspath, 3, "xyz"
17         """
18         )
19         modcol = testdir.getmodulecol(
20             """
21             import pytest
22             @pytest.fixture
23             def arg1(request):
24                 return 42
25             class MyClass(object):
26                 pass
27         """
28         )
29         # this hook finds funcarg factories
30         rep = runner.collect_one_node(collector=modcol)
31         clscol = rep.result[0]
32         clscol.obj = lambda arg1: None
33         clscol.funcargs = {}
34         pytest._fillfuncargs(clscol)
35         assert clscol.funcargs["arg1"] == 42
36 
37     def test_autouse_fixture(self, testdir):  # rough jstests usage
38         testdir.makeconftest(
39             """
40             import pytest
41             def pytest_pycollect_makeitem(collector, name, obj):
42                 if name == "MyClass":
43                     return MyCollector(name, parent=collector)
44             class MyCollector(pytest.Collector):
45                 def reportinfo(self):
46                     return self.fspath, 3, "xyz"
47         """
48         )
49         modcol = testdir.getmodulecol(
50             """
51             import pytest
52             @pytest.fixture(autouse=True)
53             def hello():
54                 pass
55             @pytest.fixture
56             def arg1(request):
57                 return 42
58             class MyClass(object):
59                 pass
60         """
61         )
62         # this hook finds funcarg factories
63         rep = runner.collect_one_node(modcol)
64         clscol = rep.result[0]
65         clscol.obj = lambda: None
66         clscol.funcargs = {}
67         pytest._fillfuncargs(clscol)
68         assert not clscol.funcargs
69 
70 
71 def test_wrapped_getfslineno():
72     def func():
73         pass
74 
75     def wrap(f):
76         func.__wrapped__ = f
77         func.patchings = ["qwe"]
78         return func
79 
80     @wrap
81     def wrapped_func(x, y, z):
82         pass
83 
84     fs, lineno = python.getfslineno(wrapped_func)
85     fs2, lineno2 = python.getfslineno(wrap)
86     assert lineno > lineno2, "getfslineno does not unwrap correctly"
87 
88 
89 class TestMockDecoration:
90     def test_wrapped_getfuncargnames(self):
91         from _pytest.compat import getfuncargnames
92 
93         def wrap(f):
94             def func():
95                 pass
96 
97             func.__wrapped__ = f
98             return func
99 
100         @wrap
101         def f(x):
102             pass
103 
104         values = getfuncargnames(f)
105         assert values == ("x",)
106 
107     @pytest.mark.xfail(
108         strict=False, reason="getfuncargnames breaks if mock is imported"
109     )
110     def test_wrapped_getfuncargnames_patching(self):
111         from _pytest.compat import getfuncargnames
112 
113         def wrap(f):
114             def func():
115                 pass
116 
117             func.__wrapped__ = f
118             func.patchings = ["qwe"]
119             return func
120 
121         @wrap
122         def f(x, y, z):
123             pass
124 
125         values = getfuncargnames(f)
126         assert values == ("y", "z")
127 
128     def test_unittest_mock(self, testdir):
129         pytest.importorskip("unittest.mock")
130         testdir.makepyfile(
131             """
132             import unittest.mock
133             class T(unittest.TestCase):
134                 @unittest.mock.patch("os.path.abspath")
135                 def test_hello(self, abspath):
136                     import os
137                     os.path.abspath("hello")
138                     abspath.assert_any_call("hello")
139         """
140         )
141         reprec = testdir.inline_run()
142         reprec.assertoutcome(passed=1)
143 
144     def test_unittest_mock_and_fixture(self, testdir):
145         pytest.importorskip("unittest.mock")
146         testdir.makepyfile(
147             """
148             import os.path
149             import unittest.mock
150             import pytest
151 
152             @pytest.fixture
153             def inject_me():
154                 pass
155 
156             @unittest.mock.patch.object(os.path, "abspath",
157                                         new=unittest.mock.MagicMock)
158             def test_hello(inject_me):
159                 import os
160                 os.path.abspath("hello")
161         """
162         )
163         reprec = testdir.inline_run()
164         reprec.assertoutcome(passed=1)
165 
166     def test_unittest_mock_and_pypi_mock(self, testdir):
167         pytest.importorskip("unittest.mock")
168         pytest.importorskip("mock", "1.0.1")
169         testdir.makepyfile(
170             """
171             import mock
172             import unittest.mock
173             class TestBoth(object):
174                 @unittest.mock.patch("os.path.abspath")
175                 def test_hello(self, abspath):
176                     import os
177                     os.path.abspath("hello")
178                     abspath.assert_any_call("hello")
179 
180                 @mock.patch("os.path.abspath")
181                 def test_hello_mock(self, abspath):
182                     import os
183                     os.path.abspath("hello")
184                     abspath.assert_any_call("hello")
185         """
186         )
187         reprec = testdir.inline_run()
188         reprec.assertoutcome(passed=2)
189 
190     def test_mock(self, testdir):
191         pytest.importorskip("mock", "1.0.1")
192         testdir.makepyfile(
193             """
194             import os
195             import unittest
196             import mock
197 
198             class T(unittest.TestCase):
199                 @mock.patch("os.path.abspath")
200                 def test_hello(self, abspath):
201                     os.path.abspath("hello")
202                     abspath.assert_any_call("hello")
203             def mock_basename(path):
204                 return "mock_basename"
205             @mock.patch("os.path.abspath")
206             @mock.patch("os.path.normpath")
207             @mock.patch("os.path.basename", new=mock_basename)
208             def test_someting(normpath, abspath, tmpdir):
209                 abspath.return_value = "this"
210                 os.path.normpath(os.path.abspath("hello"))
211                 normpath.assert_any_call("this")
212                 assert os.path.basename("123") == "mock_basename"
213         """
214         )
215         reprec = testdir.inline_run()
216         reprec.assertoutcome(passed=2)
217         calls = reprec.getcalls("pytest_runtest_logreport")
218         funcnames = [
219             call.report.location[2] for call in calls if call.report.when == "call"
220         ]
221         assert funcnames == ["T.test_hello", "test_someting"]
222 
223     def test_mock_sorting(self, testdir):
224         pytest.importorskip("mock", "1.0.1")
225         testdir.makepyfile(
226             """
227             import os
228             import mock
229 
230             @mock.patch("os.path.abspath")
231             def test_one(abspath):
232                 pass
233             @mock.patch("os.path.abspath")
234             def test_two(abspath):
235                 pass
236             @mock.patch("os.path.abspath")
237             def test_three(abspath):
238                 pass
239         """
240         )
241         reprec = testdir.inline_run()
242         calls = reprec.getreports("pytest_runtest_logreport")
243         calls = [x for x in calls if x.when == "call"]
244         names = [x.nodeid.split("::")[-1] for x in calls]
245         assert names == ["test_one", "test_two", "test_three"]
246 
247     def test_mock_double_patch_issue473(self, testdir):
248         pytest.importorskip("mock", "1.0.1")
249         testdir.makepyfile(
250             """
251             from mock import patch
252             from pytest import mark
253 
254             @patch('os.getcwd')
255             @patch('os.path')
256             @mark.slow
257             class TestSimple(object):
258                 def test_simple_thing(self, mock_path, mock_getcwd):
259                     pass
260         """
261         )
262         reprec = testdir.inline_run()
263         reprec.assertoutcome(passed=1)
264 
265 
266 class TestReRunTests:
267     def test_rerun(self, testdir):
268         testdir.makeconftest(
269             """
270             from _pytest.runner import runtestprotocol
271             def pytest_runtest_protocol(item, nextitem):
272                 runtestprotocol(item, log=False, nextitem=nextitem)
273                 runtestprotocol(item, log=True, nextitem=nextitem)
274         """
275         )
276         testdir.makepyfile(
277             """
278             import pytest
279             count = 0
280             req = None
281             @pytest.fixture
282             def fix(request):
283                 global count, req
284                 assert request != req
285                 req = request
286                 print("fix count %s" % count)
287                 count += 1
288             def test_fix(fix):
289                 pass
290         """
291         )
292         result = testdir.runpytest("-s")
293         result.stdout.fnmatch_lines(
294             """
295             *fix count 0*
296             *fix count 1*
297         """
298         )
299         result.stdout.fnmatch_lines(
300             """
301             *2 passed*
302         """
303         )
304 
305 
306 def test_pytestconfig_is_session_scoped():
307     from _pytest.fixtures import pytestconfig
308 
309     assert pytestconfig._pytestfixturefunction.scope == "session"
310 
311 
312 class TestNoselikeTestAttribute:
313     def test_module_with_global_test(self, testdir):
314         testdir.makepyfile(
315             """
316             __test__ = False
317             def test_hello():
318                 pass
319         """
320         )
321         reprec = testdir.inline_run()
322         assert not reprec.getfailedcollections()
323         calls = reprec.getreports("pytest_runtest_logreport")
324         assert not calls
325 
326     def test_class_and_method(self, testdir):
327         testdir.makepyfile(
328             """
329             __test__ = True
330             def test_func():
331                 pass
332             test_func.__test__ = False
333 
334             class TestSome(object):
335                 __test__ = False
336                 def test_method(self):
337                     pass
338         """
339         )
340         reprec = testdir.inline_run()
341         assert not reprec.getfailedcollections()
342         calls = reprec.getreports("pytest_runtest_logreport")
343         assert not calls
344 
345     def test_unittest_class(self, testdir):
346         testdir.makepyfile(
347             """
348             import unittest
349             class TC(unittest.TestCase):
350                 def test_1(self):
351                     pass
352             class TC2(unittest.TestCase):
353                 __test__ = False
354                 def test_2(self):
355                     pass
356         """
357         )
358         reprec = testdir.inline_run()
359         assert not reprec.getfailedcollections()
360         call = reprec.getcalls("pytest_collection_modifyitems")[0]
361         assert len(call.items) == 1
362         assert call.items[0].cls.__name__ == "TC"
363 
364     def test_class_with_nasty_getattr(self, testdir):
365         """Make sure we handle classes with a custom nasty __getattr__ right.
366 
367         With a custom __getattr__ which e.g. returns a function (like with a
368         RPC wrapper), we shouldn't assume this meant "__test__ = True".
369         """
370         # https://github.com/pytest-dev/pytest/issues/1204
371         testdir.makepyfile(
372             """
373             class MetaModel(type):
374 
375                 def __getattr__(cls, key):
376                     return lambda: None
377 
378 
379             BaseModel = MetaModel('Model', (), {})
380 
381 
382             class Model(BaseModel):
383 
384                 __metaclass__ = MetaModel
385 
386                 def test_blah(self):
387                     pass
388         """
389         )
390         reprec = testdir.inline_run()
391         assert not reprec.getfailedcollections()
392         call = reprec.getcalls("pytest_collection_modifyitems")[0]
393         assert not call.items
394 
395 
396 class TestParameterize:
397     """#351"""
398 
399     def test_idfn_marker(self, testdir):
400         testdir.makepyfile(
401             """
402             import pytest
403 
404             def idfn(param):
405                 if param == 0:
406                     return 'spam'
407                 elif param == 1:
408                     return 'ham'
409                 else:
410                     return None
411 
412             @pytest.mark.parametrize('a,b', [(0, 2), (1, 2)], ids=idfn)
413             def test_params(a, b):
414                 pass
415         """
416         )
417         res = testdir.runpytest("--collect-only")
418         res.stdout.fnmatch_lines(["*spam-2*", "*ham-2*"])
419 
420     def test_idfn_fixture(self, testdir):
421         testdir.makepyfile(
422             """
423             import pytest
424 
425             def idfn(param):
426                 if param == 0:
427                     return 'spam'
428                 elif param == 1:
429                     return 'ham'
430                 else:
431                     return None
432 
433             @pytest.fixture(params=[0, 1], ids=idfn)
434             def a(request):
435                 return request.param
436 
437             @pytest.fixture(params=[1, 2], ids=idfn)
438             def b(request):
439                 return request.param
440 
441             def test_params(a, b):
442                 pass
443         """
444         )
445         res = testdir.runpytest("--collect-only")
446         res.stdout.fnmatch_lines(["*spam-2*", "*ham-2*"])

</code><intended_behavior>The code that accesses `__wrapped__` should first check if the attribute exists. This could be implemented by either using `getattr` with a default value or explicitly checking the presence of the `__wrapped__` attribute on an object before accessing it. This adjustment is necessary to prevent `KeyError` when the attribute is not present on an object that is being inspected during the test collection or execution process. The existing functionality, which likely aims to introspect or modify test functions (potentially for unwrapping decorators), should be preserved while making it robust against the absence of `__wrapped__`.</intended_behavior>, <file>src/_pytest/compat.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2 python version compatibility code
3 """
4 import functools
5 import inspect
6 import io
7 import re
8 import sys
9 from contextlib import contextmanager
10 from inspect import Parameter
11 from inspect import signature
12 
13 import py
14 
15 import _pytest
16 from _pytest._io.saferepr import saferepr
17 from _pytest.outcomes import fail
18 from _pytest.outcomes import TEST_OUTCOME
19 
20 
21 NOTSET = object()
22 
23 MODULE_NOT_FOUND_ERROR = (
24     "ModuleNotFoundError" if sys.version_info[:2] >= (3, 6) else "ImportError"
25 )
26 
27 
28 def _format_args(func):
29     return str(signature(func))
30 
31 
32 isfunction = inspect.isfunction
33 isclass = inspect.isclass
34 # used to work around a python2 exception info leak
35 exc_clear = getattr(sys, "exc_clear", lambda: None)
36 # The type of re.compile objects is not exposed in Python.
37 REGEX_TYPE = type(re.compile(""))
38 
39 
40 def is_generator(func):
41     genfunc = inspect.isgeneratorfunction(func)
42     return genfunc and not iscoroutinefunction(func)
43 
44 
45 def iscoroutinefunction(func):
46     """Return True if func is a decorated coroutine function.
47 
48     Note: copied and modified from Python 3.5's builtin couroutines.py to avoid import asyncio directly,
49     which in turns also initializes the "logging" module as side-effect (see issue #8).
50     """
51     return getattr(func, "_is_coroutine", False) or (
52         hasattr(inspect, "iscoroutinefunction") and inspect.iscoroutinefunction(func)
53     )
54 
55 
56 def getlocation(function, curdir):
57     function = get_real_func(function)
58     fn = py.path.local(inspect.getfile(function))
59     lineno = function.__code__.co_firstlineno
60     if fn.relto(curdir):
61         fn = fn.relto(curdir)
62     return "%s:%d" % (fn, lineno + 1)
63 
64 
65 def num_mock_patch_args(function):
66     """ return number of arguments used up by mock arguments (if any) """
67     patchings = getattr(function, "patchings", None)
68     if not patchings:
69         return 0
70     mock_modules = [sys.modules.get("mock"), sys.modules.get("unittest.mock")]
71     if any(mock_modules):
72         sentinels = [m.DEFAULT for m in mock_modules if m is not None]
73         return len(
74             [p for p in patchings if not p.attribute_name and p.new in sentinels]
75         )
76     return len(patchings)
77 
78 
79 def getfuncargnames(function, is_method=False, cls=None):
80     """Returns the names of a function's mandatory arguments.
81 
82     This should return the names of all function arguments that:
83         * Aren't bound to an instance or type as in instance or class methods.
84         * Don't have default values.
85         * Aren't bound with functools.partial.
86         * Aren't replaced with mocks.
87 
88     The is_method and cls arguments indicate that the function should
89     be treated as a bound method even though it's not unless, only in
90     the case of cls, the function is a static method.
91 
92     @RonnyPfannschmidt: This function should be refactored when we
93     revisit fixtures. The fixture mechanism should ask the node for
94     the fixture names, and not try to obtain directly from the
95     function object well after collection has occurred.
96 
97     """
98     # The parameters attribute of a Signature object contains an
99     # ordered mapping of parameter names to Parameter instances.  This
100     # creates a tuple of the names of the parameters that don't have
101     # defaults.
102     try:
103         parameters = signature(function).parameters
104     except (ValueError, TypeError) as e:
105         fail(
106             "Could not determine arguments of {!r}: {}".format(function, e),
107             pytrace=False,
108         )
109 
110     arg_names = tuple(
111         p.name
112         for p in parameters.values()
113         if (
114             p.kind is Parameter.POSITIONAL_OR_KEYWORD
115             or p.kind is Parameter.KEYWORD_ONLY
116         )
117         and p.default is Parameter.empty
118     )
119     # If this function should be treated as a bound method even though
120     # it's passed as an unbound method or function, remove the first
121     # parameter name.
122     if is_method or (
123         cls and not isinstance(cls.__dict__.get(function.__name__, None), staticmethod)
124     ):
125         arg_names = arg_names[1:]
126     # Remove any names that will be replaced with mocks.
127     if hasattr(function, "__wrapped__"):
128         arg_names = arg_names[num_mock_patch_args(function) :]
129     return arg_names
130 
131 
132 @contextmanager
133 def dummy_context_manager():
134     """Context manager that does nothing, useful in situations where you might need an actual context manager or not
135     depending on some condition. Using this allow to keep the same code"""
136     yield
137 
138 
139 def get_default_arg_names(function):
140     # Note: this code intentionally mirrors the code at the beginning of getfuncargnames,
141     # to get the arguments which were excluded from its result because they had default values
142     return tuple(
143         p.name
144         for p in signature(function).parameters.values()
145         if p.kind in (Parameter.POSITIONAL_OR_KEYWORD, Parameter.KEYWORD_ONLY)
146         and p.default is not Parameter.empty
147     )
148 
149 
150 _non_printable_ascii_translate_table = {
151     i: "\\x{:02x}".format(i) for i in range(128) if i not in range(32, 127)
152 }
153 _non_printable_ascii_translate_table.update(
154     {ord("\t"): "\\t", ord("\r"): "\\r", ord("\n"): "\\n"}
155 )
156 
157 
158 def _translate_non_printable(s):
159     return s.translate(_non_printable_ascii_translate_table)
160 
161 
162 STRING_TYPES = bytes, str
163 
164 
165 def _bytes_to_ascii(val):
166     return val.decode("ascii", "backslashreplace")
167 
168 
169 def ascii_escaped(val):
170     """If val is pure ascii, returns it as a str().  Otherwise, escapes
171     bytes objects into a sequence of escaped bytes:
172 
173     b'\xc3\xb4\xc5\xd6' -> '\\xc3\\xb4\\xc5\\xd6'
174 
175     and escapes unicode objects into a sequence of escaped unicode
176     ids, e.g.:
177 
178     '4\\nV\\U00043efa\\x0eMXWB\\x1e\\u3028\\u15fd\\xcd\\U0007d944'
179 
180     note:
181        the obvious "v.decode('unicode-escape')" will return
182        valid utf-8 unicode if it finds them in bytes, but we
183        want to return escaped bytes for any byte, even if they match
184        a utf-8 string.
185 
186     """
187     if isinstance(val, bytes):
188         ret = _bytes_to_ascii(val)
189     else:
190         ret = val.encode("unicode_escape").decode("ascii")
191     return _translate_non_printable(ret)
192 
193 
194 class _PytestWrapper:
195     """Dummy wrapper around a function object for internal use only.
196 
197     Used to correctly unwrap the underlying function object
198     when we are creating fixtures, because we wrap the function object ourselves with a decorator
199     to issue warnings when the fixture function is called directly.
200     """
201 
202     def __init__(self, obj):
203         self.obj = obj
204 
205 
206 def get_real_func(obj):
207     """ gets the real function object of the (possibly) wrapped object by
208     functools.wraps or functools.partial.
209     """
210     start_obj = obj
211     for i in range(100):
212         # __pytest_wrapped__ is set by @pytest.fixture when wrapping the fixture function
213         # to trigger a warning if it gets called directly instead of by pytest: we don't
214         # want to unwrap further than this otherwise we lose useful wrappings like @mock.patch (#3774)
215         new_obj = getattr(obj, "__pytest_wrapped__", None)
216         if isinstance(new_obj, _PytestWrapper):
217             obj = new_obj.obj
218             break
219         new_obj = getattr(obj, "__wrapped__", None)
220         if new_obj is None:
221             break
222         obj = new_obj
223     else:
224         raise ValueError(
225             ("could not find real function of {start}\nstopped at {current}").format(
226                 start=saferepr(start_obj), current=saferepr(obj)
227             )
228         )
229     if isinstance(obj, functools.partial):
230         obj = obj.func
231     return obj
232 
233 
234 def get_real_method(obj, holder):
235     """
236     Attempts to obtain the real function object that might be wrapping ``obj``, while at the same time
237     returning a bound method to ``holder`` if the original object was a bound method.
238     """
239     try:
240         is_method = hasattr(obj, "__func__")
241         obj = get_real_func(obj)
242     except Exception:
243         return obj
244     if is_method and hasattr(obj, "__get__") and callable(obj.__get__):
245         obj = obj.__get__(holder)
246     return obj
247 
248 
249 def getfslineno(obj):
250     # xxx let decorators etc specify a sane ordering
251     obj = get_real_func(obj)
252     if hasattr(obj, "place_as"):
253         obj = obj.place_as
254     fslineno = _pytest._code.getfslineno(obj)
255     assert isinstance(fslineno[1], int), obj
256     return fslineno
257 
258 
259 def getimfunc(func):
260     try:
261         return func.__func__
262     except AttributeError:
263         return func
264 
265 
266 def safe_getattr(object, name, default):
267     """ Like getattr but return default upon any Exception or any OutcomeException.
268 
269     Attribute access can potentially fail for 'evil' Python objects.
270     See issue #214.
271     It catches OutcomeException because of #2490 (issue #580), new outcomes are derived from BaseException
272     instead of Exception (for more details check #2707)
273     """
274     try:
275         return getattr(object, name, default)
276     except TEST_OUTCOME:
277         return default
278 
279 
280 def safe_isclass(obj):
281     """Ignore any exception via isinstance on Python 3."""
282     try:
283         return isclass(obj)
284     except Exception:
285         return False
286 
287 
288 COLLECT_FAKEMODULE_ATTRIBUTES = (
289     "Collector",
290     "Module",
291     "Function",
292     "Instance",
293     "Session",
294     "Item",
295     "Class",
296     "File",
297     "_fillfuncargs",
298 )
299 
300 
301 def _setup_collect_fakemodule():
302     from types import ModuleType
303     import pytest
304 
305     pytest.collect = ModuleType("pytest.collect")
306     pytest.collect.__all__ = []  # used for setns
307     for attr in COLLECT_FAKEMODULE_ATTRIBUTES:
308         setattr(pytest.collect, attr, getattr(pytest, attr))
309 
310 
311 class CaptureIO(io.TextIOWrapper):
312     def __init__(self):
313         super().__init__(io.BytesIO(), encoding="UTF-8", newline="", write_through=True)
314 
315     def getvalue(self):
316         return self.buffer.getvalue().decode("UTF-8")
317 
318 
319 class FuncargnamesCompatAttr:
320     """ helper class so that Metafunc, Function and FixtureRequest
321     don't need to each define the "funcargnames" compatibility attribute.
322     """
323 
324     @property
325     def funcargnames(self):
326         """ alias attribute for ``fixturenames`` for pre-2.3 compatibility"""
327         return self.fixturenames

</code><intended_behavior>The code related to function unwrapping or manipulation that uses `__wrapped__` should implement safer access patterns. As in the previous location, using `getattr(obj, '__wrapped__', default)` or a similar check will ensure that `KeyError` is not raised. This file's role in smoothing over compatibility issues suggests it might be dealing with a variety of Python versions and their nuances in handling wrapped functions. Thus, enhancing robustness here is crucial. The amendment should not alter the core functionality intended by these compatibility layers but should ensure they are fault-tolerant to differences in object attributes, particularly `__wrapped__`.</intended_behavior>]
2025-10-18 04:48:24.613 | INFO     | Search completed. Bug locations: [<file>testing/python/integration.py</file>
<class>None</class>
<method>None</method>
<code>
1 import pytest
2 from _pytest import python
3 from _pytest import runner
4 
5 
6 class TestOEJSKITSpecials:
7     def test_funcarg_non_pycollectobj(self, testdir):  # rough jstests usage
8         testdir.makeconftest(
9             """
10             import pytest
11             def pytest_pycollect_makeitem(collector, name, obj):
12                 if name == "MyClass":
13                     return MyCollector(name, parent=collector)
14             class MyCollector(pytest.Collector):
15                 def reportinfo(self):
16                     return self.fspath, 3, "xyz"
17         """
18         )
19         modcol = testdir.getmodulecol(
20             """
21             import pytest
22             @pytest.fixture
23             def arg1(request):
24                 return 42
25             class MyClass(object):
26                 pass
27         """
28         )
29         # this hook finds funcarg factories
30         rep = runner.collect_one_node(collector=modcol)
31         clscol = rep.result[0]
32         clscol.obj = lambda arg1: None
33         clscol.funcargs = {}
34         pytest._fillfuncargs(clscol)
35         assert clscol.funcargs["arg1"] == 42
36 
37     def test_autouse_fixture(self, testdir):  # rough jstests usage
38         testdir.makeconftest(
39             """
40             import pytest
41             def pytest_pycollect_makeitem(collector, name, obj):
42                 if name == "MyClass":
43                     return MyCollector(name, parent=collector)
44             class MyCollector(pytest.Collector):
45                 def reportinfo(self):
46                     return self.fspath, 3, "xyz"
47         """
48         )
49         modcol = testdir.getmodulecol(
50             """
51             import pytest
52             @pytest.fixture(autouse=True)
53             def hello():
54                 pass
55             @pytest.fixture
56             def arg1(request):
57                 return 42
58             class MyClass(object):
59                 pass
60         """
61         )
62         # this hook finds funcarg factories
63         rep = runner.collect_one_node(modcol)
64         clscol = rep.result[0]
65         clscol.obj = lambda: None
66         clscol.funcargs = {}
67         pytest._fillfuncargs(clscol)
68         assert not clscol.funcargs
69 
70 
71 def test_wrapped_getfslineno():
72     def func():
73         pass
74 
75     def wrap(f):
76         func.__wrapped__ = f
77         func.patchings = ["qwe"]
78         return func
79 
80     @wrap
81     def wrapped_func(x, y, z):
82         pass
83 
84     fs, lineno = python.getfslineno(wrapped_func)
85     fs2, lineno2 = python.getfslineno(wrap)
86     assert lineno > lineno2, "getfslineno does not unwrap correctly"
87 
88 
89 class TestMockDecoration:
90     def test_wrapped_getfuncargnames(self):
91         from _pytest.compat import getfuncargnames
92 
93         def wrap(f):
94             def func():
95                 pass
96 
97             func.__wrapped__ = f
98             return func
99 
100         @wrap
101         def f(x):
102             pass
103 
104         values = getfuncargnames(f)
105         assert values == ("x",)
106 
107     @pytest.mark.xfail(
108         strict=False, reason="getfuncargnames breaks if mock is imported"
109     )
110     def test_wrapped_getfuncargnames_patching(self):
111         from _pytest.compat import getfuncargnames
112 
113         def wrap(f):
114             def func():
115                 pass
116 
117             func.__wrapped__ = f
118             func.patchings = ["qwe"]
119             return func
120 
121         @wrap
122         def f(x, y, z):
123             pass
124 
125         values = getfuncargnames(f)
126         assert values == ("y", "z")
127 
128     def test_unittest_mock(self, testdir):
129         pytest.importorskip("unittest.mock")
130         testdir.makepyfile(
131             """
132             import unittest.mock
133             class T(unittest.TestCase):
134                 @unittest.mock.patch("os.path.abspath")
135                 def test_hello(self, abspath):
136                     import os
137                     os.path.abspath("hello")
138                     abspath.assert_any_call("hello")
139         """
140         )
141         reprec = testdir.inline_run()
142         reprec.assertoutcome(passed=1)
143 
144     def test_unittest_mock_and_fixture(self, testdir):
145         pytest.importorskip("unittest.mock")
146         testdir.makepyfile(
147             """
148             import os.path
149             import unittest.mock
150             import pytest
151 
152             @pytest.fixture
153             def inject_me():
154                 pass
155 
156             @unittest.mock.patch.object(os.path, "abspath",
157                                         new=unittest.mock.MagicMock)
158             def test_hello(inject_me):
159                 import os
160                 os.path.abspath("hello")
161         """
162         )
163         reprec = testdir.inline_run()
164         reprec.assertoutcome(passed=1)
165 
166     def test_unittest_mock_and_pypi_mock(self, testdir):
167         pytest.importorskip("unittest.mock")
168         pytest.importorskip("mock", "1.0.1")
169         testdir.makepyfile(
170             """
171             import mock
172             import unittest.mock
173             class TestBoth(object):
174                 @unittest.mock.patch("os.path.abspath")
175                 def test_hello(self, abspath):
176                     import os
177                     os.path.abspath("hello")
178                     abspath.assert_any_call("hello")
179 
180                 @mock.patch("os.path.abspath")
181                 def test_hello_mock(self, abspath):
182                     import os
183                     os.path.abspath("hello")
184                     abspath.assert_any_call("hello")
185         """
186         )
187         reprec = testdir.inline_run()
188         reprec.assertoutcome(passed=2)
189 
190     def test_mock(self, testdir):
191         pytest.importorskip("mock", "1.0.1")
192         testdir.makepyfile(
193             """
194             import os
195             import unittest
196             import mock
197 
198             class T(unittest.TestCase):
199                 @mock.patch("os.path.abspath")
200                 def test_hello(self, abspath):
201                     os.path.abspath("hello")
202                     abspath.assert_any_call("hello")
203             def mock_basename(path):
204                 return "mock_basename"
205             @mock.patch("os.path.abspath")
206             @mock.patch("os.path.normpath")
207             @mock.patch("os.path.basename", new=mock_basename)
208             def test_someting(normpath, abspath, tmpdir):
209                 abspath.return_value = "this"
210                 os.path.normpath(os.path.abspath("hello"))
211                 normpath.assert_any_call("this")
212                 assert os.path.basename("123") == "mock_basename"
213         """
214         )
215         reprec = testdir.inline_run()
216         reprec.assertoutcome(passed=2)
217         calls = reprec.getcalls("pytest_runtest_logreport")
218         funcnames = [
219             call.report.location[2] for call in calls if call.report.when == "call"
220         ]
221         assert funcnames == ["T.test_hello", "test_someting"]
222 
223     def test_mock_sorting(self, testdir):
224         pytest.importorskip("mock", "1.0.1")
225         testdir.makepyfile(
226             """
227             import os
228             import mock
229 
230             @mock.patch("os.path.abspath")
231             def test_one(abspath):
232                 pass
233             @mock.patch("os.path.abspath")
234             def test_two(abspath):
235                 pass
236             @mock.patch("os.path.abspath")
237             def test_three(abspath):
238                 pass
239         """
240         )
241         reprec = testdir.inline_run()
242         calls = reprec.getreports("pytest_runtest_logreport")
243         calls = [x for x in calls if x.when == "call"]
244         names = [x.nodeid.split("::")[-1] for x in calls]
245         assert names == ["test_one", "test_two", "test_three"]
246 
247     def test_mock_double_patch_issue473(self, testdir):
248         pytest.importorskip("mock", "1.0.1")
249         testdir.makepyfile(
250             """
251             from mock import patch
252             from pytest import mark
253 
254             @patch('os.getcwd')
255             @patch('os.path')
256             @mark.slow
257             class TestSimple(object):
258                 def test_simple_thing(self, mock_path, mock_getcwd):
259                     pass
260         """
261         )
262         reprec = testdir.inline_run()
263         reprec.assertoutcome(passed=1)
264 
265 
266 class TestReRunTests:
267     def test_rerun(self, testdir):
268         testdir.makeconftest(
269             """
270             from _pytest.runner import runtestprotocol
271             def pytest_runtest_protocol(item, nextitem):
272                 runtestprotocol(item, log=False, nextitem=nextitem)
273                 runtestprotocol(item, log=True, nextitem=nextitem)
274         """
275         )
276         testdir.makepyfile(
277             """
278             import pytest
279             count = 0
280             req = None
281             @pytest.fixture
282             def fix(request):
283                 global count, req
284                 assert request != req
285                 req = request
286                 print("fix count %s" % count)
287                 count += 1
288             def test_fix(fix):
289                 pass
290         """
291         )
292         result = testdir.runpytest("-s")
293         result.stdout.fnmatch_lines(
294             """
295             *fix count 0*
296             *fix count 1*
297         """
298         )
299         result.stdout.fnmatch_lines(
300             """
301             *2 passed*
302         """
303         )
304 
305 
306 def test_pytestconfig_is_session_scoped():
307     from _pytest.fixtures import pytestconfig
308 
309     assert pytestconfig._pytestfixturefunction.scope == "session"
310 
311 
312 class TestNoselikeTestAttribute:
313     def test_module_with_global_test(self, testdir):
314         testdir.makepyfile(
315             """
316             __test__ = False
317             def test_hello():
318                 pass
319         """
320         )
321         reprec = testdir.inline_run()
322         assert not reprec.getfailedcollections()
323         calls = reprec.getreports("pytest_runtest_logreport")
324         assert not calls
325 
326     def test_class_and_method(self, testdir):
327         testdir.makepyfile(
328             """
329             __test__ = True
330             def test_func():
331                 pass
332             test_func.__test__ = False
333 
334             class TestSome(object):
335                 __test__ = False
336                 def test_method(self):
337                     pass
338         """
339         )
340         reprec = testdir.inline_run()
341         assert not reprec.getfailedcollections()
342         calls = reprec.getreports("pytest_runtest_logreport")
343         assert not calls
344 
345     def test_unittest_class(self, testdir):
346         testdir.makepyfile(
347             """
348             import unittest
349             class TC(unittest.TestCase):
350                 def test_1(self):
351                     pass
352             class TC2(unittest.TestCase):
353                 __test__ = False
354                 def test_2(self):
355                     pass
356         """
357         )
358         reprec = testdir.inline_run()
359         assert not reprec.getfailedcollections()
360         call = reprec.getcalls("pytest_collection_modifyitems")[0]
361         assert len(call.items) == 1
362         assert call.items[0].cls.__name__ == "TC"
363 
364     def test_class_with_nasty_getattr(self, testdir):
365         """Make sure we handle classes with a custom nasty __getattr__ right.
366 
367         With a custom __getattr__ which e.g. returns a function (like with a
368         RPC wrapper), we shouldn't assume this meant "__test__ = True".
369         """
370         # https://github.com/pytest-dev/pytest/issues/1204
371         testdir.makepyfile(
372             """
373             class MetaModel(type):
374 
375                 def __getattr__(cls, key):
376                     return lambda: None
377 
378 
379             BaseModel = MetaModel('Model', (), {})
380 
381 
382             class Model(BaseModel):
383 
384                 __metaclass__ = MetaModel
385 
386                 def test_blah(self):
387                     pass
388         """
389         )
390         reprec = testdir.inline_run()
391         assert not reprec.getfailedcollections()
392         call = reprec.getcalls("pytest_collection_modifyitems")[0]
393         assert not call.items
394 
395 
396 class TestParameterize:
397     """#351"""
398 
399     def test_idfn_marker(self, testdir):
400         testdir.makepyfile(
401             """
402             import pytest
403 
404             def idfn(param):
405                 if param == 0:
406                     return 'spam'
407                 elif param == 1:
408                     return 'ham'
409                 else:
410                     return None
411 
412             @pytest.mark.parametrize('a,b', [(0, 2), (1, 2)], ids=idfn)
413             def test_params(a, b):
414                 pass
415         """
416         )
417         res = testdir.runpytest("--collect-only")
418         res.stdout.fnmatch_lines(["*spam-2*", "*ham-2*"])
419 
420     def test_idfn_fixture(self, testdir):
421         testdir.makepyfile(
422             """
423             import pytest
424 
425             def idfn(param):
426                 if param == 0:
427                     return 'spam'
428                 elif param == 1:
429                     return 'ham'
430                 else:
431                     return None
432 
433             @pytest.fixture(params=[0, 1], ids=idfn)
434             def a(request):
435                 return request.param
436 
437             @pytest.fixture(params=[1, 2], ids=idfn)
438             def b(request):
439                 return request.param
440 
441             def test_params(a, b):
442                 pass
443         """
444         )
445         res = testdir.runpytest("--collect-only")
446         res.stdout.fnmatch_lines(["*spam-2*", "*ham-2*"])

</code><intended_behavior>The code that accesses `__wrapped__` should first check if the attribute exists. This could be implemented by either using `getattr` with a default value or explicitly checking the presence of the `__wrapped__` attribute on an object before accessing it. This adjustment is necessary to prevent `KeyError` when the attribute is not present on an object that is being inspected during the test collection or execution process. The existing functionality, which likely aims to introspect or modify test functions (potentially for unwrapping decorators), should be preserved while making it robust against the absence of `__wrapped__`.</intended_behavior>, <file>src/_pytest/compat.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2 python version compatibility code
3 """
4 import functools
5 import inspect
6 import io
7 import re
8 import sys
9 from contextlib import contextmanager
10 from inspect import Parameter
11 from inspect import signature
12 
13 import py
14 
15 import _pytest
16 from _pytest._io.saferepr import saferepr
17 from _pytest.outcomes import fail
18 from _pytest.outcomes import TEST_OUTCOME
19 
20 
21 NOTSET = object()
22 
23 MODULE_NOT_FOUND_ERROR = (
24     "ModuleNotFoundError" if sys.version_info[:2] >= (3, 6) else "ImportError"
25 )
26 
27 
28 def _format_args(func):
29     return str(signature(func))
30 
31 
32 isfunction = inspect.isfunction
33 isclass = inspect.isclass
34 # used to work around a python2 exception info leak
35 exc_clear = getattr(sys, "exc_clear", lambda: None)
36 # The type of re.compile objects is not exposed in Python.
37 REGEX_TYPE = type(re.compile(""))
38 
39 
40 def is_generator(func):
41     genfunc = inspect.isgeneratorfunction(func)
42     return genfunc and not iscoroutinefunction(func)
43 
44 
45 def iscoroutinefunction(func):
46     """Return True if func is a decorated coroutine function.
47 
48     Note: copied and modified from Python 3.5's builtin couroutines.py to avoid import asyncio directly,
49     which in turns also initializes the "logging" module as side-effect (see issue #8).
50     """
51     return getattr(func, "_is_coroutine", False) or (
52         hasattr(inspect, "iscoroutinefunction") and inspect.iscoroutinefunction(func)
53     )
54 
55 
56 def getlocation(function, curdir):
57     function = get_real_func(function)
58     fn = py.path.local(inspect.getfile(function))
59     lineno = function.__code__.co_firstlineno
60     if fn.relto(curdir):
61         fn = fn.relto(curdir)
62     return "%s:%d" % (fn, lineno + 1)
63 
64 
65 def num_mock_patch_args(function):
66     """ return number of arguments used up by mock arguments (if any) """
67     patchings = getattr(function, "patchings", None)
68     if not patchings:
69         return 0
70     mock_modules = [sys.modules.get("mock"), sys.modules.get("unittest.mock")]
71     if any(mock_modules):
72         sentinels = [m.DEFAULT for m in mock_modules if m is not None]
73         return len(
74             [p for p in patchings if not p.attribute_name and p.new in sentinels]
75         )
76     return len(patchings)
77 
78 
79 def getfuncargnames(function, is_method=False, cls=None):
80     """Returns the names of a function's mandatory arguments.
81 
82     This should return the names of all function arguments that:
83         * Aren't bound to an instance or type as in instance or class methods.
84         * Don't have default values.
85         * Aren't bound with functools.partial.
86         * Aren't replaced with mocks.
87 
88     The is_method and cls arguments indicate that the function should
89     be treated as a bound method even though it's not unless, only in
90     the case of cls, the function is a static method.
91 
92     @RonnyPfannschmidt: This function should be refactored when we
93     revisit fixtures. The fixture mechanism should ask the node for
94     the fixture names, and not try to obtain directly from the
95     function object well after collection has occurred.
96 
97     """
98     # The parameters attribute of a Signature object contains an
99     # ordered mapping of parameter names to Parameter instances.  This
100     # creates a tuple of the names of the parameters that don't have
101     # defaults.
102     try:
103         parameters = signature(function).parameters
104     except (ValueError, TypeError) as e:
105         fail(
106             "Could not determine arguments of {!r}: {}".format(function, e),
107             pytrace=False,
108         )
109 
110     arg_names = tuple(
111         p.name
112         for p in parameters.values()
113         if (
114             p.kind is Parameter.POSITIONAL_OR_KEYWORD
115             or p.kind is Parameter.KEYWORD_ONLY
116         )
117         and p.default is Parameter.empty
118     )
119     # If this function should be treated as a bound method even though
120     # it's passed as an unbound method or function, remove the first
121     # parameter name.
122     if is_method or (
123         cls and not isinstance(cls.__dict__.get(function.__name__, None), staticmethod)
124     ):
125         arg_names = arg_names[1:]
126     # Remove any names that will be replaced with mocks.
127     if hasattr(function, "__wrapped__"):
128         arg_names = arg_names[num_mock_patch_args(function) :]
129     return arg_names
130 
131 
132 @contextmanager
133 def dummy_context_manager():
134     """Context manager that does nothing, useful in situations where you might need an actual context manager or not
135     depending on some condition. Using this allow to keep the same code"""
136     yield
137 
138 
139 def get_default_arg_names(function):
140     # Note: this code intentionally mirrors the code at the beginning of getfuncargnames,
141     # to get the arguments which were excluded from its result because they had default values
142     return tuple(
143         p.name
144         for p in signature(function).parameters.values()
145         if p.kind in (Parameter.POSITIONAL_OR_KEYWORD, Parameter.KEYWORD_ONLY)
146         and p.default is not Parameter.empty
147     )
148 
149 
150 _non_printable_ascii_translate_table = {
151     i: "\\x{:02x}".format(i) for i in range(128) if i not in range(32, 127)
152 }
153 _non_printable_ascii_translate_table.update(
154     {ord("\t"): "\\t", ord("\r"): "\\r", ord("\n"): "\\n"}
155 )
156 
157 
158 def _translate_non_printable(s):
159     return s.translate(_non_printable_ascii_translate_table)
160 
161 
162 STRING_TYPES = bytes, str
163 
164 
165 def _bytes_to_ascii(val):
166     return val.decode("ascii", "backslashreplace")
167 
168 
169 def ascii_escaped(val):
170     """If val is pure ascii, returns it as a str().  Otherwise, escapes
171     bytes objects into a sequence of escaped bytes:
172 
173     b'\xc3\xb4\xc5\xd6' -> '\\xc3\\xb4\\xc5\\xd6'
174 
175     and escapes unicode objects into a sequence of escaped unicode
176     ids, e.g.:
177 
178     '4\\nV\\U00043efa\\x0eMXWB\\x1e\\u3028\\u15fd\\xcd\\U0007d944'
179 
180     note:
181        the obvious "v.decode('unicode-escape')" will return
182        valid utf-8 unicode if it finds them in bytes, but we
183        want to return escaped bytes for any byte, even if they match
184        a utf-8 string.
185 
186     """
187     if isinstance(val, bytes):
188         ret = _bytes_to_ascii(val)
189     else:
190         ret = val.encode("unicode_escape").decode("ascii")
191     return _translate_non_printable(ret)
192 
193 
194 class _PytestWrapper:
195     """Dummy wrapper around a function object for internal use only.
196 
197     Used to correctly unwrap the underlying function object
198     when we are creating fixtures, because we wrap the function object ourselves with a decorator
199     to issue warnings when the fixture function is called directly.
200     """
201 
202     def __init__(self, obj):
203         self.obj = obj
204 
205 
206 def get_real_func(obj):
207     """ gets the real function object of the (possibly) wrapped object by
208     functools.wraps or functools.partial.
209     """
210     start_obj = obj
211     for i in range(100):
212         # __pytest_wrapped__ is set by @pytest.fixture when wrapping the fixture function
213         # to trigger a warning if it gets called directly instead of by pytest: we don't
214         # want to unwrap further than this otherwise we lose useful wrappings like @mock.patch (#3774)
215         new_obj = getattr(obj, "__pytest_wrapped__", None)
216         if isinstance(new_obj, _PytestWrapper):
217             obj = new_obj.obj
218             break
219         new_obj = getattr(obj, "__wrapped__", None)
220         if new_obj is None:
221             break
222         obj = new_obj
223     else:
224         raise ValueError(
225             ("could not find real function of {start}\nstopped at {current}").format(
226                 start=saferepr(start_obj), current=saferepr(obj)
227             )
228         )
229     if isinstance(obj, functools.partial):
230         obj = obj.func
231     return obj
232 
233 
234 def get_real_method(obj, holder):
235     """
236     Attempts to obtain the real function object that might be wrapping ``obj``, while at the same time
237     returning a bound method to ``holder`` if the original object was a bound method.
238     """
239     try:
240         is_method = hasattr(obj, "__func__")
241         obj = get_real_func(obj)
242     except Exception:
243         return obj
244     if is_method and hasattr(obj, "__get__") and callable(obj.__get__):
245         obj = obj.__get__(holder)
246     return obj
247 
248 
249 def getfslineno(obj):
250     # xxx let decorators etc specify a sane ordering
251     obj = get_real_func(obj)
252     if hasattr(obj, "place_as"):
253         obj = obj.place_as
254     fslineno = _pytest._code.getfslineno(obj)
255     assert isinstance(fslineno[1], int), obj
256     return fslineno
257 
258 
259 def getimfunc(func):
260     try:
261         return func.__func__
262     except AttributeError:
263         return func
264 
265 
266 def safe_getattr(object, name, default):
267     """ Like getattr but return default upon any Exception or any OutcomeException.
268 
269     Attribute access can potentially fail for 'evil' Python objects.
270     See issue #214.
271     It catches OutcomeException because of #2490 (issue #580), new outcomes are derived from BaseException
272     instead of Exception (for more details check #2707)
273     """
274     try:
275         return getattr(object, name, default)
276     except TEST_OUTCOME:
277         return default
278 
279 
280 def safe_isclass(obj):
281     """Ignore any exception via isinstance on Python 3."""
282     try:
283         return isclass(obj)
284     except Exception:
285         return False
286 
287 
288 COLLECT_FAKEMODULE_ATTRIBUTES = (
289     "Collector",
290     "Module",
291     "Function",
292     "Instance",
293     "Session",
294     "Item",
295     "Class",
296     "File",
297     "_fillfuncargs",
298 )
299 
300 
301 def _setup_collect_fakemodule():
302     from types import ModuleType
303     import pytest
304 
305     pytest.collect = ModuleType("pytest.collect")
306     pytest.collect.__all__ = []  # used for setns
307     for attr in COLLECT_FAKEMODULE_ATTRIBUTES:
308         setattr(pytest.collect, attr, getattr(pytest, attr))
309 
310 
311 class CaptureIO(io.TextIOWrapper):
312     def __init__(self):
313         super().__init__(io.BytesIO(), encoding="UTF-8", newline="", write_through=True)
314 
315     def getvalue(self):
316         return self.buffer.getvalue().decode("UTF-8")
317 
318 
319 class FuncargnamesCompatAttr:
320     """ helper class so that Metafunc, Function and FixtureRequest
321     don't need to each define the "funcargnames" compatibility attribute.
322     """
323 
324     @property
325     def funcargnames(self):
326         """ alias attribute for ``fixturenames`` for pre-2.3 compatibility"""
327         return self.fixturenames

</code><intended_behavior>The code related to function unwrapping or manipulation that uses `__wrapped__` should implement safer access patterns. As in the previous location, using `getattr(obj, '__wrapped__', default)` or a similar check will ensure that `KeyError` is not raised. This file's role in smoothing over compatibility issues suggests it might be dealing with a variety of Python versions and their nuances in handling wrapped functions. Thus, enhancing robustness here is crucial. The amendment should not alter the core functionality intended by these compatibility layers but should ensure they are fault-tolerant to differences in object attributes, particularly `__wrapped__`.</intended_behavior>]
2025-10-18 04:48:24.613 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-18 04:48:24.613 | INFO     | Search-only: skipping patch selection
2025-10-18 04:48:24.695 | INFO     | Task pytest-dev__pytest-5404 completed successfully.
2025-10-18 04:48:24.696 | INFO     | No patch generated. You can try running ACR again.
