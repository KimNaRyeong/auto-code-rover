[
    {
        "rel_file_path": "testing/python/integration.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/pytest-dev__pytest/setup_pytest-dev__pytest__4.6/testing/python/integration.py",
        "start": 1,
        "end": 446,
        "class_name": null,
        "method_name": null,
        "code": "1 import pytest\n2 from _pytest import python\n3 from _pytest import runner\n4 \n5 \n6 class TestOEJSKITSpecials:\n7     def test_funcarg_non_pycollectobj(self, testdir):  # rough jstests usage\n8         testdir.makeconftest(\n9             \"\"\"\n10             import pytest\n11             def pytest_pycollect_makeitem(collector, name, obj):\n12                 if name == \"MyClass\":\n13                     return MyCollector(name, parent=collector)\n14             class MyCollector(pytest.Collector):\n15                 def reportinfo(self):\n16                     return self.fspath, 3, \"xyz\"\n17         \"\"\"\n18         )\n19         modcol = testdir.getmodulecol(\n20             \"\"\"\n21             import pytest\n22             @pytest.fixture\n23             def arg1(request):\n24                 return 42\n25             class MyClass(object):\n26                 pass\n27         \"\"\"\n28         )\n29         # this hook finds funcarg factories\n30         rep = runner.collect_one_node(collector=modcol)\n31         clscol = rep.result[0]\n32         clscol.obj = lambda arg1: None\n33         clscol.funcargs = {}\n34         pytest._fillfuncargs(clscol)\n35         assert clscol.funcargs[\"arg1\"] == 42\n36 \n37     def test_autouse_fixture(self, testdir):  # rough jstests usage\n38         testdir.makeconftest(\n39             \"\"\"\n40             import pytest\n41             def pytest_pycollect_makeitem(collector, name, obj):\n42                 if name == \"MyClass\":\n43                     return MyCollector(name, parent=collector)\n44             class MyCollector(pytest.Collector):\n45                 def reportinfo(self):\n46                     return self.fspath, 3, \"xyz\"\n47         \"\"\"\n48         )\n49         modcol = testdir.getmodulecol(\n50             \"\"\"\n51             import pytest\n52             @pytest.fixture(autouse=True)\n53             def hello():\n54                 pass\n55             @pytest.fixture\n56             def arg1(request):\n57                 return 42\n58             class MyClass(object):\n59                 pass\n60         \"\"\"\n61         )\n62         # this hook finds funcarg factories\n63         rep = runner.collect_one_node(modcol)\n64         clscol = rep.result[0]\n65         clscol.obj = lambda: None\n66         clscol.funcargs = {}\n67         pytest._fillfuncargs(clscol)\n68         assert not clscol.funcargs\n69 \n70 \n71 def test_wrapped_getfslineno():\n72     def func():\n73         pass\n74 \n75     def wrap(f):\n76         func.__wrapped__ = f\n77         func.patchings = [\"qwe\"]\n78         return func\n79 \n80     @wrap\n81     def wrapped_func(x, y, z):\n82         pass\n83 \n84     fs, lineno = python.getfslineno(wrapped_func)\n85     fs2, lineno2 = python.getfslineno(wrap)\n86     assert lineno > lineno2, \"getfslineno does not unwrap correctly\"\n87 \n88 \n89 class TestMockDecoration:\n90     def test_wrapped_getfuncargnames(self):\n91         from _pytest.compat import getfuncargnames\n92 \n93         def wrap(f):\n94             def func():\n95                 pass\n96 \n97             func.__wrapped__ = f\n98             return func\n99 \n100         @wrap\n101         def f(x):\n102             pass\n103 \n104         values = getfuncargnames(f)\n105         assert values == (\"x\",)\n106 \n107     @pytest.mark.xfail(\n108         strict=False, reason=\"getfuncargnames breaks if mock is imported\"\n109     )\n110     def test_wrapped_getfuncargnames_patching(self):\n111         from _pytest.compat import getfuncargnames\n112 \n113         def wrap(f):\n114             def func():\n115                 pass\n116 \n117             func.__wrapped__ = f\n118             func.patchings = [\"qwe\"]\n119             return func\n120 \n121         @wrap\n122         def f(x, y, z):\n123             pass\n124 \n125         values = getfuncargnames(f)\n126         assert values == (\"y\", \"z\")\n127 \n128     def test_unittest_mock(self, testdir):\n129         pytest.importorskip(\"unittest.mock\")\n130         testdir.makepyfile(\n131             \"\"\"\n132             import unittest.mock\n133             class T(unittest.TestCase):\n134                 @unittest.mock.patch(\"os.path.abspath\")\n135                 def test_hello(self, abspath):\n136                     import os\n137                     os.path.abspath(\"hello\")\n138                     abspath.assert_any_call(\"hello\")\n139         \"\"\"\n140         )\n141         reprec = testdir.inline_run()\n142         reprec.assertoutcome(passed=1)\n143 \n144     def test_unittest_mock_and_fixture(self, testdir):\n145         pytest.importorskip(\"unittest.mock\")\n146         testdir.makepyfile(\n147             \"\"\"\n148             import os.path\n149             import unittest.mock\n150             import pytest\n151 \n152             @pytest.fixture\n153             def inject_me():\n154                 pass\n155 \n156             @unittest.mock.patch.object(os.path, \"abspath\",\n157                                         new=unittest.mock.MagicMock)\n158             def test_hello(inject_me):\n159                 import os\n160                 os.path.abspath(\"hello\")\n161         \"\"\"\n162         )\n163         reprec = testdir.inline_run()\n164         reprec.assertoutcome(passed=1)\n165 \n166     def test_unittest_mock_and_pypi_mock(self, testdir):\n167         pytest.importorskip(\"unittest.mock\")\n168         pytest.importorskip(\"mock\", \"1.0.1\")\n169         testdir.makepyfile(\n170             \"\"\"\n171             import mock\n172             import unittest.mock\n173             class TestBoth(object):\n174                 @unittest.mock.patch(\"os.path.abspath\")\n175                 def test_hello(self, abspath):\n176                     import os\n177                     os.path.abspath(\"hello\")\n178                     abspath.assert_any_call(\"hello\")\n179 \n180                 @mock.patch(\"os.path.abspath\")\n181                 def test_hello_mock(self, abspath):\n182                     import os\n183                     os.path.abspath(\"hello\")\n184                     abspath.assert_any_call(\"hello\")\n185         \"\"\"\n186         )\n187         reprec = testdir.inline_run()\n188         reprec.assertoutcome(passed=2)\n189 \n190     def test_mock(self, testdir):\n191         pytest.importorskip(\"mock\", \"1.0.1\")\n192         testdir.makepyfile(\n193             \"\"\"\n194             import os\n195             import unittest\n196             import mock\n197 \n198             class T(unittest.TestCase):\n199                 @mock.patch(\"os.path.abspath\")\n200                 def test_hello(self, abspath):\n201                     os.path.abspath(\"hello\")\n202                     abspath.assert_any_call(\"hello\")\n203             def mock_basename(path):\n204                 return \"mock_basename\"\n205             @mock.patch(\"os.path.abspath\")\n206             @mock.patch(\"os.path.normpath\")\n207             @mock.patch(\"os.path.basename\", new=mock_basename)\n208             def test_someting(normpath, abspath, tmpdir):\n209                 abspath.return_value = \"this\"\n210                 os.path.normpath(os.path.abspath(\"hello\"))\n211                 normpath.assert_any_call(\"this\")\n212                 assert os.path.basename(\"123\") == \"mock_basename\"\n213         \"\"\"\n214         )\n215         reprec = testdir.inline_run()\n216         reprec.assertoutcome(passed=2)\n217         calls = reprec.getcalls(\"pytest_runtest_logreport\")\n218         funcnames = [\n219             call.report.location[2] for call in calls if call.report.when == \"call\"\n220         ]\n221         assert funcnames == [\"T.test_hello\", \"test_someting\"]\n222 \n223     def test_mock_sorting(self, testdir):\n224         pytest.importorskip(\"mock\", \"1.0.1\")\n225         testdir.makepyfile(\n226             \"\"\"\n227             import os\n228             import mock\n229 \n230             @mock.patch(\"os.path.abspath\")\n231             def test_one(abspath):\n232                 pass\n233             @mock.patch(\"os.path.abspath\")\n234             def test_two(abspath):\n235                 pass\n236             @mock.patch(\"os.path.abspath\")\n237             def test_three(abspath):\n238                 pass\n239         \"\"\"\n240         )\n241         reprec = testdir.inline_run()\n242         calls = reprec.getreports(\"pytest_runtest_logreport\")\n243         calls = [x for x in calls if x.when == \"call\"]\n244         names = [x.nodeid.split(\"::\")[-1] for x in calls]\n245         assert names == [\"test_one\", \"test_two\", \"test_three\"]\n246 \n247     def test_mock_double_patch_issue473(self, testdir):\n248         pytest.importorskip(\"mock\", \"1.0.1\")\n249         testdir.makepyfile(\n250             \"\"\"\n251             from mock import patch\n252             from pytest import mark\n253 \n254             @patch('os.getcwd')\n255             @patch('os.path')\n256             @mark.slow\n257             class TestSimple(object):\n258                 def test_simple_thing(self, mock_path, mock_getcwd):\n259                     pass\n260         \"\"\"\n261         )\n262         reprec = testdir.inline_run()\n263         reprec.assertoutcome(passed=1)\n264 \n265 \n266 class TestReRunTests:\n267     def test_rerun(self, testdir):\n268         testdir.makeconftest(\n269             \"\"\"\n270             from _pytest.runner import runtestprotocol\n271             def pytest_runtest_protocol(item, nextitem):\n272                 runtestprotocol(item, log=False, nextitem=nextitem)\n273                 runtestprotocol(item, log=True, nextitem=nextitem)\n274         \"\"\"\n275         )\n276         testdir.makepyfile(\n277             \"\"\"\n278             import pytest\n279             count = 0\n280             req = None\n281             @pytest.fixture\n282             def fix(request):\n283                 global count, req\n284                 assert request != req\n285                 req = request\n286                 print(\"fix count %s\" % count)\n287                 count += 1\n288             def test_fix(fix):\n289                 pass\n290         \"\"\"\n291         )\n292         result = testdir.runpytest(\"-s\")\n293         result.stdout.fnmatch_lines(\n294             \"\"\"\n295             *fix count 0*\n296             *fix count 1*\n297         \"\"\"\n298         )\n299         result.stdout.fnmatch_lines(\n300             \"\"\"\n301             *2 passed*\n302         \"\"\"\n303         )\n304 \n305 \n306 def test_pytestconfig_is_session_scoped():\n307     from _pytest.fixtures import pytestconfig\n308 \n309     assert pytestconfig._pytestfixturefunction.scope == \"session\"\n310 \n311 \n312 class TestNoselikeTestAttribute:\n313     def test_module_with_global_test(self, testdir):\n314         testdir.makepyfile(\n315             \"\"\"\n316             __test__ = False\n317             def test_hello():\n318                 pass\n319         \"\"\"\n320         )\n321         reprec = testdir.inline_run()\n322         assert not reprec.getfailedcollections()\n323         calls = reprec.getreports(\"pytest_runtest_logreport\")\n324         assert not calls\n325 \n326     def test_class_and_method(self, testdir):\n327         testdir.makepyfile(\n328             \"\"\"\n329             __test__ = True\n330             def test_func():\n331                 pass\n332             test_func.__test__ = False\n333 \n334             class TestSome(object):\n335                 __test__ = False\n336                 def test_method(self):\n337                     pass\n338         \"\"\"\n339         )\n340         reprec = testdir.inline_run()\n341         assert not reprec.getfailedcollections()\n342         calls = reprec.getreports(\"pytest_runtest_logreport\")\n343         assert not calls\n344 \n345     def test_unittest_class(self, testdir):\n346         testdir.makepyfile(\n347             \"\"\"\n348             import unittest\n349             class TC(unittest.TestCase):\n350                 def test_1(self):\n351                     pass\n352             class TC2(unittest.TestCase):\n353                 __test__ = False\n354                 def test_2(self):\n355                     pass\n356         \"\"\"\n357         )\n358         reprec = testdir.inline_run()\n359         assert not reprec.getfailedcollections()\n360         call = reprec.getcalls(\"pytest_collection_modifyitems\")[0]\n361         assert len(call.items) == 1\n362         assert call.items[0].cls.__name__ == \"TC\"\n363 \n364     def test_class_with_nasty_getattr(self, testdir):\n365         \"\"\"Make sure we handle classes with a custom nasty __getattr__ right.\n366 \n367         With a custom __getattr__ which e.g. returns a function (like with a\n368         RPC wrapper), we shouldn't assume this meant \"__test__ = True\".\n369         \"\"\"\n370         # https://github.com/pytest-dev/pytest/issues/1204\n371         testdir.makepyfile(\n372             \"\"\"\n373             class MetaModel(type):\n374 \n375                 def __getattr__(cls, key):\n376                     return lambda: None\n377 \n378 \n379             BaseModel = MetaModel('Model', (), {})\n380 \n381 \n382             class Model(BaseModel):\n383 \n384                 __metaclass__ = MetaModel\n385 \n386                 def test_blah(self):\n387                     pass\n388         \"\"\"\n389         )\n390         reprec = testdir.inline_run()\n391         assert not reprec.getfailedcollections()\n392         call = reprec.getcalls(\"pytest_collection_modifyitems\")[0]\n393         assert not call.items\n394 \n395 \n396 class TestParameterize:\n397     \"\"\"#351\"\"\"\n398 \n399     def test_idfn_marker(self, testdir):\n400         testdir.makepyfile(\n401             \"\"\"\n402             import pytest\n403 \n404             def idfn(param):\n405                 if param == 0:\n406                     return 'spam'\n407                 elif param == 1:\n408                     return 'ham'\n409                 else:\n410                     return None\n411 \n412             @pytest.mark.parametrize('a,b', [(0, 2), (1, 2)], ids=idfn)\n413             def test_params(a, b):\n414                 pass\n415         \"\"\"\n416         )\n417         res = testdir.runpytest(\"--collect-only\")\n418         res.stdout.fnmatch_lines([\"*spam-2*\", \"*ham-2*\"])\n419 \n420     def test_idfn_fixture(self, testdir):\n421         testdir.makepyfile(\n422             \"\"\"\n423             import pytest\n424 \n425             def idfn(param):\n426                 if param == 0:\n427                     return 'spam'\n428                 elif param == 1:\n429                     return 'ham'\n430                 else:\n431                     return None\n432 \n433             @pytest.fixture(params=[0, 1], ids=idfn)\n434             def a(request):\n435                 return request.param\n436 \n437             @pytest.fixture(params=[1, 2], ids=idfn)\n438             def b(request):\n439                 return request.param\n440 \n441             def test_params(a, b):\n442                 pass\n443         \"\"\"\n444         )\n445         res = testdir.runpytest(\"--collect-only\")\n446         res.stdout.fnmatch_lines([\"*spam-2*\", \"*ham-2*\"])\n",
        "intended_behavior": "The code that accesses `__wrapped__` should first check if the attribute exists. This could be implemented by either using `getattr` with a default value or explicitly checking the presence of the `__wrapped__` attribute on an object before accessing it. This adjustment is necessary to prevent `KeyError` when the attribute is not present on an object that is being inspected during the test collection or execution process. The existing functionality, which likely aims to introspect or modify test functions (potentially for unwrapping decorators), should be preserved while making it robust against the absence of `__wrapped__`."
    },
    {
        "rel_file_path": "src/_pytest/compat.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/pytest-dev__pytest/setup_pytest-dev__pytest__4.6/src/_pytest/compat.py",
        "start": 1,
        "end": 327,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2 python version compatibility code\n3 \"\"\"\n4 import functools\n5 import inspect\n6 import io\n7 import re\n8 import sys\n9 from contextlib import contextmanager\n10 from inspect import Parameter\n11 from inspect import signature\n12 \n13 import py\n14 \n15 import _pytest\n16 from _pytest._io.saferepr import saferepr\n17 from _pytest.outcomes import fail\n18 from _pytest.outcomes import TEST_OUTCOME\n19 \n20 \n21 NOTSET = object()\n22 \n23 MODULE_NOT_FOUND_ERROR = (\n24     \"ModuleNotFoundError\" if sys.version_info[:2] >= (3, 6) else \"ImportError\"\n25 )\n26 \n27 \n28 def _format_args(func):\n29     return str(signature(func))\n30 \n31 \n32 isfunction = inspect.isfunction\n33 isclass = inspect.isclass\n34 # used to work around a python2 exception info leak\n35 exc_clear = getattr(sys, \"exc_clear\", lambda: None)\n36 # The type of re.compile objects is not exposed in Python.\n37 REGEX_TYPE = type(re.compile(\"\"))\n38 \n39 \n40 def is_generator(func):\n41     genfunc = inspect.isgeneratorfunction(func)\n42     return genfunc and not iscoroutinefunction(func)\n43 \n44 \n45 def iscoroutinefunction(func):\n46     \"\"\"Return True if func is a decorated coroutine function.\n47 \n48     Note: copied and modified from Python 3.5's builtin couroutines.py to avoid import asyncio directly,\n49     which in turns also initializes the \"logging\" module as side-effect (see issue #8).\n50     \"\"\"\n51     return getattr(func, \"_is_coroutine\", False) or (\n52         hasattr(inspect, \"iscoroutinefunction\") and inspect.iscoroutinefunction(func)\n53     )\n54 \n55 \n56 def getlocation(function, curdir):\n57     function = get_real_func(function)\n58     fn = py.path.local(inspect.getfile(function))\n59     lineno = function.__code__.co_firstlineno\n60     if fn.relto(curdir):\n61         fn = fn.relto(curdir)\n62     return \"%s:%d\" % (fn, lineno + 1)\n63 \n64 \n65 def num_mock_patch_args(function):\n66     \"\"\" return number of arguments used up by mock arguments (if any) \"\"\"\n67     patchings = getattr(function, \"patchings\", None)\n68     if not patchings:\n69         return 0\n70     mock_modules = [sys.modules.get(\"mock\"), sys.modules.get(\"unittest.mock\")]\n71     if any(mock_modules):\n72         sentinels = [m.DEFAULT for m in mock_modules if m is not None]\n73         return len(\n74             [p for p in patchings if not p.attribute_name and p.new in sentinels]\n75         )\n76     return len(patchings)\n77 \n78 \n79 def getfuncargnames(function, is_method=False, cls=None):\n80     \"\"\"Returns the names of a function's mandatory arguments.\n81 \n82     This should return the names of all function arguments that:\n83         * Aren't bound to an instance or type as in instance or class methods.\n84         * Don't have default values.\n85         * Aren't bound with functools.partial.\n86         * Aren't replaced with mocks.\n87 \n88     The is_method and cls arguments indicate that the function should\n89     be treated as a bound method even though it's not unless, only in\n90     the case of cls, the function is a static method.\n91 \n92     @RonnyPfannschmidt: This function should be refactored when we\n93     revisit fixtures. The fixture mechanism should ask the node for\n94     the fixture names, and not try to obtain directly from the\n95     function object well after collection has occurred.\n96 \n97     \"\"\"\n98     # The parameters attribute of a Signature object contains an\n99     # ordered mapping of parameter names to Parameter instances.  This\n100     # creates a tuple of the names of the parameters that don't have\n101     # defaults.\n102     try:\n103         parameters = signature(function).parameters\n104     except (ValueError, TypeError) as e:\n105         fail(\n106             \"Could not determine arguments of {!r}: {}\".format(function, e),\n107             pytrace=False,\n108         )\n109 \n110     arg_names = tuple(\n111         p.name\n112         for p in parameters.values()\n113         if (\n114             p.kind is Parameter.POSITIONAL_OR_KEYWORD\n115             or p.kind is Parameter.KEYWORD_ONLY\n116         )\n117         and p.default is Parameter.empty\n118     )\n119     # If this function should be treated as a bound method even though\n120     # it's passed as an unbound method or function, remove the first\n121     # parameter name.\n122     if is_method or (\n123         cls and not isinstance(cls.__dict__.get(function.__name__, None), staticmethod)\n124     ):\n125         arg_names = arg_names[1:]\n126     # Remove any names that will be replaced with mocks.\n127     if hasattr(function, \"__wrapped__\"):\n128         arg_names = arg_names[num_mock_patch_args(function) :]\n129     return arg_names\n130 \n131 \n132 @contextmanager\n133 def dummy_context_manager():\n134     \"\"\"Context manager that does nothing, useful in situations where you might need an actual context manager or not\n135     depending on some condition. Using this allow to keep the same code\"\"\"\n136     yield\n137 \n138 \n139 def get_default_arg_names(function):\n140     # Note: this code intentionally mirrors the code at the beginning of getfuncargnames,\n141     # to get the arguments which were excluded from its result because they had default values\n142     return tuple(\n143         p.name\n144         for p in signature(function).parameters.values()\n145         if p.kind in (Parameter.POSITIONAL_OR_KEYWORD, Parameter.KEYWORD_ONLY)\n146         and p.default is not Parameter.empty\n147     )\n148 \n149 \n150 _non_printable_ascii_translate_table = {\n151     i: \"\\\\x{:02x}\".format(i) for i in range(128) if i not in range(32, 127)\n152 }\n153 _non_printable_ascii_translate_table.update(\n154     {ord(\"\\t\"): \"\\\\t\", ord(\"\\r\"): \"\\\\r\", ord(\"\\n\"): \"\\\\n\"}\n155 )\n156 \n157 \n158 def _translate_non_printable(s):\n159     return s.translate(_non_printable_ascii_translate_table)\n160 \n161 \n162 STRING_TYPES = bytes, str\n163 \n164 \n165 def _bytes_to_ascii(val):\n166     return val.decode(\"ascii\", \"backslashreplace\")\n167 \n168 \n169 def ascii_escaped(val):\n170     \"\"\"If val is pure ascii, returns it as a str().  Otherwise, escapes\n171     bytes objects into a sequence of escaped bytes:\n172 \n173     b'\\xc3\\xb4\\xc5\\xd6' -> '\\\\xc3\\\\xb4\\\\xc5\\\\xd6'\n174 \n175     and escapes unicode objects into a sequence of escaped unicode\n176     ids, e.g.:\n177 \n178     '4\\\\nV\\\\U00043efa\\\\x0eMXWB\\\\x1e\\\\u3028\\\\u15fd\\\\xcd\\\\U0007d944'\n179 \n180     note:\n181        the obvious \"v.decode('unicode-escape')\" will return\n182        valid utf-8 unicode if it finds them in bytes, but we\n183        want to return escaped bytes for any byte, even if they match\n184        a utf-8 string.\n185 \n186     \"\"\"\n187     if isinstance(val, bytes):\n188         ret = _bytes_to_ascii(val)\n189     else:\n190         ret = val.encode(\"unicode_escape\").decode(\"ascii\")\n191     return _translate_non_printable(ret)\n192 \n193 \n194 class _PytestWrapper:\n195     \"\"\"Dummy wrapper around a function object for internal use only.\n196 \n197     Used to correctly unwrap the underlying function object\n198     when we are creating fixtures, because we wrap the function object ourselves with a decorator\n199     to issue warnings when the fixture function is called directly.\n200     \"\"\"\n201 \n202     def __init__(self, obj):\n203         self.obj = obj\n204 \n205 \n206 def get_real_func(obj):\n207     \"\"\" gets the real function object of the (possibly) wrapped object by\n208     functools.wraps or functools.partial.\n209     \"\"\"\n210     start_obj = obj\n211     for i in range(100):\n212         # __pytest_wrapped__ is set by @pytest.fixture when wrapping the fixture function\n213         # to trigger a warning if it gets called directly instead of by pytest: we don't\n214         # want to unwrap further than this otherwise we lose useful wrappings like @mock.patch (#3774)\n215         new_obj = getattr(obj, \"__pytest_wrapped__\", None)\n216         if isinstance(new_obj, _PytestWrapper):\n217             obj = new_obj.obj\n218             break\n219         new_obj = getattr(obj, \"__wrapped__\", None)\n220         if new_obj is None:\n221             break\n222         obj = new_obj\n223     else:\n224         raise ValueError(\n225             (\"could not find real function of {start}\\nstopped at {current}\").format(\n226                 start=saferepr(start_obj), current=saferepr(obj)\n227             )\n228         )\n229     if isinstance(obj, functools.partial):\n230         obj = obj.func\n231     return obj\n232 \n233 \n234 def get_real_method(obj, holder):\n235     \"\"\"\n236     Attempts to obtain the real function object that might be wrapping ``obj``, while at the same time\n237     returning a bound method to ``holder`` if the original object was a bound method.\n238     \"\"\"\n239     try:\n240         is_method = hasattr(obj, \"__func__\")\n241         obj = get_real_func(obj)\n242     except Exception:\n243         return obj\n244     if is_method and hasattr(obj, \"__get__\") and callable(obj.__get__):\n245         obj = obj.__get__(holder)\n246     return obj\n247 \n248 \n249 def getfslineno(obj):\n250     # xxx let decorators etc specify a sane ordering\n251     obj = get_real_func(obj)\n252     if hasattr(obj, \"place_as\"):\n253         obj = obj.place_as\n254     fslineno = _pytest._code.getfslineno(obj)\n255     assert isinstance(fslineno[1], int), obj\n256     return fslineno\n257 \n258 \n259 def getimfunc(func):\n260     try:\n261         return func.__func__\n262     except AttributeError:\n263         return func\n264 \n265 \n266 def safe_getattr(object, name, default):\n267     \"\"\" Like getattr but return default upon any Exception or any OutcomeException.\n268 \n269     Attribute access can potentially fail for 'evil' Python objects.\n270     See issue #214.\n271     It catches OutcomeException because of #2490 (issue #580), new outcomes are derived from BaseException\n272     instead of Exception (for more details check #2707)\n273     \"\"\"\n274     try:\n275         return getattr(object, name, default)\n276     except TEST_OUTCOME:\n277         return default\n278 \n279 \n280 def safe_isclass(obj):\n281     \"\"\"Ignore any exception via isinstance on Python 3.\"\"\"\n282     try:\n283         return isclass(obj)\n284     except Exception:\n285         return False\n286 \n287 \n288 COLLECT_FAKEMODULE_ATTRIBUTES = (\n289     \"Collector\",\n290     \"Module\",\n291     \"Function\",\n292     \"Instance\",\n293     \"Session\",\n294     \"Item\",\n295     \"Class\",\n296     \"File\",\n297     \"_fillfuncargs\",\n298 )\n299 \n300 \n301 def _setup_collect_fakemodule():\n302     from types import ModuleType\n303     import pytest\n304 \n305     pytest.collect = ModuleType(\"pytest.collect\")\n306     pytest.collect.__all__ = []  # used for setns\n307     for attr in COLLECT_FAKEMODULE_ATTRIBUTES:\n308         setattr(pytest.collect, attr, getattr(pytest, attr))\n309 \n310 \n311 class CaptureIO(io.TextIOWrapper):\n312     def __init__(self):\n313         super().__init__(io.BytesIO(), encoding=\"UTF-8\", newline=\"\", write_through=True)\n314 \n315     def getvalue(self):\n316         return self.buffer.getvalue().decode(\"UTF-8\")\n317 \n318 \n319 class FuncargnamesCompatAttr:\n320     \"\"\" helper class so that Metafunc, Function and FixtureRequest\n321     don't need to each define the \"funcargnames\" compatibility attribute.\n322     \"\"\"\n323 \n324     @property\n325     def funcargnames(self):\n326         \"\"\" alias attribute for ``fixturenames`` for pre-2.3 compatibility\"\"\"\n327         return self.fixturenames\n",
        "intended_behavior": "The code related to function unwrapping or manipulation that uses `__wrapped__` should implement safer access patterns. As in the previous location, using `getattr(obj, '__wrapped__', default)` or a similar check will ensure that `KeyError` is not raised. This file's role in smoothing over compatibility issues suggests it might be dealing with a variety of Python versions and their nuances in handling wrapped functions. Thus, enhancing robustness here is crucial. The amendment should not alter the core functionality intended by these compatibility layers but should ensure they are fault-tolerant to differences in object attributes, particularly `__wrapped__`."
    }
]