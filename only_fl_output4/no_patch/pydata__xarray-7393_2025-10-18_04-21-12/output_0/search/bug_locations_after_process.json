[
    {
        "rel_file_path": "xarray/core/dataset.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/pydata__xarray/setup_pydata__xarray__2022.09/xarray/core/dataset.py",
        "start": 4554,
        "end": 4602,
        "class_name": "Dataset",
        "method_name": "stack",
        "code": "4554     def stack(\n4555         self: T_Dataset,\n4556         dimensions: Mapping[Any, Sequence[Hashable | ellipsis]] | None = None,\n4557         create_index: bool | None = True,\n4558         index_cls: type[Index] = PandasMultiIndex,\n4559         **dimensions_kwargs: Sequence[Hashable | ellipsis],\n4560     ) -> T_Dataset:\n4561         \"\"\"\n4562         Stack any number of existing dimensions into a single new dimension.\n4563 \n4564         New dimensions will be added at the end, and by default the corresponding\n4565         coordinate variables will be combined into a MultiIndex.\n4566 \n4567         Parameters\n4568         ----------\n4569         dimensions : mapping of hashable to sequence of hashable\n4570             Mapping of the form `new_name=(dim1, dim2, ...)`. Names of new\n4571             dimensions, and the existing dimensions that they replace. An\n4572             ellipsis (`...`) will be replaced by all unlisted dimensions.\n4573             Passing a list containing an ellipsis (`stacked_dim=[...]`) will stack over\n4574             all dimensions.\n4575         create_index : bool or None, default: True\n4576 \n4577             - True: create a multi-index for each of the stacked dimensions.\n4578             - False: don't create any index.\n4579             - None. create a multi-index only if exactly one single (1-d) coordinate\n4580               index is found for every dimension to stack.\n4581 \n4582         index_cls: Index-class, default: PandasMultiIndex\n4583             Can be used to pass a custom multi-index type (must be an Xarray index that\n4584             implements `.stack()`). By default, a pandas multi-index wrapper is used.\n4585         **dimensions_kwargs\n4586             The keyword arguments form of ``dimensions``.\n4587             One of dimensions or dimensions_kwargs must be provided.\n4588 \n4589         Returns\n4590         -------\n4591         stacked : Dataset\n4592             Dataset with stacked data.\n4593 \n4594         See Also\n4595         --------\n4596         Dataset.unstack\n4597         \"\"\"\n4598         dimensions = either_dict_or_kwargs(dimensions, dimensions_kwargs, \"stack\")\n4599         result = self\n4600         for new_dim, dims in dimensions.items():\n4601             result = result._stack_once(dims, new_dim, index_cls, create_index)\n4602         return result\n",
        "intended_behavior": "The `stack` method should ensure that the dtype of coordinates remains unchanged after the operation completes. It should explicitly check the dtype of coordinates before the stacking operation and preserve those dtypes throughout the process, possibly by implementing a check or conversion routine that verifies the dtype post-operation against the original dtypes, reverting to the original dtype if a change is detected."
    },
    {
        "rel_file_path": "xarray/core/dataset.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/pydata__xarray/setup_pydata__xarray__2022.09/xarray/core/dataset.py",
        "start": 440,
        "end": 9233,
        "class_name": "Dataset",
        "method_name": null,
        "code": "440 class Dataset(\n441     DataWithCoords,\n442     DatasetAggregations,\n443     DatasetArithmetic,\n444     Mapping[Hashable, \"DataArray\"],\n445 ):\n446     \"\"\"A multi-dimensional, in memory, array database.\n447 \n448     A dataset resembles an in-memory representation of a NetCDF file,\n449     and consists of variables, coordinates and attributes which\n450     together form a self describing dataset.\n451 \n452     Dataset implements the mapping interface with keys given by variable\n453     names and values given by DataArray objects for each variable name.\n454 \n455     One dimensional variables with name equal to their dimension are\n456     index coordinates used for label based indexing.\n457 \n458     To load data from a file or file-like object, use the `open_dataset`\n459     function.\n460 \n461     Parameters\n462     ----------\n463     data_vars : dict-like, optional\n464         A mapping from variable names to :py:class:`~xarray.DataArray`\n465         objects, :py:class:`~xarray.Variable` objects or to tuples of\n466         the form ``(dims, data[, attrs])`` which can be used as\n467         arguments to create a new ``Variable``. Each dimension must\n468         have the same length in all variables in which it appears.\n469 \n470         The following notations are accepted:\n471 \n472         - mapping {var name: DataArray}\n473         - mapping {var name: Variable}\n474         - mapping {var name: (dimension name, array-like)}\n475         - mapping {var name: (tuple of dimension names, array-like)}\n476         - mapping {dimension name: array-like}\n477           (it will be automatically moved to coords, see below)\n478 \n479         Each dimension must have the same length in all variables in\n480         which it appears.\n481     coords : dict-like, optional\n482         Another mapping in similar form as the `data_vars` argument,\n483         except the each item is saved on the dataset as a \"coordinate\".\n484         These variables have an associated meaning: they describe\n485         constant/fixed/independent quantities, unlike the\n486         varying/measured/dependent quantities that belong in\n487         `variables`. Coordinates values may be given by 1-dimensional\n488         arrays or scalars, in which case `dims` do not need to be\n489         supplied: 1D arrays will be assumed to give index values along\n490         the dimension with the same name.\n491 \n492         The following notations are accepted:\n493 \n494         - mapping {coord name: DataArray}\n495         - mapping {coord name: Variable}\n496         - mapping {coord name: (dimension name, array-like)}\n497         - mapping {coord name: (tuple of dimension names, array-like)}\n498         - mapping {dimension name: array-like}\n499           (the dimension name is implicitly set to be the same as the\n500           coord name)\n501 \n502         The last notation implies that the coord name is the same as\n503         the dimension name.\n504 \n505     attrs : dict-like, optional\n506         Global attributes to save on this dataset.\n507 \n508     Examples\n509     --------\n510     Create data:\n511 \n512     >>> np.random.seed(0)\n513     >>> temperature = 15 + 8 * np.random.randn(2, 2, 3)\n514     >>> precipitation = 10 * np.random.rand(2, 2, 3)\n515     >>> lon = [[-99.83, -99.32], [-99.79, -99.23]]\n516     >>> lat = [[42.25, 42.21], [42.63, 42.59]]\n517     >>> time = pd.date_range(\"2014-09-06\", periods=3)\n518     >>> reference_time = pd.Timestamp(\"2014-09-05\")\n519 \n520     Initialize a dataset with multiple dimensions:\n521 \n522     >>> ds = xr.Dataset(\n523     ...     data_vars=dict(\n524     ...         temperature=([\"x\", \"y\", \"time\"], temperature),\n525     ...         precipitation=([\"x\", \"y\", \"time\"], precipitation),\n526     ...     ),\n527     ...     coords=dict(\n528     ...         lon=([\"x\", \"y\"], lon),\n529     ...         lat=([\"x\", \"y\"], lat),\n530     ...         time=time,\n531     ...         reference_time=reference_time,\n532     ...     ),\n533     ...     attrs=dict(description=\"Weather related data.\"),\n534     ... )\n535     >>> ds\n536     <xarray.Dataset>\n537     Dimensions:         (x: 2, y: 2, time: 3)\n538     Coordinates:\n539         lon             (x, y) float64 -99.83 -99.32 -99.79 -99.23\n540         lat             (x, y) float64 42.25 42.21 42.63 42.59\n541       * time            (time) datetime64[ns] 2014-09-06 2014-09-07 2014-09-08\n542         reference_time  datetime64[ns] 2014-09-05\n543     Dimensions without coordinates: x, y\n544     Data variables:\n545         temperature     (x, y, time) float64 29.11 18.2 22.83 ... 18.28 16.15 26.63\n546         precipitation   (x, y, time) float64 5.68 9.256 0.7104 ... 7.992 4.615 7.805\n547     Attributes:\n548         description:  Weather related data.\n549 \n550     Find out where the coldest temperature was and what values the\n551     other variables had:\n552 \n553     >>> ds.isel(ds.temperature.argmin(...))\n554     <xarray.Dataset>\n555     Dimensions:         ()\n556     Coordinates:\n557         lon             float64 -99.32\n558         lat             float64 42.21\n559         time            datetime64[ns] 2014-09-08\n560         reference_time  datetime64[ns] 2014-09-05\n561     Data variables:\n562         temperature     float64 7.182\n563         precipitation   float64 8.326\n564     Attributes:\n565         description:  Weather related data.\n566     \"\"\"\n567 \n568     _attrs: dict[Hashable, Any] | None\n569     _cache: dict[str, Any]\n570     _coord_names: set[Hashable]\n571     _dims: dict[Hashable, int]\n572     _encoding: dict[Hashable, Any] | None\n573     _close: Callable[[], None] | None\n574     _indexes: dict[Hashable, Index]\n575     _variables: dict[Hashable, Variable]\n576 \n577     __slots__ = (\n578         \"_attrs\",\n579         \"_cache\",\n580         \"_coord_names\",\n581         \"_dims\",\n582         \"_encoding\",\n583         \"_close\",\n584         \"_indexes\",\n585         \"_variables\",\n586         \"__weakref__\",\n587     )\n588 \n589     def __init__(\n590         self,\n591         # could make a VariableArgs to use more generally, and refine these\n592         # categories\n593         data_vars: Mapping[Any, Any] | None = None,\n594         coords: Mapping[Any, Any] | None = None,\n595         attrs: Mapping[Any, Any] | None = None,\n596     ) -> None:\n597         # TODO(shoyer): expose indexes as a public argument in __init__\n598 \n599         if data_vars is None:\n600             data_vars = {}\n601         if coords is None:\n602             coords = {}\n603 \n604         both_data_and_coords = set(data_vars) & set(coords)\n605         if both_data_and_coords:\n606             raise ValueError(\n607                 f\"variables {both_data_and_coords!r} are found in both data_vars and coords\"\n608             )\n609 \n610         if isinstance(coords, Dataset):\n611             coords = coords.variables\n612 \n613         variables, coord_names, dims, indexes, _ = merge_data_and_coords(\n614             data_vars, coords, compat=\"broadcast_equals\"\n615         )\n616 \n617         self._attrs = dict(attrs) if attrs is not None else None\n618         self._close = None\n619         self._encoding = None\n620         self._variables = variables\n621         self._coord_names = coord_names\n622         self._dims = dims\n623         self._indexes = indexes\n624 \n625     @classmethod\n626     def load_store(cls: type[T_Dataset], store, decoder=None) -> T_Dataset:\n627         \"\"\"Create a new dataset from the contents of a backends.*DataStore\n628         object\n629         \"\"\"\n630         variables, attributes = store.load()\n631         if decoder:\n632             variables, attributes = decoder(variables, attributes)\n633         obj = cls(variables, attrs=attributes)\n634         obj.set_close(store.close)\n635         return obj\n636 \n637     @property\n638     def variables(self) -> Frozen[Hashable, Variable]:\n639         \"\"\"Low level interface to Dataset contents as dict of Variable objects.\n640 \n641         This ordered dictionary is frozen to prevent mutation that could\n642         violate Dataset invariants. It contains all variable objects\n643         constituting the Dataset, including both data variables and\n644         coordinates.\n645         \"\"\"\n646         return Frozen(self._variables)\n647 \n648     @property\n649     def attrs(self) -> dict[Any, Any]:\n650         \"\"\"Dictionary of global attributes on this dataset\"\"\"\n651         if self._attrs is None:\n652             self._attrs = {}\n653         return self._attrs\n654 \n655     @attrs.setter\n656     def attrs(self, value: Mapping[Any, Any]) -> None:\n657         self._attrs = dict(value)\n658 \n659     @property\n660     def encoding(self) -> dict[Any, Any]:\n661         \"\"\"Dictionary of global encoding attributes on this dataset\"\"\"\n662         if self._encoding is None:\n663             self._encoding = {}\n664         return self._encoding\n665 \n666     @encoding.setter\n667     def encoding(self, value: Mapping[Any, Any]) -> None:\n668         self._encoding = dict(value)\n669 \n670     @property\n671     def dims(self) -> Frozen[Hashable, int]:\n672         \"\"\"Mapping from dimension names to lengths.\n673 \n674         Cannot be modified directly, but is updated when adding new variables.\n675 \n676         Note that type of this object differs from `DataArray.dims`.\n677         See `Dataset.sizes` and `DataArray.sizes` for consistently named\n678         properties.\n679 \n680         See Also\n681         --------\n682         Dataset.sizes\n683         DataArray.dims\n684         \"\"\"\n685         return Frozen(self._dims)\n686 \n687     @property\n688     def sizes(self) -> Frozen[Hashable, int]:\n689         \"\"\"Mapping from dimension names to lengths.\n690 \n691         Cannot be modified directly, but is updated when adding new variables.\n692 \n693         This is an alias for `Dataset.dims` provided for the benefit of\n694         consistency with `DataArray.sizes`.\n695 \n696         See Also\n697         --------\n698         DataArray.sizes\n699         \"\"\"\n700         return self.dims\n701 \n702     @property\n703     def dtypes(self) -> Frozen[Hashable, np.dtype]:\n704         \"\"\"Mapping from data variable names to dtypes.\n705 \n706         Cannot be modified directly, but is updated when adding new variables.\n707 \n708         See Also\n709         --------\n710         DataArray.dtype\n711         \"\"\"\n712         return Frozen(\n713             {\n714                 n: v.dtype\n715                 for n, v in self._variables.items()\n716                 if n not in self._coord_names\n717             }\n718         )\n719 \n720     def load(self: T_Dataset, **kwargs) -> T_Dataset:\n721         \"\"\"Manually trigger loading and/or computation of this dataset's data\n722         from disk or a remote source into memory and return this dataset.\n723         Unlike compute, the original dataset is modified and returned.\n724 \n725         Normally, it should not be necessary to call this method in user code,\n726         because all xarray functions should either work on deferred data or\n727         load data automatically. However, this method can be necessary when\n728         working with many file objects on disk.\n729 \n730         Parameters\n731         ----------\n732         **kwargs : dict\n733             Additional keyword arguments passed on to ``dask.compute``.\n734 \n735         See Also\n736         --------\n737         dask.compute\n738         \"\"\"\n739         # access .data to coerce everything to numpy or dask arrays\n740         lazy_data = {\n741             k: v._data for k, v in self.variables.items() if is_duck_dask_array(v._data)\n742         }\n743         if lazy_data:\n744             import dask.array as da\n745 \n746             # evaluate all the dask arrays simultaneously\n747             evaluated_data = da.compute(*lazy_data.values(), **kwargs)\n748 \n749             for k, data in zip(lazy_data, evaluated_data):\n750                 self.variables[k].data = data\n751 \n752         # load everything else sequentially\n753         for k, v in self.variables.items():\n754             if k not in lazy_data:\n755                 v.load()\n756 \n757         return self\n758 \n759     def __dask_tokenize__(self):\n760         from dask.base import normalize_token\n761 \n762         return normalize_token(\n763             (type(self), self._variables, self._coord_names, self._attrs)\n764         )\n765 \n766     def __dask_graph__(self):\n767         graphs = {k: v.__dask_graph__() for k, v in self.variables.items()}\n768         graphs = {k: v for k, v in graphs.items() if v is not None}\n769         if not graphs:\n770             return None\n771         else:\n772             try:\n773                 from dask.highlevelgraph import HighLevelGraph\n774 \n775                 return HighLevelGraph.merge(*graphs.values())\n776             except ImportError:\n777                 from dask import sharedict\n778 \n779                 return sharedict.merge(*graphs.values())\n780 \n781     def __dask_keys__(self):\n782         import dask\n783 \n784         return [\n785             v.__dask_keys__()\n786             for v in self.variables.values()\n787             if dask.is_dask_collection(v)\n788         ]\n789 \n790     def __dask_layers__(self):\n791         import dask\n792 \n793         return sum(\n794             (\n795                 v.__dask_layers__()\n796                 for v in self.variables.values()\n797                 if dask.is_dask_collection(v)\n798             ),\n799             (),\n800         )\n801 \n802     @property\n803     def __dask_optimize__(self):\n804         import dask.array as da\n805 \n806         return da.Array.__dask_optimize__\n807 \n808     @property\n809     def __dask_scheduler__(self):\n810         import dask.array as da\n811 \n812         return da.Array.__dask_scheduler__\n813 \n814     def __dask_postcompute__(self):\n815         return self._dask_postcompute, ()\n816 \n817     def __dask_postpersist__(self):\n818         return self._dask_postpersist, ()\n819 \n820     def _dask_postcompute(self: T_Dataset, results: Iterable[Variable]) -> T_Dataset:\n821         import dask\n822 \n823         variables = {}\n824         results_iter = iter(results)\n825 \n826         for k, v in self._variables.items():\n827             if dask.is_dask_collection(v):\n828                 rebuild, args = v.__dask_postcompute__()\n829                 v = rebuild(next(results_iter), *args)\n830             variables[k] = v\n831 \n832         return type(self)._construct_direct(\n833             variables,\n834             self._coord_names,\n835             self._dims,\n836             self._attrs,\n837             self._indexes,\n838             self._encoding,\n839             self._close,\n840         )\n841 \n842     def _dask_postpersist(\n843         self: T_Dataset, dsk: Mapping, *, rename: Mapping[str, str] | None = None\n844     ) -> T_Dataset:\n845         from dask import is_dask_collection\n846         from dask.highlevelgraph import HighLevelGraph\n847         from dask.optimization import cull\n848 \n849         variables = {}\n850 \n851         for k, v in self._variables.items():\n852             if not is_dask_collection(v):\n853                 variables[k] = v\n854                 continue\n855 \n856             if isinstance(dsk, HighLevelGraph):\n857                 # dask >= 2021.3\n858                 # __dask_postpersist__() was called by dask.highlevelgraph.\n859                 # Don't use dsk.cull(), as we need to prevent partial layers:\n860                 # https://github.com/dask/dask/issues/7137\n861                 layers = v.__dask_layers__()\n862                 if rename:\n863                     layers = [rename.get(k, k) for k in layers]\n864                 dsk2 = dsk.cull_layers(layers)\n865             elif rename:  # pragma: nocover\n866                 # At the moment of writing, this is only for forward compatibility.\n867                 # replace_name_in_key requires dask >= 2021.3.\n868                 from dask.base import flatten, replace_name_in_key\n869 \n870                 keys = [\n871                     replace_name_in_key(k, rename) for k in flatten(v.__dask_keys__())\n872                 ]\n873                 dsk2, _ = cull(dsk, keys)\n874             else:\n875                 # __dask_postpersist__() was called by dask.optimize or dask.persist\n876                 dsk2, _ = cull(dsk, v.__dask_keys__())\n877 \n878             rebuild, args = v.__dask_postpersist__()\n879             # rename was added in dask 2021.3\n880             kwargs = {\"rename\": rename} if rename else {}\n881             variables[k] = rebuild(dsk2, *args, **kwargs)\n882 \n883         return type(self)._construct_direct(\n884             variables,\n885             self._coord_names,\n886             self._dims,\n887             self._attrs,\n888             self._indexes,\n889             self._encoding,\n890             self._close,\n891         )\n892 \n893     def compute(self: T_Dataset, **kwargs) -> T_Dataset:\n894         \"\"\"Manually trigger loading and/or computation of this dataset's data\n895         from disk or a remote source into memory and return a new dataset.\n896         Unlike load, the original dataset is left unaltered.\n897 \n898         Normally, it should not be necessary to call this method in user code,\n899         because all xarray functions should either work on deferred data or\n900         load data automatically. However, this method can be necessary when\n901         working with many file objects on disk.\n902 \n903         Parameters\n904         ----------\n905         **kwargs : dict\n906             Additional keyword arguments passed on to ``dask.compute``.\n907 \n908         See Also\n909         --------\n910         dask.compute\n911         \"\"\"\n912         new = self.copy(deep=False)\n913         return new.load(**kwargs)\n914 \n915     def _persist_inplace(self: T_Dataset, **kwargs) -> T_Dataset:\n916         \"\"\"Persist all Dask arrays in memory\"\"\"\n917         # access .data to coerce everything to numpy or dask arrays\n918         lazy_data = {\n919             k: v._data for k, v in self.variables.items() if is_duck_dask_array(v._data)\n920         }\n921         if lazy_data:\n922             import dask\n923 \n924             # evaluate all the dask arrays simultaneously\n925             evaluated_data = dask.persist(*lazy_data.values(), **kwargs)\n926 \n927             for k, data in zip(lazy_data, evaluated_data):\n928                 self.variables[k].data = data\n929 \n930         return self\n931 \n932     def persist(self: T_Dataset, **kwargs) -> T_Dataset:\n933         \"\"\"Trigger computation, keeping data as dask arrays\n934 \n935         This operation can be used to trigger computation on underlying dask\n936         arrays, similar to ``.compute()`` or ``.load()``.  However this\n937         operation keeps the data as dask arrays. This is particularly useful\n938         when using the dask.distributed scheduler and you want to load a large\n939         amount of data into distributed memory.\n940 \n941         Parameters\n942         ----------\n943         **kwargs : dict\n944             Additional keyword arguments passed on to ``dask.persist``.\n945 \n946         See Also\n947         --------\n948         dask.persist\n949         \"\"\"\n950         new = self.copy(deep=False)\n951         return new._persist_inplace(**kwargs)\n952 \n953     @classmethod\n954     def _construct_direct(\n955         cls: type[T_Dataset],\n956         variables: dict[Any, Variable],\n957         coord_names: set[Hashable],\n958         dims: dict[Any, int] | None = None,\n959         attrs: dict | None = None,\n960         indexes: dict[Any, Index] | None = None,\n961         encoding: dict | None = None,\n962         close: Callable[[], None] | None = None,\n963     ) -> T_Dataset:\n964         \"\"\"Shortcut around __init__ for internal use when we want to skip\n965         costly validation\n966         \"\"\"\n967         if dims is None:\n968             dims = calculate_dimensions(variables)\n969         if indexes is None:\n970             indexes = {}\n971         obj = object.__new__(cls)\n972         obj._variables = variables\n973         obj._coord_names = coord_names\n974         obj._dims = dims\n975         obj._indexes = indexes\n976         obj._attrs = attrs\n977         obj._close = close\n978         obj._encoding = encoding\n979         return obj\n980 \n981     def _replace(\n982         self: T_Dataset,\n983         variables: dict[Hashable, Variable] | None = None,\n984         coord_names: set[Hashable] | None = None,\n985         dims: dict[Any, int] | None = None,\n986         attrs: dict[Hashable, Any] | None | Default = _default,\n987         indexes: dict[Hashable, Index] | None = None,\n988         encoding: dict | None | Default = _default,\n989         inplace: bool = False,\n990     ) -> T_Dataset:\n991         \"\"\"Fastpath constructor for internal use.\n992 \n993         Returns an object with optionally with replaced attributes.\n994 \n995         Explicitly passed arguments are *not* copied when placed on the new\n996         dataset. It is up to the caller to ensure that they have the right type\n997         and are not used elsewhere.\n998         \"\"\"\n999         if inplace:\n1000             if variables is not None:\n1001                 self._variables = variables\n1002             if coord_names is not None:\n1003                 self._coord_names = coord_names\n1004             if dims is not None:\n1005                 self._dims = dims\n1006             if attrs is not _default:\n1007                 self._attrs = attrs\n1008             if indexes is not None:\n1009                 self._indexes = indexes\n1010             if encoding is not _default:\n1011                 self._encoding = encoding\n1012             obj = self\n1013         else:\n1014             if variables is None:\n1015                 variables = self._variables.copy()\n1016             if coord_names is None:\n1017                 coord_names = self._coord_names.copy()\n1018             if dims is None:\n1019                 dims = self._dims.copy()\n1020             if attrs is _default:\n1021                 attrs = copy.copy(self._attrs)\n1022             if indexes is None:\n1023                 indexes = self._indexes.copy()\n1024             if encoding is _default:\n1025                 encoding = copy.copy(self._encoding)\n1026             obj = self._construct_direct(\n1027                 variables, coord_names, dims, attrs, indexes, encoding\n1028             )\n1029         return obj\n1030 \n1031     def _replace_with_new_dims(\n1032         self: T_Dataset,\n1033         variables: dict[Hashable, Variable],\n1034         coord_names: set | None = None,\n1035         attrs: dict[Hashable, Any] | None | Default = _default,\n1036         indexes: dict[Hashable, Index] | None = None,\n1037         inplace: bool = False,\n1038     ) -> T_Dataset:\n1039         \"\"\"Replace variables with recalculated dimensions.\"\"\"\n1040         dims = calculate_dimensions(variables)\n1041         return self._replace(\n1042             variables, coord_names, dims, attrs, indexes, inplace=inplace\n1043         )\n1044 \n1045     def _replace_vars_and_dims(\n1046         self: T_Dataset,\n1047         variables: dict[Hashable, Variable],\n1048         coord_names: set | None = None,\n1049         dims: dict[Hashable, int] | None = None,\n1050         attrs: dict[Hashable, Any] | None | Default = _default,\n1051         inplace: bool = False,\n1052     ) -> T_Dataset:\n1053         \"\"\"Deprecated version of _replace_with_new_dims().\n1054 \n1055         Unlike _replace_with_new_dims(), this method always recalculates\n1056         indexes from variables.\n1057         \"\"\"\n1058         if dims is None:\n1059             dims = calculate_dimensions(variables)\n1060         return self._replace(\n1061             variables, coord_names, dims, attrs, indexes=None, inplace=inplace\n1062         )\n1063 \n1064     def _overwrite_indexes(\n1065         self: T_Dataset,\n1066         indexes: Mapping[Hashable, Index],\n1067         variables: Mapping[Hashable, Variable] | None = None,\n1068         drop_variables: list[Hashable] | None = None,\n1069         drop_indexes: list[Hashable] | None = None,\n1070         rename_dims: Mapping[Hashable, Hashable] | None = None,\n1071     ) -> T_Dataset:\n1072         \"\"\"Maybe replace indexes.\n1073 \n1074         This function may do a lot more depending on index query\n1075         results.\n1076 \n1077         \"\"\"\n1078         if not indexes:\n1079             return self\n1080 \n1081         if variables is None:\n1082             variables = {}\n1083         if drop_variables is None:\n1084             drop_variables = []\n1085         if drop_indexes is None:\n1086             drop_indexes = []\n1087 \n1088         new_variables = self._variables.copy()\n1089         new_coord_names = self._coord_names.copy()\n1090         new_indexes = dict(self._indexes)\n1091 \n1092         index_variables = {}\n1093         no_index_variables = {}\n1094         for name, var in variables.items():\n1095             old_var = self._variables.get(name)\n1096             if old_var is not None:\n1097                 var.attrs.update(old_var.attrs)\n1098                 var.encoding.update(old_var.encoding)\n1099             if name in indexes:\n1100                 index_variables[name] = var\n1101             else:\n1102                 no_index_variables[name] = var\n1103 \n1104         for name in indexes:\n1105             new_indexes[name] = indexes[name]\n1106 \n1107         for name, var in index_variables.items():\n1108             new_coord_names.add(name)\n1109             new_variables[name] = var\n1110 \n1111         # append no-index variables at the end\n1112         for k in no_index_variables:\n1113             new_variables.pop(k)\n1114         new_variables.update(no_index_variables)\n1115 \n1116         for name in drop_indexes:\n1117             new_indexes.pop(name)\n1118 \n1119         for name in drop_variables:\n1120             new_variables.pop(name)\n1121             new_indexes.pop(name, None)\n1122             new_coord_names.remove(name)\n1123 \n1124         replaced = self._replace(\n1125             variables=new_variables, coord_names=new_coord_names, indexes=new_indexes\n1126         )\n1127 \n1128         if rename_dims:\n1129             # skip rename indexes: they should already have the right name(s)\n1130             dims = replaced._rename_dims(rename_dims)\n1131             new_variables, new_coord_names = replaced._rename_vars({}, rename_dims)\n1132             return replaced._replace(\n1133                 variables=new_variables, coord_names=new_coord_names, dims=dims\n1134             )\n1135         else:\n1136             return replaced\n1137 \n1138     def copy(\n1139         self: T_Dataset, deep: bool = False, data: Mapping[Any, ArrayLike] | None = None\n1140     ) -> T_Dataset:\n1141         \"\"\"Returns a copy of this dataset.\n1142 \n1143         If `deep=True`, a deep copy is made of each of the component variables.\n1144         Otherwise, a shallow copy of each of the component variable is made, so\n1145         that the underlying memory region of the new dataset is the same as in\n1146         the original dataset.\n1147 \n1148         Use `data` to create a new object with the same structure as\n1149         original but entirely new data.\n1150 \n1151         Parameters\n1152         ----------\n1153         deep : bool, default: False\n1154             Whether each component variable is loaded into memory and copied onto\n1155             the new object. Default is False.\n1156         data : dict-like or None, optional\n1157             Data to use in the new object. Each item in `data` must have same\n1158             shape as corresponding data variable in original. When `data` is\n1159             used, `deep` is ignored for the data variables and only used for\n1160             coords.\n1161 \n1162         Returns\n1163         -------\n1164         object : Dataset\n1165             New object with dimensions, attributes, coordinates, name, encoding,\n1166             and optionally data copied from original.\n1167 \n1168         Examples\n1169         --------\n1170         Shallow copy versus deep copy\n1171 \n1172         >>> da = xr.DataArray(np.random.randn(2, 3))\n1173         >>> ds = xr.Dataset(\n1174         ...     {\"foo\": da, \"bar\": (\"x\", [-1, 2])},\n1175         ...     coords={\"x\": [\"one\", \"two\"]},\n1176         ... )\n1177         >>> ds.copy()\n1178         <xarray.Dataset>\n1179         Dimensions:  (dim_0: 2, dim_1: 3, x: 2)\n1180         Coordinates:\n1181           * x        (x) <U3 'one' 'two'\n1182         Dimensions without coordinates: dim_0, dim_1\n1183         Data variables:\n1184             foo      (dim_0, dim_1) float64 1.764 0.4002 0.9787 2.241 1.868 -0.9773\n1185             bar      (x) int64 -1 2\n1186 \n1187         >>> ds_0 = ds.copy(deep=False)\n1188         >>> ds_0[\"foo\"][0, 0] = 7\n1189         >>> ds_0\n1190         <xarray.Dataset>\n1191         Dimensions:  (dim_0: 2, dim_1: 3, x: 2)\n1192         Coordinates:\n1193           * x        (x) <U3 'one' 'two'\n1194         Dimensions without coordinates: dim_0, dim_1\n1195         Data variables:\n1196             foo      (dim_0, dim_1) float64 7.0 0.4002 0.9787 2.241 1.868 -0.9773\n1197             bar      (x) int64 -1 2\n1198 \n1199         >>> ds\n1200         <xarray.Dataset>\n1201         Dimensions:  (dim_0: 2, dim_1: 3, x: 2)\n1202         Coordinates:\n1203           * x        (x) <U3 'one' 'two'\n1204         Dimensions without coordinates: dim_0, dim_1\n1205         Data variables:\n1206             foo      (dim_0, dim_1) float64 7.0 0.4002 0.9787 2.241 1.868 -0.9773\n1207             bar      (x) int64 -1 2\n1208 \n1209         Changing the data using the ``data`` argument maintains the\n1210         structure of the original object, but with the new data. Original\n1211         object is unaffected.\n1212 \n1213         >>> ds.copy(data={\"foo\": np.arange(6).reshape(2, 3), \"bar\": [\"a\", \"b\"]})\n1214         <xarray.Dataset>\n1215         Dimensions:  (dim_0: 2, dim_1: 3, x: 2)\n1216         Coordinates:\n1217           * x        (x) <U3 'one' 'two'\n1218         Dimensions without coordinates: dim_0, dim_1\n1219         Data variables:\n1220             foo      (dim_0, dim_1) int64 0 1 2 3 4 5\n1221             bar      (x) <U1 'a' 'b'\n1222 \n1223         >>> ds\n1224         <xarray.Dataset>\n1225         Dimensions:  (dim_0: 2, dim_1: 3, x: 2)\n1226         Coordinates:\n1227           * x        (x) <U3 'one' 'two'\n1228         Dimensions without coordinates: dim_0, dim_1\n1229         Data variables:\n1230             foo      (dim_0, dim_1) float64 7.0 0.4002 0.9787 2.241 1.868 -0.9773\n1231             bar      (x) int64 -1 2\n1232 \n1233         See Also\n1234         --------\n1235         pandas.DataFrame.copy\n1236         \"\"\"\n1237         return self._copy(deep=deep, data=data)\n1238 \n1239     def _copy(\n1240         self: T_Dataset,\n1241         deep: bool = False,\n1242         data: Mapping[Any, ArrayLike] | None = None,\n1243         memo: dict[int, Any] | None = None,\n1244     ) -> T_Dataset:\n1245         if data is None:\n1246             data = {}\n1247         elif not utils.is_dict_like(data):\n1248             raise ValueError(\"Data must be dict-like\")\n1249 \n1250         if data:\n1251             var_keys = set(self.data_vars.keys())\n1252             data_keys = set(data.keys())\n1253             keys_not_in_vars = data_keys - var_keys\n1254             if keys_not_in_vars:\n1255                 raise ValueError(\n1256                     \"Data must only contain variables in original \"\n1257                     \"dataset. Extra variables: {}\".format(keys_not_in_vars)\n1258                 )\n1259             keys_missing_from_data = var_keys - data_keys\n1260             if keys_missing_from_data:\n1261                 raise ValueError(\n1262                     \"Data must contain all variables in original \"\n1263                     \"dataset. Data is missing {}\".format(keys_missing_from_data)\n1264                 )\n1265 \n1266         indexes, index_vars = self.xindexes.copy_indexes(deep=deep)\n1267 \n1268         variables = {}\n1269         for k, v in self._variables.items():\n1270             if k in index_vars:\n1271                 variables[k] = index_vars[k]\n1272             else:\n1273                 variables[k] = v._copy(deep=deep, data=data.get(k), memo=memo)\n1274 \n1275         attrs = copy.deepcopy(self._attrs, memo) if deep else copy.copy(self._attrs)\n1276         encoding = (\n1277             copy.deepcopy(self._encoding, memo) if deep else copy.copy(self._encoding)\n1278         )\n1279 \n1280         return self._replace(variables, indexes=indexes, attrs=attrs, encoding=encoding)\n1281 \n1282     def __copy__(self: T_Dataset) -> T_Dataset:\n1283         return self._copy(deep=False)\n1284 \n1285     def __deepcopy__(self: T_Dataset, memo: dict[int, Any] | None = None) -> T_Dataset:\n1286         return self._copy(deep=True, memo=memo)\n1287 \n1288     def as_numpy(self: T_Dataset) -> T_Dataset:\n1289         \"\"\"\n1290         Coerces wrapped data and coordinates into numpy arrays, returning a Dataset.\n1291 \n1292         See also\n1293         --------\n1294         DataArray.as_numpy\n1295         DataArray.to_numpy : Returns only the data as a numpy.ndarray object.\n1296         \"\"\"\n1297         numpy_variables = {k: v.as_numpy() for k, v in self.variables.items()}\n1298         return self._replace(variables=numpy_variables)\n1299 \n1300     def _copy_listed(self: T_Dataset, names: Iterable[Hashable]) -> T_Dataset:\n1301         \"\"\"Create a new Dataset with the listed variables from this dataset and\n1302         the all relevant coordinates. Skips all validation.\n1303         \"\"\"\n1304         variables: dict[Hashable, Variable] = {}\n1305         coord_names = set()\n1306         indexes: dict[Hashable, Index] = {}\n1307 \n1308         for name in names:\n1309             try:\n1310                 variables[name] = self._variables[name]\n1311             except KeyError:\n1312                 ref_name, var_name, var = _get_virtual_variable(\n1313                     self._variables, name, self.dims\n1314                 )\n1315                 variables[var_name] = var\n1316                 if ref_name in self._coord_names or ref_name in self.dims:\n1317                     coord_names.add(var_name)\n1318                 if (var_name,) == var.dims:\n1319                     index, index_vars = create_default_index_implicit(var, names)\n1320                     indexes.update({k: index for k in index_vars})\n1321                     variables.update(index_vars)\n1322                     coord_names.update(index_vars)\n1323 \n1324         needed_dims: OrderedSet[Hashable] = OrderedSet()\n1325         for v in variables.values():\n1326             needed_dims.update(v.dims)\n1327 \n1328         dims = {k: self.dims[k] for k in needed_dims}\n1329 \n1330         # preserves ordering of coordinates\n1331         for k in self._variables:\n1332             if k not in self._coord_names:\n1333                 continue\n1334 \n1335             if set(self.variables[k].dims) <= needed_dims:\n1336                 variables[k] = self._variables[k]\n1337                 coord_names.add(k)\n1338 \n1339         indexes.update(filter_indexes_from_coords(self._indexes, coord_names))\n1340 \n1341         return self._replace(variables, coord_names, dims, indexes=indexes)\n1342 \n1343     def _construct_dataarray(self, name: Hashable) -> DataArray:\n1344         \"\"\"Construct a DataArray by indexing this dataset\"\"\"\n1345         from xarray.core.dataarray import DataArray\n1346 \n1347         try:\n1348             variable = self._variables[name]\n1349         except KeyError:\n1350             _, name, variable = _get_virtual_variable(self._variables, name, self.dims)\n1351 \n1352         needed_dims = set(variable.dims)\n1353 \n1354         coords: dict[Hashable, Variable] = {}\n1355         # preserve ordering\n1356         for k in self._variables:\n1357             if k in self._coord_names and set(self.variables[k].dims) <= needed_dims:\n1358                 coords[k] = self.variables[k]\n1359 \n1360         indexes = filter_indexes_from_coords(self._indexes, set(coords))\n1361 \n1362         return DataArray(variable, coords, name=name, indexes=indexes, fastpath=True)\n1363 \n1364     @property\n1365     def _attr_sources(self) -> Iterable[Mapping[Hashable, Any]]:\n1366         \"\"\"Places to look-up items for attribute-style access\"\"\"\n1367         yield from self._item_sources\n1368         yield self.attrs\n1369 \n1370     @property\n1371     def _item_sources(self) -> Iterable[Mapping[Hashable, Any]]:\n1372         \"\"\"Places to look-up items for key-completion\"\"\"\n1373         yield self.data_vars\n1374         yield HybridMappingProxy(keys=self._coord_names, mapping=self.coords)\n1375 \n1376         # virtual coordinates\n1377         yield HybridMappingProxy(keys=self.dims, mapping=self)\n1378 \n1379     def __contains__(self, key: object) -> bool:\n1380         \"\"\"The 'in' operator will return true or false depending on whether\n1381         'key' is an array in the dataset or not.\n1382         \"\"\"\n1383         return key in self._variables\n1384 \n1385     def __len__(self) -> int:\n1386         return len(self.data_vars)\n1387 \n1388     def __bool__(self) -> bool:\n1389         return bool(self.data_vars)\n1390 \n1391     def __iter__(self) -> Iterator[Hashable]:\n1392         return iter(self.data_vars)\n1393 \n1394     def __array__(self, dtype=None):\n1395         raise TypeError(\n1396             \"cannot directly convert an xarray.Dataset into a \"\n1397             \"numpy array. Instead, create an xarray.DataArray \"\n1398             \"first, either with indexing on the Dataset or by \"\n1399             \"invoking the `to_array()` method.\"\n1400         )\n1401 \n1402     @property\n1403     def nbytes(self) -> int:\n1404         \"\"\"\n1405         Total bytes consumed by the data arrays of all variables in this dataset.\n1406 \n1407         If the backend array for any variable does not include ``nbytes``, estimates\n1408         the total bytes for that array based on the ``size`` and ``dtype``.\n1409         \"\"\"\n1410         return sum(v.nbytes for v in self.variables.values())\n1411 \n1412     @property\n1413     def loc(self: T_Dataset) -> _LocIndexer[T_Dataset]:\n1414         \"\"\"Attribute for location based indexing. Only supports __getitem__,\n1415         and only when the key is a dict of the form {dim: labels}.\n1416         \"\"\"\n1417         return _LocIndexer(self)\n1418 \n1419     @overload\n1420     def __getitem__(self, key: Hashable) -> DataArray:\n1421         ...\n1422 \n1423     # Mapping is Iterable\n1424     @overload\n1425     def __getitem__(self: T_Dataset, key: Iterable[Hashable]) -> T_Dataset:\n1426         ...\n1427 \n1428     def __getitem__(\n1429         self: T_Dataset, key: Mapping[Any, Any] | Hashable | Iterable[Hashable]\n1430     ) -> T_Dataset | DataArray:\n1431         \"\"\"Access variables or coordinates of this dataset as a\n1432         :py:class:`~xarray.DataArray` or a subset of variables or a indexed dataset.\n1433 \n1434         Indexing with a list of names will return a new ``Dataset`` object.\n1435         \"\"\"\n1436         if utils.is_dict_like(key):\n1437             return self.isel(**key)\n1438         if utils.hashable(key):\n1439             return self._construct_dataarray(key)\n1440         if utils.iterable_of_hashable(key):\n1441             return self._copy_listed(key)\n1442         raise ValueError(f\"Unsupported key-type {type(key)}\")\n1443 \n1444     def __setitem__(\n1445         self, key: Hashable | Iterable[Hashable] | Mapping, value: Any\n1446     ) -> None:\n1447         \"\"\"Add an array to this dataset.\n1448         Multiple arrays can be added at the same time, in which case each of\n1449         the following operations is applied to the respective value.\n1450 \n1451         If key is dict-like, update all variables in the dataset\n1452         one by one with the given value at the given location.\n1453         If the given value is also a dataset, select corresponding variables\n1454         in the given value and in the dataset to be changed.\n1455 \n1456         If value is a `\n1457         from .dataarray import DataArray`, call its `select_vars()` method, rename it\n1458         to `key` and merge the contents of the resulting dataset into this\n1459         dataset.\n1460 \n1461         If value is a `Variable` object (or tuple of form\n1462         ``(dims, data[, attrs])``), add it to this dataset as a new\n1463         variable.\n1464         \"\"\"\n1465         from xarray.core.dataarray import DataArray\n1466 \n1467         if utils.is_dict_like(key):\n1468             # check for consistency and convert value to dataset\n1469             value = self._setitem_check(key, value)\n1470             # loop over dataset variables and set new values\n1471             processed = []\n1472             for name, var in self.items():\n1473                 try:\n1474                     var[key] = value[name]\n1475                     processed.append(name)\n1476                 except Exception as e:\n1477                     if processed:\n1478                         raise RuntimeError(\n1479                             \"An error occurred while setting values of the\"\n1480                             f\" variable '{name}'. The following variables have\"\n1481                             f\" been successfully updated:\\n{processed}\"\n1482                         ) from e\n1483                     else:\n1484                         raise e\n1485 \n1486         elif utils.hashable(key):\n1487             if isinstance(value, Dataset):\n1488                 raise TypeError(\n1489                     \"Cannot assign a Dataset to a single key - only a DataArray or Variable \"\n1490                     \"object can be stored under a single key.\"\n1491                 )\n1492             self.update({key: value})\n1493 \n1494         elif utils.iterable_of_hashable(key):\n1495             keylist = list(key)\n1496             if len(keylist) == 0:\n1497                 raise ValueError(\"Empty list of variables to be set\")\n1498             if len(keylist) == 1:\n1499                 self.update({keylist[0]: value})\n1500             else:\n1501                 if len(keylist) != len(value):\n1502                     raise ValueError(\n1503                         f\"Different lengths of variables to be set \"\n1504                         f\"({len(keylist)}) and data used as input for \"\n1505                         f\"setting ({len(value)})\"\n1506                     )\n1507                 if isinstance(value, Dataset):\n1508                     self.update(dict(zip(keylist, value.data_vars.values())))\n1509                 elif isinstance(value, DataArray):\n1510                     raise ValueError(\"Cannot assign single DataArray to multiple keys\")\n1511                 else:\n1512                     self.update(dict(zip(keylist, value)))\n1513 \n1514         else:\n1515             raise ValueError(f\"Unsupported key-type {type(key)}\")\n1516 \n1517     def _setitem_check(self, key, value):\n1518         \"\"\"Consistency check for __setitem__\n1519 \n1520         When assigning values to a subset of a Dataset, do consistency check beforehand\n1521         to avoid leaving the dataset in a partially updated state when an error occurs.\n1522         \"\"\"\n1523         from xarray.core.alignment import align\n1524         from xarray.core.dataarray import DataArray\n1525 \n1526         if isinstance(value, Dataset):\n1527             missing_vars = [\n1528                 name for name in value.data_vars if name not in self.data_vars\n1529             ]\n1530             if missing_vars:\n1531                 raise ValueError(\n1532                     f\"Variables {missing_vars} in new values\"\n1533                     f\" not available in original dataset:\\n{self}\"\n1534                 )\n1535         elif not any([isinstance(value, t) for t in [DataArray, Number, str]]):\n1536             raise TypeError(\n1537                 \"Dataset assignment only accepts DataArrays, Datasets, and scalars.\"\n1538             )\n1539 \n1540         new_value = Dataset()\n1541         for name, var in self.items():\n1542             # test indexing\n1543             try:\n1544                 var_k = var[key]\n1545             except Exception as e:\n1546                 raise ValueError(\n1547                     f\"Variable '{name}': indexer {key} not available\"\n1548                 ) from e\n1549 \n1550             if isinstance(value, Dataset):\n1551                 val = value[name]\n1552             else:\n1553                 val = value\n1554 \n1555             if isinstance(val, DataArray):\n1556                 # check consistency of dimensions\n1557                 for dim in val.dims:\n1558                     if dim not in var_k.dims:\n1559                         raise KeyError(\n1560                             f\"Variable '{name}': dimension '{dim}' appears in new values \"\n1561                             f\"but not in the indexed original data\"\n1562                         )\n1563                 dims = tuple(dim for dim in var_k.dims if dim in val.dims)\n1564                 if dims != val.dims:\n1565                     raise ValueError(\n1566                         f\"Variable '{name}': dimension order differs between\"\n1567                         f\" original and new data:\\n{dims}\\nvs.\\n{val.dims}\"\n1568                     )\n1569             else:\n1570                 val = np.array(val)\n1571 \n1572             # type conversion\n1573             new_value[name] = val.astype(var_k.dtype, copy=False)\n1574 \n1575         # check consistency of dimension sizes and dimension coordinates\n1576         if isinstance(value, DataArray) or isinstance(value, Dataset):\n1577             align(self[key], value, join=\"exact\", copy=False)\n1578 \n1579         return new_value\n1580 \n1581     def __delitem__(self, key: Hashable) -> None:\n1582         \"\"\"Remove a variable from this dataset.\"\"\"\n1583         assert_no_index_corrupted(self.xindexes, {key})\n1584 \n1585         if key in self._indexes:\n1586             del self._indexes[key]\n1587         del self._variables[key]\n1588         self._coord_names.discard(key)\n1589         self._dims = calculate_dimensions(self._variables)\n1590 \n1591     # mutable objects should not be hashable\n1592     # https://github.com/python/mypy/issues/4266\n1593     __hash__ = None  # type: ignore[assignment]\n1594 \n1595     def _all_compat(self, other: Dataset, compat_str: str) -> bool:\n1596         \"\"\"Helper function for equals and identical\"\"\"\n1597 \n1598         # some stores (e.g., scipy) do not seem to preserve order, so don't\n1599         # require matching order for equality\n1600         def compat(x: Variable, y: Variable) -> bool:\n1601             return getattr(x, compat_str)(y)\n1602 \n1603         return self._coord_names == other._coord_names and utils.dict_equiv(\n1604             self._variables, other._variables, compat=compat\n1605         )\n1606 \n1607     def broadcast_equals(self, other: Dataset) -> bool:\n1608         \"\"\"Two Datasets are broadcast equal if they are equal after\n1609         broadcasting all variables against each other.\n1610 \n1611         For example, variables that are scalar in one dataset but non-scalar in\n1612         the other dataset can still be broadcast equal if the the non-scalar\n1613         variable is a constant.\n1614 \n1615         See Also\n1616         --------\n1617         Dataset.equals\n1618         Dataset.identical\n1619         \"\"\"\n1620         try:\n1621             return self._all_compat(other, \"broadcast_equals\")\n1622         except (TypeError, AttributeError):\n1623             return False\n1624 \n1625     def equals(self, other: Dataset) -> bool:\n1626         \"\"\"Two Datasets are equal if they have matching variables and\n1627         coordinates, all of which are equal.\n1628 \n1629         Datasets can still be equal (like pandas objects) if they have NaN\n1630         values in the same locations.\n1631 \n1632         This method is necessary because `v1 == v2` for ``Dataset``\n1633         does element-wise comparisons (like numpy.ndarrays).\n1634 \n1635         See Also\n1636         --------\n1637         Dataset.broadcast_equals\n1638         Dataset.identical\n1639         \"\"\"\n1640         try:\n1641             return self._all_compat(other, \"equals\")\n1642         except (TypeError, AttributeError):\n1643             return False\n1644 \n1645     def identical(self, other: Dataset) -> bool:\n1646         \"\"\"Like equals, but also checks all dataset attributes and the\n1647         attributes on all variables and coordinates.\n1648 \n1649         See Also\n1650         --------\n1651         Dataset.broadcast_equals\n1652         Dataset.equals\n1653         \"\"\"\n1654         try:\n1655             return utils.dict_equiv(self.attrs, other.attrs) and self._all_compat(\n1656                 other, \"identical\"\n1657             )\n1658         except (TypeError, AttributeError):\n1659             return False\n1660 \n1661     @property\n1662     def indexes(self) -> Indexes[pd.Index]:\n1663         \"\"\"Mapping of pandas.Index objects used for label based indexing.\n1664 \n1665         Raises an error if this Dataset has indexes that cannot be coerced\n1666         to pandas.Index objects.\n1667 \n1668         See Also\n1669         --------\n1670         Dataset.xindexes\n1671 \n1672         \"\"\"\n1673         return self.xindexes.to_pandas_indexes()\n1674 \n1675     @property\n1676     def xindexes(self) -> Indexes[Index]:\n1677         \"\"\"Mapping of xarray Index objects used for label based indexing.\"\"\"\n1678         return Indexes(self._indexes, {k: self._variables[k] for k in self._indexes})\n1679 \n1680     @property\n1681     def coords(self) -> DatasetCoordinates:\n1682         \"\"\"Dictionary of xarray.DataArray objects corresponding to coordinate\n1683         variables\n1684         \"\"\"\n1685         return DatasetCoordinates(self)\n1686 \n1687     @property\n1688     def data_vars(self) -> DataVariables:\n1689         \"\"\"Dictionary of DataArray objects corresponding to data variables\"\"\"\n1690         return DataVariables(self)\n1691 \n1692     def set_coords(self: T_Dataset, names: Hashable | Iterable[Hashable]) -> T_Dataset:\n1693         \"\"\"Given names of one or more variables, set them as coordinates\n1694 \n1695         Parameters\n1696         ----------\n1697         names : hashable or iterable of hashable\n1698             Name(s) of variables in this dataset to convert into coordinates.\n1699 \n1700         Returns\n1701         -------\n1702         Dataset\n1703 \n1704         See Also\n1705         --------\n1706         Dataset.swap_dims\n1707         Dataset.assign_coords\n1708         \"\"\"\n1709         # TODO: allow inserting new coordinates with this method, like\n1710         # DataFrame.set_index?\n1711         # nb. check in self._variables, not self.data_vars to insure that the\n1712         # operation is idempotent\n1713         if isinstance(names, str) or not isinstance(names, Iterable):\n1714             names = [names]\n1715         else:\n1716             names = list(names)\n1717         self._assert_all_in_dataset(names)\n1718         obj = self.copy()\n1719         obj._coord_names.update(names)\n1720         return obj\n1721 \n1722     def reset_coords(\n1723         self: T_Dataset,\n1724         names: Dims = None,\n1725         drop: bool = False,\n1726     ) -> T_Dataset:\n1727         \"\"\"Given names of coordinates, reset them to become variables\n1728 \n1729         Parameters\n1730         ----------\n1731         names : str, Iterable of Hashable or None, optional\n1732             Name(s) of non-index coordinates in this dataset to reset into\n1733             variables. By default, all non-index coordinates are reset.\n1734         drop : bool, default: False\n1735             If True, remove coordinates instead of converting them into\n1736             variables.\n1737 \n1738         Returns\n1739         -------\n1740         Dataset\n1741         \"\"\"\n1742         if names is None:\n1743             names = self._coord_names - set(self._indexes)\n1744         else:\n1745             if isinstance(names, str) or not isinstance(names, Iterable):\n1746                 names = [names]\n1747             else:\n1748                 names = list(names)\n1749             self._assert_all_in_dataset(names)\n1750             bad_coords = set(names) & set(self._indexes)\n1751             if bad_coords:\n1752                 raise ValueError(\n1753                     f\"cannot remove index coordinates with reset_coords: {bad_coords}\"\n1754                 )\n1755         obj = self.copy()\n1756         obj._coord_names.difference_update(names)\n1757         if drop:\n1758             for name in names:\n1759                 del obj._variables[name]\n1760         return obj\n1761 \n1762     def dump_to_store(self, store: AbstractDataStore, **kwargs) -> None:\n1763         \"\"\"Store dataset contents to a backends.*DataStore object.\"\"\"\n1764         from xarray.backends.api import dump_to_store\n1765 \n1766         # TODO: rename and/or cleanup this method to make it more consistent\n1767         # with to_netcdf()\n1768         dump_to_store(self, store, **kwargs)\n1769 \n1770     # path=None writes to bytes\n1771     @overload\n1772     def to_netcdf(\n1773         self,\n1774         path: None = None,\n1775         mode: Literal[\"w\", \"a\"] = \"w\",\n1776         format: T_NetcdfTypes | None = None,\n1777         group: str | None = None,\n1778         engine: T_NetcdfEngine | None = None,\n1779         encoding: Mapping[Any, Mapping[str, Any]] | None = None,\n1780         unlimited_dims: Iterable[Hashable] | None = None,\n1781         compute: bool = True,\n1782         invalid_netcdf: bool = False,\n1783     ) -> bytes:\n1784         ...\n1785 \n1786     # default return None\n1787     @overload\n1788     def to_netcdf(\n1789         self,\n1790         path: str | PathLike,\n1791         mode: Literal[\"w\", \"a\"] = \"w\",\n1792         format: T_NetcdfTypes | None = None,\n1793         group: str | None = None,\n1794         engine: T_NetcdfEngine | None = None,\n1795         encoding: Mapping[Any, Mapping[str, Any]] | None = None,\n1796         unlimited_dims: Iterable[Hashable] | None = None,\n1797         compute: Literal[True] = True,\n1798         invalid_netcdf: bool = False,\n1799     ) -> None:\n1800         ...\n1801 \n1802     # compute=False returns dask.Delayed\n1803     @overload\n1804     def to_netcdf(\n1805         self,\n1806         path: str | PathLike,\n1807         mode: Literal[\"w\", \"a\"] = \"w\",\n1808         format: T_NetcdfTypes | None = None,\n1809         group: str | None = None,\n1810         engine: T_NetcdfEngine | None = None,\n1811         encoding: Mapping[Any, Mapping[str, Any]] | None = None,\n1812         unlimited_dims: Iterable[Hashable] | None = None,\n1813         *,\n1814         compute: Literal[False],\n1815         invalid_netcdf: bool = False,\n1816     ) -> Delayed:\n1817         ...\n1818 \n1819     def to_netcdf(\n1820         self,\n1821         path: str | PathLike | None = None,\n1822         mode: Literal[\"w\", \"a\"] = \"w\",\n1823         format: T_NetcdfTypes | None = None,\n1824         group: str | None = None,\n1825         engine: T_NetcdfEngine | None = None,\n1826         encoding: Mapping[Any, Mapping[str, Any]] | None = None,\n1827         unlimited_dims: Iterable[Hashable] | None = None,\n1828         compute: bool = True,\n1829         invalid_netcdf: bool = False,\n1830     ) -> bytes | Delayed | None:\n1831         \"\"\"Write dataset contents to a netCDF file.\n1832 \n1833         Parameters\n1834         ----------\n1835         path : str, path-like or file-like, optional\n1836             Path to which to save this dataset. File-like objects are only\n1837             supported by the scipy engine. If no path is provided, this\n1838             function returns the resulting netCDF file as bytes; in this case,\n1839             we need to use scipy, which does not support netCDF version 4 (the\n1840             default format becomes NETCDF3_64BIT).\n1841         mode : {\"w\", \"a\"}, default: \"w\"\n1842             Write ('w') or append ('a') mode. If mode='w', any existing file at\n1843             this location will be overwritten. If mode='a', existing variables\n1844             will be overwritten.\n1845         format : {\"NETCDF4\", \"NETCDF4_CLASSIC\", \"NETCDF3_64BIT\", \\\n1846                   \"NETCDF3_CLASSIC\"}, optional\n1847             File format for the resulting netCDF file:\n1848 \n1849             * NETCDF4: Data is stored in an HDF5 file, using netCDF4 API\n1850               features.\n1851             * NETCDF4_CLASSIC: Data is stored in an HDF5 file, using only\n1852               netCDF 3 compatible API features.\n1853             * NETCDF3_64BIT: 64-bit offset version of the netCDF 3 file format,\n1854               which fully supports 2+ GB files, but is only compatible with\n1855               clients linked against netCDF version 3.6.0 or later.\n1856             * NETCDF3_CLASSIC: The classic netCDF 3 file format. It does not\n1857               handle 2+ GB files very well.\n1858 \n1859             All formats are supported by the netCDF4-python library.\n1860             scipy.io.netcdf only supports the last two formats.\n1861 \n1862             The default format is NETCDF4 if you are saving a file to disk and\n1863             have the netCDF4-python library available. Otherwise, xarray falls\n1864             back to using scipy to write netCDF files and defaults to the\n1865             NETCDF3_64BIT format (scipy does not support netCDF4).\n1866         group : str, optional\n1867             Path to the netCDF4 group in the given file to open (only works for\n1868             format='NETCDF4'). The group(s) will be created if necessary.\n1869         engine : {\"netcdf4\", \"scipy\", \"h5netcdf\"}, optional\n1870             Engine to use when writing netCDF files. If not provided, the\n1871             default engine is chosen based on available dependencies, with a\n1872             preference for 'netcdf4' if writing to a file on disk.\n1873         encoding : dict, optional\n1874             Nested dictionary with variable names as keys and dictionaries of\n1875             variable specific encodings as values, e.g.,\n1876             ``{\"my_variable\": {\"dtype\": \"int16\", \"scale_factor\": 0.1,\n1877             \"zlib\": True}, ...}``\n1878 \n1879             The `h5netcdf` engine supports both the NetCDF4-style compression\n1880             encoding parameters ``{\"zlib\": True, \"complevel\": 9}`` and the h5py\n1881             ones ``{\"compression\": \"gzip\", \"compression_opts\": 9}``.\n1882             This allows using any compression plugin installed in the HDF5\n1883             library, e.g. LZF.\n1884 \n1885         unlimited_dims : iterable of hashable, optional\n1886             Dimension(s) that should be serialized as unlimited dimensions.\n1887             By default, no dimensions are treated as unlimited dimensions.\n1888             Note that unlimited_dims may also be set via\n1889             ``dataset.encoding[\"unlimited_dims\"]``.\n1890         compute: bool, default: True\n1891             If true compute immediately, otherwise return a\n1892             ``dask.delayed.Delayed`` object that can be computed later.\n1893         invalid_netcdf: bool, default: False\n1894             Only valid along with ``engine=\"h5netcdf\"``. If True, allow writing\n1895             hdf5 files which are invalid netcdf as described in\n1896             https://github.com/h5netcdf/h5netcdf.\n1897 \n1898         Returns\n1899         -------\n1900             * ``bytes`` if path is None\n1901             * ``dask.delayed.Delayed`` if compute is False\n1902             * None otherwise\n1903 \n1904         See Also\n1905         --------\n1906         DataArray.to_netcdf\n1907         \"\"\"\n1908         if encoding is None:\n1909             encoding = {}\n1910         from xarray.backends.api import to_netcdf\n1911 \n1912         return to_netcdf(  # type: ignore  # mypy cannot resolve the overloads:(\n1913             self,\n1914             path,\n1915             mode=mode,\n1916             format=format,\n1917             group=group,\n1918             engine=engine,\n1919             encoding=encoding,\n1920             unlimited_dims=unlimited_dims,\n1921             compute=compute,\n1922             multifile=False,\n1923             invalid_netcdf=invalid_netcdf,\n1924         )\n1925 \n1926     # compute=True (default) returns ZarrStore\n1927     @overload\n1928     def to_zarr(\n1929         self,\n1930         store: MutableMapping | str | PathLike[str] | None = None,\n1931         chunk_store: MutableMapping | str | PathLike | None = None,\n1932         mode: Literal[\"w\", \"w-\", \"a\", \"r+\", None] = None,\n1933         synchronizer=None,\n1934         group: str | None = None,\n1935         encoding: Mapping | None = None,\n1936         compute: Literal[True] = True,\n1937         consolidated: bool | None = None,\n1938         append_dim: Hashable | None = None,\n1939         region: Mapping[str, slice] | None = None,\n1940         safe_chunks: bool = True,\n1941         storage_options: dict[str, str] | None = None,\n1942         zarr_version: int | None = None,\n1943     ) -> ZarrStore:\n1944         ...\n1945 \n1946     # compute=False returns dask.Delayed\n1947     @overload\n1948     def to_zarr(\n1949         self,\n1950         store: MutableMapping | str | PathLike[str] | None = None,\n1951         chunk_store: MutableMapping | str | PathLike | None = None,\n1952         mode: Literal[\"w\", \"w-\", \"a\", \"r+\", None] = None,\n1953         synchronizer=None,\n1954         group: str | None = None,\n1955         encoding: Mapping | None = None,\n1956         *,\n1957         compute: Literal[False],\n1958         consolidated: bool | None = None,\n1959         append_dim: Hashable | None = None,\n1960         region: Mapping[str, slice] | None = None,\n1961         safe_chunks: bool = True,\n1962         storage_options: dict[str, str] | None = None,\n1963     ) -> Delayed:\n1964         ...\n1965 \n1966     def to_zarr(\n1967         self,\n1968         store: MutableMapping | str | PathLike[str] | None = None,\n1969         chunk_store: MutableMapping | str | PathLike | None = None,\n1970         mode: Literal[\"w\", \"w-\", \"a\", \"r+\", None] = None,\n1971         synchronizer=None,\n1972         group: str | None = None,\n1973         encoding: Mapping | None = None,\n1974         compute: bool = True,\n1975         consolidated: bool | None = None,\n1976         append_dim: Hashable | None = None,\n1977         region: Mapping[str, slice] | None = None,\n1978         safe_chunks: bool = True,\n1979         storage_options: dict[str, str] | None = None,\n1980         zarr_version: int | None = None,\n1981     ) -> ZarrStore | Delayed:\n1982         \"\"\"Write dataset contents to a zarr group.\n1983 \n1984         Zarr chunks are determined in the following way:\n1985 \n1986         - From the ``chunks`` attribute in each variable's ``encoding``\n1987           (can be set via `Dataset.chunk`).\n1988         - If the variable is a Dask array, from the dask chunks\n1989         - If neither Dask chunks nor encoding chunks are present, chunks will\n1990           be determined automatically by Zarr\n1991         - If both Dask chunks and encoding chunks are present, encoding chunks\n1992           will be used, provided that there is a many-to-one relationship between\n1993           encoding chunks and dask chunks (i.e. Dask chunks are bigger than and\n1994           evenly divide encoding chunks); otherwise raise a ``ValueError``.\n1995           This restriction ensures that no synchronization / locks are required\n1996           when writing. To disable this restriction, use ``safe_chunks=False``.\n1997 \n1998         Parameters\n1999         ----------\n2000         store : MutableMapping, str or path-like, optional\n2001             Store or path to directory in local or remote file system.\n2002         chunk_store : MutableMapping, str or path-like, optional\n2003             Store or path to directory in local or remote file system only for Zarr\n2004             array chunks. Requires zarr-python v2.4.0 or later.\n2005         mode : {\"w\", \"w-\", \"a\", \"r+\", None}, optional\n2006             Persistence mode: \"w\" means create (overwrite if exists);\n2007             \"w-\" means create (fail if exists);\n2008             \"a\" means override existing variables (create if does not exist);\n2009             \"r+\" means modify existing array *values* only (raise an error if\n2010             any metadata or shapes would change).\n2011             The default mode is \"a\" if ``append_dim`` is set. Otherwise, it is\n2012             \"r+\" if ``region`` is set and ``w-`` otherwise.\n2013         synchronizer : object, optional\n2014             Zarr array synchronizer.\n2015         group : str, optional\n2016             Group path. (a.k.a. `path` in zarr terminology.)\n2017         encoding : dict, optional\n2018             Nested dictionary with variable names as keys and dictionaries of\n2019             variable specific encodings as values, e.g.,\n2020             ``{\"my_variable\": {\"dtype\": \"int16\", \"scale_factor\": 0.1,}, ...}``\n2021         compute : bool, optional\n2022             If True write array data immediately, otherwise return a\n2023             ``dask.delayed.Delayed`` object that can be computed to write\n2024             array data later. Metadata is always updated eagerly.\n2025         consolidated : bool, optional\n2026             If True, apply zarr's `consolidate_metadata` function to the store\n2027             after writing metadata and read existing stores with consolidated\n2028             metadata; if False, do not. The default (`consolidated=None`) means\n2029             write consolidated metadata and attempt to read consolidated\n2030             metadata for existing stores (falling back to non-consolidated).\n2031 \n2032             When the experimental ``zarr_version=3``, ``consolidated`` must be\n2033             either be ``None`` or ``False``.\n2034         append_dim : hashable, optional\n2035             If set, the dimension along which the data will be appended. All\n2036             other dimensions on overridden variables must remain the same size.\n2037         region : dict, optional\n2038             Optional mapping from dimension names to integer slices along\n2039             dataset dimensions to indicate the region of existing zarr array(s)\n2040             in which to write this dataset's data. For example,\n2041             ``{'x': slice(0, 1000), 'y': slice(10000, 11000)}`` would indicate\n2042             that values should be written to the region ``0:1000`` along ``x``\n2043             and ``10000:11000`` along ``y``.\n2044 \n2045             Two restrictions apply to the use of ``region``:\n2046 \n2047             - If ``region`` is set, _all_ variables in a dataset must have at\n2048               least one dimension in common with the region. Other variables\n2049               should be written in a separate call to ``to_zarr()``.\n2050             - Dimensions cannot be included in both ``region`` and\n2051               ``append_dim`` at the same time. To create empty arrays to fill\n2052               in with ``region``, use a separate call to ``to_zarr()`` with\n2053               ``compute=False``. See \"Appending to existing Zarr stores\" in\n2054               the reference documentation for full details.\n2055         safe_chunks : bool, optional\n2056             If True, only allow writes to when there is a many-to-one relationship\n2057             between Zarr chunks (specified in encoding) and Dask chunks.\n2058             Set False to override this restriction; however, data may become corrupted\n2059             if Zarr arrays are written in parallel. This option may be useful in combination\n2060             with ``compute=False`` to initialize a Zarr from an existing\n2061             Dataset with arbitrary chunk structure.\n2062         storage_options : dict, optional\n2063             Any additional parameters for the storage backend (ignored for local\n2064             paths).\n2065         zarr_version : int or None, optional\n2066             The desired zarr spec version to target (currently 2 or 3). The\n2067             default of None will attempt to determine the zarr version from\n2068             ``store`` when possible, otherwise defaulting to 2.\n2069 \n2070         Returns\n2071         -------\n2072             * ``dask.delayed.Delayed`` if compute is False\n2073             * ZarrStore otherwise\n2074 \n2075         References\n2076         ----------\n2077         https://zarr.readthedocs.io/\n2078 \n2079         Notes\n2080         -----\n2081         Zarr chunking behavior:\n2082             If chunks are found in the encoding argument or attribute\n2083             corresponding to any DataArray, those chunks are used.\n2084             If a DataArray is a dask array, it is written with those chunks.\n2085             If not other chunks are found, Zarr uses its own heuristics to\n2086             choose automatic chunk sizes.\n2087 \n2088         encoding:\n2089             The encoding attribute (if exists) of the DataArray(s) will be\n2090             used. Override any existing encodings by providing the ``encoding`` kwarg.\n2091 \n2092         See Also\n2093         --------\n2094         :ref:`io.zarr`\n2095             The I/O user guide, with more details and examples.\n2096         \"\"\"\n2097         from xarray.backends.api import to_zarr\n2098 \n2099         return to_zarr(  # type: ignore\n2100             self,\n2101             store=store,\n2102             chunk_store=chunk_store,\n2103             storage_options=storage_options,\n2104             mode=mode,\n2105             synchronizer=synchronizer,\n2106             group=group,\n2107             encoding=encoding,\n2108             compute=compute,\n2109             consolidated=consolidated,\n2110             append_dim=append_dim,\n2111             region=region,\n2112             safe_chunks=safe_chunks,\n2113             zarr_version=zarr_version,\n2114         )\n2115 \n2116     def __repr__(self) -> str:\n2117         return formatting.dataset_repr(self)\n2118 \n2119     def _repr_html_(self) -> str:\n2120         if OPTIONS[\"display_style\"] == \"text\":\n2121             return f\"<pre>{escape(repr(self))}</pre>\"\n2122         return formatting_html.dataset_repr(self)\n2123 \n2124     def info(self, buf: IO | None = None) -> None:\n2125         \"\"\"\n2126         Concise summary of a Dataset variables and attributes.\n2127 \n2128         Parameters\n2129         ----------\n2130         buf : file-like, default: sys.stdout\n2131             writable buffer\n2132 \n2133         See Also\n2134         --------\n2135         pandas.DataFrame.assign\n2136         ncdump : netCDF's ncdump\n2137         \"\"\"\n2138         if buf is None:  # pragma: no cover\n2139             buf = sys.stdout\n2140 \n2141         lines = []\n2142         lines.append(\"xarray.Dataset {\")\n2143         lines.append(\"dimensions:\")\n2144         for name, size in self.dims.items():\n2145             lines.append(f\"\\t{name} = {size} ;\")\n2146         lines.append(\"\\nvariables:\")\n2147         for name, da in self.variables.items():\n2148             dims = \", \".join(map(str, da.dims))\n2149             lines.append(f\"\\t{da.dtype} {name}({dims}) ;\")\n2150             for k, v in da.attrs.items():\n2151                 lines.append(f\"\\t\\t{name}:{k} = {v} ;\")\n2152         lines.append(\"\\n// global attributes:\")\n2153         for k, v in self.attrs.items():\n2154             lines.append(f\"\\t:{k} = {v} ;\")\n2155         lines.append(\"}\")\n2156 \n2157         buf.write(\"\\n\".join(lines))\n2158 \n2159     @property\n2160     def chunks(self) -> Mapping[Hashable, tuple[int, ...]]:\n2161         \"\"\"\n2162         Mapping from dimension names to block lengths for this dataset's data, or None if\n2163         the underlying data is not a dask array.\n2164         Cannot be modified directly, but can be modified by calling .chunk().\n2165 \n2166         Same as Dataset.chunksizes, but maintained for backwards compatibility.\n2167 \n2168         See Also\n2169         --------\n2170         Dataset.chunk\n2171         Dataset.chunksizes\n2172         xarray.unify_chunks\n2173         \"\"\"\n2174         return get_chunksizes(self.variables.values())\n2175 \n2176     @property\n2177     def chunksizes(self) -> Mapping[Hashable, tuple[int, ...]]:\n2178         \"\"\"\n2179         Mapping from dimension names to block lengths for this dataset's data, or None if\n2180         the underlying data is not a dask array.\n2181         Cannot be modified directly, but can be modified by calling .chunk().\n2182 \n2183         Same as Dataset.chunks.\n2184 \n2185         See Also\n2186         --------\n2187         Dataset.chunk\n2188         Dataset.chunks\n2189         xarray.unify_chunks\n2190         \"\"\"\n2191         return get_chunksizes(self.variables.values())\n2192 \n2193     def chunk(\n2194         self: T_Dataset,\n2195         chunks: (\n2196             int | Literal[\"auto\"] | Mapping[Any, None | int | str | tuple[int, ...]]\n2197         ) = {},  # {} even though it's technically unsafe, is being used intentionally here (#4667)\n2198         name_prefix: str = \"xarray-\",\n2199         token: str | None = None,\n2200         lock: bool = False,\n2201         inline_array: bool = False,\n2202         **chunks_kwargs: None | int | str | tuple[int, ...],\n2203     ) -> T_Dataset:\n2204         \"\"\"Coerce all arrays in this dataset into dask arrays with the given\n2205         chunks.\n2206 \n2207         Non-dask arrays in this dataset will be converted to dask arrays. Dask\n2208         arrays will be rechunked to the given chunk sizes.\n2209 \n2210         If neither chunks is not provided for one or more dimensions, chunk\n2211         sizes along that dimension will not be updated; non-dask arrays will be\n2212         converted into dask arrays with a single block.\n2213 \n2214         Parameters\n2215         ----------\n2216         chunks : int, tuple of int, \"auto\" or mapping of hashable to int, optional\n2217             Chunk sizes along each dimension, e.g., ``5``, ``\"auto\"``, or\n2218             ``{\"x\": 5, \"y\": 5}``.\n2219         name_prefix : str, default: \"xarray-\"\n2220             Prefix for the name of any new dask arrays.\n2221         token : str, optional\n2222             Token uniquely identifying this dataset.\n2223         lock : bool, default: False\n2224             Passed on to :py:func:`dask.array.from_array`, if the array is not\n2225             already as dask array.\n2226         inline_array: bool, default: False\n2227             Passed on to :py:func:`dask.array.from_array`, if the array is not\n2228             already as dask array.\n2229         **chunks_kwargs : {dim: chunks, ...}, optional\n2230             The keyword arguments form of ``chunks``.\n2231             One of chunks or chunks_kwargs must be provided\n2232 \n2233         Returns\n2234         -------\n2235         chunked : xarray.Dataset\n2236 \n2237         See Also\n2238         --------\n2239         Dataset.chunks\n2240         Dataset.chunksizes\n2241         xarray.unify_chunks\n2242         dask.array.from_array\n2243         \"\"\"\n2244         if chunks is None and chunks_kwargs is None:\n2245             warnings.warn(\n2246                 \"None value for 'chunks' is deprecated. \"\n2247                 \"It will raise an error in the future. Use instead '{}'\",\n2248                 category=FutureWarning,\n2249             )\n2250             chunks = {}\n2251 \n2252         if isinstance(chunks, (Number, str, int)):\n2253             chunks = dict.fromkeys(self.dims, chunks)\n2254         else:\n2255             chunks = either_dict_or_kwargs(chunks, chunks_kwargs, \"chunk\")\n2256 \n2257         bad_dims = chunks.keys() - self.dims.keys()\n2258         if bad_dims:\n2259             raise ValueError(\n2260                 f\"some chunks keys are not dimensions on this object: {bad_dims}\"\n2261             )\n2262 \n2263         variables = {\n2264             k: _maybe_chunk(k, v, chunks, token, lock, name_prefix)\n2265             for k, v in self.variables.items()\n2266         }\n2267         return self._replace(variables)\n2268 \n2269     def _validate_indexers(\n2270         self, indexers: Mapping[Any, Any], missing_dims: ErrorOptionsWithWarn = \"raise\"\n2271     ) -> Iterator[tuple[Hashable, int | slice | np.ndarray | Variable]]:\n2272         \"\"\"Here we make sure\n2273         + indexer has a valid keys\n2274         + indexer is in a valid data type\n2275         + string indexers are cast to the appropriate date type if the\n2276           associated index is a DatetimeIndex or CFTimeIndex\n2277         \"\"\"\n2278         from xarray.coding.cftimeindex import CFTimeIndex\n2279         from xarray.core.dataarray import DataArray\n2280 \n2281         indexers = drop_dims_from_indexers(indexers, self.dims, missing_dims)\n2282 \n2283         # all indexers should be int, slice, np.ndarrays, or Variable\n2284         for k, v in indexers.items():\n2285             if isinstance(v, (int, slice, Variable)):\n2286                 yield k, v\n2287             elif isinstance(v, DataArray):\n2288                 yield k, v.variable\n2289             elif isinstance(v, tuple):\n2290                 yield k, as_variable(v)\n2291             elif isinstance(v, Dataset):\n2292                 raise TypeError(\"cannot use a Dataset as an indexer\")\n2293             elif isinstance(v, Sequence) and len(v) == 0:\n2294                 yield k, np.empty((0,), dtype=\"int64\")\n2295             else:\n2296                 v = np.asarray(v)\n2297 \n2298                 if v.dtype.kind in \"US\":\n2299                     index = self._indexes[k].to_pandas_index()\n2300                     if isinstance(index, pd.DatetimeIndex):\n2301                         v = v.astype(\"datetime64[ns]\")\n2302                     elif isinstance(index, CFTimeIndex):\n2303                         v = _parse_array_of_cftime_strings(v, index.date_type)\n2304 \n2305                 if v.ndim > 1:\n2306                     raise IndexError(\n2307                         \"Unlabeled multi-dimensional array cannot be \"\n2308                         \"used for indexing: {}\".format(k)\n2309                     )\n2310                 yield k, v\n2311 \n2312     def _validate_interp_indexers(\n2313         self, indexers: Mapping[Any, Any]\n2314     ) -> Iterator[tuple[Hashable, Variable]]:\n2315         \"\"\"Variant of _validate_indexers to be used for interpolation\"\"\"\n2316         for k, v in self._validate_indexers(indexers):\n2317             if isinstance(v, Variable):\n2318                 if v.ndim == 1:\n2319                     yield k, v.to_index_variable()\n2320                 else:\n2321                     yield k, v\n2322             elif isinstance(v, int):\n2323                 yield k, Variable((), v, attrs=self.coords[k].attrs)\n2324             elif isinstance(v, np.ndarray):\n2325                 if v.ndim == 0:\n2326                     yield k, Variable((), v, attrs=self.coords[k].attrs)\n2327                 elif v.ndim == 1:\n2328                     yield k, IndexVariable((k,), v, attrs=self.coords[k].attrs)\n2329                 else:\n2330                     raise AssertionError()  # Already tested by _validate_indexers\n2331             else:\n2332                 raise TypeError(type(v))\n2333 \n2334     def _get_indexers_coords_and_indexes(self, indexers):\n2335         \"\"\"Extract coordinates and indexes from indexers.\n2336 \n2337         Only coordinate with a name different from any of self.variables will\n2338         be attached.\n2339         \"\"\"\n2340         from xarray.core.dataarray import DataArray\n2341 \n2342         coords_list = []\n2343         for k, v in indexers.items():\n2344             if isinstance(v, DataArray):\n2345                 if v.dtype.kind == \"b\":\n2346                     if v.ndim != 1:  # we only support 1-d boolean array\n2347                         raise ValueError(\n2348                             \"{:d}d-boolean array is used for indexing along \"\n2349                             \"dimension {!r}, but only 1d boolean arrays are \"\n2350                             \"supported.\".format(v.ndim, k)\n2351                         )\n2352                     # Make sure in case of boolean DataArray, its\n2353                     # coordinate also should be indexed.\n2354                     v_coords = v[v.values.nonzero()[0]].coords\n2355                 else:\n2356                     v_coords = v.coords\n2357                 coords_list.append(v_coords)\n2358 \n2359         # we don't need to call align() explicitly or check indexes for\n2360         # alignment, because merge_variables already checks for exact alignment\n2361         # between dimension coordinates\n2362         coords, indexes = merge_coordinates_without_align(coords_list)\n2363         assert_coordinate_consistent(self, coords)\n2364 \n2365         # silently drop the conflicted variables.\n2366         attached_coords = {k: v for k, v in coords.items() if k not in self._variables}\n2367         attached_indexes = {\n2368             k: v for k, v in indexes.items() if k not in self._variables\n2369         }\n2370         return attached_coords, attached_indexes\n2371 \n2372     def isel(\n2373         self: T_Dataset,\n2374         indexers: Mapping[Any, Any] | None = None,\n2375         drop: bool = False,\n2376         missing_dims: ErrorOptionsWithWarn = \"raise\",\n2377         **indexers_kwargs: Any,\n2378     ) -> T_Dataset:\n2379         \"\"\"Returns a new dataset with each array indexed along the specified\n2380         dimension(s).\n2381 \n2382         This method selects values from each array using its `__getitem__`\n2383         method, except this method does not require knowing the order of\n2384         each array's dimensions.\n2385 \n2386         Parameters\n2387         ----------\n2388         indexers : dict, optional\n2389             A dict with keys matching dimensions and values given\n2390             by integers, slice objects or arrays.\n2391             indexer can be a integer, slice, array-like or DataArray.\n2392             If DataArrays are passed as indexers, xarray-style indexing will be\n2393             carried out. See :ref:`indexing` for the details.\n2394             One of indexers or indexers_kwargs must be provided.\n2395         drop : bool, default: False\n2396             If ``drop=True``, drop coordinates variables indexed by integers\n2397             instead of making them scalar.\n2398         missing_dims : {\"raise\", \"warn\", \"ignore\"}, default: \"raise\"\n2399             What to do if dimensions that should be selected from are not present in the\n2400             Dataset:\n2401             - \"raise\": raise an exception\n2402             - \"warn\": raise a warning, and ignore the missing dimensions\n2403             - \"ignore\": ignore the missing dimensions\n2404 \n2405         **indexers_kwargs : {dim: indexer, ...}, optional\n2406             The keyword arguments form of ``indexers``.\n2407             One of indexers or indexers_kwargs must be provided.\n2408 \n2409         Returns\n2410         -------\n2411         obj : Dataset\n2412             A new Dataset with the same contents as this dataset, except each\n2413             array and dimension is indexed by the appropriate indexers.\n2414             If indexer DataArrays have coordinates that do not conflict with\n2415             this object, then these coordinates will be attached.\n2416             In general, each array's data will be a view of the array's data\n2417             in this dataset, unless vectorized indexing was triggered by using\n2418             an array indexer, in which case the data will be a copy.\n2419 \n2420         See Also\n2421         --------\n2422         Dataset.sel\n2423         DataArray.isel\n2424         \"\"\"\n2425         indexers = either_dict_or_kwargs(indexers, indexers_kwargs, \"isel\")\n2426         if any(is_fancy_indexer(idx) for idx in indexers.values()):\n2427             return self._isel_fancy(indexers, drop=drop, missing_dims=missing_dims)\n2428 \n2429         # Much faster algorithm for when all indexers are ints, slices, one-dimensional\n2430         # lists, or zero or one-dimensional np.ndarray's\n2431         indexers = drop_dims_from_indexers(indexers, self.dims, missing_dims)\n2432 \n2433         variables = {}\n2434         dims: dict[Hashable, int] = {}\n2435         coord_names = self._coord_names.copy()\n2436 \n2437         indexes, index_variables = isel_indexes(self.xindexes, indexers)\n2438 \n2439         for name, var in self._variables.items():\n2440             # preserve variable order\n2441             if name in index_variables:\n2442                 var = index_variables[name]\n2443             else:\n2444                 var_indexers = {k: v for k, v in indexers.items() if k in var.dims}\n2445                 if var_indexers:\n2446                     var = var.isel(var_indexers)\n2447                     if drop and var.ndim == 0 and name in coord_names:\n2448                         coord_names.remove(name)\n2449                         continue\n2450             variables[name] = var\n2451             dims.update(zip(var.dims, var.shape))\n2452 \n2453         return self._construct_direct(\n2454             variables=variables,\n2455             coord_names=coord_names,\n2456             dims=dims,\n2457             attrs=self._attrs,\n2458             indexes=indexes,\n2459             encoding=self._encoding,\n2460             close=self._close,\n2461         )\n2462 \n2463     def _isel_fancy(\n2464         self: T_Dataset,\n2465         indexers: Mapping[Any, Any],\n2466         *,\n2467         drop: bool,\n2468         missing_dims: ErrorOptionsWithWarn = \"raise\",\n2469     ) -> T_Dataset:\n2470         valid_indexers = dict(self._validate_indexers(indexers, missing_dims))\n2471 \n2472         variables: dict[Hashable, Variable] = {}\n2473         indexes, index_variables = isel_indexes(self.xindexes, valid_indexers)\n2474 \n2475         for name, var in self.variables.items():\n2476             if name in index_variables:\n2477                 new_var = index_variables[name]\n2478             else:\n2479                 var_indexers = {\n2480                     k: v for k, v in valid_indexers.items() if k in var.dims\n2481                 }\n2482                 if var_indexers:\n2483                     new_var = var.isel(indexers=var_indexers)\n2484                     # drop scalar coordinates\n2485                     # https://github.com/pydata/xarray/issues/6554\n2486                     if name in self.coords and drop and new_var.ndim == 0:\n2487                         continue\n2488                 else:\n2489                     new_var = var.copy(deep=False)\n2490                 if name not in indexes:\n2491                     new_var = new_var.to_base_variable()\n2492             variables[name] = new_var\n2493 \n2494         coord_names = self._coord_names & variables.keys()\n2495         selected = self._replace_with_new_dims(variables, coord_names, indexes)\n2496 \n2497         # Extract coordinates from indexers\n2498         coord_vars, new_indexes = selected._get_indexers_coords_and_indexes(indexers)\n2499         variables.update(coord_vars)\n2500         indexes.update(new_indexes)\n2501         coord_names = self._coord_names & variables.keys() | coord_vars.keys()\n2502         return self._replace_with_new_dims(variables, coord_names, indexes=indexes)\n2503 \n2504     def sel(\n2505         self: T_Dataset,\n2506         indexers: Mapping[Any, Any] | None = None,\n2507         method: str | None = None,\n2508         tolerance: int | float | Iterable[int | float] | None = None,\n2509         drop: bool = False,\n2510         **indexers_kwargs: Any,\n2511     ) -> T_Dataset:\n2512         \"\"\"Returns a new dataset with each array indexed by tick labels\n2513         along the specified dimension(s).\n2514 \n2515         In contrast to `Dataset.isel`, indexers for this method should use\n2516         labels instead of integers.\n2517 \n2518         Under the hood, this method is powered by using pandas's powerful Index\n2519         objects. This makes label based indexing essentially just as fast as\n2520         using integer indexing.\n2521 \n2522         It also means this method uses pandas's (well documented) logic for\n2523         indexing. This means you can use string shortcuts for datetime indexes\n2524         (e.g., '2000-01' to select all values in January 2000). It also means\n2525         that slices are treated as inclusive of both the start and stop values,\n2526         unlike normal Python indexing.\n2527 \n2528         Parameters\n2529         ----------\n2530         indexers : dict, optional\n2531             A dict with keys matching dimensions and values given\n2532             by scalars, slices or arrays of tick labels. For dimensions with\n2533             multi-index, the indexer may also be a dict-like object with keys\n2534             matching index level names.\n2535             If DataArrays are passed as indexers, xarray-style indexing will be\n2536             carried out. See :ref:`indexing` for the details.\n2537             One of indexers or indexers_kwargs must be provided.\n2538         method : {None, \"nearest\", \"pad\", \"ffill\", \"backfill\", \"bfill\"}, optional\n2539             Method to use for inexact matches:\n2540 \n2541             * None (default): only exact matches\n2542             * pad / ffill: propagate last valid index value forward\n2543             * backfill / bfill: propagate next valid index value backward\n2544             * nearest: use nearest valid index value\n2545         tolerance : optional\n2546             Maximum distance between original and new labels for inexact\n2547             matches. The values of the index at the matching locations must\n2548             satisfy the equation ``abs(index[indexer] - target) <= tolerance``.\n2549         drop : bool, optional\n2550             If ``drop=True``, drop coordinates variables in `indexers` instead\n2551             of making them scalar.\n2552         **indexers_kwargs : {dim: indexer, ...}, optional\n2553             The keyword arguments form of ``indexers``.\n2554             One of indexers or indexers_kwargs must be provided.\n2555 \n2556         Returns\n2557         -------\n2558         obj : Dataset\n2559             A new Dataset with the same contents as this dataset, except each\n2560             variable and dimension is indexed by the appropriate indexers.\n2561             If indexer DataArrays have coordinates that do not conflict with\n2562             this object, then these coordinates will be attached.\n2563             In general, each array's data will be a view of the array's data\n2564             in this dataset, unless vectorized indexing was triggered by using\n2565             an array indexer, in which case the data will be a copy.\n2566 \n2567         See Also\n2568         --------\n2569         Dataset.isel\n2570         DataArray.sel\n2571         \"\"\"\n2572         indexers = either_dict_or_kwargs(indexers, indexers_kwargs, \"sel\")\n2573         query_results = map_index_queries(\n2574             self, indexers=indexers, method=method, tolerance=tolerance\n2575         )\n2576 \n2577         if drop:\n2578             no_scalar_variables = {}\n2579             for k, v in query_results.variables.items():\n2580                 if v.dims:\n2581                     no_scalar_variables[k] = v\n2582                 else:\n2583                     if k in self._coord_names:\n2584                         query_results.drop_coords.append(k)\n2585             query_results.variables = no_scalar_variables\n2586 \n2587         result = self.isel(indexers=query_results.dim_indexers, drop=drop)\n2588         return result._overwrite_indexes(*query_results.as_tuple()[1:])\n2589 \n2590     def head(\n2591         self: T_Dataset,\n2592         indexers: Mapping[Any, int] | int | None = None,\n2593         **indexers_kwargs: Any,\n2594     ) -> T_Dataset:\n2595         \"\"\"Returns a new dataset with the first `n` values of each array\n2596         for the specified dimension(s).\n2597 \n2598         Parameters\n2599         ----------\n2600         indexers : dict or int, default: 5\n2601             A dict with keys matching dimensions and integer values `n`\n2602             or a single integer `n` applied over all dimensions.\n2603             One of indexers or indexers_kwargs must be provided.\n2604         **indexers_kwargs : {dim: n, ...}, optional\n2605             The keyword arguments form of ``indexers``.\n2606             One of indexers or indexers_kwargs must be provided.\n2607 \n2608         See Also\n2609         --------\n2610         Dataset.tail\n2611         Dataset.thin\n2612         DataArray.head\n2613         \"\"\"\n2614         if not indexers_kwargs:\n2615             if indexers is None:\n2616                 indexers = 5\n2617             if not isinstance(indexers, int) and not is_dict_like(indexers):\n2618                 raise TypeError(\"indexers must be either dict-like or a single integer\")\n2619         if isinstance(indexers, int):\n2620             indexers = {dim: indexers for dim in self.dims}\n2621         indexers = either_dict_or_kwargs(indexers, indexers_kwargs, \"head\")\n2622         for k, v in indexers.items():\n2623             if not isinstance(v, int):\n2624                 raise TypeError(\n2625                     \"expected integer type indexer for \"\n2626                     f\"dimension {k!r}, found {type(v)!r}\"\n2627                 )\n2628             elif v < 0:\n2629                 raise ValueError(\n2630                     \"expected positive integer as indexer \"\n2631                     f\"for dimension {k!r}, found {v}\"\n2632                 )\n2633         indexers_slices = {k: slice(val) for k, val in indexers.items()}\n2634         return self.isel(indexers_slices)\n2635 \n2636     def tail(\n2637         self: T_Dataset,\n2638         indexers: Mapping[Any, int] | int | None = None,\n2639         **indexers_kwargs: Any,\n2640     ) -> T_Dataset:\n2641         \"\"\"Returns a new dataset with the last `n` values of each array\n2642         for the specified dimension(s).\n2643 \n2644         Parameters\n2645         ----------\n2646         indexers : dict or int, default: 5\n2647             A dict with keys matching dimensions and integer values `n`\n2648             or a single integer `n` applied over all dimensions.\n2649             One of indexers or indexers_kwargs must be provided.\n2650         **indexers_kwargs : {dim: n, ...}, optional\n2651             The keyword arguments form of ``indexers``.\n2652             One of indexers or indexers_kwargs must be provided.\n2653 \n2654         See Also\n2655         --------\n2656         Dataset.head\n2657         Dataset.thin\n2658         DataArray.tail\n2659         \"\"\"\n2660         if not indexers_kwargs:\n2661             if indexers is None:\n2662                 indexers = 5\n2663             if not isinstance(indexers, int) and not is_dict_like(indexers):\n2664                 raise TypeError(\"indexers must be either dict-like or a single integer\")\n2665         if isinstance(indexers, int):\n2666             indexers = {dim: indexers for dim in self.dims}\n2667         indexers = either_dict_or_kwargs(indexers, indexers_kwargs, \"tail\")\n2668         for k, v in indexers.items():\n2669             if not isinstance(v, int):\n2670                 raise TypeError(\n2671                     \"expected integer type indexer for \"\n2672                     f\"dimension {k!r}, found {type(v)!r}\"\n2673                 )\n2674             elif v < 0:\n2675                 raise ValueError(\n2676                     \"expected positive integer as indexer \"\n2677                     f\"for dimension {k!r}, found {v}\"\n2678                 )\n2679         indexers_slices = {\n2680             k: slice(-val, None) if val != 0 else slice(val)\n2681             for k, val in indexers.items()\n2682         }\n2683         return self.isel(indexers_slices)\n2684 \n2685     def thin(\n2686         self: T_Dataset,\n2687         indexers: Mapping[Any, int] | int | None = None,\n2688         **indexers_kwargs: Any,\n2689     ) -> T_Dataset:\n2690         \"\"\"Returns a new dataset with each array indexed along every `n`-th\n2691         value for the specified dimension(s)\n2692 \n2693         Parameters\n2694         ----------\n2695         indexers : dict or int\n2696             A dict with keys matching dimensions and integer values `n`\n2697             or a single integer `n` applied over all dimensions.\n2698             One of indexers or indexers_kwargs must be provided.\n2699         **indexers_kwargs : {dim: n, ...}, optional\n2700             The keyword arguments form of ``indexers``.\n2701             One of indexers or indexers_kwargs must be provided.\n2702 \n2703         Examples\n2704         --------\n2705         >>> x_arr = np.arange(0, 26)\n2706         >>> x_arr\n2707         array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,\n2708                17, 18, 19, 20, 21, 22, 23, 24, 25])\n2709         >>> x = xr.DataArray(\n2710         ...     np.reshape(x_arr, (2, 13)),\n2711         ...     dims=(\"x\", \"y\"),\n2712         ...     coords={\"x\": [0, 1], \"y\": np.arange(0, 13)},\n2713         ... )\n2714         >>> x_ds = xr.Dataset({\"foo\": x})\n2715         >>> x_ds\n2716         <xarray.Dataset>\n2717         Dimensions:  (x: 2, y: 13)\n2718         Coordinates:\n2719           * x        (x) int64 0 1\n2720           * y        (y) int64 0 1 2 3 4 5 6 7 8 9 10 11 12\n2721         Data variables:\n2722             foo      (x, y) int64 0 1 2 3 4 5 6 7 8 9 ... 16 17 18 19 20 21 22 23 24 25\n2723 \n2724         >>> x_ds.thin(3)\n2725         <xarray.Dataset>\n2726         Dimensions:  (x: 1, y: 5)\n2727         Coordinates:\n2728           * x        (x) int64 0\n2729           * y        (y) int64 0 3 6 9 12\n2730         Data variables:\n2731             foo      (x, y) int64 0 3 6 9 12\n2732         >>> x.thin({\"x\": 2, \"y\": 5})\n2733         <xarray.DataArray (x: 1, y: 3)>\n2734         array([[ 0,  5, 10]])\n2735         Coordinates:\n2736           * x        (x) int64 0\n2737           * y        (y) int64 0 5 10\n2738 \n2739         See Also\n2740         --------\n2741         Dataset.head\n2742         Dataset.tail\n2743         DataArray.thin\n2744         \"\"\"\n2745         if (\n2746             not indexers_kwargs\n2747             and not isinstance(indexers, int)\n2748             and not is_dict_like(indexers)\n2749         ):\n2750             raise TypeError(\"indexers must be either dict-like or a single integer\")\n2751         if isinstance(indexers, int):\n2752             indexers = {dim: indexers for dim in self.dims}\n2753         indexers = either_dict_or_kwargs(indexers, indexers_kwargs, \"thin\")\n2754         for k, v in indexers.items():\n2755             if not isinstance(v, int):\n2756                 raise TypeError(\n2757                     \"expected integer type indexer for \"\n2758                     f\"dimension {k!r}, found {type(v)!r}\"\n2759                 )\n2760             elif v < 0:\n2761                 raise ValueError(\n2762                     \"expected positive integer as indexer \"\n2763                     f\"for dimension {k!r}, found {v}\"\n2764                 )\n2765             elif v == 0:\n2766                 raise ValueError(\"step cannot be zero\")\n2767         indexers_slices = {k: slice(None, None, val) for k, val in indexers.items()}\n2768         return self.isel(indexers_slices)\n2769 \n2770     def broadcast_like(\n2771         self: T_Dataset,\n2772         other: Dataset | DataArray,\n2773         exclude: Iterable[Hashable] | None = None,\n2774     ) -> T_Dataset:\n2775         \"\"\"Broadcast this DataArray against another Dataset or DataArray.\n2776         This is equivalent to xr.broadcast(other, self)[1]\n2777 \n2778         Parameters\n2779         ----------\n2780         other : Dataset or DataArray\n2781             Object against which to broadcast this array.\n2782         exclude : iterable of hashable, optional\n2783             Dimensions that must not be broadcasted\n2784 \n2785         \"\"\"\n2786         if exclude is None:\n2787             exclude = set()\n2788         else:\n2789             exclude = set(exclude)\n2790         args = align(other, self, join=\"outer\", copy=False, exclude=exclude)\n2791 \n2792         dims_map, common_coords = _get_broadcast_dims_map_common_coords(args, exclude)\n2793 \n2794         return _broadcast_helper(\n2795             cast(\"T_Dataset\", args[1]), exclude, dims_map, common_coords\n2796         )\n2797 \n2798     def _reindex_callback(\n2799         self,\n2800         aligner: alignment.Aligner,\n2801         dim_pos_indexers: dict[Hashable, Any],\n2802         variables: dict[Hashable, Variable],\n2803         indexes: dict[Hashable, Index],\n2804         fill_value: Any,\n2805         exclude_dims: frozenset[Hashable],\n2806         exclude_vars: frozenset[Hashable],\n2807     ) -> Dataset:\n2808         \"\"\"Callback called from ``Aligner`` to create a new reindexed Dataset.\"\"\"\n2809 \n2810         new_variables = variables.copy()\n2811         new_indexes = indexes.copy()\n2812 \n2813         # re-assign variable metadata\n2814         for name, new_var in new_variables.items():\n2815             var = self._variables.get(name)\n2816             if var is not None:\n2817                 new_var.attrs = var.attrs\n2818                 new_var.encoding = var.encoding\n2819 \n2820         # pass through indexes from excluded dimensions\n2821         # no extra check needed for multi-coordinate indexes, potential conflicts\n2822         # should already have been detected when aligning the indexes\n2823         for name, idx in self._indexes.items():\n2824             var = self._variables[name]\n2825             if set(var.dims) <= exclude_dims:\n2826                 new_indexes[name] = idx\n2827                 new_variables[name] = var\n2828 \n2829         if not dim_pos_indexers:\n2830             # fast path for no reindexing necessary\n2831             if set(new_indexes) - set(self._indexes):\n2832                 # this only adds new indexes and their coordinate variables\n2833                 reindexed = self._overwrite_indexes(new_indexes, new_variables)\n2834             else:\n2835                 reindexed = self.copy(deep=aligner.copy)\n2836         else:\n2837             to_reindex = {\n2838                 k: v\n2839                 for k, v in self.variables.items()\n2840                 if k not in variables and k not in exclude_vars\n2841             }\n2842             reindexed_vars = alignment.reindex_variables(\n2843                 to_reindex,\n2844                 dim_pos_indexers,\n2845                 copy=aligner.copy,\n2846                 fill_value=fill_value,\n2847                 sparse=aligner.sparse,\n2848             )\n2849             new_variables.update(reindexed_vars)\n2850             new_coord_names = self._coord_names | set(new_indexes)\n2851             reindexed = self._replace_with_new_dims(\n2852                 new_variables, new_coord_names, indexes=new_indexes\n2853             )\n2854 \n2855         return reindexed\n2856 \n2857     def reindex_like(\n2858         self: T_Dataset,\n2859         other: Dataset | DataArray,\n2860         method: ReindexMethodOptions = None,\n2861         tolerance: int | float | Iterable[int | float] | None = None,\n2862         copy: bool = True,\n2863         fill_value: Any = xrdtypes.NA,\n2864     ) -> T_Dataset:\n2865         \"\"\"Conform this object onto the indexes of another object, filling in\n2866         missing values with ``fill_value``. The default fill value is NaN.\n2867 \n2868         Parameters\n2869         ----------\n2870         other : Dataset or DataArray\n2871             Object with an 'indexes' attribute giving a mapping from dimension\n2872             names to pandas.Index objects, which provides coordinates upon\n2873             which to index the variables in this dataset. The indexes on this\n2874             other object need not be the same as the indexes on this\n2875             dataset. Any mis-matched index values will be filled in with\n2876             NaN, and any mis-matched dimension names will simply be ignored.\n2877         method : {None, \"nearest\", \"pad\", \"ffill\", \"backfill\", \"bfill\", None}, optional\n2878             Method to use for filling index values from other not found in this\n2879             dataset:\n2880 \n2881             - None (default): don't fill gaps\n2882             - \"pad\" / \"ffill\": propagate last valid index value forward\n2883             - \"backfill\" / \"bfill\": propagate next valid index value backward\n2884             - \"nearest\": use nearest valid index value\n2885 \n2886         tolerance : optional\n2887             Maximum distance between original and new labels for inexact\n2888             matches. The values of the index at the matching locations must\n2889             satisfy the equation ``abs(index[indexer] - target) <= tolerance``.\n2890             Tolerance may be a scalar value, which applies the same tolerance\n2891             to all values, or list-like, which applies variable tolerance per\n2892             element. List-like must be the same size as the index and its dtype\n2893             must exactly match the index\u2019s type.\n2894         copy : bool, default: True\n2895             If ``copy=True``, data in the return value is always copied. If\n2896             ``copy=False`` and reindexing is unnecessary, or can be performed\n2897             with only slice operations, then the output may share memory with\n2898             the input. In either case, a new xarray object is always returned.\n2899         fill_value : scalar or dict-like, optional\n2900             Value to use for newly missing values. If a dict-like maps\n2901             variable names to fill values.\n2902 \n2903         Returns\n2904         -------\n2905         reindexed : Dataset\n2906             Another dataset, with this dataset's data but coordinates from the\n2907             other object.\n2908 \n2909         See Also\n2910         --------\n2911         Dataset.reindex\n2912         align\n2913         \"\"\"\n2914         return alignment.reindex_like(\n2915             self,\n2916             other=other,\n2917             method=method,\n2918             tolerance=tolerance,\n2919             copy=copy,\n2920             fill_value=fill_value,\n2921         )\n2922 \n2923     def reindex(\n2924         self: T_Dataset,\n2925         indexers: Mapping[Any, Any] | None = None,\n2926         method: ReindexMethodOptions = None,\n2927         tolerance: int | float | Iterable[int | float] | None = None,\n2928         copy: bool = True,\n2929         fill_value: Any = xrdtypes.NA,\n2930         **indexers_kwargs: Any,\n2931     ) -> T_Dataset:\n2932         \"\"\"Conform this object onto a new set of indexes, filling in\n2933         missing values with ``fill_value``. The default fill value is NaN.\n2934 \n2935         Parameters\n2936         ----------\n2937         indexers : dict, optional\n2938             Dictionary with keys given by dimension names and values given by\n2939             arrays of coordinates tick labels. Any mis-matched coordinate\n2940             values will be filled in with NaN, and any mis-matched dimension\n2941             names will simply be ignored.\n2942             One of indexers or indexers_kwargs must be provided.\n2943         method : {None, \"nearest\", \"pad\", \"ffill\", \"backfill\", \"bfill\", None}, optional\n2944             Method to use for filling index values in ``indexers`` not found in\n2945             this dataset:\n2946 \n2947             - None (default): don't fill gaps\n2948             - \"pad\" / \"ffill\": propagate last valid index value forward\n2949             - \"backfill\" / \"bfill\": propagate next valid index value backward\n2950             - \"nearest\": use nearest valid index value\n2951 \n2952         tolerance : optional\n2953             Maximum distance between original and new labels for inexact\n2954             matches. The values of the index at the matching locations must\n2955             satisfy the equation ``abs(index[indexer] - target) <= tolerance``.\n2956             Tolerance may be a scalar value, which applies the same tolerance\n2957             to all values, or list-like, which applies variable tolerance per\n2958             element. List-like must be the same size as the index and its dtype\n2959             must exactly match the index\u2019s type.\n2960         copy : bool, default: True\n2961             If ``copy=True``, data in the return value is always copied. If\n2962             ``copy=False`` and reindexing is unnecessary, or can be performed\n2963             with only slice operations, then the output may share memory with\n2964             the input. In either case, a new xarray object is always returned.\n2965         fill_value : scalar or dict-like, optional\n2966             Value to use for newly missing values. If a dict-like,\n2967             maps variable names (including coordinates) to fill values.\n2968         sparse : bool, default: False\n2969             use sparse-array.\n2970         **indexers_kwargs : {dim: indexer, ...}, optional\n2971             Keyword arguments in the same form as ``indexers``.\n2972             One of indexers or indexers_kwargs must be provided.\n2973 \n2974         Returns\n2975         -------\n2976         reindexed : Dataset\n2977             Another dataset, with this dataset's data but replaced coordinates.\n2978 \n2979         See Also\n2980         --------\n2981         Dataset.reindex_like\n2982         align\n2983         pandas.Index.get_indexer\n2984 \n2985         Examples\n2986         --------\n2987         Create a dataset with some fictional data.\n2988 \n2989         >>> x = xr.Dataset(\n2990         ...     {\n2991         ...         \"temperature\": (\"station\", 20 * np.random.rand(4)),\n2992         ...         \"pressure\": (\"station\", 500 * np.random.rand(4)),\n2993         ...     },\n2994         ...     coords={\"station\": [\"boston\", \"nyc\", \"seattle\", \"denver\"]},\n2995         ... )\n2996         >>> x\n2997         <xarray.Dataset>\n2998         Dimensions:      (station: 4)\n2999         Coordinates:\n3000           * station      (station) <U7 'boston' 'nyc' 'seattle' 'denver'\n3001         Data variables:\n3002             temperature  (station) float64 10.98 14.3 12.06 10.9\n3003             pressure     (station) float64 211.8 322.9 218.8 445.9\n3004         >>> x.indexes\n3005         Indexes:\n3006             station  Index(['boston', 'nyc', 'seattle', 'denver'], dtype='object', name='station')\n3007 \n3008         Create a new index and reindex the dataset. By default values in the new index that\n3009         do not have corresponding records in the dataset are assigned `NaN`.\n3010 \n3011         >>> new_index = [\"boston\", \"austin\", \"seattle\", \"lincoln\"]\n3012         >>> x.reindex({\"station\": new_index})\n3013         <xarray.Dataset>\n3014         Dimensions:      (station: 4)\n3015         Coordinates:\n3016           * station      (station) <U7 'boston' 'austin' 'seattle' 'lincoln'\n3017         Data variables:\n3018             temperature  (station) float64 10.98 nan 12.06 nan\n3019             pressure     (station) float64 211.8 nan 218.8 nan\n3020 \n3021         We can fill in the missing values by passing a value to the keyword `fill_value`.\n3022 \n3023         >>> x.reindex({\"station\": new_index}, fill_value=0)\n3024         <xarray.Dataset>\n3025         Dimensions:      (station: 4)\n3026         Coordinates:\n3027           * station      (station) <U7 'boston' 'austin' 'seattle' 'lincoln'\n3028         Data variables:\n3029             temperature  (station) float64 10.98 0.0 12.06 0.0\n3030             pressure     (station) float64 211.8 0.0 218.8 0.0\n3031 \n3032         We can also use different fill values for each variable.\n3033 \n3034         >>> x.reindex(\n3035         ...     {\"station\": new_index}, fill_value={\"temperature\": 0, \"pressure\": 100}\n3036         ... )\n3037         <xarray.Dataset>\n3038         Dimensions:      (station: 4)\n3039         Coordinates:\n3040           * station      (station) <U7 'boston' 'austin' 'seattle' 'lincoln'\n3041         Data variables:\n3042             temperature  (station) float64 10.98 0.0 12.06 0.0\n3043             pressure     (station) float64 211.8 100.0 218.8 100.0\n3044 \n3045         Because the index is not monotonically increasing or decreasing, we cannot use arguments\n3046         to the keyword method to fill the `NaN` values.\n3047 \n3048         >>> x.reindex({\"station\": new_index}, method=\"nearest\")\n3049         Traceback (most recent call last):\n3050         ...\n3051             raise ValueError('index must be monotonic increasing or decreasing')\n3052         ValueError: index must be monotonic increasing or decreasing\n3053 \n3054         To further illustrate the filling functionality in reindex, we will create a\n3055         dataset with a monotonically increasing index (for example, a sequence of dates).\n3056 \n3057         >>> x2 = xr.Dataset(\n3058         ...     {\n3059         ...         \"temperature\": (\n3060         ...             \"time\",\n3061         ...             [15.57, 12.77, np.nan, 0.3081, 16.59, 15.12],\n3062         ...         ),\n3063         ...         \"pressure\": (\"time\", 500 * np.random.rand(6)),\n3064         ...     },\n3065         ...     coords={\"time\": pd.date_range(\"01/01/2019\", periods=6, freq=\"D\")},\n3066         ... )\n3067         >>> x2\n3068         <xarray.Dataset>\n3069         Dimensions:      (time: 6)\n3070         Coordinates:\n3071           * time         (time) datetime64[ns] 2019-01-01 2019-01-02 ... 2019-01-06\n3072         Data variables:\n3073             temperature  (time) float64 15.57 12.77 nan 0.3081 16.59 15.12\n3074             pressure     (time) float64 481.8 191.7 395.9 264.4 284.0 462.8\n3075 \n3076         Suppose we decide to expand the dataset to cover a wider date range.\n3077 \n3078         >>> time_index2 = pd.date_range(\"12/29/2018\", periods=10, freq=\"D\")\n3079         >>> x2.reindex({\"time\": time_index2})\n3080         <xarray.Dataset>\n3081         Dimensions:      (time: 10)\n3082         Coordinates:\n3083           * time         (time) datetime64[ns] 2018-12-29 2018-12-30 ... 2019-01-07\n3084         Data variables:\n3085             temperature  (time) float64 nan nan nan 15.57 ... 0.3081 16.59 15.12 nan\n3086             pressure     (time) float64 nan nan nan 481.8 ... 264.4 284.0 462.8 nan\n3087 \n3088         The index entries that did not have a value in the original data frame (for example, `2018-12-29`)\n3089         are by default filled with NaN. If desired, we can fill in the missing values using one of several options.\n3090 \n3091         For example, to back-propagate the last valid value to fill the `NaN` values,\n3092         pass `bfill` as an argument to the `method` keyword.\n3093 \n3094         >>> x3 = x2.reindex({\"time\": time_index2}, method=\"bfill\")\n3095         >>> x3\n3096         <xarray.Dataset>\n3097         Dimensions:      (time: 10)\n3098         Coordinates:\n3099           * time         (time) datetime64[ns] 2018-12-29 2018-12-30 ... 2019-01-07\n3100         Data variables:\n3101             temperature  (time) float64 15.57 15.57 15.57 15.57 ... 16.59 15.12 nan\n3102             pressure     (time) float64 481.8 481.8 481.8 481.8 ... 284.0 462.8 nan\n3103 \n3104         Please note that the `NaN` value present in the original dataset (at index value `2019-01-03`)\n3105         will not be filled by any of the value propagation schemes.\n3106 \n3107         >>> x2.where(x2.temperature.isnull(), drop=True)\n3108         <xarray.Dataset>\n3109         Dimensions:      (time: 1)\n3110         Coordinates:\n3111           * time         (time) datetime64[ns] 2019-01-03\n3112         Data variables:\n3113             temperature  (time) float64 nan\n3114             pressure     (time) float64 395.9\n3115         >>> x3.where(x3.temperature.isnull(), drop=True)\n3116         <xarray.Dataset>\n3117         Dimensions:      (time: 2)\n3118         Coordinates:\n3119           * time         (time) datetime64[ns] 2019-01-03 2019-01-07\n3120         Data variables:\n3121             temperature  (time) float64 nan nan\n3122             pressure     (time) float64 395.9 nan\n3123 \n3124         This is because filling while reindexing does not look at dataset values, but only compares\n3125         the original and desired indexes. If you do want to fill in the `NaN` values present in the\n3126         original dataset, use the :py:meth:`~Dataset.fillna()` method.\n3127 \n3128         \"\"\"\n3129         indexers = utils.either_dict_or_kwargs(indexers, indexers_kwargs, \"reindex\")\n3130         return alignment.reindex(\n3131             self,\n3132             indexers=indexers,\n3133             method=method,\n3134             tolerance=tolerance,\n3135             copy=copy,\n3136             fill_value=fill_value,\n3137         )\n3138 \n3139     def _reindex(\n3140         self: T_Dataset,\n3141         indexers: Mapping[Any, Any] | None = None,\n3142         method: str | None = None,\n3143         tolerance: int | float | Iterable[int | float] | None = None,\n3144         copy: bool = True,\n3145         fill_value: Any = xrdtypes.NA,\n3146         sparse: bool = False,\n3147         **indexers_kwargs: Any,\n3148     ) -> T_Dataset:\n3149         \"\"\"\n3150         Same as reindex but supports sparse option.\n3151         \"\"\"\n3152         indexers = utils.either_dict_or_kwargs(indexers, indexers_kwargs, \"reindex\")\n3153         return alignment.reindex(\n3154             self,\n3155             indexers=indexers,\n3156             method=method,\n3157             tolerance=tolerance,\n3158             copy=copy,\n3159             fill_value=fill_value,\n3160             sparse=sparse,\n3161         )\n3162 \n3163     def interp(\n3164         self: T_Dataset,\n3165         coords: Mapping[Any, Any] | None = None,\n3166         method: InterpOptions = \"linear\",\n3167         assume_sorted: bool = False,\n3168         kwargs: Mapping[str, Any] | None = None,\n3169         method_non_numeric: str = \"nearest\",\n3170         **coords_kwargs: Any,\n3171     ) -> T_Dataset:\n3172         \"\"\"Interpolate a Dataset onto new coordinates\n3173 \n3174         Performs univariate or multivariate interpolation of a Dataset onto\n3175         new coordinates using scipy's interpolation routines. If interpolating\n3176         along an existing dimension, :py:class:`scipy.interpolate.interp1d` is\n3177         called.  When interpolating along multiple existing dimensions, an\n3178         attempt is made to decompose the interpolation into multiple\n3179         1-dimensional interpolations. If this is possible,\n3180         :py:class:`scipy.interpolate.interp1d` is called. Otherwise,\n3181         :py:func:`scipy.interpolate.interpn` is called.\n3182 \n3183         Parameters\n3184         ----------\n3185         coords : dict, optional\n3186             Mapping from dimension names to the new coordinates.\n3187             New coordinate can be a scalar, array-like or DataArray.\n3188             If DataArrays are passed as new coordinates, their dimensions are\n3189             used for the broadcasting. Missing values are skipped.\n3190         method : {\"linear\", \"nearest\", \"zero\", \"slinear\", \"quadratic\", \"cubic\", \"polynomial\", \\\n3191             \"barycentric\", \"krog\", \"pchip\", \"spline\", \"akima\"}, default: \"linear\"\n3192             String indicating which method to use for interpolation:\n3193 \n3194             - 'linear': linear interpolation. Additional keyword\n3195               arguments are passed to :py:func:`numpy.interp`\n3196             - 'nearest', 'zero', 'slinear', 'quadratic', 'cubic', 'polynomial':\n3197               are passed to :py:func:`scipy.interpolate.interp1d`. If\n3198               ``method='polynomial'``, the ``order`` keyword argument must also be\n3199               provided.\n3200             - 'barycentric', 'krog', 'pchip', 'spline', 'akima': use their\n3201               respective :py:class:`scipy.interpolate` classes.\n3202 \n3203         assume_sorted : bool, default: False\n3204             If False, values of coordinates that are interpolated over can be\n3205             in any order and they are sorted first. If True, interpolated\n3206             coordinates are assumed to be an array of monotonically increasing\n3207             values.\n3208         kwargs : dict, optional\n3209             Additional keyword arguments passed to scipy's interpolator. Valid\n3210             options and their behavior depend whether ``interp1d`` or\n3211             ``interpn`` is used.\n3212         method_non_numeric : {\"nearest\", \"pad\", \"ffill\", \"backfill\", \"bfill\"}, optional\n3213             Method for non-numeric types. Passed on to :py:meth:`Dataset.reindex`.\n3214             ``\"nearest\"`` is used by default.\n3215         **coords_kwargs : {dim: coordinate, ...}, optional\n3216             The keyword arguments form of ``coords``.\n3217             One of coords or coords_kwargs must be provided.\n3218 \n3219         Returns\n3220         -------\n3221         interpolated : Dataset\n3222             New dataset on the new coordinates.\n3223 \n3224         Notes\n3225         -----\n3226         scipy is required.\n3227 \n3228         See Also\n3229         --------\n3230         scipy.interpolate.interp1d\n3231         scipy.interpolate.interpn\n3232 \n3233         Examples\n3234         --------\n3235         >>> ds = xr.Dataset(\n3236         ...     data_vars={\n3237         ...         \"a\": (\"x\", [5, 7, 4]),\n3238         ...         \"b\": (\n3239         ...             (\"x\", \"y\"),\n3240         ...             [[1, 4, 2, 9], [2, 7, 6, np.nan], [6, np.nan, 5, 8]],\n3241         ...         ),\n3242         ...     },\n3243         ...     coords={\"x\": [0, 1, 2], \"y\": [10, 12, 14, 16]},\n3244         ... )\n3245         >>> ds\n3246         <xarray.Dataset>\n3247         Dimensions:  (x: 3, y: 4)\n3248         Coordinates:\n3249           * x        (x) int64 0 1 2\n3250           * y        (y) int64 10 12 14 16\n3251         Data variables:\n3252             a        (x) int64 5 7 4\n3253             b        (x, y) float64 1.0 4.0 2.0 9.0 2.0 7.0 6.0 nan 6.0 nan 5.0 8.0\n3254 \n3255         1D interpolation with the default method (linear):\n3256 \n3257         >>> ds.interp(x=[0, 0.75, 1.25, 1.75])\n3258         <xarray.Dataset>\n3259         Dimensions:  (x: 4, y: 4)\n3260         Coordinates:\n3261           * y        (y) int64 10 12 14 16\n3262           * x        (x) float64 0.0 0.75 1.25 1.75\n3263         Data variables:\n3264             a        (x) float64 5.0 6.5 6.25 4.75\n3265             b        (x, y) float64 1.0 4.0 2.0 nan 1.75 6.25 ... nan 5.0 nan 5.25 nan\n3266 \n3267         1D interpolation with a different method:\n3268 \n3269         >>> ds.interp(x=[0, 0.75, 1.25, 1.75], method=\"nearest\")\n3270         <xarray.Dataset>\n3271         Dimensions:  (x: 4, y: 4)\n3272         Coordinates:\n3273           * y        (y) int64 10 12 14 16\n3274           * x        (x) float64 0.0 0.75 1.25 1.75\n3275         Data variables:\n3276             a        (x) float64 5.0 7.0 7.0 4.0\n3277             b        (x, y) float64 1.0 4.0 2.0 9.0 2.0 7.0 ... 6.0 nan 6.0 nan 5.0 8.0\n3278 \n3279         1D extrapolation:\n3280 \n3281         >>> ds.interp(\n3282         ...     x=[1, 1.5, 2.5, 3.5],\n3283         ...     method=\"linear\",\n3284         ...     kwargs={\"fill_value\": \"extrapolate\"},\n3285         ... )\n3286         <xarray.Dataset>\n3287         Dimensions:  (x: 4, y: 4)\n3288         Coordinates:\n3289           * y        (y) int64 10 12 14 16\n3290           * x        (x) float64 1.0 1.5 2.5 3.5\n3291         Data variables:\n3292             a        (x) float64 7.0 5.5 2.5 -0.5\n3293             b        (x, y) float64 2.0 7.0 6.0 nan 4.0 nan ... 4.5 nan 12.0 nan 3.5 nan\n3294 \n3295         2D interpolation:\n3296 \n3297         >>> ds.interp(x=[0, 0.75, 1.25, 1.75], y=[11, 13, 15], method=\"linear\")\n3298         <xarray.Dataset>\n3299         Dimensions:  (x: 4, y: 3)\n3300         Coordinates:\n3301           * x        (x) float64 0.0 0.75 1.25 1.75\n3302           * y        (y) int64 11 13 15\n3303         Data variables:\n3304             a        (x) float64 5.0 6.5 6.25 4.75\n3305             b        (x, y) float64 2.5 3.0 nan 4.0 5.625 nan nan nan nan nan nan nan\n3306         \"\"\"\n3307         from xarray.core import missing\n3308 \n3309         if kwargs is None:\n3310             kwargs = {}\n3311 \n3312         coords = either_dict_or_kwargs(coords, coords_kwargs, \"interp\")\n3313         indexers = dict(self._validate_interp_indexers(coords))\n3314 \n3315         if coords:\n3316             # This avoids broadcasting over coordinates that are both in\n3317             # the original array AND in the indexing array. It essentially\n3318             # forces interpolation along the shared coordinates.\n3319             sdims = (\n3320                 set(self.dims)\n3321                 .intersection(*[set(nx.dims) for nx in indexers.values()])\n3322                 .difference(coords.keys())\n3323             )\n3324             indexers.update({d: self.variables[d] for d in sdims})\n3325 \n3326         obj = self if assume_sorted else self.sortby([k for k in coords])\n3327 \n3328         def maybe_variable(obj, k):\n3329             # workaround to get variable for dimension without coordinate.\n3330             try:\n3331                 return obj._variables[k]\n3332             except KeyError:\n3333                 return as_variable((k, range(obj.dims[k])))\n3334 \n3335         def _validate_interp_indexer(x, new_x):\n3336             # In the case of datetimes, the restrictions placed on indexers\n3337             # used with interp are stronger than those which are placed on\n3338             # isel, so we need an additional check after _validate_indexers.\n3339             if _contains_datetime_like_objects(\n3340                 x\n3341             ) and not _contains_datetime_like_objects(new_x):\n3342                 raise TypeError(\n3343                     \"When interpolating over a datetime-like \"\n3344                     \"coordinate, the coordinates to \"\n3345                     \"interpolate to must be either datetime \"\n3346                     \"strings or datetimes. \"\n3347                     \"Instead got\\n{}\".format(new_x)\n3348                 )\n3349             return x, new_x\n3350 \n3351         validated_indexers = {\n3352             k: _validate_interp_indexer(maybe_variable(obj, k), v)\n3353             for k, v in indexers.items()\n3354         }\n3355 \n3356         # optimization: subset to coordinate range of the target index\n3357         if method in [\"linear\", \"nearest\"]:\n3358             for k, v in validated_indexers.items():\n3359                 obj, newidx = missing._localize(obj, {k: v})\n3360                 validated_indexers[k] = newidx[k]\n3361 \n3362         # optimization: create dask coordinate arrays once per Dataset\n3363         # rather than once per Variable when dask.array.unify_chunks is called later\n3364         # GH4739\n3365         if obj.__dask_graph__():\n3366             dask_indexers = {\n3367                 k: (index.to_base_variable().chunk(), dest.to_base_variable().chunk())\n3368                 for k, (index, dest) in validated_indexers.items()\n3369             }\n3370 \n3371         variables: dict[Hashable, Variable] = {}\n3372         reindex: bool = False\n3373         for name, var in obj._variables.items():\n3374             if name in indexers:\n3375                 continue\n3376 \n3377             if is_duck_dask_array(var.data):\n3378                 use_indexers = dask_indexers\n3379             else:\n3380                 use_indexers = validated_indexers\n3381 \n3382             dtype_kind = var.dtype.kind\n3383             if dtype_kind in \"uifc\":\n3384                 # For normal number types do the interpolation:\n3385                 var_indexers = {k: v for k, v in use_indexers.items() if k in var.dims}\n3386                 variables[name] = missing.interp(var, var_indexers, method, **kwargs)\n3387             elif dtype_kind in \"ObU\" and (use_indexers.keys() & var.dims):\n3388                 # For types that we do not understand do stepwise\n3389                 # interpolation to avoid modifying the elements.\n3390                 # reindex the variable instead because it supports\n3391                 # booleans and objects and retains the dtype but inside\n3392                 # this loop there might be some duplicate code that slows it\n3393                 # down, therefore collect these signals and run it later:\n3394                 reindex = True\n3395             elif all(d not in indexers for d in var.dims):\n3396                 # For anything else we can only keep variables if they\n3397                 # are not dependent on any coords that are being\n3398                 # interpolated along:\n3399                 variables[name] = var\n3400 \n3401         if reindex:\n3402             reindex_indexers = {\n3403                 k: v for k, (_, v) in validated_indexers.items() if v.dims == (k,)\n3404             }\n3405             reindexed = alignment.reindex(\n3406                 obj,\n3407                 indexers=reindex_indexers,\n3408                 method=method_non_numeric,\n3409                 exclude_vars=variables.keys(),\n3410             )\n3411             indexes = dict(reindexed._indexes)\n3412             variables.update(reindexed.variables)\n3413         else:\n3414             # Get the indexes that are not being interpolated along\n3415             indexes = {k: v for k, v in obj._indexes.items() if k not in indexers}\n3416 \n3417         # Get the coords that also exist in the variables:\n3418         coord_names = obj._coord_names & variables.keys()\n3419         selected = self._replace_with_new_dims(\n3420             variables.copy(), coord_names, indexes=indexes\n3421         )\n3422 \n3423         # Attach indexer as coordinate\n3424         for k, v in indexers.items():\n3425             assert isinstance(v, Variable)\n3426             if v.dims == (k,):\n3427                 index = PandasIndex(v, k, coord_dtype=v.dtype)\n3428                 index_vars = index.create_variables({k: v})\n3429                 indexes[k] = index\n3430                 variables.update(index_vars)\n3431             else:\n3432                 variables[k] = v\n3433 \n3434         # Extract coordinates from indexers\n3435         coord_vars, new_indexes = selected._get_indexers_coords_and_indexes(coords)\n3436         variables.update(coord_vars)\n3437         indexes.update(new_indexes)\n3438 \n3439         coord_names = obj._coord_names & variables.keys() | coord_vars.keys()\n3440         return self._replace_with_new_dims(variables, coord_names, indexes=indexes)\n3441 \n3442     def interp_like(\n3443         self,\n3444         other: Dataset | DataArray,\n3445         method: InterpOptions = \"linear\",\n3446         assume_sorted: bool = False,\n3447         kwargs: Mapping[str, Any] | None = None,\n3448         method_non_numeric: str = \"nearest\",\n3449     ) -> Dataset:\n3450         \"\"\"Interpolate this object onto the coordinates of another object,\n3451         filling the out of range values with NaN.\n3452 \n3453         If interpolating along a single existing dimension,\n3454         :py:class:`scipy.interpolate.interp1d` is called. When interpolating\n3455         along multiple existing dimensions, an attempt is made to decompose the\n3456         interpolation into multiple 1-dimensional interpolations. If this is\n3457         possible, :py:class:`scipy.interpolate.interp1d` is called. Otherwise,\n3458         :py:func:`scipy.interpolate.interpn` is called.\n3459 \n3460         Parameters\n3461         ----------\n3462         other : Dataset or DataArray\n3463             Object with an 'indexes' attribute giving a mapping from dimension\n3464             names to an 1d array-like, which provides coordinates upon\n3465             which to index the variables in this dataset. Missing values are skipped.\n3466         method : {\"linear\", \"nearest\", \"zero\", \"slinear\", \"quadratic\", \"cubic\", \"polynomial\", \\\n3467             \"barycentric\", \"krog\", \"pchip\", \"spline\", \"akima\"}, default: \"linear\"\n3468             String indicating which method to use for interpolation:\n3469 \n3470             - 'linear': linear interpolation. Additional keyword\n3471               arguments are passed to :py:func:`numpy.interp`\n3472             - 'nearest', 'zero', 'slinear', 'quadratic', 'cubic', 'polynomial':\n3473               are passed to :py:func:`scipy.interpolate.interp1d`. If\n3474               ``method='polynomial'``, the ``order`` keyword argument must also be\n3475               provided.\n3476             - 'barycentric', 'krog', 'pchip', 'spline', 'akima': use their\n3477               respective :py:class:`scipy.interpolate` classes.\n3478 \n3479         assume_sorted : bool, default: False\n3480             If False, values of coordinates that are interpolated over can be\n3481             in any order and they are sorted first. If True, interpolated\n3482             coordinates are assumed to be an array of monotonically increasing\n3483             values.\n3484         kwargs : dict, optional\n3485             Additional keyword passed to scipy's interpolator.\n3486         method_non_numeric : {\"nearest\", \"pad\", \"ffill\", \"backfill\", \"bfill\"}, optional\n3487             Method for non-numeric types. Passed on to :py:meth:`Dataset.reindex`.\n3488             ``\"nearest\"`` is used by default.\n3489 \n3490         Returns\n3491         -------\n3492         interpolated : Dataset\n3493             Another dataset by interpolating this dataset's data along the\n3494             coordinates of the other object.\n3495 \n3496         Notes\n3497         -----\n3498         scipy is required.\n3499         If the dataset has object-type coordinates, reindex is used for these\n3500         coordinates instead of the interpolation.\n3501 \n3502         See Also\n3503         --------\n3504         Dataset.interp\n3505         Dataset.reindex_like\n3506         \"\"\"\n3507         if kwargs is None:\n3508             kwargs = {}\n3509 \n3510         # pick only dimension coordinates with a single index\n3511         coords = {}\n3512         other_indexes = other.xindexes\n3513         for dim in self.dims:\n3514             other_dim_coords = other_indexes.get_all_coords(dim, errors=\"ignore\")\n3515             if len(other_dim_coords) == 1:\n3516                 coords[dim] = other_dim_coords[dim]\n3517 \n3518         numeric_coords: dict[Hashable, pd.Index] = {}\n3519         object_coords: dict[Hashable, pd.Index] = {}\n3520         for k, v in coords.items():\n3521             if v.dtype.kind in \"uifcMm\":\n3522                 numeric_coords[k] = v\n3523             else:\n3524                 object_coords[k] = v\n3525 \n3526         ds = self\n3527         if object_coords:\n3528             # We do not support interpolation along object coordinate.\n3529             # reindex instead.\n3530             ds = self.reindex(object_coords)\n3531         return ds.interp(\n3532             coords=numeric_coords,\n3533             method=method,\n3534             assume_sorted=assume_sorted,\n3535             kwargs=kwargs,\n3536             method_non_numeric=method_non_numeric,\n3537         )\n3538 \n3539     # Helper methods for rename()\n3540     def _rename_vars(\n3541         self, name_dict, dims_dict\n3542     ) -> tuple[dict[Hashable, Variable], set[Hashable]]:\n3543         variables = {}\n3544         coord_names = set()\n3545         for k, v in self.variables.items():\n3546             var = v.copy(deep=False)\n3547             var.dims = tuple(dims_dict.get(dim, dim) for dim in v.dims)\n3548             name = name_dict.get(k, k)\n3549             if name in variables:\n3550                 raise ValueError(f\"the new name {name!r} conflicts\")\n3551             variables[name] = var\n3552             if k in self._coord_names:\n3553                 coord_names.add(name)\n3554         return variables, coord_names\n3555 \n3556     def _rename_dims(self, name_dict: Mapping[Any, Hashable]) -> dict[Hashable, int]:\n3557         return {name_dict.get(k, k): v for k, v in self.dims.items()}\n3558 \n3559     def _rename_indexes(\n3560         self, name_dict: Mapping[Any, Hashable], dims_dict: Mapping[Any, Hashable]\n3561     ) -> tuple[dict[Hashable, Index], dict[Hashable, Variable]]:\n3562         if not self._indexes:\n3563             return {}, {}\n3564 \n3565         indexes = {}\n3566         variables = {}\n3567 \n3568         for index, coord_names in self.xindexes.group_by_index():\n3569             new_index = index.rename(name_dict, dims_dict)\n3570             new_coord_names = [name_dict.get(k, k) for k in coord_names]\n3571             indexes.update({k: new_index for k in new_coord_names})\n3572             new_index_vars = new_index.create_variables(\n3573                 {\n3574                     new: self._variables[old]\n3575                     for old, new in zip(coord_names, new_coord_names)\n3576                 }\n3577             )\n3578             variables.update(new_index_vars)\n3579 \n3580         return indexes, variables\n3581 \n3582     def _rename_all(\n3583         self, name_dict: Mapping[Any, Hashable], dims_dict: Mapping[Any, Hashable]\n3584     ) -> tuple[\n3585         dict[Hashable, Variable],\n3586         set[Hashable],\n3587         dict[Hashable, int],\n3588         dict[Hashable, Index],\n3589     ]:\n3590         variables, coord_names = self._rename_vars(name_dict, dims_dict)\n3591         dims = self._rename_dims(dims_dict)\n3592 \n3593         indexes, index_vars = self._rename_indexes(name_dict, dims_dict)\n3594         variables = {k: index_vars.get(k, v) for k, v in variables.items()}\n3595 \n3596         return variables, coord_names, dims, indexes\n3597 \n3598     def _rename(\n3599         self: T_Dataset,\n3600         name_dict: Mapping[Any, Hashable] | None = None,\n3601         **names: Hashable,\n3602     ) -> T_Dataset:\n3603         \"\"\"Also used internally by DataArray so that the warning (if any)\n3604         is raised at the right stack level.\n3605         \"\"\"\n3606         name_dict = either_dict_or_kwargs(name_dict, names, \"rename\")\n3607         for k in name_dict.keys():\n3608             if k not in self and k not in self.dims:\n3609                 raise ValueError(\n3610                     f\"cannot rename {k!r} because it is not a \"\n3611                     \"variable or dimension in this dataset\"\n3612                 )\n3613 \n3614             create_dim_coord = False\n3615             new_k = name_dict[k]\n3616 \n3617             if k in self.dims and new_k in self._coord_names:\n3618                 coord_dims = self._variables[name_dict[k]].dims\n3619                 if coord_dims == (k,):\n3620                     create_dim_coord = True\n3621             elif k in self._coord_names and new_k in self.dims:\n3622                 coord_dims = self._variables[k].dims\n3623                 if coord_dims == (new_k,):\n3624                     create_dim_coord = True\n3625 \n3626             if create_dim_coord:\n3627                 warnings.warn(\n3628                     f\"rename {k!r} to {name_dict[k]!r} does not create an index \"\n3629                     \"anymore. Try using swap_dims instead or use set_index \"\n3630                     \"after rename to create an indexed coordinate.\",\n3631                     UserWarning,\n3632                     stacklevel=3,\n3633                 )\n3634 \n3635         variables, coord_names, dims, indexes = self._rename_all(\n3636             name_dict=name_dict, dims_dict=name_dict\n3637         )\n3638         return self._replace(variables, coord_names, dims=dims, indexes=indexes)\n3639 \n3640     def rename(\n3641         self: T_Dataset,\n3642         name_dict: Mapping[Any, Hashable] | None = None,\n3643         **names: Hashable,\n3644     ) -> T_Dataset:\n3645         \"\"\"Returns a new object with renamed variables, coordinates and dimensions.\n3646 \n3647         Parameters\n3648         ----------\n3649         name_dict : dict-like, optional\n3650             Dictionary whose keys are current variable, coordinate or dimension names and\n3651             whose values are the desired names.\n3652         **names : optional\n3653             Keyword form of ``name_dict``.\n3654             One of name_dict or names must be provided.\n3655 \n3656         Returns\n3657         -------\n3658         renamed : Dataset\n3659             Dataset with renamed variables, coordinates and dimensions.\n3660 \n3661         See Also\n3662         --------\n3663         Dataset.swap_dims\n3664         Dataset.rename_vars\n3665         Dataset.rename_dims\n3666         DataArray.rename\n3667         \"\"\"\n3668         return self._rename(name_dict=name_dict, **names)\n3669 \n3670     def rename_dims(\n3671         self: T_Dataset,\n3672         dims_dict: Mapping[Any, Hashable] | None = None,\n3673         **dims: Hashable,\n3674     ) -> T_Dataset:\n3675         \"\"\"Returns a new object with renamed dimensions only.\n3676 \n3677         Parameters\n3678         ----------\n3679         dims_dict : dict-like, optional\n3680             Dictionary whose keys are current dimension names and\n3681             whose values are the desired names. The desired names must\n3682             not be the name of an existing dimension or Variable in the Dataset.\n3683         **dims : optional\n3684             Keyword form of ``dims_dict``.\n3685             One of dims_dict or dims must be provided.\n3686 \n3687         Returns\n3688         -------\n3689         renamed : Dataset\n3690             Dataset with renamed dimensions.\n3691 \n3692         See Also\n3693         --------\n3694         Dataset.swap_dims\n3695         Dataset.rename\n3696         Dataset.rename_vars\n3697         DataArray.rename\n3698         \"\"\"\n3699         dims_dict = either_dict_or_kwargs(dims_dict, dims, \"rename_dims\")\n3700         for k, v in dims_dict.items():\n3701             if k not in self.dims:\n3702                 raise ValueError(\n3703                     f\"cannot rename {k!r} because it is not a \"\n3704                     \"dimension in this dataset\"\n3705                 )\n3706             if v in self.dims or v in self:\n3707                 raise ValueError(\n3708                     f\"Cannot rename {k} to {v} because {v} already exists. \"\n3709                     \"Try using swap_dims instead.\"\n3710                 )\n3711 \n3712         variables, coord_names, sizes, indexes = self._rename_all(\n3713             name_dict={}, dims_dict=dims_dict\n3714         )\n3715         return self._replace(variables, coord_names, dims=sizes, indexes=indexes)\n3716 \n3717     def rename_vars(\n3718         self: T_Dataset,\n3719         name_dict: Mapping[Any, Hashable] | None = None,\n3720         **names: Hashable,\n3721     ) -> T_Dataset:\n3722         \"\"\"Returns a new object with renamed variables including coordinates\n3723 \n3724         Parameters\n3725         ----------\n3726         name_dict : dict-like, optional\n3727             Dictionary whose keys are current variable or coordinate names and\n3728             whose values are the desired names.\n3729         **names : optional\n3730             Keyword form of ``name_dict``.\n3731             One of name_dict or names must be provided.\n3732 \n3733         Returns\n3734         -------\n3735         renamed : Dataset\n3736             Dataset with renamed variables including coordinates\n3737 \n3738         See Also\n3739         --------\n3740         Dataset.swap_dims\n3741         Dataset.rename\n3742         Dataset.rename_dims\n3743         DataArray.rename\n3744         \"\"\"\n3745         name_dict = either_dict_or_kwargs(name_dict, names, \"rename_vars\")\n3746         for k in name_dict:\n3747             if k not in self:\n3748                 raise ValueError(\n3749                     f\"cannot rename {k!r} because it is not a \"\n3750                     \"variable or coordinate in this dataset\"\n3751                 )\n3752         variables, coord_names, dims, indexes = self._rename_all(\n3753             name_dict=name_dict, dims_dict={}\n3754         )\n3755         return self._replace(variables, coord_names, dims=dims, indexes=indexes)\n3756 \n3757     def swap_dims(\n3758         self: T_Dataset, dims_dict: Mapping[Any, Hashable] | None = None, **dims_kwargs\n3759     ) -> T_Dataset:\n3760         \"\"\"Returns a new object with swapped dimensions.\n3761 \n3762         Parameters\n3763         ----------\n3764         dims_dict : dict-like\n3765             Dictionary whose keys are current dimension names and whose values\n3766             are new names.\n3767         **dims_kwargs : {existing_dim: new_dim, ...}, optional\n3768             The keyword arguments form of ``dims_dict``.\n3769             One of dims_dict or dims_kwargs must be provided.\n3770 \n3771         Returns\n3772         -------\n3773         swapped : Dataset\n3774             Dataset with swapped dimensions.\n3775 \n3776         Examples\n3777         --------\n3778         >>> ds = xr.Dataset(\n3779         ...     data_vars={\"a\": (\"x\", [5, 7]), \"b\": (\"x\", [0.1, 2.4])},\n3780         ...     coords={\"x\": [\"a\", \"b\"], \"y\": (\"x\", [0, 1])},\n3781         ... )\n3782         >>> ds\n3783         <xarray.Dataset>\n3784         Dimensions:  (x: 2)\n3785         Coordinates:\n3786           * x        (x) <U1 'a' 'b'\n3787             y        (x) int64 0 1\n3788         Data variables:\n3789             a        (x) int64 5 7\n3790             b        (x) float64 0.1 2.4\n3791 \n3792         >>> ds.swap_dims({\"x\": \"y\"})\n3793         <xarray.Dataset>\n3794         Dimensions:  (y: 2)\n3795         Coordinates:\n3796             x        (y) <U1 'a' 'b'\n3797           * y        (y) int64 0 1\n3798         Data variables:\n3799             a        (y) int64 5 7\n3800             b        (y) float64 0.1 2.4\n3801 \n3802         >>> ds.swap_dims({\"x\": \"z\"})\n3803         <xarray.Dataset>\n3804         Dimensions:  (z: 2)\n3805         Coordinates:\n3806             x        (z) <U1 'a' 'b'\n3807             y        (z) int64 0 1\n3808         Dimensions without coordinates: z\n3809         Data variables:\n3810             a        (z) int64 5 7\n3811             b        (z) float64 0.1 2.4\n3812 \n3813         See Also\n3814         --------\n3815         Dataset.rename\n3816         DataArray.swap_dims\n3817         \"\"\"\n3818         # TODO: deprecate this method in favor of a (less confusing)\n3819         # rename_dims() method that only renames dimensions.\n3820 \n3821         dims_dict = either_dict_or_kwargs(dims_dict, dims_kwargs, \"swap_dims\")\n3822         for k, v in dims_dict.items():\n3823             if k not in self.dims:\n3824                 raise ValueError(\n3825                     f\"cannot swap from dimension {k!r} because it is \"\n3826                     \"not an existing dimension\"\n3827                 )\n3828             if v in self.variables and self.variables[v].dims != (k,):\n3829                 raise ValueError(\n3830                     f\"replacement dimension {v!r} is not a 1D \"\n3831                     f\"variable along the old dimension {k!r}\"\n3832                 )\n3833 \n3834         result_dims = {dims_dict.get(dim, dim) for dim in self.dims}\n3835 \n3836         coord_names = self._coord_names.copy()\n3837         coord_names.update({dim for dim in dims_dict.values() if dim in self.variables})\n3838 \n3839         variables: dict[Hashable, Variable] = {}\n3840         indexes: dict[Hashable, Index] = {}\n3841         for k, v in self.variables.items():\n3842             dims = tuple(dims_dict.get(dim, dim) for dim in v.dims)\n3843             var: Variable\n3844             if k in result_dims:\n3845                 var = v.to_index_variable()\n3846                 var.dims = dims\n3847                 if k in self._indexes:\n3848                     indexes[k] = self._indexes[k]\n3849                     variables[k] = var\n3850                 else:\n3851                     index, index_vars = create_default_index_implicit(var)\n3852                     indexes.update({name: index for name in index_vars})\n3853                     variables.update(index_vars)\n3854                     coord_names.update(index_vars)\n3855             else:\n3856                 var = v.to_base_variable()\n3857                 var.dims = dims\n3858                 variables[k] = var\n3859 \n3860         return self._replace_with_new_dims(variables, coord_names, indexes=indexes)\n3861 \n3862     # change type of self and return to T_Dataset once\n3863     # https://github.com/python/mypy/issues/12846 is resolved\n3864     def expand_dims(\n3865         self,\n3866         dim: None | Hashable | Sequence[Hashable] | Mapping[Any, Any] = None,\n3867         axis: None | int | Sequence[int] = None,\n3868         **dim_kwargs: Any,\n3869     ) -> Dataset:\n3870         \"\"\"Return a new object with an additional axis (or axes) inserted at\n3871         the corresponding position in the array shape.  The new object is a\n3872         view into the underlying array, not a copy.\n3873 \n3874         If dim is already a scalar coordinate, it will be promoted to a 1D\n3875         coordinate consisting of a single value.\n3876 \n3877         Parameters\n3878         ----------\n3879         dim : hashable, sequence of hashable, mapping, or None\n3880             Dimensions to include on the new variable. If provided as hashable\n3881             or sequence of hashable, then dimensions are inserted with length\n3882             1. If provided as a mapping, then the keys are the new dimensions\n3883             and the values are either integers (giving the length of the new\n3884             dimensions) or array-like (giving the coordinates of the new\n3885             dimensions).\n3886         axis : int, sequence of int, or None, default: None\n3887             Axis position(s) where new axis is to be inserted (position(s) on\n3888             the result array). If a sequence of integers is passed,\n3889             multiple axes are inserted. In this case, dim arguments should be\n3890             same length list. If axis=None is passed, all the axes will be\n3891             inserted to the start of the result array.\n3892         **dim_kwargs : int or sequence or ndarray\n3893             The keywords are arbitrary dimensions being inserted and the values\n3894             are either the lengths of the new dims (if int is given), or their\n3895             coordinates. Note, this is an alternative to passing a dict to the\n3896             dim kwarg and will only be used if dim is None.\n3897 \n3898         Returns\n3899         -------\n3900         expanded : Dataset\n3901             This object, but with additional dimension(s).\n3902 \n3903         See Also\n3904         --------\n3905         DataArray.expand_dims\n3906         \"\"\"\n3907         if dim is None:\n3908             pass\n3909         elif isinstance(dim, Mapping):\n3910             # We're later going to modify dim in place; don't tamper with\n3911             # the input\n3912             dim = dict(dim)\n3913         elif isinstance(dim, int):\n3914             raise TypeError(\n3915                 \"dim should be hashable or sequence of hashables or mapping\"\n3916             )\n3917         elif isinstance(dim, str) or not isinstance(dim, Sequence):\n3918             dim = {dim: 1}\n3919         elif isinstance(dim, Sequence):\n3920             if len(dim) != len(set(dim)):\n3921                 raise ValueError(\"dims should not contain duplicate values.\")\n3922             dim = {d: 1 for d in dim}\n3923 \n3924         dim = either_dict_or_kwargs(dim, dim_kwargs, \"expand_dims\")\n3925         assert isinstance(dim, MutableMapping)\n3926 \n3927         if axis is None:\n3928             axis = list(range(len(dim)))\n3929         elif not isinstance(axis, Sequence):\n3930             axis = [axis]\n3931 \n3932         if len(dim) != len(axis):\n3933             raise ValueError(\"lengths of dim and axis should be identical.\")\n3934         for d in dim:\n3935             if d in self.dims:\n3936                 raise ValueError(f\"Dimension {d} already exists.\")\n3937             if d in self._variables and not utils.is_scalar(self._variables[d]):\n3938                 raise ValueError(\n3939                     \"{dim} already exists as coordinate or\"\n3940                     \" variable name.\".format(dim=d)\n3941                 )\n3942 \n3943         variables: dict[Hashable, Variable] = {}\n3944         indexes: dict[Hashable, Index] = dict(self._indexes)\n3945         coord_names = self._coord_names.copy()\n3946         # If dim is a dict, then ensure that the values are either integers\n3947         # or iterables.\n3948         for k, v in dim.items():\n3949             if hasattr(v, \"__iter__\"):\n3950                 # If the value for the new dimension is an iterable, then\n3951                 # save the coordinates to the variables dict, and set the\n3952                 # value within the dim dict to the length of the iterable\n3953                 # for later use.\n3954                 index = PandasIndex(v, k)\n3955                 indexes[k] = index\n3956                 variables.update(index.create_variables())\n3957                 coord_names.add(k)\n3958                 dim[k] = variables[k].size\n3959             elif isinstance(v, int):\n3960                 pass  # Do nothing if the dimensions value is just an int\n3961             else:\n3962                 raise TypeError(\n3963                     \"The value of new dimension {k} must be \"\n3964                     \"an iterable or an int\".format(k=k)\n3965                 )\n3966 \n3967         for k, v in self._variables.items():\n3968             if k not in dim:\n3969                 if k in coord_names:  # Do not change coordinates\n3970                     variables[k] = v\n3971                 else:\n3972                     result_ndim = len(v.dims) + len(axis)\n3973                     for a in axis:\n3974                         if a < -result_ndim or result_ndim - 1 < a:\n3975                             raise IndexError(\n3976                                 f\"Axis {a} of variable {k} is out of bounds of the \"\n3977                                 f\"expanded dimension size {result_ndim}\"\n3978                             )\n3979 \n3980                     axis_pos = [a if a >= 0 else result_ndim + a for a in axis]\n3981                     if len(axis_pos) != len(set(axis_pos)):\n3982                         raise ValueError(\"axis should not contain duplicate values\")\n3983                     # We need to sort them to make sure `axis` equals to the\n3984                     # axis positions of the result array.\n3985                     zip_axis_dim = sorted(zip(axis_pos, dim.items()))\n3986 \n3987                     all_dims = list(zip(v.dims, v.shape))\n3988                     for d, c in zip_axis_dim:\n3989                         all_dims.insert(d, c)\n3990                     variables[k] = v.set_dims(dict(all_dims))\n3991             else:\n3992                 if k not in variables:\n3993                     # If dims includes a label of a non-dimension coordinate,\n3994                     # it will be promoted to a 1D coordinate with a single value.\n3995                     index, index_vars = create_default_index_implicit(v.set_dims(k))\n3996                     indexes[k] = index\n3997                     variables.update(index_vars)\n3998 \n3999         return self._replace_with_new_dims(\n4000             variables, coord_names=coord_names, indexes=indexes\n4001         )\n4002 \n4003     # change type of self and return to T_Dataset once\n4004     # https://github.com/python/mypy/issues/12846 is resolved\n4005     def set_index(\n4006         self,\n4007         indexes: Mapping[Any, Hashable | Sequence[Hashable]] | None = None,\n4008         append: bool = False,\n4009         **indexes_kwargs: Hashable | Sequence[Hashable],\n4010     ) -> Dataset:\n4011         \"\"\"Set Dataset (multi-)indexes using one or more existing coordinates\n4012         or variables.\n4013 \n4014         This legacy method is limited to pandas (multi-)indexes and\n4015         1-dimensional \"dimension\" coordinates. See\n4016         :py:meth:`~Dataset.set_xindex` for setting a pandas or a custom\n4017         Xarray-compatible index from one or more arbitrary coordinates.\n4018 \n4019         Parameters\n4020         ----------\n4021         indexes : {dim: index, ...}\n4022             Mapping from names matching dimensions and values given\n4023             by (lists of) the names of existing coordinates or variables to set\n4024             as new (multi-)index.\n4025         append : bool, default: False\n4026             If True, append the supplied index(es) to the existing index(es).\n4027             Otherwise replace the existing index(es) (default).\n4028         **indexes_kwargs : optional\n4029             The keyword arguments form of ``indexes``.\n4030             One of indexes or indexes_kwargs must be provided.\n4031 \n4032         Returns\n4033         -------\n4034         obj : Dataset\n4035             Another dataset, with this dataset's data but replaced coordinates.\n4036 \n4037         Examples\n4038         --------\n4039         >>> arr = xr.DataArray(\n4040         ...     data=np.ones((2, 3)),\n4041         ...     dims=[\"x\", \"y\"],\n4042         ...     coords={\"x\": range(2), \"y\": range(3), \"a\": (\"x\", [3, 4])},\n4043         ... )\n4044         >>> ds = xr.Dataset({\"v\": arr})\n4045         >>> ds\n4046         <xarray.Dataset>\n4047         Dimensions:  (x: 2, y: 3)\n4048         Coordinates:\n4049           * x        (x) int64 0 1\n4050           * y        (y) int64 0 1 2\n4051             a        (x) int64 3 4\n4052         Data variables:\n4053             v        (x, y) float64 1.0 1.0 1.0 1.0 1.0 1.0\n4054         >>> ds.set_index(x=\"a\")\n4055         <xarray.Dataset>\n4056         Dimensions:  (x: 2, y: 3)\n4057         Coordinates:\n4058           * x        (x) int64 3 4\n4059           * y        (y) int64 0 1 2\n4060         Data variables:\n4061             v        (x, y) float64 1.0 1.0 1.0 1.0 1.0 1.0\n4062 \n4063         See Also\n4064         --------\n4065         Dataset.reset_index\n4066         Dataset.set_xindex\n4067         Dataset.swap_dims\n4068         \"\"\"\n4069         dim_coords = either_dict_or_kwargs(indexes, indexes_kwargs, \"set_index\")\n4070 \n4071         new_indexes: dict[Hashable, Index] = {}\n4072         new_variables: dict[Hashable, Variable] = {}\n4073         drop_indexes: set[Hashable] = set()\n4074         drop_variables: set[Hashable] = set()\n4075         replace_dims: dict[Hashable, Hashable] = {}\n4076         all_var_names: set[Hashable] = set()\n4077 \n4078         for dim, _var_names in dim_coords.items():\n4079             if isinstance(_var_names, str) or not isinstance(_var_names, Sequence):\n4080                 var_names = [_var_names]\n4081             else:\n4082                 var_names = list(_var_names)\n4083 \n4084             invalid_vars = set(var_names) - set(self._variables)\n4085             if invalid_vars:\n4086                 raise ValueError(\n4087                     \", \".join([str(v) for v in invalid_vars])\n4088                     + \" variable(s) do not exist\"\n4089                 )\n4090 \n4091             all_var_names.update(var_names)\n4092             drop_variables.update(var_names)\n4093 \n4094             # drop any pre-existing index involved and its corresponding coordinates\n4095             index_coord_names = self.xindexes.get_all_coords(dim, errors=\"ignore\")\n4096             all_index_coord_names = set(index_coord_names)\n4097             for k in var_names:\n4098                 all_index_coord_names.update(\n4099                     self.xindexes.get_all_coords(k, errors=\"ignore\")\n4100                 )\n4101 \n4102             drop_indexes.update(all_index_coord_names)\n4103             drop_variables.update(all_index_coord_names)\n4104 \n4105             if len(var_names) == 1 and (not append or dim not in self._indexes):\n4106                 var_name = var_names[0]\n4107                 var = self._variables[var_name]\n4108                 if var.dims != (dim,):\n4109                     raise ValueError(\n4110                         f\"dimension mismatch: try setting an index for dimension {dim!r} with \"\n4111                         f\"variable {var_name!r} that has dimensions {var.dims}\"\n4112                     )\n4113                 idx = PandasIndex.from_variables({dim: var}, options={})\n4114                 idx_vars = idx.create_variables({var_name: var})\n4115 \n4116                 # trick to preserve coordinate order in this case\n4117                 if dim in self._coord_names:\n4118                     drop_variables.remove(dim)\n4119             else:\n4120                 if append:\n4121                     current_variables = {\n4122                         k: self._variables[k] for k in index_coord_names\n4123                     }\n4124                 else:\n4125                     current_variables = {}\n4126                 idx, idx_vars = PandasMultiIndex.from_variables_maybe_expand(\n4127                     dim,\n4128                     current_variables,\n4129                     {k: self._variables[k] for k in var_names},\n4130                 )\n4131                 for n in idx.index.names:\n4132                     replace_dims[n] = dim\n4133 \n4134             new_indexes.update({k: idx for k in idx_vars})\n4135             new_variables.update(idx_vars)\n4136 \n4137         # re-add deindexed coordinates (convert to base variables)\n4138         for k in drop_variables:\n4139             if (\n4140                 k not in new_variables\n4141                 and k not in all_var_names\n4142                 and k in self._coord_names\n4143             ):\n4144                 new_variables[k] = self._variables[k].to_base_variable()\n4145 \n4146         indexes_: dict[Any, Index] = {\n4147             k: v for k, v in self._indexes.items() if k not in drop_indexes\n4148         }\n4149         indexes_.update(new_indexes)\n4150 \n4151         variables = {\n4152             k: v for k, v in self._variables.items() if k not in drop_variables\n4153         }\n4154         variables.update(new_variables)\n4155 \n4156         # update dimensions if necessary, GH: 3512\n4157         for k, v in variables.items():\n4158             if any(d in replace_dims for d in v.dims):\n4159                 new_dims = [replace_dims.get(d, d) for d in v.dims]\n4160                 variables[k] = v._replace(dims=new_dims)\n4161 \n4162         coord_names = self._coord_names - drop_variables | set(new_variables)\n4163 \n4164         return self._replace_with_new_dims(\n4165             variables, coord_names=coord_names, indexes=indexes_\n4166         )\n4167 \n4168     def reset_index(\n4169         self: T_Dataset,\n4170         dims_or_levels: Hashable | Sequence[Hashable],\n4171         drop: bool = False,\n4172     ) -> T_Dataset:\n4173         \"\"\"Reset the specified index(es) or multi-index level(s).\n4174 \n4175         This legacy method is specific to pandas (multi-)indexes and\n4176         1-dimensional \"dimension\" coordinates. See the more generic\n4177         :py:meth:`~Dataset.drop_indexes` and :py:meth:`~Dataset.set_xindex`\n4178         method to respectively drop and set pandas or custom indexes for\n4179         arbitrary coordinates.\n4180 \n4181         Parameters\n4182         ----------\n4183         dims_or_levels : Hashable or Sequence of Hashable\n4184             Name(s) of the dimension(s) and/or multi-index level(s) that will\n4185             be reset.\n4186         drop : bool, default: False\n4187             If True, remove the specified indexes and/or multi-index levels\n4188             instead of extracting them as new coordinates (default: False).\n4189 \n4190         Returns\n4191         -------\n4192         obj : Dataset\n4193             Another dataset, with this dataset's data but replaced coordinates.\n4194 \n4195         See Also\n4196         --------\n4197         Dataset.set_index\n4198         Dataset.set_xindex\n4199         Dataset.drop_indexes\n4200         \"\"\"\n4201         if isinstance(dims_or_levels, str) or not isinstance(dims_or_levels, Sequence):\n4202             dims_or_levels = [dims_or_levels]\n4203 \n4204         invalid_coords = set(dims_or_levels) - set(self._indexes)\n4205         if invalid_coords:\n4206             raise ValueError(\n4207                 f\"{tuple(invalid_coords)} are not coordinates with an index\"\n4208             )\n4209 \n4210         drop_indexes: set[Hashable] = set()\n4211         drop_variables: set[Hashable] = set()\n4212         seen: set[Index] = set()\n4213         new_indexes: dict[Hashable, Index] = {}\n4214         new_variables: dict[Hashable, Variable] = {}\n4215 \n4216         def drop_or_convert(var_names):\n4217             if drop:\n4218                 drop_variables.update(var_names)\n4219             else:\n4220                 base_vars = {\n4221                     k: self._variables[k].to_base_variable() for k in var_names\n4222                 }\n4223                 new_variables.update(base_vars)\n4224 \n4225         for name in dims_or_levels:\n4226             index = self._indexes[name]\n4227 \n4228             if index in seen:\n4229                 continue\n4230             seen.add(index)\n4231 \n4232             idx_var_names = set(self.xindexes.get_all_coords(name))\n4233             drop_indexes.update(idx_var_names)\n4234 \n4235             if isinstance(index, PandasMultiIndex):\n4236                 # special case for pd.MultiIndex\n4237                 level_names = index.index.names\n4238                 keep_level_vars = {\n4239                     k: self._variables[k]\n4240                     for k in level_names\n4241                     if k not in dims_or_levels\n4242                 }\n4243 \n4244                 if index.dim not in dims_or_levels and keep_level_vars:\n4245                     # do not drop the multi-index completely\n4246                     # instead replace it by a new (multi-)index with dropped level(s)\n4247                     idx = index.keep_levels(keep_level_vars)\n4248                     idx_vars = idx.create_variables(keep_level_vars)\n4249                     new_indexes.update({k: idx for k in idx_vars})\n4250                     new_variables.update(idx_vars)\n4251                     if not isinstance(idx, PandasMultiIndex):\n4252                         # multi-index reduced to single index\n4253                         # backward compatibility: unique level coordinate renamed to dimension\n4254                         drop_variables.update(keep_level_vars)\n4255                     drop_or_convert(\n4256                         [k for k in level_names if k not in keep_level_vars]\n4257                     )\n4258                 else:\n4259                     # always drop the multi-index dimension variable\n4260                     drop_variables.add(index.dim)\n4261                     drop_or_convert(level_names)\n4262             else:\n4263                 drop_or_convert(idx_var_names)\n4264 \n4265         indexes = {k: v for k, v in self._indexes.items() if k not in drop_indexes}\n4266         indexes.update(new_indexes)\n4267 \n4268         variables = {\n4269             k: v for k, v in self._variables.items() if k not in drop_variables\n4270         }\n4271         variables.update(new_variables)\n4272 \n4273         coord_names = self._coord_names - drop_variables\n4274 \n4275         return self._replace_with_new_dims(\n4276             variables, coord_names=coord_names, indexes=indexes\n4277         )\n4278 \n4279     def set_xindex(\n4280         self: T_Dataset,\n4281         coord_names: str | Sequence[Hashable],\n4282         index_cls: type[Index] | None = None,\n4283         **options,\n4284     ) -> T_Dataset:\n4285         \"\"\"Set a new, Xarray-compatible index from one or more existing\n4286         coordinate(s).\n4287 \n4288         Parameters\n4289         ----------\n4290         coord_names : str or list\n4291             Name(s) of the coordinate(s) used to build the index.\n4292             If several names are given, their order matters.\n4293         index_cls : subclass of :class:`~xarray.indexes.Index`, optional\n4294             The type of index to create. By default, try setting\n4295             a ``PandasIndex`` if ``len(coord_names) == 1``,\n4296             otherwise a ``PandasMultiIndex``.\n4297         **options\n4298             Options passed to the index constructor.\n4299 \n4300         Returns\n4301         -------\n4302         obj : Dataset\n4303             Another dataset, with this dataset's data and with a new index.\n4304 \n4305         \"\"\"\n4306         # the Sequence check is required for mypy\n4307         if is_scalar(coord_names) or not isinstance(coord_names, Sequence):\n4308             coord_names = [coord_names]\n4309 \n4310         if index_cls is None:\n4311             if len(coord_names) == 1:\n4312                 index_cls = PandasIndex\n4313             else:\n4314                 index_cls = PandasMultiIndex\n4315         else:\n4316             if not issubclass(index_cls, Index):\n4317                 raise TypeError(f\"{index_cls} is not a subclass of xarray.Index\")\n4318 \n4319         invalid_coords = set(coord_names) - self._coord_names\n4320 \n4321         if invalid_coords:\n4322             msg = [\"invalid coordinate(s)\"]\n4323             no_vars = invalid_coords - set(self._variables)\n4324             data_vars = invalid_coords - no_vars\n4325             if no_vars:\n4326                 msg.append(f\"those variables don't exist: {no_vars}\")\n4327             if data_vars:\n4328                 msg.append(\n4329                     f\"those variables are data variables: {data_vars}, use `set_coords` first\"\n4330                 )\n4331             raise ValueError(\"\\n\".join(msg))\n4332 \n4333         # we could be more clever here (e.g., drop-in index replacement if index\n4334         # coordinates do not conflict), but let's not allow this for now\n4335         indexed_coords = set(coord_names) & set(self._indexes)\n4336 \n4337         if indexed_coords:\n4338             raise ValueError(\n4339                 f\"those coordinates already have an index: {indexed_coords}\"\n4340             )\n4341 \n4342         coord_vars = {name: self._variables[name] for name in coord_names}\n4343 \n4344         index = index_cls.from_variables(coord_vars, options=options)\n4345 \n4346         new_coord_vars = index.create_variables(coord_vars)\n4347 \n4348         # special case for setting a pandas multi-index from level coordinates\n4349         # TODO: remove it once we depreciate pandas multi-index dimension (tuple\n4350         # elements) coordinate\n4351         if isinstance(index, PandasMultiIndex):\n4352             coord_names = [index.dim] + list(coord_names)\n4353 \n4354         variables: dict[Hashable, Variable]\n4355         indexes: dict[Hashable, Index]\n4356 \n4357         if len(coord_names) == 1:\n4358             variables = self._variables.copy()\n4359             indexes = self._indexes.copy()\n4360 \n4361             name = list(coord_names).pop()\n4362             if name in new_coord_vars:\n4363                 variables[name] = new_coord_vars[name]\n4364             indexes[name] = index\n4365         else:\n4366             # reorder variables and indexes so that coordinates having the same\n4367             # index are next to each other\n4368             variables = {}\n4369             for name, var in self._variables.items():\n4370                 if name not in coord_names:\n4371                     variables[name] = var\n4372 \n4373             indexes = {}\n4374             for name, idx in self._indexes.items():\n4375                 if name not in coord_names:\n4376                     indexes[name] = idx\n4377 \n4378             for name in coord_names:\n4379                 try:\n4380                     variables[name] = new_coord_vars[name]\n4381                 except KeyError:\n4382                     variables[name] = self._variables[name]\n4383                 indexes[name] = index\n4384 \n4385         return self._replace(\n4386             variables=variables,\n4387             coord_names=self._coord_names | set(coord_names),\n4388             indexes=indexes,\n4389         )\n4390 \n4391     def reorder_levels(\n4392         self: T_Dataset,\n4393         dim_order: Mapping[Any, Sequence[int | Hashable]] | None = None,\n4394         **dim_order_kwargs: Sequence[int | Hashable],\n4395     ) -> T_Dataset:\n4396         \"\"\"Rearrange index levels using input order.\n4397 \n4398         Parameters\n4399         ----------\n4400         dim_order : dict-like of Hashable to Sequence of int or Hashable, optional\n4401             Mapping from names matching dimensions and values given\n4402             by lists representing new level orders. Every given dimension\n4403             must have a multi-index.\n4404         **dim_order_kwargs : Sequence of int or Hashable, optional\n4405             The keyword arguments form of ``dim_order``.\n4406             One of dim_order or dim_order_kwargs must be provided.\n4407 \n4408         Returns\n4409         -------\n4410         obj : Dataset\n4411             Another dataset, with this dataset's data but replaced\n4412             coordinates.\n4413         \"\"\"\n4414         dim_order = either_dict_or_kwargs(dim_order, dim_order_kwargs, \"reorder_levels\")\n4415         variables = self._variables.copy()\n4416         indexes = dict(self._indexes)\n4417         new_indexes: dict[Hashable, Index] = {}\n4418         new_variables: dict[Hashable, IndexVariable] = {}\n4419 \n4420         for dim, order in dim_order.items():\n4421             index = self._indexes[dim]\n4422 \n4423             if not isinstance(index, PandasMultiIndex):\n4424                 raise ValueError(f\"coordinate {dim} has no MultiIndex\")\n4425 \n4426             level_vars = {k: self._variables[k] for k in order}\n4427             idx = index.reorder_levels(level_vars)\n4428             idx_vars = idx.create_variables(level_vars)\n4429             new_indexes.update({k: idx for k in idx_vars})\n4430             new_variables.update(idx_vars)\n4431 \n4432         indexes = {k: v for k, v in self._indexes.items() if k not in new_indexes}\n4433         indexes.update(new_indexes)\n4434 \n4435         variables = {k: v for k, v in self._variables.items() if k not in new_variables}\n4436         variables.update(new_variables)\n4437 \n4438         return self._replace(variables, indexes=indexes)\n4439 \n4440     def _get_stack_index(\n4441         self,\n4442         dim,\n4443         multi=False,\n4444         create_index=False,\n4445     ) -> tuple[Index | None, dict[Hashable, Variable]]:\n4446         \"\"\"Used by stack and unstack to get one pandas (multi-)index among\n4447         the indexed coordinates along dimension `dim`.\n4448 \n4449         If exactly one index is found, return it with its corresponding\n4450         coordinate variables(s), otherwise return None and an empty dict.\n4451 \n4452         If `create_index=True`, create a new index if none is found or raise\n4453         an error if multiple indexes are found.\n4454 \n4455         \"\"\"\n4456         stack_index: Index | None = None\n4457         stack_coords: dict[Hashable, Variable] = {}\n4458 \n4459         for name, index in self._indexes.items():\n4460             var = self._variables[name]\n4461             if (\n4462                 var.ndim == 1\n4463                 and var.dims[0] == dim\n4464                 and (\n4465                     # stack: must be a single coordinate index\n4466                     not multi\n4467                     and not self.xindexes.is_multi(name)\n4468                     # unstack: must be an index that implements .unstack\n4469                     or multi\n4470                     and type(index).unstack is not Index.unstack\n4471                 )\n4472             ):\n4473                 if stack_index is not None and index is not stack_index:\n4474                     # more than one index found, stop\n4475                     if create_index:\n4476                         raise ValueError(\n4477                             f\"cannot stack dimension {dim!r} with `create_index=True` \"\n4478                             \"and with more than one index found along that dimension\"\n4479                         )\n4480                     return None, {}\n4481                 stack_index = index\n4482                 stack_coords[name] = var\n4483 \n4484         if create_index and stack_index is None:\n4485             if dim in self._variables:\n4486                 var = self._variables[dim]\n4487             else:\n4488                 _, _, var = _get_virtual_variable(self._variables, dim, self.dims)\n4489             # dummy index (only `stack_coords` will be used to construct the multi-index)\n4490             stack_index = PandasIndex([0], dim)\n4491             stack_coords = {dim: var}\n4492 \n4493         return stack_index, stack_coords\n4494 \n4495     def _stack_once(\n4496         self: T_Dataset,\n4497         dims: Sequence[Hashable | ellipsis],\n4498         new_dim: Hashable,\n4499         index_cls: type[Index],\n4500         create_index: bool | None = True,\n4501     ) -> T_Dataset:\n4502         if dims == ...:\n4503             raise ValueError(\"Please use [...] for dims, rather than just ...\")\n4504         if ... in dims:\n4505             dims = list(infix_dims(dims, self.dims))\n4506 \n4507         new_variables: dict[Hashable, Variable] = {}\n4508         stacked_var_names: list[Hashable] = []\n4509         drop_indexes: list[Hashable] = []\n4510 \n4511         for name, var in self.variables.items():\n4512             if any(d in var.dims for d in dims):\n4513                 add_dims = [d for d in dims if d not in var.dims]\n4514                 vdims = list(var.dims) + add_dims\n4515                 shape = [self.dims[d] for d in vdims]\n4516                 exp_var = var.set_dims(vdims, shape)\n4517                 stacked_var = exp_var.stack(**{new_dim: dims})\n4518                 new_variables[name] = stacked_var\n4519                 stacked_var_names.append(name)\n4520             else:\n4521                 new_variables[name] = var.copy(deep=False)\n4522 \n4523         # drop indexes of stacked coordinates (if any)\n4524         for name in stacked_var_names:\n4525             drop_indexes += list(self.xindexes.get_all_coords(name, errors=\"ignore\"))\n4526 \n4527         new_indexes = {}\n4528         new_coord_names = set(self._coord_names)\n4529         if create_index or create_index is None:\n4530             product_vars: dict[Any, Variable] = {}\n4531             for dim in dims:\n4532                 idx, idx_vars = self._get_stack_index(dim, create_index=create_index)\n4533                 if idx is not None:\n4534                     product_vars.update(idx_vars)\n4535 \n4536             if len(product_vars) == len(dims):\n4537                 idx = index_cls.stack(product_vars, new_dim)\n4538                 new_indexes[new_dim] = idx\n4539                 new_indexes.update({k: idx for k in product_vars})\n4540                 idx_vars = idx.create_variables(product_vars)\n4541                 # keep consistent multi-index coordinate order\n4542                 for k in idx_vars:\n4543                     new_variables.pop(k, None)\n4544                 new_variables.update(idx_vars)\n4545                 new_coord_names.update(idx_vars)\n4546 \n4547         indexes = {k: v for k, v in self._indexes.items() if k not in drop_indexes}\n4548         indexes.update(new_indexes)\n4549 \n4550         return self._replace_with_new_dims(\n4551             new_variables, coord_names=new_coord_names, indexes=indexes\n4552         )\n4553 \n4554     def stack(\n4555         self: T_Dataset,\n4556         dimensions: Mapping[Any, Sequence[Hashable | ellipsis]] | None = None,\n4557         create_index: bool | None = True,\n4558         index_cls: type[Index] = PandasMultiIndex,\n4559         **dimensions_kwargs: Sequence[Hashable | ellipsis],\n4560     ) -> T_Dataset:\n4561         \"\"\"\n4562         Stack any number of existing dimensions into a single new dimension.\n4563 \n4564         New dimensions will be added at the end, and by default the corresponding\n4565         coordinate variables will be combined into a MultiIndex.\n4566 \n4567         Parameters\n4568         ----------\n4569         dimensions : mapping of hashable to sequence of hashable\n4570             Mapping of the form `new_name=(dim1, dim2, ...)`. Names of new\n4571             dimensions, and the existing dimensions that they replace. An\n4572             ellipsis (`...`) will be replaced by all unlisted dimensions.\n4573             Passing a list containing an ellipsis (`stacked_dim=[...]`) will stack over\n4574             all dimensions.\n4575         create_index : bool or None, default: True\n4576 \n4577             - True: create a multi-index for each of the stacked dimensions.\n4578             - False: don't create any index.\n4579             - None. create a multi-index only if exactly one single (1-d) coordinate\n4580               index is found for every dimension to stack.\n4581 \n4582         index_cls: Index-class, default: PandasMultiIndex\n4583             Can be used to pass a custom multi-index type (must be an Xarray index that\n4584             implements `.stack()`). By default, a pandas multi-index wrapper is used.\n4585         **dimensions_kwargs\n4586             The keyword arguments form of ``dimensions``.\n4587             One of dimensions or dimensions_kwargs must be provided.\n4588 \n4589         Returns\n4590         -------\n4591         stacked : Dataset\n4592             Dataset with stacked data.\n4593 \n4594         See Also\n4595         --------\n4596         Dataset.unstack\n4597         \"\"\"\n4598         dimensions = either_dict_or_kwargs(dimensions, dimensions_kwargs, \"stack\")\n4599         result = self\n4600         for new_dim, dims in dimensions.items():\n4601             result = result._stack_once(dims, new_dim, index_cls, create_index)\n4602         return result\n4603 \n4604     def to_stacked_array(\n4605         self,\n4606         new_dim: Hashable,\n4607         sample_dims: Collection[Hashable],\n4608         variable_dim: Hashable = \"variable\",\n4609         name: Hashable | None = None,\n4610     ) -> DataArray:\n4611         \"\"\"Combine variables of differing dimensionality into a DataArray\n4612         without broadcasting.\n4613 \n4614         This method is similar to Dataset.to_array but does not broadcast the\n4615         variables.\n4616 \n4617         Parameters\n4618         ----------\n4619         new_dim : hashable\n4620             Name of the new stacked coordinate\n4621         sample_dims : Collection of hashables\n4622             List of dimensions that **will not** be stacked. Each array in the\n4623             dataset must share these dimensions. For machine learning\n4624             applications, these define the dimensions over which samples are\n4625             drawn.\n4626         variable_dim : hashable, default: \"variable\"\n4627             Name of the level in the stacked coordinate which corresponds to\n4628             the variables.\n4629         name : hashable, optional\n4630             Name of the new data array.\n4631 \n4632         Returns\n4633         -------\n4634         stacked : DataArray\n4635             DataArray with the specified dimensions and data variables\n4636             stacked together. The stacked coordinate is named ``new_dim``\n4637             and represented by a MultiIndex object with a level containing the\n4638             data variable names. The name of this level is controlled using\n4639             the ``variable_dim`` argument.\n4640 \n4641         See Also\n4642         --------\n4643         Dataset.to_array\n4644         Dataset.stack\n4645         DataArray.to_unstacked_dataset\n4646 \n4647         Examples\n4648         --------\n4649         >>> data = xr.Dataset(\n4650         ...     data_vars={\n4651         ...         \"a\": ((\"x\", \"y\"), [[0, 1, 2], [3, 4, 5]]),\n4652         ...         \"b\": (\"x\", [6, 7]),\n4653         ...     },\n4654         ...     coords={\"y\": [\"u\", \"v\", \"w\"]},\n4655         ... )\n4656 \n4657         >>> data\n4658         <xarray.Dataset>\n4659         Dimensions:  (x: 2, y: 3)\n4660         Coordinates:\n4661           * y        (y) <U1 'u' 'v' 'w'\n4662         Dimensions without coordinates: x\n4663         Data variables:\n4664             a        (x, y) int64 0 1 2 3 4 5\n4665             b        (x) int64 6 7\n4666 \n4667         >>> data.to_stacked_array(\"z\", sample_dims=[\"x\"])\n4668         <xarray.DataArray 'a' (x: 2, z: 4)>\n4669         array([[0, 1, 2, 6],\n4670                [3, 4, 5, 7]])\n4671         Coordinates:\n4672           * z         (z) object MultiIndex\n4673           * variable  (z) object 'a' 'a' 'a' 'b'\n4674           * y         (z) object 'u' 'v' 'w' nan\n4675         Dimensions without coordinates: x\n4676 \n4677         \"\"\"\n4678         from xarray.core.concat import concat\n4679 \n4680         stacking_dims = tuple(dim for dim in self.dims if dim not in sample_dims)\n4681 \n4682         for variable in self:\n4683             dims = self[variable].dims\n4684             dims_include_sample_dims = set(sample_dims) <= set(dims)\n4685             if not dims_include_sample_dims:\n4686                 raise ValueError(\n4687                     \"All variables in the dataset must contain the \"\n4688                     \"dimensions {}.\".format(dims)\n4689                 )\n4690 \n4691         def ensure_stackable(val):\n4692             assign_coords = {variable_dim: val.name}\n4693             for dim in stacking_dims:\n4694                 if dim not in val.dims:\n4695                     assign_coords[dim] = None\n4696 \n4697             expand_dims = set(stacking_dims).difference(set(val.dims))\n4698             expand_dims.add(variable_dim)\n4699             # must be list for .expand_dims\n4700             expand_dims = list(expand_dims)\n4701 \n4702             return (\n4703                 val.assign_coords(**assign_coords)\n4704                 .expand_dims(expand_dims)\n4705                 .stack({new_dim: (variable_dim,) + stacking_dims})\n4706             )\n4707 \n4708         # concatenate the arrays\n4709         stackable_vars = [ensure_stackable(self[key]) for key in self.data_vars]\n4710         data_array = concat(stackable_vars, dim=new_dim)\n4711 \n4712         if name is not None:\n4713             data_array.name = name\n4714 \n4715         return data_array\n4716 \n4717     def _unstack_once(\n4718         self: T_Dataset,\n4719         dim: Hashable,\n4720         index_and_vars: tuple[Index, dict[Hashable, Variable]],\n4721         fill_value,\n4722         sparse: bool = False,\n4723     ) -> T_Dataset:\n4724         index, index_vars = index_and_vars\n4725         variables: dict[Hashable, Variable] = {}\n4726         indexes = {k: v for k, v in self._indexes.items() if k != dim}\n4727 \n4728         new_indexes, clean_index = index.unstack()\n4729         indexes.update(new_indexes)\n4730 \n4731         for name, idx in new_indexes.items():\n4732             variables.update(idx.create_variables(index_vars))\n4733 \n4734         for name, var in self.variables.items():\n4735             if name not in index_vars:\n4736                 if dim in var.dims:\n4737                     if isinstance(fill_value, Mapping):\n4738                         fill_value_ = fill_value[name]\n4739                     else:\n4740                         fill_value_ = fill_value\n4741 \n4742                     variables[name] = var._unstack_once(\n4743                         index=clean_index,\n4744                         dim=dim,\n4745                         fill_value=fill_value_,\n4746                         sparse=sparse,\n4747                     )\n4748                 else:\n4749                     variables[name] = var\n4750 \n4751         coord_names = set(self._coord_names) - {dim} | set(new_indexes)\n4752 \n4753         return self._replace_with_new_dims(\n4754             variables, coord_names=coord_names, indexes=indexes\n4755         )\n4756 \n4757     def _unstack_full_reindex(\n4758         self: T_Dataset,\n4759         dim: Hashable,\n4760         index_and_vars: tuple[Index, dict[Hashable, Variable]],\n4761         fill_value,\n4762         sparse: bool,\n4763     ) -> T_Dataset:\n4764         index, index_vars = index_and_vars\n4765         variables: dict[Hashable, Variable] = {}\n4766         indexes = {k: v for k, v in self._indexes.items() if k != dim}\n4767 \n4768         new_indexes, clean_index = index.unstack()\n4769         indexes.update(new_indexes)\n4770 \n4771         new_index_variables = {}\n4772         for name, idx in new_indexes.items():\n4773             new_index_variables.update(idx.create_variables(index_vars))\n4774 \n4775         new_dim_sizes = {k: v.size for k, v in new_index_variables.items()}\n4776         variables.update(new_index_variables)\n4777 \n4778         # take a shortcut in case the MultiIndex was not modified.\n4779         full_idx = pd.MultiIndex.from_product(\n4780             clean_index.levels, names=clean_index.names\n4781         )\n4782         if clean_index.equals(full_idx):\n4783             obj = self\n4784         else:\n4785             # TODO: we may depreciate implicit re-indexing with a pandas.MultiIndex\n4786             xr_full_idx = PandasMultiIndex(full_idx, dim)\n4787             indexers = Indexes(\n4788                 {k: xr_full_idx for k in index_vars},\n4789                 xr_full_idx.create_variables(index_vars),\n4790             )\n4791             obj = self._reindex(\n4792                 indexers, copy=False, fill_value=fill_value, sparse=sparse\n4793             )\n4794 \n4795         for name, var in obj.variables.items():\n4796             if name not in index_vars:\n4797                 if dim in var.dims:\n4798                     variables[name] = var.unstack({dim: new_dim_sizes})\n4799                 else:\n4800                     variables[name] = var\n4801 \n4802         coord_names = set(self._coord_names) - {dim} | set(new_dim_sizes)\n4803 \n4804         return self._replace_with_new_dims(\n4805             variables, coord_names=coord_names, indexes=indexes\n4806         )\n4807 \n4808     def unstack(\n4809         self: T_Dataset,\n4810         dim: Dims = None,\n4811         fill_value: Any = xrdtypes.NA,\n4812         sparse: bool = False,\n4813     ) -> T_Dataset:\n4814         \"\"\"\n4815         Unstack existing dimensions corresponding to MultiIndexes into\n4816         multiple new dimensions.\n4817 \n4818         New dimensions will be added at the end.\n4819 \n4820         Parameters\n4821         ----------\n4822         dim : str, Iterable of Hashable or None, optional\n4823             Dimension(s) over which to unstack. By default unstacks all\n4824             MultiIndexes.\n4825         fill_value : scalar or dict-like, default: nan\n4826             value to be filled. If a dict-like, maps variable names to\n4827             fill values. If not provided or if the dict-like does not\n4828             contain all variables, the dtype's NA value will be used.\n4829         sparse : bool, default: False\n4830             use sparse-array if True\n4831 \n4832         Returns\n4833         -------\n4834         unstacked : Dataset\n4835             Dataset with unstacked data.\n4836 \n4837         See Also\n4838         --------\n4839         Dataset.stack\n4840         \"\"\"\n4841 \n4842         if dim is None:\n4843             dims = list(self.dims)\n4844         else:\n4845             if isinstance(dim, str) or not isinstance(dim, Iterable):\n4846                 dims = [dim]\n4847             else:\n4848                 dims = list(dim)\n4849 \n4850             missing_dims = [d for d in dims if d not in self.dims]\n4851             if missing_dims:\n4852                 raise ValueError(\n4853                     f\"Dataset does not contain the dimensions: {missing_dims}\"\n4854                 )\n4855 \n4856         # each specified dimension must have exactly one multi-index\n4857         stacked_indexes: dict[Any, tuple[Index, dict[Hashable, Variable]]] = {}\n4858         for d in dims:\n4859             idx, idx_vars = self._get_stack_index(d, multi=True)\n4860             if idx is not None:\n4861                 stacked_indexes[d] = idx, idx_vars\n4862 \n4863         if dim is None:\n4864             dims = list(stacked_indexes)\n4865         else:\n4866             non_multi_dims = set(dims) - set(stacked_indexes)\n4867             if non_multi_dims:\n4868                 raise ValueError(\n4869                     \"cannot unstack dimensions that do not \"\n4870                     f\"have exactly one multi-index: {tuple(non_multi_dims)}\"\n4871                 )\n4872 \n4873         result = self.copy(deep=False)\n4874 \n4875         # we want to avoid allocating an object-dtype ndarray for a MultiIndex,\n4876         # so we can't just access self.variables[v].data for every variable.\n4877         # We only check the non-index variables.\n4878         # https://github.com/pydata/xarray/issues/5902\n4879         nonindexes = [\n4880             self.variables[k] for k in set(self.variables) - set(self._indexes)\n4881         ]\n4882         # Notes for each of these cases:\n4883         # 1. Dask arrays don't support assignment by index, which the fast unstack\n4884         #    function requires.\n4885         #    https://github.com/pydata/xarray/pull/4746#issuecomment-753282125\n4886         # 2. Sparse doesn't currently support (though we could special-case it)\n4887         #    https://github.com/pydata/sparse/issues/422\n4888         # 3. pint requires checking if it's a NumPy array until\n4889         #    https://github.com/pydata/xarray/pull/4751 is resolved,\n4890         #    Once that is resolved, explicitly exclude pint arrays.\n4891         #    pint doesn't implement `np.full_like` in a way that's\n4892         #    currently compatible.\n4893         sparse_array_type = array_type(\"sparse\")\n4894         needs_full_reindex = any(\n4895             is_duck_dask_array(v.data)\n4896             or isinstance(v.data, sparse_array_type)\n4897             or not isinstance(v.data, np.ndarray)\n4898             for v in nonindexes\n4899         )\n4900 \n4901         for d in dims:\n4902             if needs_full_reindex:\n4903                 result = result._unstack_full_reindex(\n4904                     d, stacked_indexes[d], fill_value, sparse\n4905                 )\n4906             else:\n4907                 result = result._unstack_once(d, stacked_indexes[d], fill_value, sparse)\n4908         return result\n4909 \n4910     def update(self: T_Dataset, other: CoercibleMapping) -> T_Dataset:\n4911         \"\"\"Update this dataset's variables with those from another dataset.\n4912 \n4913         Just like :py:meth:`dict.update` this is a in-place operation.\n4914         For a non-inplace version, see :py:meth:`Dataset.merge`.\n4915 \n4916         Parameters\n4917         ----------\n4918         other : Dataset or mapping\n4919             Variables with which to update this dataset. One of:\n4920 \n4921             - Dataset\n4922             - mapping {var name: DataArray}\n4923             - mapping {var name: Variable}\n4924             - mapping {var name: (dimension name, array-like)}\n4925             - mapping {var name: (tuple of dimension names, array-like)}\n4926 \n4927         Returns\n4928         -------\n4929         updated : Dataset\n4930             Updated dataset. Note that since the update is in-place this is the input\n4931             dataset.\n4932 \n4933             It is deprecated since version 0.17 and scheduled to be removed in 0.21.\n4934 \n4935         Raises\n4936         ------\n4937         ValueError\n4938             If any dimensions would have inconsistent sizes in the updated\n4939             dataset.\n4940 \n4941         See Also\n4942         --------\n4943         Dataset.assign\n4944         Dataset.merge\n4945         \"\"\"\n4946         merge_result = dataset_update_method(self, other)\n4947         return self._replace(inplace=True, **merge_result._asdict())\n4948 \n4949     def merge(\n4950         self: T_Dataset,\n4951         other: CoercibleMapping | DataArray,\n4952         overwrite_vars: Hashable | Iterable[Hashable] = frozenset(),\n4953         compat: CompatOptions = \"no_conflicts\",\n4954         join: JoinOptions = \"outer\",\n4955         fill_value: Any = xrdtypes.NA,\n4956         combine_attrs: CombineAttrsOptions = \"override\",\n4957     ) -> T_Dataset:\n4958         \"\"\"Merge the arrays of two datasets into a single dataset.\n4959 \n4960         This method generally does not allow for overriding data, with the\n4961         exception of attributes, which are ignored on the second dataset.\n4962         Variables with the same name are checked for conflicts via the equals\n4963         or identical methods.\n4964 \n4965         Parameters\n4966         ----------\n4967         other : Dataset or mapping\n4968             Dataset or variables to merge with this dataset.\n4969         overwrite_vars : hashable or iterable of hashable, optional\n4970             If provided, update variables of these name(s) without checking for\n4971             conflicts in this dataset.\n4972         compat : {\"identical\", \"equals\", \"broadcast_equals\", \\\n4973                   \"no_conflicts\", \"override\", \"minimal\"}, default: \"no_conflicts\"\n4974             String indicating how to compare variables of the same name for\n4975             potential conflicts:\n4976 \n4977             - 'identical': all values, dimensions and attributes must be the\n4978               same.\n4979             - 'equals': all values and dimensions must be the same.\n4980             - 'broadcast_equals': all values must be equal when variables are\n4981               broadcast against each other to ensure common dimensions.\n4982             - 'no_conflicts': only values which are not null in both datasets\n4983               must be equal. The returned dataset then contains the combination\n4984               of all non-null values.\n4985             - 'override': skip comparing and pick variable from first dataset\n4986             - 'minimal': drop conflicting coordinates\n4987 \n4988         join : {\"outer\", \"inner\", \"left\", \"right\", \"exact\", \"override\"}, \\\n4989                default: \"outer\"\n4990             Method for joining ``self`` and ``other`` along shared dimensions:\n4991 \n4992             - 'outer': use the union of the indexes\n4993             - 'inner': use the intersection of the indexes\n4994             - 'left': use indexes from ``self``\n4995             - 'right': use indexes from ``other``\n4996             - 'exact': error instead of aligning non-equal indexes\n4997             - 'override': use indexes from ``self`` that are the same size\n4998               as those of ``other`` in that dimension\n4999 \n5000         fill_value : scalar or dict-like, optional\n5001             Value to use for newly missing values. If a dict-like, maps\n5002             variable names (including coordinates) to fill values.\n5003         combine_attrs : {\"drop\", \"identical\", \"no_conflicts\", \"drop_conflicts\", \\\n5004                          \"override\"} or callable, default: \"override\"\n5005             A callable or a string indicating how to combine attrs of the objects being\n5006             merged:\n5007 \n5008             - \"drop\": empty attrs on returned Dataset.\n5009             - \"identical\": all attrs must be the same on every object.\n5010             - \"no_conflicts\": attrs from all objects are combined, any that have\n5011               the same name must also have the same value.\n5012             - \"drop_conflicts\": attrs from all objects are combined, any that have\n5013               the same name but different values are dropped.\n5014             - \"override\": skip comparing and copy attrs from the first dataset to\n5015               the result.\n5016 \n5017             If a callable, it must expect a sequence of ``attrs`` dicts and a context object\n5018             as its only parameters.\n5019 \n5020         Returns\n5021         -------\n5022         merged : Dataset\n5023             Merged dataset.\n5024 \n5025         Raises\n5026         ------\n5027         MergeError\n5028             If any variables conflict (see ``compat``).\n5029 \n5030         See Also\n5031         --------\n5032         Dataset.update\n5033         \"\"\"\n5034         from xarray.core.dataarray import DataArray\n5035 \n5036         other = other.to_dataset() if isinstance(other, DataArray) else other\n5037         merge_result = dataset_merge_method(\n5038             self,\n5039             other,\n5040             overwrite_vars=overwrite_vars,\n5041             compat=compat,\n5042             join=join,\n5043             fill_value=fill_value,\n5044             combine_attrs=combine_attrs,\n5045         )\n5046         return self._replace(**merge_result._asdict())\n5047 \n5048     def _assert_all_in_dataset(\n5049         self, names: Iterable[Hashable], virtual_okay: bool = False\n5050     ) -> None:\n5051         bad_names = set(names) - set(self._variables)\n5052         if virtual_okay:\n5053             bad_names -= self.virtual_variables\n5054         if bad_names:\n5055             raise ValueError(\n5056                 \"One or more of the specified variables \"\n5057                 \"cannot be found in this dataset\"\n5058             )\n5059 \n5060     def drop_vars(\n5061         self: T_Dataset,\n5062         names: Hashable | Iterable[Hashable],\n5063         *,\n5064         errors: ErrorOptions = \"raise\",\n5065     ) -> T_Dataset:\n5066         \"\"\"Drop variables from this dataset.\n5067 \n5068         Parameters\n5069         ----------\n5070         names : hashable or iterable of hashable\n5071             Name(s) of variables to drop.\n5072         errors : {\"raise\", \"ignore\"}, default: \"raise\"\n5073             If 'raise', raises a ValueError error if any of the variable\n5074             passed are not in the dataset. If 'ignore', any given names that are in the\n5075             dataset are dropped and no error is raised.\n5076 \n5077         Returns\n5078         -------\n5079         dropped : Dataset\n5080 \n5081         \"\"\"\n5082         # the Iterable check is required for mypy\n5083         if is_scalar(names) or not isinstance(names, Iterable):\n5084             names = {names}\n5085         else:\n5086             names = set(names)\n5087         if errors == \"raise\":\n5088             self._assert_all_in_dataset(names)\n5089 \n5090         # GH6505\n5091         other_names = set()\n5092         for var in names:\n5093             maybe_midx = self._indexes.get(var, None)\n5094             if isinstance(maybe_midx, PandasMultiIndex):\n5095                 idx_coord_names = set(maybe_midx.index.names + [maybe_midx.dim])\n5096                 idx_other_names = idx_coord_names - set(names)\n5097                 other_names.update(idx_other_names)\n5098         if other_names:\n5099             names |= set(other_names)\n5100             warnings.warn(\n5101                 f\"Deleting a single level of a MultiIndex is deprecated. Previously, this deleted all levels of a MultiIndex. \"\n5102                 f\"Please also drop the following variables: {other_names!r} to avoid an error in the future.\",\n5103                 DeprecationWarning,\n5104                 stacklevel=2,\n5105             )\n5106 \n5107         assert_no_index_corrupted(self.xindexes, names)\n5108 \n5109         variables = {k: v for k, v in self._variables.items() if k not in names}\n5110         coord_names = {k for k in self._coord_names if k in variables}\n5111         indexes = {k: v for k, v in self._indexes.items() if k not in names}\n5112         return self._replace_with_new_dims(\n5113             variables, coord_names=coord_names, indexes=indexes\n5114         )\n5115 \n5116     def drop_indexes(\n5117         self: T_Dataset,\n5118         coord_names: Hashable | Iterable[Hashable],\n5119         *,\n5120         errors: ErrorOptions = \"raise\",\n5121     ) -> T_Dataset:\n5122         \"\"\"Drop the indexes assigned to the given coordinates.\n5123 \n5124         Parameters\n5125         ----------\n5126         coord_names : hashable or iterable of hashable\n5127             Name(s) of the coordinate(s) for which to drop the index.\n5128         errors : {\"raise\", \"ignore\"}, default: \"raise\"\n5129             If 'raise', raises a ValueError error if any of the coordinates\n5130             passed have no index or are not in the dataset.\n5131             If 'ignore', no error is raised.\n5132 \n5133         Returns\n5134         -------\n5135         dropped : Dataset\n5136             A new dataset with dropped indexes.\n5137 \n5138         \"\"\"\n5139         # the Iterable check is required for mypy\n5140         if is_scalar(coord_names) or not isinstance(coord_names, Iterable):\n5141             coord_names = {coord_names}\n5142         else:\n5143             coord_names = set(coord_names)\n5144 \n5145         if errors == \"raise\":\n5146             invalid_coords = coord_names - self._coord_names\n5147             if invalid_coords:\n5148                 raise ValueError(f\"those coordinates don't exist: {invalid_coords}\")\n5149 \n5150             unindexed_coords = set(coord_names) - set(self._indexes)\n5151             if unindexed_coords:\n5152                 raise ValueError(\n5153                     f\"those coordinates do not have an index: {unindexed_coords}\"\n5154                 )\n5155 \n5156         assert_no_index_corrupted(self.xindexes, coord_names, action=\"remove index(es)\")\n5157 \n5158         variables = {}\n5159         for name, var in self._variables.items():\n5160             if name in coord_names:\n5161                 variables[name] = var.to_base_variable()\n5162             else:\n5163                 variables[name] = var\n5164 \n5165         indexes = {k: v for k, v in self._indexes.items() if k not in coord_names}\n5166 \n5167         return self._replace(variables=variables, indexes=indexes)\n5168 \n5169     def drop(\n5170         self: T_Dataset,\n5171         labels=None,\n5172         dim=None,\n5173         *,\n5174         errors: ErrorOptions = \"raise\",\n5175         **labels_kwargs,\n5176     ) -> T_Dataset:\n5177         \"\"\"Backward compatible method based on `drop_vars` and `drop_sel`\n5178 \n5179         Using either `drop_vars` or `drop_sel` is encouraged\n5180 \n5181         See Also\n5182         --------\n5183         Dataset.drop_vars\n5184         Dataset.drop_sel\n5185         \"\"\"\n5186         if errors not in [\"raise\", \"ignore\"]:\n5187             raise ValueError('errors must be either \"raise\" or \"ignore\"')\n5188 \n5189         if is_dict_like(labels) and not isinstance(labels, dict):\n5190             warnings.warn(\n5191                 \"dropping coordinates using `drop` is be deprecated; use drop_vars.\",\n5192                 FutureWarning,\n5193                 stacklevel=2,\n5194             )\n5195             return self.drop_vars(labels, errors=errors)\n5196 \n5197         if labels_kwargs or isinstance(labels, dict):\n5198             if dim is not None:\n5199                 raise ValueError(\"cannot specify dim and dict-like arguments.\")\n5200             labels = either_dict_or_kwargs(labels, labels_kwargs, \"drop\")\n5201 \n5202         if dim is None and (is_scalar(labels) or isinstance(labels, Iterable)):\n5203             warnings.warn(\n5204                 \"dropping variables using `drop` will be deprecated; using drop_vars is encouraged.\",\n5205                 PendingDeprecationWarning,\n5206                 stacklevel=2,\n5207             )\n5208             return self.drop_vars(labels, errors=errors)\n5209         if dim is not None:\n5210             warnings.warn(\n5211                 \"dropping labels using list-like labels is deprecated; using \"\n5212                 \"dict-like arguments with `drop_sel`, e.g. `ds.drop_sel(dim=[labels]).\",\n5213                 DeprecationWarning,\n5214                 stacklevel=2,\n5215             )\n5216             return self.drop_sel({dim: labels}, errors=errors, **labels_kwargs)\n5217 \n5218         warnings.warn(\n5219             \"dropping labels using `drop` will be deprecated; using drop_sel is encouraged.\",\n5220             PendingDeprecationWarning,\n5221             stacklevel=2,\n5222         )\n5223         return self.drop_sel(labels, errors=errors)\n5224 \n5225     def drop_sel(\n5226         self: T_Dataset, labels=None, *, errors: ErrorOptions = \"raise\", **labels_kwargs\n5227     ) -> T_Dataset:\n5228         \"\"\"Drop index labels from this dataset.\n5229 \n5230         Parameters\n5231         ----------\n5232         labels : mapping of hashable to Any\n5233             Index labels to drop\n5234         errors : {\"raise\", \"ignore\"}, default: \"raise\"\n5235             If 'raise', raises a ValueError error if\n5236             any of the index labels passed are not\n5237             in the dataset. If 'ignore', any given labels that are in the\n5238             dataset are dropped and no error is raised.\n5239         **labels_kwargs : {dim: label, ...}, optional\n5240             The keyword arguments form of ``dim`` and ``labels``\n5241 \n5242         Returns\n5243         -------\n5244         dropped : Dataset\n5245 \n5246         Examples\n5247         --------\n5248         >>> data = np.arange(6).reshape(2, 3)\n5249         >>> labels = [\"a\", \"b\", \"c\"]\n5250         >>> ds = xr.Dataset({\"A\": ([\"x\", \"y\"], data), \"y\": labels})\n5251         >>> ds\n5252         <xarray.Dataset>\n5253         Dimensions:  (x: 2, y: 3)\n5254         Coordinates:\n5255           * y        (y) <U1 'a' 'b' 'c'\n5256         Dimensions without coordinates: x\n5257         Data variables:\n5258             A        (x, y) int64 0 1 2 3 4 5\n5259         >>> ds.drop_sel(y=[\"a\", \"c\"])\n5260         <xarray.Dataset>\n5261         Dimensions:  (x: 2, y: 1)\n5262         Coordinates:\n5263           * y        (y) <U1 'b'\n5264         Dimensions without coordinates: x\n5265         Data variables:\n5266             A        (x, y) int64 1 4\n5267         >>> ds.drop_sel(y=\"b\")\n5268         <xarray.Dataset>\n5269         Dimensions:  (x: 2, y: 2)\n5270         Coordinates:\n5271           * y        (y) <U1 'a' 'c'\n5272         Dimensions without coordinates: x\n5273         Data variables:\n5274             A        (x, y) int64 0 2 3 5\n5275         \"\"\"\n5276         if errors not in [\"raise\", \"ignore\"]:\n5277             raise ValueError('errors must be either \"raise\" or \"ignore\"')\n5278 \n5279         labels = either_dict_or_kwargs(labels, labels_kwargs, \"drop_sel\")\n5280 \n5281         ds = self\n5282         for dim, labels_for_dim in labels.items():\n5283             # Don't cast to set, as it would harm performance when labels\n5284             # is a large numpy array\n5285             if utils.is_scalar(labels_for_dim):\n5286                 labels_for_dim = [labels_for_dim]\n5287             labels_for_dim = np.asarray(labels_for_dim)\n5288             try:\n5289                 index = self.get_index(dim)\n5290             except KeyError:\n5291                 raise ValueError(f\"dimension {dim!r} does not have coordinate labels\")\n5292             new_index = index.drop(labels_for_dim, errors=errors)\n5293             ds = ds.loc[{dim: new_index}]\n5294         return ds\n5295 \n5296     def drop_isel(self: T_Dataset, indexers=None, **indexers_kwargs) -> T_Dataset:\n5297         \"\"\"Drop index positions from this Dataset.\n5298 \n5299         Parameters\n5300         ----------\n5301         indexers : mapping of hashable to Any\n5302             Index locations to drop\n5303         **indexers_kwargs : {dim: position, ...}, optional\n5304             The keyword arguments form of ``dim`` and ``positions``\n5305 \n5306         Returns\n5307         -------\n5308         dropped : Dataset\n5309 \n5310         Raises\n5311         ------\n5312         IndexError\n5313 \n5314         Examples\n5315         --------\n5316         >>> data = np.arange(6).reshape(2, 3)\n5317         >>> labels = [\"a\", \"b\", \"c\"]\n5318         >>> ds = xr.Dataset({\"A\": ([\"x\", \"y\"], data), \"y\": labels})\n5319         >>> ds\n5320         <xarray.Dataset>\n5321         Dimensions:  (x: 2, y: 3)\n5322         Coordinates:\n5323           * y        (y) <U1 'a' 'b' 'c'\n5324         Dimensions without coordinates: x\n5325         Data variables:\n5326             A        (x, y) int64 0 1 2 3 4 5\n5327         >>> ds.drop_isel(y=[0, 2])\n5328         <xarray.Dataset>\n5329         Dimensions:  (x: 2, y: 1)\n5330         Coordinates:\n5331           * y        (y) <U1 'b'\n5332         Dimensions without coordinates: x\n5333         Data variables:\n5334             A        (x, y) int64 1 4\n5335         >>> ds.drop_isel(y=1)\n5336         <xarray.Dataset>\n5337         Dimensions:  (x: 2, y: 2)\n5338         Coordinates:\n5339           * y        (y) <U1 'a' 'c'\n5340         Dimensions without coordinates: x\n5341         Data variables:\n5342             A        (x, y) int64 0 2 3 5\n5343         \"\"\"\n5344 \n5345         indexers = either_dict_or_kwargs(indexers, indexers_kwargs, \"drop_isel\")\n5346 \n5347         ds = self\n5348         dimension_index = {}\n5349         for dim, pos_for_dim in indexers.items():\n5350             # Don't cast to set, as it would harm performance when labels\n5351             # is a large numpy array\n5352             if utils.is_scalar(pos_for_dim):\n5353                 pos_for_dim = [pos_for_dim]\n5354             pos_for_dim = np.asarray(pos_for_dim)\n5355             index = self.get_index(dim)\n5356             new_index = index.delete(pos_for_dim)\n5357             dimension_index[dim] = new_index\n5358         ds = ds.loc[dimension_index]\n5359         return ds\n5360 \n5361     def drop_dims(\n5362         self: T_Dataset,\n5363         drop_dims: str | Iterable[Hashable],\n5364         *,\n5365         errors: ErrorOptions = \"raise\",\n5366     ) -> T_Dataset:\n5367         \"\"\"Drop dimensions and associated variables from this dataset.\n5368 \n5369         Parameters\n5370         ----------\n5371         drop_dims : str or Iterable of Hashable\n5372             Dimension or dimensions to drop.\n5373         errors : {\"raise\", \"ignore\"}, default: \"raise\"\n5374             If 'raise', raises a ValueError error if any of the\n5375             dimensions passed are not in the dataset. If 'ignore', any given\n5376             dimensions that are in the dataset are dropped and no error is raised.\n5377 \n5378         Returns\n5379         -------\n5380         obj : Dataset\n5381             The dataset without the given dimensions (or any variables\n5382             containing those dimensions).\n5383         \"\"\"\n5384         if errors not in [\"raise\", \"ignore\"]:\n5385             raise ValueError('errors must be either \"raise\" or \"ignore\"')\n5386 \n5387         if isinstance(drop_dims, str) or not isinstance(drop_dims, Iterable):\n5388             drop_dims = {drop_dims}\n5389         else:\n5390             drop_dims = set(drop_dims)\n5391 \n5392         if errors == \"raise\":\n5393             missing_dims = drop_dims - set(self.dims)\n5394             if missing_dims:\n5395                 raise ValueError(\n5396                     f\"Dataset does not contain the dimensions: {missing_dims}\"\n5397                 )\n5398 \n5399         drop_vars = {k for k, v in self._variables.items() if set(v.dims) & drop_dims}\n5400         return self.drop_vars(drop_vars)\n5401 \n5402     def transpose(\n5403         self: T_Dataset,\n5404         *dims: Hashable,\n5405         missing_dims: ErrorOptionsWithWarn = \"raise\",\n5406     ) -> T_Dataset:\n5407         \"\"\"Return a new Dataset object with all array dimensions transposed.\n5408 \n5409         Although the order of dimensions on each array will change, the dataset\n5410         dimensions themselves will remain in fixed (sorted) order.\n5411 \n5412         Parameters\n5413         ----------\n5414         *dims : hashable, optional\n5415             By default, reverse the dimensions on each array. Otherwise,\n5416             reorder the dimensions to this order.\n5417         missing_dims : {\"raise\", \"warn\", \"ignore\"}, default: \"raise\"\n5418             What to do if dimensions that should be selected from are not present in the\n5419             Dataset:\n5420             - \"raise\": raise an exception\n5421             - \"warn\": raise a warning, and ignore the missing dimensions\n5422             - \"ignore\": ignore the missing dimensions\n5423 \n5424         Returns\n5425         -------\n5426         transposed : Dataset\n5427             Each array in the dataset (including) coordinates will be\n5428             transposed to the given order.\n5429 \n5430         Notes\n5431         -----\n5432         This operation returns a view of each array's data. It is\n5433         lazy for dask-backed DataArrays but not for numpy-backed DataArrays\n5434         -- the data will be fully loaded into memory.\n5435 \n5436         See Also\n5437         --------\n5438         numpy.transpose\n5439         DataArray.transpose\n5440         \"\"\"\n5441         # Raise error if list is passed as dims\n5442         if (len(dims) > 0) and (isinstance(dims[0], list)):\n5443             list_fix = [f\"{repr(x)}\" if isinstance(x, str) else f\"{x}\" for x in dims[0]]\n5444             raise TypeError(\n5445                 f'transpose requires dims to be passed as multiple arguments. Expected `{\", \".join(list_fix)}`. Received `{dims[0]}` instead'\n5446             )\n5447 \n5448         # Use infix_dims to check once for missing dimensions\n5449         if len(dims) != 0:\n5450             _ = list(infix_dims(dims, self.dims, missing_dims))\n5451 \n5452         ds = self.copy()\n5453         for name, var in self._variables.items():\n5454             var_dims = tuple(dim for dim in dims if dim in (var.dims + (...,)))\n5455             ds._variables[name] = var.transpose(*var_dims)\n5456         return ds\n5457 \n5458     def dropna(\n5459         self: T_Dataset,\n5460         dim: Hashable,\n5461         how: Literal[\"any\", \"all\"] = \"any\",\n5462         thresh: int | None = None,\n5463         subset: Iterable[Hashable] | None = None,\n5464     ) -> T_Dataset:\n5465         \"\"\"Returns a new dataset with dropped labels for missing values along\n5466         the provided dimension.\n5467 \n5468         Parameters\n5469         ----------\n5470         dim : hashable\n5471             Dimension along which to drop missing values. Dropping along\n5472             multiple dimensions simultaneously is not yet supported.\n5473         how : {\"any\", \"all\"}, default: \"any\"\n5474             - any : if any NA values are present, drop that label\n5475             - all : if all values are NA, drop that label\n5476 \n5477         thresh : int or None, optional\n5478             If supplied, require this many non-NA values.\n5479         subset : iterable of hashable or None, optional\n5480             Which variables to check for missing values. By default, all\n5481             variables in the dataset are checked.\n5482 \n5483         Returns\n5484         -------\n5485         Dataset\n5486         \"\"\"\n5487         # TODO: consider supporting multiple dimensions? Or not, given that\n5488         # there are some ugly edge cases, e.g., pandas's dropna differs\n5489         # depending on the order of the supplied axes.\n5490 \n5491         if dim not in self.dims:\n5492             raise ValueError(f\"{dim} must be a single dataset dimension\")\n5493 \n5494         if subset is None:\n5495             subset = iter(self.data_vars)\n5496 \n5497         count = np.zeros(self.dims[dim], dtype=np.int64)\n5498         size = np.int_(0)  # for type checking\n5499 \n5500         for k in subset:\n5501             array = self._variables[k]\n5502             if dim in array.dims:\n5503                 dims = [d for d in array.dims if d != dim]\n5504                 count += np.asarray(array.count(dims))  # type: ignore[attr-defined]\n5505                 size += math.prod([self.dims[d] for d in dims])\n5506 \n5507         if thresh is not None:\n5508             mask = count >= thresh\n5509         elif how == \"any\":\n5510             mask = count == size\n5511         elif how == \"all\":\n5512             mask = count > 0\n5513         elif how is not None:\n5514             raise ValueError(f\"invalid how option: {how}\")\n5515         else:\n5516             raise TypeError(\"must specify how or thresh\")\n5517 \n5518         return self.isel({dim: mask})\n5519 \n5520     def fillna(self: T_Dataset, value: Any) -> T_Dataset:\n5521         \"\"\"Fill missing values in this object.\n5522 \n5523         This operation follows the normal broadcasting and alignment rules that\n5524         xarray uses for binary arithmetic, except the result is aligned to this\n5525         object (``join='left'``) instead of aligned to the intersection of\n5526         index coordinates (``join='inner'``).\n5527 \n5528         Parameters\n5529         ----------\n5530         value : scalar, ndarray, DataArray, dict or Dataset\n5531             Used to fill all matching missing values in this dataset's data\n5532             variables. Scalars, ndarrays or DataArrays arguments are used to\n5533             fill all data with aligned coordinates (for DataArrays).\n5534             Dictionaries or datasets match data variables and then align\n5535             coordinates if necessary.\n5536 \n5537         Returns\n5538         -------\n5539         Dataset\n5540 \n5541         Examples\n5542         --------\n5543         >>> ds = xr.Dataset(\n5544         ...     {\n5545         ...         \"A\": (\"x\", [np.nan, 2, np.nan, 0]),\n5546         ...         \"B\": (\"x\", [3, 4, np.nan, 1]),\n5547         ...         \"C\": (\"x\", [np.nan, np.nan, np.nan, 5]),\n5548         ...         \"D\": (\"x\", [np.nan, 3, np.nan, 4]),\n5549         ...     },\n5550         ...     coords={\"x\": [0, 1, 2, 3]},\n5551         ... )\n5552         >>> ds\n5553         <xarray.Dataset>\n5554         Dimensions:  (x: 4)\n5555         Coordinates:\n5556           * x        (x) int64 0 1 2 3\n5557         Data variables:\n5558             A        (x) float64 nan 2.0 nan 0.0\n5559             B        (x) float64 3.0 4.0 nan 1.0\n5560             C        (x) float64 nan nan nan 5.0\n5561             D        (x) float64 nan 3.0 nan 4.0\n5562 \n5563         Replace all `NaN` values with 0s.\n5564 \n5565         >>> ds.fillna(0)\n5566         <xarray.Dataset>\n5567         Dimensions:  (x: 4)\n5568         Coordinates:\n5569           * x        (x) int64 0 1 2 3\n5570         Data variables:\n5571             A        (x) float64 0.0 2.0 0.0 0.0\n5572             B        (x) float64 3.0 4.0 0.0 1.0\n5573             C        (x) float64 0.0 0.0 0.0 5.0\n5574             D        (x) float64 0.0 3.0 0.0 4.0\n5575 \n5576         Replace all `NaN` elements in column \u2018A\u2019, \u2018B\u2019, \u2018C\u2019, and \u2018D\u2019, with 0, 1, 2, and 3 respectively.\n5577 \n5578         >>> values = {\"A\": 0, \"B\": 1, \"C\": 2, \"D\": 3}\n5579         >>> ds.fillna(value=values)\n5580         <xarray.Dataset>\n5581         Dimensions:  (x: 4)\n5582         Coordinates:\n5583           * x        (x) int64 0 1 2 3\n5584         Data variables:\n5585             A        (x) float64 0.0 2.0 0.0 0.0\n5586             B        (x) float64 3.0 4.0 1.0 1.0\n5587             C        (x) float64 2.0 2.0 2.0 5.0\n5588             D        (x) float64 3.0 3.0 3.0 4.0\n5589         \"\"\"\n5590         if utils.is_dict_like(value):\n5591             value_keys = getattr(value, \"data_vars\", value).keys()\n5592             if not set(value_keys) <= set(self.data_vars.keys()):\n5593                 raise ValueError(\n5594                     \"all variables in the argument to `fillna` \"\n5595                     \"must be contained in the original dataset\"\n5596                 )\n5597         out = ops.fillna(self, value)\n5598         return out\n5599 \n5600     def interpolate_na(\n5601         self: T_Dataset,\n5602         dim: Hashable | None = None,\n5603         method: InterpOptions = \"linear\",\n5604         limit: int | None = None,\n5605         use_coordinate: bool | Hashable = True,\n5606         max_gap: (\n5607             int | float | str | pd.Timedelta | np.timedelta64 | datetime.timedelta\n5608         ) = None,\n5609         **kwargs: Any,\n5610     ) -> T_Dataset:\n5611         \"\"\"Fill in NaNs by interpolating according to different methods.\n5612 \n5613         Parameters\n5614         ----------\n5615         dim : Hashable or None, optional\n5616             Specifies the dimension along which to interpolate.\n5617         method : {\"linear\", \"nearest\", \"zero\", \"slinear\", \"quadratic\", \"cubic\", \"polynomial\", \\\n5618             \"barycentric\", \"krog\", \"pchip\", \"spline\", \"akima\"}, default: \"linear\"\n5619             String indicating which method to use for interpolation:\n5620 \n5621             - 'linear': linear interpolation. Additional keyword\n5622               arguments are passed to :py:func:`numpy.interp`\n5623             - 'nearest', 'zero', 'slinear', 'quadratic', 'cubic', 'polynomial':\n5624               are passed to :py:func:`scipy.interpolate.interp1d`. If\n5625               ``method='polynomial'``, the ``order`` keyword argument must also be\n5626               provided.\n5627             - 'barycentric', 'krog', 'pchip', 'spline', 'akima': use their\n5628               respective :py:class:`scipy.interpolate` classes.\n5629 \n5630         use_coordinate : bool or Hashable, default: True\n5631             Specifies which index to use as the x values in the interpolation\n5632             formulated as `y = f(x)`. If False, values are treated as if\n5633             eqaully-spaced along ``dim``. If True, the IndexVariable `dim` is\n5634             used. If ``use_coordinate`` is a string, it specifies the name of a\n5635             coordinate variariable to use as the index.\n5636         limit : int, default: None\n5637             Maximum number of consecutive NaNs to fill. Must be greater than 0\n5638             or None for no limit. This filling is done regardless of the size of\n5639             the gap in the data. To only interpolate over gaps less than a given length,\n5640             see ``max_gap``.\n5641         max_gap : int, float, str, pandas.Timedelta, numpy.timedelta64, datetime.timedelta, default: None\n5642             Maximum size of gap, a continuous sequence of NaNs, that will be filled.\n5643             Use None for no limit. When interpolating along a datetime64 dimension\n5644             and ``use_coordinate=True``, ``max_gap`` can be one of the following:\n5645 \n5646             - a string that is valid input for pandas.to_timedelta\n5647             - a :py:class:`numpy.timedelta64` object\n5648             - a :py:class:`pandas.Timedelta` object\n5649             - a :py:class:`datetime.timedelta` object\n5650 \n5651             Otherwise, ``max_gap`` must be an int or a float. Use of ``max_gap`` with unlabeled\n5652             dimensions has not been implemented yet. Gap length is defined as the difference\n5653             between coordinate values at the first data point after a gap and the last value\n5654             before a gap. For gaps at the beginning (end), gap length is defined as the difference\n5655             between coordinate values at the first (last) valid data point and the first (last) NaN.\n5656             For example, consider::\n5657 \n5658                 <xarray.DataArray (x: 9)>\n5659                 array([nan, nan, nan,  1., nan, nan,  4., nan, nan])\n5660                 Coordinates:\n5661                   * x        (x) int64 0 1 2 3 4 5 6 7 8\n5662 \n5663             The gap lengths are 3-0 = 3; 6-3 = 3; and 8-6 = 2 respectively\n5664         **kwargs : dict, optional\n5665             parameters passed verbatim to the underlying interpolation function\n5666 \n5667         Returns\n5668         -------\n5669         interpolated: Dataset\n5670             Filled in Dataset.\n5671 \n5672         See Also\n5673         --------\n5674         numpy.interp\n5675         scipy.interpolate\n5676 \n5677         Examples\n5678         --------\n5679         >>> ds = xr.Dataset(\n5680         ...     {\n5681         ...         \"A\": (\"x\", [np.nan, 2, 3, np.nan, 0]),\n5682         ...         \"B\": (\"x\", [3, 4, np.nan, 1, 7]),\n5683         ...         \"C\": (\"x\", [np.nan, np.nan, np.nan, 5, 0]),\n5684         ...         \"D\": (\"x\", [np.nan, 3, np.nan, -1, 4]),\n5685         ...     },\n5686         ...     coords={\"x\": [0, 1, 2, 3, 4]},\n5687         ... )\n5688         >>> ds\n5689         <xarray.Dataset>\n5690         Dimensions:  (x: 5)\n5691         Coordinates:\n5692           * x        (x) int64 0 1 2 3 4\n5693         Data variables:\n5694             A        (x) float64 nan 2.0 3.0 nan 0.0\n5695             B        (x) float64 3.0 4.0 nan 1.0 7.0\n5696             C        (x) float64 nan nan nan 5.0 0.0\n5697             D        (x) float64 nan 3.0 nan -1.0 4.0\n5698 \n5699         >>> ds.interpolate_na(dim=\"x\", method=\"linear\")\n5700         <xarray.Dataset>\n5701         Dimensions:  (x: 5)\n5702         Coordinates:\n5703           * x        (x) int64 0 1 2 3 4\n5704         Data variables:\n5705             A        (x) float64 nan 2.0 3.0 1.5 0.0\n5706             B        (x) float64 3.0 4.0 2.5 1.0 7.0\n5707             C        (x) float64 nan nan nan 5.0 0.0\n5708             D        (x) float64 nan 3.0 1.0 -1.0 4.0\n5709 \n5710         >>> ds.interpolate_na(dim=\"x\", method=\"linear\", fill_value=\"extrapolate\")\n5711         <xarray.Dataset>\n5712         Dimensions:  (x: 5)\n5713         Coordinates:\n5714           * x        (x) int64 0 1 2 3 4\n5715         Data variables:\n5716             A        (x) float64 1.0 2.0 3.0 1.5 0.0\n5717             B        (x) float64 3.0 4.0 2.5 1.0 7.0\n5718             C        (x) float64 20.0 15.0 10.0 5.0 0.0\n5719             D        (x) float64 5.0 3.0 1.0 -1.0 4.0\n5720         \"\"\"\n5721         from xarray.core.missing import _apply_over_vars_with_dim, interp_na\n5722 \n5723         new = _apply_over_vars_with_dim(\n5724             interp_na,\n5725             self,\n5726             dim=dim,\n5727             method=method,\n5728             limit=limit,\n5729             use_coordinate=use_coordinate,\n5730             max_gap=max_gap,\n5731             **kwargs,\n5732         )\n5733         return new\n5734 \n5735     def ffill(self: T_Dataset, dim: Hashable, limit: int | None = None) -> T_Dataset:\n5736         \"\"\"Fill NaN values by propagating values forward\n5737 \n5738         *Requires bottleneck.*\n5739 \n5740         Parameters\n5741         ----------\n5742         dim : Hashable\n5743             Specifies the dimension along which to propagate values when\n5744             filling.\n5745         limit : int or None, optional\n5746             The maximum number of consecutive NaN values to forward fill. In\n5747             other words, if there is a gap with more than this number of\n5748             consecutive NaNs, it will only be partially filled. Must be greater\n5749             than 0 or None for no limit. Must be None or greater than or equal\n5750             to axis length if filling along chunked axes (dimensions).\n5751 \n5752         Returns\n5753         -------\n5754         Dataset\n5755         \"\"\"\n5756         from xarray.core.missing import _apply_over_vars_with_dim, ffill\n5757 \n5758         new = _apply_over_vars_with_dim(ffill, self, dim=dim, limit=limit)\n5759         return new\n5760 \n5761     def bfill(self: T_Dataset, dim: Hashable, limit: int | None = None) -> T_Dataset:\n5762         \"\"\"Fill NaN values by propagating values backward\n5763 \n5764         *Requires bottleneck.*\n5765 \n5766         Parameters\n5767         ----------\n5768         dim : Hashable\n5769             Specifies the dimension along which to propagate values when\n5770             filling.\n5771         limit : int or None, optional\n5772             The maximum number of consecutive NaN values to backward fill. In\n5773             other words, if there is a gap with more than this number of\n5774             consecutive NaNs, it will only be partially filled. Must be greater\n5775             than 0 or None for no limit. Must be None or greater than or equal\n5776             to axis length if filling along chunked axes (dimensions).\n5777 \n5778         Returns\n5779         -------\n5780         Dataset\n5781         \"\"\"\n5782         from xarray.core.missing import _apply_over_vars_with_dim, bfill\n5783 \n5784         new = _apply_over_vars_with_dim(bfill, self, dim=dim, limit=limit)\n5785         return new\n5786 \n5787     def combine_first(self: T_Dataset, other: T_Dataset) -> T_Dataset:\n5788         \"\"\"Combine two Datasets, default to data_vars of self.\n5789 \n5790         The new coordinates follow the normal broadcasting and alignment rules\n5791         of ``join='outer'``.  Vacant cells in the expanded coordinates are\n5792         filled with np.nan.\n5793 \n5794         Parameters\n5795         ----------\n5796         other : Dataset\n5797             Used to fill all matching missing values in this array.\n5798 \n5799         Returns\n5800         -------\n5801         Dataset\n5802         \"\"\"\n5803         out = ops.fillna(self, other, join=\"outer\", dataset_join=\"outer\")\n5804         return out\n5805 \n5806     def reduce(\n5807         self: T_Dataset,\n5808         func: Callable,\n5809         dim: Dims = None,\n5810         *,\n5811         keep_attrs: bool | None = None,\n5812         keepdims: bool = False,\n5813         numeric_only: bool = False,\n5814         **kwargs: Any,\n5815     ) -> T_Dataset:\n5816         \"\"\"Reduce this dataset by applying `func` along some dimension(s).\n5817 \n5818         Parameters\n5819         ----------\n5820         func : callable\n5821             Function which can be called in the form\n5822             `f(x, axis=axis, **kwargs)` to return the result of reducing an\n5823             np.ndarray over an integer valued axis.\n5824         dim : str, Iterable of Hashable or None, optional\n5825             Dimension(s) over which to apply `func`. By default `func` is\n5826             applied over all dimensions.\n5827         keep_attrs : bool or None, optional\n5828             If True, the dataset's attributes (`attrs`) will be copied from\n5829             the original object to the new one.  If False (default), the new\n5830             object will be returned without attributes.\n5831         keepdims : bool, default: False\n5832             If True, the dimensions which are reduced are left in the result\n5833             as dimensions of size one. Coordinates that use these dimensions\n5834             are removed.\n5835         numeric_only : bool, default: False\n5836             If True, only apply ``func`` to variables with a numeric dtype.\n5837         **kwargs : Any\n5838             Additional keyword arguments passed on to ``func``.\n5839 \n5840         Returns\n5841         -------\n5842         reduced : Dataset\n5843             Dataset with this object's DataArrays replaced with new DataArrays\n5844             of summarized data and the indicated dimension(s) removed.\n5845         \"\"\"\n5846         if kwargs.get(\"axis\", None) is not None:\n5847             raise ValueError(\n5848                 \"passing 'axis' to Dataset reduce methods is ambiguous.\"\n5849                 \" Please use 'dim' instead.\"\n5850             )\n5851 \n5852         if dim is None or dim is ...:\n5853             dims = set(self.dims)\n5854         elif isinstance(dim, str) or not isinstance(dim, Iterable):\n5855             dims = {dim}\n5856         else:\n5857             dims = set(dim)\n5858 \n5859         missing_dimensions = [d for d in dims if d not in self.dims]\n5860         if missing_dimensions:\n5861             raise ValueError(\n5862                 f\"Dataset does not contain the dimensions: {missing_dimensions}\"\n5863             )\n5864 \n5865         if keep_attrs is None:\n5866             keep_attrs = _get_keep_attrs(default=False)\n5867 \n5868         variables: dict[Hashable, Variable] = {}\n5869         for name, var in self._variables.items():\n5870             reduce_dims = [d for d in var.dims if d in dims]\n5871             if name in self.coords:\n5872                 if not reduce_dims:\n5873                     variables[name] = var\n5874             else:\n5875                 if (\n5876                     # Some reduction functions (e.g. std, var) need to run on variables\n5877                     # that don't have the reduce dims: PR5393\n5878                     not reduce_dims\n5879                     or not numeric_only\n5880                     or np.issubdtype(var.dtype, np.number)\n5881                     or (var.dtype == np.bool_)\n5882                 ):\n5883                     # prefer to aggregate over axis=None rather than\n5884                     # axis=(0, 1) if they will be equivalent, because\n5885                     # the former is often more efficient\n5886                     # keep single-element dims as list, to support Hashables\n5887                     reduce_maybe_single = (\n5888                         None\n5889                         if len(reduce_dims) == var.ndim and var.ndim != 1\n5890                         else reduce_dims\n5891                     )\n5892                     variables[name] = var.reduce(\n5893                         func,\n5894                         dim=reduce_maybe_single,\n5895                         keep_attrs=keep_attrs,\n5896                         keepdims=keepdims,\n5897                         **kwargs,\n5898                     )\n5899 \n5900         coord_names = {k for k in self.coords if k in variables}\n5901         indexes = {k: v for k, v in self._indexes.items() if k in variables}\n5902         attrs = self.attrs if keep_attrs else None\n5903         return self._replace_with_new_dims(\n5904             variables, coord_names=coord_names, attrs=attrs, indexes=indexes\n5905         )\n5906 \n5907     def map(\n5908         self: T_Dataset,\n5909         func: Callable,\n5910         keep_attrs: bool | None = None,\n5911         args: Iterable[Any] = (),\n5912         **kwargs: Any,\n5913     ) -> T_Dataset:\n5914         \"\"\"Apply a function to each data variable in this dataset\n5915 \n5916         Parameters\n5917         ----------\n5918         func : callable\n5919             Function which can be called in the form `func(x, *args, **kwargs)`\n5920             to transform each DataArray `x` in this dataset into another\n5921             DataArray.\n5922         keep_attrs : bool or None, optional\n5923             If True, both the dataset's and variables' attributes (`attrs`) will be\n5924             copied from the original objects to the new ones. If False, the new dataset\n5925             and variables will be returned without copying the attributes.\n5926         args : iterable, optional\n5927             Positional arguments passed on to `func`.\n5928         **kwargs : Any\n5929             Keyword arguments passed on to `func`.\n5930 \n5931         Returns\n5932         -------\n5933         applied : Dataset\n5934             Resulting dataset from applying ``func`` to each data variable.\n5935 \n5936         Examples\n5937         --------\n5938         >>> da = xr.DataArray(np.random.randn(2, 3))\n5939         >>> ds = xr.Dataset({\"foo\": da, \"bar\": (\"x\", [-1, 2])})\n5940         >>> ds\n5941         <xarray.Dataset>\n5942         Dimensions:  (dim_0: 2, dim_1: 3, x: 2)\n5943         Dimensions without coordinates: dim_0, dim_1, x\n5944         Data variables:\n5945             foo      (dim_0, dim_1) float64 1.764 0.4002 0.9787 2.241 1.868 -0.9773\n5946             bar      (x) int64 -1 2\n5947         >>> ds.map(np.fabs)\n5948         <xarray.Dataset>\n5949         Dimensions:  (dim_0: 2, dim_1: 3, x: 2)\n5950         Dimensions without coordinates: dim_0, dim_1, x\n5951         Data variables:\n5952             foo      (dim_0, dim_1) float64 1.764 0.4002 0.9787 2.241 1.868 0.9773\n5953             bar      (x) float64 1.0 2.0\n5954         \"\"\"\n5955         if keep_attrs is None:\n5956             keep_attrs = _get_keep_attrs(default=False)\n5957         variables = {\n5958             k: maybe_wrap_array(v, func(v, *args, **kwargs))\n5959             for k, v in self.data_vars.items()\n5960         }\n5961         if keep_attrs:\n5962             for k, v in variables.items():\n5963                 v._copy_attrs_from(self.data_vars[k])\n5964         attrs = self.attrs if keep_attrs else None\n5965         return type(self)(variables, attrs=attrs)\n5966 \n5967     def apply(\n5968         self: T_Dataset,\n5969         func: Callable,\n5970         keep_attrs: bool | None = None,\n5971         args: Iterable[Any] = (),\n5972         **kwargs: Any,\n5973     ) -> T_Dataset:\n5974         \"\"\"\n5975         Backward compatible implementation of ``map``\n5976 \n5977         See Also\n5978         --------\n5979         Dataset.map\n5980         \"\"\"\n5981         warnings.warn(\n5982             \"Dataset.apply may be deprecated in the future. Using Dataset.map is encouraged\",\n5983             PendingDeprecationWarning,\n5984             stacklevel=2,\n5985         )\n5986         return self.map(func, keep_attrs, args, **kwargs)\n5987 \n5988     def assign(\n5989         self: T_Dataset,\n5990         variables: Mapping[Any, Any] | None = None,\n5991         **variables_kwargs: Any,\n5992     ) -> T_Dataset:\n5993         \"\"\"Assign new data variables to a Dataset, returning a new object\n5994         with all the original variables in addition to the new ones.\n5995 \n5996         Parameters\n5997         ----------\n5998         variables : mapping of hashable to Any\n5999             Mapping from variables names to the new values. If the new values\n6000             are callable, they are computed on the Dataset and assigned to new\n6001             data variables. If the values are not callable, (e.g. a DataArray,\n6002             scalar, or array), they are simply assigned.\n6003         **variables_kwargs\n6004             The keyword arguments form of ``variables``.\n6005             One of variables or variables_kwargs must be provided.\n6006 \n6007         Returns\n6008         -------\n6009         ds : Dataset\n6010             A new Dataset with the new variables in addition to all the\n6011             existing variables.\n6012 \n6013         Notes\n6014         -----\n6015         Since ``kwargs`` is a dictionary, the order of your arguments may not\n6016         be preserved, and so the order of the new variables is not well\n6017         defined. Assigning multiple variables within the same ``assign`` is\n6018         possible, but you cannot reference other variables created within the\n6019         same ``assign`` call.\n6020 \n6021         See Also\n6022         --------\n6023         pandas.DataFrame.assign\n6024 \n6025         Examples\n6026         --------\n6027         >>> x = xr.Dataset(\n6028         ...     {\n6029         ...         \"temperature_c\": (\n6030         ...             (\"lat\", \"lon\"),\n6031         ...             20 * np.random.rand(4).reshape(2, 2),\n6032         ...         ),\n6033         ...         \"precipitation\": ((\"lat\", \"lon\"), np.random.rand(4).reshape(2, 2)),\n6034         ...     },\n6035         ...     coords={\"lat\": [10, 20], \"lon\": [150, 160]},\n6036         ... )\n6037         >>> x\n6038         <xarray.Dataset>\n6039         Dimensions:        (lat: 2, lon: 2)\n6040         Coordinates:\n6041           * lat            (lat) int64 10 20\n6042           * lon            (lon) int64 150 160\n6043         Data variables:\n6044             temperature_c  (lat, lon) float64 10.98 14.3 12.06 10.9\n6045             precipitation  (lat, lon) float64 0.4237 0.6459 0.4376 0.8918\n6046 \n6047         Where the value is a callable, evaluated on dataset:\n6048 \n6049         >>> x.assign(temperature_f=lambda x: x.temperature_c * 9 / 5 + 32)\n6050         <xarray.Dataset>\n6051         Dimensions:        (lat: 2, lon: 2)\n6052         Coordinates:\n6053           * lat            (lat) int64 10 20\n6054           * lon            (lon) int64 150 160\n6055         Data variables:\n6056             temperature_c  (lat, lon) float64 10.98 14.3 12.06 10.9\n6057             precipitation  (lat, lon) float64 0.4237 0.6459 0.4376 0.8918\n6058             temperature_f  (lat, lon) float64 51.76 57.75 53.7 51.62\n6059 \n6060         Alternatively, the same behavior can be achieved by directly referencing an existing dataarray:\n6061 \n6062         >>> x.assign(temperature_f=x[\"temperature_c\"] * 9 / 5 + 32)\n6063         <xarray.Dataset>\n6064         Dimensions:        (lat: 2, lon: 2)\n6065         Coordinates:\n6066           * lat            (lat) int64 10 20\n6067           * lon            (lon) int64 150 160\n6068         Data variables:\n6069             temperature_c  (lat, lon) float64 10.98 14.3 12.06 10.9\n6070             precipitation  (lat, lon) float64 0.4237 0.6459 0.4376 0.8918\n6071             temperature_f  (lat, lon) float64 51.76 57.75 53.7 51.62\n6072 \n6073         \"\"\"\n6074         variables = either_dict_or_kwargs(variables, variables_kwargs, \"assign\")\n6075         data = self.copy()\n6076         # do all calculations first...\n6077         results: CoercibleMapping = data._calc_assign_results(variables)\n6078         data.coords._maybe_drop_multiindex_coords(set(results.keys()))\n6079         # ... and then assign\n6080         data.update(results)\n6081         return data\n6082 \n6083     def to_array(\n6084         self, dim: Hashable = \"variable\", name: Hashable | None = None\n6085     ) -> DataArray:\n6086         \"\"\"Convert this dataset into an xarray.DataArray\n6087 \n6088         The data variables of this dataset will be broadcast against each other\n6089         and stacked along the first axis of the new array. All coordinates of\n6090         this dataset will remain coordinates.\n6091 \n6092         Parameters\n6093         ----------\n6094         dim : Hashable, default: \"variable\"\n6095             Name of the new dimension.\n6096         name : Hashable or None, optional\n6097             Name of the new data array.\n6098 \n6099         Returns\n6100         -------\n6101         array : xarray.DataArray\n6102         \"\"\"\n6103         from xarray.core.dataarray import DataArray\n6104 \n6105         data_vars = [self.variables[k] for k in self.data_vars]\n6106         broadcast_vars = broadcast_variables(*data_vars)\n6107         data = duck_array_ops.stack([b.data for b in broadcast_vars], axis=0)\n6108 \n6109         dims = (dim,) + broadcast_vars[0].dims\n6110         variable = Variable(dims, data, self.attrs, fastpath=True)\n6111 \n6112         coords = {k: v.variable for k, v in self.coords.items()}\n6113         indexes = filter_indexes_from_coords(self._indexes, set(coords))\n6114         new_dim_index = PandasIndex(list(self.data_vars), dim)\n6115         indexes[dim] = new_dim_index\n6116         coords.update(new_dim_index.create_variables())\n6117 \n6118         return DataArray._construct_direct(variable, coords, name, indexes)\n6119 \n6120     def _normalize_dim_order(\n6121         self, dim_order: Sequence[Hashable] | None = None\n6122     ) -> dict[Hashable, int]:\n6123         \"\"\"\n6124         Check the validity of the provided dimensions if any and return the mapping\n6125         between dimension name and their size.\n6126 \n6127         Parameters\n6128         ----------\n6129         dim_order: Sequence of Hashable or None, optional\n6130             Dimension order to validate (default to the alphabetical order if None).\n6131 \n6132         Returns\n6133         -------\n6134         result : dict[Hashable, int]\n6135             Validated dimensions mapping.\n6136 \n6137         \"\"\"\n6138         if dim_order is None:\n6139             dim_order = list(self.dims)\n6140         elif set(dim_order) != set(self.dims):\n6141             raise ValueError(\n6142                 \"dim_order {} does not match the set of dimensions of this \"\n6143                 \"Dataset: {}\".format(dim_order, list(self.dims))\n6144             )\n6145 \n6146         ordered_dims = {k: self.dims[k] for k in dim_order}\n6147 \n6148         return ordered_dims\n6149 \n6150     def to_pandas(self) -> pd.Series | pd.DataFrame:\n6151         \"\"\"Convert this dataset into a pandas object without changing the number of dimensions.\n6152 \n6153         The type of the returned object depends on the number of Dataset\n6154         dimensions:\n6155 \n6156         * 0D -> `pandas.Series`\n6157         * 1D -> `pandas.DataFrame`\n6158 \n6159         Only works for Datasets with 1 or fewer dimensions.\n6160         \"\"\"\n6161         if len(self.dims) == 0:\n6162             return pd.Series({k: v.item() for k, v in self.items()})\n6163         if len(self.dims) == 1:\n6164             return self.to_dataframe()\n6165         raise ValueError(\n6166             \"cannot convert Datasets with %s dimensions into \"\n6167             \"pandas objects without changing the number of dimensions. \"\n6168             \"Please use Dataset.to_dataframe() instead.\" % len(self.dims)\n6169         )\n6170 \n6171     def _to_dataframe(self, ordered_dims: Mapping[Any, int]):\n6172         columns = [k for k in self.variables if k not in self.dims]\n6173         data = [\n6174             self._variables[k].set_dims(ordered_dims).values.reshape(-1)\n6175             for k in columns\n6176         ]\n6177         index = self.coords.to_index([*ordered_dims])\n6178         return pd.DataFrame(dict(zip(columns, data)), index=index)\n6179 \n6180     def to_dataframe(self, dim_order: Sequence[Hashable] | None = None) -> pd.DataFrame:\n6181         \"\"\"Convert this dataset into a pandas.DataFrame.\n6182 \n6183         Non-index variables in this dataset form the columns of the\n6184         DataFrame. The DataFrame is indexed by the Cartesian product of\n6185         this dataset's indices.\n6186 \n6187         Parameters\n6188         ----------\n6189         dim_order: Sequence of Hashable or None, optional\n6190             Hierarchical dimension order for the resulting dataframe. All\n6191             arrays are transposed to this order and then written out as flat\n6192             vectors in contiguous order, so the last dimension in this list\n6193             will be contiguous in the resulting DataFrame. This has a major\n6194             influence on which operations are efficient on the resulting\n6195             dataframe.\n6196 \n6197             If provided, must include all dimensions of this dataset. By\n6198             default, dimensions are sorted alphabetically.\n6199 \n6200         Returns\n6201         -------\n6202         result : DataFrame\n6203             Dataset as a pandas DataFrame.\n6204 \n6205         \"\"\"\n6206 \n6207         ordered_dims = self._normalize_dim_order(dim_order=dim_order)\n6208 \n6209         return self._to_dataframe(ordered_dims=ordered_dims)\n6210 \n6211     def _set_sparse_data_from_dataframe(\n6212         self, idx: pd.Index, arrays: list[tuple[Hashable, np.ndarray]], dims: tuple\n6213     ) -> None:\n6214         from sparse import COO\n6215 \n6216         if isinstance(idx, pd.MultiIndex):\n6217             coords = np.stack([np.asarray(code) for code in idx.codes], axis=0)\n6218             is_sorted = idx.is_monotonic_increasing\n6219             shape = tuple(lev.size for lev in idx.levels)\n6220         else:\n6221             coords = np.arange(idx.size).reshape(1, -1)\n6222             is_sorted = True\n6223             shape = (idx.size,)\n6224 \n6225         for name, values in arrays:\n6226             # In virtually all real use cases, the sparse array will now have\n6227             # missing values and needs a fill_value. For consistency, don't\n6228             # special case the rare exceptions (e.g., dtype=int without a\n6229             # MultiIndex).\n6230             dtype, fill_value = xrdtypes.maybe_promote(values.dtype)\n6231             values = np.asarray(values, dtype=dtype)\n6232 \n6233             data = COO(\n6234                 coords,\n6235                 values,\n6236                 shape,\n6237                 has_duplicates=False,\n6238                 sorted=is_sorted,\n6239                 fill_value=fill_value,\n6240             )\n6241             self[name] = (dims, data)\n6242 \n6243     def _set_numpy_data_from_dataframe(\n6244         self, idx: pd.Index, arrays: list[tuple[Hashable, np.ndarray]], dims: tuple\n6245     ) -> None:\n6246         if not isinstance(idx, pd.MultiIndex):\n6247             for name, values in arrays:\n6248                 self[name] = (dims, values)\n6249             return\n6250 \n6251         # NB: similar, more general logic, now exists in\n6252         # variable.unstack_once; we could consider combining them at some\n6253         # point.\n6254 \n6255         shape = tuple(lev.size for lev in idx.levels)\n6256         indexer = tuple(idx.codes)\n6257 \n6258         # We already verified that the MultiIndex has all unique values, so\n6259         # there are missing values if and only if the size of output arrays is\n6260         # larger that the index.\n6261         missing_values = math.prod(shape) > idx.shape[0]\n6262 \n6263         for name, values in arrays:\n6264             # NumPy indexing is much faster than using DataFrame.reindex() to\n6265             # fill in missing values:\n6266             # https://stackoverflow.com/a/35049899/809705\n6267             if missing_values:\n6268                 dtype, fill_value = xrdtypes.maybe_promote(values.dtype)\n6269                 data = np.full(shape, fill_value, dtype)\n6270             else:\n6271                 # If there are no missing values, keep the existing dtype\n6272                 # instead of promoting to support NA, e.g., keep integer\n6273                 # columns as integers.\n6274                 # TODO: consider removing this special case, which doesn't\n6275                 # exist for sparse=True.\n6276                 data = np.zeros(shape, values.dtype)\n6277             data[indexer] = values\n6278             self[name] = (dims, data)\n6279 \n6280     @classmethod\n6281     def from_dataframe(\n6282         cls: type[T_Dataset], dataframe: pd.DataFrame, sparse: bool = False\n6283     ) -> T_Dataset:\n6284         \"\"\"Convert a pandas.DataFrame into an xarray.Dataset\n6285 \n6286         Each column will be converted into an independent variable in the\n6287         Dataset. If the dataframe's index is a MultiIndex, it will be expanded\n6288         into a tensor product of one-dimensional indices (filling in missing\n6289         values with NaN). This method will produce a Dataset very similar to\n6290         that on which the 'to_dataframe' method was called, except with\n6291         possibly redundant dimensions (since all dataset variables will have\n6292         the same dimensionality)\n6293 \n6294         Parameters\n6295         ----------\n6296         dataframe : DataFrame\n6297             DataFrame from which to copy data and indices.\n6298         sparse : bool, default: False\n6299             If true, create a sparse arrays instead of dense numpy arrays. This\n6300             can potentially save a large amount of memory if the DataFrame has\n6301             a MultiIndex. Requires the sparse package (sparse.pydata.org).\n6302 \n6303         Returns\n6304         -------\n6305         New Dataset.\n6306 \n6307         See Also\n6308         --------\n6309         xarray.DataArray.from_series\n6310         pandas.DataFrame.to_xarray\n6311         \"\"\"\n6312         # TODO: Add an option to remove dimensions along which the variables\n6313         # are constant, to enable consistent serialization to/from a dataframe,\n6314         # even if some variables have different dimensionality.\n6315 \n6316         if not dataframe.columns.is_unique:\n6317             raise ValueError(\"cannot convert DataFrame with non-unique columns\")\n6318 \n6319         idx = remove_unused_levels_categories(dataframe.index)\n6320 \n6321         if isinstance(idx, pd.MultiIndex) and not idx.is_unique:\n6322             raise ValueError(\n6323                 \"cannot convert a DataFrame with a non-unique MultiIndex into xarray\"\n6324             )\n6325 \n6326         # Cast to a NumPy array first, in case the Series is a pandas Extension\n6327         # array (which doesn't have a valid NumPy dtype)\n6328         # TODO: allow users to control how this casting happens, e.g., by\n6329         # forwarding arguments to pandas.Series.to_numpy?\n6330         arrays = [(k, np.asarray(v)) for k, v in dataframe.items()]\n6331 \n6332         indexes: dict[Hashable, Index] = {}\n6333         index_vars: dict[Hashable, Variable] = {}\n6334 \n6335         if isinstance(idx, pd.MultiIndex):\n6336             dims = tuple(\n6337                 name if name is not None else \"level_%i\" % n\n6338                 for n, name in enumerate(idx.names)\n6339             )\n6340             for dim, lev in zip(dims, idx.levels):\n6341                 xr_idx = PandasIndex(lev, dim)\n6342                 indexes[dim] = xr_idx\n6343                 index_vars.update(xr_idx.create_variables())\n6344         else:\n6345             index_name = idx.name if idx.name is not None else \"index\"\n6346             dims = (index_name,)\n6347             xr_idx = PandasIndex(idx, index_name)\n6348             indexes[index_name] = xr_idx\n6349             index_vars.update(xr_idx.create_variables())\n6350 \n6351         obj = cls._construct_direct(index_vars, set(index_vars), indexes=indexes)\n6352 \n6353         if sparse:\n6354             obj._set_sparse_data_from_dataframe(idx, arrays, dims)\n6355         else:\n6356             obj._set_numpy_data_from_dataframe(idx, arrays, dims)\n6357         return obj\n6358 \n6359     def to_dask_dataframe(\n6360         self, dim_order: Sequence[Hashable] | None = None, set_index: bool = False\n6361     ) -> DaskDataFrame:\n6362         \"\"\"\n6363         Convert this dataset into a dask.dataframe.DataFrame.\n6364 \n6365         The dimensions, coordinates and data variables in this dataset form\n6366         the columns of the DataFrame.\n6367 \n6368         Parameters\n6369         ----------\n6370         dim_order : list, optional\n6371             Hierarchical dimension order for the resulting dataframe. All\n6372             arrays are transposed to this order and then written out as flat\n6373             vectors in contiguous order, so the last dimension in this list\n6374             will be contiguous in the resulting DataFrame. This has a major\n6375             influence on which operations are efficient on the resulting dask\n6376             dataframe.\n6377 \n6378             If provided, must include all dimensions of this dataset. By\n6379             default, dimensions are sorted alphabetically.\n6380         set_index : bool, default: False\n6381             If set_index=True, the dask DataFrame is indexed by this dataset's\n6382             coordinate. Since dask DataFrames do not support multi-indexes,\n6383             set_index only works if the dataset only contains one dimension.\n6384 \n6385         Returns\n6386         -------\n6387         dask.dataframe.DataFrame\n6388         \"\"\"\n6389 \n6390         import dask.array as da\n6391         import dask.dataframe as dd\n6392 \n6393         ordered_dims = self._normalize_dim_order(dim_order=dim_order)\n6394 \n6395         columns = list(ordered_dims)\n6396         columns.extend(k for k in self.coords if k not in self.dims)\n6397         columns.extend(self.data_vars)\n6398 \n6399         series_list = []\n6400         for name in columns:\n6401             try:\n6402                 var = self.variables[name]\n6403             except KeyError:\n6404                 # dimension without a matching coordinate\n6405                 size = self.dims[name]\n6406                 data = da.arange(size, chunks=size, dtype=np.int64)\n6407                 var = Variable((name,), data)\n6408 \n6409             # IndexVariable objects have a dummy .chunk() method\n6410             if isinstance(var, IndexVariable):\n6411                 var = var.to_base_variable()\n6412 \n6413             dask_array = var.set_dims(ordered_dims).chunk(self.chunks).data\n6414             series = dd.from_array(dask_array.reshape(-1), columns=[name])\n6415             series_list.append(series)\n6416 \n6417         df = dd.concat(series_list, axis=1)\n6418 \n6419         if set_index:\n6420             dim_order = [*ordered_dims]\n6421 \n6422             if len(dim_order) == 1:\n6423                 (dim,) = dim_order\n6424                 df = df.set_index(dim)\n6425             else:\n6426                 # triggers an error about multi-indexes, even if only one\n6427                 # dimension is passed\n6428                 df = df.set_index(dim_order)\n6429 \n6430         return df\n6431 \n6432     def to_dict(self, data: bool = True, encoding: bool = False) -> dict[str, Any]:\n6433         \"\"\"\n6434         Convert this dataset to a dictionary following xarray naming\n6435         conventions.\n6436 \n6437         Converts all variables and attributes to native Python objects\n6438         Useful for converting to json. To avoid datetime incompatibility\n6439         use decode_times=False kwarg in xarrray.open_dataset.\n6440 \n6441         Parameters\n6442         ----------\n6443         data : bool, default: True\n6444             Whether to include the actual data in the dictionary. When set to\n6445             False, returns just the schema.\n6446         encoding : bool, default: False\n6447             Whether to include the Dataset's encoding in the dictionary.\n6448 \n6449         Returns\n6450         -------\n6451         d : dict\n6452             Dict with keys: \"coords\", \"attrs\", \"dims\", \"data_vars\" and optionally\n6453             \"encoding\".\n6454 \n6455         See Also\n6456         --------\n6457         Dataset.from_dict\n6458         DataArray.to_dict\n6459         \"\"\"\n6460         d: dict = {\n6461             \"coords\": {},\n6462             \"attrs\": decode_numpy_dict_values(self.attrs),\n6463             \"dims\": dict(self.dims),\n6464             \"data_vars\": {},\n6465         }\n6466         for k in self.coords:\n6467             d[\"coords\"].update(\n6468                 {k: self[k].variable.to_dict(data=data, encoding=encoding)}\n6469             )\n6470         for k in self.data_vars:\n6471             d[\"data_vars\"].update(\n6472                 {k: self[k].variable.to_dict(data=data, encoding=encoding)}\n6473             )\n6474         if encoding:\n6475             d[\"encoding\"] = dict(self.encoding)\n6476         return d\n6477 \n6478     @classmethod\n6479     def from_dict(cls: type[T_Dataset], d: Mapping[Any, Any]) -> T_Dataset:\n6480         \"\"\"Convert a dictionary into an xarray.Dataset.\n6481 \n6482         Parameters\n6483         ----------\n6484         d : dict-like\n6485             Mapping with a minimum structure of\n6486                 ``{\"var_0\": {\"dims\": [..], \"data\": [..]}, \\\n6487                             ...}``\n6488 \n6489         Returns\n6490         -------\n6491         obj : Dataset\n6492 \n6493         See also\n6494         --------\n6495         Dataset.to_dict\n6496         DataArray.from_dict\n6497 \n6498         Examples\n6499         --------\n6500         >>> d = {\n6501         ...     \"t\": {\"dims\": (\"t\"), \"data\": [0, 1, 2]},\n6502         ...     \"a\": {\"dims\": (\"t\"), \"data\": [\"a\", \"b\", \"c\"]},\n6503         ...     \"b\": {\"dims\": (\"t\"), \"data\": [10, 20, 30]},\n6504         ... }\n6505         >>> ds = xr.Dataset.from_dict(d)\n6506         >>> ds\n6507         <xarray.Dataset>\n6508         Dimensions:  (t: 3)\n6509         Coordinates:\n6510           * t        (t) int64 0 1 2\n6511         Data variables:\n6512             a        (t) <U1 'a' 'b' 'c'\n6513             b        (t) int64 10 20 30\n6514 \n6515         >>> d = {\n6516         ...     \"coords\": {\n6517         ...         \"t\": {\"dims\": \"t\", \"data\": [0, 1, 2], \"attrs\": {\"units\": \"s\"}}\n6518         ...     },\n6519         ...     \"attrs\": {\"title\": \"air temperature\"},\n6520         ...     \"dims\": \"t\",\n6521         ...     \"data_vars\": {\n6522         ...         \"a\": {\"dims\": \"t\", \"data\": [10, 20, 30]},\n6523         ...         \"b\": {\"dims\": \"t\", \"data\": [\"a\", \"b\", \"c\"]},\n6524         ...     },\n6525         ... }\n6526         >>> ds = xr.Dataset.from_dict(d)\n6527         >>> ds\n6528         <xarray.Dataset>\n6529         Dimensions:  (t: 3)\n6530         Coordinates:\n6531           * t        (t) int64 0 1 2\n6532         Data variables:\n6533             a        (t) int64 10 20 30\n6534             b        (t) <U1 'a' 'b' 'c'\n6535         Attributes:\n6536             title:    air temperature\n6537 \n6538         \"\"\"\n6539 \n6540         variables: Iterable[tuple[Hashable, Any]]\n6541         if not {\"coords\", \"data_vars\"}.issubset(set(d)):\n6542             variables = d.items()\n6543         else:\n6544             import itertools\n6545 \n6546             variables = itertools.chain(\n6547                 d.get(\"coords\", {}).items(), d.get(\"data_vars\", {}).items()\n6548             )\n6549         try:\n6550             variable_dict = {\n6551                 k: (v[\"dims\"], v[\"data\"], v.get(\"attrs\")) for k, v in variables\n6552             }\n6553         except KeyError as e:\n6554             raise ValueError(\n6555                 \"cannot convert dict without the key \"\n6556                 \"'{dims_data}'\".format(dims_data=str(e.args[0]))\n6557             )\n6558         obj = cls(variable_dict)\n6559 \n6560         # what if coords aren't dims?\n6561         coords = set(d.get(\"coords\", {})) - set(d.get(\"dims\", {}))\n6562         obj = obj.set_coords(coords)\n6563 \n6564         obj.attrs.update(d.get(\"attrs\", {}))\n6565         obj.encoding.update(d.get(\"encoding\", {}))\n6566 \n6567         return obj\n6568 \n6569     def _unary_op(self: T_Dataset, f, *args, **kwargs) -> T_Dataset:\n6570         variables = {}\n6571         keep_attrs = kwargs.pop(\"keep_attrs\", None)\n6572         if keep_attrs is None:\n6573             keep_attrs = _get_keep_attrs(default=True)\n6574         for k, v in self._variables.items():\n6575             if k in self._coord_names:\n6576                 variables[k] = v\n6577             else:\n6578                 variables[k] = f(v, *args, **kwargs)\n6579                 if keep_attrs:\n6580                     variables[k].attrs = v._attrs\n6581         attrs = self._attrs if keep_attrs else None\n6582         return self._replace_with_new_dims(variables, attrs=attrs)\n6583 \n6584     def _binary_op(self, other, f, reflexive=False, join=None) -> Dataset:\n6585         from xarray.core.dataarray import DataArray\n6586         from xarray.core.groupby import GroupBy\n6587 \n6588         if isinstance(other, GroupBy):\n6589             return NotImplemented\n6590         align_type = OPTIONS[\"arithmetic_join\"] if join is None else join\n6591         if isinstance(other, (DataArray, Dataset)):\n6592             self, other = align(self, other, join=align_type, copy=False)  # type: ignore[assignment]\n6593         g = f if not reflexive else lambda x, y: f(y, x)\n6594         ds = self._calculate_binary_op(g, other, join=align_type)\n6595         return ds\n6596 \n6597     def _inplace_binary_op(self: T_Dataset, other, f) -> T_Dataset:\n6598         from xarray.core.dataarray import DataArray\n6599         from xarray.core.groupby import GroupBy\n6600 \n6601         if isinstance(other, GroupBy):\n6602             raise TypeError(\n6603                 \"in-place operations between a Dataset and \"\n6604                 \"a grouped object are not permitted\"\n6605             )\n6606         # we don't actually modify arrays in-place with in-place Dataset\n6607         # arithmetic -- this lets us automatically align things\n6608         if isinstance(other, (DataArray, Dataset)):\n6609             other = other.reindex_like(self, copy=False)\n6610         g = ops.inplace_to_noninplace_op(f)\n6611         ds = self._calculate_binary_op(g, other, inplace=True)\n6612         self._replace_with_new_dims(\n6613             ds._variables,\n6614             ds._coord_names,\n6615             attrs=ds._attrs,\n6616             indexes=ds._indexes,\n6617             inplace=True,\n6618         )\n6619         return self\n6620 \n6621     def _calculate_binary_op(\n6622         self, f, other, join=\"inner\", inplace: bool = False\n6623     ) -> Dataset:\n6624         def apply_over_both(lhs_data_vars, rhs_data_vars, lhs_vars, rhs_vars):\n6625             if inplace and set(lhs_data_vars) != set(rhs_data_vars):\n6626                 raise ValueError(\n6627                     \"datasets must have the same data variables \"\n6628                     f\"for in-place arithmetic operations: {list(lhs_data_vars)}, {list(rhs_data_vars)}\"\n6629                 )\n6630 \n6631             dest_vars = {}\n6632 \n6633             for k in lhs_data_vars:\n6634                 if k in rhs_data_vars:\n6635                     dest_vars[k] = f(lhs_vars[k], rhs_vars[k])\n6636                 elif join in [\"left\", \"outer\"]:\n6637                     dest_vars[k] = f(lhs_vars[k], np.nan)\n6638             for k in rhs_data_vars:\n6639                 if k not in dest_vars and join in [\"right\", \"outer\"]:\n6640                     dest_vars[k] = f(rhs_vars[k], np.nan)\n6641             return dest_vars\n6642 \n6643         if utils.is_dict_like(other) and not isinstance(other, Dataset):\n6644             # can't use our shortcut of doing the binary operation with\n6645             # Variable objects, so apply over our data vars instead.\n6646             new_data_vars = apply_over_both(\n6647                 self.data_vars, other, self.data_vars, other\n6648             )\n6649             return type(self)(new_data_vars)\n6650 \n6651         other_coords: Coordinates | None = getattr(other, \"coords\", None)\n6652         ds = self.coords.merge(other_coords)\n6653 \n6654         if isinstance(other, Dataset):\n6655             new_vars = apply_over_both(\n6656                 self.data_vars, other.data_vars, self.variables, other.variables\n6657             )\n6658         else:\n6659             other_variable = getattr(other, \"variable\", other)\n6660             new_vars = {k: f(self.variables[k], other_variable) for k in self.data_vars}\n6661         ds._variables.update(new_vars)\n6662         ds._dims = calculate_dimensions(ds._variables)\n6663         return ds\n6664 \n6665     def _copy_attrs_from(self, other):\n6666         self.attrs = other.attrs\n6667         for v in other.variables:\n6668             if v in self.variables:\n6669                 self.variables[v].attrs = other.variables[v].attrs\n6670 \n6671     def diff(\n6672         self: T_Dataset,\n6673         dim: Hashable,\n6674         n: int = 1,\n6675         label: Literal[\"upper\", \"lower\"] = \"upper\",\n6676     ) -> T_Dataset:\n6677         \"\"\"Calculate the n-th order discrete difference along given axis.\n6678 \n6679         Parameters\n6680         ----------\n6681         dim : Hashable\n6682             Dimension over which to calculate the finite difference.\n6683         n : int, default: 1\n6684             The number of times values are differenced.\n6685         label : {\"upper\", \"lower\"}, default: \"upper\"\n6686             The new coordinate in dimension ``dim`` will have the\n6687             values of either the minuend's or subtrahend's coordinate\n6688             for values 'upper' and 'lower', respectively.\n6689 \n6690         Returns\n6691         -------\n6692         difference : Dataset\n6693             The n-th order finite difference of this object.\n6694 \n6695         Notes\n6696         -----\n6697         `n` matches numpy's behavior and is different from pandas' first argument named\n6698         `periods`.\n6699 \n6700         Examples\n6701         --------\n6702         >>> ds = xr.Dataset({\"foo\": (\"x\", [5, 5, 6, 6])})\n6703         >>> ds.diff(\"x\")\n6704         <xarray.Dataset>\n6705         Dimensions:  (x: 3)\n6706         Dimensions without coordinates: x\n6707         Data variables:\n6708             foo      (x) int64 0 1 0\n6709         >>> ds.diff(\"x\", 2)\n6710         <xarray.Dataset>\n6711         Dimensions:  (x: 2)\n6712         Dimensions without coordinates: x\n6713         Data variables:\n6714             foo      (x) int64 1 -1\n6715 \n6716         See Also\n6717         --------\n6718         Dataset.differentiate\n6719         \"\"\"\n6720         if n == 0:\n6721             return self\n6722         if n < 0:\n6723             raise ValueError(f\"order `n` must be non-negative but got {n}\")\n6724 \n6725         # prepare slices\n6726         slice_start = {dim: slice(None, -1)}\n6727         slice_end = {dim: slice(1, None)}\n6728 \n6729         # prepare new coordinate\n6730         if label == \"upper\":\n6731             slice_new = slice_end\n6732         elif label == \"lower\":\n6733             slice_new = slice_start\n6734         else:\n6735             raise ValueError(\"The 'label' argument has to be either 'upper' or 'lower'\")\n6736 \n6737         indexes, index_vars = isel_indexes(self.xindexes, slice_new)\n6738         variables = {}\n6739 \n6740         for name, var in self.variables.items():\n6741             if name in index_vars:\n6742                 variables[name] = index_vars[name]\n6743             elif dim in var.dims:\n6744                 if name in self.data_vars:\n6745                     variables[name] = var.isel(slice_end) - var.isel(slice_start)\n6746                 else:\n6747                     variables[name] = var.isel(slice_new)\n6748             else:\n6749                 variables[name] = var\n6750 \n6751         difference = self._replace_with_new_dims(variables, indexes=indexes)\n6752 \n6753         if n > 1:\n6754             return difference.diff(dim, n - 1)\n6755         else:\n6756             return difference\n6757 \n6758     def shift(\n6759         self: T_Dataset,\n6760         shifts: Mapping[Any, int] | None = None,\n6761         fill_value: Any = xrdtypes.NA,\n6762         **shifts_kwargs: int,\n6763     ) -> T_Dataset:\n6764 \n6765         \"\"\"Shift this dataset by an offset along one or more dimensions.\n6766 \n6767         Only data variables are moved; coordinates stay in place. This is\n6768         consistent with the behavior of ``shift`` in pandas.\n6769 \n6770         Values shifted from beyond array bounds will appear at one end of\n6771         each dimension, which are filled according to `fill_value`. For periodic\n6772         offsets instead see `roll`.\n6773 \n6774         Parameters\n6775         ----------\n6776         shifts : mapping of hashable to int\n6777             Integer offset to shift along each of the given dimensions.\n6778             Positive offsets shift to the right; negative offsets shift to the\n6779             left.\n6780         fill_value : scalar or dict-like, optional\n6781             Value to use for newly missing values. If a dict-like, maps\n6782             variable names (including coordinates) to fill values.\n6783         **shifts_kwargs\n6784             The keyword arguments form of ``shifts``.\n6785             One of shifts or shifts_kwargs must be provided.\n6786 \n6787         Returns\n6788         -------\n6789         shifted : Dataset\n6790             Dataset with the same coordinates and attributes but shifted data\n6791             variables.\n6792 \n6793         See Also\n6794         --------\n6795         roll\n6796 \n6797         Examples\n6798         --------\n6799         >>> ds = xr.Dataset({\"foo\": (\"x\", list(\"abcde\"))})\n6800         >>> ds.shift(x=2)\n6801         <xarray.Dataset>\n6802         Dimensions:  (x: 5)\n6803         Dimensions without coordinates: x\n6804         Data variables:\n6805             foo      (x) object nan nan 'a' 'b' 'c'\n6806         \"\"\"\n6807         shifts = either_dict_or_kwargs(shifts, shifts_kwargs, \"shift\")\n6808         invalid = [k for k in shifts if k not in self.dims]\n6809         if invalid:\n6810             raise ValueError(f\"dimensions {invalid!r} do not exist\")\n6811 \n6812         variables = {}\n6813         for name, var in self.variables.items():\n6814             if name in self.data_vars:\n6815                 fill_value_ = (\n6816                     fill_value.get(name, xrdtypes.NA)\n6817                     if isinstance(fill_value, dict)\n6818                     else fill_value\n6819                 )\n6820 \n6821                 var_shifts = {k: v for k, v in shifts.items() if k in var.dims}\n6822                 variables[name] = var.shift(fill_value=fill_value_, shifts=var_shifts)\n6823             else:\n6824                 variables[name] = var\n6825 \n6826         return self._replace(variables)\n6827 \n6828     def roll(\n6829         self: T_Dataset,\n6830         shifts: Mapping[Any, int] | None = None,\n6831         roll_coords: bool = False,\n6832         **shifts_kwargs: int,\n6833     ) -> T_Dataset:\n6834         \"\"\"Roll this dataset by an offset along one or more dimensions.\n6835 \n6836         Unlike shift, roll treats the given dimensions as periodic, so will not\n6837         create any missing values to be filled.\n6838 \n6839         Also unlike shift, roll may rotate all variables, including coordinates\n6840         if specified. The direction of rotation is consistent with\n6841         :py:func:`numpy.roll`.\n6842 \n6843         Parameters\n6844         ----------\n6845         shifts : mapping of hashable to int, optional\n6846             A dict with keys matching dimensions and values given\n6847             by integers to rotate each of the given dimensions. Positive\n6848             offsets roll to the right; negative offsets roll to the left.\n6849         roll_coords : bool, default: False\n6850             Indicates whether to roll the coordinates by the offset too.\n6851         **shifts_kwargs : {dim: offset, ...}, optional\n6852             The keyword arguments form of ``shifts``.\n6853             One of shifts or shifts_kwargs must be provided.\n6854 \n6855         Returns\n6856         -------\n6857         rolled : Dataset\n6858             Dataset with the same attributes but rolled data and coordinates.\n6859 \n6860         See Also\n6861         --------\n6862         shift\n6863 \n6864         Examples\n6865         --------\n6866         >>> ds = xr.Dataset({\"foo\": (\"x\", list(\"abcde\"))}, coords={\"x\": np.arange(5)})\n6867         >>> ds.roll(x=2)\n6868         <xarray.Dataset>\n6869         Dimensions:  (x: 5)\n6870         Coordinates:\n6871           * x        (x) int64 0 1 2 3 4\n6872         Data variables:\n6873             foo      (x) <U1 'd' 'e' 'a' 'b' 'c'\n6874 \n6875         >>> ds.roll(x=2, roll_coords=True)\n6876         <xarray.Dataset>\n6877         Dimensions:  (x: 5)\n6878         Coordinates:\n6879           * x        (x) int64 3 4 0 1 2\n6880         Data variables:\n6881             foo      (x) <U1 'd' 'e' 'a' 'b' 'c'\n6882 \n6883         \"\"\"\n6884         shifts = either_dict_or_kwargs(shifts, shifts_kwargs, \"roll\")\n6885         invalid = [k for k in shifts if k not in self.dims]\n6886         if invalid:\n6887             raise ValueError(f\"dimensions {invalid!r} do not exist\")\n6888 \n6889         unrolled_vars: tuple[Hashable, ...]\n6890 \n6891         if roll_coords:\n6892             indexes, index_vars = roll_indexes(self.xindexes, shifts)\n6893             unrolled_vars = ()\n6894         else:\n6895             indexes = dict(self._indexes)\n6896             index_vars = dict(self.xindexes.variables)\n6897             unrolled_vars = tuple(self.coords)\n6898 \n6899         variables = {}\n6900         for k, var in self.variables.items():\n6901             if k in index_vars:\n6902                 variables[k] = index_vars[k]\n6903             elif k not in unrolled_vars:\n6904                 variables[k] = var.roll(\n6905                     shifts={k: s for k, s in shifts.items() if k in var.dims}\n6906                 )\n6907             else:\n6908                 variables[k] = var\n6909 \n6910         return self._replace(variables, indexes=indexes)\n6911 \n6912     def sortby(\n6913         self: T_Dataset,\n6914         variables: Hashable | DataArray | list[Hashable | DataArray],\n6915         ascending: bool = True,\n6916     ) -> T_Dataset:\n6917         \"\"\"\n6918         Sort object by labels or values (along an axis).\n6919 \n6920         Sorts the dataset, either along specified dimensions,\n6921         or according to values of 1-D dataarrays that share dimension\n6922         with calling object.\n6923 \n6924         If the input variables are dataarrays, then the dataarrays are aligned\n6925         (via left-join) to the calling object prior to sorting by cell values.\n6926         NaNs are sorted to the end, following Numpy convention.\n6927 \n6928         If multiple sorts along the same dimension is\n6929         given, numpy's lexsort is performed along that dimension:\n6930         https://numpy.org/doc/stable/reference/generated/numpy.lexsort.html\n6931         and the FIRST key in the sequence is used as the primary sort key,\n6932         followed by the 2nd key, etc.\n6933 \n6934         Parameters\n6935         ----------\n6936         variables : Hashable, DataArray, or list of hashable or DataArray\n6937             1D DataArray objects or name(s) of 1D variable(s) in\n6938             coords/data_vars whose values are used to sort the dataset.\n6939         ascending : bool, default: True\n6940             Whether to sort by ascending or descending order.\n6941 \n6942         Returns\n6943         -------\n6944         sorted : Dataset\n6945             A new dataset where all the specified dims are sorted by dim\n6946             labels.\n6947 \n6948         See Also\n6949         --------\n6950         DataArray.sortby\n6951         numpy.sort\n6952         pandas.sort_values\n6953         pandas.sort_index\n6954 \n6955         Examples\n6956         --------\n6957         >>> ds = xr.Dataset(\n6958         ...     {\n6959         ...         \"A\": ((\"x\", \"y\"), [[1, 2], [3, 4]]),\n6960         ...         \"B\": ((\"x\", \"y\"), [[5, 6], [7, 8]]),\n6961         ...     },\n6962         ...     coords={\"x\": [\"b\", \"a\"], \"y\": [1, 0]},\n6963         ... )\n6964         >>> ds = ds.sortby(\"x\")\n6965         >>> ds\n6966         <xarray.Dataset>\n6967         Dimensions:  (x: 2, y: 2)\n6968         Coordinates:\n6969           * x        (x) <U1 'a' 'b'\n6970           * y        (y) int64 1 0\n6971         Data variables:\n6972             A        (x, y) int64 3 4 1 2\n6973             B        (x, y) int64 7 8 5 6\n6974         \"\"\"\n6975         from xarray.core.dataarray import DataArray\n6976 \n6977         if not isinstance(variables, list):\n6978             variables = [variables]\n6979         else:\n6980             variables = variables\n6981         arrays = [v if isinstance(v, DataArray) else self[v] for v in variables]\n6982         aligned_vars = align(self, *arrays, join=\"left\")  # type: ignore[type-var]\n6983         aligned_self: T_Dataset = aligned_vars[0]  # type: ignore[assignment]\n6984         aligned_other_vars: tuple[DataArray, ...] = aligned_vars[1:]  # type: ignore[assignment]\n6985         vars_by_dim = defaultdict(list)\n6986         for data_array in aligned_other_vars:\n6987             if data_array.ndim != 1:\n6988                 raise ValueError(\"Input DataArray is not 1-D.\")\n6989             (key,) = data_array.dims\n6990             vars_by_dim[key].append(data_array)\n6991 \n6992         indices = {}\n6993         for key, arrays in vars_by_dim.items():\n6994             order = np.lexsort(tuple(reversed(arrays)))\n6995             indices[key] = order if ascending else order[::-1]\n6996         return aligned_self.isel(indices)\n6997 \n6998     def quantile(\n6999         self: T_Dataset,\n7000         q: ArrayLike,\n7001         dim: Dims = None,\n7002         method: QuantileMethods = \"linear\",\n7003         numeric_only: bool = False,\n7004         keep_attrs: bool | None = None,\n7005         skipna: bool | None = None,\n7006         interpolation: QuantileMethods | None = None,\n7007     ) -> T_Dataset:\n7008         \"\"\"Compute the qth quantile of the data along the specified dimension.\n7009 \n7010         Returns the qth quantiles(s) of the array elements for each variable\n7011         in the Dataset.\n7012 \n7013         Parameters\n7014         ----------\n7015         q : float or array-like of float\n7016             Quantile to compute, which must be between 0 and 1 inclusive.\n7017         dim : str or Iterable of Hashable, optional\n7018             Dimension(s) over which to apply quantile.\n7019         method : str, default: \"linear\"\n7020             This optional parameter specifies the interpolation method to use when the\n7021             desired quantile lies between two data points. The options sorted by their R\n7022             type as summarized in the H&F paper [1]_ are:\n7023 \n7024                 1. \"inverted_cdf\" (*)\n7025                 2. \"averaged_inverted_cdf\" (*)\n7026                 3. \"closest_observation\" (*)\n7027                 4. \"interpolated_inverted_cdf\" (*)\n7028                 5. \"hazen\" (*)\n7029                 6. \"weibull\" (*)\n7030                 7. \"linear\"  (default)\n7031                 8. \"median_unbiased\" (*)\n7032                 9. \"normal_unbiased\" (*)\n7033 \n7034             The first three methods are discontiuous.  The following discontinuous\n7035             variations of the default \"linear\" (7.) option are also available:\n7036 \n7037                 * \"lower\"\n7038                 * \"higher\"\n7039                 * \"midpoint\"\n7040                 * \"nearest\"\n7041 \n7042             See :py:func:`numpy.quantile` or [1]_ for details. The \"method\" argument\n7043             was previously called \"interpolation\", renamed in accordance with numpy\n7044             version 1.22.0.\n7045 \n7046             (*) These methods require numpy version 1.22 or newer.\n7047 \n7048         keep_attrs : bool, optional\n7049             If True, the dataset's attributes (`attrs`) will be copied from\n7050             the original object to the new one.  If False (default), the new\n7051             object will be returned without attributes.\n7052         numeric_only : bool, optional\n7053             If True, only apply ``func`` to variables with a numeric dtype.\n7054         skipna : bool, optional\n7055             If True, skip missing values (as marked by NaN). By default, only\n7056             skips missing values for float dtypes; other dtypes either do not\n7057             have a sentinel missing value (int) or skipna=True has not been\n7058             implemented (object, datetime64 or timedelta64).\n7059 \n7060         Returns\n7061         -------\n7062         quantiles : Dataset\n7063             If `q` is a single quantile, then the result is a scalar for each\n7064             variable in data_vars. If multiple percentiles are given, first\n7065             axis of the result corresponds to the quantile and a quantile\n7066             dimension is added to the return Dataset. The other dimensions are\n7067             the dimensions that remain after the reduction of the array.\n7068 \n7069         See Also\n7070         --------\n7071         numpy.nanquantile, numpy.quantile, pandas.Series.quantile, DataArray.quantile\n7072 \n7073         Examples\n7074         --------\n7075         >>> ds = xr.Dataset(\n7076         ...     {\"a\": ((\"x\", \"y\"), [[0.7, 4.2, 9.4, 1.5], [6.5, 7.3, 2.6, 1.9]])},\n7077         ...     coords={\"x\": [7, 9], \"y\": [1, 1.5, 2, 2.5]},\n7078         ... )\n7079         >>> ds.quantile(0)  # or ds.quantile(0, dim=...)\n7080         <xarray.Dataset>\n7081         Dimensions:   ()\n7082         Coordinates:\n7083             quantile  float64 0.0\n7084         Data variables:\n7085             a         float64 0.7\n7086         >>> ds.quantile(0, dim=\"x\")\n7087         <xarray.Dataset>\n7088         Dimensions:   (y: 4)\n7089         Coordinates:\n7090           * y         (y) float64 1.0 1.5 2.0 2.5\n7091             quantile  float64 0.0\n7092         Data variables:\n7093             a         (y) float64 0.7 4.2 2.6 1.5\n7094         >>> ds.quantile([0, 0.5, 1])\n7095         <xarray.Dataset>\n7096         Dimensions:   (quantile: 3)\n7097         Coordinates:\n7098           * quantile  (quantile) float64 0.0 0.5 1.0\n7099         Data variables:\n7100             a         (quantile) float64 0.7 3.4 9.4\n7101         >>> ds.quantile([0, 0.5, 1], dim=\"x\")\n7102         <xarray.Dataset>\n7103         Dimensions:   (quantile: 3, y: 4)\n7104         Coordinates:\n7105           * y         (y) float64 1.0 1.5 2.0 2.5\n7106           * quantile  (quantile) float64 0.0 0.5 1.0\n7107         Data variables:\n7108             a         (quantile, y) float64 0.7 4.2 2.6 1.5 3.6 ... 1.7 6.5 7.3 9.4 1.9\n7109 \n7110         References\n7111         ----------\n7112         .. [1] R. J. Hyndman and Y. Fan,\n7113            \"Sample quantiles in statistical packages,\"\n7114            The American Statistician, 50(4), pp. 361-365, 1996\n7115         \"\"\"\n7116 \n7117         # interpolation renamed to method in version 0.21.0\n7118         # check here and in variable to avoid repeated warnings\n7119         if interpolation is not None:\n7120             warnings.warn(\n7121                 \"The `interpolation` argument to quantile was renamed to `method`.\",\n7122                 FutureWarning,\n7123             )\n7124 \n7125             if method != \"linear\":\n7126                 raise TypeError(\"Cannot pass interpolation and method keywords!\")\n7127 \n7128             method = interpolation\n7129 \n7130         dims: set[Hashable]\n7131         if isinstance(dim, str):\n7132             dims = {dim}\n7133         elif dim is None or dim is ...:\n7134             dims = set(self.dims)\n7135         else:\n7136             dims = set(dim)\n7137 \n7138         _assert_empty(\n7139             tuple(d for d in dims if d not in self.dims),\n7140             \"Dataset does not contain the dimensions: %s\",\n7141         )\n7142 \n7143         q = np.asarray(q, dtype=np.float64)\n7144 \n7145         variables = {}\n7146         for name, var in self.variables.items():\n7147             reduce_dims = [d for d in var.dims if d in dims]\n7148             if reduce_dims or not var.dims:\n7149                 if name not in self.coords:\n7150                     if (\n7151                         not numeric_only\n7152                         or np.issubdtype(var.dtype, np.number)\n7153                         or var.dtype == np.bool_\n7154                     ):\n7155                         variables[name] = var.quantile(\n7156                             q,\n7157                             dim=reduce_dims,\n7158                             method=method,\n7159                             keep_attrs=keep_attrs,\n7160                             skipna=skipna,\n7161                         )\n7162 \n7163             else:\n7164                 variables[name] = var\n7165 \n7166         # construct the new dataset\n7167         coord_names = {k for k in self.coords if k in variables}\n7168         indexes = {k: v for k, v in self._indexes.items() if k in variables}\n7169         if keep_attrs is None:\n7170             keep_attrs = _get_keep_attrs(default=False)\n7171         attrs = self.attrs if keep_attrs else None\n7172         new = self._replace_with_new_dims(\n7173             variables, coord_names=coord_names, attrs=attrs, indexes=indexes\n7174         )\n7175         return new.assign_coords(quantile=q)\n7176 \n7177     def rank(\n7178         self: T_Dataset,\n7179         dim: Hashable,\n7180         pct: bool = False,\n7181         keep_attrs: bool | None = None,\n7182     ) -> T_Dataset:\n7183         \"\"\"Ranks the data.\n7184 \n7185         Equal values are assigned a rank that is the average of the ranks that\n7186         would have been otherwise assigned to all of the values within\n7187         that set.\n7188         Ranks begin at 1, not 0. If pct is True, computes percentage ranks.\n7189 \n7190         NaNs in the input array are returned as NaNs.\n7191 \n7192         The `bottleneck` library is required.\n7193 \n7194         Parameters\n7195         ----------\n7196         dim : Hashable\n7197             Dimension over which to compute rank.\n7198         pct : bool, default: False\n7199             If True, compute percentage ranks, otherwise compute integer ranks.\n7200         keep_attrs : bool or None, optional\n7201             If True, the dataset's attributes (`attrs`) will be copied from\n7202             the original object to the new one.  If False, the new\n7203             object will be returned without attributes.\n7204 \n7205         Returns\n7206         -------\n7207         ranked : Dataset\n7208             Variables that do not depend on `dim` are dropped.\n7209         \"\"\"\n7210         if not OPTIONS[\"use_bottleneck\"]:\n7211             raise RuntimeError(\n7212                 \"rank requires bottleneck to be enabled.\"\n7213                 \" Call `xr.set_options(use_bottleneck=True)` to enable it.\"\n7214             )\n7215 \n7216         if dim not in self.dims:\n7217             raise ValueError(f\"Dataset does not contain the dimension: {dim}\")\n7218 \n7219         variables = {}\n7220         for name, var in self.variables.items():\n7221             if name in self.data_vars:\n7222                 if dim in var.dims:\n7223                     variables[name] = var.rank(dim, pct=pct)\n7224             else:\n7225                 variables[name] = var\n7226 \n7227         coord_names = set(self.coords)\n7228         if keep_attrs is None:\n7229             keep_attrs = _get_keep_attrs(default=False)\n7230         attrs = self.attrs if keep_attrs else None\n7231         return self._replace(variables, coord_names, attrs=attrs)\n7232 \n7233     def differentiate(\n7234         self: T_Dataset,\n7235         coord: Hashable,\n7236         edge_order: Literal[1, 2] = 1,\n7237         datetime_unit: DatetimeUnitOptions | None = None,\n7238     ) -> T_Dataset:\n7239         \"\"\" Differentiate with the second order accurate central\n7240         differences.\n7241 \n7242         .. note::\n7243             This feature is limited to simple cartesian geometry, i.e. coord\n7244             must be one dimensional.\n7245 \n7246         Parameters\n7247         ----------\n7248         coord : Hashable\n7249             The coordinate to be used to compute the gradient.\n7250         edge_order : {1, 2}, default: 1\n7251             N-th order accurate differences at the boundaries.\n7252         datetime_unit : None or {\"Y\", \"M\", \"W\", \"D\", \"h\", \"m\", \"s\", \"ms\", \\\n7253             \"us\", \"ns\", \"ps\", \"fs\", \"as\", None}, default: None\n7254             Unit to compute gradient. Only valid for datetime coordinate.\n7255 \n7256         Returns\n7257         -------\n7258         differentiated: Dataset\n7259 \n7260         See also\n7261         --------\n7262         numpy.gradient: corresponding numpy function\n7263         \"\"\"\n7264         from xarray.core.variable import Variable\n7265 \n7266         if coord not in self.variables and coord not in self.dims:\n7267             raise ValueError(f\"Coordinate {coord} does not exist.\")\n7268 \n7269         coord_var = self[coord].variable\n7270         if coord_var.ndim != 1:\n7271             raise ValueError(\n7272                 \"Coordinate {} must be 1 dimensional but is {}\"\n7273                 \" dimensional\".format(coord, coord_var.ndim)\n7274             )\n7275 \n7276         dim = coord_var.dims[0]\n7277         if _contains_datetime_like_objects(coord_var):\n7278             if coord_var.dtype.kind in \"mM\" and datetime_unit is None:\n7279                 datetime_unit = cast(\n7280                     \"DatetimeUnitOptions\", np.datetime_data(coord_var.dtype)[0]\n7281                 )\n7282             elif datetime_unit is None:\n7283                 datetime_unit = \"s\"  # Default to seconds for cftime objects\n7284             coord_var = coord_var._to_numeric(datetime_unit=datetime_unit)\n7285 \n7286         variables = {}\n7287         for k, v in self.variables.items():\n7288             if k in self.data_vars and dim in v.dims and k not in self.coords:\n7289                 if _contains_datetime_like_objects(v):\n7290                     v = v._to_numeric(datetime_unit=datetime_unit)\n7291                 grad = duck_array_ops.gradient(\n7292                     v.data,\n7293                     coord_var.data,\n7294                     edge_order=edge_order,\n7295                     axis=v.get_axis_num(dim),\n7296                 )\n7297                 variables[k] = Variable(v.dims, grad)\n7298             else:\n7299                 variables[k] = v\n7300         return self._replace(variables)\n7301 \n7302     def integrate(\n7303         self: T_Dataset,\n7304         coord: Hashable | Sequence[Hashable],\n7305         datetime_unit: DatetimeUnitOptions = None,\n7306     ) -> T_Dataset:\n7307         \"\"\"Integrate along the given coordinate using the trapezoidal rule.\n7308 \n7309         .. note::\n7310             This feature is limited to simple cartesian geometry, i.e. coord\n7311             must be one dimensional.\n7312 \n7313         Parameters\n7314         ----------\n7315         coord : hashable, or sequence of hashable\n7316             Coordinate(s) used for the integration.\n7317         datetime_unit : {'Y', 'M', 'W', 'D', 'h', 'm', 's', 'ms', 'us', 'ns', \\\n7318                         'ps', 'fs', 'as', None}, optional\n7319             Specify the unit if datetime coordinate is used.\n7320 \n7321         Returns\n7322         -------\n7323         integrated : Dataset\n7324 \n7325         See also\n7326         --------\n7327         DataArray.integrate\n7328         numpy.trapz : corresponding numpy function\n7329 \n7330         Examples\n7331         --------\n7332         >>> ds = xr.Dataset(\n7333         ...     data_vars={\"a\": (\"x\", [5, 5, 6, 6]), \"b\": (\"x\", [1, 2, 1, 0])},\n7334         ...     coords={\"x\": [0, 1, 2, 3], \"y\": (\"x\", [1, 7, 3, 5])},\n7335         ... )\n7336         >>> ds\n7337         <xarray.Dataset>\n7338         Dimensions:  (x: 4)\n7339         Coordinates:\n7340           * x        (x) int64 0 1 2 3\n7341             y        (x) int64 1 7 3 5\n7342         Data variables:\n7343             a        (x) int64 5 5 6 6\n7344             b        (x) int64 1 2 1 0\n7345         >>> ds.integrate(\"x\")\n7346         <xarray.Dataset>\n7347         Dimensions:  ()\n7348         Data variables:\n7349             a        float64 16.5\n7350             b        float64 3.5\n7351         >>> ds.integrate(\"y\")\n7352         <xarray.Dataset>\n7353         Dimensions:  ()\n7354         Data variables:\n7355             a        float64 20.0\n7356             b        float64 4.0\n7357         \"\"\"\n7358         if not isinstance(coord, (list, tuple)):\n7359             coord = (coord,)\n7360         result = self\n7361         for c in coord:\n7362             result = result._integrate_one(c, datetime_unit=datetime_unit)\n7363         return result\n7364 \n7365     def _integrate_one(self, coord, datetime_unit=None, cumulative=False):\n7366         from xarray.core.variable import Variable\n7367 \n7368         if coord not in self.variables and coord not in self.dims:\n7369             raise ValueError(f\"Coordinate {coord} does not exist.\")\n7370 \n7371         coord_var = self[coord].variable\n7372         if coord_var.ndim != 1:\n7373             raise ValueError(\n7374                 \"Coordinate {} must be 1 dimensional but is {}\"\n7375                 \" dimensional\".format(coord, coord_var.ndim)\n7376             )\n7377 \n7378         dim = coord_var.dims[0]\n7379         if _contains_datetime_like_objects(coord_var):\n7380             if coord_var.dtype.kind in \"mM\" and datetime_unit is None:\n7381                 datetime_unit, _ = np.datetime_data(coord_var.dtype)\n7382             elif datetime_unit is None:\n7383                 datetime_unit = \"s\"  # Default to seconds for cftime objects\n7384             coord_var = coord_var._replace(\n7385                 data=datetime_to_numeric(coord_var.data, datetime_unit=datetime_unit)\n7386             )\n7387 \n7388         variables = {}\n7389         coord_names = set()\n7390         for k, v in self.variables.items():\n7391             if k in self.coords:\n7392                 if dim not in v.dims or cumulative:\n7393                     variables[k] = v\n7394                     coord_names.add(k)\n7395             else:\n7396                 if k in self.data_vars and dim in v.dims:\n7397                     if _contains_datetime_like_objects(v):\n7398                         v = datetime_to_numeric(v, datetime_unit=datetime_unit)\n7399                     if cumulative:\n7400                         integ = duck_array_ops.cumulative_trapezoid(\n7401                             v.data, coord_var.data, axis=v.get_axis_num(dim)\n7402                         )\n7403                         v_dims = v.dims\n7404                     else:\n7405                         integ = duck_array_ops.trapz(\n7406                             v.data, coord_var.data, axis=v.get_axis_num(dim)\n7407                         )\n7408                         v_dims = list(v.dims)\n7409                         v_dims.remove(dim)\n7410                     variables[k] = Variable(v_dims, integ)\n7411                 else:\n7412                     variables[k] = v\n7413         indexes = {k: v for k, v in self._indexes.items() if k in variables}\n7414         return self._replace_with_new_dims(\n7415             variables, coord_names=coord_names, indexes=indexes\n7416         )\n7417 \n7418     def cumulative_integrate(\n7419         self: T_Dataset,\n7420         coord: Hashable | Sequence[Hashable],\n7421         datetime_unit: DatetimeUnitOptions = None,\n7422     ) -> T_Dataset:\n7423         \"\"\"Integrate along the given coordinate using the trapezoidal rule.\n7424 \n7425         .. note::\n7426             This feature is limited to simple cartesian geometry, i.e. coord\n7427             must be one dimensional.\n7428 \n7429             The first entry of the cumulative integral of each variable is always 0, in\n7430             order to keep the length of the dimension unchanged between input and\n7431             output.\n7432 \n7433         Parameters\n7434         ----------\n7435         coord : hashable, or sequence of hashable\n7436             Coordinate(s) used for the integration.\n7437         datetime_unit : {'Y', 'M', 'W', 'D', 'h', 'm', 's', 'ms', 'us', 'ns', \\\n7438                         'ps', 'fs', 'as', None}, optional\n7439             Specify the unit if datetime coordinate is used.\n7440 \n7441         Returns\n7442         -------\n7443         integrated : Dataset\n7444 \n7445         See also\n7446         --------\n7447         DataArray.cumulative_integrate\n7448         scipy.integrate.cumulative_trapezoid : corresponding scipy function\n7449 \n7450         Examples\n7451         --------\n7452         >>> ds = xr.Dataset(\n7453         ...     data_vars={\"a\": (\"x\", [5, 5, 6, 6]), \"b\": (\"x\", [1, 2, 1, 0])},\n7454         ...     coords={\"x\": [0, 1, 2, 3], \"y\": (\"x\", [1, 7, 3, 5])},\n7455         ... )\n7456         >>> ds\n7457         <xarray.Dataset>\n7458         Dimensions:  (x: 4)\n7459         Coordinates:\n7460           * x        (x) int64 0 1 2 3\n7461             y        (x) int64 1 7 3 5\n7462         Data variables:\n7463             a        (x) int64 5 5 6 6\n7464             b        (x) int64 1 2 1 0\n7465         >>> ds.cumulative_integrate(\"x\")\n7466         <xarray.Dataset>\n7467         Dimensions:  (x: 4)\n7468         Coordinates:\n7469           * x        (x) int64 0 1 2 3\n7470             y        (x) int64 1 7 3 5\n7471         Data variables:\n7472             a        (x) float64 0.0 5.0 10.5 16.5\n7473             b        (x) float64 0.0 1.5 3.0 3.5\n7474         >>> ds.cumulative_integrate(\"y\")\n7475         <xarray.Dataset>\n7476         Dimensions:  (x: 4)\n7477         Coordinates:\n7478           * x        (x) int64 0 1 2 3\n7479             y        (x) int64 1 7 3 5\n7480         Data variables:\n7481             a        (x) float64 0.0 30.0 8.0 20.0\n7482             b        (x) float64 0.0 9.0 3.0 4.0\n7483         \"\"\"\n7484         if not isinstance(coord, (list, tuple)):\n7485             coord = (coord,)\n7486         result = self\n7487         for c in coord:\n7488             result = result._integrate_one(\n7489                 c, datetime_unit=datetime_unit, cumulative=True\n7490             )\n7491         return result\n7492 \n7493     @property\n7494     def real(self: T_Dataset) -> T_Dataset:\n7495         \"\"\"\n7496         The real part of each data variable.\n7497 \n7498         See Also\n7499         --------\n7500         numpy.ndarray.real\n7501         \"\"\"\n7502         return self.map(lambda x: x.real, keep_attrs=True)\n7503 \n7504     @property\n7505     def imag(self: T_Dataset) -> T_Dataset:\n7506         \"\"\"\n7507         The imaginary part of each data variable.\n7508 \n7509         See Also\n7510         --------\n7511         numpy.ndarray.imag\n7512         \"\"\"\n7513         return self.map(lambda x: x.imag, keep_attrs=True)\n7514 \n7515     plot = utils.UncachedAccessor(DatasetPlotAccessor)\n7516 \n7517     def filter_by_attrs(self: T_Dataset, **kwargs) -> T_Dataset:\n7518         \"\"\"Returns a ``Dataset`` with variables that match specific conditions.\n7519 \n7520         Can pass in ``key=value`` or ``key=callable``.  A Dataset is returned\n7521         containing only the variables for which all the filter tests pass.\n7522         These tests are either ``key=value`` for which the attribute ``key``\n7523         has the exact value ``value`` or the callable passed into\n7524         ``key=callable`` returns True. The callable will be passed a single\n7525         value, either the value of the attribute ``key`` or ``None`` if the\n7526         DataArray does not have an attribute with the name ``key``.\n7527 \n7528         Parameters\n7529         ----------\n7530         **kwargs\n7531             key : str\n7532                 Attribute name.\n7533             value : callable or obj\n7534                 If value is a callable, it should return a boolean in the form\n7535                 of bool = func(attr) where attr is da.attrs[key].\n7536                 Otherwise, value will be compared to the each\n7537                 DataArray's attrs[key].\n7538 \n7539         Returns\n7540         -------\n7541         new : Dataset\n7542             New dataset with variables filtered by attribute.\n7543 \n7544         Examples\n7545         --------\n7546         >>> temp = 15 + 8 * np.random.randn(2, 2, 3)\n7547         >>> precip = 10 * np.random.rand(2, 2, 3)\n7548         >>> lon = [[-99.83, -99.32], [-99.79, -99.23]]\n7549         >>> lat = [[42.25, 42.21], [42.63, 42.59]]\n7550         >>> dims = [\"x\", \"y\", \"time\"]\n7551         >>> temp_attr = dict(standard_name=\"air_potential_temperature\")\n7552         >>> precip_attr = dict(standard_name=\"convective_precipitation_flux\")\n7553 \n7554         >>> ds = xr.Dataset(\n7555         ...     dict(\n7556         ...         temperature=(dims, temp, temp_attr),\n7557         ...         precipitation=(dims, precip, precip_attr),\n7558         ...     ),\n7559         ...     coords=dict(\n7560         ...         lon=([\"x\", \"y\"], lon),\n7561         ...         lat=([\"x\", \"y\"], lat),\n7562         ...         time=pd.date_range(\"2014-09-06\", periods=3),\n7563         ...         reference_time=pd.Timestamp(\"2014-09-05\"),\n7564         ...     ),\n7565         ... )\n7566 \n7567         Get variables matching a specific standard_name:\n7568 \n7569         >>> ds.filter_by_attrs(standard_name=\"convective_precipitation_flux\")\n7570         <xarray.Dataset>\n7571         Dimensions:         (x: 2, y: 2, time: 3)\n7572         Coordinates:\n7573             lon             (x, y) float64 -99.83 -99.32 -99.79 -99.23\n7574             lat             (x, y) float64 42.25 42.21 42.63 42.59\n7575           * time            (time) datetime64[ns] 2014-09-06 2014-09-07 2014-09-08\n7576             reference_time  datetime64[ns] 2014-09-05\n7577         Dimensions without coordinates: x, y\n7578         Data variables:\n7579             precipitation   (x, y, time) float64 5.68 9.256 0.7104 ... 7.992 4.615 7.805\n7580 \n7581         Get all variables that have a standard_name attribute:\n7582 \n7583         >>> standard_name = lambda v: v is not None\n7584         >>> ds.filter_by_attrs(standard_name=standard_name)\n7585         <xarray.Dataset>\n7586         Dimensions:         (x: 2, y: 2, time: 3)\n7587         Coordinates:\n7588             lon             (x, y) float64 -99.83 -99.32 -99.79 -99.23\n7589             lat             (x, y) float64 42.25 42.21 42.63 42.59\n7590           * time            (time) datetime64[ns] 2014-09-06 2014-09-07 2014-09-08\n7591             reference_time  datetime64[ns] 2014-09-05\n7592         Dimensions without coordinates: x, y\n7593         Data variables:\n7594             temperature     (x, y, time) float64 29.11 18.2 22.83 ... 18.28 16.15 26.63\n7595             precipitation   (x, y, time) float64 5.68 9.256 0.7104 ... 7.992 4.615 7.805\n7596 \n7597         \"\"\"\n7598         selection = []\n7599         for var_name, variable in self.variables.items():\n7600             has_value_flag = False\n7601             for attr_name, pattern in kwargs.items():\n7602                 attr_value = variable.attrs.get(attr_name)\n7603                 if (callable(pattern) and pattern(attr_value)) or attr_value == pattern:\n7604                     has_value_flag = True\n7605                 else:\n7606                     has_value_flag = False\n7607                     break\n7608             if has_value_flag is True:\n7609                 selection.append(var_name)\n7610         return self[selection]\n7611 \n7612     def unify_chunks(self: T_Dataset) -> T_Dataset:\n7613         \"\"\"Unify chunk size along all chunked dimensions of this Dataset.\n7614 \n7615         Returns\n7616         -------\n7617         Dataset with consistent chunk sizes for all dask-array variables\n7618 \n7619         See Also\n7620         --------\n7621         dask.array.core.unify_chunks\n7622         \"\"\"\n7623 \n7624         return unify_chunks(self)[0]\n7625 \n7626     def map_blocks(\n7627         self,\n7628         func: Callable[..., T_Xarray],\n7629         args: Sequence[Any] = (),\n7630         kwargs: Mapping[str, Any] | None = None,\n7631         template: DataArray | Dataset | None = None,\n7632     ) -> T_Xarray:\n7633         \"\"\"\n7634         Apply a function to each block of this Dataset.\n7635 \n7636         .. warning::\n7637             This method is experimental and its signature may change.\n7638 \n7639         Parameters\n7640         ----------\n7641         func : callable\n7642             User-provided function that accepts a Dataset as its first\n7643             parameter. The function will receive a subset or 'block' of this Dataset (see below),\n7644             corresponding to one chunk along each chunked dimension. ``func`` will be\n7645             executed as ``func(subset_dataset, *subset_args, **kwargs)``.\n7646 \n7647             This function must return either a single DataArray or a single Dataset.\n7648 \n7649             This function cannot add a new chunked dimension.\n7650         args : sequence\n7651             Passed to func after unpacking and subsetting any xarray objects by blocks.\n7652             xarray objects in args must be aligned with obj, otherwise an error is raised.\n7653         kwargs : Mapping or None\n7654             Passed verbatim to func after unpacking. xarray objects, if any, will not be\n7655             subset to blocks. Passing dask collections in kwargs is not allowed.\n7656         template : DataArray, Dataset or None, optional\n7657             xarray object representing the final result after compute is called. If not provided,\n7658             the function will be first run on mocked-up data, that looks like this object but\n7659             has sizes 0, to determine properties of the returned object such as dtype,\n7660             variable names, attributes, new dimensions and new indexes (if any).\n7661             ``template`` must be provided if the function changes the size of existing dimensions.\n7662             When provided, ``attrs`` on variables in `template` are copied over to the result. Any\n7663             ``attrs`` set by ``func`` will be ignored.\n7664 \n7665         Returns\n7666         -------\n7667         A single DataArray or Dataset with dask backend, reassembled from the outputs of the\n7668         function.\n7669 \n7670         Notes\n7671         -----\n7672         This function is designed for when ``func`` needs to manipulate a whole xarray object\n7673         subset to each block. Each block is loaded into memory. In the more common case where\n7674         ``func`` can work on numpy arrays, it is recommended to use ``apply_ufunc``.\n7675 \n7676         If none of the variables in this object is backed by dask arrays, calling this function is\n7677         equivalent to calling ``func(obj, *args, **kwargs)``.\n7678 \n7679         See Also\n7680         --------\n7681         dask.array.map_blocks, xarray.apply_ufunc, xarray.Dataset.map_blocks\n7682         xarray.DataArray.map_blocks\n7683 \n7684         Examples\n7685         --------\n7686         Calculate an anomaly from climatology using ``.groupby()``. Using\n7687         ``xr.map_blocks()`` allows for parallel operations with knowledge of ``xarray``,\n7688         its indices, and its methods like ``.groupby()``.\n7689 \n7690         >>> def calculate_anomaly(da, groupby_type=\"time.month\"):\n7691         ...     gb = da.groupby(groupby_type)\n7692         ...     clim = gb.mean(dim=\"time\")\n7693         ...     return gb - clim\n7694         ...\n7695         >>> time = xr.cftime_range(\"1990-01\", \"1992-01\", freq=\"M\")\n7696         >>> month = xr.DataArray(time.month, coords={\"time\": time}, dims=[\"time\"])\n7697         >>> np.random.seed(123)\n7698         >>> array = xr.DataArray(\n7699         ...     np.random.rand(len(time)),\n7700         ...     dims=[\"time\"],\n7701         ...     coords={\"time\": time, \"month\": month},\n7702         ... ).chunk()\n7703         >>> ds = xr.Dataset({\"a\": array})\n7704         >>> ds.map_blocks(calculate_anomaly, template=ds).compute()\n7705         <xarray.Dataset>\n7706         Dimensions:  (time: 24)\n7707         Coordinates:\n7708           * time     (time) object 1990-01-31 00:00:00 ... 1991-12-31 00:00:00\n7709             month    (time) int64 1 2 3 4 5 6 7 8 9 10 11 12 1 2 3 4 5 6 7 8 9 10 11 12\n7710         Data variables:\n7711             a        (time) float64 0.1289 0.1132 -0.0856 ... 0.2287 0.1906 -0.05901\n7712 \n7713         Note that one must explicitly use ``args=[]`` and ``kwargs={}`` to pass arguments\n7714         to the function being applied in ``xr.map_blocks()``:\n7715 \n7716         >>> ds.map_blocks(\n7717         ...     calculate_anomaly,\n7718         ...     kwargs={\"groupby_type\": \"time.year\"},\n7719         ...     template=ds,\n7720         ... )\n7721         <xarray.Dataset>\n7722         Dimensions:  (time: 24)\n7723         Coordinates:\n7724           * time     (time) object 1990-01-31 00:00:00 ... 1991-12-31 00:00:00\n7725             month    (time) int64 dask.array<chunksize=(24,), meta=np.ndarray>\n7726         Data variables:\n7727             a        (time) float64 dask.array<chunksize=(24,), meta=np.ndarray>\n7728         \"\"\"\n7729         from xarray.core.parallel import map_blocks\n7730 \n7731         return map_blocks(func, self, args, kwargs, template)\n7732 \n7733     def polyfit(\n7734         self: T_Dataset,\n7735         dim: Hashable,\n7736         deg: int,\n7737         skipna: bool | None = None,\n7738         rcond: float | None = None,\n7739         w: Hashable | Any = None,\n7740         full: bool = False,\n7741         cov: bool | Literal[\"unscaled\"] = False,\n7742     ) -> T_Dataset:\n7743         \"\"\"\n7744         Least squares polynomial fit.\n7745 \n7746         This replicates the behaviour of `numpy.polyfit` but differs by skipping\n7747         invalid values when `skipna = True`.\n7748 \n7749         Parameters\n7750         ----------\n7751         dim : hashable\n7752             Coordinate along which to fit the polynomials.\n7753         deg : int\n7754             Degree of the fitting polynomial.\n7755         skipna : bool or None, optional\n7756             If True, removes all invalid values before fitting each 1D slices of the array.\n7757             Default is True if data is stored in a dask.array or if there is any\n7758             invalid values, False otherwise.\n7759         rcond : float or None, optional\n7760             Relative condition number to the fit.\n7761         w : hashable or Any, optional\n7762             Weights to apply to the y-coordinate of the sample points.\n7763             Can be an array-like object or the name of a coordinate in the dataset.\n7764         full : bool, default: False\n7765             Whether to return the residuals, matrix rank and singular values in addition\n7766             to the coefficients.\n7767         cov : bool or \"unscaled\", default: False\n7768             Whether to return to the covariance matrix in addition to the coefficients.\n7769             The matrix is not scaled if `cov='unscaled'`.\n7770 \n7771         Returns\n7772         -------\n7773         polyfit_results : Dataset\n7774             A single dataset which contains (for each \"var\" in the input dataset):\n7775 \n7776             [var]_polyfit_coefficients\n7777                 The coefficients of the best fit for each variable in this dataset.\n7778             [var]_polyfit_residuals\n7779                 The residuals of the least-square computation for each variable (only included if `full=True`)\n7780                 When the matrix rank is deficient, np.nan is returned.\n7781             [dim]_matrix_rank\n7782                 The effective rank of the scaled Vandermonde coefficient matrix (only included if `full=True`)\n7783                 The rank is computed ignoring the NaN values that might be skipped.\n7784             [dim]_singular_values\n7785                 The singular values of the scaled Vandermonde coefficient matrix (only included if `full=True`)\n7786             [var]_polyfit_covariance\n7787                 The covariance matrix of the polynomial coefficient estimates (only included if `full=False` and `cov=True`)\n7788 \n7789         Warns\n7790         -----\n7791         RankWarning\n7792             The rank of the coefficient matrix in the least-squares fit is deficient.\n7793             The warning is not raised with in-memory (not dask) data and `full=True`.\n7794 \n7795         See Also\n7796         --------\n7797         numpy.polyfit\n7798         numpy.polyval\n7799         xarray.polyval\n7800         \"\"\"\n7801         from xarray.core.dataarray import DataArray\n7802 \n7803         variables = {}\n7804         skipna_da = skipna\n7805 \n7806         x = get_clean_interp_index(self, dim, strict=False)\n7807         xname = f\"{self[dim].name}_\"\n7808         order = int(deg) + 1\n7809         lhs = np.vander(x, order)\n7810 \n7811         if rcond is None:\n7812             rcond = (\n7813                 x.shape[0] * np.core.finfo(x.dtype).eps  # type: ignore[attr-defined]\n7814             )\n7815 \n7816         # Weights:\n7817         if w is not None:\n7818             if isinstance(w, Hashable):\n7819                 w = self.coords[w]\n7820             w = np.asarray(w)\n7821             if w.ndim != 1:\n7822                 raise TypeError(\"Expected a 1-d array for weights.\")\n7823             if w.shape[0] != lhs.shape[0]:\n7824                 raise TypeError(f\"Expected w and {dim} to have the same length\")\n7825             lhs *= w[:, np.newaxis]\n7826 \n7827         # Scaling\n7828         scale = np.sqrt((lhs * lhs).sum(axis=0))\n7829         lhs /= scale\n7830 \n7831         degree_dim = utils.get_temp_dimname(self.dims, \"degree\")\n7832 \n7833         rank = np.linalg.matrix_rank(lhs)\n7834 \n7835         if full:\n7836             rank = DataArray(rank, name=xname + \"matrix_rank\")\n7837             variables[rank.name] = rank\n7838             _sing = np.linalg.svd(lhs, compute_uv=False)\n7839             sing = DataArray(\n7840                 _sing,\n7841                 dims=(degree_dim,),\n7842                 coords={degree_dim: np.arange(rank - 1, -1, -1)},\n7843                 name=xname + \"singular_values\",\n7844             )\n7845             variables[sing.name] = sing\n7846 \n7847         for name, da in self.data_vars.items():\n7848             if dim not in da.dims:\n7849                 continue\n7850 \n7851             if is_duck_dask_array(da.data) and (\n7852                 rank != order or full or skipna is None\n7853             ):\n7854                 # Current algorithm with dask and skipna=False neither supports\n7855                 # deficient ranks nor does it output the \"full\" info (issue dask/dask#6516)\n7856                 skipna_da = True\n7857             elif skipna is None:\n7858                 skipna_da = bool(np.any(da.isnull()))\n7859 \n7860             dims_to_stack = [dimname for dimname in da.dims if dimname != dim]\n7861             stacked_coords: dict[Hashable, DataArray] = {}\n7862             if dims_to_stack:\n7863                 stacked_dim = utils.get_temp_dimname(dims_to_stack, \"stacked\")\n7864                 rhs = da.transpose(dim, *dims_to_stack).stack(\n7865                     {stacked_dim: dims_to_stack}\n7866                 )\n7867                 stacked_coords = {stacked_dim: rhs[stacked_dim]}\n7868                 scale_da = scale[:, np.newaxis]\n7869             else:\n7870                 rhs = da\n7871                 scale_da = scale\n7872 \n7873             if w is not None:\n7874                 rhs *= w[:, np.newaxis]\n7875 \n7876             with warnings.catch_warnings():\n7877                 if full:  # Copy np.polyfit behavior\n7878                     warnings.simplefilter(\"ignore\", np.RankWarning)\n7879                 else:  # Raise only once per variable\n7880                     warnings.simplefilter(\"once\", np.RankWarning)\n7881 \n7882                 coeffs, residuals = duck_array_ops.least_squares(\n7883                     lhs, rhs.data, rcond=rcond, skipna=skipna_da\n7884                 )\n7885 \n7886             if isinstance(name, str):\n7887                 name = f\"{name}_\"\n7888             else:\n7889                 # Thus a ReprObject => polyfit was called on a DataArray\n7890                 name = \"\"\n7891 \n7892             coeffs = DataArray(\n7893                 coeffs / scale_da,\n7894                 dims=[degree_dim] + list(stacked_coords.keys()),\n7895                 coords={degree_dim: np.arange(order)[::-1], **stacked_coords},\n7896                 name=name + \"polyfit_coefficients\",\n7897             )\n7898             if dims_to_stack:\n7899                 coeffs = coeffs.unstack(stacked_dim)\n7900             variables[coeffs.name] = coeffs\n7901 \n7902             if full or (cov is True):\n7903                 residuals = DataArray(\n7904                     residuals if dims_to_stack else residuals.squeeze(),\n7905                     dims=list(stacked_coords.keys()),\n7906                     coords=stacked_coords,\n7907                     name=name + \"polyfit_residuals\",\n7908                 )\n7909                 if dims_to_stack:\n7910                     residuals = residuals.unstack(stacked_dim)\n7911                 variables[residuals.name] = residuals\n7912 \n7913             if cov:\n7914                 Vbase = np.linalg.inv(np.dot(lhs.T, lhs))\n7915                 Vbase /= np.outer(scale, scale)\n7916                 if cov == \"unscaled\":\n7917                     fac = 1\n7918                 else:\n7919                     if x.shape[0] <= order:\n7920                         raise ValueError(\n7921                             \"The number of data points must exceed order to scale the covariance matrix.\"\n7922                         )\n7923                     fac = residuals / (x.shape[0] - order)\n7924                 covariance = DataArray(Vbase, dims=(\"cov_i\", \"cov_j\")) * fac\n7925                 variables[name + \"polyfit_covariance\"] = covariance\n7926 \n7927         return type(self)(data_vars=variables, attrs=self.attrs.copy())\n7928 \n7929     def pad(\n7930         self: T_Dataset,\n7931         pad_width: Mapping[Any, int | tuple[int, int]] | None = None,\n7932         mode: PadModeOptions = \"constant\",\n7933         stat_length: int\n7934         | tuple[int, int]\n7935         | Mapping[Any, tuple[int, int]]\n7936         | None = None,\n7937         constant_values: (\n7938             float | tuple[float, float] | Mapping[Any, tuple[float, float]] | None\n7939         ) = None,\n7940         end_values: int | tuple[int, int] | Mapping[Any, tuple[int, int]] | None = None,\n7941         reflect_type: PadReflectOptions = None,\n7942         keep_attrs: bool | None = None,\n7943         **pad_width_kwargs: Any,\n7944     ) -> T_Dataset:\n7945         \"\"\"Pad this dataset along one or more dimensions.\n7946 \n7947         .. warning::\n7948             This function is experimental and its behaviour is likely to change\n7949             especially regarding padding of dimension coordinates (or IndexVariables).\n7950 \n7951         When using one of the modes (\"edge\", \"reflect\", \"symmetric\", \"wrap\"),\n7952         coordinates will be padded with the same mode, otherwise coordinates\n7953         are padded using the \"constant\" mode with fill_value dtypes.NA.\n7954 \n7955         Parameters\n7956         ----------\n7957         pad_width : mapping of hashable to tuple of int\n7958             Mapping with the form of {dim: (pad_before, pad_after)}\n7959             describing the number of values padded along each dimension.\n7960             {dim: pad} is a shortcut for pad_before = pad_after = pad\n7961         mode : {\"constant\", \"edge\", \"linear_ramp\", \"maximum\", \"mean\", \"median\", \\\n7962             \"minimum\", \"reflect\", \"symmetric\", \"wrap\"}, default: \"constant\"\n7963             How to pad the DataArray (taken from numpy docs):\n7964 \n7965             - \"constant\": Pads with a constant value.\n7966             - \"edge\": Pads with the edge values of array.\n7967             - \"linear_ramp\": Pads with the linear ramp between end_value and the\n7968               array edge value.\n7969             - \"maximum\": Pads with the maximum value of all or part of the\n7970               vector along each axis.\n7971             - \"mean\": Pads with the mean value of all or part of the\n7972               vector along each axis.\n7973             - \"median\": Pads with the median value of all or part of the\n7974               vector along each axis.\n7975             - \"minimum\": Pads with the minimum value of all or part of the\n7976               vector along each axis.\n7977             - \"reflect\": Pads with the reflection of the vector mirrored on\n7978               the first and last values of the vector along each axis.\n7979             - \"symmetric\": Pads with the reflection of the vector mirrored\n7980               along the edge of the array.\n7981             - \"wrap\": Pads with the wrap of the vector along the axis.\n7982               The first values are used to pad the end and the\n7983               end values are used to pad the beginning.\n7984 \n7985         stat_length : int, tuple or mapping of hashable to tuple, default: None\n7986             Used in 'maximum', 'mean', 'median', and 'minimum'.  Number of\n7987             values at edge of each axis used to calculate the statistic value.\n7988             {dim_1: (before_1, after_1), ... dim_N: (before_N, after_N)} unique\n7989             statistic lengths along each dimension.\n7990             ((before, after),) yields same before and after statistic lengths\n7991             for each dimension.\n7992             (stat_length,) or int is a shortcut for before = after = statistic\n7993             length for all axes.\n7994             Default is ``None``, to use the entire axis.\n7995         constant_values : scalar, tuple or mapping of hashable to tuple, default: 0\n7996             Used in 'constant'.  The values to set the padded values for each\n7997             axis.\n7998             ``{dim_1: (before_1, after_1), ... dim_N: (before_N, after_N)}`` unique\n7999             pad constants along each dimension.\n8000             ``((before, after),)`` yields same before and after constants for each\n8001             dimension.\n8002             ``(constant,)`` or ``constant`` is a shortcut for ``before = after = constant`` for\n8003             all dimensions.\n8004             Default is 0.\n8005         end_values : scalar, tuple or mapping of hashable to tuple, default: 0\n8006             Used in 'linear_ramp'.  The values used for the ending value of the\n8007             linear_ramp and that will form the edge of the padded array.\n8008             ``{dim_1: (before_1, after_1), ... dim_N: (before_N, after_N)}`` unique\n8009             end values along each dimension.\n8010             ``((before, after),)`` yields same before and after end values for each\n8011             axis.\n8012             ``(constant,)`` or ``constant`` is a shortcut for ``before = after = constant`` for\n8013             all axes.\n8014             Default is 0.\n8015         reflect_type : {\"even\", \"odd\", None}, optional\n8016             Used in \"reflect\", and \"symmetric\".  The \"even\" style is the\n8017             default with an unaltered reflection around the edge value.  For\n8018             the \"odd\" style, the extended part of the array is created by\n8019             subtracting the reflected values from two times the edge value.\n8020         keep_attrs : bool or None, optional\n8021             If True, the attributes (``attrs``) will be copied from the\n8022             original object to the new one. If False, the new object\n8023             will be returned without attributes.\n8024         **pad_width_kwargs\n8025             The keyword arguments form of ``pad_width``.\n8026             One of ``pad_width`` or ``pad_width_kwargs`` must be provided.\n8027 \n8028         Returns\n8029         -------\n8030         padded : Dataset\n8031             Dataset with the padded coordinates and data.\n8032 \n8033         See Also\n8034         --------\n8035         Dataset.shift, Dataset.roll, Dataset.bfill, Dataset.ffill, numpy.pad, dask.array.pad\n8036 \n8037         Notes\n8038         -----\n8039         By default when ``mode=\"constant\"`` and ``constant_values=None``, integer types will be\n8040         promoted to ``float`` and padded with ``np.nan``. To avoid type promotion\n8041         specify ``constant_values=np.nan``\n8042 \n8043         Padding coordinates will drop their corresponding index (if any) and will reset default\n8044         indexes for dimension coordinates.\n8045 \n8046         Examples\n8047         --------\n8048         >>> ds = xr.Dataset({\"foo\": (\"x\", range(5))})\n8049         >>> ds.pad(x=(1, 2))\n8050         <xarray.Dataset>\n8051         Dimensions:  (x: 8)\n8052         Dimensions without coordinates: x\n8053         Data variables:\n8054             foo      (x) float64 nan 0.0 1.0 2.0 3.0 4.0 nan nan\n8055         \"\"\"\n8056         pad_width = either_dict_or_kwargs(pad_width, pad_width_kwargs, \"pad\")\n8057 \n8058         if mode in (\"edge\", \"reflect\", \"symmetric\", \"wrap\"):\n8059             coord_pad_mode = mode\n8060             coord_pad_options = {\n8061                 \"stat_length\": stat_length,\n8062                 \"constant_values\": constant_values,\n8063                 \"end_values\": end_values,\n8064                 \"reflect_type\": reflect_type,\n8065             }\n8066         else:\n8067             coord_pad_mode = \"constant\"\n8068             coord_pad_options = {}\n8069 \n8070         if keep_attrs is None:\n8071             keep_attrs = _get_keep_attrs(default=True)\n8072 \n8073         variables = {}\n8074 \n8075         # keep indexes that won't be affected by pad and drop all other indexes\n8076         xindexes = self.xindexes\n8077         pad_dims = set(pad_width)\n8078         indexes = {}\n8079         for k, idx in xindexes.items():\n8080             if not pad_dims.intersection(xindexes.get_all_dims(k)):\n8081                 indexes[k] = idx\n8082 \n8083         for name, var in self.variables.items():\n8084             var_pad_width = {k: v for k, v in pad_width.items() if k in var.dims}\n8085             if not var_pad_width:\n8086                 variables[name] = var\n8087             elif name in self.data_vars:\n8088                 variables[name] = var.pad(\n8089                     pad_width=var_pad_width,\n8090                     mode=mode,\n8091                     stat_length=stat_length,\n8092                     constant_values=constant_values,\n8093                     end_values=end_values,\n8094                     reflect_type=reflect_type,\n8095                     keep_attrs=keep_attrs,\n8096                 )\n8097             else:\n8098                 variables[name] = var.pad(\n8099                     pad_width=var_pad_width,\n8100                     mode=coord_pad_mode,\n8101                     keep_attrs=keep_attrs,\n8102                     **coord_pad_options,  # type: ignore[arg-type]\n8103                 )\n8104                 # reset default index of dimension coordinates\n8105                 if (name,) == var.dims:\n8106                     dim_var = {name: variables[name]}\n8107                     index = PandasIndex.from_variables(dim_var, options={})\n8108                     index_vars = index.create_variables(dim_var)\n8109                     indexes[name] = index\n8110                     variables[name] = index_vars[name]\n8111 \n8112         attrs = self._attrs if keep_attrs else None\n8113         return self._replace_with_new_dims(variables, indexes=indexes, attrs=attrs)\n8114 \n8115     def idxmin(\n8116         self: T_Dataset,\n8117         dim: Hashable | None = None,\n8118         skipna: bool | None = None,\n8119         fill_value: Any = xrdtypes.NA,\n8120         keep_attrs: bool | None = None,\n8121     ) -> T_Dataset:\n8122         \"\"\"Return the coordinate label of the minimum value along a dimension.\n8123 \n8124         Returns a new `Dataset` named after the dimension with the values of\n8125         the coordinate labels along that dimension corresponding to minimum\n8126         values along that dimension.\n8127 \n8128         In comparison to :py:meth:`~Dataset.argmin`, this returns the\n8129         coordinate label while :py:meth:`~Dataset.argmin` returns the index.\n8130 \n8131         Parameters\n8132         ----------\n8133         dim : Hashable, optional\n8134             Dimension over which to apply `idxmin`.  This is optional for 1D\n8135             variables, but required for variables with 2 or more dimensions.\n8136         skipna : bool or None, optional\n8137             If True, skip missing values (as marked by NaN). By default, only\n8138             skips missing values for ``float``, ``complex``, and ``object``\n8139             dtypes; other dtypes either do not have a sentinel missing value\n8140             (``int``) or ``skipna=True`` has not been implemented\n8141             (``datetime64`` or ``timedelta64``).\n8142         fill_value : Any, default: NaN\n8143             Value to be filled in case all of the values along a dimension are\n8144             null.  By default this is NaN.  The fill value and result are\n8145             automatically converted to a compatible dtype if possible.\n8146             Ignored if ``skipna`` is False.\n8147         keep_attrs : bool or None, optional\n8148             If True, the attributes (``attrs``) will be copied from the\n8149             original object to the new one. If False, the new object\n8150             will be returned without attributes.\n8151 \n8152         Returns\n8153         -------\n8154         reduced : Dataset\n8155             New `Dataset` object with `idxmin` applied to its data and the\n8156             indicated dimension removed.\n8157 \n8158         See Also\n8159         --------\n8160         DataArray.idxmin, Dataset.idxmax, Dataset.min, Dataset.argmin\n8161 \n8162         Examples\n8163         --------\n8164         >>> array1 = xr.DataArray(\n8165         ...     [0, 2, 1, 0, -2], dims=\"x\", coords={\"x\": [\"a\", \"b\", \"c\", \"d\", \"e\"]}\n8166         ... )\n8167         >>> array2 = xr.DataArray(\n8168         ...     [\n8169         ...         [2.0, 1.0, 2.0, 0.0, -2.0],\n8170         ...         [-4.0, np.NaN, 2.0, np.NaN, -2.0],\n8171         ...         [np.NaN, np.NaN, 1.0, np.NaN, np.NaN],\n8172         ...     ],\n8173         ...     dims=[\"y\", \"x\"],\n8174         ...     coords={\"y\": [-1, 0, 1], \"x\": [\"a\", \"b\", \"c\", \"d\", \"e\"]},\n8175         ... )\n8176         >>> ds = xr.Dataset({\"int\": array1, \"float\": array2})\n8177         >>> ds.min(dim=\"x\")\n8178         <xarray.Dataset>\n8179         Dimensions:  (y: 3)\n8180         Coordinates:\n8181           * y        (y) int64 -1 0 1\n8182         Data variables:\n8183             int      int64 -2\n8184             float    (y) float64 -2.0 -4.0 1.0\n8185         >>> ds.argmin(dim=\"x\")\n8186         <xarray.Dataset>\n8187         Dimensions:  (y: 3)\n8188         Coordinates:\n8189           * y        (y) int64 -1 0 1\n8190         Data variables:\n8191             int      int64 4\n8192             float    (y) int64 4 0 2\n8193         >>> ds.idxmin(dim=\"x\")\n8194         <xarray.Dataset>\n8195         Dimensions:  (y: 3)\n8196         Coordinates:\n8197           * y        (y) int64 -1 0 1\n8198         Data variables:\n8199             int      <U1 'e'\n8200             float    (y) object 'e' 'a' 'c'\n8201         \"\"\"\n8202         return self.map(\n8203             methodcaller(\n8204                 \"idxmin\",\n8205                 dim=dim,\n8206                 skipna=skipna,\n8207                 fill_value=fill_value,\n8208                 keep_attrs=keep_attrs,\n8209             )\n8210         )\n8211 \n8212     def idxmax(\n8213         self: T_Dataset,\n8214         dim: Hashable | None = None,\n8215         skipna: bool | None = None,\n8216         fill_value: Any = xrdtypes.NA,\n8217         keep_attrs: bool | None = None,\n8218     ) -> T_Dataset:\n8219         \"\"\"Return the coordinate label of the maximum value along a dimension.\n8220 \n8221         Returns a new `Dataset` named after the dimension with the values of\n8222         the coordinate labels along that dimension corresponding to maximum\n8223         values along that dimension.\n8224 \n8225         In comparison to :py:meth:`~Dataset.argmax`, this returns the\n8226         coordinate label while :py:meth:`~Dataset.argmax` returns the index.\n8227 \n8228         Parameters\n8229         ----------\n8230         dim : str, optional\n8231             Dimension over which to apply `idxmax`.  This is optional for 1D\n8232             variables, but required for variables with 2 or more dimensions.\n8233         skipna : bool or None, optional\n8234             If True, skip missing values (as marked by NaN). By default, only\n8235             skips missing values for ``float``, ``complex``, and ``object``\n8236             dtypes; other dtypes either do not have a sentinel missing value\n8237             (``int``) or ``skipna=True`` has not been implemented\n8238             (``datetime64`` or ``timedelta64``).\n8239         fill_value : Any, default: NaN\n8240             Value to be filled in case all of the values along a dimension are\n8241             null.  By default this is NaN.  The fill value and result are\n8242             automatically converted to a compatible dtype if possible.\n8243             Ignored if ``skipna`` is False.\n8244         keep_attrs : bool or None, optional\n8245             If True, the attributes (``attrs``) will be copied from the\n8246             original object to the new one. If False, the new object\n8247             will be returned without attributes.\n8248 \n8249         Returns\n8250         -------\n8251         reduced : Dataset\n8252             New `Dataset` object with `idxmax` applied to its data and the\n8253             indicated dimension removed.\n8254 \n8255         See Also\n8256         --------\n8257         DataArray.idxmax, Dataset.idxmin, Dataset.max, Dataset.argmax\n8258 \n8259         Examples\n8260         --------\n8261         >>> array1 = xr.DataArray(\n8262         ...     [0, 2, 1, 0, -2], dims=\"x\", coords={\"x\": [\"a\", \"b\", \"c\", \"d\", \"e\"]}\n8263         ... )\n8264         >>> array2 = xr.DataArray(\n8265         ...     [\n8266         ...         [2.0, 1.0, 2.0, 0.0, -2.0],\n8267         ...         [-4.0, np.NaN, 2.0, np.NaN, -2.0],\n8268         ...         [np.NaN, np.NaN, 1.0, np.NaN, np.NaN],\n8269         ...     ],\n8270         ...     dims=[\"y\", \"x\"],\n8271         ...     coords={\"y\": [-1, 0, 1], \"x\": [\"a\", \"b\", \"c\", \"d\", \"e\"]},\n8272         ... )\n8273         >>> ds = xr.Dataset({\"int\": array1, \"float\": array2})\n8274         >>> ds.max(dim=\"x\")\n8275         <xarray.Dataset>\n8276         Dimensions:  (y: 3)\n8277         Coordinates:\n8278           * y        (y) int64 -1 0 1\n8279         Data variables:\n8280             int      int64 2\n8281             float    (y) float64 2.0 2.0 1.0\n8282         >>> ds.argmax(dim=\"x\")\n8283         <xarray.Dataset>\n8284         Dimensions:  (y: 3)\n8285         Coordinates:\n8286           * y        (y) int64 -1 0 1\n8287         Data variables:\n8288             int      int64 1\n8289             float    (y) int64 0 2 2\n8290         >>> ds.idxmax(dim=\"x\")\n8291         <xarray.Dataset>\n8292         Dimensions:  (y: 3)\n8293         Coordinates:\n8294           * y        (y) int64 -1 0 1\n8295         Data variables:\n8296             int      <U1 'b'\n8297             float    (y) object 'a' 'c' 'c'\n8298         \"\"\"\n8299         return self.map(\n8300             methodcaller(\n8301                 \"idxmax\",\n8302                 dim=dim,\n8303                 skipna=skipna,\n8304                 fill_value=fill_value,\n8305                 keep_attrs=keep_attrs,\n8306             )\n8307         )\n8308 \n8309     def argmin(self: T_Dataset, dim: Hashable | None = None, **kwargs) -> T_Dataset:\n8310         \"\"\"Indices of the minima of the member variables.\n8311 \n8312         If there are multiple minima, the indices of the first one found will be\n8313         returned.\n8314 \n8315         Parameters\n8316         ----------\n8317         dim : Hashable, optional\n8318             The dimension over which to find the minimum. By default, finds minimum over\n8319             all dimensions - for now returning an int for backward compatibility, but\n8320             this is deprecated, in future will be an error, since DataArray.argmin will\n8321             return a dict with indices for all dimensions, which does not make sense for\n8322             a Dataset.\n8323         keep_attrs : bool, optional\n8324             If True, the attributes (`attrs`) will be copied from the original\n8325             object to the new one.  If False (default), the new object will be\n8326             returned without attributes.\n8327         skipna : bool, optional\n8328             If True, skip missing values (as marked by NaN). By default, only\n8329             skips missing values for float dtypes; other dtypes either do not\n8330             have a sentinel missing value (int) or skipna=True has not been\n8331             implemented (object, datetime64 or timedelta64).\n8332 \n8333         Returns\n8334         -------\n8335         result : Dataset\n8336 \n8337         See Also\n8338         --------\n8339         DataArray.argmin\n8340         \"\"\"\n8341         if dim is None:\n8342             warnings.warn(\n8343                 \"Once the behaviour of DataArray.argmin() and Variable.argmin() without \"\n8344                 \"dim changes to return a dict of indices of each dimension, for \"\n8345                 \"consistency it will be an error to call Dataset.argmin() with no argument,\"\n8346                 \"since we don't return a dict of Datasets.\",\n8347                 DeprecationWarning,\n8348                 stacklevel=2,\n8349             )\n8350         if (\n8351             dim is None\n8352             or (not isinstance(dim, Sequence) and dim is not ...)\n8353             or isinstance(dim, str)\n8354         ):\n8355             # Return int index if single dimension is passed, and is not part of a\n8356             # sequence\n8357             argmin_func = getattr(duck_array_ops, \"argmin\")\n8358             return self.reduce(\n8359                 argmin_func, dim=None if dim is None else [dim], **kwargs\n8360             )\n8361         else:\n8362             raise ValueError(\n8363                 \"When dim is a sequence or ..., DataArray.argmin() returns a dict. \"\n8364                 \"dicts cannot be contained in a Dataset, so cannot call \"\n8365                 \"Dataset.argmin() with a sequence or ... for dim\"\n8366             )\n8367 \n8368     def argmax(self: T_Dataset, dim: Hashable | None = None, **kwargs) -> T_Dataset:\n8369         \"\"\"Indices of the maxima of the member variables.\n8370 \n8371         If there are multiple maxima, the indices of the first one found will be\n8372         returned.\n8373 \n8374         Parameters\n8375         ----------\n8376         dim : str, optional\n8377             The dimension over which to find the maximum. By default, finds maximum over\n8378             all dimensions - for now returning an int for backward compatibility, but\n8379             this is deprecated, in future will be an error, since DataArray.argmax will\n8380             return a dict with indices for all dimensions, which does not make sense for\n8381             a Dataset.\n8382         keep_attrs : bool, optional\n8383             If True, the attributes (`attrs`) will be copied from the original\n8384             object to the new one.  If False (default), the new object will be\n8385             returned without attributes.\n8386         skipna : bool, optional\n8387             If True, skip missing values (as marked by NaN). By default, only\n8388             skips missing values for float dtypes; other dtypes either do not\n8389             have a sentinel missing value (int) or skipna=True has not been\n8390             implemented (object, datetime64 or timedelta64).\n8391 \n8392         Returns\n8393         -------\n8394         result : Dataset\n8395 \n8396         See Also\n8397         --------\n8398         DataArray.argmax\n8399 \n8400         \"\"\"\n8401         if dim is None:\n8402             warnings.warn(\n8403                 \"Once the behaviour of DataArray.argmin() and Variable.argmin() without \"\n8404                 \"dim changes to return a dict of indices of each dimension, for \"\n8405                 \"consistency it will be an error to call Dataset.argmin() with no argument,\"\n8406                 \"since we don't return a dict of Datasets.\",\n8407                 DeprecationWarning,\n8408                 stacklevel=2,\n8409             )\n8410         if (\n8411             dim is None\n8412             or (not isinstance(dim, Sequence) and dim is not ...)\n8413             or isinstance(dim, str)\n8414         ):\n8415             # Return int index if single dimension is passed, and is not part of a\n8416             # sequence\n8417             argmax_func = getattr(duck_array_ops, \"argmax\")\n8418             return self.reduce(\n8419                 argmax_func, dim=None if dim is None else [dim], **kwargs\n8420             )\n8421         else:\n8422             raise ValueError(\n8423                 \"When dim is a sequence or ..., DataArray.argmin() returns a dict. \"\n8424                 \"dicts cannot be contained in a Dataset, so cannot call \"\n8425                 \"Dataset.argmin() with a sequence or ... for dim\"\n8426             )\n8427 \n8428     def query(\n8429         self: T_Dataset,\n8430         queries: Mapping[Any, Any] | None = None,\n8431         parser: QueryParserOptions = \"pandas\",\n8432         engine: QueryEngineOptions = None,\n8433         missing_dims: ErrorOptionsWithWarn = \"raise\",\n8434         **queries_kwargs: Any,\n8435     ) -> T_Dataset:\n8436         \"\"\"Return a new dataset with each array indexed along the specified\n8437         dimension(s), where the indexers are given as strings containing\n8438         Python expressions to be evaluated against the data variables in the\n8439         dataset.\n8440 \n8441         Parameters\n8442         ----------\n8443         queries : dict-like, optional\n8444             A dict-like with keys matching dimensions and values given by strings\n8445             containing Python expressions to be evaluated against the data variables\n8446             in the dataset. The expressions will be evaluated using the pandas\n8447             eval() function, and can contain any valid Python expressions but cannot\n8448             contain any Python statements.\n8449         parser : {\"pandas\", \"python\"}, default: \"pandas\"\n8450             The parser to use to construct the syntax tree from the expression.\n8451             The default of 'pandas' parses code slightly different than standard\n8452             Python. Alternatively, you can parse an expression using the 'python'\n8453             parser to retain strict Python semantics.\n8454         engine : {\"python\", \"numexpr\", None}, default: None\n8455             The engine used to evaluate the expression. Supported engines are:\n8456 \n8457             - None: tries to use numexpr, falls back to python\n8458             - \"numexpr\": evaluates expressions using numexpr\n8459             - \"python\": performs operations as if you had eval\u2019d in top level python\n8460 \n8461         missing_dims : {\"raise\", \"warn\", \"ignore\"}, default: \"raise\"\n8462             What to do if dimensions that should be selected from are not present in the\n8463             Dataset:\n8464 \n8465             - \"raise\": raise an exception\n8466             - \"warn\": raise a warning, and ignore the missing dimensions\n8467             - \"ignore\": ignore the missing dimensions\n8468 \n8469         **queries_kwargs : {dim: query, ...}, optional\n8470             The keyword arguments form of ``queries``.\n8471             One of queries or queries_kwargs must be provided.\n8472 \n8473         Returns\n8474         -------\n8475         obj : Dataset\n8476             A new Dataset with the same contents as this dataset, except each\n8477             array and dimension is indexed by the results of the appropriate\n8478             queries.\n8479 \n8480         See Also\n8481         --------\n8482         Dataset.isel\n8483         pandas.eval\n8484 \n8485         Examples\n8486         --------\n8487         >>> a = np.arange(0, 5, 1)\n8488         >>> b = np.linspace(0, 1, 5)\n8489         >>> ds = xr.Dataset({\"a\": (\"x\", a), \"b\": (\"x\", b)})\n8490         >>> ds\n8491         <xarray.Dataset>\n8492         Dimensions:  (x: 5)\n8493         Dimensions without coordinates: x\n8494         Data variables:\n8495             a        (x) int64 0 1 2 3 4\n8496             b        (x) float64 0.0 0.25 0.5 0.75 1.0\n8497         >>> ds.query(x=\"a > 2\")\n8498         <xarray.Dataset>\n8499         Dimensions:  (x: 2)\n8500         Dimensions without coordinates: x\n8501         Data variables:\n8502             a        (x) int64 3 4\n8503             b        (x) float64 0.75 1.0\n8504         \"\"\"\n8505 \n8506         # allow queries to be given either as a dict or as kwargs\n8507         queries = either_dict_or_kwargs(queries, queries_kwargs, \"query\")\n8508 \n8509         # check queries\n8510         for dim, expr in queries.items():\n8511             if not isinstance(expr, str):\n8512                 msg = f\"expr for dim {dim} must be a string to be evaluated, {type(expr)} given\"\n8513                 raise ValueError(msg)\n8514 \n8515         # evaluate the queries to create the indexers\n8516         indexers = {\n8517             dim: pd.eval(expr, resolvers=[self], parser=parser, engine=engine)\n8518             for dim, expr in queries.items()\n8519         }\n8520 \n8521         # apply the selection\n8522         return self.isel(indexers, missing_dims=missing_dims)\n8523 \n8524     def curvefit(\n8525         self: T_Dataset,\n8526         coords: str | DataArray | Iterable[str | DataArray],\n8527         func: Callable[..., Any],\n8528         reduce_dims: Dims = None,\n8529         skipna: bool = True,\n8530         p0: dict[str, Any] | None = None,\n8531         bounds: dict[str, Any] | None = None,\n8532         param_names: Sequence[str] | None = None,\n8533         kwargs: dict[str, Any] | None = None,\n8534     ) -> T_Dataset:\n8535         \"\"\"\n8536         Curve fitting optimization for arbitrary functions.\n8537 \n8538         Wraps `scipy.optimize.curve_fit` with `apply_ufunc`.\n8539 \n8540         Parameters\n8541         ----------\n8542         coords : hashable, DataArray, or sequence of hashable or DataArray\n8543             Independent coordinate(s) over which to perform the curve fitting. Must share\n8544             at least one dimension with the calling object. When fitting multi-dimensional\n8545             functions, supply `coords` as a sequence in the same order as arguments in\n8546             `func`. To fit along existing dimensions of the calling object, `coords` can\n8547             also be specified as a str or sequence of strs.\n8548         func : callable\n8549             User specified function in the form `f(x, *params)` which returns a numpy\n8550             array of length `len(x)`. `params` are the fittable parameters which are optimized\n8551             by scipy curve_fit. `x` can also be specified as a sequence containing multiple\n8552             coordinates, e.g. `f((x0, x1), *params)`.\n8553         reduce_dims : str, Iterable of Hashable or None, optional\n8554             Additional dimension(s) over which to aggregate while fitting. For example,\n8555             calling `ds.curvefit(coords='time', reduce_dims=['lat', 'lon'], ...)` will\n8556             aggregate all lat and lon points and fit the specified function along the\n8557             time dimension.\n8558         skipna : bool, default: True\n8559             Whether to skip missing values when fitting. Default is True.\n8560         p0 : dict-like, optional\n8561             Optional dictionary of parameter names to initial guesses passed to the\n8562             `curve_fit` `p0` arg. If none or only some parameters are passed, the rest will\n8563             be assigned initial values following the default scipy behavior.\n8564         bounds : dict-like, optional\n8565             Optional dictionary of parameter names to bounding values passed to the\n8566             `curve_fit` `bounds` arg. If none or only some parameters are passed, the rest\n8567             will be unbounded following the default scipy behavior.\n8568         param_names : sequence of hashable, optional\n8569             Sequence of names for the fittable parameters of `func`. If not supplied,\n8570             this will be automatically determined by arguments of `func`. `param_names`\n8571             should be manually supplied when fitting a function that takes a variable\n8572             number of parameters.\n8573         **kwargs : optional\n8574             Additional keyword arguments to passed to scipy curve_fit.\n8575 \n8576         Returns\n8577         -------\n8578         curvefit_results : Dataset\n8579             A single dataset which contains:\n8580 \n8581             [var]_curvefit_coefficients\n8582                 The coefficients of the best fit.\n8583             [var]_curvefit_covariance\n8584                 The covariance matrix of the coefficient estimates.\n8585 \n8586         See Also\n8587         --------\n8588         Dataset.polyfit\n8589         scipy.optimize.curve_fit\n8590         \"\"\"\n8591         from scipy.optimize import curve_fit\n8592 \n8593         from xarray.core.alignment import broadcast\n8594         from xarray.core.computation import apply_ufunc\n8595         from xarray.core.dataarray import _THIS_ARRAY, DataArray\n8596 \n8597         if p0 is None:\n8598             p0 = {}\n8599         if bounds is None:\n8600             bounds = {}\n8601         if kwargs is None:\n8602             kwargs = {}\n8603 \n8604         reduce_dims_: list[Hashable]\n8605         if not reduce_dims:\n8606             reduce_dims_ = []\n8607         elif isinstance(reduce_dims, str) or not isinstance(reduce_dims, Iterable):\n8608             reduce_dims_ = [reduce_dims]\n8609         else:\n8610             reduce_dims_ = list(reduce_dims)\n8611 \n8612         if (\n8613             isinstance(coords, str)\n8614             or isinstance(coords, DataArray)\n8615             or not isinstance(coords, Iterable)\n8616         ):\n8617             coords = [coords]\n8618         coords_: Sequence[DataArray] = [\n8619             self[coord] if isinstance(coord, str) else coord for coord in coords\n8620         ]\n8621 \n8622         # Determine whether any coords are dims on self\n8623         for coord in coords_:\n8624             reduce_dims_ += [c for c in self.dims if coord.equals(self[c])]\n8625         reduce_dims_ = list(set(reduce_dims_))\n8626         preserved_dims = list(set(self.dims) - set(reduce_dims_))\n8627         if not reduce_dims_:\n8628             raise ValueError(\n8629                 \"No arguments to `coords` were identified as a dimension on the calling \"\n8630                 \"object, and no dims were supplied to `reduce_dims`. This would result \"\n8631                 \"in fitting on scalar data.\"\n8632             )\n8633 \n8634         # Broadcast all coords with each other\n8635         coords_ = broadcast(*coords_)\n8636         coords_ = [\n8637             coord.broadcast_like(self, exclude=preserved_dims) for coord in coords_\n8638         ]\n8639 \n8640         params, func_args = _get_func_args(func, param_names)\n8641         param_defaults, bounds_defaults = _initialize_curvefit_params(\n8642             params, p0, bounds, func_args\n8643         )\n8644         n_params = len(params)\n8645         kwargs.setdefault(\"p0\", [param_defaults[p] for p in params])\n8646         kwargs.setdefault(\n8647             \"bounds\",\n8648             [\n8649                 [bounds_defaults[p][0] for p in params],\n8650                 [bounds_defaults[p][1] for p in params],\n8651             ],\n8652         )\n8653 \n8654         def _wrapper(Y, *coords_, **kwargs):\n8655             # Wrap curve_fit with raveled coordinates and pointwise NaN handling\n8656             x = np.vstack([c.ravel() for c in coords_])\n8657             y = Y.ravel()\n8658             if skipna:\n8659                 mask = np.all([np.any(~np.isnan(x), axis=0), ~np.isnan(y)], axis=0)\n8660                 x = x[:, mask]\n8661                 y = y[mask]\n8662                 if not len(y):\n8663                     popt = np.full([n_params], np.nan)\n8664                     pcov = np.full([n_params, n_params], np.nan)\n8665                     return popt, pcov\n8666             x = np.squeeze(x)\n8667             popt, pcov = curve_fit(func, x, y, **kwargs)\n8668             return popt, pcov\n8669 \n8670         result = type(self)()\n8671         for name, da in self.data_vars.items():\n8672             if name is _THIS_ARRAY:\n8673                 name = \"\"\n8674             else:\n8675                 name = f\"{str(name)}_\"\n8676 \n8677             popt, pcov = apply_ufunc(\n8678                 _wrapper,\n8679                 da,\n8680                 *coords_,\n8681                 vectorize=True,\n8682                 dask=\"parallelized\",\n8683                 input_core_dims=[reduce_dims_ for d in range(len(coords_) + 1)],\n8684                 output_core_dims=[[\"param\"], [\"cov_i\", \"cov_j\"]],\n8685                 dask_gufunc_kwargs={\n8686                     \"output_sizes\": {\n8687                         \"param\": n_params,\n8688                         \"cov_i\": n_params,\n8689                         \"cov_j\": n_params,\n8690                     },\n8691                 },\n8692                 output_dtypes=(np.float64, np.float64),\n8693                 exclude_dims=set(reduce_dims_),\n8694                 kwargs=kwargs,\n8695             )\n8696             result[name + \"curvefit_coefficients\"] = popt\n8697             result[name + \"curvefit_covariance\"] = pcov\n8698 \n8699         result = result.assign_coords(\n8700             {\"param\": params, \"cov_i\": params, \"cov_j\": params}\n8701         )\n8702         result.attrs = self.attrs.copy()\n8703 \n8704         return result\n8705 \n8706     def drop_duplicates(\n8707         self: T_Dataset,\n8708         dim: Hashable | Iterable[Hashable],\n8709         keep: Literal[\"first\", \"last\", False] = \"first\",\n8710     ) -> T_Dataset:\n8711         \"\"\"Returns a new Dataset with duplicate dimension values removed.\n8712 \n8713         Parameters\n8714         ----------\n8715         dim : dimension label or labels\n8716             Pass `...` to drop duplicates along all dimensions.\n8717         keep : {\"first\", \"last\", False}, default: \"first\"\n8718             Determines which duplicates (if any) to keep.\n8719             - ``\"first\"`` : Drop duplicates except for the first occurrence.\n8720             - ``\"last\"`` : Drop duplicates except for the last occurrence.\n8721             - False : Drop all duplicates.\n8722 \n8723         Returns\n8724         -------\n8725         Dataset\n8726 \n8727         See Also\n8728         --------\n8729         DataArray.drop_duplicates\n8730         \"\"\"\n8731         if isinstance(dim, str):\n8732             dims: Iterable = (dim,)\n8733         elif dim is ...:\n8734             dims = self.dims\n8735         elif not isinstance(dim, Iterable):\n8736             dims = [dim]\n8737         else:\n8738             dims = dim\n8739 \n8740         missing_dims = set(dims) - set(self.dims)\n8741         if missing_dims:\n8742             raise ValueError(f\"'{missing_dims}' not found in dimensions\")\n8743 \n8744         indexes = {dim: ~self.get_index(dim).duplicated(keep=keep) for dim in dims}\n8745         return self.isel(indexes)\n8746 \n8747     def convert_calendar(\n8748         self: T_Dataset,\n8749         calendar: CFCalendar,\n8750         dim: Hashable = \"time\",\n8751         align_on: Literal[\"date\", \"year\", None] = None,\n8752         missing: Any | None = None,\n8753         use_cftime: bool | None = None,\n8754     ) -> T_Dataset:\n8755         \"\"\"Convert the Dataset to another calendar.\n8756 \n8757         Only converts the individual timestamps, does not modify any data except\n8758         in dropping invalid/surplus dates or inserting missing dates.\n8759 \n8760         If the source and target calendars are either no_leap, all_leap or a\n8761         standard type, only the type of the time array is modified.\n8762         When converting to a leap year from a non-leap year, the 29th of February\n8763         is removed from the array. In the other direction the 29th of February\n8764         will be missing in the output, unless `missing` is specified,\n8765         in which case that value is inserted.\n8766 \n8767         For conversions involving `360_day` calendars, see Notes.\n8768 \n8769         This method is safe to use with sub-daily data as it doesn't touch the\n8770         time part of the timestamps.\n8771 \n8772         Parameters\n8773         ---------\n8774         calendar : str\n8775             The target calendar name.\n8776         dim : Hashable, default: \"time\"\n8777             Name of the time coordinate.\n8778         align_on : {None, 'date', 'year'}, optional\n8779             Must be specified when either source or target is a `360_day` calendar,\n8780             ignored otherwise. See Notes.\n8781         missing : Any or None, optional\n8782             By default, i.e. if the value is None, this method will simply attempt\n8783             to convert the dates in the source calendar to the same dates in the\n8784             target calendar, and drop any of those that are not possible to\n8785             represent.  If a value is provided, a new time coordinate will be\n8786             created in the target calendar with the same frequency as the original\n8787             time coordinate; for any dates that are not present in the source, the\n8788             data will be filled with this value.  Note that using this mode requires\n8789             that the source data have an inferable frequency; for more information\n8790             see :py:func:`xarray.infer_freq`.  For certain frequency, source, and\n8791             target calendar combinations, this could result in many missing values, see notes.\n8792         use_cftime : bool or None, optional\n8793             Whether to use cftime objects in the output, only used if `calendar`\n8794             is one of {\"proleptic_gregorian\", \"gregorian\" or \"standard\"}.\n8795             If True, the new time axis uses cftime objects.\n8796             If None (default), it uses :py:class:`numpy.datetime64` values if the\n8797             date range permits it, and :py:class:`cftime.datetime` objects if not.\n8798             If False, it uses :py:class:`numpy.datetime64`  or fails.\n8799 \n8800         Returns\n8801         -------\n8802         Dataset\n8803             Copy of the dataarray with the time coordinate converted to the\n8804             target calendar. If 'missing' was None (default), invalid dates in\n8805             the new calendar are dropped, but missing dates are not inserted.\n8806             If `missing` was given, the new data is reindexed to have a time axis\n8807             with the same frequency as the source, but in the new calendar; any\n8808             missing datapoints are filled with `missing`.\n8809 \n8810         Notes\n8811         -----\n8812         Passing a value to `missing` is only usable if the source's time coordinate as an\n8813         inferable frequencies (see :py:func:`~xarray.infer_freq`) and is only appropriate\n8814         if the target coordinate, generated from this frequency, has dates equivalent to the\n8815         source. It is usually **not** appropriate to use this mode with:\n8816 \n8817         - Period-end frequencies : 'A', 'Y', 'Q' or 'M', in opposition to 'AS' 'YS', 'QS' and 'MS'\n8818         - Sub-monthly frequencies that do not divide a day evenly : 'W', 'nD' where `N != 1`\n8819             or 'mH' where 24 % m != 0).\n8820 \n8821         If one of the source or target calendars is `\"360_day\"`, `align_on` must\n8822         be specified and two options are offered.\n8823 \n8824         - \"year\"\n8825             The dates are translated according to their relative position in the year,\n8826             ignoring their original month and day information, meaning that the\n8827             missing/surplus days are added/removed at regular intervals.\n8828 \n8829             From a `360_day` to a standard calendar, the output will be missing the\n8830             following dates (day of year in parentheses):\n8831 \n8832             To a leap year:\n8833                 January 31st (31), March 31st (91), June 1st (153), July 31st (213),\n8834                 September 31st (275) and November 30th (335).\n8835             To a non-leap year:\n8836                 February 6th (36), April 19th (109), July 2nd (183),\n8837                 September 12th (255), November 25th (329).\n8838 \n8839             From a standard calendar to a `\"360_day\"`, the following dates in the\n8840             source array will be dropped:\n8841 \n8842             From a leap year:\n8843                 January 31st (31), April 1st (92), June 1st (153), August 1st (214),\n8844                 September 31st (275), December 1st (336)\n8845             From a non-leap year:\n8846                 February 6th (37), April 20th (110), July 2nd (183),\n8847                 September 13th (256), November 25th (329)\n8848 \n8849             This option is best used on daily and subdaily data.\n8850 \n8851         - \"date\"\n8852             The month/day information is conserved and invalid dates are dropped\n8853             from the output. This means that when converting from a `\"360_day\"` to a\n8854             standard calendar, all 31st (Jan, March, May, July, August, October and\n8855             December) will be missing as there is no equivalent dates in the\n8856             `\"360_day\"` calendar and the 29th (on non-leap years) and 30th of February\n8857             will be dropped as there are no equivalent dates in a standard calendar.\n8858 \n8859             This option is best used with data on a frequency coarser than daily.\n8860         \"\"\"\n8861         return convert_calendar(\n8862             self,\n8863             calendar,\n8864             dim=dim,\n8865             align_on=align_on,\n8866             missing=missing,\n8867             use_cftime=use_cftime,\n8868         )\n8869 \n8870     def interp_calendar(\n8871         self: T_Dataset,\n8872         target: pd.DatetimeIndex | CFTimeIndex | DataArray,\n8873         dim: Hashable = \"time\",\n8874     ) -> T_Dataset:\n8875         \"\"\"Interpolates the Dataset to another calendar based on decimal year measure.\n8876 \n8877         Each timestamp in `source` and `target` are first converted to their decimal\n8878         year equivalent then `source` is interpolated on the target coordinate.\n8879         The decimal year of a timestamp is its year plus its sub-year component\n8880         converted to the fraction of its year. For example \"2000-03-01 12:00\" is\n8881         2000.1653 in a standard calendar or 2000.16301 in a `\"noleap\"` calendar.\n8882 \n8883         This method should only be used when the time (HH:MM:SS) information of\n8884         time coordinate is not important.\n8885 \n8886         Parameters\n8887         ----------\n8888         target: DataArray or DatetimeIndex or CFTimeIndex\n8889             The target time coordinate of a valid dtype\n8890             (np.datetime64 or cftime objects)\n8891         dim : Hashable, default: \"time\"\n8892             The time coordinate name.\n8893 \n8894         Return\n8895         ------\n8896         DataArray\n8897             The source interpolated on the decimal years of target,\n8898         \"\"\"\n8899         return interp_calendar(self, target, dim=dim)\n8900 \n8901     def groupby(\n8902         self,\n8903         group: Hashable | DataArray | IndexVariable,\n8904         squeeze: bool = True,\n8905         restore_coord_dims: bool = False,\n8906     ) -> DatasetGroupBy:\n8907         \"\"\"Returns a DatasetGroupBy object for performing grouped operations.\n8908 \n8909         Parameters\n8910         ----------\n8911         group : Hashable, DataArray or IndexVariable\n8912             Array whose unique values should be used to group this array. If a\n8913             string, must be the name of a variable contained in this dataset.\n8914         squeeze : bool, default: True\n8915             If \"group\" is a dimension of any arrays in this dataset, `squeeze`\n8916             controls whether the subarrays have a dimension of length 1 along\n8917             that dimension or if the dimension is squeezed out.\n8918         restore_coord_dims : bool, default: False\n8919             If True, also restore the dimension order of multi-dimensional\n8920             coordinates.\n8921 \n8922         Returns\n8923         -------\n8924         grouped : DatasetGroupBy\n8925             A `DatasetGroupBy` object patterned after `pandas.GroupBy` that can be\n8926             iterated over in the form of `(unique_value, grouped_array)` pairs.\n8927 \n8928         See Also\n8929         --------\n8930         Dataset.groupby_bins\n8931         DataArray.groupby\n8932         core.groupby.DatasetGroupBy\n8933         pandas.DataFrame.groupby\n8934         \"\"\"\n8935         from xarray.core.groupby import DatasetGroupBy\n8936 \n8937         # While we don't generally check the type of every arg, passing\n8938         # multiple dimensions as multiple arguments is common enough, and the\n8939         # consequences hidden enough (strings evaluate as true) to warrant\n8940         # checking here.\n8941         # A future version could make squeeze kwarg only, but would face\n8942         # backward-compat issues.\n8943         if not isinstance(squeeze, bool):\n8944             raise TypeError(\n8945                 f\"`squeeze` must be True or False, but {squeeze} was supplied\"\n8946             )\n8947 \n8948         return DatasetGroupBy(\n8949             self, group, squeeze=squeeze, restore_coord_dims=restore_coord_dims\n8950         )\n8951 \n8952     def groupby_bins(\n8953         self,\n8954         group: Hashable | DataArray | IndexVariable,\n8955         bins: ArrayLike,\n8956         right: bool = True,\n8957         labels: ArrayLike | None = None,\n8958         precision: int = 3,\n8959         include_lowest: bool = False,\n8960         squeeze: bool = True,\n8961         restore_coord_dims: bool = False,\n8962     ) -> DatasetGroupBy:\n8963         \"\"\"Returns a DatasetGroupBy object for performing grouped operations.\n8964 \n8965         Rather than using all unique values of `group`, the values are discretized\n8966         first by applying `pandas.cut` [1]_ to `group`.\n8967 \n8968         Parameters\n8969         ----------\n8970         group : Hashable, DataArray or IndexVariable\n8971             Array whose binned values should be used to group this array. If a\n8972             string, must be the name of a variable contained in this dataset.\n8973         bins : int or array-like\n8974             If bins is an int, it defines the number of equal-width bins in the\n8975             range of x. However, in this case, the range of x is extended by .1%\n8976             on each side to include the min or max values of x. If bins is a\n8977             sequence it defines the bin edges allowing for non-uniform bin\n8978             width. No extension of the range of x is done in this case.\n8979         right : bool, default: True\n8980             Indicates whether the bins include the rightmost edge or not. If\n8981             right == True (the default), then the bins [1,2,3,4] indicate\n8982             (1,2], (2,3], (3,4].\n8983         labels : array-like or bool, default: None\n8984             Used as labels for the resulting bins. Must be of the same length as\n8985             the resulting bins. If False, string bin labels are assigned by\n8986             `pandas.cut`.\n8987         precision : int, default: 3\n8988             The precision at which to store and display the bins labels.\n8989         include_lowest : bool, default: False\n8990             Whether the first interval should be left-inclusive or not.\n8991         squeeze : bool, default: True\n8992             If \"group\" is a dimension of any arrays in this dataset, `squeeze`\n8993             controls whether the subarrays have a dimension of length 1 along\n8994             that dimension or if the dimension is squeezed out.\n8995         restore_coord_dims : bool, default: False\n8996             If True, also restore the dimension order of multi-dimensional\n8997             coordinates.\n8998 \n8999         Returns\n9000         -------\n9001         grouped : DatasetGroupBy\n9002             A `DatasetGroupBy` object patterned after `pandas.GroupBy` that can be\n9003             iterated over in the form of `(unique_value, grouped_array)` pairs.\n9004             The name of the group has the added suffix `_bins` in order to\n9005             distinguish it from the original variable.\n9006 \n9007         See Also\n9008         --------\n9009         Dataset.groupby\n9010         DataArray.groupby_bins\n9011         core.groupby.DatasetGroupBy\n9012         pandas.DataFrame.groupby\n9013 \n9014         References\n9015         ----------\n9016         .. [1] http://pandas.pydata.org/pandas-docs/stable/generated/pandas.cut.html\n9017         \"\"\"\n9018         from xarray.core.groupby import DatasetGroupBy\n9019 \n9020         return DatasetGroupBy(\n9021             self,\n9022             group,\n9023             squeeze=squeeze,\n9024             bins=bins,\n9025             restore_coord_dims=restore_coord_dims,\n9026             cut_kwargs={\n9027                 \"right\": right,\n9028                 \"labels\": labels,\n9029                 \"precision\": precision,\n9030                 \"include_lowest\": include_lowest,\n9031             },\n9032         )\n9033 \n9034     def weighted(self, weights: DataArray) -> DatasetWeighted:\n9035         \"\"\"\n9036         Weighted Dataset operations.\n9037 \n9038         Parameters\n9039         ----------\n9040         weights : DataArray\n9041             An array of weights associated with the values in this Dataset.\n9042             Each value in the data contributes to the reduction operation\n9043             according to its associated weight.\n9044 \n9045         Notes\n9046         -----\n9047         ``weights`` must be a DataArray and cannot contain missing values.\n9048         Missing values can be replaced by ``weights.fillna(0)``.\n9049 \n9050         Returns\n9051         -------\n9052         core.weighted.DatasetWeighted\n9053 \n9054         See Also\n9055         --------\n9056         DataArray.weighted\n9057         \"\"\"\n9058         from xarray.core.weighted import DatasetWeighted\n9059 \n9060         return DatasetWeighted(self, weights)\n9061 \n9062     def rolling(\n9063         self,\n9064         dim: Mapping[Any, int] | None = None,\n9065         min_periods: int | None = None,\n9066         center: bool | Mapping[Any, bool] = False,\n9067         **window_kwargs: int,\n9068     ) -> DatasetRolling:\n9069         \"\"\"\n9070         Rolling window object for Datasets.\n9071 \n9072         Parameters\n9073         ----------\n9074         dim : dict, optional\n9075             Mapping from the dimension name to create the rolling iterator\n9076             along (e.g. `time`) to its moving window size.\n9077         min_periods : int or None, default: None\n9078             Minimum number of observations in window required to have a value\n9079             (otherwise result is NA). The default, None, is equivalent to\n9080             setting min_periods equal to the size of the window.\n9081         center : bool or Mapping to int, default: False\n9082             Set the labels at the center of the window.\n9083         **window_kwargs : optional\n9084             The keyword arguments form of ``dim``.\n9085             One of dim or window_kwargs must be provided.\n9086 \n9087         Returns\n9088         -------\n9089         core.rolling.DatasetRolling\n9090 \n9091         See Also\n9092         --------\n9093         core.rolling.DatasetRolling\n9094         DataArray.rolling\n9095         \"\"\"\n9096         from xarray.core.rolling import DatasetRolling\n9097 \n9098         dim = either_dict_or_kwargs(dim, window_kwargs, \"rolling\")\n9099         return DatasetRolling(self, dim, min_periods=min_periods, center=center)\n9100 \n9101     def coarsen(\n9102         self,\n9103         dim: Mapping[Any, int] | None = None,\n9104         boundary: CoarsenBoundaryOptions = \"exact\",\n9105         side: SideOptions | Mapping[Any, SideOptions] = \"left\",\n9106         coord_func: str | Callable | Mapping[Any, str | Callable] = \"mean\",\n9107         **window_kwargs: int,\n9108     ) -> DatasetCoarsen:\n9109         \"\"\"\n9110         Coarsen object for Datasets.\n9111 \n9112         Parameters\n9113         ----------\n9114         dim : mapping of hashable to int, optional\n9115             Mapping from the dimension name to the window size.\n9116         boundary : {\"exact\", \"trim\", \"pad\"}, default: \"exact\"\n9117             If 'exact', a ValueError will be raised if dimension size is not a\n9118             multiple of the window size. If 'trim', the excess entries are\n9119             dropped. If 'pad', NA will be padded.\n9120         side : {\"left\", \"right\"} or mapping of str to {\"left\", \"right\"}, default: \"left\"\n9121         coord_func : str or mapping of hashable to str, default: \"mean\"\n9122             function (name) that is applied to the coordinates,\n9123             or a mapping from coordinate name to function (name).\n9124 \n9125         Returns\n9126         -------\n9127         core.rolling.DatasetCoarsen\n9128 \n9129         See Also\n9130         --------\n9131         core.rolling.DatasetCoarsen\n9132         DataArray.coarsen\n9133         \"\"\"\n9134         from xarray.core.rolling import DatasetCoarsen\n9135 \n9136         dim = either_dict_or_kwargs(dim, window_kwargs, \"coarsen\")\n9137         return DatasetCoarsen(\n9138             self,\n9139             dim,\n9140             boundary=boundary,\n9141             side=side,\n9142             coord_func=coord_func,\n9143         )\n9144 \n9145     def resample(\n9146         self,\n9147         indexer: Mapping[Any, str] | None = None,\n9148         skipna: bool | None = None,\n9149         closed: SideOptions | None = None,\n9150         label: SideOptions | None = None,\n9151         base: int | None = None,\n9152         offset: pd.Timedelta | datetime.timedelta | str | None = None,\n9153         origin: str | DatetimeLike = \"start_day\",\n9154         keep_attrs: bool | None = None,\n9155         loffset: datetime.timedelta | str | None = None,\n9156         restore_coord_dims: bool | None = None,\n9157         **indexer_kwargs: str,\n9158     ) -> DatasetResample:\n9159         \"\"\"Returns a Resample object for performing resampling operations.\n9160 \n9161         Handles both downsampling and upsampling. The resampled\n9162         dimension must be a datetime-like coordinate. If any intervals\n9163         contain no values from the original object, they will be given\n9164         the value ``NaN``.\n9165 \n9166         Parameters\n9167         ----------\n9168         indexer : Mapping of Hashable to str, optional\n9169             Mapping from the dimension name to resample frequency [1]_. The\n9170             dimension must be datetime-like.\n9171         skipna : bool, optional\n9172             Whether to skip missing values when aggregating in downsampling.\n9173         closed : {\"left\", \"right\"}, optional\n9174             Side of each interval to treat as closed.\n9175         label : {\"left\", \"right\"}, optional\n9176             Side of each interval to use for labeling.\n9177         base : int, optional\n9178             For frequencies that evenly subdivide 1 day, the \"origin\" of the\n9179             aggregated intervals. For example, for \"24H\" frequency, base could\n9180             range from 0 through 23.\n9181         origin : {'epoch', 'start', 'start_day', 'end', 'end_day'}, pd.Timestamp, datetime.datetime, np.datetime64, or cftime.datetime, default 'start_day'\n9182             The datetime on which to adjust the grouping. The timezone of origin\n9183             must match the timezone of the index.\n9184 \n9185             If a datetime is not used, these values are also supported:\n9186             - 'epoch': `origin` is 1970-01-01\n9187             - 'start': `origin` is the first value of the timeseries\n9188             - 'start_day': `origin` is the first day at midnight of the timeseries\n9189             - 'end': `origin` is the last value of the timeseries\n9190             - 'end_day': `origin` is the ceiling midnight of the last day\n9191         offset : pd.Timedelta, datetime.timedelta, or str, default is None\n9192             An offset timedelta added to the origin.\n9193         loffset : timedelta or str, optional\n9194             Offset used to adjust the resampled time labels. Some pandas date\n9195             offset strings are supported.\n9196         restore_coord_dims : bool, optional\n9197             If True, also restore the dimension order of multi-dimensional\n9198             coordinates.\n9199         **indexer_kwargs : str\n9200             The keyword arguments form of ``indexer``.\n9201             One of indexer or indexer_kwargs must be provided.\n9202 \n9203         Returns\n9204         -------\n9205         resampled : core.resample.DataArrayResample\n9206             This object resampled.\n9207 \n9208         See Also\n9209         --------\n9210         DataArray.resample\n9211         pandas.Series.resample\n9212         pandas.DataFrame.resample\n9213 \n9214         References\n9215         ----------\n9216         .. [1] http://pandas.pydata.org/pandas-docs/stable/timeseries.html#offset-aliases\n9217         \"\"\"\n9218         from xarray.core.resample import DatasetResample\n9219 \n9220         return self._resample(\n9221             resample_cls=DatasetResample,\n9222             indexer=indexer,\n9223             skipna=skipna,\n9224             closed=closed,\n9225             label=label,\n9226             base=base,\n9227             offset=offset,\n9228             origin=origin,\n9229             keep_attrs=keep_attrs,\n9230             loffset=loffset,\n9231             restore_coord_dims=restore_coord_dims,\n9232             **indexer_kwargs,\n9233         )\n",
        "intended_behavior": "This class provides additional context to the issue."
    },
    {
        "rel_file_path": "xarray/core/dataarray.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/pydata__xarray/setup_pydata__xarray__2022.09/xarray/core/dataarray.py",
        "start": 2683,
        "end": 2754,
        "class_name": "DataArray",
        "method_name": "stack",
        "code": "2683     def stack(\n2684         self: T_DataArray,\n2685         dimensions: Mapping[Any, Sequence[Hashable]] | None = None,\n2686         create_index: bool | None = True,\n2687         index_cls: type[Index] = PandasMultiIndex,\n2688         **dimensions_kwargs: Sequence[Hashable],\n2689     ) -> T_DataArray:\n2690         \"\"\"\n2691         Stack any number of existing dimensions into a single new dimension.\n2692 \n2693         New dimensions will be added at the end, and the corresponding\n2694         coordinate variables will be combined into a MultiIndex.\n2695 \n2696         Parameters\n2697         ----------\n2698         dimensions : mapping of Hashable to sequence of Hashable\n2699             Mapping of the form `new_name=(dim1, dim2, ...)`.\n2700             Names of new dimensions, and the existing dimensions that they\n2701             replace. An ellipsis (`...`) will be replaced by all unlisted dimensions.\n2702             Passing a list containing an ellipsis (`stacked_dim=[...]`) will stack over\n2703             all dimensions.\n2704         create_index : bool or None, default: True\n2705             If True, create a multi-index for each of the stacked dimensions.\n2706             If False, don't create any index.\n2707             If None, create a multi-index only if exactly one single (1-d) coordinate\n2708             index is found for every dimension to stack.\n2709         index_cls: class, optional\n2710             Can be used to pass a custom multi-index type. Must be an Xarray index that\n2711             implements `.stack()`. By default, a pandas multi-index wrapper is used.\n2712         **dimensions_kwargs\n2713             The keyword arguments form of ``dimensions``.\n2714             One of dimensions or dimensions_kwargs must be provided.\n2715 \n2716         Returns\n2717         -------\n2718         stacked : DataArray\n2719             DataArray with stacked data.\n2720 \n2721         Examples\n2722         --------\n2723         >>> arr = xr.DataArray(\n2724         ...     np.arange(6).reshape(2, 3),\n2725         ...     coords=[(\"x\", [\"a\", \"b\"]), (\"y\", [0, 1, 2])],\n2726         ... )\n2727         >>> arr\n2728         <xarray.DataArray (x: 2, y: 3)>\n2729         array([[0, 1, 2],\n2730                [3, 4, 5]])\n2731         Coordinates:\n2732           * x        (x) <U1 'a' 'b'\n2733           * y        (y) int64 0 1 2\n2734         >>> stacked = arr.stack(z=(\"x\", \"y\"))\n2735         >>> stacked.indexes[\"z\"]\n2736         MultiIndex([('a', 0),\n2737                     ('a', 1),\n2738                     ('a', 2),\n2739                     ('b', 0),\n2740                     ('b', 1),\n2741                     ('b', 2)],\n2742                    name='z')\n2743 \n2744         See Also\n2745         --------\n2746         DataArray.unstack\n2747         \"\"\"\n2748         ds = self._to_temp_dataset().stack(\n2749             dimensions,\n2750             create_index=create_index,\n2751             index_cls=index_cls,\n2752             **dimensions_kwargs,\n2753         )\n2754         return self._from_temp_dataset(ds)\n",
        "intended_behavior": "Similarly to `Dataset`, the `stack` method here should make sure that the data type (`dtype`) for any coordinates involved in a stack operation is maintained as it was before the operation. If necessary, additional logic should be included to explicitly force the stacked object to match the original dtype if the operation inherently changes it, potentially using a mechanism to specify or cast dtypes during the stacking process."
    },
    {
        "rel_file_path": "xarray/core/dataarray.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/pydata__xarray/setup_pydata__xarray__2022.09/xarray/core/dataarray.py",
        "start": 235,
        "end": 6683,
        "class_name": "DataArray",
        "method_name": null,
        "code": "235 class DataArray(\n236     AbstractArray,\n237     DataWithCoords,\n238     DataArrayArithmetic,\n239     DataArrayAggregations,\n240 ):\n241     \"\"\"N-dimensional array with labeled coordinates and dimensions.\n242 \n243     DataArray provides a wrapper around numpy ndarrays that uses\n244     labeled dimensions and coordinates to support metadata aware\n245     operations. The API is similar to that for the pandas Series or\n246     DataFrame, but DataArray objects can have any number of dimensions,\n247     and their contents have fixed data types.\n248 \n249     Additional features over raw numpy arrays:\n250 \n251     - Apply operations over dimensions by name: ``x.sum('time')``.\n252     - Select or assign values by integer location (like numpy):\n253       ``x[:10]`` or by label (like pandas): ``x.loc['2014-01-01']`` or\n254       ``x.sel(time='2014-01-01')``.\n255     - Mathematical operations (e.g., ``x - y``) vectorize across\n256       multiple dimensions (known in numpy as \"broadcasting\") based on\n257       dimension names, regardless of their original order.\n258     - Keep track of arbitrary metadata in the form of a Python\n259       dictionary: ``x.attrs``\n260     - Convert to a pandas Series: ``x.to_series()``.\n261 \n262     Getting items from or doing mathematical operations with a\n263     DataArray always returns another DataArray.\n264 \n265     Parameters\n266     ----------\n267     data : array_like\n268         Values for this array. Must be an ``numpy.ndarray``, ndarray\n269         like, or castable to an ``ndarray``. If a self-described xarray\n270         or pandas object, attempts are made to use this array's\n271         metadata to fill in other unspecified arguments. A view of the\n272         array's data is used instead of a copy if possible.\n273     coords : sequence or dict of array_like, optional\n274         Coordinates (tick labels) to use for indexing along each\n275         dimension. The following notations are accepted:\n276 \n277         - mapping {dimension name: array-like}\n278         - sequence of tuples that are valid arguments for\n279           ``xarray.Variable()``\n280           - (dims, data)\n281           - (dims, data, attrs)\n282           - (dims, data, attrs, encoding)\n283 \n284         Additionally, it is possible to define a coord whose name\n285         does not match the dimension name, or a coord based on multiple\n286         dimensions, with one of the following notations:\n287 \n288         - mapping {coord name: DataArray}\n289         - mapping {coord name: Variable}\n290         - mapping {coord name: (dimension name, array-like)}\n291         - mapping {coord name: (tuple of dimension names, array-like)}\n292 \n293     dims : Hashable or sequence of Hashable, optional\n294         Name(s) of the data dimension(s). Must be either a Hashable\n295         (only for 1D data) or a sequence of Hashables with length equal\n296         to the number of dimensions. If this argument is omitted,\n297         dimension names are taken from ``coords`` (if possible) and\n298         otherwise default to ``['dim_0', ... 'dim_n']``.\n299     name : str or None, optional\n300         Name of this array.\n301     attrs : dict_like or None, optional\n302         Attributes to assign to the new instance. By default, an empty\n303         attribute dictionary is initialized.\n304 \n305     Examples\n306     --------\n307     Create data:\n308 \n309     >>> np.random.seed(0)\n310     >>> temperature = 15 + 8 * np.random.randn(2, 2, 3)\n311     >>> lon = [[-99.83, -99.32], [-99.79, -99.23]]\n312     >>> lat = [[42.25, 42.21], [42.63, 42.59]]\n313     >>> time = pd.date_range(\"2014-09-06\", periods=3)\n314     >>> reference_time = pd.Timestamp(\"2014-09-05\")\n315 \n316     Initialize a dataarray with multiple dimensions:\n317 \n318     >>> da = xr.DataArray(\n319     ...     data=temperature,\n320     ...     dims=[\"x\", \"y\", \"time\"],\n321     ...     coords=dict(\n322     ...         lon=([\"x\", \"y\"], lon),\n323     ...         lat=([\"x\", \"y\"], lat),\n324     ...         time=time,\n325     ...         reference_time=reference_time,\n326     ...     ),\n327     ...     attrs=dict(\n328     ...         description=\"Ambient temperature.\",\n329     ...         units=\"degC\",\n330     ...     ),\n331     ... )\n332     >>> da\n333     <xarray.DataArray (x: 2, y: 2, time: 3)>\n334     array([[[29.11241877, 18.20125767, 22.82990387],\n335             [32.92714559, 29.94046392,  7.18177696]],\n336     <BLANKLINE>\n337            [[22.60070734, 13.78914233, 14.17424919],\n338             [18.28478802, 16.15234857, 26.63418806]]])\n339     Coordinates:\n340         lon             (x, y) float64 -99.83 -99.32 -99.79 -99.23\n341         lat             (x, y) float64 42.25 42.21 42.63 42.59\n342       * time            (time) datetime64[ns] 2014-09-06 2014-09-07 2014-09-08\n343         reference_time  datetime64[ns] 2014-09-05\n344     Dimensions without coordinates: x, y\n345     Attributes:\n346         description:  Ambient temperature.\n347         units:        degC\n348 \n349     Find out where the coldest temperature was:\n350 \n351     >>> da.isel(da.argmin(...))\n352     <xarray.DataArray ()>\n353     array(7.18177696)\n354     Coordinates:\n355         lon             float64 -99.32\n356         lat             float64 42.21\n357         time            datetime64[ns] 2014-09-08\n358         reference_time  datetime64[ns] 2014-09-05\n359     Attributes:\n360         description:  Ambient temperature.\n361         units:        degC\n362     \"\"\"\n363 \n364     _cache: dict[str, Any]\n365     _coords: dict[Any, Variable]\n366     _close: Callable[[], None] | None\n367     _indexes: dict[Hashable, Index]\n368     _name: Hashable | None\n369     _variable: Variable\n370 \n371     __slots__ = (\n372         \"_cache\",\n373         \"_coords\",\n374         \"_close\",\n375         \"_indexes\",\n376         \"_name\",\n377         \"_variable\",\n378         \"__weakref__\",\n379     )\n380 \n381     dt = utils.UncachedAccessor(CombinedDatetimelikeAccessor[\"DataArray\"])\n382 \n383     def __init__(\n384         self,\n385         data: Any = dtypes.NA,\n386         coords: Sequence[Sequence[Any] | pd.Index | DataArray]\n387         | Mapping[Any, Any]\n388         | None = None,\n389         dims: Hashable | Sequence[Hashable] | None = None,\n390         name: Hashable | None = None,\n391         attrs: Mapping | None = None,\n392         # internal parameters\n393         indexes: dict[Hashable, Index] | None = None,\n394         fastpath: bool = False,\n395     ) -> None:\n396         if fastpath:\n397             variable = data\n398             assert dims is None\n399             assert attrs is None\n400             assert indexes is not None\n401         else:\n402             # TODO: (benbovy - explicit indexes) remove\n403             # once it becomes part of the public interface\n404             if indexes is not None:\n405                 raise ValueError(\"Providing explicit indexes is not supported yet\")\n406 \n407             # try to fill in arguments from data if they weren't supplied\n408             if coords is None:\n409 \n410                 if isinstance(data, DataArray):\n411                     coords = data.coords\n412                 elif isinstance(data, pd.Series):\n413                     coords = [data.index]\n414                 elif isinstance(data, pd.DataFrame):\n415                     coords = [data.index, data.columns]\n416                 elif isinstance(data, (pd.Index, IndexVariable)):\n417                     coords = [data]\n418 \n419             if dims is None:\n420                 dims = getattr(data, \"dims\", getattr(coords, \"dims\", None))\n421             if name is None:\n422                 name = getattr(data, \"name\", None)\n423             if attrs is None and not isinstance(data, PANDAS_TYPES):\n424                 attrs = getattr(data, \"attrs\", None)\n425 \n426             data = _check_data_shape(data, coords, dims)\n427             data = as_compatible_data(data)\n428             coords, dims = _infer_coords_and_dims(data.shape, coords, dims)\n429             variable = Variable(dims, data, attrs, fastpath=True)\n430             indexes, coords = _create_indexes_from_coords(coords)\n431 \n432         # These fully describe a DataArray\n433         self._variable = variable\n434         assert isinstance(coords, dict)\n435         self._coords = coords\n436         self._name = name\n437 \n438         # TODO(shoyer): document this argument, once it becomes part of the\n439         # public interface.\n440         self._indexes = indexes\n441 \n442         self._close = None\n443 \n444     @classmethod\n445     def _construct_direct(\n446         cls: type[T_DataArray],\n447         variable: Variable,\n448         coords: dict[Any, Variable],\n449         name: Hashable,\n450         indexes: dict[Hashable, Index],\n451     ) -> T_DataArray:\n452         \"\"\"Shortcut around __init__ for internal use when we want to skip\n453         costly validation\n454         \"\"\"\n455         obj = object.__new__(cls)\n456         obj._variable = variable\n457         obj._coords = coords\n458         obj._name = name\n459         obj._indexes = indexes\n460         obj._close = None\n461         return obj\n462 \n463     def _replace(\n464         self: T_DataArray,\n465         variable: Variable | None = None,\n466         coords=None,\n467         name: Hashable | None | Default = _default,\n468         indexes=None,\n469     ) -> T_DataArray:\n470         if variable is None:\n471             variable = self.variable\n472         if coords is None:\n473             coords = self._coords\n474         if indexes is None:\n475             indexes = self._indexes\n476         if name is _default:\n477             name = self.name\n478         return type(self)(variable, coords, name=name, indexes=indexes, fastpath=True)\n479 \n480     def _replace_maybe_drop_dims(\n481         self: T_DataArray,\n482         variable: Variable,\n483         name: Hashable | None | Default = _default,\n484     ) -> T_DataArray:\n485         if variable.dims == self.dims and variable.shape == self.shape:\n486             coords = self._coords.copy()\n487             indexes = self._indexes\n488         elif variable.dims == self.dims:\n489             # Shape has changed (e.g. from reduce(..., keepdims=True)\n490             new_sizes = dict(zip(self.dims, variable.shape))\n491             coords = {\n492                 k: v\n493                 for k, v in self._coords.items()\n494                 if v.shape == tuple(new_sizes[d] for d in v.dims)\n495             }\n496             indexes = filter_indexes_from_coords(self._indexes, set(coords))\n497         else:\n498             allowed_dims = set(variable.dims)\n499             coords = {\n500                 k: v for k, v in self._coords.items() if set(v.dims) <= allowed_dims\n501             }\n502             indexes = filter_indexes_from_coords(self._indexes, set(coords))\n503         return self._replace(variable, coords, name, indexes=indexes)\n504 \n505     def _overwrite_indexes(\n506         self: T_DataArray,\n507         indexes: Mapping[Any, Index],\n508         coords: Mapping[Any, Variable] | None = None,\n509         drop_coords: list[Hashable] | None = None,\n510         rename_dims: Mapping[Any, Any] | None = None,\n511     ) -> T_DataArray:\n512         \"\"\"Maybe replace indexes and their corresponding coordinates.\"\"\"\n513         if not indexes:\n514             return self\n515 \n516         if coords is None:\n517             coords = {}\n518         if drop_coords is None:\n519             drop_coords = []\n520 \n521         new_variable = self.variable.copy()\n522         new_coords = self._coords.copy()\n523         new_indexes = dict(self._indexes)\n524 \n525         for name in indexes:\n526             new_coords[name] = coords[name]\n527             new_indexes[name] = indexes[name]\n528 \n529         for name in drop_coords:\n530             new_coords.pop(name)\n531             new_indexes.pop(name)\n532 \n533         if rename_dims:\n534             new_variable.dims = tuple(rename_dims.get(d, d) for d in new_variable.dims)\n535 \n536         return self._replace(\n537             variable=new_variable, coords=new_coords, indexes=new_indexes\n538         )\n539 \n540     def _to_temp_dataset(self) -> Dataset:\n541         return self._to_dataset_whole(name=_THIS_ARRAY, shallow_copy=False)\n542 \n543     def _from_temp_dataset(\n544         self: T_DataArray, dataset: Dataset, name: Hashable | None | Default = _default\n545     ) -> T_DataArray:\n546         variable = dataset._variables.pop(_THIS_ARRAY)\n547         coords = dataset._variables\n548         indexes = dataset._indexes\n549         return self._replace(variable, coords, name, indexes=indexes)\n550 \n551     def _to_dataset_split(self, dim: Hashable) -> Dataset:\n552         \"\"\"splits dataarray along dimension 'dim'\"\"\"\n553 \n554         def subset(dim, label):\n555             array = self.loc[{dim: label}]\n556             array.attrs = {}\n557             return as_variable(array)\n558 \n559         variables = {label: subset(dim, label) for label in self.get_index(dim)}\n560         variables.update({k: v for k, v in self._coords.items() if k != dim})\n561         coord_names = set(self._coords) - {dim}\n562         indexes = filter_indexes_from_coords(self._indexes, coord_names)\n563         dataset = Dataset._construct_direct(\n564             variables, coord_names, indexes=indexes, attrs=self.attrs\n565         )\n566         return dataset\n567 \n568     def _to_dataset_whole(\n569         self, name: Hashable = None, shallow_copy: bool = True\n570     ) -> Dataset:\n571         if name is None:\n572             name = self.name\n573         if name is None:\n574             raise ValueError(\n575                 \"unable to convert unnamed DataArray to a \"\n576                 \"Dataset without providing an explicit name\"\n577             )\n578         if name in self.coords:\n579             raise ValueError(\n580                 \"cannot create a Dataset from a DataArray with \"\n581                 \"the same name as one of its coordinates\"\n582             )\n583         # use private APIs for speed: this is called by _to_temp_dataset(),\n584         # which is used in the guts of a lot of operations (e.g., reindex)\n585         variables = self._coords.copy()\n586         variables[name] = self.variable\n587         if shallow_copy:\n588             for k in variables:\n589                 variables[k] = variables[k].copy(deep=False)\n590         indexes = self._indexes\n591 \n592         coord_names = set(self._coords)\n593         return Dataset._construct_direct(variables, coord_names, indexes=indexes)\n594 \n595     def to_dataset(\n596         self,\n597         dim: Hashable = None,\n598         *,\n599         name: Hashable = None,\n600         promote_attrs: bool = False,\n601     ) -> Dataset:\n602         \"\"\"Convert a DataArray to a Dataset.\n603 \n604         Parameters\n605         ----------\n606         dim : Hashable, optional\n607             Name of the dimension on this array along which to split this array\n608             into separate variables. If not provided, this array is converted\n609             into a Dataset of one variable.\n610         name : Hashable, optional\n611             Name to substitute for this array's name. Only valid if ``dim`` is\n612             not provided.\n613         promote_attrs : bool, default: False\n614             Set to True to shallow copy attrs of DataArray to returned Dataset.\n615 \n616         Returns\n617         -------\n618         dataset : Dataset\n619         \"\"\"\n620         if dim is not None and dim not in self.dims:\n621             raise TypeError(\n622                 f\"{dim} is not a dim. If supplying a ``name``, pass as a kwarg.\"\n623             )\n624 \n625         if dim is not None:\n626             if name is not None:\n627                 raise TypeError(\"cannot supply both dim and name arguments\")\n628             result = self._to_dataset_split(dim)\n629         else:\n630             result = self._to_dataset_whole(name)\n631 \n632         if promote_attrs:\n633             result.attrs = dict(self.attrs)\n634 \n635         return result\n636 \n637     @property\n638     def name(self) -> Hashable | None:\n639         \"\"\"The name of this array.\"\"\"\n640         return self._name\n641 \n642     @name.setter\n643     def name(self, value: Hashable | None) -> None:\n644         self._name = value\n645 \n646     @property\n647     def variable(self) -> Variable:\n648         \"\"\"Low level interface to the Variable object for this DataArray.\"\"\"\n649         return self._variable\n650 \n651     @property\n652     def dtype(self) -> np.dtype:\n653         \"\"\"\n654         Data-type of the array\u2019s elements.\n655 \n656         See Also\n657         --------\n658         ndarray.dtype\n659         numpy.dtype\n660         \"\"\"\n661         return self.variable.dtype\n662 \n663     @property\n664     def shape(self) -> tuple[int, ...]:\n665         \"\"\"\n666         Tuple of array dimensions.\n667 \n668         See Also\n669         --------\n670         numpy.ndarray.shape\n671         \"\"\"\n672         return self.variable.shape\n673 \n674     @property\n675     def size(self) -> int:\n676         \"\"\"\n677         Number of elements in the array.\n678 \n679         Equal to ``np.prod(a.shape)``, i.e., the product of the array\u2019s dimensions.\n680 \n681         See Also\n682         --------\n683         numpy.ndarray.size\n684         \"\"\"\n685         return self.variable.size\n686 \n687     @property\n688     def nbytes(self) -> int:\n689         \"\"\"\n690         Total bytes consumed by the elements of this DataArray's data.\n691 \n692         If the underlying data array does not include ``nbytes``, estimates\n693         the bytes consumed based on the ``size`` and ``dtype``.\n694         \"\"\"\n695         return self.variable.nbytes\n696 \n697     @property\n698     def ndim(self) -> int:\n699         \"\"\"\n700         Number of array dimensions.\n701 \n702         See Also\n703         --------\n704         numpy.ndarray.ndim\n705         \"\"\"\n706         return self.variable.ndim\n707 \n708     def __len__(self) -> int:\n709         return len(self.variable)\n710 \n711     @property\n712     def data(self) -> Any:\n713         \"\"\"\n714         The DataArray's data as an array. The underlying array type\n715         (e.g. dask, sparse, pint) is preserved.\n716 \n717         See Also\n718         --------\n719         DataArray.to_numpy\n720         DataArray.as_numpy\n721         DataArray.values\n722         \"\"\"\n723         return self.variable.data\n724 \n725     @data.setter\n726     def data(self, value: Any) -> None:\n727         self.variable.data = value\n728 \n729     @property\n730     def values(self) -> np.ndarray:\n731         \"\"\"\n732         The array's data as a numpy.ndarray.\n733 \n734         If the array's data is not a numpy.ndarray this will attempt to convert\n735         it naively using np.array(), which will raise an error if the array\n736         type does not support coercion like this (e.g. cupy).\n737         \"\"\"\n738         return self.variable.values\n739 \n740     @values.setter\n741     def values(self, value: Any) -> None:\n742         self.variable.values = value\n743 \n744     def to_numpy(self) -> np.ndarray:\n745         \"\"\"\n746         Coerces wrapped data to numpy and returns a numpy.ndarray.\n747 \n748         See Also\n749         --------\n750         DataArray.as_numpy : Same but returns the surrounding DataArray instead.\n751         Dataset.as_numpy\n752         DataArray.values\n753         DataArray.data\n754         \"\"\"\n755         return self.variable.to_numpy()\n756 \n757     def as_numpy(self: T_DataArray) -> T_DataArray:\n758         \"\"\"\n759         Coerces wrapped data and coordinates into numpy arrays, returning a DataArray.\n760 \n761         See Also\n762         --------\n763         DataArray.to_numpy : Same but returns only the data as a numpy.ndarray object.\n764         Dataset.as_numpy : Converts all variables in a Dataset.\n765         DataArray.values\n766         DataArray.data\n767         \"\"\"\n768         coords = {k: v.as_numpy() for k, v in self._coords.items()}\n769         return self._replace(self.variable.as_numpy(), coords, indexes=self._indexes)\n770 \n771     @property\n772     def _in_memory(self) -> bool:\n773         return self.variable._in_memory\n774 \n775     def _to_index(self) -> pd.Index:\n776         return self.variable._to_index()\n777 \n778     def to_index(self) -> pd.Index:\n779         \"\"\"Convert this variable to a pandas.Index. Only possible for 1D\n780         arrays.\n781         \"\"\"\n782         return self.variable.to_index()\n783 \n784     @property\n785     def dims(self) -> tuple[Hashable, ...]:\n786         \"\"\"Tuple of dimension names associated with this array.\n787 \n788         Note that the type of this property is inconsistent with\n789         `Dataset.dims`.  See `Dataset.sizes` and `DataArray.sizes` for\n790         consistently named properties.\n791 \n792         See Also\n793         --------\n794         DataArray.sizes\n795         Dataset.dims\n796         \"\"\"\n797         return self.variable.dims\n798 \n799     @dims.setter\n800     def dims(self, value: Any) -> NoReturn:\n801         raise AttributeError(\n802             \"you cannot assign dims on a DataArray. Use \"\n803             \".rename() or .swap_dims() instead.\"\n804         )\n805 \n806     def _item_key_to_dict(self, key: Any) -> Mapping[Hashable, Any]:\n807         if utils.is_dict_like(key):\n808             return key\n809         key = indexing.expanded_indexer(key, self.ndim)\n810         return dict(zip(self.dims, key))\n811 \n812     def _getitem_coord(self: T_DataArray, key: Any) -> T_DataArray:\n813         from xarray.core.dataset import _get_virtual_variable\n814 \n815         try:\n816             var = self._coords[key]\n817         except KeyError:\n818             dim_sizes = dict(zip(self.dims, self.shape))\n819             _, key, var = _get_virtual_variable(self._coords, key, dim_sizes)\n820 \n821         return self._replace_maybe_drop_dims(var, name=key)\n822 \n823     def __getitem__(self: T_DataArray, key: Any) -> T_DataArray:\n824         if isinstance(key, str):\n825             return self._getitem_coord(key)\n826         else:\n827             # xarray-style array indexing\n828             return self.isel(indexers=self._item_key_to_dict(key))\n829 \n830     def __setitem__(self, key: Any, value: Any) -> None:\n831         if isinstance(key, str):\n832             self.coords[key] = value\n833         else:\n834             # Coordinates in key, value and self[key] should be consistent.\n835             # TODO Coordinate consistency in key is checked here, but it\n836             # causes unnecessary indexing. It should be optimized.\n837             obj = self[key]\n838             if isinstance(value, DataArray):\n839                 assert_coordinate_consistent(value, obj.coords.variables)\n840             # DataArray key -> Variable key\n841             key = {\n842                 k: v.variable if isinstance(v, DataArray) else v\n843                 for k, v in self._item_key_to_dict(key).items()\n844             }\n845             self.variable[key] = value\n846 \n847     def __delitem__(self, key: Any) -> None:\n848         del self.coords[key]\n849 \n850     @property\n851     def _attr_sources(self) -> Iterable[Mapping[Hashable, Any]]:\n852         \"\"\"Places to look-up items for attribute-style access\"\"\"\n853         yield from self._item_sources\n854         yield self.attrs\n855 \n856     @property\n857     def _item_sources(self) -> Iterable[Mapping[Hashable, Any]]:\n858         \"\"\"Places to look-up items for key-completion\"\"\"\n859         yield HybridMappingProxy(keys=self._coords, mapping=self.coords)\n860 \n861         # virtual coordinates\n862         # uses empty dict -- everything here can already be found in self.coords.\n863         yield HybridMappingProxy(keys=self.dims, mapping={})\n864 \n865     def __contains__(self, key: Any) -> bool:\n866         return key in self.data\n867 \n868     @property\n869     def loc(self) -> _LocIndexer:\n870         \"\"\"Attribute for location based indexing like pandas.\"\"\"\n871         return _LocIndexer(self)\n872 \n873     @property\n874     def attrs(self) -> dict[Any, Any]:\n875         \"\"\"Dictionary storing arbitrary metadata with this array.\"\"\"\n876         return self.variable.attrs\n877 \n878     @attrs.setter\n879     def attrs(self, value: Mapping[Any, Any]) -> None:\n880         self.variable.attrs = dict(value)\n881 \n882     @property\n883     def encoding(self) -> dict[Any, Any]:\n884         \"\"\"Dictionary of format-specific settings for how this array should be\n885         serialized.\"\"\"\n886         return self.variable.encoding\n887 \n888     @encoding.setter\n889     def encoding(self, value: Mapping[Any, Any]) -> None:\n890         self.variable.encoding = dict(value)\n891 \n892     @property\n893     def indexes(self) -> Indexes:\n894         \"\"\"Mapping of pandas.Index objects used for label based indexing.\n895 \n896         Raises an error if this Dataset has indexes that cannot be coerced\n897         to pandas.Index objects.\n898 \n899         See Also\n900         --------\n901         DataArray.xindexes\n902 \n903         \"\"\"\n904         return self.xindexes.to_pandas_indexes()\n905 \n906     @property\n907     def xindexes(self) -> Indexes:\n908         \"\"\"Mapping of xarray Index objects used for label based indexing.\"\"\"\n909         return Indexes(self._indexes, {k: self._coords[k] for k in self._indexes})\n910 \n911     @property\n912     def coords(self) -> DataArrayCoordinates:\n913         \"\"\"Dictionary-like container of coordinate arrays.\"\"\"\n914         return DataArrayCoordinates(self)\n915 \n916     @overload\n917     def reset_coords(\n918         self: T_DataArray,\n919         names: Dims = None,\n920         drop: Literal[False] = False,\n921     ) -> Dataset:\n922         ...\n923 \n924     @overload\n925     def reset_coords(\n926         self: T_DataArray,\n927         names: Dims = None,\n928         *,\n929         drop: Literal[True],\n930     ) -> T_DataArray:\n931         ...\n932 \n933     def reset_coords(\n934         self: T_DataArray,\n935         names: Dims = None,\n936         drop: bool = False,\n937     ) -> T_DataArray | Dataset:\n938         \"\"\"Given names of coordinates, reset them to become variables.\n939 \n940         Parameters\n941         ----------\n942         names : str, Iterable of Hashable or None, optional\n943             Name(s) of non-index coordinates in this dataset to reset into\n944             variables. By default, all non-index coordinates are reset.\n945         drop : bool, default: False\n946             If True, remove coordinates instead of converting them into\n947             variables.\n948 \n949         Returns\n950         -------\n951         Dataset, or DataArray if ``drop == True``\n952 \n953         Examples\n954         --------\n955         >>> temperature = np.arange(25).reshape(5, 5)\n956         >>> pressure = np.arange(50, 75).reshape(5, 5)\n957         >>> da = xr.DataArray(\n958         ...     data=temperature,\n959         ...     dims=[\"x\", \"y\"],\n960         ...     coords=dict(\n961         ...         lon=(\"x\", np.arange(10, 15)),\n962         ...         lat=(\"y\", np.arange(20, 25)),\n963         ...         Pressure=([\"x\", \"y\"], pressure),\n964         ...     ),\n965         ...     name=\"Temperature\",\n966         ... )\n967         >>> da\n968         <xarray.DataArray 'Temperature' (x: 5, y: 5)>\n969         array([[ 0,  1,  2,  3,  4],\n970                [ 5,  6,  7,  8,  9],\n971                [10, 11, 12, 13, 14],\n972                [15, 16, 17, 18, 19],\n973                [20, 21, 22, 23, 24]])\n974         Coordinates:\n975             lon       (x) int64 10 11 12 13 14\n976             lat       (y) int64 20 21 22 23 24\n977             Pressure  (x, y) int64 50 51 52 53 54 55 56 57 ... 67 68 69 70 71 72 73 74\n978         Dimensions without coordinates: x, y\n979 \n980         Return Dataset with target coordinate as a data variable rather than a coordinate variable:\n981 \n982         >>> da.reset_coords(names=\"Pressure\")\n983         <xarray.Dataset>\n984         Dimensions:      (x: 5, y: 5)\n985         Coordinates:\n986             lon          (x) int64 10 11 12 13 14\n987             lat          (y) int64 20 21 22 23 24\n988         Dimensions without coordinates: x, y\n989         Data variables:\n990             Pressure     (x, y) int64 50 51 52 53 54 55 56 57 ... 68 69 70 71 72 73 74\n991             Temperature  (x, y) int64 0 1 2 3 4 5 6 7 8 9 ... 16 17 18 19 20 21 22 23 24\n992 \n993         Return DataArray without targeted coordinate:\n994 \n995         >>> da.reset_coords(names=\"Pressure\", drop=True)\n996         <xarray.DataArray 'Temperature' (x: 5, y: 5)>\n997         array([[ 0,  1,  2,  3,  4],\n998                [ 5,  6,  7,  8,  9],\n999                [10, 11, 12, 13, 14],\n1000                [15, 16, 17, 18, 19],\n1001                [20, 21, 22, 23, 24]])\n1002         Coordinates:\n1003             lon      (x) int64 10 11 12 13 14\n1004             lat      (y) int64 20 21 22 23 24\n1005         Dimensions without coordinates: x, y\n1006         \"\"\"\n1007         if names is None:\n1008             names = set(self.coords) - set(self._indexes)\n1009         dataset = self.coords.to_dataset().reset_coords(names, drop)\n1010         if drop:\n1011             return self._replace(coords=dataset._variables)\n1012         if self.name is None:\n1013             raise ValueError(\n1014                 \"cannot reset_coords with drop=False on an unnamed DataArrray\"\n1015             )\n1016         dataset[self.name] = self.variable\n1017         return dataset\n1018 \n1019     def __dask_tokenize__(self):\n1020         from dask.base import normalize_token\n1021 \n1022         return normalize_token((type(self), self._variable, self._coords, self._name))\n1023 \n1024     def __dask_graph__(self):\n1025         return self._to_temp_dataset().__dask_graph__()\n1026 \n1027     def __dask_keys__(self):\n1028         return self._to_temp_dataset().__dask_keys__()\n1029 \n1030     def __dask_layers__(self):\n1031         return self._to_temp_dataset().__dask_layers__()\n1032 \n1033     @property\n1034     def __dask_optimize__(self):\n1035         return self._to_temp_dataset().__dask_optimize__\n1036 \n1037     @property\n1038     def __dask_scheduler__(self):\n1039         return self._to_temp_dataset().__dask_scheduler__\n1040 \n1041     def __dask_postcompute__(self):\n1042         func, args = self._to_temp_dataset().__dask_postcompute__()\n1043         return self._dask_finalize, (self.name, func) + args\n1044 \n1045     def __dask_postpersist__(self):\n1046         func, args = self._to_temp_dataset().__dask_postpersist__()\n1047         return self._dask_finalize, (self.name, func) + args\n1048 \n1049     @staticmethod\n1050     def _dask_finalize(results, name, func, *args, **kwargs) -> DataArray:\n1051         ds = func(results, *args, **kwargs)\n1052         variable = ds._variables.pop(_THIS_ARRAY)\n1053         coords = ds._variables\n1054         indexes = ds._indexes\n1055         return DataArray(variable, coords, name=name, indexes=indexes, fastpath=True)\n1056 \n1057     def load(self: T_DataArray, **kwargs) -> T_DataArray:\n1058         \"\"\"Manually trigger loading of this array's data from disk or a\n1059         remote source into memory and return this array.\n1060 \n1061         Normally, it should not be necessary to call this method in user code,\n1062         because all xarray functions should either work on deferred data or\n1063         load data automatically. However, this method can be necessary when\n1064         working with many file objects on disk.\n1065 \n1066         Parameters\n1067         ----------\n1068         **kwargs : dict\n1069             Additional keyword arguments passed on to ``dask.compute``.\n1070 \n1071         See Also\n1072         --------\n1073         dask.compute\n1074         \"\"\"\n1075         ds = self._to_temp_dataset().load(**kwargs)\n1076         new = self._from_temp_dataset(ds)\n1077         self._variable = new._variable\n1078         self._coords = new._coords\n1079         return self\n1080 \n1081     def compute(self: T_DataArray, **kwargs) -> T_DataArray:\n1082         \"\"\"Manually trigger loading of this array's data from disk or a\n1083         remote source into memory and return a new array. The original is\n1084         left unaltered.\n1085 \n1086         Normally, it should not be necessary to call this method in user code,\n1087         because all xarray functions should either work on deferred data or\n1088         load data automatically. However, this method can be necessary when\n1089         working with many file objects on disk.\n1090 \n1091         Parameters\n1092         ----------\n1093         **kwargs : dict\n1094             Additional keyword arguments passed on to ``dask.compute``.\n1095 \n1096         See Also\n1097         --------\n1098         dask.compute\n1099         \"\"\"\n1100         new = self.copy(deep=False)\n1101         return new.load(**kwargs)\n1102 \n1103     def persist(self: T_DataArray, **kwargs) -> T_DataArray:\n1104         \"\"\"Trigger computation in constituent dask arrays\n1105 \n1106         This keeps them as dask arrays but encourages them to keep data in\n1107         memory.  This is particularly useful when on a distributed machine.\n1108         When on a single machine consider using ``.compute()`` instead.\n1109 \n1110         Parameters\n1111         ----------\n1112         **kwargs : dict\n1113             Additional keyword arguments passed on to ``dask.persist``.\n1114 \n1115         See Also\n1116         --------\n1117         dask.persist\n1118         \"\"\"\n1119         ds = self._to_temp_dataset().persist(**kwargs)\n1120         return self._from_temp_dataset(ds)\n1121 \n1122     def copy(self: T_DataArray, deep: bool = True, data: Any = None) -> T_DataArray:\n1123         \"\"\"Returns a copy of this array.\n1124 \n1125         If `deep=True`, a deep copy is made of the data array.\n1126         Otherwise, a shallow copy is made, and the returned data array's\n1127         values are a new view of this data array's values.\n1128 \n1129         Use `data` to create a new object with the same structure as\n1130         original but entirely new data.\n1131 \n1132         Parameters\n1133         ----------\n1134         deep : bool, optional\n1135             Whether the data array and its coordinates are loaded into memory\n1136             and copied onto the new object. Default is True.\n1137         data : array_like, optional\n1138             Data to use in the new object. Must have same shape as original.\n1139             When `data` is used, `deep` is ignored for all data variables,\n1140             and only used for coords.\n1141 \n1142         Returns\n1143         -------\n1144         copy : DataArray\n1145             New object with dimensions, attributes, coordinates, name,\n1146             encoding, and optionally data copied from original.\n1147 \n1148         Examples\n1149         --------\n1150         Shallow versus deep copy\n1151 \n1152         >>> array = xr.DataArray([1, 2, 3], dims=\"x\", coords={\"x\": [\"a\", \"b\", \"c\"]})\n1153         >>> array.copy()\n1154         <xarray.DataArray (x: 3)>\n1155         array([1, 2, 3])\n1156         Coordinates:\n1157           * x        (x) <U1 'a' 'b' 'c'\n1158         >>> array_0 = array.copy(deep=False)\n1159         >>> array_0[0] = 7\n1160         >>> array_0\n1161         <xarray.DataArray (x: 3)>\n1162         array([7, 2, 3])\n1163         Coordinates:\n1164           * x        (x) <U1 'a' 'b' 'c'\n1165         >>> array\n1166         <xarray.DataArray (x: 3)>\n1167         array([7, 2, 3])\n1168         Coordinates:\n1169           * x        (x) <U1 'a' 'b' 'c'\n1170 \n1171         Changing the data using the ``data`` argument maintains the\n1172         structure of the original object, but with the new data. Original\n1173         object is unaffected.\n1174 \n1175         >>> array.copy(data=[0.1, 0.2, 0.3])\n1176         <xarray.DataArray (x: 3)>\n1177         array([0.1, 0.2, 0.3])\n1178         Coordinates:\n1179           * x        (x) <U1 'a' 'b' 'c'\n1180         >>> array\n1181         <xarray.DataArray (x: 3)>\n1182         array([7, 2, 3])\n1183         Coordinates:\n1184           * x        (x) <U1 'a' 'b' 'c'\n1185 \n1186         See Also\n1187         --------\n1188         pandas.DataFrame.copy\n1189         \"\"\"\n1190         return self._copy(deep=deep, data=data)\n1191 \n1192     def _copy(\n1193         self: T_DataArray,\n1194         deep: bool = True,\n1195         data: Any = None,\n1196         memo: dict[int, Any] | None = None,\n1197     ) -> T_DataArray:\n1198         variable = self.variable._copy(deep=deep, data=data, memo=memo)\n1199         indexes, index_vars = self.xindexes.copy_indexes(deep=deep)\n1200 \n1201         coords = {}\n1202         for k, v in self._coords.items():\n1203             if k in index_vars:\n1204                 coords[k] = index_vars[k]\n1205             else:\n1206                 coords[k] = v._copy(deep=deep, memo=memo)\n1207 \n1208         return self._replace(variable, coords, indexes=indexes)\n1209 \n1210     def __copy__(self: T_DataArray) -> T_DataArray:\n1211         return self._copy(deep=False)\n1212 \n1213     def __deepcopy__(\n1214         self: T_DataArray, memo: dict[int, Any] | None = None\n1215     ) -> T_DataArray:\n1216         return self._copy(deep=True, memo=memo)\n1217 \n1218     # mutable objects should not be Hashable\n1219     # https://github.com/python/mypy/issues/4266\n1220     __hash__ = None  # type: ignore[assignment]\n1221 \n1222     @property\n1223     def chunks(self) -> tuple[tuple[int, ...], ...] | None:\n1224         \"\"\"\n1225         Tuple of block lengths for this dataarray's data, in order of dimensions, or None if\n1226         the underlying data is not a dask array.\n1227 \n1228         See Also\n1229         --------\n1230         DataArray.chunk\n1231         DataArray.chunksizes\n1232         xarray.unify_chunks\n1233         \"\"\"\n1234         return self.variable.chunks\n1235 \n1236     @property\n1237     def chunksizes(self) -> Mapping[Any, tuple[int, ...]]:\n1238         \"\"\"\n1239         Mapping from dimension names to block lengths for this dataarray's data, or None if\n1240         the underlying data is not a dask array.\n1241         Cannot be modified directly, but can be modified by calling .chunk().\n1242 \n1243         Differs from DataArray.chunks because it returns a mapping of dimensions to chunk shapes\n1244         instead of a tuple of chunk shapes.\n1245 \n1246         See Also\n1247         --------\n1248         DataArray.chunk\n1249         DataArray.chunks\n1250         xarray.unify_chunks\n1251         \"\"\"\n1252         all_variables = [self.variable] + [c.variable for c in self.coords.values()]\n1253         return get_chunksizes(all_variables)\n1254 \n1255     def chunk(\n1256         self: T_DataArray,\n1257         chunks: (\n1258             int\n1259             | Literal[\"auto\"]\n1260             | tuple[int, ...]\n1261             | tuple[tuple[int, ...], ...]\n1262             | Mapping[Any, None | int | tuple[int, ...]]\n1263         ) = {},  # {} even though it's technically unsafe, is being used intentionally here (#4667)\n1264         name_prefix: str = \"xarray-\",\n1265         token: str | None = None,\n1266         lock: bool = False,\n1267         inline_array: bool = False,\n1268         **chunks_kwargs: Any,\n1269     ) -> T_DataArray:\n1270         \"\"\"Coerce this array's data into a dask arrays with the given chunks.\n1271 \n1272         If this variable is a non-dask array, it will be converted to dask\n1273         array. If it's a dask array, it will be rechunked to the given chunk\n1274         sizes.\n1275 \n1276         If neither chunks is not provided for one or more dimensions, chunk\n1277         sizes along that dimension will not be updated; non-dask arrays will be\n1278         converted into dask arrays with a single block.\n1279 \n1280         Parameters\n1281         ----------\n1282         chunks : int, \"auto\", tuple of int or mapping of Hashable to int, optional\n1283             Chunk sizes along each dimension, e.g., ``5``, ``\"auto\"``, ``(5, 5)`` or\n1284             ``{\"x\": 5, \"y\": 5}``.\n1285         name_prefix : str, optional\n1286             Prefix for the name of the new dask array.\n1287         token : str, optional\n1288             Token uniquely identifying this array.\n1289         lock : optional\n1290             Passed on to :py:func:`dask.array.from_array`, if the array is not\n1291             already as dask array.\n1292         inline_array: optional\n1293             Passed on to :py:func:`dask.array.from_array`, if the array is not\n1294             already as dask array.\n1295         **chunks_kwargs : {dim: chunks, ...}, optional\n1296             The keyword arguments form of ``chunks``.\n1297             One of chunks or chunks_kwargs must be provided.\n1298 \n1299         Returns\n1300         -------\n1301         chunked : xarray.DataArray\n1302 \n1303         See Also\n1304         --------\n1305         DataArray.chunks\n1306         DataArray.chunksizes\n1307         xarray.unify_chunks\n1308         dask.array.from_array\n1309         \"\"\"\n1310         if chunks is None:\n1311             warnings.warn(\n1312                 \"None value for 'chunks' is deprecated. \"\n1313                 \"It will raise an error in the future. Use instead '{}'\",\n1314                 category=FutureWarning,\n1315             )\n1316             chunks = {}\n1317 \n1318         if isinstance(chunks, (float, str, int)):\n1319             # ignoring type; unclear why it won't accept a Literal into the value.\n1320             chunks = dict.fromkeys(self.dims, chunks)  # type: ignore\n1321         elif isinstance(chunks, (tuple, list)):\n1322             chunks = dict(zip(self.dims, chunks))\n1323         else:\n1324             chunks = either_dict_or_kwargs(chunks, chunks_kwargs, \"chunk\")\n1325 \n1326         ds = self._to_temp_dataset().chunk(\n1327             chunks,\n1328             name_prefix=name_prefix,\n1329             token=token,\n1330             lock=lock,\n1331             inline_array=inline_array,\n1332         )\n1333         return self._from_temp_dataset(ds)\n1334 \n1335     def isel(\n1336         self: T_DataArray,\n1337         indexers: Mapping[Any, Any] | None = None,\n1338         drop: bool = False,\n1339         missing_dims: ErrorOptionsWithWarn = \"raise\",\n1340         **indexers_kwargs: Any,\n1341     ) -> T_DataArray:\n1342         \"\"\"Return a new DataArray whose data is given by selecting indexes\n1343         along the specified dimension(s).\n1344 \n1345         Parameters\n1346         ----------\n1347         indexers : dict, optional\n1348             A dict with keys matching dimensions and values given\n1349             by integers, slice objects or arrays.\n1350             indexer can be a integer, slice, array-like or DataArray.\n1351             If DataArrays are passed as indexers, xarray-style indexing will be\n1352             carried out. See :ref:`indexing` for the details.\n1353             One of indexers or indexers_kwargs must be provided.\n1354         drop : bool, default: False\n1355             If ``drop=True``, drop coordinates variables indexed by integers\n1356             instead of making them scalar.\n1357         missing_dims : {\"raise\", \"warn\", \"ignore\"}, default: \"raise\"\n1358             What to do if dimensions that should be selected from are not present in the\n1359             DataArray:\n1360             - \"raise\": raise an exception\n1361             - \"warn\": raise a warning, and ignore the missing dimensions\n1362             - \"ignore\": ignore the missing dimensions\n1363         **indexers_kwargs : {dim: indexer, ...}, optional\n1364             The keyword arguments form of ``indexers``.\n1365 \n1366         Returns\n1367         -------\n1368         indexed : xarray.DataArray\n1369 \n1370         See Also\n1371         --------\n1372         Dataset.isel\n1373         DataArray.sel\n1374 \n1375         Examples\n1376         --------\n1377         >>> da = xr.DataArray(np.arange(25).reshape(5, 5), dims=(\"x\", \"y\"))\n1378         >>> da\n1379         <xarray.DataArray (x: 5, y: 5)>\n1380         array([[ 0,  1,  2,  3,  4],\n1381                [ 5,  6,  7,  8,  9],\n1382                [10, 11, 12, 13, 14],\n1383                [15, 16, 17, 18, 19],\n1384                [20, 21, 22, 23, 24]])\n1385         Dimensions without coordinates: x, y\n1386 \n1387         >>> tgt_x = xr.DataArray(np.arange(0, 5), dims=\"points\")\n1388         >>> tgt_y = xr.DataArray(np.arange(0, 5), dims=\"points\")\n1389         >>> da = da.isel(x=tgt_x, y=tgt_y)\n1390         >>> da\n1391         <xarray.DataArray (points: 5)>\n1392         array([ 0,  6, 12, 18, 24])\n1393         Dimensions without coordinates: points\n1394         \"\"\"\n1395 \n1396         indexers = either_dict_or_kwargs(indexers, indexers_kwargs, \"isel\")\n1397 \n1398         if any(is_fancy_indexer(idx) for idx in indexers.values()):\n1399             ds = self._to_temp_dataset()._isel_fancy(\n1400                 indexers, drop=drop, missing_dims=missing_dims\n1401             )\n1402             return self._from_temp_dataset(ds)\n1403 \n1404         # Much faster algorithm for when all indexers are ints, slices, one-dimensional\n1405         # lists, or zero or one-dimensional np.ndarray's\n1406 \n1407         variable = self._variable.isel(indexers, missing_dims=missing_dims)\n1408         indexes, index_variables = isel_indexes(self.xindexes, indexers)\n1409 \n1410         coords = {}\n1411         for coord_name, coord_value in self._coords.items():\n1412             if coord_name in index_variables:\n1413                 coord_value = index_variables[coord_name]\n1414             else:\n1415                 coord_indexers = {\n1416                     k: v for k, v in indexers.items() if k in coord_value.dims\n1417                 }\n1418                 if coord_indexers:\n1419                     coord_value = coord_value.isel(coord_indexers)\n1420                     if drop and coord_value.ndim == 0:\n1421                         continue\n1422             coords[coord_name] = coord_value\n1423 \n1424         return self._replace(variable=variable, coords=coords, indexes=indexes)\n1425 \n1426     def sel(\n1427         self: T_DataArray,\n1428         indexers: Mapping[Any, Any] | None = None,\n1429         method: str | None = None,\n1430         tolerance=None,\n1431         drop: bool = False,\n1432         **indexers_kwargs: Any,\n1433     ) -> T_DataArray:\n1434         \"\"\"Return a new DataArray whose data is given by selecting index\n1435         labels along the specified dimension(s).\n1436 \n1437         In contrast to `DataArray.isel`, indexers for this method should use\n1438         labels instead of integers.\n1439 \n1440         Under the hood, this method is powered by using pandas's powerful Index\n1441         objects. This makes label based indexing essentially just as fast as\n1442         using integer indexing.\n1443 \n1444         It also means this method uses pandas's (well documented) logic for\n1445         indexing. This means you can use string shortcuts for datetime indexes\n1446         (e.g., '2000-01' to select all values in January 2000). It also means\n1447         that slices are treated as inclusive of both the start and stop values,\n1448         unlike normal Python indexing.\n1449 \n1450         .. warning::\n1451 \n1452           Do not try to assign values when using any of the indexing methods\n1453           ``isel`` or ``sel``::\n1454 \n1455             da = xr.DataArray([0, 1, 2, 3], dims=['x'])\n1456             # DO NOT do this\n1457             da.isel(x=[0, 1, 2])[1] = -1\n1458 \n1459           Assigning values with the chained indexing using ``.sel`` or\n1460           ``.isel`` fails silently.\n1461 \n1462         Parameters\n1463         ----------\n1464         indexers : dict, optional\n1465             A dict with keys matching dimensions and values given\n1466             by scalars, slices or arrays of tick labels. For dimensions with\n1467             multi-index, the indexer may also be a dict-like object with keys\n1468             matching index level names.\n1469             If DataArrays are passed as indexers, xarray-style indexing will be\n1470             carried out. See :ref:`indexing` for the details.\n1471             One of indexers or indexers_kwargs must be provided.\n1472         method : {None, \"nearest\", \"pad\", \"ffill\", \"backfill\", \"bfill\"}, optional\n1473             Method to use for inexact matches:\n1474 \n1475             - None (default): only exact matches\n1476             - pad / ffill: propagate last valid index value forward\n1477             - backfill / bfill: propagate next valid index value backward\n1478             - nearest: use nearest valid index value\n1479 \n1480         tolerance : optional\n1481             Maximum distance between original and new labels for inexact\n1482             matches. The values of the index at the matching locations must\n1483             satisfy the equation ``abs(index[indexer] - target) <= tolerance``.\n1484         drop : bool, optional\n1485             If ``drop=True``, drop coordinates variables in `indexers` instead\n1486             of making them scalar.\n1487         **indexers_kwargs : {dim: indexer, ...}, optional\n1488             The keyword arguments form of ``indexers``.\n1489             One of indexers or indexers_kwargs must be provided.\n1490 \n1491         Returns\n1492         -------\n1493         obj : DataArray\n1494             A new DataArray with the same contents as this DataArray, except the\n1495             data and each dimension is indexed by the appropriate indexers.\n1496             If indexer DataArrays have coordinates that do not conflict with\n1497             this object, then these coordinates will be attached.\n1498             In general, each array's data will be a view of the array's data\n1499             in this DataArray, unless vectorized indexing was triggered by using\n1500             an array indexer, in which case the data will be a copy.\n1501 \n1502         See Also\n1503         --------\n1504         Dataset.sel\n1505         DataArray.isel\n1506 \n1507         Examples\n1508         --------\n1509         >>> da = xr.DataArray(\n1510         ...     np.arange(25).reshape(5, 5),\n1511         ...     coords={\"x\": np.arange(5), \"y\": np.arange(5)},\n1512         ...     dims=(\"x\", \"y\"),\n1513         ... )\n1514         >>> da\n1515         <xarray.DataArray (x: 5, y: 5)>\n1516         array([[ 0,  1,  2,  3,  4],\n1517                [ 5,  6,  7,  8,  9],\n1518                [10, 11, 12, 13, 14],\n1519                [15, 16, 17, 18, 19],\n1520                [20, 21, 22, 23, 24]])\n1521         Coordinates:\n1522           * x        (x) int64 0 1 2 3 4\n1523           * y        (y) int64 0 1 2 3 4\n1524 \n1525         >>> tgt_x = xr.DataArray(np.linspace(0, 4, num=5), dims=\"points\")\n1526         >>> tgt_y = xr.DataArray(np.linspace(0, 4, num=5), dims=\"points\")\n1527         >>> da = da.sel(x=tgt_x, y=tgt_y, method=\"nearest\")\n1528         >>> da\n1529         <xarray.DataArray (points: 5)>\n1530         array([ 0,  6, 12, 18, 24])\n1531         Coordinates:\n1532             x        (points) int64 0 1 2 3 4\n1533             y        (points) int64 0 1 2 3 4\n1534         Dimensions without coordinates: points\n1535         \"\"\"\n1536         ds = self._to_temp_dataset().sel(\n1537             indexers=indexers,\n1538             drop=drop,\n1539             method=method,\n1540             tolerance=tolerance,\n1541             **indexers_kwargs,\n1542         )\n1543         return self._from_temp_dataset(ds)\n1544 \n1545     def head(\n1546         self: T_DataArray,\n1547         indexers: Mapping[Any, int] | int | None = None,\n1548         **indexers_kwargs: Any,\n1549     ) -> T_DataArray:\n1550         \"\"\"Return a new DataArray whose data is given by the the first `n`\n1551         values along the specified dimension(s). Default `n` = 5\n1552 \n1553         See Also\n1554         --------\n1555         Dataset.head\n1556         DataArray.tail\n1557         DataArray.thin\n1558 \n1559         Examples\n1560         --------\n1561         >>> da = xr.DataArray(\n1562         ...     np.arange(25).reshape(5, 5),\n1563         ...     dims=(\"x\", \"y\"),\n1564         ... )\n1565         >>> da\n1566         <xarray.DataArray (x: 5, y: 5)>\n1567         array([[ 0,  1,  2,  3,  4],\n1568                [ 5,  6,  7,  8,  9],\n1569                [10, 11, 12, 13, 14],\n1570                [15, 16, 17, 18, 19],\n1571                [20, 21, 22, 23, 24]])\n1572         Dimensions without coordinates: x, y\n1573 \n1574         >>> da.head(x=1)\n1575         <xarray.DataArray (x: 1, y: 5)>\n1576         array([[0, 1, 2, 3, 4]])\n1577         Dimensions without coordinates: x, y\n1578 \n1579         >>> da.head({\"x\": 2, \"y\": 2})\n1580         <xarray.DataArray (x: 2, y: 2)>\n1581         array([[0, 1],\n1582                [5, 6]])\n1583         Dimensions without coordinates: x, y\n1584         \"\"\"\n1585         ds = self._to_temp_dataset().head(indexers, **indexers_kwargs)\n1586         return self._from_temp_dataset(ds)\n1587 \n1588     def tail(\n1589         self: T_DataArray,\n1590         indexers: Mapping[Any, int] | int | None = None,\n1591         **indexers_kwargs: Any,\n1592     ) -> T_DataArray:\n1593         \"\"\"Return a new DataArray whose data is given by the the last `n`\n1594         values along the specified dimension(s). Default `n` = 5\n1595 \n1596         See Also\n1597         --------\n1598         Dataset.tail\n1599         DataArray.head\n1600         DataArray.thin\n1601 \n1602         Examples\n1603         --------\n1604         >>> da = xr.DataArray(\n1605         ...     np.arange(25).reshape(5, 5),\n1606         ...     dims=(\"x\", \"y\"),\n1607         ... )\n1608         >>> da\n1609         <xarray.DataArray (x: 5, y: 5)>\n1610         array([[ 0,  1,  2,  3,  4],\n1611                [ 5,  6,  7,  8,  9],\n1612                [10, 11, 12, 13, 14],\n1613                [15, 16, 17, 18, 19],\n1614                [20, 21, 22, 23, 24]])\n1615         Dimensions without coordinates: x, y\n1616 \n1617         >>> da.tail(y=1)\n1618         <xarray.DataArray (x: 5, y: 1)>\n1619         array([[ 4],\n1620                [ 9],\n1621                [14],\n1622                [19],\n1623                [24]])\n1624         Dimensions without coordinates: x, y\n1625 \n1626         >>> da.tail({\"x\": 2, \"y\": 2})\n1627         <xarray.DataArray (x: 2, y: 2)>\n1628         array([[18, 19],\n1629                [23, 24]])\n1630         Dimensions without coordinates: x, y\n1631         \"\"\"\n1632         ds = self._to_temp_dataset().tail(indexers, **indexers_kwargs)\n1633         return self._from_temp_dataset(ds)\n1634 \n1635     def thin(\n1636         self: T_DataArray,\n1637         indexers: Mapping[Any, int] | int | None = None,\n1638         **indexers_kwargs: Any,\n1639     ) -> T_DataArray:\n1640         \"\"\"Return a new DataArray whose data is given by each `n` value\n1641         along the specified dimension(s).\n1642 \n1643         Examples\n1644         --------\n1645         >>> x_arr = np.arange(0, 26)\n1646         >>> x_arr\n1647         array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,\n1648                17, 18, 19, 20, 21, 22, 23, 24, 25])\n1649         >>> x = xr.DataArray(\n1650         ...     np.reshape(x_arr, (2, 13)),\n1651         ...     dims=(\"x\", \"y\"),\n1652         ...     coords={\"x\": [0, 1], \"y\": np.arange(0, 13)},\n1653         ... )\n1654         >>> x\n1655         <xarray.DataArray (x: 2, y: 13)>\n1656         array([[ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12],\n1657                [13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25]])\n1658         Coordinates:\n1659           * x        (x) int64 0 1\n1660           * y        (y) int64 0 1 2 3 4 5 6 7 8 9 10 11 12\n1661 \n1662         >>>\n1663         >>> x.thin(3)\n1664         <xarray.DataArray (x: 1, y: 5)>\n1665         array([[ 0,  3,  6,  9, 12]])\n1666         Coordinates:\n1667           * x        (x) int64 0\n1668           * y        (y) int64 0 3 6 9 12\n1669         >>> x.thin({\"x\": 2, \"y\": 5})\n1670         <xarray.DataArray (x: 1, y: 3)>\n1671         array([[ 0,  5, 10]])\n1672         Coordinates:\n1673           * x        (x) int64 0\n1674           * y        (y) int64 0 5 10\n1675 \n1676         See Also\n1677         --------\n1678         Dataset.thin\n1679         DataArray.head\n1680         DataArray.tail\n1681         \"\"\"\n1682         ds = self._to_temp_dataset().thin(indexers, **indexers_kwargs)\n1683         return self._from_temp_dataset(ds)\n1684 \n1685     def broadcast_like(\n1686         self: T_DataArray,\n1687         other: DataArray | Dataset,\n1688         exclude: Iterable[Hashable] | None = None,\n1689     ) -> T_DataArray:\n1690         \"\"\"Broadcast this DataArray against another Dataset or DataArray.\n1691 \n1692         This is equivalent to xr.broadcast(other, self)[1]\n1693 \n1694         xarray objects are broadcast against each other in arithmetic\n1695         operations, so this method is not be necessary for most uses.\n1696 \n1697         If no change is needed, the input data is returned to the output\n1698         without being copied.\n1699 \n1700         If new coords are added by the broadcast, their values are\n1701         NaN filled.\n1702 \n1703         Parameters\n1704         ----------\n1705         other : Dataset or DataArray\n1706             Object against which to broadcast this array.\n1707         exclude : iterable of Hashable, optional\n1708             Dimensions that must not be broadcasted\n1709 \n1710         Returns\n1711         -------\n1712         new_da : DataArray\n1713             The caller broadcasted against ``other``.\n1714 \n1715         Examples\n1716         --------\n1717         >>> arr1 = xr.DataArray(\n1718         ...     np.random.randn(2, 3),\n1719         ...     dims=(\"x\", \"y\"),\n1720         ...     coords={\"x\": [\"a\", \"b\"], \"y\": [\"a\", \"b\", \"c\"]},\n1721         ... )\n1722         >>> arr2 = xr.DataArray(\n1723         ...     np.random.randn(3, 2),\n1724         ...     dims=(\"x\", \"y\"),\n1725         ...     coords={\"x\": [\"a\", \"b\", \"c\"], \"y\": [\"a\", \"b\"]},\n1726         ... )\n1727         >>> arr1\n1728         <xarray.DataArray (x: 2, y: 3)>\n1729         array([[ 1.76405235,  0.40015721,  0.97873798],\n1730                [ 2.2408932 ,  1.86755799, -0.97727788]])\n1731         Coordinates:\n1732           * x        (x) <U1 'a' 'b'\n1733           * y        (y) <U1 'a' 'b' 'c'\n1734         >>> arr2\n1735         <xarray.DataArray (x: 3, y: 2)>\n1736         array([[ 0.95008842, -0.15135721],\n1737                [-0.10321885,  0.4105985 ],\n1738                [ 0.14404357,  1.45427351]])\n1739         Coordinates:\n1740           * x        (x) <U1 'a' 'b' 'c'\n1741           * y        (y) <U1 'a' 'b'\n1742         >>> arr1.broadcast_like(arr2)\n1743         <xarray.DataArray (x: 3, y: 3)>\n1744         array([[ 1.76405235,  0.40015721,  0.97873798],\n1745                [ 2.2408932 ,  1.86755799, -0.97727788],\n1746                [        nan,         nan,         nan]])\n1747         Coordinates:\n1748           * x        (x) <U1 'a' 'b' 'c'\n1749           * y        (y) <U1 'a' 'b' 'c'\n1750         \"\"\"\n1751         if exclude is None:\n1752             exclude = set()\n1753         else:\n1754             exclude = set(exclude)\n1755         args = align(other, self, join=\"outer\", copy=False, exclude=exclude)\n1756 \n1757         dims_map, common_coords = _get_broadcast_dims_map_common_coords(args, exclude)\n1758 \n1759         return _broadcast_helper(\n1760             cast(\"T_DataArray\", args[1]), exclude, dims_map, common_coords\n1761         )\n1762 \n1763     def _reindex_callback(\n1764         self: T_DataArray,\n1765         aligner: alignment.Aligner,\n1766         dim_pos_indexers: dict[Hashable, Any],\n1767         variables: dict[Hashable, Variable],\n1768         indexes: dict[Hashable, Index],\n1769         fill_value: Any,\n1770         exclude_dims: frozenset[Hashable],\n1771         exclude_vars: frozenset[Hashable],\n1772     ) -> T_DataArray:\n1773         \"\"\"Callback called from ``Aligner`` to create a new reindexed DataArray.\"\"\"\n1774 \n1775         if isinstance(fill_value, dict):\n1776             fill_value = fill_value.copy()\n1777             sentinel = object()\n1778             value = fill_value.pop(self.name, sentinel)\n1779             if value is not sentinel:\n1780                 fill_value[_THIS_ARRAY] = value\n1781 \n1782         ds = self._to_temp_dataset()\n1783         reindexed = ds._reindex_callback(\n1784             aligner,\n1785             dim_pos_indexers,\n1786             variables,\n1787             indexes,\n1788             fill_value,\n1789             exclude_dims,\n1790             exclude_vars,\n1791         )\n1792         return self._from_temp_dataset(reindexed)\n1793 \n1794     def reindex_like(\n1795         self: T_DataArray,\n1796         other: DataArray | Dataset,\n1797         method: ReindexMethodOptions = None,\n1798         tolerance: int | float | Iterable[int | float] | None = None,\n1799         copy: bool = True,\n1800         fill_value=dtypes.NA,\n1801     ) -> T_DataArray:\n1802         \"\"\"Conform this object onto the indexes of another object, filling in\n1803         missing values with ``fill_value``. The default fill value is NaN.\n1804 \n1805         Parameters\n1806         ----------\n1807         other : Dataset or DataArray\n1808             Object with an 'indexes' attribute giving a mapping from dimension\n1809             names to pandas.Index objects, which provides coordinates upon\n1810             which to index the variables in this dataset. The indexes on this\n1811             other object need not be the same as the indexes on this\n1812             dataset. Any mis-matched index values will be filled in with\n1813             NaN, and any mis-matched dimension names will simply be ignored.\n1814         method : {None, \"nearest\", \"pad\", \"ffill\", \"backfill\", \"bfill\"}, optional\n1815             Method to use for filling index values from other not found on this\n1816             data array:\n1817 \n1818             - None (default): don't fill gaps\n1819             - pad / ffill: propagate last valid index value forward\n1820             - backfill / bfill: propagate next valid index value backward\n1821             - nearest: use nearest valid index value\n1822 \n1823         tolerance : optional\n1824             Maximum distance between original and new labels for inexact\n1825             matches. The values of the index at the matching locations must\n1826             satisfy the equation ``abs(index[indexer] - target) <= tolerance``.\n1827             Tolerance may be a scalar value, which applies the same tolerance\n1828             to all values, or list-like, which applies variable tolerance per\n1829             element. List-like must be the same size as the index and its dtype\n1830             must exactly match the index\u2019s type.\n1831         copy : bool, default: True\n1832             If ``copy=True``, data in the return value is always copied. If\n1833             ``copy=False`` and reindexing is unnecessary, or can be performed\n1834             with only slice operations, then the output may share memory with\n1835             the input. In either case, a new xarray object is always returned.\n1836         fill_value : scalar or dict-like, optional\n1837             Value to use for newly missing values. If a dict-like, maps\n1838             variable names (including coordinates) to fill values. Use this\n1839             data array's name to refer to the data array's values.\n1840 \n1841         Returns\n1842         -------\n1843         reindexed : DataArray\n1844             Another dataset array, with this array's data but coordinates from\n1845             the other object.\n1846 \n1847         Examples\n1848         --------\n1849         >>> data = np.arange(12).reshape(4, 3)\n1850         >>> da1 = xr.DataArray(\n1851         ...     data=data,\n1852         ...     dims=[\"x\", \"y\"],\n1853         ...     coords={\"x\": [10, 20, 30, 40], \"y\": [70, 80, 90]},\n1854         ... )\n1855         >>> da1\n1856         <xarray.DataArray (x: 4, y: 3)>\n1857         array([[ 0,  1,  2],\n1858                [ 3,  4,  5],\n1859                [ 6,  7,  8],\n1860                [ 9, 10, 11]])\n1861         Coordinates:\n1862           * x        (x) int64 10 20 30 40\n1863           * y        (y) int64 70 80 90\n1864         >>> da2 = xr.DataArray(\n1865         ...     data=data,\n1866         ...     dims=[\"x\", \"y\"],\n1867         ...     coords={\"x\": [40, 30, 20, 10], \"y\": [90, 80, 70]},\n1868         ... )\n1869         >>> da2\n1870         <xarray.DataArray (x: 4, y: 3)>\n1871         array([[ 0,  1,  2],\n1872                [ 3,  4,  5],\n1873                [ 6,  7,  8],\n1874                [ 9, 10, 11]])\n1875         Coordinates:\n1876           * x        (x) int64 40 30 20 10\n1877           * y        (y) int64 90 80 70\n1878 \n1879         Reindexing with both DataArrays having the same coordinates set, but in different order:\n1880 \n1881         >>> da1.reindex_like(da2)\n1882         <xarray.DataArray (x: 4, y: 3)>\n1883         array([[11, 10,  9],\n1884                [ 8,  7,  6],\n1885                [ 5,  4,  3],\n1886                [ 2,  1,  0]])\n1887         Coordinates:\n1888           * x        (x) int64 40 30 20 10\n1889           * y        (y) int64 90 80 70\n1890 \n1891         Reindexing with the other array having coordinates which the source array doesn't have:\n1892 \n1893         >>> data = np.arange(12).reshape(4, 3)\n1894         >>> da1 = xr.DataArray(\n1895         ...     data=data,\n1896         ...     dims=[\"x\", \"y\"],\n1897         ...     coords={\"x\": [10, 20, 30, 40], \"y\": [70, 80, 90]},\n1898         ... )\n1899         >>> da2 = xr.DataArray(\n1900         ...     data=data,\n1901         ...     dims=[\"x\", \"y\"],\n1902         ...     coords={\"x\": [20, 10, 29, 39], \"y\": [70, 80, 90]},\n1903         ... )\n1904         >>> da1.reindex_like(da2)\n1905         <xarray.DataArray (x: 4, y: 3)>\n1906         array([[ 3.,  4.,  5.],\n1907                [ 0.,  1.,  2.],\n1908                [nan, nan, nan],\n1909                [nan, nan, nan]])\n1910         Coordinates:\n1911           * x        (x) int64 20 10 29 39\n1912           * y        (y) int64 70 80 90\n1913 \n1914         Filling missing values with the previous valid index with respect to the coordinates' value:\n1915 \n1916         >>> da1.reindex_like(da2, method=\"ffill\")\n1917         <xarray.DataArray (x: 4, y: 3)>\n1918         array([[3, 4, 5],\n1919                [0, 1, 2],\n1920                [3, 4, 5],\n1921                [6, 7, 8]])\n1922         Coordinates:\n1923           * x        (x) int64 20 10 29 39\n1924           * y        (y) int64 70 80 90\n1925 \n1926         Filling missing values while tolerating specified error for inexact matches:\n1927 \n1928         >>> da1.reindex_like(da2, method=\"ffill\", tolerance=5)\n1929         <xarray.DataArray (x: 4, y: 3)>\n1930         array([[ 3.,  4.,  5.],\n1931                [ 0.,  1.,  2.],\n1932                [nan, nan, nan],\n1933                [nan, nan, nan]])\n1934         Coordinates:\n1935           * x        (x) int64 20 10 29 39\n1936           * y        (y) int64 70 80 90\n1937 \n1938         Filling missing values with manually specified values:\n1939 \n1940         >>> da1.reindex_like(da2, fill_value=19)\n1941         <xarray.DataArray (x: 4, y: 3)>\n1942         array([[ 3,  4,  5],\n1943                [ 0,  1,  2],\n1944                [19, 19, 19],\n1945                [19, 19, 19]])\n1946         Coordinates:\n1947           * x        (x) int64 20 10 29 39\n1948           * y        (y) int64 70 80 90\n1949 \n1950         See Also\n1951         --------\n1952         DataArray.reindex\n1953         align\n1954         \"\"\"\n1955         return alignment.reindex_like(\n1956             self,\n1957             other=other,\n1958             method=method,\n1959             tolerance=tolerance,\n1960             copy=copy,\n1961             fill_value=fill_value,\n1962         )\n1963 \n1964     def reindex(\n1965         self: T_DataArray,\n1966         indexers: Mapping[Any, Any] | None = None,\n1967         method: ReindexMethodOptions = None,\n1968         tolerance: float | Iterable[float] | None = None,\n1969         copy: bool = True,\n1970         fill_value=dtypes.NA,\n1971         **indexers_kwargs: Any,\n1972     ) -> T_DataArray:\n1973         \"\"\"Conform this object onto the indexes of another object, filling in\n1974         missing values with ``fill_value``. The default fill value is NaN.\n1975 \n1976         Parameters\n1977         ----------\n1978         indexers : dict, optional\n1979             Dictionary with keys given by dimension names and values given by\n1980             arrays of coordinates tick labels. Any mis-matched coordinate\n1981             values will be filled in with NaN, and any mis-matched dimension\n1982             names will simply be ignored.\n1983             One of indexers or indexers_kwargs must be provided.\n1984         copy : bool, optional\n1985             If ``copy=True``, data in the return value is always copied. If\n1986             ``copy=False`` and reindexing is unnecessary, or can be performed\n1987             with only slice operations, then the output may share memory with\n1988             the input. In either case, a new xarray object is always returned.\n1989         method : {None, 'nearest', 'pad'/'ffill', 'backfill'/'bfill'}, optional\n1990             Method to use for filling index values in ``indexers`` not found on\n1991             this data array:\n1992 \n1993             - None (default): don't fill gaps\n1994             - pad / ffill: propagate last valid index value forward\n1995             - backfill / bfill: propagate next valid index value backward\n1996             - nearest: use nearest valid index value\n1997 \n1998         tolerance : float | Iterable[float] | None, default: None\n1999             Maximum distance between original and new labels for inexact\n2000             matches. The values of the index at the matching locations must\n2001             satisfy the equation ``abs(index[indexer] - target) <= tolerance``.\n2002             Tolerance may be a scalar value, which applies the same tolerance\n2003             to all values, or list-like, which applies variable tolerance per\n2004             element. List-like must be the same size as the index and its dtype\n2005             must exactly match the index\u2019s type.\n2006         fill_value : scalar or dict-like, optional\n2007             Value to use for newly missing values. If a dict-like, maps\n2008             variable names (including coordinates) to fill values. Use this\n2009             data array's name to refer to the data array's values.\n2010         **indexers_kwargs : {dim: indexer, ...}, optional\n2011             The keyword arguments form of ``indexers``.\n2012             One of indexers or indexers_kwargs must be provided.\n2013 \n2014         Returns\n2015         -------\n2016         reindexed : DataArray\n2017             Another dataset array, with this array's data but replaced\n2018             coordinates.\n2019 \n2020         Examples\n2021         --------\n2022         Reverse latitude:\n2023 \n2024         >>> da = xr.DataArray(\n2025         ...     np.arange(4),\n2026         ...     coords=[np.array([90, 89, 88, 87])],\n2027         ...     dims=\"lat\",\n2028         ... )\n2029         >>> da\n2030         <xarray.DataArray (lat: 4)>\n2031         array([0, 1, 2, 3])\n2032         Coordinates:\n2033           * lat      (lat) int64 90 89 88 87\n2034         >>> da.reindex(lat=da.lat[::-1])\n2035         <xarray.DataArray (lat: 4)>\n2036         array([3, 2, 1, 0])\n2037         Coordinates:\n2038           * lat      (lat) int64 87 88 89 90\n2039 \n2040         See Also\n2041         --------\n2042         DataArray.reindex_like\n2043         align\n2044         \"\"\"\n2045         indexers = utils.either_dict_or_kwargs(indexers, indexers_kwargs, \"reindex\")\n2046         return alignment.reindex(\n2047             self,\n2048             indexers=indexers,\n2049             method=method,\n2050             tolerance=tolerance,\n2051             copy=copy,\n2052             fill_value=fill_value,\n2053         )\n2054 \n2055     def interp(\n2056         self: T_DataArray,\n2057         coords: Mapping[Any, Any] | None = None,\n2058         method: InterpOptions = \"linear\",\n2059         assume_sorted: bool = False,\n2060         kwargs: Mapping[str, Any] | None = None,\n2061         **coords_kwargs: Any,\n2062     ) -> T_DataArray:\n2063         \"\"\"Interpolate a DataArray onto new coordinates\n2064 \n2065         Performs univariate or multivariate interpolation of a DataArray onto\n2066         new coordinates using scipy's interpolation routines. If interpolating\n2067         along an existing dimension, :py:class:`scipy.interpolate.interp1d` is\n2068         called. When interpolating along multiple existing dimensions, an\n2069         attempt is made to decompose the interpolation into multiple\n2070         1-dimensional interpolations. If this is possible,\n2071         :py:class:`scipy.interpolate.interp1d` is called. Otherwise,\n2072         :py:func:`scipy.interpolate.interpn` is called.\n2073 \n2074         Parameters\n2075         ----------\n2076         coords : dict, optional\n2077             Mapping from dimension names to the new coordinates.\n2078             New coordinate can be a scalar, array-like or DataArray.\n2079             If DataArrays are passed as new coordinates, their dimensions are\n2080             used for the broadcasting. Missing values are skipped.\n2081         method : {\"linear\", \"nearest\", \"zero\", \"slinear\", \"quadratic\", \"cubic\", \"polynomial\"}, default: \"linear\"\n2082             The method used to interpolate. The method should be supported by\n2083             the scipy interpolator:\n2084 \n2085             - ``interp1d``: {\"linear\", \"nearest\", \"zero\", \"slinear\",\n2086               \"quadratic\", \"cubic\", \"polynomial\"}\n2087             - ``interpn``: {\"linear\", \"nearest\"}\n2088 \n2089             If ``\"polynomial\"`` is passed, the ``order`` keyword argument must\n2090             also be provided.\n2091         assume_sorted : bool, default: False\n2092             If False, values of x can be in any order and they are sorted\n2093             first. If True, x has to be an array of monotonically increasing\n2094             values.\n2095         kwargs : dict-like or None, default: None\n2096             Additional keyword arguments passed to scipy's interpolator. Valid\n2097             options and their behavior depend whether ``interp1d`` or\n2098             ``interpn`` is used.\n2099         **coords_kwargs : {dim: coordinate, ...}, optional\n2100             The keyword arguments form of ``coords``.\n2101             One of coords or coords_kwargs must be provided.\n2102 \n2103         Returns\n2104         -------\n2105         interpolated : DataArray\n2106             New dataarray on the new coordinates.\n2107 \n2108         Notes\n2109         -----\n2110         scipy is required.\n2111 \n2112         See Also\n2113         --------\n2114         scipy.interpolate.interp1d\n2115         scipy.interpolate.interpn\n2116 \n2117         Examples\n2118         --------\n2119         >>> da = xr.DataArray(\n2120         ...     data=[[1, 4, 2, 9], [2, 7, 6, np.nan], [6, np.nan, 5, 8]],\n2121         ...     dims=(\"x\", \"y\"),\n2122         ...     coords={\"x\": [0, 1, 2], \"y\": [10, 12, 14, 16]},\n2123         ... )\n2124         >>> da\n2125         <xarray.DataArray (x: 3, y: 4)>\n2126         array([[ 1.,  4.,  2.,  9.],\n2127                [ 2.,  7.,  6., nan],\n2128                [ 6., nan,  5.,  8.]])\n2129         Coordinates:\n2130           * x        (x) int64 0 1 2\n2131           * y        (y) int64 10 12 14 16\n2132 \n2133         1D linear interpolation (the default):\n2134 \n2135         >>> da.interp(x=[0, 0.75, 1.25, 1.75])\n2136         <xarray.DataArray (x: 4, y: 4)>\n2137         array([[1.  , 4.  , 2.  ,  nan],\n2138                [1.75, 6.25, 5.  ,  nan],\n2139                [3.  ,  nan, 5.75,  nan],\n2140                [5.  ,  nan, 5.25,  nan]])\n2141         Coordinates:\n2142           * y        (y) int64 10 12 14 16\n2143           * x        (x) float64 0.0 0.75 1.25 1.75\n2144 \n2145         1D nearest interpolation:\n2146 \n2147         >>> da.interp(x=[0, 0.75, 1.25, 1.75], method=\"nearest\")\n2148         <xarray.DataArray (x: 4, y: 4)>\n2149         array([[ 1.,  4.,  2.,  9.],\n2150                [ 2.,  7.,  6., nan],\n2151                [ 2.,  7.,  6., nan],\n2152                [ 6., nan,  5.,  8.]])\n2153         Coordinates:\n2154           * y        (y) int64 10 12 14 16\n2155           * x        (x) float64 0.0 0.75 1.25 1.75\n2156 \n2157         1D linear extrapolation:\n2158 \n2159         >>> da.interp(\n2160         ...     x=[1, 1.5, 2.5, 3.5],\n2161         ...     method=\"linear\",\n2162         ...     kwargs={\"fill_value\": \"extrapolate\"},\n2163         ... )\n2164         <xarray.DataArray (x: 4, y: 4)>\n2165         array([[ 2. ,  7. ,  6. ,  nan],\n2166                [ 4. ,  nan,  5.5,  nan],\n2167                [ 8. ,  nan,  4.5,  nan],\n2168                [12. ,  nan,  3.5,  nan]])\n2169         Coordinates:\n2170           * y        (y) int64 10 12 14 16\n2171           * x        (x) float64 1.0 1.5 2.5 3.5\n2172 \n2173         2D linear interpolation:\n2174 \n2175         >>> da.interp(x=[0, 0.75, 1.25, 1.75], y=[11, 13, 15], method=\"linear\")\n2176         <xarray.DataArray (x: 4, y: 3)>\n2177         array([[2.5  , 3.   ,   nan],\n2178                [4.   , 5.625,   nan],\n2179                [  nan,   nan,   nan],\n2180                [  nan,   nan,   nan]])\n2181         Coordinates:\n2182           * x        (x) float64 0.0 0.75 1.25 1.75\n2183           * y        (y) int64 11 13 15\n2184         \"\"\"\n2185         if self.dtype.kind not in \"uifc\":\n2186             raise TypeError(\n2187                 \"interp only works for a numeric type array. \"\n2188                 \"Given {}.\".format(self.dtype)\n2189             )\n2190         ds = self._to_temp_dataset().interp(\n2191             coords,\n2192             method=method,\n2193             kwargs=kwargs,\n2194             assume_sorted=assume_sorted,\n2195             **coords_kwargs,\n2196         )\n2197         return self._from_temp_dataset(ds)\n2198 \n2199     def interp_like(\n2200         self: T_DataArray,\n2201         other: DataArray | Dataset,\n2202         method: InterpOptions = \"linear\",\n2203         assume_sorted: bool = False,\n2204         kwargs: Mapping[str, Any] | None = None,\n2205     ) -> T_DataArray:\n2206         \"\"\"Interpolate this object onto the coordinates of another object,\n2207         filling out of range values with NaN.\n2208 \n2209         If interpolating along a single existing dimension,\n2210         :py:class:`scipy.interpolate.interp1d` is called. When interpolating\n2211         along multiple existing dimensions, an attempt is made to decompose the\n2212         interpolation into multiple 1-dimensional interpolations. If this is\n2213         possible, :py:class:`scipy.interpolate.interp1d` is called. Otherwise,\n2214         :py:func:`scipy.interpolate.interpn` is called.\n2215 \n2216         Parameters\n2217         ----------\n2218         other : Dataset or DataArray\n2219             Object with an 'indexes' attribute giving a mapping from dimension\n2220             names to an 1d array-like, which provides coordinates upon\n2221             which to index the variables in this dataset. Missing values are skipped.\n2222         method : {\"linear\", \"nearest\", \"zero\", \"slinear\", \"quadratic\", \"cubic\", \"polynomial\"}, default: \"linear\"\n2223             The method used to interpolate. The method should be supported by\n2224             the scipy interpolator:\n2225 \n2226             - {\"linear\", \"nearest\", \"zero\", \"slinear\", \"quadratic\", \"cubic\",\n2227               \"polynomial\"} when ``interp1d`` is called.\n2228             - {\"linear\", \"nearest\"} when ``interpn`` is called.\n2229 \n2230             If ``\"polynomial\"`` is passed, the ``order`` keyword argument must\n2231             also be provided.\n2232         assume_sorted : bool, default: False\n2233             If False, values of coordinates that are interpolated over can be\n2234             in any order and they are sorted first. If True, interpolated\n2235             coordinates are assumed to be an array of monotonically increasing\n2236             values.\n2237         kwargs : dict, optional\n2238             Additional keyword passed to scipy's interpolator.\n2239 \n2240         Returns\n2241         -------\n2242         interpolated : DataArray\n2243             Another dataarray by interpolating this dataarray's data along the\n2244             coordinates of the other object.\n2245 \n2246         Examples\n2247         --------\n2248         >>> data = np.arange(12).reshape(4, 3)\n2249         >>> da1 = xr.DataArray(\n2250         ...     data=data,\n2251         ...     dims=[\"x\", \"y\"],\n2252         ...     coords={\"x\": [10, 20, 30, 40], \"y\": [70, 80, 90]},\n2253         ... )\n2254         >>> da1\n2255         <xarray.DataArray (x: 4, y: 3)>\n2256         array([[ 0,  1,  2],\n2257                [ 3,  4,  5],\n2258                [ 6,  7,  8],\n2259                [ 9, 10, 11]])\n2260         Coordinates:\n2261           * x        (x) int64 10 20 30 40\n2262           * y        (y) int64 70 80 90\n2263         >>> da2 = xr.DataArray(\n2264         ...     data=data,\n2265         ...     dims=[\"x\", \"y\"],\n2266         ...     coords={\"x\": [10, 20, 29, 39], \"y\": [70, 80, 90]},\n2267         ... )\n2268         >>> da2\n2269         <xarray.DataArray (x: 4, y: 3)>\n2270         array([[ 0,  1,  2],\n2271                [ 3,  4,  5],\n2272                [ 6,  7,  8],\n2273                [ 9, 10, 11]])\n2274         Coordinates:\n2275           * x        (x) int64 10 20 29 39\n2276           * y        (y) int64 70 80 90\n2277 \n2278         Interpolate the values in the coordinates of the other DataArray with respect to the source's values:\n2279 \n2280         >>> da2.interp_like(da1)\n2281         <xarray.DataArray (x: 4, y: 3)>\n2282         array([[0. , 1. , 2. ],\n2283                [3. , 4. , 5. ],\n2284                [6.3, 7.3, 8.3],\n2285                [nan, nan, nan]])\n2286         Coordinates:\n2287           * x        (x) int64 10 20 30 40\n2288           * y        (y) int64 70 80 90\n2289 \n2290         Could also extrapolate missing values:\n2291 \n2292         >>> da2.interp_like(da1, kwargs={\"fill_value\": \"extrapolate\"})\n2293         <xarray.DataArray (x: 4, y: 3)>\n2294         array([[ 0. ,  1. ,  2. ],\n2295                [ 3. ,  4. ,  5. ],\n2296                [ 6.3,  7.3,  8.3],\n2297                [ 9.3, 10.3, 11.3]])\n2298         Coordinates:\n2299           * x        (x) int64 10 20 30 40\n2300           * y        (y) int64 70 80 90\n2301 \n2302         Notes\n2303         -----\n2304         scipy is required.\n2305         If the dataarray has object-type coordinates, reindex is used for these\n2306         coordinates instead of the interpolation.\n2307 \n2308         See Also\n2309         --------\n2310         DataArray.interp\n2311         DataArray.reindex_like\n2312         \"\"\"\n2313         if self.dtype.kind not in \"uifc\":\n2314             raise TypeError(\n2315                 \"interp only works for a numeric type array. \"\n2316                 \"Given {}.\".format(self.dtype)\n2317             )\n2318         ds = self._to_temp_dataset().interp_like(\n2319             other, method=method, kwargs=kwargs, assume_sorted=assume_sorted\n2320         )\n2321         return self._from_temp_dataset(ds)\n2322 \n2323     # change type of self and return to T_DataArray once\n2324     # https://github.com/python/mypy/issues/12846 is resolved\n2325     def rename(\n2326         self,\n2327         new_name_or_name_dict: Hashable | Mapping[Any, Hashable] | None = None,\n2328         **names: Hashable,\n2329     ) -> DataArray:\n2330         \"\"\"Returns a new DataArray with renamed coordinates, dimensions or a new name.\n2331 \n2332         Parameters\n2333         ----------\n2334         new_name_or_name_dict : str or dict-like, optional\n2335             If the argument is dict-like, it used as a mapping from old\n2336             names to new names for coordinates or dimensions. Otherwise,\n2337             use the argument as the new name for this array.\n2338         **names : Hashable, optional\n2339             The keyword arguments form of a mapping from old names to\n2340             new names for coordinates or dimensions.\n2341             One of new_name_or_name_dict or names must be provided.\n2342 \n2343         Returns\n2344         -------\n2345         renamed : DataArray\n2346             Renamed array or array with renamed coordinates.\n2347 \n2348         See Also\n2349         --------\n2350         Dataset.rename\n2351         DataArray.swap_dims\n2352         \"\"\"\n2353         if new_name_or_name_dict is None and not names:\n2354             # change name to None?\n2355             return self._replace(name=None)\n2356         if utils.is_dict_like(new_name_or_name_dict) or new_name_or_name_dict is None:\n2357             # change dims/coords\n2358             name_dict = either_dict_or_kwargs(new_name_or_name_dict, names, \"rename\")\n2359             dataset = self._to_temp_dataset()._rename(name_dict)\n2360             return self._from_temp_dataset(dataset)\n2361         if utils.hashable(new_name_or_name_dict) and names:\n2362             # change name + dims/coords\n2363             dataset = self._to_temp_dataset()._rename(names)\n2364             dataarray = self._from_temp_dataset(dataset)\n2365             return dataarray._replace(name=new_name_or_name_dict)\n2366         # only change name\n2367         return self._replace(name=new_name_or_name_dict)\n2368 \n2369     def swap_dims(\n2370         self: T_DataArray,\n2371         dims_dict: Mapping[Any, Hashable] | None = None,\n2372         **dims_kwargs,\n2373     ) -> T_DataArray:\n2374         \"\"\"Returns a new DataArray with swapped dimensions.\n2375 \n2376         Parameters\n2377         ----------\n2378         dims_dict : dict-like\n2379             Dictionary whose keys are current dimension names and whose values\n2380             are new names.\n2381         **dims_kwargs : {existing_dim: new_dim, ...}, optional\n2382             The keyword arguments form of ``dims_dict``.\n2383             One of dims_dict or dims_kwargs must be provided.\n2384 \n2385         Returns\n2386         -------\n2387         swapped : DataArray\n2388             DataArray with swapped dimensions.\n2389 \n2390         Examples\n2391         --------\n2392         >>> arr = xr.DataArray(\n2393         ...     data=[0, 1],\n2394         ...     dims=\"x\",\n2395         ...     coords={\"x\": [\"a\", \"b\"], \"y\": (\"x\", [0, 1])},\n2396         ... )\n2397         >>> arr\n2398         <xarray.DataArray (x: 2)>\n2399         array([0, 1])\n2400         Coordinates:\n2401           * x        (x) <U1 'a' 'b'\n2402             y        (x) int64 0 1\n2403 \n2404         >>> arr.swap_dims({\"x\": \"y\"})\n2405         <xarray.DataArray (y: 2)>\n2406         array([0, 1])\n2407         Coordinates:\n2408             x        (y) <U1 'a' 'b'\n2409           * y        (y) int64 0 1\n2410 \n2411         >>> arr.swap_dims({\"x\": \"z\"})\n2412         <xarray.DataArray (z: 2)>\n2413         array([0, 1])\n2414         Coordinates:\n2415             x        (z) <U1 'a' 'b'\n2416             y        (z) int64 0 1\n2417         Dimensions without coordinates: z\n2418 \n2419         See Also\n2420         --------\n2421         DataArray.rename\n2422         Dataset.swap_dims\n2423         \"\"\"\n2424         dims_dict = either_dict_or_kwargs(dims_dict, dims_kwargs, \"swap_dims\")\n2425         ds = self._to_temp_dataset().swap_dims(dims_dict)\n2426         return self._from_temp_dataset(ds)\n2427 \n2428     # change type of self and return to T_DataArray once\n2429     # https://github.com/python/mypy/issues/12846 is resolved\n2430     def expand_dims(\n2431         self,\n2432         dim: None | Hashable | Sequence[Hashable] | Mapping[Any, Any] = None,\n2433         axis: None | int | Sequence[int] = None,\n2434         **dim_kwargs: Any,\n2435     ) -> DataArray:\n2436         \"\"\"Return a new object with an additional axis (or axes) inserted at\n2437         the corresponding position in the array shape. The new object is a\n2438         view into the underlying array, not a copy.\n2439 \n2440         If dim is already a scalar coordinate, it will be promoted to a 1D\n2441         coordinate consisting of a single value.\n2442 \n2443         Parameters\n2444         ----------\n2445         dim : Hashable, sequence of Hashable, dict, or None, optional\n2446             Dimensions to include on the new variable.\n2447             If provided as str or sequence of str, then dimensions are inserted\n2448             with length 1. If provided as a dict, then the keys are the new\n2449             dimensions and the values are either integers (giving the length of\n2450             the new dimensions) or sequence/ndarray (giving the coordinates of\n2451             the new dimensions).\n2452         axis : int, sequence of int, or None, default: None\n2453             Axis position(s) where new axis is to be inserted (position(s) on\n2454             the result array). If a sequence of integers is passed,\n2455             multiple axes are inserted. In this case, dim arguments should be\n2456             same length list. If axis=None is passed, all the axes will be\n2457             inserted to the start of the result array.\n2458         **dim_kwargs : int or sequence or ndarray\n2459             The keywords are arbitrary dimensions being inserted and the values\n2460             are either the lengths of the new dims (if int is given), or their\n2461             coordinates. Note, this is an alternative to passing a dict to the\n2462             dim kwarg and will only be used if dim is None.\n2463 \n2464         Returns\n2465         -------\n2466         expanded : DataArray\n2467             This object, but with additional dimension(s).\n2468 \n2469         See Also\n2470         --------\n2471         Dataset.expand_dims\n2472 \n2473         Examples\n2474         --------\n2475         >>> da = xr.DataArray(np.arange(5), dims=(\"x\"))\n2476         >>> da\n2477         <xarray.DataArray (x: 5)>\n2478         array([0, 1, 2, 3, 4])\n2479         Dimensions without coordinates: x\n2480 \n2481         Add new dimension of length 2:\n2482 \n2483         >>> da.expand_dims(dim={\"y\": 2})\n2484         <xarray.DataArray (y: 2, x: 5)>\n2485         array([[0, 1, 2, 3, 4],\n2486                [0, 1, 2, 3, 4]])\n2487         Dimensions without coordinates: y, x\n2488 \n2489         >>> da.expand_dims(dim={\"y\": 2}, axis=1)\n2490         <xarray.DataArray (x: 5, y: 2)>\n2491         array([[0, 0],\n2492                [1, 1],\n2493                [2, 2],\n2494                [3, 3],\n2495                [4, 4]])\n2496         Dimensions without coordinates: x, y\n2497 \n2498         Add a new dimension with coordinates from array:\n2499 \n2500         >>> da.expand_dims(dim={\"y\": np.arange(5)}, axis=0)\n2501         <xarray.DataArray (y: 5, x: 5)>\n2502         array([[0, 1, 2, 3, 4],\n2503                [0, 1, 2, 3, 4],\n2504                [0, 1, 2, 3, 4],\n2505                [0, 1, 2, 3, 4],\n2506                [0, 1, 2, 3, 4]])\n2507         Coordinates:\n2508           * y        (y) int64 0 1 2 3 4\n2509         Dimensions without coordinates: x\n2510         \"\"\"\n2511         if isinstance(dim, int):\n2512             raise TypeError(\"dim should be Hashable or sequence/mapping of Hashables\")\n2513         elif isinstance(dim, Sequence) and not isinstance(dim, str):\n2514             if len(dim) != len(set(dim)):\n2515                 raise ValueError(\"dims should not contain duplicate values.\")\n2516             dim = dict.fromkeys(dim, 1)\n2517         elif dim is not None and not isinstance(dim, Mapping):\n2518             dim = {cast(Hashable, dim): 1}\n2519 \n2520         dim = either_dict_or_kwargs(dim, dim_kwargs, \"expand_dims\")\n2521         ds = self._to_temp_dataset().expand_dims(dim, axis)\n2522         return self._from_temp_dataset(ds)\n2523 \n2524     # change type of self and return to T_DataArray once\n2525     # https://github.com/python/mypy/issues/12846 is resolved\n2526     def set_index(\n2527         self,\n2528         indexes: Mapping[Any, Hashable | Sequence[Hashable]] | None = None,\n2529         append: bool = False,\n2530         **indexes_kwargs: Hashable | Sequence[Hashable],\n2531     ) -> DataArray:\n2532         \"\"\"Set DataArray (multi-)indexes using one or more existing\n2533         coordinates.\n2534 \n2535         This legacy method is limited to pandas (multi-)indexes and\n2536         1-dimensional \"dimension\" coordinates. See\n2537         :py:meth:`~DataArray.set_xindex` for setting a pandas or a custom\n2538         Xarray-compatible index from one or more arbitrary coordinates.\n2539 \n2540         Parameters\n2541         ----------\n2542         indexes : {dim: index, ...}\n2543             Mapping from names matching dimensions and values given\n2544             by (lists of) the names of existing coordinates or variables to set\n2545             as new (multi-)index.\n2546         append : bool, default: False\n2547             If True, append the supplied index(es) to the existing index(es).\n2548             Otherwise replace the existing index(es).\n2549         **indexes_kwargs : optional\n2550             The keyword arguments form of ``indexes``.\n2551             One of indexes or indexes_kwargs must be provided.\n2552 \n2553         Returns\n2554         -------\n2555         obj : DataArray\n2556             Another DataArray, with this data but replaced coordinates.\n2557 \n2558         Examples\n2559         --------\n2560         >>> arr = xr.DataArray(\n2561         ...     data=np.ones((2, 3)),\n2562         ...     dims=[\"x\", \"y\"],\n2563         ...     coords={\"x\": range(2), \"y\": range(3), \"a\": (\"x\", [3, 4])},\n2564         ... )\n2565         >>> arr\n2566         <xarray.DataArray (x: 2, y: 3)>\n2567         array([[1., 1., 1.],\n2568                [1., 1., 1.]])\n2569         Coordinates:\n2570           * x        (x) int64 0 1\n2571           * y        (y) int64 0 1 2\n2572             a        (x) int64 3 4\n2573         >>> arr.set_index(x=\"a\")\n2574         <xarray.DataArray (x: 2, y: 3)>\n2575         array([[1., 1., 1.],\n2576                [1., 1., 1.]])\n2577         Coordinates:\n2578           * x        (x) int64 3 4\n2579           * y        (y) int64 0 1 2\n2580 \n2581         See Also\n2582         --------\n2583         DataArray.reset_index\n2584         DataArray.set_xindex\n2585         \"\"\"\n2586         ds = self._to_temp_dataset().set_index(indexes, append=append, **indexes_kwargs)\n2587         return self._from_temp_dataset(ds)\n2588 \n2589     # change type of self and return to T_DataArray once\n2590     # https://github.com/python/mypy/issues/12846 is resolved\n2591     def reset_index(\n2592         self,\n2593         dims_or_levels: Hashable | Sequence[Hashable],\n2594         drop: bool = False,\n2595     ) -> DataArray:\n2596         \"\"\"Reset the specified index(es) or multi-index level(s).\n2597 \n2598         This legacy method is specific to pandas (multi-)indexes and\n2599         1-dimensional \"dimension\" coordinates. See the more generic\n2600         :py:meth:`~DataArray.drop_indexes` and :py:meth:`~DataArray.set_xindex`\n2601         method to respectively drop and set pandas or custom indexes for\n2602         arbitrary coordinates.\n2603 \n2604         Parameters\n2605         ----------\n2606         dims_or_levels : Hashable or sequence of Hashable\n2607             Name(s) of the dimension(s) and/or multi-index level(s) that will\n2608             be reset.\n2609         drop : bool, default: False\n2610             If True, remove the specified indexes and/or multi-index levels\n2611             instead of extracting them as new coordinates (default: False).\n2612 \n2613         Returns\n2614         -------\n2615         obj : DataArray\n2616             Another dataarray, with this dataarray's data but replaced\n2617             coordinates.\n2618 \n2619         See Also\n2620         --------\n2621         DataArray.set_index\n2622         DataArray.set_xindex\n2623         DataArray.drop_indexes\n2624         \"\"\"\n2625         ds = self._to_temp_dataset().reset_index(dims_or_levels, drop=drop)\n2626         return self._from_temp_dataset(ds)\n2627 \n2628     def set_xindex(\n2629         self: T_DataArray,\n2630         coord_names: str | Sequence[Hashable],\n2631         index_cls: type[Index] | None = None,\n2632         **options,\n2633     ) -> T_DataArray:\n2634         \"\"\"Set a new, Xarray-compatible index from one or more existing\n2635         coordinate(s).\n2636 \n2637         Parameters\n2638         ----------\n2639         coord_names : str or list\n2640             Name(s) of the coordinate(s) used to build the index.\n2641             If several names are given, their order matters.\n2642         index_cls : subclass of :class:`~xarray.indexes.Index`\n2643             The type of index to create. By default, try setting\n2644             a pandas (multi-)index from the supplied coordinates.\n2645         **options\n2646             Options passed to the index constructor.\n2647 \n2648         Returns\n2649         -------\n2650         obj : DataArray\n2651             Another dataarray, with this dataarray's data and with a new index.\n2652 \n2653         \"\"\"\n2654         ds = self._to_temp_dataset().set_xindex(coord_names, index_cls, **options)\n2655         return self._from_temp_dataset(ds)\n2656 \n2657     def reorder_levels(\n2658         self: T_DataArray,\n2659         dim_order: Mapping[Any, Sequence[int | Hashable]] | None = None,\n2660         **dim_order_kwargs: Sequence[int | Hashable],\n2661     ) -> T_DataArray:\n2662         \"\"\"Rearrange index levels using input order.\n2663 \n2664         Parameters\n2665         ----------\n2666         dim_order dict-like of Hashable to int or Hashable: optional\n2667             Mapping from names matching dimensions and values given\n2668             by lists representing new level orders. Every given dimension\n2669             must have a multi-index.\n2670         **dim_order_kwargs : optional\n2671             The keyword arguments form of ``dim_order``.\n2672             One of dim_order or dim_order_kwargs must be provided.\n2673 \n2674         Returns\n2675         -------\n2676         obj : DataArray\n2677             Another dataarray, with this dataarray's data but replaced\n2678             coordinates.\n2679         \"\"\"\n2680         ds = self._to_temp_dataset().reorder_levels(dim_order, **dim_order_kwargs)\n2681         return self._from_temp_dataset(ds)\n2682 \n2683     def stack(\n2684         self: T_DataArray,\n2685         dimensions: Mapping[Any, Sequence[Hashable]] | None = None,\n2686         create_index: bool | None = True,\n2687         index_cls: type[Index] = PandasMultiIndex,\n2688         **dimensions_kwargs: Sequence[Hashable],\n2689     ) -> T_DataArray:\n2690         \"\"\"\n2691         Stack any number of existing dimensions into a single new dimension.\n2692 \n2693         New dimensions will be added at the end, and the corresponding\n2694         coordinate variables will be combined into a MultiIndex.\n2695 \n2696         Parameters\n2697         ----------\n2698         dimensions : mapping of Hashable to sequence of Hashable\n2699             Mapping of the form `new_name=(dim1, dim2, ...)`.\n2700             Names of new dimensions, and the existing dimensions that they\n2701             replace. An ellipsis (`...`) will be replaced by all unlisted dimensions.\n2702             Passing a list containing an ellipsis (`stacked_dim=[...]`) will stack over\n2703             all dimensions.\n2704         create_index : bool or None, default: True\n2705             If True, create a multi-index for each of the stacked dimensions.\n2706             If False, don't create any index.\n2707             If None, create a multi-index only if exactly one single (1-d) coordinate\n2708             index is found for every dimension to stack.\n2709         index_cls: class, optional\n2710             Can be used to pass a custom multi-index type. Must be an Xarray index that\n2711             implements `.stack()`. By default, a pandas multi-index wrapper is used.\n2712         **dimensions_kwargs\n2713             The keyword arguments form of ``dimensions``.\n2714             One of dimensions or dimensions_kwargs must be provided.\n2715 \n2716         Returns\n2717         -------\n2718         stacked : DataArray\n2719             DataArray with stacked data.\n2720 \n2721         Examples\n2722         --------\n2723         >>> arr = xr.DataArray(\n2724         ...     np.arange(6).reshape(2, 3),\n2725         ...     coords=[(\"x\", [\"a\", \"b\"]), (\"y\", [0, 1, 2])],\n2726         ... )\n2727         >>> arr\n2728         <xarray.DataArray (x: 2, y: 3)>\n2729         array([[0, 1, 2],\n2730                [3, 4, 5]])\n2731         Coordinates:\n2732           * x        (x) <U1 'a' 'b'\n2733           * y        (y) int64 0 1 2\n2734         >>> stacked = arr.stack(z=(\"x\", \"y\"))\n2735         >>> stacked.indexes[\"z\"]\n2736         MultiIndex([('a', 0),\n2737                     ('a', 1),\n2738                     ('a', 2),\n2739                     ('b', 0),\n2740                     ('b', 1),\n2741                     ('b', 2)],\n2742                    name='z')\n2743 \n2744         See Also\n2745         --------\n2746         DataArray.unstack\n2747         \"\"\"\n2748         ds = self._to_temp_dataset().stack(\n2749             dimensions,\n2750             create_index=create_index,\n2751             index_cls=index_cls,\n2752             **dimensions_kwargs,\n2753         )\n2754         return self._from_temp_dataset(ds)\n2755 \n2756     # change type of self and return to T_DataArray once\n2757     # https://github.com/python/mypy/issues/12846 is resolved\n2758     def unstack(\n2759         self,\n2760         dim: Dims = None,\n2761         fill_value: Any = dtypes.NA,\n2762         sparse: bool = False,\n2763     ) -> DataArray:\n2764         \"\"\"\n2765         Unstack existing dimensions corresponding to MultiIndexes into\n2766         multiple new dimensions.\n2767 \n2768         New dimensions will be added at the end.\n2769 \n2770         Parameters\n2771         ----------\n2772         dim : str, Iterable of Hashable or None, optional\n2773             Dimension(s) over which to unstack. By default unstacks all\n2774             MultiIndexes.\n2775         fill_value : scalar or dict-like, default: nan\n2776             Value to be filled. If a dict-like, maps variable names to\n2777             fill values. Use the data array's name to refer to its\n2778             name. If not provided or if the dict-like does not contain\n2779             all variables, the dtype's NA value will be used.\n2780         sparse : bool, default: False\n2781             Use sparse-array if True\n2782 \n2783         Returns\n2784         -------\n2785         unstacked : DataArray\n2786             Array with unstacked data.\n2787 \n2788         Examples\n2789         --------\n2790         >>> arr = xr.DataArray(\n2791         ...     np.arange(6).reshape(2, 3),\n2792         ...     coords=[(\"x\", [\"a\", \"b\"]), (\"y\", [0, 1, 2])],\n2793         ... )\n2794         >>> arr\n2795         <xarray.DataArray (x: 2, y: 3)>\n2796         array([[0, 1, 2],\n2797                [3, 4, 5]])\n2798         Coordinates:\n2799           * x        (x) <U1 'a' 'b'\n2800           * y        (y) int64 0 1 2\n2801         >>> stacked = arr.stack(z=(\"x\", \"y\"))\n2802         >>> stacked.indexes[\"z\"]\n2803         MultiIndex([('a', 0),\n2804                     ('a', 1),\n2805                     ('a', 2),\n2806                     ('b', 0),\n2807                     ('b', 1),\n2808                     ('b', 2)],\n2809                    name='z')\n2810         >>> roundtripped = stacked.unstack()\n2811         >>> arr.identical(roundtripped)\n2812         True\n2813 \n2814         See Also\n2815         --------\n2816         DataArray.stack\n2817         \"\"\"\n2818         ds = self._to_temp_dataset().unstack(dim, fill_value, sparse)\n2819         return self._from_temp_dataset(ds)\n2820 \n2821     def to_unstacked_dataset(self, dim: Hashable, level: int | Hashable = 0) -> Dataset:\n2822         \"\"\"Unstack DataArray expanding to Dataset along a given level of a\n2823         stacked coordinate.\n2824 \n2825         This is the inverse operation of Dataset.to_stacked_array.\n2826 \n2827         Parameters\n2828         ----------\n2829         dim : Hashable\n2830             Name of existing dimension to unstack\n2831         level : int or Hashable, default: 0\n2832             The MultiIndex level to expand to a dataset along. Can either be\n2833             the integer index of the level or its name.\n2834 \n2835         Returns\n2836         -------\n2837         unstacked: Dataset\n2838 \n2839         Examples\n2840         --------\n2841         >>> arr = xr.DataArray(\n2842         ...     np.arange(6).reshape(2, 3),\n2843         ...     coords=[(\"x\", [\"a\", \"b\"]), (\"y\", [0, 1, 2])],\n2844         ... )\n2845         >>> data = xr.Dataset({\"a\": arr, \"b\": arr.isel(y=0)})\n2846         >>> data\n2847         <xarray.Dataset>\n2848         Dimensions:  (x: 2, y: 3)\n2849         Coordinates:\n2850           * x        (x) <U1 'a' 'b'\n2851           * y        (y) int64 0 1 2\n2852         Data variables:\n2853             a        (x, y) int64 0 1 2 3 4 5\n2854             b        (x) int64 0 3\n2855         >>> stacked = data.to_stacked_array(\"z\", [\"x\"])\n2856         >>> stacked.indexes[\"z\"]\n2857         MultiIndex([('a', 0.0),\n2858                     ('a', 1.0),\n2859                     ('a', 2.0),\n2860                     ('b', nan)],\n2861                    name='z')\n2862         >>> roundtripped = stacked.to_unstacked_dataset(dim=\"z\")\n2863         >>> data.identical(roundtripped)\n2864         True\n2865 \n2866         See Also\n2867         --------\n2868         Dataset.to_stacked_array\n2869         \"\"\"\n2870         idx = self._indexes[dim].to_pandas_index()\n2871         if not isinstance(idx, pd.MultiIndex):\n2872             raise ValueError(f\"'{dim}' is not a stacked coordinate\")\n2873 \n2874         level_number = idx._get_level_number(level)\n2875         variables = idx.levels[level_number]\n2876         variable_dim = idx.names[level_number]\n2877 \n2878         # pull variables out of datarray\n2879         data_dict = {}\n2880         for k in variables:\n2881             data_dict[k] = self.sel({variable_dim: k}, drop=True).squeeze(drop=True)\n2882 \n2883         # unstacked dataset\n2884         return Dataset(data_dict)\n2885 \n2886     def transpose(\n2887         self: T_DataArray,\n2888         *dims: Hashable,\n2889         transpose_coords: bool = True,\n2890         missing_dims: ErrorOptionsWithWarn = \"raise\",\n2891     ) -> T_DataArray:\n2892         \"\"\"Return a new DataArray object with transposed dimensions.\n2893 \n2894         Parameters\n2895         ----------\n2896         *dims : Hashable, optional\n2897             By default, reverse the dimensions. Otherwise, reorder the\n2898             dimensions to this order.\n2899         transpose_coords : bool, default: True\n2900             If True, also transpose the coordinates of this DataArray.\n2901         missing_dims : {\"raise\", \"warn\", \"ignore\"}, default: \"raise\"\n2902             What to do if dimensions that should be selected from are not present in the\n2903             DataArray:\n2904             - \"raise\": raise an exception\n2905             - \"warn\": raise a warning, and ignore the missing dimensions\n2906             - \"ignore\": ignore the missing dimensions\n2907 \n2908         Returns\n2909         -------\n2910         transposed : DataArray\n2911             The returned DataArray's array is transposed.\n2912 \n2913         Notes\n2914         -----\n2915         This operation returns a view of this array's data. It is\n2916         lazy for dask-backed DataArrays but not for numpy-backed DataArrays\n2917         -- the data will be fully loaded.\n2918 \n2919         See Also\n2920         --------\n2921         numpy.transpose\n2922         Dataset.transpose\n2923         \"\"\"\n2924         if dims:\n2925             dims = tuple(utils.infix_dims(dims, self.dims, missing_dims))\n2926         variable = self.variable.transpose(*dims)\n2927         if transpose_coords:\n2928             coords: dict[Hashable, Variable] = {}\n2929             for name, coord in self.coords.items():\n2930                 coord_dims = tuple(dim for dim in dims if dim in coord.dims)\n2931                 coords[name] = coord.variable.transpose(*coord_dims)\n2932             return self._replace(variable, coords)\n2933         else:\n2934             return self._replace(variable)\n2935 \n2936     @property\n2937     def T(self: T_DataArray) -> T_DataArray:\n2938         return self.transpose()\n2939 \n2940     # change type of self and return to T_DataArray once\n2941     # https://github.com/python/mypy/issues/12846 is resolved\n2942     def drop_vars(\n2943         self,\n2944         names: Hashable | Iterable[Hashable],\n2945         *,\n2946         errors: ErrorOptions = \"raise\",\n2947     ) -> DataArray:\n2948         \"\"\"Returns an array with dropped variables.\n2949 \n2950         Parameters\n2951         ----------\n2952         names : Hashable or iterable of Hashable\n2953             Name(s) of variables to drop.\n2954         errors : {\"raise\", \"ignore\"}, default: \"raise\"\n2955             If 'raise', raises a ValueError error if any of the variable\n2956             passed are not in the dataset. If 'ignore', any given names that are in the\n2957             DataArray are dropped and no error is raised.\n2958 \n2959         Returns\n2960         -------\n2961         dropped : Dataset\n2962             New Dataset copied from `self` with variables removed.\n2963 \n2964         Examples\n2965         -------\n2966         >>> data = np.arange(12).reshape(4, 3)\n2967         >>> da = xr.DataArray(\n2968         ...     data=data,\n2969         ...     dims=[\"x\", \"y\"],\n2970         ...     coords={\"x\": [10, 20, 30, 40], \"y\": [70, 80, 90]},\n2971         ... )\n2972         >>> da\n2973         <xarray.DataArray (x: 4, y: 3)>\n2974         array([[ 0,  1,  2],\n2975                [ 3,  4,  5],\n2976                [ 6,  7,  8],\n2977                [ 9, 10, 11]])\n2978         Coordinates:\n2979           * x        (x) int64 10 20 30 40\n2980           * y        (y) int64 70 80 90\n2981 \n2982         Removing a single variable:\n2983 \n2984         >>> da.drop_vars(\"x\")\n2985         <xarray.DataArray (x: 4, y: 3)>\n2986         array([[ 0,  1,  2],\n2987                [ 3,  4,  5],\n2988                [ 6,  7,  8],\n2989                [ 9, 10, 11]])\n2990         Coordinates:\n2991           * y        (y) int64 70 80 90\n2992         Dimensions without coordinates: x\n2993 \n2994         Removing a list of variables:\n2995 \n2996         >>> da.drop_vars([\"x\", \"y\"])\n2997         <xarray.DataArray (x: 4, y: 3)>\n2998         array([[ 0,  1,  2],\n2999                [ 3,  4,  5],\n3000                [ 6,  7,  8],\n3001                [ 9, 10, 11]])\n3002         Dimensions without coordinates: x, y\n3003         \"\"\"\n3004         ds = self._to_temp_dataset().drop_vars(names, errors=errors)\n3005         return self._from_temp_dataset(ds)\n3006 \n3007     def drop_indexes(\n3008         self: T_DataArray,\n3009         coord_names: Hashable | Iterable[Hashable],\n3010         *,\n3011         errors: ErrorOptions = \"raise\",\n3012     ) -> T_DataArray:\n3013         \"\"\"Drop the indexes assigned to the given coordinates.\n3014 \n3015         Parameters\n3016         ----------\n3017         coord_names : hashable or iterable of hashable\n3018             Name(s) of the coordinate(s) for which to drop the index.\n3019         errors : {\"raise\", \"ignore\"}, default: \"raise\"\n3020             If 'raise', raises a ValueError error if any of the coordinates\n3021             passed have no index or are not in the dataset.\n3022             If 'ignore', no error is raised.\n3023 \n3024         Returns\n3025         -------\n3026         dropped : DataArray\n3027             A new dataarray with dropped indexes.\n3028         \"\"\"\n3029         ds = self._to_temp_dataset().drop_indexes(coord_names, errors=errors)\n3030         return self._from_temp_dataset(ds)\n3031 \n3032     def drop(\n3033         self: T_DataArray,\n3034         labels: Mapping[Any, Any] | None = None,\n3035         dim: Hashable | None = None,\n3036         *,\n3037         errors: ErrorOptions = \"raise\",\n3038         **labels_kwargs,\n3039     ) -> T_DataArray:\n3040         \"\"\"Backward compatible method based on `drop_vars` and `drop_sel`\n3041 \n3042         Using either `drop_vars` or `drop_sel` is encouraged\n3043 \n3044         See Also\n3045         --------\n3046         DataArray.drop_vars\n3047         DataArray.drop_sel\n3048         \"\"\"\n3049         ds = self._to_temp_dataset().drop(labels, dim, errors=errors, **labels_kwargs)\n3050         return self._from_temp_dataset(ds)\n3051 \n3052     def drop_sel(\n3053         self: T_DataArray,\n3054         labels: Mapping[Any, Any] | None = None,\n3055         *,\n3056         errors: ErrorOptions = \"raise\",\n3057         **labels_kwargs,\n3058     ) -> T_DataArray:\n3059         \"\"\"Drop index labels from this DataArray.\n3060 \n3061         Parameters\n3062         ----------\n3063         labels : mapping of Hashable to Any\n3064             Index labels to drop\n3065         errors : {\"raise\", \"ignore\"}, default: \"raise\"\n3066             If 'raise', raises a ValueError error if\n3067             any of the index labels passed are not\n3068             in the dataset. If 'ignore', any given labels that are in the\n3069             dataset are dropped and no error is raised.\n3070         **labels_kwargs : {dim: label, ...}, optional\n3071             The keyword arguments form of ``dim`` and ``labels``\n3072 \n3073         Returns\n3074         -------\n3075         dropped : DataArray\n3076 \n3077         Examples\n3078         --------\n3079         >>> da = xr.DataArray(\n3080         ...     np.arange(25).reshape(5, 5),\n3081         ...     coords={\"x\": np.arange(0, 9, 2), \"y\": np.arange(0, 13, 3)},\n3082         ...     dims=(\"x\", \"y\"),\n3083         ... )\n3084         >>> da\n3085         <xarray.DataArray (x: 5, y: 5)>\n3086         array([[ 0,  1,  2,  3,  4],\n3087                [ 5,  6,  7,  8,  9],\n3088                [10, 11, 12, 13, 14],\n3089                [15, 16, 17, 18, 19],\n3090                [20, 21, 22, 23, 24]])\n3091         Coordinates:\n3092           * x        (x) int64 0 2 4 6 8\n3093           * y        (y) int64 0 3 6 9 12\n3094 \n3095         >>> da.drop_sel(x=[0, 2], y=9)\n3096         <xarray.DataArray (x: 3, y: 4)>\n3097         array([[10, 11, 12, 14],\n3098                [15, 16, 17, 19],\n3099                [20, 21, 22, 24]])\n3100         Coordinates:\n3101           * x        (x) int64 4 6 8\n3102           * y        (y) int64 0 3 6 12\n3103 \n3104         >>> da.drop_sel({\"x\": 6, \"y\": [0, 3]})\n3105         <xarray.DataArray (x: 4, y: 3)>\n3106         array([[ 2,  3,  4],\n3107                [ 7,  8,  9],\n3108                [12, 13, 14],\n3109                [22, 23, 24]])\n3110         Coordinates:\n3111           * x        (x) int64 0 2 4 8\n3112           * y        (y) int64 6 9 12\n3113         \"\"\"\n3114         if labels_kwargs or isinstance(labels, dict):\n3115             labels = either_dict_or_kwargs(labels, labels_kwargs, \"drop\")\n3116 \n3117         ds = self._to_temp_dataset().drop_sel(labels, errors=errors)\n3118         return self._from_temp_dataset(ds)\n3119 \n3120     def drop_isel(\n3121         self: T_DataArray, indexers: Mapping[Any, Any] | None = None, **indexers_kwargs\n3122     ) -> T_DataArray:\n3123         \"\"\"Drop index positions from this DataArray.\n3124 \n3125         Parameters\n3126         ----------\n3127         indexers : mapping of Hashable to Any or None, default: None\n3128             Index locations to drop\n3129         **indexers_kwargs : {dim: position, ...}, optional\n3130             The keyword arguments form of ``dim`` and ``positions``\n3131 \n3132         Returns\n3133         -------\n3134         dropped : DataArray\n3135 \n3136         Raises\n3137         ------\n3138         IndexError\n3139 \n3140         Examples\n3141         --------\n3142         >>> da = xr.DataArray(np.arange(25).reshape(5, 5), dims=(\"X\", \"Y\"))\n3143         >>> da\n3144         <xarray.DataArray (X: 5, Y: 5)>\n3145         array([[ 0,  1,  2,  3,  4],\n3146                [ 5,  6,  7,  8,  9],\n3147                [10, 11, 12, 13, 14],\n3148                [15, 16, 17, 18, 19],\n3149                [20, 21, 22, 23, 24]])\n3150         Dimensions without coordinates: X, Y\n3151 \n3152         >>> da.drop_isel(X=[0, 4], Y=2)\n3153         <xarray.DataArray (X: 3, Y: 4)>\n3154         array([[ 5,  6,  8,  9],\n3155                [10, 11, 13, 14],\n3156                [15, 16, 18, 19]])\n3157         Dimensions without coordinates: X, Y\n3158 \n3159         >>> da.drop_isel({\"X\": 3, \"Y\": 3})\n3160         <xarray.DataArray (X: 4, Y: 4)>\n3161         array([[ 0,  1,  2,  4],\n3162                [ 5,  6,  7,  9],\n3163                [10, 11, 12, 14],\n3164                [20, 21, 22, 24]])\n3165         Dimensions without coordinates: X, Y\n3166         \"\"\"\n3167         dataset = self._to_temp_dataset()\n3168         dataset = dataset.drop_isel(indexers=indexers, **indexers_kwargs)\n3169         return self._from_temp_dataset(dataset)\n3170 \n3171     def dropna(\n3172         self: T_DataArray,\n3173         dim: Hashable,\n3174         how: Literal[\"any\", \"all\"] = \"any\",\n3175         thresh: int | None = None,\n3176     ) -> T_DataArray:\n3177         \"\"\"Returns a new array with dropped labels for missing values along\n3178         the provided dimension.\n3179 \n3180         Parameters\n3181         ----------\n3182         dim : Hashable\n3183             Dimension along which to drop missing values. Dropping along\n3184             multiple dimensions simultaneously is not yet supported.\n3185         how : {\"any\", \"all\"}, default: \"any\"\n3186             - any : if any NA values are present, drop that label\n3187             - all : if all values are NA, drop that label\n3188 \n3189         thresh : int or None, default: None\n3190             If supplied, require this many non-NA values.\n3191 \n3192         Returns\n3193         -------\n3194         dropped : DataArray\n3195 \n3196         Examples\n3197         --------\n3198         >>> temperature = [\n3199         ...     [0, 4, 2, 9],\n3200         ...     [np.nan, np.nan, np.nan, np.nan],\n3201         ...     [np.nan, 4, 2, 0],\n3202         ...     [3, 1, 0, 0],\n3203         ... ]\n3204         >>> da = xr.DataArray(\n3205         ...     data=temperature,\n3206         ...     dims=[\"Y\", \"X\"],\n3207         ...     coords=dict(\n3208         ...         lat=(\"Y\", np.array([-20.0, -20.25, -20.50, -20.75])),\n3209         ...         lon=(\"X\", np.array([10.0, 10.25, 10.5, 10.75])),\n3210         ...     ),\n3211         ... )\n3212         >>> da\n3213         <xarray.DataArray (Y: 4, X: 4)>\n3214         array([[ 0.,  4.,  2.,  9.],\n3215                [nan, nan, nan, nan],\n3216                [nan,  4.,  2.,  0.],\n3217                [ 3.,  1.,  0.,  0.]])\n3218         Coordinates:\n3219             lat      (Y) float64 -20.0 -20.25 -20.5 -20.75\n3220             lon      (X) float64 10.0 10.25 10.5 10.75\n3221         Dimensions without coordinates: Y, X\n3222 \n3223         >>> da.dropna(dim=\"Y\", how=\"any\")\n3224         <xarray.DataArray (Y: 2, X: 4)>\n3225         array([[0., 4., 2., 9.],\n3226                [3., 1., 0., 0.]])\n3227         Coordinates:\n3228             lat      (Y) float64 -20.0 -20.75\n3229             lon      (X) float64 10.0 10.25 10.5 10.75\n3230         Dimensions without coordinates: Y, X\n3231 \n3232         Drop values only if all values along the dimension are NaN:\n3233 \n3234         >>> da.dropna(dim=\"Y\", how=\"all\")\n3235         <xarray.DataArray (Y: 3, X: 4)>\n3236         array([[ 0.,  4.,  2.,  9.],\n3237                [nan,  4.,  2.,  0.],\n3238                [ 3.,  1.,  0.,  0.]])\n3239         Coordinates:\n3240             lat      (Y) float64 -20.0 -20.5 -20.75\n3241             lon      (X) float64 10.0 10.25 10.5 10.75\n3242         Dimensions without coordinates: Y, X\n3243         \"\"\"\n3244         ds = self._to_temp_dataset().dropna(dim, how=how, thresh=thresh)\n3245         return self._from_temp_dataset(ds)\n3246 \n3247     def fillna(self: T_DataArray, value: Any) -> T_DataArray:\n3248         \"\"\"Fill missing values in this object.\n3249 \n3250         This operation follows the normal broadcasting and alignment rules that\n3251         xarray uses for binary arithmetic, except the result is aligned to this\n3252         object (``join='left'``) instead of aligned to the intersection of\n3253         index coordinates (``join='inner'``).\n3254 \n3255         Parameters\n3256         ----------\n3257         value : scalar, ndarray or DataArray\n3258             Used to fill all matching missing values in this array. If the\n3259             argument is a DataArray, it is first aligned with (reindexed to)\n3260             this array.\n3261 \n3262         Returns\n3263         -------\n3264         filled : DataArray\n3265 \n3266         Examples\n3267         --------\n3268         >>> da = xr.DataArray(\n3269         ...     np.array([1, 4, np.nan, 0, 3, np.nan]),\n3270         ...     dims=\"Z\",\n3271         ...     coords=dict(\n3272         ...         Z=(\"Z\", np.arange(6)),\n3273         ...         height=(\"Z\", np.array([0, 10, 20, 30, 40, 50])),\n3274         ...     ),\n3275         ... )\n3276         >>> da\n3277         <xarray.DataArray (Z: 6)>\n3278         array([ 1.,  4., nan,  0.,  3., nan])\n3279         Coordinates:\n3280           * Z        (Z) int64 0 1 2 3 4 5\n3281             height   (Z) int64 0 10 20 30 40 50\n3282 \n3283         Fill all NaN values with 0:\n3284 \n3285         >>> da.fillna(0)\n3286         <xarray.DataArray (Z: 6)>\n3287         array([1., 4., 0., 0., 3., 0.])\n3288         Coordinates:\n3289           * Z        (Z) int64 0 1 2 3 4 5\n3290             height   (Z) int64 0 10 20 30 40 50\n3291 \n3292         Fill NaN values with corresponding values in array:\n3293 \n3294         >>> da.fillna(np.array([2, 9, 4, 2, 8, 9]))\n3295         <xarray.DataArray (Z: 6)>\n3296         array([1., 4., 4., 0., 3., 9.])\n3297         Coordinates:\n3298           * Z        (Z) int64 0 1 2 3 4 5\n3299             height   (Z) int64 0 10 20 30 40 50\n3300         \"\"\"\n3301         if utils.is_dict_like(value):\n3302             raise TypeError(\n3303                 \"cannot provide fill value as a dictionary with \"\n3304                 \"fillna on a DataArray\"\n3305             )\n3306         out = ops.fillna(self, value)\n3307         return out\n3308 \n3309     def interpolate_na(\n3310         self: T_DataArray,\n3311         dim: Hashable | None = None,\n3312         method: InterpOptions = \"linear\",\n3313         limit: int | None = None,\n3314         use_coordinate: bool | str = True,\n3315         max_gap: (\n3316             None\n3317             | int\n3318             | float\n3319             | str\n3320             | pd.Timedelta\n3321             | np.timedelta64\n3322             | datetime.timedelta\n3323         ) = None,\n3324         keep_attrs: bool | None = None,\n3325         **kwargs: Any,\n3326     ) -> T_DataArray:\n3327         \"\"\"Fill in NaNs by interpolating according to different methods.\n3328 \n3329         Parameters\n3330         ----------\n3331         dim : Hashable or None, optional\n3332             Specifies the dimension along which to interpolate.\n3333         method : {\"linear\", \"nearest\", \"zero\", \"slinear\", \"quadratic\", \"cubic\", \"polynomial\", \\\n3334             \"barycentric\", \"krog\", \"pchip\", \"spline\", \"akima\"}, default: \"linear\"\n3335             String indicating which method to use for interpolation:\n3336 \n3337             - 'linear': linear interpolation. Additional keyword\n3338               arguments are passed to :py:func:`numpy.interp`\n3339             - 'nearest', 'zero', 'slinear', 'quadratic', 'cubic', 'polynomial':\n3340               are passed to :py:func:`scipy.interpolate.interp1d`. If\n3341               ``method='polynomial'``, the ``order`` keyword argument must also be\n3342               provided.\n3343             - 'barycentric', 'krog', 'pchip', 'spline', 'akima': use their\n3344               respective :py:class:`scipy.interpolate` classes.\n3345 \n3346         use_coordinate : bool or str, default: True\n3347             Specifies which index to use as the x values in the interpolation\n3348             formulated as `y = f(x)`. If False, values are treated as if\n3349             eqaully-spaced along ``dim``. If True, the IndexVariable `dim` is\n3350             used. If ``use_coordinate`` is a string, it specifies the name of a\n3351             coordinate variariable to use as the index.\n3352         limit : int or None, default: None\n3353             Maximum number of consecutive NaNs to fill. Must be greater than 0\n3354             or None for no limit. This filling is done regardless of the size of\n3355             the gap in the data. To only interpolate over gaps less than a given length,\n3356             see ``max_gap``.\n3357         max_gap : int, float, str, pandas.Timedelta, numpy.timedelta64, datetime.timedelta, default: None\n3358             Maximum size of gap, a continuous sequence of NaNs, that will be filled.\n3359             Use None for no limit. When interpolating along a datetime64 dimension\n3360             and ``use_coordinate=True``, ``max_gap`` can be one of the following:\n3361 \n3362             - a string that is valid input for pandas.to_timedelta\n3363             - a :py:class:`numpy.timedelta64` object\n3364             - a :py:class:`pandas.Timedelta` object\n3365             - a :py:class:`datetime.timedelta` object\n3366 \n3367             Otherwise, ``max_gap`` must be an int or a float. Use of ``max_gap`` with unlabeled\n3368             dimensions has not been implemented yet. Gap length is defined as the difference\n3369             between coordinate values at the first data point after a gap and the last value\n3370             before a gap. For gaps at the beginning (end), gap length is defined as the difference\n3371             between coordinate values at the first (last) valid data point and the first (last) NaN.\n3372             For example, consider::\n3373 \n3374                 <xarray.DataArray (x: 9)>\n3375                 array([nan, nan, nan,  1., nan, nan,  4., nan, nan])\n3376                 Coordinates:\n3377                   * x        (x) int64 0 1 2 3 4 5 6 7 8\n3378 \n3379             The gap lengths are 3-0 = 3; 6-3 = 3; and 8-6 = 2 respectively\n3380         keep_attrs : bool or None, default: None\n3381             If True, the dataarray's attributes (`attrs`) will be copied from\n3382             the original object to the new one.  If False, the new\n3383             object will be returned without attributes.\n3384         **kwargs : dict, optional\n3385             parameters passed verbatim to the underlying interpolation function\n3386 \n3387         Returns\n3388         -------\n3389         interpolated: DataArray\n3390             Filled in DataArray.\n3391 \n3392         See Also\n3393         --------\n3394         numpy.interp\n3395         scipy.interpolate\n3396 \n3397         Examples\n3398         --------\n3399         >>> da = xr.DataArray(\n3400         ...     [np.nan, 2, 3, np.nan, 0], dims=\"x\", coords={\"x\": [0, 1, 2, 3, 4]}\n3401         ... )\n3402         >>> da\n3403         <xarray.DataArray (x: 5)>\n3404         array([nan,  2.,  3., nan,  0.])\n3405         Coordinates:\n3406           * x        (x) int64 0 1 2 3 4\n3407 \n3408         >>> da.interpolate_na(dim=\"x\", method=\"linear\")\n3409         <xarray.DataArray (x: 5)>\n3410         array([nan, 2. , 3. , 1.5, 0. ])\n3411         Coordinates:\n3412           * x        (x) int64 0 1 2 3 4\n3413 \n3414         >>> da.interpolate_na(dim=\"x\", method=\"linear\", fill_value=\"extrapolate\")\n3415         <xarray.DataArray (x: 5)>\n3416         array([1. , 2. , 3. , 1.5, 0. ])\n3417         Coordinates:\n3418           * x        (x) int64 0 1 2 3 4\n3419         \"\"\"\n3420         from xarray.core.missing import interp_na\n3421 \n3422         return interp_na(\n3423             self,\n3424             dim=dim,\n3425             method=method,\n3426             limit=limit,\n3427             use_coordinate=use_coordinate,\n3428             max_gap=max_gap,\n3429             keep_attrs=keep_attrs,\n3430             **kwargs,\n3431         )\n3432 \n3433     def ffill(\n3434         self: T_DataArray, dim: Hashable, limit: int | None = None\n3435     ) -> T_DataArray:\n3436         \"\"\"Fill NaN values by propagating values forward\n3437 \n3438         *Requires bottleneck.*\n3439 \n3440         Parameters\n3441         ----------\n3442         dim : Hashable\n3443             Specifies the dimension along which to propagate values when\n3444             filling.\n3445         limit : int or None, default: None\n3446             The maximum number of consecutive NaN values to forward fill. In\n3447             other words, if there is a gap with more than this number of\n3448             consecutive NaNs, it will only be partially filled. Must be greater\n3449             than 0 or None for no limit. Must be None or greater than or equal\n3450             to axis length if filling along chunked axes (dimensions).\n3451 \n3452         Returns\n3453         -------\n3454         filled : DataArray\n3455 \n3456         Examples\n3457         --------\n3458         >>> temperature = np.array(\n3459         ...     [\n3460         ...         [np.nan, 1, 3],\n3461         ...         [0, np.nan, 5],\n3462         ...         [5, np.nan, np.nan],\n3463         ...         [3, np.nan, np.nan],\n3464         ...         [0, 2, 0],\n3465         ...     ]\n3466         ... )\n3467         >>> da = xr.DataArray(\n3468         ...     data=temperature,\n3469         ...     dims=[\"Y\", \"X\"],\n3470         ...     coords=dict(\n3471         ...         lat=(\"Y\", np.array([-20.0, -20.25, -20.50, -20.75, -21.0])),\n3472         ...         lon=(\"X\", np.array([10.0, 10.25, 10.5])),\n3473         ...     ),\n3474         ... )\n3475         >>> da\n3476         <xarray.DataArray (Y: 5, X: 3)>\n3477         array([[nan,  1.,  3.],\n3478                [ 0., nan,  5.],\n3479                [ 5., nan, nan],\n3480                [ 3., nan, nan],\n3481                [ 0.,  2.,  0.]])\n3482         Coordinates:\n3483             lat      (Y) float64 -20.0 -20.25 -20.5 -20.75 -21.0\n3484             lon      (X) float64 10.0 10.25 10.5\n3485         Dimensions without coordinates: Y, X\n3486 \n3487         Fill all NaN values:\n3488 \n3489         >>> da.ffill(dim=\"Y\", limit=None)\n3490         <xarray.DataArray (Y: 5, X: 3)>\n3491         array([[nan,  1.,  3.],\n3492                [ 0.,  1.,  5.],\n3493                [ 5.,  1.,  5.],\n3494                [ 3.,  1.,  5.],\n3495                [ 0.,  2.,  0.]])\n3496         Coordinates:\n3497             lat      (Y) float64 -20.0 -20.25 -20.5 -20.75 -21.0\n3498             lon      (X) float64 10.0 10.25 10.5\n3499         Dimensions without coordinates: Y, X\n3500 \n3501         Fill only the first of consecutive NaN values:\n3502 \n3503         >>> da.ffill(dim=\"Y\", limit=1)\n3504         <xarray.DataArray (Y: 5, X: 3)>\n3505         array([[nan,  1.,  3.],\n3506                [ 0.,  1.,  5.],\n3507                [ 5., nan,  5.],\n3508                [ 3., nan, nan],\n3509                [ 0.,  2.,  0.]])\n3510         Coordinates:\n3511             lat      (Y) float64 -20.0 -20.25 -20.5 -20.75 -21.0\n3512             lon      (X) float64 10.0 10.25 10.5\n3513         Dimensions without coordinates: Y, X\n3514         \"\"\"\n3515         from xarray.core.missing import ffill\n3516 \n3517         return ffill(self, dim, limit=limit)\n3518 \n3519     def bfill(\n3520         self: T_DataArray, dim: Hashable, limit: int | None = None\n3521     ) -> T_DataArray:\n3522         \"\"\"Fill NaN values by propagating values backward\n3523 \n3524         *Requires bottleneck.*\n3525 \n3526         Parameters\n3527         ----------\n3528         dim : str\n3529             Specifies the dimension along which to propagate values when\n3530             filling.\n3531         limit : int or None, default: None\n3532             The maximum number of consecutive NaN values to backward fill. In\n3533             other words, if there is a gap with more than this number of\n3534             consecutive NaNs, it will only be partially filled. Must be greater\n3535             than 0 or None for no limit. Must be None or greater than or equal\n3536             to axis length if filling along chunked axes (dimensions).\n3537 \n3538         Returns\n3539         -------\n3540         filled : DataArray\n3541 \n3542         Examples\n3543         --------\n3544         >>> temperature = np.array(\n3545         ...     [\n3546         ...         [0, 1, 3],\n3547         ...         [0, np.nan, 5],\n3548         ...         [5, np.nan, np.nan],\n3549         ...         [3, np.nan, np.nan],\n3550         ...         [np.nan, 2, 0],\n3551         ...     ]\n3552         ... )\n3553         >>> da = xr.DataArray(\n3554         ...     data=temperature,\n3555         ...     dims=[\"Y\", \"X\"],\n3556         ...     coords=dict(\n3557         ...         lat=(\"Y\", np.array([-20.0, -20.25, -20.50, -20.75, -21.0])),\n3558         ...         lon=(\"X\", np.array([10.0, 10.25, 10.5])),\n3559         ...     ),\n3560         ... )\n3561         >>> da\n3562         <xarray.DataArray (Y: 5, X: 3)>\n3563         array([[ 0.,  1.,  3.],\n3564                [ 0., nan,  5.],\n3565                [ 5., nan, nan],\n3566                [ 3., nan, nan],\n3567                [nan,  2.,  0.]])\n3568         Coordinates:\n3569             lat      (Y) float64 -20.0 -20.25 -20.5 -20.75 -21.0\n3570             lon      (X) float64 10.0 10.25 10.5\n3571         Dimensions without coordinates: Y, X\n3572 \n3573         Fill all NaN values:\n3574 \n3575         >>> da.bfill(dim=\"Y\", limit=None)\n3576         <xarray.DataArray (Y: 5, X: 3)>\n3577         array([[ 0.,  1.,  3.],\n3578                [ 0.,  2.,  5.],\n3579                [ 5.,  2.,  0.],\n3580                [ 3.,  2.,  0.],\n3581                [nan,  2.,  0.]])\n3582         Coordinates:\n3583             lat      (Y) float64 -20.0 -20.25 -20.5 -20.75 -21.0\n3584             lon      (X) float64 10.0 10.25 10.5\n3585         Dimensions without coordinates: Y, X\n3586 \n3587         Fill only the first of consecutive NaN values:\n3588 \n3589         >>> da.bfill(dim=\"Y\", limit=1)\n3590         <xarray.DataArray (Y: 5, X: 3)>\n3591         array([[ 0.,  1.,  3.],\n3592                [ 0., nan,  5.],\n3593                [ 5., nan, nan],\n3594                [ 3.,  2.,  0.],\n3595                [nan,  2.,  0.]])\n3596         Coordinates:\n3597             lat      (Y) float64 -20.0 -20.25 -20.5 -20.75 -21.0\n3598             lon      (X) float64 10.0 10.25 10.5\n3599         Dimensions without coordinates: Y, X\n3600         \"\"\"\n3601         from xarray.core.missing import bfill\n3602 \n3603         return bfill(self, dim, limit=limit)\n3604 \n3605     def combine_first(self: T_DataArray, other: T_DataArray) -> T_DataArray:\n3606         \"\"\"Combine two DataArray objects, with union of coordinates.\n3607 \n3608         This operation follows the normal broadcasting and alignment rules of\n3609         ``join='outer'``.  Default to non-null values of array calling the\n3610         method.  Use np.nan to fill in vacant cells after alignment.\n3611 \n3612         Parameters\n3613         ----------\n3614         other : DataArray\n3615             Used to fill all matching missing values in this array.\n3616 \n3617         Returns\n3618         -------\n3619         DataArray\n3620         \"\"\"\n3621         return ops.fillna(self, other, join=\"outer\")\n3622 \n3623     def reduce(\n3624         self: T_DataArray,\n3625         func: Callable[..., Any],\n3626         dim: Dims = None,\n3627         *,\n3628         axis: int | Sequence[int] | None = None,\n3629         keep_attrs: bool | None = None,\n3630         keepdims: bool = False,\n3631         **kwargs: Any,\n3632     ) -> T_DataArray:\n3633         \"\"\"Reduce this array by applying `func` along some dimension(s).\n3634 \n3635         Parameters\n3636         ----------\n3637         func : callable\n3638             Function which can be called in the form\n3639             `f(x, axis=axis, **kwargs)` to return the result of reducing an\n3640             np.ndarray over an integer valued axis.\n3641         dim : \"...\", str, Iterable of Hashable or None, optional\n3642             Dimension(s) over which to apply `func`. By default `func` is\n3643             applied over all dimensions.\n3644         axis : int or sequence of int, optional\n3645             Axis(es) over which to repeatedly apply `func`. Only one of the\n3646             'dim' and 'axis' arguments can be supplied. If neither are\n3647             supplied, then the reduction is calculated over the flattened array\n3648             (by calling `f(x)` without an axis argument).\n3649         keep_attrs : bool or None, optional\n3650             If True, the variable's attributes (`attrs`) will be copied from\n3651             the original object to the new one.  If False (default), the new\n3652             object will be returned without attributes.\n3653         keepdims : bool, default: False\n3654             If True, the dimensions which are reduced are left in the result\n3655             as dimensions of size one. Coordinates that use these dimensions\n3656             are removed.\n3657         **kwargs : dict\n3658             Additional keyword arguments passed on to `func`.\n3659 \n3660         Returns\n3661         -------\n3662         reduced : DataArray\n3663             DataArray with this object's array replaced with an array with\n3664             summarized data and the indicated dimension(s) removed.\n3665         \"\"\"\n3666 \n3667         var = self.variable.reduce(func, dim, axis, keep_attrs, keepdims, **kwargs)\n3668         return self._replace_maybe_drop_dims(var)\n3669 \n3670     def to_pandas(self) -> DataArray | pd.Series | pd.DataFrame:\n3671         \"\"\"Convert this array into a pandas object with the same shape.\n3672 \n3673         The type of the returned object depends on the number of DataArray\n3674         dimensions:\n3675 \n3676         * 0D -> `xarray.DataArray`\n3677         * 1D -> `pandas.Series`\n3678         * 2D -> `pandas.DataFrame`\n3679 \n3680         Only works for arrays with 2 or fewer dimensions.\n3681 \n3682         The DataArray constructor performs the inverse transformation.\n3683 \n3684         Returns\n3685         -------\n3686         result : DataArray | Series | DataFrame\n3687             DataArray, pandas Series or pandas DataFrame.\n3688         \"\"\"\n3689         # TODO: consolidate the info about pandas constructors and the\n3690         # attributes that correspond to their indexes into a separate module?\n3691         constructors = {0: lambda x: x, 1: pd.Series, 2: pd.DataFrame}\n3692         try:\n3693             constructor = constructors[self.ndim]\n3694         except KeyError:\n3695             raise ValueError(\n3696                 f\"Cannot convert arrays with {self.ndim} dimensions into \"\n3697                 \"pandas objects. Requires 2 or fewer dimensions.\"\n3698             )\n3699         indexes = [self.get_index(dim) for dim in self.dims]\n3700         return constructor(self.values, *indexes)\n3701 \n3702     def to_dataframe(\n3703         self, name: Hashable | None = None, dim_order: Sequence[Hashable] | None = None\n3704     ) -> pd.DataFrame:\n3705         \"\"\"Convert this array and its coordinates into a tidy pandas.DataFrame.\n3706 \n3707         The DataFrame is indexed by the Cartesian product of index coordinates\n3708         (in the form of a :py:class:`pandas.MultiIndex`). Other coordinates are\n3709         included as columns in the DataFrame.\n3710 \n3711         For 1D and 2D DataArrays, see also :py:func:`DataArray.to_pandas` which\n3712         doesn't rely on a MultiIndex to build the DataFrame.\n3713 \n3714         Parameters\n3715         ----------\n3716         name: Hashable or None, optional\n3717             Name to give to this array (required if unnamed).\n3718         dim_order: Sequence of Hashable or None, optional\n3719             Hierarchical dimension order for the resulting dataframe.\n3720             Array content is transposed to this order and then written out as flat\n3721             vectors in contiguous order, so the last dimension in this list\n3722             will be contiguous in the resulting DataFrame. This has a major\n3723             influence on which operations are efficient on the resulting\n3724             dataframe.\n3725 \n3726             If provided, must include all dimensions of this DataArray. By default,\n3727             dimensions are sorted according to the DataArray dimensions order.\n3728 \n3729         Returns\n3730         -------\n3731         result: DataFrame\n3732             DataArray as a pandas DataFrame.\n3733 \n3734         See also\n3735         --------\n3736         DataArray.to_pandas\n3737         DataArray.to_series\n3738         \"\"\"\n3739         if name is None:\n3740             name = self.name\n3741         if name is None:\n3742             raise ValueError(\n3743                 \"cannot convert an unnamed DataArray to a \"\n3744                 \"DataFrame: use the ``name`` parameter\"\n3745             )\n3746         if self.ndim == 0:\n3747             raise ValueError(\"cannot convert a scalar to a DataFrame\")\n3748 \n3749         # By using a unique name, we can convert a DataArray into a DataFrame\n3750         # even if it shares a name with one of its coordinates.\n3751         # I would normally use unique_name = object() but that results in a\n3752         # dataframe with columns in the wrong order, for reasons I have not\n3753         # been able to debug (possibly a pandas bug?).\n3754         unique_name = \"__unique_name_identifier_z98xfz98xugfg73ho__\"\n3755         ds = self._to_dataset_whole(name=unique_name)\n3756 \n3757         if dim_order is None:\n3758             ordered_dims = dict(zip(self.dims, self.shape))\n3759         else:\n3760             ordered_dims = ds._normalize_dim_order(dim_order=dim_order)\n3761 \n3762         df = ds._to_dataframe(ordered_dims)\n3763         df.columns = [name if c == unique_name else c for c in df.columns]\n3764         return df\n3765 \n3766     def to_series(self) -> pd.Series:\n3767         \"\"\"Convert this array into a pandas.Series.\n3768 \n3769         The Series is indexed by the Cartesian product of index coordinates\n3770         (in the form of a :py:class:`pandas.MultiIndex`).\n3771 \n3772         Returns\n3773         -------\n3774         result : Series\n3775             DataArray as a pandas Series.\n3776 \n3777         See also\n3778         --------\n3779         DataArray.to_pandas\n3780         DataArray.to_dataframe\n3781         \"\"\"\n3782         index = self.coords.to_index()\n3783         return pd.Series(self.values.reshape(-1), index=index, name=self.name)\n3784 \n3785     def to_masked_array(self, copy: bool = True) -> np.ma.MaskedArray:\n3786         \"\"\"Convert this array into a numpy.ma.MaskedArray\n3787 \n3788         Parameters\n3789         ----------\n3790         copy : bool, default: True\n3791             If True make a copy of the array in the result. If False,\n3792             a MaskedArray view of DataArray.values is returned.\n3793 \n3794         Returns\n3795         -------\n3796         result : MaskedArray\n3797             Masked where invalid values (nan or inf) occur.\n3798         \"\"\"\n3799         values = self.to_numpy()  # only compute lazy arrays once\n3800         isnull = pd.isnull(values)\n3801         return np.ma.MaskedArray(data=values, mask=isnull, copy=copy)\n3802 \n3803     # path=None writes to bytes\n3804     @overload\n3805     def to_netcdf(\n3806         self,\n3807         path: None = None,\n3808         mode: Literal[\"w\", \"a\"] = \"w\",\n3809         format: T_NetcdfTypes | None = None,\n3810         group: str | None = None,\n3811         engine: T_NetcdfEngine | None = None,\n3812         encoding: Mapping[Hashable, Mapping[str, Any]] | None = None,\n3813         unlimited_dims: Iterable[Hashable] | None = None,\n3814         compute: bool = True,\n3815         invalid_netcdf: bool = False,\n3816     ) -> bytes:\n3817         ...\n3818 \n3819     # default return None\n3820     @overload\n3821     def to_netcdf(\n3822         self,\n3823         path: str | PathLike,\n3824         mode: Literal[\"w\", \"a\"] = \"w\",\n3825         format: T_NetcdfTypes | None = None,\n3826         group: str | None = None,\n3827         engine: T_NetcdfEngine | None = None,\n3828         encoding: Mapping[Hashable, Mapping[str, Any]] | None = None,\n3829         unlimited_dims: Iterable[Hashable] | None = None,\n3830         compute: Literal[True] = True,\n3831         invalid_netcdf: bool = False,\n3832     ) -> None:\n3833         ...\n3834 \n3835     # compute=False returns dask.Delayed\n3836     @overload\n3837     def to_netcdf(\n3838         self,\n3839         path: str | PathLike,\n3840         mode: Literal[\"w\", \"a\"] = \"w\",\n3841         format: T_NetcdfTypes | None = None,\n3842         group: str | None = None,\n3843         engine: T_NetcdfEngine | None = None,\n3844         encoding: Mapping[Hashable, Mapping[str, Any]] | None = None,\n3845         unlimited_dims: Iterable[Hashable] | None = None,\n3846         *,\n3847         compute: Literal[False],\n3848         invalid_netcdf: bool = False,\n3849     ) -> Delayed:\n3850         ...\n3851 \n3852     def to_netcdf(\n3853         self,\n3854         path: str | PathLike | None = None,\n3855         mode: Literal[\"w\", \"a\"] = \"w\",\n3856         format: T_NetcdfTypes | None = None,\n3857         group: str | None = None,\n3858         engine: T_NetcdfEngine | None = None,\n3859         encoding: Mapping[Hashable, Mapping[str, Any]] | None = None,\n3860         unlimited_dims: Iterable[Hashable] | None = None,\n3861         compute: bool = True,\n3862         invalid_netcdf: bool = False,\n3863     ) -> bytes | Delayed | None:\n3864         \"\"\"Write dataset contents to a netCDF file.\n3865 \n3866         Parameters\n3867         ----------\n3868         path : str, path-like or None, optional\n3869             Path to which to save this dataset. File-like objects are only\n3870             supported by the scipy engine. If no path is provided, this\n3871             function returns the resulting netCDF file as bytes; in this case,\n3872             we need to use scipy, which does not support netCDF version 4 (the\n3873             default format becomes NETCDF3_64BIT).\n3874         mode : {\"w\", \"a\"}, default: \"w\"\n3875             Write ('w') or append ('a') mode. If mode='w', any existing file at\n3876             this location will be overwritten. If mode='a', existing variables\n3877             will be overwritten.\n3878         format : {\"NETCDF4\", \"NETCDF4_CLASSIC\", \"NETCDF3_64BIT\", \\\n3879                   \"NETCDF3_CLASSIC\"}, optional\n3880             File format for the resulting netCDF file:\n3881 \n3882             * NETCDF4: Data is stored in an HDF5 file, using netCDF4 API\n3883               features.\n3884             * NETCDF4_CLASSIC: Data is stored in an HDF5 file, using only\n3885               netCDF 3 compatible API features.\n3886             * NETCDF3_64BIT: 64-bit offset version of the netCDF 3 file format,\n3887               which fully supports 2+ GB files, but is only compatible with\n3888               clients linked against netCDF version 3.6.0 or later.\n3889             * NETCDF3_CLASSIC: The classic netCDF 3 file format. It does not\n3890               handle 2+ GB files very well.\n3891 \n3892             All formats are supported by the netCDF4-python library.\n3893             scipy.io.netcdf only supports the last two formats.\n3894 \n3895             The default format is NETCDF4 if you are saving a file to disk and\n3896             have the netCDF4-python library available. Otherwise, xarray falls\n3897             back to using scipy to write netCDF files and defaults to the\n3898             NETCDF3_64BIT format (scipy does not support netCDF4).\n3899         group : str, optional\n3900             Path to the netCDF4 group in the given file to open (only works for\n3901             format='NETCDF4'). The group(s) will be created if necessary.\n3902         engine : {\"netcdf4\", \"scipy\", \"h5netcdf\"}, optional\n3903             Engine to use when writing netCDF files. If not provided, the\n3904             default engine is chosen based on available dependencies, with a\n3905             preference for 'netcdf4' if writing to a file on disk.\n3906         encoding : dict, optional\n3907             Nested dictionary with variable names as keys and dictionaries of\n3908             variable specific encodings as values, e.g.,\n3909             ``{\"my_variable\": {\"dtype\": \"int16\", \"scale_factor\": 0.1,\n3910             \"zlib\": True}, ...}``\n3911 \n3912             The `h5netcdf` engine supports both the NetCDF4-style compression\n3913             encoding parameters ``{\"zlib\": True, \"complevel\": 9}`` and the h5py\n3914             ones ``{\"compression\": \"gzip\", \"compression_opts\": 9}``.\n3915             This allows using any compression plugin installed in the HDF5\n3916             library, e.g. LZF.\n3917 \n3918         unlimited_dims : iterable of Hashable, optional\n3919             Dimension(s) that should be serialized as unlimited dimensions.\n3920             By default, no dimensions are treated as unlimited dimensions.\n3921             Note that unlimited_dims may also be set via\n3922             ``dataset.encoding[\"unlimited_dims\"]``.\n3923         compute: bool, default: True\n3924             If true compute immediately, otherwise return a\n3925             ``dask.delayed.Delayed`` object that can be computed later.\n3926         invalid_netcdf: bool, default: False\n3927             Only valid along with ``engine=\"h5netcdf\"``. If True, allow writing\n3928             hdf5 files which are invalid netcdf as described in\n3929             https://github.com/h5netcdf/h5netcdf.\n3930 \n3931         Returns\n3932         -------\n3933         store: bytes or Delayed or None\n3934             * ``bytes`` if path is None\n3935             * ``dask.delayed.Delayed`` if compute is False\n3936             * None otherwise\n3937 \n3938         Notes\n3939         -----\n3940         Only xarray.Dataset objects can be written to netCDF files, so\n3941         the xarray.DataArray is converted to a xarray.Dataset object\n3942         containing a single variable. If the DataArray has no name, or if the\n3943         name is the same as a coordinate name, then it is given the name\n3944         ``\"__xarray_dataarray_variable__\"``.\n3945 \n3946         See Also\n3947         --------\n3948         Dataset.to_netcdf\n3949         \"\"\"\n3950         from xarray.backends.api import DATAARRAY_NAME, DATAARRAY_VARIABLE, to_netcdf\n3951 \n3952         if self.name is None:\n3953             # If no name is set then use a generic xarray name\n3954             dataset = self.to_dataset(name=DATAARRAY_VARIABLE)\n3955         elif self.name in self.coords or self.name in self.dims:\n3956             # The name is the same as one of the coords names, which netCDF\n3957             # doesn't support, so rename it but keep track of the old name\n3958             dataset = self.to_dataset(name=DATAARRAY_VARIABLE)\n3959             dataset.attrs[DATAARRAY_NAME] = self.name\n3960         else:\n3961             # No problems with the name - so we're fine!\n3962             dataset = self.to_dataset()\n3963 \n3964         return to_netcdf(  # type: ignore  # mypy cannot resolve the overloads:(\n3965             dataset,\n3966             path,\n3967             mode=mode,\n3968             format=format,\n3969             group=group,\n3970             engine=engine,\n3971             encoding=encoding,\n3972             unlimited_dims=unlimited_dims,\n3973             compute=compute,\n3974             multifile=False,\n3975             invalid_netcdf=invalid_netcdf,\n3976         )\n3977 \n3978     def to_dict(self, data: bool = True, encoding: bool = False) -> dict[str, Any]:\n3979         \"\"\"\n3980         Convert this xarray.DataArray into a dictionary following xarray\n3981         naming conventions.\n3982 \n3983         Converts all variables and attributes to native Python objects.\n3984         Useful for converting to json. To avoid datetime incompatibility\n3985         use decode_times=False kwarg in xarray.open_dataset.\n3986 \n3987         Parameters\n3988         ----------\n3989         data : bool, default: True\n3990             Whether to include the actual data in the dictionary. When set to\n3991             False, returns just the schema.\n3992         encoding : bool, default: False\n3993             Whether to include the Dataset's encoding in the dictionary.\n3994 \n3995         Returns\n3996         -------\n3997         dict: dict\n3998 \n3999         See Also\n4000         --------\n4001         DataArray.from_dict\n4002         Dataset.to_dict\n4003         \"\"\"\n4004         d = self.variable.to_dict(data=data)\n4005         d.update({\"coords\": {}, \"name\": self.name})\n4006         for k, coord in self.coords.items():\n4007             d[\"coords\"][k] = coord.variable.to_dict(data=data)\n4008         if encoding:\n4009             d[\"encoding\"] = dict(self.encoding)\n4010         return d\n4011 \n4012     @classmethod\n4013     def from_dict(cls: type[T_DataArray], d: Mapping[str, Any]) -> T_DataArray:\n4014         \"\"\"Convert a dictionary into an xarray.DataArray\n4015 \n4016         Parameters\n4017         ----------\n4018         d : dict\n4019             Mapping with a minimum structure of {\"dims\": [...], \"data\": [...]}\n4020 \n4021         Returns\n4022         -------\n4023         obj : xarray.DataArray\n4024 \n4025         See Also\n4026         --------\n4027         DataArray.to_dict\n4028         Dataset.from_dict\n4029 \n4030         Examples\n4031         --------\n4032         >>> d = {\"dims\": \"t\", \"data\": [1, 2, 3]}\n4033         >>> da = xr.DataArray.from_dict(d)\n4034         >>> da\n4035         <xarray.DataArray (t: 3)>\n4036         array([1, 2, 3])\n4037         Dimensions without coordinates: t\n4038 \n4039         >>> d = {\n4040         ...     \"coords\": {\n4041         ...         \"t\": {\"dims\": \"t\", \"data\": [0, 1, 2], \"attrs\": {\"units\": \"s\"}}\n4042         ...     },\n4043         ...     \"attrs\": {\"title\": \"air temperature\"},\n4044         ...     \"dims\": \"t\",\n4045         ...     \"data\": [10, 20, 30],\n4046         ...     \"name\": \"a\",\n4047         ... }\n4048         >>> da = xr.DataArray.from_dict(d)\n4049         >>> da\n4050         <xarray.DataArray 'a' (t: 3)>\n4051         array([10, 20, 30])\n4052         Coordinates:\n4053           * t        (t) int64 0 1 2\n4054         Attributes:\n4055             title:    air temperature\n4056         \"\"\"\n4057         coords = None\n4058         if \"coords\" in d:\n4059             try:\n4060                 coords = {\n4061                     k: (v[\"dims\"], v[\"data\"], v.get(\"attrs\"))\n4062                     for k, v in d[\"coords\"].items()\n4063                 }\n4064             except KeyError as e:\n4065                 raise ValueError(\n4066                     \"cannot convert dict when coords are missing the key \"\n4067                     \"'{dims_data}'\".format(dims_data=str(e.args[0]))\n4068                 )\n4069         try:\n4070             data = d[\"data\"]\n4071         except KeyError:\n4072             raise ValueError(\"cannot convert dict without the key 'data''\")\n4073         else:\n4074             obj = cls(data, coords, d.get(\"dims\"), d.get(\"name\"), d.get(\"attrs\"))\n4075 \n4076         obj.encoding.update(d.get(\"encoding\", {}))\n4077 \n4078         return obj\n4079 \n4080     @classmethod\n4081     def from_series(cls, series: pd.Series, sparse: bool = False) -> DataArray:\n4082         \"\"\"Convert a pandas.Series into an xarray.DataArray.\n4083 \n4084         If the series's index is a MultiIndex, it will be expanded into a\n4085         tensor product of one-dimensional coordinates (filling in missing\n4086         values with NaN). Thus this operation should be the inverse of the\n4087         `to_series` method.\n4088 \n4089         Parameters\n4090         ----------\n4091         series : Series\n4092             Pandas Series object to convert.\n4093         sparse : bool, default: False\n4094             If sparse=True, creates a sparse array instead of a dense NumPy array.\n4095             Requires the pydata/sparse package.\n4096 \n4097         See Also\n4098         --------\n4099         DataArray.to_series\n4100         Dataset.from_dataframe\n4101         \"\"\"\n4102         temp_name = \"__temporary_name\"\n4103         df = pd.DataFrame({temp_name: series})\n4104         ds = Dataset.from_dataframe(df, sparse=sparse)\n4105         result = cast(DataArray, ds[temp_name])\n4106         result.name = series.name\n4107         return result\n4108 \n4109     def to_cdms2(self) -> cdms2_Variable:\n4110         \"\"\"Convert this array into a cdms2.Variable\"\"\"\n4111         from xarray.convert import to_cdms2\n4112 \n4113         return to_cdms2(self)\n4114 \n4115     @classmethod\n4116     def from_cdms2(cls, variable: cdms2_Variable) -> DataArray:\n4117         \"\"\"Convert a cdms2.Variable into an xarray.DataArray\"\"\"\n4118         from xarray.convert import from_cdms2\n4119 \n4120         return from_cdms2(variable)\n4121 \n4122     def to_iris(self) -> iris_Cube:\n4123         \"\"\"Convert this array into a iris.cube.Cube\"\"\"\n4124         from xarray.convert import to_iris\n4125 \n4126         return to_iris(self)\n4127 \n4128     @classmethod\n4129     def from_iris(cls, cube: iris_Cube) -> DataArray:\n4130         \"\"\"Convert a iris.cube.Cube into an xarray.DataArray\"\"\"\n4131         from xarray.convert import from_iris\n4132 \n4133         return from_iris(cube)\n4134 \n4135     def _all_compat(self: T_DataArray, other: T_DataArray, compat_str: str) -> bool:\n4136         \"\"\"Helper function for equals, broadcast_equals, and identical\"\"\"\n4137 \n4138         def compat(x, y):\n4139             return getattr(x.variable, compat_str)(y.variable)\n4140 \n4141         return utils.dict_equiv(self.coords, other.coords, compat=compat) and compat(\n4142             self, other\n4143         )\n4144 \n4145     def broadcast_equals(self: T_DataArray, other: T_DataArray) -> bool:\n4146         \"\"\"Two DataArrays are broadcast equal if they are equal after\n4147         broadcasting them against each other such that they have the same\n4148         dimensions.\n4149 \n4150         Parameters\n4151         ----------\n4152         other : DataArray\n4153             DataArray to compare to.\n4154 \n4155         Returns\n4156         ----------\n4157         equal : bool\n4158             True if the two DataArrays are broadcast equal.\n4159 \n4160         See Also\n4161         --------\n4162         DataArray.equals\n4163         DataArray.identical\n4164 \n4165         Examples\n4166         --------\n4167         >>> a = xr.DataArray([1, 2], dims=\"X\")\n4168         >>> b = xr.DataArray([[1, 1], [2, 2]], dims=[\"X\", \"Y\"])\n4169         >>> a\n4170         <xarray.DataArray (X: 2)>\n4171         array([1, 2])\n4172         Dimensions without coordinates: X\n4173         >>> b\n4174         <xarray.DataArray (X: 2, Y: 2)>\n4175         array([[1, 1],\n4176                [2, 2]])\n4177         Dimensions without coordinates: X, Y\n4178 \n4179         .equals returns True if two DataArrays have the same values, dimensions, and coordinates. .broadcast_equals returns True if the results of broadcasting two DataArrays against eachother have the same values, dimensions, and coordinates.\n4180 \n4181         >>> a.equals(b)\n4182         False\n4183         >>> a2, b2 = xr.broadcast(a, b)\n4184         >>> a2.equals(b2)\n4185         True\n4186         >>> a.broadcast_equals(b)\n4187         True\n4188         \"\"\"\n4189         try:\n4190             return self._all_compat(other, \"broadcast_equals\")\n4191         except (TypeError, AttributeError):\n4192             return False\n4193 \n4194     def equals(self: T_DataArray, other: T_DataArray) -> bool:\n4195         \"\"\"True if two DataArrays have the same dimensions, coordinates and\n4196         values; otherwise False.\n4197 \n4198         DataArrays can still be equal (like pandas objects) if they have NaN\n4199         values in the same locations.\n4200 \n4201         This method is necessary because `v1 == v2` for ``DataArray``\n4202         does element-wise comparisons (like numpy.ndarrays).\n4203 \n4204         Parameters\n4205         ----------\n4206         other : DataArray\n4207             DataArray to compare to.\n4208 \n4209         Returns\n4210         ----------\n4211         equal : bool\n4212             True if the two DataArrays are equal.\n4213 \n4214         See Also\n4215         --------\n4216         DataArray.broadcast_equals\n4217         DataArray.identical\n4218 \n4219         Examples\n4220         --------\n4221         >>> a = xr.DataArray([1, 2, 3], dims=\"X\")\n4222         >>> b = xr.DataArray([1, 2, 3], dims=\"X\", attrs=dict(units=\"m\"))\n4223         >>> c = xr.DataArray([1, 2, 3], dims=\"Y\")\n4224         >>> d = xr.DataArray([3, 2, 1], dims=\"X\")\n4225         >>> a\n4226         <xarray.DataArray (X: 3)>\n4227         array([1, 2, 3])\n4228         Dimensions without coordinates: X\n4229         >>> b\n4230         <xarray.DataArray (X: 3)>\n4231         array([1, 2, 3])\n4232         Dimensions without coordinates: X\n4233         Attributes:\n4234             units:    m\n4235         >>> c\n4236         <xarray.DataArray (Y: 3)>\n4237         array([1, 2, 3])\n4238         Dimensions without coordinates: Y\n4239         >>> d\n4240         <xarray.DataArray (X: 3)>\n4241         array([3, 2, 1])\n4242         Dimensions without coordinates: X\n4243 \n4244         >>> a.equals(b)\n4245         True\n4246         >>> a.equals(c)\n4247         False\n4248         >>> a.equals(d)\n4249         False\n4250         \"\"\"\n4251         try:\n4252             return self._all_compat(other, \"equals\")\n4253         except (TypeError, AttributeError):\n4254             return False\n4255 \n4256     def identical(self: T_DataArray, other: T_DataArray) -> bool:\n4257         \"\"\"Like equals, but also checks the array name and attributes, and\n4258         attributes on all coordinates.\n4259 \n4260         Parameters\n4261         ----------\n4262         other : DataArray\n4263             DataArray to compare to.\n4264 \n4265         Returns\n4266         ----------\n4267         equal : bool\n4268             True if the two DataArrays are identical.\n4269 \n4270         See Also\n4271         --------\n4272         DataArray.broadcast_equals\n4273         DataArray.equals\n4274 \n4275         Examples\n4276         --------\n4277         >>> a = xr.DataArray([1, 2, 3], dims=\"X\", attrs=dict(units=\"m\"), name=\"Width\")\n4278         >>> b = xr.DataArray([1, 2, 3], dims=\"X\", attrs=dict(units=\"m\"), name=\"Width\")\n4279         >>> c = xr.DataArray([1, 2, 3], dims=\"X\", attrs=dict(units=\"ft\"), name=\"Width\")\n4280         >>> a\n4281         <xarray.DataArray 'Width' (X: 3)>\n4282         array([1, 2, 3])\n4283         Dimensions without coordinates: X\n4284         Attributes:\n4285             units:    m\n4286         >>> b\n4287         <xarray.DataArray 'Width' (X: 3)>\n4288         array([1, 2, 3])\n4289         Dimensions without coordinates: X\n4290         Attributes:\n4291             units:    m\n4292         >>> c\n4293         <xarray.DataArray 'Width' (X: 3)>\n4294         array([1, 2, 3])\n4295         Dimensions without coordinates: X\n4296         Attributes:\n4297             units:    ft\n4298 \n4299         >>> a.equals(b)\n4300         True\n4301         >>> a.identical(b)\n4302         True\n4303 \n4304         >>> a.equals(c)\n4305         True\n4306         >>> a.identical(c)\n4307         False\n4308         \"\"\"\n4309         try:\n4310             return self.name == other.name and self._all_compat(other, \"identical\")\n4311         except (TypeError, AttributeError):\n4312             return False\n4313 \n4314     def _result_name(self, other: Any = None) -> Hashable | None:\n4315         # use the same naming heuristics as pandas:\n4316         # https://github.com/ContinuumIO/blaze/issues/458#issuecomment-51936356\n4317         other_name = getattr(other, \"name\", _default)\n4318         if other_name is _default or other_name == self.name:\n4319             return self.name\n4320         else:\n4321             return None\n4322 \n4323     def __array_wrap__(self: T_DataArray, obj, context=None) -> T_DataArray:\n4324         new_var = self.variable.__array_wrap__(obj, context)\n4325         return self._replace(new_var)\n4326 \n4327     def __matmul__(self: T_DataArray, obj: T_DataArray) -> T_DataArray:\n4328         return self.dot(obj)\n4329 \n4330     def __rmatmul__(self: T_DataArray, other: T_DataArray) -> T_DataArray:\n4331         # currently somewhat duplicative, as only other DataArrays are\n4332         # compatible with matmul\n4333         return computation.dot(other, self)\n4334 \n4335     def _unary_op(self: T_DataArray, f: Callable, *args, **kwargs) -> T_DataArray:\n4336         keep_attrs = kwargs.pop(\"keep_attrs\", None)\n4337         if keep_attrs is None:\n4338             keep_attrs = _get_keep_attrs(default=True)\n4339         with warnings.catch_warnings():\n4340             warnings.filterwarnings(\"ignore\", r\"All-NaN (slice|axis) encountered\")\n4341             warnings.filterwarnings(\n4342                 \"ignore\", r\"Mean of empty slice\", category=RuntimeWarning\n4343             )\n4344             with np.errstate(all=\"ignore\"):\n4345                 da = self.__array_wrap__(f(self.variable.data, *args, **kwargs))\n4346             if keep_attrs:\n4347                 da.attrs = self.attrs\n4348             return da\n4349 \n4350     def _binary_op(\n4351         self: T_DataArray,\n4352         other: Any,\n4353         f: Callable,\n4354         reflexive: bool = False,\n4355     ) -> T_DataArray:\n4356         from xarray.core.groupby import GroupBy\n4357 \n4358         if isinstance(other, (Dataset, GroupBy)):\n4359             return NotImplemented\n4360         if isinstance(other, DataArray):\n4361             align_type = OPTIONS[\"arithmetic_join\"]\n4362             self, other = align(self, other, join=align_type, copy=False)  # type: ignore\n4363         other_variable = getattr(other, \"variable\", other)\n4364         other_coords = getattr(other, \"coords\", None)\n4365 \n4366         variable = (\n4367             f(self.variable, other_variable)\n4368             if not reflexive\n4369             else f(other_variable, self.variable)\n4370         )\n4371         coords, indexes = self.coords._merge_raw(other_coords, reflexive)\n4372         name = self._result_name(other)\n4373 \n4374         return self._replace(variable, coords, name, indexes=indexes)\n4375 \n4376     def _inplace_binary_op(self: T_DataArray, other: Any, f: Callable) -> T_DataArray:\n4377         from xarray.core.groupby import GroupBy\n4378 \n4379         if isinstance(other, GroupBy):\n4380             raise TypeError(\n4381                 \"in-place operations between a DataArray and \"\n4382                 \"a grouped object are not permitted\"\n4383             )\n4384         # n.b. we can't align other to self (with other.reindex_like(self))\n4385         # because `other` may be converted into floats, which would cause\n4386         # in-place arithmetic to fail unpredictably. Instead, we simply\n4387         # don't support automatic alignment with in-place arithmetic.\n4388         other_coords = getattr(other, \"coords\", None)\n4389         other_variable = getattr(other, \"variable\", other)\n4390         try:\n4391             with self.coords._merge_inplace(other_coords):\n4392                 f(self.variable, other_variable)\n4393         except MergeError as exc:\n4394             raise MergeError(\n4395                 \"Automatic alignment is not supported for in-place operations.\\n\"\n4396                 \"Consider aligning the indices manually or using a not-in-place operation.\\n\"\n4397                 \"See https://github.com/pydata/xarray/issues/3910 for more explanations.\"\n4398             ) from exc\n4399         return self\n4400 \n4401     def _copy_attrs_from(self, other: DataArray | Dataset | Variable) -> None:\n4402         self.attrs = other.attrs\n4403 \n4404     plot = utils.UncachedAccessor(DataArrayPlotAccessor)\n4405 \n4406     def _title_for_slice(self, truncate: int = 50) -> str:\n4407         \"\"\"\n4408         If the dataarray has 1 dimensional coordinates or comes from a slice\n4409         we can show that info in the title\n4410 \n4411         Parameters\n4412         ----------\n4413         truncate : int, default: 50\n4414             maximum number of characters for title\n4415 \n4416         Returns\n4417         -------\n4418         title : string\n4419             Can be used for plot titles\n4420 \n4421         \"\"\"\n4422         one_dims = []\n4423         for dim, coord in self.coords.items():\n4424             if coord.size == 1:\n4425                 one_dims.append(\n4426                     \"{dim} = {v}{unit}\".format(\n4427                         dim=dim,\n4428                         v=format_item(coord.values),\n4429                         unit=_get_units_from_attrs(coord),\n4430                     )\n4431                 )\n4432 \n4433         title = \", \".join(one_dims)\n4434         if len(title) > truncate:\n4435             title = title[: (truncate - 3)] + \"...\"\n4436 \n4437         return title\n4438 \n4439     def diff(\n4440         self: T_DataArray,\n4441         dim: Hashable,\n4442         n: int = 1,\n4443         label: Literal[\"upper\", \"lower\"] = \"upper\",\n4444     ) -> T_DataArray:\n4445         \"\"\"Calculate the n-th order discrete difference along given axis.\n4446 \n4447         Parameters\n4448         ----------\n4449         dim : Hashable\n4450             Dimension over which to calculate the finite difference.\n4451         n : int, default: 1\n4452             The number of times values are differenced.\n4453         label : {\"upper\", \"lower\"}, default: \"upper\"\n4454             The new coordinate in dimension ``dim`` will have the\n4455             values of either the minuend's or subtrahend's coordinate\n4456             for values 'upper' and 'lower', respectively.\n4457 \n4458         Returns\n4459         -------\n4460         difference : DataArray\n4461             The n-th order finite difference of this object.\n4462 \n4463         Notes\n4464         -----\n4465         `n` matches numpy's behavior and is different from pandas' first argument named\n4466         `periods`.\n4467 \n4468         Examples\n4469         --------\n4470         >>> arr = xr.DataArray([5, 5, 6, 6], [[1, 2, 3, 4]], [\"x\"])\n4471         >>> arr.diff(\"x\")\n4472         <xarray.DataArray (x: 3)>\n4473         array([0, 1, 0])\n4474         Coordinates:\n4475           * x        (x) int64 2 3 4\n4476         >>> arr.diff(\"x\", 2)\n4477         <xarray.DataArray (x: 2)>\n4478         array([ 1, -1])\n4479         Coordinates:\n4480           * x        (x) int64 3 4\n4481 \n4482         See Also\n4483         --------\n4484         DataArray.differentiate\n4485         \"\"\"\n4486         ds = self._to_temp_dataset().diff(n=n, dim=dim, label=label)\n4487         return self._from_temp_dataset(ds)\n4488 \n4489     def shift(\n4490         self: T_DataArray,\n4491         shifts: Mapping[Any, int] | None = None,\n4492         fill_value: Any = dtypes.NA,\n4493         **shifts_kwargs: int,\n4494     ) -> T_DataArray:\n4495         \"\"\"Shift this DataArray by an offset along one or more dimensions.\n4496 \n4497         Only the data is moved; coordinates stay in place. This is consistent\n4498         with the behavior of ``shift`` in pandas.\n4499 \n4500         Values shifted from beyond array bounds will appear at one end of\n4501         each dimension, which are filled according to `fill_value`. For periodic\n4502         offsets instead see `roll`.\n4503 \n4504         Parameters\n4505         ----------\n4506         shifts : mapping of Hashable to int or None, optional\n4507             Integer offset to shift along each of the given dimensions.\n4508             Positive offsets shift to the right; negative offsets shift to the\n4509             left.\n4510         fill_value : scalar, optional\n4511             Value to use for newly missing values\n4512         **shifts_kwargs\n4513             The keyword arguments form of ``shifts``.\n4514             One of shifts or shifts_kwargs must be provided.\n4515 \n4516         Returns\n4517         -------\n4518         shifted : DataArray\n4519             DataArray with the same coordinates and attributes but shifted\n4520             data.\n4521 \n4522         See Also\n4523         --------\n4524         roll\n4525 \n4526         Examples\n4527         --------\n4528         >>> arr = xr.DataArray([5, 6, 7], dims=\"x\")\n4529         >>> arr.shift(x=1)\n4530         <xarray.DataArray (x: 3)>\n4531         array([nan,  5.,  6.])\n4532         Dimensions without coordinates: x\n4533         \"\"\"\n4534         variable = self.variable.shift(\n4535             shifts=shifts, fill_value=fill_value, **shifts_kwargs\n4536         )\n4537         return self._replace(variable=variable)\n4538 \n4539     def roll(\n4540         self: T_DataArray,\n4541         shifts: Mapping[Hashable, int] | None = None,\n4542         roll_coords: bool = False,\n4543         **shifts_kwargs: int,\n4544     ) -> T_DataArray:\n4545         \"\"\"Roll this array by an offset along one or more dimensions.\n4546 \n4547         Unlike shift, roll treats the given dimensions as periodic, so will not\n4548         create any missing values to be filled.\n4549 \n4550         Unlike shift, roll may rotate all variables, including coordinates\n4551         if specified. The direction of rotation is consistent with\n4552         :py:func:`numpy.roll`.\n4553 \n4554         Parameters\n4555         ----------\n4556         shifts : mapping of Hashable to int, optional\n4557             Integer offset to rotate each of the given dimensions.\n4558             Positive offsets roll to the right; negative offsets roll to the\n4559             left.\n4560         roll_coords : bool, default: False\n4561             Indicates whether to roll the coordinates by the offset too.\n4562         **shifts_kwargs : {dim: offset, ...}, optional\n4563             The keyword arguments form of ``shifts``.\n4564             One of shifts or shifts_kwargs must be provided.\n4565 \n4566         Returns\n4567         -------\n4568         rolled : DataArray\n4569             DataArray with the same attributes but rolled data and coordinates.\n4570 \n4571         See Also\n4572         --------\n4573         shift\n4574 \n4575         Examples\n4576         --------\n4577         >>> arr = xr.DataArray([5, 6, 7], dims=\"x\")\n4578         >>> arr.roll(x=1)\n4579         <xarray.DataArray (x: 3)>\n4580         array([7, 5, 6])\n4581         Dimensions without coordinates: x\n4582         \"\"\"\n4583         ds = self._to_temp_dataset().roll(\n4584             shifts=shifts, roll_coords=roll_coords, **shifts_kwargs\n4585         )\n4586         return self._from_temp_dataset(ds)\n4587 \n4588     @property\n4589     def real(self: T_DataArray) -> T_DataArray:\n4590         \"\"\"\n4591         The real part of the array.\n4592 \n4593         See Also\n4594         --------\n4595         numpy.ndarray.real\n4596         \"\"\"\n4597         return self._replace(self.variable.real)\n4598 \n4599     @property\n4600     def imag(self: T_DataArray) -> T_DataArray:\n4601         \"\"\"\n4602         The imaginary part of the array.\n4603 \n4604         See Also\n4605         --------\n4606         numpy.ndarray.imag\n4607         \"\"\"\n4608         return self._replace(self.variable.imag)\n4609 \n4610     def dot(\n4611         self: T_DataArray,\n4612         other: T_DataArray,\n4613         dims: Dims = None,\n4614     ) -> T_DataArray:\n4615         \"\"\"Perform dot product of two DataArrays along their shared dims.\n4616 \n4617         Equivalent to taking taking tensordot over all shared dims.\n4618 \n4619         Parameters\n4620         ----------\n4621         other : DataArray\n4622             The other array with which the dot product is performed.\n4623         dims : ..., str, Iterable of Hashable or None, optional\n4624             Which dimensions to sum over. Ellipsis (`...`) sums over all dimensions.\n4625             If not specified, then all the common dimensions are summed over.\n4626 \n4627         Returns\n4628         -------\n4629         result : DataArray\n4630             Array resulting from the dot product over all shared dimensions.\n4631 \n4632         See Also\n4633         --------\n4634         dot\n4635         numpy.tensordot\n4636 \n4637         Examples\n4638         --------\n4639         >>> da_vals = np.arange(6 * 5 * 4).reshape((6, 5, 4))\n4640         >>> da = xr.DataArray(da_vals, dims=[\"x\", \"y\", \"z\"])\n4641         >>> dm_vals = np.arange(4)\n4642         >>> dm = xr.DataArray(dm_vals, dims=[\"z\"])\n4643 \n4644         >>> dm.dims\n4645         ('z',)\n4646 \n4647         >>> da.dims\n4648         ('x', 'y', 'z')\n4649 \n4650         >>> dot_result = da.dot(dm)\n4651         >>> dot_result.dims\n4652         ('x', 'y')\n4653 \n4654         \"\"\"\n4655         if isinstance(other, Dataset):\n4656             raise NotImplementedError(\n4657                 \"dot products are not yet supported with Dataset objects.\"\n4658             )\n4659         if not isinstance(other, DataArray):\n4660             raise TypeError(\"dot only operates on DataArrays.\")\n4661 \n4662         return computation.dot(self, other, dims=dims)\n4663 \n4664     # change type of self and return to T_DataArray once\n4665     # https://github.com/python/mypy/issues/12846 is resolved\n4666     def sortby(\n4667         self,\n4668         variables: Hashable | DataArray | Sequence[Hashable | DataArray],\n4669         ascending: bool = True,\n4670     ) -> DataArray:\n4671         \"\"\"Sort object by labels or values (along an axis).\n4672 \n4673         Sorts the dataarray, either along specified dimensions,\n4674         or according to values of 1-D dataarrays that share dimension\n4675         with calling object.\n4676 \n4677         If the input variables are dataarrays, then the dataarrays are aligned\n4678         (via left-join) to the calling object prior to sorting by cell values.\n4679         NaNs are sorted to the end, following Numpy convention.\n4680 \n4681         If multiple sorts along the same dimension is\n4682         given, numpy's lexsort is performed along that dimension:\n4683         https://numpy.org/doc/stable/reference/generated/numpy.lexsort.html\n4684         and the FIRST key in the sequence is used as the primary sort key,\n4685         followed by the 2nd key, etc.\n4686 \n4687         Parameters\n4688         ----------\n4689         variables : Hashable, DataArray, or sequence of Hashable or DataArray\n4690             1D DataArray objects or name(s) of 1D variable(s) in\n4691             coords whose values are used to sort this array.\n4692         ascending : bool, default: True\n4693             Whether to sort by ascending or descending order.\n4694 \n4695         Returns\n4696         -------\n4697         sorted : DataArray\n4698             A new dataarray where all the specified dims are sorted by dim\n4699             labels.\n4700 \n4701         See Also\n4702         --------\n4703         Dataset.sortby\n4704         numpy.sort\n4705         pandas.sort_values\n4706         pandas.sort_index\n4707 \n4708         Examples\n4709         --------\n4710         >>> da = xr.DataArray(\n4711         ...     np.random.rand(5),\n4712         ...     coords=[pd.date_range(\"1/1/2000\", periods=5)],\n4713         ...     dims=\"time\",\n4714         ... )\n4715         >>> da\n4716         <xarray.DataArray (time: 5)>\n4717         array([0.5488135 , 0.71518937, 0.60276338, 0.54488318, 0.4236548 ])\n4718         Coordinates:\n4719           * time     (time) datetime64[ns] 2000-01-01 2000-01-02 ... 2000-01-05\n4720 \n4721         >>> da.sortby(da)\n4722         <xarray.DataArray (time: 5)>\n4723         array([0.4236548 , 0.54488318, 0.5488135 , 0.60276338, 0.71518937])\n4724         Coordinates:\n4725           * time     (time) datetime64[ns] 2000-01-05 2000-01-04 ... 2000-01-02\n4726         \"\"\"\n4727         ds = self._to_temp_dataset().sortby(variables, ascending=ascending)\n4728         return self._from_temp_dataset(ds)\n4729 \n4730     def quantile(\n4731         self: T_DataArray,\n4732         q: ArrayLike,\n4733         dim: Dims = None,\n4734         method: QuantileMethods = \"linear\",\n4735         keep_attrs: bool | None = None,\n4736         skipna: bool | None = None,\n4737         interpolation: QuantileMethods | None = None,\n4738     ) -> T_DataArray:\n4739         \"\"\"Compute the qth quantile of the data along the specified dimension.\n4740 \n4741         Returns the qth quantiles(s) of the array elements.\n4742 \n4743         Parameters\n4744         ----------\n4745         q : float or array-like of float\n4746             Quantile to compute, which must be between 0 and 1 inclusive.\n4747         dim : str or Iterable of Hashable, optional\n4748             Dimension(s) over which to apply quantile.\n4749         method : str, default: \"linear\"\n4750             This optional parameter specifies the interpolation method to use when the\n4751             desired quantile lies between two data points. The options sorted by their R\n4752             type as summarized in the H&F paper [1]_ are:\n4753 \n4754                 1. \"inverted_cdf\" (*)\n4755                 2. \"averaged_inverted_cdf\" (*)\n4756                 3. \"closest_observation\" (*)\n4757                 4. \"interpolated_inverted_cdf\" (*)\n4758                 5. \"hazen\" (*)\n4759                 6. \"weibull\" (*)\n4760                 7. \"linear\"  (default)\n4761                 8. \"median_unbiased\" (*)\n4762                 9. \"normal_unbiased\" (*)\n4763 \n4764             The first three methods are discontiuous. The following discontinuous\n4765             variations of the default \"linear\" (7.) option are also available:\n4766 \n4767                 * \"lower\"\n4768                 * \"higher\"\n4769                 * \"midpoint\"\n4770                 * \"nearest\"\n4771 \n4772             See :py:func:`numpy.quantile` or [1]_ for details. The \"method\" argument\n4773             was previously called \"interpolation\", renamed in accordance with numpy\n4774             version 1.22.0.\n4775 \n4776             (*) These methods require numpy version 1.22 or newer.\n4777 \n4778         keep_attrs : bool or None, optional\n4779             If True, the dataset's attributes (`attrs`) will be copied from\n4780             the original object to the new one.  If False (default), the new\n4781             object will be returned without attributes.\n4782         skipna : bool or None, optional\n4783             If True, skip missing values (as marked by NaN). By default, only\n4784             skips missing values for float dtypes; other dtypes either do not\n4785             have a sentinel missing value (int) or skipna=True has not been\n4786             implemented (object, datetime64 or timedelta64).\n4787 \n4788         Returns\n4789         -------\n4790         quantiles : DataArray\n4791             If `q` is a single quantile, then the result\n4792             is a scalar. If multiple percentiles are given, first axis of\n4793             the result corresponds to the quantile and a quantile dimension\n4794             is added to the return array. The other dimensions are the\n4795             dimensions that remain after the reduction of the array.\n4796 \n4797         See Also\n4798         --------\n4799         numpy.nanquantile, numpy.quantile, pandas.Series.quantile, Dataset.quantile\n4800 \n4801         Examples\n4802         --------\n4803         >>> da = xr.DataArray(\n4804         ...     data=[[0.7, 4.2, 9.4, 1.5], [6.5, 7.3, 2.6, 1.9]],\n4805         ...     coords={\"x\": [7, 9], \"y\": [1, 1.5, 2, 2.5]},\n4806         ...     dims=(\"x\", \"y\"),\n4807         ... )\n4808         >>> da.quantile(0)  # or da.quantile(0, dim=...)\n4809         <xarray.DataArray ()>\n4810         array(0.7)\n4811         Coordinates:\n4812             quantile  float64 0.0\n4813         >>> da.quantile(0, dim=\"x\")\n4814         <xarray.DataArray (y: 4)>\n4815         array([0.7, 4.2, 2.6, 1.5])\n4816         Coordinates:\n4817           * y         (y) float64 1.0 1.5 2.0 2.5\n4818             quantile  float64 0.0\n4819         >>> da.quantile([0, 0.5, 1])\n4820         <xarray.DataArray (quantile: 3)>\n4821         array([0.7, 3.4, 9.4])\n4822         Coordinates:\n4823           * quantile  (quantile) float64 0.0 0.5 1.0\n4824         >>> da.quantile([0, 0.5, 1], dim=\"x\")\n4825         <xarray.DataArray (quantile: 3, y: 4)>\n4826         array([[0.7 , 4.2 , 2.6 , 1.5 ],\n4827                [3.6 , 5.75, 6.  , 1.7 ],\n4828                [6.5 , 7.3 , 9.4 , 1.9 ]])\n4829         Coordinates:\n4830           * y         (y) float64 1.0 1.5 2.0 2.5\n4831           * quantile  (quantile) float64 0.0 0.5 1.0\n4832 \n4833         References\n4834         ----------\n4835         .. [1] R. J. Hyndman and Y. Fan,\n4836            \"Sample quantiles in statistical packages,\"\n4837            The American Statistician, 50(4), pp. 361-365, 1996\n4838         \"\"\"\n4839 \n4840         ds = self._to_temp_dataset().quantile(\n4841             q,\n4842             dim=dim,\n4843             keep_attrs=keep_attrs,\n4844             method=method,\n4845             skipna=skipna,\n4846             interpolation=interpolation,\n4847         )\n4848         return self._from_temp_dataset(ds)\n4849 \n4850     def rank(\n4851         self: T_DataArray,\n4852         dim: Hashable,\n4853         pct: bool = False,\n4854         keep_attrs: bool | None = None,\n4855     ) -> T_DataArray:\n4856         \"\"\"Ranks the data.\n4857 \n4858         Equal values are assigned a rank that is the average of the ranks that\n4859         would have been otherwise assigned to all of the values within that\n4860         set.  Ranks begin at 1, not 0. If pct, computes percentage ranks.\n4861 \n4862         NaNs in the input array are returned as NaNs.\n4863 \n4864         The `bottleneck` library is required.\n4865 \n4866         Parameters\n4867         ----------\n4868         dim : Hashable\n4869             Dimension over which to compute rank.\n4870         pct : bool, default: False\n4871             If True, compute percentage ranks, otherwise compute integer ranks.\n4872         keep_attrs : bool or None, optional\n4873             If True, the dataset's attributes (`attrs`) will be copied from\n4874             the original object to the new one.  If False (default), the new\n4875             object will be returned without attributes.\n4876 \n4877         Returns\n4878         -------\n4879         ranked : DataArray\n4880             DataArray with the same coordinates and dtype 'float64'.\n4881 \n4882         Examples\n4883         --------\n4884         >>> arr = xr.DataArray([5, 6, 7], dims=\"x\")\n4885         >>> arr.rank(\"x\")\n4886         <xarray.DataArray (x: 3)>\n4887         array([1., 2., 3.])\n4888         Dimensions without coordinates: x\n4889         \"\"\"\n4890 \n4891         ds = self._to_temp_dataset().rank(dim, pct=pct, keep_attrs=keep_attrs)\n4892         return self._from_temp_dataset(ds)\n4893 \n4894     def differentiate(\n4895         self: T_DataArray,\n4896         coord: Hashable,\n4897         edge_order: Literal[1, 2] = 1,\n4898         datetime_unit: DatetimeUnitOptions = None,\n4899     ) -> T_DataArray:\n4900         \"\"\" Differentiate the array with the second order accurate central\n4901         differences.\n4902 \n4903         .. note::\n4904             This feature is limited to simple cartesian geometry, i.e. coord\n4905             must be one dimensional.\n4906 \n4907         Parameters\n4908         ----------\n4909         coord : Hashable\n4910             The coordinate to be used to compute the gradient.\n4911         edge_order : {1, 2}, default: 1\n4912             N-th order accurate differences at the boundaries.\n4913         datetime_unit : {\"Y\", \"M\", \"W\", \"D\", \"h\", \"m\", \"s\", \"ms\", \\\n4914                          \"us\", \"ns\", \"ps\", \"fs\", \"as\", None}, optional\n4915             Unit to compute gradient. Only valid for datetime coordinate.\n4916 \n4917         Returns\n4918         -------\n4919         differentiated: DataArray\n4920 \n4921         See also\n4922         --------\n4923         numpy.gradient: corresponding numpy function\n4924 \n4925         Examples\n4926         --------\n4927 \n4928         >>> da = xr.DataArray(\n4929         ...     np.arange(12).reshape(4, 3),\n4930         ...     dims=[\"x\", \"y\"],\n4931         ...     coords={\"x\": [0, 0.1, 1.1, 1.2]},\n4932         ... )\n4933         >>> da\n4934         <xarray.DataArray (x: 4, y: 3)>\n4935         array([[ 0,  1,  2],\n4936                [ 3,  4,  5],\n4937                [ 6,  7,  8],\n4938                [ 9, 10, 11]])\n4939         Coordinates:\n4940           * x        (x) float64 0.0 0.1 1.1 1.2\n4941         Dimensions without coordinates: y\n4942         >>>\n4943         >>> da.differentiate(\"x\")\n4944         <xarray.DataArray (x: 4, y: 3)>\n4945         array([[30.        , 30.        , 30.        ],\n4946                [27.54545455, 27.54545455, 27.54545455],\n4947                [27.54545455, 27.54545455, 27.54545455],\n4948                [30.        , 30.        , 30.        ]])\n4949         Coordinates:\n4950           * x        (x) float64 0.0 0.1 1.1 1.2\n4951         Dimensions without coordinates: y\n4952         \"\"\"\n4953         ds = self._to_temp_dataset().differentiate(coord, edge_order, datetime_unit)\n4954         return self._from_temp_dataset(ds)\n4955 \n4956     # change type of self and return to T_DataArray once\n4957     # https://github.com/python/mypy/issues/12846 is resolved\n4958     def integrate(\n4959         self,\n4960         coord: Hashable | Sequence[Hashable] = None,\n4961         datetime_unit: DatetimeUnitOptions = None,\n4962     ) -> DataArray:\n4963         \"\"\"Integrate along the given coordinate using the trapezoidal rule.\n4964 \n4965         .. note::\n4966             This feature is limited to simple cartesian geometry, i.e. coord\n4967             must be one dimensional.\n4968 \n4969         Parameters\n4970         ----------\n4971         coord : Hashable, or sequence of Hashable\n4972             Coordinate(s) used for the integration.\n4973         datetime_unit : {'Y', 'M', 'W', 'D', 'h', 'm', 's', 'ms', 'us', 'ns', \\\n4974                         'ps', 'fs', 'as', None}, optional\n4975             Specify the unit if a datetime coordinate is used.\n4976 \n4977         Returns\n4978         -------\n4979         integrated : DataArray\n4980 \n4981         See also\n4982         --------\n4983         Dataset.integrate\n4984         numpy.trapz : corresponding numpy function\n4985 \n4986         Examples\n4987         --------\n4988 \n4989         >>> da = xr.DataArray(\n4990         ...     np.arange(12).reshape(4, 3),\n4991         ...     dims=[\"x\", \"y\"],\n4992         ...     coords={\"x\": [0, 0.1, 1.1, 1.2]},\n4993         ... )\n4994         >>> da\n4995         <xarray.DataArray (x: 4, y: 3)>\n4996         array([[ 0,  1,  2],\n4997                [ 3,  4,  5],\n4998                [ 6,  7,  8],\n4999                [ 9, 10, 11]])\n5000         Coordinates:\n5001           * x        (x) float64 0.0 0.1 1.1 1.2\n5002         Dimensions without coordinates: y\n5003         >>>\n5004         >>> da.integrate(\"x\")\n5005         <xarray.DataArray (y: 3)>\n5006         array([5.4, 6.6, 7.8])\n5007         Dimensions without coordinates: y\n5008         \"\"\"\n5009         ds = self._to_temp_dataset().integrate(coord, datetime_unit)\n5010         return self._from_temp_dataset(ds)\n5011 \n5012     # change type of self and return to T_DataArray once\n5013     # https://github.com/python/mypy/issues/12846 is resolved\n5014     def cumulative_integrate(\n5015         self,\n5016         coord: Hashable | Sequence[Hashable] = None,\n5017         datetime_unit: DatetimeUnitOptions = None,\n5018     ) -> DataArray:\n5019         \"\"\"Integrate cumulatively along the given coordinate using the trapezoidal rule.\n5020 \n5021         .. note::\n5022             This feature is limited to simple cartesian geometry, i.e. coord\n5023             must be one dimensional.\n5024 \n5025             The first entry of the cumulative integral is always 0, in order to keep the\n5026             length of the dimension unchanged between input and output.\n5027 \n5028         Parameters\n5029         ----------\n5030         coord : Hashable, or sequence of Hashable\n5031             Coordinate(s) used for the integration.\n5032         datetime_unit : {'Y', 'M', 'W', 'D', 'h', 'm', 's', 'ms', 'us', 'ns', \\\n5033                         'ps', 'fs', 'as', None}, optional\n5034             Specify the unit if a datetime coordinate is used.\n5035 \n5036         Returns\n5037         -------\n5038         integrated : DataArray\n5039 \n5040         See also\n5041         --------\n5042         Dataset.cumulative_integrate\n5043         scipy.integrate.cumulative_trapezoid : corresponding scipy function\n5044 \n5045         Examples\n5046         --------\n5047 \n5048         >>> da = xr.DataArray(\n5049         ...     np.arange(12).reshape(4, 3),\n5050         ...     dims=[\"x\", \"y\"],\n5051         ...     coords={\"x\": [0, 0.1, 1.1, 1.2]},\n5052         ... )\n5053         >>> da\n5054         <xarray.DataArray (x: 4, y: 3)>\n5055         array([[ 0,  1,  2],\n5056                [ 3,  4,  5],\n5057                [ 6,  7,  8],\n5058                [ 9, 10, 11]])\n5059         Coordinates:\n5060           * x        (x) float64 0.0 0.1 1.1 1.2\n5061         Dimensions without coordinates: y\n5062         >>>\n5063         >>> da.cumulative_integrate(\"x\")\n5064         <xarray.DataArray (x: 4, y: 3)>\n5065         array([[0.  , 0.  , 0.  ],\n5066                [0.15, 0.25, 0.35],\n5067                [4.65, 5.75, 6.85],\n5068                [5.4 , 6.6 , 7.8 ]])\n5069         Coordinates:\n5070           * x        (x) float64 0.0 0.1 1.1 1.2\n5071         Dimensions without coordinates: y\n5072         \"\"\"\n5073         ds = self._to_temp_dataset().cumulative_integrate(coord, datetime_unit)\n5074         return self._from_temp_dataset(ds)\n5075 \n5076     def unify_chunks(self) -> DataArray:\n5077         \"\"\"Unify chunk size along all chunked dimensions of this DataArray.\n5078 \n5079         Returns\n5080         -------\n5081         DataArray with consistent chunk sizes for all dask-array variables\n5082 \n5083         See Also\n5084         --------\n5085         dask.array.core.unify_chunks\n5086         \"\"\"\n5087 \n5088         return unify_chunks(self)[0]\n5089 \n5090     def map_blocks(\n5091         self,\n5092         func: Callable[..., T_Xarray],\n5093         args: Sequence[Any] = (),\n5094         kwargs: Mapping[str, Any] | None = None,\n5095         template: DataArray | Dataset | None = None,\n5096     ) -> T_Xarray:\n5097         \"\"\"\n5098         Apply a function to each block of this DataArray.\n5099 \n5100         .. warning::\n5101             This method is experimental and its signature may change.\n5102 \n5103         Parameters\n5104         ----------\n5105         func : callable\n5106             User-provided function that accepts a DataArray as its first\n5107             parameter. The function will receive a subset or 'block' of this DataArray (see below),\n5108             corresponding to one chunk along each chunked dimension. ``func`` will be\n5109             executed as ``func(subset_dataarray, *subset_args, **kwargs)``.\n5110 \n5111             This function must return either a single DataArray or a single Dataset.\n5112 \n5113             This function cannot add a new chunked dimension.\n5114         args : sequence\n5115             Passed to func after unpacking and subsetting any xarray objects by blocks.\n5116             xarray objects in args must be aligned with this object, otherwise an error is raised.\n5117         kwargs : mapping\n5118             Passed verbatim to func after unpacking. xarray objects, if any, will not be\n5119             subset to blocks. Passing dask collections in kwargs is not allowed.\n5120         template : DataArray or Dataset, optional\n5121             xarray object representing the final result after compute is called. If not provided,\n5122             the function will be first run on mocked-up data, that looks like this object but\n5123             has sizes 0, to determine properties of the returned object such as dtype,\n5124             variable names, attributes, new dimensions and new indexes (if any).\n5125             ``template`` must be provided if the function changes the size of existing dimensions.\n5126             When provided, ``attrs`` on variables in `template` are copied over to the result. Any\n5127             ``attrs`` set by ``func`` will be ignored.\n5128 \n5129         Returns\n5130         -------\n5131         A single DataArray or Dataset with dask backend, reassembled from the outputs of the\n5132         function.\n5133 \n5134         Notes\n5135         -----\n5136         This function is designed for when ``func`` needs to manipulate a whole xarray object\n5137         subset to each block. Each block is loaded into memory. In the more common case where\n5138         ``func`` can work on numpy arrays, it is recommended to use ``apply_ufunc``.\n5139 \n5140         If none of the variables in this object is backed by dask arrays, calling this function is\n5141         equivalent to calling ``func(obj, *args, **kwargs)``.\n5142 \n5143         See Also\n5144         --------\n5145         dask.array.map_blocks, xarray.apply_ufunc, xarray.Dataset.map_blocks\n5146         xarray.DataArray.map_blocks\n5147 \n5148         Examples\n5149         --------\n5150         Calculate an anomaly from climatology using ``.groupby()``. Using\n5151         ``xr.map_blocks()`` allows for parallel operations with knowledge of ``xarray``,\n5152         its indices, and its methods like ``.groupby()``.\n5153 \n5154         >>> def calculate_anomaly(da, groupby_type=\"time.month\"):\n5155         ...     gb = da.groupby(groupby_type)\n5156         ...     clim = gb.mean(dim=\"time\")\n5157         ...     return gb - clim\n5158         ...\n5159         >>> time = xr.cftime_range(\"1990-01\", \"1992-01\", freq=\"M\")\n5160         >>> month = xr.DataArray(time.month, coords={\"time\": time}, dims=[\"time\"])\n5161         >>> np.random.seed(123)\n5162         >>> array = xr.DataArray(\n5163         ...     np.random.rand(len(time)),\n5164         ...     dims=[\"time\"],\n5165         ...     coords={\"time\": time, \"month\": month},\n5166         ... ).chunk()\n5167         >>> array.map_blocks(calculate_anomaly, template=array).compute()\n5168         <xarray.DataArray (time: 24)>\n5169         array([ 0.12894847,  0.11323072, -0.0855964 , -0.09334032,  0.26848862,\n5170                 0.12382735,  0.22460641,  0.07650108, -0.07673453, -0.22865714,\n5171                -0.19063865,  0.0590131 , -0.12894847, -0.11323072,  0.0855964 ,\n5172                 0.09334032, -0.26848862, -0.12382735, -0.22460641, -0.07650108,\n5173                 0.07673453,  0.22865714,  0.19063865, -0.0590131 ])\n5174         Coordinates:\n5175           * time     (time) object 1990-01-31 00:00:00 ... 1991-12-31 00:00:00\n5176             month    (time) int64 1 2 3 4 5 6 7 8 9 10 11 12 1 2 3 4 5 6 7 8 9 10 11 12\n5177 \n5178         Note that one must explicitly use ``args=[]`` and ``kwargs={}`` to pass arguments\n5179         to the function being applied in ``xr.map_blocks()``:\n5180 \n5181         >>> array.map_blocks(\n5182         ...     calculate_anomaly, kwargs={\"groupby_type\": \"time.year\"}, template=array\n5183         ... )  # doctest: +ELLIPSIS\n5184         <xarray.DataArray (time: 24)>\n5185         dask.array<<this-array>-calculate_anomaly, shape=(24,), dtype=float64, chunksize=(24,), chunktype=numpy.ndarray>\n5186         Coordinates:\n5187           * time     (time) object 1990-01-31 00:00:00 ... 1991-12-31 00:00:00\n5188             month    (time) int64 dask.array<chunksize=(24,), meta=np.ndarray>\n5189         \"\"\"\n5190         from xarray.core.parallel import map_blocks\n5191 \n5192         return map_blocks(func, self, args, kwargs, template)\n5193 \n5194     def polyfit(\n5195         self,\n5196         dim: Hashable,\n5197         deg: int,\n5198         skipna: bool | None = None,\n5199         rcond: float | None = None,\n5200         w: Hashable | Any | None = None,\n5201         full: bool = False,\n5202         cov: bool | Literal[\"unscaled\"] = False,\n5203     ) -> Dataset:\n5204         \"\"\"\n5205         Least squares polynomial fit.\n5206 \n5207         This replicates the behaviour of `numpy.polyfit` but differs by skipping\n5208         invalid values when `skipna = True`.\n5209 \n5210         Parameters\n5211         ----------\n5212         dim : Hashable\n5213             Coordinate along which to fit the polynomials.\n5214         deg : int\n5215             Degree of the fitting polynomial.\n5216         skipna : bool or None, optional\n5217             If True, removes all invalid values before fitting each 1D slices of the array.\n5218             Default is True if data is stored in a dask.array or if there is any\n5219             invalid values, False otherwise.\n5220         rcond : float or None, optional\n5221             Relative condition number to the fit.\n5222         w : Hashable, array-like or None, optional\n5223             Weights to apply to the y-coordinate of the sample points.\n5224             Can be an array-like object or the name of a coordinate in the dataset.\n5225         full : bool, default: False\n5226             Whether to return the residuals, matrix rank and singular values in addition\n5227             to the coefficients.\n5228         cov : bool or \"unscaled\", default: False\n5229             Whether to return to the covariance matrix in addition to the coefficients.\n5230             The matrix is not scaled if `cov='unscaled'`.\n5231 \n5232         Returns\n5233         -------\n5234         polyfit_results : Dataset\n5235             A single dataset which contains:\n5236 \n5237             polyfit_coefficients\n5238                 The coefficients of the best fit.\n5239             polyfit_residuals\n5240                 The residuals of the least-square computation (only included if `full=True`).\n5241                 When the matrix rank is deficient, np.nan is returned.\n5242             [dim]_matrix_rank\n5243                 The effective rank of the scaled Vandermonde coefficient matrix (only included if `full=True`)\n5244             [dim]_singular_value\n5245                 The singular values of the scaled Vandermonde coefficient matrix (only included if `full=True`)\n5246             polyfit_covariance\n5247                 The covariance matrix of the polynomial coefficient estimates (only included if `full=False` and `cov=True`)\n5248 \n5249         See Also\n5250         --------\n5251         numpy.polyfit\n5252         numpy.polyval\n5253         xarray.polyval\n5254         \"\"\"\n5255         return self._to_temp_dataset().polyfit(\n5256             dim, deg, skipna=skipna, rcond=rcond, w=w, full=full, cov=cov\n5257         )\n5258 \n5259     def pad(\n5260         self: T_DataArray,\n5261         pad_width: Mapping[Any, int | tuple[int, int]] | None = None,\n5262         mode: PadModeOptions = \"constant\",\n5263         stat_length: int\n5264         | tuple[int, int]\n5265         | Mapping[Any, tuple[int, int]]\n5266         | None = None,\n5267         constant_values: float\n5268         | tuple[float, float]\n5269         | Mapping[Any, tuple[float, float]]\n5270         | None = None,\n5271         end_values: int | tuple[int, int] | Mapping[Any, tuple[int, int]] | None = None,\n5272         reflect_type: PadReflectOptions = None,\n5273         keep_attrs: bool | None = None,\n5274         **pad_width_kwargs: Any,\n5275     ) -> T_DataArray:\n5276         \"\"\"Pad this array along one or more dimensions.\n5277 \n5278         .. warning::\n5279             This function is experimental and its behaviour is likely to change\n5280             especially regarding padding of dimension coordinates (or IndexVariables).\n5281 \n5282         When using one of the modes (\"edge\", \"reflect\", \"symmetric\", \"wrap\"),\n5283         coordinates will be padded with the same mode, otherwise coordinates\n5284         are padded using the \"constant\" mode with fill_value dtypes.NA.\n5285 \n5286         Parameters\n5287         ----------\n5288         pad_width : mapping of Hashable to tuple of int\n5289             Mapping with the form of {dim: (pad_before, pad_after)}\n5290             describing the number of values padded along each dimension.\n5291             {dim: pad} is a shortcut for pad_before = pad_after = pad\n5292         mode : {\"constant\", \"edge\", \"linear_ramp\", \"maximum\", \"mean\", \"median\", \\\n5293             \"minimum\", \"reflect\", \"symmetric\", \"wrap\"}, default: \"constant\"\n5294             How to pad the DataArray (taken from numpy docs):\n5295 \n5296             - \"constant\": Pads with a constant value.\n5297             - \"edge\": Pads with the edge values of array.\n5298             - \"linear_ramp\": Pads with the linear ramp between end_value and the\n5299               array edge value.\n5300             - \"maximum\": Pads with the maximum value of all or part of the\n5301               vector along each axis.\n5302             - \"mean\": Pads with the mean value of all or part of the\n5303               vector along each axis.\n5304             - \"median\": Pads with the median value of all or part of the\n5305               vector along each axis.\n5306             - \"minimum\": Pads with the minimum value of all or part of the\n5307               vector along each axis.\n5308             - \"reflect\": Pads with the reflection of the vector mirrored on\n5309               the first and last values of the vector along each axis.\n5310             - \"symmetric\": Pads with the reflection of the vector mirrored\n5311               along the edge of the array.\n5312             - \"wrap\": Pads with the wrap of the vector along the axis.\n5313               The first values are used to pad the end and the\n5314               end values are used to pad the beginning.\n5315 \n5316         stat_length : int, tuple or mapping of Hashable to tuple, default: None\n5317             Used in 'maximum', 'mean', 'median', and 'minimum'.  Number of\n5318             values at edge of each axis used to calculate the statistic value.\n5319             {dim_1: (before_1, after_1), ... dim_N: (before_N, after_N)} unique\n5320             statistic lengths along each dimension.\n5321             ((before, after),) yields same before and after statistic lengths\n5322             for each dimension.\n5323             (stat_length,) or int is a shortcut for before = after = statistic\n5324             length for all axes.\n5325             Default is ``None``, to use the entire axis.\n5326         constant_values : scalar, tuple or mapping of Hashable to tuple, default: 0\n5327             Used in 'constant'.  The values to set the padded values for each\n5328             axis.\n5329             ``{dim_1: (before_1, after_1), ... dim_N: (before_N, after_N)}`` unique\n5330             pad constants along each dimension.\n5331             ``((before, after),)`` yields same before and after constants for each\n5332             dimension.\n5333             ``(constant,)`` or ``constant`` is a shortcut for ``before = after = constant`` for\n5334             all dimensions.\n5335             Default is 0.\n5336         end_values : scalar, tuple or mapping of Hashable to tuple, default: 0\n5337             Used in 'linear_ramp'.  The values used for the ending value of the\n5338             linear_ramp and that will form the edge of the padded array.\n5339             ``{dim_1: (before_1, after_1), ... dim_N: (before_N, after_N)}`` unique\n5340             end values along each dimension.\n5341             ``((before, after),)`` yields same before and after end values for each\n5342             axis.\n5343             ``(constant,)`` or ``constant`` is a shortcut for ``before = after = constant`` for\n5344             all axes.\n5345             Default is 0.\n5346         reflect_type : {\"even\", \"odd\", None}, optional\n5347             Used in \"reflect\", and \"symmetric\". The \"even\" style is the\n5348             default with an unaltered reflection around the edge value. For\n5349             the \"odd\" style, the extended part of the array is created by\n5350             subtracting the reflected values from two times the edge value.\n5351         keep_attrs : bool or None, optional\n5352             If True, the attributes (``attrs``) will be copied from the\n5353             original object to the new one. If False, the new object\n5354             will be returned without attributes.\n5355         **pad_width_kwargs\n5356             The keyword arguments form of ``pad_width``.\n5357             One of ``pad_width`` or ``pad_width_kwargs`` must be provided.\n5358 \n5359         Returns\n5360         -------\n5361         padded : DataArray\n5362             DataArray with the padded coordinates and data.\n5363 \n5364         See Also\n5365         --------\n5366         DataArray.shift, DataArray.roll, DataArray.bfill, DataArray.ffill, numpy.pad, dask.array.pad\n5367 \n5368         Notes\n5369         -----\n5370         For ``mode=\"constant\"`` and ``constant_values=None``, integer types will be\n5371         promoted to ``float`` and padded with ``np.nan``.\n5372 \n5373         Padding coordinates will drop their corresponding index (if any) and will reset default\n5374         indexes for dimension coordinates.\n5375 \n5376         Examples\n5377         --------\n5378         >>> arr = xr.DataArray([5, 6, 7], coords=[(\"x\", [0, 1, 2])])\n5379         >>> arr.pad(x=(1, 2), constant_values=0)\n5380         <xarray.DataArray (x: 6)>\n5381         array([0, 5, 6, 7, 0, 0])\n5382         Coordinates:\n5383           * x        (x) float64 nan 0.0 1.0 2.0 nan nan\n5384 \n5385         >>> da = xr.DataArray(\n5386         ...     [[0, 1, 2, 3], [10, 11, 12, 13]],\n5387         ...     dims=[\"x\", \"y\"],\n5388         ...     coords={\"x\": [0, 1], \"y\": [10, 20, 30, 40], \"z\": (\"x\", [100, 200])},\n5389         ... )\n5390         >>> da.pad(x=1)\n5391         <xarray.DataArray (x: 4, y: 4)>\n5392         array([[nan, nan, nan, nan],\n5393                [ 0.,  1.,  2.,  3.],\n5394                [10., 11., 12., 13.],\n5395                [nan, nan, nan, nan]])\n5396         Coordinates:\n5397           * x        (x) float64 nan 0.0 1.0 nan\n5398           * y        (y) int64 10 20 30 40\n5399             z        (x) float64 nan 100.0 200.0 nan\n5400 \n5401         Careful, ``constant_values`` are coerced to the data type of the array which may\n5402         lead to a loss of precision:\n5403 \n5404         >>> da.pad(x=1, constant_values=1.23456789)\n5405         <xarray.DataArray (x: 4, y: 4)>\n5406         array([[ 1,  1,  1,  1],\n5407                [ 0,  1,  2,  3],\n5408                [10, 11, 12, 13],\n5409                [ 1,  1,  1,  1]])\n5410         Coordinates:\n5411           * x        (x) float64 nan 0.0 1.0 nan\n5412           * y        (y) int64 10 20 30 40\n5413             z        (x) float64 nan 100.0 200.0 nan\n5414         \"\"\"\n5415         ds = self._to_temp_dataset().pad(\n5416             pad_width=pad_width,\n5417             mode=mode,\n5418             stat_length=stat_length,\n5419             constant_values=constant_values,\n5420             end_values=end_values,\n5421             reflect_type=reflect_type,\n5422             keep_attrs=keep_attrs,\n5423             **pad_width_kwargs,\n5424         )\n5425         return self._from_temp_dataset(ds)\n5426 \n5427     def idxmin(\n5428         self,\n5429         dim: Hashable | None = None,\n5430         skipna: bool | None = None,\n5431         fill_value: Any = dtypes.NA,\n5432         keep_attrs: bool | None = None,\n5433     ) -> DataArray:\n5434         \"\"\"Return the coordinate label of the minimum value along a dimension.\n5435 \n5436         Returns a new `DataArray` named after the dimension with the values of\n5437         the coordinate labels along that dimension corresponding to minimum\n5438         values along that dimension.\n5439 \n5440         In comparison to :py:meth:`~DataArray.argmin`, this returns the\n5441         coordinate label while :py:meth:`~DataArray.argmin` returns the index.\n5442 \n5443         Parameters\n5444         ----------\n5445         dim : str, optional\n5446             Dimension over which to apply `idxmin`.  This is optional for 1D\n5447             arrays, but required for arrays with 2 or more dimensions.\n5448         skipna : bool or None, default: None\n5449             If True, skip missing values (as marked by NaN). By default, only\n5450             skips missing values for ``float``, ``complex``, and ``object``\n5451             dtypes; other dtypes either do not have a sentinel missing value\n5452             (``int``) or ``skipna=True`` has not been implemented\n5453             (``datetime64`` or ``timedelta64``).\n5454         fill_value : Any, default: NaN\n5455             Value to be filled in case all of the values along a dimension are\n5456             null.  By default this is NaN.  The fill value and result are\n5457             automatically converted to a compatible dtype if possible.\n5458             Ignored if ``skipna`` is False.\n5459         keep_attrs : bool or None, optional\n5460             If True, the attributes (``attrs``) will be copied from the\n5461             original object to the new one. If False, the new object\n5462             will be returned without attributes.\n5463 \n5464         Returns\n5465         -------\n5466         reduced : DataArray\n5467             New `DataArray` object with `idxmin` applied to its data and the\n5468             indicated dimension removed.\n5469 \n5470         See Also\n5471         --------\n5472         Dataset.idxmin, DataArray.idxmax, DataArray.min, DataArray.argmin\n5473 \n5474         Examples\n5475         --------\n5476         >>> array = xr.DataArray(\n5477         ...     [0, 2, 1, 0, -2], dims=\"x\", coords={\"x\": [\"a\", \"b\", \"c\", \"d\", \"e\"]}\n5478         ... )\n5479         >>> array.min()\n5480         <xarray.DataArray ()>\n5481         array(-2)\n5482         >>> array.argmin(...)\n5483         {'x': <xarray.DataArray ()>\n5484         array(4)}\n5485         >>> array.idxmin()\n5486         <xarray.DataArray 'x' ()>\n5487         array('e', dtype='<U1')\n5488 \n5489         >>> array = xr.DataArray(\n5490         ...     [\n5491         ...         [2.0, 1.0, 2.0, 0.0, -2.0],\n5492         ...         [-4.0, np.NaN, 2.0, np.NaN, -2.0],\n5493         ...         [np.NaN, np.NaN, 1.0, np.NaN, np.NaN],\n5494         ...     ],\n5495         ...     dims=[\"y\", \"x\"],\n5496         ...     coords={\"y\": [-1, 0, 1], \"x\": np.arange(5.0) ** 2},\n5497         ... )\n5498         >>> array.min(dim=\"x\")\n5499         <xarray.DataArray (y: 3)>\n5500         array([-2., -4.,  1.])\n5501         Coordinates:\n5502           * y        (y) int64 -1 0 1\n5503         >>> array.argmin(dim=\"x\")\n5504         <xarray.DataArray (y: 3)>\n5505         array([4, 0, 2])\n5506         Coordinates:\n5507           * y        (y) int64 -1 0 1\n5508         >>> array.idxmin(dim=\"x\")\n5509         <xarray.DataArray 'x' (y: 3)>\n5510         array([16.,  0.,  4.])\n5511         Coordinates:\n5512           * y        (y) int64 -1 0 1\n5513         \"\"\"\n5514         return computation._calc_idxminmax(\n5515             array=self,\n5516             func=lambda x, *args, **kwargs: x.argmin(*args, **kwargs),\n5517             dim=dim,\n5518             skipna=skipna,\n5519             fill_value=fill_value,\n5520             keep_attrs=keep_attrs,\n5521         )\n5522 \n5523     def idxmax(\n5524         self,\n5525         dim: Hashable = None,\n5526         skipna: bool | None = None,\n5527         fill_value: Any = dtypes.NA,\n5528         keep_attrs: bool | None = None,\n5529     ) -> DataArray:\n5530         \"\"\"Return the coordinate label of the maximum value along a dimension.\n5531 \n5532         Returns a new `DataArray` named after the dimension with the values of\n5533         the coordinate labels along that dimension corresponding to maximum\n5534         values along that dimension.\n5535 \n5536         In comparison to :py:meth:`~DataArray.argmax`, this returns the\n5537         coordinate label while :py:meth:`~DataArray.argmax` returns the index.\n5538 \n5539         Parameters\n5540         ----------\n5541         dim : Hashable, optional\n5542             Dimension over which to apply `idxmax`.  This is optional for 1D\n5543             arrays, but required for arrays with 2 or more dimensions.\n5544         skipna : bool or None, default: None\n5545             If True, skip missing values (as marked by NaN). By default, only\n5546             skips missing values for ``float``, ``complex``, and ``object``\n5547             dtypes; other dtypes either do not have a sentinel missing value\n5548             (``int``) or ``skipna=True`` has not been implemented\n5549             (``datetime64`` or ``timedelta64``).\n5550         fill_value : Any, default: NaN\n5551             Value to be filled in case all of the values along a dimension are\n5552             null.  By default this is NaN.  The fill value and result are\n5553             automatically converted to a compatible dtype if possible.\n5554             Ignored if ``skipna`` is False.\n5555         keep_attrs : bool or None, optional\n5556             If True, the attributes (``attrs``) will be copied from the\n5557             original object to the new one. If False, the new object\n5558             will be returned without attributes.\n5559 \n5560         Returns\n5561         -------\n5562         reduced : DataArray\n5563             New `DataArray` object with `idxmax` applied to its data and the\n5564             indicated dimension removed.\n5565 \n5566         See Also\n5567         --------\n5568         Dataset.idxmax, DataArray.idxmin, DataArray.max, DataArray.argmax\n5569 \n5570         Examples\n5571         --------\n5572         >>> array = xr.DataArray(\n5573         ...     [0, 2, 1, 0, -2], dims=\"x\", coords={\"x\": [\"a\", \"b\", \"c\", \"d\", \"e\"]}\n5574         ... )\n5575         >>> array.max()\n5576         <xarray.DataArray ()>\n5577         array(2)\n5578         >>> array.argmax(...)\n5579         {'x': <xarray.DataArray ()>\n5580         array(1)}\n5581         >>> array.idxmax()\n5582         <xarray.DataArray 'x' ()>\n5583         array('b', dtype='<U1')\n5584 \n5585         >>> array = xr.DataArray(\n5586         ...     [\n5587         ...         [2.0, 1.0, 2.0, 0.0, -2.0],\n5588         ...         [-4.0, np.NaN, 2.0, np.NaN, -2.0],\n5589         ...         [np.NaN, np.NaN, 1.0, np.NaN, np.NaN],\n5590         ...     ],\n5591         ...     dims=[\"y\", \"x\"],\n5592         ...     coords={\"y\": [-1, 0, 1], \"x\": np.arange(5.0) ** 2},\n5593         ... )\n5594         >>> array.max(dim=\"x\")\n5595         <xarray.DataArray (y: 3)>\n5596         array([2., 2., 1.])\n5597         Coordinates:\n5598           * y        (y) int64 -1 0 1\n5599         >>> array.argmax(dim=\"x\")\n5600         <xarray.DataArray (y: 3)>\n5601         array([0, 2, 2])\n5602         Coordinates:\n5603           * y        (y) int64 -1 0 1\n5604         >>> array.idxmax(dim=\"x\")\n5605         <xarray.DataArray 'x' (y: 3)>\n5606         array([0., 4., 4.])\n5607         Coordinates:\n5608           * y        (y) int64 -1 0 1\n5609         \"\"\"\n5610         return computation._calc_idxminmax(\n5611             array=self,\n5612             func=lambda x, *args, **kwargs: x.argmax(*args, **kwargs),\n5613             dim=dim,\n5614             skipna=skipna,\n5615             fill_value=fill_value,\n5616             keep_attrs=keep_attrs,\n5617         )\n5618 \n5619     # change type of self and return to T_DataArray once\n5620     # https://github.com/python/mypy/issues/12846 is resolved\n5621     def argmin(\n5622         self,\n5623         dim: Dims = None,\n5624         axis: int | None = None,\n5625         keep_attrs: bool | None = None,\n5626         skipna: bool | None = None,\n5627     ) -> DataArray | dict[Hashable, DataArray]:\n5628         \"\"\"Index or indices of the minimum of the DataArray over one or more dimensions.\n5629 \n5630         If a sequence is passed to 'dim', then result returned as dict of DataArrays,\n5631         which can be passed directly to isel(). If a single str is passed to 'dim' then\n5632         returns a DataArray with dtype int.\n5633 \n5634         If there are multiple minima, the indices of the first one found will be\n5635         returned.\n5636 \n5637         Parameters\n5638         ----------\n5639         dim : \"...\", str, Iterable of Hashable or None, optional\n5640             The dimensions over which to find the minimum. By default, finds minimum over\n5641             all dimensions - for now returning an int for backward compatibility, but\n5642             this is deprecated, in future will return a dict with indices for all\n5643             dimensions; to return a dict with all dimensions now, pass '...'.\n5644         axis : int or None, optional\n5645             Axis over which to apply `argmin`. Only one of the 'dim' and 'axis' arguments\n5646             can be supplied.\n5647         keep_attrs : bool or None, optional\n5648             If True, the attributes (`attrs`) will be copied from the original\n5649             object to the new one. If False, the new object will be\n5650             returned without attributes.\n5651         skipna : bool or None, optional\n5652             If True, skip missing values (as marked by NaN). By default, only\n5653             skips missing values for float dtypes; other dtypes either do not\n5654             have a sentinel missing value (int) or skipna=True has not been\n5655             implemented (object, datetime64 or timedelta64).\n5656 \n5657         Returns\n5658         -------\n5659         result : DataArray or dict of DataArray\n5660 \n5661         See Also\n5662         --------\n5663         Variable.argmin, DataArray.idxmin\n5664 \n5665         Examples\n5666         --------\n5667         >>> array = xr.DataArray([0, 2, -1, 3], dims=\"x\")\n5668         >>> array.min()\n5669         <xarray.DataArray ()>\n5670         array(-1)\n5671         >>> array.argmin(...)\n5672         {'x': <xarray.DataArray ()>\n5673         array(2)}\n5674         >>> array.isel(array.argmin(...))\n5675         <xarray.DataArray ()>\n5676         array(-1)\n5677 \n5678         >>> array = xr.DataArray(\n5679         ...     [[[3, 2, 1], [3, 1, 2], [2, 1, 3]], [[1, 3, 2], [2, -5, 1], [2, 3, 1]]],\n5680         ...     dims=(\"x\", \"y\", \"z\"),\n5681         ... )\n5682         >>> array.min(dim=\"x\")\n5683         <xarray.DataArray (y: 3, z: 3)>\n5684         array([[ 1,  2,  1],\n5685                [ 2, -5,  1],\n5686                [ 2,  1,  1]])\n5687         Dimensions without coordinates: y, z\n5688         >>> array.argmin(dim=\"x\")\n5689         <xarray.DataArray (y: 3, z: 3)>\n5690         array([[1, 0, 0],\n5691                [1, 1, 1],\n5692                [0, 0, 1]])\n5693         Dimensions without coordinates: y, z\n5694         >>> array.argmin(dim=[\"x\"])\n5695         {'x': <xarray.DataArray (y: 3, z: 3)>\n5696         array([[1, 0, 0],\n5697                [1, 1, 1],\n5698                [0, 0, 1]])\n5699         Dimensions without coordinates: y, z}\n5700         >>> array.min(dim=(\"x\", \"z\"))\n5701         <xarray.DataArray (y: 3)>\n5702         array([ 1, -5,  1])\n5703         Dimensions without coordinates: y\n5704         >>> array.argmin(dim=[\"x\", \"z\"])\n5705         {'x': <xarray.DataArray (y: 3)>\n5706         array([0, 1, 0])\n5707         Dimensions without coordinates: y, 'z': <xarray.DataArray (y: 3)>\n5708         array([2, 1, 1])\n5709         Dimensions without coordinates: y}\n5710         >>> array.isel(array.argmin(dim=[\"x\", \"z\"]))\n5711         <xarray.DataArray (y: 3)>\n5712         array([ 1, -5,  1])\n5713         Dimensions without coordinates: y\n5714         \"\"\"\n5715         result = self.variable.argmin(dim, axis, keep_attrs, skipna)\n5716         if isinstance(result, dict):\n5717             return {k: self._replace_maybe_drop_dims(v) for k, v in result.items()}\n5718         else:\n5719             return self._replace_maybe_drop_dims(result)\n5720 \n5721     # change type of self and return to T_DataArray once\n5722     # https://github.com/python/mypy/issues/12846 is resolved\n5723     def argmax(\n5724         self,\n5725         dim: Dims = None,\n5726         axis: int | None = None,\n5727         keep_attrs: bool | None = None,\n5728         skipna: bool | None = None,\n5729     ) -> DataArray | dict[Hashable, DataArray]:\n5730         \"\"\"Index or indices of the maximum of the DataArray over one or more dimensions.\n5731 \n5732         If a sequence is passed to 'dim', then result returned as dict of DataArrays,\n5733         which can be passed directly to isel(). If a single str is passed to 'dim' then\n5734         returns a DataArray with dtype int.\n5735 \n5736         If there are multiple maxima, the indices of the first one found will be\n5737         returned.\n5738 \n5739         Parameters\n5740         ----------\n5741         dim : \"...\", str, Iterable of Hashable or None, optional\n5742             The dimensions over which to find the maximum. By default, finds maximum over\n5743             all dimensions - for now returning an int for backward compatibility, but\n5744             this is deprecated, in future will return a dict with indices for all\n5745             dimensions; to return a dict with all dimensions now, pass '...'.\n5746         axis : int or None, optional\n5747             Axis over which to apply `argmax`. Only one of the 'dim' and 'axis' arguments\n5748             can be supplied.\n5749         keep_attrs : bool or None, optional\n5750             If True, the attributes (`attrs`) will be copied from the original\n5751             object to the new one. If False, the new object will be\n5752             returned without attributes.\n5753         skipna : bool or None, optional\n5754             If True, skip missing values (as marked by NaN). By default, only\n5755             skips missing values for float dtypes; other dtypes either do not\n5756             have a sentinel missing value (int) or skipna=True has not been\n5757             implemented (object, datetime64 or timedelta64).\n5758 \n5759         Returns\n5760         -------\n5761         result : DataArray or dict of DataArray\n5762 \n5763         See Also\n5764         --------\n5765         Variable.argmax, DataArray.idxmax\n5766 \n5767         Examples\n5768         --------\n5769         >>> array = xr.DataArray([0, 2, -1, 3], dims=\"x\")\n5770         >>> array.max()\n5771         <xarray.DataArray ()>\n5772         array(3)\n5773         >>> array.argmax(...)\n5774         {'x': <xarray.DataArray ()>\n5775         array(3)}\n5776         >>> array.isel(array.argmax(...))\n5777         <xarray.DataArray ()>\n5778         array(3)\n5779 \n5780         >>> array = xr.DataArray(\n5781         ...     [[[3, 2, 1], [3, 1, 2], [2, 1, 3]], [[1, 3, 2], [2, 5, 1], [2, 3, 1]]],\n5782         ...     dims=(\"x\", \"y\", \"z\"),\n5783         ... )\n5784         >>> array.max(dim=\"x\")\n5785         <xarray.DataArray (y: 3, z: 3)>\n5786         array([[3, 3, 2],\n5787                [3, 5, 2],\n5788                [2, 3, 3]])\n5789         Dimensions without coordinates: y, z\n5790         >>> array.argmax(dim=\"x\")\n5791         <xarray.DataArray (y: 3, z: 3)>\n5792         array([[0, 1, 1],\n5793                [0, 1, 0],\n5794                [0, 1, 0]])\n5795         Dimensions without coordinates: y, z\n5796         >>> array.argmax(dim=[\"x\"])\n5797         {'x': <xarray.DataArray (y: 3, z: 3)>\n5798         array([[0, 1, 1],\n5799                [0, 1, 0],\n5800                [0, 1, 0]])\n5801         Dimensions without coordinates: y, z}\n5802         >>> array.max(dim=(\"x\", \"z\"))\n5803         <xarray.DataArray (y: 3)>\n5804         array([3, 5, 3])\n5805         Dimensions without coordinates: y\n5806         >>> array.argmax(dim=[\"x\", \"z\"])\n5807         {'x': <xarray.DataArray (y: 3)>\n5808         array([0, 1, 0])\n5809         Dimensions without coordinates: y, 'z': <xarray.DataArray (y: 3)>\n5810         array([0, 1, 2])\n5811         Dimensions without coordinates: y}\n5812         >>> array.isel(array.argmax(dim=[\"x\", \"z\"]))\n5813         <xarray.DataArray (y: 3)>\n5814         array([3, 5, 3])\n5815         Dimensions without coordinates: y\n5816         \"\"\"\n5817         result = self.variable.argmax(dim, axis, keep_attrs, skipna)\n5818         if isinstance(result, dict):\n5819             return {k: self._replace_maybe_drop_dims(v) for k, v in result.items()}\n5820         else:\n5821             return self._replace_maybe_drop_dims(result)\n5822 \n5823     def query(\n5824         self,\n5825         queries: Mapping[Any, Any] | None = None,\n5826         parser: QueryParserOptions = \"pandas\",\n5827         engine: QueryEngineOptions = None,\n5828         missing_dims: ErrorOptionsWithWarn = \"raise\",\n5829         **queries_kwargs: Any,\n5830     ) -> DataArray:\n5831         \"\"\"Return a new data array indexed along the specified\n5832         dimension(s), where the indexers are given as strings containing\n5833         Python expressions to be evaluated against the values in the array.\n5834 \n5835         Parameters\n5836         ----------\n5837         queries : dict-like or None, optional\n5838             A dict-like with keys matching dimensions and values given by strings\n5839             containing Python expressions to be evaluated against the data variables\n5840             in the dataset. The expressions will be evaluated using the pandas\n5841             eval() function, and can contain any valid Python expressions but cannot\n5842             contain any Python statements.\n5843         parser : {\"pandas\", \"python\"}, default: \"pandas\"\n5844             The parser to use to construct the syntax tree from the expression.\n5845             The default of 'pandas' parses code slightly different than standard\n5846             Python. Alternatively, you can parse an expression using the 'python'\n5847             parser to retain strict Python semantics.\n5848         engine : {\"python\", \"numexpr\", None}, default: None\n5849             The engine used to evaluate the expression. Supported engines are:\n5850 \n5851             - None: tries to use numexpr, falls back to python\n5852             - \"numexpr\": evaluates expressions using numexpr\n5853             - \"python\": performs operations as if you had eval\u2019d in top level python\n5854 \n5855         missing_dims : {\"raise\", \"warn\", \"ignore\"}, default: \"raise\"\n5856             What to do if dimensions that should be selected from are not present in the\n5857             DataArray:\n5858 \n5859             - \"raise\": raise an exception\n5860             - \"warn\": raise a warning, and ignore the missing dimensions\n5861             - \"ignore\": ignore the missing dimensions\n5862 \n5863         **queries_kwargs : {dim: query, ...}, optional\n5864             The keyword arguments form of ``queries``.\n5865             One of queries or queries_kwargs must be provided.\n5866 \n5867         Returns\n5868         -------\n5869         obj : DataArray\n5870             A new DataArray with the same contents as this dataset, indexed by\n5871             the results of the appropriate queries.\n5872 \n5873         See Also\n5874         --------\n5875         DataArray.isel\n5876         Dataset.query\n5877         pandas.eval\n5878 \n5879         Examples\n5880         --------\n5881         >>> da = xr.DataArray(np.arange(0, 5, 1), dims=\"x\", name=\"a\")\n5882         >>> da\n5883         <xarray.DataArray 'a' (x: 5)>\n5884         array([0, 1, 2, 3, 4])\n5885         Dimensions without coordinates: x\n5886         >>> da.query(x=\"a > 2\")\n5887         <xarray.DataArray 'a' (x: 2)>\n5888         array([3, 4])\n5889         Dimensions without coordinates: x\n5890         \"\"\"\n5891 \n5892         ds = self._to_dataset_whole(shallow_copy=True)\n5893         ds = ds.query(\n5894             queries=queries,\n5895             parser=parser,\n5896             engine=engine,\n5897             missing_dims=missing_dims,\n5898             **queries_kwargs,\n5899         )\n5900         return ds[self.name]\n5901 \n5902     def curvefit(\n5903         self,\n5904         coords: str | DataArray | Iterable[str | DataArray],\n5905         func: Callable[..., Any],\n5906         reduce_dims: Dims = None,\n5907         skipna: bool = True,\n5908         p0: dict[str, Any] | None = None,\n5909         bounds: dict[str, Any] | None = None,\n5910         param_names: Sequence[str] | None = None,\n5911         kwargs: dict[str, Any] | None = None,\n5912     ) -> Dataset:\n5913         \"\"\"\n5914         Curve fitting optimization for arbitrary functions.\n5915 \n5916         Wraps `scipy.optimize.curve_fit` with `apply_ufunc`.\n5917 \n5918         Parameters\n5919         ----------\n5920         coords : Hashable, DataArray, or sequence of DataArray or Hashable\n5921             Independent coordinate(s) over which to perform the curve fitting. Must share\n5922             at least one dimension with the calling object. When fitting multi-dimensional\n5923             functions, supply `coords` as a sequence in the same order as arguments in\n5924             `func`. To fit along existing dimensions of the calling object, `coords` can\n5925             also be specified as a str or sequence of strs.\n5926         func : callable\n5927             User specified function in the form `f(x, *params)` which returns a numpy\n5928             array of length `len(x)`. `params` are the fittable parameters which are optimized\n5929             by scipy curve_fit. `x` can also be specified as a sequence containing multiple\n5930             coordinates, e.g. `f((x0, x1), *params)`.\n5931         reduce_dims : str, Iterable of Hashable or None, optional\n5932             Additional dimension(s) over which to aggregate while fitting. For example,\n5933             calling `ds.curvefit(coords='time', reduce_dims=['lat', 'lon'], ...)` will\n5934             aggregate all lat and lon points and fit the specified function along the\n5935             time dimension.\n5936         skipna : bool, default: True\n5937             Whether to skip missing values when fitting. Default is True.\n5938         p0 : dict-like or None, optional\n5939             Optional dictionary of parameter names to initial guesses passed to the\n5940             `curve_fit` `p0` arg. If none or only some parameters are passed, the rest will\n5941             be assigned initial values following the default scipy behavior.\n5942         bounds : dict-like or None, optional\n5943             Optional dictionary of parameter names to bounding values passed to the\n5944             `curve_fit` `bounds` arg. If none or only some parameters are passed, the rest\n5945             will be unbounded following the default scipy behavior.\n5946         param_names : sequence of Hashable or None, optional\n5947             Sequence of names for the fittable parameters of `func`. If not supplied,\n5948             this will be automatically determined by arguments of `func`. `param_names`\n5949             should be manually supplied when fitting a function that takes a variable\n5950             number of parameters.\n5951         **kwargs : optional\n5952             Additional keyword arguments to passed to scipy curve_fit.\n5953 \n5954         Returns\n5955         -------\n5956         curvefit_results : Dataset\n5957             A single dataset which contains:\n5958 \n5959             [var]_curvefit_coefficients\n5960                 The coefficients of the best fit.\n5961             [var]_curvefit_covariance\n5962                 The covariance matrix of the coefficient estimates.\n5963 \n5964         See Also\n5965         --------\n5966         DataArray.polyfit\n5967         scipy.optimize.curve_fit\n5968         \"\"\"\n5969         return self._to_temp_dataset().curvefit(\n5970             coords,\n5971             func,\n5972             reduce_dims=reduce_dims,\n5973             skipna=skipna,\n5974             p0=p0,\n5975             bounds=bounds,\n5976             param_names=param_names,\n5977             kwargs=kwargs,\n5978         )\n5979 \n5980     def drop_duplicates(\n5981         self: T_DataArray,\n5982         dim: Hashable | Iterable[Hashable],\n5983         keep: Literal[\"first\", \"last\", False] = \"first\",\n5984     ) -> T_DataArray:\n5985         \"\"\"Returns a new DataArray with duplicate dimension values removed.\n5986 \n5987         Parameters\n5988         ----------\n5989         dim : dimension label or labels\n5990             Pass `...` to drop duplicates along all dimensions.\n5991         keep : {\"first\", \"last\", False}, default: \"first\"\n5992             Determines which duplicates (if any) to keep.\n5993 \n5994             - ``\"first\"`` : Drop duplicates except for the first occurrence.\n5995             - ``\"last\"`` : Drop duplicates except for the last occurrence.\n5996             - False : Drop all duplicates.\n5997 \n5998         Returns\n5999         -------\n6000         DataArray\n6001 \n6002         See Also\n6003         --------\n6004         Dataset.drop_duplicates\n6005 \n6006         Examples\n6007         --------\n6008         >>> da = xr.DataArray(\n6009         ...     np.arange(25).reshape(5, 5),\n6010         ...     dims=(\"x\", \"y\"),\n6011         ...     coords={\"x\": np.array([0, 0, 1, 2, 3]), \"y\": np.array([0, 1, 2, 3, 3])},\n6012         ... )\n6013         >>> da\n6014         <xarray.DataArray (x: 5, y: 5)>\n6015         array([[ 0,  1,  2,  3,  4],\n6016                [ 5,  6,  7,  8,  9],\n6017                [10, 11, 12, 13, 14],\n6018                [15, 16, 17, 18, 19],\n6019                [20, 21, 22, 23, 24]])\n6020         Coordinates:\n6021           * x        (x) int64 0 0 1 2 3\n6022           * y        (y) int64 0 1 2 3 3\n6023 \n6024         >>> da.drop_duplicates(dim=\"x\")\n6025         <xarray.DataArray (x: 4, y: 5)>\n6026         array([[ 0,  1,  2,  3,  4],\n6027                [10, 11, 12, 13, 14],\n6028                [15, 16, 17, 18, 19],\n6029                [20, 21, 22, 23, 24]])\n6030         Coordinates:\n6031           * x        (x) int64 0 1 2 3\n6032           * y        (y) int64 0 1 2 3 3\n6033 \n6034         >>> da.drop_duplicates(dim=\"x\", keep=\"last\")\n6035         <xarray.DataArray (x: 4, y: 5)>\n6036         array([[ 5,  6,  7,  8,  9],\n6037                [10, 11, 12, 13, 14],\n6038                [15, 16, 17, 18, 19],\n6039                [20, 21, 22, 23, 24]])\n6040         Coordinates:\n6041           * x        (x) int64 0 1 2 3\n6042           * y        (y) int64 0 1 2 3 3\n6043 \n6044         Drop all duplicate dimension values:\n6045 \n6046         >>> da.drop_duplicates(dim=...)\n6047         <xarray.DataArray (x: 4, y: 4)>\n6048         array([[ 0,  1,  2,  3],\n6049                [10, 11, 12, 13],\n6050                [15, 16, 17, 18],\n6051                [20, 21, 22, 23]])\n6052         Coordinates:\n6053           * x        (x) int64 0 1 2 3\n6054           * y        (y) int64 0 1 2 3\n6055         \"\"\"\n6056         deduplicated = self._to_temp_dataset().drop_duplicates(dim, keep=keep)\n6057         return self._from_temp_dataset(deduplicated)\n6058 \n6059     def convert_calendar(\n6060         self,\n6061         calendar: str,\n6062         dim: str = \"time\",\n6063         align_on: str | None = None,\n6064         missing: Any | None = None,\n6065         use_cftime: bool | None = None,\n6066     ) -> DataArray:\n6067         \"\"\"Convert the DataArray to another calendar.\n6068 \n6069         Only converts the individual timestamps, does not modify any data except\n6070         in dropping invalid/surplus dates or inserting missing dates.\n6071 \n6072         If the source and target calendars are either no_leap, all_leap or a\n6073         standard type, only the type of the time array is modified.\n6074         When converting to a leap year from a non-leap year, the 29th of February\n6075         is removed from the array. In the other direction the 29th of February\n6076         will be missing in the output, unless `missing` is specified,\n6077         in which case that value is inserted.\n6078 \n6079         For conversions involving `360_day` calendars, see Notes.\n6080 \n6081         This method is safe to use with sub-daily data as it doesn't touch the\n6082         time part of the timestamps.\n6083 \n6084         Parameters\n6085         ---------\n6086         calendar : str\n6087             The target calendar name.\n6088         dim : str\n6089             Name of the time coordinate.\n6090         align_on : {None, 'date', 'year'}\n6091             Must be specified when either source or target is a `360_day` calendar,\n6092            ignored otherwise. See Notes.\n6093         missing : Optional[any]\n6094             By default, i.e. if the value is None, this method will simply attempt\n6095             to convert the dates in the source calendar to the same dates in the\n6096             target calendar, and drop any of those that are not possible to\n6097             represent.  If a value is provided, a new time coordinate will be\n6098             created in the target calendar with the same frequency as the original\n6099             time coordinate; for any dates that are not present in the source, the\n6100             data will be filled with this value.  Note that using this mode requires\n6101             that the source data have an inferable frequency; for more information\n6102             see :py:func:`xarray.infer_freq`.  For certain frequency, source, and\n6103             target calendar combinations, this could result in many missing values, see notes.\n6104         use_cftime : boolean, optional\n6105             Whether to use cftime objects in the output, only used if `calendar`\n6106             is one of {\"proleptic_gregorian\", \"gregorian\" or \"standard\"}.\n6107             If True, the new time axis uses cftime objects.\n6108             If None (default), it uses :py:class:`numpy.datetime64` values if the\n6109             date range permits it, and :py:class:`cftime.datetime` objects if not.\n6110             If False, it uses :py:class:`numpy.datetime64`  or fails.\n6111 \n6112         Returns\n6113         -------\n6114         DataArray\n6115             Copy of the dataarray with the time coordinate converted to the\n6116             target calendar. If 'missing' was None (default), invalid dates in\n6117             the new calendar are dropped, but missing dates are not inserted.\n6118             If `missing` was given, the new data is reindexed to have a time axis\n6119             with the same frequency as the source, but in the new calendar; any\n6120             missing datapoints are filled with `missing`.\n6121 \n6122         Notes\n6123         -----\n6124         Passing a value to `missing` is only usable if the source's time coordinate as an\n6125         inferable frequencies (see :py:func:`~xarray.infer_freq`) and is only appropriate\n6126         if the target coordinate, generated from this frequency, has dates equivalent to the\n6127         source. It is usually **not** appropriate to use this mode with:\n6128 \n6129         - Period-end frequencies : 'A', 'Y', 'Q' or 'M', in opposition to 'AS' 'YS', 'QS' and 'MS'\n6130         - Sub-monthly frequencies that do not divide a day evenly : 'W', 'nD' where `N != 1`\n6131             or 'mH' where 24 % m != 0).\n6132 \n6133         If one of the source or target calendars is `\"360_day\"`, `align_on` must\n6134         be specified and two options are offered.\n6135 \n6136         - \"year\"\n6137             The dates are translated according to their relative position in the year,\n6138             ignoring their original month and day information, meaning that the\n6139             missing/surplus days are added/removed at regular intervals.\n6140 \n6141             From a `360_day` to a standard calendar, the output will be missing the\n6142             following dates (day of year in parentheses):\n6143 \n6144             To a leap year:\n6145                 January 31st (31), March 31st (91), June 1st (153), July 31st (213),\n6146                 September 31st (275) and November 30th (335).\n6147             To a non-leap year:\n6148                 February 6th (36), April 19th (109), July 2nd (183),\n6149                 September 12th (255), November 25th (329).\n6150 \n6151             From a standard calendar to a `\"360_day\"`, the following dates in the\n6152             source array will be dropped:\n6153 \n6154             From a leap year:\n6155                 January 31st (31), April 1st (92), June 1st (153), August 1st (214),\n6156                 September 31st (275), December 1st (336)\n6157             From a non-leap year:\n6158                 February 6th (37), April 20th (110), July 2nd (183),\n6159                 September 13th (256), November 25th (329)\n6160 \n6161             This option is best used on daily and subdaily data.\n6162 \n6163         - \"date\"\n6164             The month/day information is conserved and invalid dates are dropped\n6165             from the output. This means that when converting from a `\"360_day\"` to a\n6166             standard calendar, all 31st (Jan, March, May, July, August, October and\n6167             December) will be missing as there is no equivalent dates in the\n6168             `\"360_day\"` calendar and the 29th (on non-leap years) and 30th of February\n6169             will be dropped as there are no equivalent dates in a standard calendar.\n6170 \n6171             This option is best used with data on a frequency coarser than daily.\n6172         \"\"\"\n6173         return convert_calendar(\n6174             self,\n6175             calendar,\n6176             dim=dim,\n6177             align_on=align_on,\n6178             missing=missing,\n6179             use_cftime=use_cftime,\n6180         )\n6181 \n6182     def interp_calendar(\n6183         self,\n6184         target: pd.DatetimeIndex | CFTimeIndex | DataArray,\n6185         dim: str = \"time\",\n6186     ) -> DataArray:\n6187         \"\"\"Interpolates the DataArray to another calendar based on decimal year measure.\n6188 \n6189         Each timestamp in `source` and `target` are first converted to their decimal\n6190         year equivalent then `source` is interpolated on the target coordinate.\n6191         The decimal year of a timestamp is its year plus its sub-year component\n6192         converted to the fraction of its year. For example \"2000-03-01 12:00\" is\n6193         2000.1653 in a standard calendar or 2000.16301 in a `\"noleap\"` calendar.\n6194 \n6195         This method should only be used when the time (HH:MM:SS) information of\n6196         time coordinate is not important.\n6197 \n6198         Parameters\n6199         ----------\n6200         target: DataArray or DatetimeIndex or CFTimeIndex\n6201             The target time coordinate of a valid dtype\n6202             (np.datetime64 or cftime objects)\n6203         dim : str\n6204             The time coordinate name.\n6205 \n6206         Return\n6207         ------\n6208         DataArray\n6209             The source interpolated on the decimal years of target,\n6210         \"\"\"\n6211         return interp_calendar(self, target, dim=dim)\n6212 \n6213     def groupby(\n6214         self,\n6215         group: Hashable | DataArray | IndexVariable,\n6216         squeeze: bool = True,\n6217         restore_coord_dims: bool = False,\n6218     ) -> DataArrayGroupBy:\n6219         \"\"\"Returns a DataArrayGroupBy object for performing grouped operations.\n6220 \n6221         Parameters\n6222         ----------\n6223         group : Hashable, DataArray or IndexVariable\n6224             Array whose unique values should be used to group this array. If a\n6225             Hashable, must be the name of a coordinate contained in this dataarray.\n6226         squeeze : bool, default: True\n6227             If \"group\" is a dimension of any arrays in this dataset, `squeeze`\n6228             controls whether the subarrays have a dimension of length 1 along\n6229             that dimension or if the dimension is squeezed out.\n6230         restore_coord_dims : bool, default: False\n6231             If True, also restore the dimension order of multi-dimensional\n6232             coordinates.\n6233 \n6234         Returns\n6235         -------\n6236         grouped : DataArrayGroupBy\n6237             A `DataArrayGroupBy` object patterned after `pandas.GroupBy` that can be\n6238             iterated over in the form of `(unique_value, grouped_array)` pairs.\n6239 \n6240         Examples\n6241         --------\n6242         Calculate daily anomalies for daily data:\n6243 \n6244         >>> da = xr.DataArray(\n6245         ...     np.linspace(0, 1826, num=1827),\n6246         ...     coords=[pd.date_range(\"2000-01-01\", \"2004-12-31\", freq=\"D\")],\n6247         ...     dims=\"time\",\n6248         ... )\n6249         >>> da\n6250         <xarray.DataArray (time: 1827)>\n6251         array([0.000e+00, 1.000e+00, 2.000e+00, ..., 1.824e+03, 1.825e+03,\n6252                1.826e+03])\n6253         Coordinates:\n6254           * time     (time) datetime64[ns] 2000-01-01 2000-01-02 ... 2004-12-31\n6255         >>> da.groupby(\"time.dayofyear\") - da.groupby(\"time.dayofyear\").mean(\"time\")\n6256         <xarray.DataArray (time: 1827)>\n6257         array([-730.8, -730.8, -730.8, ...,  730.2,  730.2,  730.5])\n6258         Coordinates:\n6259           * time       (time) datetime64[ns] 2000-01-01 2000-01-02 ... 2004-12-31\n6260             dayofyear  (time) int64 1 2 3 4 5 6 7 8 ... 359 360 361 362 363 364 365 366\n6261 \n6262         See Also\n6263         --------\n6264         DataArray.groupby_bins\n6265         Dataset.groupby\n6266         core.groupby.DataArrayGroupBy\n6267         pandas.DataFrame.groupby\n6268         \"\"\"\n6269         from xarray.core.groupby import DataArrayGroupBy\n6270 \n6271         # While we don't generally check the type of every arg, passing\n6272         # multiple dimensions as multiple arguments is common enough, and the\n6273         # consequences hidden enough (strings evaluate as true) to warrant\n6274         # checking here.\n6275         # A future version could make squeeze kwarg only, but would face\n6276         # backward-compat issues.\n6277         if not isinstance(squeeze, bool):\n6278             raise TypeError(\n6279                 f\"`squeeze` must be True or False, but {squeeze} was supplied\"\n6280             )\n6281 \n6282         return DataArrayGroupBy(\n6283             self, group, squeeze=squeeze, restore_coord_dims=restore_coord_dims\n6284         )\n6285 \n6286     def groupby_bins(\n6287         self,\n6288         group: Hashable | DataArray | IndexVariable,\n6289         bins: ArrayLike,\n6290         right: bool = True,\n6291         labels: ArrayLike | Literal[False] | None = None,\n6292         precision: int = 3,\n6293         include_lowest: bool = False,\n6294         squeeze: bool = True,\n6295         restore_coord_dims: bool = False,\n6296     ) -> DataArrayGroupBy:\n6297         \"\"\"Returns a DataArrayGroupBy object for performing grouped operations.\n6298 \n6299         Rather than using all unique values of `group`, the values are discretized\n6300         first by applying `pandas.cut` [1]_ to `group`.\n6301 \n6302         Parameters\n6303         ----------\n6304         group : Hashable, DataArray or IndexVariable\n6305             Array whose binned values should be used to group this array. If a\n6306             Hashable, must be the name of a coordinate contained in this dataarray.\n6307         bins : int or array-like\n6308             If bins is an int, it defines the number of equal-width bins in the\n6309             range of x. However, in this case, the range of x is extended by .1%\n6310             on each side to include the min or max values of x. If bins is a\n6311             sequence it defines the bin edges allowing for non-uniform bin\n6312             width. No extension of the range of x is done in this case.\n6313         right : bool, default: True\n6314             Indicates whether the bins include the rightmost edge or not. If\n6315             right == True (the default), then the bins [1,2,3,4] indicate\n6316             (1,2], (2,3], (3,4].\n6317         labels : array-like, False or None, default: None\n6318             Used as labels for the resulting bins. Must be of the same length as\n6319             the resulting bins. If False, string bin labels are assigned by\n6320             `pandas.cut`.\n6321         precision : int, default: 3\n6322             The precision at which to store and display the bins labels.\n6323         include_lowest : bool, default: False\n6324             Whether the first interval should be left-inclusive or not.\n6325         squeeze : bool, default: True\n6326             If \"group\" is a dimension of any arrays in this dataset, `squeeze`\n6327             controls whether the subarrays have a dimension of length 1 along\n6328             that dimension or if the dimension is squeezed out.\n6329         restore_coord_dims : bool, default: False\n6330             If True, also restore the dimension order of multi-dimensional\n6331             coordinates.\n6332 \n6333         Returns\n6334         -------\n6335         grouped : DataArrayGroupBy\n6336             A `DataArrayGroupBy` object patterned after `pandas.GroupBy` that can be\n6337             iterated over in the form of `(unique_value, grouped_array)` pairs.\n6338             The name of the group has the added suffix `_bins` in order to\n6339             distinguish it from the original variable.\n6340 \n6341         See Also\n6342         --------\n6343         DataArray.groupby\n6344         Dataset.groupby_bins\n6345         core.groupby.DataArrayGroupBy\n6346         pandas.DataFrame.groupby\n6347 \n6348         References\n6349         ----------\n6350         .. [1] http://pandas.pydata.org/pandas-docs/stable/generated/pandas.cut.html\n6351         \"\"\"\n6352         from xarray.core.groupby import DataArrayGroupBy\n6353 \n6354         return DataArrayGroupBy(\n6355             self,\n6356             group,\n6357             squeeze=squeeze,\n6358             bins=bins,\n6359             restore_coord_dims=restore_coord_dims,\n6360             cut_kwargs={\n6361                 \"right\": right,\n6362                 \"labels\": labels,\n6363                 \"precision\": precision,\n6364                 \"include_lowest\": include_lowest,\n6365             },\n6366         )\n6367 \n6368     def weighted(self, weights: DataArray) -> DataArrayWeighted:\n6369         \"\"\"\n6370         Weighted DataArray operations.\n6371 \n6372         Parameters\n6373         ----------\n6374         weights : DataArray\n6375             An array of weights associated with the values in this Dataset.\n6376             Each value in the data contributes to the reduction operation\n6377             according to its associated weight.\n6378 \n6379         Notes\n6380         -----\n6381         ``weights`` must be a DataArray and cannot contain missing values.\n6382         Missing values can be replaced by ``weights.fillna(0)``.\n6383 \n6384         Returns\n6385         -------\n6386         core.weighted.DataArrayWeighted\n6387 \n6388         See Also\n6389         --------\n6390         Dataset.weighted\n6391         \"\"\"\n6392         from xarray.core.weighted import DataArrayWeighted\n6393 \n6394         return DataArrayWeighted(self, weights)\n6395 \n6396     def rolling(\n6397         self,\n6398         dim: Mapping[Any, int] | None = None,\n6399         min_periods: int | None = None,\n6400         center: bool | Mapping[Any, bool] = False,\n6401         **window_kwargs: int,\n6402     ) -> DataArrayRolling:\n6403         \"\"\"\n6404         Rolling window object for DataArrays.\n6405 \n6406         Parameters\n6407         ----------\n6408         dim : dict, optional\n6409             Mapping from the dimension name to create the rolling iterator\n6410             along (e.g. `time`) to its moving window size.\n6411         min_periods : int or None, default: None\n6412             Minimum number of observations in window required to have a value\n6413             (otherwise result is NA). The default, None, is equivalent to\n6414             setting min_periods equal to the size of the window.\n6415         center : bool or Mapping to int, default: False\n6416             Set the labels at the center of the window.\n6417         **window_kwargs : optional\n6418             The keyword arguments form of ``dim``.\n6419             One of dim or window_kwargs must be provided.\n6420 \n6421         Returns\n6422         -------\n6423         core.rolling.DataArrayRolling\n6424 \n6425         Examples\n6426         --------\n6427         Create rolling seasonal average of monthly data e.g. DJF, JFM, ..., SON:\n6428 \n6429         >>> da = xr.DataArray(\n6430         ...     np.linspace(0, 11, num=12),\n6431         ...     coords=[\n6432         ...         pd.date_range(\n6433         ...             \"1999-12-15\",\n6434         ...             periods=12,\n6435         ...             freq=pd.DateOffset(months=1),\n6436         ...         )\n6437         ...     ],\n6438         ...     dims=\"time\",\n6439         ... )\n6440         >>> da\n6441         <xarray.DataArray (time: 12)>\n6442         array([ 0.,  1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  9., 10., 11.])\n6443         Coordinates:\n6444           * time     (time) datetime64[ns] 1999-12-15 2000-01-15 ... 2000-11-15\n6445         >>> da.rolling(time=3, center=True).mean()\n6446         <xarray.DataArray (time: 12)>\n6447         array([nan,  1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  9., 10., nan])\n6448         Coordinates:\n6449           * time     (time) datetime64[ns] 1999-12-15 2000-01-15 ... 2000-11-15\n6450 \n6451         Remove the NaNs using ``dropna()``:\n6452 \n6453         >>> da.rolling(time=3, center=True).mean().dropna(\"time\")\n6454         <xarray.DataArray (time: 10)>\n6455         array([ 1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  9., 10.])\n6456         Coordinates:\n6457           * time     (time) datetime64[ns] 2000-01-15 2000-02-15 ... 2000-10-15\n6458 \n6459         See Also\n6460         --------\n6461         core.rolling.DataArrayRolling\n6462         Dataset.rolling\n6463         \"\"\"\n6464         from xarray.core.rolling import DataArrayRolling\n6465 \n6466         dim = either_dict_or_kwargs(dim, window_kwargs, \"rolling\")\n6467         return DataArrayRolling(self, dim, min_periods=min_periods, center=center)\n6468 \n6469     def coarsen(\n6470         self,\n6471         dim: Mapping[Any, int] | None = None,\n6472         boundary: CoarsenBoundaryOptions = \"exact\",\n6473         side: SideOptions | Mapping[Any, SideOptions] = \"left\",\n6474         coord_func: str | Callable | Mapping[Any, str | Callable] = \"mean\",\n6475         **window_kwargs: int,\n6476     ) -> DataArrayCoarsen:\n6477         \"\"\"\n6478         Coarsen object for DataArrays.\n6479 \n6480         Parameters\n6481         ----------\n6482         dim : mapping of hashable to int, optional\n6483             Mapping from the dimension name to the window size.\n6484         boundary : {\"exact\", \"trim\", \"pad\"}, default: \"exact\"\n6485             If 'exact', a ValueError will be raised if dimension size is not a\n6486             multiple of the window size. If 'trim', the excess entries are\n6487             dropped. If 'pad', NA will be padded.\n6488         side : {\"left\", \"right\"} or mapping of str to {\"left\", \"right\"}, default: \"left\"\n6489         coord_func : str or mapping of hashable to str, default: \"mean\"\n6490             function (name) that is applied to the coordinates,\n6491             or a mapping from coordinate name to function (name).\n6492 \n6493         Returns\n6494         -------\n6495         core.rolling.DataArrayCoarsen\n6496 \n6497         Examples\n6498         --------\n6499         Coarsen the long time series by averaging over every four days.\n6500 \n6501         >>> da = xr.DataArray(\n6502         ...     np.linspace(0, 364, num=364),\n6503         ...     dims=\"time\",\n6504         ...     coords={\"time\": pd.date_range(\"1999-12-15\", periods=364)},\n6505         ... )\n6506         >>> da  # +doctest: ELLIPSIS\n6507         <xarray.DataArray (time: 364)>\n6508         array([  0.        ,   1.00275482,   2.00550964,   3.00826446,\n6509                  4.01101928,   5.0137741 ,   6.01652893,   7.01928375,\n6510                  8.02203857,   9.02479339,  10.02754821,  11.03030303,\n6511         ...\n6512                356.98071625, 357.98347107, 358.9862259 , 359.98898072,\n6513                360.99173554, 361.99449036, 362.99724518, 364.        ])\n6514         Coordinates:\n6515           * time     (time) datetime64[ns] 1999-12-15 1999-12-16 ... 2000-12-12\n6516         >>> da.coarsen(time=3, boundary=\"trim\").mean()  # +doctest: ELLIPSIS\n6517         <xarray.DataArray (time: 121)>\n6518         array([  1.00275482,   4.01101928,   7.01928375,  10.02754821,\n6519                 13.03581267,  16.04407713,  19.0523416 ,  22.06060606,\n6520                 25.06887052,  28.07713499,  31.08539945,  34.09366391,\n6521         ...\n6522                349.96143251, 352.96969697, 355.97796143, 358.9862259 ,\n6523                361.99449036])\n6524         Coordinates:\n6525           * time     (time) datetime64[ns] 1999-12-16 1999-12-19 ... 2000-12-10\n6526         >>>\n6527 \n6528         See Also\n6529         --------\n6530         core.rolling.DataArrayCoarsen\n6531         Dataset.coarsen\n6532         \"\"\"\n6533         from xarray.core.rolling import DataArrayCoarsen\n6534 \n6535         dim = either_dict_or_kwargs(dim, window_kwargs, \"coarsen\")\n6536         return DataArrayCoarsen(\n6537             self,\n6538             dim,\n6539             boundary=boundary,\n6540             side=side,\n6541             coord_func=coord_func,\n6542         )\n6543 \n6544     def resample(\n6545         self,\n6546         indexer: Mapping[Any, str] | None = None,\n6547         skipna: bool | None = None,\n6548         closed: SideOptions | None = None,\n6549         label: SideOptions | None = None,\n6550         base: int | None = None,\n6551         offset: pd.Timedelta | datetime.timedelta | str | None = None,\n6552         origin: str | DatetimeLike = \"start_day\",\n6553         keep_attrs: bool | None = None,\n6554         loffset: datetime.timedelta | str | None = None,\n6555         restore_coord_dims: bool | None = None,\n6556         **indexer_kwargs: str,\n6557     ) -> DataArrayResample:\n6558         \"\"\"Returns a Resample object for performing resampling operations.\n6559 \n6560         Handles both downsampling and upsampling. The resampled\n6561         dimension must be a datetime-like coordinate. If any intervals\n6562         contain no values from the original object, they will be given\n6563         the value ``NaN``.\n6564 \n6565         Parameters\n6566         ----------\n6567         indexer : Mapping of Hashable to str, optional\n6568             Mapping from the dimension name to resample frequency [1]_. The\n6569             dimension must be datetime-like.\n6570         skipna : bool, optional\n6571             Whether to skip missing values when aggregating in downsampling.\n6572         closed : {\"left\", \"right\"}, optional\n6573             Side of each interval to treat as closed.\n6574         label : {\"left\", \"right\"}, optional\n6575             Side of each interval to use for labeling.\n6576         base : int, optional\n6577             For frequencies that evenly subdivide 1 day, the \"origin\" of the\n6578             aggregated intervals. For example, for \"24H\" frequency, base could\n6579             range from 0 through 23.\n6580         origin : {'epoch', 'start', 'start_day', 'end', 'end_day'}, pd.Timestamp, datetime.datetime, np.datetime64, or cftime.datetime, default 'start_day'\n6581             The datetime on which to adjust the grouping. The timezone of origin\n6582             must match the timezone of the index.\n6583 \n6584             If a datetime is not used, these values are also supported:\n6585             - 'epoch': `origin` is 1970-01-01\n6586             - 'start': `origin` is the first value of the timeseries\n6587             - 'start_day': `origin` is the first day at midnight of the timeseries\n6588             - 'end': `origin` is the last value of the timeseries\n6589             - 'end_day': `origin` is the ceiling midnight of the last day\n6590         offset : pd.Timedelta, datetime.timedelta, or str, default is None\n6591             An offset timedelta added to the origin.\n6592         loffset : timedelta or str, optional\n6593             Offset used to adjust the resampled time labels. Some pandas date\n6594             offset strings are supported.\n6595         restore_coord_dims : bool, optional\n6596             If True, also restore the dimension order of multi-dimensional\n6597             coordinates.\n6598         **indexer_kwargs : str\n6599             The keyword arguments form of ``indexer``.\n6600             One of indexer or indexer_kwargs must be provided.\n6601 \n6602         Returns\n6603         -------\n6604         resampled : core.resample.DataArrayResample\n6605             This object resampled.\n6606 \n6607         Examples\n6608         --------\n6609         Downsample monthly time-series data to seasonal data:\n6610 \n6611         >>> da = xr.DataArray(\n6612         ...     np.linspace(0, 11, num=12),\n6613         ...     coords=[\n6614         ...         pd.date_range(\n6615         ...             \"1999-12-15\",\n6616         ...             periods=12,\n6617         ...             freq=pd.DateOffset(months=1),\n6618         ...         )\n6619         ...     ],\n6620         ...     dims=\"time\",\n6621         ... )\n6622         >>> da\n6623         <xarray.DataArray (time: 12)>\n6624         array([ 0.,  1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  9., 10., 11.])\n6625         Coordinates:\n6626           * time     (time) datetime64[ns] 1999-12-15 2000-01-15 ... 2000-11-15\n6627         >>> da.resample(time=\"QS-DEC\").mean()\n6628         <xarray.DataArray (time: 4)>\n6629         array([ 1.,  4.,  7., 10.])\n6630         Coordinates:\n6631           * time     (time) datetime64[ns] 1999-12-01 2000-03-01 2000-06-01 2000-09-01\n6632 \n6633         Upsample monthly time-series data to daily data:\n6634 \n6635         >>> da.resample(time=\"1D\").interpolate(\"linear\")  # +doctest: ELLIPSIS\n6636         <xarray.DataArray (time: 337)>\n6637         array([ 0.        ,  0.03225806,  0.06451613,  0.09677419,  0.12903226,\n6638                 0.16129032,  0.19354839,  0.22580645,  0.25806452,  0.29032258,\n6639                 0.32258065,  0.35483871,  0.38709677,  0.41935484,  0.4516129 ,\n6640         ...\n6641                10.80645161, 10.83870968, 10.87096774, 10.90322581, 10.93548387,\n6642                10.96774194, 11.        ])\n6643         Coordinates:\n6644           * time     (time) datetime64[ns] 1999-12-15 1999-12-16 ... 2000-11-15\n6645 \n6646         Limit scope of upsampling method\n6647 \n6648         >>> da.resample(time=\"1D\").nearest(tolerance=\"1D\")\n6649         <xarray.DataArray (time: 337)>\n6650         array([ 0.,  0., nan, ..., nan, 11., 11.])\n6651         Coordinates:\n6652           * time     (time) datetime64[ns] 1999-12-15 1999-12-16 ... 2000-11-15\n6653 \n6654         See Also\n6655         --------\n6656         Dataset.resample\n6657         pandas.Series.resample\n6658         pandas.DataFrame.resample\n6659 \n6660         References\n6661         ----------\n6662         .. [1] http://pandas.pydata.org/pandas-docs/stable/timeseries.html#offset-aliases\n6663         \"\"\"\n6664         from xarray.core.resample import DataArrayResample\n6665 \n6666         return self._resample(\n6667             resample_cls=DataArrayResample,\n6668             indexer=indexer,\n6669             skipna=skipna,\n6670             closed=closed,\n6671             label=label,\n6672             base=base,\n6673             offset=offset,\n6674             origin=origin,\n6675             keep_attrs=keep_attrs,\n6676             loffset=loffset,\n6677             restore_coord_dims=restore_coord_dims,\n6678             **indexer_kwargs,\n6679         )\n6680 \n6681     # this needs to be at the end, or mypy will confuse with `str`\n6682     # https://mypy.readthedocs.io/en/latest/common_issues.html#dealing-with-conflicting-names\n6683     str = utils.UncachedAccessor(StringAccessor[\"DataArray\"])\n",
        "intended_behavior": "This class provides additional context to the issue."
    }
]