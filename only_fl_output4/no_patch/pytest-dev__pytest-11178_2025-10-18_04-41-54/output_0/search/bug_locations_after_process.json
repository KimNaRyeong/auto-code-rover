[
    {
        "rel_file_path": "src/_pytest/python_api.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/pytest-dev__pytest/setup_pytest-dev__pytest__8.0/src/_pytest/python_api.py",
        "start": 426,
        "end": 465,
        "class_name": "ApproxScalar",
        "method_name": "__eq__",
        "code": "426     def __eq__(self, actual) -> bool:\n427         \"\"\"Return whether the given value is equal to the expected value\n428         within the pre-specified tolerance.\"\"\"\n429         asarray = _as_numpy_array(actual)\n430         if asarray is not None:\n431             # Call ``__eq__()`` manually to prevent infinite-recursion with\n432             # numpy<1.13.  See #3748.\n433             return all(self.__eq__(a) for a in asarray.flat)\n434 \n435         # Short-circuit exact equality.\n436         if actual == self.expected:\n437             return True\n438 \n439         # If either type is non-numeric, fall back to strict equality.\n440         # NB: we need Complex, rather than just Number, to ensure that __abs__,\n441         # __sub__, and __float__ are defined.\n442         if not (\n443             isinstance(self.expected, (Complex, Decimal))\n444             and isinstance(actual, (Complex, Decimal))\n445         ):\n446             return False\n447 \n448         # Allow the user to control whether NaNs are considered equal to each\n449         # other or not.  The abs() calls are for compatibility with complex\n450         # numbers.\n451         if math.isnan(abs(self.expected)):  # type: ignore[arg-type]\n452             return self.nan_ok and math.isnan(abs(actual))  # type: ignore[arg-type]\n453 \n454         # Infinity shouldn't be approximately equal to anything but itself, but\n455         # if there's a relative tolerance, it will be infinite and infinity\n456         # will seem approximately equal to everything.  The equal-to-itself\n457         # case would have been short circuited above, so here we can just\n458         # return false if the expected value is infinite.  The abs() call is\n459         # for compatibility with complex numbers.\n460         if math.isinf(abs(self.expected)):  # type: ignore[arg-type]\n461             return False\n462 \n463         # Return true if the two numbers are within the tolerance.\n464         result: bool = abs(self.expected - actual) <= self.tolerance\n465         return result\n",
        "intended_behavior": "The method `__eq__` should include an explicit check for `None` at the beginning. If `actual` or the object being compared (`self.expected`) is `None`, the method should return `False` directly or raise a more descriptive error indicating that `None` values cannot be compared using `approx`. This change ensures that users are not met with a `TypeError` due to unsupported arithmetic operations involving `None`, but instead receive clear feedback on the nature of the error."
    },
    {
        "rel_file_path": "src/_pytest/python_api.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/pytest-dev__pytest/setup_pytest-dev__pytest__8.0/src/_pytest/python_api.py",
        "start": 389,
        "end": 515,
        "class_name": "ApproxScalar",
        "method_name": null,
        "code": "389 class ApproxScalar(ApproxBase):\n390     \"\"\"Perform approximate comparisons where the expected value is a single number.\"\"\"\n391 \n392     # Using Real should be better than this Union, but not possible yet:\n393     # https://github.com/python/typeshed/pull/3108\n394     DEFAULT_ABSOLUTE_TOLERANCE: Union[float, Decimal] = 1e-12\n395     DEFAULT_RELATIVE_TOLERANCE: Union[float, Decimal] = 1e-6\n396 \n397     def __repr__(self) -> str:\n398         \"\"\"Return a string communicating both the expected value and the\n399         tolerance for the comparison being made.\n400 \n401         For example, ``1.0 \u00b1 1e-6``, ``(3+4j) \u00b1 5e-6 \u2220 \u00b1180\u00b0``.\n402         \"\"\"\n403         # Don't show a tolerance for values that aren't compared using\n404         # tolerances, i.e. non-numerics and infinities. Need to call abs to\n405         # handle complex numbers, e.g. (inf + 1j).\n406         if (not isinstance(self.expected, (Complex, Decimal))) or math.isinf(\n407             abs(self.expected)  # type: ignore[arg-type]\n408         ):\n409             return str(self.expected)\n410 \n411         # If a sensible tolerance can't be calculated, self.tolerance will\n412         # raise a ValueError.  In this case, display '???'.\n413         try:\n414             vetted_tolerance = f\"{self.tolerance:.1e}\"\n415             if (\n416                 isinstance(self.expected, Complex)\n417                 and self.expected.imag\n418                 and not math.isinf(self.tolerance)\n419             ):\n420                 vetted_tolerance += \" \u2220 \u00b1180\u00b0\"\n421         except ValueError:\n422             vetted_tolerance = \"???\"\n423 \n424         return f\"{self.expected} \u00b1 {vetted_tolerance}\"\n425 \n426     def __eq__(self, actual) -> bool:\n427         \"\"\"Return whether the given value is equal to the expected value\n428         within the pre-specified tolerance.\"\"\"\n429         asarray = _as_numpy_array(actual)\n430         if asarray is not None:\n431             # Call ``__eq__()`` manually to prevent infinite-recursion with\n432             # numpy<1.13.  See #3748.\n433             return all(self.__eq__(a) for a in asarray.flat)\n434 \n435         # Short-circuit exact equality.\n436         if actual == self.expected:\n437             return True\n438 \n439         # If either type is non-numeric, fall back to strict equality.\n440         # NB: we need Complex, rather than just Number, to ensure that __abs__,\n441         # __sub__, and __float__ are defined.\n442         if not (\n443             isinstance(self.expected, (Complex, Decimal))\n444             and isinstance(actual, (Complex, Decimal))\n445         ):\n446             return False\n447 \n448         # Allow the user to control whether NaNs are considered equal to each\n449         # other or not.  The abs() calls are for compatibility with complex\n450         # numbers.\n451         if math.isnan(abs(self.expected)):  # type: ignore[arg-type]\n452             return self.nan_ok and math.isnan(abs(actual))  # type: ignore[arg-type]\n453 \n454         # Infinity shouldn't be approximately equal to anything but itself, but\n455         # if there's a relative tolerance, it will be infinite and infinity\n456         # will seem approximately equal to everything.  The equal-to-itself\n457         # case would have been short circuited above, so here we can just\n458         # return false if the expected value is infinite.  The abs() call is\n459         # for compatibility with complex numbers.\n460         if math.isinf(abs(self.expected)):  # type: ignore[arg-type]\n461             return False\n462 \n463         # Return true if the two numbers are within the tolerance.\n464         result: bool = abs(self.expected - actual) <= self.tolerance\n465         return result\n466 \n467     # Ignore type because of https://github.com/python/mypy/issues/4266.\n468     __hash__ = None  # type: ignore\n469 \n470     @property\n471     def tolerance(self):\n472         \"\"\"Return the tolerance for the comparison.\n473 \n474         This could be either an absolute tolerance or a relative tolerance,\n475         depending on what the user specified or which would be larger.\n476         \"\"\"\n477 \n478         def set_default(x, default):\n479             return x if x is not None else default\n480 \n481         # Figure out what the absolute tolerance should be.  ``self.abs`` is\n482         # either None or a value specified by the user.\n483         absolute_tolerance = set_default(self.abs, self.DEFAULT_ABSOLUTE_TOLERANCE)\n484 \n485         if absolute_tolerance < 0:\n486             raise ValueError(\n487                 f\"absolute tolerance can't be negative: {absolute_tolerance}\"\n488             )\n489         if math.isnan(absolute_tolerance):\n490             raise ValueError(\"absolute tolerance can't be NaN.\")\n491 \n492         # If the user specified an absolute tolerance but not a relative one,\n493         # just return the absolute tolerance.\n494         if self.rel is None:\n495             if self.abs is not None:\n496                 return absolute_tolerance\n497 \n498         # Figure out what the relative tolerance should be.  ``self.rel`` is\n499         # either None or a value specified by the user.  This is done after\n500         # we've made sure the user didn't ask for an absolute tolerance only,\n501         # because we don't want to raise errors about the relative tolerance if\n502         # we aren't even going to use it.\n503         relative_tolerance = set_default(\n504             self.rel, self.DEFAULT_RELATIVE_TOLERANCE\n505         ) * abs(self.expected)\n506 \n507         if relative_tolerance < 0:\n508             raise ValueError(\n509                 f\"relative tolerance can't be negative: {relative_tolerance}\"\n510             )\n511         if math.isnan(relative_tolerance):\n512             raise ValueError(\"relative tolerance can't be NaN.\")\n513 \n514         # Return the larger of the relative and absolute tolerances.\n515         return max(relative_tolerance, absolute_tolerance)\n",
        "intended_behavior": "This class provides additional context to the issue."
    },
    {
        "rel_file_path": "src/_pytest/python_api.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/pytest-dev__pytest/setup_pytest-dev__pytest__8.0/src/_pytest/python_api.py",
        "start": 297,
        "end": 304,
        "class_name": "ApproxMapping",
        "method_name": "__eq__",
        "code": "297     def __eq__(self, actual) -> bool:\n298         try:\n299             if set(actual.keys()) != set(self.expected.keys()):\n300                 return False\n301         except AttributeError:\n302             return False\n303 \n304         return super().__eq__(actual)\n",
        "intended_behavior": "In the `__eq__` method, before performing any comparison, check if any value in the `actual` mapping or in the expected mapping (`self.expected`) is `None`. If so, handle gracefully by either explicitly returning `False` to indicate non-equality due to `None` values or raise an informative exception that `None` values are not supported for approximate comparisons in dictionaries. This will guide the user to either correct the test or adjust their expectations regarding the use of `approx` with mappings containing `None`."
    },
    {
        "rel_file_path": "src/_pytest/python_api.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/pytest-dev__pytest/setup_pytest-dev__pytest__8.0/src/_pytest/python_api.py",
        "start": 244,
        "end": 315,
        "class_name": "ApproxMapping",
        "method_name": null,
        "code": "244 class ApproxMapping(ApproxBase):\n245     \"\"\"Perform approximate comparisons where the expected value is a mapping\n246     with numeric values (the keys can be anything).\"\"\"\n247 \n248     def __repr__(self) -> str:\n249         return \"approx({!r})\".format(\n250             {k: self._approx_scalar(v) for k, v in self.expected.items()}\n251         )\n252 \n253     def _repr_compare(self, other_side: Mapping[object, float]) -> List[str]:\n254         import math\n255 \n256         approx_side_as_map = {\n257             k: self._approx_scalar(v) for k, v in self.expected.items()\n258         }\n259 \n260         number_of_elements = len(approx_side_as_map)\n261         max_abs_diff = -math.inf\n262         max_rel_diff = -math.inf\n263         different_ids = []\n264         for (approx_key, approx_value), other_value in zip(\n265             approx_side_as_map.items(), other_side.values()\n266         ):\n267             if approx_value != other_value:\n268                 max_abs_diff = max(\n269                     max_abs_diff, abs(approx_value.expected - other_value)\n270                 )\n271                 if approx_value.expected == 0.0:\n272                     max_rel_diff = math.inf\n273                 else:\n274                     max_rel_diff = max(\n275                         max_rel_diff,\n276                         abs(\n277                             (approx_value.expected - other_value)\n278                             / approx_value.expected\n279                         ),\n280                     )\n281                 different_ids.append(approx_key)\n282 \n283         message_data = [\n284             (str(key), str(other_side[key]), str(approx_side_as_map[key]))\n285             for key in different_ids\n286         ]\n287 \n288         return _compare_approx(\n289             self.expected,\n290             message_data,\n291             number_of_elements,\n292             different_ids,\n293             max_abs_diff,\n294             max_rel_diff,\n295         )\n296 \n297     def __eq__(self, actual) -> bool:\n298         try:\n299             if set(actual.keys()) != set(self.expected.keys()):\n300                 return False\n301         except AttributeError:\n302             return False\n303 \n304         return super().__eq__(actual)\n305 \n306     def _yield_comparisons(self, actual):\n307         for k in self.expected.keys():\n308             yield actual[k], self.expected[k]\n309 \n310     def _check_type(self) -> None:\n311         __tracebackhide__ = True\n312         for key, value in self.expected.items():\n313             if isinstance(value, type(self.expected)):\n314                 msg = \"pytest.approx() does not support nested dictionaries: key={!r} value={!r}\\n  full mapping={}\"\n315                 raise TypeError(msg.format(key, value, pprint.pformat(self.expected)))\n",
        "intended_behavior": "This class provides additional context to the issue."
    }
]