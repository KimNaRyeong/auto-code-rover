[
    {
        "rel_file_path": "sphinx/directives/code.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__5.0/sphinx/directives/code.py",
        "start": 1,
        "end": 461,
        "class_name": null,
        "method_name": null,
        "code": "1 import sys\n2 import textwrap\n3 from difflib import unified_diff\n4 from typing import TYPE_CHECKING, Any, Dict, List, Tuple\n5 \n6 from docutils import nodes\n7 from docutils.nodes import Element, Node\n8 from docutils.parsers.rst import directives\n9 from docutils.statemachine import StringList\n10 \n11 from sphinx import addnodes\n12 from sphinx.config import Config\n13 from sphinx.directives import optional_int\n14 from sphinx.locale import __\n15 from sphinx.util import logging, parselinenos\n16 from sphinx.util.docutils import SphinxDirective\n17 from sphinx.util.typing import OptionSpec\n18 \n19 if TYPE_CHECKING:\n20     from sphinx.application import Sphinx\n21 \n22 logger = logging.getLogger(__name__)\n23 \n24 \n25 class Highlight(SphinxDirective):\n26     \"\"\"\n27     Directive to set the highlighting language for code blocks, as well\n28     as the threshold for line numbers.\n29     \"\"\"\n30 \n31     has_content = False\n32     required_arguments = 1\n33     optional_arguments = 0\n34     final_argument_whitespace = False\n35     option_spec: OptionSpec = {\n36         'force': directives.flag,\n37         'linenothreshold': directives.positive_int,\n38     }\n39 \n40     def run(self) -> List[Node]:\n41         language = self.arguments[0].strip()\n42         linenothreshold = self.options.get('linenothreshold', sys.maxsize)\n43         force = 'force' in self.options\n44 \n45         self.env.temp_data['highlight_language'] = language\n46         return [addnodes.highlightlang(lang=language,\n47                                        force=force,\n48                                        linenothreshold=linenothreshold)]\n49 \n50 \n51 def dedent_lines(lines: List[str], dedent: int, location: Tuple[str, int] = None) -> List[str]:\n52     if dedent is None:\n53         return textwrap.dedent(''.join(lines)).splitlines(True)\n54 \n55     if any(s[:dedent].strip() for s in lines):\n56         logger.warning(__('non-whitespace stripped by dedent'), location=location)\n57 \n58     new_lines = []\n59     for line in lines:\n60         new_line = line[dedent:]\n61         if line.endswith('\\n') and not new_line:\n62             new_line = '\\n'  # keep CRLF\n63         new_lines.append(new_line)\n64 \n65     return new_lines\n66 \n67 \n68 def container_wrapper(directive: SphinxDirective, literal_node: Node, caption: str) -> nodes.container:  # NOQA\n69     container_node = nodes.container('', literal_block=True,\n70                                      classes=['literal-block-wrapper'])\n71     parsed = nodes.Element()\n72     directive.state.nested_parse(StringList([caption], source=''),\n73                                  directive.content_offset, parsed)\n74     if isinstance(parsed[0], nodes.system_message):\n75         msg = __('Invalid caption: %s' % parsed[0].astext())\n76         raise ValueError(msg)\n77     elif isinstance(parsed[0], nodes.Element):\n78         caption_node = nodes.caption(parsed[0].rawsource, '',\n79                                      *parsed[0].children)\n80         caption_node.source = literal_node.source\n81         caption_node.line = literal_node.line\n82         container_node += caption_node\n83         container_node += literal_node\n84         return container_node\n85     else:\n86         raise RuntimeError  # never reached\n87 \n88 \n89 class CodeBlock(SphinxDirective):\n90     \"\"\"\n91     Directive for a code block with special highlighting or line numbering\n92     settings.\n93     \"\"\"\n94 \n95     has_content = True\n96     required_arguments = 0\n97     optional_arguments = 1\n98     final_argument_whitespace = False\n99     option_spec: OptionSpec = {\n100         'force': directives.flag,\n101         'linenos': directives.flag,\n102         'dedent': optional_int,\n103         'lineno-start': int,\n104         'emphasize-lines': directives.unchanged_required,\n105         'caption': directives.unchanged_required,\n106         'class': directives.class_option,\n107         'name': directives.unchanged,\n108     }\n109 \n110     def run(self) -> List[Node]:\n111         document = self.state.document\n112         code = '\\n'.join(self.content)\n113         location = self.state_machine.get_source_and_line(self.lineno)\n114 \n115         linespec = self.options.get('emphasize-lines')\n116         if linespec:\n117             try:\n118                 nlines = len(self.content)\n119                 hl_lines = parselinenos(linespec, nlines)\n120                 if any(i >= nlines for i in hl_lines):\n121                     logger.warning(__('line number spec is out of range(1-%d): %r') %\n122                                    (nlines, self.options['emphasize-lines']),\n123                                    location=location)\n124 \n125                 hl_lines = [x + 1 for x in hl_lines if x < nlines]\n126             except ValueError as err:\n127                 return [document.reporter.warning(err, line=self.lineno)]\n128         else:\n129             hl_lines = None\n130 \n131         if 'dedent' in self.options:\n132             location = self.state_machine.get_source_and_line(self.lineno)\n133             lines = code.splitlines(True)\n134             lines = dedent_lines(lines, self.options['dedent'], location=location)\n135             code = ''.join(lines)\n136 \n137         literal: Element = nodes.literal_block(code, code)\n138         if 'linenos' in self.options or 'lineno-start' in self.options:\n139             literal['linenos'] = True\n140         literal['classes'] += self.options.get('class', [])\n141         literal['force'] = 'force' in self.options\n142         if self.arguments:\n143             # highlight language specified\n144             literal['language'] = self.arguments[0]\n145         else:\n146             # no highlight language specified.  Then this directive refers the current\n147             # highlight setting via ``highlight`` directive or ``highlight_language``\n148             # configuration.\n149             literal['language'] = self.env.temp_data.get('highlight_language',\n150                                                          self.config.highlight_language)\n151         extra_args = literal['highlight_args'] = {}\n152         if hl_lines is not None:\n153             extra_args['hl_lines'] = hl_lines\n154         if 'lineno-start' in self.options:\n155             extra_args['linenostart'] = self.options['lineno-start']\n156         self.set_source_info(literal)\n157 \n158         caption = self.options.get('caption')\n159         if caption:\n160             try:\n161                 literal = container_wrapper(self, literal, caption)\n162             except ValueError as exc:\n163                 return [document.reporter.warning(exc, line=self.lineno)]\n164 \n165         # literal will be note_implicit_target that is linked from caption and numref.\n166         # when options['name'] is provided, it should be primary ID.\n167         self.add_name(literal)\n168 \n169         return [literal]\n170 \n171 \n172 class LiteralIncludeReader:\n173     INVALID_OPTIONS_PAIR = [\n174         ('lineno-match', 'lineno-start'),\n175         ('lineno-match', 'append'),\n176         ('lineno-match', 'prepend'),\n177         ('start-after', 'start-at'),\n178         ('end-before', 'end-at'),\n179         ('diff', 'pyobject'),\n180         ('diff', 'lineno-start'),\n181         ('diff', 'lineno-match'),\n182         ('diff', 'lines'),\n183         ('diff', 'start-after'),\n184         ('diff', 'end-before'),\n185         ('diff', 'start-at'),\n186         ('diff', 'end-at'),\n187     ]\n188 \n189     def __init__(self, filename: str, options: Dict, config: Config) -> None:\n190         self.filename = filename\n191         self.options = options\n192         self.encoding = options.get('encoding', config.source_encoding)\n193         self.lineno_start = self.options.get('lineno-start', 1)\n194 \n195         self.parse_options()\n196 \n197     def parse_options(self) -> None:\n198         for option1, option2 in self.INVALID_OPTIONS_PAIR:\n199             if option1 in self.options and option2 in self.options:\n200                 raise ValueError(__('Cannot use both \"%s\" and \"%s\" options') %\n201                                  (option1, option2))\n202 \n203     def read_file(self, filename: str, location: Tuple[str, int] = None) -> List[str]:\n204         try:\n205             with open(filename, encoding=self.encoding, errors='strict') as f:\n206                 text = f.read()\n207                 if 'tab-width' in self.options:\n208                     text = text.expandtabs(self.options['tab-width'])\n209 \n210                 return text.splitlines(True)\n211         except OSError as exc:\n212             raise OSError(__('Include file %r not found or reading it failed') %\n213                           filename) from exc\n214         except UnicodeError as exc:\n215             raise UnicodeError(__('Encoding %r used for reading included file %r seems to '\n216                                   'be wrong, try giving an :encoding: option') %\n217                                (self.encoding, filename)) from exc\n218 \n219     def read(self, location: Tuple[str, int] = None) -> Tuple[str, int]:\n220         if 'diff' in self.options:\n221             lines = self.show_diff()\n222         else:\n223             filters = [self.pyobject_filter,\n224                        self.start_filter,\n225                        self.end_filter,\n226                        self.lines_filter,\n227                        self.prepend_filter,\n228                        self.append_filter,\n229                        self.dedent_filter]\n230             lines = self.read_file(self.filename, location=location)\n231             for func in filters:\n232                 lines = func(lines, location=location)\n233 \n234         return ''.join(lines), len(lines)\n235 \n236     def show_diff(self, location: Tuple[str, int] = None) -> List[str]:\n237         new_lines = self.read_file(self.filename)\n238         old_filename = self.options.get('diff')\n239         old_lines = self.read_file(old_filename)\n240         diff = unified_diff(old_lines, new_lines, old_filename, self.filename)\n241         return list(diff)\n242 \n243     def pyobject_filter(self, lines: List[str], location: Tuple[str, int] = None) -> List[str]:\n244         pyobject = self.options.get('pyobject')\n245         if pyobject:\n246             from sphinx.pycode import ModuleAnalyzer\n247             analyzer = ModuleAnalyzer.for_file(self.filename, '')\n248             tags = analyzer.find_tags()\n249             if pyobject not in tags:\n250                 raise ValueError(__('Object named %r not found in include file %r') %\n251                                  (pyobject, self.filename))\n252             else:\n253                 start = tags[pyobject][1]\n254                 end = tags[pyobject][2]\n255                 lines = lines[start - 1:end]\n256                 if 'lineno-match' in self.options:\n257                     self.lineno_start = start\n258 \n259         return lines\n260 \n261     def lines_filter(self, lines: List[str], location: Tuple[str, int] = None) -> List[str]:\n262         linespec = self.options.get('lines')\n263         if linespec:\n264             linelist = parselinenos(linespec, len(lines))\n265             if any(i >= len(lines) for i in linelist):\n266                 logger.warning(__('line number spec is out of range(1-%d): %r') %\n267                                (len(lines), linespec), location=location)\n268 \n269             if 'lineno-match' in self.options:\n270                 # make sure the line list is not \"disjoint\".\n271                 first = linelist[0]\n272                 if all(first + i == n for i, n in enumerate(linelist)):\n273                     self.lineno_start += linelist[0]\n274                 else:\n275                     raise ValueError(__('Cannot use \"lineno-match\" with a disjoint '\n276                                         'set of \"lines\"'))\n277 \n278             lines = [lines[n] for n in linelist if n < len(lines)]\n279             if lines == []:\n280                 raise ValueError(__('Line spec %r: no lines pulled from include file %r') %\n281                                  (linespec, self.filename))\n282 \n283         return lines\n284 \n285     def start_filter(self, lines: List[str], location: Tuple[str, int] = None) -> List[str]:\n286         if 'start-at' in self.options:\n287             start = self.options.get('start-at')\n288             inclusive = False\n289         elif 'start-after' in self.options:\n290             start = self.options.get('start-after')\n291             inclusive = True\n292         else:\n293             start = None\n294 \n295         if start:\n296             for lineno, line in enumerate(lines):\n297                 if start in line:\n298                     if inclusive:\n299                         if 'lineno-match' in self.options:\n300                             self.lineno_start += lineno + 1\n301 \n302                         return lines[lineno + 1:]\n303                     else:\n304                         if 'lineno-match' in self.options:\n305                             self.lineno_start += lineno\n306 \n307                         return lines[lineno:]\n308 \n309             if inclusive is True:\n310                 raise ValueError('start-after pattern not found: %s' % start)\n311             else:\n312                 raise ValueError('start-at pattern not found: %s' % start)\n313 \n314         return lines\n315 \n316     def end_filter(self, lines: List[str], location: Tuple[str, int] = None) -> List[str]:\n317         if 'end-at' in self.options:\n318             end = self.options.get('end-at')\n319             inclusive = True\n320         elif 'end-before' in self.options:\n321             end = self.options.get('end-before')\n322             inclusive = False\n323         else:\n324             end = None\n325 \n326         if end:\n327             for lineno, line in enumerate(lines):\n328                 if end in line:\n329                     if inclusive:\n330                         return lines[:lineno + 1]\n331                     else:\n332                         if lineno == 0:\n333                             pass  # end-before ignores first line\n334                         else:\n335                             return lines[:lineno]\n336             if inclusive is True:\n337                 raise ValueError('end-at pattern not found: %s' % end)\n338             else:\n339                 raise ValueError('end-before pattern not found: %s' % end)\n340 \n341         return lines\n342 \n343     def prepend_filter(self, lines: List[str], location: Tuple[str, int] = None) -> List[str]:\n344         prepend = self.options.get('prepend')\n345         if prepend:\n346             lines.insert(0, prepend + '\\n')\n347 \n348         return lines\n349 \n350     def append_filter(self, lines: List[str], location: Tuple[str, int] = None) -> List[str]:\n351         append = self.options.get('append')\n352         if append:\n353             lines.append(append + '\\n')\n354 \n355         return lines\n356 \n357     def dedent_filter(self, lines: List[str], location: Tuple[str, int] = None) -> List[str]:\n358         if 'dedent' in self.options:\n359             return dedent_lines(lines, self.options.get('dedent'), location=location)\n360         else:\n361             return lines\n362 \n363 \n364 class LiteralInclude(SphinxDirective):\n365     \"\"\"\n366     Like ``.. include:: :literal:``, but only warns if the include file is\n367     not found, and does not raise errors.  Also has several options for\n368     selecting what to include.\n369     \"\"\"\n370 \n371     has_content = False\n372     required_arguments = 1\n373     optional_arguments = 0\n374     final_argument_whitespace = True\n375     option_spec: OptionSpec = {\n376         'dedent': optional_int,\n377         'linenos': directives.flag,\n378         'lineno-start': int,\n379         'lineno-match': directives.flag,\n380         'tab-width': int,\n381         'language': directives.unchanged_required,\n382         'force': directives.flag,\n383         'encoding': directives.encoding,\n384         'pyobject': directives.unchanged_required,\n385         'lines': directives.unchanged_required,\n386         'start-after': directives.unchanged_required,\n387         'end-before': directives.unchanged_required,\n388         'start-at': directives.unchanged_required,\n389         'end-at': directives.unchanged_required,\n390         'prepend': directives.unchanged_required,\n391         'append': directives.unchanged_required,\n392         'emphasize-lines': directives.unchanged_required,\n393         'caption': directives.unchanged,\n394         'class': directives.class_option,\n395         'name': directives.unchanged,\n396         'diff': directives.unchanged_required,\n397     }\n398 \n399     def run(self) -> List[Node]:\n400         document = self.state.document\n401         if not document.settings.file_insertion_enabled:\n402             return [document.reporter.warning('File insertion disabled',\n403                                               line=self.lineno)]\n404         # convert options['diff'] to absolute path\n405         if 'diff' in self.options:\n406             _, path = self.env.relfn2path(self.options['diff'])\n407             self.options['diff'] = path\n408 \n409         try:\n410             location = self.state_machine.get_source_and_line(self.lineno)\n411             rel_filename, filename = self.env.relfn2path(self.arguments[0])\n412             self.env.note_dependency(rel_filename)\n413 \n414             reader = LiteralIncludeReader(filename, self.options, self.config)\n415             text, lines = reader.read(location=location)\n416 \n417             retnode: Element = nodes.literal_block(text, text, source=filename)\n418             retnode['force'] = 'force' in self.options\n419             self.set_source_info(retnode)\n420             if self.options.get('diff'):  # if diff is set, set udiff\n421                 retnode['language'] = 'udiff'\n422             elif 'language' in self.options:\n423                 retnode['language'] = self.options['language']\n424             if ('linenos' in self.options or 'lineno-start' in self.options or\n425                     'lineno-match' in self.options):\n426                 retnode['linenos'] = True\n427             retnode['classes'] += self.options.get('class', [])\n428             extra_args = retnode['highlight_args'] = {}\n429             if 'emphasize-lines' in self.options:\n430                 hl_lines = parselinenos(self.options['emphasize-lines'], lines)\n431                 if any(i >= lines for i in hl_lines):\n432                     logger.warning(__('line number spec is out of range(1-%d): %r') %\n433                                    (lines, self.options['emphasize-lines']),\n434                                    location=location)\n435                 extra_args['hl_lines'] = [x + 1 for x in hl_lines if x < lines]\n436             extra_args['linenostart'] = reader.lineno_start\n437 \n438             if 'caption' in self.options:\n439                 caption = self.options['caption'] or self.arguments[0]\n440                 retnode = container_wrapper(self, retnode, caption)\n441 \n442             # retnode will be note_implicit_target that is linked from caption and numref.\n443             # when options['name'] is provided, it should be primary ID.\n444             self.add_name(retnode)\n445 \n446             return [retnode]\n447         except Exception as exc:\n448             return [document.reporter.warning(exc, line=self.lineno)]\n449 \n450 \n451 def setup(app: \"Sphinx\") -> Dict[str, Any]:\n452     directives.register_directive('highlight', Highlight)\n453     directives.register_directive('code-block', CodeBlock)\n454     directives.register_directive('sourcecode', CodeBlock)\n455     directives.register_directive('literalinclude', LiteralInclude)\n456 \n457     return {\n458         'version': 'builtin',\n459         'parallel_read_safe': True,\n460         'parallel_write_safe': True,\n461     }\n",
        "intended_behavior": "The method handling the `literalinclude` directive options should preserve the indentation of the text provided through the `prepend` option when it is being added to the beginning of the included code block. Additionally, it should ensure that the `dedent` operation only applies to the code content from the included file itself, not affecting the indentation level of the `prepend` or `append` text. This would require adding logic to separately manage the indentation for `prepend`/`append` content and the included content, allowing `dedent` to only impact the latter. A possible implementation may involve calculating the indentation level of the included content after `dedent` is applied and then applying the necessary indentation to `prepend` or `append` text so it matches the document's intended layout. This ensures that the `prepend` and `append` functionalities can be used flexibly without unintended effects on text indentation, preserving or enhancing the directive's usability for documentation authors."
    }
]