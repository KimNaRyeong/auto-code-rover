[
    {
        "rel_file_path": "pylint/pyreverse/writer.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/pylint-dev__pylint/setup_pylint-dev__pylint__2.9/pylint/pyreverse/writer.py",
        "start": 1,
        "end": 218,
        "class_name": null,
        "method_name": null,
        "code": "1 # Copyright (c) 2008-2010, 2013-2014 LOGILAB S.A. (Paris, FRANCE) <contact@logilab.fr>\n2 # Copyright (c) 2014 Arun Persaud <arun@nubati.net>\n3 # Copyright (c) 2015-2018, 2020 Claudiu Popa <pcmanticore@gmail.com>\n4 # Copyright (c) 2015 Mike Frysinger <vapier@gentoo.org>\n5 # Copyright (c) 2015 Florian Bruhin <me@the-compiler.org>\n6 # Copyright (c) 2015 Ionel Cristian Maries <contact@ionelmc.ro>\n7 # Copyright (c) 2018, 2020 Anthony Sottile <asottile@umich.edu>\n8 # Copyright (c) 2018 ssolanki <sushobhitsolanki@gmail.com>\n9 # Copyright (c) 2019-2021 Pierre Sassoulas <pierre.sassoulas@gmail.com>\n10 # Copyright (c) 2019 Kylian <development@goudcode.nl>\n11 # Copyright (c) 2021 Andreas Finkler <andi.finkler@gmail.com>\n12 # Copyright (c) 2021 Mark Byrne <mbyrnepr2@gmail.com>\n13 \n14 # Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n15 # For details: https://github.com/PyCQA/pylint/blob/master/LICENSE\n16 \n17 \"\"\"Utilities for creating VCG and Dot diagrams\"\"\"\n18 \n19 import os\n20 \n21 from pylint.graph import DotBackend\n22 from pylint.pyreverse.utils import is_exception\n23 from pylint.pyreverse.vcgutils import VCGPrinter\n24 \n25 \n26 class DiagramWriter:\n27     \"\"\"base class for writing project diagrams\"\"\"\n28 \n29     def __init__(self, config, styles):\n30         self.config = config\n31         self.pkg_edges, self.inh_edges, self.imp_edges, self.association_edges = styles\n32         self.printer = None  # defined in set_printer\n33 \n34     def write(self, diadefs):\n35         \"\"\"write files for <project> according to <diadefs>\"\"\"\n36         for diagram in diadefs:\n37             basename = diagram.title.strip().replace(\" \", \"_\")\n38             file_name = f\"{basename}.{self.config.output_format}\"\n39             if os.path.exists(self.config.output_directory):\n40                 file_name = os.path.join(self.config.output_directory, file_name)\n41             self.set_printer(file_name, basename)\n42             if diagram.TYPE == \"class\":\n43                 self.write_classes(diagram)\n44             else:\n45                 self.write_packages(diagram)\n46             self.close_graph()\n47 \n48     def write_packages(self, diagram):\n49         \"\"\"write a package diagram\"\"\"\n50         # sorted to get predictable (hence testable) results\n51         for i, obj in enumerate(sorted(diagram.modules(), key=lambda x: x.title)):\n52             self.printer.emit_node(i, label=self.get_title(obj), shape=\"box\")\n53             obj.fig_id = i\n54         # package dependencies\n55         for rel in diagram.get_relationships(\"depends\"):\n56             self.printer.emit_edge(\n57                 rel.from_object.fig_id, rel.to_object.fig_id, **self.pkg_edges\n58             )\n59 \n60     def write_classes(self, diagram):\n61         \"\"\"write a class diagram\"\"\"\n62         # sorted to get predictable (hence testable) results\n63         for i, obj in enumerate(sorted(diagram.objects, key=lambda x: x.title)):\n64             self.printer.emit_node(i, **self.get_values(obj))\n65             obj.fig_id = i\n66         # inheritance links\n67         for rel in diagram.get_relationships(\"specialization\"):\n68             self.printer.emit_edge(\n69                 rel.from_object.fig_id, rel.to_object.fig_id, **self.inh_edges\n70             )\n71         # implementation links\n72         for rel in diagram.get_relationships(\"implements\"):\n73             self.printer.emit_edge(\n74                 rel.from_object.fig_id, rel.to_object.fig_id, **self.imp_edges\n75             )\n76         # generate associations\n77         for rel in diagram.get_relationships(\"association\"):\n78             self.printer.emit_edge(\n79                 rel.from_object.fig_id,\n80                 rel.to_object.fig_id,\n81                 label=rel.name,\n82                 **self.association_edges,\n83             )\n84 \n85     def set_printer(self, file_name, basename):\n86         \"\"\"set printer\"\"\"\n87         raise NotImplementedError\n88 \n89     def get_title(self, obj):\n90         \"\"\"get project title\"\"\"\n91         raise NotImplementedError\n92 \n93     def get_values(self, obj):\n94         \"\"\"get label and shape for classes.\"\"\"\n95         raise NotImplementedError\n96 \n97     def close_graph(self):\n98         \"\"\"finalize the graph\"\"\"\n99         raise NotImplementedError\n100 \n101 \n102 class DotWriter(DiagramWriter):\n103     \"\"\"write dot graphs from a diagram definition and a project\"\"\"\n104 \n105     def __init__(self, config):\n106         styles = [\n107             dict(arrowtail=\"none\", arrowhead=\"open\"),\n108             dict(arrowtail=\"none\", arrowhead=\"empty\"),\n109             dict(arrowtail=\"node\", arrowhead=\"empty\", style=\"dashed\"),\n110             dict(\n111                 fontcolor=\"green\", arrowtail=\"none\", arrowhead=\"diamond\", style=\"solid\"\n112             ),\n113         ]\n114         DiagramWriter.__init__(self, config, styles)\n115 \n116     def set_printer(self, file_name, basename):\n117         \"\"\"initialize DotWriter and add options for layout.\"\"\"\n118         layout = dict(rankdir=\"BT\")\n119         self.printer = DotBackend(basename, additional_param=layout)\n120         self.file_name = file_name\n121 \n122     def get_title(self, obj):\n123         \"\"\"get project title\"\"\"\n124         return obj.title\n125 \n126     def get_values(self, obj):\n127         \"\"\"get label and shape for classes.\n128 \n129         The label contains all attributes and methods\n130         \"\"\"\n131         label = obj.title\n132         if obj.shape == \"interface\":\n133             label = \"\u00abinterface\u00bb\\\\n%s\" % label\n134         if not self.config.only_classnames:\n135             label = r\"{}|{}\\l|\".format(label, r\"\\l\".join(obj.attrs))\n136             for func in obj.methods:\n137                 if func.args.args:\n138                     args = [arg.name for arg in func.args.args if arg.name != \"self\"]\n139                 else:\n140                     args = []\n141                 label = r\"{}{}({})\\l\".format(label, func.name, \", \".join(args))\n142             label = \"{%s}\" % label\n143         if is_exception(obj.node):\n144             return dict(fontcolor=\"red\", label=label, shape=\"record\")\n145         return dict(label=label, shape=\"record\")\n146 \n147     def close_graph(self):\n148         \"\"\"print the dot graph into <file_name>\"\"\"\n149         self.printer.generate(self.file_name)\n150 \n151 \n152 class VCGWriter(DiagramWriter):\n153     \"\"\"write vcg graphs from a diagram definition and a project\"\"\"\n154 \n155     def __init__(self, config):\n156         styles = [\n157             dict(arrowstyle=\"solid\", backarrowstyle=\"none\", backarrowsize=0),\n158             dict(arrowstyle=\"solid\", backarrowstyle=\"none\", backarrowsize=10),\n159             dict(\n160                 arrowstyle=\"solid\",\n161                 backarrowstyle=\"none\",\n162                 linestyle=\"dotted\",\n163                 backarrowsize=10,\n164             ),\n165             dict(arrowstyle=\"solid\", backarrowstyle=\"none\", textcolor=\"green\"),\n166         ]\n167         DiagramWriter.__init__(self, config, styles)\n168 \n169     def set_printer(self, file_name, basename):\n170         \"\"\"initialize VCGWriter for a UML graph\"\"\"\n171         self.graph_file = open(file_name, \"w+\")  # pylint: disable=consider-using-with\n172         self.printer = VCGPrinter(self.graph_file)\n173         self.printer.open_graph(\n174             title=basename,\n175             layoutalgorithm=\"dfs\",\n176             late_edge_labels=\"yes\",\n177             port_sharing=\"no\",\n178             manhattan_edges=\"yes\",\n179         )\n180         self.printer.emit_node = self.printer.node\n181         self.printer.emit_edge = self.printer.edge\n182 \n183     def get_title(self, obj):\n184         \"\"\"get project title in vcg format\"\"\"\n185         return r\"\\fb%s\\fn\" % obj.title\n186 \n187     def get_values(self, obj):\n188         \"\"\"get label and shape for classes.\n189 \n190         The label contains all attributes and methods\n191         \"\"\"\n192         if is_exception(obj.node):\n193             label = r\"\\fb\\f09%s\\fn\" % obj.title\n194         else:\n195             label = r\"\\fb%s\\fn\" % obj.title\n196         if obj.shape == \"interface\":\n197             shape = \"ellipse\"\n198         else:\n199             shape = \"box\"\n200         if not self.config.only_classnames:\n201             attrs = obj.attrs\n202             methods = [func.name for func in obj.methods]\n203             # box width for UML like diagram\n204             maxlen = max(len(name) for name in [obj.title] + methods + attrs)\n205             line = \"_\" * (maxlen + 2)\n206             label = fr\"{label}\\n\\f{line}\"\n207             for attr in attrs:\n208                 label = fr\"{label}\\n\\f08{attr}\"\n209             if attrs:\n210                 label = fr\"{label}\\n\\f{line}\"\n211             for func in methods:\n212                 label = fr\"{label}\\n\\f10{func}()\"\n213         return dict(label=label, shape=shape)\n214 \n215     def close_graph(self):\n216         \"\"\"close graph and file\"\"\"\n217         self.printer.close_graph()\n218         self.graph_file.close()\n",
        "intended_behavior": "This file should be enhanced to ensure that when UML diagrams are being output, type hints associated with class attributes and method parameters are included. For an attribute or parameter initially set to `None` but annotated with a type hint (e.g., `a: str = None`), the UML diagram must display this as having the hinted type (e.g., `a : String`). This enhancement should preserve the ability to generate diagrams as currently done, adding the functionality to display type hints."
    },
    {
        "rel_file_path": "pylint/pyreverse/diagrams.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/pylint-dev__pylint/setup_pylint-dev__pylint__2.9/pylint/pyreverse/diagrams.py",
        "start": 1,
        "end": 255,
        "class_name": null,
        "method_name": null,
        "code": "1 # Copyright (c) 2006, 2008-2010, 2012-2014 LOGILAB S.A. (Paris, FRANCE) <contact@logilab.fr>\n2 # Copyright (c) 2014-2018, 2020 Claudiu Popa <pcmanticore@gmail.com>\n3 # Copyright (c) 2014 Brett Cannon <brett@python.org>\n4 # Copyright (c) 2014 Arun Persaud <arun@nubati.net>\n5 # Copyright (c) 2015 Ionel Cristian Maries <contact@ionelmc.ro>\n6 # Copyright (c) 2018 ssolanki <sushobhitsolanki@gmail.com>\n7 # Copyright (c) 2019-2021 Pierre Sassoulas <pierre.sassoulas@gmail.com>\n8 # Copyright (c) 2020 hippo91 <guillaume.peillex@gmail.com>\n9 \n10 # Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n11 # For details: https://github.com/PyCQA/pylint/blob/master/LICENSE\n12 \n13 \"\"\"diagram objects\n14 \"\"\"\n15 \n16 import astroid\n17 \n18 from pylint.checkers.utils import decorated_with_property\n19 from pylint.pyreverse.utils import FilterMixIn, is_interface\n20 \n21 \n22 class Figure:\n23     \"\"\"base class for counter handling\"\"\"\n24 \n25 \n26 class Relationship(Figure):\n27     \"\"\"a relation ship from an object in the diagram to another\"\"\"\n28 \n29     def __init__(self, from_object, to_object, relation_type, name=None):\n30         Figure.__init__(self)\n31         self.from_object = from_object\n32         self.to_object = to_object\n33         self.type = relation_type\n34         self.name = name\n35 \n36 \n37 class DiagramEntity(Figure):\n38     \"\"\"a diagram object, i.e. a label associated to an astroid node\"\"\"\n39 \n40     def __init__(self, title=\"No name\", node=None):\n41         Figure.__init__(self)\n42         self.title = title\n43         self.node = node\n44 \n45 \n46 class ClassDiagram(Figure, FilterMixIn):\n47     \"\"\"main class diagram handling\"\"\"\n48 \n49     TYPE = \"class\"\n50 \n51     def __init__(self, title, mode):\n52         FilterMixIn.__init__(self, mode)\n53         Figure.__init__(self)\n54         self.title = title\n55         self.objects = []\n56         self.relationships = {}\n57         self._nodes = {}\n58         self.depends = []\n59 \n60     def get_relationships(self, role):\n61         # sorted to get predictable (hence testable) results\n62         return sorted(\n63             self.relationships.get(role, ()),\n64             key=lambda x: (x.from_object.fig_id, x.to_object.fig_id),\n65         )\n66 \n67     def add_relationship(self, from_object, to_object, relation_type, name=None):\n68         \"\"\"create a relation ship\"\"\"\n69         rel = Relationship(from_object, to_object, relation_type, name)\n70         self.relationships.setdefault(relation_type, []).append(rel)\n71 \n72     def get_relationship(self, from_object, relation_type):\n73         \"\"\"return a relation ship or None\"\"\"\n74         for rel in self.relationships.get(relation_type, ()):\n75             if rel.from_object is from_object:\n76                 return rel\n77         raise KeyError(relation_type)\n78 \n79     def get_attrs(self, node):\n80         \"\"\"return visible attributes, possibly with class name\"\"\"\n81         attrs = []\n82         properties = [\n83             (n, m)\n84             for n, m in node.items()\n85             if isinstance(m, astroid.FunctionDef) and decorated_with_property(m)\n86         ]\n87         for node_name, associated_nodes in (\n88             list(node.instance_attrs_type.items())\n89             + list(node.locals_type.items())\n90             + properties\n91         ):\n92             if not self.show_attr(node_name):\n93                 continue\n94             names = self.class_names(associated_nodes)\n95             if names:\n96                 node_name = \"{} : {}\".format(node_name, \", \".join(names))\n97             attrs.append(node_name)\n98         return sorted(attrs)\n99 \n100     def get_methods(self, node):\n101         \"\"\"return visible methods\"\"\"\n102         methods = [\n103             m\n104             for m in node.values()\n105             if isinstance(m, astroid.FunctionDef)\n106             and not decorated_with_property(m)\n107             and self.show_attr(m.name)\n108         ]\n109         return sorted(methods, key=lambda n: n.name)\n110 \n111     def add_object(self, title, node):\n112         \"\"\"create a diagram object\"\"\"\n113         assert node not in self._nodes\n114         ent = DiagramEntity(title, node)\n115         self._nodes[node] = ent\n116         self.objects.append(ent)\n117 \n118     def class_names(self, nodes):\n119         \"\"\"return class names if needed in diagram\"\"\"\n120         names = []\n121         for node in nodes:\n122             if isinstance(node, astroid.Instance):\n123                 node = node._proxied\n124             if (\n125                 isinstance(node, astroid.ClassDef)\n126                 and hasattr(node, \"name\")\n127                 and not self.has_node(node)\n128             ):\n129                 if node.name not in names:\n130                     node_name = node.name\n131                     names.append(node_name)\n132         return names\n133 \n134     def nodes(self):\n135         \"\"\"return the list of underlying nodes\"\"\"\n136         return self._nodes.keys()\n137 \n138     def has_node(self, node):\n139         \"\"\"return true if the given node is included in the diagram\"\"\"\n140         return node in self._nodes\n141 \n142     def object_from_node(self, node):\n143         \"\"\"return the diagram object mapped to node\"\"\"\n144         return self._nodes[node]\n145 \n146     def classes(self):\n147         \"\"\"return all class nodes in the diagram\"\"\"\n148         return [o for o in self.objects if isinstance(o.node, astroid.ClassDef)]\n149 \n150     def classe(self, name):\n151         \"\"\"return a class by its name, raise KeyError if not found\"\"\"\n152         for klass in self.classes():\n153             if klass.node.name == name:\n154                 return klass\n155         raise KeyError(name)\n156 \n157     def extract_relationships(self):\n158         \"\"\"extract relation ships between nodes in the diagram\"\"\"\n159         for obj in self.classes():\n160             node = obj.node\n161             obj.attrs = self.get_attrs(node)\n162             obj.methods = self.get_methods(node)\n163             # shape\n164             if is_interface(node):\n165                 obj.shape = \"interface\"\n166             else:\n167                 obj.shape = \"class\"\n168             # inheritance link\n169             for par_node in node.ancestors(recurs=False):\n170                 try:\n171                     par_obj = self.object_from_node(par_node)\n172                     self.add_relationship(obj, par_obj, \"specialization\")\n173                 except KeyError:\n174                     continue\n175             # implements link\n176             for impl_node in node.implements:\n177                 try:\n178                     impl_obj = self.object_from_node(impl_node)\n179                     self.add_relationship(obj, impl_obj, \"implements\")\n180                 except KeyError:\n181                     continue\n182             # associations link\n183             for name, values in list(node.instance_attrs_type.items()) + list(\n184                 node.locals_type.items()\n185             ):\n186                 for value in values:\n187                     if value is astroid.Uninferable:\n188                         continue\n189                     if isinstance(value, astroid.Instance):\n190                         value = value._proxied\n191                     try:\n192                         associated_obj = self.object_from_node(value)\n193                         self.add_relationship(associated_obj, obj, \"association\", name)\n194                     except KeyError:\n195                         continue\n196 \n197 \n198 class PackageDiagram(ClassDiagram):\n199     \"\"\"package diagram handling\"\"\"\n200 \n201     TYPE = \"package\"\n202 \n203     def modules(self):\n204         \"\"\"return all module nodes in the diagram\"\"\"\n205         return [o for o in self.objects if isinstance(o.node, astroid.Module)]\n206 \n207     def module(self, name):\n208         \"\"\"return a module by its name, raise KeyError if not found\"\"\"\n209         for mod in self.modules():\n210             if mod.node.name == name:\n211                 return mod\n212         raise KeyError(name)\n213 \n214     def get_module(self, name, node):\n215         \"\"\"return a module by its name, looking also for relative imports;\n216         raise KeyError if not found\n217         \"\"\"\n218         for mod in self.modules():\n219             mod_name = mod.node.name\n220             if mod_name == name:\n221                 return mod\n222             # search for fullname of relative import modules\n223             package = node.root().name\n224             if mod_name == f\"{package}.{name}\":\n225                 return mod\n226             if mod_name == \"{}.{}\".format(package.rsplit(\".\", 1)[0], name):\n227                 return mod\n228         raise KeyError(name)\n229 \n230     def add_from_depend(self, node, from_module):\n231         \"\"\"add dependencies created by from-imports\"\"\"\n232         mod_name = node.root().name\n233         obj = self.module(mod_name)\n234         if from_module not in obj.node.depends:\n235             obj.node.depends.append(from_module)\n236 \n237     def extract_relationships(self):\n238         \"\"\"extract relation ships between nodes in the diagram\"\"\"\n239         ClassDiagram.extract_relationships(self)\n240         for obj in self.classes():\n241             # ownership\n242             try:\n243                 mod = self.object_from_node(obj.node.root())\n244                 self.add_relationship(obj, mod, \"ownership\")\n245             except KeyError:\n246                 continue\n247         for obj in self.modules():\n248             obj.shape = \"package\"\n249             # dependencies\n250             for dep_name in obj.node.depends:\n251                 try:\n252                     dep = self.get_module(dep_name, obj.node)\n253                 except KeyError:\n254                     continue\n255                 self.add_relationship(obj, dep, \"depends\")\n",
        "intended_behavior": "Modify the logic for representing classes and relationships in the diagram to include type hints in the diagram's internal representation. This involves adjusting how classes and methods are processed to ensure that type annotations are captured and reflected in the generated diagrams."
    },
    {
        "rel_file_path": "pylint/pyreverse/diadefslib.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/pylint-dev__pylint/setup_pylint-dev__pylint__2.9/pylint/pyreverse/diadefslib.py",
        "start": 1,
        "end": 239,
        "class_name": null,
        "method_name": null,
        "code": "1 # Copyright (c) 2006, 2008-2010, 2013-2014 LOGILAB S.A. (Paris, FRANCE) <contact@logilab.fr>\n2 # Copyright (c) 2014 Brett Cannon <brett@python.org>\n3 # Copyright (c) 2014 Arun Persaud <arun@nubati.net>\n4 # Copyright (c) 2015-2018, 2020 Claudiu Popa <pcmanticore@gmail.com>\n5 # Copyright (c) 2015 Florian Bruhin <me@the-compiler.org>\n6 # Copyright (c) 2015 Ionel Cristian Maries <contact@ionelmc.ro>\n7 # Copyright (c) 2016 Ashley Whetter <ashley@awhetter.co.uk>\n8 # Copyright (c) 2017 \u0141ukasz Rogalski <rogalski.91@gmail.com>\n9 # Copyright (c) 2018 ssolanki <sushobhitsolanki@gmail.com>\n10 # Copyright (c) 2018 Sushobhit <31987769+sushobhit27@users.noreply.github.com>\n11 # Copyright (c) 2018 Ville Skytt\u00e4 <ville.skytta@iki.fi>\n12 # Copyright (c) 2019-2021 Pierre Sassoulas <pierre.sassoulas@gmail.com>\n13 # Copyright (c) 2020 hippo91 <guillaume.peillex@gmail.com>\n14 # Copyright (c) 2020 Anthony Sottile <asottile@umich.edu>\n15 \n16 # Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n17 # For details: https://github.com/PyCQA/pylint/blob/master/LICENSE\n18 \n19 \"\"\"handle diagram generation options for class diagram or default diagrams\n20 \"\"\"\n21 \n22 import astroid\n23 \n24 from pylint.pyreverse.diagrams import ClassDiagram, PackageDiagram\n25 from pylint.pyreverse.utils import LocalsVisitor\n26 \n27 BUILTINS_NAME = \"builtins\"\n28 \n29 # diagram generators ##########################################################\n30 \n31 \n32 class DiaDefGenerator:\n33     \"\"\"handle diagram generation options\"\"\"\n34 \n35     def __init__(self, linker, handler):\n36         \"\"\"common Diagram Handler initialization\"\"\"\n37         self.config = handler.config\n38         self._set_default_options()\n39         self.linker = linker\n40         self.classdiagram = None  # defined by subclasses\n41 \n42     def get_title(self, node):\n43         \"\"\"get title for objects\"\"\"\n44         title = node.name\n45         if self.module_names:\n46             title = f\"{node.root().name}.{title}\"\n47         return title\n48 \n49     def _set_option(self, option):\n50         \"\"\"activate some options if not explicitly deactivated\"\"\"\n51         # if we have a class diagram, we want more information by default;\n52         # so if the option is None, we return True\n53         if option is None:\n54             return bool(self.config.classes)\n55         return option\n56 \n57     def _set_default_options(self):\n58         \"\"\"set different default options with _default dictionary\"\"\"\n59         self.module_names = self._set_option(self.config.module_names)\n60         all_ancestors = self._set_option(self.config.all_ancestors)\n61         all_associated = self._set_option(self.config.all_associated)\n62         anc_level, association_level = (0, 0)\n63         if all_ancestors:\n64             anc_level = -1\n65         if all_associated:\n66             association_level = -1\n67         if self.config.show_ancestors is not None:\n68             anc_level = self.config.show_ancestors\n69         if self.config.show_associated is not None:\n70             association_level = self.config.show_associated\n71         self.anc_level, self.association_level = anc_level, association_level\n72 \n73     def _get_levels(self):\n74         \"\"\"help function for search levels\"\"\"\n75         return self.anc_level, self.association_level\n76 \n77     def show_node(self, node):\n78         \"\"\"true if builtins and not show_builtins\"\"\"\n79         if self.config.show_builtin:\n80             return True\n81         return node.root().name != BUILTINS_NAME\n82 \n83     def add_class(self, node):\n84         \"\"\"visit one class and add it to diagram\"\"\"\n85         self.linker.visit(node)\n86         self.classdiagram.add_object(self.get_title(node), node)\n87 \n88     def get_ancestors(self, node, level):\n89         \"\"\"return ancestor nodes of a class node\"\"\"\n90         if level == 0:\n91             return\n92         for ancestor in node.ancestors(recurs=False):\n93             if not self.show_node(ancestor):\n94                 continue\n95             yield ancestor\n96 \n97     def get_associated(self, klass_node, level):\n98         \"\"\"return associated nodes of a class node\"\"\"\n99         if level == 0:\n100             return\n101         for association_nodes in list(klass_node.instance_attrs_type.values()) + list(\n102             klass_node.locals_type.values()\n103         ):\n104             for node in association_nodes:\n105                 if isinstance(node, astroid.Instance):\n106                     node = node._proxied\n107                 if not (isinstance(node, astroid.ClassDef) and self.show_node(node)):\n108                     continue\n109                 yield node\n110 \n111     def extract_classes(self, klass_node, anc_level, association_level):\n112         \"\"\"extract recursively classes related to klass_node\"\"\"\n113         if self.classdiagram.has_node(klass_node) or not self.show_node(klass_node):\n114             return\n115         self.add_class(klass_node)\n116 \n117         for ancestor in self.get_ancestors(klass_node, anc_level):\n118             self.extract_classes(ancestor, anc_level - 1, association_level)\n119 \n120         for node in self.get_associated(klass_node, association_level):\n121             self.extract_classes(node, anc_level, association_level - 1)\n122 \n123 \n124 class DefaultDiadefGenerator(LocalsVisitor, DiaDefGenerator):\n125     \"\"\"generate minimum diagram definition for the project :\n126 \n127     * a package diagram including project's modules\n128     * a class diagram including project's classes\n129     \"\"\"\n130 \n131     def __init__(self, linker, handler):\n132         DiaDefGenerator.__init__(self, linker, handler)\n133         LocalsVisitor.__init__(self)\n134 \n135     def visit_project(self, node):\n136         \"\"\"visit a pyreverse.utils.Project node\n137 \n138         create a diagram definition for packages\n139         \"\"\"\n140         mode = self.config.mode\n141         if len(node.modules) > 1:\n142             self.pkgdiagram = PackageDiagram(\"packages %s\" % node.name, mode)\n143         else:\n144             self.pkgdiagram = None\n145         self.classdiagram = ClassDiagram(\"classes %s\" % node.name, mode)\n146 \n147     def leave_project(self, node):  # pylint: disable=unused-argument\n148         \"\"\"leave the pyreverse.utils.Project node\n149 \n150         return the generated diagram definition\n151         \"\"\"\n152         if self.pkgdiagram:\n153             return self.pkgdiagram, self.classdiagram\n154         return (self.classdiagram,)\n155 \n156     def visit_module(self, node):\n157         \"\"\"visit an astroid.Module node\n158 \n159         add this class to the package diagram definition\n160         \"\"\"\n161         if self.pkgdiagram:\n162             self.linker.visit(node)\n163             self.pkgdiagram.add_object(node.name, node)\n164 \n165     def visit_classdef(self, node):\n166         \"\"\"visit an astroid.Class node\n167 \n168         add this class to the class diagram definition\n169         \"\"\"\n170         anc_level, association_level = self._get_levels()\n171         self.extract_classes(node, anc_level, association_level)\n172 \n173     def visit_importfrom(self, node):\n174         \"\"\"visit astroid.ImportFrom  and catch modules for package diagram\"\"\"\n175         if self.pkgdiagram:\n176             self.pkgdiagram.add_from_depend(node, node.modname)\n177 \n178 \n179 class ClassDiadefGenerator(DiaDefGenerator):\n180     \"\"\"generate a class diagram definition including all classes related to a\n181     given class\n182     \"\"\"\n183 \n184     def __init__(self, linker, handler):\n185         DiaDefGenerator.__init__(self, linker, handler)\n186 \n187     def class_diagram(self, project, klass):\n188         \"\"\"return a class diagram definition for the given klass and its\n189         related klasses\n190         \"\"\"\n191 \n192         self.classdiagram = ClassDiagram(klass, self.config.mode)\n193         if len(project.modules) > 1:\n194             module, klass = klass.rsplit(\".\", 1)\n195             module = project.get_module(module)\n196         else:\n197             module = project.modules[0]\n198             klass = klass.split(\".\")[-1]\n199         klass = next(module.ilookup(klass))\n200 \n201         anc_level, association_level = self._get_levels()\n202         self.extract_classes(klass, anc_level, association_level)\n203         return self.classdiagram\n204 \n205 \n206 # diagram handler #############################################################\n207 \n208 \n209 class DiadefsHandler:\n210     \"\"\"handle diagram definitions :\n211 \n212     get it from user (i.e. xml files) or generate them\n213     \"\"\"\n214 \n215     def __init__(self, config):\n216         self.config = config\n217 \n218     def get_diadefs(self, project, linker):\n219         \"\"\"Get the diagrams configuration data\n220 \n221         :param project:The pyreverse project\n222         :type project: pyreverse.utils.Project\n223         :param linker: The linker\n224         :type linker: pyreverse.inspector.Linker(IdGeneratorMixIn, LocalsVisitor)\n225 \n226         :returns: The list of diagram definitions\n227         :rtype: list(:class:`pylint.pyreverse.diagrams.ClassDiagram`)\n228         \"\"\"\n229 \n230         #  read and interpret diagram definitions (Diadefs)\n231         diagrams = []\n232         generator = ClassDiadefGenerator(linker, self)\n233         for klass in self.config.classes:\n234             diagrams.append(generator.class_diagram(project, klass))\n235         if not diagrams:\n236             diagrams = DefaultDiadefGenerator(linker, self).visit(project)\n237         for diagram in diagrams:\n238             diagram.extract_relationships()\n239         return diagrams\n",
        "intended_behavior": "In this library, responsible for defining the diagrams, ensure that type hints are part of the definition process. This might involve adding new properties or methods to classes that represent diagram elements to store and manage type hint information extracted from the AST."
    },
    {
        "rel_file_path": "pylint/utils/ast_walker.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/pylint-dev__pylint/setup_pylint-dev__pylint__2.9/pylint/utils/ast_walker.py",
        "start": 1,
        "end": 85,
        "class_name": null,
        "method_name": null,
        "code": "1 # Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n2 # For details: https://github.com/PyCQA/pylint/blob/master/LICENSE\n3 \n4 import collections\n5 \n6 from astroid import nodes\n7 \n8 \n9 class ASTWalker:\n10     def __init__(self, linter):\n11         # callbacks per node types\n12         self.nbstatements = 0\n13         self.visit_events = collections.defaultdict(list)\n14         self.leave_events = collections.defaultdict(list)\n15         self.linter = linter\n16         self.exception_msg = False\n17 \n18     def _is_method_enabled(self, method):\n19         if not hasattr(method, \"checks_msgs\"):\n20             return True\n21         for msg_desc in method.checks_msgs:\n22             if self.linter.is_message_enabled(msg_desc):\n23                 return True\n24         return False\n25 \n26     def add_checker(self, checker):\n27         \"\"\"walk to the checker's dir and collect visit and leave methods\"\"\"\n28         vcids = set()\n29         lcids = set()\n30         visits = self.visit_events\n31         leaves = self.leave_events\n32         for member in dir(checker):\n33             cid = member[6:]\n34             if cid == \"default\":\n35                 continue\n36             if member.startswith(\"visit_\"):\n37                 v_meth = getattr(checker, member)\n38                 # don't use visit_methods with no activated message:\n39                 if self._is_method_enabled(v_meth):\n40                     visits[cid].append(v_meth)\n41                     vcids.add(cid)\n42             elif member.startswith(\"leave_\"):\n43                 l_meth = getattr(checker, member)\n44                 # don't use leave_methods with no activated message:\n45                 if self._is_method_enabled(l_meth):\n46                     leaves[cid].append(l_meth)\n47                     lcids.add(cid)\n48         visit_default = getattr(checker, \"visit_default\", None)\n49         if visit_default:\n50             for cls in nodes.ALL_NODE_CLASSES:\n51                 cid = cls.__name__.lower()\n52                 if cid not in vcids:\n53                     visits[cid].append(visit_default)\n54         # for now we have no \"leave_default\" method in Pylint\n55 \n56     def walk(self, astroid):\n57         \"\"\"call visit events of astroid checkers for the given node, recurse on\n58         its children, then leave events.\n59         \"\"\"\n60         cid = astroid.__class__.__name__.lower()\n61 \n62         # Detect if the node is a new name for a deprecated alias.\n63         # In this case, favour the methods for the deprecated\n64         # alias if any,  in order to maintain backwards\n65         # compatibility.\n66         visit_events = self.visit_events.get(cid, ())\n67         leave_events = self.leave_events.get(cid, ())\n68 \n69         try:\n70             if astroid.is_statement:\n71                 self.nbstatements += 1\n72             # generate events for this node on each checker\n73             for callback in visit_events or ():\n74                 callback(astroid)\n75             # recurse on children\n76             for child in astroid.get_children():\n77                 self.walk(child)\n78             for callback in leave_events or ():\n79                 callback(astroid)\n80         except Exception:\n81             if self.exception_msg is False:\n82                 file = getattr(astroid.root(), \"file\", None)\n83                 print(f\"Exception on node {repr(astroid)} in file '{file}'\")\n84                 self.exception_msg = True\n85             raise\n",
        "intended_behavior": "Since this file is involved in walking the AST, it should ensure that while processing nodes, type hints are appropriately recognized and extracted for use in `pyreverse` diagram generation. This might require adjustments or enhancements to the visitor functions or methods that process specific types of AST nodes related to class and method definitions."
    },
    {
        "rel_file_path": "pylint/lint/pylinter.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/pylint-dev__pylint/setup_pylint-dev__pylint__2.9/pylint/lint/pylinter.py",
        "start": 1,
        "end": 1286,
        "class_name": null,
        "method_name": null,
        "code": "1 # Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n2 # For details: https://github.com/PyCQA/pylint/blob/master/LICENSE\n3 \n4 import collections\n5 import contextlib\n6 import functools\n7 import operator\n8 import os\n9 import sys\n10 import tokenize\n11 import traceback\n12 import warnings\n13 from io import TextIOWrapper\n14 \n15 import astroid\n16 \n17 from pylint import checkers, config, exceptions, interfaces, reporters\n18 from pylint.constants import MAIN_CHECKER_NAME, MSG_TYPES\n19 from pylint.lint.expand_modules import expand_modules\n20 from pylint.lint.parallel import check_parallel\n21 from pylint.lint.report_functions import (\n22     report_messages_by_module_stats,\n23     report_messages_stats,\n24     report_total_messages_stats,\n25 )\n26 from pylint.lint.utils import fix_import_path\n27 from pylint.message import MessageDefinitionStore, MessagesHandlerMixIn\n28 from pylint.reporters.ureports import nodes as report_nodes\n29 from pylint.utils import ASTWalker, FileState, utils\n30 from pylint.utils.pragma_parser import (\n31     OPTION_PO,\n32     InvalidPragmaError,\n33     UnRecognizedOptionError,\n34     parse_pragma,\n35 )\n36 \n37 MANAGER = astroid.MANAGER\n38 \n39 \n40 def _read_stdin():\n41     # https://mail.python.org/pipermail/python-list/2012-November/634424.html\n42     sys.stdin = TextIOWrapper(sys.stdin.detach(), encoding=\"utf-8\")\n43     return sys.stdin.read()\n44 \n45 \n46 def _load_reporter_by_class(reporter_class: str) -> type:\n47     qname = reporter_class\n48     module_part = astroid.modutils.get_module_part(qname)\n49     module = astroid.modutils.load_module_from_name(module_part)\n50     class_name = qname.split(\".\")[-1]\n51     return getattr(module, class_name)\n52 \n53 \n54 # Python Linter class #########################################################\n55 \n56 MSGS = {\n57     \"F0001\": (\n58         \"%s\",\n59         \"fatal\",\n60         \"Used when an error occurred preventing the analysis of a \\\n61               module (unable to find it for instance).\",\n62     ),\n63     \"F0002\": (\n64         \"%s: %s\",\n65         \"astroid-error\",\n66         \"Used when an unexpected error occurred while building the \"\n67         \"Astroid  representation. This is usually accompanied by a \"\n68         \"traceback. Please report such errors !\",\n69     ),\n70     \"F0010\": (\n71         \"error while code parsing: %s\",\n72         \"parse-error\",\n73         \"Used when an exception occurred while building the Astroid \"\n74         \"representation which could be handled by astroid.\",\n75     ),\n76     \"I0001\": (\n77         \"Unable to run raw checkers on built-in module %s\",\n78         \"raw-checker-failed\",\n79         \"Used to inform that a built-in module has not been checked \"\n80         \"using the raw checkers.\",\n81     ),\n82     \"I0010\": (\n83         \"Unable to consider inline option %r\",\n84         \"bad-inline-option\",\n85         \"Used when an inline option is either badly formatted or can't \"\n86         \"be used inside modules.\",\n87     ),\n88     \"I0011\": (\n89         \"Locally disabling %s (%s)\",\n90         \"locally-disabled\",\n91         \"Used when an inline option disables a message or a messages category.\",\n92     ),\n93     \"I0013\": (\n94         \"Ignoring entire file\",\n95         \"file-ignored\",\n96         \"Used to inform that the file will not be checked\",\n97     ),\n98     \"I0020\": (\n99         \"Suppressed %s (from line %d)\",\n100         \"suppressed-message\",\n101         \"A message was triggered on a line, but suppressed explicitly \"\n102         \"by a disable= comment in the file. This message is not \"\n103         \"generated for messages that are ignored due to configuration \"\n104         \"settings.\",\n105     ),\n106     \"I0021\": (\n107         \"Useless suppression of %s\",\n108         \"useless-suppression\",\n109         \"Reported when a message is explicitly disabled for a line or \"\n110         \"a block of code, but never triggered.\",\n111     ),\n112     \"I0022\": (\n113         'Pragma \"%s\" is deprecated, use \"%s\" instead',\n114         \"deprecated-pragma\",\n115         \"Some inline pylint options have been renamed or reworked, \"\n116         \"only the most recent form should be used. \"\n117         \"NOTE:skip-all is only available with pylint >= 0.26\",\n118         {\"old_names\": [(\"I0014\", \"deprecated-disable-all\")]},\n119     ),\n120     \"E0001\": (\"%s\", \"syntax-error\", \"Used when a syntax error is raised for a module.\"),\n121     \"E0011\": (\n122         \"Unrecognized file option %r\",\n123         \"unrecognized-inline-option\",\n124         \"Used when an unknown inline option is encountered.\",\n125     ),\n126     \"E0012\": (\n127         \"Bad option value %r\",\n128         \"bad-option-value\",\n129         \"Used when a bad value for an inline option is encountered.\",\n130     ),\n131     \"E0013\": (\n132         \"Plugin '%s' is impossible to load, is it installed ? ('%s')\",\n133         \"bad-plugin-value\",\n134         \"Used when a bad value is used in 'load-plugins'.\",\n135     ),\n136 }\n137 \n138 \n139 # pylint: disable=too-many-instance-attributes,too-many-public-methods\n140 class PyLinter(\n141     config.OptionsManagerMixIn,\n142     MessagesHandlerMixIn,\n143     reporters.ReportsHandlerMixIn,\n144     checkers.BaseTokenChecker,\n145 ):\n146     \"\"\"lint Python modules using external checkers.\n147 \n148     This is the main checker controlling the other ones and the reports\n149     generation. It is itself both a raw checker and an astroid checker in order\n150     to:\n151     * handle message activation / deactivation at the module level\n152     * handle some basic but necessary stats'data (number of classes, methods...)\n153 \n154     IDE plugin developers: you may have to call\n155     `astroid.builder.MANAGER.astroid_cache.clear()` across runs if you want\n156     to ensure the latest code version is actually checked.\n157 \n158     This class needs to support pickling for parallel linting to work. The exception\n159     is reporter member; see check_parallel function for more details.\n160     \"\"\"\n161 \n162     __implements__ = (interfaces.ITokenChecker,)\n163 \n164     name = MAIN_CHECKER_NAME\n165     priority = 0\n166     level = 0\n167     msgs = MSGS\n168 \n169     @staticmethod\n170     def make_options():\n171         return (\n172             (\n173                 \"ignore\",\n174                 {\n175                     \"type\": \"csv\",\n176                     \"metavar\": \"<file>[,<file>...]\",\n177                     \"dest\": \"black_list\",\n178                     \"default\": (\"CVS\",),\n179                     \"help\": \"Files or directories to be skipped. \"\n180                     \"They should be base names, not paths.\",\n181                 },\n182             ),\n183             (\n184                 \"ignore-patterns\",\n185                 {\n186                     \"type\": \"regexp_csv\",\n187                     \"metavar\": \"<pattern>[,<pattern>...]\",\n188                     \"dest\": \"black_list_re\",\n189                     \"default\": (),\n190                     \"help\": \"Files or directories matching the regex patterns are\"\n191                     \" skipped. The regex matches against base names, not paths.\",\n192                 },\n193             ),\n194             (\n195                 \"ignore-paths\",\n196                 {\n197                     \"type\": \"regexp_csv\",\n198                     \"metavar\": \"<pattern>[,<pattern>...]\",\n199                     \"dest\": \"ignore_list_paths_re\",\n200                     \"default\": (),\n201                     \"help\": \"Add files or directories matching the regex patterns to the\"\n202                     \" ignore-list. The regex matches against paths.\",\n203                 },\n204             ),\n205             (\n206                 \"persistent\",\n207                 {\n208                     \"default\": True,\n209                     \"type\": \"yn\",\n210                     \"metavar\": \"<y_or_n>\",\n211                     \"level\": 1,\n212                     \"help\": \"Pickle collected data for later comparisons.\",\n213                 },\n214             ),\n215             (\n216                 \"load-plugins\",\n217                 {\n218                     \"type\": \"csv\",\n219                     \"metavar\": \"<modules>\",\n220                     \"default\": (),\n221                     \"level\": 1,\n222                     \"help\": \"List of plugins (as comma separated values of \"\n223                     \"python module names) to load, usually to register \"\n224                     \"additional checkers.\",\n225                 },\n226             ),\n227             (\n228                 \"output-format\",\n229                 {\n230                     \"default\": \"text\",\n231                     \"type\": \"string\",\n232                     \"metavar\": \"<format>\",\n233                     \"short\": \"f\",\n234                     \"group\": \"Reports\",\n235                     \"help\": \"Set the output format. Available formats are text,\"\n236                     \" parseable, colorized, json and msvs (visual studio).\"\n237                     \" You can also give a reporter class, e.g. mypackage.mymodule.\"\n238                     \"MyReporterClass.\",\n239                 },\n240             ),\n241             (\n242                 \"reports\",\n243                 {\n244                     \"default\": False,\n245                     \"type\": \"yn\",\n246                     \"metavar\": \"<y_or_n>\",\n247                     \"short\": \"r\",\n248                     \"group\": \"Reports\",\n249                     \"help\": \"Tells whether to display a full report or only the \"\n250                     \"messages.\",\n251                 },\n252             ),\n253             (\n254                 \"evaluation\",\n255                 {\n256                     \"type\": \"string\",\n257                     \"metavar\": \"<python_expression>\",\n258                     \"group\": \"Reports\",\n259                     \"level\": 1,\n260                     \"default\": \"10.0 - ((float(5 * error + warning + refactor + \"\n261                     \"convention) / statement) * 10)\",\n262                     \"help\": \"Python expression which should return a score less \"\n263                     \"than or equal to 10. You have access to the variables \"\n264                     \"'error', 'warning', 'refactor', and 'convention' which \"\n265                     \"contain the number of messages in each category, as well as \"\n266                     \"'statement' which is the total number of statements \"\n267                     \"analyzed. This score is used by the global \"\n268                     \"evaluation report (RP0004).\",\n269                 },\n270             ),\n271             (\n272                 \"score\",\n273                 {\n274                     \"default\": True,\n275                     \"type\": \"yn\",\n276                     \"metavar\": \"<y_or_n>\",\n277                     \"short\": \"s\",\n278                     \"group\": \"Reports\",\n279                     \"help\": \"Activate the evaluation score.\",\n280                 },\n281             ),\n282             (\n283                 \"fail-under\",\n284                 {\n285                     \"default\": 10,\n286                     \"type\": \"float\",\n287                     \"metavar\": \"<score>\",\n288                     \"help\": \"Specify a score threshold to be exceeded before program exits with error.\",\n289                 },\n290             ),\n291             (\n292                 \"fail-on\",\n293                 {\n294                     \"default\": \"\",\n295                     \"type\": \"csv\",\n296                     \"metavar\": \"<msg ids>\",\n297                     \"help\": \"Return non-zero exit code if any of these messages/categories are detected,\"\n298                     \" even if score is above --fail-under value. Syntax same as enable.\"\n299                     \" Messages specified are enabled, while categories only check already-enabled messages.\",\n300                 },\n301             ),\n302             (\n303                 \"confidence\",\n304                 {\n305                     \"type\": \"multiple_choice\",\n306                     \"metavar\": \"<levels>\",\n307                     \"default\": \"\",\n308                     \"choices\": [c.name for c in interfaces.CONFIDENCE_LEVELS],\n309                     \"group\": \"Messages control\",\n310                     \"help\": \"Only show warnings with the listed confidence levels.\"\n311                     \" Leave empty to show all. Valid levels: %s.\"\n312                     % (\", \".join(c.name for c in interfaces.CONFIDENCE_LEVELS),),\n313                 },\n314             ),\n315             (\n316                 \"enable\",\n317                 {\n318                     \"type\": \"csv\",\n319                     \"metavar\": \"<msg ids>\",\n320                     \"short\": \"e\",\n321                     \"group\": \"Messages control\",\n322                     \"help\": \"Enable the message, report, category or checker with the \"\n323                     \"given id(s). You can either give multiple identifier \"\n324                     \"separated by comma (,) or put this option multiple time \"\n325                     \"(only on the command line, not in the configuration file \"\n326                     \"where it should appear only once). \"\n327                     'See also the \"--disable\" option for examples.',\n328                 },\n329             ),\n330             (\n331                 \"disable\",\n332                 {\n333                     \"type\": \"csv\",\n334                     \"metavar\": \"<msg ids>\",\n335                     \"short\": \"d\",\n336                     \"group\": \"Messages control\",\n337                     \"help\": \"Disable the message, report, category or checker \"\n338                     \"with the given id(s). You can either give multiple identifiers \"\n339                     \"separated by comma (,) or put this option multiple times \"\n340                     \"(only on the command line, not in the configuration file \"\n341                     \"where it should appear only once). \"\n342                     'You can also use \"--disable=all\" to disable everything first '\n343                     \"and then reenable specific checks. For example, if you want \"\n344                     \"to run only the similarities checker, you can use \"\n345                     '\"--disable=all --enable=similarities\". '\n346                     \"If you want to run only the classes checker, but have no \"\n347                     \"Warning level messages displayed, use \"\n348                     '\"--disable=all --enable=classes --disable=W\".',\n349                 },\n350             ),\n351             (\n352                 \"msg-template\",\n353                 {\n354                     \"type\": \"string\",\n355                     \"metavar\": \"<template>\",\n356                     \"group\": \"Reports\",\n357                     \"help\": (\n358                         \"Template used to display messages. \"\n359                         \"This is a python new-style format string \"\n360                         \"used to format the message information. \"\n361                         \"See doc for all details.\"\n362                     ),\n363                 },\n364             ),\n365             (\n366                 \"jobs\",\n367                 {\n368                     \"type\": \"int\",\n369                     \"metavar\": \"<n-processes>\",\n370                     \"short\": \"j\",\n371                     \"default\": 1,\n372                     \"help\": \"Use multiple processes to speed up Pylint. Specifying 0 will \"\n373                     \"auto-detect the number of processors available to use.\",\n374                 },\n375             ),\n376             (\n377                 \"unsafe-load-any-extension\",\n378                 {\n379                     \"type\": \"yn\",\n380                     \"metavar\": \"<yn>\",\n381                     \"default\": False,\n382                     \"hide\": True,\n383                     \"help\": (\n384                         \"Allow loading of arbitrary C extensions. Extensions\"\n385                         \" are imported into the active Python interpreter and\"\n386                         \" may run arbitrary code.\"\n387                     ),\n388                 },\n389             ),\n390             (\n391                 \"limit-inference-results\",\n392                 {\n393                     \"type\": \"int\",\n394                     \"metavar\": \"<number-of-results>\",\n395                     \"default\": 100,\n396                     \"help\": (\n397                         \"Control the amount of potential inferred values when inferring \"\n398                         \"a single object. This can help the performance when dealing with \"\n399                         \"large functions or complex, nested conditions. \"\n400                     ),\n401                 },\n402             ),\n403             (\n404                 \"extension-pkg-allow-list\",\n405                 {\n406                     \"type\": \"csv\",\n407                     \"metavar\": \"<pkg[,pkg]>\",\n408                     \"default\": [],\n409                     \"help\": (\n410                         \"A comma-separated list of package or module names\"\n411                         \" from where C extensions may be loaded. Extensions are\"\n412                         \" loading into the active Python interpreter and may run\"\n413                         \" arbitrary code.\"\n414                     ),\n415                 },\n416             ),\n417             (\n418                 \"extension-pkg-whitelist\",\n419                 {\n420                     \"type\": \"csv\",\n421                     \"metavar\": \"<pkg[,pkg]>\",\n422                     \"default\": [],\n423                     \"help\": (\n424                         \"A comma-separated list of package or module names\"\n425                         \" from where C extensions may be loaded. Extensions are\"\n426                         \" loading into the active Python interpreter and may run\"\n427                         \" arbitrary code. (This is an alternative name to\"\n428                         \" extension-pkg-allow-list for backward compatibility.)\"\n429                     ),\n430                 },\n431             ),\n432             (\n433                 \"suggestion-mode\",\n434                 {\n435                     \"type\": \"yn\",\n436                     \"metavar\": \"<yn>\",\n437                     \"default\": True,\n438                     \"help\": (\n439                         \"When enabled, pylint would attempt to guess common \"\n440                         \"misconfiguration and emit user-friendly hints instead \"\n441                         \"of false-positive error messages.\"\n442                     ),\n443                 },\n444             ),\n445             (\n446                 \"exit-zero\",\n447                 {\n448                     \"action\": \"store_true\",\n449                     \"help\": (\n450                         \"Always return a 0 (non-error) status code, even if \"\n451                         \"lint errors are found. This is primarily useful in \"\n452                         \"continuous integration scripts.\"\n453                     ),\n454                 },\n455             ),\n456             (\n457                 \"from-stdin\",\n458                 {\n459                     \"action\": \"store_true\",\n460                     \"help\": (\n461                         \"Interpret the stdin as a python script, whose filename \"\n462                         \"needs to be passed as the module_or_package argument.\"\n463                     ),\n464                 },\n465             ),\n466         )\n467 \n468     option_groups = (\n469         (\"Messages control\", \"Options controlling analysis messages\"),\n470         (\"Reports\", \"Options related to output formatting and reporting\"),\n471     )\n472 \n473     def __init__(self, options=(), reporter=None, option_groups=(), pylintrc=None):\n474         \"\"\"Some stuff has to be done before ancestors initialization...\n475         messages store / checkers / reporter / astroid manager\"\"\"\n476         self.msgs_store = MessageDefinitionStore()\n477         self.reporter = None\n478         self._reporter_names = None\n479         self._reporters = {}\n480         self._checkers = collections.defaultdict(list)\n481         self._pragma_lineno = {}\n482         self._ignore_file = False\n483         # visit variables\n484         self.file_state = FileState()\n485         self.current_name = None\n486         self.current_file = None\n487         self.stats = None\n488         self.fail_on_symbols = []\n489         # init options\n490         self._external_opts = options\n491         self.options = options + PyLinter.make_options()\n492         self.option_groups = option_groups + PyLinter.option_groups\n493         self._options_methods = {\"enable\": self.enable, \"disable\": self.disable}\n494         self._bw_options_methods = {\n495             \"disable-msg\": self._options_methods[\"disable\"],\n496             \"enable-msg\": self._options_methods[\"enable\"],\n497         }\n498         MessagesHandlerMixIn.__init__(self)\n499         reporters.ReportsHandlerMixIn.__init__(self)\n500         super().__init__(\n501             usage=__doc__,\n502             config_file=pylintrc or next(config.find_default_config_files(), None),\n503         )\n504         checkers.BaseTokenChecker.__init__(self)\n505         # provided reports\n506         self.reports = (\n507             (\"RP0001\", \"Messages by category\", report_total_messages_stats),\n508             (\n509                 \"RP0002\",\n510                 \"% errors / warnings by module\",\n511                 report_messages_by_module_stats,\n512             ),\n513             (\"RP0003\", \"Messages\", report_messages_stats),\n514         )\n515         self.register_checker(self)\n516         self._dynamic_plugins = set()\n517         self._python3_porting_mode = False\n518         self._error_mode = False\n519         self.load_provider_defaults()\n520         if reporter:\n521             self.set_reporter(reporter)\n522 \n523     def load_default_plugins(self):\n524         checkers.initialize(self)\n525         reporters.initialize(self)\n526         # Make sure to load the default reporter, because\n527         # the option has been set before the plugins had been loaded.\n528         if not self.reporter:\n529             self._load_reporters()\n530 \n531     def load_plugin_modules(self, modnames):\n532         \"\"\"take a list of module names which are pylint plugins and load\n533         and register them\n534         \"\"\"\n535         for modname in modnames:\n536             if modname in self._dynamic_plugins:\n537                 continue\n538             self._dynamic_plugins.add(modname)\n539             try:\n540                 module = astroid.modutils.load_module_from_name(modname)\n541                 module.register(self)\n542             except ModuleNotFoundError:\n543                 pass\n544 \n545     def load_plugin_configuration(self):\n546         \"\"\"Call the configuration hook for plugins\n547 \n548         This walks through the list of plugins, grabs the \"load_configuration\"\n549         hook, if exposed, and calls it to allow plugins to configure specific\n550         settings.\n551         \"\"\"\n552         for modname in self._dynamic_plugins:\n553             try:\n554                 module = astroid.modutils.load_module_from_name(modname)\n555                 if hasattr(module, \"load_configuration\"):\n556                     module.load_configuration(self)\n557             except ModuleNotFoundError as e:\n558                 self.add_message(\"bad-plugin-value\", args=(modname, e), line=0)\n559 \n560     def _load_reporters(self) -> None:\n561         sub_reporters = []\n562         output_files = []\n563         with contextlib.ExitStack() as stack:\n564             for reporter_name in self._reporter_names.split(\",\"):\n565                 reporter_name, *reporter_output = reporter_name.split(\":\", 1)\n566 \n567                 reporter = self._load_reporter_by_name(reporter_name)\n568                 sub_reporters.append(reporter)\n569 \n570                 if reporter_output:\n571                     (reporter_output,) = reporter_output\n572 \n573                     # pylint: disable=consider-using-with\n574                     output_file = stack.enter_context(open(reporter_output, \"w\"))\n575 \n576                     reporter.set_output(output_file)\n577                     output_files.append(output_file)\n578 \n579             # Extend the lifetime of all opened output files\n580             close_output_files = stack.pop_all().close\n581 \n582         if len(sub_reporters) > 1 or output_files:\n583             self.set_reporter(\n584                 reporters.MultiReporter(\n585                     sub_reporters,\n586                     close_output_files,\n587                 )\n588             )\n589         else:\n590             self.set_reporter(sub_reporters[0])\n591 \n592     def _load_reporter_by_name(self, reporter_name: str) -> reporters.BaseReporter:\n593         name = reporter_name.lower()\n594         if name in self._reporters:\n595             return self._reporters[name]()\n596 \n597         try:\n598             reporter_class = _load_reporter_by_class(reporter_name)\n599         except (ImportError, AttributeError) as e:\n600             raise exceptions.InvalidReporterError(name) from e\n601         else:\n602             return reporter_class()\n603 \n604     def set_reporter(self, reporter):\n605         \"\"\"set the reporter used to display messages and reports\"\"\"\n606         self.reporter = reporter\n607         reporter.linter = self\n608 \n609     def set_option(self, optname, value, action=None, optdict=None):\n610         \"\"\"overridden from config.OptionsProviderMixin to handle some\n611         special options\n612         \"\"\"\n613         if optname in self._options_methods or optname in self._bw_options_methods:\n614             if value:\n615                 try:\n616                     meth = self._options_methods[optname]\n617                 except KeyError:\n618                     meth = self._bw_options_methods[optname]\n619                     warnings.warn(\n620                         \"%s is deprecated, replace it by %s\"\n621                         % (optname, optname.split(\"-\")[0]),\n622                         DeprecationWarning,\n623                     )\n624                 value = utils._check_csv(value)\n625                 if isinstance(value, (list, tuple)):\n626                     for _id in value:\n627                         meth(_id, ignore_unknown=True)\n628                 else:\n629                     meth(value)\n630                 return  # no need to call set_option, disable/enable methods do it\n631         elif optname == \"output-format\":\n632             self._reporter_names = value\n633             # If the reporters are already available, load\n634             # the reporter class.\n635             if self._reporters:\n636                 self._load_reporters()\n637 \n638         try:\n639             checkers.BaseTokenChecker.set_option(self, optname, value, action, optdict)\n640         except config.UnsupportedAction:\n641             print(\"option %s can't be read from config file\" % optname, file=sys.stderr)\n642 \n643     def register_reporter(self, reporter_class):\n644         self._reporters[reporter_class.name] = reporter_class\n645 \n646     def report_order(self):\n647         reports = sorted(self._reports, key=lambda x: getattr(x, \"name\", \"\"))\n648         try:\n649             # Remove the current reporter and add it\n650             # at the end of the list.\n651             reports.pop(reports.index(self))\n652         except ValueError:\n653             pass\n654         else:\n655             reports.append(self)\n656         return reports\n657 \n658     # checkers manipulation methods ############################################\n659 \n660     def register_checker(self, checker):\n661         \"\"\"register a new checker\n662 \n663         checker is an object implementing IRawChecker or / and IAstroidChecker\n664         \"\"\"\n665         assert checker.priority <= 0, \"checker priority can't be >= 0\"\n666         self._checkers[checker.name].append(checker)\n667         for r_id, r_title, r_cb in checker.reports:\n668             self.register_report(r_id, r_title, r_cb, checker)\n669         self.register_options_provider(checker)\n670         if hasattr(checker, \"msgs\"):\n671             self.msgs_store.register_messages_from_checker(checker)\n672         checker.load_defaults()\n673 \n674         # Register the checker, but disable all of its messages.\n675         if not getattr(checker, \"enabled\", True):\n676             self.disable(checker.name)\n677 \n678     def enable_fail_on_messages(self):\n679         \"\"\"enable 'fail on' msgs\n680 \n681         Convert values in config.fail_on (which might be msg category, msg id,\n682         or symbol) to specific msgs, then enable and flag them for later.\n683         \"\"\"\n684         fail_on_vals = self.config.fail_on\n685         if not fail_on_vals:\n686             return\n687 \n688         fail_on_cats = set()\n689         fail_on_msgs = set()\n690         for val in fail_on_vals:\n691             # If value is a cateogry, add category, else add message\n692             if val in MSG_TYPES:\n693                 fail_on_cats.add(val)\n694             else:\n695                 fail_on_msgs.add(val)\n696 \n697         # For every message in every checker, if cat or msg flagged, enable check\n698         for all_checkers in self._checkers.values():\n699             for checker in all_checkers:\n700                 for msg in checker.messages:\n701                     if msg.msgid in fail_on_msgs or msg.symbol in fail_on_msgs:\n702                         # message id/symbol matched, enable and flag it\n703                         self.enable(msg.msgid)\n704                         self.fail_on_symbols.append(msg.symbol)\n705                     elif msg.msgid[0] in fail_on_cats:\n706                         # message starts with a cateogry value, flag (but do not enable) it\n707                         self.fail_on_symbols.append(msg.symbol)\n708 \n709     def any_fail_on_issues(self):\n710         return any(x in self.fail_on_symbols for x in self.stats[\"by_msg\"])\n711 \n712     def disable_noerror_messages(self):\n713         for msgcat, msgids in self.msgs_store._msgs_by_category.items():\n714             # enable only messages with 'error' severity and above ('fatal')\n715             if msgcat in [\"E\", \"F\"]:\n716                 for msgid in msgids:\n717                     self.enable(msgid)\n718             else:\n719                 for msgid in msgids:\n720                     self.disable(msgid)\n721 \n722     def disable_reporters(self):\n723         \"\"\"disable all reporters\"\"\"\n724         for _reporters in self._reports.values():\n725             for report_id, _, _ in _reporters:\n726                 self.disable_report(report_id)\n727 \n728     def error_mode(self):\n729         \"\"\"error mode: enable only errors; no reports, no persistent\"\"\"\n730         self._error_mode = True\n731         self.disable_noerror_messages()\n732         self.disable(\"miscellaneous\")\n733         if self._python3_porting_mode:\n734             self.disable(\"all\")\n735             for msg_id in self._checker_messages(\"python3\"):\n736                 if msg_id.startswith(\"E\"):\n737                     self.enable(msg_id)\n738             config_parser = self.cfgfile_parser\n739             if config_parser.has_option(\"MESSAGES CONTROL\", \"disable\"):\n740                 value = config_parser.get(\"MESSAGES CONTROL\", \"disable\")\n741                 self.global_set_option(\"disable\", value)\n742         else:\n743             self.disable(\"python3\")\n744         self.set_option(\"reports\", False)\n745         self.set_option(\"persistent\", False)\n746         self.set_option(\"score\", False)\n747 \n748     def python3_porting_mode(self):\n749         \"\"\"Disable all other checkers and enable Python 3 warnings.\"\"\"\n750         self.disable(\"all\")\n751         # re-enable some errors, or 'print', 'raise', 'async', 'await' will mistakenly lint fine\n752         self.enable(\"fatal\")  # F0001\n753         self.enable(\"astroid-error\")  # F0002\n754         self.enable(\"parse-error\")  # F0010\n755         self.enable(\"syntax-error\")  # E0001\n756         self.enable(\"python3\")\n757         if self._error_mode:\n758             # The error mode was activated, using the -E flag.\n759             # So we'll need to enable only the errors from the\n760             # Python 3 porting checker.\n761             for msg_id in self._checker_messages(\"python3\"):\n762                 if msg_id.startswith(\"E\"):\n763                     self.enable(msg_id)\n764                 else:\n765                     self.disable(msg_id)\n766         config_parser = self.cfgfile_parser\n767         if config_parser.has_option(\"MESSAGES CONTROL\", \"disable\"):\n768             value = config_parser.get(\"MESSAGES CONTROL\", \"disable\")\n769             self.global_set_option(\"disable\", value)\n770         self._python3_porting_mode = True\n771 \n772     def list_messages_enabled(self):\n773         enabled = [\n774             f\"  {message.symbol} ({message.msgid})\"\n775             for message in self.msgs_store.messages\n776             if self.is_message_enabled(message.msgid)\n777         ]\n778         disabled = [\n779             f\"  {message.symbol} ({message.msgid})\"\n780             for message in self.msgs_store.messages\n781             if not self.is_message_enabled(message.msgid)\n782         ]\n783         print(\"Enabled messages:\")\n784         for msg in sorted(enabled):\n785             print(msg)\n786         print(\"\\nDisabled messages:\")\n787         for msg in sorted(disabled):\n788             print(msg)\n789         print(\"\")\n790 \n791     # block level option handling #############################################\n792     # see func_block_disable_msg.py test case for expected behaviour\n793 \n794     def process_tokens(self, tokens):\n795         \"\"\"Process tokens from the current module to search for module/block level\n796         options.\"\"\"\n797         control_pragmas = {\"disable\", \"enable\"}\n798         prev_line = None\n799         saw_newline = True\n800         seen_newline = True\n801         for (tok_type, content, start, _, _) in tokens:\n802             if prev_line and prev_line != start[0]:\n803                 saw_newline = seen_newline\n804                 seen_newline = False\n805 \n806             prev_line = start[0]\n807             if tok_type in (tokenize.NL, tokenize.NEWLINE):\n808                 seen_newline = True\n809 \n810             if tok_type != tokenize.COMMENT:\n811                 continue\n812             match = OPTION_PO.search(content)\n813             if match is None:\n814                 continue\n815             try:\n816                 for pragma_repr in parse_pragma(match.group(2)):\n817                     if pragma_repr.action in (\"disable-all\", \"skip-file\"):\n818                         if pragma_repr.action == \"disable-all\":\n819                             self.add_message(\n820                                 \"deprecated-pragma\",\n821                                 line=start[0],\n822                                 args=(\"disable-all\", \"skip-file\"),\n823                             )\n824                         self.add_message(\"file-ignored\", line=start[0])\n825                         self._ignore_file = True\n826                         return\n827                     try:\n828                         meth = self._options_methods[pragma_repr.action]\n829                     except KeyError:\n830                         meth = self._bw_options_methods[pragma_repr.action]\n831                         # found a \"(dis|en)able-msg\" pragma deprecated suppression\n832                         self.add_message(\n833                             \"deprecated-pragma\",\n834                             line=start[0],\n835                             args=(\n836                                 pragma_repr.action,\n837                                 pragma_repr.action.replace(\"-msg\", \"\"),\n838                             ),\n839                         )\n840                     for msgid in pragma_repr.messages:\n841                         # Add the line where a control pragma was encountered.\n842                         if pragma_repr.action in control_pragmas:\n843                             self._pragma_lineno[msgid] = start[0]\n844 \n845                         if (pragma_repr.action, msgid) == (\"disable\", \"all\"):\n846                             self.add_message(\n847                                 \"deprecated-pragma\",\n848                                 line=start[0],\n849                                 args=(\"disable=all\", \"skip-file\"),\n850                             )\n851                             self.add_message(\"file-ignored\", line=start[0])\n852                             self._ignore_file = True\n853                             return\n854                             # If we did not see a newline between the previous line and now,\n855                             # we saw a backslash so treat the two lines as one.\n856                         l_start = start[0]\n857                         if not saw_newline:\n858                             l_start -= 1\n859                         try:\n860                             meth(msgid, \"module\", l_start)\n861                         except exceptions.UnknownMessageError:\n862                             self.add_message(\n863                                 \"bad-option-value\", args=msgid, line=start[0]\n864                             )\n865             except UnRecognizedOptionError as err:\n866                 self.add_message(\n867                     \"unrecognized-inline-option\", args=err.token, line=start[0]\n868                 )\n869                 continue\n870             except InvalidPragmaError as err:\n871                 self.add_message(\"bad-inline-option\", args=err.token, line=start[0])\n872                 continue\n873 \n874     # code checking methods ###################################################\n875 \n876     def get_checkers(self):\n877         \"\"\"return all available checkers as a list\"\"\"\n878         return [self] + [\n879             c\n880             for _checkers in self._checkers.values()\n881             for c in _checkers\n882             if c is not self\n883         ]\n884 \n885     def get_checker_names(self):\n886         \"\"\"Get all the checker names that this linter knows about.\"\"\"\n887         current_checkers = self.get_checkers()\n888         return sorted(\n889             {\n890                 checker.name\n891                 for checker in current_checkers\n892                 if checker.name != MAIN_CHECKER_NAME\n893             }\n894         )\n895 \n896     def prepare_checkers(self):\n897         \"\"\"return checkers needed for activated messages and reports\"\"\"\n898         if not self.config.reports:\n899             self.disable_reporters()\n900         # get needed checkers\n901         needed_checkers = [self]\n902         for checker in self.get_checkers()[1:]:\n903             messages = {msg for msg in checker.msgs if self.is_message_enabled(msg)}\n904             if messages or any(self.report_is_enabled(r[0]) for r in checker.reports):\n905                 needed_checkers.append(checker)\n906         # Sort checkers by priority\n907         needed_checkers = sorted(\n908             needed_checkers, key=operator.attrgetter(\"priority\"), reverse=True\n909         )\n910         return needed_checkers\n911 \n912     # pylint: disable=unused-argument\n913     @staticmethod\n914     def should_analyze_file(modname, path, is_argument=False):\n915         \"\"\"Returns whether or not a module should be checked.\n916 \n917         This implementation returns True for all python source file, indicating\n918         that all files should be linted.\n919 \n920         Subclasses may override this method to indicate that modules satisfying\n921         certain conditions should not be linted.\n922 \n923         :param str modname: The name of the module to be checked.\n924         :param str path: The full path to the source code of the module.\n925         :param bool is_argument: Whether the file is an argument to pylint or not.\n926                                  Files which respect this property are always\n927                                  checked, since the user requested it explicitly.\n928         :returns: True if the module should be checked.\n929         :rtype: bool\n930         \"\"\"\n931         if is_argument:\n932             return True\n933         return path.endswith(\".py\")\n934 \n935     # pylint: enable=unused-argument\n936 \n937     def initialize(self):\n938         \"\"\"Initialize linter for linting\n939 \n940         This method is called before any linting is done.\n941         \"\"\"\n942         # initialize msgs_state now that all messages have been registered into\n943         # the store\n944         for msg in self.msgs_store.messages:\n945             if not msg.may_be_emitted():\n946                 self._msgs_state[msg.msgid] = False\n947 \n948     def check(self, files_or_modules):\n949         \"\"\"main checking entry: check a list of files or modules from their name.\n950 \n951         files_or_modules is either a string or list of strings presenting modules to check.\n952         \"\"\"\n953 \n954         self.initialize()\n955 \n956         if not isinstance(files_or_modules, (list, tuple)):\n957             files_or_modules = (files_or_modules,)\n958 \n959         if self.config.from_stdin:\n960             if len(files_or_modules) != 1:\n961                 raise exceptions.InvalidArgsError(\n962                     \"Missing filename required for --from-stdin\"\n963                 )\n964 \n965             filepath = files_or_modules[0]\n966             with fix_import_path(files_or_modules):\n967                 self._check_files(\n968                     functools.partial(self.get_ast, data=_read_stdin()),\n969                     [self._get_file_descr_from_stdin(filepath)],\n970                 )\n971         elif self.config.jobs == 1:\n972             with fix_import_path(files_or_modules):\n973                 self._check_files(\n974                     self.get_ast, self._iterate_file_descrs(files_or_modules)\n975                 )\n976         else:\n977             check_parallel(\n978                 self,\n979                 self.config.jobs,\n980                 self._iterate_file_descrs(files_or_modules),\n981                 files_or_modules,\n982             )\n983 \n984     def check_single_file(self, name, filepath, modname):\n985         \"\"\"Check single file\n986 \n987         The arguments are the same that are documented in _check_files\n988 \n989         The initialize() method should be called before calling this method\n990         \"\"\"\n991         with self._astroid_module_checker() as check_astroid_module:\n992             self._check_file(\n993                 self.get_ast, check_astroid_module, name, filepath, modname\n994             )\n995 \n996     def _check_files(self, get_ast, file_descrs):\n997         \"\"\"Check all files from file_descrs\n998 \n999         The file_descrs should be iterable of tuple (name, filepath, modname)\n1000         where\n1001         - name: full name of the module\n1002         - filepath: path of the file\n1003         - modname: module name\n1004         \"\"\"\n1005         with self._astroid_module_checker() as check_astroid_module:\n1006             for name, filepath, modname in file_descrs:\n1007                 self._check_file(get_ast, check_astroid_module, name, filepath, modname)\n1008 \n1009     def _check_file(self, get_ast, check_astroid_module, name, filepath, modname):\n1010         \"\"\"Check a file using the passed utility functions (get_ast and check_astroid_module)\n1011 \n1012         :param callable get_ast: callable returning AST from defined file taking the following arguments\n1013         - filepath: path to the file to check\n1014         - name: Python module name\n1015         :param callable check_astroid_module: callable checking an AST taking the following arguments\n1016         - ast: AST of the module\n1017         :param str name: full name of the module\n1018         :param str filepath: path to checked file\n1019         :param str modname: name of the checked Python module\n1020         \"\"\"\n1021         self.set_current_module(name, filepath)\n1022         # get the module representation\n1023         ast_node = get_ast(filepath, name)\n1024         if ast_node is None:\n1025             return\n1026 \n1027         self._ignore_file = False\n1028 \n1029         self.file_state = FileState(modname)\n1030         # fix the current file (if the source file was not available or\n1031         # if it's actually a c extension)\n1032         self.current_file = ast_node.file  # pylint: disable=maybe-no-member\n1033         check_astroid_module(ast_node)\n1034         # warn about spurious inline messages handling\n1035         spurious_messages = self.file_state.iter_spurious_suppression_messages(\n1036             self.msgs_store\n1037         )\n1038         for msgid, line, args in spurious_messages:\n1039             self.add_message(msgid, line, None, args)\n1040 \n1041     @staticmethod\n1042     def _get_file_descr_from_stdin(filepath):\n1043         \"\"\"Return file description (tuple of module name, file path, base name) from given file path\n1044 \n1045         This method is used for creating suitable file description for _check_files when the\n1046         source is standard input.\n1047         \"\"\"\n1048         try:\n1049             # Note that this function does not really perform an\n1050             # __import__ but may raise an ImportError exception, which\n1051             # we want to catch here.\n1052             modname = \".\".join(astroid.modutils.modpath_from_file(filepath))\n1053         except ImportError:\n1054             modname = os.path.splitext(os.path.basename(filepath))[0]\n1055 \n1056         return (modname, filepath, filepath)\n1057 \n1058     def _iterate_file_descrs(self, files_or_modules):\n1059         \"\"\"Return generator yielding file descriptions (tuples of module name, file path, base name)\n1060 \n1061         The returned generator yield one item for each Python module that should be linted.\n1062         \"\"\"\n1063         for descr in self._expand_files(files_or_modules):\n1064             name, filepath, is_arg = descr[\"name\"], descr[\"path\"], descr[\"isarg\"]\n1065             if self.should_analyze_file(name, filepath, is_argument=is_arg):\n1066                 yield (name, filepath, descr[\"basename\"])\n1067 \n1068     def _expand_files(self, modules):\n1069         \"\"\"get modules and errors from a list of modules and handle errors\"\"\"\n1070         result, errors = expand_modules(\n1071             modules,\n1072             self.config.black_list,\n1073             self.config.black_list_re,\n1074             self.config.ignore_list_paths_re,\n1075         )\n1076         for error in errors:\n1077             message = modname = error[\"mod\"]\n1078             key = error[\"key\"]\n1079             self.set_current_module(modname)\n1080             if key == \"fatal\":\n1081                 message = str(error[\"ex\"]).replace(os.getcwd() + os.sep, \"\")\n1082             self.add_message(key, args=message)\n1083         return result\n1084 \n1085     def set_current_module(self, modname, filepath=None):\n1086         \"\"\"set the name of the currently analyzed module and\n1087         init statistics for it\n1088         \"\"\"\n1089         if not modname and filepath is None:\n1090             return\n1091         self.reporter.on_set_current_module(modname, filepath)\n1092         self.current_name = modname\n1093         self.current_file = filepath or modname\n1094         self.stats[\"by_module\"][modname] = {}\n1095         self.stats[\"by_module\"][modname][\"statement\"] = 0\n1096         for msg_cat in MSG_TYPES.values():\n1097             self.stats[\"by_module\"][modname][msg_cat] = 0\n1098 \n1099     @contextlib.contextmanager\n1100     def _astroid_module_checker(self):\n1101         \"\"\"Context manager for checking ASTs\n1102 \n1103         The value in the context is callable accepting AST as its only argument.\n1104         \"\"\"\n1105         walker = ASTWalker(self)\n1106         _checkers = self.prepare_checkers()\n1107         tokencheckers = [\n1108             c\n1109             for c in _checkers\n1110             if interfaces.implements(c, interfaces.ITokenChecker) and c is not self\n1111         ]\n1112         rawcheckers = [\n1113             c for c in _checkers if interfaces.implements(c, interfaces.IRawChecker)\n1114         ]\n1115         # notify global begin\n1116         for checker in _checkers:\n1117             checker.open()\n1118             if interfaces.implements(checker, interfaces.IAstroidChecker):\n1119                 walker.add_checker(checker)\n1120 \n1121         yield functools.partial(\n1122             self.check_astroid_module,\n1123             walker=walker,\n1124             tokencheckers=tokencheckers,\n1125             rawcheckers=rawcheckers,\n1126         )\n1127 \n1128         # notify global end\n1129         self.stats[\"statement\"] = walker.nbstatements\n1130         for checker in reversed(_checkers):\n1131             checker.close()\n1132 \n1133     def get_ast(self, filepath, modname, data=None):\n1134         \"\"\"Return an ast(roid) representation of a module or a string.\n1135 \n1136         :param str filepath: path to checked file.\n1137         :param str modname: The name of the module to be checked.\n1138         :param str data: optional contents of the checked file.\n1139         :returns: the AST\n1140         :rtype: astroid.nodes.Module\n1141         \"\"\"\n1142         try:\n1143             if data is None:\n1144                 return MANAGER.ast_from_file(filepath, modname, source=True)\n1145             return astroid.builder.AstroidBuilder(MANAGER).string_build(\n1146                 data, modname, filepath\n1147             )\n1148         except astroid.AstroidSyntaxError as ex:\n1149             # pylint: disable=no-member\n1150             self.add_message(\n1151                 \"syntax-error\",\n1152                 line=getattr(ex.error, \"lineno\", 0),\n1153                 col_offset=getattr(ex.error, \"offset\", None),\n1154                 args=str(ex.error),\n1155             )\n1156         except astroid.AstroidBuildingException as ex:\n1157             self.add_message(\"parse-error\", args=ex)\n1158         except Exception as ex:  # pylint: disable=broad-except\n1159             traceback.print_exc()\n1160             self.add_message(\"astroid-error\", args=(ex.__class__, ex))\n1161         return None\n1162 \n1163     def check_astroid_module(self, ast_node, walker, rawcheckers, tokencheckers):\n1164         \"\"\"Check a module from its astroid representation.\n1165 \n1166         For return value see _check_astroid_module\n1167         \"\"\"\n1168         before_check_statements = walker.nbstatements\n1169 \n1170         retval = self._check_astroid_module(\n1171             ast_node, walker, rawcheckers, tokencheckers\n1172         )\n1173 \n1174         self.stats[\"by_module\"][self.current_name][\"statement\"] = (\n1175             walker.nbstatements - before_check_statements\n1176         )\n1177 \n1178         return retval\n1179 \n1180     def _check_astroid_module(self, ast_node, walker, rawcheckers, tokencheckers):\n1181         \"\"\"Check given AST node with given walker and checkers\n1182 \n1183         :param astroid.nodes.Module ast_node: AST node of the module to check\n1184         :param pylint.utils.ast_walker.ASTWalker walker: AST walker\n1185         :param list rawcheckers: List of token checkers to use\n1186         :param list tokencheckers: List of raw checkers to use\n1187 \n1188         :returns: True if the module was checked, False if ignored,\n1189             None if the module contents could not be parsed\n1190         :rtype: bool\n1191         \"\"\"\n1192         try:\n1193             tokens = utils.tokenize_module(ast_node)\n1194         except tokenize.TokenError as ex:\n1195             self.add_message(\"syntax-error\", line=ex.args[1][0], args=ex.args[0])\n1196             return None\n1197 \n1198         if not ast_node.pure_python:\n1199             self.add_message(\"raw-checker-failed\", args=ast_node.name)\n1200         else:\n1201             # assert astroid.file.endswith('.py')\n1202             # invoke ITokenChecker interface on self to fetch module/block\n1203             # level options\n1204             self.process_tokens(tokens)\n1205             if self._ignore_file:\n1206                 return False\n1207             # walk ast to collect line numbers\n1208             self.file_state.collect_block_lines(self.msgs_store, ast_node)\n1209             # run raw and tokens checkers\n1210             for checker in rawcheckers:\n1211                 checker.process_module(ast_node)\n1212             for checker in tokencheckers:\n1213                 checker.process_tokens(tokens)\n1214         # generate events to astroid checkers\n1215         walker.walk(ast_node)\n1216         return True\n1217 \n1218     # IAstroidChecker interface #################################################\n1219 \n1220     def open(self):\n1221         \"\"\"initialize counters\"\"\"\n1222         self.stats = {\"by_module\": {}, \"by_msg\": {}}\n1223         MANAGER.always_load_extensions = self.config.unsafe_load_any_extension\n1224         MANAGER.max_inferable_values = self.config.limit_inference_results\n1225         MANAGER.extension_package_whitelist.update(self.config.extension_pkg_allow_list)\n1226         if self.config.extension_pkg_whitelist:\n1227             MANAGER.extension_package_whitelist.update(\n1228                 self.config.extension_pkg_whitelist\n1229             )\n1230         for msg_cat in MSG_TYPES.values():\n1231             self.stats[msg_cat] = 0\n1232 \n1233     def generate_reports(self):\n1234         \"\"\"close the whole package /module, it's time to make reports !\n1235 \n1236         if persistent run, pickle results for later comparison\n1237         \"\"\"\n1238         # Display whatever messages are left on the reporter.\n1239         self.reporter.display_messages(report_nodes.Section())\n1240 \n1241         if self.file_state.base_name is not None:\n1242             # load previous results if any\n1243             previous_stats = config.load_results(self.file_state.base_name)\n1244             self.reporter.on_close(self.stats, previous_stats)\n1245             if self.config.reports:\n1246                 sect = self.make_reports(self.stats, previous_stats)\n1247             else:\n1248                 sect = report_nodes.Section()\n1249 \n1250             if self.config.reports:\n1251                 self.reporter.display_reports(sect)\n1252             score_value = self._report_evaluation()\n1253             # save results if persistent run\n1254             if self.config.persistent:\n1255                 config.save_results(self.stats, self.file_state.base_name)\n1256         else:\n1257             self.reporter.on_close(self.stats, {})\n1258             score_value = None\n1259         return score_value\n1260 \n1261     def _report_evaluation(self):\n1262         \"\"\"make the global evaluation report\"\"\"\n1263         # check with at least check 1 statements (usually 0 when there is a\n1264         # syntax error preventing pylint from further processing)\n1265         note = None\n1266         previous_stats = config.load_results(self.file_state.base_name)\n1267         if self.stats[\"statement\"] == 0:\n1268             return note\n1269 \n1270         # get a global note for the code\n1271         evaluation = self.config.evaluation\n1272         try:\n1273             note = eval(evaluation, {}, self.stats)  # pylint: disable=eval-used\n1274         except Exception as ex:  # pylint: disable=broad-except\n1275             msg = \"An exception occurred while rating: %s\" % ex\n1276         else:\n1277             self.stats[\"global_note\"] = note\n1278             msg = \"Your code has been rated at %.2f/10\" % note\n1279             pnote = previous_stats.get(\"global_note\")\n1280             if pnote is not None:\n1281                 msg += f\" (previous run: {pnote:.2f}/10, {note - pnote:+.2f})\"\n1282 \n1283         if self.config.score:\n1284             sect = report_nodes.EvaluationSection(msg)\n1285             self.reporter.display_reports(sect)\n1286         return note\n",
        "intended_behavior": "As part of the linting process, ensure that the analysis phase that feeds into `pyreverse` can identify and pass along type hint information. Though not directly responsible for UML generation, enhancing this component to better recognize and handle type hints could benefit the overall goal of improving UML output."
    }
]