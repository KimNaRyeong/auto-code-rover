2025-10-18 04:23:11.277 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-18 04:23:14.826 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=326, output_tokens=12, cost=0.003620
2025-10-18 04:23:32.071 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=506, output_tokens=780, cost=0.028460
2025-10-18 04:23:33.053 | INFO     | registered non reproducing test 0
2025-10-18 04:23:51.393 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1822, output_tokens=847, cost=0.043630
2025-10-18 04:23:52.368 | INFO     | registered non reproducing test 1
2025-10-18 04:24:05.832 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1670, output_tokens=602, cost=0.034760
2025-10-18 04:24:06.789 | INFO     | registered non reproducing test 2
2025-10-18 04:24:06.790 | WARNING  | Failed to write a reproducer test; skipping reproducer tracing
2025-10-18 04:24:06.793 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 04:24:09.099 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=630, output_tokens=80, cost=0.008700
2025-10-18 04:24:09.103 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 04:24:12.745 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=434, output_tokens=58, cost=0.006080
2025-10-18 04:24:12.747 | DEBUG    | Extracted a valid json.
2025-10-18 04:24:12.747 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_class(\"C\")",
        "search_method_in_class(\"__init__\", \"C\")",
        "search_code(\"def __init__(self, a: str = None):\")"
    ],
    "bug_locations": []
}
2025-10-18 04:24:12.760 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 04:24:12.761 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 04:24:19.650 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=903, output_tokens=239, cost=0.016200
2025-10-18 04:24:19.658 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 04:24:27.349 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1358, output_tokens=338, cost=0.023720
2025-10-18 04:24:27.356 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 04:24:29.074 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=692, output_tokens=14, cost=0.007340
2025-10-18 04:24:29.075 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-18 04:24:29.075 | DEBUG    | Trying to convert API calls/bug locations into json. Try 2 of 5.
2025-10-18 04:24:30.696 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=692, output_tokens=14, cost=0.007340
2025-10-18 04:24:30.697 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-18 04:24:30.697 | DEBUG    | Trying to convert API calls/bug locations into json. Try 3 of 5.
2025-10-18 04:24:32.616 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=692, output_tokens=14, cost=0.007340
2025-10-18 04:24:32.617 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-18 04:24:32.617 | DEBUG    | Trying to convert API calls/bug locations into json. Try 4 of 5.
2025-10-18 04:24:34.690 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=692, output_tokens=14, cost=0.007340
2025-10-18 04:24:34.691 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-18 04:24:34.691 | DEBUG    | Trying to convert API calls/bug locations into json. Try 5 of 5.
2025-10-18 04:24:35.853 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=692, output_tokens=14, cost=0.007340
2025-10-18 04:24:35.854 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-18 04:24:35.854 | DEBUG    | Agent proxy return the following json: None
2025-10-18 04:24:35.855 | DEBUG    | Could not extract API calls from agent search response, asking search agent to re-generate response.
2025-10-18 04:24:35.855 | DEBUG    | <Agent search> Downstream could not consume our last response. Will retry.
2025-10-18 04:24:35.856 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 04:24:38.227 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1723, output_tokens=76, cost=0.019510
2025-10-18 04:24:38.230 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 04:24:39.701 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=430, output_tokens=33, cost=0.005290
2025-10-18 04:24:39.703 | DEBUG    | Extracted a valid json.
2025-10-18 04:24:39.703 | DEBUG    | Agent proxy return the following json: {
    "API_calls": ["search_code(\"pyreverse UML generation\")", "search_code(\"type hint processing\")"],
    "bug_locations": []
}
2025-10-18 04:24:39.722 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 04:24:39.723 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 04:24:47.014 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1958, output_tokens=297, cost=0.028490
2025-10-18 04:24:47.022 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 04:24:48.313 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2471, output_tokens=23, cost=0.025400
2025-10-18 04:24:48.316 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 04:24:51.833 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=377, output_tokens=42, cost=0.005030
2025-10-18 04:24:51.834 | DEBUG    | Extracted a valid json.
2025-10-18 04:24:51.834 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_code(\"class diagram\")",
        "search_code(\"file parsing\")",
        "search_code(\"AST\")"
    ],
    "bug_locations": []
}
2025-10-18 04:24:51.890 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 04:24:51.891 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 04:25:06.782 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3093, output_tokens=713, cost=0.052320
2025-10-18 04:25:06.796 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 04:25:18.614 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=4022, output_tokens=519, cost=0.055790
2025-10-18 04:25:18.625 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 04:25:30.311 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=873, output_tokens=502, cost=0.023790
2025-10-18 04:25:30.313 | DEBUG    | Extracted a valid json.
2025-10-18 04:25:30.313 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "pylint/pyreverse/writer.py",
            "class": "",
            "method": "",
            "intended_behavior": "This file should be enhanced to ensure that when UML diagrams are being output, type hints associated with class attributes and method parameters are included. For an attribute or parameter initially set to `None` but annotated with a type hint (e.g., `a: str = None`), the UML diagram must display this as having the hinted type (e.g., `a : String`). This enhancement should preserve the ability to generate diagrams as currently done, adding the functionality to display type hints."
        },
        {
            "file": "pylint/pyreverse/diagrams.py",
            "class": "",
            "method": "",
            "intended_behavior": "Modify the logic for representing classes and relationships in the diagram to include type hints in the diagram's internal representation. This involves adjusting how classes and methods are processed to ensure that type annotations are captured and reflected in the generated diagrams."
        },
        {
            "file": "pylint/pyreverse/diadefslib.py",
            "class": "",
            "method": "",
            "intended_behavior": "In this library, responsible for defining the diagrams, ensure that type hints are part of the definition process. This might involve adding new properties or methods to classes that represent diagram elements to store and manage type hint information extracted from the AST."
        },
        {
            "file": "pylint/utils/ast_walker.py",
            "class": "",
            "method": "",
            "intended_behavior": "Since this file is involved in walking the AST, it should ensure that while processing nodes, type hints are appropriately recognized and extracted for use in `pyreverse` diagram generation. This might require adjustments or enhancements to the visitor functions or methods that process specific types of AST nodes related to class and method definitions."
        },
        {
            "file": "pylint/lint/pylinter.py",
            "class": "",
            "method": "",
            "intended_behavior": "As part of the linting process, ensure that the analysis phase that feeds into `pyreverse` can identify and pass along type hint information. Though not directly responsible for UML generation, enhancing this component to better recognize and handle type hints could benefit the overall goal of improving UML output."
        }
    ]
}
2025-10-18 04:25:30.326 | DEBUG    | Bug location extracted successfully: [<file>pylint/pyreverse/writer.py</file>
<class>None</class>
<method>None</method>
<code>
1 # Copyright (c) 2008-2010, 2013-2014 LOGILAB S.A. (Paris, FRANCE) <contact@logilab.fr>
2 # Copyright (c) 2014 Arun Persaud <arun@nubati.net>
3 # Copyright (c) 2015-2018, 2020 Claudiu Popa <pcmanticore@gmail.com>
4 # Copyright (c) 2015 Mike Frysinger <vapier@gentoo.org>
5 # Copyright (c) 2015 Florian Bruhin <me@the-compiler.org>
6 # Copyright (c) 2015 Ionel Cristian Maries <contact@ionelmc.ro>
7 # Copyright (c) 2018, 2020 Anthony Sottile <asottile@umich.edu>
8 # Copyright (c) 2018 ssolanki <sushobhitsolanki@gmail.com>
9 # Copyright (c) 2019-2021 Pierre Sassoulas <pierre.sassoulas@gmail.com>
10 # Copyright (c) 2019 Kylian <development@goudcode.nl>
11 # Copyright (c) 2021 Andreas Finkler <andi.finkler@gmail.com>
12 # Copyright (c) 2021 Mark Byrne <mbyrnepr2@gmail.com>
13 
14 # Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
15 # For details: https://github.com/PyCQA/pylint/blob/master/LICENSE
16 
17 """Utilities for creating VCG and Dot diagrams"""
18 
19 import os
20 
21 from pylint.graph import DotBackend
22 from pylint.pyreverse.utils import is_exception
23 from pylint.pyreverse.vcgutils import VCGPrinter
24 
25 
26 class DiagramWriter:
27     """base class for writing project diagrams"""
28 
29     def __init__(self, config, styles):
30         self.config = config
31         self.pkg_edges, self.inh_edges, self.imp_edges, self.association_edges = styles
32         self.printer = None  # defined in set_printer
33 
34     def write(self, diadefs):
35         """write files for <project> according to <diadefs>"""
36         for diagram in diadefs:
37             basename = diagram.title.strip().replace(" ", "_")
38             file_name = f"{basename}.{self.config.output_format}"
39             if os.path.exists(self.config.output_directory):
40                 file_name = os.path.join(self.config.output_directory, file_name)
41             self.set_printer(file_name, basename)
42             if diagram.TYPE == "class":
43                 self.write_classes(diagram)
44             else:
45                 self.write_packages(diagram)
46             self.close_graph()
47 
48     def write_packages(self, diagram):
49         """write a package diagram"""
50         # sorted to get predictable (hence testable) results
51         for i, obj in enumerate(sorted(diagram.modules(), key=lambda x: x.title)):
52             self.printer.emit_node(i, label=self.get_title(obj), shape="box")
53             obj.fig_id = i
54         # package dependencies
55         for rel in diagram.get_relationships("depends"):
56             self.printer.emit_edge(
57                 rel.from_object.fig_id, rel.to_object.fig_id, **self.pkg_edges
58             )
59 
60     def write_classes(self, diagram):
61         """write a class diagram"""
62         # sorted to get predictable (hence testable) results
63         for i, obj in enumerate(sorted(diagram.objects, key=lambda x: x.title)):
64             self.printer.emit_node(i, **self.get_values(obj))
65             obj.fig_id = i
66         # inheritance links
67         for rel in diagram.get_relationships("specialization"):
68             self.printer.emit_edge(
69                 rel.from_object.fig_id, rel.to_object.fig_id, **self.inh_edges
70             )
71         # implementation links
72         for rel in diagram.get_relationships("implements"):
73             self.printer.emit_edge(
74                 rel.from_object.fig_id, rel.to_object.fig_id, **self.imp_edges
75             )
76         # generate associations
77         for rel in diagram.get_relationships("association"):
78             self.printer.emit_edge(
79                 rel.from_object.fig_id,
80                 rel.to_object.fig_id,
81                 label=rel.name,
82                 **self.association_edges,
83             )
84 
85     def set_printer(self, file_name, basename):
86         """set printer"""
87         raise NotImplementedError
88 
89     def get_title(self, obj):
90         """get project title"""
91         raise NotImplementedError
92 
93     def get_values(self, obj):
94         """get label and shape for classes."""
95         raise NotImplementedError
96 
97     def close_graph(self):
98         """finalize the graph"""
99         raise NotImplementedError
100 
101 
102 class DotWriter(DiagramWriter):
103     """write dot graphs from a diagram definition and a project"""
104 
105     def __init__(self, config):
106         styles = [
107             dict(arrowtail="none", arrowhead="open"),
108             dict(arrowtail="none", arrowhead="empty"),
109             dict(arrowtail="node", arrowhead="empty", style="dashed"),
110             dict(
111                 fontcolor="green", arrowtail="none", arrowhead="diamond", style="solid"
112             ),
113         ]
114         DiagramWriter.__init__(self, config, styles)
115 
116     def set_printer(self, file_name, basename):
117         """initialize DotWriter and add options for layout."""
118         layout = dict(rankdir="BT")
119         self.printer = DotBackend(basename, additional_param=layout)
120         self.file_name = file_name
121 
122     def get_title(self, obj):
123         """get project title"""
124         return obj.title
125 
126     def get_values(self, obj):
127         """get label and shape for classes.
128 
129         The label contains all attributes and methods
130         """
131         label = obj.title
132         if obj.shape == "interface":
133             label = "«interface»\\n%s" % label
134         if not self.config.only_classnames:
135             label = r"{}|{}\l|".format(label, r"\l".join(obj.attrs))
136             for func in obj.methods:
137                 if func.args.args:
138                     args = [arg.name for arg in func.args.args if arg.name != "self"]
139                 else:
140                     args = []
141                 label = r"{}{}({})\l".format(label, func.name, ", ".join(args))
142             label = "{%s}" % label
143         if is_exception(obj.node):
144             return dict(fontcolor="red", label=label, shape="record")
145         return dict(label=label, shape="record")
146 
147     def close_graph(self):
148         """print the dot graph into <file_name>"""
149         self.printer.generate(self.file_name)
150 
151 
152 class VCGWriter(DiagramWriter):
153     """write vcg graphs from a diagram definition and a project"""
154 
155     def __init__(self, config):
156         styles = [
157             dict(arrowstyle="solid", backarrowstyle="none", backarrowsize=0),
158             dict(arrowstyle="solid", backarrowstyle="none", backarrowsize=10),
159             dict(
160                 arrowstyle="solid",
161                 backarrowstyle="none",
162                 linestyle="dotted",
163                 backarrowsize=10,
164             ),
165             dict(arrowstyle="solid", backarrowstyle="none", textcolor="green"),
166         ]
167         DiagramWriter.__init__(self, config, styles)
168 
169     def set_printer(self, file_name, basename):
170         """initialize VCGWriter for a UML graph"""
171         self.graph_file = open(file_name, "w+")  # pylint: disable=consider-using-with
172         self.printer = VCGPrinter(self.graph_file)
173         self.printer.open_graph(
174             title=basename,
175             layoutalgorithm="dfs",
176             late_edge_labels="yes",
177             port_sharing="no",
178             manhattan_edges="yes",
179         )
180         self.printer.emit_node = self.printer.node
181         self.printer.emit_edge = self.printer.edge
182 
183     def get_title(self, obj):
184         """get project title in vcg format"""
185         return r"\fb%s\fn" % obj.title
186 
187     def get_values(self, obj):
188         """get label and shape for classes.
189 
190         The label contains all attributes and methods
191         """
192         if is_exception(obj.node):
193             label = r"\fb\f09%s\fn" % obj.title
194         else:
195             label = r"\fb%s\fn" % obj.title
196         if obj.shape == "interface":
197             shape = "ellipse"
198         else:
199             shape = "box"
200         if not self.config.only_classnames:
201             attrs = obj.attrs
202             methods = [func.name for func in obj.methods]
203             # box width for UML like diagram
204             maxlen = max(len(name) for name in [obj.title] + methods + attrs)
205             line = "_" * (maxlen + 2)
206             label = fr"{label}\n\f{line}"
207             for attr in attrs:
208                 label = fr"{label}\n\f08{attr}"
209             if attrs:
210                 label = fr"{label}\n\f{line}"
211             for func in methods:
212                 label = fr"{label}\n\f10{func}()"
213         return dict(label=label, shape=shape)
214 
215     def close_graph(self):
216         """close graph and file"""
217         self.printer.close_graph()
218         self.graph_file.close()

</code><intended_behavior>This file should be enhanced to ensure that when UML diagrams are being output, type hints associated with class attributes and method parameters are included. For an attribute or parameter initially set to `None` but annotated with a type hint (e.g., `a: str = None`), the UML diagram must display this as having the hinted type (e.g., `a : String`). This enhancement should preserve the ability to generate diagrams as currently done, adding the functionality to display type hints.</intended_behavior>, <file>pylint/pyreverse/diagrams.py</file>
<class>None</class>
<method>None</method>
<code>
1 # Copyright (c) 2006, 2008-2010, 2012-2014 LOGILAB S.A. (Paris, FRANCE) <contact@logilab.fr>
2 # Copyright (c) 2014-2018, 2020 Claudiu Popa <pcmanticore@gmail.com>
3 # Copyright (c) 2014 Brett Cannon <brett@python.org>
4 # Copyright (c) 2014 Arun Persaud <arun@nubati.net>
5 # Copyright (c) 2015 Ionel Cristian Maries <contact@ionelmc.ro>
6 # Copyright (c) 2018 ssolanki <sushobhitsolanki@gmail.com>
7 # Copyright (c) 2019-2021 Pierre Sassoulas <pierre.sassoulas@gmail.com>
8 # Copyright (c) 2020 hippo91 <guillaume.peillex@gmail.com>
9 
10 # Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
11 # For details: https://github.com/PyCQA/pylint/blob/master/LICENSE
12 
13 """diagram objects
14 """
15 
16 import astroid
17 
18 from pylint.checkers.utils import decorated_with_property
19 from pylint.pyreverse.utils import FilterMixIn, is_interface
20 
21 
22 class Figure:
23     """base class for counter handling"""
24 
25 
26 class Relationship(Figure):
27     """a relation ship from an object in the diagram to another"""
28 
29     def __init__(self, from_object, to_object, relation_type, name=None):
30         Figure.__init__(self)
31         self.from_object = from_object
32         self.to_object = to_object
33         self.type = relation_type
34         self.name = name
35 
36 
37 class DiagramEntity(Figure):
38     """a diagram object, i.e. a label associated to an astroid node"""
39 
40     def __init__(self, title="No name", node=None):
41         Figure.__init__(self)
42         self.title = title
43         self.node = node
44 
45 
46 class ClassDiagram(Figure, FilterMixIn):
47     """main class diagram handling"""
48 
49     TYPE = "class"
50 
51     def __init__(self, title, mode):
52         FilterMixIn.__init__(self, mode)
53         Figure.__init__(self)
54         self.title = title
55         self.objects = []
56         self.relationships = {}
57         self._nodes = {}
58         self.depends = []
59 
60     def get_relationships(self, role):
61         # sorted to get predictable (hence testable) results
62         return sorted(
63             self.relationships.get(role, ()),
64             key=lambda x: (x.from_object.fig_id, x.to_object.fig_id),
65         )
66 
67     def add_relationship(self, from_object, to_object, relation_type, name=None):
68         """create a relation ship"""
69         rel = Relationship(from_object, to_object, relation_type, name)
70         self.relationships.setdefault(relation_type, []).append(rel)
71 
72     def get_relationship(self, from_object, relation_type):
73         """return a relation ship or None"""
74         for rel in self.relationships.get(relation_type, ()):
75             if rel.from_object is from_object:
76                 return rel
77         raise KeyError(relation_type)
78 
79     def get_attrs(self, node):
80         """return visible attributes, possibly with class name"""
81         attrs = []
82         properties = [
83             (n, m)
84             for n, m in node.items()
85             if isinstance(m, astroid.FunctionDef) and decorated_with_property(m)
86         ]
87         for node_name, associated_nodes in (
88             list(node.instance_attrs_type.items())
89             + list(node.locals_type.items())
90             + properties
91         ):
92             if not self.show_attr(node_name):
93                 continue
94             names = self.class_names(associated_nodes)
95             if names:
96                 node_name = "{} : {}".format(node_name, ", ".join(names))
97             attrs.append(node_name)
98         return sorted(attrs)
99 
100     def get_methods(self, node):
101         """return visible methods"""
102         methods = [
103             m
104             for m in node.values()
105             if isinstance(m, astroid.FunctionDef)
106             and not decorated_with_property(m)
107             and self.show_attr(m.name)
108         ]
109         return sorted(methods, key=lambda n: n.name)
110 
111     def add_object(self, title, node):
112         """create a diagram object"""
113         assert node not in self._nodes
114         ent = DiagramEntity(title, node)
115         self._nodes[node] = ent
116         self.objects.append(ent)
117 
118     def class_names(self, nodes):
119         """return class names if needed in diagram"""
120         names = []
121         for node in nodes:
122             if isinstance(node, astroid.Instance):
123                 node = node._proxied
124             if (
125                 isinstance(node, astroid.ClassDef)
126                 and hasattr(node, "name")
127                 and not self.has_node(node)
128             ):
129                 if node.name not in names:
130                     node_name = node.name
131                     names.append(node_name)
132         return names
133 
134     def nodes(self):
135         """return the list of underlying nodes"""
136         return self._nodes.keys()
137 
138     def has_node(self, node):
139         """return true if the given node is included in the diagram"""
140         return node in self._nodes
141 
142     def object_from_node(self, node):
143         """return the diagram object mapped to node"""
144         return self._nodes[node]
145 
146     def classes(self):
147         """return all class nodes in the diagram"""
148         return [o for o in self.objects if isinstance(o.node, astroid.ClassDef)]
149 
150     def classe(self, name):
151         """return a class by its name, raise KeyError if not found"""
152         for klass in self.classes():
153             if klass.node.name == name:
154                 return klass
155         raise KeyError(name)
156 
157     def extract_relationships(self):
158         """extract relation ships between nodes in the diagram"""
159         for obj in self.classes():
160             node = obj.node
161             obj.attrs = self.get_attrs(node)
162             obj.methods = self.get_methods(node)
163             # shape
164             if is_interface(node):
165                 obj.shape = "interface"
166             else:
167                 obj.shape = "class"
168             # inheritance link
169             for par_node in node.ancestors(recurs=False):
170                 try:
171                     par_obj = self.object_from_node(par_node)
172                     self.add_relationship(obj, par_obj, "specialization")
173                 except KeyError:
174                     continue
175             # implements link
176             for impl_node in node.implements:
177                 try:
178                     impl_obj = self.object_from_node(impl_node)
179                     self.add_relationship(obj, impl_obj, "implements")
180                 except KeyError:
181                     continue
182             # associations link
183             for name, values in list(node.instance_attrs_type.items()) + list(
184                 node.locals_type.items()
185             ):
186                 for value in values:
187                     if value is astroid.Uninferable:
188                         continue
189                     if isinstance(value, astroid.Instance):
190                         value = value._proxied
191                     try:
192                         associated_obj = self.object_from_node(value)
193                         self.add_relationship(associated_obj, obj, "association", name)
194                     except KeyError:
195                         continue
196 
197 
198 class PackageDiagram(ClassDiagram):
199     """package diagram handling"""
200 
201     TYPE = "package"
202 
203     def modules(self):
204         """return all module nodes in the diagram"""
205         return [o for o in self.objects if isinstance(o.node, astroid.Module)]
206 
207     def module(self, name):
208         """return a module by its name, raise KeyError if not found"""
209         for mod in self.modules():
210             if mod.node.name == name:
211                 return mod
212         raise KeyError(name)
213 
214     def get_module(self, name, node):
215         """return a module by its name, looking also for relative imports;
216         raise KeyError if not found
217         """
218         for mod in self.modules():
219             mod_name = mod.node.name
220             if mod_name == name:
221                 return mod
222             # search for fullname of relative import modules
223             package = node.root().name
224             if mod_name == f"{package}.{name}":
225                 return mod
226             if mod_name == "{}.{}".format(package.rsplit(".", 1)[0], name):
227                 return mod
228         raise KeyError(name)
229 
230     def add_from_depend(self, node, from_module):
231         """add dependencies created by from-imports"""
232         mod_name = node.root().name
233         obj = self.module(mod_name)
234         if from_module not in obj.node.depends:
235             obj.node.depends.append(from_module)
236 
237     def extract_relationships(self):
238         """extract relation ships between nodes in the diagram"""
239         ClassDiagram.extract_relationships(self)
240         for obj in self.classes():
241             # ownership
242             try:
243                 mod = self.object_from_node(obj.node.root())
244                 self.add_relationship(obj, mod, "ownership")
245             except KeyError:
246                 continue
247         for obj in self.modules():
248             obj.shape = "package"
249             # dependencies
250             for dep_name in obj.node.depends:
251                 try:
252                     dep = self.get_module(dep_name, obj.node)
253                 except KeyError:
254                     continue
255                 self.add_relationship(obj, dep, "depends")

</code><intended_behavior>Modify the logic for representing classes and relationships in the diagram to include type hints in the diagram's internal representation. This involves adjusting how classes and methods are processed to ensure that type annotations are captured and reflected in the generated diagrams.</intended_behavior>, <file>pylint/pyreverse/diadefslib.py</file>
<class>None</class>
<method>None</method>
<code>
1 # Copyright (c) 2006, 2008-2010, 2013-2014 LOGILAB S.A. (Paris, FRANCE) <contact@logilab.fr>
2 # Copyright (c) 2014 Brett Cannon <brett@python.org>
3 # Copyright (c) 2014 Arun Persaud <arun@nubati.net>
4 # Copyright (c) 2015-2018, 2020 Claudiu Popa <pcmanticore@gmail.com>
5 # Copyright (c) 2015 Florian Bruhin <me@the-compiler.org>
6 # Copyright (c) 2015 Ionel Cristian Maries <contact@ionelmc.ro>
7 # Copyright (c) 2016 Ashley Whetter <ashley@awhetter.co.uk>
8 # Copyright (c) 2017 Łukasz Rogalski <rogalski.91@gmail.com>
9 # Copyright (c) 2018 ssolanki <sushobhitsolanki@gmail.com>
10 # Copyright (c) 2018 Sushobhit <31987769+sushobhit27@users.noreply.github.com>
11 # Copyright (c) 2018 Ville Skyttä <ville.skytta@iki.fi>
12 # Copyright (c) 2019-2021 Pierre Sassoulas <pierre.sassoulas@gmail.com>
13 # Copyright (c) 2020 hippo91 <guillaume.peillex@gmail.com>
14 # Copyright (c) 2020 Anthony Sottile <asottile@umich.edu>
15 
16 # Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
17 # For details: https://github.com/PyCQA/pylint/blob/master/LICENSE
18 
19 """handle diagram generation options for class diagram or default diagrams
20 """
21 
22 import astroid
23 
24 from pylint.pyreverse.diagrams import ClassDiagram, PackageDiagram
25 from pylint.pyreverse.utils import LocalsVisitor
26 
27 BUILTINS_NAME = "builtins"
28 
29 # diagram generators ##########################################################
30 
31 
32 class DiaDefGenerator:
33     """handle diagram generation options"""
34 
35     def __init__(self, linker, handler):
36         """common Diagram Handler initialization"""
37         self.config = handler.config
38         self._set_default_options()
39         self.linker = linker
40         self.classdiagram = None  # defined by subclasses
41 
42     def get_title(self, node):
43         """get title for objects"""
44         title = node.name
45         if self.module_names:
46             title = f"{node.root().name}.{title}"
47         return title
48 
49     def _set_option(self, option):
50         """activate some options if not explicitly deactivated"""
51         # if we have a class diagram, we want more information by default;
52         # so if the option is None, we return True
53         if option is None:
54             return bool(self.config.classes)
55         return option
56 
57     def _set_default_options(self):
58         """set different default options with _default dictionary"""
59         self.module_names = self._set_option(self.config.module_names)
60         all_ancestors = self._set_option(self.config.all_ancestors)
61         all_associated = self._set_option(self.config.all_associated)
62         anc_level, association_level = (0, 0)
63         if all_ancestors:
64             anc_level = -1
65         if all_associated:
66             association_level = -1
67         if self.config.show_ancestors is not None:
68             anc_level = self.config.show_ancestors
69         if self.config.show_associated is not None:
70             association_level = self.config.show_associated
71         self.anc_level, self.association_level = anc_level, association_level
72 
73     def _get_levels(self):
74         """help function for search levels"""
75         return self.anc_level, self.association_level
76 
77     def show_node(self, node):
78         """true if builtins and not show_builtins"""
79         if self.config.show_builtin:
80             return True
81         return node.root().name != BUILTINS_NAME
82 
83     def add_class(self, node):
84         """visit one class and add it to diagram"""
85         self.linker.visit(node)
86         self.classdiagram.add_object(self.get_title(node), node)
87 
88     def get_ancestors(self, node, level):
89         """return ancestor nodes of a class node"""
90         if level == 0:
91             return
92         for ancestor in node.ancestors(recurs=False):
93             if not self.show_node(ancestor):
94                 continue
95             yield ancestor
96 
97     def get_associated(self, klass_node, level):
98         """return associated nodes of a class node"""
99         if level == 0:
100             return
101         for association_nodes in list(klass_node.instance_attrs_type.values()) + list(
102             klass_node.locals_type.values()
103         ):
104             for node in association_nodes:
105                 if isinstance(node, astroid.Instance):
106                     node = node._proxied
107                 if not (isinstance(node, astroid.ClassDef) and self.show_node(node)):
108                     continue
109                 yield node
110 
111     def extract_classes(self, klass_node, anc_level, association_level):
112         """extract recursively classes related to klass_node"""
113         if self.classdiagram.has_node(klass_node) or not self.show_node(klass_node):
114             return
115         self.add_class(klass_node)
116 
117         for ancestor in self.get_ancestors(klass_node, anc_level):
118             self.extract_classes(ancestor, anc_level - 1, association_level)
119 
120         for node in self.get_associated(klass_node, association_level):
121             self.extract_classes(node, anc_level, association_level - 1)
122 
123 
124 class DefaultDiadefGenerator(LocalsVisitor, DiaDefGenerator):
125     """generate minimum diagram definition for the project :
126 
127     * a package diagram including project's modules
128     * a class diagram including project's classes
129     """
130 
131     def __init__(self, linker, handler):
132         DiaDefGenerator.__init__(self, linker, handler)
133         LocalsVisitor.__init__(self)
134 
135     def visit_project(self, node):
136         """visit a pyreverse.utils.Project node
137 
138         create a diagram definition for packages
139         """
140         mode = self.config.mode
141         if len(node.modules) > 1:
142             self.pkgdiagram = PackageDiagram("packages %s" % node.name, mode)
143         else:
144             self.pkgdiagram = None
145         self.classdiagram = ClassDiagram("classes %s" % node.name, mode)
146 
147     def leave_project(self, node):  # pylint: disable=unused-argument
148         """leave the pyreverse.utils.Project node
149 
150         return the generated diagram definition
151         """
152         if self.pkgdiagram:
153             return self.pkgdiagram, self.classdiagram
154         return (self.classdiagram,)
155 
156     def visit_module(self, node):
157         """visit an astroid.Module node
158 
159         add this class to the package diagram definition
160         """
161         if self.pkgdiagram:
162             self.linker.visit(node)
163             self.pkgdiagram.add_object(node.name, node)
164 
165     def visit_classdef(self, node):
166         """visit an astroid.Class node
167 
168         add this class to the class diagram definition
169         """
170         anc_level, association_level = self._get_levels()
171         self.extract_classes(node, anc_level, association_level)
172 
173     def visit_importfrom(self, node):
174         """visit astroid.ImportFrom  and catch modules for package diagram"""
175         if self.pkgdiagram:
176             self.pkgdiagram.add_from_depend(node, node.modname)
177 
178 
179 class ClassDiadefGenerator(DiaDefGenerator):
180     """generate a class diagram definition including all classes related to a
181     given class
182     """
183 
184     def __init__(self, linker, handler):
185         DiaDefGenerator.__init__(self, linker, handler)
186 
187     def class_diagram(self, project, klass):
188         """return a class diagram definition for the given klass and its
189         related klasses
190         """
191 
192         self.classdiagram = ClassDiagram(klass, self.config.mode)
193         if len(project.modules) > 1:
194             module, klass = klass.rsplit(".", 1)
195             module = project.get_module(module)
196         else:
197             module = project.modules[0]
198             klass = klass.split(".")[-1]
199         klass = next(module.ilookup(klass))
200 
201         anc_level, association_level = self._get_levels()
202         self.extract_classes(klass, anc_level, association_level)
203         return self.classdiagram
204 
205 
206 # diagram handler #############################################################
207 
208 
209 class DiadefsHandler:
210     """handle diagram definitions :
211 
212     get it from user (i.e. xml files) or generate them
213     """
214 
215     def __init__(self, config):
216         self.config = config
217 
218     def get_diadefs(self, project, linker):
219         """Get the diagrams configuration data
220 
221         :param project:The pyreverse project
222         :type project: pyreverse.utils.Project
223         :param linker: The linker
224         :type linker: pyreverse.inspector.Linker(IdGeneratorMixIn, LocalsVisitor)
225 
226         :returns: The list of diagram definitions
227         :rtype: list(:class:`pylint.pyreverse.diagrams.ClassDiagram`)
228         """
229 
230         #  read and interpret diagram definitions (Diadefs)
231         diagrams = []
232         generator = ClassDiadefGenerator(linker, self)
233         for klass in self.config.classes:
234             diagrams.append(generator.class_diagram(project, klass))
235         if not diagrams:
236             diagrams = DefaultDiadefGenerator(linker, self).visit(project)
237         for diagram in diagrams:
238             diagram.extract_relationships()
239         return diagrams

</code><intended_behavior>In this library, responsible for defining the diagrams, ensure that type hints are part of the definition process. This might involve adding new properties or methods to classes that represent diagram elements to store and manage type hint information extracted from the AST.</intended_behavior>, <file>pylint/utils/ast_walker.py</file>
<class>None</class>
<method>None</method>
<code>
1 # Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
2 # For details: https://github.com/PyCQA/pylint/blob/master/LICENSE
3 
4 import collections
5 
6 from astroid import nodes
7 
8 
9 class ASTWalker:
10     def __init__(self, linter):
11         # callbacks per node types
12         self.nbstatements = 0
13         self.visit_events = collections.defaultdict(list)
14         self.leave_events = collections.defaultdict(list)
15         self.linter = linter
16         self.exception_msg = False
17 
18     def _is_method_enabled(self, method):
19         if not hasattr(method, "checks_msgs"):
20             return True
21         for msg_desc in method.checks_msgs:
22             if self.linter.is_message_enabled(msg_desc):
23                 return True
24         return False
25 
26     def add_checker(self, checker):
27         """walk to the checker's dir and collect visit and leave methods"""
28         vcids = set()
29         lcids = set()
30         visits = self.visit_events
31         leaves = self.leave_events
32         for member in dir(checker):
33             cid = member[6:]
34             if cid == "default":
35                 continue
36             if member.startswith("visit_"):
37                 v_meth = getattr(checker, member)
38                 # don't use visit_methods with no activated message:
39                 if self._is_method_enabled(v_meth):
40                     visits[cid].append(v_meth)
41                     vcids.add(cid)
42             elif member.startswith("leave_"):
43                 l_meth = getattr(checker, member)
44                 # don't use leave_methods with no activated message:
45                 if self._is_method_enabled(l_meth):
46                     leaves[cid].append(l_meth)
47                     lcids.add(cid)
48         visit_default = getattr(checker, "visit_default", None)
49         if visit_default:
50             for cls in nodes.ALL_NODE_CLASSES:
51                 cid = cls.__name__.lower()
52                 if cid not in vcids:
53                     visits[cid].append(visit_default)
54         # for now we have no "leave_default" method in Pylint
55 
56     def walk(self, astroid):
57         """call visit events of astroid checkers for the given node, recurse on
58         its children, then leave events.
59         """
60         cid = astroid.__class__.__name__.lower()
61 
62         # Detect if the node is a new name for a deprecated alias.
63         # In this case, favour the methods for the deprecated
64         # alias if any,  in order to maintain backwards
65         # compatibility.
66         visit_events = self.visit_events.get(cid, ())
67         leave_events = self.leave_events.get(cid, ())
68 
69         try:
70             if astroid.is_statement:
71                 self.nbstatements += 1
72             # generate events for this node on each checker
73             for callback in visit_events or ():
74                 callback(astroid)
75             # recurse on children
76             for child in astroid.get_children():
77                 self.walk(child)
78             for callback in leave_events or ():
79                 callback(astroid)
80         except Exception:
81             if self.exception_msg is False:
82                 file = getattr(astroid.root(), "file", None)
83                 print(f"Exception on node {repr(astroid)} in file '{file}'")
84                 self.exception_msg = True
85             raise

</code><intended_behavior>Since this file is involved in walking the AST, it should ensure that while processing nodes, type hints are appropriately recognized and extracted for use in `pyreverse` diagram generation. This might require adjustments or enhancements to the visitor functions or methods that process specific types of AST nodes related to class and method definitions.</intended_behavior>, <file>pylint/lint/pylinter.py</file>
<class>None</class>
<method>None</method>
<code>
1 # Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
2 # For details: https://github.com/PyCQA/pylint/blob/master/LICENSE
3 
4 import collections
5 import contextlib
6 import functools
7 import operator
8 import os
9 import sys
10 import tokenize
11 import traceback
12 import warnings
13 from io import TextIOWrapper
14 
15 import astroid
16 
17 from pylint import checkers, config, exceptions, interfaces, reporters
18 from pylint.constants import MAIN_CHECKER_NAME, MSG_TYPES
19 from pylint.lint.expand_modules import expand_modules
20 from pylint.lint.parallel import check_parallel
21 from pylint.lint.report_functions import (
22     report_messages_by_module_stats,
23     report_messages_stats,
24     report_total_messages_stats,
25 )
26 from pylint.lint.utils import fix_import_path
27 from pylint.message import MessageDefinitionStore, MessagesHandlerMixIn
28 from pylint.reporters.ureports import nodes as report_nodes
29 from pylint.utils import ASTWalker, FileState, utils
30 from pylint.utils.pragma_parser import (
31     OPTION_PO,
32     InvalidPragmaError,
33     UnRecognizedOptionError,
34     parse_pragma,
35 )
36 
37 MANAGER = astroid.MANAGER
38 
39 
40 def _read_stdin():
41     # https://mail.python.org/pipermail/python-list/2012-November/634424.html
42     sys.stdin = TextIOWrapper(sys.stdin.detach(), encoding="utf-8")
43     return sys.stdin.read()
44 
45 
46 def _load_reporter_by_class(reporter_class: str) -> type:
47     qname = reporter_class
48     module_part = astroid.modutils.get_module_part(qname)
49     module = astroid.modutils.load_module_from_name(module_part)
50     class_name = qname.split(".")[-1]
51     return getattr(module, class_name)
52 
53 
54 # Python Linter class #########################################################
55 
56 MSGS = {
57     "F0001": (
58         "%s",
59         "fatal",
60         "Used when an error occurred preventing the analysis of a \
61               module (unable to find it for instance).",
62     ),
63     "F0002": (
64         "%s: %s",
65         "astroid-error",
66         "Used when an unexpected error occurred while building the "
67         "Astroid  representation. This is usually accompanied by a "
68         "traceback. Please report such errors !",
69     ),
70     "F0010": (
71         "error while code parsing: %s",
72         "parse-error",
73         "Used when an exception occurred while building the Astroid "
74         "representation which could be handled by astroid.",
75     ),
76     "I0001": (
77         "Unable to run raw checkers on built-in module %s",
78         "raw-checker-failed",
79         "Used to inform that a built-in module has not been checked "
80         "using the raw checkers.",
81     ),
82     "I0010": (
83         "Unable to consider inline option %r",
84         "bad-inline-option",
85         "Used when an inline option is either badly formatted or can't "
86         "be used inside modules.",
87     ),
88     "I0011": (
89         "Locally disabling %s (%s)",
90         "locally-disabled",
91         "Used when an inline option disables a message or a messages category.",
92     ),
93     "I0013": (
94         "Ignoring entire file",
95         "file-ignored",
96         "Used to inform that the file will not be checked",
97     ),
98     "I0020": (
99         "Suppressed %s (from line %d)",
100         "suppressed-message",
101         "A message was triggered on a line, but suppressed explicitly "
102         "by a disable= comment in the file. This message is not "
103         "generated for messages that are ignored due to configuration "
104         "settings.",
105     ),
106     "I0021": (
107         "Useless suppression of %s",
108         "useless-suppression",
109         "Reported when a message is explicitly disabled for a line or "
110         "a block of code, but never triggered.",
111     ),
112     "I0022": (
113         'Pragma "%s" is deprecated, use "%s" instead',
114         "deprecated-pragma",
115         "Some inline pylint options have been renamed or reworked, "
116         "only the most recent form should be used. "
117         "NOTE:skip-all is only available with pylint >= 0.26",
118         {"old_names": [("I0014", "deprecated-disable-all")]},
119     ),
120     "E0001": ("%s", "syntax-error", "Used when a syntax error is raised for a module."),
121     "E0011": (
122         "Unrecognized file option %r",
123         "unrecognized-inline-option",
124         "Used when an unknown inline option is encountered.",
125     ),
126     "E0012": (
127         "Bad option value %r",
128         "bad-option-value",
129         "Used when a bad value for an inline option is encountered.",
130     ),
131     "E0013": (
132         "Plugin '%s' is impossible to load, is it installed ? ('%s')",
133         "bad-plugin-value",
134         "Used when a bad value is used in 'load-plugins'.",
135     ),
136 }
137 
138 
139 # pylint: disable=too-many-instance-attributes,too-many-public-methods
140 class PyLinter(
141     config.OptionsManagerMixIn,
142     MessagesHandlerMixIn,
143     reporters.ReportsHandlerMixIn,
144     checkers.BaseTokenChecker,
145 ):
146     """lint Python modules using external checkers.
147 
148     This is the main checker controlling the other ones and the reports
149     generation. It is itself both a raw checker and an astroid checker in order
150     to:
151     * handle message activation / deactivation at the module level
152     * handle some basic but necessary stats'data (number of classes, methods...)
153 
154     IDE plugin developers: you may have to call
155     `astroid.builder.MANAGER.astroid_cache.clear()` across runs if you want
156     to ensure the latest code version is actually checked.
157 
158     This class needs to support pickling for parallel linting to work. The exception
159     is reporter member; see check_parallel function for more details.
160     """
161 
162     __implements__ = (interfaces.ITokenChecker,)
163 
164     name = MAIN_CHECKER_NAME
165     priority = 0
166     level = 0
167     msgs = MSGS
168 
169     @staticmethod
170     def make_options():
171         return (
172             (
173                 "ignore",
174                 {
175                     "type": "csv",
176                     "metavar": "<file>[,<file>...]",
177                     "dest": "black_list",
178                     "default": ("CVS",),
179                     "help": "Files or directories to be skipped. "
180                     "They should be base names, not paths.",
181                 },
182             ),
183             (
184                 "ignore-patterns",
185                 {
186                     "type": "regexp_csv",
187                     "metavar": "<pattern>[,<pattern>...]",
188                     "dest": "black_list_re",
189                     "default": (),
190                     "help": "Files or directories matching the regex patterns are"
191                     " skipped. The regex matches against base names, not paths.",
192                 },
193             ),
194             (
195                 "ignore-paths",
196                 {
197                     "type": "regexp_csv",
198                     "metavar": "<pattern>[,<pattern>...]",
199                     "dest": "ignore_list_paths_re",
200                     "default": (),
201                     "help": "Add files or directories matching the regex patterns to the"
202                     " ignore-list. The regex matches against paths.",
203                 },
204             ),
205             (
206                 "persistent",
207                 {
208                     "default": True,
209                     "type": "yn",
210                     "metavar": "<y_or_n>",
211                     "level": 1,
212                     "help": "Pickle collected data for later comparisons.",
213                 },
214             ),
215             (
216                 "load-plugins",
217                 {
218                     "type": "csv",
219                     "metavar": "<modules>",
220                     "default": (),
221                     "level": 1,
222                     "help": "List of plugins (as comma separated values of "
223                     "python module names) to load, usually to register "
224                     "additional checkers.",
225                 },
226             ),
227             (
228                 "output-format",
229                 {
230                     "default": "text",
231                     "type": "string",
232                     "metavar": "<format>",
233                     "short": "f",
234                     "group": "Reports",
235                     "help": "Set the output format. Available formats are text,"
236                     " parseable, colorized, json and msvs (visual studio)."
237                     " You can also give a reporter class, e.g. mypackage.mymodule."
238                     "MyReporterClass.",
239                 },
240             ),
241             (
242                 "reports",
243                 {
244                     "default": False,
245                     "type": "yn",
246                     "metavar": "<y_or_n>",
247                     "short": "r",
248                     "group": "Reports",
249                     "help": "Tells whether to display a full report or only the "
250                     "messages.",
251                 },
252             ),
253             (
254                 "evaluation",
255                 {
256                     "type": "string",
257                     "metavar": "<python_expression>",
258                     "group": "Reports",
259                     "level": 1,
260                     "default": "10.0 - ((float(5 * error + warning + refactor + "
261                     "convention) / statement) * 10)",
262                     "help": "Python expression which should return a score less "
263                     "than or equal to 10. You have access to the variables "
264                     "'error', 'warning', 'refactor', and 'convention' which "
265                     "contain the number of messages in each category, as well as "
266                     "'statement' which is the total number of statements "
267                     "analyzed. This score is used by the global "
268                     "evaluation report (RP0004).",
269                 },
270             ),
271             (
272                 "score",
273                 {
274                     "default": True,
275                     "type": "yn",
276                     "metavar": "<y_or_n>",
277                     "short": "s",
278                     "group": "Reports",
279                     "help": "Activate the evaluation score.",
280                 },
281             ),
282             (
283                 "fail-under",
284                 {
285                     "default": 10,
286                     "type": "float",
287                     "metavar": "<score>",
288                     "help": "Specify a score threshold to be exceeded before program exits with error.",
289                 },
290             ),
291             (
292                 "fail-on",
293                 {
294                     "default": "",
295                     "type": "csv",
296                     "metavar": "<msg ids>",
297                     "help": "Return non-zero exit code if any of these messages/categories are detected,"
298                     " even if score is above --fail-under value. Syntax same as enable."
299                     " Messages specified are enabled, while categories only check already-enabled messages.",
300                 },
301             ),
302             (
303                 "confidence",
304                 {
305                     "type": "multiple_choice",
306                     "metavar": "<levels>",
307                     "default": "",
308                     "choices": [c.name for c in interfaces.CONFIDENCE_LEVELS],
309                     "group": "Messages control",
310                     "help": "Only show warnings with the listed confidence levels."
311                     " Leave empty to show all. Valid levels: %s."
312                     % (", ".join(c.name for c in interfaces.CONFIDENCE_LEVELS),),
313                 },
314             ),
315             (
316                 "enable",
317                 {
318                     "type": "csv",
319                     "metavar": "<msg ids>",
320                     "short": "e",
321                     "group": "Messages control",
322                     "help": "Enable the message, report, category or checker with the "
323                     "given id(s). You can either give multiple identifier "
324                     "separated by comma (,) or put this option multiple time "
325                     "(only on the command line, not in the configuration file "
326                     "where it should appear only once). "
327                     'See also the "--disable" option for examples.',
328                 },
329             ),
330             (
331                 "disable",
332                 {
333                     "type": "csv",
334                     "metavar": "<msg ids>",
335                     "short": "d",
336                     "group": "Messages control",
337                     "help": "Disable the message, report, category or checker "
338                     "with the given id(s). You can either give multiple identifiers "
339                     "separated by comma (,) or put this option multiple times "
340                     "(only on the command line, not in the configuration file "
341                     "where it should appear only once). "
342                     'You can also use "--disable=all" to disable everything first '
343                     "and then reenable specific checks. For example, if you want "
344                     "to run only the similarities checker, you can use "
345                     '"--disable=all --enable=similarities". '
346                     "If you want to run only the classes checker, but have no "
347                     "Warning level messages displayed, use "
348                     '"--disable=all --enable=classes --disable=W".',
349                 },
350             ),
351             (
352                 "msg-template",
353                 {
354                     "type": "string",
355                     "metavar": "<template>",
356                     "group": "Reports",
357                     "help": (
358                         "Template used to display messages. "
359                         "This is a python new-style format string "
360                         "used to format the message information. "
361                         "See doc for all details."
362                     ),
363                 },
364             ),
365             (
366                 "jobs",
367                 {
368                     "type": "int",
369                     "metavar": "<n-processes>",
370                     "short": "j",
371                     "default": 1,
372                     "help": "Use multiple processes to speed up Pylint. Specifying 0 will "
373                     "auto-detect the number of processors available to use.",
374                 },
375             ),
376             (
377                 "unsafe-load-any-extension",
378                 {
379                     "type": "yn",
380                     "metavar": "<yn>",
381                     "default": False,
382                     "hide": True,
383                     "help": (
384                         "Allow loading of arbitrary C extensions. Extensions"
385                         " are imported into the active Python interpreter and"
386                         " may run arbitrary code."
387                     ),
388                 },
389             ),
390             (
391                 "limit-inference-results",
392                 {
393                     "type": "int",
394                     "metavar": "<number-of-results>",
395                     "default": 100,
396                     "help": (
397                         "Control the amount of potential inferred values when inferring "
398                         "a single object. This can help the performance when dealing with "
399                         "large functions or complex, nested conditions. "
400                     ),
401                 },
402             ),
403             (
404                 "extension-pkg-allow-list",
405                 {
406                     "type": "csv",
407                     "metavar": "<pkg[,pkg]>",
408                     "default": [],
409                     "help": (
410                         "A comma-separated list of package or module names"
411                         " from where C extensions may be loaded. Extensions are"
412                         " loading into the active Python interpreter and may run"
413                         " arbitrary code."
414                     ),
415                 },
416             ),
417             (
418                 "extension-pkg-whitelist",
419                 {
420                     "type": "csv",
421                     "metavar": "<pkg[,pkg]>",
422                     "default": [],
423                     "help": (
424                         "A comma-separated list of package or module names"
425                         " from where C extensions may be loaded. Extensions are"
426                         " loading into the active Python interpreter and may run"
427                         " arbitrary code. (This is an alternative name to"
428                         " extension-pkg-allow-list for backward compatibility.)"
429                     ),
430                 },
431             ),
432             (
433                 "suggestion-mode",
434                 {
435                     "type": "yn",
436                     "metavar": "<yn>",
437                     "default": True,
438                     "help": (
439                         "When enabled, pylint would attempt to guess common "
440                         "misconfiguration and emit user-friendly hints instead "
441                         "of false-positive error messages."
442                     ),
443                 },
444             ),
445             (
446                 "exit-zero",
447                 {
448                     "action": "store_true",
449                     "help": (
450                         "Always return a 0 (non-error) status code, even if "
451                         "lint errors are found. This is primarily useful in "
452                         "continuous integration scripts."
453                     ),
454                 },
455             ),
456             (
457                 "from-stdin",
458                 {
459                     "action": "store_true",
460                     "help": (
461                         "Interpret the stdin as a python script, whose filename "
462                         "needs to be passed as the module_or_package argument."
463                     ),
464                 },
465             ),
466         )
467 
468     option_groups = (
469         ("Messages control", "Options controlling analysis messages"),
470         ("Reports", "Options related to output formatting and reporting"),
471     )
472 
473     def __init__(self, options=(), reporter=None, option_groups=(), pylintrc=None):
474         """Some stuff has to be done before ancestors initialization...
475         messages store / checkers / reporter / astroid manager"""
476         self.msgs_store = MessageDefinitionStore()
477         self.reporter = None
478         self._reporter_names = None
479         self._reporters = {}
480         self._checkers = collections.defaultdict(list)
481         self._pragma_lineno = {}
482         self._ignore_file = False
483         # visit variables
484         self.file_state = FileState()
485         self.current_name = None
486         self.current_file = None
487         self.stats = None
488         self.fail_on_symbols = []
489         # init options
490         self._external_opts = options
491         self.options = options + PyLinter.make_options()
492         self.option_groups = option_groups + PyLinter.option_groups
493         self._options_methods = {"enable": self.enable, "disable": self.disable}
494         self._bw_options_methods = {
495             "disable-msg": self._options_methods["disable"],
496             "enable-msg": self._options_methods["enable"],
497         }
498         MessagesHandlerMixIn.__init__(self)
499         reporters.ReportsHandlerMixIn.__init__(self)
500         super().__init__(
501             usage=__doc__,
502             config_file=pylintrc or next(config.find_default_config_files(), None),
503         )
504         checkers.BaseTokenChecker.__init__(self)
505         # provided reports
506         self.reports = (
507             ("RP0001", "Messages by category", report_total_messages_stats),
508             (
509                 "RP0002",
510                 "% errors / warnings by module",
511                 report_messages_by_module_stats,
512             ),
513             ("RP0003", "Messages", report_messages_stats),
514         )
515         self.register_checker(self)
516         self._dynamic_plugins = set()
517         self._python3_porting_mode = False
518         self._error_mode = False
519         self.load_provider_defaults()
520         if reporter:
521             self.set_reporter(reporter)
522 
523     def load_default_plugins(self):
524         checkers.initialize(self)
525         reporters.initialize(self)
526         # Make sure to load the default reporter, because
527         # the option has been set before the plugins had been loaded.
528         if not self.reporter:
529             self._load_reporters()
530 
531     def load_plugin_modules(self, modnames):
532         """take a list of module names which are pylint plugins and load
533         and register them
534         """
535         for modname in modnames:
536             if modname in self._dynamic_plugins:
537                 continue
538             self._dynamic_plugins.add(modname)
539             try:
540                 module = astroid.modutils.load_module_from_name(modname)
541                 module.register(self)
542             except ModuleNotFoundError:
543                 pass
544 
545     def load_plugin_configuration(self):
546         """Call the configuration hook for plugins
547 
548         This walks through the list of plugins, grabs the "load_configuration"
549         hook, if exposed, and calls it to allow plugins to configure specific
550         settings.
551         """
552         for modname in self._dynamic_plugins:
553             try:
554                 module = astroid.modutils.load_module_from_name(modname)
555                 if hasattr(module, "load_configuration"):
556                     module.load_configuration(self)
557             except ModuleNotFoundError as e:
558                 self.add_message("bad-plugin-value", args=(modname, e), line=0)
559 
560     def _load_reporters(self) -> None:
561         sub_reporters = []
562         output_files = []
563         with contextlib.ExitStack() as stack:
564             for reporter_name in self._reporter_names.split(","):
565                 reporter_name, *reporter_output = reporter_name.split(":", 1)
566 
567                 reporter = self._load_reporter_by_name(reporter_name)
568                 sub_reporters.append(reporter)
569 
570                 if reporter_output:
571                     (reporter_output,) = reporter_output
572 
573                     # pylint: disable=consider-using-with
574                     output_file = stack.enter_context(open(reporter_output, "w"))
575 
576                     reporter.set_output(output_file)
577                     output_files.append(output_file)
578 
579             # Extend the lifetime of all opened output files
580             close_output_files = stack.pop_all().close
581 
582         if len(sub_reporters) > 1 or output_files:
583             self.set_reporter(
584                 reporters.MultiReporter(
585                     sub_reporters,
586                     close_output_files,
587                 )
588             )
589         else:
590             self.set_reporter(sub_reporters[0])
591 
592     def _load_reporter_by_name(self, reporter_name: str) -> reporters.BaseReporter:
593         name = reporter_name.lower()
594         if name in self._reporters:
595             return self._reporters[name]()
596 
597         try:
598             reporter_class = _load_reporter_by_class(reporter_name)
599         except (ImportError, AttributeError) as e:
600             raise exceptions.InvalidReporterError(name) from e
601         else:
602             return reporter_class()
603 
604     def set_reporter(self, reporter):
605         """set the reporter used to display messages and reports"""
606         self.reporter = reporter
607         reporter.linter = self
608 
609     def set_option(self, optname, value, action=None, optdict=None):
610         """overridden from config.OptionsProviderMixin to handle some
611         special options
612         """
613         if optname in self._options_methods or optname in self._bw_options_methods:
614             if value:
615                 try:
616                     meth = self._options_methods[optname]
617                 except KeyError:
618                     meth = self._bw_options_methods[optname]
619                     warnings.warn(
620                         "%s is deprecated, replace it by %s"
621                         % (optname, optname.split("-")[0]),
622                         DeprecationWarning,
623                     )
624                 value = utils._check_csv(value)
625                 if isinstance(value, (list, tuple)):
626                     for _id in value:
627                         meth(_id, ignore_unknown=True)
628                 else:
629                     meth(value)
630                 return  # no need to call set_option, disable/enable methods do it
631         elif optname == "output-format":
632             self._reporter_names = value
633             # If the reporters are already available, load
634             # the reporter class.
635             if self._reporters:
636                 self._load_reporters()
637 
638         try:
639             checkers.BaseTokenChecker.set_option(self, optname, value, action, optdict)
640         except config.UnsupportedAction:
641             print("option %s can't be read from config file" % optname, file=sys.stderr)
642 
643     def register_reporter(self, reporter_class):
644         self._reporters[reporter_class.name] = reporter_class
645 
646     def report_order(self):
647         reports = sorted(self._reports, key=lambda x: getattr(x, "name", ""))
648         try:
649             # Remove the current reporter and add it
650             # at the end of the list.
651             reports.pop(reports.index(self))
652         except ValueError:
653             pass
654         else:
655             reports.append(self)
656         return reports
657 
658     # checkers manipulation methods ############################################
659 
660     def register_checker(self, checker):
661         """register a new checker
662 
663         checker is an object implementing IRawChecker or / and IAstroidChecker
664         """
665         assert checker.priority <= 0, "checker priority can't be >= 0"
666         self._checkers[checker.name].append(checker)
667         for r_id, r_title, r_cb in checker.reports:
668             self.register_report(r_id, r_title, r_cb, checker)
669         self.register_options_provider(checker)
670         if hasattr(checker, "msgs"):
671             self.msgs_store.register_messages_from_checker(checker)
672         checker.load_defaults()
673 
674         # Register the checker, but disable all of its messages.
675         if not getattr(checker, "enabled", True):
676             self.disable(checker.name)
677 
678     def enable_fail_on_messages(self):
679         """enable 'fail on' msgs
680 
681         Convert values in config.fail_on (which might be msg category, msg id,
682         or symbol) to specific msgs, then enable and flag them for later.
683         """
684         fail_on_vals = self.config.fail_on
685         if not fail_on_vals:
686             return
687 
688         fail_on_cats = set()
689         fail_on_msgs = set()
690         for val in fail_on_vals:
691             # If value is a cateogry, add category, else add message
692             if val in MSG_TYPES:
693                 fail_on_cats.add(val)
694             else:
695                 fail_on_msgs.add(val)
696 
697         # For every message in every checker, if cat or msg flagged, enable check
698         for all_checkers in self._checkers.values():
699             for checker in all_checkers:
700                 for msg in checker.messages:
701                     if msg.msgid in fail_on_msgs or msg.symbol in fail_on_msgs:
702                         # message id/symbol matched, enable and flag it
703                         self.enable(msg.msgid)
704                         self.fail_on_symbols.append(msg.symbol)
705                     elif msg.msgid[0] in fail_on_cats:
706                         # message starts with a cateogry value, flag (but do not enable) it
707                         self.fail_on_symbols.append(msg.symbol)
708 
709     def any_fail_on_issues(self):
710         return any(x in self.fail_on_symbols for x in self.stats["by_msg"])
711 
712     def disable_noerror_messages(self):
713         for msgcat, msgids in self.msgs_store._msgs_by_category.items():
714             # enable only messages with 'error' severity and above ('fatal')
715             if msgcat in ["E", "F"]:
716                 for msgid in msgids:
717                     self.enable(msgid)
718             else:
719                 for msgid in msgids:
720                     self.disable(msgid)
721 
722     def disable_reporters(self):
723         """disable all reporters"""
724         for _reporters in self._reports.values():
725             for report_id, _, _ in _reporters:
726                 self.disable_report(report_id)
727 
728     def error_mode(self):
729         """error mode: enable only errors; no reports, no persistent"""
730         self._error_mode = True
731         self.disable_noerror_messages()
732         self.disable("miscellaneous")
733         if self._python3_porting_mode:
734             self.disable("all")
735             for msg_id in self._checker_messages("python3"):
736                 if msg_id.startswith("E"):
737                     self.enable(msg_id)
738             config_parser = self.cfgfile_parser
739             if config_parser.has_option("MESSAGES CONTROL", "disable"):
740                 value = config_parser.get("MESSAGES CONTROL", "disable")
741                 self.global_set_option("disable", value)
742         else:
743             self.disable("python3")
744         self.set_option("reports", False)
745         self.set_option("persistent", False)
746         self.set_option("score", False)
747 
748     def python3_porting_mode(self):
749         """Disable all other checkers and enable Python 3 warnings."""
750         self.disable("all")
751         # re-enable some errors, or 'print', 'raise', 'async', 'await' will mistakenly lint fine
752         self.enable("fatal")  # F0001
753         self.enable("astroid-error")  # F0002
754         self.enable("parse-error")  # F0010
755         self.enable("syntax-error")  # E0001
756         self.enable("python3")
757         if self._error_mode:
758             # The error mode was activated, using the -E flag.
759             # So we'll need to enable only the errors from the
760             # Python 3 porting checker.
761             for msg_id in self._checker_messages("python3"):
762                 if msg_id.startswith("E"):
763                     self.enable(msg_id)
764                 else:
765                     self.disable(msg_id)
766         config_parser = self.cfgfile_parser
767         if config_parser.has_option("MESSAGES CONTROL", "disable"):
768             value = config_parser.get("MESSAGES CONTROL", "disable")
769             self.global_set_option("disable", value)
770         self._python3_porting_mode = True
771 
772     def list_messages_enabled(self):
773         enabled = [
774             f"  {message.symbol} ({message.msgid})"
775             for message in self.msgs_store.messages
776             if self.is_message_enabled(message.msgid)
777         ]
778         disabled = [
779             f"  {message.symbol} ({message.msgid})"
780             for message in self.msgs_store.messages
781             if not self.is_message_enabled(message.msgid)
782         ]
783         print("Enabled messages:")
784         for msg in sorted(enabled):
785             print(msg)
786         print("\nDisabled messages:")
787         for msg in sorted(disabled):
788             print(msg)
789         print("")
790 
791     # block level option handling #############################################
792     # see func_block_disable_msg.py test case for expected behaviour
793 
794     def process_tokens(self, tokens):
795         """Process tokens from the current module to search for module/block level
796         options."""
797         control_pragmas = {"disable", "enable"}
798         prev_line = None
799         saw_newline = True
800         seen_newline = True
801         for (tok_type, content, start, _, _) in tokens:
802             if prev_line and prev_line != start[0]:
803                 saw_newline = seen_newline
804                 seen_newline = False
805 
806             prev_line = start[0]
807             if tok_type in (tokenize.NL, tokenize.NEWLINE):
808                 seen_newline = True
809 
810             if tok_type != tokenize.COMMENT:
811                 continue
812             match = OPTION_PO.search(content)
813             if match is None:
814                 continue
815             try:
816                 for pragma_repr in parse_pragma(match.group(2)):
817                     if pragma_repr.action in ("disable-all", "skip-file"):
818                         if pragma_repr.action == "disable-all":
819                             self.add_message(
820                                 "deprecated-pragma",
821                                 line=start[0],
822                                 args=("disable-all", "skip-file"),
823                             )
824                         self.add_message("file-ignored", line=start[0])
825                         self._ignore_file = True
826                         return
827                     try:
828                         meth = self._options_methods[pragma_repr.action]
829                     except KeyError:
830                         meth = self._bw_options_methods[pragma_repr.action]
831                         # found a "(dis|en)able-msg" pragma deprecated suppression
832                         self.add_message(
833                             "deprecated-pragma",
834                             line=start[0],
835                             args=(
836                                 pragma_repr.action,
837                                 pragma_repr.action.replace("-msg", ""),
838                             ),
839                         )
840                     for msgid in pragma_repr.messages:
841                         # Add the line where a control pragma was encountered.
842                         if pragma_repr.action in control_pragmas:
843                             self._pragma_lineno[msgid] = start[0]
844 
845                         if (pragma_repr.action, msgid) == ("disable", "all"):
846                             self.add_message(
847                                 "deprecated-pragma",
848                                 line=start[0],
849                                 args=("disable=all", "skip-file"),
850                             )
851                             self.add_message("file-ignored", line=start[0])
852                             self._ignore_file = True
853                             return
854                             # If we did not see a newline between the previous line and now,
855                             # we saw a backslash so treat the two lines as one.
856                         l_start = start[0]
857                         if not saw_newline:
858                             l_start -= 1
859                         try:
860                             meth(msgid, "module", l_start)
861                         except exceptions.UnknownMessageError:
862                             self.add_message(
863                                 "bad-option-value", args=msgid, line=start[0]
864                             )
865             except UnRecognizedOptionError as err:
866                 self.add_message(
867                     "unrecognized-inline-option", args=err.token, line=start[0]
868                 )
869                 continue
870             except InvalidPragmaError as err:
871                 self.add_message("bad-inline-option", args=err.token, line=start[0])
872                 continue
873 
874     # code checking methods ###################################################
875 
876     def get_checkers(self):
877         """return all available checkers as a list"""
878         return [self] + [
879             c
880             for _checkers in self._checkers.values()
881             for c in _checkers
882             if c is not self
883         ]
884 
885     def get_checker_names(self):
886         """Get all the checker names that this linter knows about."""
887         current_checkers = self.get_checkers()
888         return sorted(
889             {
890                 checker.name
891                 for checker in current_checkers
892                 if checker.name != MAIN_CHECKER_NAME
893             }
894         )
895 
896     def prepare_checkers(self):
897         """return checkers needed for activated messages and reports"""
898         if not self.config.reports:
899             self.disable_reporters()
900         # get needed checkers
901         needed_checkers = [self]
902         for checker in self.get_checkers()[1:]:
903             messages = {msg for msg in checker.msgs if self.is_message_enabled(msg)}
904             if messages or any(self.report_is_enabled(r[0]) for r in checker.reports):
905                 needed_checkers.append(checker)
906         # Sort checkers by priority
907         needed_checkers = sorted(
908             needed_checkers, key=operator.attrgetter("priority"), reverse=True
909         )
910         return needed_checkers
911 
912     # pylint: disable=unused-argument
913     @staticmethod
914     def should_analyze_file(modname, path, is_argument=False):
915         """Returns whether or not a module should be checked.
916 
917         This implementation returns True for all python source file, indicating
918         that all files should be linted.
919 
920         Subclasses may override this method to indicate that modules satisfying
921         certain conditions should not be linted.
922 
923         :param str modname: The name of the module to be checked.
924         :param str path: The full path to the source code of the module.
925         :param bool is_argument: Whether the file is an argument to pylint or not.
926                                  Files which respect this property are always
927                                  checked, since the user requested it explicitly.
928         :returns: True if the module should be checked.
929         :rtype: bool
930         """
931         if is_argument:
932             return True
933         return path.endswith(".py")
934 
935     # pylint: enable=unused-argument
936 
937     def initialize(self):
938         """Initialize linter for linting
939 
940         This method is called before any linting is done.
941         """
942         # initialize msgs_state now that all messages have been registered into
943         # the store
944         for msg in self.msgs_store.messages:
945             if not msg.may_be_emitted():
946                 self._msgs_state[msg.msgid] = False
947 
948     def check(self, files_or_modules):
949         """main checking entry: check a list of files or modules from their name.
950 
951         files_or_modules is either a string or list of strings presenting modules to check.
952         """
953 
954         self.initialize()
955 
956         if not isinstance(files_or_modules, (list, tuple)):
957             files_or_modules = (files_or_modules,)
958 
959         if self.config.from_stdin:
960             if len(files_or_modules) != 1:
961                 raise exceptions.InvalidArgsError(
962                     "Missing filename required for --from-stdin"
963                 )
964 
965             filepath = files_or_modules[0]
966             with fix_import_path(files_or_modules):
967                 self._check_files(
968                     functools.partial(self.get_ast, data=_read_stdin()),
969                     [self._get_file_descr_from_stdin(filepath)],
970                 )
971         elif self.config.jobs == 1:
972             with fix_import_path(files_or_modules):
973                 self._check_files(
974                     self.get_ast, self._iterate_file_descrs(files_or_modules)
975                 )
976         else:
977             check_parallel(
978                 self,
979                 self.config.jobs,
980                 self._iterate_file_descrs(files_or_modules),
981                 files_or_modules,
982             )
983 
984     def check_single_file(self, name, filepath, modname):
985         """Check single file
986 
987         The arguments are the same that are documented in _check_files
988 
989         The initialize() method should be called before calling this method
990         """
991         with self._astroid_module_checker() as check_astroid_module:
992             self._check_file(
993                 self.get_ast, check_astroid_module, name, filepath, modname
994             )
995 
996     def _check_files(self, get_ast, file_descrs):
997         """Check all files from file_descrs
998 
999         The file_descrs should be iterable of tuple (name, filepath, modname)
1000         where
1001         - name: full name of the module
1002         - filepath: path of the file
1003         - modname: module name
1004         """
1005         with self._astroid_module_checker() as check_astroid_module:
1006             for name, filepath, modname in file_descrs:
1007                 self._check_file(get_ast, check_astroid_module, name, filepath, modname)
1008 
1009     def _check_file(self, get_ast, check_astroid_module, name, filepath, modname):
1010         """Check a file using the passed utility functions (get_ast and check_astroid_module)
1011 
1012         :param callable get_ast: callable returning AST from defined file taking the following arguments
1013         - filepath: path to the file to check
1014         - name: Python module name
1015         :param callable check_astroid_module: callable checking an AST taking the following arguments
1016         - ast: AST of the module
1017         :param str name: full name of the module
1018         :param str filepath: path to checked file
1019         :param str modname: name of the checked Python module
1020         """
1021         self.set_current_module(name, filepath)
1022         # get the module representation
1023         ast_node = get_ast(filepath, name)
1024         if ast_node is None:
1025             return
1026 
1027         self._ignore_file = False
1028 
1029         self.file_state = FileState(modname)
1030         # fix the current file (if the source file was not available or
1031         # if it's actually a c extension)
1032         self.current_file = ast_node.file  # pylint: disable=maybe-no-member
1033         check_astroid_module(ast_node)
1034         # warn about spurious inline messages handling
1035         spurious_messages = self.file_state.iter_spurious_suppression_messages(
1036             self.msgs_store
1037         )
1038         for msgid, line, args in spurious_messages:
1039             self.add_message(msgid, line, None, args)
1040 
1041     @staticmethod
1042     def _get_file_descr_from_stdin(filepath):
1043         """Return file description (tuple of module name, file path, base name) from given file path
1044 
1045         This method is used for creating suitable file description for _check_files when the
1046         source is standard input.
1047         """
1048         try:
1049             # Note that this function does not really perform an
1050             # __import__ but may raise an ImportError exception, which
1051             # we want to catch here.
1052             modname = ".".join(astroid.modutils.modpath_from_file(filepath))
1053         except ImportError:
1054             modname = os.path.splitext(os.path.basename(filepath))[0]
1055 
1056         return (modname, filepath, filepath)
1057 
1058     def _iterate_file_descrs(self, files_or_modules):
1059         """Return generator yielding file descriptions (tuples of module name, file path, base name)
1060 
1061         The returned generator yield one item for each Python module that should be linted.
1062         """
1063         for descr in self._expand_files(files_or_modules):
1064             name, filepath, is_arg = descr["name"], descr["path"], descr["isarg"]
1065             if self.should_analyze_file(name, filepath, is_argument=is_arg):
1066                 yield (name, filepath, descr["basename"])
1067 
1068     def _expand_files(self, modules):
1069         """get modules and errors from a list of modules and handle errors"""
1070         result, errors = expand_modules(
1071             modules,
1072             self.config.black_list,
1073             self.config.black_list_re,
1074             self.config.ignore_list_paths_re,
1075         )
1076         for error in errors:
1077             message = modname = error["mod"]
1078             key = error["key"]
1079             self.set_current_module(modname)
1080             if key == "fatal":
1081                 message = str(error["ex"]).replace(os.getcwd() + os.sep, "")
1082             self.add_message(key, args=message)
1083         return result
1084 
1085     def set_current_module(self, modname, filepath=None):
1086         """set the name of the currently analyzed module and
1087         init statistics for it
1088         """
1089         if not modname and filepath is None:
1090             return
1091         self.reporter.on_set_current_module(modname, filepath)
1092         self.current_name = modname
1093         self.current_file = filepath or modname
1094         self.stats["by_module"][modname] = {}
1095         self.stats["by_module"][modname]["statement"] = 0
1096         for msg_cat in MSG_TYPES.values():
1097             self.stats["by_module"][modname][msg_cat] = 0
1098 
1099     @contextlib.contextmanager
1100     def _astroid_module_checker(self):
1101         """Context manager for checking ASTs
1102 
1103         The value in the context is callable accepting AST as its only argument.
1104         """
1105         walker = ASTWalker(self)
1106         _checkers = self.prepare_checkers()
1107         tokencheckers = [
1108             c
1109             for c in _checkers
1110             if interfaces.implements(c, interfaces.ITokenChecker) and c is not self
1111         ]
1112         rawcheckers = [
1113             c for c in _checkers if interfaces.implements(c, interfaces.IRawChecker)
1114         ]
1115         # notify global begin
1116         for checker in _checkers:
1117             checker.open()
1118             if interfaces.implements(checker, interfaces.IAstroidChecker):
1119                 walker.add_checker(checker)
1120 
1121         yield functools.partial(
1122             self.check_astroid_module,
1123             walker=walker,
1124             tokencheckers=tokencheckers,
1125             rawcheckers=rawcheckers,
1126         )
1127 
1128         # notify global end
1129         self.stats["statement"] = walker.nbstatements
1130         for checker in reversed(_checkers):
1131             checker.close()
1132 
1133     def get_ast(self, filepath, modname, data=None):
1134         """Return an ast(roid) representation of a module or a string.
1135 
1136         :param str filepath: path to checked file.
1137         :param str modname: The name of the module to be checked.
1138         :param str data: optional contents of the checked file.
1139         :returns: the AST
1140         :rtype: astroid.nodes.Module
1141         """
1142         try:
1143             if data is None:
1144                 return MANAGER.ast_from_file(filepath, modname, source=True)
1145             return astroid.builder.AstroidBuilder(MANAGER).string_build(
1146                 data, modname, filepath
1147             )
1148         except astroid.AstroidSyntaxError as ex:
1149             # pylint: disable=no-member
1150             self.add_message(
1151                 "syntax-error",
1152                 line=getattr(ex.error, "lineno", 0),
1153                 col_offset=getattr(ex.error, "offset", None),
1154                 args=str(ex.error),
1155             )
1156         except astroid.AstroidBuildingException as ex:
1157             self.add_message("parse-error", args=ex)
1158         except Exception as ex:  # pylint: disable=broad-except
1159             traceback.print_exc()
1160             self.add_message("astroid-error", args=(ex.__class__, ex))
1161         return None
1162 
1163     def check_astroid_module(self, ast_node, walker, rawcheckers, tokencheckers):
1164         """Check a module from its astroid representation.
1165 
1166         For return value see _check_astroid_module
1167         """
1168         before_check_statements = walker.nbstatements
1169 
1170         retval = self._check_astroid_module(
1171             ast_node, walker, rawcheckers, tokencheckers
1172         )
1173 
1174         self.stats["by_module"][self.current_name]["statement"] = (
1175             walker.nbstatements - before_check_statements
1176         )
1177 
1178         return retval
1179 
1180     def _check_astroid_module(self, ast_node, walker, rawcheckers, tokencheckers):
1181         """Check given AST node with given walker and checkers
1182 
1183         :param astroid.nodes.Module ast_node: AST node of the module to check
1184         :param pylint.utils.ast_walker.ASTWalker walker: AST walker
1185         :param list rawcheckers: List of token checkers to use
1186         :param list tokencheckers: List of raw checkers to use
1187 
1188         :returns: True if the module was checked, False if ignored,
1189             None if the module contents could not be parsed
1190         :rtype: bool
1191         """
1192         try:
1193             tokens = utils.tokenize_module(ast_node)
1194         except tokenize.TokenError as ex:
1195             self.add_message("syntax-error", line=ex.args[1][0], args=ex.args[0])
1196             return None
1197 
1198         if not ast_node.pure_python:
1199             self.add_message("raw-checker-failed", args=ast_node.name)
1200         else:
1201             # assert astroid.file.endswith('.py')
1202             # invoke ITokenChecker interface on self to fetch module/block
1203             # level options
1204             self.process_tokens(tokens)
1205             if self._ignore_file:
1206                 return False
1207             # walk ast to collect line numbers
1208             self.file_state.collect_block_lines(self.msgs_store, ast_node)
1209             # run raw and tokens checkers
1210             for checker in rawcheckers:
1211                 checker.process_module(ast_node)
1212             for checker in tokencheckers:
1213                 checker.process_tokens(tokens)
1214         # generate events to astroid checkers
1215         walker.walk(ast_node)
1216         return True
1217 
1218     # IAstroidChecker interface #################################################
1219 
1220     def open(self):
1221         """initialize counters"""
1222         self.stats = {"by_module": {}, "by_msg": {}}
1223         MANAGER.always_load_extensions = self.config.unsafe_load_any_extension
1224         MANAGER.max_inferable_values = self.config.limit_inference_results
1225         MANAGER.extension_package_whitelist.update(self.config.extension_pkg_allow_list)
1226         if self.config.extension_pkg_whitelist:
1227             MANAGER.extension_package_whitelist.update(
1228                 self.config.extension_pkg_whitelist
1229             )
1230         for msg_cat in MSG_TYPES.values():
1231             self.stats[msg_cat] = 0
1232 
1233     def generate_reports(self):
1234         """close the whole package /module, it's time to make reports !
1235 
1236         if persistent run, pickle results for later comparison
1237         """
1238         # Display whatever messages are left on the reporter.
1239         self.reporter.display_messages(report_nodes.Section())
1240 
1241         if self.file_state.base_name is not None:
1242             # load previous results if any
1243             previous_stats = config.load_results(self.file_state.base_name)
1244             self.reporter.on_close(self.stats, previous_stats)
1245             if self.config.reports:
1246                 sect = self.make_reports(self.stats, previous_stats)
1247             else:
1248                 sect = report_nodes.Section()
1249 
1250             if self.config.reports:
1251                 self.reporter.display_reports(sect)
1252             score_value = self._report_evaluation()
1253             # save results if persistent run
1254             if self.config.persistent:
1255                 config.save_results(self.stats, self.file_state.base_name)
1256         else:
1257             self.reporter.on_close(self.stats, {})
1258             score_value = None
1259         return score_value
1260 
1261     def _report_evaluation(self):
1262         """make the global evaluation report"""
1263         # check with at least check 1 statements (usually 0 when there is a
1264         # syntax error preventing pylint from further processing)
1265         note = None
1266         previous_stats = config.load_results(self.file_state.base_name)
1267         if self.stats["statement"] == 0:
1268             return note
1269 
1270         # get a global note for the code
1271         evaluation = self.config.evaluation
1272         try:
1273             note = eval(evaluation, {}, self.stats)  # pylint: disable=eval-used
1274         except Exception as ex:  # pylint: disable=broad-except
1275             msg = "An exception occurred while rating: %s" % ex
1276         else:
1277             self.stats["global_note"] = note
1278             msg = "Your code has been rated at %.2f/10" % note
1279             pnote = previous_stats.get("global_note")
1280             if pnote is not None:
1281                 msg += f" (previous run: {pnote:.2f}/10, {note - pnote:+.2f})"
1282 
1283         if self.config.score:
1284             sect = report_nodes.EvaluationSection(msg)
1285             self.reporter.display_reports(sect)
1286         return note

</code><intended_behavior>As part of the linting process, ensure that the analysis phase that feeds into `pyreverse` can identify and pass along type hint information. Though not directly responsible for UML generation, enhancing this component to better recognize and handle type hints could benefit the overall goal of improving UML output.</intended_behavior>]
2025-10-18 04:25:30.326 | INFO     | Search completed. Bug locations: [<file>pylint/pyreverse/writer.py</file>
<class>None</class>
<method>None</method>
<code>
1 # Copyright (c) 2008-2010, 2013-2014 LOGILAB S.A. (Paris, FRANCE) <contact@logilab.fr>
2 # Copyright (c) 2014 Arun Persaud <arun@nubati.net>
3 # Copyright (c) 2015-2018, 2020 Claudiu Popa <pcmanticore@gmail.com>
4 # Copyright (c) 2015 Mike Frysinger <vapier@gentoo.org>
5 # Copyright (c) 2015 Florian Bruhin <me@the-compiler.org>
6 # Copyright (c) 2015 Ionel Cristian Maries <contact@ionelmc.ro>
7 # Copyright (c) 2018, 2020 Anthony Sottile <asottile@umich.edu>
8 # Copyright (c) 2018 ssolanki <sushobhitsolanki@gmail.com>
9 # Copyright (c) 2019-2021 Pierre Sassoulas <pierre.sassoulas@gmail.com>
10 # Copyright (c) 2019 Kylian <development@goudcode.nl>
11 # Copyright (c) 2021 Andreas Finkler <andi.finkler@gmail.com>
12 # Copyright (c) 2021 Mark Byrne <mbyrnepr2@gmail.com>
13 
14 # Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
15 # For details: https://github.com/PyCQA/pylint/blob/master/LICENSE
16 
17 """Utilities for creating VCG and Dot diagrams"""
18 
19 import os
20 
21 from pylint.graph import DotBackend
22 from pylint.pyreverse.utils import is_exception
23 from pylint.pyreverse.vcgutils import VCGPrinter
24 
25 
26 class DiagramWriter:
27     """base class for writing project diagrams"""
28 
29     def __init__(self, config, styles):
30         self.config = config
31         self.pkg_edges, self.inh_edges, self.imp_edges, self.association_edges = styles
32         self.printer = None  # defined in set_printer
33 
34     def write(self, diadefs):
35         """write files for <project> according to <diadefs>"""
36         for diagram in diadefs:
37             basename = diagram.title.strip().replace(" ", "_")
38             file_name = f"{basename}.{self.config.output_format}"
39             if os.path.exists(self.config.output_directory):
40                 file_name = os.path.join(self.config.output_directory, file_name)
41             self.set_printer(file_name, basename)
42             if diagram.TYPE == "class":
43                 self.write_classes(diagram)
44             else:
45                 self.write_packages(diagram)
46             self.close_graph()
47 
48     def write_packages(self, diagram):
49         """write a package diagram"""
50         # sorted to get predictable (hence testable) results
51         for i, obj in enumerate(sorted(diagram.modules(), key=lambda x: x.title)):
52             self.printer.emit_node(i, label=self.get_title(obj), shape="box")
53             obj.fig_id = i
54         # package dependencies
55         for rel in diagram.get_relationships("depends"):
56             self.printer.emit_edge(
57                 rel.from_object.fig_id, rel.to_object.fig_id, **self.pkg_edges
58             )
59 
60     def write_classes(self, diagram):
61         """write a class diagram"""
62         # sorted to get predictable (hence testable) results
63         for i, obj in enumerate(sorted(diagram.objects, key=lambda x: x.title)):
64             self.printer.emit_node(i, **self.get_values(obj))
65             obj.fig_id = i
66         # inheritance links
67         for rel in diagram.get_relationships("specialization"):
68             self.printer.emit_edge(
69                 rel.from_object.fig_id, rel.to_object.fig_id, **self.inh_edges
70             )
71         # implementation links
72         for rel in diagram.get_relationships("implements"):
73             self.printer.emit_edge(
74                 rel.from_object.fig_id, rel.to_object.fig_id, **self.imp_edges
75             )
76         # generate associations
77         for rel in diagram.get_relationships("association"):
78             self.printer.emit_edge(
79                 rel.from_object.fig_id,
80                 rel.to_object.fig_id,
81                 label=rel.name,
82                 **self.association_edges,
83             )
84 
85     def set_printer(self, file_name, basename):
86         """set printer"""
87         raise NotImplementedError
88 
89     def get_title(self, obj):
90         """get project title"""
91         raise NotImplementedError
92 
93     def get_values(self, obj):
94         """get label and shape for classes."""
95         raise NotImplementedError
96 
97     def close_graph(self):
98         """finalize the graph"""
99         raise NotImplementedError
100 
101 
102 class DotWriter(DiagramWriter):
103     """write dot graphs from a diagram definition and a project"""
104 
105     def __init__(self, config):
106         styles = [
107             dict(arrowtail="none", arrowhead="open"),
108             dict(arrowtail="none", arrowhead="empty"),
109             dict(arrowtail="node", arrowhead="empty", style="dashed"),
110             dict(
111                 fontcolor="green", arrowtail="none", arrowhead="diamond", style="solid"
112             ),
113         ]
114         DiagramWriter.__init__(self, config, styles)
115 
116     def set_printer(self, file_name, basename):
117         """initialize DotWriter and add options for layout."""
118         layout = dict(rankdir="BT")
119         self.printer = DotBackend(basename, additional_param=layout)
120         self.file_name = file_name
121 
122     def get_title(self, obj):
123         """get project title"""
124         return obj.title
125 
126     def get_values(self, obj):
127         """get label and shape for classes.
128 
129         The label contains all attributes and methods
130         """
131         label = obj.title
132         if obj.shape == "interface":
133             label = "«interface»\\n%s" % label
134         if not self.config.only_classnames:
135             label = r"{}|{}\l|".format(label, r"\l".join(obj.attrs))
136             for func in obj.methods:
137                 if func.args.args:
138                     args = [arg.name for arg in func.args.args if arg.name != "self"]
139                 else:
140                     args = []
141                 label = r"{}{}({})\l".format(label, func.name, ", ".join(args))
142             label = "{%s}" % label
143         if is_exception(obj.node):
144             return dict(fontcolor="red", label=label, shape="record")
145         return dict(label=label, shape="record")
146 
147     def close_graph(self):
148         """print the dot graph into <file_name>"""
149         self.printer.generate(self.file_name)
150 
151 
152 class VCGWriter(DiagramWriter):
153     """write vcg graphs from a diagram definition and a project"""
154 
155     def __init__(self, config):
156         styles = [
157             dict(arrowstyle="solid", backarrowstyle="none", backarrowsize=0),
158             dict(arrowstyle="solid", backarrowstyle="none", backarrowsize=10),
159             dict(
160                 arrowstyle="solid",
161                 backarrowstyle="none",
162                 linestyle="dotted",
163                 backarrowsize=10,
164             ),
165             dict(arrowstyle="solid", backarrowstyle="none", textcolor="green"),
166         ]
167         DiagramWriter.__init__(self, config, styles)
168 
169     def set_printer(self, file_name, basename):
170         """initialize VCGWriter for a UML graph"""
171         self.graph_file = open(file_name, "w+")  # pylint: disable=consider-using-with
172         self.printer = VCGPrinter(self.graph_file)
173         self.printer.open_graph(
174             title=basename,
175             layoutalgorithm="dfs",
176             late_edge_labels="yes",
177             port_sharing="no",
178             manhattan_edges="yes",
179         )
180         self.printer.emit_node = self.printer.node
181         self.printer.emit_edge = self.printer.edge
182 
183     def get_title(self, obj):
184         """get project title in vcg format"""
185         return r"\fb%s\fn" % obj.title
186 
187     def get_values(self, obj):
188         """get label and shape for classes.
189 
190         The label contains all attributes and methods
191         """
192         if is_exception(obj.node):
193             label = r"\fb\f09%s\fn" % obj.title
194         else:
195             label = r"\fb%s\fn" % obj.title
196         if obj.shape == "interface":
197             shape = "ellipse"
198         else:
199             shape = "box"
200         if not self.config.only_classnames:
201             attrs = obj.attrs
202             methods = [func.name for func in obj.methods]
203             # box width for UML like diagram
204             maxlen = max(len(name) for name in [obj.title] + methods + attrs)
205             line = "_" * (maxlen + 2)
206             label = fr"{label}\n\f{line}"
207             for attr in attrs:
208                 label = fr"{label}\n\f08{attr}"
209             if attrs:
210                 label = fr"{label}\n\f{line}"
211             for func in methods:
212                 label = fr"{label}\n\f10{func}()"
213         return dict(label=label, shape=shape)
214 
215     def close_graph(self):
216         """close graph and file"""
217         self.printer.close_graph()
218         self.graph_file.close()

</code><intended_behavior>This file should be enhanced to ensure that when UML diagrams are being output, type hints associated with class attributes and method parameters are included. For an attribute or parameter initially set to `None` but annotated with a type hint (e.g., `a: str = None`), the UML diagram must display this as having the hinted type (e.g., `a : String`). This enhancement should preserve the ability to generate diagrams as currently done, adding the functionality to display type hints.</intended_behavior>, <file>pylint/pyreverse/diagrams.py</file>
<class>None</class>
<method>None</method>
<code>
1 # Copyright (c) 2006, 2008-2010, 2012-2014 LOGILAB S.A. (Paris, FRANCE) <contact@logilab.fr>
2 # Copyright (c) 2014-2018, 2020 Claudiu Popa <pcmanticore@gmail.com>
3 # Copyright (c) 2014 Brett Cannon <brett@python.org>
4 # Copyright (c) 2014 Arun Persaud <arun@nubati.net>
5 # Copyright (c) 2015 Ionel Cristian Maries <contact@ionelmc.ro>
6 # Copyright (c) 2018 ssolanki <sushobhitsolanki@gmail.com>
7 # Copyright (c) 2019-2021 Pierre Sassoulas <pierre.sassoulas@gmail.com>
8 # Copyright (c) 2020 hippo91 <guillaume.peillex@gmail.com>
9 
10 # Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
11 # For details: https://github.com/PyCQA/pylint/blob/master/LICENSE
12 
13 """diagram objects
14 """
15 
16 import astroid
17 
18 from pylint.checkers.utils import decorated_with_property
19 from pylint.pyreverse.utils import FilterMixIn, is_interface
20 
21 
22 class Figure:
23     """base class for counter handling"""
24 
25 
26 class Relationship(Figure):
27     """a relation ship from an object in the diagram to another"""
28 
29     def __init__(self, from_object, to_object, relation_type, name=None):
30         Figure.__init__(self)
31         self.from_object = from_object
32         self.to_object = to_object
33         self.type = relation_type
34         self.name = name
35 
36 
37 class DiagramEntity(Figure):
38     """a diagram object, i.e. a label associated to an astroid node"""
39 
40     def __init__(self, title="No name", node=None):
41         Figure.__init__(self)
42         self.title = title
43         self.node = node
44 
45 
46 class ClassDiagram(Figure, FilterMixIn):
47     """main class diagram handling"""
48 
49     TYPE = "class"
50 
51     def __init__(self, title, mode):
52         FilterMixIn.__init__(self, mode)
53         Figure.__init__(self)
54         self.title = title
55         self.objects = []
56         self.relationships = {}
57         self._nodes = {}
58         self.depends = []
59 
60     def get_relationships(self, role):
61         # sorted to get predictable (hence testable) results
62         return sorted(
63             self.relationships.get(role, ()),
64             key=lambda x: (x.from_object.fig_id, x.to_object.fig_id),
65         )
66 
67     def add_relationship(self, from_object, to_object, relation_type, name=None):
68         """create a relation ship"""
69         rel = Relationship(from_object, to_object, relation_type, name)
70         self.relationships.setdefault(relation_type, []).append(rel)
71 
72     def get_relationship(self, from_object, relation_type):
73         """return a relation ship or None"""
74         for rel in self.relationships.get(relation_type, ()):
75             if rel.from_object is from_object:
76                 return rel
77         raise KeyError(relation_type)
78 
79     def get_attrs(self, node):
80         """return visible attributes, possibly with class name"""
81         attrs = []
82         properties = [
83             (n, m)
84             for n, m in node.items()
85             if isinstance(m, astroid.FunctionDef) and decorated_with_property(m)
86         ]
87         for node_name, associated_nodes in (
88             list(node.instance_attrs_type.items())
89             + list(node.locals_type.items())
90             + properties
91         ):
92             if not self.show_attr(node_name):
93                 continue
94             names = self.class_names(associated_nodes)
95             if names:
96                 node_name = "{} : {}".format(node_name, ", ".join(names))
97             attrs.append(node_name)
98         return sorted(attrs)
99 
100     def get_methods(self, node):
101         """return visible methods"""
102         methods = [
103             m
104             for m in node.values()
105             if isinstance(m, astroid.FunctionDef)
106             and not decorated_with_property(m)
107             and self.show_attr(m.name)
108         ]
109         return sorted(methods, key=lambda n: n.name)
110 
111     def add_object(self, title, node):
112         """create a diagram object"""
113         assert node not in self._nodes
114         ent = DiagramEntity(title, node)
115         self._nodes[node] = ent
116         self.objects.append(ent)
117 
118     def class_names(self, nodes):
119         """return class names if needed in diagram"""
120         names = []
121         for node in nodes:
122             if isinstance(node, astroid.Instance):
123                 node = node._proxied
124             if (
125                 isinstance(node, astroid.ClassDef)
126                 and hasattr(node, "name")
127                 and not self.has_node(node)
128             ):
129                 if node.name not in names:
130                     node_name = node.name
131                     names.append(node_name)
132         return names
133 
134     def nodes(self):
135         """return the list of underlying nodes"""
136         return self._nodes.keys()
137 
138     def has_node(self, node):
139         """return true if the given node is included in the diagram"""
140         return node in self._nodes
141 
142     def object_from_node(self, node):
143         """return the diagram object mapped to node"""
144         return self._nodes[node]
145 
146     def classes(self):
147         """return all class nodes in the diagram"""
148         return [o for o in self.objects if isinstance(o.node, astroid.ClassDef)]
149 
150     def classe(self, name):
151         """return a class by its name, raise KeyError if not found"""
152         for klass in self.classes():
153             if klass.node.name == name:
154                 return klass
155         raise KeyError(name)
156 
157     def extract_relationships(self):
158         """extract relation ships between nodes in the diagram"""
159         for obj in self.classes():
160             node = obj.node
161             obj.attrs = self.get_attrs(node)
162             obj.methods = self.get_methods(node)
163             # shape
164             if is_interface(node):
165                 obj.shape = "interface"
166             else:
167                 obj.shape = "class"
168             # inheritance link
169             for par_node in node.ancestors(recurs=False):
170                 try:
171                     par_obj = self.object_from_node(par_node)
172                     self.add_relationship(obj, par_obj, "specialization")
173                 except KeyError:
174                     continue
175             # implements link
176             for impl_node in node.implements:
177                 try:
178                     impl_obj = self.object_from_node(impl_node)
179                     self.add_relationship(obj, impl_obj, "implements")
180                 except KeyError:
181                     continue
182             # associations link
183             for name, values in list(node.instance_attrs_type.items()) + list(
184                 node.locals_type.items()
185             ):
186                 for value in values:
187                     if value is astroid.Uninferable:
188                         continue
189                     if isinstance(value, astroid.Instance):
190                         value = value._proxied
191                     try:
192                         associated_obj = self.object_from_node(value)
193                         self.add_relationship(associated_obj, obj, "association", name)
194                     except KeyError:
195                         continue
196 
197 
198 class PackageDiagram(ClassDiagram):
199     """package diagram handling"""
200 
201     TYPE = "package"
202 
203     def modules(self):
204         """return all module nodes in the diagram"""
205         return [o for o in self.objects if isinstance(o.node, astroid.Module)]
206 
207     def module(self, name):
208         """return a module by its name, raise KeyError if not found"""
209         for mod in self.modules():
210             if mod.node.name == name:
211                 return mod
212         raise KeyError(name)
213 
214     def get_module(self, name, node):
215         """return a module by its name, looking also for relative imports;
216         raise KeyError if not found
217         """
218         for mod in self.modules():
219             mod_name = mod.node.name
220             if mod_name == name:
221                 return mod
222             # search for fullname of relative import modules
223             package = node.root().name
224             if mod_name == f"{package}.{name}":
225                 return mod
226             if mod_name == "{}.{}".format(package.rsplit(".", 1)[0], name):
227                 return mod
228         raise KeyError(name)
229 
230     def add_from_depend(self, node, from_module):
231         """add dependencies created by from-imports"""
232         mod_name = node.root().name
233         obj = self.module(mod_name)
234         if from_module not in obj.node.depends:
235             obj.node.depends.append(from_module)
236 
237     def extract_relationships(self):
238         """extract relation ships between nodes in the diagram"""
239         ClassDiagram.extract_relationships(self)
240         for obj in self.classes():
241             # ownership
242             try:
243                 mod = self.object_from_node(obj.node.root())
244                 self.add_relationship(obj, mod, "ownership")
245             except KeyError:
246                 continue
247         for obj in self.modules():
248             obj.shape = "package"
249             # dependencies
250             for dep_name in obj.node.depends:
251                 try:
252                     dep = self.get_module(dep_name, obj.node)
253                 except KeyError:
254                     continue
255                 self.add_relationship(obj, dep, "depends")

</code><intended_behavior>Modify the logic for representing classes and relationships in the diagram to include type hints in the diagram's internal representation. This involves adjusting how classes and methods are processed to ensure that type annotations are captured and reflected in the generated diagrams.</intended_behavior>, <file>pylint/pyreverse/diadefslib.py</file>
<class>None</class>
<method>None</method>
<code>
1 # Copyright (c) 2006, 2008-2010, 2013-2014 LOGILAB S.A. (Paris, FRANCE) <contact@logilab.fr>
2 # Copyright (c) 2014 Brett Cannon <brett@python.org>
3 # Copyright (c) 2014 Arun Persaud <arun@nubati.net>
4 # Copyright (c) 2015-2018, 2020 Claudiu Popa <pcmanticore@gmail.com>
5 # Copyright (c) 2015 Florian Bruhin <me@the-compiler.org>
6 # Copyright (c) 2015 Ionel Cristian Maries <contact@ionelmc.ro>
7 # Copyright (c) 2016 Ashley Whetter <ashley@awhetter.co.uk>
8 # Copyright (c) 2017 Łukasz Rogalski <rogalski.91@gmail.com>
9 # Copyright (c) 2018 ssolanki <sushobhitsolanki@gmail.com>
10 # Copyright (c) 2018 Sushobhit <31987769+sushobhit27@users.noreply.github.com>
11 # Copyright (c) 2018 Ville Skyttä <ville.skytta@iki.fi>
12 # Copyright (c) 2019-2021 Pierre Sassoulas <pierre.sassoulas@gmail.com>
13 # Copyright (c) 2020 hippo91 <guillaume.peillex@gmail.com>
14 # Copyright (c) 2020 Anthony Sottile <asottile@umich.edu>
15 
16 # Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
17 # For details: https://github.com/PyCQA/pylint/blob/master/LICENSE
18 
19 """handle diagram generation options for class diagram or default diagrams
20 """
21 
22 import astroid
23 
24 from pylint.pyreverse.diagrams import ClassDiagram, PackageDiagram
25 from pylint.pyreverse.utils import LocalsVisitor
26 
27 BUILTINS_NAME = "builtins"
28 
29 # diagram generators ##########################################################
30 
31 
32 class DiaDefGenerator:
33     """handle diagram generation options"""
34 
35     def __init__(self, linker, handler):
36         """common Diagram Handler initialization"""
37         self.config = handler.config
38         self._set_default_options()
39         self.linker = linker
40         self.classdiagram = None  # defined by subclasses
41 
42     def get_title(self, node):
43         """get title for objects"""
44         title = node.name
45         if self.module_names:
46             title = f"{node.root().name}.{title}"
47         return title
48 
49     def _set_option(self, option):
50         """activate some options if not explicitly deactivated"""
51         # if we have a class diagram, we want more information by default;
52         # so if the option is None, we return True
53         if option is None:
54             return bool(self.config.classes)
55         return option
56 
57     def _set_default_options(self):
58         """set different default options with _default dictionary"""
59         self.module_names = self._set_option(self.config.module_names)
60         all_ancestors = self._set_option(self.config.all_ancestors)
61         all_associated = self._set_option(self.config.all_associated)
62         anc_level, association_level = (0, 0)
63         if all_ancestors:
64             anc_level = -1
65         if all_associated:
66             association_level = -1
67         if self.config.show_ancestors is not None:
68             anc_level = self.config.show_ancestors
69         if self.config.show_associated is not None:
70             association_level = self.config.show_associated
71         self.anc_level, self.association_level = anc_level, association_level
72 
73     def _get_levels(self):
74         """help function for search levels"""
75         return self.anc_level, self.association_level
76 
77     def show_node(self, node):
78         """true if builtins and not show_builtins"""
79         if self.config.show_builtin:
80             return True
81         return node.root().name != BUILTINS_NAME
82 
83     def add_class(self, node):
84         """visit one class and add it to diagram"""
85         self.linker.visit(node)
86         self.classdiagram.add_object(self.get_title(node), node)
87 
88     def get_ancestors(self, node, level):
89         """return ancestor nodes of a class node"""
90         if level == 0:
91             return
92         for ancestor in node.ancestors(recurs=False):
93             if not self.show_node(ancestor):
94                 continue
95             yield ancestor
96 
97     def get_associated(self, klass_node, level):
98         """return associated nodes of a class node"""
99         if level == 0:
100             return
101         for association_nodes in list(klass_node.instance_attrs_type.values()) + list(
102             klass_node.locals_type.values()
103         ):
104             for node in association_nodes:
105                 if isinstance(node, astroid.Instance):
106                     node = node._proxied
107                 if not (isinstance(node, astroid.ClassDef) and self.show_node(node)):
108                     continue
109                 yield node
110 
111     def extract_classes(self, klass_node, anc_level, association_level):
112         """extract recursively classes related to klass_node"""
113         if self.classdiagram.has_node(klass_node) or not self.show_node(klass_node):
114             return
115         self.add_class(klass_node)
116 
117         for ancestor in self.get_ancestors(klass_node, anc_level):
118             self.extract_classes(ancestor, anc_level - 1, association_level)
119 
120         for node in self.get_associated(klass_node, association_level):
121             self.extract_classes(node, anc_level, association_level - 1)
122 
123 
124 class DefaultDiadefGenerator(LocalsVisitor, DiaDefGenerator):
125     """generate minimum diagram definition for the project :
126 
127     * a package diagram including project's modules
128     * a class diagram including project's classes
129     """
130 
131     def __init__(self, linker, handler):
132         DiaDefGenerator.__init__(self, linker, handler)
133         LocalsVisitor.__init__(self)
134 
135     def visit_project(self, node):
136         """visit a pyreverse.utils.Project node
137 
138         create a diagram definition for packages
139         """
140         mode = self.config.mode
141         if len(node.modules) > 1:
142             self.pkgdiagram = PackageDiagram("packages %s" % node.name, mode)
143         else:
144             self.pkgdiagram = None
145         self.classdiagram = ClassDiagram("classes %s" % node.name, mode)
146 
147     def leave_project(self, node):  # pylint: disable=unused-argument
148         """leave the pyreverse.utils.Project node
149 
150         return the generated diagram definition
151         """
152         if self.pkgdiagram:
153             return self.pkgdiagram, self.classdiagram
154         return (self.classdiagram,)
155 
156     def visit_module(self, node):
157         """visit an astroid.Module node
158 
159         add this class to the package diagram definition
160         """
161         if self.pkgdiagram:
162             self.linker.visit(node)
163             self.pkgdiagram.add_object(node.name, node)
164 
165     def visit_classdef(self, node):
166         """visit an astroid.Class node
167 
168         add this class to the class diagram definition
169         """
170         anc_level, association_level = self._get_levels()
171         self.extract_classes(node, anc_level, association_level)
172 
173     def visit_importfrom(self, node):
174         """visit astroid.ImportFrom  and catch modules for package diagram"""
175         if self.pkgdiagram:
176             self.pkgdiagram.add_from_depend(node, node.modname)
177 
178 
179 class ClassDiadefGenerator(DiaDefGenerator):
180     """generate a class diagram definition including all classes related to a
181     given class
182     """
183 
184     def __init__(self, linker, handler):
185         DiaDefGenerator.__init__(self, linker, handler)
186 
187     def class_diagram(self, project, klass):
188         """return a class diagram definition for the given klass and its
189         related klasses
190         """
191 
192         self.classdiagram = ClassDiagram(klass, self.config.mode)
193         if len(project.modules) > 1:
194             module, klass = klass.rsplit(".", 1)
195             module = project.get_module(module)
196         else:
197             module = project.modules[0]
198             klass = klass.split(".")[-1]
199         klass = next(module.ilookup(klass))
200 
201         anc_level, association_level = self._get_levels()
202         self.extract_classes(klass, anc_level, association_level)
203         return self.classdiagram
204 
205 
206 # diagram handler #############################################################
207 
208 
209 class DiadefsHandler:
210     """handle diagram definitions :
211 
212     get it from user (i.e. xml files) or generate them
213     """
214 
215     def __init__(self, config):
216         self.config = config
217 
218     def get_diadefs(self, project, linker):
219         """Get the diagrams configuration data
220 
221         :param project:The pyreverse project
222         :type project: pyreverse.utils.Project
223         :param linker: The linker
224         :type linker: pyreverse.inspector.Linker(IdGeneratorMixIn, LocalsVisitor)
225 
226         :returns: The list of diagram definitions
227         :rtype: list(:class:`pylint.pyreverse.diagrams.ClassDiagram`)
228         """
229 
230         #  read and interpret diagram definitions (Diadefs)
231         diagrams = []
232         generator = ClassDiadefGenerator(linker, self)
233         for klass in self.config.classes:
234             diagrams.append(generator.class_diagram(project, klass))
235         if not diagrams:
236             diagrams = DefaultDiadefGenerator(linker, self).visit(project)
237         for diagram in diagrams:
238             diagram.extract_relationships()
239         return diagrams

</code><intended_behavior>In this library, responsible for defining the diagrams, ensure that type hints are part of the definition process. This might involve adding new properties or methods to classes that represent diagram elements to store and manage type hint information extracted from the AST.</intended_behavior>, <file>pylint/utils/ast_walker.py</file>
<class>None</class>
<method>None</method>
<code>
1 # Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
2 # For details: https://github.com/PyCQA/pylint/blob/master/LICENSE
3 
4 import collections
5 
6 from astroid import nodes
7 
8 
9 class ASTWalker:
10     def __init__(self, linter):
11         # callbacks per node types
12         self.nbstatements = 0
13         self.visit_events = collections.defaultdict(list)
14         self.leave_events = collections.defaultdict(list)
15         self.linter = linter
16         self.exception_msg = False
17 
18     def _is_method_enabled(self, method):
19         if not hasattr(method, "checks_msgs"):
20             return True
21         for msg_desc in method.checks_msgs:
22             if self.linter.is_message_enabled(msg_desc):
23                 return True
24         return False
25 
26     def add_checker(self, checker):
27         """walk to the checker's dir and collect visit and leave methods"""
28         vcids = set()
29         lcids = set()
30         visits = self.visit_events
31         leaves = self.leave_events
32         for member in dir(checker):
33             cid = member[6:]
34             if cid == "default":
35                 continue
36             if member.startswith("visit_"):
37                 v_meth = getattr(checker, member)
38                 # don't use visit_methods with no activated message:
39                 if self._is_method_enabled(v_meth):
40                     visits[cid].append(v_meth)
41                     vcids.add(cid)
42             elif member.startswith("leave_"):
43                 l_meth = getattr(checker, member)
44                 # don't use leave_methods with no activated message:
45                 if self._is_method_enabled(l_meth):
46                     leaves[cid].append(l_meth)
47                     lcids.add(cid)
48         visit_default = getattr(checker, "visit_default", None)
49         if visit_default:
50             for cls in nodes.ALL_NODE_CLASSES:
51                 cid = cls.__name__.lower()
52                 if cid not in vcids:
53                     visits[cid].append(visit_default)
54         # for now we have no "leave_default" method in Pylint
55 
56     def walk(self, astroid):
57         """call visit events of astroid checkers for the given node, recurse on
58         its children, then leave events.
59         """
60         cid = astroid.__class__.__name__.lower()
61 
62         # Detect if the node is a new name for a deprecated alias.
63         # In this case, favour the methods for the deprecated
64         # alias if any,  in order to maintain backwards
65         # compatibility.
66         visit_events = self.visit_events.get(cid, ())
67         leave_events = self.leave_events.get(cid, ())
68 
69         try:
70             if astroid.is_statement:
71                 self.nbstatements += 1
72             # generate events for this node on each checker
73             for callback in visit_events or ():
74                 callback(astroid)
75             # recurse on children
76             for child in astroid.get_children():
77                 self.walk(child)
78             for callback in leave_events or ():
79                 callback(astroid)
80         except Exception:
81             if self.exception_msg is False:
82                 file = getattr(astroid.root(), "file", None)
83                 print(f"Exception on node {repr(astroid)} in file '{file}'")
84                 self.exception_msg = True
85             raise

</code><intended_behavior>Since this file is involved in walking the AST, it should ensure that while processing nodes, type hints are appropriately recognized and extracted for use in `pyreverse` diagram generation. This might require adjustments or enhancements to the visitor functions or methods that process specific types of AST nodes related to class and method definitions.</intended_behavior>, <file>pylint/lint/pylinter.py</file>
<class>None</class>
<method>None</method>
<code>
1 # Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
2 # For details: https://github.com/PyCQA/pylint/blob/master/LICENSE
3 
4 import collections
5 import contextlib
6 import functools
7 import operator
8 import os
9 import sys
10 import tokenize
11 import traceback
12 import warnings
13 from io import TextIOWrapper
14 
15 import astroid
16 
17 from pylint import checkers, config, exceptions, interfaces, reporters
18 from pylint.constants import MAIN_CHECKER_NAME, MSG_TYPES
19 from pylint.lint.expand_modules import expand_modules
20 from pylint.lint.parallel import check_parallel
21 from pylint.lint.report_functions import (
22     report_messages_by_module_stats,
23     report_messages_stats,
24     report_total_messages_stats,
25 )
26 from pylint.lint.utils import fix_import_path
27 from pylint.message import MessageDefinitionStore, MessagesHandlerMixIn
28 from pylint.reporters.ureports import nodes as report_nodes
29 from pylint.utils import ASTWalker, FileState, utils
30 from pylint.utils.pragma_parser import (
31     OPTION_PO,
32     InvalidPragmaError,
33     UnRecognizedOptionError,
34     parse_pragma,
35 )
36 
37 MANAGER = astroid.MANAGER
38 
39 
40 def _read_stdin():
41     # https://mail.python.org/pipermail/python-list/2012-November/634424.html
42     sys.stdin = TextIOWrapper(sys.stdin.detach(), encoding="utf-8")
43     return sys.stdin.read()
44 
45 
46 def _load_reporter_by_class(reporter_class: str) -> type:
47     qname = reporter_class
48     module_part = astroid.modutils.get_module_part(qname)
49     module = astroid.modutils.load_module_from_name(module_part)
50     class_name = qname.split(".")[-1]
51     return getattr(module, class_name)
52 
53 
54 # Python Linter class #########################################################
55 
56 MSGS = {
57     "F0001": (
58         "%s",
59         "fatal",
60         "Used when an error occurred preventing the analysis of a \
61               module (unable to find it for instance).",
62     ),
63     "F0002": (
64         "%s: %s",
65         "astroid-error",
66         "Used when an unexpected error occurred while building the "
67         "Astroid  representation. This is usually accompanied by a "
68         "traceback. Please report such errors !",
69     ),
70     "F0010": (
71         "error while code parsing: %s",
72         "parse-error",
73         "Used when an exception occurred while building the Astroid "
74         "representation which could be handled by astroid.",
75     ),
76     "I0001": (
77         "Unable to run raw checkers on built-in module %s",
78         "raw-checker-failed",
79         "Used to inform that a built-in module has not been checked "
80         "using the raw checkers.",
81     ),
82     "I0010": (
83         "Unable to consider inline option %r",
84         "bad-inline-option",
85         "Used when an inline option is either badly formatted or can't "
86         "be used inside modules.",
87     ),
88     "I0011": (
89         "Locally disabling %s (%s)",
90         "locally-disabled",
91         "Used when an inline option disables a message or a messages category.",
92     ),
93     "I0013": (
94         "Ignoring entire file",
95         "file-ignored",
96         "Used to inform that the file will not be checked",
97     ),
98     "I0020": (
99         "Suppressed %s (from line %d)",
100         "suppressed-message",
101         "A message was triggered on a line, but suppressed explicitly "
102         "by a disable= comment in the file. This message is not "
103         "generated for messages that are ignored due to configuration "
104         "settings.",
105     ),
106     "I0021": (
107         "Useless suppression of %s",
108         "useless-suppression",
109         "Reported when a message is explicitly disabled for a line or "
110         "a block of code, but never triggered.",
111     ),
112     "I0022": (
113         'Pragma "%s" is deprecated, use "%s" instead',
114         "deprecated-pragma",
115         "Some inline pylint options have been renamed or reworked, "
116         "only the most recent form should be used. "
117         "NOTE:skip-all is only available with pylint >= 0.26",
118         {"old_names": [("I0014", "deprecated-disable-all")]},
119     ),
120     "E0001": ("%s", "syntax-error", "Used when a syntax error is raised for a module."),
121     "E0011": (
122         "Unrecognized file option %r",
123         "unrecognized-inline-option",
124         "Used when an unknown inline option is encountered.",
125     ),
126     "E0012": (
127         "Bad option value %r",
128         "bad-option-value",
129         "Used when a bad value for an inline option is encountered.",
130     ),
131     "E0013": (
132         "Plugin '%s' is impossible to load, is it installed ? ('%s')",
133         "bad-plugin-value",
134         "Used when a bad value is used in 'load-plugins'.",
135     ),
136 }
137 
138 
139 # pylint: disable=too-many-instance-attributes,too-many-public-methods
140 class PyLinter(
141     config.OptionsManagerMixIn,
142     MessagesHandlerMixIn,
143     reporters.ReportsHandlerMixIn,
144     checkers.BaseTokenChecker,
145 ):
146     """lint Python modules using external checkers.
147 
148     This is the main checker controlling the other ones and the reports
149     generation. It is itself both a raw checker and an astroid checker in order
150     to:
151     * handle message activation / deactivation at the module level
152     * handle some basic but necessary stats'data (number of classes, methods...)
153 
154     IDE plugin developers: you may have to call
155     `astroid.builder.MANAGER.astroid_cache.clear()` across runs if you want
156     to ensure the latest code version is actually checked.
157 
158     This class needs to support pickling for parallel linting to work. The exception
159     is reporter member; see check_parallel function for more details.
160     """
161 
162     __implements__ = (interfaces.ITokenChecker,)
163 
164     name = MAIN_CHECKER_NAME
165     priority = 0
166     level = 0
167     msgs = MSGS
168 
169     @staticmethod
170     def make_options():
171         return (
172             (
173                 "ignore",
174                 {
175                     "type": "csv",
176                     "metavar": "<file>[,<file>...]",
177                     "dest": "black_list",
178                     "default": ("CVS",),
179                     "help": "Files or directories to be skipped. "
180                     "They should be base names, not paths.",
181                 },
182             ),
183             (
184                 "ignore-patterns",
185                 {
186                     "type": "regexp_csv",
187                     "metavar": "<pattern>[,<pattern>...]",
188                     "dest": "black_list_re",
189                     "default": (),
190                     "help": "Files or directories matching the regex patterns are"
191                     " skipped. The regex matches against base names, not paths.",
192                 },
193             ),
194             (
195                 "ignore-paths",
196                 {
197                     "type": "regexp_csv",
198                     "metavar": "<pattern>[,<pattern>...]",
199                     "dest": "ignore_list_paths_re",
200                     "default": (),
201                     "help": "Add files or directories matching the regex patterns to the"
202                     " ignore-list. The regex matches against paths.",
203                 },
204             ),
205             (
206                 "persistent",
207                 {
208                     "default": True,
209                     "type": "yn",
210                     "metavar": "<y_or_n>",
211                     "level": 1,
212                     "help": "Pickle collected data for later comparisons.",
213                 },
214             ),
215             (
216                 "load-plugins",
217                 {
218                     "type": "csv",
219                     "metavar": "<modules>",
220                     "default": (),
221                     "level": 1,
222                     "help": "List of plugins (as comma separated values of "
223                     "python module names) to load, usually to register "
224                     "additional checkers.",
225                 },
226             ),
227             (
228                 "output-format",
229                 {
230                     "default": "text",
231                     "type": "string",
232                     "metavar": "<format>",
233                     "short": "f",
234                     "group": "Reports",
235                     "help": "Set the output format. Available formats are text,"
236                     " parseable, colorized, json and msvs (visual studio)."
237                     " You can also give a reporter class, e.g. mypackage.mymodule."
238                     "MyReporterClass.",
239                 },
240             ),
241             (
242                 "reports",
243                 {
244                     "default": False,
245                     "type": "yn",
246                     "metavar": "<y_or_n>",
247                     "short": "r",
248                     "group": "Reports",
249                     "help": "Tells whether to display a full report or only the "
250                     "messages.",
251                 },
252             ),
253             (
254                 "evaluation",
255                 {
256                     "type": "string",
257                     "metavar": "<python_expression>",
258                     "group": "Reports",
259                     "level": 1,
260                     "default": "10.0 - ((float(5 * error + warning + refactor + "
261                     "convention) / statement) * 10)",
262                     "help": "Python expression which should return a score less "
263                     "than or equal to 10. You have access to the variables "
264                     "'error', 'warning', 'refactor', and 'convention' which "
265                     "contain the number of messages in each category, as well as "
266                     "'statement' which is the total number of statements "
267                     "analyzed. This score is used by the global "
268                     "evaluation report (RP0004).",
269                 },
270             ),
271             (
272                 "score",
273                 {
274                     "default": True,
275                     "type": "yn",
276                     "metavar": "<y_or_n>",
277                     "short": "s",
278                     "group": "Reports",
279                     "help": "Activate the evaluation score.",
280                 },
281             ),
282             (
283                 "fail-under",
284                 {
285                     "default": 10,
286                     "type": "float",
287                     "metavar": "<score>",
288                     "help": "Specify a score threshold to be exceeded before program exits with error.",
289                 },
290             ),
291             (
292                 "fail-on",
293                 {
294                     "default": "",
295                     "type": "csv",
296                     "metavar": "<msg ids>",
297                     "help": "Return non-zero exit code if any of these messages/categories are detected,"
298                     " even if score is above --fail-under value. Syntax same as enable."
299                     " Messages specified are enabled, while categories only check already-enabled messages.",
300                 },
301             ),
302             (
303                 "confidence",
304                 {
305                     "type": "multiple_choice",
306                     "metavar": "<levels>",
307                     "default": "",
308                     "choices": [c.name for c in interfaces.CONFIDENCE_LEVELS],
309                     "group": "Messages control",
310                     "help": "Only show warnings with the listed confidence levels."
311                     " Leave empty to show all. Valid levels: %s."
312                     % (", ".join(c.name for c in interfaces.CONFIDENCE_LEVELS),),
313                 },
314             ),
315             (
316                 "enable",
317                 {
318                     "type": "csv",
319                     "metavar": "<msg ids>",
320                     "short": "e",
321                     "group": "Messages control",
322                     "help": "Enable the message, report, category or checker with the "
323                     "given id(s). You can either give multiple identifier "
324                     "separated by comma (,) or put this option multiple time "
325                     "(only on the command line, not in the configuration file "
326                     "where it should appear only once). "
327                     'See also the "--disable" option for examples.',
328                 },
329             ),
330             (
331                 "disable",
332                 {
333                     "type": "csv",
334                     "metavar": "<msg ids>",
335                     "short": "d",
336                     "group": "Messages control",
337                     "help": "Disable the message, report, category or checker "
338                     "with the given id(s). You can either give multiple identifiers "
339                     "separated by comma (,) or put this option multiple times "
340                     "(only on the command line, not in the configuration file "
341                     "where it should appear only once). "
342                     'You can also use "--disable=all" to disable everything first '
343                     "and then reenable specific checks. For example, if you want "
344                     "to run only the similarities checker, you can use "
345                     '"--disable=all --enable=similarities". '
346                     "If you want to run only the classes checker, but have no "
347                     "Warning level messages displayed, use "
348                     '"--disable=all --enable=classes --disable=W".',
349                 },
350             ),
351             (
352                 "msg-template",
353                 {
354                     "type": "string",
355                     "metavar": "<template>",
356                     "group": "Reports",
357                     "help": (
358                         "Template used to display messages. "
359                         "This is a python new-style format string "
360                         "used to format the message information. "
361                         "See doc for all details."
362                     ),
363                 },
364             ),
365             (
366                 "jobs",
367                 {
368                     "type": "int",
369                     "metavar": "<n-processes>",
370                     "short": "j",
371                     "default": 1,
372                     "help": "Use multiple processes to speed up Pylint. Specifying 0 will "
373                     "auto-detect the number of processors available to use.",
374                 },
375             ),
376             (
377                 "unsafe-load-any-extension",
378                 {
379                     "type": "yn",
380                     "metavar": "<yn>",
381                     "default": False,
382                     "hide": True,
383                     "help": (
384                         "Allow loading of arbitrary C extensions. Extensions"
385                         " are imported into the active Python interpreter and"
386                         " may run arbitrary code."
387                     ),
388                 },
389             ),
390             (
391                 "limit-inference-results",
392                 {
393                     "type": "int",
394                     "metavar": "<number-of-results>",
395                     "default": 100,
396                     "help": (
397                         "Control the amount of potential inferred values when inferring "
398                         "a single object. This can help the performance when dealing with "
399                         "large functions or complex, nested conditions. "
400                     ),
401                 },
402             ),
403             (
404                 "extension-pkg-allow-list",
405                 {
406                     "type": "csv",
407                     "metavar": "<pkg[,pkg]>",
408                     "default": [],
409                     "help": (
410                         "A comma-separated list of package or module names"
411                         " from where C extensions may be loaded. Extensions are"
412                         " loading into the active Python interpreter and may run"
413                         " arbitrary code."
414                     ),
415                 },
416             ),
417             (
418                 "extension-pkg-whitelist",
419                 {
420                     "type": "csv",
421                     "metavar": "<pkg[,pkg]>",
422                     "default": [],
423                     "help": (
424                         "A comma-separated list of package or module names"
425                         " from where C extensions may be loaded. Extensions are"
426                         " loading into the active Python interpreter and may run"
427                         " arbitrary code. (This is an alternative name to"
428                         " extension-pkg-allow-list for backward compatibility.)"
429                     ),
430                 },
431             ),
432             (
433                 "suggestion-mode",
434                 {
435                     "type": "yn",
436                     "metavar": "<yn>",
437                     "default": True,
438                     "help": (
439                         "When enabled, pylint would attempt to guess common "
440                         "misconfiguration and emit user-friendly hints instead "
441                         "of false-positive error messages."
442                     ),
443                 },
444             ),
445             (
446                 "exit-zero",
447                 {
448                     "action": "store_true",
449                     "help": (
450                         "Always return a 0 (non-error) status code, even if "
451                         "lint errors are found. This is primarily useful in "
452                         "continuous integration scripts."
453                     ),
454                 },
455             ),
456             (
457                 "from-stdin",
458                 {
459                     "action": "store_true",
460                     "help": (
461                         "Interpret the stdin as a python script, whose filename "
462                         "needs to be passed as the module_or_package argument."
463                     ),
464                 },
465             ),
466         )
467 
468     option_groups = (
469         ("Messages control", "Options controlling analysis messages"),
470         ("Reports", "Options related to output formatting and reporting"),
471     )
472 
473     def __init__(self, options=(), reporter=None, option_groups=(), pylintrc=None):
474         """Some stuff has to be done before ancestors initialization...
475         messages store / checkers / reporter / astroid manager"""
476         self.msgs_store = MessageDefinitionStore()
477         self.reporter = None
478         self._reporter_names = None
479         self._reporters = {}
480         self._checkers = collections.defaultdict(list)
481         self._pragma_lineno = {}
482         self._ignore_file = False
483         # visit variables
484         self.file_state = FileState()
485         self.current_name = None
486         self.current_file = None
487         self.stats = None
488         self.fail_on_symbols = []
489         # init options
490         self._external_opts = options
491         self.options = options + PyLinter.make_options()
492         self.option_groups = option_groups + PyLinter.option_groups
493         self._options_methods = {"enable": self.enable, "disable": self.disable}
494         self._bw_options_methods = {
495             "disable-msg": self._options_methods["disable"],
496             "enable-msg": self._options_methods["enable"],
497         }
498         MessagesHandlerMixIn.__init__(self)
499         reporters.ReportsHandlerMixIn.__init__(self)
500         super().__init__(
501             usage=__doc__,
502             config_file=pylintrc or next(config.find_default_config_files(), None),
503         )
504         checkers.BaseTokenChecker.__init__(self)
505         # provided reports
506         self.reports = (
507             ("RP0001", "Messages by category", report_total_messages_stats),
508             (
509                 "RP0002",
510                 "% errors / warnings by module",
511                 report_messages_by_module_stats,
512             ),
513             ("RP0003", "Messages", report_messages_stats),
514         )
515         self.register_checker(self)
516         self._dynamic_plugins = set()
517         self._python3_porting_mode = False
518         self._error_mode = False
519         self.load_provider_defaults()
520         if reporter:
521             self.set_reporter(reporter)
522 
523     def load_default_plugins(self):
524         checkers.initialize(self)
525         reporters.initialize(self)
526         # Make sure to load the default reporter, because
527         # the option has been set before the plugins had been loaded.
528         if not self.reporter:
529             self._load_reporters()
530 
531     def load_plugin_modules(self, modnames):
532         """take a list of module names which are pylint plugins and load
533         and register them
534         """
535         for modname in modnames:
536             if modname in self._dynamic_plugins:
537                 continue
538             self._dynamic_plugins.add(modname)
539             try:
540                 module = astroid.modutils.load_module_from_name(modname)
541                 module.register(self)
542             except ModuleNotFoundError:
543                 pass
544 
545     def load_plugin_configuration(self):
546         """Call the configuration hook for plugins
547 
548         This walks through the list of plugins, grabs the "load_configuration"
549         hook, if exposed, and calls it to allow plugins to configure specific
550         settings.
551         """
552         for modname in self._dynamic_plugins:
553             try:
554                 module = astroid.modutils.load_module_from_name(modname)
555                 if hasattr(module, "load_configuration"):
556                     module.load_configuration(self)
557             except ModuleNotFoundError as e:
558                 self.add_message("bad-plugin-value", args=(modname, e), line=0)
559 
560     def _load_reporters(self) -> None:
561         sub_reporters = []
562         output_files = []
563         with contextlib.ExitStack() as stack:
564             for reporter_name in self._reporter_names.split(","):
565                 reporter_name, *reporter_output = reporter_name.split(":", 1)
566 
567                 reporter = self._load_reporter_by_name(reporter_name)
568                 sub_reporters.append(reporter)
569 
570                 if reporter_output:
571                     (reporter_output,) = reporter_output
572 
573                     # pylint: disable=consider-using-with
574                     output_file = stack.enter_context(open(reporter_output, "w"))
575 
576                     reporter.set_output(output_file)
577                     output_files.append(output_file)
578 
579             # Extend the lifetime of all opened output files
580             close_output_files = stack.pop_all().close
581 
582         if len(sub_reporters) > 1 or output_files:
583             self.set_reporter(
584                 reporters.MultiReporter(
585                     sub_reporters,
586                     close_output_files,
587                 )
588             )
589         else:
590             self.set_reporter(sub_reporters[0])
591 
592     def _load_reporter_by_name(self, reporter_name: str) -> reporters.BaseReporter:
593         name = reporter_name.lower()
594         if name in self._reporters:
595             return self._reporters[name]()
596 
597         try:
598             reporter_class = _load_reporter_by_class(reporter_name)
599         except (ImportError, AttributeError) as e:
600             raise exceptions.InvalidReporterError(name) from e
601         else:
602             return reporter_class()
603 
604     def set_reporter(self, reporter):
605         """set the reporter used to display messages and reports"""
606         self.reporter = reporter
607         reporter.linter = self
608 
609     def set_option(self, optname, value, action=None, optdict=None):
610         """overridden from config.OptionsProviderMixin to handle some
611         special options
612         """
613         if optname in self._options_methods or optname in self._bw_options_methods:
614             if value:
615                 try:
616                     meth = self._options_methods[optname]
617                 except KeyError:
618                     meth = self._bw_options_methods[optname]
619                     warnings.warn(
620                         "%s is deprecated, replace it by %s"
621                         % (optname, optname.split("-")[0]),
622                         DeprecationWarning,
623                     )
624                 value = utils._check_csv(value)
625                 if isinstance(value, (list, tuple)):
626                     for _id in value:
627                         meth(_id, ignore_unknown=True)
628                 else:
629                     meth(value)
630                 return  # no need to call set_option, disable/enable methods do it
631         elif optname == "output-format":
632             self._reporter_names = value
633             # If the reporters are already available, load
634             # the reporter class.
635             if self._reporters:
636                 self._load_reporters()
637 
638         try:
639             checkers.BaseTokenChecker.set_option(self, optname, value, action, optdict)
640         except config.UnsupportedAction:
641             print("option %s can't be read from config file" % optname, file=sys.stderr)
642 
643     def register_reporter(self, reporter_class):
644         self._reporters[reporter_class.name] = reporter_class
645 
646     def report_order(self):
647         reports = sorted(self._reports, key=lambda x: getattr(x, "name", ""))
648         try:
649             # Remove the current reporter and add it
650             # at the end of the list.
651             reports.pop(reports.index(self))
652         except ValueError:
653             pass
654         else:
655             reports.append(self)
656         return reports
657 
658     # checkers manipulation methods ############################################
659 
660     def register_checker(self, checker):
661         """register a new checker
662 
663         checker is an object implementing IRawChecker or / and IAstroidChecker
664         """
665         assert checker.priority <= 0, "checker priority can't be >= 0"
666         self._checkers[checker.name].append(checker)
667         for r_id, r_title, r_cb in checker.reports:
668             self.register_report(r_id, r_title, r_cb, checker)
669         self.register_options_provider(checker)
670         if hasattr(checker, "msgs"):
671             self.msgs_store.register_messages_from_checker(checker)
672         checker.load_defaults()
673 
674         # Register the checker, but disable all of its messages.
675         if not getattr(checker, "enabled", True):
676             self.disable(checker.name)
677 
678     def enable_fail_on_messages(self):
679         """enable 'fail on' msgs
680 
681         Convert values in config.fail_on (which might be msg category, msg id,
682         or symbol) to specific msgs, then enable and flag them for later.
683         """
684         fail_on_vals = self.config.fail_on
685         if not fail_on_vals:
686             return
687 
688         fail_on_cats = set()
689         fail_on_msgs = set()
690         for val in fail_on_vals:
691             # If value is a cateogry, add category, else add message
692             if val in MSG_TYPES:
693                 fail_on_cats.add(val)
694             else:
695                 fail_on_msgs.add(val)
696 
697         # For every message in every checker, if cat or msg flagged, enable check
698         for all_checkers in self._checkers.values():
699             for checker in all_checkers:
700                 for msg in checker.messages:
701                     if msg.msgid in fail_on_msgs or msg.symbol in fail_on_msgs:
702                         # message id/symbol matched, enable and flag it
703                         self.enable(msg.msgid)
704                         self.fail_on_symbols.append(msg.symbol)
705                     elif msg.msgid[0] in fail_on_cats:
706                         # message starts with a cateogry value, flag (but do not enable) it
707                         self.fail_on_symbols.append(msg.symbol)
708 
709     def any_fail_on_issues(self):
710         return any(x in self.fail_on_symbols for x in self.stats["by_msg"])
711 
712     def disable_noerror_messages(self):
713         for msgcat, msgids in self.msgs_store._msgs_by_category.items():
714             # enable only messages with 'error' severity and above ('fatal')
715             if msgcat in ["E", "F"]:
716                 for msgid in msgids:
717                     self.enable(msgid)
718             else:
719                 for msgid in msgids:
720                     self.disable(msgid)
721 
722     def disable_reporters(self):
723         """disable all reporters"""
724         for _reporters in self._reports.values():
725             for report_id, _, _ in _reporters:
726                 self.disable_report(report_id)
727 
728     def error_mode(self):
729         """error mode: enable only errors; no reports, no persistent"""
730         self._error_mode = True
731         self.disable_noerror_messages()
732         self.disable("miscellaneous")
733         if self._python3_porting_mode:
734             self.disable("all")
735             for msg_id in self._checker_messages("python3"):
736                 if msg_id.startswith("E"):
737                     self.enable(msg_id)
738             config_parser = self.cfgfile_parser
739             if config_parser.has_option("MESSAGES CONTROL", "disable"):
740                 value = config_parser.get("MESSAGES CONTROL", "disable")
741                 self.global_set_option("disable", value)
742         else:
743             self.disable("python3")
744         self.set_option("reports", False)
745         self.set_option("persistent", False)
746         self.set_option("score", False)
747 
748     def python3_porting_mode(self):
749         """Disable all other checkers and enable Python 3 warnings."""
750         self.disable("all")
751         # re-enable some errors, or 'print', 'raise', 'async', 'await' will mistakenly lint fine
752         self.enable("fatal")  # F0001
753         self.enable("astroid-error")  # F0002
754         self.enable("parse-error")  # F0010
755         self.enable("syntax-error")  # E0001
756         self.enable("python3")
757         if self._error_mode:
758             # The error mode was activated, using the -E flag.
759             # So we'll need to enable only the errors from the
760             # Python 3 porting checker.
761             for msg_id in self._checker_messages("python3"):
762                 if msg_id.startswith("E"):
763                     self.enable(msg_id)
764                 else:
765                     self.disable(msg_id)
766         config_parser = self.cfgfile_parser
767         if config_parser.has_option("MESSAGES CONTROL", "disable"):
768             value = config_parser.get("MESSAGES CONTROL", "disable")
769             self.global_set_option("disable", value)
770         self._python3_porting_mode = True
771 
772     def list_messages_enabled(self):
773         enabled = [
774             f"  {message.symbol} ({message.msgid})"
775             for message in self.msgs_store.messages
776             if self.is_message_enabled(message.msgid)
777         ]
778         disabled = [
779             f"  {message.symbol} ({message.msgid})"
780             for message in self.msgs_store.messages
781             if not self.is_message_enabled(message.msgid)
782         ]
783         print("Enabled messages:")
784         for msg in sorted(enabled):
785             print(msg)
786         print("\nDisabled messages:")
787         for msg in sorted(disabled):
788             print(msg)
789         print("")
790 
791     # block level option handling #############################################
792     # see func_block_disable_msg.py test case for expected behaviour
793 
794     def process_tokens(self, tokens):
795         """Process tokens from the current module to search for module/block level
796         options."""
797         control_pragmas = {"disable", "enable"}
798         prev_line = None
799         saw_newline = True
800         seen_newline = True
801         for (tok_type, content, start, _, _) in tokens:
802             if prev_line and prev_line != start[0]:
803                 saw_newline = seen_newline
804                 seen_newline = False
805 
806             prev_line = start[0]
807             if tok_type in (tokenize.NL, tokenize.NEWLINE):
808                 seen_newline = True
809 
810             if tok_type != tokenize.COMMENT:
811                 continue
812             match = OPTION_PO.search(content)
813             if match is None:
814                 continue
815             try:
816                 for pragma_repr in parse_pragma(match.group(2)):
817                     if pragma_repr.action in ("disable-all", "skip-file"):
818                         if pragma_repr.action == "disable-all":
819                             self.add_message(
820                                 "deprecated-pragma",
821                                 line=start[0],
822                                 args=("disable-all", "skip-file"),
823                             )
824                         self.add_message("file-ignored", line=start[0])
825                         self._ignore_file = True
826                         return
827                     try:
828                         meth = self._options_methods[pragma_repr.action]
829                     except KeyError:
830                         meth = self._bw_options_methods[pragma_repr.action]
831                         # found a "(dis|en)able-msg" pragma deprecated suppression
832                         self.add_message(
833                             "deprecated-pragma",
834                             line=start[0],
835                             args=(
836                                 pragma_repr.action,
837                                 pragma_repr.action.replace("-msg", ""),
838                             ),
839                         )
840                     for msgid in pragma_repr.messages:
841                         # Add the line where a control pragma was encountered.
842                         if pragma_repr.action in control_pragmas:
843                             self._pragma_lineno[msgid] = start[0]
844 
845                         if (pragma_repr.action, msgid) == ("disable", "all"):
846                             self.add_message(
847                                 "deprecated-pragma",
848                                 line=start[0],
849                                 args=("disable=all", "skip-file"),
850                             )
851                             self.add_message("file-ignored", line=start[0])
852                             self._ignore_file = True
853                             return
854                             # If we did not see a newline between the previous line and now,
855                             # we saw a backslash so treat the two lines as one.
856                         l_start = start[0]
857                         if not saw_newline:
858                             l_start -= 1
859                         try:
860                             meth(msgid, "module", l_start)
861                         except exceptions.UnknownMessageError:
862                             self.add_message(
863                                 "bad-option-value", args=msgid, line=start[0]
864                             )
865             except UnRecognizedOptionError as err:
866                 self.add_message(
867                     "unrecognized-inline-option", args=err.token, line=start[0]
868                 )
869                 continue
870             except InvalidPragmaError as err:
871                 self.add_message("bad-inline-option", args=err.token, line=start[0])
872                 continue
873 
874     # code checking methods ###################################################
875 
876     def get_checkers(self):
877         """return all available checkers as a list"""
878         return [self] + [
879             c
880             for _checkers in self._checkers.values()
881             for c in _checkers
882             if c is not self
883         ]
884 
885     def get_checker_names(self):
886         """Get all the checker names that this linter knows about."""
887         current_checkers = self.get_checkers()
888         return sorted(
889             {
890                 checker.name
891                 for checker in current_checkers
892                 if checker.name != MAIN_CHECKER_NAME
893             }
894         )
895 
896     def prepare_checkers(self):
897         """return checkers needed for activated messages and reports"""
898         if not self.config.reports:
899             self.disable_reporters()
900         # get needed checkers
901         needed_checkers = [self]
902         for checker in self.get_checkers()[1:]:
903             messages = {msg for msg in checker.msgs if self.is_message_enabled(msg)}
904             if messages or any(self.report_is_enabled(r[0]) for r in checker.reports):
905                 needed_checkers.append(checker)
906         # Sort checkers by priority
907         needed_checkers = sorted(
908             needed_checkers, key=operator.attrgetter("priority"), reverse=True
909         )
910         return needed_checkers
911 
912     # pylint: disable=unused-argument
913     @staticmethod
914     def should_analyze_file(modname, path, is_argument=False):
915         """Returns whether or not a module should be checked.
916 
917         This implementation returns True for all python source file, indicating
918         that all files should be linted.
919 
920         Subclasses may override this method to indicate that modules satisfying
921         certain conditions should not be linted.
922 
923         :param str modname: The name of the module to be checked.
924         :param str path: The full path to the source code of the module.
925         :param bool is_argument: Whether the file is an argument to pylint or not.
926                                  Files which respect this property are always
927                                  checked, since the user requested it explicitly.
928         :returns: True if the module should be checked.
929         :rtype: bool
930         """
931         if is_argument:
932             return True
933         return path.endswith(".py")
934 
935     # pylint: enable=unused-argument
936 
937     def initialize(self):
938         """Initialize linter for linting
939 
940         This method is called before any linting is done.
941         """
942         # initialize msgs_state now that all messages have been registered into
943         # the store
944         for msg in self.msgs_store.messages:
945             if not msg.may_be_emitted():
946                 self._msgs_state[msg.msgid] = False
947 
948     def check(self, files_or_modules):
949         """main checking entry: check a list of files or modules from their name.
950 
951         files_or_modules is either a string or list of strings presenting modules to check.
952         """
953 
954         self.initialize()
955 
956         if not isinstance(files_or_modules, (list, tuple)):
957             files_or_modules = (files_or_modules,)
958 
959         if self.config.from_stdin:
960             if len(files_or_modules) != 1:
961                 raise exceptions.InvalidArgsError(
962                     "Missing filename required for --from-stdin"
963                 )
964 
965             filepath = files_or_modules[0]
966             with fix_import_path(files_or_modules):
967                 self._check_files(
968                     functools.partial(self.get_ast, data=_read_stdin()),
969                     [self._get_file_descr_from_stdin(filepath)],
970                 )
971         elif self.config.jobs == 1:
972             with fix_import_path(files_or_modules):
973                 self._check_files(
974                     self.get_ast, self._iterate_file_descrs(files_or_modules)
975                 )
976         else:
977             check_parallel(
978                 self,
979                 self.config.jobs,
980                 self._iterate_file_descrs(files_or_modules),
981                 files_or_modules,
982             )
983 
984     def check_single_file(self, name, filepath, modname):
985         """Check single file
986 
987         The arguments are the same that are documented in _check_files
988 
989         The initialize() method should be called before calling this method
990         """
991         with self._astroid_module_checker() as check_astroid_module:
992             self._check_file(
993                 self.get_ast, check_astroid_module, name, filepath, modname
994             )
995 
996     def _check_files(self, get_ast, file_descrs):
997         """Check all files from file_descrs
998 
999         The file_descrs should be iterable of tuple (name, filepath, modname)
1000         where
1001         - name: full name of the module
1002         - filepath: path of the file
1003         - modname: module name
1004         """
1005         with self._astroid_module_checker() as check_astroid_module:
1006             for name, filepath, modname in file_descrs:
1007                 self._check_file(get_ast, check_astroid_module, name, filepath, modname)
1008 
1009     def _check_file(self, get_ast, check_astroid_module, name, filepath, modname):
1010         """Check a file using the passed utility functions (get_ast and check_astroid_module)
1011 
1012         :param callable get_ast: callable returning AST from defined file taking the following arguments
1013         - filepath: path to the file to check
1014         - name: Python module name
1015         :param callable check_astroid_module: callable checking an AST taking the following arguments
1016         - ast: AST of the module
1017         :param str name: full name of the module
1018         :param str filepath: path to checked file
1019         :param str modname: name of the checked Python module
1020         """
1021         self.set_current_module(name, filepath)
1022         # get the module representation
1023         ast_node = get_ast(filepath, name)
1024         if ast_node is None:
1025             return
1026 
1027         self._ignore_file = False
1028 
1029         self.file_state = FileState(modname)
1030         # fix the current file (if the source file was not available or
1031         # if it's actually a c extension)
1032         self.current_file = ast_node.file  # pylint: disable=maybe-no-member
1033         check_astroid_module(ast_node)
1034         # warn about spurious inline messages handling
1035         spurious_messages = self.file_state.iter_spurious_suppression_messages(
1036             self.msgs_store
1037         )
1038         for msgid, line, args in spurious_messages:
1039             self.add_message(msgid, line, None, args)
1040 
1041     @staticmethod
1042     def _get_file_descr_from_stdin(filepath):
1043         """Return file description (tuple of module name, file path, base name) from given file path
1044 
1045         This method is used for creating suitable file description for _check_files when the
1046         source is standard input.
1047         """
1048         try:
1049             # Note that this function does not really perform an
1050             # __import__ but may raise an ImportError exception, which
1051             # we want to catch here.
1052             modname = ".".join(astroid.modutils.modpath_from_file(filepath))
1053         except ImportError:
1054             modname = os.path.splitext(os.path.basename(filepath))[0]
1055 
1056         return (modname, filepath, filepath)
1057 
1058     def _iterate_file_descrs(self, files_or_modules):
1059         """Return generator yielding file descriptions (tuples of module name, file path, base name)
1060 
1061         The returned generator yield one item for each Python module that should be linted.
1062         """
1063         for descr in self._expand_files(files_or_modules):
1064             name, filepath, is_arg = descr["name"], descr["path"], descr["isarg"]
1065             if self.should_analyze_file(name, filepath, is_argument=is_arg):
1066                 yield (name, filepath, descr["basename"])
1067 
1068     def _expand_files(self, modules):
1069         """get modules and errors from a list of modules and handle errors"""
1070         result, errors = expand_modules(
1071             modules,
1072             self.config.black_list,
1073             self.config.black_list_re,
1074             self.config.ignore_list_paths_re,
1075         )
1076         for error in errors:
1077             message = modname = error["mod"]
1078             key = error["key"]
1079             self.set_current_module(modname)
1080             if key == "fatal":
1081                 message = str(error["ex"]).replace(os.getcwd() + os.sep, "")
1082             self.add_message(key, args=message)
1083         return result
1084 
1085     def set_current_module(self, modname, filepath=None):
1086         """set the name of the currently analyzed module and
1087         init statistics for it
1088         """
1089         if not modname and filepath is None:
1090             return
1091         self.reporter.on_set_current_module(modname, filepath)
1092         self.current_name = modname
1093         self.current_file = filepath or modname
1094         self.stats["by_module"][modname] = {}
1095         self.stats["by_module"][modname]["statement"] = 0
1096         for msg_cat in MSG_TYPES.values():
1097             self.stats["by_module"][modname][msg_cat] = 0
1098 
1099     @contextlib.contextmanager
1100     def _astroid_module_checker(self):
1101         """Context manager for checking ASTs
1102 
1103         The value in the context is callable accepting AST as its only argument.
1104         """
1105         walker = ASTWalker(self)
1106         _checkers = self.prepare_checkers()
1107         tokencheckers = [
1108             c
1109             for c in _checkers
1110             if interfaces.implements(c, interfaces.ITokenChecker) and c is not self
1111         ]
1112         rawcheckers = [
1113             c for c in _checkers if interfaces.implements(c, interfaces.IRawChecker)
1114         ]
1115         # notify global begin
1116         for checker in _checkers:
1117             checker.open()
1118             if interfaces.implements(checker, interfaces.IAstroidChecker):
1119                 walker.add_checker(checker)
1120 
1121         yield functools.partial(
1122             self.check_astroid_module,
1123             walker=walker,
1124             tokencheckers=tokencheckers,
1125             rawcheckers=rawcheckers,
1126         )
1127 
1128         # notify global end
1129         self.stats["statement"] = walker.nbstatements
1130         for checker in reversed(_checkers):
1131             checker.close()
1132 
1133     def get_ast(self, filepath, modname, data=None):
1134         """Return an ast(roid) representation of a module or a string.
1135 
1136         :param str filepath: path to checked file.
1137         :param str modname: The name of the module to be checked.
1138         :param str data: optional contents of the checked file.
1139         :returns: the AST
1140         :rtype: astroid.nodes.Module
1141         """
1142         try:
1143             if data is None:
1144                 return MANAGER.ast_from_file(filepath, modname, source=True)
1145             return astroid.builder.AstroidBuilder(MANAGER).string_build(
1146                 data, modname, filepath
1147             )
1148         except astroid.AstroidSyntaxError as ex:
1149             # pylint: disable=no-member
1150             self.add_message(
1151                 "syntax-error",
1152                 line=getattr(ex.error, "lineno", 0),
1153                 col_offset=getattr(ex.error, "offset", None),
1154                 args=str(ex.error),
1155             )
1156         except astroid.AstroidBuildingException as ex:
1157             self.add_message("parse-error", args=ex)
1158         except Exception as ex:  # pylint: disable=broad-except
1159             traceback.print_exc()
1160             self.add_message("astroid-error", args=(ex.__class__, ex))
1161         return None
1162 
1163     def check_astroid_module(self, ast_node, walker, rawcheckers, tokencheckers):
1164         """Check a module from its astroid representation.
1165 
1166         For return value see _check_astroid_module
1167         """
1168         before_check_statements = walker.nbstatements
1169 
1170         retval = self._check_astroid_module(
1171             ast_node, walker, rawcheckers, tokencheckers
1172         )
1173 
1174         self.stats["by_module"][self.current_name]["statement"] = (
1175             walker.nbstatements - before_check_statements
1176         )
1177 
1178         return retval
1179 
1180     def _check_astroid_module(self, ast_node, walker, rawcheckers, tokencheckers):
1181         """Check given AST node with given walker and checkers
1182 
1183         :param astroid.nodes.Module ast_node: AST node of the module to check
1184         :param pylint.utils.ast_walker.ASTWalker walker: AST walker
1185         :param list rawcheckers: List of token checkers to use
1186         :param list tokencheckers: List of raw checkers to use
1187 
1188         :returns: True if the module was checked, False if ignored,
1189             None if the module contents could not be parsed
1190         :rtype: bool
1191         """
1192         try:
1193             tokens = utils.tokenize_module(ast_node)
1194         except tokenize.TokenError as ex:
1195             self.add_message("syntax-error", line=ex.args[1][0], args=ex.args[0])
1196             return None
1197 
1198         if not ast_node.pure_python:
1199             self.add_message("raw-checker-failed", args=ast_node.name)
1200         else:
1201             # assert astroid.file.endswith('.py')
1202             # invoke ITokenChecker interface on self to fetch module/block
1203             # level options
1204             self.process_tokens(tokens)
1205             if self._ignore_file:
1206                 return False
1207             # walk ast to collect line numbers
1208             self.file_state.collect_block_lines(self.msgs_store, ast_node)
1209             # run raw and tokens checkers
1210             for checker in rawcheckers:
1211                 checker.process_module(ast_node)
1212             for checker in tokencheckers:
1213                 checker.process_tokens(tokens)
1214         # generate events to astroid checkers
1215         walker.walk(ast_node)
1216         return True
1217 
1218     # IAstroidChecker interface #################################################
1219 
1220     def open(self):
1221         """initialize counters"""
1222         self.stats = {"by_module": {}, "by_msg": {}}
1223         MANAGER.always_load_extensions = self.config.unsafe_load_any_extension
1224         MANAGER.max_inferable_values = self.config.limit_inference_results
1225         MANAGER.extension_package_whitelist.update(self.config.extension_pkg_allow_list)
1226         if self.config.extension_pkg_whitelist:
1227             MANAGER.extension_package_whitelist.update(
1228                 self.config.extension_pkg_whitelist
1229             )
1230         for msg_cat in MSG_TYPES.values():
1231             self.stats[msg_cat] = 0
1232 
1233     def generate_reports(self):
1234         """close the whole package /module, it's time to make reports !
1235 
1236         if persistent run, pickle results for later comparison
1237         """
1238         # Display whatever messages are left on the reporter.
1239         self.reporter.display_messages(report_nodes.Section())
1240 
1241         if self.file_state.base_name is not None:
1242             # load previous results if any
1243             previous_stats = config.load_results(self.file_state.base_name)
1244             self.reporter.on_close(self.stats, previous_stats)
1245             if self.config.reports:
1246                 sect = self.make_reports(self.stats, previous_stats)
1247             else:
1248                 sect = report_nodes.Section()
1249 
1250             if self.config.reports:
1251                 self.reporter.display_reports(sect)
1252             score_value = self._report_evaluation()
1253             # save results if persistent run
1254             if self.config.persistent:
1255                 config.save_results(self.stats, self.file_state.base_name)
1256         else:
1257             self.reporter.on_close(self.stats, {})
1258             score_value = None
1259         return score_value
1260 
1261     def _report_evaluation(self):
1262         """make the global evaluation report"""
1263         # check with at least check 1 statements (usually 0 when there is a
1264         # syntax error preventing pylint from further processing)
1265         note = None
1266         previous_stats = config.load_results(self.file_state.base_name)
1267         if self.stats["statement"] == 0:
1268             return note
1269 
1270         # get a global note for the code
1271         evaluation = self.config.evaluation
1272         try:
1273             note = eval(evaluation, {}, self.stats)  # pylint: disable=eval-used
1274         except Exception as ex:  # pylint: disable=broad-except
1275             msg = "An exception occurred while rating: %s" % ex
1276         else:
1277             self.stats["global_note"] = note
1278             msg = "Your code has been rated at %.2f/10" % note
1279             pnote = previous_stats.get("global_note")
1280             if pnote is not None:
1281                 msg += f" (previous run: {pnote:.2f}/10, {note - pnote:+.2f})"
1282 
1283         if self.config.score:
1284             sect = report_nodes.EvaluationSection(msg)
1285             self.reporter.display_reports(sect)
1286         return note

</code><intended_behavior>As part of the linting process, ensure that the analysis phase that feeds into `pyreverse` can identify and pass along type hint information. Though not directly responsible for UML generation, enhancing this component to better recognize and handle type hints could benefit the overall goal of improving UML output.</intended_behavior>]
2025-10-18 04:25:30.327 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-18 04:25:30.327 | INFO     | Search-only: skipping patch selection
2025-10-18 04:25:30.400 | INFO     | Task pylint-dev__pylint-4551 completed successfully.
2025-10-18 04:25:30.401 | INFO     | No patch generated. You can try running ACR again.
