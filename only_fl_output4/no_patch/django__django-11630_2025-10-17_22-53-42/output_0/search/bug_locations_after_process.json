[
    {
        "rel_file_path": "django/contrib/gis/db/backends/base/models.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.0/django/contrib/gis/db/backends/base/models.py",
        "start": 1,
        "end": 136,
        "class_name": null,
        "method_name": null,
        "code": "1 from django.contrib.gis import gdal\n2 \n3 \n4 class SpatialRefSysMixin:\n5     \"\"\"\n6     The SpatialRefSysMixin is a class used by the database-dependent\n7     SpatialRefSys objects to reduce redundant code.\n8     \"\"\"\n9     @property\n10     def srs(self):\n11         \"\"\"\n12         Return a GDAL SpatialReference object.\n13         \"\"\"\n14         # TODO: Is caching really necessary here?  Is complexity worth it?\n15         if hasattr(self, '_srs'):\n16             # Returning a clone of the cached SpatialReference object.\n17             return self._srs.clone()\n18         else:\n19             # Attempting to cache a SpatialReference object.\n20 \n21             # Trying to get from WKT first.\n22             try:\n23                 self._srs = gdal.SpatialReference(self.wkt)\n24                 return self.srs\n25             except Exception as e:\n26                 msg = e\n27 \n28             try:\n29                 self._srs = gdal.SpatialReference(self.proj4text)\n30                 return self.srs\n31             except Exception as e:\n32                 msg = e\n33 \n34             raise Exception('Could not get OSR SpatialReference from WKT: %s\\nError:\\n%s' % (self.wkt, msg))\n35 \n36     @property\n37     def ellipsoid(self):\n38         \"\"\"\n39         Return a tuple of the ellipsoid parameters:\n40         (semimajor axis, semiminor axis, and inverse flattening).\n41         \"\"\"\n42         return self.srs.ellipsoid\n43 \n44     @property\n45     def name(self):\n46         \"Return the projection name.\"\n47         return self.srs.name\n48 \n49     @property\n50     def spheroid(self):\n51         \"Return the spheroid name for this spatial reference.\"\n52         return self.srs['spheroid']\n53 \n54     @property\n55     def datum(self):\n56         \"Return the datum for this spatial reference.\"\n57         return self.srs['datum']\n58 \n59     @property\n60     def projected(self):\n61         \"Is this Spatial Reference projected?\"\n62         return self.srs.projected\n63 \n64     @property\n65     def local(self):\n66         \"Is this Spatial Reference local?\"\n67         return self.srs.local\n68 \n69     @property\n70     def geographic(self):\n71         \"Is this Spatial Reference geographic?\"\n72         return self.srs.geographic\n73 \n74     @property\n75     def linear_name(self):\n76         \"Return the linear units name.\"\n77         return self.srs.linear_name\n78 \n79     @property\n80     def linear_units(self):\n81         \"Return the linear units.\"\n82         return self.srs.linear_units\n83 \n84     @property\n85     def angular_name(self):\n86         \"Return the name of the angular units.\"\n87         return self.srs.angular_name\n88 \n89     @property\n90     def angular_units(self):\n91         \"Return the angular units.\"\n92         return self.srs.angular_units\n93 \n94     @property\n95     def units(self):\n96         \"Return a tuple of the units and the name.\"\n97         if self.projected or self.local:\n98             return (self.linear_units, self.linear_name)\n99         elif self.geographic:\n100             return (self.angular_units, self.angular_name)\n101         else:\n102             return (None, None)\n103 \n104     @classmethod\n105     def get_units(cls, wkt):\n106         \"\"\"\n107         Return a tuple of (unit_value, unit_name) for the given WKT without\n108         using any of the database fields.\n109         \"\"\"\n110         return gdal.SpatialReference(wkt).units\n111 \n112     @classmethod\n113     def get_spheroid(cls, wkt, string=True):\n114         \"\"\"\n115         Class method used by GeometryField on initialization to\n116         retrieve the `SPHEROID[..]` parameters from the given WKT.\n117         \"\"\"\n118         srs = gdal.SpatialReference(wkt)\n119         sphere_params = srs.ellipsoid\n120         sphere_name = srs['spheroid']\n121 \n122         if not string:\n123             return sphere_name, sphere_params\n124         else:\n125             # `string` parameter used to place in format acceptable by PostGIS\n126             if len(sphere_params) == 3:\n127                 radius, flattening = sphere_params[0], sphere_params[2]\n128             else:\n129                 radius, flattening = sphere_params\n130             return 'SPHEROID[\"%s\",%s,%s]' % (sphere_name, radius, flattening)\n131 \n132     def __str__(self):\n133         \"\"\"\n134         Return the string representation, a 'pretty' OGC WKT.\n135         \"\"\"\n136         return str(self.srs)\n",
        "intended_behavior": "Examine how db_table is configured in the Meta classes."
    },
    {
        "rel_file_path": "django/core/management/commands/diffsettings.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.0/django/core/management/commands/diffsettings.py",
        "start": 1,
        "end": 79,
        "class_name": null,
        "method_name": null,
        "code": "1 from django.core.management.base import BaseCommand\n2 \n3 \n4 def module_to_dict(module, omittable=lambda k: k.startswith('_') or not k.isupper()):\n5     \"\"\"Convert a module namespace to a Python dictionary.\"\"\"\n6     return {k: repr(getattr(module, k)) for k in dir(module) if not omittable(k)}\n7 \n8 \n9 class Command(BaseCommand):\n10     help = \"\"\"Displays differences between the current settings.py and Django's\n11     default settings.\"\"\"\n12 \n13     requires_system_checks = False\n14 \n15     def add_arguments(self, parser):\n16         parser.add_argument(\n17             '--all', action='store_true',\n18             help=(\n19                 'Display all settings, regardless of their value. In \"hash\" '\n20                 'mode, default values are prefixed by \"###\".'\n21             ),\n22         )\n23         parser.add_argument(\n24             '--default', metavar='MODULE',\n25             help=(\n26                 \"The settings module to compare the current settings against. Leave empty to \"\n27                 \"compare against Django's default settings.\"\n28             ),\n29         )\n30         parser.add_argument(\n31             '--output', default='hash', choices=('hash', 'unified'),\n32             help=(\n33                 \"Selects the output format. 'hash' mode displays each changed \"\n34                 \"setting, with the settings that don't appear in the defaults \"\n35                 \"followed by ###. 'unified' mode prefixes the default setting \"\n36                 \"with a minus sign, followed by the changed setting prefixed \"\n37                 \"with a plus sign.\"\n38             ),\n39         )\n40 \n41     def handle(self, **options):\n42         from django.conf import settings, Settings, global_settings\n43 \n44         # Because settings are imported lazily, we need to explicitly load them.\n45         if not settings.configured:\n46             settings._setup()\n47 \n48         user_settings = module_to_dict(settings._wrapped)\n49         default = options['default']\n50         default_settings = module_to_dict(Settings(default) if default else global_settings)\n51         output_func = {\n52             'hash': self.output_hash,\n53             'unified': self.output_unified,\n54         }[options['output']]\n55         return '\\n'.join(output_func(user_settings, default_settings, **options))\n56 \n57     def output_hash(self, user_settings, default_settings, **options):\n58         # Inspired by Postfix's \"postconf -n\".\n59         output = []\n60         for key in sorted(user_settings):\n61             if key not in default_settings:\n62                 output.append(\"%s = %s  ###\" % (key, user_settings[key]))\n63             elif user_settings[key] != default_settings[key]:\n64                 output.append(\"%s = %s\" % (key, user_settings[key]))\n65             elif options['all']:\n66                 output.append(\"### %s = %s\" % (key, user_settings[key]))\n67         return output\n68 \n69     def output_unified(self, user_settings, default_settings, **options):\n70         output = []\n71         for key in sorted(user_settings):\n72             if key not in default_settings:\n73                 output.append(self.style.SUCCESS(\"+ %s = %s\" % (key, user_settings[key])))\n74             elif user_settings[key] != default_settings[key]:\n75                 output.append(self.style.ERROR(\"- %s = %s\" % (key, default_settings[key])))\n76                 output.append(self.style.SUCCESS(\"+ %s = %s\" % (key, user_settings[key])))\n77             elif options['all']:\n78                 output.append(\"  %s = %s\" % (key, user_settings[key]))\n79         return output\n",
        "intended_behavior": "Analyze the DATABASE_ROUTERS configuration and any other database-related settings."
    }
]