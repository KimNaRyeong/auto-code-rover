2025-10-18 01:55:34.725 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-18 01:55:39.545 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=221, output_tokens=12, cost=0.002570
2025-10-18 01:55:54.291 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=401, output_tokens=650, cost=0.023510
2025-10-18 01:55:55.318 | INFO     | registered non reproducing test 0
2025-10-18 01:56:13.637 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1447, output_tokens=716, cost=0.035950
2025-10-18 01:56:14.864 | INFO     | registered non reproducing test 1
2025-10-18 01:56:36.967 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2115, output_tokens=951, cost=0.049680
2025-10-18 01:56:38.079 | INFO     | registered non reproducing test 2
2025-10-18 01:56:38.079 | WARNING  | Failed to write a reproducer test; skipping reproducer tracing
2025-10-18 01:56:38.086 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 01:56:48.581 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=530, output_tokens=405, cost=0.017450
2025-10-18 01:56:48.590 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 01:56:51.542 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=759, output_tokens=61, cost=0.009420
2025-10-18 01:56:51.543 | DEBUG    | Extracted a valid json.
2025-10-18 01:56:51.543 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_class(\"Foo\")",
        "search_class(\"Bar\")",
        "search_method(\"makemigrations\")",
        "search_method(\"migrate\")",
        "search_code(\"ManyToManyField\")"
    ],
    "bug_locations": []
}
2025-10-18 01:56:51.650 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 01:56:51.651 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 01:57:10.971 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2571, output_tokens=943, cost=0.054000
2025-10-18 01:57:10.989 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 01:57:25.104 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3730, output_tokens=515, cost=0.052750
2025-10-18 01:57:25.114 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 01:57:32.219 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=869, output_tokens=248, cost=0.016130
2025-10-18 01:57:32.221 | DEBUG    | Extracted a valid json.
2025-10-18 01:57:32.221 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_code_in_file(\"ManyToManyField\", \"django/db/migrations/autodetector.py\")",
        "search_code_in_file(\"ManyToManyField('self')\", \"django/db/migrations/operations/models.py\")",
        "search_code(\"ManyToManyField('self')\")"
    ],
    "bug_locations": [
        {
            "file": "django/db/migrations/autodetector.py",
            "class": "",
            "method": "",
            "intended_behavior": "Ensure that when a `ManyToManyField`'s target changes to 'self', the autodetector generates correct migration operations that reflect this change in the database schema without causing reference errors."
        },
        {
            "file": "django/db/migrations/operations/models.py",
            "class": "",
            "method": "",
            "intended_behavior": "Safely handle the transition of a `ManyToManyField` to target 'self', ensuring any necessary adjustments to intermediary tables (e.g., correctly referencing the same model for both sides of the relation) are made without creating invalid state or schema references that could lead to operational errors."
        }
    ]
}
2025-10-18 01:57:32.258 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 01:57:32.259 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 01:57:46.818 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=4474, output_tokens=664, cost=0.064660
2025-10-18 01:57:46.832 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 01:57:58.167 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=5354, output_tokens=505, cost=0.068690
2025-10-18 01:57:58.176 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 01:58:03.579 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=859, output_tokens=173, cost=0.013780
2025-10-18 01:58:03.580 | DEBUG    | Extracted a valid json.
2025-10-18 01:58:03.586 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations":[
        {
            "file": "django/db/migrations/",
            "class": "",
            "method": "",
            "intended_behavior": "The correct handling of a `ManyToManyField` change to reference 'self' should gracefully adjust the schema, ensuring that any intermediary (through) tables that facilitate the many-to-many relationship are correctly modified. This includes: 1. Correctly retaining or updating column references to ensure they accurately represent the self-reference. 2. Ensuring that migration applying or rollback procedures accurately reflect changes without causing breakdowns in schema consistency, such as missing columns or incorrectly formed relationships. 3. Preserving existing functionality and data integrity for the `ManyToManyField` relationships, including those that now reference 'self', throughout the migration process."
        }
    ]
}
2025-10-18 01:58:03.589 | DEBUG    | Failed to retrieve code from all bug locations. Asking search agent to re-generate response.
2025-10-18 01:58:03.590 | DEBUG    | <Agent search> Downstream could not consume our last response. Will retry.
2025-10-18 01:58:03.590 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 01:58:13.898 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=5893, output_tokens=473, cost=0.073120
2025-10-18 01:58:13.907 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 01:58:16.173 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=827, output_tokens=14, cost=0.008690
2025-10-18 01:58:16.174 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-18 01:58:16.174 | DEBUG    | Trying to convert API calls/bug locations into json. Try 2 of 5.
2025-10-18 01:58:18.054 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=827, output_tokens=14, cost=0.008690
2025-10-18 01:58:18.055 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-18 01:58:18.055 | DEBUG    | Trying to convert API calls/bug locations into json. Try 3 of 5.
2025-10-18 01:58:21.276 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=827, output_tokens=14, cost=0.008690
2025-10-18 01:58:21.277 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-18 01:58:21.277 | DEBUG    | Trying to convert API calls/bug locations into json. Try 4 of 5.
2025-10-18 01:58:23.103 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=827, output_tokens=14, cost=0.008690
2025-10-18 01:58:23.104 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-18 01:58:23.105 | DEBUG    | Trying to convert API calls/bug locations into json. Try 5 of 5.
2025-10-18 01:58:26.084 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=827, output_tokens=14, cost=0.008690
2025-10-18 01:58:26.085 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-18 01:58:26.086 | DEBUG    | Agent proxy return the following json: None
2025-10-18 01:58:26.086 | DEBUG    | Could not extract API calls from agent search response, asking search agent to re-generate response.
2025-10-18 01:58:26.087 | DEBUG    | <Agent search> Downstream could not consume our last response. Will retry.
2025-10-18 01:58:26.087 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 01:58:37.969 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=6393, output_tokens=506, cost=0.079110
2025-10-18 01:58:37.979 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 01:58:39.598 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=860, output_tokens=14, cost=0.009020
2025-10-18 01:58:39.599 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-18 01:58:39.599 | DEBUG    | Trying to convert API calls/bug locations into json. Try 2 of 5.
2025-10-18 01:58:41.527 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=860, output_tokens=14, cost=0.009020
2025-10-18 01:58:41.528 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-18 01:58:41.528 | DEBUG    | Trying to convert API calls/bug locations into json. Try 3 of 5.
2025-10-18 01:58:43.720 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=860, output_tokens=14, cost=0.009020
2025-10-18 01:58:43.721 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-18 01:58:43.722 | DEBUG    | Trying to convert API calls/bug locations into json. Try 4 of 5.
2025-10-18 01:58:45.713 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=860, output_tokens=14, cost=0.009020
2025-10-18 01:58:45.714 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-18 01:58:45.714 | DEBUG    | Trying to convert API calls/bug locations into json. Try 5 of 5.
2025-10-18 01:58:47.716 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=860, output_tokens=14, cost=0.009020
2025-10-18 01:58:47.717 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-18 01:58:47.717 | DEBUG    | Agent proxy return the following json: None
2025-10-18 01:58:47.717 | DEBUG    | Could not extract API calls from agent search response, asking search agent to re-generate response.
2025-10-18 01:58:47.718 | DEBUG    | <Agent search> Downstream could not consume our last response. Will retry.
2025-10-18 01:58:47.718 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 01:59:00.015 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=6926, output_tokens=559, cost=0.086030
2025-10-18 01:59:00.025 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 01:59:01.070 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=913, output_tokens=14, cost=0.009550
2025-10-18 01:59:01.071 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-18 01:59:01.071 | DEBUG    | Trying to convert API calls/bug locations into json. Try 2 of 5.
2025-10-18 01:59:02.049 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=913, output_tokens=14, cost=0.009550
2025-10-18 01:59:02.050 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-18 01:59:02.050 | DEBUG    | Trying to convert API calls/bug locations into json. Try 3 of 5.
2025-10-18 01:59:02.914 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=913, output_tokens=14, cost=0.009550
2025-10-18 01:59:02.915 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-18 01:59:02.915 | DEBUG    | Trying to convert API calls/bug locations into json. Try 4 of 5.
2025-10-18 01:59:04.132 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=913, output_tokens=14, cost=0.009550
2025-10-18 01:59:04.133 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-18 01:59:04.134 | DEBUG    | Trying to convert API calls/bug locations into json. Try 5 of 5.
2025-10-18 01:59:05.223 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=913, output_tokens=14, cost=0.009550
2025-10-18 01:59:05.224 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-18 01:59:05.231 | DEBUG    | Agent proxy return the following json: None
2025-10-18 01:59:05.231 | DEBUG    | Could not extract API calls from agent search response, asking search agent to re-generate response.
2025-10-18 01:59:05.232 | DEBUG    | <Agent search> Downstream could not consume our last response. Will retry.
2025-10-18 01:59:05.232 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 01:59:20.521 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=7512, output_tokens=525, cost=0.090870
2025-10-18 01:59:20.532 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 01:59:23.721 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=879, output_tokens=66, cost=0.010770
2025-10-18 01:59:23.723 | DEBUG    | Extracted a valid json.
2025-10-18 01:59:23.723 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_code(\"AddField\")",
        "search_code(\"AlterField\")",
        "search_code(\"ManyToManyField\")",
        "search_code_in_file(\"ManyToManyField\", \"django/db/models/fields/related.py\")"
    ],
    "bug_locations": []
}
2025-10-18 01:59:23.902 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 01:59:23.902 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 01:59:44.737 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=9400, output_tokens=957, cost=0.122710
2025-10-18 01:59:44.745 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 01:59:59.787 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=10573, output_tokens=568, cost=0.122770
2025-10-18 01:59:59.793 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 02:00:07.305 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=922, output_tokens=318, cost=0.018760
2025-10-18 02:00:07.306 | DEBUG    | Extracted a valid json.
2025-10-18 02:00:07.306 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "django/db/migrations/autodetector.py",
            "class": "",
            "method": "",
            "intended_behavior": "Enhance detection logic for `ManyToManyField` when its target changes, especially to 'self'. Ensure that the autodetector generates accurate migration operations that reflect complex changes in field relationships, such as changes in target models or the introduction of self-referencing relations."
        },
        {
            "file": "django/db/migrations/operations/fields.py",
            "class": "",
            "method": "",
            "intended_behavior": "Incorporate logic to handle the special case where a `ManyToManyField` is altered to target 'self', ensuring the correct intermediary table schema is generated and existing references are updated or maintained properly. Ensure that both `AddField` and `AlterField` operations accurately apply schema changes for self-referencing many-to-many relationships."
        },
        {
            "file": "django/db/models/fields/related.py",
            "class": "",
            "method": "",
            "intended_behavior": "Strengthen validation and deconstruction logic to accurately handle `ManyToManyField` pointing to 'self'. This includes ensuring the field's initialization properly sets up self-references and that deconstruction provides the correct state for migration serialization. The `_check_relationship_model` method specifically could be enhanced to ensure it validates self-referencing relationships correctly, preventing schema inconsistencies."
        }
    ]
}
2025-10-18 02:00:07.320 | DEBUG    | Bug location extracted successfully: [<file>django/db/migrations/autodetector.py</file>
<class>None</class>
<method>None</method>
<code>
1 import functools
2 import re
3 from collections import defaultdict
4 from itertools import chain
5 
6 from django.conf import settings
7 from django.db import models
8 from django.db.migrations import operations
9 from django.db.migrations.migration import Migration
10 from django.db.migrations.operations.models import AlterModelOptions
11 from django.db.migrations.optimizer import MigrationOptimizer
12 from django.db.migrations.questioner import MigrationQuestioner
13 from django.db.migrations.utils import (
14     COMPILED_REGEX_TYPE,
15     RegexObject,
16     resolve_relation,
17 )
18 from django.utils.topological_sort import stable_topological_sort
19 
20 
21 class MigrationAutodetector:
22     """
23     Take a pair of ProjectStates and compare them to see what the first would
24     need doing to make it match the second (the second usually being the
25     project's current state).
26 
27     Note that this naturally operates on entire projects at a time,
28     as it's likely that changes interact (for example, you can't
29     add a ForeignKey without having a migration to add the table it
30     depends on first). A user interface may offer single-app usage
31     if it wishes, with the caveat that it may not always be possible.
32     """
33 
34     def __init__(self, from_state, to_state, questioner=None):
35         self.from_state = from_state
36         self.to_state = to_state
37         self.questioner = questioner or MigrationQuestioner()
38         self.existing_apps = {app for app, model in from_state.models}
39 
40     def changes(self, graph, trim_to_apps=None, convert_apps=None, migration_name=None):
41         """
42         Main entry point to produce a list of applicable changes.
43         Take a graph to base names on and an optional set of apps
44         to try and restrict to (restriction is not guaranteed)
45         """
46         changes = self._detect_changes(convert_apps, graph)
47         changes = self.arrange_for_graph(changes, graph, migration_name)
48         if trim_to_apps:
49             changes = self._trim_to_apps(changes, trim_to_apps)
50         return changes
51 
52     def deep_deconstruct(self, obj):
53         """
54         Recursive deconstruction for a field and its arguments.
55         Used for full comparison for rename/alter; sometimes a single-level
56         deconstruction will not compare correctly.
57         """
58         if isinstance(obj, list):
59             return [self.deep_deconstruct(value) for value in obj]
60         elif isinstance(obj, tuple):
61             return tuple(self.deep_deconstruct(value) for value in obj)
62         elif isinstance(obj, dict):
63             return {key: self.deep_deconstruct(value) for key, value in obj.items()}
64         elif isinstance(obj, functools.partial):
65             return (
66                 obj.func,
67                 self.deep_deconstruct(obj.args),
68                 self.deep_deconstruct(obj.keywords),
69             )
70         elif isinstance(obj, COMPILED_REGEX_TYPE):
71             return RegexObject(obj)
72         elif isinstance(obj, type):
73             # If this is a type that implements 'deconstruct' as an instance method,
74             # avoid treating this as being deconstructible itself - see #22951
75             return obj
76         elif hasattr(obj, "deconstruct"):
77             deconstructed = obj.deconstruct()
78             if isinstance(obj, models.Field):
79                 # we have a field which also returns a name
80                 deconstructed = deconstructed[1:]
81             path, args, kwargs = deconstructed
82             return (
83                 path,
84                 [self.deep_deconstruct(value) for value in args],
85                 {key: self.deep_deconstruct(value) for key, value in kwargs.items()},
86             )
87         else:
88             return obj
89 
90     def only_relation_agnostic_fields(self, fields):
91         """
92         Return a definition of the fields that ignores field names and
93         what related fields actually relate to. Used for detecting renames (as
94         the related fields change during renames).
95         """
96         fields_def = []
97         for name, field in sorted(fields.items()):
98             deconstruction = self.deep_deconstruct(field)
99             if field.remote_field and field.remote_field.model:
100                 deconstruction[2].pop("to", None)
101             fields_def.append(deconstruction)
102         return fields_def
103 
104     def _detect_changes(self, convert_apps=None, graph=None):
105         """
106         Return a dict of migration plans which will achieve the
107         change from from_state to to_state. The dict has app labels
108         as keys and a list of migrations as values.
109 
110         The resulting migrations aren't specially named, but the names
111         do matter for dependencies inside the set.
112 
113         convert_apps is the list of apps to convert to use migrations
114         (i.e. to make initial migrations for, in the usual case)
115 
116         graph is an optional argument that, if provided, can help improve
117         dependency generation and avoid potential circular dependencies.
118         """
119         # The first phase is generating all the operations for each app
120         # and gathering them into a big per-app list.
121         # Then go through that list, order it, and split into migrations to
122         # resolve dependencies caused by M2Ms and FKs.
123         self.generated_operations = {}
124         self.altered_indexes = {}
125         self.altered_constraints = {}
126         self.renamed_fields = {}
127 
128         # Prepare some old/new state and model lists, separating
129         # proxy models and ignoring unmigrated apps.
130         self.old_model_keys = set()
131         self.old_proxy_keys = set()
132         self.old_unmanaged_keys = set()
133         self.new_model_keys = set()
134         self.new_proxy_keys = set()
135         self.new_unmanaged_keys = set()
136         for (app_label, model_name), model_state in self.from_state.models.items():
137             if not model_state.options.get("managed", True):
138                 self.old_unmanaged_keys.add((app_label, model_name))
139             elif app_label not in self.from_state.real_apps:
140                 if model_state.options.get("proxy"):
141                     self.old_proxy_keys.add((app_label, model_name))
142                 else:
143                     self.old_model_keys.add((app_label, model_name))
144 
145         for (app_label, model_name), model_state in self.to_state.models.items():
146             if not model_state.options.get("managed", True):
147                 self.new_unmanaged_keys.add((app_label, model_name))
148             elif app_label not in self.from_state.real_apps or (
149                 convert_apps and app_label in convert_apps
150             ):
151                 if model_state.options.get("proxy"):
152                     self.new_proxy_keys.add((app_label, model_name))
153                 else:
154                     self.new_model_keys.add((app_label, model_name))
155 
156         self.from_state.resolve_fields_and_relations()
157         self.to_state.resolve_fields_and_relations()
158 
159         # Renames have to come first
160         self.generate_renamed_models()
161 
162         # Prepare lists of fields and generate through model map
163         self._prepare_field_lists()
164         self._generate_through_model_map()
165 
166         # Generate non-rename model operations
167         self.generate_deleted_models()
168         self.generate_created_models()
169         self.generate_deleted_proxies()
170         self.generate_created_proxies()
171         self.generate_altered_options()
172         self.generate_altered_managers()
173 
174         # Create the renamed fields and store them in self.renamed_fields.
175         # They are used by create_altered_indexes(), generate_altered_fields(),
176         # generate_removed_altered_index/unique_together(), and
177         # generate_altered_index/unique_together().
178         self.create_renamed_fields()
179         # Create the altered indexes and store them in self.altered_indexes.
180         # This avoids the same computation in generate_removed_indexes()
181         # and generate_added_indexes().
182         self.create_altered_indexes()
183         self.create_altered_constraints()
184         # Generate index removal operations before field is removed
185         self.generate_removed_constraints()
186         self.generate_removed_indexes()
187         # Generate field renaming operations.
188         self.generate_renamed_fields()
189         self.generate_renamed_indexes()
190         # Generate removal of foo together.
191         self.generate_removed_altered_unique_together()
192         self.generate_removed_altered_index_together()  # RemovedInDjango51Warning.
193         # Generate field operations.
194         self.generate_removed_fields()
195         self.generate_added_fields()
196         self.generate_altered_fields()
197         self.generate_altered_order_with_respect_to()
198         self.generate_altered_unique_together()
199         self.generate_altered_index_together()  # RemovedInDjango51Warning.
200         self.generate_added_indexes()
201         self.generate_added_constraints()
202         self.generate_altered_db_table()
203 
204         self._sort_migrations()
205         self._build_migration_list(graph)
206         self._optimize_migrations()
207 
208         return self.migrations
209 
210     def _prepare_field_lists(self):
211         """
212         Prepare field lists and a list of the fields that used through models
213         in the old state so dependencies can be made from the through model
214         deletion to the field that uses it.
215         """
216         self.kept_model_keys = self.old_model_keys & self.new_model_keys
217         self.kept_proxy_keys = self.old_proxy_keys & self.new_proxy_keys
218         self.kept_unmanaged_keys = self.old_unmanaged_keys & self.new_unmanaged_keys
219         self.through_users = {}
220         self.old_field_keys = {
221             (app_label, model_name, field_name)
222             for app_label, model_name in self.kept_model_keys
223             for field_name in self.from_state.models[
224                 app_label, self.renamed_models.get((app_label, model_name), model_name)
225             ].fields
226         }
227         self.new_field_keys = {
228             (app_label, model_name, field_name)
229             for app_label, model_name in self.kept_model_keys
230             for field_name in self.to_state.models[app_label, model_name].fields
231         }
232 
233     def _generate_through_model_map(self):
234         """Through model map generation."""
235         for app_label, model_name in sorted(self.old_model_keys):
236             old_model_name = self.renamed_models.get(
237                 (app_label, model_name), model_name
238             )
239             old_model_state = self.from_state.models[app_label, old_model_name]
240             for field_name, field in old_model_state.fields.items():
241                 if hasattr(field, "remote_field") and getattr(
242                     field.remote_field, "through", None
243                 ):
244                     through_key = resolve_relation(
245                         field.remote_field.through, app_label, model_name
246                     )
247                     self.through_users[through_key] = (
248                         app_label,
249                         old_model_name,
250                         field_name,
251                     )
252 
253     @staticmethod
254     def _resolve_dependency(dependency):
255         """
256         Return the resolved dependency and a boolean denoting whether or not
257         it was swappable.
258         """
259         if dependency[0] != "__setting__":
260             return dependency, False
261         resolved_app_label, resolved_object_name = getattr(
262             settings, dependency[1]
263         ).split(".")
264         return (resolved_app_label, resolved_object_name.lower()) + dependency[2:], True
265 
266     def _build_migration_list(self, graph=None):
267         """
268         Chop the lists of operations up into migrations with dependencies on
269         each other. Do this by going through an app's list of operations until
270         one is found that has an outgoing dependency that isn't in another
271         app's migration yet (hasn't been chopped off its list). Then chop off
272         the operations before it into a migration and move onto the next app.
273         If the loops completes without doing anything, there's a circular
274         dependency (which _should_ be impossible as the operations are
275         all split at this point so they can't depend and be depended on).
276         """
277         self.migrations = {}
278         num_ops = sum(len(x) for x in self.generated_operations.values())
279         chop_mode = False
280         while num_ops:
281             # On every iteration, we step through all the apps and see if there
282             # is a completed set of operations.
283             # If we find that a subset of the operations are complete we can
284             # try to chop it off from the rest and continue, but we only
285             # do this if we've already been through the list once before
286             # without any chopping and nothing has changed.
287             for app_label in sorted(self.generated_operations):
288                 chopped = []
289                 dependencies = set()
290                 for operation in list(self.generated_operations[app_label]):
291                     deps_satisfied = True
292                     operation_dependencies = set()
293                     for dep in operation._auto_deps:
294                         # Temporarily resolve the swappable dependency to
295                         # prevent circular references. While keeping the
296                         # dependency checks on the resolved model, add the
297                         # swappable dependencies.
298                         original_dep = dep
299                         dep, is_swappable_dep = self._resolve_dependency(dep)
300                         if dep[0] != app_label:
301                             # External app dependency. See if it's not yet
302                             # satisfied.
303                             for other_operation in self.generated_operations.get(
304                                 dep[0], []
305                             ):
306                                 if self.check_dependency(other_operation, dep):
307                                     deps_satisfied = False
308                                     break
309                             if not deps_satisfied:
310                                 break
311                             else:
312                                 if is_swappable_dep:
313                                     operation_dependencies.add(
314                                         (original_dep[0], original_dep[1])
315                                     )
316                                 elif dep[0] in self.migrations:
317                                     operation_dependencies.add(
318                                         (dep[0], self.migrations[dep[0]][-1].name)
319                                     )
320                                 else:
321                                     # If we can't find the other app, we add a
322                                     # first/last dependency, but only if we've
323                                     # already been through once and checked
324                                     # everything.
325                                     if chop_mode:
326                                         # If the app already exists, we add a
327                                         # dependency on the last migration, as
328                                         # we don't know which migration
329                                         # contains the target field. If it's
330                                         # not yet migrated or has no
331                                         # migrations, we use __first__.
332                                         if graph and graph.leaf_nodes(dep[0]):
333                                             operation_dependencies.add(
334                                                 graph.leaf_nodes(dep[0])[0]
335                                             )
336                                         else:
337                                             operation_dependencies.add(
338                                                 (dep[0], "__first__")
339                                             )
340                                     else:
341                                         deps_satisfied = False
342                     if deps_satisfied:
343                         chopped.append(operation)
344                         dependencies.update(operation_dependencies)
345                         del self.generated_operations[app_label][0]
346                     else:
347                         break
348                 # Make a migration! Well, only if there's stuff to put in it
349                 if dependencies or chopped:
350                     if not self.generated_operations[app_label] or chop_mode:
351                         subclass = type(
352                             "Migration",
353                             (Migration,),
354                             {"operations": [], "dependencies": []},
355                         )
356                         instance = subclass(
357                             "auto_%i" % (len(self.migrations.get(app_label, [])) + 1),
358                             app_label,
359                         )
360                         instance.dependencies = list(dependencies)
361                         instance.operations = chopped
362                         instance.initial = app_label not in self.existing_apps
363                         self.migrations.setdefault(app_label, []).append(instance)
364                         chop_mode = False
365                     else:
366                         self.generated_operations[app_label] = (
367                             chopped + self.generated_operations[app_label]
368                         )
369             new_num_ops = sum(len(x) for x in self.generated_operations.values())
370             if new_num_ops == num_ops:
371                 if not chop_mode:
372                     chop_mode = True
373                 else:
374                     raise ValueError(
375                         "Cannot resolve operation dependencies: %r"
376                         % self.generated_operations
377                     )
378             num_ops = new_num_ops
379 
380     def _sort_migrations(self):
381         """
382         Reorder to make things possible. Reordering may be needed so FKs work
383         nicely inside the same app.
384         """
385         for app_label, ops in sorted(self.generated_operations.items()):
386             # construct a dependency graph for intra-app dependencies
387             dependency_graph = {op: set() for op in ops}
388             for op in ops:
389                 for dep in op._auto_deps:
390                     # Resolve intra-app dependencies to handle circular
391                     # references involving a swappable model.
392                     dep = self._resolve_dependency(dep)[0]
393                     if dep[0] == app_label:
394                         for op2 in ops:
395                             if self.check_dependency(op2, dep):
396                                 dependency_graph[op].add(op2)
397 
398             # we use a stable sort for deterministic tests & general behavior
399             self.generated_operations[app_label] = stable_topological_sort(
400                 ops, dependency_graph
401             )
402 
403     def _optimize_migrations(self):
404         # Add in internal dependencies among the migrations
405         for app_label, migrations in self.migrations.items():
406             for m1, m2 in zip(migrations, migrations[1:]):
407                 m2.dependencies.append((app_label, m1.name))
408 
409         # De-dupe dependencies
410         for migrations in self.migrations.values():
411             for migration in migrations:
412                 migration.dependencies = list(set(migration.dependencies))
413 
414         # Optimize migrations
415         for app_label, migrations in self.migrations.items():
416             for migration in migrations:
417                 migration.operations = MigrationOptimizer().optimize(
418                     migration.operations, app_label
419                 )
420 
421     def check_dependency(self, operation, dependency):
422         """
423         Return True if the given operation depends on the given dependency,
424         False otherwise.
425         """
426         # Created model
427         if dependency[2] is None and dependency[3] is True:
428             return (
429                 isinstance(operation, operations.CreateModel)
430                 and operation.name_lower == dependency[1].lower()
431             )
432         # Created field
433         elif dependency[2] is not None and dependency[3] is True:
434             return (
435                 isinstance(operation, operations.CreateModel)
436                 and operation.name_lower == dependency[1].lower()
437                 and any(dependency[2] == x for x, y in operation.fields)
438             ) or (
439                 isinstance(operation, operations.AddField)
440                 and operation.model_name_lower == dependency[1].lower()
441                 and operation.name_lower == dependency[2].lower()
442             )
443         # Removed field
444         elif dependency[2] is not None and dependency[3] is False:
445             return (
446                 isinstance(operation, operations.RemoveField)
447                 and operation.model_name_lower == dependency[1].lower()
448                 and operation.name_lower == dependency[2].lower()
449             )
450         # Removed model
451         elif dependency[2] is None and dependency[3] is False:
452             return (
453                 isinstance(operation, operations.DeleteModel)
454                 and operation.name_lower == dependency[1].lower()
455             )
456         # Field being altered
457         elif dependency[2] is not None and dependency[3] == "alter":
458             return (
459                 isinstance(operation, operations.AlterField)
460                 and operation.model_name_lower == dependency[1].lower()
461                 and operation.name_lower == dependency[2].lower()
462             )
463         # order_with_respect_to being unset for a field
464         elif dependency[2] is not None and dependency[3] == "order_wrt_unset":
465             return (
466                 isinstance(operation, operations.AlterOrderWithRespectTo)
467                 and operation.name_lower == dependency[1].lower()
468                 and (operation.order_with_respect_to or "").lower()
469                 != dependency[2].lower()
470             )
471         # Field is removed and part of an index/unique_together
472         elif dependency[2] is not None and dependency[3] == "foo_together_change":
473             return (
474                 isinstance(
475                     operation,
476                     (operations.AlterUniqueTogether, operations.AlterIndexTogether),
477                 )
478                 and operation.name_lower == dependency[1].lower()
479             )
480         # Unknown dependency. Raise an error.
481         else:
482             raise ValueError("Can't handle dependency %r" % (dependency,))
483 
484     def add_operation(self, app_label, operation, dependencies=None, beginning=False):
485         # Dependencies are
486         # (app_label, model_name, field_name, create/delete as True/False)
487         operation._auto_deps = dependencies or []
488         if beginning:
489             self.generated_operations.setdefault(app_label, []).insert(0, operation)
490         else:
491             self.generated_operations.setdefault(app_label, []).append(operation)
492 
493     def swappable_first_key(self, item):
494         """
495         Place potential swappable models first in lists of created models (only
496         real way to solve #22783).
497         """
498         try:
499             model_state = self.to_state.models[item]
500             base_names = {
501                 base if isinstance(base, str) else base.__name__
502                 for base in model_state.bases
503             }
504             string_version = "%s.%s" % (item[0], item[1])
505             if (
506                 model_state.options.get("swappable")
507                 or "AbstractUser" in base_names
508                 or "AbstractBaseUser" in base_names
509                 or settings.AUTH_USER_MODEL.lower() == string_version.lower()
510             ):
511                 return ("___" + item[0], "___" + item[1])
512         except LookupError:
513             pass
514         return item
515 
516     def generate_renamed_models(self):
517         """
518         Find any renamed models, generate the operations for them, and remove
519         the old entry from the model lists. Must be run before other
520         model-level generation.
521         """
522         self.renamed_models = {}
523         self.renamed_models_rel = {}
524         added_models = self.new_model_keys - self.old_model_keys
525         for app_label, model_name in sorted(added_models):
526             model_state = self.to_state.models[app_label, model_name]
527             model_fields_def = self.only_relation_agnostic_fields(model_state.fields)
528 
529             removed_models = self.old_model_keys - self.new_model_keys
530             for rem_app_label, rem_model_name in removed_models:
531                 if rem_app_label == app_label:
532                     rem_model_state = self.from_state.models[
533                         rem_app_label, rem_model_name
534                     ]
535                     rem_model_fields_def = self.only_relation_agnostic_fields(
536                         rem_model_state.fields
537                     )
538                     if model_fields_def == rem_model_fields_def:
539                         if self.questioner.ask_rename_model(
540                             rem_model_state, model_state
541                         ):
542                             dependencies = []
543                             fields = list(model_state.fields.values()) + [
544                                 field.remote_field
545                                 for relations in self.to_state.relations[
546                                     app_label, model_name
547                                 ].values()
548                                 for field in relations.values()
549                             ]
550                             for field in fields:
551                                 if field.is_relation:
552                                     dependencies.extend(
553                                         self._get_dependencies_for_foreign_key(
554                                             app_label,
555                                             model_name,
556                                             field,
557                                             self.to_state,
558                                         )
559                                     )
560                             self.add_operation(
561                                 app_label,
562                                 operations.RenameModel(
563                                     old_name=rem_model_state.name,
564                                     new_name=model_state.name,
565                                 ),
566                                 dependencies=dependencies,
567                             )
568                             self.renamed_models[app_label, model_name] = rem_model_name
569                             renamed_models_rel_key = "%s.%s" % (
570                                 rem_model_state.app_label,
571                                 rem_model_state.name_lower,
572                             )
573                             self.renamed_models_rel[
574                                 renamed_models_rel_key
575                             ] = "%s.%s" % (
576                                 model_state.app_label,
577                                 model_state.name_lower,
578                             )
579                             self.old_model_keys.remove((rem_app_label, rem_model_name))
580                             self.old_model_keys.add((app_label, model_name))
581                             break
582 
583     def generate_created_models(self):
584         """
585         Find all new models (both managed and unmanaged) and make create
586         operations for them as well as separate operations to create any
587         foreign key or M2M relationships (these are optimized later, if
588         possible).
589 
590         Defer any model options that refer to collections of fields that might
591         be deferred (e.g. unique_together, index_together).
592         """
593         old_keys = self.old_model_keys | self.old_unmanaged_keys
594         added_models = self.new_model_keys - old_keys
595         added_unmanaged_models = self.new_unmanaged_keys - old_keys
596         all_added_models = chain(
597             sorted(added_models, key=self.swappable_first_key, reverse=True),
598             sorted(added_unmanaged_models, key=self.swappable_first_key, reverse=True),
599         )
600         for app_label, model_name in all_added_models:
601             model_state = self.to_state.models[app_label, model_name]
602             # Gather related fields
603             related_fields = {}
604             primary_key_rel = None
605             for field_name, field in model_state.fields.items():
606                 if field.remote_field:
607                     if field.remote_field.model:
608                         if field.primary_key:
609                             primary_key_rel = field.remote_field.model
610                         elif not field.remote_field.parent_link:
611                             related_fields[field_name] = field
612                     if getattr(field.remote_field, "through", None):
613                         related_fields[field_name] = field
614 
615             # Are there indexes/unique|index_together to defer?
616             indexes = model_state.options.pop("indexes")
617             constraints = model_state.options.pop("constraints")
618             unique_together = model_state.options.pop("unique_together", None)
619             # RemovedInDjango51Warning.
620             index_together = model_state.options.pop("index_together", None)
621             order_with_respect_to = model_state.options.pop(
622                 "order_with_respect_to", None
623             )
624             # Depend on the deletion of any possible proxy version of us
625             dependencies = [
626                 (app_label, model_name, None, False),
627             ]
628             # Depend on all bases
629             for base in model_state.bases:
630                 if isinstance(base, str) and "." in base:
631                     base_app_label, base_name = base.split(".", 1)
632                     dependencies.append((base_app_label, base_name, None, True))
633                     # Depend on the removal of base fields if the new model has
634                     # a field with the same name.
635                     old_base_model_state = self.from_state.models.get(
636                         (base_app_label, base_name)
637                     )
638                     new_base_model_state = self.to_state.models.get(
639                         (base_app_label, base_name)
640                     )
641                     if old_base_model_state and new_base_model_state:
642                         removed_base_fields = (
643                             set(old_base_model_state.fields)
644                             .difference(
645                                 new_base_model_state.fields,
646                             )
647                             .intersection(model_state.fields)
648                         )
649                         for removed_base_field in removed_base_fields:
650                             dependencies.append(
651                                 (base_app_label, base_name, removed_base_field, False)
652                             )
653             # Depend on the other end of the primary key if it's a relation
654             if primary_key_rel:
655                 dependencies.append(
656                     resolve_relation(
657                         primary_key_rel,
658                         app_label,
659                         model_name,
660                     )
661                     + (None, True)
662                 )
663             # Generate creation operation
664             self.add_operation(
665                 app_label,
666                 operations.CreateModel(
667                     name=model_state.name,
668                     fields=[
669                         d
670                         for d in model_state.fields.items()
671                         if d[0] not in related_fields
672                     ],
673                     options=model_state.options,
674                     bases=model_state.bases,
675                     managers=model_state.managers,
676                 ),
677                 dependencies=dependencies,
678                 beginning=True,
679             )
680 
681             # Don't add operations which modify the database for unmanaged models
682             if not model_state.options.get("managed", True):
683                 continue
684 
685             # Generate operations for each related field
686             for name, field in sorted(related_fields.items()):
687                 dependencies = self._get_dependencies_for_foreign_key(
688                     app_label,
689                     model_name,
690                     field,
691                     self.to_state,
692                 )
693                 # Depend on our own model being created
694                 dependencies.append((app_label, model_name, None, True))
695                 # Make operation
696                 self.add_operation(
697                     app_label,
698                     operations.AddField(
699                         model_name=model_name,
700                         name=name,
701                         field=field,
702                     ),
703                     dependencies=list(set(dependencies)),
704                 )
705             # Generate other opns
706             if order_with_respect_to:
707                 self.add_operation(
708                     app_label,
709                     operations.AlterOrderWithRespectTo(
710                         name=model_name,
711                         order_with_respect_to=order_with_respect_to,
712                     ),
713                     dependencies=[
714                         (app_label, model_name, order_with_respect_to, True),
715                         (app_label, model_name, None, True),
716                     ],
717                 )
718             related_dependencies = [
719                 (app_label, model_name, name, True) for name in sorted(related_fields)
720             ]
721             related_dependencies.append((app_label, model_name, None, True))
722             for index in indexes:
723                 self.add_operation(
724                     app_label,
725                     operations.AddIndex(
726                         model_name=model_name,
727                         index=index,
728                     ),
729                     dependencies=related_dependencies,
730                 )
731             for constraint in constraints:
732                 self.add_operation(
733                     app_label,
734                     operations.AddConstraint(
735                         model_name=model_name,
736                         constraint=constraint,
737                     ),
738                     dependencies=related_dependencies,
739                 )
740             if unique_together:
741                 self.add_operation(
742                     app_label,
743                     operations.AlterUniqueTogether(
744                         name=model_name,
745                         unique_together=unique_together,
746                     ),
747                     dependencies=related_dependencies,
748                 )
749             # RemovedInDjango51Warning.
750             if index_together:
751                 self.add_operation(
752                     app_label,
753                     operations.AlterIndexTogether(
754                         name=model_name,
755                         index_together=index_together,
756                     ),
757                     dependencies=related_dependencies,
758                 )
759             # Fix relationships if the model changed from a proxy model to a
760             # concrete model.
761             relations = self.to_state.relations
762             if (app_label, model_name) in self.old_proxy_keys:
763                 for related_model_key, related_fields in relations[
764                     app_label, model_name
765                 ].items():
766                     related_model_state = self.to_state.models[related_model_key]
767                     for related_field_name, related_field in related_fields.items():
768                         self.add_operation(
769                             related_model_state.app_label,
770                             operations.AlterField(
771                                 model_name=related_model_state.name,
772                                 name=related_field_name,
773                                 field=related_field,
774                             ),
775                             dependencies=[(app_label, model_name, None, True)],
776                         )
777 
778     def generate_created_proxies(self):
779         """
780         Make CreateModel statements for proxy models. Use the same statements
781         as that way there's less code duplication, but for proxy models it's
782         safe to skip all the pointless field stuff and chuck out an operation.
783         """
784         added = self.new_proxy_keys - self.old_proxy_keys
785         for app_label, model_name in sorted(added):
786             model_state = self.to_state.models[app_label, model_name]
787             assert model_state.options.get("proxy")
788             # Depend on the deletion of any possible non-proxy version of us
789             dependencies = [
790                 (app_label, model_name, None, False),
791             ]
792             # Depend on all bases
793             for base in model_state.bases:
794                 if isinstance(base, str) and "." in base:
795                     base_app_label, base_name = base.split(".", 1)
796                     dependencies.append((base_app_label, base_name, None, True))
797             # Generate creation operation
798             self.add_operation(
799                 app_label,
800                 operations.CreateModel(
801                     name=model_state.name,
802                     fields=[],
803                     options=model_state.options,
804                     bases=model_state.bases,
805                     managers=model_state.managers,
806                 ),
807                 # Depend on the deletion of any possible non-proxy version of us
808                 dependencies=dependencies,
809             )
810 
811     def generate_deleted_models(self):
812         """
813         Find all deleted models (managed and unmanaged) and make delete
814         operations for them as well as separate operations to delete any
815         foreign key or M2M relationships (these are optimized later, if
816         possible).
817 
818         Also bring forward removal of any model options that refer to
819         collections of fields - the inverse of generate_created_models().
820         """
821         new_keys = self.new_model_keys | self.new_unmanaged_keys
822         deleted_models = self.old_model_keys - new_keys
823         deleted_unmanaged_models = self.old_unmanaged_keys - new_keys
824         all_deleted_models = chain(
825             sorted(deleted_models), sorted(deleted_unmanaged_models)
826         )
827         for app_label, model_name in all_deleted_models:
828             model_state = self.from_state.models[app_label, model_name]
829             # Gather related fields
830             related_fields = {}
831             for field_name, field in model_state.fields.items():
832                 if field.remote_field:
833                     if field.remote_field.model:
834                         related_fields[field_name] = field
835                     if getattr(field.remote_field, "through", None):
836                         related_fields[field_name] = field
837             # Generate option removal first
838             unique_together = model_state.options.pop("unique_together", None)
839             # RemovedInDjango51Warning.
840             index_together = model_state.options.pop("index_together", None)
841             if unique_together:
842                 self.add_operation(
843                     app_label,
844                     operations.AlterUniqueTogether(
845                         name=model_name,
846                         unique_together=None,
847                     ),
848                 )
849             # RemovedInDjango51Warning.
850             if index_together:
851                 self.add_operation(
852                     app_label,
853                     operations.AlterIndexTogether(
854                         name=model_name,
855                         index_together=None,
856                     ),
857                 )
858             # Then remove each related field
859             for name in sorted(related_fields):
860                 self.add_operation(
861                     app_label,
862                     operations.RemoveField(
863                         model_name=model_name,
864                         name=name,
865                     ),
866                 )
867             # Finally, remove the model.
868             # This depends on both the removal/alteration of all incoming fields
869             # and the removal of all its own related fields, and if it's
870             # a through model the field that references it.
871             dependencies = []
872             relations = self.from_state.relations
873             for (
874                 related_object_app_label,
875                 object_name,
876             ), relation_related_fields in relations[app_label, model_name].items():
877                 for field_name, field in relation_related_fields.items():
878                     dependencies.append(
879                         (related_object_app_label, object_name, field_name, False),
880                     )
881                     if not field.many_to_many:
882                         dependencies.append(
883                             (
884                                 related_object_app_label,
885                                 object_name,
886                                 field_name,
887                                 "alter",
888                             ),
889                         )
890 
891             for name in sorted(related_fields):
892                 dependencies.append((app_label, model_name, name, False))
893             # We're referenced in another field's through=
894             through_user = self.through_users.get((app_label, model_state.name_lower))
895             if through_user:
896                 dependencies.append(
897                     (through_user[0], through_user[1], through_user[2], False)
898                 )
899             # Finally, make the operation, deduping any dependencies
900             self.add_operation(
901                 app_label,
902                 operations.DeleteModel(
903                     name=model_state.name,
904                 ),
905                 dependencies=list(set(dependencies)),
906             )
907 
908     def generate_deleted_proxies(self):
909         """Make DeleteModel options for proxy models."""
910         deleted = self.old_proxy_keys - self.new_proxy_keys
911         for app_label, model_name in sorted(deleted):
912             model_state = self.from_state.models[app_label, model_name]
913             assert model_state.options.get("proxy")
914             self.add_operation(
915                 app_label,
916                 operations.DeleteModel(
917                     name=model_state.name,
918                 ),
919             )
920 
921     def create_renamed_fields(self):
922         """Work out renamed fields."""
923         self.renamed_operations = []
924         old_field_keys = self.old_field_keys.copy()
925         for app_label, model_name, field_name in sorted(
926             self.new_field_keys - old_field_keys
927         ):
928             old_model_name = self.renamed_models.get(
929                 (app_label, model_name), model_name
930             )
931             old_model_state = self.from_state.models[app_label, old_model_name]
932             new_model_state = self.to_state.models[app_label, model_name]
933             field = new_model_state.get_field(field_name)
934             # Scan to see if this is actually a rename!
935             field_dec = self.deep_deconstruct(field)
936             for rem_app_label, rem_model_name, rem_field_name in sorted(
937                 old_field_keys - self.new_field_keys
938             ):
939                 if rem_app_label == app_label and rem_model_name == model_name:
940                     old_field = old_model_state.get_field(rem_field_name)
941                     old_field_dec = self.deep_deconstruct(old_field)
942                     if (
943                         field.remote_field
944                         and field.remote_field.model
945                         and "to" in old_field_dec[2]
946                     ):
947                         old_rel_to = old_field_dec[2]["to"]
948                         if old_rel_to in self.renamed_models_rel:
949                             old_field_dec[2]["to"] = self.renamed_models_rel[old_rel_to]
950                     old_field.set_attributes_from_name(rem_field_name)
951                     old_db_column = old_field.get_attname_column()[1]
952                     if old_field_dec == field_dec or (
953                         # Was the field renamed and db_column equal to the
954                         # old field's column added?
955                         old_field_dec[0:2] == field_dec[0:2]
956                         and dict(old_field_dec[2], db_column=old_db_column)
957                         == field_dec[2]
958                     ):
959                         if self.questioner.ask_rename(
960                             model_name, rem_field_name, field_name, field
961                         ):
962                             self.renamed_operations.append(
963                                 (
964                                     rem_app_label,
965                                     rem_model_name,
966                                     old_field.db_column,
967                                     rem_field_name,
968                                     app_label,
969                                     model_name,
970                                     field,
971                                     field_name,
972                                 )
973                             )
974                             old_field_keys.remove(
975                                 (rem_app_label, rem_model_name, rem_field_name)
976                             )
977                             old_field_keys.add((app_label, model_name, field_name))
978                             self.renamed_fields[
979                                 app_label, model_name, field_name
980                             ] = rem_field_name
981                             break
982 
983     def generate_renamed_fields(self):
984         """Generate RenameField operations."""
985         for (
986             rem_app_label,
987             rem_model_name,
988             rem_db_column,
989             rem_field_name,
990             app_label,
991             model_name,
992             field,
993             field_name,
994         ) in self.renamed_operations:
995             # A db_column mismatch requires a prior noop AlterField for the
996             # subsequent RenameField to be a noop on attempts at preserving the
997             # old name.
998             if rem_db_column != field.db_column:
999                 altered_field = field.clone()
1000                 altered_field.name = rem_field_name
1001                 self.add_operation(
1002                     app_label,
1003                     operations.AlterField(
1004                         model_name=model_name,
1005                         name=rem_field_name,
1006                         field=altered_field,
1007                     ),
1008                 )
1009             self.add_operation(
1010                 app_label,
1011                 operations.RenameField(
1012                     model_name=model_name,
1013                     old_name=rem_field_name,
1014                     new_name=field_name,
1015                 ),
1016             )
1017             self.old_field_keys.remove((rem_app_label, rem_model_name, rem_field_name))
1018             self.old_field_keys.add((app_label, model_name, field_name))
1019 
1020     def generate_added_fields(self):
1021         """Make AddField operations."""
1022         for app_label, model_name, field_name in sorted(
1023             self.new_field_keys - self.old_field_keys
1024         ):
1025             self._generate_added_field(app_label, model_name, field_name)
1026 
1027     def _generate_added_field(self, app_label, model_name, field_name):
1028         field = self.to_state.models[app_label, model_name].get_field(field_name)
1029         # Adding a field always depends at least on its removal.
1030         dependencies = [(app_label, model_name, field_name, False)]
1031         # Fields that are foreignkeys/m2ms depend on stuff.
1032         if field.remote_field and field.remote_field.model:
1033             dependencies.extend(
1034                 self._get_dependencies_for_foreign_key(
1035                     app_label,
1036                     model_name,
1037                     field,
1038                     self.to_state,
1039                 )
1040             )
1041         # You can't just add NOT NULL fields with no default or fields
1042         # which don't allow empty strings as default.
1043         time_fields = (models.DateField, models.DateTimeField, models.TimeField)
1044         preserve_default = (
1045             field.null
1046             or field.has_default()
1047             or field.many_to_many
1048             or (field.blank and field.empty_strings_allowed)
1049             or (isinstance(field, time_fields) and field.auto_now)
1050         )
1051         if not preserve_default:
1052             field = field.clone()
1053             if isinstance(field, time_fields) and field.auto_now_add:
1054                 field.default = self.questioner.ask_auto_now_add_addition(
1055                     field_name, model_name
1056                 )
1057             else:
1058                 field.default = self.questioner.ask_not_null_addition(
1059                     field_name, model_name
1060                 )
1061         if (
1062             field.unique
1063             and field.default is not models.NOT_PROVIDED
1064             and callable(field.default)
1065         ):
1066             self.questioner.ask_unique_callable_default_addition(field_name, model_name)
1067         self.add_operation(
1068             app_label,
1069             operations.AddField(
1070                 model_name=model_name,
1071                 name=field_name,
1072                 field=field,
1073                 preserve_default=preserve_default,
1074             ),
1075             dependencies=dependencies,
1076         )
1077 
1078     def generate_removed_fields(self):
1079         """Make RemoveField operations."""
1080         for app_label, model_name, field_name in sorted(
1081             self.old_field_keys - self.new_field_keys
1082         ):
1083             self._generate_removed_field(app_label, model_name, field_name)
1084 
1085     def _generate_removed_field(self, app_label, model_name, field_name):
1086         self.add_operation(
1087             app_label,
1088             operations.RemoveField(
1089                 model_name=model_name,
1090                 name=field_name,
1091             ),
1092             # We might need to depend on the removal of an
1093             # order_with_respect_to or index/unique_together operation;
1094             # this is safely ignored if there isn't one
1095             dependencies=[
1096                 (app_label, model_name, field_name, "order_wrt_unset"),
1097                 (app_label, model_name, field_name, "foo_together_change"),
1098             ],
1099         )
1100 
1101     def generate_altered_fields(self):
1102         """
1103         Make AlterField operations, or possibly RemovedField/AddField if alter
1104         isn't possible.
1105         """
1106         for app_label, model_name, field_name in sorted(
1107             self.old_field_keys & self.new_field_keys
1108         ):
1109             # Did the field change?
1110             old_model_name = self.renamed_models.get(
1111                 (app_label, model_name), model_name
1112             )
1113             old_field_name = self.renamed_fields.get(
1114                 (app_label, model_name, field_name), field_name
1115             )
1116             old_field = self.from_state.models[app_label, old_model_name].get_field(
1117                 old_field_name
1118             )
1119             new_field = self.to_state.models[app_label, model_name].get_field(
1120                 field_name
1121             )
1122             dependencies = []
1123             # Implement any model renames on relations; these are handled by RenameModel
1124             # so we need to exclude them from the comparison
1125             if hasattr(new_field, "remote_field") and getattr(
1126                 new_field.remote_field, "model", None
1127             ):
1128                 rename_key = resolve_relation(
1129                     new_field.remote_field.model, app_label, model_name
1130                 )
1131                 if rename_key in self.renamed_models:
1132                     new_field.remote_field.model = old_field.remote_field.model
1133                 # Handle ForeignKey which can only have a single to_field.
1134                 remote_field_name = getattr(new_field.remote_field, "field_name", None)
1135                 if remote_field_name:
1136                     to_field_rename_key = rename_key + (remote_field_name,)
1137                     if to_field_rename_key in self.renamed_fields:
1138                         # Repoint both model and field name because to_field
1139                         # inclusion in ForeignKey.deconstruct() is based on
1140                         # both.
1141                         new_field.remote_field.model = old_field.remote_field.model
1142                         new_field.remote_field.field_name = (
1143                             old_field.remote_field.field_name
1144                         )
1145                 # Handle ForeignObjects which can have multiple from_fields/to_fields.
1146                 from_fields = getattr(new_field, "from_fields", None)
1147                 if from_fields:
1148                     from_rename_key = (app_label, model_name)
1149                     new_field.from_fields = tuple(
1150                         [
1151                             self.renamed_fields.get(
1152                                 from_rename_key + (from_field,), from_field
1153                             )
1154                             for from_field in from_fields
1155                         ]
1156                     )
1157                     new_field.to_fields = tuple(
1158                         [
1159                             self.renamed_fields.get(rename_key + (to_field,), to_field)
1160                             for to_field in new_field.to_fields
1161                         ]
1162                     )
1163                 dependencies.extend(
1164                     self._get_dependencies_for_foreign_key(
1165                         app_label,
1166                         model_name,
1167                         new_field,
1168                         self.to_state,
1169                     )
1170                 )
1171             if hasattr(new_field, "remote_field") and getattr(
1172                 new_field.remote_field, "through", None
1173             ):
1174                 rename_key = resolve_relation(
1175                     new_field.remote_field.through, app_label, model_name
1176                 )
1177                 if rename_key in self.renamed_models:
1178                     new_field.remote_field.through = old_field.remote_field.through
1179             old_field_dec = self.deep_deconstruct(old_field)
1180             new_field_dec = self.deep_deconstruct(new_field)
1181             # If the field was confirmed to be renamed it means that only
1182             # db_column was allowed to change which generate_renamed_fields()
1183             # already accounts for by adding an AlterField operation.
1184             if old_field_dec != new_field_dec and old_field_name == field_name:
1185                 both_m2m = old_field.many_to_many and new_field.many_to_many
1186                 neither_m2m = not old_field.many_to_many and not new_field.many_to_many
1187                 if both_m2m or neither_m2m:
1188                     # Either both fields are m2m or neither is
1189                     preserve_default = True
1190                     if (
1191                         old_field.null
1192                         and not new_field.null
1193                         and not new_field.has_default()
1194                         and not new_field.many_to_many
1195                     ):
1196                         field = new_field.clone()
1197                         new_default = self.questioner.ask_not_null_alteration(
1198                             field_name, model_name
1199                         )
1200                         if new_default is not models.NOT_PROVIDED:
1201                             field.default = new_default
1202                             preserve_default = False
1203                     else:
1204                         field = new_field
1205                     self.add_operation(
1206                         app_label,
1207                         operations.AlterField(
1208                             model_name=model_name,
1209                             name=field_name,
1210                             field=field,
1211                             preserve_default=preserve_default,
1212                         ),
1213                         dependencies=dependencies,
1214                     )
1215                 else:
1216                     # We cannot alter between m2m and concrete fields
1217                     self._generate_removed_field(app_label, model_name, field_name)
1218                     self._generate_added_field(app_label, model_name, field_name)
1219 
1220     def create_altered_indexes(self):
1221         option_name = operations.AddIndex.option_name
1222         self.renamed_index_together_values = defaultdict(list)
1223 
1224         for app_label, model_name in sorted(self.kept_model_keys):
1225             old_model_name = self.renamed_models.get(
1226                 (app_label, model_name), model_name
1227             )
1228             old_model_state = self.from_state.models[app_label, old_model_name]
1229             new_model_state = self.to_state.models[app_label, model_name]
1230 
1231             old_indexes = old_model_state.options[option_name]
1232             new_indexes = new_model_state.options[option_name]
1233             added_indexes = [idx for idx in new_indexes if idx not in old_indexes]
1234             removed_indexes = [idx for idx in old_indexes if idx not in new_indexes]
1235             renamed_indexes = []
1236             # Find renamed indexes.
1237             remove_from_added = []
1238             remove_from_removed = []
1239             for new_index in added_indexes:
1240                 new_index_dec = new_index.deconstruct()
1241                 new_index_name = new_index_dec[2].pop("name")
1242                 for old_index in removed_indexes:
1243                     old_index_dec = old_index.deconstruct()
1244                     old_index_name = old_index_dec[2].pop("name")
1245                     # Indexes are the same except for the names.
1246                     if (
1247                         new_index_dec == old_index_dec
1248                         and new_index_name != old_index_name
1249                     ):
1250                         renamed_indexes.append((old_index_name, new_index_name, None))
1251                         remove_from_added.append(new_index)
1252                         remove_from_removed.append(old_index)
1253             # Find index_together changed to indexes.
1254             for (
1255                 old_value,
1256                 new_value,
1257                 index_together_app_label,
1258                 index_together_model_name,
1259                 dependencies,
1260             ) in self._get_altered_foo_together_operations(
1261                 operations.AlterIndexTogether.option_name
1262             ):
1263                 if (
1264                     app_label != index_together_app_label
1265                     or model_name != index_together_model_name
1266                 ):
1267                     continue
1268                 removed_values = old_value.difference(new_value)
1269                 for removed_index_together in removed_values:
1270                     renamed_index_together_indexes = []
1271                     for new_index in added_indexes:
1272                         _, args, kwargs = new_index.deconstruct()
1273                         # Ensure only 'fields' are defined in the Index.
1274                         if (
1275                             not args
1276                             and new_index.fields == list(removed_index_together)
1277                             and set(kwargs) == {"name", "fields"}
1278                         ):
1279                             renamed_index_together_indexes.append(new_index)
1280 
1281                     if len(renamed_index_together_indexes) == 1:
1282                         renamed_index = renamed_index_together_indexes[0]
1283                         remove_from_added.append(renamed_index)
1284                         renamed_indexes.append(
1285                             (None, renamed_index.name, removed_index_together)
1286                         )
1287                         self.renamed_index_together_values[
1288                             index_together_app_label, index_together_model_name
1289                         ].append(removed_index_together)
1290             # Remove renamed indexes from the lists of added and removed
1291             # indexes.
1292             added_indexes = [
1293                 idx for idx in added_indexes if idx not in remove_from_added
1294             ]
1295             removed_indexes = [
1296                 idx for idx in removed_indexes if idx not in remove_from_removed
1297             ]
1298 
1299             self.altered_indexes.update(
1300                 {
1301                     (app_label, model_name): {
1302                         "added_indexes": added_indexes,
1303                         "removed_indexes": removed_indexes,
1304                         "renamed_indexes": renamed_indexes,
1305                     }
1306                 }
1307             )
1308 
1309     def generate_added_indexes(self):
1310         for (app_label, model_name), alt_indexes in self.altered_indexes.items():
1311             for index in alt_indexes["added_indexes"]:
1312                 self.add_operation(
1313                     app_label,
1314                     operations.AddIndex(
1315                         model_name=model_name,
1316                         index=index,
1317                     ),
1318                 )
1319 
1320     def generate_removed_indexes(self):
1321         for (app_label, model_name), alt_indexes in self.altered_indexes.items():
1322             for index in alt_indexes["removed_indexes"]:
1323                 self.add_operation(
1324                     app_label,
1325                     operations.RemoveIndex(
1326                         model_name=model_name,
1327                         name=index.name,
1328                     ),
1329                 )
1330 
1331     def generate_renamed_indexes(self):
1332         for (app_label, model_name), alt_indexes in self.altered_indexes.items():
1333             for old_index_name, new_index_name, old_fields in alt_indexes[
1334                 "renamed_indexes"
1335             ]:
1336                 self.add_operation(
1337                     app_label,
1338                     operations.RenameIndex(
1339                         model_name=model_name,
1340                         new_name=new_index_name,
1341                         old_name=old_index_name,
1342                         old_fields=old_fields,
1343                     ),
1344                 )
1345 
1346     def create_altered_constraints(self):
1347         option_name = operations.AddConstraint.option_name
1348         for app_label, model_name in sorted(self.kept_model_keys):
1349             old_model_name = self.renamed_models.get(
1350                 (app_label, model_name), model_name
1351             )
1352             old_model_state = self.from_state.models[app_label, old_model_name]
1353             new_model_state = self.to_state.models[app_label, model_name]
1354 
1355             old_constraints = old_model_state.options[option_name]
1356             new_constraints = new_model_state.options[option_name]
1357             add_constraints = [c for c in new_constraints if c not in old_constraints]
1358             rem_constraints = [c for c in old_constraints if c not in new_constraints]
1359 
1360             self.altered_constraints.update(
1361                 {
1362                     (app_label, model_name): {
1363                         "added_constraints": add_constraints,
1364                         "removed_constraints": rem_constraints,
1365                     }
1366                 }
1367             )
1368 
1369     def generate_added_constraints(self):
1370         for (
1371             app_label,
1372             model_name,
1373         ), alt_constraints in self.altered_constraints.items():
1374             for constraint in alt_constraints["added_constraints"]:
1375                 self.add_operation(
1376                     app_label,
1377                     operations.AddConstraint(
1378                         model_name=model_name,
1379                         constraint=constraint,
1380                     ),
1381                 )
1382 
1383     def generate_removed_constraints(self):
1384         for (
1385             app_label,
1386             model_name,
1387         ), alt_constraints in self.altered_constraints.items():
1388             for constraint in alt_constraints["removed_constraints"]:
1389                 self.add_operation(
1390                     app_label,
1391                     operations.RemoveConstraint(
1392                         model_name=model_name,
1393                         name=constraint.name,
1394                     ),
1395                 )
1396 
1397     @staticmethod
1398     def _get_dependencies_for_foreign_key(app_label, model_name, field, project_state):
1399         remote_field_model = None
1400         if hasattr(field.remote_field, "model"):
1401             remote_field_model = field.remote_field.model
1402         else:
1403             relations = project_state.relations[app_label, model_name]
1404             for (remote_app_label, remote_model_name), fields in relations.items():
1405                 if any(
1406                     field == related_field.remote_field
1407                     for related_field in fields.values()
1408                 ):
1409                     remote_field_model = f"{remote_app_label}.{remote_model_name}"
1410                     break
1411         # Account for FKs to swappable models
1412         swappable_setting = getattr(field, "swappable_setting", None)
1413         if swappable_setting is not None:
1414             dep_app_label = "__setting__"
1415             dep_object_name = swappable_setting
1416         else:
1417             dep_app_label, dep_object_name = resolve_relation(
1418                 remote_field_model,
1419                 app_label,
1420                 model_name,
1421             )
1422         dependencies = [(dep_app_label, dep_object_name, None, True)]
1423         if getattr(field.remote_field, "through", None):
1424             through_app_label, through_object_name = resolve_relation(
1425                 field.remote_field.through,
1426                 app_label,
1427                 model_name,
1428             )
1429             dependencies.append((through_app_label, through_object_name, None, True))
1430         return dependencies
1431 
1432     def _get_altered_foo_together_operations(self, option_name):
1433         for app_label, model_name in sorted(self.kept_model_keys):
1434             old_model_name = self.renamed_models.get(
1435                 (app_label, model_name), model_name
1436             )
1437             old_model_state = self.from_state.models[app_label, old_model_name]
1438             new_model_state = self.to_state.models[app_label, model_name]
1439 
1440             # We run the old version through the field renames to account for those
1441             old_value = old_model_state.options.get(option_name)
1442             old_value = (
1443                 {
1444                     tuple(
1445                         self.renamed_fields.get((app_label, model_name, n), n)
1446                         for n in unique
1447                     )
1448                     for unique in old_value
1449                 }
1450                 if old_value
1451                 else set()
1452             )
1453 
1454             new_value = new_model_state.options.get(option_name)
1455             new_value = set(new_value) if new_value else set()
1456 
1457             if old_value != new_value:
1458                 dependencies = []
1459                 for foo_togethers in new_value:
1460                     for field_name in foo_togethers:
1461                         field = new_model_state.get_field(field_name)
1462                         if field.remote_field and field.remote_field.model:
1463                             dependencies.extend(
1464                                 self._get_dependencies_for_foreign_key(
1465                                     app_label,
1466                                     model_name,
1467                                     field,
1468                                     self.to_state,
1469                                 )
1470                             )
1471                 yield (
1472                     old_value,
1473                     new_value,
1474                     app_label,
1475                     model_name,
1476                     dependencies,
1477                 )
1478 
1479     def _generate_removed_altered_foo_together(self, operation):
1480         for (
1481             old_value,
1482             new_value,
1483             app_label,
1484             model_name,
1485             dependencies,
1486         ) in self._get_altered_foo_together_operations(operation.option_name):
1487             if operation == operations.AlterIndexTogether:
1488                 old_value = {
1489                     value
1490                     for value in old_value
1491                     if value
1492                     not in self.renamed_index_together_values[app_label, model_name]
1493                 }
1494             removal_value = new_value.intersection(old_value)
1495             if removal_value or old_value:
1496                 self.add_operation(
1497                     app_label,
1498                     operation(
1499                         name=model_name, **{operation.option_name: removal_value}
1500                     ),
1501                     dependencies=dependencies,
1502                 )
1503 
1504     def generate_removed_altered_unique_together(self):
1505         self._generate_removed_altered_foo_together(operations.AlterUniqueTogether)
1506 
1507     # RemovedInDjango51Warning.
1508     def generate_removed_altered_index_together(self):
1509         self._generate_removed_altered_foo_together(operations.AlterIndexTogether)
1510 
1511     def _generate_altered_foo_together(self, operation):
1512         for (
1513             old_value,
1514             new_value,
1515             app_label,
1516             model_name,
1517             dependencies,
1518         ) in self._get_altered_foo_together_operations(operation.option_name):
1519             removal_value = new_value.intersection(old_value)
1520             if new_value != removal_value:
1521                 self.add_operation(
1522                     app_label,
1523                     operation(name=model_name, **{operation.option_name: new_value}),
1524                     dependencies=dependencies,
1525                 )
1526 
1527     def generate_altered_unique_together(self):
1528         self._generate_altered_foo_together(operations.AlterUniqueTogether)
1529 
1530     # RemovedInDjango51Warning.
1531     def generate_altered_index_together(self):
1532         self._generate_altered_foo_together(operations.AlterIndexTogether)
1533 
1534     def generate_altered_db_table(self):
1535         models_to_check = self.kept_model_keys.union(
1536             self.kept_proxy_keys, self.kept_unmanaged_keys
1537         )
1538         for app_label, model_name in sorted(models_to_check):
1539             old_model_name = self.renamed_models.get(
1540                 (app_label, model_name), model_name
1541             )
1542             old_model_state = self.from_state.models[app_label, old_model_name]
1543             new_model_state = self.to_state.models[app_label, model_name]
1544             old_db_table_name = old_model_state.options.get("db_table")
1545             new_db_table_name = new_model_state.options.get("db_table")
1546             if old_db_table_name != new_db_table_name:
1547                 self.add_operation(
1548                     app_label,
1549                     operations.AlterModelTable(
1550                         name=model_name,
1551                         table=new_db_table_name,
1552                     ),
1553                 )
1554 
1555     def generate_altered_options(self):
1556         """
1557         Work out if any non-schema-affecting options have changed and make an
1558         operation to represent them in state changes (in case Python code in
1559         migrations needs them).
1560         """
1561         models_to_check = self.kept_model_keys.union(
1562             self.kept_proxy_keys,
1563             self.kept_unmanaged_keys,
1564             # unmanaged converted to managed
1565             self.old_unmanaged_keys & self.new_model_keys,
1566             # managed converted to unmanaged
1567             self.old_model_keys & self.new_unmanaged_keys,
1568         )
1569 
1570         for app_label, model_name in sorted(models_to_check):
1571             old_model_name = self.renamed_models.get(
1572                 (app_label, model_name), model_name
1573             )
1574             old_model_state = self.from_state.models[app_label, old_model_name]
1575             new_model_state = self.to_state.models[app_label, model_name]
1576             old_options = {
1577                 key: value
1578                 for key, value in old_model_state.options.items()
1579                 if key in AlterModelOptions.ALTER_OPTION_KEYS
1580             }
1581             new_options = {
1582                 key: value
1583                 for key, value in new_model_state.options.items()
1584                 if key in AlterModelOptions.ALTER_OPTION_KEYS
1585             }
1586             if old_options != new_options:
1587                 self.add_operation(
1588                     app_label,
1589                     operations.AlterModelOptions(
1590                         name=model_name,
1591                         options=new_options,
1592                     ),
1593                 )
1594 
1595     def generate_altered_order_with_respect_to(self):
1596         for app_label, model_name in sorted(self.kept_model_keys):
1597             old_model_name = self.renamed_models.get(
1598                 (app_label, model_name), model_name
1599             )
1600             old_model_state = self.from_state.models[app_label, old_model_name]
1601             new_model_state = self.to_state.models[app_label, model_name]
1602             if old_model_state.options.get(
1603                 "order_with_respect_to"
1604             ) != new_model_state.options.get("order_with_respect_to"):
1605                 # Make sure it comes second if we're adding
1606                 # (removal dependency is part of RemoveField)
1607                 dependencies = []
1608                 if new_model_state.options.get("order_with_respect_to"):
1609                     dependencies.append(
1610                         (
1611                             app_label,
1612                             model_name,
1613                             new_model_state.options["order_with_respect_to"],
1614                             True,
1615                         )
1616                     )
1617                 # Actually generate the operation
1618                 self.add_operation(
1619                     app_label,
1620                     operations.AlterOrderWithRespectTo(
1621                         name=model_name,
1622                         order_with_respect_to=new_model_state.options.get(
1623                             "order_with_respect_to"
1624                         ),
1625                     ),
1626                     dependencies=dependencies,
1627                 )
1628 
1629     def generate_altered_managers(self):
1630         for app_label, model_name in sorted(self.kept_model_keys):
1631             old_model_name = self.renamed_models.get(
1632                 (app_label, model_name), model_name
1633             )
1634             old_model_state = self.from_state.models[app_label, old_model_name]
1635             new_model_state = self.to_state.models[app_label, model_name]
1636             if old_model_state.managers != new_model_state.managers:
1637                 self.add_operation(
1638                     app_label,
1639                     operations.AlterModelManagers(
1640                         name=model_name,
1641                         managers=new_model_state.managers,
1642                     ),
1643                 )
1644 
1645     def arrange_for_graph(self, changes, graph, migration_name=None):
1646         """
1647         Take a result from changes() and a MigrationGraph, and fix the names
1648         and dependencies of the changes so they extend the graph from the leaf
1649         nodes for each app.
1650         """
1651         leaves = graph.leaf_nodes()
1652         name_map = {}
1653         for app_label, migrations in list(changes.items()):
1654             if not migrations:
1655                 continue
1656             # Find the app label's current leaf node
1657             app_leaf = None
1658             for leaf in leaves:
1659                 if leaf[0] == app_label:
1660                     app_leaf = leaf
1661                     break
1662             # Do they want an initial migration for this app?
1663             if app_leaf is None and not self.questioner.ask_initial(app_label):
1664                 # They don't.
1665                 for migration in migrations:
1666                     name_map[(app_label, migration.name)] = (app_label, "__first__")
1667                 del changes[app_label]
1668                 continue
1669             # Work out the next number in the sequence
1670             if app_leaf is None:
1671                 next_number = 1
1672             else:
1673                 next_number = (self.parse_number(app_leaf[1]) or 0) + 1
1674             # Name each migration
1675             for i, migration in enumerate(migrations):
1676                 if i == 0 and app_leaf:
1677                     migration.dependencies.append(app_leaf)
1678                 new_name_parts = ["%04i" % next_number]
1679                 if migration_name:
1680                     new_name_parts.append(migration_name)
1681                 elif i == 0 and not app_leaf:
1682                     new_name_parts.append("initial")
1683                 else:
1684                     new_name_parts.append(migration.suggest_name()[:100])
1685                 new_name = "_".join(new_name_parts)
1686                 name_map[(app_label, migration.name)] = (app_label, new_name)
1687                 next_number += 1
1688                 migration.name = new_name
1689         # Now fix dependencies
1690         for migrations in changes.values():
1691             for migration in migrations:
1692                 migration.dependencies = [
1693                     name_map.get(d, d) for d in migration.dependencies
1694                 ]
1695         return changes
1696 
1697     def _trim_to_apps(self, changes, app_labels):
1698         """
1699         Take changes from arrange_for_graph() and set of app labels, and return
1700         a modified set of changes which trims out as many migrations that are
1701         not in app_labels as possible. Note that some other migrations may
1702         still be present as they may be required dependencies.
1703         """
1704         # Gather other app dependencies in a first pass
1705         app_dependencies = {}
1706         for app_label, migrations in changes.items():
1707             for migration in migrations:
1708                 for dep_app_label, name in migration.dependencies:
1709                     app_dependencies.setdefault(app_label, set()).add(dep_app_label)
1710         required_apps = set(app_labels)
1711         # Keep resolving till there's no change
1712         old_required_apps = None
1713         while old_required_apps != required_apps:
1714             old_required_apps = set(required_apps)
1715             required_apps.update(
1716                 *[app_dependencies.get(app_label, ()) for app_label in required_apps]
1717             )
1718         # Remove all migrations that aren't needed
1719         for app_label in list(changes):
1720             if app_label not in required_apps:
1721                 del changes[app_label]
1722         return changes
1723 
1724     @classmethod
1725     def parse_number(cls, name):
1726         """
1727         Given a migration name, try to extract a number from the beginning of
1728         it. For a squashed migration such as '0001_squashed_0004', return the
1729         second number. If no number is found, return None.
1730         """
1731         if squashed_match := re.search(r".*_squashed_(\d+)", name):
1732             return int(squashed_match[1])
1733         match = re.match(r"^\d+", name)
1734         if match:
1735             return int(match[0])
1736         return None

</code><intended_behavior>Enhance detection logic for `ManyToManyField` when its target changes, especially to 'self'. Ensure that the autodetector generates accurate migration operations that reflect complex changes in field relationships, such as changes in target models or the introduction of self-referencing relations.</intended_behavior>, <file>django/db/migrations/operations/fields.py</file>
<class>None</class>
<method>None</method>
<code>
1 from django.db.migrations.utils import field_references
2 from django.db.models import NOT_PROVIDED
3 from django.utils.functional import cached_property
4 
5 from .base import Operation
6 
7 
8 class FieldOperation(Operation):
9     def __init__(self, model_name, name, field=None):
10         self.model_name = model_name
11         self.name = name
12         self.field = field
13 
14     @cached_property
15     def model_name_lower(self):
16         return self.model_name.lower()
17 
18     @cached_property
19     def name_lower(self):
20         return self.name.lower()
21 
22     def is_same_model_operation(self, operation):
23         return self.model_name_lower == operation.model_name_lower
24 
25     def is_same_field_operation(self, operation):
26         return (
27             self.is_same_model_operation(operation)
28             and self.name_lower == operation.name_lower
29         )
30 
31     def references_model(self, name, app_label):
32         name_lower = name.lower()
33         if name_lower == self.model_name_lower:
34             return True
35         if self.field:
36             return bool(
37                 field_references(
38                     (app_label, self.model_name_lower),
39                     self.field,
40                     (app_label, name_lower),
41                 )
42             )
43         return False
44 
45     def references_field(self, model_name, name, app_label):
46         model_name_lower = model_name.lower()
47         # Check if this operation locally references the field.
48         if model_name_lower == self.model_name_lower:
49             if name == self.name:
50                 return True
51             elif (
52                 self.field
53                 and hasattr(self.field, "from_fields")
54                 and name in self.field.from_fields
55             ):
56                 return True
57         # Check if this operation remotely references the field.
58         if self.field is None:
59             return False
60         return bool(
61             field_references(
62                 (app_label, self.model_name_lower),
63                 self.field,
64                 (app_label, model_name_lower),
65                 name,
66             )
67         )
68 
69     def reduce(self, operation, app_label):
70         return super().reduce(operation, app_label) or not operation.references_field(
71             self.model_name, self.name, app_label
72         )
73 
74 
75 class AddField(FieldOperation):
76     """Add a field to a model."""
77 
78     def __init__(self, model_name, name, field, preserve_default=True):
79         self.preserve_default = preserve_default
80         super().__init__(model_name, name, field)
81 
82     def deconstruct(self):
83         kwargs = {
84             "model_name": self.model_name,
85             "name": self.name,
86             "field": self.field,
87         }
88         if self.preserve_default is not True:
89             kwargs["preserve_default"] = self.preserve_default
90         return (self.__class__.__name__, [], kwargs)
91 
92     def state_forwards(self, app_label, state):
93         state.add_field(
94             app_label,
95             self.model_name_lower,
96             self.name,
97             self.field,
98             self.preserve_default,
99         )
100 
101     def database_forwards(self, app_label, schema_editor, from_state, to_state):
102         to_model = to_state.apps.get_model(app_label, self.model_name)
103         if self.allow_migrate_model(schema_editor.connection.alias, to_model):
104             from_model = from_state.apps.get_model(app_label, self.model_name)
105             field = to_model._meta.get_field(self.name)
106             if not self.preserve_default:
107                 field.default = self.field.default
108             schema_editor.add_field(
109                 from_model,
110                 field,
111             )
112             if not self.preserve_default:
113                 field.default = NOT_PROVIDED
114 
115     def database_backwards(self, app_label, schema_editor, from_state, to_state):
116         from_model = from_state.apps.get_model(app_label, self.model_name)
117         if self.allow_migrate_model(schema_editor.connection.alias, from_model):
118             schema_editor.remove_field(
119                 from_model, from_model._meta.get_field(self.name)
120             )
121 
122     def describe(self):
123         return "Add field %s to %s" % (self.name, self.model_name)
124 
125     @property
126     def migration_name_fragment(self):
127         return "%s_%s" % (self.model_name_lower, self.name_lower)
128 
129     def reduce(self, operation, app_label):
130         if isinstance(operation, FieldOperation) and self.is_same_field_operation(
131             operation
132         ):
133             if isinstance(operation, AlterField):
134                 return [
135                     AddField(
136                         model_name=self.model_name,
137                         name=operation.name,
138                         field=operation.field,
139                     ),
140                 ]
141             elif isinstance(operation, RemoveField):
142                 return []
143             elif isinstance(operation, RenameField):
144                 return [
145                     AddField(
146                         model_name=self.model_name,
147                         name=operation.new_name,
148                         field=self.field,
149                     ),
150                 ]
151         return super().reduce(operation, app_label)
152 
153 
154 class RemoveField(FieldOperation):
155     """Remove a field from a model."""
156 
157     def deconstruct(self):
158         kwargs = {
159             "model_name": self.model_name,
160             "name": self.name,
161         }
162         return (self.__class__.__name__, [], kwargs)
163 
164     def state_forwards(self, app_label, state):
165         state.remove_field(app_label, self.model_name_lower, self.name)
166 
167     def database_forwards(self, app_label, schema_editor, from_state, to_state):
168         from_model = from_state.apps.get_model(app_label, self.model_name)
169         if self.allow_migrate_model(schema_editor.connection.alias, from_model):
170             schema_editor.remove_field(
171                 from_model, from_model._meta.get_field(self.name)
172             )
173 
174     def database_backwards(self, app_label, schema_editor, from_state, to_state):
175         to_model = to_state.apps.get_model(app_label, self.model_name)
176         if self.allow_migrate_model(schema_editor.connection.alias, to_model):
177             from_model = from_state.apps.get_model(app_label, self.model_name)
178             schema_editor.add_field(from_model, to_model._meta.get_field(self.name))
179 
180     def describe(self):
181         return "Remove field %s from %s" % (self.name, self.model_name)
182 
183     @property
184     def migration_name_fragment(self):
185         return "remove_%s_%s" % (self.model_name_lower, self.name_lower)
186 
187     def reduce(self, operation, app_label):
188         from .models import DeleteModel
189 
190         if (
191             isinstance(operation, DeleteModel)
192             and operation.name_lower == self.model_name_lower
193         ):
194             return [operation]
195         return super().reduce(operation, app_label)
196 
197 
198 class AlterField(FieldOperation):
199     """
200     Alter a field's database column (e.g. null, max_length) to the provided
201     new field.
202     """
203 
204     def __init__(self, model_name, name, field, preserve_default=True):
205         self.preserve_default = preserve_default
206         super().__init__(model_name, name, field)
207 
208     def deconstruct(self):
209         kwargs = {
210             "model_name": self.model_name,
211             "name": self.name,
212             "field": self.field,
213         }
214         if self.preserve_default is not True:
215             kwargs["preserve_default"] = self.preserve_default
216         return (self.__class__.__name__, [], kwargs)
217 
218     def state_forwards(self, app_label, state):
219         state.alter_field(
220             app_label,
221             self.model_name_lower,
222             self.name,
223             self.field,
224             self.preserve_default,
225         )
226 
227     def database_forwards(self, app_label, schema_editor, from_state, to_state):
228         to_model = to_state.apps.get_model(app_label, self.model_name)
229         if self.allow_migrate_model(schema_editor.connection.alias, to_model):
230             from_model = from_state.apps.get_model(app_label, self.model_name)
231             from_field = from_model._meta.get_field(self.name)
232             to_field = to_model._meta.get_field(self.name)
233             if not self.preserve_default:
234                 to_field.default = self.field.default
235             schema_editor.alter_field(from_model, from_field, to_field)
236             if not self.preserve_default:
237                 to_field.default = NOT_PROVIDED
238 
239     def database_backwards(self, app_label, schema_editor, from_state, to_state):
240         self.database_forwards(app_label, schema_editor, from_state, to_state)
241 
242     def describe(self):
243         return "Alter field %s on %s" % (self.name, self.model_name)
244 
245     @property
246     def migration_name_fragment(self):
247         return "alter_%s_%s" % (self.model_name_lower, self.name_lower)
248 
249     def reduce(self, operation, app_label):
250         if isinstance(operation, RemoveField) and self.is_same_field_operation(
251             operation
252         ):
253             return [operation]
254         elif (
255             isinstance(operation, RenameField)
256             and self.is_same_field_operation(operation)
257             and self.field.db_column is None
258         ):
259             return [
260                 operation,
261                 AlterField(
262                     model_name=self.model_name,
263                     name=operation.new_name,
264                     field=self.field,
265                 ),
266             ]
267         return super().reduce(operation, app_label)
268 
269 
270 class RenameField(FieldOperation):
271     """Rename a field on the model. Might affect db_column too."""
272 
273     def __init__(self, model_name, old_name, new_name):
274         self.old_name = old_name
275         self.new_name = new_name
276         super().__init__(model_name, old_name)
277 
278     @cached_property
279     def old_name_lower(self):
280         return self.old_name.lower()
281 
282     @cached_property
283     def new_name_lower(self):
284         return self.new_name.lower()
285 
286     def deconstruct(self):
287         kwargs = {
288             "model_name": self.model_name,
289             "old_name": self.old_name,
290             "new_name": self.new_name,
291         }
292         return (self.__class__.__name__, [], kwargs)
293 
294     def state_forwards(self, app_label, state):
295         state.rename_field(
296             app_label, self.model_name_lower, self.old_name, self.new_name
297         )
298 
299     def database_forwards(self, app_label, schema_editor, from_state, to_state):
300         to_model = to_state.apps.get_model(app_label, self.model_name)
301         if self.allow_migrate_model(schema_editor.connection.alias, to_model):
302             from_model = from_state.apps.get_model(app_label, self.model_name)
303             schema_editor.alter_field(
304                 from_model,
305                 from_model._meta.get_field(self.old_name),
306                 to_model._meta.get_field(self.new_name),
307             )
308 
309     def database_backwards(self, app_label, schema_editor, from_state, to_state):
310         to_model = to_state.apps.get_model(app_label, self.model_name)
311         if self.allow_migrate_model(schema_editor.connection.alias, to_model):
312             from_model = from_state.apps.get_model(app_label, self.model_name)
313             schema_editor.alter_field(
314                 from_model,
315                 from_model._meta.get_field(self.new_name),
316                 to_model._meta.get_field(self.old_name),
317             )
318 
319     def describe(self):
320         return "Rename field %s on %s to %s" % (
321             self.old_name,
322             self.model_name,
323             self.new_name,
324         )
325 
326     @property
327     def migration_name_fragment(self):
328         return "rename_%s_%s_%s" % (
329             self.old_name_lower,
330             self.model_name_lower,
331             self.new_name_lower,
332         )
333 
334     def references_field(self, model_name, name, app_label):
335         return self.references_model(model_name, app_label) and (
336             name.lower() == self.old_name_lower or name.lower() == self.new_name_lower
337         )
338 
339     def reduce(self, operation, app_label):
340         if (
341             isinstance(operation, RenameField)
342             and self.is_same_model_operation(operation)
343             and self.new_name_lower == operation.old_name_lower
344         ):
345             return [
346                 RenameField(
347                     self.model_name,
348                     self.old_name,
349                     operation.new_name,
350                 ),
351             ]
352         # Skip `FieldOperation.reduce` as we want to run `references_field`
353         # against self.old_name and self.new_name.
354         return super(FieldOperation, self).reduce(operation, app_label) or not (
355             operation.references_field(self.model_name, self.old_name, app_label)
356             or operation.references_field(self.model_name, self.new_name, app_label)
357         )

</code><intended_behavior>Incorporate logic to handle the special case where a `ManyToManyField` is altered to target 'self', ensuring the correct intermediary table schema is generated and existing references are updated or maintained properly. Ensure that both `AddField` and `AlterField` operations accurately apply schema changes for self-referencing many-to-many relationships.</intended_behavior>, <file>django/db/models/fields/related.py</file>
<class>None</class>
<method>None</method>
<code>
1 import functools
2 import inspect
3 from functools import partial
4 
5 from django import forms
6 from django.apps import apps
7 from django.conf import SettingsReference, settings
8 from django.core import checks, exceptions
9 from django.db import connection, router
10 from django.db.backends import utils
11 from django.db.models import Q
12 from django.db.models.constants import LOOKUP_SEP
13 from django.db.models.deletion import CASCADE, SET_DEFAULT, SET_NULL
14 from django.db.models.query_utils import PathInfo
15 from django.db.models.utils import make_model_tuple
16 from django.utils.functional import cached_property
17 from django.utils.translation import gettext_lazy as _
18 
19 from . import Field
20 from .mixins import FieldCacheMixin
21 from .related_descriptors import (
22     ForeignKeyDeferredAttribute,
23     ForwardManyToOneDescriptor,
24     ForwardOneToOneDescriptor,
25     ManyToManyDescriptor,
26     ReverseManyToOneDescriptor,
27     ReverseOneToOneDescriptor,
28 )
29 from .related_lookups import (
30     RelatedExact,
31     RelatedGreaterThan,
32     RelatedGreaterThanOrEqual,
33     RelatedIn,
34     RelatedIsNull,
35     RelatedLessThan,
36     RelatedLessThanOrEqual,
37 )
38 from .reverse_related import ForeignObjectRel, ManyToManyRel, ManyToOneRel, OneToOneRel
39 
40 RECURSIVE_RELATIONSHIP_CONSTANT = "self"
41 
42 
43 def resolve_relation(scope_model, relation):
44     """
45     Transform relation into a model or fully-qualified model string of the form
46     "app_label.ModelName", relative to scope_model.
47 
48     The relation argument can be:
49       * RECURSIVE_RELATIONSHIP_CONSTANT, i.e. the string "self", in which case
50         the model argument will be returned.
51       * A bare model name without an app_label, in which case scope_model's
52         app_label will be prepended.
53       * An "app_label.ModelName" string.
54       * A model class, which will be returned unchanged.
55     """
56     # Check for recursive relations
57     if relation == RECURSIVE_RELATIONSHIP_CONSTANT:
58         relation = scope_model
59 
60     # Look for an "app.Model" relation
61     if isinstance(relation, str):
62         if "." not in relation:
63             relation = "%s.%s" % (scope_model._meta.app_label, relation)
64 
65     return relation
66 
67 
68 def lazy_related_operation(function, model, *related_models, **kwargs):
69     """
70     Schedule `function` to be called once `model` and all `related_models`
71     have been imported and registered with the app registry. `function` will
72     be called with the newly-loaded model classes as its positional arguments,
73     plus any optional keyword arguments.
74 
75     The `model` argument must be a model class. Each subsequent positional
76     argument is another model, or a reference to another model - see
77     `resolve_relation()` for the various forms these may take. Any relative
78     references will be resolved relative to `model`.
79 
80     This is a convenience wrapper for `Apps.lazy_model_operation` - the app
81     registry model used is the one found in `model._meta.apps`.
82     """
83     models = [model] + [resolve_relation(model, rel) for rel in related_models]
84     model_keys = (make_model_tuple(m) for m in models)
85     apps = model._meta.apps
86     return apps.lazy_model_operation(partial(function, **kwargs), *model_keys)
87 
88 
89 class RelatedField(FieldCacheMixin, Field):
90     """Base class that all relational fields inherit from."""
91 
92     # Field flags
93     one_to_many = False
94     one_to_one = False
95     many_to_many = False
96     many_to_one = False
97 
98     def __init__(
99         self,
100         related_name=None,
101         related_query_name=None,
102         limit_choices_to=None,
103         **kwargs,
104     ):
105         self._related_name = related_name
106         self._related_query_name = related_query_name
107         self._limit_choices_to = limit_choices_to
108         super().__init__(**kwargs)
109 
110     @cached_property
111     def related_model(self):
112         # Can't cache this property until all the models are loaded.
113         apps.check_models_ready()
114         return self.remote_field.model
115 
116     def check(self, **kwargs):
117         return [
118             *super().check(**kwargs),
119             *self._check_related_name_is_valid(),
120             *self._check_related_query_name_is_valid(),
121             *self._check_relation_model_exists(),
122             *self._check_referencing_to_swapped_model(),
123             *self._check_clashes(),
124         ]
125 
126     def _check_related_name_is_valid(self):
127         import keyword
128 
129         related_name = self.remote_field.related_name
130         if related_name is None:
131             return []
132         is_valid_id = (
133             not keyword.iskeyword(related_name) and related_name.isidentifier()
134         )
135         if not (is_valid_id or related_name.endswith("+")):
136             return [
137                 checks.Error(
138                     "The name '%s' is invalid related_name for field %s.%s"
139                     % (
140                         self.remote_field.related_name,
141                         self.model._meta.object_name,
142                         self.name,
143                     ),
144                     hint=(
145                         "Related name must be a valid Python identifier or end with a "
146                         "'+'"
147                     ),
148                     obj=self,
149                     id="fields.E306",
150                 )
151             ]
152         return []
153 
154     def _check_related_query_name_is_valid(self):
155         if self.remote_field.is_hidden():
156             return []
157         rel_query_name = self.related_query_name()
158         errors = []
159         if rel_query_name.endswith("_"):
160             errors.append(
161                 checks.Error(
162                     "Reverse query name '%s' must not end with an underscore."
163                     % rel_query_name,
164                     hint=(
165                         "Add or change a related_name or related_query_name "
166                         "argument for this field."
167                     ),
168                     obj=self,
169                     id="fields.E308",
170                 )
171             )
172         if LOOKUP_SEP in rel_query_name:
173             errors.append(
174                 checks.Error(
175                     "Reverse query name '%s' must not contain '%s'."
176                     % (rel_query_name, LOOKUP_SEP),
177                     hint=(
178                         "Add or change a related_name or related_query_name "
179                         "argument for this field."
180                     ),
181                     obj=self,
182                     id="fields.E309",
183                 )
184             )
185         return errors
186 
187     def _check_relation_model_exists(self):
188         rel_is_missing = self.remote_field.model not in self.opts.apps.get_models()
189         rel_is_string = isinstance(self.remote_field.model, str)
190         model_name = (
191             self.remote_field.model
192             if rel_is_string
193             else self.remote_field.model._meta.object_name
194         )
195         if rel_is_missing and (
196             rel_is_string or not self.remote_field.model._meta.swapped
197         ):
198             return [
199                 checks.Error(
200                     "Field defines a relation with model '%s', which is either "
201                     "not installed, or is abstract." % model_name,
202                     obj=self,
203                     id="fields.E300",
204                 )
205             ]
206         return []
207 
208     def _check_referencing_to_swapped_model(self):
209         if (
210             self.remote_field.model not in self.opts.apps.get_models()
211             and not isinstance(self.remote_field.model, str)
212             and self.remote_field.model._meta.swapped
213         ):
214             return [
215                 checks.Error(
216                     "Field defines a relation with the model '%s', which has "
217                     "been swapped out." % self.remote_field.model._meta.label,
218                     hint="Update the relation to point at 'settings.%s'."
219                     % self.remote_field.model._meta.swappable,
220                     obj=self,
221                     id="fields.E301",
222                 )
223             ]
224         return []
225 
226     def _check_clashes(self):
227         """Check accessor and reverse query name clashes."""
228         from django.db.models.base import ModelBase
229 
230         errors = []
231         opts = self.model._meta
232 
233         # f.remote_field.model may be a string instead of a model. Skip if
234         # model name is not resolved.
235         if not isinstance(self.remote_field.model, ModelBase):
236             return []
237 
238         # Consider that we are checking field `Model.foreign` and the models
239         # are:
240         #
241         #     class Target(models.Model):
242         #         model = models.IntegerField()
243         #         model_set = models.IntegerField()
244         #
245         #     class Model(models.Model):
246         #         foreign = models.ForeignKey(Target)
247         #         m2m = models.ManyToManyField(Target)
248 
249         # rel_opts.object_name == "Target"
250         rel_opts = self.remote_field.model._meta
251         # If the field doesn't install a backward relation on the target model
252         # (so `is_hidden` returns True), then there are no clashes to check
253         # and we can skip these fields.
254         rel_is_hidden = self.remote_field.is_hidden()
255         rel_name = self.remote_field.get_accessor_name()  # i. e. "model_set"
256         rel_query_name = self.related_query_name()  # i. e. "model"
257         # i.e. "app_label.Model.field".
258         field_name = "%s.%s" % (opts.label, self.name)
259 
260         # Check clashes between accessor or reverse query name of `field`
261         # and any other field name -- i.e. accessor for Model.foreign is
262         # model_set and it clashes with Target.model_set.
263         potential_clashes = rel_opts.fields + rel_opts.many_to_many
264         for clash_field in potential_clashes:
265             # i.e. "app_label.Target.model_set".
266             clash_name = "%s.%s" % (rel_opts.label, clash_field.name)
267             if not rel_is_hidden and clash_field.name == rel_name:
268                 errors.append(
269                     checks.Error(
270                         f"Reverse accessor '{rel_opts.object_name}.{rel_name}' "
271                         f"for '{field_name}' clashes with field name "
272                         f"'{clash_name}'.",
273                         hint=(
274                             "Rename field '%s', or add/change a related_name "
275                             "argument to the definition for field '%s'."
276                         )
277                         % (clash_name, field_name),
278                         obj=self,
279                         id="fields.E302",
280                     )
281                 )
282 
283             if clash_field.name == rel_query_name:
284                 errors.append(
285                     checks.Error(
286                         "Reverse query name for '%s' clashes with field name '%s'."
287                         % (field_name, clash_name),
288                         hint=(
289                             "Rename field '%s', or add/change a related_name "
290                             "argument to the definition for field '%s'."
291                         )
292                         % (clash_name, field_name),
293                         obj=self,
294                         id="fields.E303",
295                     )
296                 )
297 
298         # Check clashes between accessors/reverse query names of `field` and
299         # any other field accessor -- i. e. Model.foreign accessor clashes with
300         # Model.m2m accessor.
301         potential_clashes = (r for r in rel_opts.related_objects if r.field is not self)
302         for clash_field in potential_clashes:
303             # i.e. "app_label.Model.m2m".
304             clash_name = "%s.%s" % (
305                 clash_field.related_model._meta.label,
306                 clash_field.field.name,
307             )
308             if not rel_is_hidden and clash_field.get_accessor_name() == rel_name:
309                 errors.append(
310                     checks.Error(
311                         f"Reverse accessor '{rel_opts.object_name}.{rel_name}' "
312                         f"for '{field_name}' clashes with reverse accessor for "
313                         f"'{clash_name}'.",
314                         hint=(
315                             "Add or change a related_name argument "
316                             "to the definition for '%s' or '%s'."
317                         )
318                         % (field_name, clash_name),
319                         obj=self,
320                         id="fields.E304",
321                     )
322                 )
323 
324             if clash_field.get_accessor_name() == rel_query_name:
325                 errors.append(
326                     checks.Error(
327                         "Reverse query name for '%s' clashes with reverse query name "
328                         "for '%s'." % (field_name, clash_name),
329                         hint=(
330                             "Add or change a related_name argument "
331                             "to the definition for '%s' or '%s'."
332                         )
333                         % (field_name, clash_name),
334                         obj=self,
335                         id="fields.E305",
336                     )
337                 )
338 
339         return errors
340 
341     def db_type(self, connection):
342         # By default related field will not have a column as it relates to
343         # columns from another table.
344         return None
345 
346     def contribute_to_class(self, cls, name, private_only=False, **kwargs):
347 
348         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)
349 
350         self.opts = cls._meta
351 
352         if not cls._meta.abstract:
353             if self.remote_field.related_name:
354                 related_name = self.remote_field.related_name
355             else:
356                 related_name = self.opts.default_related_name
357             if related_name:
358                 related_name %= {
359                     "class": cls.__name__.lower(),
360                     "model_name": cls._meta.model_name.lower(),
361                     "app_label": cls._meta.app_label.lower(),
362                 }
363                 self.remote_field.related_name = related_name
364 
365             if self.remote_field.related_query_name:
366                 related_query_name = self.remote_field.related_query_name % {
367                     "class": cls.__name__.lower(),
368                     "app_label": cls._meta.app_label.lower(),
369                 }
370                 self.remote_field.related_query_name = related_query_name
371 
372             def resolve_related_class(model, related, field):
373                 field.remote_field.model = related
374                 field.do_related_class(related, model)
375 
376             lazy_related_operation(
377                 resolve_related_class, cls, self.remote_field.model, field=self
378             )
379 
380     def deconstruct(self):
381         name, path, args, kwargs = super().deconstruct()
382         if self._limit_choices_to:
383             kwargs["limit_choices_to"] = self._limit_choices_to
384         if self._related_name is not None:
385             kwargs["related_name"] = self._related_name
386         if self._related_query_name is not None:
387             kwargs["related_query_name"] = self._related_query_name
388         return name, path, args, kwargs
389 
390     def get_forward_related_filter(self, obj):
391         """
392         Return the keyword arguments that when supplied to
393         self.model.object.filter(), would select all instances related through
394         this field to the remote obj. This is used to build the querysets
395         returned by related descriptors. obj is an instance of
396         self.related_field.model.
397         """
398         return {
399             "%s__%s" % (self.name, rh_field.name): getattr(obj, rh_field.attname)
400             for _, rh_field in self.related_fields
401         }
402 
403     def get_reverse_related_filter(self, obj):
404         """
405         Complement to get_forward_related_filter(). Return the keyword
406         arguments that when passed to self.related_field.model.object.filter()
407         select all instances of self.related_field.model related through
408         this field to obj. obj is an instance of self.model.
409         """
410         base_q = Q.create(
411             [
412                 (rh_field.attname, getattr(obj, lh_field.attname))
413                 for lh_field, rh_field in self.related_fields
414             ]
415         )
416         descriptor_filter = self.get_extra_descriptor_filter(obj)
417         if isinstance(descriptor_filter, dict):
418             return base_q & Q(**descriptor_filter)
419         elif descriptor_filter:
420             return base_q & descriptor_filter
421         return base_q
422 
423     @property
424     def swappable_setting(self):
425         """
426         Get the setting that this is powered from for swapping, or None
427         if it's not swapped in / marked with swappable=False.
428         """
429         if self.swappable:
430             # Work out string form of "to"
431             if isinstance(self.remote_field.model, str):
432                 to_string = self.remote_field.model
433             else:
434                 to_string = self.remote_field.model._meta.label
435             return apps.get_swappable_settings_name(to_string)
436         return None
437 
438     def set_attributes_from_rel(self):
439         self.name = self.name or (
440             self.remote_field.model._meta.model_name
441             + "_"
442             + self.remote_field.model._meta.pk.name
443         )
444         if self.verbose_name is None:
445             self.verbose_name = self.remote_field.model._meta.verbose_name
446         self.remote_field.set_field_name()
447 
448     def do_related_class(self, other, cls):
449         self.set_attributes_from_rel()
450         self.contribute_to_related_class(other, self.remote_field)
451 
452     def get_limit_choices_to(self):
453         """
454         Return ``limit_choices_to`` for this model field.
455 
456         If it is a callable, it will be invoked and the result will be
457         returned.
458         """
459         if callable(self.remote_field.limit_choices_to):
460             return self.remote_field.limit_choices_to()
461         return self.remote_field.limit_choices_to
462 
463     def formfield(self, **kwargs):
464         """
465         Pass ``limit_choices_to`` to the field being constructed.
466 
467         Only passes it if there is a type that supports related fields.
468         This is a similar strategy used to pass the ``queryset`` to the field
469         being constructed.
470         """
471         defaults = {}
472         if hasattr(self.remote_field, "get_related_field"):
473             # If this is a callable, do not invoke it here. Just pass
474             # it in the defaults for when the form class will later be
475             # instantiated.
476             limit_choices_to = self.remote_field.limit_choices_to
477             defaults.update(
478                 {
479                     "limit_choices_to": limit_choices_to,
480                 }
481             )
482         defaults.update(kwargs)
483         return super().formfield(**defaults)
484 
485     def related_query_name(self):
486         """
487         Define the name that can be used to identify this related object in a
488         table-spanning query.
489         """
490         return (
491             self.remote_field.related_query_name
492             or self.remote_field.related_name
493             or self.opts.model_name
494         )
495 
496     @property
497     def target_field(self):
498         """
499         When filtering against this relation, return the field on the remote
500         model against which the filtering should happen.
501         """
502         target_fields = self.path_infos[-1].target_fields
503         if len(target_fields) > 1:
504             raise exceptions.FieldError(
505                 "The relation has multiple target fields, but only single target field "
506                 "was asked for"
507             )
508         return target_fields[0]
509 
510     def get_cache_name(self):
511         return self.name
512 
513 
514 class ForeignObject(RelatedField):
515     """
516     Abstraction of the ForeignKey relation to support multi-column relations.
517     """
518 
519     # Field flags
520     many_to_many = False
521     many_to_one = True
522     one_to_many = False
523     one_to_one = False
524 
525     requires_unique_target = True
526     related_accessor_class = ReverseManyToOneDescriptor
527     forward_related_accessor_class = ForwardManyToOneDescriptor
528     rel_class = ForeignObjectRel
529 
530     def __init__(
531         self,
532         to,
533         on_delete,
534         from_fields,
535         to_fields,
536         rel=None,
537         related_name=None,
538         related_query_name=None,
539         limit_choices_to=None,
540         parent_link=False,
541         swappable=True,
542         **kwargs,
543     ):
544 
545         if rel is None:
546             rel = self.rel_class(
547                 self,
548                 to,
549                 related_name=related_name,
550                 related_query_name=related_query_name,
551                 limit_choices_to=limit_choices_to,
552                 parent_link=parent_link,
553                 on_delete=on_delete,
554             )
555 
556         super().__init__(
557             rel=rel,
558             related_name=related_name,
559             related_query_name=related_query_name,
560             limit_choices_to=limit_choices_to,
561             **kwargs,
562         )
563 
564         self.from_fields = from_fields
565         self.to_fields = to_fields
566         self.swappable = swappable
567 
568     def __copy__(self):
569         obj = super().__copy__()
570         # Remove any cached PathInfo values.
571         obj.__dict__.pop("path_infos", None)
572         obj.__dict__.pop("reverse_path_infos", None)
573         return obj
574 
575     def check(self, **kwargs):
576         return [
577             *super().check(**kwargs),
578             *self._check_to_fields_exist(),
579             *self._check_unique_target(),
580         ]
581 
582     def _check_to_fields_exist(self):
583         # Skip nonexistent models.
584         if isinstance(self.remote_field.model, str):
585             return []
586 
587         errors = []
588         for to_field in self.to_fields:
589             if to_field:
590                 try:
591                     self.remote_field.model._meta.get_field(to_field)
592                 except exceptions.FieldDoesNotExist:
593                     errors.append(
594                         checks.Error(
595                             "The to_field '%s' doesn't exist on the related "
596                             "model '%s'."
597                             % (to_field, self.remote_field.model._meta.label),
598                             obj=self,
599                             id="fields.E312",
600                         )
601                     )
602         return errors
603 
604     def _check_unique_target(self):
605         rel_is_string = isinstance(self.remote_field.model, str)
606         if rel_is_string or not self.requires_unique_target:
607             return []
608 
609         try:
610             self.foreign_related_fields
611         except exceptions.FieldDoesNotExist:
612             return []
613 
614         if not self.foreign_related_fields:
615             return []
616 
617         unique_foreign_fields = {
618             frozenset([f.name])
619             for f in self.remote_field.model._meta.get_fields()
620             if getattr(f, "unique", False)
621         }
622         unique_foreign_fields.update(
623             {frozenset(ut) for ut in self.remote_field.model._meta.unique_together}
624         )
625         unique_foreign_fields.update(
626             {
627                 frozenset(uc.fields)
628                 for uc in self.remote_field.model._meta.total_unique_constraints
629             }
630         )
631         foreign_fields = {f.name for f in self.foreign_related_fields}
632         has_unique_constraint = any(u <= foreign_fields for u in unique_foreign_fields)
633 
634         if not has_unique_constraint and len(self.foreign_related_fields) > 1:
635             field_combination = ", ".join(
636                 "'%s'" % rel_field.name for rel_field in self.foreign_related_fields
637             )
638             model_name = self.remote_field.model.__name__
639             return [
640                 checks.Error(
641                     "No subset of the fields %s on model '%s' is unique."
642                     % (field_combination, model_name),
643                     hint=(
644                         "Mark a single field as unique=True or add a set of "
645                         "fields to a unique constraint (via unique_together "
646                         "or a UniqueConstraint (without condition) in the "
647                         "model Meta.constraints)."
648                     ),
649                     obj=self,
650                     id="fields.E310",
651                 )
652             ]
653         elif not has_unique_constraint:
654             field_name = self.foreign_related_fields[0].name
655             model_name = self.remote_field.model.__name__
656             return [
657                 checks.Error(
658                     "'%s.%s' must be unique because it is referenced by "
659                     "a foreign key." % (model_name, field_name),
660                     hint=(
661                         "Add unique=True to this field or add a "
662                         "UniqueConstraint (without condition) in the model "
663                         "Meta.constraints."
664                     ),
665                     obj=self,
666                     id="fields.E311",
667                 )
668             ]
669         else:
670             return []
671 
672     def deconstruct(self):
673         name, path, args, kwargs = super().deconstruct()
674         kwargs["on_delete"] = self.remote_field.on_delete
675         kwargs["from_fields"] = self.from_fields
676         kwargs["to_fields"] = self.to_fields
677 
678         if self.remote_field.parent_link:
679             kwargs["parent_link"] = self.remote_field.parent_link
680         if isinstance(self.remote_field.model, str):
681             if "." in self.remote_field.model:
682                 app_label, model_name = self.remote_field.model.split(".")
683                 kwargs["to"] = "%s.%s" % (app_label, model_name.lower())
684             else:
685                 kwargs["to"] = self.remote_field.model.lower()
686         else:
687             kwargs["to"] = self.remote_field.model._meta.label_lower
688         # If swappable is True, then see if we're actually pointing to the target
689         # of a swap.
690         swappable_setting = self.swappable_setting
691         if swappable_setting is not None:
692             # If it's already a settings reference, error
693             if hasattr(kwargs["to"], "setting_name"):
694                 if kwargs["to"].setting_name != swappable_setting:
695                     raise ValueError(
696                         "Cannot deconstruct a ForeignKey pointing to a model "
697                         "that is swapped in place of more than one model (%s and %s)"
698                         % (kwargs["to"].setting_name, swappable_setting)
699                     )
700             # Set it
701             kwargs["to"] = SettingsReference(
702                 kwargs["to"],
703                 swappable_setting,
704             )
705         return name, path, args, kwargs
706 
707     def resolve_related_fields(self):
708         if not self.from_fields or len(self.from_fields) != len(self.to_fields):
709             raise ValueError(
710                 "Foreign Object from and to fields must be the same non-zero length"
711             )
712         if isinstance(self.remote_field.model, str):
713             raise ValueError(
714                 "Related model %r cannot be resolved" % self.remote_field.model
715             )
716         related_fields = []
717         for index in range(len(self.from_fields)):
718             from_field_name = self.from_fields[index]
719             to_field_name = self.to_fields[index]
720             from_field = (
721                 self
722                 if from_field_name == RECURSIVE_RELATIONSHIP_CONSTANT
723                 else self.opts.get_field(from_field_name)
724             )
725             to_field = (
726                 self.remote_field.model._meta.pk
727                 if to_field_name is None
728                 else self.remote_field.model._meta.get_field(to_field_name)
729             )
730             related_fields.append((from_field, to_field))
731         return related_fields
732 
733     @cached_property
734     def related_fields(self):
735         return self.resolve_related_fields()
736 
737     @cached_property
738     def reverse_related_fields(self):
739         return [(rhs_field, lhs_field) for lhs_field, rhs_field in self.related_fields]
740 
741     @cached_property
742     def local_related_fields(self):
743         return tuple(lhs_field for lhs_field, rhs_field in self.related_fields)
744 
745     @cached_property
746     def foreign_related_fields(self):
747         return tuple(
748             rhs_field for lhs_field, rhs_field in self.related_fields if rhs_field
749         )
750 
751     def get_local_related_value(self, instance):
752         return self.get_instance_value_for_fields(instance, self.local_related_fields)
753 
754     def get_foreign_related_value(self, instance):
755         return self.get_instance_value_for_fields(instance, self.foreign_related_fields)
756 
757     @staticmethod
758     def get_instance_value_for_fields(instance, fields):
759         ret = []
760         opts = instance._meta
761         for field in fields:
762             # Gotcha: in some cases (like fixture loading) a model can have
763             # different values in parent_ptr_id and parent's id. So, use
764             # instance.pk (that is, parent_ptr_id) when asked for instance.id.
765             if field.primary_key:
766                 possible_parent_link = opts.get_ancestor_link(field.model)
767                 if (
768                     not possible_parent_link
769                     or possible_parent_link.primary_key
770                     or possible_parent_link.model._meta.abstract
771                 ):
772                     ret.append(instance.pk)
773                     continue
774             ret.append(getattr(instance, field.attname))
775         return tuple(ret)
776 
777     def get_attname_column(self):
778         attname, column = super().get_attname_column()
779         return attname, None
780 
781     def get_joining_columns(self, reverse_join=False):
782         source = self.reverse_related_fields if reverse_join else self.related_fields
783         return tuple(
784             (lhs_field.column, rhs_field.column) for lhs_field, rhs_field in source
785         )
786 
787     def get_reverse_joining_columns(self):
788         return self.get_joining_columns(reverse_join=True)
789 
790     def get_extra_descriptor_filter(self, instance):
791         """
792         Return an extra filter condition for related object fetching when
793         user does 'instance.fieldname', that is the extra filter is used in
794         the descriptor of the field.
795 
796         The filter should be either a dict usable in .filter(**kwargs) call or
797         a Q-object. The condition will be ANDed together with the relation's
798         joining columns.
799 
800         A parallel method is get_extra_restriction() which is used in
801         JOIN and subquery conditions.
802         """
803         return {}
804 
805     def get_extra_restriction(self, alias, related_alias):
806         """
807         Return a pair condition used for joining and subquery pushdown. The
808         condition is something that responds to as_sql(compiler, connection)
809         method.
810 
811         Note that currently referring both the 'alias' and 'related_alias'
812         will not work in some conditions, like subquery pushdown.
813 
814         A parallel method is get_extra_descriptor_filter() which is used in
815         instance.fieldname related object fetching.
816         """
817         return None
818 
819     def get_path_info(self, filtered_relation=None):
820         """Get path from this field to the related model."""
821         opts = self.remote_field.model._meta
822         from_opts = self.model._meta
823         return [
824             PathInfo(
825                 from_opts=from_opts,
826                 to_opts=opts,
827                 target_fields=self.foreign_related_fields,
828                 join_field=self,
829                 m2m=False,
830                 direct=True,
831                 filtered_relation=filtered_relation,
832             )
833         ]
834 
835     @cached_property
836     def path_infos(self):
837         return self.get_path_info()
838 
839     def get_reverse_path_info(self, filtered_relation=None):
840         """Get path from the related model to this field's model."""
841         opts = self.model._meta
842         from_opts = self.remote_field.model._meta
843         return [
844             PathInfo(
845                 from_opts=from_opts,
846                 to_opts=opts,
847                 target_fields=(opts.pk,),
848                 join_field=self.remote_field,
849                 m2m=not self.unique,
850                 direct=False,
851                 filtered_relation=filtered_relation,
852             )
853         ]
854 
855     @cached_property
856     def reverse_path_infos(self):
857         return self.get_reverse_path_info()
858 
859     @classmethod
860     @functools.lru_cache(maxsize=None)
861     def get_class_lookups(cls):
862         bases = inspect.getmro(cls)
863         bases = bases[: bases.index(ForeignObject) + 1]
864         class_lookups = [parent.__dict__.get("class_lookups", {}) for parent in bases]
865         return cls.merge_dicts(class_lookups)
866 
867     def contribute_to_class(self, cls, name, private_only=False, **kwargs):
868         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)
869         setattr(cls, self.name, self.forward_related_accessor_class(self))
870 
871     def contribute_to_related_class(self, cls, related):
872         # Internal FK's - i.e., those with a related name ending with '+' -
873         # and swapped models don't get a related descriptor.
874         if (
875             not self.remote_field.is_hidden()
876             and not related.related_model._meta.swapped
877         ):
878             setattr(
879                 cls._meta.concrete_model,
880                 related.get_accessor_name(),
881                 self.related_accessor_class(related),
882             )
883             # While 'limit_choices_to' might be a callable, simply pass
884             # it along for later - this is too early because it's still
885             # model load time.
886             if self.remote_field.limit_choices_to:
887                 cls._meta.related_fkey_lookups.append(
888                     self.remote_field.limit_choices_to
889                 )
890 
891 
892 ForeignObject.register_lookup(RelatedIn)
893 ForeignObject.register_lookup(RelatedExact)
894 ForeignObject.register_lookup(RelatedLessThan)
895 ForeignObject.register_lookup(RelatedGreaterThan)
896 ForeignObject.register_lookup(RelatedGreaterThanOrEqual)
897 ForeignObject.register_lookup(RelatedLessThanOrEqual)
898 ForeignObject.register_lookup(RelatedIsNull)
899 
900 
901 class ForeignKey(ForeignObject):
902     """
903     Provide a many-to-one relation by adding a column to the local model
904     to hold the remote value.
905 
906     By default ForeignKey will target the pk of the remote model but this
907     behavior can be changed by using the ``to_field`` argument.
908     """
909 
910     descriptor_class = ForeignKeyDeferredAttribute
911     # Field flags
912     many_to_many = False
913     many_to_one = True
914     one_to_many = False
915     one_to_one = False
916 
917     rel_class = ManyToOneRel
918 
919     empty_strings_allowed = False
920     default_error_messages = {
921         "invalid": _("%(model)s instance with %(field)s %(value)r does not exist.")
922     }
923     description = _("Foreign Key (type determined by related field)")
924 
925     def __init__(
926         self,
927         to,
928         on_delete,
929         related_name=None,
930         related_query_name=None,
931         limit_choices_to=None,
932         parent_link=False,
933         to_field=None,
934         db_constraint=True,
935         **kwargs,
936     ):
937         try:
938             to._meta.model_name
939         except AttributeError:
940             if not isinstance(to, str):
941                 raise TypeError(
942                     "%s(%r) is invalid. First parameter to ForeignKey must be "
943                     "either a model, a model name, or the string %r"
944                     % (
945                         self.__class__.__name__,
946                         to,
947                         RECURSIVE_RELATIONSHIP_CONSTANT,
948                     )
949                 )
950         else:
951             # For backwards compatibility purposes, we need to *try* and set
952             # the to_field during FK construction. It won't be guaranteed to
953             # be correct until contribute_to_class is called. Refs #12190.
954             to_field = to_field or (to._meta.pk and to._meta.pk.name)
955         if not callable(on_delete):
956             raise TypeError("on_delete must be callable.")
957 
958         kwargs["rel"] = self.rel_class(
959             self,
960             to,
961             to_field,
962             related_name=related_name,
963             related_query_name=related_query_name,
964             limit_choices_to=limit_choices_to,
965             parent_link=parent_link,
966             on_delete=on_delete,
967         )
968         kwargs.setdefault("db_index", True)
969 
970         super().__init__(
971             to,
972             on_delete,
973             related_name=related_name,
974             related_query_name=related_query_name,
975             limit_choices_to=limit_choices_to,
976             from_fields=[RECURSIVE_RELATIONSHIP_CONSTANT],
977             to_fields=[to_field],
978             **kwargs,
979         )
980         self.db_constraint = db_constraint
981 
982     def __class_getitem__(cls, *args, **kwargs):
983         return cls
984 
985     def check(self, **kwargs):
986         return [
987             *super().check(**kwargs),
988             *self._check_on_delete(),
989             *self._check_unique(),
990         ]
991 
992     def _check_on_delete(self):
993         on_delete = getattr(self.remote_field, "on_delete", None)
994         if on_delete == SET_NULL and not self.null:
995             return [
996                 checks.Error(
997                     "Field specifies on_delete=SET_NULL, but cannot be null.",
998                     hint=(
999                         "Set null=True argument on the field, or change the on_delete "
1000                         "rule."
1001                     ),
1002                     obj=self,
1003                     id="fields.E320",
1004                 )
1005             ]
1006         elif on_delete == SET_DEFAULT and not self.has_default():
1007             return [
1008                 checks.Error(
1009                     "Field specifies on_delete=SET_DEFAULT, but has no default value.",
1010                     hint="Set a default value, or change the on_delete rule.",
1011                     obj=self,
1012                     id="fields.E321",
1013                 )
1014             ]
1015         else:
1016             return []
1017 
1018     def _check_unique(self, **kwargs):
1019         return (
1020             [
1021                 checks.Warning(
1022                     "Setting unique=True on a ForeignKey has the same effect as using "
1023                     "a OneToOneField.",
1024                     hint=(
1025                         "ForeignKey(unique=True) is usually better served by a "
1026                         "OneToOneField."
1027                     ),
1028                     obj=self,
1029                     id="fields.W342",
1030                 )
1031             ]
1032             if self.unique
1033             else []
1034         )
1035 
1036     def deconstruct(self):
1037         name, path, args, kwargs = super().deconstruct()
1038         del kwargs["to_fields"]
1039         del kwargs["from_fields"]
1040         # Handle the simpler arguments
1041         if self.db_index:
1042             del kwargs["db_index"]
1043         else:
1044             kwargs["db_index"] = False
1045         if self.db_constraint is not True:
1046             kwargs["db_constraint"] = self.db_constraint
1047         # Rel needs more work.
1048         to_meta = getattr(self.remote_field.model, "_meta", None)
1049         if self.remote_field.field_name and (
1050             not to_meta
1051             or (to_meta.pk and self.remote_field.field_name != to_meta.pk.name)
1052         ):
1053             kwargs["to_field"] = self.remote_field.field_name
1054         return name, path, args, kwargs
1055 
1056     def to_python(self, value):
1057         return self.target_field.to_python(value)
1058 
1059     @property
1060     def target_field(self):
1061         return self.foreign_related_fields[0]
1062 
1063     def get_reverse_path_info(self, filtered_relation=None):
1064         """Get path from the related model to this field's model."""
1065         opts = self.model._meta
1066         from_opts = self.remote_field.model._meta
1067         return [
1068             PathInfo(
1069                 from_opts=from_opts,
1070                 to_opts=opts,
1071                 target_fields=(opts.pk,),
1072                 join_field=self.remote_field,
1073                 m2m=not self.unique,
1074                 direct=False,
1075                 filtered_relation=filtered_relation,
1076             )
1077         ]
1078 
1079     def validate(self, value, model_instance):
1080         if self.remote_field.parent_link:
1081             return
1082         super().validate(value, model_instance)
1083         if value is None:
1084             return
1085 
1086         using = router.db_for_read(self.remote_field.model, instance=model_instance)
1087         qs = self.remote_field.model._base_manager.using(using).filter(
1088             **{self.remote_field.field_name: value}
1089         )
1090         qs = qs.complex_filter(self.get_limit_choices_to())
1091         if not qs.exists():
1092             raise exceptions.ValidationError(
1093                 self.error_messages["invalid"],
1094                 code="invalid",
1095                 params={
1096                     "model": self.remote_field.model._meta.verbose_name,
1097                     "pk": value,
1098                     "field": self.remote_field.field_name,
1099                     "value": value,
1100                 },  # 'pk' is included for backwards compatibility
1101             )
1102 
1103     def resolve_related_fields(self):
1104         related_fields = super().resolve_related_fields()
1105         for from_field, to_field in related_fields:
1106             if (
1107                 to_field
1108                 and to_field.model != self.remote_field.model._meta.concrete_model
1109             ):
1110                 raise exceptions.FieldError(
1111                     "'%s.%s' refers to field '%s' which is not local to model "
1112                     "'%s'."
1113                     % (
1114                         self.model._meta.label,
1115                         self.name,
1116                         to_field.name,
1117                         self.remote_field.model._meta.concrete_model._meta.label,
1118                     )
1119                 )
1120         return related_fields
1121 
1122     def get_attname(self):
1123         return "%s_id" % self.name
1124 
1125     def get_attname_column(self):
1126         attname = self.get_attname()
1127         column = self.db_column or attname
1128         return attname, column
1129 
1130     def get_default(self):
1131         """Return the to_field if the default value is an object."""
1132         field_default = super().get_default()
1133         if isinstance(field_default, self.remote_field.model):
1134             return getattr(field_default, self.target_field.attname)
1135         return field_default
1136 
1137     def get_db_prep_save(self, value, connection):
1138         if value is None or (
1139             value == ""
1140             and (
1141                 not self.target_field.empty_strings_allowed
1142                 or connection.features.interprets_empty_strings_as_nulls
1143             )
1144         ):
1145             return None
1146         else:
1147             return self.target_field.get_db_prep_save(value, connection=connection)
1148 
1149     def get_db_prep_value(self, value, connection, prepared=False):
1150         return self.target_field.get_db_prep_value(value, connection, prepared)
1151 
1152     def get_prep_value(self, value):
1153         return self.target_field.get_prep_value(value)
1154 
1155     def contribute_to_related_class(self, cls, related):
1156         super().contribute_to_related_class(cls, related)
1157         if self.remote_field.field_name is None:
1158             self.remote_field.field_name = cls._meta.pk.name
1159 
1160     def formfield(self, *, using=None, **kwargs):
1161         if isinstance(self.remote_field.model, str):
1162             raise ValueError(
1163                 "Cannot create form field for %r yet, because "
1164                 "its related model %r has not been loaded yet"
1165                 % (self.name, self.remote_field.model)
1166             )
1167         return super().formfield(
1168             **{
1169                 "form_class": forms.ModelChoiceField,
1170                 "queryset": self.remote_field.model._default_manager.using(using),
1171                 "to_field_name": self.remote_field.field_name,
1172                 **kwargs,
1173                 "blank": self.blank,
1174             }
1175         )
1176 
1177     def db_check(self, connection):
1178         return None
1179 
1180     def db_type(self, connection):
1181         return self.target_field.rel_db_type(connection=connection)
1182 
1183     def db_parameters(self, connection):
1184         target_db_parameters = self.target_field.db_parameters(connection)
1185         return {
1186             "type": self.db_type(connection),
1187             "check": self.db_check(connection),
1188             "collation": target_db_parameters.get("collation"),
1189         }
1190 
1191     def convert_empty_strings(self, value, expression, connection):
1192         if (not value) and isinstance(value, str):
1193             return None
1194         return value
1195 
1196     def get_db_converters(self, connection):
1197         converters = super().get_db_converters(connection)
1198         if connection.features.interprets_empty_strings_as_nulls:
1199             converters += [self.convert_empty_strings]
1200         return converters
1201 
1202     def get_col(self, alias, output_field=None):
1203         if output_field is None:
1204             output_field = self.target_field
1205             while isinstance(output_field, ForeignKey):
1206                 output_field = output_field.target_field
1207                 if output_field is self:
1208                     raise ValueError("Cannot resolve output_field.")
1209         return super().get_col(alias, output_field)
1210 
1211 
1212 class OneToOneField(ForeignKey):
1213     """
1214     A OneToOneField is essentially the same as a ForeignKey, with the exception
1215     that it always carries a "unique" constraint with it and the reverse
1216     relation always returns the object pointed to (since there will only ever
1217     be one), rather than returning a list.
1218     """
1219 
1220     # Field flags
1221     many_to_many = False
1222     many_to_one = False
1223     one_to_many = False
1224     one_to_one = True
1225 
1226     related_accessor_class = ReverseOneToOneDescriptor
1227     forward_related_accessor_class = ForwardOneToOneDescriptor
1228     rel_class = OneToOneRel
1229 
1230     description = _("One-to-one relationship")
1231 
1232     def __init__(self, to, on_delete, to_field=None, **kwargs):
1233         kwargs["unique"] = True
1234         super().__init__(to, on_delete, to_field=to_field, **kwargs)
1235 
1236     def deconstruct(self):
1237         name, path, args, kwargs = super().deconstruct()
1238         if "unique" in kwargs:
1239             del kwargs["unique"]
1240         return name, path, args, kwargs
1241 
1242     def formfield(self, **kwargs):
1243         if self.remote_field.parent_link:
1244             return None
1245         return super().formfield(**kwargs)
1246 
1247     def save_form_data(self, instance, data):
1248         if isinstance(data, self.remote_field.model):
1249             setattr(instance, self.name, data)
1250         else:
1251             setattr(instance, self.attname, data)
1252             # Remote field object must be cleared otherwise Model.save()
1253             # will reassign attname using the related object pk.
1254             if data is None:
1255                 setattr(instance, self.name, data)
1256 
1257     def _check_unique(self, **kwargs):
1258         # Override ForeignKey since check isn't applicable here.
1259         return []
1260 
1261 
1262 def create_many_to_many_intermediary_model(field, klass):
1263     from django.db import models
1264 
1265     def set_managed(model, related, through):
1266         through._meta.managed = model._meta.managed or related._meta.managed
1267 
1268     to_model = resolve_relation(klass, field.remote_field.model)
1269     name = "%s_%s" % (klass._meta.object_name, field.name)
1270     lazy_related_operation(set_managed, klass, to_model, name)
1271 
1272     to = make_model_tuple(to_model)[1]
1273     from_ = klass._meta.model_name
1274     if to == from_:
1275         to = "to_%s" % to
1276         from_ = "from_%s" % from_
1277 
1278     meta = type(
1279         "Meta",
1280         (),
1281         {
1282             "db_table": field._get_m2m_db_table(klass._meta),
1283             "auto_created": klass,
1284             "app_label": klass._meta.app_label,
1285             "db_tablespace": klass._meta.db_tablespace,
1286             "unique_together": (from_, to),
1287             "verbose_name": _("%(from)s-%(to)s relationship")
1288             % {"from": from_, "to": to},
1289             "verbose_name_plural": _("%(from)s-%(to)s relationships")
1290             % {"from": from_, "to": to},
1291             "apps": field.model._meta.apps,
1292         },
1293     )
1294     # Construct and return the new class.
1295     return type(
1296         name,
1297         (models.Model,),
1298         {
1299             "Meta": meta,
1300             "__module__": klass.__module__,
1301             from_: models.ForeignKey(
1302                 klass,
1303                 related_name="%s+" % name,
1304                 db_tablespace=field.db_tablespace,
1305                 db_constraint=field.remote_field.db_constraint,
1306                 on_delete=CASCADE,
1307             ),
1308             to: models.ForeignKey(
1309                 to_model,
1310                 related_name="%s+" % name,
1311                 db_tablespace=field.db_tablespace,
1312                 db_constraint=field.remote_field.db_constraint,
1313                 on_delete=CASCADE,
1314             ),
1315         },
1316     )
1317 
1318 
1319 class ManyToManyField(RelatedField):
1320     """
1321     Provide a many-to-many relation by using an intermediary model that
1322     holds two ForeignKey fields pointed at the two sides of the relation.
1323 
1324     Unless a ``through`` model was provided, ManyToManyField will use the
1325     create_many_to_many_intermediary_model factory to automatically generate
1326     the intermediary model.
1327     """
1328 
1329     # Field flags
1330     many_to_many = True
1331     many_to_one = False
1332     one_to_many = False
1333     one_to_one = False
1334 
1335     rel_class = ManyToManyRel
1336 
1337     description = _("Many-to-many relationship")
1338 
1339     def __init__(
1340         self,
1341         to,
1342         related_name=None,
1343         related_query_name=None,
1344         limit_choices_to=None,
1345         symmetrical=None,
1346         through=None,
1347         through_fields=None,
1348         db_constraint=True,
1349         db_table=None,
1350         swappable=True,
1351         **kwargs,
1352     ):
1353         try:
1354             to._meta
1355         except AttributeError:
1356             if not isinstance(to, str):
1357                 raise TypeError(
1358                     "%s(%r) is invalid. First parameter to ManyToManyField "
1359                     "must be either a model, a model name, or the string %r"
1360                     % (
1361                         self.__class__.__name__,
1362                         to,
1363                         RECURSIVE_RELATIONSHIP_CONSTANT,
1364                     )
1365                 )
1366 
1367         if symmetrical is None:
1368             symmetrical = to == RECURSIVE_RELATIONSHIP_CONSTANT
1369 
1370         if through is not None and db_table is not None:
1371             raise ValueError(
1372                 "Cannot specify a db_table if an intermediary model is used."
1373             )
1374 
1375         kwargs["rel"] = self.rel_class(
1376             self,
1377             to,
1378             related_name=related_name,
1379             related_query_name=related_query_name,
1380             limit_choices_to=limit_choices_to,
1381             symmetrical=symmetrical,
1382             through=through,
1383             through_fields=through_fields,
1384             db_constraint=db_constraint,
1385         )
1386         self.has_null_arg = "null" in kwargs
1387 
1388         super().__init__(
1389             related_name=related_name,
1390             related_query_name=related_query_name,
1391             limit_choices_to=limit_choices_to,
1392             **kwargs,
1393         )
1394 
1395         self.db_table = db_table
1396         self.swappable = swappable
1397 
1398     def check(self, **kwargs):
1399         return [
1400             *super().check(**kwargs),
1401             *self._check_unique(**kwargs),
1402             *self._check_relationship_model(**kwargs),
1403             *self._check_ignored_options(**kwargs),
1404             *self._check_table_uniqueness(**kwargs),
1405         ]
1406 
1407     def _check_unique(self, **kwargs):
1408         if self.unique:
1409             return [
1410                 checks.Error(
1411                     "ManyToManyFields cannot be unique.",
1412                     obj=self,
1413                     id="fields.E330",
1414                 )
1415             ]
1416         return []
1417 
1418     def _check_ignored_options(self, **kwargs):
1419         warnings = []
1420 
1421         if self.has_null_arg:
1422             warnings.append(
1423                 checks.Warning(
1424                     "null has no effect on ManyToManyField.",
1425                     obj=self,
1426                     id="fields.W340",
1427                 )
1428             )
1429 
1430         if self._validators:
1431             warnings.append(
1432                 checks.Warning(
1433                     "ManyToManyField does not support validators.",
1434                     obj=self,
1435                     id="fields.W341",
1436                 )
1437             )
1438         if self.remote_field.symmetrical and self._related_name:
1439             warnings.append(
1440                 checks.Warning(
1441                     "related_name has no effect on ManyToManyField "
1442                     'with a symmetrical relationship, e.g. to "self".',
1443                     obj=self,
1444                     id="fields.W345",
1445                 )
1446             )
1447 
1448         return warnings
1449 
1450     def _check_relationship_model(self, from_model=None, **kwargs):
1451         if hasattr(self.remote_field.through, "_meta"):
1452             qualified_model_name = "%s.%s" % (
1453                 self.remote_field.through._meta.app_label,
1454                 self.remote_field.through.__name__,
1455             )
1456         else:
1457             qualified_model_name = self.remote_field.through
1458 
1459         errors = []
1460 
1461         if self.remote_field.through not in self.opts.apps.get_models(
1462             include_auto_created=True
1463         ):
1464             # The relationship model is not installed.
1465             errors.append(
1466                 checks.Error(
1467                     "Field specifies a many-to-many relation through model "
1468                     "'%s', which has not been installed." % qualified_model_name,
1469                     obj=self,
1470                     id="fields.E331",
1471                 )
1472             )
1473 
1474         else:
1475             assert from_model is not None, (
1476                 "ManyToManyField with intermediate "
1477                 "tables cannot be checked if you don't pass the model "
1478                 "where the field is attached to."
1479             )
1480             # Set some useful local variables
1481             to_model = resolve_relation(from_model, self.remote_field.model)
1482             from_model_name = from_model._meta.object_name
1483             if isinstance(to_model, str):
1484                 to_model_name = to_model
1485             else:
1486                 to_model_name = to_model._meta.object_name
1487             relationship_model_name = self.remote_field.through._meta.object_name
1488             self_referential = from_model == to_model
1489             # Count foreign keys in intermediate model
1490             if self_referential:
1491                 seen_self = sum(
1492                     from_model == getattr(field.remote_field, "model", None)
1493                     for field in self.remote_field.through._meta.fields
1494                 )
1495 
1496                 if seen_self > 2 and not self.remote_field.through_fields:
1497                     errors.append(
1498                         checks.Error(
1499                             "The model is used as an intermediate model by "
1500                             "'%s', but it has more than two foreign keys "
1501                             "to '%s', which is ambiguous. You must specify "
1502                             "which two foreign keys Django should use via the "
1503                             "through_fields keyword argument."
1504                             % (self, from_model_name),
1505                             hint=(
1506                                 "Use through_fields to specify which two foreign keys "
1507                                 "Django should use."
1508                             ),
1509                             obj=self.remote_field.through,
1510                             id="fields.E333",
1511                         )
1512                     )
1513 
1514             else:
1515                 # Count foreign keys in relationship model
1516                 seen_from = sum(
1517                     from_model == getattr(field.remote_field, "model", None)
1518                     for field in self.remote_field.through._meta.fields
1519                 )
1520                 seen_to = sum(
1521                     to_model == getattr(field.remote_field, "model", None)
1522                     for field in self.remote_field.through._meta.fields
1523                 )
1524 
1525                 if seen_from > 1 and not self.remote_field.through_fields:
1526                     errors.append(
1527                         checks.Error(
1528                             (
1529                                 "The model is used as an intermediate model by "
1530                                 "'%s', but it has more than one foreign key "
1531                                 "from '%s', which is ambiguous. You must specify "
1532                                 "which foreign key Django should use via the "
1533                                 "through_fields keyword argument."
1534                             )
1535                             % (self, from_model_name),
1536                             hint=(
1537                                 "If you want to create a recursive relationship, "
1538                                 'use ManyToManyField("%s", through="%s").'
1539                             )
1540                             % (
1541                                 RECURSIVE_RELATIONSHIP_CONSTANT,
1542                                 relationship_model_name,
1543                             ),
1544                             obj=self,
1545                             id="fields.E334",
1546                         )
1547                     )
1548 
1549                 if seen_to > 1 and not self.remote_field.through_fields:
1550                     errors.append(
1551                         checks.Error(
1552                             "The model is used as an intermediate model by "
1553                             "'%s', but it has more than one foreign key "
1554                             "to '%s', which is ambiguous. You must specify "
1555                             "which foreign key Django should use via the "
1556                             "through_fields keyword argument." % (self, to_model_name),
1557                             hint=(
1558                                 "If you want to create a recursive relationship, "
1559                                 'use ManyToManyField("%s", through="%s").'
1560                             )
1561                             % (
1562                                 RECURSIVE_RELATIONSHIP_CONSTANT,
1563                                 relationship_model_name,
1564                             ),
1565                             obj=self,
1566                             id="fields.E335",
1567                         )
1568                     )
1569 
1570                 if seen_from == 0 or seen_to == 0:
1571                     errors.append(
1572                         checks.Error(
1573                             "The model is used as an intermediate model by "
1574                             "'%s', but it does not have a foreign key to '%s' or '%s'."
1575                             % (self, from_model_name, to_model_name),
1576                             obj=self.remote_field.through,
1577                             id="fields.E336",
1578                         )
1579                     )
1580 
1581         # Validate `through_fields`.
1582         if self.remote_field.through_fields is not None:
1583             # Validate that we're given an iterable of at least two items
1584             # and that none of them is "falsy".
1585             if not (
1586                 len(self.remote_field.through_fields) >= 2
1587                 and self.remote_field.through_fields[0]
1588                 and self.remote_field.through_fields[1]
1589             ):
1590                 errors.append(
1591                     checks.Error(
1592                         "Field specifies 'through_fields' but does not provide "
1593                         "the names of the two link fields that should be used "
1594                         "for the relation through model '%s'." % qualified_model_name,
1595                         hint=(
1596                             "Make sure you specify 'through_fields' as "
1597                             "through_fields=('field1', 'field2')"
1598                         ),
1599                         obj=self,
1600                         id="fields.E337",
1601                     )
1602                 )
1603 
1604             # Validate the given through fields -- they should be actual
1605             # fields on the through model, and also be foreign keys to the
1606             # expected models.
1607             else:
1608                 assert from_model is not None, (
1609                     "ManyToManyField with intermediate "
1610                     "tables cannot be checked if you don't pass the model "
1611                     "where the field is attached to."
1612                 )
1613 
1614                 source, through, target = (
1615                     from_model,
1616                     self.remote_field.through,
1617                     self.remote_field.model,
1618                 )
1619                 source_field_name, target_field_name = self.remote_field.through_fields[
1620                     :2
1621                 ]
1622 
1623                 for field_name, related_model in (
1624                     (source_field_name, source),
1625                     (target_field_name, target),
1626                 ):
1627 
1628                     possible_field_names = []
1629                     for f in through._meta.fields:
1630                         if (
1631                             hasattr(f, "remote_field")
1632                             and getattr(f.remote_field, "model", None) == related_model
1633                         ):
1634                             possible_field_names.append(f.name)
1635                     if possible_field_names:
1636                         hint = (
1637                             "Did you mean one of the following foreign keys to '%s': "
1638                             "%s?"
1639                             % (
1640                                 related_model._meta.object_name,
1641                                 ", ".join(possible_field_names),
1642                             )
1643                         )
1644                     else:
1645                         hint = None
1646 
1647                     try:
1648                         field = through._meta.get_field(field_name)
1649                     except exceptions.FieldDoesNotExist:
1650                         errors.append(
1651                             checks.Error(
1652                                 "The intermediary model '%s' has no field '%s'."
1653                                 % (qualified_model_name, field_name),
1654                                 hint=hint,
1655                                 obj=self,
1656                                 id="fields.E338",
1657                             )
1658                         )
1659                     else:
1660                         if not (
1661                             hasattr(field, "remote_field")
1662                             and getattr(field.remote_field, "model", None)
1663                             == related_model
1664                         ):
1665                             errors.append(
1666                                 checks.Error(
1667                                     "'%s.%s' is not a foreign key to '%s'."
1668                                     % (
1669                                         through._meta.object_name,
1670                                         field_name,
1671                                         related_model._meta.object_name,
1672                                     ),
1673                                     hint=hint,
1674                                     obj=self,
1675                                     id="fields.E339",
1676                                 )
1677                             )
1678 
1679         return errors
1680 
1681     def _check_table_uniqueness(self, **kwargs):
1682         if (
1683             isinstance(self.remote_field.through, str)
1684             or not self.remote_field.through._meta.managed
1685         ):
1686             return []
1687         registered_tables = {
1688             model._meta.db_table: model
1689             for model in self.opts.apps.get_models(include_auto_created=True)
1690             if model != self.remote_field.through and model._meta.managed
1691         }
1692         m2m_db_table = self.m2m_db_table()
1693         model = registered_tables.get(m2m_db_table)
1694         # The second condition allows multiple m2m relations on a model if
1695         # some point to a through model that proxies another through model.
1696         if (
1697             model
1698             and model._meta.concrete_model
1699             != self.remote_field.through._meta.concrete_model
1700         ):
1701             if model._meta.auto_created:
1702 
1703                 def _get_field_name(model):
1704                     for field in model._meta.auto_created._meta.many_to_many:
1705                         if field.remote_field.through is model:
1706                             return field.name
1707 
1708                 opts = model._meta.auto_created._meta
1709                 clashing_obj = "%s.%s" % (opts.label, _get_field_name(model))
1710             else:
1711                 clashing_obj = model._meta.label
1712             if settings.DATABASE_ROUTERS:
1713                 error_class, error_id = checks.Warning, "fields.W344"
1714                 error_hint = (
1715                     "You have configured settings.DATABASE_ROUTERS. Verify "
1716                     "that the table of %r is correctly routed to a separate "
1717                     "database." % clashing_obj
1718                 )
1719             else:
1720                 error_class, error_id = checks.Error, "fields.E340"
1721                 error_hint = None
1722             return [
1723                 error_class(
1724                     "The field's intermediary table '%s' clashes with the "
1725                     "table name of '%s'." % (m2m_db_table, clashing_obj),
1726                     obj=self,
1727                     hint=error_hint,
1728                     id=error_id,
1729                 )
1730             ]
1731         return []
1732 
1733     def deconstruct(self):
1734         name, path, args, kwargs = super().deconstruct()
1735         # Handle the simpler arguments.
1736         if self.db_table is not None:
1737             kwargs["db_table"] = self.db_table
1738         if self.remote_field.db_constraint is not True:
1739             kwargs["db_constraint"] = self.remote_field.db_constraint
1740         # Lowercase model names as they should be treated as case-insensitive.
1741         if isinstance(self.remote_field.model, str):
1742             if "." in self.remote_field.model:
1743                 app_label, model_name = self.remote_field.model.split(".")
1744                 kwargs["to"] = "%s.%s" % (app_label, model_name.lower())
1745             else:
1746                 kwargs["to"] = self.remote_field.model.lower()
1747         else:
1748             kwargs["to"] = self.remote_field.model._meta.label_lower
1749         if getattr(self.remote_field, "through", None) is not None:
1750             if isinstance(self.remote_field.through, str):
1751                 kwargs["through"] = self.remote_field.through
1752             elif not self.remote_field.through._meta.auto_created:
1753                 kwargs["through"] = self.remote_field.through._meta.label
1754         # If swappable is True, then see if we're actually pointing to the target
1755         # of a swap.
1756         swappable_setting = self.swappable_setting
1757         if swappable_setting is not None:
1758             # If it's already a settings reference, error.
1759             if hasattr(kwargs["to"], "setting_name"):
1760                 if kwargs["to"].setting_name != swappable_setting:
1761                     raise ValueError(
1762                         "Cannot deconstruct a ManyToManyField pointing to a "
1763                         "model that is swapped in place of more than one model "
1764                         "(%s and %s)" % (kwargs["to"].setting_name, swappable_setting)
1765                     )
1766 
1767             kwargs["to"] = SettingsReference(
1768                 kwargs["to"],
1769                 swappable_setting,
1770             )
1771         return name, path, args, kwargs
1772 
1773     def _get_path_info(self, direct=False, filtered_relation=None):
1774         """Called by both direct and indirect m2m traversal."""
1775         int_model = self.remote_field.through
1776         linkfield1 = int_model._meta.get_field(self.m2m_field_name())
1777         linkfield2 = int_model._meta.get_field(self.m2m_reverse_field_name())
1778         if direct:
1779             join1infos = linkfield1.reverse_path_infos
1780             if filtered_relation:
1781                 join2infos = linkfield2.get_path_info(filtered_relation)
1782             else:
1783                 join2infos = linkfield2.path_infos
1784         else:
1785             join1infos = linkfield2.reverse_path_infos
1786             if filtered_relation:
1787                 join2infos = linkfield1.get_path_info(filtered_relation)
1788             else:
1789                 join2infos = linkfield1.path_infos
1790         # Get join infos between the last model of join 1 and the first model
1791         # of join 2. Assume the only reason these may differ is due to model
1792         # inheritance.
1793         join1_final = join1infos[-1].to_opts
1794         join2_initial = join2infos[0].from_opts
1795         if join1_final is join2_initial:
1796             intermediate_infos = []
1797         elif issubclass(join1_final.model, join2_initial.model):
1798             intermediate_infos = join1_final.get_path_to_parent(join2_initial.model)
1799         else:
1800             intermediate_infos = join2_initial.get_path_from_parent(join1_final.model)
1801 
1802         return [*join1infos, *intermediate_infos, *join2infos]
1803 
1804     def get_path_info(self, filtered_relation=None):
1805         return self._get_path_info(direct=True, filtered_relation=filtered_relation)
1806 
1807     @cached_property
1808     def path_infos(self):
1809         return self.get_path_info()
1810 
1811     def get_reverse_path_info(self, filtered_relation=None):
1812         return self._get_path_info(direct=False, filtered_relation=filtered_relation)
1813 
1814     @cached_property
1815     def reverse_path_infos(self):
1816         return self.get_reverse_path_info()
1817 
1818     def _get_m2m_db_table(self, opts):
1819         """
1820         Function that can be curried to provide the m2m table name for this
1821         relation.
1822         """
1823         if self.remote_field.through is not None:
1824             return self.remote_field.through._meta.db_table
1825         elif self.db_table:
1826             return self.db_table
1827         else:
1828             m2m_table_name = "%s_%s" % (utils.strip_quotes(opts.db_table), self.name)
1829             return utils.truncate_name(m2m_table_name, connection.ops.max_name_length())
1830 
1831     def _get_m2m_attr(self, related, attr):
1832         """
1833         Function that can be curried to provide the source accessor or DB
1834         column name for the m2m table.
1835         """
1836         cache_attr = "_m2m_%s_cache" % attr
1837         if hasattr(self, cache_attr):
1838             return getattr(self, cache_attr)
1839         if self.remote_field.through_fields is not None:
1840             link_field_name = self.remote_field.through_fields[0]
1841         else:
1842             link_field_name = None
1843         for f in self.remote_field.through._meta.fields:
1844             if (
1845                 f.is_relation
1846                 and f.remote_field.model == related.related_model
1847                 and (link_field_name is None or link_field_name == f.name)
1848             ):
1849                 setattr(self, cache_attr, getattr(f, attr))
1850                 return getattr(self, cache_attr)
1851 
1852     def _get_m2m_reverse_attr(self, related, attr):
1853         """
1854         Function that can be curried to provide the related accessor or DB
1855         column name for the m2m table.
1856         """
1857         cache_attr = "_m2m_reverse_%s_cache" % attr
1858         if hasattr(self, cache_attr):
1859             return getattr(self, cache_attr)
1860         found = False
1861         if self.remote_field.through_fields is not None:
1862             link_field_name = self.remote_field.through_fields[1]
1863         else:
1864             link_field_name = None
1865         for f in self.remote_field.through._meta.fields:
1866             if f.is_relation and f.remote_field.model == related.model:
1867                 if link_field_name is None and related.related_model == related.model:
1868                     # If this is an m2m-intermediate to self,
1869                     # the first foreign key you find will be
1870                     # the source column. Keep searching for
1871                     # the second foreign key.
1872                     if found:
1873                         setattr(self, cache_attr, getattr(f, attr))
1874                         break
1875                     else:
1876                         found = True
1877                 elif link_field_name is None or link_field_name == f.name:
1878                     setattr(self, cache_attr, getattr(f, attr))
1879                     break
1880         return getattr(self, cache_attr)
1881 
1882     def contribute_to_class(self, cls, name, **kwargs):
1883         # To support multiple relations to self, it's useful to have a non-None
1884         # related name on symmetrical relations for internal reasons. The
1885         # concept doesn't make a lot of sense externally ("you want me to
1886         # specify *what* on my non-reversible relation?!"), so we set it up
1887         # automatically. The funky name reduces the chance of an accidental
1888         # clash.
1889         if self.remote_field.symmetrical and (
1890             self.remote_field.model == RECURSIVE_RELATIONSHIP_CONSTANT
1891             or self.remote_field.model == cls._meta.object_name
1892         ):
1893             self.remote_field.related_name = "%s_rel_+" % name
1894         elif self.remote_field.is_hidden():
1895             # If the backwards relation is disabled, replace the original
1896             # related_name with one generated from the m2m field name. Django
1897             # still uses backwards relations internally and we need to avoid
1898             # clashes between multiple m2m fields with related_name == '+'.
1899             self.remote_field.related_name = "_%s_%s_%s_+" % (
1900                 cls._meta.app_label,
1901                 cls.__name__.lower(),
1902                 name,
1903             )
1904 
1905         super().contribute_to_class(cls, name, **kwargs)
1906 
1907         # The intermediate m2m model is not auto created if:
1908         #  1) There is a manually specified intermediate, or
1909         #  2) The class owning the m2m field is abstract.
1910         #  3) The class owning the m2m field has been swapped out.
1911         if not cls._meta.abstract:
1912             if self.remote_field.through:
1913 
1914                 def resolve_through_model(_, model, field):
1915                     field.remote_field.through = model
1916 
1917                 lazy_related_operation(
1918                     resolve_through_model, cls, self.remote_field.through, field=self
1919                 )
1920             elif not cls._meta.swapped:
1921                 self.remote_field.through = create_many_to_many_intermediary_model(
1922                     self, cls
1923                 )
1924 
1925         # Add the descriptor for the m2m relation.
1926         setattr(cls, self.name, ManyToManyDescriptor(self.remote_field, reverse=False))
1927 
1928         # Set up the accessor for the m2m table name for the relation.
1929         self.m2m_db_table = partial(self._get_m2m_db_table, cls._meta)
1930 
1931     def contribute_to_related_class(self, cls, related):
1932         # Internal M2Ms (i.e., those with a related name ending with '+')
1933         # and swapped models don't get a related descriptor.
1934         if (
1935             not self.remote_field.is_hidden()
1936             and not related.related_model._meta.swapped
1937         ):
1938             setattr(
1939                 cls,
1940                 related.get_accessor_name(),
1941                 ManyToManyDescriptor(self.remote_field, reverse=True),
1942             )
1943 
1944         # Set up the accessors for the column names on the m2m table.
1945         self.m2m_column_name = partial(self._get_m2m_attr, related, "column")
1946         self.m2m_reverse_name = partial(self._get_m2m_reverse_attr, related, "column")
1947 
1948         self.m2m_field_name = partial(self._get_m2m_attr, related, "name")
1949         self.m2m_reverse_field_name = partial(
1950             self._get_m2m_reverse_attr, related, "name"
1951         )
1952 
1953         get_m2m_rel = partial(self._get_m2m_attr, related, "remote_field")
1954         self.m2m_target_field_name = lambda: get_m2m_rel().field_name
1955         get_m2m_reverse_rel = partial(
1956             self._get_m2m_reverse_attr, related, "remote_field"
1957         )
1958         self.m2m_reverse_target_field_name = lambda: get_m2m_reverse_rel().field_name
1959 
1960     def set_attributes_from_rel(self):
1961         pass
1962 
1963     def value_from_object(self, obj):
1964         return [] if obj.pk is None else list(getattr(obj, self.attname).all())
1965 
1966     def save_form_data(self, instance, data):
1967         getattr(instance, self.attname).set(data)
1968 
1969     def formfield(self, *, using=None, **kwargs):
1970         defaults = {
1971             "form_class": forms.ModelMultipleChoiceField,
1972             "queryset": self.remote_field.model._default_manager.using(using),
1973             **kwargs,
1974         }
1975         # If initial is passed in, it's a list of related objects, but the
1976         # MultipleChoiceField takes a list of IDs.
1977         if defaults.get("initial") is not None:
1978             initial = defaults["initial"]
1979             if callable(initial):
1980                 initial = initial()
1981             defaults["initial"] = [i.pk for i in initial]
1982         return super().formfield(**defaults)
1983 
1984     def db_check(self, connection):
1985         return None
1986 
1987     def db_type(self, connection):
1988         # A ManyToManyField is not represented by a single column,
1989         # so return None.
1990         return None
1991 
1992     def db_parameters(self, connection):
1993         return {"type": None, "check": None}

</code><intended_behavior>Strengthen validation and deconstruction logic to accurately handle `ManyToManyField` pointing to 'self'. This includes ensuring the field's initialization properly sets up self-references and that deconstruction provides the correct state for migration serialization. The `_check_relationship_model` method specifically could be enhanced to ensure it validates self-referencing relationships correctly, preventing schema inconsistencies.</intended_behavior>]
2025-10-18 02:00:07.321 | INFO     | Search completed. Bug locations: [<file>django/db/migrations/autodetector.py</file>
<class>None</class>
<method>None</method>
<code>
1 import functools
2 import re
3 from collections import defaultdict
4 from itertools import chain
5 
6 from django.conf import settings
7 from django.db import models
8 from django.db.migrations import operations
9 from django.db.migrations.migration import Migration
10 from django.db.migrations.operations.models import AlterModelOptions
11 from django.db.migrations.optimizer import MigrationOptimizer
12 from django.db.migrations.questioner import MigrationQuestioner
13 from django.db.migrations.utils import (
14     COMPILED_REGEX_TYPE,
15     RegexObject,
16     resolve_relation,
17 )
18 from django.utils.topological_sort import stable_topological_sort
19 
20 
21 class MigrationAutodetector:
22     """
23     Take a pair of ProjectStates and compare them to see what the first would
24     need doing to make it match the second (the second usually being the
25     project's current state).
26 
27     Note that this naturally operates on entire projects at a time,
28     as it's likely that changes interact (for example, you can't
29     add a ForeignKey without having a migration to add the table it
30     depends on first). A user interface may offer single-app usage
31     if it wishes, with the caveat that it may not always be possible.
32     """
33 
34     def __init__(self, from_state, to_state, questioner=None):
35         self.from_state = from_state
36         self.to_state = to_state
37         self.questioner = questioner or MigrationQuestioner()
38         self.existing_apps = {app for app, model in from_state.models}
39 
40     def changes(self, graph, trim_to_apps=None, convert_apps=None, migration_name=None):
41         """
42         Main entry point to produce a list of applicable changes.
43         Take a graph to base names on and an optional set of apps
44         to try and restrict to (restriction is not guaranteed)
45         """
46         changes = self._detect_changes(convert_apps, graph)
47         changes = self.arrange_for_graph(changes, graph, migration_name)
48         if trim_to_apps:
49             changes = self._trim_to_apps(changes, trim_to_apps)
50         return changes
51 
52     def deep_deconstruct(self, obj):
53         """
54         Recursive deconstruction for a field and its arguments.
55         Used for full comparison for rename/alter; sometimes a single-level
56         deconstruction will not compare correctly.
57         """
58         if isinstance(obj, list):
59             return [self.deep_deconstruct(value) for value in obj]
60         elif isinstance(obj, tuple):
61             return tuple(self.deep_deconstruct(value) for value in obj)
62         elif isinstance(obj, dict):
63             return {key: self.deep_deconstruct(value) for key, value in obj.items()}
64         elif isinstance(obj, functools.partial):
65             return (
66                 obj.func,
67                 self.deep_deconstruct(obj.args),
68                 self.deep_deconstruct(obj.keywords),
69             )
70         elif isinstance(obj, COMPILED_REGEX_TYPE):
71             return RegexObject(obj)
72         elif isinstance(obj, type):
73             # If this is a type that implements 'deconstruct' as an instance method,
74             # avoid treating this as being deconstructible itself - see #22951
75             return obj
76         elif hasattr(obj, "deconstruct"):
77             deconstructed = obj.deconstruct()
78             if isinstance(obj, models.Field):
79                 # we have a field which also returns a name
80                 deconstructed = deconstructed[1:]
81             path, args, kwargs = deconstructed
82             return (
83                 path,
84                 [self.deep_deconstruct(value) for value in args],
85                 {key: self.deep_deconstruct(value) for key, value in kwargs.items()},
86             )
87         else:
88             return obj
89 
90     def only_relation_agnostic_fields(self, fields):
91         """
92         Return a definition of the fields that ignores field names and
93         what related fields actually relate to. Used for detecting renames (as
94         the related fields change during renames).
95         """
96         fields_def = []
97         for name, field in sorted(fields.items()):
98             deconstruction = self.deep_deconstruct(field)
99             if field.remote_field and field.remote_field.model:
100                 deconstruction[2].pop("to", None)
101             fields_def.append(deconstruction)
102         return fields_def
103 
104     def _detect_changes(self, convert_apps=None, graph=None):
105         """
106         Return a dict of migration plans which will achieve the
107         change from from_state to to_state. The dict has app labels
108         as keys and a list of migrations as values.
109 
110         The resulting migrations aren't specially named, but the names
111         do matter for dependencies inside the set.
112 
113         convert_apps is the list of apps to convert to use migrations
114         (i.e. to make initial migrations for, in the usual case)
115 
116         graph is an optional argument that, if provided, can help improve
117         dependency generation and avoid potential circular dependencies.
118         """
119         # The first phase is generating all the operations for each app
120         # and gathering them into a big per-app list.
121         # Then go through that list, order it, and split into migrations to
122         # resolve dependencies caused by M2Ms and FKs.
123         self.generated_operations = {}
124         self.altered_indexes = {}
125         self.altered_constraints = {}
126         self.renamed_fields = {}
127 
128         # Prepare some old/new state and model lists, separating
129         # proxy models and ignoring unmigrated apps.
130         self.old_model_keys = set()
131         self.old_proxy_keys = set()
132         self.old_unmanaged_keys = set()
133         self.new_model_keys = set()
134         self.new_proxy_keys = set()
135         self.new_unmanaged_keys = set()
136         for (app_label, model_name), model_state in self.from_state.models.items():
137             if not model_state.options.get("managed", True):
138                 self.old_unmanaged_keys.add((app_label, model_name))
139             elif app_label not in self.from_state.real_apps:
140                 if model_state.options.get("proxy"):
141                     self.old_proxy_keys.add((app_label, model_name))
142                 else:
143                     self.old_model_keys.add((app_label, model_name))
144 
145         for (app_label, model_name), model_state in self.to_state.models.items():
146             if not model_state.options.get("managed", True):
147                 self.new_unmanaged_keys.add((app_label, model_name))
148             elif app_label not in self.from_state.real_apps or (
149                 convert_apps and app_label in convert_apps
150             ):
151                 if model_state.options.get("proxy"):
152                     self.new_proxy_keys.add((app_label, model_name))
153                 else:
154                     self.new_model_keys.add((app_label, model_name))
155 
156         self.from_state.resolve_fields_and_relations()
157         self.to_state.resolve_fields_and_relations()
158 
159         # Renames have to come first
160         self.generate_renamed_models()
161 
162         # Prepare lists of fields and generate through model map
163         self._prepare_field_lists()
164         self._generate_through_model_map()
165 
166         # Generate non-rename model operations
167         self.generate_deleted_models()
168         self.generate_created_models()
169         self.generate_deleted_proxies()
170         self.generate_created_proxies()
171         self.generate_altered_options()
172         self.generate_altered_managers()
173 
174         # Create the renamed fields and store them in self.renamed_fields.
175         # They are used by create_altered_indexes(), generate_altered_fields(),
176         # generate_removed_altered_index/unique_together(), and
177         # generate_altered_index/unique_together().
178         self.create_renamed_fields()
179         # Create the altered indexes and store them in self.altered_indexes.
180         # This avoids the same computation in generate_removed_indexes()
181         # and generate_added_indexes().
182         self.create_altered_indexes()
183         self.create_altered_constraints()
184         # Generate index removal operations before field is removed
185         self.generate_removed_constraints()
186         self.generate_removed_indexes()
187         # Generate field renaming operations.
188         self.generate_renamed_fields()
189         self.generate_renamed_indexes()
190         # Generate removal of foo together.
191         self.generate_removed_altered_unique_together()
192         self.generate_removed_altered_index_together()  # RemovedInDjango51Warning.
193         # Generate field operations.
194         self.generate_removed_fields()
195         self.generate_added_fields()
196         self.generate_altered_fields()
197         self.generate_altered_order_with_respect_to()
198         self.generate_altered_unique_together()
199         self.generate_altered_index_together()  # RemovedInDjango51Warning.
200         self.generate_added_indexes()
201         self.generate_added_constraints()
202         self.generate_altered_db_table()
203 
204         self._sort_migrations()
205         self._build_migration_list(graph)
206         self._optimize_migrations()
207 
208         return self.migrations
209 
210     def _prepare_field_lists(self):
211         """
212         Prepare field lists and a list of the fields that used through models
213         in the old state so dependencies can be made from the through model
214         deletion to the field that uses it.
215         """
216         self.kept_model_keys = self.old_model_keys & self.new_model_keys
217         self.kept_proxy_keys = self.old_proxy_keys & self.new_proxy_keys
218         self.kept_unmanaged_keys = self.old_unmanaged_keys & self.new_unmanaged_keys
219         self.through_users = {}
220         self.old_field_keys = {
221             (app_label, model_name, field_name)
222             for app_label, model_name in self.kept_model_keys
223             for field_name in self.from_state.models[
224                 app_label, self.renamed_models.get((app_label, model_name), model_name)
225             ].fields
226         }
227         self.new_field_keys = {
228             (app_label, model_name, field_name)
229             for app_label, model_name in self.kept_model_keys
230             for field_name in self.to_state.models[app_label, model_name].fields
231         }
232 
233     def _generate_through_model_map(self):
234         """Through model map generation."""
235         for app_label, model_name in sorted(self.old_model_keys):
236             old_model_name = self.renamed_models.get(
237                 (app_label, model_name), model_name
238             )
239             old_model_state = self.from_state.models[app_label, old_model_name]
240             for field_name, field in old_model_state.fields.items():
241                 if hasattr(field, "remote_field") and getattr(
242                     field.remote_field, "through", None
243                 ):
244                     through_key = resolve_relation(
245                         field.remote_field.through, app_label, model_name
246                     )
247                     self.through_users[through_key] = (
248                         app_label,
249                         old_model_name,
250                         field_name,
251                     )
252 
253     @staticmethod
254     def _resolve_dependency(dependency):
255         """
256         Return the resolved dependency and a boolean denoting whether or not
257         it was swappable.
258         """
259         if dependency[0] != "__setting__":
260             return dependency, False
261         resolved_app_label, resolved_object_name = getattr(
262             settings, dependency[1]
263         ).split(".")
264         return (resolved_app_label, resolved_object_name.lower()) + dependency[2:], True
265 
266     def _build_migration_list(self, graph=None):
267         """
268         Chop the lists of operations up into migrations with dependencies on
269         each other. Do this by going through an app's list of operations until
270         one is found that has an outgoing dependency that isn't in another
271         app's migration yet (hasn't been chopped off its list). Then chop off
272         the operations before it into a migration and move onto the next app.
273         If the loops completes without doing anything, there's a circular
274         dependency (which _should_ be impossible as the operations are
275         all split at this point so they can't depend and be depended on).
276         """
277         self.migrations = {}
278         num_ops = sum(len(x) for x in self.generated_operations.values())
279         chop_mode = False
280         while num_ops:
281             # On every iteration, we step through all the apps and see if there
282             # is a completed set of operations.
283             # If we find that a subset of the operations are complete we can
284             # try to chop it off from the rest and continue, but we only
285             # do this if we've already been through the list once before
286             # without any chopping and nothing has changed.
287             for app_label in sorted(self.generated_operations):
288                 chopped = []
289                 dependencies = set()
290                 for operation in list(self.generated_operations[app_label]):
291                     deps_satisfied = True
292                     operation_dependencies = set()
293                     for dep in operation._auto_deps:
294                         # Temporarily resolve the swappable dependency to
295                         # prevent circular references. While keeping the
296                         # dependency checks on the resolved model, add the
297                         # swappable dependencies.
298                         original_dep = dep
299                         dep, is_swappable_dep = self._resolve_dependency(dep)
300                         if dep[0] != app_label:
301                             # External app dependency. See if it's not yet
302                             # satisfied.
303                             for other_operation in self.generated_operations.get(
304                                 dep[0], []
305                             ):
306                                 if self.check_dependency(other_operation, dep):
307                                     deps_satisfied = False
308                                     break
309                             if not deps_satisfied:
310                                 break
311                             else:
312                                 if is_swappable_dep:
313                                     operation_dependencies.add(
314                                         (original_dep[0], original_dep[1])
315                                     )
316                                 elif dep[0] in self.migrations:
317                                     operation_dependencies.add(
318                                         (dep[0], self.migrations[dep[0]][-1].name)
319                                     )
320                                 else:
321                                     # If we can't find the other app, we add a
322                                     # first/last dependency, but only if we've
323                                     # already been through once and checked
324                                     # everything.
325                                     if chop_mode:
326                                         # If the app already exists, we add a
327                                         # dependency on the last migration, as
328                                         # we don't know which migration
329                                         # contains the target field. If it's
330                                         # not yet migrated or has no
331                                         # migrations, we use __first__.
332                                         if graph and graph.leaf_nodes(dep[0]):
333                                             operation_dependencies.add(
334                                                 graph.leaf_nodes(dep[0])[0]
335                                             )
336                                         else:
337                                             operation_dependencies.add(
338                                                 (dep[0], "__first__")
339                                             )
340                                     else:
341                                         deps_satisfied = False
342                     if deps_satisfied:
343                         chopped.append(operation)
344                         dependencies.update(operation_dependencies)
345                         del self.generated_operations[app_label][0]
346                     else:
347                         break
348                 # Make a migration! Well, only if there's stuff to put in it
349                 if dependencies or chopped:
350                     if not self.generated_operations[app_label] or chop_mode:
351                         subclass = type(
352                             "Migration",
353                             (Migration,),
354                             {"operations": [], "dependencies": []},
355                         )
356                         instance = subclass(
357                             "auto_%i" % (len(self.migrations.get(app_label, [])) + 1),
358                             app_label,
359                         )
360                         instance.dependencies = list(dependencies)
361                         instance.operations = chopped
362                         instance.initial = app_label not in self.existing_apps
363                         self.migrations.setdefault(app_label, []).append(instance)
364                         chop_mode = False
365                     else:
366                         self.generated_operations[app_label] = (
367                             chopped + self.generated_operations[app_label]
368                         )
369             new_num_ops = sum(len(x) for x in self.generated_operations.values())
370             if new_num_ops == num_ops:
371                 if not chop_mode:
372                     chop_mode = True
373                 else:
374                     raise ValueError(
375                         "Cannot resolve operation dependencies: %r"
376                         % self.generated_operations
377                     )
378             num_ops = new_num_ops
379 
380     def _sort_migrations(self):
381         """
382         Reorder to make things possible. Reordering may be needed so FKs work
383         nicely inside the same app.
384         """
385         for app_label, ops in sorted(self.generated_operations.items()):
386             # construct a dependency graph for intra-app dependencies
387             dependency_graph = {op: set() for op in ops}
388             for op in ops:
389                 for dep in op._auto_deps:
390                     # Resolve intra-app dependencies to handle circular
391                     # references involving a swappable model.
392                     dep = self._resolve_dependency(dep)[0]
393                     if dep[0] == app_label:
394                         for op2 in ops:
395                             if self.check_dependency(op2, dep):
396                                 dependency_graph[op].add(op2)
397 
398             # we use a stable sort for deterministic tests & general behavior
399             self.generated_operations[app_label] = stable_topological_sort(
400                 ops, dependency_graph
401             )
402 
403     def _optimize_migrations(self):
404         # Add in internal dependencies among the migrations
405         for app_label, migrations in self.migrations.items():
406             for m1, m2 in zip(migrations, migrations[1:]):
407                 m2.dependencies.append((app_label, m1.name))
408 
409         # De-dupe dependencies
410         for migrations in self.migrations.values():
411             for migration in migrations:
412                 migration.dependencies = list(set(migration.dependencies))
413 
414         # Optimize migrations
415         for app_label, migrations in self.migrations.items():
416             for migration in migrations:
417                 migration.operations = MigrationOptimizer().optimize(
418                     migration.operations, app_label
419                 )
420 
421     def check_dependency(self, operation, dependency):
422         """
423         Return True if the given operation depends on the given dependency,
424         False otherwise.
425         """
426         # Created model
427         if dependency[2] is None and dependency[3] is True:
428             return (
429                 isinstance(operation, operations.CreateModel)
430                 and operation.name_lower == dependency[1].lower()
431             )
432         # Created field
433         elif dependency[2] is not None and dependency[3] is True:
434             return (
435                 isinstance(operation, operations.CreateModel)
436                 and operation.name_lower == dependency[1].lower()
437                 and any(dependency[2] == x for x, y in operation.fields)
438             ) or (
439                 isinstance(operation, operations.AddField)
440                 and operation.model_name_lower == dependency[1].lower()
441                 and operation.name_lower == dependency[2].lower()
442             )
443         # Removed field
444         elif dependency[2] is not None and dependency[3] is False:
445             return (
446                 isinstance(operation, operations.RemoveField)
447                 and operation.model_name_lower == dependency[1].lower()
448                 and operation.name_lower == dependency[2].lower()
449             )
450         # Removed model
451         elif dependency[2] is None and dependency[3] is False:
452             return (
453                 isinstance(operation, operations.DeleteModel)
454                 and operation.name_lower == dependency[1].lower()
455             )
456         # Field being altered
457         elif dependency[2] is not None and dependency[3] == "alter":
458             return (
459                 isinstance(operation, operations.AlterField)
460                 and operation.model_name_lower == dependency[1].lower()
461                 and operation.name_lower == dependency[2].lower()
462             )
463         # order_with_respect_to being unset for a field
464         elif dependency[2] is not None and dependency[3] == "order_wrt_unset":
465             return (
466                 isinstance(operation, operations.AlterOrderWithRespectTo)
467                 and operation.name_lower == dependency[1].lower()
468                 and (operation.order_with_respect_to or "").lower()
469                 != dependency[2].lower()
470             )
471         # Field is removed and part of an index/unique_together
472         elif dependency[2] is not None and dependency[3] == "foo_together_change":
473             return (
474                 isinstance(
475                     operation,
476                     (operations.AlterUniqueTogether, operations.AlterIndexTogether),
477                 )
478                 and operation.name_lower == dependency[1].lower()
479             )
480         # Unknown dependency. Raise an error.
481         else:
482             raise ValueError("Can't handle dependency %r" % (dependency,))
483 
484     def add_operation(self, app_label, operation, dependencies=None, beginning=False):
485         # Dependencies are
486         # (app_label, model_name, field_name, create/delete as True/False)
487         operation._auto_deps = dependencies or []
488         if beginning:
489             self.generated_operations.setdefault(app_label, []).insert(0, operation)
490         else:
491             self.generated_operations.setdefault(app_label, []).append(operation)
492 
493     def swappable_first_key(self, item):
494         """
495         Place potential swappable models first in lists of created models (only
496         real way to solve #22783).
497         """
498         try:
499             model_state = self.to_state.models[item]
500             base_names = {
501                 base if isinstance(base, str) else base.__name__
502                 for base in model_state.bases
503             }
504             string_version = "%s.%s" % (item[0], item[1])
505             if (
506                 model_state.options.get("swappable")
507                 or "AbstractUser" in base_names
508                 or "AbstractBaseUser" in base_names
509                 or settings.AUTH_USER_MODEL.lower() == string_version.lower()
510             ):
511                 return ("___" + item[0], "___" + item[1])
512         except LookupError:
513             pass
514         return item
515 
516     def generate_renamed_models(self):
517         """
518         Find any renamed models, generate the operations for them, and remove
519         the old entry from the model lists. Must be run before other
520         model-level generation.
521         """
522         self.renamed_models = {}
523         self.renamed_models_rel = {}
524         added_models = self.new_model_keys - self.old_model_keys
525         for app_label, model_name in sorted(added_models):
526             model_state = self.to_state.models[app_label, model_name]
527             model_fields_def = self.only_relation_agnostic_fields(model_state.fields)
528 
529             removed_models = self.old_model_keys - self.new_model_keys
530             for rem_app_label, rem_model_name in removed_models:
531                 if rem_app_label == app_label:
532                     rem_model_state = self.from_state.models[
533                         rem_app_label, rem_model_name
534                     ]
535                     rem_model_fields_def = self.only_relation_agnostic_fields(
536                         rem_model_state.fields
537                     )
538                     if model_fields_def == rem_model_fields_def:
539                         if self.questioner.ask_rename_model(
540                             rem_model_state, model_state
541                         ):
542                             dependencies = []
543                             fields = list(model_state.fields.values()) + [
544                                 field.remote_field
545                                 for relations in self.to_state.relations[
546                                     app_label, model_name
547                                 ].values()
548                                 for field in relations.values()
549                             ]
550                             for field in fields:
551                                 if field.is_relation:
552                                     dependencies.extend(
553                                         self._get_dependencies_for_foreign_key(
554                                             app_label,
555                                             model_name,
556                                             field,
557                                             self.to_state,
558                                         )
559                                     )
560                             self.add_operation(
561                                 app_label,
562                                 operations.RenameModel(
563                                     old_name=rem_model_state.name,
564                                     new_name=model_state.name,
565                                 ),
566                                 dependencies=dependencies,
567                             )
568                             self.renamed_models[app_label, model_name] = rem_model_name
569                             renamed_models_rel_key = "%s.%s" % (
570                                 rem_model_state.app_label,
571                                 rem_model_state.name_lower,
572                             )
573                             self.renamed_models_rel[
574                                 renamed_models_rel_key
575                             ] = "%s.%s" % (
576                                 model_state.app_label,
577                                 model_state.name_lower,
578                             )
579                             self.old_model_keys.remove((rem_app_label, rem_model_name))
580                             self.old_model_keys.add((app_label, model_name))
581                             break
582 
583     def generate_created_models(self):
584         """
585         Find all new models (both managed and unmanaged) and make create
586         operations for them as well as separate operations to create any
587         foreign key or M2M relationships (these are optimized later, if
588         possible).
589 
590         Defer any model options that refer to collections of fields that might
591         be deferred (e.g. unique_together, index_together).
592         """
593         old_keys = self.old_model_keys | self.old_unmanaged_keys
594         added_models = self.new_model_keys - old_keys
595         added_unmanaged_models = self.new_unmanaged_keys - old_keys
596         all_added_models = chain(
597             sorted(added_models, key=self.swappable_first_key, reverse=True),
598             sorted(added_unmanaged_models, key=self.swappable_first_key, reverse=True),
599         )
600         for app_label, model_name in all_added_models:
601             model_state = self.to_state.models[app_label, model_name]
602             # Gather related fields
603             related_fields = {}
604             primary_key_rel = None
605             for field_name, field in model_state.fields.items():
606                 if field.remote_field:
607                     if field.remote_field.model:
608                         if field.primary_key:
609                             primary_key_rel = field.remote_field.model
610                         elif not field.remote_field.parent_link:
611                             related_fields[field_name] = field
612                     if getattr(field.remote_field, "through", None):
613                         related_fields[field_name] = field
614 
615             # Are there indexes/unique|index_together to defer?
616             indexes = model_state.options.pop("indexes")
617             constraints = model_state.options.pop("constraints")
618             unique_together = model_state.options.pop("unique_together", None)
619             # RemovedInDjango51Warning.
620             index_together = model_state.options.pop("index_together", None)
621             order_with_respect_to = model_state.options.pop(
622                 "order_with_respect_to", None
623             )
624             # Depend on the deletion of any possible proxy version of us
625             dependencies = [
626                 (app_label, model_name, None, False),
627             ]
628             # Depend on all bases
629             for base in model_state.bases:
630                 if isinstance(base, str) and "." in base:
631                     base_app_label, base_name = base.split(".", 1)
632                     dependencies.append((base_app_label, base_name, None, True))
633                     # Depend on the removal of base fields if the new model has
634                     # a field with the same name.
635                     old_base_model_state = self.from_state.models.get(
636                         (base_app_label, base_name)
637                     )
638                     new_base_model_state = self.to_state.models.get(
639                         (base_app_label, base_name)
640                     )
641                     if old_base_model_state and new_base_model_state:
642                         removed_base_fields = (
643                             set(old_base_model_state.fields)
644                             .difference(
645                                 new_base_model_state.fields,
646                             )
647                             .intersection(model_state.fields)
648                         )
649                         for removed_base_field in removed_base_fields:
650                             dependencies.append(
651                                 (base_app_label, base_name, removed_base_field, False)
652                             )
653             # Depend on the other end of the primary key if it's a relation
654             if primary_key_rel:
655                 dependencies.append(
656                     resolve_relation(
657                         primary_key_rel,
658                         app_label,
659                         model_name,
660                     )
661                     + (None, True)
662                 )
663             # Generate creation operation
664             self.add_operation(
665                 app_label,
666                 operations.CreateModel(
667                     name=model_state.name,
668                     fields=[
669                         d
670                         for d in model_state.fields.items()
671                         if d[0] not in related_fields
672                     ],
673                     options=model_state.options,
674                     bases=model_state.bases,
675                     managers=model_state.managers,
676                 ),
677                 dependencies=dependencies,
678                 beginning=True,
679             )
680 
681             # Don't add operations which modify the database for unmanaged models
682             if not model_state.options.get("managed", True):
683                 continue
684 
685             # Generate operations for each related field
686             for name, field in sorted(related_fields.items()):
687                 dependencies = self._get_dependencies_for_foreign_key(
688                     app_label,
689                     model_name,
690                     field,
691                     self.to_state,
692                 )
693                 # Depend on our own model being created
694                 dependencies.append((app_label, model_name, None, True))
695                 # Make operation
696                 self.add_operation(
697                     app_label,
698                     operations.AddField(
699                         model_name=model_name,
700                         name=name,
701                         field=field,
702                     ),
703                     dependencies=list(set(dependencies)),
704                 )
705             # Generate other opns
706             if order_with_respect_to:
707                 self.add_operation(
708                     app_label,
709                     operations.AlterOrderWithRespectTo(
710                         name=model_name,
711                         order_with_respect_to=order_with_respect_to,
712                     ),
713                     dependencies=[
714                         (app_label, model_name, order_with_respect_to, True),
715                         (app_label, model_name, None, True),
716                     ],
717                 )
718             related_dependencies = [
719                 (app_label, model_name, name, True) for name in sorted(related_fields)
720             ]
721             related_dependencies.append((app_label, model_name, None, True))
722             for index in indexes:
723                 self.add_operation(
724                     app_label,
725                     operations.AddIndex(
726                         model_name=model_name,
727                         index=index,
728                     ),
729                     dependencies=related_dependencies,
730                 )
731             for constraint in constraints:
732                 self.add_operation(
733                     app_label,
734                     operations.AddConstraint(
735                         model_name=model_name,
736                         constraint=constraint,
737                     ),
738                     dependencies=related_dependencies,
739                 )
740             if unique_together:
741                 self.add_operation(
742                     app_label,
743                     operations.AlterUniqueTogether(
744                         name=model_name,
745                         unique_together=unique_together,
746                     ),
747                     dependencies=related_dependencies,
748                 )
749             # RemovedInDjango51Warning.
750             if index_together:
751                 self.add_operation(
752                     app_label,
753                     operations.AlterIndexTogether(
754                         name=model_name,
755                         index_together=index_together,
756                     ),
757                     dependencies=related_dependencies,
758                 )
759             # Fix relationships if the model changed from a proxy model to a
760             # concrete model.
761             relations = self.to_state.relations
762             if (app_label, model_name) in self.old_proxy_keys:
763                 for related_model_key, related_fields in relations[
764                     app_label, model_name
765                 ].items():
766                     related_model_state = self.to_state.models[related_model_key]
767                     for related_field_name, related_field in related_fields.items():
768                         self.add_operation(
769                             related_model_state.app_label,
770                             operations.AlterField(
771                                 model_name=related_model_state.name,
772                                 name=related_field_name,
773                                 field=related_field,
774                             ),
775                             dependencies=[(app_label, model_name, None, True)],
776                         )
777 
778     def generate_created_proxies(self):
779         """
780         Make CreateModel statements for proxy models. Use the same statements
781         as that way there's less code duplication, but for proxy models it's
782         safe to skip all the pointless field stuff and chuck out an operation.
783         """
784         added = self.new_proxy_keys - self.old_proxy_keys
785         for app_label, model_name in sorted(added):
786             model_state = self.to_state.models[app_label, model_name]
787             assert model_state.options.get("proxy")
788             # Depend on the deletion of any possible non-proxy version of us
789             dependencies = [
790                 (app_label, model_name, None, False),
791             ]
792             # Depend on all bases
793             for base in model_state.bases:
794                 if isinstance(base, str) and "." in base:
795                     base_app_label, base_name = base.split(".", 1)
796                     dependencies.append((base_app_label, base_name, None, True))
797             # Generate creation operation
798             self.add_operation(
799                 app_label,
800                 operations.CreateModel(
801                     name=model_state.name,
802                     fields=[],
803                     options=model_state.options,
804                     bases=model_state.bases,
805                     managers=model_state.managers,
806                 ),
807                 # Depend on the deletion of any possible non-proxy version of us
808                 dependencies=dependencies,
809             )
810 
811     def generate_deleted_models(self):
812         """
813         Find all deleted models (managed and unmanaged) and make delete
814         operations for them as well as separate operations to delete any
815         foreign key or M2M relationships (these are optimized later, if
816         possible).
817 
818         Also bring forward removal of any model options that refer to
819         collections of fields - the inverse of generate_created_models().
820         """
821         new_keys = self.new_model_keys | self.new_unmanaged_keys
822         deleted_models = self.old_model_keys - new_keys
823         deleted_unmanaged_models = self.old_unmanaged_keys - new_keys
824         all_deleted_models = chain(
825             sorted(deleted_models), sorted(deleted_unmanaged_models)
826         )
827         for app_label, model_name in all_deleted_models:
828             model_state = self.from_state.models[app_label, model_name]
829             # Gather related fields
830             related_fields = {}
831             for field_name, field in model_state.fields.items():
832                 if field.remote_field:
833                     if field.remote_field.model:
834                         related_fields[field_name] = field
835                     if getattr(field.remote_field, "through", None):
836                         related_fields[field_name] = field
837             # Generate option removal first
838             unique_together = model_state.options.pop("unique_together", None)
839             # RemovedInDjango51Warning.
840             index_together = model_state.options.pop("index_together", None)
841             if unique_together:
842                 self.add_operation(
843                     app_label,
844                     operations.AlterUniqueTogether(
845                         name=model_name,
846                         unique_together=None,
847                     ),
848                 )
849             # RemovedInDjango51Warning.
850             if index_together:
851                 self.add_operation(
852                     app_label,
853                     operations.AlterIndexTogether(
854                         name=model_name,
855                         index_together=None,
856                     ),
857                 )
858             # Then remove each related field
859             for name in sorted(related_fields):
860                 self.add_operation(
861                     app_label,
862                     operations.RemoveField(
863                         model_name=model_name,
864                         name=name,
865                     ),
866                 )
867             # Finally, remove the model.
868             # This depends on both the removal/alteration of all incoming fields
869             # and the removal of all its own related fields, and if it's
870             # a through model the field that references it.
871             dependencies = []
872             relations = self.from_state.relations
873             for (
874                 related_object_app_label,
875                 object_name,
876             ), relation_related_fields in relations[app_label, model_name].items():
877                 for field_name, field in relation_related_fields.items():
878                     dependencies.append(
879                         (related_object_app_label, object_name, field_name, False),
880                     )
881                     if not field.many_to_many:
882                         dependencies.append(
883                             (
884                                 related_object_app_label,
885                                 object_name,
886                                 field_name,
887                                 "alter",
888                             ),
889                         )
890 
891             for name in sorted(related_fields):
892                 dependencies.append((app_label, model_name, name, False))
893             # We're referenced in another field's through=
894             through_user = self.through_users.get((app_label, model_state.name_lower))
895             if through_user:
896                 dependencies.append(
897                     (through_user[0], through_user[1], through_user[2], False)
898                 )
899             # Finally, make the operation, deduping any dependencies
900             self.add_operation(
901                 app_label,
902                 operations.DeleteModel(
903                     name=model_state.name,
904                 ),
905                 dependencies=list(set(dependencies)),
906             )
907 
908     def generate_deleted_proxies(self):
909         """Make DeleteModel options for proxy models."""
910         deleted = self.old_proxy_keys - self.new_proxy_keys
911         for app_label, model_name in sorted(deleted):
912             model_state = self.from_state.models[app_label, model_name]
913             assert model_state.options.get("proxy")
914             self.add_operation(
915                 app_label,
916                 operations.DeleteModel(
917                     name=model_state.name,
918                 ),
919             )
920 
921     def create_renamed_fields(self):
922         """Work out renamed fields."""
923         self.renamed_operations = []
924         old_field_keys = self.old_field_keys.copy()
925         for app_label, model_name, field_name in sorted(
926             self.new_field_keys - old_field_keys
927         ):
928             old_model_name = self.renamed_models.get(
929                 (app_label, model_name), model_name
930             )
931             old_model_state = self.from_state.models[app_label, old_model_name]
932             new_model_state = self.to_state.models[app_label, model_name]
933             field = new_model_state.get_field(field_name)
934             # Scan to see if this is actually a rename!
935             field_dec = self.deep_deconstruct(field)
936             for rem_app_label, rem_model_name, rem_field_name in sorted(
937                 old_field_keys - self.new_field_keys
938             ):
939                 if rem_app_label == app_label and rem_model_name == model_name:
940                     old_field = old_model_state.get_field(rem_field_name)
941                     old_field_dec = self.deep_deconstruct(old_field)
942                     if (
943                         field.remote_field
944                         and field.remote_field.model
945                         and "to" in old_field_dec[2]
946                     ):
947                         old_rel_to = old_field_dec[2]["to"]
948                         if old_rel_to in self.renamed_models_rel:
949                             old_field_dec[2]["to"] = self.renamed_models_rel[old_rel_to]
950                     old_field.set_attributes_from_name(rem_field_name)
951                     old_db_column = old_field.get_attname_column()[1]
952                     if old_field_dec == field_dec or (
953                         # Was the field renamed and db_column equal to the
954                         # old field's column added?
955                         old_field_dec[0:2] == field_dec[0:2]
956                         and dict(old_field_dec[2], db_column=old_db_column)
957                         == field_dec[2]
958                     ):
959                         if self.questioner.ask_rename(
960                             model_name, rem_field_name, field_name, field
961                         ):
962                             self.renamed_operations.append(
963                                 (
964                                     rem_app_label,
965                                     rem_model_name,
966                                     old_field.db_column,
967                                     rem_field_name,
968                                     app_label,
969                                     model_name,
970                                     field,
971                                     field_name,
972                                 )
973                             )
974                             old_field_keys.remove(
975                                 (rem_app_label, rem_model_name, rem_field_name)
976                             )
977                             old_field_keys.add((app_label, model_name, field_name))
978                             self.renamed_fields[
979                                 app_label, model_name, field_name
980                             ] = rem_field_name
981                             break
982 
983     def generate_renamed_fields(self):
984         """Generate RenameField operations."""
985         for (
986             rem_app_label,
987             rem_model_name,
988             rem_db_column,
989             rem_field_name,
990             app_label,
991             model_name,
992             field,
993             field_name,
994         ) in self.renamed_operations:
995             # A db_column mismatch requires a prior noop AlterField for the
996             # subsequent RenameField to be a noop on attempts at preserving the
997             # old name.
998             if rem_db_column != field.db_column:
999                 altered_field = field.clone()
1000                 altered_field.name = rem_field_name
1001                 self.add_operation(
1002                     app_label,
1003                     operations.AlterField(
1004                         model_name=model_name,
1005                         name=rem_field_name,
1006                         field=altered_field,
1007                     ),
1008                 )
1009             self.add_operation(
1010                 app_label,
1011                 operations.RenameField(
1012                     model_name=model_name,
1013                     old_name=rem_field_name,
1014                     new_name=field_name,
1015                 ),
1016             )
1017             self.old_field_keys.remove((rem_app_label, rem_model_name, rem_field_name))
1018             self.old_field_keys.add((app_label, model_name, field_name))
1019 
1020     def generate_added_fields(self):
1021         """Make AddField operations."""
1022         for app_label, model_name, field_name in sorted(
1023             self.new_field_keys - self.old_field_keys
1024         ):
1025             self._generate_added_field(app_label, model_name, field_name)
1026 
1027     def _generate_added_field(self, app_label, model_name, field_name):
1028         field = self.to_state.models[app_label, model_name].get_field(field_name)
1029         # Adding a field always depends at least on its removal.
1030         dependencies = [(app_label, model_name, field_name, False)]
1031         # Fields that are foreignkeys/m2ms depend on stuff.
1032         if field.remote_field and field.remote_field.model:
1033             dependencies.extend(
1034                 self._get_dependencies_for_foreign_key(
1035                     app_label,
1036                     model_name,
1037                     field,
1038                     self.to_state,
1039                 )
1040             )
1041         # You can't just add NOT NULL fields with no default or fields
1042         # which don't allow empty strings as default.
1043         time_fields = (models.DateField, models.DateTimeField, models.TimeField)
1044         preserve_default = (
1045             field.null
1046             or field.has_default()
1047             or field.many_to_many
1048             or (field.blank and field.empty_strings_allowed)
1049             or (isinstance(field, time_fields) and field.auto_now)
1050         )
1051         if not preserve_default:
1052             field = field.clone()
1053             if isinstance(field, time_fields) and field.auto_now_add:
1054                 field.default = self.questioner.ask_auto_now_add_addition(
1055                     field_name, model_name
1056                 )
1057             else:
1058                 field.default = self.questioner.ask_not_null_addition(
1059                     field_name, model_name
1060                 )
1061         if (
1062             field.unique
1063             and field.default is not models.NOT_PROVIDED
1064             and callable(field.default)
1065         ):
1066             self.questioner.ask_unique_callable_default_addition(field_name, model_name)
1067         self.add_operation(
1068             app_label,
1069             operations.AddField(
1070                 model_name=model_name,
1071                 name=field_name,
1072                 field=field,
1073                 preserve_default=preserve_default,
1074             ),
1075             dependencies=dependencies,
1076         )
1077 
1078     def generate_removed_fields(self):
1079         """Make RemoveField operations."""
1080         for app_label, model_name, field_name in sorted(
1081             self.old_field_keys - self.new_field_keys
1082         ):
1083             self._generate_removed_field(app_label, model_name, field_name)
1084 
1085     def _generate_removed_field(self, app_label, model_name, field_name):
1086         self.add_operation(
1087             app_label,
1088             operations.RemoveField(
1089                 model_name=model_name,
1090                 name=field_name,
1091             ),
1092             # We might need to depend on the removal of an
1093             # order_with_respect_to or index/unique_together operation;
1094             # this is safely ignored if there isn't one
1095             dependencies=[
1096                 (app_label, model_name, field_name, "order_wrt_unset"),
1097                 (app_label, model_name, field_name, "foo_together_change"),
1098             ],
1099         )
1100 
1101     def generate_altered_fields(self):
1102         """
1103         Make AlterField operations, or possibly RemovedField/AddField if alter
1104         isn't possible.
1105         """
1106         for app_label, model_name, field_name in sorted(
1107             self.old_field_keys & self.new_field_keys
1108         ):
1109             # Did the field change?
1110             old_model_name = self.renamed_models.get(
1111                 (app_label, model_name), model_name
1112             )
1113             old_field_name = self.renamed_fields.get(
1114                 (app_label, model_name, field_name), field_name
1115             )
1116             old_field = self.from_state.models[app_label, old_model_name].get_field(
1117                 old_field_name
1118             )
1119             new_field = self.to_state.models[app_label, model_name].get_field(
1120                 field_name
1121             )
1122             dependencies = []
1123             # Implement any model renames on relations; these are handled by RenameModel
1124             # so we need to exclude them from the comparison
1125             if hasattr(new_field, "remote_field") and getattr(
1126                 new_field.remote_field, "model", None
1127             ):
1128                 rename_key = resolve_relation(
1129                     new_field.remote_field.model, app_label, model_name
1130                 )
1131                 if rename_key in self.renamed_models:
1132                     new_field.remote_field.model = old_field.remote_field.model
1133                 # Handle ForeignKey which can only have a single to_field.
1134                 remote_field_name = getattr(new_field.remote_field, "field_name", None)
1135                 if remote_field_name:
1136                     to_field_rename_key = rename_key + (remote_field_name,)
1137                     if to_field_rename_key in self.renamed_fields:
1138                         # Repoint both model and field name because to_field
1139                         # inclusion in ForeignKey.deconstruct() is based on
1140                         # both.
1141                         new_field.remote_field.model = old_field.remote_field.model
1142                         new_field.remote_field.field_name = (
1143                             old_field.remote_field.field_name
1144                         )
1145                 # Handle ForeignObjects which can have multiple from_fields/to_fields.
1146                 from_fields = getattr(new_field, "from_fields", None)
1147                 if from_fields:
1148                     from_rename_key = (app_label, model_name)
1149                     new_field.from_fields = tuple(
1150                         [
1151                             self.renamed_fields.get(
1152                                 from_rename_key + (from_field,), from_field
1153                             )
1154                             for from_field in from_fields
1155                         ]
1156                     )
1157                     new_field.to_fields = tuple(
1158                         [
1159                             self.renamed_fields.get(rename_key + (to_field,), to_field)
1160                             for to_field in new_field.to_fields
1161                         ]
1162                     )
1163                 dependencies.extend(
1164                     self._get_dependencies_for_foreign_key(
1165                         app_label,
1166                         model_name,
1167                         new_field,
1168                         self.to_state,
1169                     )
1170                 )
1171             if hasattr(new_field, "remote_field") and getattr(
1172                 new_field.remote_field, "through", None
1173             ):
1174                 rename_key = resolve_relation(
1175                     new_field.remote_field.through, app_label, model_name
1176                 )
1177                 if rename_key in self.renamed_models:
1178                     new_field.remote_field.through = old_field.remote_field.through
1179             old_field_dec = self.deep_deconstruct(old_field)
1180             new_field_dec = self.deep_deconstruct(new_field)
1181             # If the field was confirmed to be renamed it means that only
1182             # db_column was allowed to change which generate_renamed_fields()
1183             # already accounts for by adding an AlterField operation.
1184             if old_field_dec != new_field_dec and old_field_name == field_name:
1185                 both_m2m = old_field.many_to_many and new_field.many_to_many
1186                 neither_m2m = not old_field.many_to_many and not new_field.many_to_many
1187                 if both_m2m or neither_m2m:
1188                     # Either both fields are m2m or neither is
1189                     preserve_default = True
1190                     if (
1191                         old_field.null
1192                         and not new_field.null
1193                         and not new_field.has_default()
1194                         and not new_field.many_to_many
1195                     ):
1196                         field = new_field.clone()
1197                         new_default = self.questioner.ask_not_null_alteration(
1198                             field_name, model_name
1199                         )
1200                         if new_default is not models.NOT_PROVIDED:
1201                             field.default = new_default
1202                             preserve_default = False
1203                     else:
1204                         field = new_field
1205                     self.add_operation(
1206                         app_label,
1207                         operations.AlterField(
1208                             model_name=model_name,
1209                             name=field_name,
1210                             field=field,
1211                             preserve_default=preserve_default,
1212                         ),
1213                         dependencies=dependencies,
1214                     )
1215                 else:
1216                     # We cannot alter between m2m and concrete fields
1217                     self._generate_removed_field(app_label, model_name, field_name)
1218                     self._generate_added_field(app_label, model_name, field_name)
1219 
1220     def create_altered_indexes(self):
1221         option_name = operations.AddIndex.option_name
1222         self.renamed_index_together_values = defaultdict(list)
1223 
1224         for app_label, model_name in sorted(self.kept_model_keys):
1225             old_model_name = self.renamed_models.get(
1226                 (app_label, model_name), model_name
1227             )
1228             old_model_state = self.from_state.models[app_label, old_model_name]
1229             new_model_state = self.to_state.models[app_label, model_name]
1230 
1231             old_indexes = old_model_state.options[option_name]
1232             new_indexes = new_model_state.options[option_name]
1233             added_indexes = [idx for idx in new_indexes if idx not in old_indexes]
1234             removed_indexes = [idx for idx in old_indexes if idx not in new_indexes]
1235             renamed_indexes = []
1236             # Find renamed indexes.
1237             remove_from_added = []
1238             remove_from_removed = []
1239             for new_index in added_indexes:
1240                 new_index_dec = new_index.deconstruct()
1241                 new_index_name = new_index_dec[2].pop("name")
1242                 for old_index in removed_indexes:
1243                     old_index_dec = old_index.deconstruct()
1244                     old_index_name = old_index_dec[2].pop("name")
1245                     # Indexes are the same except for the names.
1246                     if (
1247                         new_index_dec == old_index_dec
1248                         and new_index_name != old_index_name
1249                     ):
1250                         renamed_indexes.append((old_index_name, new_index_name, None))
1251                         remove_from_added.append(new_index)
1252                         remove_from_removed.append(old_index)
1253             # Find index_together changed to indexes.
1254             for (
1255                 old_value,
1256                 new_value,
1257                 index_together_app_label,
1258                 index_together_model_name,
1259                 dependencies,
1260             ) in self._get_altered_foo_together_operations(
1261                 operations.AlterIndexTogether.option_name
1262             ):
1263                 if (
1264                     app_label != index_together_app_label
1265                     or model_name != index_together_model_name
1266                 ):
1267                     continue
1268                 removed_values = old_value.difference(new_value)
1269                 for removed_index_together in removed_values:
1270                     renamed_index_together_indexes = []
1271                     for new_index in added_indexes:
1272                         _, args, kwargs = new_index.deconstruct()
1273                         # Ensure only 'fields' are defined in the Index.
1274                         if (
1275                             not args
1276                             and new_index.fields == list(removed_index_together)
1277                             and set(kwargs) == {"name", "fields"}
1278                         ):
1279                             renamed_index_together_indexes.append(new_index)
1280 
1281                     if len(renamed_index_together_indexes) == 1:
1282                         renamed_index = renamed_index_together_indexes[0]
1283                         remove_from_added.append(renamed_index)
1284                         renamed_indexes.append(
1285                             (None, renamed_index.name, removed_index_together)
1286                         )
1287                         self.renamed_index_together_values[
1288                             index_together_app_label, index_together_model_name
1289                         ].append(removed_index_together)
1290             # Remove renamed indexes from the lists of added and removed
1291             # indexes.
1292             added_indexes = [
1293                 idx for idx in added_indexes if idx not in remove_from_added
1294             ]
1295             removed_indexes = [
1296                 idx for idx in removed_indexes if idx not in remove_from_removed
1297             ]
1298 
1299             self.altered_indexes.update(
1300                 {
1301                     (app_label, model_name): {
1302                         "added_indexes": added_indexes,
1303                         "removed_indexes": removed_indexes,
1304                         "renamed_indexes": renamed_indexes,
1305                     }
1306                 }
1307             )
1308 
1309     def generate_added_indexes(self):
1310         for (app_label, model_name), alt_indexes in self.altered_indexes.items():
1311             for index in alt_indexes["added_indexes"]:
1312                 self.add_operation(
1313                     app_label,
1314                     operations.AddIndex(
1315                         model_name=model_name,
1316                         index=index,
1317                     ),
1318                 )
1319 
1320     def generate_removed_indexes(self):
1321         for (app_label, model_name), alt_indexes in self.altered_indexes.items():
1322             for index in alt_indexes["removed_indexes"]:
1323                 self.add_operation(
1324                     app_label,
1325                     operations.RemoveIndex(
1326                         model_name=model_name,
1327                         name=index.name,
1328                     ),
1329                 )
1330 
1331     def generate_renamed_indexes(self):
1332         for (app_label, model_name), alt_indexes in self.altered_indexes.items():
1333             for old_index_name, new_index_name, old_fields in alt_indexes[
1334                 "renamed_indexes"
1335             ]:
1336                 self.add_operation(
1337                     app_label,
1338                     operations.RenameIndex(
1339                         model_name=model_name,
1340                         new_name=new_index_name,
1341                         old_name=old_index_name,
1342                         old_fields=old_fields,
1343                     ),
1344                 )
1345 
1346     def create_altered_constraints(self):
1347         option_name = operations.AddConstraint.option_name
1348         for app_label, model_name in sorted(self.kept_model_keys):
1349             old_model_name = self.renamed_models.get(
1350                 (app_label, model_name), model_name
1351             )
1352             old_model_state = self.from_state.models[app_label, old_model_name]
1353             new_model_state = self.to_state.models[app_label, model_name]
1354 
1355             old_constraints = old_model_state.options[option_name]
1356             new_constraints = new_model_state.options[option_name]
1357             add_constraints = [c for c in new_constraints if c not in old_constraints]
1358             rem_constraints = [c for c in old_constraints if c not in new_constraints]
1359 
1360             self.altered_constraints.update(
1361                 {
1362                     (app_label, model_name): {
1363                         "added_constraints": add_constraints,
1364                         "removed_constraints": rem_constraints,
1365                     }
1366                 }
1367             )
1368 
1369     def generate_added_constraints(self):
1370         for (
1371             app_label,
1372             model_name,
1373         ), alt_constraints in self.altered_constraints.items():
1374             for constraint in alt_constraints["added_constraints"]:
1375                 self.add_operation(
1376                     app_label,
1377                     operations.AddConstraint(
1378                         model_name=model_name,
1379                         constraint=constraint,
1380                     ),
1381                 )
1382 
1383     def generate_removed_constraints(self):
1384         for (
1385             app_label,
1386             model_name,
1387         ), alt_constraints in self.altered_constraints.items():
1388             for constraint in alt_constraints["removed_constraints"]:
1389                 self.add_operation(
1390                     app_label,
1391                     operations.RemoveConstraint(
1392                         model_name=model_name,
1393                         name=constraint.name,
1394                     ),
1395                 )
1396 
1397     @staticmethod
1398     def _get_dependencies_for_foreign_key(app_label, model_name, field, project_state):
1399         remote_field_model = None
1400         if hasattr(field.remote_field, "model"):
1401             remote_field_model = field.remote_field.model
1402         else:
1403             relations = project_state.relations[app_label, model_name]
1404             for (remote_app_label, remote_model_name), fields in relations.items():
1405                 if any(
1406                     field == related_field.remote_field
1407                     for related_field in fields.values()
1408                 ):
1409                     remote_field_model = f"{remote_app_label}.{remote_model_name}"
1410                     break
1411         # Account for FKs to swappable models
1412         swappable_setting = getattr(field, "swappable_setting", None)
1413         if swappable_setting is not None:
1414             dep_app_label = "__setting__"
1415             dep_object_name = swappable_setting
1416         else:
1417             dep_app_label, dep_object_name = resolve_relation(
1418                 remote_field_model,
1419                 app_label,
1420                 model_name,
1421             )
1422         dependencies = [(dep_app_label, dep_object_name, None, True)]
1423         if getattr(field.remote_field, "through", None):
1424             through_app_label, through_object_name = resolve_relation(
1425                 field.remote_field.through,
1426                 app_label,
1427                 model_name,
1428             )
1429             dependencies.append((through_app_label, through_object_name, None, True))
1430         return dependencies
1431 
1432     def _get_altered_foo_together_operations(self, option_name):
1433         for app_label, model_name in sorted(self.kept_model_keys):
1434             old_model_name = self.renamed_models.get(
1435                 (app_label, model_name), model_name
1436             )
1437             old_model_state = self.from_state.models[app_label, old_model_name]
1438             new_model_state = self.to_state.models[app_label, model_name]
1439 
1440             # We run the old version through the field renames to account for those
1441             old_value = old_model_state.options.get(option_name)
1442             old_value = (
1443                 {
1444                     tuple(
1445                         self.renamed_fields.get((app_label, model_name, n), n)
1446                         for n in unique
1447                     )
1448                     for unique in old_value
1449                 }
1450                 if old_value
1451                 else set()
1452             )
1453 
1454             new_value = new_model_state.options.get(option_name)
1455             new_value = set(new_value) if new_value else set()
1456 
1457             if old_value != new_value:
1458                 dependencies = []
1459                 for foo_togethers in new_value:
1460                     for field_name in foo_togethers:
1461                         field = new_model_state.get_field(field_name)
1462                         if field.remote_field and field.remote_field.model:
1463                             dependencies.extend(
1464                                 self._get_dependencies_for_foreign_key(
1465                                     app_label,
1466                                     model_name,
1467                                     field,
1468                                     self.to_state,
1469                                 )
1470                             )
1471                 yield (
1472                     old_value,
1473                     new_value,
1474                     app_label,
1475                     model_name,
1476                     dependencies,
1477                 )
1478 
1479     def _generate_removed_altered_foo_together(self, operation):
1480         for (
1481             old_value,
1482             new_value,
1483             app_label,
1484             model_name,
1485             dependencies,
1486         ) in self._get_altered_foo_together_operations(operation.option_name):
1487             if operation == operations.AlterIndexTogether:
1488                 old_value = {
1489                     value
1490                     for value in old_value
1491                     if value
1492                     not in self.renamed_index_together_values[app_label, model_name]
1493                 }
1494             removal_value = new_value.intersection(old_value)
1495             if removal_value or old_value:
1496                 self.add_operation(
1497                     app_label,
1498                     operation(
1499                         name=model_name, **{operation.option_name: removal_value}
1500                     ),
1501                     dependencies=dependencies,
1502                 )
1503 
1504     def generate_removed_altered_unique_together(self):
1505         self._generate_removed_altered_foo_together(operations.AlterUniqueTogether)
1506 
1507     # RemovedInDjango51Warning.
1508     def generate_removed_altered_index_together(self):
1509         self._generate_removed_altered_foo_together(operations.AlterIndexTogether)
1510 
1511     def _generate_altered_foo_together(self, operation):
1512         for (
1513             old_value,
1514             new_value,
1515             app_label,
1516             model_name,
1517             dependencies,
1518         ) in self._get_altered_foo_together_operations(operation.option_name):
1519             removal_value = new_value.intersection(old_value)
1520             if new_value != removal_value:
1521                 self.add_operation(
1522                     app_label,
1523                     operation(name=model_name, **{operation.option_name: new_value}),
1524                     dependencies=dependencies,
1525                 )
1526 
1527     def generate_altered_unique_together(self):
1528         self._generate_altered_foo_together(operations.AlterUniqueTogether)
1529 
1530     # RemovedInDjango51Warning.
1531     def generate_altered_index_together(self):
1532         self._generate_altered_foo_together(operations.AlterIndexTogether)
1533 
1534     def generate_altered_db_table(self):
1535         models_to_check = self.kept_model_keys.union(
1536             self.kept_proxy_keys, self.kept_unmanaged_keys
1537         )
1538         for app_label, model_name in sorted(models_to_check):
1539             old_model_name = self.renamed_models.get(
1540                 (app_label, model_name), model_name
1541             )
1542             old_model_state = self.from_state.models[app_label, old_model_name]
1543             new_model_state = self.to_state.models[app_label, model_name]
1544             old_db_table_name = old_model_state.options.get("db_table")
1545             new_db_table_name = new_model_state.options.get("db_table")
1546             if old_db_table_name != new_db_table_name:
1547                 self.add_operation(
1548                     app_label,
1549                     operations.AlterModelTable(
1550                         name=model_name,
1551                         table=new_db_table_name,
1552                     ),
1553                 )
1554 
1555     def generate_altered_options(self):
1556         """
1557         Work out if any non-schema-affecting options have changed and make an
1558         operation to represent them in state changes (in case Python code in
1559         migrations needs them).
1560         """
1561         models_to_check = self.kept_model_keys.union(
1562             self.kept_proxy_keys,
1563             self.kept_unmanaged_keys,
1564             # unmanaged converted to managed
1565             self.old_unmanaged_keys & self.new_model_keys,
1566             # managed converted to unmanaged
1567             self.old_model_keys & self.new_unmanaged_keys,
1568         )
1569 
1570         for app_label, model_name in sorted(models_to_check):
1571             old_model_name = self.renamed_models.get(
1572                 (app_label, model_name), model_name
1573             )
1574             old_model_state = self.from_state.models[app_label, old_model_name]
1575             new_model_state = self.to_state.models[app_label, model_name]
1576             old_options = {
1577                 key: value
1578                 for key, value in old_model_state.options.items()
1579                 if key in AlterModelOptions.ALTER_OPTION_KEYS
1580             }
1581             new_options = {
1582                 key: value
1583                 for key, value in new_model_state.options.items()
1584                 if key in AlterModelOptions.ALTER_OPTION_KEYS
1585             }
1586             if old_options != new_options:
1587                 self.add_operation(
1588                     app_label,
1589                     operations.AlterModelOptions(
1590                         name=model_name,
1591                         options=new_options,
1592                     ),
1593                 )
1594 
1595     def generate_altered_order_with_respect_to(self):
1596         for app_label, model_name in sorted(self.kept_model_keys):
1597             old_model_name = self.renamed_models.get(
1598                 (app_label, model_name), model_name
1599             )
1600             old_model_state = self.from_state.models[app_label, old_model_name]
1601             new_model_state = self.to_state.models[app_label, model_name]
1602             if old_model_state.options.get(
1603                 "order_with_respect_to"
1604             ) != new_model_state.options.get("order_with_respect_to"):
1605                 # Make sure it comes second if we're adding
1606                 # (removal dependency is part of RemoveField)
1607                 dependencies = []
1608                 if new_model_state.options.get("order_with_respect_to"):
1609                     dependencies.append(
1610                         (
1611                             app_label,
1612                             model_name,
1613                             new_model_state.options["order_with_respect_to"],
1614                             True,
1615                         )
1616                     )
1617                 # Actually generate the operation
1618                 self.add_operation(
1619                     app_label,
1620                     operations.AlterOrderWithRespectTo(
1621                         name=model_name,
1622                         order_with_respect_to=new_model_state.options.get(
1623                             "order_with_respect_to"
1624                         ),
1625                     ),
1626                     dependencies=dependencies,
1627                 )
1628 
1629     def generate_altered_managers(self):
1630         for app_label, model_name in sorted(self.kept_model_keys):
1631             old_model_name = self.renamed_models.get(
1632                 (app_label, model_name), model_name
1633             )
1634             old_model_state = self.from_state.models[app_label, old_model_name]
1635             new_model_state = self.to_state.models[app_label, model_name]
1636             if old_model_state.managers != new_model_state.managers:
1637                 self.add_operation(
1638                     app_label,
1639                     operations.AlterModelManagers(
1640                         name=model_name,
1641                         managers=new_model_state.managers,
1642                     ),
1643                 )
1644 
1645     def arrange_for_graph(self, changes, graph, migration_name=None):
1646         """
1647         Take a result from changes() and a MigrationGraph, and fix the names
1648         and dependencies of the changes so they extend the graph from the leaf
1649         nodes for each app.
1650         """
1651         leaves = graph.leaf_nodes()
1652         name_map = {}
1653         for app_label, migrations in list(changes.items()):
1654             if not migrations:
1655                 continue
1656             # Find the app label's current leaf node
1657             app_leaf = None
1658             for leaf in leaves:
1659                 if leaf[0] == app_label:
1660                     app_leaf = leaf
1661                     break
1662             # Do they want an initial migration for this app?
1663             if app_leaf is None and not self.questioner.ask_initial(app_label):
1664                 # They don't.
1665                 for migration in migrations:
1666                     name_map[(app_label, migration.name)] = (app_label, "__first__")
1667                 del changes[app_label]
1668                 continue
1669             # Work out the next number in the sequence
1670             if app_leaf is None:
1671                 next_number = 1
1672             else:
1673                 next_number = (self.parse_number(app_leaf[1]) or 0) + 1
1674             # Name each migration
1675             for i, migration in enumerate(migrations):
1676                 if i == 0 and app_leaf:
1677                     migration.dependencies.append(app_leaf)
1678                 new_name_parts = ["%04i" % next_number]
1679                 if migration_name:
1680                     new_name_parts.append(migration_name)
1681                 elif i == 0 and not app_leaf:
1682                     new_name_parts.append("initial")
1683                 else:
1684                     new_name_parts.append(migration.suggest_name()[:100])
1685                 new_name = "_".join(new_name_parts)
1686                 name_map[(app_label, migration.name)] = (app_label, new_name)
1687                 next_number += 1
1688                 migration.name = new_name
1689         # Now fix dependencies
1690         for migrations in changes.values():
1691             for migration in migrations:
1692                 migration.dependencies = [
1693                     name_map.get(d, d) for d in migration.dependencies
1694                 ]
1695         return changes
1696 
1697     def _trim_to_apps(self, changes, app_labels):
1698         """
1699         Take changes from arrange_for_graph() and set of app labels, and return
1700         a modified set of changes which trims out as many migrations that are
1701         not in app_labels as possible. Note that some other migrations may
1702         still be present as they may be required dependencies.
1703         """
1704         # Gather other app dependencies in a first pass
1705         app_dependencies = {}
1706         for app_label, migrations in changes.items():
1707             for migration in migrations:
1708                 for dep_app_label, name in migration.dependencies:
1709                     app_dependencies.setdefault(app_label, set()).add(dep_app_label)
1710         required_apps = set(app_labels)
1711         # Keep resolving till there's no change
1712         old_required_apps = None
1713         while old_required_apps != required_apps:
1714             old_required_apps = set(required_apps)
1715             required_apps.update(
1716                 *[app_dependencies.get(app_label, ()) for app_label in required_apps]
1717             )
1718         # Remove all migrations that aren't needed
1719         for app_label in list(changes):
1720             if app_label not in required_apps:
1721                 del changes[app_label]
1722         return changes
1723 
1724     @classmethod
1725     def parse_number(cls, name):
1726         """
1727         Given a migration name, try to extract a number from the beginning of
1728         it. For a squashed migration such as '0001_squashed_0004', return the
1729         second number. If no number is found, return None.
1730         """
1731         if squashed_match := re.search(r".*_squashed_(\d+)", name):
1732             return int(squashed_match[1])
1733         match = re.match(r"^\d+", name)
1734         if match:
1735             return int(match[0])
1736         return None

</code><intended_behavior>Enhance detection logic for `ManyToManyField` when its target changes, especially to 'self'. Ensure that the autodetector generates accurate migration operations that reflect complex changes in field relationships, such as changes in target models or the introduction of self-referencing relations.</intended_behavior>, <file>django/db/migrations/operations/fields.py</file>
<class>None</class>
<method>None</method>
<code>
1 from django.db.migrations.utils import field_references
2 from django.db.models import NOT_PROVIDED
3 from django.utils.functional import cached_property
4 
5 from .base import Operation
6 
7 
8 class FieldOperation(Operation):
9     def __init__(self, model_name, name, field=None):
10         self.model_name = model_name
11         self.name = name
12         self.field = field
13 
14     @cached_property
15     def model_name_lower(self):
16         return self.model_name.lower()
17 
18     @cached_property
19     def name_lower(self):
20         return self.name.lower()
21 
22     def is_same_model_operation(self, operation):
23         return self.model_name_lower == operation.model_name_lower
24 
25     def is_same_field_operation(self, operation):
26         return (
27             self.is_same_model_operation(operation)
28             and self.name_lower == operation.name_lower
29         )
30 
31     def references_model(self, name, app_label):
32         name_lower = name.lower()
33         if name_lower == self.model_name_lower:
34             return True
35         if self.field:
36             return bool(
37                 field_references(
38                     (app_label, self.model_name_lower),
39                     self.field,
40                     (app_label, name_lower),
41                 )
42             )
43         return False
44 
45     def references_field(self, model_name, name, app_label):
46         model_name_lower = model_name.lower()
47         # Check if this operation locally references the field.
48         if model_name_lower == self.model_name_lower:
49             if name == self.name:
50                 return True
51             elif (
52                 self.field
53                 and hasattr(self.field, "from_fields")
54                 and name in self.field.from_fields
55             ):
56                 return True
57         # Check if this operation remotely references the field.
58         if self.field is None:
59             return False
60         return bool(
61             field_references(
62                 (app_label, self.model_name_lower),
63                 self.field,
64                 (app_label, model_name_lower),
65                 name,
66             )
67         )
68 
69     def reduce(self, operation, app_label):
70         return super().reduce(operation, app_label) or not operation.references_field(
71             self.model_name, self.name, app_label
72         )
73 
74 
75 class AddField(FieldOperation):
76     """Add a field to a model."""
77 
78     def __init__(self, model_name, name, field, preserve_default=True):
79         self.preserve_default = preserve_default
80         super().__init__(model_name, name, field)
81 
82     def deconstruct(self):
83         kwargs = {
84             "model_name": self.model_name,
85             "name": self.name,
86             "field": self.field,
87         }
88         if self.preserve_default is not True:
89             kwargs["preserve_default"] = self.preserve_default
90         return (self.__class__.__name__, [], kwargs)
91 
92     def state_forwards(self, app_label, state):
93         state.add_field(
94             app_label,
95             self.model_name_lower,
96             self.name,
97             self.field,
98             self.preserve_default,
99         )
100 
101     def database_forwards(self, app_label, schema_editor, from_state, to_state):
102         to_model = to_state.apps.get_model(app_label, self.model_name)
103         if self.allow_migrate_model(schema_editor.connection.alias, to_model):
104             from_model = from_state.apps.get_model(app_label, self.model_name)
105             field = to_model._meta.get_field(self.name)
106             if not self.preserve_default:
107                 field.default = self.field.default
108             schema_editor.add_field(
109                 from_model,
110                 field,
111             )
112             if not self.preserve_default:
113                 field.default = NOT_PROVIDED
114 
115     def database_backwards(self, app_label, schema_editor, from_state, to_state):
116         from_model = from_state.apps.get_model(app_label, self.model_name)
117         if self.allow_migrate_model(schema_editor.connection.alias, from_model):
118             schema_editor.remove_field(
119                 from_model, from_model._meta.get_field(self.name)
120             )
121 
122     def describe(self):
123         return "Add field %s to %s" % (self.name, self.model_name)
124 
125     @property
126     def migration_name_fragment(self):
127         return "%s_%s" % (self.model_name_lower, self.name_lower)
128 
129     def reduce(self, operation, app_label):
130         if isinstance(operation, FieldOperation) and self.is_same_field_operation(
131             operation
132         ):
133             if isinstance(operation, AlterField):
134                 return [
135                     AddField(
136                         model_name=self.model_name,
137                         name=operation.name,
138                         field=operation.field,
139                     ),
140                 ]
141             elif isinstance(operation, RemoveField):
142                 return []
143             elif isinstance(operation, RenameField):
144                 return [
145                     AddField(
146                         model_name=self.model_name,
147                         name=operation.new_name,
148                         field=self.field,
149                     ),
150                 ]
151         return super().reduce(operation, app_label)
152 
153 
154 class RemoveField(FieldOperation):
155     """Remove a field from a model."""
156 
157     def deconstruct(self):
158         kwargs = {
159             "model_name": self.model_name,
160             "name": self.name,
161         }
162         return (self.__class__.__name__, [], kwargs)
163 
164     def state_forwards(self, app_label, state):
165         state.remove_field(app_label, self.model_name_lower, self.name)
166 
167     def database_forwards(self, app_label, schema_editor, from_state, to_state):
168         from_model = from_state.apps.get_model(app_label, self.model_name)
169         if self.allow_migrate_model(schema_editor.connection.alias, from_model):
170             schema_editor.remove_field(
171                 from_model, from_model._meta.get_field(self.name)
172             )
173 
174     def database_backwards(self, app_label, schema_editor, from_state, to_state):
175         to_model = to_state.apps.get_model(app_label, self.model_name)
176         if self.allow_migrate_model(schema_editor.connection.alias, to_model):
177             from_model = from_state.apps.get_model(app_label, self.model_name)
178             schema_editor.add_field(from_model, to_model._meta.get_field(self.name))
179 
180     def describe(self):
181         return "Remove field %s from %s" % (self.name, self.model_name)
182 
183     @property
184     def migration_name_fragment(self):
185         return "remove_%s_%s" % (self.model_name_lower, self.name_lower)
186 
187     def reduce(self, operation, app_label):
188         from .models import DeleteModel
189 
190         if (
191             isinstance(operation, DeleteModel)
192             and operation.name_lower == self.model_name_lower
193         ):
194             return [operation]
195         return super().reduce(operation, app_label)
196 
197 
198 class AlterField(FieldOperation):
199     """
200     Alter a field's database column (e.g. null, max_length) to the provided
201     new field.
202     """
203 
204     def __init__(self, model_name, name, field, preserve_default=True):
205         self.preserve_default = preserve_default
206         super().__init__(model_name, name, field)
207 
208     def deconstruct(self):
209         kwargs = {
210             "model_name": self.model_name,
211             "name": self.name,
212             "field": self.field,
213         }
214         if self.preserve_default is not True:
215             kwargs["preserve_default"] = self.preserve_default
216         return (self.__class__.__name__, [], kwargs)
217 
218     def state_forwards(self, app_label, state):
219         state.alter_field(
220             app_label,
221             self.model_name_lower,
222             self.name,
223             self.field,
224             self.preserve_default,
225         )
226 
227     def database_forwards(self, app_label, schema_editor, from_state, to_state):
228         to_model = to_state.apps.get_model(app_label, self.model_name)
229         if self.allow_migrate_model(schema_editor.connection.alias, to_model):
230             from_model = from_state.apps.get_model(app_label, self.model_name)
231             from_field = from_model._meta.get_field(self.name)
232             to_field = to_model._meta.get_field(self.name)
233             if not self.preserve_default:
234                 to_field.default = self.field.default
235             schema_editor.alter_field(from_model, from_field, to_field)
236             if not self.preserve_default:
237                 to_field.default = NOT_PROVIDED
238 
239     def database_backwards(self, app_label, schema_editor, from_state, to_state):
240         self.database_forwards(app_label, schema_editor, from_state, to_state)
241 
242     def describe(self):
243         return "Alter field %s on %s" % (self.name, self.model_name)
244 
245     @property
246     def migration_name_fragment(self):
247         return "alter_%s_%s" % (self.model_name_lower, self.name_lower)
248 
249     def reduce(self, operation, app_label):
250         if isinstance(operation, RemoveField) and self.is_same_field_operation(
251             operation
252         ):
253             return [operation]
254         elif (
255             isinstance(operation, RenameField)
256             and self.is_same_field_operation(operation)
257             and self.field.db_column is None
258         ):
259             return [
260                 operation,
261                 AlterField(
262                     model_name=self.model_name,
263                     name=operation.new_name,
264                     field=self.field,
265                 ),
266             ]
267         return super().reduce(operation, app_label)
268 
269 
270 class RenameField(FieldOperation):
271     """Rename a field on the model. Might affect db_column too."""
272 
273     def __init__(self, model_name, old_name, new_name):
274         self.old_name = old_name
275         self.new_name = new_name
276         super().__init__(model_name, old_name)
277 
278     @cached_property
279     def old_name_lower(self):
280         return self.old_name.lower()
281 
282     @cached_property
283     def new_name_lower(self):
284         return self.new_name.lower()
285 
286     def deconstruct(self):
287         kwargs = {
288             "model_name": self.model_name,
289             "old_name": self.old_name,
290             "new_name": self.new_name,
291         }
292         return (self.__class__.__name__, [], kwargs)
293 
294     def state_forwards(self, app_label, state):
295         state.rename_field(
296             app_label, self.model_name_lower, self.old_name, self.new_name
297         )
298 
299     def database_forwards(self, app_label, schema_editor, from_state, to_state):
300         to_model = to_state.apps.get_model(app_label, self.model_name)
301         if self.allow_migrate_model(schema_editor.connection.alias, to_model):
302             from_model = from_state.apps.get_model(app_label, self.model_name)
303             schema_editor.alter_field(
304                 from_model,
305                 from_model._meta.get_field(self.old_name),
306                 to_model._meta.get_field(self.new_name),
307             )
308 
309     def database_backwards(self, app_label, schema_editor, from_state, to_state):
310         to_model = to_state.apps.get_model(app_label, self.model_name)
311         if self.allow_migrate_model(schema_editor.connection.alias, to_model):
312             from_model = from_state.apps.get_model(app_label, self.model_name)
313             schema_editor.alter_field(
314                 from_model,
315                 from_model._meta.get_field(self.new_name),
316                 to_model._meta.get_field(self.old_name),
317             )
318 
319     def describe(self):
320         return "Rename field %s on %s to %s" % (
321             self.old_name,
322             self.model_name,
323             self.new_name,
324         )
325 
326     @property
327     def migration_name_fragment(self):
328         return "rename_%s_%s_%s" % (
329             self.old_name_lower,
330             self.model_name_lower,
331             self.new_name_lower,
332         )
333 
334     def references_field(self, model_name, name, app_label):
335         return self.references_model(model_name, app_label) and (
336             name.lower() == self.old_name_lower or name.lower() == self.new_name_lower
337         )
338 
339     def reduce(self, operation, app_label):
340         if (
341             isinstance(operation, RenameField)
342             and self.is_same_model_operation(operation)
343             and self.new_name_lower == operation.old_name_lower
344         ):
345             return [
346                 RenameField(
347                     self.model_name,
348                     self.old_name,
349                     operation.new_name,
350                 ),
351             ]
352         # Skip `FieldOperation.reduce` as we want to run `references_field`
353         # against self.old_name and self.new_name.
354         return super(FieldOperation, self).reduce(operation, app_label) or not (
355             operation.references_field(self.model_name, self.old_name, app_label)
356             or operation.references_field(self.model_name, self.new_name, app_label)
357         )

</code><intended_behavior>Incorporate logic to handle the special case where a `ManyToManyField` is altered to target 'self', ensuring the correct intermediary table schema is generated and existing references are updated or maintained properly. Ensure that both `AddField` and `AlterField` operations accurately apply schema changes for self-referencing many-to-many relationships.</intended_behavior>, <file>django/db/models/fields/related.py</file>
<class>None</class>
<method>None</method>
<code>
1 import functools
2 import inspect
3 from functools import partial
4 
5 from django import forms
6 from django.apps import apps
7 from django.conf import SettingsReference, settings
8 from django.core import checks, exceptions
9 from django.db import connection, router
10 from django.db.backends import utils
11 from django.db.models import Q
12 from django.db.models.constants import LOOKUP_SEP
13 from django.db.models.deletion import CASCADE, SET_DEFAULT, SET_NULL
14 from django.db.models.query_utils import PathInfo
15 from django.db.models.utils import make_model_tuple
16 from django.utils.functional import cached_property
17 from django.utils.translation import gettext_lazy as _
18 
19 from . import Field
20 from .mixins import FieldCacheMixin
21 from .related_descriptors import (
22     ForeignKeyDeferredAttribute,
23     ForwardManyToOneDescriptor,
24     ForwardOneToOneDescriptor,
25     ManyToManyDescriptor,
26     ReverseManyToOneDescriptor,
27     ReverseOneToOneDescriptor,
28 )
29 from .related_lookups import (
30     RelatedExact,
31     RelatedGreaterThan,
32     RelatedGreaterThanOrEqual,
33     RelatedIn,
34     RelatedIsNull,
35     RelatedLessThan,
36     RelatedLessThanOrEqual,
37 )
38 from .reverse_related import ForeignObjectRel, ManyToManyRel, ManyToOneRel, OneToOneRel
39 
40 RECURSIVE_RELATIONSHIP_CONSTANT = "self"
41 
42 
43 def resolve_relation(scope_model, relation):
44     """
45     Transform relation into a model or fully-qualified model string of the form
46     "app_label.ModelName", relative to scope_model.
47 
48     The relation argument can be:
49       * RECURSIVE_RELATIONSHIP_CONSTANT, i.e. the string "self", in which case
50         the model argument will be returned.
51       * A bare model name without an app_label, in which case scope_model's
52         app_label will be prepended.
53       * An "app_label.ModelName" string.
54       * A model class, which will be returned unchanged.
55     """
56     # Check for recursive relations
57     if relation == RECURSIVE_RELATIONSHIP_CONSTANT:
58         relation = scope_model
59 
60     # Look for an "app.Model" relation
61     if isinstance(relation, str):
62         if "." not in relation:
63             relation = "%s.%s" % (scope_model._meta.app_label, relation)
64 
65     return relation
66 
67 
68 def lazy_related_operation(function, model, *related_models, **kwargs):
69     """
70     Schedule `function` to be called once `model` and all `related_models`
71     have been imported and registered with the app registry. `function` will
72     be called with the newly-loaded model classes as its positional arguments,
73     plus any optional keyword arguments.
74 
75     The `model` argument must be a model class. Each subsequent positional
76     argument is another model, or a reference to another model - see
77     `resolve_relation()` for the various forms these may take. Any relative
78     references will be resolved relative to `model`.
79 
80     This is a convenience wrapper for `Apps.lazy_model_operation` - the app
81     registry model used is the one found in `model._meta.apps`.
82     """
83     models = [model] + [resolve_relation(model, rel) for rel in related_models]
84     model_keys = (make_model_tuple(m) for m in models)
85     apps = model._meta.apps
86     return apps.lazy_model_operation(partial(function, **kwargs), *model_keys)
87 
88 
89 class RelatedField(FieldCacheMixin, Field):
90     """Base class that all relational fields inherit from."""
91 
92     # Field flags
93     one_to_many = False
94     one_to_one = False
95     many_to_many = False
96     many_to_one = False
97 
98     def __init__(
99         self,
100         related_name=None,
101         related_query_name=None,
102         limit_choices_to=None,
103         **kwargs,
104     ):
105         self._related_name = related_name
106         self._related_query_name = related_query_name
107         self._limit_choices_to = limit_choices_to
108         super().__init__(**kwargs)
109 
110     @cached_property
111     def related_model(self):
112         # Can't cache this property until all the models are loaded.
113         apps.check_models_ready()
114         return self.remote_field.model
115 
116     def check(self, **kwargs):
117         return [
118             *super().check(**kwargs),
119             *self._check_related_name_is_valid(),
120             *self._check_related_query_name_is_valid(),
121             *self._check_relation_model_exists(),
122             *self._check_referencing_to_swapped_model(),
123             *self._check_clashes(),
124         ]
125 
126     def _check_related_name_is_valid(self):
127         import keyword
128 
129         related_name = self.remote_field.related_name
130         if related_name is None:
131             return []
132         is_valid_id = (
133             not keyword.iskeyword(related_name) and related_name.isidentifier()
134         )
135         if not (is_valid_id or related_name.endswith("+")):
136             return [
137                 checks.Error(
138                     "The name '%s' is invalid related_name for field %s.%s"
139                     % (
140                         self.remote_field.related_name,
141                         self.model._meta.object_name,
142                         self.name,
143                     ),
144                     hint=(
145                         "Related name must be a valid Python identifier or end with a "
146                         "'+'"
147                     ),
148                     obj=self,
149                     id="fields.E306",
150                 )
151             ]
152         return []
153 
154     def _check_related_query_name_is_valid(self):
155         if self.remote_field.is_hidden():
156             return []
157         rel_query_name = self.related_query_name()
158         errors = []
159         if rel_query_name.endswith("_"):
160             errors.append(
161                 checks.Error(
162                     "Reverse query name '%s' must not end with an underscore."
163                     % rel_query_name,
164                     hint=(
165                         "Add or change a related_name or related_query_name "
166                         "argument for this field."
167                     ),
168                     obj=self,
169                     id="fields.E308",
170                 )
171             )
172         if LOOKUP_SEP in rel_query_name:
173             errors.append(
174                 checks.Error(
175                     "Reverse query name '%s' must not contain '%s'."
176                     % (rel_query_name, LOOKUP_SEP),
177                     hint=(
178                         "Add or change a related_name or related_query_name "
179                         "argument for this field."
180                     ),
181                     obj=self,
182                     id="fields.E309",
183                 )
184             )
185         return errors
186 
187     def _check_relation_model_exists(self):
188         rel_is_missing = self.remote_field.model not in self.opts.apps.get_models()
189         rel_is_string = isinstance(self.remote_field.model, str)
190         model_name = (
191             self.remote_field.model
192             if rel_is_string
193             else self.remote_field.model._meta.object_name
194         )
195         if rel_is_missing and (
196             rel_is_string or not self.remote_field.model._meta.swapped
197         ):
198             return [
199                 checks.Error(
200                     "Field defines a relation with model '%s', which is either "
201                     "not installed, or is abstract." % model_name,
202                     obj=self,
203                     id="fields.E300",
204                 )
205             ]
206         return []
207 
208     def _check_referencing_to_swapped_model(self):
209         if (
210             self.remote_field.model not in self.opts.apps.get_models()
211             and not isinstance(self.remote_field.model, str)
212             and self.remote_field.model._meta.swapped
213         ):
214             return [
215                 checks.Error(
216                     "Field defines a relation with the model '%s', which has "
217                     "been swapped out." % self.remote_field.model._meta.label,
218                     hint="Update the relation to point at 'settings.%s'."
219                     % self.remote_field.model._meta.swappable,
220                     obj=self,
221                     id="fields.E301",
222                 )
223             ]
224         return []
225 
226     def _check_clashes(self):
227         """Check accessor and reverse query name clashes."""
228         from django.db.models.base import ModelBase
229 
230         errors = []
231         opts = self.model._meta
232 
233         # f.remote_field.model may be a string instead of a model. Skip if
234         # model name is not resolved.
235         if not isinstance(self.remote_field.model, ModelBase):
236             return []
237 
238         # Consider that we are checking field `Model.foreign` and the models
239         # are:
240         #
241         #     class Target(models.Model):
242         #         model = models.IntegerField()
243         #         model_set = models.IntegerField()
244         #
245         #     class Model(models.Model):
246         #         foreign = models.ForeignKey(Target)
247         #         m2m = models.ManyToManyField(Target)
248 
249         # rel_opts.object_name == "Target"
250         rel_opts = self.remote_field.model._meta
251         # If the field doesn't install a backward relation on the target model
252         # (so `is_hidden` returns True), then there are no clashes to check
253         # and we can skip these fields.
254         rel_is_hidden = self.remote_field.is_hidden()
255         rel_name = self.remote_field.get_accessor_name()  # i. e. "model_set"
256         rel_query_name = self.related_query_name()  # i. e. "model"
257         # i.e. "app_label.Model.field".
258         field_name = "%s.%s" % (opts.label, self.name)
259 
260         # Check clashes between accessor or reverse query name of `field`
261         # and any other field name -- i.e. accessor for Model.foreign is
262         # model_set and it clashes with Target.model_set.
263         potential_clashes = rel_opts.fields + rel_opts.many_to_many
264         for clash_field in potential_clashes:
265             # i.e. "app_label.Target.model_set".
266             clash_name = "%s.%s" % (rel_opts.label, clash_field.name)
267             if not rel_is_hidden and clash_field.name == rel_name:
268                 errors.append(
269                     checks.Error(
270                         f"Reverse accessor '{rel_opts.object_name}.{rel_name}' "
271                         f"for '{field_name}' clashes with field name "
272                         f"'{clash_name}'.",
273                         hint=(
274                             "Rename field '%s', or add/change a related_name "
275                             "argument to the definition for field '%s'."
276                         )
277                         % (clash_name, field_name),
278                         obj=self,
279                         id="fields.E302",
280                     )
281                 )
282 
283             if clash_field.name == rel_query_name:
284                 errors.append(
285                     checks.Error(
286                         "Reverse query name for '%s' clashes with field name '%s'."
287                         % (field_name, clash_name),
288                         hint=(
289                             "Rename field '%s', or add/change a related_name "
290                             "argument to the definition for field '%s'."
291                         )
292                         % (clash_name, field_name),
293                         obj=self,
294                         id="fields.E303",
295                     )
296                 )
297 
298         # Check clashes between accessors/reverse query names of `field` and
299         # any other field accessor -- i. e. Model.foreign accessor clashes with
300         # Model.m2m accessor.
301         potential_clashes = (r for r in rel_opts.related_objects if r.field is not self)
302         for clash_field in potential_clashes:
303             # i.e. "app_label.Model.m2m".
304             clash_name = "%s.%s" % (
305                 clash_field.related_model._meta.label,
306                 clash_field.field.name,
307             )
308             if not rel_is_hidden and clash_field.get_accessor_name() == rel_name:
309                 errors.append(
310                     checks.Error(
311                         f"Reverse accessor '{rel_opts.object_name}.{rel_name}' "
312                         f"for '{field_name}' clashes with reverse accessor for "
313                         f"'{clash_name}'.",
314                         hint=(
315                             "Add or change a related_name argument "
316                             "to the definition for '%s' or '%s'."
317                         )
318                         % (field_name, clash_name),
319                         obj=self,
320                         id="fields.E304",
321                     )
322                 )
323 
324             if clash_field.get_accessor_name() == rel_query_name:
325                 errors.append(
326                     checks.Error(
327                         "Reverse query name for '%s' clashes with reverse query name "
328                         "for '%s'." % (field_name, clash_name),
329                         hint=(
330                             "Add or change a related_name argument "
331                             "to the definition for '%s' or '%s'."
332                         )
333                         % (field_name, clash_name),
334                         obj=self,
335                         id="fields.E305",
336                     )
337                 )
338 
339         return errors
340 
341     def db_type(self, connection):
342         # By default related field will not have a column as it relates to
343         # columns from another table.
344         return None
345 
346     def contribute_to_class(self, cls, name, private_only=False, **kwargs):
347 
348         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)
349 
350         self.opts = cls._meta
351 
352         if not cls._meta.abstract:
353             if self.remote_field.related_name:
354                 related_name = self.remote_field.related_name
355             else:
356                 related_name = self.opts.default_related_name
357             if related_name:
358                 related_name %= {
359                     "class": cls.__name__.lower(),
360                     "model_name": cls._meta.model_name.lower(),
361                     "app_label": cls._meta.app_label.lower(),
362                 }
363                 self.remote_field.related_name = related_name
364 
365             if self.remote_field.related_query_name:
366                 related_query_name = self.remote_field.related_query_name % {
367                     "class": cls.__name__.lower(),
368                     "app_label": cls._meta.app_label.lower(),
369                 }
370                 self.remote_field.related_query_name = related_query_name
371 
372             def resolve_related_class(model, related, field):
373                 field.remote_field.model = related
374                 field.do_related_class(related, model)
375 
376             lazy_related_operation(
377                 resolve_related_class, cls, self.remote_field.model, field=self
378             )
379 
380     def deconstruct(self):
381         name, path, args, kwargs = super().deconstruct()
382         if self._limit_choices_to:
383             kwargs["limit_choices_to"] = self._limit_choices_to
384         if self._related_name is not None:
385             kwargs["related_name"] = self._related_name
386         if self._related_query_name is not None:
387             kwargs["related_query_name"] = self._related_query_name
388         return name, path, args, kwargs
389 
390     def get_forward_related_filter(self, obj):
391         """
392         Return the keyword arguments that when supplied to
393         self.model.object.filter(), would select all instances related through
394         this field to the remote obj. This is used to build the querysets
395         returned by related descriptors. obj is an instance of
396         self.related_field.model.
397         """
398         return {
399             "%s__%s" % (self.name, rh_field.name): getattr(obj, rh_field.attname)
400             for _, rh_field in self.related_fields
401         }
402 
403     def get_reverse_related_filter(self, obj):
404         """
405         Complement to get_forward_related_filter(). Return the keyword
406         arguments that when passed to self.related_field.model.object.filter()
407         select all instances of self.related_field.model related through
408         this field to obj. obj is an instance of self.model.
409         """
410         base_q = Q.create(
411             [
412                 (rh_field.attname, getattr(obj, lh_field.attname))
413                 for lh_field, rh_field in self.related_fields
414             ]
415         )
416         descriptor_filter = self.get_extra_descriptor_filter(obj)
417         if isinstance(descriptor_filter, dict):
418             return base_q & Q(**descriptor_filter)
419         elif descriptor_filter:
420             return base_q & descriptor_filter
421         return base_q
422 
423     @property
424     def swappable_setting(self):
425         """
426         Get the setting that this is powered from for swapping, or None
427         if it's not swapped in / marked with swappable=False.
428         """
429         if self.swappable:
430             # Work out string form of "to"
431             if isinstance(self.remote_field.model, str):
432                 to_string = self.remote_field.model
433             else:
434                 to_string = self.remote_field.model._meta.label
435             return apps.get_swappable_settings_name(to_string)
436         return None
437 
438     def set_attributes_from_rel(self):
439         self.name = self.name or (
440             self.remote_field.model._meta.model_name
441             + "_"
442             + self.remote_field.model._meta.pk.name
443         )
444         if self.verbose_name is None:
445             self.verbose_name = self.remote_field.model._meta.verbose_name
446         self.remote_field.set_field_name()
447 
448     def do_related_class(self, other, cls):
449         self.set_attributes_from_rel()
450         self.contribute_to_related_class(other, self.remote_field)
451 
452     def get_limit_choices_to(self):
453         """
454         Return ``limit_choices_to`` for this model field.
455 
456         If it is a callable, it will be invoked and the result will be
457         returned.
458         """
459         if callable(self.remote_field.limit_choices_to):
460             return self.remote_field.limit_choices_to()
461         return self.remote_field.limit_choices_to
462 
463     def formfield(self, **kwargs):
464         """
465         Pass ``limit_choices_to`` to the field being constructed.
466 
467         Only passes it if there is a type that supports related fields.
468         This is a similar strategy used to pass the ``queryset`` to the field
469         being constructed.
470         """
471         defaults = {}
472         if hasattr(self.remote_field, "get_related_field"):
473             # If this is a callable, do not invoke it here. Just pass
474             # it in the defaults for when the form class will later be
475             # instantiated.
476             limit_choices_to = self.remote_field.limit_choices_to
477             defaults.update(
478                 {
479                     "limit_choices_to": limit_choices_to,
480                 }
481             )
482         defaults.update(kwargs)
483         return super().formfield(**defaults)
484 
485     def related_query_name(self):
486         """
487         Define the name that can be used to identify this related object in a
488         table-spanning query.
489         """
490         return (
491             self.remote_field.related_query_name
492             or self.remote_field.related_name
493             or self.opts.model_name
494         )
495 
496     @property
497     def target_field(self):
498         """
499         When filtering against this relation, return the field on the remote
500         model against which the filtering should happen.
501         """
502         target_fields = self.path_infos[-1].target_fields
503         if len(target_fields) > 1:
504             raise exceptions.FieldError(
505                 "The relation has multiple target fields, but only single target field "
506                 "was asked for"
507             )
508         return target_fields[0]
509 
510     def get_cache_name(self):
511         return self.name
512 
513 
514 class ForeignObject(RelatedField):
515     """
516     Abstraction of the ForeignKey relation to support multi-column relations.
517     """
518 
519     # Field flags
520     many_to_many = False
521     many_to_one = True
522     one_to_many = False
523     one_to_one = False
524 
525     requires_unique_target = True
526     related_accessor_class = ReverseManyToOneDescriptor
527     forward_related_accessor_class = ForwardManyToOneDescriptor
528     rel_class = ForeignObjectRel
529 
530     def __init__(
531         self,
532         to,
533         on_delete,
534         from_fields,
535         to_fields,
536         rel=None,
537         related_name=None,
538         related_query_name=None,
539         limit_choices_to=None,
540         parent_link=False,
541         swappable=True,
542         **kwargs,
543     ):
544 
545         if rel is None:
546             rel = self.rel_class(
547                 self,
548                 to,
549                 related_name=related_name,
550                 related_query_name=related_query_name,
551                 limit_choices_to=limit_choices_to,
552                 parent_link=parent_link,
553                 on_delete=on_delete,
554             )
555 
556         super().__init__(
557             rel=rel,
558             related_name=related_name,
559             related_query_name=related_query_name,
560             limit_choices_to=limit_choices_to,
561             **kwargs,
562         )
563 
564         self.from_fields = from_fields
565         self.to_fields = to_fields
566         self.swappable = swappable
567 
568     def __copy__(self):
569         obj = super().__copy__()
570         # Remove any cached PathInfo values.
571         obj.__dict__.pop("path_infos", None)
572         obj.__dict__.pop("reverse_path_infos", None)
573         return obj
574 
575     def check(self, **kwargs):
576         return [
577             *super().check(**kwargs),
578             *self._check_to_fields_exist(),
579             *self._check_unique_target(),
580         ]
581 
582     def _check_to_fields_exist(self):
583         # Skip nonexistent models.
584         if isinstance(self.remote_field.model, str):
585             return []
586 
587         errors = []
588         for to_field in self.to_fields:
589             if to_field:
590                 try:
591                     self.remote_field.model._meta.get_field(to_field)
592                 except exceptions.FieldDoesNotExist:
593                     errors.append(
594                         checks.Error(
595                             "The to_field '%s' doesn't exist on the related "
596                             "model '%s'."
597                             % (to_field, self.remote_field.model._meta.label),
598                             obj=self,
599                             id="fields.E312",
600                         )
601                     )
602         return errors
603 
604     def _check_unique_target(self):
605         rel_is_string = isinstance(self.remote_field.model, str)
606         if rel_is_string or not self.requires_unique_target:
607             return []
608 
609         try:
610             self.foreign_related_fields
611         except exceptions.FieldDoesNotExist:
612             return []
613 
614         if not self.foreign_related_fields:
615             return []
616 
617         unique_foreign_fields = {
618             frozenset([f.name])
619             for f in self.remote_field.model._meta.get_fields()
620             if getattr(f, "unique", False)
621         }
622         unique_foreign_fields.update(
623             {frozenset(ut) for ut in self.remote_field.model._meta.unique_together}
624         )
625         unique_foreign_fields.update(
626             {
627                 frozenset(uc.fields)
628                 for uc in self.remote_field.model._meta.total_unique_constraints
629             }
630         )
631         foreign_fields = {f.name for f in self.foreign_related_fields}
632         has_unique_constraint = any(u <= foreign_fields for u in unique_foreign_fields)
633 
634         if not has_unique_constraint and len(self.foreign_related_fields) > 1:
635             field_combination = ", ".join(
636                 "'%s'" % rel_field.name for rel_field in self.foreign_related_fields
637             )
638             model_name = self.remote_field.model.__name__
639             return [
640                 checks.Error(
641                     "No subset of the fields %s on model '%s' is unique."
642                     % (field_combination, model_name),
643                     hint=(
644                         "Mark a single field as unique=True or add a set of "
645                         "fields to a unique constraint (via unique_together "
646                         "or a UniqueConstraint (without condition) in the "
647                         "model Meta.constraints)."
648                     ),
649                     obj=self,
650                     id="fields.E310",
651                 )
652             ]
653         elif not has_unique_constraint:
654             field_name = self.foreign_related_fields[0].name
655             model_name = self.remote_field.model.__name__
656             return [
657                 checks.Error(
658                     "'%s.%s' must be unique because it is referenced by "
659                     "a foreign key." % (model_name, field_name),
660                     hint=(
661                         "Add unique=True to this field or add a "
662                         "UniqueConstraint (without condition) in the model "
663                         "Meta.constraints."
664                     ),
665                     obj=self,
666                     id="fields.E311",
667                 )
668             ]
669         else:
670             return []
671 
672     def deconstruct(self):
673         name, path, args, kwargs = super().deconstruct()
674         kwargs["on_delete"] = self.remote_field.on_delete
675         kwargs["from_fields"] = self.from_fields
676         kwargs["to_fields"] = self.to_fields
677 
678         if self.remote_field.parent_link:
679             kwargs["parent_link"] = self.remote_field.parent_link
680         if isinstance(self.remote_field.model, str):
681             if "." in self.remote_field.model:
682                 app_label, model_name = self.remote_field.model.split(".")
683                 kwargs["to"] = "%s.%s" % (app_label, model_name.lower())
684             else:
685                 kwargs["to"] = self.remote_field.model.lower()
686         else:
687             kwargs["to"] = self.remote_field.model._meta.label_lower
688         # If swappable is True, then see if we're actually pointing to the target
689         # of a swap.
690         swappable_setting = self.swappable_setting
691         if swappable_setting is not None:
692             # If it's already a settings reference, error
693             if hasattr(kwargs["to"], "setting_name"):
694                 if kwargs["to"].setting_name != swappable_setting:
695                     raise ValueError(
696                         "Cannot deconstruct a ForeignKey pointing to a model "
697                         "that is swapped in place of more than one model (%s and %s)"
698                         % (kwargs["to"].setting_name, swappable_setting)
699                     )
700             # Set it
701             kwargs["to"] = SettingsReference(
702                 kwargs["to"],
703                 swappable_setting,
704             )
705         return name, path, args, kwargs
706 
707     def resolve_related_fields(self):
708         if not self.from_fields or len(self.from_fields) != len(self.to_fields):
709             raise ValueError(
710                 "Foreign Object from and to fields must be the same non-zero length"
711             )
712         if isinstance(self.remote_field.model, str):
713             raise ValueError(
714                 "Related model %r cannot be resolved" % self.remote_field.model
715             )
716         related_fields = []
717         for index in range(len(self.from_fields)):
718             from_field_name = self.from_fields[index]
719             to_field_name = self.to_fields[index]
720             from_field = (
721                 self
722                 if from_field_name == RECURSIVE_RELATIONSHIP_CONSTANT
723                 else self.opts.get_field(from_field_name)
724             )
725             to_field = (
726                 self.remote_field.model._meta.pk
727                 if to_field_name is None
728                 else self.remote_field.model._meta.get_field(to_field_name)
729             )
730             related_fields.append((from_field, to_field))
731         return related_fields
732 
733     @cached_property
734     def related_fields(self):
735         return self.resolve_related_fields()
736 
737     @cached_property
738     def reverse_related_fields(self):
739         return [(rhs_field, lhs_field) for lhs_field, rhs_field in self.related_fields]
740 
741     @cached_property
742     def local_related_fields(self):
743         return tuple(lhs_field for lhs_field, rhs_field in self.related_fields)
744 
745     @cached_property
746     def foreign_related_fields(self):
747         return tuple(
748             rhs_field for lhs_field, rhs_field in self.related_fields if rhs_field
749         )
750 
751     def get_local_related_value(self, instance):
752         return self.get_instance_value_for_fields(instance, self.local_related_fields)
753 
754     def get_foreign_related_value(self, instance):
755         return self.get_instance_value_for_fields(instance, self.foreign_related_fields)
756 
757     @staticmethod
758     def get_instance_value_for_fields(instance, fields):
759         ret = []
760         opts = instance._meta
761         for field in fields:
762             # Gotcha: in some cases (like fixture loading) a model can have
763             # different values in parent_ptr_id and parent's id. So, use
764             # instance.pk (that is, parent_ptr_id) when asked for instance.id.
765             if field.primary_key:
766                 possible_parent_link = opts.get_ancestor_link(field.model)
767                 if (
768                     not possible_parent_link
769                     or possible_parent_link.primary_key
770                     or possible_parent_link.model._meta.abstract
771                 ):
772                     ret.append(instance.pk)
773                     continue
774             ret.append(getattr(instance, field.attname))
775         return tuple(ret)
776 
777     def get_attname_column(self):
778         attname, column = super().get_attname_column()
779         return attname, None
780 
781     def get_joining_columns(self, reverse_join=False):
782         source = self.reverse_related_fields if reverse_join else self.related_fields
783         return tuple(
784             (lhs_field.column, rhs_field.column) for lhs_field, rhs_field in source
785         )
786 
787     def get_reverse_joining_columns(self):
788         return self.get_joining_columns(reverse_join=True)
789 
790     def get_extra_descriptor_filter(self, instance):
791         """
792         Return an extra filter condition for related object fetching when
793         user does 'instance.fieldname', that is the extra filter is used in
794         the descriptor of the field.
795 
796         The filter should be either a dict usable in .filter(**kwargs) call or
797         a Q-object. The condition will be ANDed together with the relation's
798         joining columns.
799 
800         A parallel method is get_extra_restriction() which is used in
801         JOIN and subquery conditions.
802         """
803         return {}
804 
805     def get_extra_restriction(self, alias, related_alias):
806         """
807         Return a pair condition used for joining and subquery pushdown. The
808         condition is something that responds to as_sql(compiler, connection)
809         method.
810 
811         Note that currently referring both the 'alias' and 'related_alias'
812         will not work in some conditions, like subquery pushdown.
813 
814         A parallel method is get_extra_descriptor_filter() which is used in
815         instance.fieldname related object fetching.
816         """
817         return None
818 
819     def get_path_info(self, filtered_relation=None):
820         """Get path from this field to the related model."""
821         opts = self.remote_field.model._meta
822         from_opts = self.model._meta
823         return [
824             PathInfo(
825                 from_opts=from_opts,
826                 to_opts=opts,
827                 target_fields=self.foreign_related_fields,
828                 join_field=self,
829                 m2m=False,
830                 direct=True,
831                 filtered_relation=filtered_relation,
832             )
833         ]
834 
835     @cached_property
836     def path_infos(self):
837         return self.get_path_info()
838 
839     def get_reverse_path_info(self, filtered_relation=None):
840         """Get path from the related model to this field's model."""
841         opts = self.model._meta
842         from_opts = self.remote_field.model._meta
843         return [
844             PathInfo(
845                 from_opts=from_opts,
846                 to_opts=opts,
847                 target_fields=(opts.pk,),
848                 join_field=self.remote_field,
849                 m2m=not self.unique,
850                 direct=False,
851                 filtered_relation=filtered_relation,
852             )
853         ]
854 
855     @cached_property
856     def reverse_path_infos(self):
857         return self.get_reverse_path_info()
858 
859     @classmethod
860     @functools.lru_cache(maxsize=None)
861     def get_class_lookups(cls):
862         bases = inspect.getmro(cls)
863         bases = bases[: bases.index(ForeignObject) + 1]
864         class_lookups = [parent.__dict__.get("class_lookups", {}) for parent in bases]
865         return cls.merge_dicts(class_lookups)
866 
867     def contribute_to_class(self, cls, name, private_only=False, **kwargs):
868         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)
869         setattr(cls, self.name, self.forward_related_accessor_class(self))
870 
871     def contribute_to_related_class(self, cls, related):
872         # Internal FK's - i.e., those with a related name ending with '+' -
873         # and swapped models don't get a related descriptor.
874         if (
875             not self.remote_field.is_hidden()
876             and not related.related_model._meta.swapped
877         ):
878             setattr(
879                 cls._meta.concrete_model,
880                 related.get_accessor_name(),
881                 self.related_accessor_class(related),
882             )
883             # While 'limit_choices_to' might be a callable, simply pass
884             # it along for later - this is too early because it's still
885             # model load time.
886             if self.remote_field.limit_choices_to:
887                 cls._meta.related_fkey_lookups.append(
888                     self.remote_field.limit_choices_to
889                 )
890 
891 
892 ForeignObject.register_lookup(RelatedIn)
893 ForeignObject.register_lookup(RelatedExact)
894 ForeignObject.register_lookup(RelatedLessThan)
895 ForeignObject.register_lookup(RelatedGreaterThan)
896 ForeignObject.register_lookup(RelatedGreaterThanOrEqual)
897 ForeignObject.register_lookup(RelatedLessThanOrEqual)
898 ForeignObject.register_lookup(RelatedIsNull)
899 
900 
901 class ForeignKey(ForeignObject):
902     """
903     Provide a many-to-one relation by adding a column to the local model
904     to hold the remote value.
905 
906     By default ForeignKey will target the pk of the remote model but this
907     behavior can be changed by using the ``to_field`` argument.
908     """
909 
910     descriptor_class = ForeignKeyDeferredAttribute
911     # Field flags
912     many_to_many = False
913     many_to_one = True
914     one_to_many = False
915     one_to_one = False
916 
917     rel_class = ManyToOneRel
918 
919     empty_strings_allowed = False
920     default_error_messages = {
921         "invalid": _("%(model)s instance with %(field)s %(value)r does not exist.")
922     }
923     description = _("Foreign Key (type determined by related field)")
924 
925     def __init__(
926         self,
927         to,
928         on_delete,
929         related_name=None,
930         related_query_name=None,
931         limit_choices_to=None,
932         parent_link=False,
933         to_field=None,
934         db_constraint=True,
935         **kwargs,
936     ):
937         try:
938             to._meta.model_name
939         except AttributeError:
940             if not isinstance(to, str):
941                 raise TypeError(
942                     "%s(%r) is invalid. First parameter to ForeignKey must be "
943                     "either a model, a model name, or the string %r"
944                     % (
945                         self.__class__.__name__,
946                         to,
947                         RECURSIVE_RELATIONSHIP_CONSTANT,
948                     )
949                 )
950         else:
951             # For backwards compatibility purposes, we need to *try* and set
952             # the to_field during FK construction. It won't be guaranteed to
953             # be correct until contribute_to_class is called. Refs #12190.
954             to_field = to_field or (to._meta.pk and to._meta.pk.name)
955         if not callable(on_delete):
956             raise TypeError("on_delete must be callable.")
957 
958         kwargs["rel"] = self.rel_class(
959             self,
960             to,
961             to_field,
962             related_name=related_name,
963             related_query_name=related_query_name,
964             limit_choices_to=limit_choices_to,
965             parent_link=parent_link,
966             on_delete=on_delete,
967         )
968         kwargs.setdefault("db_index", True)
969 
970         super().__init__(
971             to,
972             on_delete,
973             related_name=related_name,
974             related_query_name=related_query_name,
975             limit_choices_to=limit_choices_to,
976             from_fields=[RECURSIVE_RELATIONSHIP_CONSTANT],
977             to_fields=[to_field],
978             **kwargs,
979         )
980         self.db_constraint = db_constraint
981 
982     def __class_getitem__(cls, *args, **kwargs):
983         return cls
984 
985     def check(self, **kwargs):
986         return [
987             *super().check(**kwargs),
988             *self._check_on_delete(),
989             *self._check_unique(),
990         ]
991 
992     def _check_on_delete(self):
993         on_delete = getattr(self.remote_field, "on_delete", None)
994         if on_delete == SET_NULL and not self.null:
995             return [
996                 checks.Error(
997                     "Field specifies on_delete=SET_NULL, but cannot be null.",
998                     hint=(
999                         "Set null=True argument on the field, or change the on_delete "
1000                         "rule."
1001                     ),
1002                     obj=self,
1003                     id="fields.E320",
1004                 )
1005             ]
1006         elif on_delete == SET_DEFAULT and not self.has_default():
1007             return [
1008                 checks.Error(
1009                     "Field specifies on_delete=SET_DEFAULT, but has no default value.",
1010                     hint="Set a default value, or change the on_delete rule.",
1011                     obj=self,
1012                     id="fields.E321",
1013                 )
1014             ]
1015         else:
1016             return []
1017 
1018     def _check_unique(self, **kwargs):
1019         return (
1020             [
1021                 checks.Warning(
1022                     "Setting unique=True on a ForeignKey has the same effect as using "
1023                     "a OneToOneField.",
1024                     hint=(
1025                         "ForeignKey(unique=True) is usually better served by a "
1026                         "OneToOneField."
1027                     ),
1028                     obj=self,
1029                     id="fields.W342",
1030                 )
1031             ]
1032             if self.unique
1033             else []
1034         )
1035 
1036     def deconstruct(self):
1037         name, path, args, kwargs = super().deconstruct()
1038         del kwargs["to_fields"]
1039         del kwargs["from_fields"]
1040         # Handle the simpler arguments
1041         if self.db_index:
1042             del kwargs["db_index"]
1043         else:
1044             kwargs["db_index"] = False
1045         if self.db_constraint is not True:
1046             kwargs["db_constraint"] = self.db_constraint
1047         # Rel needs more work.
1048         to_meta = getattr(self.remote_field.model, "_meta", None)
1049         if self.remote_field.field_name and (
1050             not to_meta
1051             or (to_meta.pk and self.remote_field.field_name != to_meta.pk.name)
1052         ):
1053             kwargs["to_field"] = self.remote_field.field_name
1054         return name, path, args, kwargs
1055 
1056     def to_python(self, value):
1057         return self.target_field.to_python(value)
1058 
1059     @property
1060     def target_field(self):
1061         return self.foreign_related_fields[0]
1062 
1063     def get_reverse_path_info(self, filtered_relation=None):
1064         """Get path from the related model to this field's model."""
1065         opts = self.model._meta
1066         from_opts = self.remote_field.model._meta
1067         return [
1068             PathInfo(
1069                 from_opts=from_opts,
1070                 to_opts=opts,
1071                 target_fields=(opts.pk,),
1072                 join_field=self.remote_field,
1073                 m2m=not self.unique,
1074                 direct=False,
1075                 filtered_relation=filtered_relation,
1076             )
1077         ]
1078 
1079     def validate(self, value, model_instance):
1080         if self.remote_field.parent_link:
1081             return
1082         super().validate(value, model_instance)
1083         if value is None:
1084             return
1085 
1086         using = router.db_for_read(self.remote_field.model, instance=model_instance)
1087         qs = self.remote_field.model._base_manager.using(using).filter(
1088             **{self.remote_field.field_name: value}
1089         )
1090         qs = qs.complex_filter(self.get_limit_choices_to())
1091         if not qs.exists():
1092             raise exceptions.ValidationError(
1093                 self.error_messages["invalid"],
1094                 code="invalid",
1095                 params={
1096                     "model": self.remote_field.model._meta.verbose_name,
1097                     "pk": value,
1098                     "field": self.remote_field.field_name,
1099                     "value": value,
1100                 },  # 'pk' is included for backwards compatibility
1101             )
1102 
1103     def resolve_related_fields(self):
1104         related_fields = super().resolve_related_fields()
1105         for from_field, to_field in related_fields:
1106             if (
1107                 to_field
1108                 and to_field.model != self.remote_field.model._meta.concrete_model
1109             ):
1110                 raise exceptions.FieldError(
1111                     "'%s.%s' refers to field '%s' which is not local to model "
1112                     "'%s'."
1113                     % (
1114                         self.model._meta.label,
1115                         self.name,
1116                         to_field.name,
1117                         self.remote_field.model._meta.concrete_model._meta.label,
1118                     )
1119                 )
1120         return related_fields
1121 
1122     def get_attname(self):
1123         return "%s_id" % self.name
1124 
1125     def get_attname_column(self):
1126         attname = self.get_attname()
1127         column = self.db_column or attname
1128         return attname, column
1129 
1130     def get_default(self):
1131         """Return the to_field if the default value is an object."""
1132         field_default = super().get_default()
1133         if isinstance(field_default, self.remote_field.model):
1134             return getattr(field_default, self.target_field.attname)
1135         return field_default
1136 
1137     def get_db_prep_save(self, value, connection):
1138         if value is None or (
1139             value == ""
1140             and (
1141                 not self.target_field.empty_strings_allowed
1142                 or connection.features.interprets_empty_strings_as_nulls
1143             )
1144         ):
1145             return None
1146         else:
1147             return self.target_field.get_db_prep_save(value, connection=connection)
1148 
1149     def get_db_prep_value(self, value, connection, prepared=False):
1150         return self.target_field.get_db_prep_value(value, connection, prepared)
1151 
1152     def get_prep_value(self, value):
1153         return self.target_field.get_prep_value(value)
1154 
1155     def contribute_to_related_class(self, cls, related):
1156         super().contribute_to_related_class(cls, related)
1157         if self.remote_field.field_name is None:
1158             self.remote_field.field_name = cls._meta.pk.name
1159 
1160     def formfield(self, *, using=None, **kwargs):
1161         if isinstance(self.remote_field.model, str):
1162             raise ValueError(
1163                 "Cannot create form field for %r yet, because "
1164                 "its related model %r has not been loaded yet"
1165                 % (self.name, self.remote_field.model)
1166             )
1167         return super().formfield(
1168             **{
1169                 "form_class": forms.ModelChoiceField,
1170                 "queryset": self.remote_field.model._default_manager.using(using),
1171                 "to_field_name": self.remote_field.field_name,
1172                 **kwargs,
1173                 "blank": self.blank,
1174             }
1175         )
1176 
1177     def db_check(self, connection):
1178         return None
1179 
1180     def db_type(self, connection):
1181         return self.target_field.rel_db_type(connection=connection)
1182 
1183     def db_parameters(self, connection):
1184         target_db_parameters = self.target_field.db_parameters(connection)
1185         return {
1186             "type": self.db_type(connection),
1187             "check": self.db_check(connection),
1188             "collation": target_db_parameters.get("collation"),
1189         }
1190 
1191     def convert_empty_strings(self, value, expression, connection):
1192         if (not value) and isinstance(value, str):
1193             return None
1194         return value
1195 
1196     def get_db_converters(self, connection):
1197         converters = super().get_db_converters(connection)
1198         if connection.features.interprets_empty_strings_as_nulls:
1199             converters += [self.convert_empty_strings]
1200         return converters
1201 
1202     def get_col(self, alias, output_field=None):
1203         if output_field is None:
1204             output_field = self.target_field
1205             while isinstance(output_field, ForeignKey):
1206                 output_field = output_field.target_field
1207                 if output_field is self:
1208                     raise ValueError("Cannot resolve output_field.")
1209         return super().get_col(alias, output_field)
1210 
1211 
1212 class OneToOneField(ForeignKey):
1213     """
1214     A OneToOneField is essentially the same as a ForeignKey, with the exception
1215     that it always carries a "unique" constraint with it and the reverse
1216     relation always returns the object pointed to (since there will only ever
1217     be one), rather than returning a list.
1218     """
1219 
1220     # Field flags
1221     many_to_many = False
1222     many_to_one = False
1223     one_to_many = False
1224     one_to_one = True
1225 
1226     related_accessor_class = ReverseOneToOneDescriptor
1227     forward_related_accessor_class = ForwardOneToOneDescriptor
1228     rel_class = OneToOneRel
1229 
1230     description = _("One-to-one relationship")
1231 
1232     def __init__(self, to, on_delete, to_field=None, **kwargs):
1233         kwargs["unique"] = True
1234         super().__init__(to, on_delete, to_field=to_field, **kwargs)
1235 
1236     def deconstruct(self):
1237         name, path, args, kwargs = super().deconstruct()
1238         if "unique" in kwargs:
1239             del kwargs["unique"]
1240         return name, path, args, kwargs
1241 
1242     def formfield(self, **kwargs):
1243         if self.remote_field.parent_link:
1244             return None
1245         return super().formfield(**kwargs)
1246 
1247     def save_form_data(self, instance, data):
1248         if isinstance(data, self.remote_field.model):
1249             setattr(instance, self.name, data)
1250         else:
1251             setattr(instance, self.attname, data)
1252             # Remote field object must be cleared otherwise Model.save()
1253             # will reassign attname using the related object pk.
1254             if data is None:
1255                 setattr(instance, self.name, data)
1256 
1257     def _check_unique(self, **kwargs):
1258         # Override ForeignKey since check isn't applicable here.
1259         return []
1260 
1261 
1262 def create_many_to_many_intermediary_model(field, klass):
1263     from django.db import models
1264 
1265     def set_managed(model, related, through):
1266         through._meta.managed = model._meta.managed or related._meta.managed
1267 
1268     to_model = resolve_relation(klass, field.remote_field.model)
1269     name = "%s_%s" % (klass._meta.object_name, field.name)
1270     lazy_related_operation(set_managed, klass, to_model, name)
1271 
1272     to = make_model_tuple(to_model)[1]
1273     from_ = klass._meta.model_name
1274     if to == from_:
1275         to = "to_%s" % to
1276         from_ = "from_%s" % from_
1277 
1278     meta = type(
1279         "Meta",
1280         (),
1281         {
1282             "db_table": field._get_m2m_db_table(klass._meta),
1283             "auto_created": klass,
1284             "app_label": klass._meta.app_label,
1285             "db_tablespace": klass._meta.db_tablespace,
1286             "unique_together": (from_, to),
1287             "verbose_name": _("%(from)s-%(to)s relationship")
1288             % {"from": from_, "to": to},
1289             "verbose_name_plural": _("%(from)s-%(to)s relationships")
1290             % {"from": from_, "to": to},
1291             "apps": field.model._meta.apps,
1292         },
1293     )
1294     # Construct and return the new class.
1295     return type(
1296         name,
1297         (models.Model,),
1298         {
1299             "Meta": meta,
1300             "__module__": klass.__module__,
1301             from_: models.ForeignKey(
1302                 klass,
1303                 related_name="%s+" % name,
1304                 db_tablespace=field.db_tablespace,
1305                 db_constraint=field.remote_field.db_constraint,
1306                 on_delete=CASCADE,
1307             ),
1308             to: models.ForeignKey(
1309                 to_model,
1310                 related_name="%s+" % name,
1311                 db_tablespace=field.db_tablespace,
1312                 db_constraint=field.remote_field.db_constraint,
1313                 on_delete=CASCADE,
1314             ),
1315         },
1316     )
1317 
1318 
1319 class ManyToManyField(RelatedField):
1320     """
1321     Provide a many-to-many relation by using an intermediary model that
1322     holds two ForeignKey fields pointed at the two sides of the relation.
1323 
1324     Unless a ``through`` model was provided, ManyToManyField will use the
1325     create_many_to_many_intermediary_model factory to automatically generate
1326     the intermediary model.
1327     """
1328 
1329     # Field flags
1330     many_to_many = True
1331     many_to_one = False
1332     one_to_many = False
1333     one_to_one = False
1334 
1335     rel_class = ManyToManyRel
1336 
1337     description = _("Many-to-many relationship")
1338 
1339     def __init__(
1340         self,
1341         to,
1342         related_name=None,
1343         related_query_name=None,
1344         limit_choices_to=None,
1345         symmetrical=None,
1346         through=None,
1347         through_fields=None,
1348         db_constraint=True,
1349         db_table=None,
1350         swappable=True,
1351         **kwargs,
1352     ):
1353         try:
1354             to._meta
1355         except AttributeError:
1356             if not isinstance(to, str):
1357                 raise TypeError(
1358                     "%s(%r) is invalid. First parameter to ManyToManyField "
1359                     "must be either a model, a model name, or the string %r"
1360                     % (
1361                         self.__class__.__name__,
1362                         to,
1363                         RECURSIVE_RELATIONSHIP_CONSTANT,
1364                     )
1365                 )
1366 
1367         if symmetrical is None:
1368             symmetrical = to == RECURSIVE_RELATIONSHIP_CONSTANT
1369 
1370         if through is not None and db_table is not None:
1371             raise ValueError(
1372                 "Cannot specify a db_table if an intermediary model is used."
1373             )
1374 
1375         kwargs["rel"] = self.rel_class(
1376             self,
1377             to,
1378             related_name=related_name,
1379             related_query_name=related_query_name,
1380             limit_choices_to=limit_choices_to,
1381             symmetrical=symmetrical,
1382             through=through,
1383             through_fields=through_fields,
1384             db_constraint=db_constraint,
1385         )
1386         self.has_null_arg = "null" in kwargs
1387 
1388         super().__init__(
1389             related_name=related_name,
1390             related_query_name=related_query_name,
1391             limit_choices_to=limit_choices_to,
1392             **kwargs,
1393         )
1394 
1395         self.db_table = db_table
1396         self.swappable = swappable
1397 
1398     def check(self, **kwargs):
1399         return [
1400             *super().check(**kwargs),
1401             *self._check_unique(**kwargs),
1402             *self._check_relationship_model(**kwargs),
1403             *self._check_ignored_options(**kwargs),
1404             *self._check_table_uniqueness(**kwargs),
1405         ]
1406 
1407     def _check_unique(self, **kwargs):
1408         if self.unique:
1409             return [
1410                 checks.Error(
1411                     "ManyToManyFields cannot be unique.",
1412                     obj=self,
1413                     id="fields.E330",
1414                 )
1415             ]
1416         return []
1417 
1418     def _check_ignored_options(self, **kwargs):
1419         warnings = []
1420 
1421         if self.has_null_arg:
1422             warnings.append(
1423                 checks.Warning(
1424                     "null has no effect on ManyToManyField.",
1425                     obj=self,
1426                     id="fields.W340",
1427                 )
1428             )
1429 
1430         if self._validators:
1431             warnings.append(
1432                 checks.Warning(
1433                     "ManyToManyField does not support validators.",
1434                     obj=self,
1435                     id="fields.W341",
1436                 )
1437             )
1438         if self.remote_field.symmetrical and self._related_name:
1439             warnings.append(
1440                 checks.Warning(
1441                     "related_name has no effect on ManyToManyField "
1442                     'with a symmetrical relationship, e.g. to "self".',
1443                     obj=self,
1444                     id="fields.W345",
1445                 )
1446             )
1447 
1448         return warnings
1449 
1450     def _check_relationship_model(self, from_model=None, **kwargs):
1451         if hasattr(self.remote_field.through, "_meta"):
1452             qualified_model_name = "%s.%s" % (
1453                 self.remote_field.through._meta.app_label,
1454                 self.remote_field.through.__name__,
1455             )
1456         else:
1457             qualified_model_name = self.remote_field.through
1458 
1459         errors = []
1460 
1461         if self.remote_field.through not in self.opts.apps.get_models(
1462             include_auto_created=True
1463         ):
1464             # The relationship model is not installed.
1465             errors.append(
1466                 checks.Error(
1467                     "Field specifies a many-to-many relation through model "
1468                     "'%s', which has not been installed." % qualified_model_name,
1469                     obj=self,
1470                     id="fields.E331",
1471                 )
1472             )
1473 
1474         else:
1475             assert from_model is not None, (
1476                 "ManyToManyField with intermediate "
1477                 "tables cannot be checked if you don't pass the model "
1478                 "where the field is attached to."
1479             )
1480             # Set some useful local variables
1481             to_model = resolve_relation(from_model, self.remote_field.model)
1482             from_model_name = from_model._meta.object_name
1483             if isinstance(to_model, str):
1484                 to_model_name = to_model
1485             else:
1486                 to_model_name = to_model._meta.object_name
1487             relationship_model_name = self.remote_field.through._meta.object_name
1488             self_referential = from_model == to_model
1489             # Count foreign keys in intermediate model
1490             if self_referential:
1491                 seen_self = sum(
1492                     from_model == getattr(field.remote_field, "model", None)
1493                     for field in self.remote_field.through._meta.fields
1494                 )
1495 
1496                 if seen_self > 2 and not self.remote_field.through_fields:
1497                     errors.append(
1498                         checks.Error(
1499                             "The model is used as an intermediate model by "
1500                             "'%s', but it has more than two foreign keys "
1501                             "to '%s', which is ambiguous. You must specify "
1502                             "which two foreign keys Django should use via the "
1503                             "through_fields keyword argument."
1504                             % (self, from_model_name),
1505                             hint=(
1506                                 "Use through_fields to specify which two foreign keys "
1507                                 "Django should use."
1508                             ),
1509                             obj=self.remote_field.through,
1510                             id="fields.E333",
1511                         )
1512                     )
1513 
1514             else:
1515                 # Count foreign keys in relationship model
1516                 seen_from = sum(
1517                     from_model == getattr(field.remote_field, "model", None)
1518                     for field in self.remote_field.through._meta.fields
1519                 )
1520                 seen_to = sum(
1521                     to_model == getattr(field.remote_field, "model", None)
1522                     for field in self.remote_field.through._meta.fields
1523                 )
1524 
1525                 if seen_from > 1 and not self.remote_field.through_fields:
1526                     errors.append(
1527                         checks.Error(
1528                             (
1529                                 "The model is used as an intermediate model by "
1530                                 "'%s', but it has more than one foreign key "
1531                                 "from '%s', which is ambiguous. You must specify "
1532                                 "which foreign key Django should use via the "
1533                                 "through_fields keyword argument."
1534                             )
1535                             % (self, from_model_name),
1536                             hint=(
1537                                 "If you want to create a recursive relationship, "
1538                                 'use ManyToManyField("%s", through="%s").'
1539                             )
1540                             % (
1541                                 RECURSIVE_RELATIONSHIP_CONSTANT,
1542                                 relationship_model_name,
1543                             ),
1544                             obj=self,
1545                             id="fields.E334",
1546                         )
1547                     )
1548 
1549                 if seen_to > 1 and not self.remote_field.through_fields:
1550                     errors.append(
1551                         checks.Error(
1552                             "The model is used as an intermediate model by "
1553                             "'%s', but it has more than one foreign key "
1554                             "to '%s', which is ambiguous. You must specify "
1555                             "which foreign key Django should use via the "
1556                             "through_fields keyword argument." % (self, to_model_name),
1557                             hint=(
1558                                 "If you want to create a recursive relationship, "
1559                                 'use ManyToManyField("%s", through="%s").'
1560                             )
1561                             % (
1562                                 RECURSIVE_RELATIONSHIP_CONSTANT,
1563                                 relationship_model_name,
1564                             ),
1565                             obj=self,
1566                             id="fields.E335",
1567                         )
1568                     )
1569 
1570                 if seen_from == 0 or seen_to == 0:
1571                     errors.append(
1572                         checks.Error(
1573                             "The model is used as an intermediate model by "
1574                             "'%s', but it does not have a foreign key to '%s' or '%s'."
1575                             % (self, from_model_name, to_model_name),
1576                             obj=self.remote_field.through,
1577                             id="fields.E336",
1578                         )
1579                     )
1580 
1581         # Validate `through_fields`.
1582         if self.remote_field.through_fields is not None:
1583             # Validate that we're given an iterable of at least two items
1584             # and that none of them is "falsy".
1585             if not (
1586                 len(self.remote_field.through_fields) >= 2
1587                 and self.remote_field.through_fields[0]
1588                 and self.remote_field.through_fields[1]
1589             ):
1590                 errors.append(
1591                     checks.Error(
1592                         "Field specifies 'through_fields' but does not provide "
1593                         "the names of the two link fields that should be used "
1594                         "for the relation through model '%s'." % qualified_model_name,
1595                         hint=(
1596                             "Make sure you specify 'through_fields' as "
1597                             "through_fields=('field1', 'field2')"
1598                         ),
1599                         obj=self,
1600                         id="fields.E337",
1601                     )
1602                 )
1603 
1604             # Validate the given through fields -- they should be actual
1605             # fields on the through model, and also be foreign keys to the
1606             # expected models.
1607             else:
1608                 assert from_model is not None, (
1609                     "ManyToManyField with intermediate "
1610                     "tables cannot be checked if you don't pass the model "
1611                     "where the field is attached to."
1612                 )
1613 
1614                 source, through, target = (
1615                     from_model,
1616                     self.remote_field.through,
1617                     self.remote_field.model,
1618                 )
1619                 source_field_name, target_field_name = self.remote_field.through_fields[
1620                     :2
1621                 ]
1622 
1623                 for field_name, related_model in (
1624                     (source_field_name, source),
1625                     (target_field_name, target),
1626                 ):
1627 
1628                     possible_field_names = []
1629                     for f in through._meta.fields:
1630                         if (
1631                             hasattr(f, "remote_field")
1632                             and getattr(f.remote_field, "model", None) == related_model
1633                         ):
1634                             possible_field_names.append(f.name)
1635                     if possible_field_names:
1636                         hint = (
1637                             "Did you mean one of the following foreign keys to '%s': "
1638                             "%s?"
1639                             % (
1640                                 related_model._meta.object_name,
1641                                 ", ".join(possible_field_names),
1642                             )
1643                         )
1644                     else:
1645                         hint = None
1646 
1647                     try:
1648                         field = through._meta.get_field(field_name)
1649                     except exceptions.FieldDoesNotExist:
1650                         errors.append(
1651                             checks.Error(
1652                                 "The intermediary model '%s' has no field '%s'."
1653                                 % (qualified_model_name, field_name),
1654                                 hint=hint,
1655                                 obj=self,
1656                                 id="fields.E338",
1657                             )
1658                         )
1659                     else:
1660                         if not (
1661                             hasattr(field, "remote_field")
1662                             and getattr(field.remote_field, "model", None)
1663                             == related_model
1664                         ):
1665                             errors.append(
1666                                 checks.Error(
1667                                     "'%s.%s' is not a foreign key to '%s'."
1668                                     % (
1669                                         through._meta.object_name,
1670                                         field_name,
1671                                         related_model._meta.object_name,
1672                                     ),
1673                                     hint=hint,
1674                                     obj=self,
1675                                     id="fields.E339",
1676                                 )
1677                             )
1678 
1679         return errors
1680 
1681     def _check_table_uniqueness(self, **kwargs):
1682         if (
1683             isinstance(self.remote_field.through, str)
1684             or not self.remote_field.through._meta.managed
1685         ):
1686             return []
1687         registered_tables = {
1688             model._meta.db_table: model
1689             for model in self.opts.apps.get_models(include_auto_created=True)
1690             if model != self.remote_field.through and model._meta.managed
1691         }
1692         m2m_db_table = self.m2m_db_table()
1693         model = registered_tables.get(m2m_db_table)
1694         # The second condition allows multiple m2m relations on a model if
1695         # some point to a through model that proxies another through model.
1696         if (
1697             model
1698             and model._meta.concrete_model
1699             != self.remote_field.through._meta.concrete_model
1700         ):
1701             if model._meta.auto_created:
1702 
1703                 def _get_field_name(model):
1704                     for field in model._meta.auto_created._meta.many_to_many:
1705                         if field.remote_field.through is model:
1706                             return field.name
1707 
1708                 opts = model._meta.auto_created._meta
1709                 clashing_obj = "%s.%s" % (opts.label, _get_field_name(model))
1710             else:
1711                 clashing_obj = model._meta.label
1712             if settings.DATABASE_ROUTERS:
1713                 error_class, error_id = checks.Warning, "fields.W344"
1714                 error_hint = (
1715                     "You have configured settings.DATABASE_ROUTERS. Verify "
1716                     "that the table of %r is correctly routed to a separate "
1717                     "database." % clashing_obj
1718                 )
1719             else:
1720                 error_class, error_id = checks.Error, "fields.E340"
1721                 error_hint = None
1722             return [
1723                 error_class(
1724                     "The field's intermediary table '%s' clashes with the "
1725                     "table name of '%s'." % (m2m_db_table, clashing_obj),
1726                     obj=self,
1727                     hint=error_hint,
1728                     id=error_id,
1729                 )
1730             ]
1731         return []
1732 
1733     def deconstruct(self):
1734         name, path, args, kwargs = super().deconstruct()
1735         # Handle the simpler arguments.
1736         if self.db_table is not None:
1737             kwargs["db_table"] = self.db_table
1738         if self.remote_field.db_constraint is not True:
1739             kwargs["db_constraint"] = self.remote_field.db_constraint
1740         # Lowercase model names as they should be treated as case-insensitive.
1741         if isinstance(self.remote_field.model, str):
1742             if "." in self.remote_field.model:
1743                 app_label, model_name = self.remote_field.model.split(".")
1744                 kwargs["to"] = "%s.%s" % (app_label, model_name.lower())
1745             else:
1746                 kwargs["to"] = self.remote_field.model.lower()
1747         else:
1748             kwargs["to"] = self.remote_field.model._meta.label_lower
1749         if getattr(self.remote_field, "through", None) is not None:
1750             if isinstance(self.remote_field.through, str):
1751                 kwargs["through"] = self.remote_field.through
1752             elif not self.remote_field.through._meta.auto_created:
1753                 kwargs["through"] = self.remote_field.through._meta.label
1754         # If swappable is True, then see if we're actually pointing to the target
1755         # of a swap.
1756         swappable_setting = self.swappable_setting
1757         if swappable_setting is not None:
1758             # If it's already a settings reference, error.
1759             if hasattr(kwargs["to"], "setting_name"):
1760                 if kwargs["to"].setting_name != swappable_setting:
1761                     raise ValueError(
1762                         "Cannot deconstruct a ManyToManyField pointing to a "
1763                         "model that is swapped in place of more than one model "
1764                         "(%s and %s)" % (kwargs["to"].setting_name, swappable_setting)
1765                     )
1766 
1767             kwargs["to"] = SettingsReference(
1768                 kwargs["to"],
1769                 swappable_setting,
1770             )
1771         return name, path, args, kwargs
1772 
1773     def _get_path_info(self, direct=False, filtered_relation=None):
1774         """Called by both direct and indirect m2m traversal."""
1775         int_model = self.remote_field.through
1776         linkfield1 = int_model._meta.get_field(self.m2m_field_name())
1777         linkfield2 = int_model._meta.get_field(self.m2m_reverse_field_name())
1778         if direct:
1779             join1infos = linkfield1.reverse_path_infos
1780             if filtered_relation:
1781                 join2infos = linkfield2.get_path_info(filtered_relation)
1782             else:
1783                 join2infos = linkfield2.path_infos
1784         else:
1785             join1infos = linkfield2.reverse_path_infos
1786             if filtered_relation:
1787                 join2infos = linkfield1.get_path_info(filtered_relation)
1788             else:
1789                 join2infos = linkfield1.path_infos
1790         # Get join infos between the last model of join 1 and the first model
1791         # of join 2. Assume the only reason these may differ is due to model
1792         # inheritance.
1793         join1_final = join1infos[-1].to_opts
1794         join2_initial = join2infos[0].from_opts
1795         if join1_final is join2_initial:
1796             intermediate_infos = []
1797         elif issubclass(join1_final.model, join2_initial.model):
1798             intermediate_infos = join1_final.get_path_to_parent(join2_initial.model)
1799         else:
1800             intermediate_infos = join2_initial.get_path_from_parent(join1_final.model)
1801 
1802         return [*join1infos, *intermediate_infos, *join2infos]
1803 
1804     def get_path_info(self, filtered_relation=None):
1805         return self._get_path_info(direct=True, filtered_relation=filtered_relation)
1806 
1807     @cached_property
1808     def path_infos(self):
1809         return self.get_path_info()
1810 
1811     def get_reverse_path_info(self, filtered_relation=None):
1812         return self._get_path_info(direct=False, filtered_relation=filtered_relation)
1813 
1814     @cached_property
1815     def reverse_path_infos(self):
1816         return self.get_reverse_path_info()
1817 
1818     def _get_m2m_db_table(self, opts):
1819         """
1820         Function that can be curried to provide the m2m table name for this
1821         relation.
1822         """
1823         if self.remote_field.through is not None:
1824             return self.remote_field.through._meta.db_table
1825         elif self.db_table:
1826             return self.db_table
1827         else:
1828             m2m_table_name = "%s_%s" % (utils.strip_quotes(opts.db_table), self.name)
1829             return utils.truncate_name(m2m_table_name, connection.ops.max_name_length())
1830 
1831     def _get_m2m_attr(self, related, attr):
1832         """
1833         Function that can be curried to provide the source accessor or DB
1834         column name for the m2m table.
1835         """
1836         cache_attr = "_m2m_%s_cache" % attr
1837         if hasattr(self, cache_attr):
1838             return getattr(self, cache_attr)
1839         if self.remote_field.through_fields is not None:
1840             link_field_name = self.remote_field.through_fields[0]
1841         else:
1842             link_field_name = None
1843         for f in self.remote_field.through._meta.fields:
1844             if (
1845                 f.is_relation
1846                 and f.remote_field.model == related.related_model
1847                 and (link_field_name is None or link_field_name == f.name)
1848             ):
1849                 setattr(self, cache_attr, getattr(f, attr))
1850                 return getattr(self, cache_attr)
1851 
1852     def _get_m2m_reverse_attr(self, related, attr):
1853         """
1854         Function that can be curried to provide the related accessor or DB
1855         column name for the m2m table.
1856         """
1857         cache_attr = "_m2m_reverse_%s_cache" % attr
1858         if hasattr(self, cache_attr):
1859             return getattr(self, cache_attr)
1860         found = False
1861         if self.remote_field.through_fields is not None:
1862             link_field_name = self.remote_field.through_fields[1]
1863         else:
1864             link_field_name = None
1865         for f in self.remote_field.through._meta.fields:
1866             if f.is_relation and f.remote_field.model == related.model:
1867                 if link_field_name is None and related.related_model == related.model:
1868                     # If this is an m2m-intermediate to self,
1869                     # the first foreign key you find will be
1870                     # the source column. Keep searching for
1871                     # the second foreign key.
1872                     if found:
1873                         setattr(self, cache_attr, getattr(f, attr))
1874                         break
1875                     else:
1876                         found = True
1877                 elif link_field_name is None or link_field_name == f.name:
1878                     setattr(self, cache_attr, getattr(f, attr))
1879                     break
1880         return getattr(self, cache_attr)
1881 
1882     def contribute_to_class(self, cls, name, **kwargs):
1883         # To support multiple relations to self, it's useful to have a non-None
1884         # related name on symmetrical relations for internal reasons. The
1885         # concept doesn't make a lot of sense externally ("you want me to
1886         # specify *what* on my non-reversible relation?!"), so we set it up
1887         # automatically. The funky name reduces the chance of an accidental
1888         # clash.
1889         if self.remote_field.symmetrical and (
1890             self.remote_field.model == RECURSIVE_RELATIONSHIP_CONSTANT
1891             or self.remote_field.model == cls._meta.object_name
1892         ):
1893             self.remote_field.related_name = "%s_rel_+" % name
1894         elif self.remote_field.is_hidden():
1895             # If the backwards relation is disabled, replace the original
1896             # related_name with one generated from the m2m field name. Django
1897             # still uses backwards relations internally and we need to avoid
1898             # clashes between multiple m2m fields with related_name == '+'.
1899             self.remote_field.related_name = "_%s_%s_%s_+" % (
1900                 cls._meta.app_label,
1901                 cls.__name__.lower(),
1902                 name,
1903             )
1904 
1905         super().contribute_to_class(cls, name, **kwargs)
1906 
1907         # The intermediate m2m model is not auto created if:
1908         #  1) There is a manually specified intermediate, or
1909         #  2) The class owning the m2m field is abstract.
1910         #  3) The class owning the m2m field has been swapped out.
1911         if not cls._meta.abstract:
1912             if self.remote_field.through:
1913 
1914                 def resolve_through_model(_, model, field):
1915                     field.remote_field.through = model
1916 
1917                 lazy_related_operation(
1918                     resolve_through_model, cls, self.remote_field.through, field=self
1919                 )
1920             elif not cls._meta.swapped:
1921                 self.remote_field.through = create_many_to_many_intermediary_model(
1922                     self, cls
1923                 )
1924 
1925         # Add the descriptor for the m2m relation.
1926         setattr(cls, self.name, ManyToManyDescriptor(self.remote_field, reverse=False))
1927 
1928         # Set up the accessor for the m2m table name for the relation.
1929         self.m2m_db_table = partial(self._get_m2m_db_table, cls._meta)
1930 
1931     def contribute_to_related_class(self, cls, related):
1932         # Internal M2Ms (i.e., those with a related name ending with '+')
1933         # and swapped models don't get a related descriptor.
1934         if (
1935             not self.remote_field.is_hidden()
1936             and not related.related_model._meta.swapped
1937         ):
1938             setattr(
1939                 cls,
1940                 related.get_accessor_name(),
1941                 ManyToManyDescriptor(self.remote_field, reverse=True),
1942             )
1943 
1944         # Set up the accessors for the column names on the m2m table.
1945         self.m2m_column_name = partial(self._get_m2m_attr, related, "column")
1946         self.m2m_reverse_name = partial(self._get_m2m_reverse_attr, related, "column")
1947 
1948         self.m2m_field_name = partial(self._get_m2m_attr, related, "name")
1949         self.m2m_reverse_field_name = partial(
1950             self._get_m2m_reverse_attr, related, "name"
1951         )
1952 
1953         get_m2m_rel = partial(self._get_m2m_attr, related, "remote_field")
1954         self.m2m_target_field_name = lambda: get_m2m_rel().field_name
1955         get_m2m_reverse_rel = partial(
1956             self._get_m2m_reverse_attr, related, "remote_field"
1957         )
1958         self.m2m_reverse_target_field_name = lambda: get_m2m_reverse_rel().field_name
1959 
1960     def set_attributes_from_rel(self):
1961         pass
1962 
1963     def value_from_object(self, obj):
1964         return [] if obj.pk is None else list(getattr(obj, self.attname).all())
1965 
1966     def save_form_data(self, instance, data):
1967         getattr(instance, self.attname).set(data)
1968 
1969     def formfield(self, *, using=None, **kwargs):
1970         defaults = {
1971             "form_class": forms.ModelMultipleChoiceField,
1972             "queryset": self.remote_field.model._default_manager.using(using),
1973             **kwargs,
1974         }
1975         # If initial is passed in, it's a list of related objects, but the
1976         # MultipleChoiceField takes a list of IDs.
1977         if defaults.get("initial") is not None:
1978             initial = defaults["initial"]
1979             if callable(initial):
1980                 initial = initial()
1981             defaults["initial"] = [i.pk for i in initial]
1982         return super().formfield(**defaults)
1983 
1984     def db_check(self, connection):
1985         return None
1986 
1987     def db_type(self, connection):
1988         # A ManyToManyField is not represented by a single column,
1989         # so return None.
1990         return None
1991 
1992     def db_parameters(self, connection):
1993         return {"type": None, "check": None}

</code><intended_behavior>Strengthen validation and deconstruction logic to accurately handle `ManyToManyField` pointing to 'self'. This includes ensuring the field's initialization properly sets up self-references and that deconstruction provides the correct state for migration serialization. The `_check_relationship_model` method specifically could be enhanced to ensure it validates self-referencing relationships correctly, preventing schema inconsistencies.</intended_behavior>]
2025-10-18 02:00:07.322 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-18 02:00:07.322 | INFO     | Search-only: skipping patch selection
2025-10-18 02:00:07.472 | INFO     | Task django__django-16281 completed successfully.
2025-10-18 02:00:07.473 | INFO     | No patch generated. You can try running ACR again.
