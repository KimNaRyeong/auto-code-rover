[
    {
        "rel_file_path": "django/db/migrations/autodetector.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__4.2/django/db/migrations/autodetector.py",
        "start": 1,
        "end": 1736,
        "class_name": null,
        "method_name": null,
        "code": "1 import functools\n2 import re\n3 from collections import defaultdict\n4 from itertools import chain\n5 \n6 from django.conf import settings\n7 from django.db import models\n8 from django.db.migrations import operations\n9 from django.db.migrations.migration import Migration\n10 from django.db.migrations.operations.models import AlterModelOptions\n11 from django.db.migrations.optimizer import MigrationOptimizer\n12 from django.db.migrations.questioner import MigrationQuestioner\n13 from django.db.migrations.utils import (\n14     COMPILED_REGEX_TYPE,\n15     RegexObject,\n16     resolve_relation,\n17 )\n18 from django.utils.topological_sort import stable_topological_sort\n19 \n20 \n21 class MigrationAutodetector:\n22     \"\"\"\n23     Take a pair of ProjectStates and compare them to see what the first would\n24     need doing to make it match the second (the second usually being the\n25     project's current state).\n26 \n27     Note that this naturally operates on entire projects at a time,\n28     as it's likely that changes interact (for example, you can't\n29     add a ForeignKey without having a migration to add the table it\n30     depends on first). A user interface may offer single-app usage\n31     if it wishes, with the caveat that it may not always be possible.\n32     \"\"\"\n33 \n34     def __init__(self, from_state, to_state, questioner=None):\n35         self.from_state = from_state\n36         self.to_state = to_state\n37         self.questioner = questioner or MigrationQuestioner()\n38         self.existing_apps = {app for app, model in from_state.models}\n39 \n40     def changes(self, graph, trim_to_apps=None, convert_apps=None, migration_name=None):\n41         \"\"\"\n42         Main entry point to produce a list of applicable changes.\n43         Take a graph to base names on and an optional set of apps\n44         to try and restrict to (restriction is not guaranteed)\n45         \"\"\"\n46         changes = self._detect_changes(convert_apps, graph)\n47         changes = self.arrange_for_graph(changes, graph, migration_name)\n48         if trim_to_apps:\n49             changes = self._trim_to_apps(changes, trim_to_apps)\n50         return changes\n51 \n52     def deep_deconstruct(self, obj):\n53         \"\"\"\n54         Recursive deconstruction for a field and its arguments.\n55         Used for full comparison for rename/alter; sometimes a single-level\n56         deconstruction will not compare correctly.\n57         \"\"\"\n58         if isinstance(obj, list):\n59             return [self.deep_deconstruct(value) for value in obj]\n60         elif isinstance(obj, tuple):\n61             return tuple(self.deep_deconstruct(value) for value in obj)\n62         elif isinstance(obj, dict):\n63             return {key: self.deep_deconstruct(value) for key, value in obj.items()}\n64         elif isinstance(obj, functools.partial):\n65             return (\n66                 obj.func,\n67                 self.deep_deconstruct(obj.args),\n68                 self.deep_deconstruct(obj.keywords),\n69             )\n70         elif isinstance(obj, COMPILED_REGEX_TYPE):\n71             return RegexObject(obj)\n72         elif isinstance(obj, type):\n73             # If this is a type that implements 'deconstruct' as an instance method,\n74             # avoid treating this as being deconstructible itself - see #22951\n75             return obj\n76         elif hasattr(obj, \"deconstruct\"):\n77             deconstructed = obj.deconstruct()\n78             if isinstance(obj, models.Field):\n79                 # we have a field which also returns a name\n80                 deconstructed = deconstructed[1:]\n81             path, args, kwargs = deconstructed\n82             return (\n83                 path,\n84                 [self.deep_deconstruct(value) for value in args],\n85                 {key: self.deep_deconstruct(value) for key, value in kwargs.items()},\n86             )\n87         else:\n88             return obj\n89 \n90     def only_relation_agnostic_fields(self, fields):\n91         \"\"\"\n92         Return a definition of the fields that ignores field names and\n93         what related fields actually relate to. Used for detecting renames (as\n94         the related fields change during renames).\n95         \"\"\"\n96         fields_def = []\n97         for name, field in sorted(fields.items()):\n98             deconstruction = self.deep_deconstruct(field)\n99             if field.remote_field and field.remote_field.model:\n100                 deconstruction[2].pop(\"to\", None)\n101             fields_def.append(deconstruction)\n102         return fields_def\n103 \n104     def _detect_changes(self, convert_apps=None, graph=None):\n105         \"\"\"\n106         Return a dict of migration plans which will achieve the\n107         change from from_state to to_state. The dict has app labels\n108         as keys and a list of migrations as values.\n109 \n110         The resulting migrations aren't specially named, but the names\n111         do matter for dependencies inside the set.\n112 \n113         convert_apps is the list of apps to convert to use migrations\n114         (i.e. to make initial migrations for, in the usual case)\n115 \n116         graph is an optional argument that, if provided, can help improve\n117         dependency generation and avoid potential circular dependencies.\n118         \"\"\"\n119         # The first phase is generating all the operations for each app\n120         # and gathering them into a big per-app list.\n121         # Then go through that list, order it, and split into migrations to\n122         # resolve dependencies caused by M2Ms and FKs.\n123         self.generated_operations = {}\n124         self.altered_indexes = {}\n125         self.altered_constraints = {}\n126         self.renamed_fields = {}\n127 \n128         # Prepare some old/new state and model lists, separating\n129         # proxy models and ignoring unmigrated apps.\n130         self.old_model_keys = set()\n131         self.old_proxy_keys = set()\n132         self.old_unmanaged_keys = set()\n133         self.new_model_keys = set()\n134         self.new_proxy_keys = set()\n135         self.new_unmanaged_keys = set()\n136         for (app_label, model_name), model_state in self.from_state.models.items():\n137             if not model_state.options.get(\"managed\", True):\n138                 self.old_unmanaged_keys.add((app_label, model_name))\n139             elif app_label not in self.from_state.real_apps:\n140                 if model_state.options.get(\"proxy\"):\n141                     self.old_proxy_keys.add((app_label, model_name))\n142                 else:\n143                     self.old_model_keys.add((app_label, model_name))\n144 \n145         for (app_label, model_name), model_state in self.to_state.models.items():\n146             if not model_state.options.get(\"managed\", True):\n147                 self.new_unmanaged_keys.add((app_label, model_name))\n148             elif app_label not in self.from_state.real_apps or (\n149                 convert_apps and app_label in convert_apps\n150             ):\n151                 if model_state.options.get(\"proxy\"):\n152                     self.new_proxy_keys.add((app_label, model_name))\n153                 else:\n154                     self.new_model_keys.add((app_label, model_name))\n155 \n156         self.from_state.resolve_fields_and_relations()\n157         self.to_state.resolve_fields_and_relations()\n158 \n159         # Renames have to come first\n160         self.generate_renamed_models()\n161 \n162         # Prepare lists of fields and generate through model map\n163         self._prepare_field_lists()\n164         self._generate_through_model_map()\n165 \n166         # Generate non-rename model operations\n167         self.generate_deleted_models()\n168         self.generate_created_models()\n169         self.generate_deleted_proxies()\n170         self.generate_created_proxies()\n171         self.generate_altered_options()\n172         self.generate_altered_managers()\n173 \n174         # Create the renamed fields and store them in self.renamed_fields.\n175         # They are used by create_altered_indexes(), generate_altered_fields(),\n176         # generate_removed_altered_index/unique_together(), and\n177         # generate_altered_index/unique_together().\n178         self.create_renamed_fields()\n179         # Create the altered indexes and store them in self.altered_indexes.\n180         # This avoids the same computation in generate_removed_indexes()\n181         # and generate_added_indexes().\n182         self.create_altered_indexes()\n183         self.create_altered_constraints()\n184         # Generate index removal operations before field is removed\n185         self.generate_removed_constraints()\n186         self.generate_removed_indexes()\n187         # Generate field renaming operations.\n188         self.generate_renamed_fields()\n189         self.generate_renamed_indexes()\n190         # Generate removal of foo together.\n191         self.generate_removed_altered_unique_together()\n192         self.generate_removed_altered_index_together()  # RemovedInDjango51Warning.\n193         # Generate field operations.\n194         self.generate_removed_fields()\n195         self.generate_added_fields()\n196         self.generate_altered_fields()\n197         self.generate_altered_order_with_respect_to()\n198         self.generate_altered_unique_together()\n199         self.generate_altered_index_together()  # RemovedInDjango51Warning.\n200         self.generate_added_indexes()\n201         self.generate_added_constraints()\n202         self.generate_altered_db_table()\n203 \n204         self._sort_migrations()\n205         self._build_migration_list(graph)\n206         self._optimize_migrations()\n207 \n208         return self.migrations\n209 \n210     def _prepare_field_lists(self):\n211         \"\"\"\n212         Prepare field lists and a list of the fields that used through models\n213         in the old state so dependencies can be made from the through model\n214         deletion to the field that uses it.\n215         \"\"\"\n216         self.kept_model_keys = self.old_model_keys & self.new_model_keys\n217         self.kept_proxy_keys = self.old_proxy_keys & self.new_proxy_keys\n218         self.kept_unmanaged_keys = self.old_unmanaged_keys & self.new_unmanaged_keys\n219         self.through_users = {}\n220         self.old_field_keys = {\n221             (app_label, model_name, field_name)\n222             for app_label, model_name in self.kept_model_keys\n223             for field_name in self.from_state.models[\n224                 app_label, self.renamed_models.get((app_label, model_name), model_name)\n225             ].fields\n226         }\n227         self.new_field_keys = {\n228             (app_label, model_name, field_name)\n229             for app_label, model_name in self.kept_model_keys\n230             for field_name in self.to_state.models[app_label, model_name].fields\n231         }\n232 \n233     def _generate_through_model_map(self):\n234         \"\"\"Through model map generation.\"\"\"\n235         for app_label, model_name in sorted(self.old_model_keys):\n236             old_model_name = self.renamed_models.get(\n237                 (app_label, model_name), model_name\n238             )\n239             old_model_state = self.from_state.models[app_label, old_model_name]\n240             for field_name, field in old_model_state.fields.items():\n241                 if hasattr(field, \"remote_field\") and getattr(\n242                     field.remote_field, \"through\", None\n243                 ):\n244                     through_key = resolve_relation(\n245                         field.remote_field.through, app_label, model_name\n246                     )\n247                     self.through_users[through_key] = (\n248                         app_label,\n249                         old_model_name,\n250                         field_name,\n251                     )\n252 \n253     @staticmethod\n254     def _resolve_dependency(dependency):\n255         \"\"\"\n256         Return the resolved dependency and a boolean denoting whether or not\n257         it was swappable.\n258         \"\"\"\n259         if dependency[0] != \"__setting__\":\n260             return dependency, False\n261         resolved_app_label, resolved_object_name = getattr(\n262             settings, dependency[1]\n263         ).split(\".\")\n264         return (resolved_app_label, resolved_object_name.lower()) + dependency[2:], True\n265 \n266     def _build_migration_list(self, graph=None):\n267         \"\"\"\n268         Chop the lists of operations up into migrations with dependencies on\n269         each other. Do this by going through an app's list of operations until\n270         one is found that has an outgoing dependency that isn't in another\n271         app's migration yet (hasn't been chopped off its list). Then chop off\n272         the operations before it into a migration and move onto the next app.\n273         If the loops completes without doing anything, there's a circular\n274         dependency (which _should_ be impossible as the operations are\n275         all split at this point so they can't depend and be depended on).\n276         \"\"\"\n277         self.migrations = {}\n278         num_ops = sum(len(x) for x in self.generated_operations.values())\n279         chop_mode = False\n280         while num_ops:\n281             # On every iteration, we step through all the apps and see if there\n282             # is a completed set of operations.\n283             # If we find that a subset of the operations are complete we can\n284             # try to chop it off from the rest and continue, but we only\n285             # do this if we've already been through the list once before\n286             # without any chopping and nothing has changed.\n287             for app_label in sorted(self.generated_operations):\n288                 chopped = []\n289                 dependencies = set()\n290                 for operation in list(self.generated_operations[app_label]):\n291                     deps_satisfied = True\n292                     operation_dependencies = set()\n293                     for dep in operation._auto_deps:\n294                         # Temporarily resolve the swappable dependency to\n295                         # prevent circular references. While keeping the\n296                         # dependency checks on the resolved model, add the\n297                         # swappable dependencies.\n298                         original_dep = dep\n299                         dep, is_swappable_dep = self._resolve_dependency(dep)\n300                         if dep[0] != app_label:\n301                             # External app dependency. See if it's not yet\n302                             # satisfied.\n303                             for other_operation in self.generated_operations.get(\n304                                 dep[0], []\n305                             ):\n306                                 if self.check_dependency(other_operation, dep):\n307                                     deps_satisfied = False\n308                                     break\n309                             if not deps_satisfied:\n310                                 break\n311                             else:\n312                                 if is_swappable_dep:\n313                                     operation_dependencies.add(\n314                                         (original_dep[0], original_dep[1])\n315                                     )\n316                                 elif dep[0] in self.migrations:\n317                                     operation_dependencies.add(\n318                                         (dep[0], self.migrations[dep[0]][-1].name)\n319                                     )\n320                                 else:\n321                                     # If we can't find the other app, we add a\n322                                     # first/last dependency, but only if we've\n323                                     # already been through once and checked\n324                                     # everything.\n325                                     if chop_mode:\n326                                         # If the app already exists, we add a\n327                                         # dependency on the last migration, as\n328                                         # we don't know which migration\n329                                         # contains the target field. If it's\n330                                         # not yet migrated or has no\n331                                         # migrations, we use __first__.\n332                                         if graph and graph.leaf_nodes(dep[0]):\n333                                             operation_dependencies.add(\n334                                                 graph.leaf_nodes(dep[0])[0]\n335                                             )\n336                                         else:\n337                                             operation_dependencies.add(\n338                                                 (dep[0], \"__first__\")\n339                                             )\n340                                     else:\n341                                         deps_satisfied = False\n342                     if deps_satisfied:\n343                         chopped.append(operation)\n344                         dependencies.update(operation_dependencies)\n345                         del self.generated_operations[app_label][0]\n346                     else:\n347                         break\n348                 # Make a migration! Well, only if there's stuff to put in it\n349                 if dependencies or chopped:\n350                     if not self.generated_operations[app_label] or chop_mode:\n351                         subclass = type(\n352                             \"Migration\",\n353                             (Migration,),\n354                             {\"operations\": [], \"dependencies\": []},\n355                         )\n356                         instance = subclass(\n357                             \"auto_%i\" % (len(self.migrations.get(app_label, [])) + 1),\n358                             app_label,\n359                         )\n360                         instance.dependencies = list(dependencies)\n361                         instance.operations = chopped\n362                         instance.initial = app_label not in self.existing_apps\n363                         self.migrations.setdefault(app_label, []).append(instance)\n364                         chop_mode = False\n365                     else:\n366                         self.generated_operations[app_label] = (\n367                             chopped + self.generated_operations[app_label]\n368                         )\n369             new_num_ops = sum(len(x) for x in self.generated_operations.values())\n370             if new_num_ops == num_ops:\n371                 if not chop_mode:\n372                     chop_mode = True\n373                 else:\n374                     raise ValueError(\n375                         \"Cannot resolve operation dependencies: %r\"\n376                         % self.generated_operations\n377                     )\n378             num_ops = new_num_ops\n379 \n380     def _sort_migrations(self):\n381         \"\"\"\n382         Reorder to make things possible. Reordering may be needed so FKs work\n383         nicely inside the same app.\n384         \"\"\"\n385         for app_label, ops in sorted(self.generated_operations.items()):\n386             # construct a dependency graph for intra-app dependencies\n387             dependency_graph = {op: set() for op in ops}\n388             for op in ops:\n389                 for dep in op._auto_deps:\n390                     # Resolve intra-app dependencies to handle circular\n391                     # references involving a swappable model.\n392                     dep = self._resolve_dependency(dep)[0]\n393                     if dep[0] == app_label:\n394                         for op2 in ops:\n395                             if self.check_dependency(op2, dep):\n396                                 dependency_graph[op].add(op2)\n397 \n398             # we use a stable sort for deterministic tests & general behavior\n399             self.generated_operations[app_label] = stable_topological_sort(\n400                 ops, dependency_graph\n401             )\n402 \n403     def _optimize_migrations(self):\n404         # Add in internal dependencies among the migrations\n405         for app_label, migrations in self.migrations.items():\n406             for m1, m2 in zip(migrations, migrations[1:]):\n407                 m2.dependencies.append((app_label, m1.name))\n408 \n409         # De-dupe dependencies\n410         for migrations in self.migrations.values():\n411             for migration in migrations:\n412                 migration.dependencies = list(set(migration.dependencies))\n413 \n414         # Optimize migrations\n415         for app_label, migrations in self.migrations.items():\n416             for migration in migrations:\n417                 migration.operations = MigrationOptimizer().optimize(\n418                     migration.operations, app_label\n419                 )\n420 \n421     def check_dependency(self, operation, dependency):\n422         \"\"\"\n423         Return True if the given operation depends on the given dependency,\n424         False otherwise.\n425         \"\"\"\n426         # Created model\n427         if dependency[2] is None and dependency[3] is True:\n428             return (\n429                 isinstance(operation, operations.CreateModel)\n430                 and operation.name_lower == dependency[1].lower()\n431             )\n432         # Created field\n433         elif dependency[2] is not None and dependency[3] is True:\n434             return (\n435                 isinstance(operation, operations.CreateModel)\n436                 and operation.name_lower == dependency[1].lower()\n437                 and any(dependency[2] == x for x, y in operation.fields)\n438             ) or (\n439                 isinstance(operation, operations.AddField)\n440                 and operation.model_name_lower == dependency[1].lower()\n441                 and operation.name_lower == dependency[2].lower()\n442             )\n443         # Removed field\n444         elif dependency[2] is not None and dependency[3] is False:\n445             return (\n446                 isinstance(operation, operations.RemoveField)\n447                 and operation.model_name_lower == dependency[1].lower()\n448                 and operation.name_lower == dependency[2].lower()\n449             )\n450         # Removed model\n451         elif dependency[2] is None and dependency[3] is False:\n452             return (\n453                 isinstance(operation, operations.DeleteModel)\n454                 and operation.name_lower == dependency[1].lower()\n455             )\n456         # Field being altered\n457         elif dependency[2] is not None and dependency[3] == \"alter\":\n458             return (\n459                 isinstance(operation, operations.AlterField)\n460                 and operation.model_name_lower == dependency[1].lower()\n461                 and operation.name_lower == dependency[2].lower()\n462             )\n463         # order_with_respect_to being unset for a field\n464         elif dependency[2] is not None and dependency[3] == \"order_wrt_unset\":\n465             return (\n466                 isinstance(operation, operations.AlterOrderWithRespectTo)\n467                 and operation.name_lower == dependency[1].lower()\n468                 and (operation.order_with_respect_to or \"\").lower()\n469                 != dependency[2].lower()\n470             )\n471         # Field is removed and part of an index/unique_together\n472         elif dependency[2] is not None and dependency[3] == \"foo_together_change\":\n473             return (\n474                 isinstance(\n475                     operation,\n476                     (operations.AlterUniqueTogether, operations.AlterIndexTogether),\n477                 )\n478                 and operation.name_lower == dependency[1].lower()\n479             )\n480         # Unknown dependency. Raise an error.\n481         else:\n482             raise ValueError(\"Can't handle dependency %r\" % (dependency,))\n483 \n484     def add_operation(self, app_label, operation, dependencies=None, beginning=False):\n485         # Dependencies are\n486         # (app_label, model_name, field_name, create/delete as True/False)\n487         operation._auto_deps = dependencies or []\n488         if beginning:\n489             self.generated_operations.setdefault(app_label, []).insert(0, operation)\n490         else:\n491             self.generated_operations.setdefault(app_label, []).append(operation)\n492 \n493     def swappable_first_key(self, item):\n494         \"\"\"\n495         Place potential swappable models first in lists of created models (only\n496         real way to solve #22783).\n497         \"\"\"\n498         try:\n499             model_state = self.to_state.models[item]\n500             base_names = {\n501                 base if isinstance(base, str) else base.__name__\n502                 for base in model_state.bases\n503             }\n504             string_version = \"%s.%s\" % (item[0], item[1])\n505             if (\n506                 model_state.options.get(\"swappable\")\n507                 or \"AbstractUser\" in base_names\n508                 or \"AbstractBaseUser\" in base_names\n509                 or settings.AUTH_USER_MODEL.lower() == string_version.lower()\n510             ):\n511                 return (\"___\" + item[0], \"___\" + item[1])\n512         except LookupError:\n513             pass\n514         return item\n515 \n516     def generate_renamed_models(self):\n517         \"\"\"\n518         Find any renamed models, generate the operations for them, and remove\n519         the old entry from the model lists. Must be run before other\n520         model-level generation.\n521         \"\"\"\n522         self.renamed_models = {}\n523         self.renamed_models_rel = {}\n524         added_models = self.new_model_keys - self.old_model_keys\n525         for app_label, model_name in sorted(added_models):\n526             model_state = self.to_state.models[app_label, model_name]\n527             model_fields_def = self.only_relation_agnostic_fields(model_state.fields)\n528 \n529             removed_models = self.old_model_keys - self.new_model_keys\n530             for rem_app_label, rem_model_name in removed_models:\n531                 if rem_app_label == app_label:\n532                     rem_model_state = self.from_state.models[\n533                         rem_app_label, rem_model_name\n534                     ]\n535                     rem_model_fields_def = self.only_relation_agnostic_fields(\n536                         rem_model_state.fields\n537                     )\n538                     if model_fields_def == rem_model_fields_def:\n539                         if self.questioner.ask_rename_model(\n540                             rem_model_state, model_state\n541                         ):\n542                             dependencies = []\n543                             fields = list(model_state.fields.values()) + [\n544                                 field.remote_field\n545                                 for relations in self.to_state.relations[\n546                                     app_label, model_name\n547                                 ].values()\n548                                 for field in relations.values()\n549                             ]\n550                             for field in fields:\n551                                 if field.is_relation:\n552                                     dependencies.extend(\n553                                         self._get_dependencies_for_foreign_key(\n554                                             app_label,\n555                                             model_name,\n556                                             field,\n557                                             self.to_state,\n558                                         )\n559                                     )\n560                             self.add_operation(\n561                                 app_label,\n562                                 operations.RenameModel(\n563                                     old_name=rem_model_state.name,\n564                                     new_name=model_state.name,\n565                                 ),\n566                                 dependencies=dependencies,\n567                             )\n568                             self.renamed_models[app_label, model_name] = rem_model_name\n569                             renamed_models_rel_key = \"%s.%s\" % (\n570                                 rem_model_state.app_label,\n571                                 rem_model_state.name_lower,\n572                             )\n573                             self.renamed_models_rel[\n574                                 renamed_models_rel_key\n575                             ] = \"%s.%s\" % (\n576                                 model_state.app_label,\n577                                 model_state.name_lower,\n578                             )\n579                             self.old_model_keys.remove((rem_app_label, rem_model_name))\n580                             self.old_model_keys.add((app_label, model_name))\n581                             break\n582 \n583     def generate_created_models(self):\n584         \"\"\"\n585         Find all new models (both managed and unmanaged) and make create\n586         operations for them as well as separate operations to create any\n587         foreign key or M2M relationships (these are optimized later, if\n588         possible).\n589 \n590         Defer any model options that refer to collections of fields that might\n591         be deferred (e.g. unique_together, index_together).\n592         \"\"\"\n593         old_keys = self.old_model_keys | self.old_unmanaged_keys\n594         added_models = self.new_model_keys - old_keys\n595         added_unmanaged_models = self.new_unmanaged_keys - old_keys\n596         all_added_models = chain(\n597             sorted(added_models, key=self.swappable_first_key, reverse=True),\n598             sorted(added_unmanaged_models, key=self.swappable_first_key, reverse=True),\n599         )\n600         for app_label, model_name in all_added_models:\n601             model_state = self.to_state.models[app_label, model_name]\n602             # Gather related fields\n603             related_fields = {}\n604             primary_key_rel = None\n605             for field_name, field in model_state.fields.items():\n606                 if field.remote_field:\n607                     if field.remote_field.model:\n608                         if field.primary_key:\n609                             primary_key_rel = field.remote_field.model\n610                         elif not field.remote_field.parent_link:\n611                             related_fields[field_name] = field\n612                     if getattr(field.remote_field, \"through\", None):\n613                         related_fields[field_name] = field\n614 \n615             # Are there indexes/unique|index_together to defer?\n616             indexes = model_state.options.pop(\"indexes\")\n617             constraints = model_state.options.pop(\"constraints\")\n618             unique_together = model_state.options.pop(\"unique_together\", None)\n619             # RemovedInDjango51Warning.\n620             index_together = model_state.options.pop(\"index_together\", None)\n621             order_with_respect_to = model_state.options.pop(\n622                 \"order_with_respect_to\", None\n623             )\n624             # Depend on the deletion of any possible proxy version of us\n625             dependencies = [\n626                 (app_label, model_name, None, False),\n627             ]\n628             # Depend on all bases\n629             for base in model_state.bases:\n630                 if isinstance(base, str) and \".\" in base:\n631                     base_app_label, base_name = base.split(\".\", 1)\n632                     dependencies.append((base_app_label, base_name, None, True))\n633                     # Depend on the removal of base fields if the new model has\n634                     # a field with the same name.\n635                     old_base_model_state = self.from_state.models.get(\n636                         (base_app_label, base_name)\n637                     )\n638                     new_base_model_state = self.to_state.models.get(\n639                         (base_app_label, base_name)\n640                     )\n641                     if old_base_model_state and new_base_model_state:\n642                         removed_base_fields = (\n643                             set(old_base_model_state.fields)\n644                             .difference(\n645                                 new_base_model_state.fields,\n646                             )\n647                             .intersection(model_state.fields)\n648                         )\n649                         for removed_base_field in removed_base_fields:\n650                             dependencies.append(\n651                                 (base_app_label, base_name, removed_base_field, False)\n652                             )\n653             # Depend on the other end of the primary key if it's a relation\n654             if primary_key_rel:\n655                 dependencies.append(\n656                     resolve_relation(\n657                         primary_key_rel,\n658                         app_label,\n659                         model_name,\n660                     )\n661                     + (None, True)\n662                 )\n663             # Generate creation operation\n664             self.add_operation(\n665                 app_label,\n666                 operations.CreateModel(\n667                     name=model_state.name,\n668                     fields=[\n669                         d\n670                         for d in model_state.fields.items()\n671                         if d[0] not in related_fields\n672                     ],\n673                     options=model_state.options,\n674                     bases=model_state.bases,\n675                     managers=model_state.managers,\n676                 ),\n677                 dependencies=dependencies,\n678                 beginning=True,\n679             )\n680 \n681             # Don't add operations which modify the database for unmanaged models\n682             if not model_state.options.get(\"managed\", True):\n683                 continue\n684 \n685             # Generate operations for each related field\n686             for name, field in sorted(related_fields.items()):\n687                 dependencies = self._get_dependencies_for_foreign_key(\n688                     app_label,\n689                     model_name,\n690                     field,\n691                     self.to_state,\n692                 )\n693                 # Depend on our own model being created\n694                 dependencies.append((app_label, model_name, None, True))\n695                 # Make operation\n696                 self.add_operation(\n697                     app_label,\n698                     operations.AddField(\n699                         model_name=model_name,\n700                         name=name,\n701                         field=field,\n702                     ),\n703                     dependencies=list(set(dependencies)),\n704                 )\n705             # Generate other opns\n706             if order_with_respect_to:\n707                 self.add_operation(\n708                     app_label,\n709                     operations.AlterOrderWithRespectTo(\n710                         name=model_name,\n711                         order_with_respect_to=order_with_respect_to,\n712                     ),\n713                     dependencies=[\n714                         (app_label, model_name, order_with_respect_to, True),\n715                         (app_label, model_name, None, True),\n716                     ],\n717                 )\n718             related_dependencies = [\n719                 (app_label, model_name, name, True) for name in sorted(related_fields)\n720             ]\n721             related_dependencies.append((app_label, model_name, None, True))\n722             for index in indexes:\n723                 self.add_operation(\n724                     app_label,\n725                     operations.AddIndex(\n726                         model_name=model_name,\n727                         index=index,\n728                     ),\n729                     dependencies=related_dependencies,\n730                 )\n731             for constraint in constraints:\n732                 self.add_operation(\n733                     app_label,\n734                     operations.AddConstraint(\n735                         model_name=model_name,\n736                         constraint=constraint,\n737                     ),\n738                     dependencies=related_dependencies,\n739                 )\n740             if unique_together:\n741                 self.add_operation(\n742                     app_label,\n743                     operations.AlterUniqueTogether(\n744                         name=model_name,\n745                         unique_together=unique_together,\n746                     ),\n747                     dependencies=related_dependencies,\n748                 )\n749             # RemovedInDjango51Warning.\n750             if index_together:\n751                 self.add_operation(\n752                     app_label,\n753                     operations.AlterIndexTogether(\n754                         name=model_name,\n755                         index_together=index_together,\n756                     ),\n757                     dependencies=related_dependencies,\n758                 )\n759             # Fix relationships if the model changed from a proxy model to a\n760             # concrete model.\n761             relations = self.to_state.relations\n762             if (app_label, model_name) in self.old_proxy_keys:\n763                 for related_model_key, related_fields in relations[\n764                     app_label, model_name\n765                 ].items():\n766                     related_model_state = self.to_state.models[related_model_key]\n767                     for related_field_name, related_field in related_fields.items():\n768                         self.add_operation(\n769                             related_model_state.app_label,\n770                             operations.AlterField(\n771                                 model_name=related_model_state.name,\n772                                 name=related_field_name,\n773                                 field=related_field,\n774                             ),\n775                             dependencies=[(app_label, model_name, None, True)],\n776                         )\n777 \n778     def generate_created_proxies(self):\n779         \"\"\"\n780         Make CreateModel statements for proxy models. Use the same statements\n781         as that way there's less code duplication, but for proxy models it's\n782         safe to skip all the pointless field stuff and chuck out an operation.\n783         \"\"\"\n784         added = self.new_proxy_keys - self.old_proxy_keys\n785         for app_label, model_name in sorted(added):\n786             model_state = self.to_state.models[app_label, model_name]\n787             assert model_state.options.get(\"proxy\")\n788             # Depend on the deletion of any possible non-proxy version of us\n789             dependencies = [\n790                 (app_label, model_name, None, False),\n791             ]\n792             # Depend on all bases\n793             for base in model_state.bases:\n794                 if isinstance(base, str) and \".\" in base:\n795                     base_app_label, base_name = base.split(\".\", 1)\n796                     dependencies.append((base_app_label, base_name, None, True))\n797             # Generate creation operation\n798             self.add_operation(\n799                 app_label,\n800                 operations.CreateModel(\n801                     name=model_state.name,\n802                     fields=[],\n803                     options=model_state.options,\n804                     bases=model_state.bases,\n805                     managers=model_state.managers,\n806                 ),\n807                 # Depend on the deletion of any possible non-proxy version of us\n808                 dependencies=dependencies,\n809             )\n810 \n811     def generate_deleted_models(self):\n812         \"\"\"\n813         Find all deleted models (managed and unmanaged) and make delete\n814         operations for them as well as separate operations to delete any\n815         foreign key or M2M relationships (these are optimized later, if\n816         possible).\n817 \n818         Also bring forward removal of any model options that refer to\n819         collections of fields - the inverse of generate_created_models().\n820         \"\"\"\n821         new_keys = self.new_model_keys | self.new_unmanaged_keys\n822         deleted_models = self.old_model_keys - new_keys\n823         deleted_unmanaged_models = self.old_unmanaged_keys - new_keys\n824         all_deleted_models = chain(\n825             sorted(deleted_models), sorted(deleted_unmanaged_models)\n826         )\n827         for app_label, model_name in all_deleted_models:\n828             model_state = self.from_state.models[app_label, model_name]\n829             # Gather related fields\n830             related_fields = {}\n831             for field_name, field in model_state.fields.items():\n832                 if field.remote_field:\n833                     if field.remote_field.model:\n834                         related_fields[field_name] = field\n835                     if getattr(field.remote_field, \"through\", None):\n836                         related_fields[field_name] = field\n837             # Generate option removal first\n838             unique_together = model_state.options.pop(\"unique_together\", None)\n839             # RemovedInDjango51Warning.\n840             index_together = model_state.options.pop(\"index_together\", None)\n841             if unique_together:\n842                 self.add_operation(\n843                     app_label,\n844                     operations.AlterUniqueTogether(\n845                         name=model_name,\n846                         unique_together=None,\n847                     ),\n848                 )\n849             # RemovedInDjango51Warning.\n850             if index_together:\n851                 self.add_operation(\n852                     app_label,\n853                     operations.AlterIndexTogether(\n854                         name=model_name,\n855                         index_together=None,\n856                     ),\n857                 )\n858             # Then remove each related field\n859             for name in sorted(related_fields):\n860                 self.add_operation(\n861                     app_label,\n862                     operations.RemoveField(\n863                         model_name=model_name,\n864                         name=name,\n865                     ),\n866                 )\n867             # Finally, remove the model.\n868             # This depends on both the removal/alteration of all incoming fields\n869             # and the removal of all its own related fields, and if it's\n870             # a through model the field that references it.\n871             dependencies = []\n872             relations = self.from_state.relations\n873             for (\n874                 related_object_app_label,\n875                 object_name,\n876             ), relation_related_fields in relations[app_label, model_name].items():\n877                 for field_name, field in relation_related_fields.items():\n878                     dependencies.append(\n879                         (related_object_app_label, object_name, field_name, False),\n880                     )\n881                     if not field.many_to_many:\n882                         dependencies.append(\n883                             (\n884                                 related_object_app_label,\n885                                 object_name,\n886                                 field_name,\n887                                 \"alter\",\n888                             ),\n889                         )\n890 \n891             for name in sorted(related_fields):\n892                 dependencies.append((app_label, model_name, name, False))\n893             # We're referenced in another field's through=\n894             through_user = self.through_users.get((app_label, model_state.name_lower))\n895             if through_user:\n896                 dependencies.append(\n897                     (through_user[0], through_user[1], through_user[2], False)\n898                 )\n899             # Finally, make the operation, deduping any dependencies\n900             self.add_operation(\n901                 app_label,\n902                 operations.DeleteModel(\n903                     name=model_state.name,\n904                 ),\n905                 dependencies=list(set(dependencies)),\n906             )\n907 \n908     def generate_deleted_proxies(self):\n909         \"\"\"Make DeleteModel options for proxy models.\"\"\"\n910         deleted = self.old_proxy_keys - self.new_proxy_keys\n911         for app_label, model_name in sorted(deleted):\n912             model_state = self.from_state.models[app_label, model_name]\n913             assert model_state.options.get(\"proxy\")\n914             self.add_operation(\n915                 app_label,\n916                 operations.DeleteModel(\n917                     name=model_state.name,\n918                 ),\n919             )\n920 \n921     def create_renamed_fields(self):\n922         \"\"\"Work out renamed fields.\"\"\"\n923         self.renamed_operations = []\n924         old_field_keys = self.old_field_keys.copy()\n925         for app_label, model_name, field_name in sorted(\n926             self.new_field_keys - old_field_keys\n927         ):\n928             old_model_name = self.renamed_models.get(\n929                 (app_label, model_name), model_name\n930             )\n931             old_model_state = self.from_state.models[app_label, old_model_name]\n932             new_model_state = self.to_state.models[app_label, model_name]\n933             field = new_model_state.get_field(field_name)\n934             # Scan to see if this is actually a rename!\n935             field_dec = self.deep_deconstruct(field)\n936             for rem_app_label, rem_model_name, rem_field_name in sorted(\n937                 old_field_keys - self.new_field_keys\n938             ):\n939                 if rem_app_label == app_label and rem_model_name == model_name:\n940                     old_field = old_model_state.get_field(rem_field_name)\n941                     old_field_dec = self.deep_deconstruct(old_field)\n942                     if (\n943                         field.remote_field\n944                         and field.remote_field.model\n945                         and \"to\" in old_field_dec[2]\n946                     ):\n947                         old_rel_to = old_field_dec[2][\"to\"]\n948                         if old_rel_to in self.renamed_models_rel:\n949                             old_field_dec[2][\"to\"] = self.renamed_models_rel[old_rel_to]\n950                     old_field.set_attributes_from_name(rem_field_name)\n951                     old_db_column = old_field.get_attname_column()[1]\n952                     if old_field_dec == field_dec or (\n953                         # Was the field renamed and db_column equal to the\n954                         # old field's column added?\n955                         old_field_dec[0:2] == field_dec[0:2]\n956                         and dict(old_field_dec[2], db_column=old_db_column)\n957                         == field_dec[2]\n958                     ):\n959                         if self.questioner.ask_rename(\n960                             model_name, rem_field_name, field_name, field\n961                         ):\n962                             self.renamed_operations.append(\n963                                 (\n964                                     rem_app_label,\n965                                     rem_model_name,\n966                                     old_field.db_column,\n967                                     rem_field_name,\n968                                     app_label,\n969                                     model_name,\n970                                     field,\n971                                     field_name,\n972                                 )\n973                             )\n974                             old_field_keys.remove(\n975                                 (rem_app_label, rem_model_name, rem_field_name)\n976                             )\n977                             old_field_keys.add((app_label, model_name, field_name))\n978                             self.renamed_fields[\n979                                 app_label, model_name, field_name\n980                             ] = rem_field_name\n981                             break\n982 \n983     def generate_renamed_fields(self):\n984         \"\"\"Generate RenameField operations.\"\"\"\n985         for (\n986             rem_app_label,\n987             rem_model_name,\n988             rem_db_column,\n989             rem_field_name,\n990             app_label,\n991             model_name,\n992             field,\n993             field_name,\n994         ) in self.renamed_operations:\n995             # A db_column mismatch requires a prior noop AlterField for the\n996             # subsequent RenameField to be a noop on attempts at preserving the\n997             # old name.\n998             if rem_db_column != field.db_column:\n999                 altered_field = field.clone()\n1000                 altered_field.name = rem_field_name\n1001                 self.add_operation(\n1002                     app_label,\n1003                     operations.AlterField(\n1004                         model_name=model_name,\n1005                         name=rem_field_name,\n1006                         field=altered_field,\n1007                     ),\n1008                 )\n1009             self.add_operation(\n1010                 app_label,\n1011                 operations.RenameField(\n1012                     model_name=model_name,\n1013                     old_name=rem_field_name,\n1014                     new_name=field_name,\n1015                 ),\n1016             )\n1017             self.old_field_keys.remove((rem_app_label, rem_model_name, rem_field_name))\n1018             self.old_field_keys.add((app_label, model_name, field_name))\n1019 \n1020     def generate_added_fields(self):\n1021         \"\"\"Make AddField operations.\"\"\"\n1022         for app_label, model_name, field_name in sorted(\n1023             self.new_field_keys - self.old_field_keys\n1024         ):\n1025             self._generate_added_field(app_label, model_name, field_name)\n1026 \n1027     def _generate_added_field(self, app_label, model_name, field_name):\n1028         field = self.to_state.models[app_label, model_name].get_field(field_name)\n1029         # Adding a field always depends at least on its removal.\n1030         dependencies = [(app_label, model_name, field_name, False)]\n1031         # Fields that are foreignkeys/m2ms depend on stuff.\n1032         if field.remote_field and field.remote_field.model:\n1033             dependencies.extend(\n1034                 self._get_dependencies_for_foreign_key(\n1035                     app_label,\n1036                     model_name,\n1037                     field,\n1038                     self.to_state,\n1039                 )\n1040             )\n1041         # You can't just add NOT NULL fields with no default or fields\n1042         # which don't allow empty strings as default.\n1043         time_fields = (models.DateField, models.DateTimeField, models.TimeField)\n1044         preserve_default = (\n1045             field.null\n1046             or field.has_default()\n1047             or field.many_to_many\n1048             or (field.blank and field.empty_strings_allowed)\n1049             or (isinstance(field, time_fields) and field.auto_now)\n1050         )\n1051         if not preserve_default:\n1052             field = field.clone()\n1053             if isinstance(field, time_fields) and field.auto_now_add:\n1054                 field.default = self.questioner.ask_auto_now_add_addition(\n1055                     field_name, model_name\n1056                 )\n1057             else:\n1058                 field.default = self.questioner.ask_not_null_addition(\n1059                     field_name, model_name\n1060                 )\n1061         if (\n1062             field.unique\n1063             and field.default is not models.NOT_PROVIDED\n1064             and callable(field.default)\n1065         ):\n1066             self.questioner.ask_unique_callable_default_addition(field_name, model_name)\n1067         self.add_operation(\n1068             app_label,\n1069             operations.AddField(\n1070                 model_name=model_name,\n1071                 name=field_name,\n1072                 field=field,\n1073                 preserve_default=preserve_default,\n1074             ),\n1075             dependencies=dependencies,\n1076         )\n1077 \n1078     def generate_removed_fields(self):\n1079         \"\"\"Make RemoveField operations.\"\"\"\n1080         for app_label, model_name, field_name in sorted(\n1081             self.old_field_keys - self.new_field_keys\n1082         ):\n1083             self._generate_removed_field(app_label, model_name, field_name)\n1084 \n1085     def _generate_removed_field(self, app_label, model_name, field_name):\n1086         self.add_operation(\n1087             app_label,\n1088             operations.RemoveField(\n1089                 model_name=model_name,\n1090                 name=field_name,\n1091             ),\n1092             # We might need to depend on the removal of an\n1093             # order_with_respect_to or index/unique_together operation;\n1094             # this is safely ignored if there isn't one\n1095             dependencies=[\n1096                 (app_label, model_name, field_name, \"order_wrt_unset\"),\n1097                 (app_label, model_name, field_name, \"foo_together_change\"),\n1098             ],\n1099         )\n1100 \n1101     def generate_altered_fields(self):\n1102         \"\"\"\n1103         Make AlterField operations, or possibly RemovedField/AddField if alter\n1104         isn't possible.\n1105         \"\"\"\n1106         for app_label, model_name, field_name in sorted(\n1107             self.old_field_keys & self.new_field_keys\n1108         ):\n1109             # Did the field change?\n1110             old_model_name = self.renamed_models.get(\n1111                 (app_label, model_name), model_name\n1112             )\n1113             old_field_name = self.renamed_fields.get(\n1114                 (app_label, model_name, field_name), field_name\n1115             )\n1116             old_field = self.from_state.models[app_label, old_model_name].get_field(\n1117                 old_field_name\n1118             )\n1119             new_field = self.to_state.models[app_label, model_name].get_field(\n1120                 field_name\n1121             )\n1122             dependencies = []\n1123             # Implement any model renames on relations; these are handled by RenameModel\n1124             # so we need to exclude them from the comparison\n1125             if hasattr(new_field, \"remote_field\") and getattr(\n1126                 new_field.remote_field, \"model\", None\n1127             ):\n1128                 rename_key = resolve_relation(\n1129                     new_field.remote_field.model, app_label, model_name\n1130                 )\n1131                 if rename_key in self.renamed_models:\n1132                     new_field.remote_field.model = old_field.remote_field.model\n1133                 # Handle ForeignKey which can only have a single to_field.\n1134                 remote_field_name = getattr(new_field.remote_field, \"field_name\", None)\n1135                 if remote_field_name:\n1136                     to_field_rename_key = rename_key + (remote_field_name,)\n1137                     if to_field_rename_key in self.renamed_fields:\n1138                         # Repoint both model and field name because to_field\n1139                         # inclusion in ForeignKey.deconstruct() is based on\n1140                         # both.\n1141                         new_field.remote_field.model = old_field.remote_field.model\n1142                         new_field.remote_field.field_name = (\n1143                             old_field.remote_field.field_name\n1144                         )\n1145                 # Handle ForeignObjects which can have multiple from_fields/to_fields.\n1146                 from_fields = getattr(new_field, \"from_fields\", None)\n1147                 if from_fields:\n1148                     from_rename_key = (app_label, model_name)\n1149                     new_field.from_fields = tuple(\n1150                         [\n1151                             self.renamed_fields.get(\n1152                                 from_rename_key + (from_field,), from_field\n1153                             )\n1154                             for from_field in from_fields\n1155                         ]\n1156                     )\n1157                     new_field.to_fields = tuple(\n1158                         [\n1159                             self.renamed_fields.get(rename_key + (to_field,), to_field)\n1160                             for to_field in new_field.to_fields\n1161                         ]\n1162                     )\n1163                 dependencies.extend(\n1164                     self._get_dependencies_for_foreign_key(\n1165                         app_label,\n1166                         model_name,\n1167                         new_field,\n1168                         self.to_state,\n1169                     )\n1170                 )\n1171             if hasattr(new_field, \"remote_field\") and getattr(\n1172                 new_field.remote_field, \"through\", None\n1173             ):\n1174                 rename_key = resolve_relation(\n1175                     new_field.remote_field.through, app_label, model_name\n1176                 )\n1177                 if rename_key in self.renamed_models:\n1178                     new_field.remote_field.through = old_field.remote_field.through\n1179             old_field_dec = self.deep_deconstruct(old_field)\n1180             new_field_dec = self.deep_deconstruct(new_field)\n1181             # If the field was confirmed to be renamed it means that only\n1182             # db_column was allowed to change which generate_renamed_fields()\n1183             # already accounts for by adding an AlterField operation.\n1184             if old_field_dec != new_field_dec and old_field_name == field_name:\n1185                 both_m2m = old_field.many_to_many and new_field.many_to_many\n1186                 neither_m2m = not old_field.many_to_many and not new_field.many_to_many\n1187                 if both_m2m or neither_m2m:\n1188                     # Either both fields are m2m or neither is\n1189                     preserve_default = True\n1190                     if (\n1191                         old_field.null\n1192                         and not new_field.null\n1193                         and not new_field.has_default()\n1194                         and not new_field.many_to_many\n1195                     ):\n1196                         field = new_field.clone()\n1197                         new_default = self.questioner.ask_not_null_alteration(\n1198                             field_name, model_name\n1199                         )\n1200                         if new_default is not models.NOT_PROVIDED:\n1201                             field.default = new_default\n1202                             preserve_default = False\n1203                     else:\n1204                         field = new_field\n1205                     self.add_operation(\n1206                         app_label,\n1207                         operations.AlterField(\n1208                             model_name=model_name,\n1209                             name=field_name,\n1210                             field=field,\n1211                             preserve_default=preserve_default,\n1212                         ),\n1213                         dependencies=dependencies,\n1214                     )\n1215                 else:\n1216                     # We cannot alter between m2m and concrete fields\n1217                     self._generate_removed_field(app_label, model_name, field_name)\n1218                     self._generate_added_field(app_label, model_name, field_name)\n1219 \n1220     def create_altered_indexes(self):\n1221         option_name = operations.AddIndex.option_name\n1222         self.renamed_index_together_values = defaultdict(list)\n1223 \n1224         for app_label, model_name in sorted(self.kept_model_keys):\n1225             old_model_name = self.renamed_models.get(\n1226                 (app_label, model_name), model_name\n1227             )\n1228             old_model_state = self.from_state.models[app_label, old_model_name]\n1229             new_model_state = self.to_state.models[app_label, model_name]\n1230 \n1231             old_indexes = old_model_state.options[option_name]\n1232             new_indexes = new_model_state.options[option_name]\n1233             added_indexes = [idx for idx in new_indexes if idx not in old_indexes]\n1234             removed_indexes = [idx for idx in old_indexes if idx not in new_indexes]\n1235             renamed_indexes = []\n1236             # Find renamed indexes.\n1237             remove_from_added = []\n1238             remove_from_removed = []\n1239             for new_index in added_indexes:\n1240                 new_index_dec = new_index.deconstruct()\n1241                 new_index_name = new_index_dec[2].pop(\"name\")\n1242                 for old_index in removed_indexes:\n1243                     old_index_dec = old_index.deconstruct()\n1244                     old_index_name = old_index_dec[2].pop(\"name\")\n1245                     # Indexes are the same except for the names.\n1246                     if (\n1247                         new_index_dec == old_index_dec\n1248                         and new_index_name != old_index_name\n1249                     ):\n1250                         renamed_indexes.append((old_index_name, new_index_name, None))\n1251                         remove_from_added.append(new_index)\n1252                         remove_from_removed.append(old_index)\n1253             # Find index_together changed to indexes.\n1254             for (\n1255                 old_value,\n1256                 new_value,\n1257                 index_together_app_label,\n1258                 index_together_model_name,\n1259                 dependencies,\n1260             ) in self._get_altered_foo_together_operations(\n1261                 operations.AlterIndexTogether.option_name\n1262             ):\n1263                 if (\n1264                     app_label != index_together_app_label\n1265                     or model_name != index_together_model_name\n1266                 ):\n1267                     continue\n1268                 removed_values = old_value.difference(new_value)\n1269                 for removed_index_together in removed_values:\n1270                     renamed_index_together_indexes = []\n1271                     for new_index in added_indexes:\n1272                         _, args, kwargs = new_index.deconstruct()\n1273                         # Ensure only 'fields' are defined in the Index.\n1274                         if (\n1275                             not args\n1276                             and new_index.fields == list(removed_index_together)\n1277                             and set(kwargs) == {\"name\", \"fields\"}\n1278                         ):\n1279                             renamed_index_together_indexes.append(new_index)\n1280 \n1281                     if len(renamed_index_together_indexes) == 1:\n1282                         renamed_index = renamed_index_together_indexes[0]\n1283                         remove_from_added.append(renamed_index)\n1284                         renamed_indexes.append(\n1285                             (None, renamed_index.name, removed_index_together)\n1286                         )\n1287                         self.renamed_index_together_values[\n1288                             index_together_app_label, index_together_model_name\n1289                         ].append(removed_index_together)\n1290             # Remove renamed indexes from the lists of added and removed\n1291             # indexes.\n1292             added_indexes = [\n1293                 idx for idx in added_indexes if idx not in remove_from_added\n1294             ]\n1295             removed_indexes = [\n1296                 idx for idx in removed_indexes if idx not in remove_from_removed\n1297             ]\n1298 \n1299             self.altered_indexes.update(\n1300                 {\n1301                     (app_label, model_name): {\n1302                         \"added_indexes\": added_indexes,\n1303                         \"removed_indexes\": removed_indexes,\n1304                         \"renamed_indexes\": renamed_indexes,\n1305                     }\n1306                 }\n1307             )\n1308 \n1309     def generate_added_indexes(self):\n1310         for (app_label, model_name), alt_indexes in self.altered_indexes.items():\n1311             for index in alt_indexes[\"added_indexes\"]:\n1312                 self.add_operation(\n1313                     app_label,\n1314                     operations.AddIndex(\n1315                         model_name=model_name,\n1316                         index=index,\n1317                     ),\n1318                 )\n1319 \n1320     def generate_removed_indexes(self):\n1321         for (app_label, model_name), alt_indexes in self.altered_indexes.items():\n1322             for index in alt_indexes[\"removed_indexes\"]:\n1323                 self.add_operation(\n1324                     app_label,\n1325                     operations.RemoveIndex(\n1326                         model_name=model_name,\n1327                         name=index.name,\n1328                     ),\n1329                 )\n1330 \n1331     def generate_renamed_indexes(self):\n1332         for (app_label, model_name), alt_indexes in self.altered_indexes.items():\n1333             for old_index_name, new_index_name, old_fields in alt_indexes[\n1334                 \"renamed_indexes\"\n1335             ]:\n1336                 self.add_operation(\n1337                     app_label,\n1338                     operations.RenameIndex(\n1339                         model_name=model_name,\n1340                         new_name=new_index_name,\n1341                         old_name=old_index_name,\n1342                         old_fields=old_fields,\n1343                     ),\n1344                 )\n1345 \n1346     def create_altered_constraints(self):\n1347         option_name = operations.AddConstraint.option_name\n1348         for app_label, model_name in sorted(self.kept_model_keys):\n1349             old_model_name = self.renamed_models.get(\n1350                 (app_label, model_name), model_name\n1351             )\n1352             old_model_state = self.from_state.models[app_label, old_model_name]\n1353             new_model_state = self.to_state.models[app_label, model_name]\n1354 \n1355             old_constraints = old_model_state.options[option_name]\n1356             new_constraints = new_model_state.options[option_name]\n1357             add_constraints = [c for c in new_constraints if c not in old_constraints]\n1358             rem_constraints = [c for c in old_constraints if c not in new_constraints]\n1359 \n1360             self.altered_constraints.update(\n1361                 {\n1362                     (app_label, model_name): {\n1363                         \"added_constraints\": add_constraints,\n1364                         \"removed_constraints\": rem_constraints,\n1365                     }\n1366                 }\n1367             )\n1368 \n1369     def generate_added_constraints(self):\n1370         for (\n1371             app_label,\n1372             model_name,\n1373         ), alt_constraints in self.altered_constraints.items():\n1374             for constraint in alt_constraints[\"added_constraints\"]:\n1375                 self.add_operation(\n1376                     app_label,\n1377                     operations.AddConstraint(\n1378                         model_name=model_name,\n1379                         constraint=constraint,\n1380                     ),\n1381                 )\n1382 \n1383     def generate_removed_constraints(self):\n1384         for (\n1385             app_label,\n1386             model_name,\n1387         ), alt_constraints in self.altered_constraints.items():\n1388             for constraint in alt_constraints[\"removed_constraints\"]:\n1389                 self.add_operation(\n1390                     app_label,\n1391                     operations.RemoveConstraint(\n1392                         model_name=model_name,\n1393                         name=constraint.name,\n1394                     ),\n1395                 )\n1396 \n1397     @staticmethod\n1398     def _get_dependencies_for_foreign_key(app_label, model_name, field, project_state):\n1399         remote_field_model = None\n1400         if hasattr(field.remote_field, \"model\"):\n1401             remote_field_model = field.remote_field.model\n1402         else:\n1403             relations = project_state.relations[app_label, model_name]\n1404             for (remote_app_label, remote_model_name), fields in relations.items():\n1405                 if any(\n1406                     field == related_field.remote_field\n1407                     for related_field in fields.values()\n1408                 ):\n1409                     remote_field_model = f\"{remote_app_label}.{remote_model_name}\"\n1410                     break\n1411         # Account for FKs to swappable models\n1412         swappable_setting = getattr(field, \"swappable_setting\", None)\n1413         if swappable_setting is not None:\n1414             dep_app_label = \"__setting__\"\n1415             dep_object_name = swappable_setting\n1416         else:\n1417             dep_app_label, dep_object_name = resolve_relation(\n1418                 remote_field_model,\n1419                 app_label,\n1420                 model_name,\n1421             )\n1422         dependencies = [(dep_app_label, dep_object_name, None, True)]\n1423         if getattr(field.remote_field, \"through\", None):\n1424             through_app_label, through_object_name = resolve_relation(\n1425                 field.remote_field.through,\n1426                 app_label,\n1427                 model_name,\n1428             )\n1429             dependencies.append((through_app_label, through_object_name, None, True))\n1430         return dependencies\n1431 \n1432     def _get_altered_foo_together_operations(self, option_name):\n1433         for app_label, model_name in sorted(self.kept_model_keys):\n1434             old_model_name = self.renamed_models.get(\n1435                 (app_label, model_name), model_name\n1436             )\n1437             old_model_state = self.from_state.models[app_label, old_model_name]\n1438             new_model_state = self.to_state.models[app_label, model_name]\n1439 \n1440             # We run the old version through the field renames to account for those\n1441             old_value = old_model_state.options.get(option_name)\n1442             old_value = (\n1443                 {\n1444                     tuple(\n1445                         self.renamed_fields.get((app_label, model_name, n), n)\n1446                         for n in unique\n1447                     )\n1448                     for unique in old_value\n1449                 }\n1450                 if old_value\n1451                 else set()\n1452             )\n1453 \n1454             new_value = new_model_state.options.get(option_name)\n1455             new_value = set(new_value) if new_value else set()\n1456 \n1457             if old_value != new_value:\n1458                 dependencies = []\n1459                 for foo_togethers in new_value:\n1460                     for field_name in foo_togethers:\n1461                         field = new_model_state.get_field(field_name)\n1462                         if field.remote_field and field.remote_field.model:\n1463                             dependencies.extend(\n1464                                 self._get_dependencies_for_foreign_key(\n1465                                     app_label,\n1466                                     model_name,\n1467                                     field,\n1468                                     self.to_state,\n1469                                 )\n1470                             )\n1471                 yield (\n1472                     old_value,\n1473                     new_value,\n1474                     app_label,\n1475                     model_name,\n1476                     dependencies,\n1477                 )\n1478 \n1479     def _generate_removed_altered_foo_together(self, operation):\n1480         for (\n1481             old_value,\n1482             new_value,\n1483             app_label,\n1484             model_name,\n1485             dependencies,\n1486         ) in self._get_altered_foo_together_operations(operation.option_name):\n1487             if operation == operations.AlterIndexTogether:\n1488                 old_value = {\n1489                     value\n1490                     for value in old_value\n1491                     if value\n1492                     not in self.renamed_index_together_values[app_label, model_name]\n1493                 }\n1494             removal_value = new_value.intersection(old_value)\n1495             if removal_value or old_value:\n1496                 self.add_operation(\n1497                     app_label,\n1498                     operation(\n1499                         name=model_name, **{operation.option_name: removal_value}\n1500                     ),\n1501                     dependencies=dependencies,\n1502                 )\n1503 \n1504     def generate_removed_altered_unique_together(self):\n1505         self._generate_removed_altered_foo_together(operations.AlterUniqueTogether)\n1506 \n1507     # RemovedInDjango51Warning.\n1508     def generate_removed_altered_index_together(self):\n1509         self._generate_removed_altered_foo_together(operations.AlterIndexTogether)\n1510 \n1511     def _generate_altered_foo_together(self, operation):\n1512         for (\n1513             old_value,\n1514             new_value,\n1515             app_label,\n1516             model_name,\n1517             dependencies,\n1518         ) in self._get_altered_foo_together_operations(operation.option_name):\n1519             removal_value = new_value.intersection(old_value)\n1520             if new_value != removal_value:\n1521                 self.add_operation(\n1522                     app_label,\n1523                     operation(name=model_name, **{operation.option_name: new_value}),\n1524                     dependencies=dependencies,\n1525                 )\n1526 \n1527     def generate_altered_unique_together(self):\n1528         self._generate_altered_foo_together(operations.AlterUniqueTogether)\n1529 \n1530     # RemovedInDjango51Warning.\n1531     def generate_altered_index_together(self):\n1532         self._generate_altered_foo_together(operations.AlterIndexTogether)\n1533 \n1534     def generate_altered_db_table(self):\n1535         models_to_check = self.kept_model_keys.union(\n1536             self.kept_proxy_keys, self.kept_unmanaged_keys\n1537         )\n1538         for app_label, model_name in sorted(models_to_check):\n1539             old_model_name = self.renamed_models.get(\n1540                 (app_label, model_name), model_name\n1541             )\n1542             old_model_state = self.from_state.models[app_label, old_model_name]\n1543             new_model_state = self.to_state.models[app_label, model_name]\n1544             old_db_table_name = old_model_state.options.get(\"db_table\")\n1545             new_db_table_name = new_model_state.options.get(\"db_table\")\n1546             if old_db_table_name != new_db_table_name:\n1547                 self.add_operation(\n1548                     app_label,\n1549                     operations.AlterModelTable(\n1550                         name=model_name,\n1551                         table=new_db_table_name,\n1552                     ),\n1553                 )\n1554 \n1555     def generate_altered_options(self):\n1556         \"\"\"\n1557         Work out if any non-schema-affecting options have changed and make an\n1558         operation to represent them in state changes (in case Python code in\n1559         migrations needs them).\n1560         \"\"\"\n1561         models_to_check = self.kept_model_keys.union(\n1562             self.kept_proxy_keys,\n1563             self.kept_unmanaged_keys,\n1564             # unmanaged converted to managed\n1565             self.old_unmanaged_keys & self.new_model_keys,\n1566             # managed converted to unmanaged\n1567             self.old_model_keys & self.new_unmanaged_keys,\n1568         )\n1569 \n1570         for app_label, model_name in sorted(models_to_check):\n1571             old_model_name = self.renamed_models.get(\n1572                 (app_label, model_name), model_name\n1573             )\n1574             old_model_state = self.from_state.models[app_label, old_model_name]\n1575             new_model_state = self.to_state.models[app_label, model_name]\n1576             old_options = {\n1577                 key: value\n1578                 for key, value in old_model_state.options.items()\n1579                 if key in AlterModelOptions.ALTER_OPTION_KEYS\n1580             }\n1581             new_options = {\n1582                 key: value\n1583                 for key, value in new_model_state.options.items()\n1584                 if key in AlterModelOptions.ALTER_OPTION_KEYS\n1585             }\n1586             if old_options != new_options:\n1587                 self.add_operation(\n1588                     app_label,\n1589                     operations.AlterModelOptions(\n1590                         name=model_name,\n1591                         options=new_options,\n1592                     ),\n1593                 )\n1594 \n1595     def generate_altered_order_with_respect_to(self):\n1596         for app_label, model_name in sorted(self.kept_model_keys):\n1597             old_model_name = self.renamed_models.get(\n1598                 (app_label, model_name), model_name\n1599             )\n1600             old_model_state = self.from_state.models[app_label, old_model_name]\n1601             new_model_state = self.to_state.models[app_label, model_name]\n1602             if old_model_state.options.get(\n1603                 \"order_with_respect_to\"\n1604             ) != new_model_state.options.get(\"order_with_respect_to\"):\n1605                 # Make sure it comes second if we're adding\n1606                 # (removal dependency is part of RemoveField)\n1607                 dependencies = []\n1608                 if new_model_state.options.get(\"order_with_respect_to\"):\n1609                     dependencies.append(\n1610                         (\n1611                             app_label,\n1612                             model_name,\n1613                             new_model_state.options[\"order_with_respect_to\"],\n1614                             True,\n1615                         )\n1616                     )\n1617                 # Actually generate the operation\n1618                 self.add_operation(\n1619                     app_label,\n1620                     operations.AlterOrderWithRespectTo(\n1621                         name=model_name,\n1622                         order_with_respect_to=new_model_state.options.get(\n1623                             \"order_with_respect_to\"\n1624                         ),\n1625                     ),\n1626                     dependencies=dependencies,\n1627                 )\n1628 \n1629     def generate_altered_managers(self):\n1630         for app_label, model_name in sorted(self.kept_model_keys):\n1631             old_model_name = self.renamed_models.get(\n1632                 (app_label, model_name), model_name\n1633             )\n1634             old_model_state = self.from_state.models[app_label, old_model_name]\n1635             new_model_state = self.to_state.models[app_label, model_name]\n1636             if old_model_state.managers != new_model_state.managers:\n1637                 self.add_operation(\n1638                     app_label,\n1639                     operations.AlterModelManagers(\n1640                         name=model_name,\n1641                         managers=new_model_state.managers,\n1642                     ),\n1643                 )\n1644 \n1645     def arrange_for_graph(self, changes, graph, migration_name=None):\n1646         \"\"\"\n1647         Take a result from changes() and a MigrationGraph, and fix the names\n1648         and dependencies of the changes so they extend the graph from the leaf\n1649         nodes for each app.\n1650         \"\"\"\n1651         leaves = graph.leaf_nodes()\n1652         name_map = {}\n1653         for app_label, migrations in list(changes.items()):\n1654             if not migrations:\n1655                 continue\n1656             # Find the app label's current leaf node\n1657             app_leaf = None\n1658             for leaf in leaves:\n1659                 if leaf[0] == app_label:\n1660                     app_leaf = leaf\n1661                     break\n1662             # Do they want an initial migration for this app?\n1663             if app_leaf is None and not self.questioner.ask_initial(app_label):\n1664                 # They don't.\n1665                 for migration in migrations:\n1666                     name_map[(app_label, migration.name)] = (app_label, \"__first__\")\n1667                 del changes[app_label]\n1668                 continue\n1669             # Work out the next number in the sequence\n1670             if app_leaf is None:\n1671                 next_number = 1\n1672             else:\n1673                 next_number = (self.parse_number(app_leaf[1]) or 0) + 1\n1674             # Name each migration\n1675             for i, migration in enumerate(migrations):\n1676                 if i == 0 and app_leaf:\n1677                     migration.dependencies.append(app_leaf)\n1678                 new_name_parts = [\"%04i\" % next_number]\n1679                 if migration_name:\n1680                     new_name_parts.append(migration_name)\n1681                 elif i == 0 and not app_leaf:\n1682                     new_name_parts.append(\"initial\")\n1683                 else:\n1684                     new_name_parts.append(migration.suggest_name()[:100])\n1685                 new_name = \"_\".join(new_name_parts)\n1686                 name_map[(app_label, migration.name)] = (app_label, new_name)\n1687                 next_number += 1\n1688                 migration.name = new_name\n1689         # Now fix dependencies\n1690         for migrations in changes.values():\n1691             for migration in migrations:\n1692                 migration.dependencies = [\n1693                     name_map.get(d, d) for d in migration.dependencies\n1694                 ]\n1695         return changes\n1696 \n1697     def _trim_to_apps(self, changes, app_labels):\n1698         \"\"\"\n1699         Take changes from arrange_for_graph() and set of app labels, and return\n1700         a modified set of changes which trims out as many migrations that are\n1701         not in app_labels as possible. Note that some other migrations may\n1702         still be present as they may be required dependencies.\n1703         \"\"\"\n1704         # Gather other app dependencies in a first pass\n1705         app_dependencies = {}\n1706         for app_label, migrations in changes.items():\n1707             for migration in migrations:\n1708                 for dep_app_label, name in migration.dependencies:\n1709                     app_dependencies.setdefault(app_label, set()).add(dep_app_label)\n1710         required_apps = set(app_labels)\n1711         # Keep resolving till there's no change\n1712         old_required_apps = None\n1713         while old_required_apps != required_apps:\n1714             old_required_apps = set(required_apps)\n1715             required_apps.update(\n1716                 *[app_dependencies.get(app_label, ()) for app_label in required_apps]\n1717             )\n1718         # Remove all migrations that aren't needed\n1719         for app_label in list(changes):\n1720             if app_label not in required_apps:\n1721                 del changes[app_label]\n1722         return changes\n1723 \n1724     @classmethod\n1725     def parse_number(cls, name):\n1726         \"\"\"\n1727         Given a migration name, try to extract a number from the beginning of\n1728         it. For a squashed migration such as '0001_squashed_0004\u2026', return the\n1729         second number. If no number is found, return None.\n1730         \"\"\"\n1731         if squashed_match := re.search(r\".*_squashed_(\\d+)\", name):\n1732             return int(squashed_match[1])\n1733         match = re.match(r\"^\\d+\", name)\n1734         if match:\n1735             return int(match[0])\n1736         return None\n",
        "intended_behavior": "Enhance detection logic for `ManyToManyField` when its target changes, especially to 'self'. Ensure that the autodetector generates accurate migration operations that reflect complex changes in field relationships, such as changes in target models or the introduction of self-referencing relations."
    },
    {
        "rel_file_path": "django/db/migrations/operations/fields.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__4.2/django/db/migrations/operations/fields.py",
        "start": 1,
        "end": 357,
        "class_name": null,
        "method_name": null,
        "code": "1 from django.db.migrations.utils import field_references\n2 from django.db.models import NOT_PROVIDED\n3 from django.utils.functional import cached_property\n4 \n5 from .base import Operation\n6 \n7 \n8 class FieldOperation(Operation):\n9     def __init__(self, model_name, name, field=None):\n10         self.model_name = model_name\n11         self.name = name\n12         self.field = field\n13 \n14     @cached_property\n15     def model_name_lower(self):\n16         return self.model_name.lower()\n17 \n18     @cached_property\n19     def name_lower(self):\n20         return self.name.lower()\n21 \n22     def is_same_model_operation(self, operation):\n23         return self.model_name_lower == operation.model_name_lower\n24 \n25     def is_same_field_operation(self, operation):\n26         return (\n27             self.is_same_model_operation(operation)\n28             and self.name_lower == operation.name_lower\n29         )\n30 \n31     def references_model(self, name, app_label):\n32         name_lower = name.lower()\n33         if name_lower == self.model_name_lower:\n34             return True\n35         if self.field:\n36             return bool(\n37                 field_references(\n38                     (app_label, self.model_name_lower),\n39                     self.field,\n40                     (app_label, name_lower),\n41                 )\n42             )\n43         return False\n44 \n45     def references_field(self, model_name, name, app_label):\n46         model_name_lower = model_name.lower()\n47         # Check if this operation locally references the field.\n48         if model_name_lower == self.model_name_lower:\n49             if name == self.name:\n50                 return True\n51             elif (\n52                 self.field\n53                 and hasattr(self.field, \"from_fields\")\n54                 and name in self.field.from_fields\n55             ):\n56                 return True\n57         # Check if this operation remotely references the field.\n58         if self.field is None:\n59             return False\n60         return bool(\n61             field_references(\n62                 (app_label, self.model_name_lower),\n63                 self.field,\n64                 (app_label, model_name_lower),\n65                 name,\n66             )\n67         )\n68 \n69     def reduce(self, operation, app_label):\n70         return super().reduce(operation, app_label) or not operation.references_field(\n71             self.model_name, self.name, app_label\n72         )\n73 \n74 \n75 class AddField(FieldOperation):\n76     \"\"\"Add a field to a model.\"\"\"\n77 \n78     def __init__(self, model_name, name, field, preserve_default=True):\n79         self.preserve_default = preserve_default\n80         super().__init__(model_name, name, field)\n81 \n82     def deconstruct(self):\n83         kwargs = {\n84             \"model_name\": self.model_name,\n85             \"name\": self.name,\n86             \"field\": self.field,\n87         }\n88         if self.preserve_default is not True:\n89             kwargs[\"preserve_default\"] = self.preserve_default\n90         return (self.__class__.__name__, [], kwargs)\n91 \n92     def state_forwards(self, app_label, state):\n93         state.add_field(\n94             app_label,\n95             self.model_name_lower,\n96             self.name,\n97             self.field,\n98             self.preserve_default,\n99         )\n100 \n101     def database_forwards(self, app_label, schema_editor, from_state, to_state):\n102         to_model = to_state.apps.get_model(app_label, self.model_name)\n103         if self.allow_migrate_model(schema_editor.connection.alias, to_model):\n104             from_model = from_state.apps.get_model(app_label, self.model_name)\n105             field = to_model._meta.get_field(self.name)\n106             if not self.preserve_default:\n107                 field.default = self.field.default\n108             schema_editor.add_field(\n109                 from_model,\n110                 field,\n111             )\n112             if not self.preserve_default:\n113                 field.default = NOT_PROVIDED\n114 \n115     def database_backwards(self, app_label, schema_editor, from_state, to_state):\n116         from_model = from_state.apps.get_model(app_label, self.model_name)\n117         if self.allow_migrate_model(schema_editor.connection.alias, from_model):\n118             schema_editor.remove_field(\n119                 from_model, from_model._meta.get_field(self.name)\n120             )\n121 \n122     def describe(self):\n123         return \"Add field %s to %s\" % (self.name, self.model_name)\n124 \n125     @property\n126     def migration_name_fragment(self):\n127         return \"%s_%s\" % (self.model_name_lower, self.name_lower)\n128 \n129     def reduce(self, operation, app_label):\n130         if isinstance(operation, FieldOperation) and self.is_same_field_operation(\n131             operation\n132         ):\n133             if isinstance(operation, AlterField):\n134                 return [\n135                     AddField(\n136                         model_name=self.model_name,\n137                         name=operation.name,\n138                         field=operation.field,\n139                     ),\n140                 ]\n141             elif isinstance(operation, RemoveField):\n142                 return []\n143             elif isinstance(operation, RenameField):\n144                 return [\n145                     AddField(\n146                         model_name=self.model_name,\n147                         name=operation.new_name,\n148                         field=self.field,\n149                     ),\n150                 ]\n151         return super().reduce(operation, app_label)\n152 \n153 \n154 class RemoveField(FieldOperation):\n155     \"\"\"Remove a field from a model.\"\"\"\n156 \n157     def deconstruct(self):\n158         kwargs = {\n159             \"model_name\": self.model_name,\n160             \"name\": self.name,\n161         }\n162         return (self.__class__.__name__, [], kwargs)\n163 \n164     def state_forwards(self, app_label, state):\n165         state.remove_field(app_label, self.model_name_lower, self.name)\n166 \n167     def database_forwards(self, app_label, schema_editor, from_state, to_state):\n168         from_model = from_state.apps.get_model(app_label, self.model_name)\n169         if self.allow_migrate_model(schema_editor.connection.alias, from_model):\n170             schema_editor.remove_field(\n171                 from_model, from_model._meta.get_field(self.name)\n172             )\n173 \n174     def database_backwards(self, app_label, schema_editor, from_state, to_state):\n175         to_model = to_state.apps.get_model(app_label, self.model_name)\n176         if self.allow_migrate_model(schema_editor.connection.alias, to_model):\n177             from_model = from_state.apps.get_model(app_label, self.model_name)\n178             schema_editor.add_field(from_model, to_model._meta.get_field(self.name))\n179 \n180     def describe(self):\n181         return \"Remove field %s from %s\" % (self.name, self.model_name)\n182 \n183     @property\n184     def migration_name_fragment(self):\n185         return \"remove_%s_%s\" % (self.model_name_lower, self.name_lower)\n186 \n187     def reduce(self, operation, app_label):\n188         from .models import DeleteModel\n189 \n190         if (\n191             isinstance(operation, DeleteModel)\n192             and operation.name_lower == self.model_name_lower\n193         ):\n194             return [operation]\n195         return super().reduce(operation, app_label)\n196 \n197 \n198 class AlterField(FieldOperation):\n199     \"\"\"\n200     Alter a field's database column (e.g. null, max_length) to the provided\n201     new field.\n202     \"\"\"\n203 \n204     def __init__(self, model_name, name, field, preserve_default=True):\n205         self.preserve_default = preserve_default\n206         super().__init__(model_name, name, field)\n207 \n208     def deconstruct(self):\n209         kwargs = {\n210             \"model_name\": self.model_name,\n211             \"name\": self.name,\n212             \"field\": self.field,\n213         }\n214         if self.preserve_default is not True:\n215             kwargs[\"preserve_default\"] = self.preserve_default\n216         return (self.__class__.__name__, [], kwargs)\n217 \n218     def state_forwards(self, app_label, state):\n219         state.alter_field(\n220             app_label,\n221             self.model_name_lower,\n222             self.name,\n223             self.field,\n224             self.preserve_default,\n225         )\n226 \n227     def database_forwards(self, app_label, schema_editor, from_state, to_state):\n228         to_model = to_state.apps.get_model(app_label, self.model_name)\n229         if self.allow_migrate_model(schema_editor.connection.alias, to_model):\n230             from_model = from_state.apps.get_model(app_label, self.model_name)\n231             from_field = from_model._meta.get_field(self.name)\n232             to_field = to_model._meta.get_field(self.name)\n233             if not self.preserve_default:\n234                 to_field.default = self.field.default\n235             schema_editor.alter_field(from_model, from_field, to_field)\n236             if not self.preserve_default:\n237                 to_field.default = NOT_PROVIDED\n238 \n239     def database_backwards(self, app_label, schema_editor, from_state, to_state):\n240         self.database_forwards(app_label, schema_editor, from_state, to_state)\n241 \n242     def describe(self):\n243         return \"Alter field %s on %s\" % (self.name, self.model_name)\n244 \n245     @property\n246     def migration_name_fragment(self):\n247         return \"alter_%s_%s\" % (self.model_name_lower, self.name_lower)\n248 \n249     def reduce(self, operation, app_label):\n250         if isinstance(operation, RemoveField) and self.is_same_field_operation(\n251             operation\n252         ):\n253             return [operation]\n254         elif (\n255             isinstance(operation, RenameField)\n256             and self.is_same_field_operation(operation)\n257             and self.field.db_column is None\n258         ):\n259             return [\n260                 operation,\n261                 AlterField(\n262                     model_name=self.model_name,\n263                     name=operation.new_name,\n264                     field=self.field,\n265                 ),\n266             ]\n267         return super().reduce(operation, app_label)\n268 \n269 \n270 class RenameField(FieldOperation):\n271     \"\"\"Rename a field on the model. Might affect db_column too.\"\"\"\n272 \n273     def __init__(self, model_name, old_name, new_name):\n274         self.old_name = old_name\n275         self.new_name = new_name\n276         super().__init__(model_name, old_name)\n277 \n278     @cached_property\n279     def old_name_lower(self):\n280         return self.old_name.lower()\n281 \n282     @cached_property\n283     def new_name_lower(self):\n284         return self.new_name.lower()\n285 \n286     def deconstruct(self):\n287         kwargs = {\n288             \"model_name\": self.model_name,\n289             \"old_name\": self.old_name,\n290             \"new_name\": self.new_name,\n291         }\n292         return (self.__class__.__name__, [], kwargs)\n293 \n294     def state_forwards(self, app_label, state):\n295         state.rename_field(\n296             app_label, self.model_name_lower, self.old_name, self.new_name\n297         )\n298 \n299     def database_forwards(self, app_label, schema_editor, from_state, to_state):\n300         to_model = to_state.apps.get_model(app_label, self.model_name)\n301         if self.allow_migrate_model(schema_editor.connection.alias, to_model):\n302             from_model = from_state.apps.get_model(app_label, self.model_name)\n303             schema_editor.alter_field(\n304                 from_model,\n305                 from_model._meta.get_field(self.old_name),\n306                 to_model._meta.get_field(self.new_name),\n307             )\n308 \n309     def database_backwards(self, app_label, schema_editor, from_state, to_state):\n310         to_model = to_state.apps.get_model(app_label, self.model_name)\n311         if self.allow_migrate_model(schema_editor.connection.alias, to_model):\n312             from_model = from_state.apps.get_model(app_label, self.model_name)\n313             schema_editor.alter_field(\n314                 from_model,\n315                 from_model._meta.get_field(self.new_name),\n316                 to_model._meta.get_field(self.old_name),\n317             )\n318 \n319     def describe(self):\n320         return \"Rename field %s on %s to %s\" % (\n321             self.old_name,\n322             self.model_name,\n323             self.new_name,\n324         )\n325 \n326     @property\n327     def migration_name_fragment(self):\n328         return \"rename_%s_%s_%s\" % (\n329             self.old_name_lower,\n330             self.model_name_lower,\n331             self.new_name_lower,\n332         )\n333 \n334     def references_field(self, model_name, name, app_label):\n335         return self.references_model(model_name, app_label) and (\n336             name.lower() == self.old_name_lower or name.lower() == self.new_name_lower\n337         )\n338 \n339     def reduce(self, operation, app_label):\n340         if (\n341             isinstance(operation, RenameField)\n342             and self.is_same_model_operation(operation)\n343             and self.new_name_lower == operation.old_name_lower\n344         ):\n345             return [\n346                 RenameField(\n347                     self.model_name,\n348                     self.old_name,\n349                     operation.new_name,\n350                 ),\n351             ]\n352         # Skip `FieldOperation.reduce` as we want to run `references_field`\n353         # against self.old_name and self.new_name.\n354         return super(FieldOperation, self).reduce(operation, app_label) or not (\n355             operation.references_field(self.model_name, self.old_name, app_label)\n356             or operation.references_field(self.model_name, self.new_name, app_label)\n357         )\n",
        "intended_behavior": "Incorporate logic to handle the special case where a `ManyToManyField` is altered to target 'self', ensuring the correct intermediary table schema is generated and existing references are updated or maintained properly. Ensure that both `AddField` and `AlterField` operations accurately apply schema changes for self-referencing many-to-many relationships."
    },
    {
        "rel_file_path": "django/db/models/fields/related.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__4.2/django/db/models/fields/related.py",
        "start": 1,
        "end": 1993,
        "class_name": null,
        "method_name": null,
        "code": "1 import functools\n2 import inspect\n3 from functools import partial\n4 \n5 from django import forms\n6 from django.apps import apps\n7 from django.conf import SettingsReference, settings\n8 from django.core import checks, exceptions\n9 from django.db import connection, router\n10 from django.db.backends import utils\n11 from django.db.models import Q\n12 from django.db.models.constants import LOOKUP_SEP\n13 from django.db.models.deletion import CASCADE, SET_DEFAULT, SET_NULL\n14 from django.db.models.query_utils import PathInfo\n15 from django.db.models.utils import make_model_tuple\n16 from django.utils.functional import cached_property\n17 from django.utils.translation import gettext_lazy as _\n18 \n19 from . import Field\n20 from .mixins import FieldCacheMixin\n21 from .related_descriptors import (\n22     ForeignKeyDeferredAttribute,\n23     ForwardManyToOneDescriptor,\n24     ForwardOneToOneDescriptor,\n25     ManyToManyDescriptor,\n26     ReverseManyToOneDescriptor,\n27     ReverseOneToOneDescriptor,\n28 )\n29 from .related_lookups import (\n30     RelatedExact,\n31     RelatedGreaterThan,\n32     RelatedGreaterThanOrEqual,\n33     RelatedIn,\n34     RelatedIsNull,\n35     RelatedLessThan,\n36     RelatedLessThanOrEqual,\n37 )\n38 from .reverse_related import ForeignObjectRel, ManyToManyRel, ManyToOneRel, OneToOneRel\n39 \n40 RECURSIVE_RELATIONSHIP_CONSTANT = \"self\"\n41 \n42 \n43 def resolve_relation(scope_model, relation):\n44     \"\"\"\n45     Transform relation into a model or fully-qualified model string of the form\n46     \"app_label.ModelName\", relative to scope_model.\n47 \n48     The relation argument can be:\n49       * RECURSIVE_RELATIONSHIP_CONSTANT, i.e. the string \"self\", in which case\n50         the model argument will be returned.\n51       * A bare model name without an app_label, in which case scope_model's\n52         app_label will be prepended.\n53       * An \"app_label.ModelName\" string.\n54       * A model class, which will be returned unchanged.\n55     \"\"\"\n56     # Check for recursive relations\n57     if relation == RECURSIVE_RELATIONSHIP_CONSTANT:\n58         relation = scope_model\n59 \n60     # Look for an \"app.Model\" relation\n61     if isinstance(relation, str):\n62         if \".\" not in relation:\n63             relation = \"%s.%s\" % (scope_model._meta.app_label, relation)\n64 \n65     return relation\n66 \n67 \n68 def lazy_related_operation(function, model, *related_models, **kwargs):\n69     \"\"\"\n70     Schedule `function` to be called once `model` and all `related_models`\n71     have been imported and registered with the app registry. `function` will\n72     be called with the newly-loaded model classes as its positional arguments,\n73     plus any optional keyword arguments.\n74 \n75     The `model` argument must be a model class. Each subsequent positional\n76     argument is another model, or a reference to another model - see\n77     `resolve_relation()` for the various forms these may take. Any relative\n78     references will be resolved relative to `model`.\n79 \n80     This is a convenience wrapper for `Apps.lazy_model_operation` - the app\n81     registry model used is the one found in `model._meta.apps`.\n82     \"\"\"\n83     models = [model] + [resolve_relation(model, rel) for rel in related_models]\n84     model_keys = (make_model_tuple(m) for m in models)\n85     apps = model._meta.apps\n86     return apps.lazy_model_operation(partial(function, **kwargs), *model_keys)\n87 \n88 \n89 class RelatedField(FieldCacheMixin, Field):\n90     \"\"\"Base class that all relational fields inherit from.\"\"\"\n91 \n92     # Field flags\n93     one_to_many = False\n94     one_to_one = False\n95     many_to_many = False\n96     many_to_one = False\n97 \n98     def __init__(\n99         self,\n100         related_name=None,\n101         related_query_name=None,\n102         limit_choices_to=None,\n103         **kwargs,\n104     ):\n105         self._related_name = related_name\n106         self._related_query_name = related_query_name\n107         self._limit_choices_to = limit_choices_to\n108         super().__init__(**kwargs)\n109 \n110     @cached_property\n111     def related_model(self):\n112         # Can't cache this property until all the models are loaded.\n113         apps.check_models_ready()\n114         return self.remote_field.model\n115 \n116     def check(self, **kwargs):\n117         return [\n118             *super().check(**kwargs),\n119             *self._check_related_name_is_valid(),\n120             *self._check_related_query_name_is_valid(),\n121             *self._check_relation_model_exists(),\n122             *self._check_referencing_to_swapped_model(),\n123             *self._check_clashes(),\n124         ]\n125 \n126     def _check_related_name_is_valid(self):\n127         import keyword\n128 \n129         related_name = self.remote_field.related_name\n130         if related_name is None:\n131             return []\n132         is_valid_id = (\n133             not keyword.iskeyword(related_name) and related_name.isidentifier()\n134         )\n135         if not (is_valid_id or related_name.endswith(\"+\")):\n136             return [\n137                 checks.Error(\n138                     \"The name '%s' is invalid related_name for field %s.%s\"\n139                     % (\n140                         self.remote_field.related_name,\n141                         self.model._meta.object_name,\n142                         self.name,\n143                     ),\n144                     hint=(\n145                         \"Related name must be a valid Python identifier or end with a \"\n146                         \"'+'\"\n147                     ),\n148                     obj=self,\n149                     id=\"fields.E306\",\n150                 )\n151             ]\n152         return []\n153 \n154     def _check_related_query_name_is_valid(self):\n155         if self.remote_field.is_hidden():\n156             return []\n157         rel_query_name = self.related_query_name()\n158         errors = []\n159         if rel_query_name.endswith(\"_\"):\n160             errors.append(\n161                 checks.Error(\n162                     \"Reverse query name '%s' must not end with an underscore.\"\n163                     % rel_query_name,\n164                     hint=(\n165                         \"Add or change a related_name or related_query_name \"\n166                         \"argument for this field.\"\n167                     ),\n168                     obj=self,\n169                     id=\"fields.E308\",\n170                 )\n171             )\n172         if LOOKUP_SEP in rel_query_name:\n173             errors.append(\n174                 checks.Error(\n175                     \"Reverse query name '%s' must not contain '%s'.\"\n176                     % (rel_query_name, LOOKUP_SEP),\n177                     hint=(\n178                         \"Add or change a related_name or related_query_name \"\n179                         \"argument for this field.\"\n180                     ),\n181                     obj=self,\n182                     id=\"fields.E309\",\n183                 )\n184             )\n185         return errors\n186 \n187     def _check_relation_model_exists(self):\n188         rel_is_missing = self.remote_field.model not in self.opts.apps.get_models()\n189         rel_is_string = isinstance(self.remote_field.model, str)\n190         model_name = (\n191             self.remote_field.model\n192             if rel_is_string\n193             else self.remote_field.model._meta.object_name\n194         )\n195         if rel_is_missing and (\n196             rel_is_string or not self.remote_field.model._meta.swapped\n197         ):\n198             return [\n199                 checks.Error(\n200                     \"Field defines a relation with model '%s', which is either \"\n201                     \"not installed, or is abstract.\" % model_name,\n202                     obj=self,\n203                     id=\"fields.E300\",\n204                 )\n205             ]\n206         return []\n207 \n208     def _check_referencing_to_swapped_model(self):\n209         if (\n210             self.remote_field.model not in self.opts.apps.get_models()\n211             and not isinstance(self.remote_field.model, str)\n212             and self.remote_field.model._meta.swapped\n213         ):\n214             return [\n215                 checks.Error(\n216                     \"Field defines a relation with the model '%s', which has \"\n217                     \"been swapped out.\" % self.remote_field.model._meta.label,\n218                     hint=\"Update the relation to point at 'settings.%s'.\"\n219                     % self.remote_field.model._meta.swappable,\n220                     obj=self,\n221                     id=\"fields.E301\",\n222                 )\n223             ]\n224         return []\n225 \n226     def _check_clashes(self):\n227         \"\"\"Check accessor and reverse query name clashes.\"\"\"\n228         from django.db.models.base import ModelBase\n229 \n230         errors = []\n231         opts = self.model._meta\n232 \n233         # f.remote_field.model may be a string instead of a model. Skip if\n234         # model name is not resolved.\n235         if not isinstance(self.remote_field.model, ModelBase):\n236             return []\n237 \n238         # Consider that we are checking field `Model.foreign` and the models\n239         # are:\n240         #\n241         #     class Target(models.Model):\n242         #         model = models.IntegerField()\n243         #         model_set = models.IntegerField()\n244         #\n245         #     class Model(models.Model):\n246         #         foreign = models.ForeignKey(Target)\n247         #         m2m = models.ManyToManyField(Target)\n248 \n249         # rel_opts.object_name == \"Target\"\n250         rel_opts = self.remote_field.model._meta\n251         # If the field doesn't install a backward relation on the target model\n252         # (so `is_hidden` returns True), then there are no clashes to check\n253         # and we can skip these fields.\n254         rel_is_hidden = self.remote_field.is_hidden()\n255         rel_name = self.remote_field.get_accessor_name()  # i. e. \"model_set\"\n256         rel_query_name = self.related_query_name()  # i. e. \"model\"\n257         # i.e. \"app_label.Model.field\".\n258         field_name = \"%s.%s\" % (opts.label, self.name)\n259 \n260         # Check clashes between accessor or reverse query name of `field`\n261         # and any other field name -- i.e. accessor for Model.foreign is\n262         # model_set and it clashes with Target.model_set.\n263         potential_clashes = rel_opts.fields + rel_opts.many_to_many\n264         for clash_field in potential_clashes:\n265             # i.e. \"app_label.Target.model_set\".\n266             clash_name = \"%s.%s\" % (rel_opts.label, clash_field.name)\n267             if not rel_is_hidden and clash_field.name == rel_name:\n268                 errors.append(\n269                     checks.Error(\n270                         f\"Reverse accessor '{rel_opts.object_name}.{rel_name}' \"\n271                         f\"for '{field_name}' clashes with field name \"\n272                         f\"'{clash_name}'.\",\n273                         hint=(\n274                             \"Rename field '%s', or add/change a related_name \"\n275                             \"argument to the definition for field '%s'.\"\n276                         )\n277                         % (clash_name, field_name),\n278                         obj=self,\n279                         id=\"fields.E302\",\n280                     )\n281                 )\n282 \n283             if clash_field.name == rel_query_name:\n284                 errors.append(\n285                     checks.Error(\n286                         \"Reverse query name for '%s' clashes with field name '%s'.\"\n287                         % (field_name, clash_name),\n288                         hint=(\n289                             \"Rename field '%s', or add/change a related_name \"\n290                             \"argument to the definition for field '%s'.\"\n291                         )\n292                         % (clash_name, field_name),\n293                         obj=self,\n294                         id=\"fields.E303\",\n295                     )\n296                 )\n297 \n298         # Check clashes between accessors/reverse query names of `field` and\n299         # any other field accessor -- i. e. Model.foreign accessor clashes with\n300         # Model.m2m accessor.\n301         potential_clashes = (r for r in rel_opts.related_objects if r.field is not self)\n302         for clash_field in potential_clashes:\n303             # i.e. \"app_label.Model.m2m\".\n304             clash_name = \"%s.%s\" % (\n305                 clash_field.related_model._meta.label,\n306                 clash_field.field.name,\n307             )\n308             if not rel_is_hidden and clash_field.get_accessor_name() == rel_name:\n309                 errors.append(\n310                     checks.Error(\n311                         f\"Reverse accessor '{rel_opts.object_name}.{rel_name}' \"\n312                         f\"for '{field_name}' clashes with reverse accessor for \"\n313                         f\"'{clash_name}'.\",\n314                         hint=(\n315                             \"Add or change a related_name argument \"\n316                             \"to the definition for '%s' or '%s'.\"\n317                         )\n318                         % (field_name, clash_name),\n319                         obj=self,\n320                         id=\"fields.E304\",\n321                     )\n322                 )\n323 \n324             if clash_field.get_accessor_name() == rel_query_name:\n325                 errors.append(\n326                     checks.Error(\n327                         \"Reverse query name for '%s' clashes with reverse query name \"\n328                         \"for '%s'.\" % (field_name, clash_name),\n329                         hint=(\n330                             \"Add or change a related_name argument \"\n331                             \"to the definition for '%s' or '%s'.\"\n332                         )\n333                         % (field_name, clash_name),\n334                         obj=self,\n335                         id=\"fields.E305\",\n336                     )\n337                 )\n338 \n339         return errors\n340 \n341     def db_type(self, connection):\n342         # By default related field will not have a column as it relates to\n343         # columns from another table.\n344         return None\n345 \n346     def contribute_to_class(self, cls, name, private_only=False, **kwargs):\n347 \n348         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)\n349 \n350         self.opts = cls._meta\n351 \n352         if not cls._meta.abstract:\n353             if self.remote_field.related_name:\n354                 related_name = self.remote_field.related_name\n355             else:\n356                 related_name = self.opts.default_related_name\n357             if related_name:\n358                 related_name %= {\n359                     \"class\": cls.__name__.lower(),\n360                     \"model_name\": cls._meta.model_name.lower(),\n361                     \"app_label\": cls._meta.app_label.lower(),\n362                 }\n363                 self.remote_field.related_name = related_name\n364 \n365             if self.remote_field.related_query_name:\n366                 related_query_name = self.remote_field.related_query_name % {\n367                     \"class\": cls.__name__.lower(),\n368                     \"app_label\": cls._meta.app_label.lower(),\n369                 }\n370                 self.remote_field.related_query_name = related_query_name\n371 \n372             def resolve_related_class(model, related, field):\n373                 field.remote_field.model = related\n374                 field.do_related_class(related, model)\n375 \n376             lazy_related_operation(\n377                 resolve_related_class, cls, self.remote_field.model, field=self\n378             )\n379 \n380     def deconstruct(self):\n381         name, path, args, kwargs = super().deconstruct()\n382         if self._limit_choices_to:\n383             kwargs[\"limit_choices_to\"] = self._limit_choices_to\n384         if self._related_name is not None:\n385             kwargs[\"related_name\"] = self._related_name\n386         if self._related_query_name is not None:\n387             kwargs[\"related_query_name\"] = self._related_query_name\n388         return name, path, args, kwargs\n389 \n390     def get_forward_related_filter(self, obj):\n391         \"\"\"\n392         Return the keyword arguments that when supplied to\n393         self.model.object.filter(), would select all instances related through\n394         this field to the remote obj. This is used to build the querysets\n395         returned by related descriptors. obj is an instance of\n396         self.related_field.model.\n397         \"\"\"\n398         return {\n399             \"%s__%s\" % (self.name, rh_field.name): getattr(obj, rh_field.attname)\n400             for _, rh_field in self.related_fields\n401         }\n402 \n403     def get_reverse_related_filter(self, obj):\n404         \"\"\"\n405         Complement to get_forward_related_filter(). Return the keyword\n406         arguments that when passed to self.related_field.model.object.filter()\n407         select all instances of self.related_field.model related through\n408         this field to obj. obj is an instance of self.model.\n409         \"\"\"\n410         base_q = Q.create(\n411             [\n412                 (rh_field.attname, getattr(obj, lh_field.attname))\n413                 for lh_field, rh_field in self.related_fields\n414             ]\n415         )\n416         descriptor_filter = self.get_extra_descriptor_filter(obj)\n417         if isinstance(descriptor_filter, dict):\n418             return base_q & Q(**descriptor_filter)\n419         elif descriptor_filter:\n420             return base_q & descriptor_filter\n421         return base_q\n422 \n423     @property\n424     def swappable_setting(self):\n425         \"\"\"\n426         Get the setting that this is powered from for swapping, or None\n427         if it's not swapped in / marked with swappable=False.\n428         \"\"\"\n429         if self.swappable:\n430             # Work out string form of \"to\"\n431             if isinstance(self.remote_field.model, str):\n432                 to_string = self.remote_field.model\n433             else:\n434                 to_string = self.remote_field.model._meta.label\n435             return apps.get_swappable_settings_name(to_string)\n436         return None\n437 \n438     def set_attributes_from_rel(self):\n439         self.name = self.name or (\n440             self.remote_field.model._meta.model_name\n441             + \"_\"\n442             + self.remote_field.model._meta.pk.name\n443         )\n444         if self.verbose_name is None:\n445             self.verbose_name = self.remote_field.model._meta.verbose_name\n446         self.remote_field.set_field_name()\n447 \n448     def do_related_class(self, other, cls):\n449         self.set_attributes_from_rel()\n450         self.contribute_to_related_class(other, self.remote_field)\n451 \n452     def get_limit_choices_to(self):\n453         \"\"\"\n454         Return ``limit_choices_to`` for this model field.\n455 \n456         If it is a callable, it will be invoked and the result will be\n457         returned.\n458         \"\"\"\n459         if callable(self.remote_field.limit_choices_to):\n460             return self.remote_field.limit_choices_to()\n461         return self.remote_field.limit_choices_to\n462 \n463     def formfield(self, **kwargs):\n464         \"\"\"\n465         Pass ``limit_choices_to`` to the field being constructed.\n466 \n467         Only passes it if there is a type that supports related fields.\n468         This is a similar strategy used to pass the ``queryset`` to the field\n469         being constructed.\n470         \"\"\"\n471         defaults = {}\n472         if hasattr(self.remote_field, \"get_related_field\"):\n473             # If this is a callable, do not invoke it here. Just pass\n474             # it in the defaults for when the form class will later be\n475             # instantiated.\n476             limit_choices_to = self.remote_field.limit_choices_to\n477             defaults.update(\n478                 {\n479                     \"limit_choices_to\": limit_choices_to,\n480                 }\n481             )\n482         defaults.update(kwargs)\n483         return super().formfield(**defaults)\n484 \n485     def related_query_name(self):\n486         \"\"\"\n487         Define the name that can be used to identify this related object in a\n488         table-spanning query.\n489         \"\"\"\n490         return (\n491             self.remote_field.related_query_name\n492             or self.remote_field.related_name\n493             or self.opts.model_name\n494         )\n495 \n496     @property\n497     def target_field(self):\n498         \"\"\"\n499         When filtering against this relation, return the field on the remote\n500         model against which the filtering should happen.\n501         \"\"\"\n502         target_fields = self.path_infos[-1].target_fields\n503         if len(target_fields) > 1:\n504             raise exceptions.FieldError(\n505                 \"The relation has multiple target fields, but only single target field \"\n506                 \"was asked for\"\n507             )\n508         return target_fields[0]\n509 \n510     def get_cache_name(self):\n511         return self.name\n512 \n513 \n514 class ForeignObject(RelatedField):\n515     \"\"\"\n516     Abstraction of the ForeignKey relation to support multi-column relations.\n517     \"\"\"\n518 \n519     # Field flags\n520     many_to_many = False\n521     many_to_one = True\n522     one_to_many = False\n523     one_to_one = False\n524 \n525     requires_unique_target = True\n526     related_accessor_class = ReverseManyToOneDescriptor\n527     forward_related_accessor_class = ForwardManyToOneDescriptor\n528     rel_class = ForeignObjectRel\n529 \n530     def __init__(\n531         self,\n532         to,\n533         on_delete,\n534         from_fields,\n535         to_fields,\n536         rel=None,\n537         related_name=None,\n538         related_query_name=None,\n539         limit_choices_to=None,\n540         parent_link=False,\n541         swappable=True,\n542         **kwargs,\n543     ):\n544 \n545         if rel is None:\n546             rel = self.rel_class(\n547                 self,\n548                 to,\n549                 related_name=related_name,\n550                 related_query_name=related_query_name,\n551                 limit_choices_to=limit_choices_to,\n552                 parent_link=parent_link,\n553                 on_delete=on_delete,\n554             )\n555 \n556         super().__init__(\n557             rel=rel,\n558             related_name=related_name,\n559             related_query_name=related_query_name,\n560             limit_choices_to=limit_choices_to,\n561             **kwargs,\n562         )\n563 \n564         self.from_fields = from_fields\n565         self.to_fields = to_fields\n566         self.swappable = swappable\n567 \n568     def __copy__(self):\n569         obj = super().__copy__()\n570         # Remove any cached PathInfo values.\n571         obj.__dict__.pop(\"path_infos\", None)\n572         obj.__dict__.pop(\"reverse_path_infos\", None)\n573         return obj\n574 \n575     def check(self, **kwargs):\n576         return [\n577             *super().check(**kwargs),\n578             *self._check_to_fields_exist(),\n579             *self._check_unique_target(),\n580         ]\n581 \n582     def _check_to_fields_exist(self):\n583         # Skip nonexistent models.\n584         if isinstance(self.remote_field.model, str):\n585             return []\n586 \n587         errors = []\n588         for to_field in self.to_fields:\n589             if to_field:\n590                 try:\n591                     self.remote_field.model._meta.get_field(to_field)\n592                 except exceptions.FieldDoesNotExist:\n593                     errors.append(\n594                         checks.Error(\n595                             \"The to_field '%s' doesn't exist on the related \"\n596                             \"model '%s'.\"\n597                             % (to_field, self.remote_field.model._meta.label),\n598                             obj=self,\n599                             id=\"fields.E312\",\n600                         )\n601                     )\n602         return errors\n603 \n604     def _check_unique_target(self):\n605         rel_is_string = isinstance(self.remote_field.model, str)\n606         if rel_is_string or not self.requires_unique_target:\n607             return []\n608 \n609         try:\n610             self.foreign_related_fields\n611         except exceptions.FieldDoesNotExist:\n612             return []\n613 \n614         if not self.foreign_related_fields:\n615             return []\n616 \n617         unique_foreign_fields = {\n618             frozenset([f.name])\n619             for f in self.remote_field.model._meta.get_fields()\n620             if getattr(f, \"unique\", False)\n621         }\n622         unique_foreign_fields.update(\n623             {frozenset(ut) for ut in self.remote_field.model._meta.unique_together}\n624         )\n625         unique_foreign_fields.update(\n626             {\n627                 frozenset(uc.fields)\n628                 for uc in self.remote_field.model._meta.total_unique_constraints\n629             }\n630         )\n631         foreign_fields = {f.name for f in self.foreign_related_fields}\n632         has_unique_constraint = any(u <= foreign_fields for u in unique_foreign_fields)\n633 \n634         if not has_unique_constraint and len(self.foreign_related_fields) > 1:\n635             field_combination = \", \".join(\n636                 \"'%s'\" % rel_field.name for rel_field in self.foreign_related_fields\n637             )\n638             model_name = self.remote_field.model.__name__\n639             return [\n640                 checks.Error(\n641                     \"No subset of the fields %s on model '%s' is unique.\"\n642                     % (field_combination, model_name),\n643                     hint=(\n644                         \"Mark a single field as unique=True or add a set of \"\n645                         \"fields to a unique constraint (via unique_together \"\n646                         \"or a UniqueConstraint (without condition) in the \"\n647                         \"model Meta.constraints).\"\n648                     ),\n649                     obj=self,\n650                     id=\"fields.E310\",\n651                 )\n652             ]\n653         elif not has_unique_constraint:\n654             field_name = self.foreign_related_fields[0].name\n655             model_name = self.remote_field.model.__name__\n656             return [\n657                 checks.Error(\n658                     \"'%s.%s' must be unique because it is referenced by \"\n659                     \"a foreign key.\" % (model_name, field_name),\n660                     hint=(\n661                         \"Add unique=True to this field or add a \"\n662                         \"UniqueConstraint (without condition) in the model \"\n663                         \"Meta.constraints.\"\n664                     ),\n665                     obj=self,\n666                     id=\"fields.E311\",\n667                 )\n668             ]\n669         else:\n670             return []\n671 \n672     def deconstruct(self):\n673         name, path, args, kwargs = super().deconstruct()\n674         kwargs[\"on_delete\"] = self.remote_field.on_delete\n675         kwargs[\"from_fields\"] = self.from_fields\n676         kwargs[\"to_fields\"] = self.to_fields\n677 \n678         if self.remote_field.parent_link:\n679             kwargs[\"parent_link\"] = self.remote_field.parent_link\n680         if isinstance(self.remote_field.model, str):\n681             if \".\" in self.remote_field.model:\n682                 app_label, model_name = self.remote_field.model.split(\".\")\n683                 kwargs[\"to\"] = \"%s.%s\" % (app_label, model_name.lower())\n684             else:\n685                 kwargs[\"to\"] = self.remote_field.model.lower()\n686         else:\n687             kwargs[\"to\"] = self.remote_field.model._meta.label_lower\n688         # If swappable is True, then see if we're actually pointing to the target\n689         # of a swap.\n690         swappable_setting = self.swappable_setting\n691         if swappable_setting is not None:\n692             # If it's already a settings reference, error\n693             if hasattr(kwargs[\"to\"], \"setting_name\"):\n694                 if kwargs[\"to\"].setting_name != swappable_setting:\n695                     raise ValueError(\n696                         \"Cannot deconstruct a ForeignKey pointing to a model \"\n697                         \"that is swapped in place of more than one model (%s and %s)\"\n698                         % (kwargs[\"to\"].setting_name, swappable_setting)\n699                     )\n700             # Set it\n701             kwargs[\"to\"] = SettingsReference(\n702                 kwargs[\"to\"],\n703                 swappable_setting,\n704             )\n705         return name, path, args, kwargs\n706 \n707     def resolve_related_fields(self):\n708         if not self.from_fields or len(self.from_fields) != len(self.to_fields):\n709             raise ValueError(\n710                 \"Foreign Object from and to fields must be the same non-zero length\"\n711             )\n712         if isinstance(self.remote_field.model, str):\n713             raise ValueError(\n714                 \"Related model %r cannot be resolved\" % self.remote_field.model\n715             )\n716         related_fields = []\n717         for index in range(len(self.from_fields)):\n718             from_field_name = self.from_fields[index]\n719             to_field_name = self.to_fields[index]\n720             from_field = (\n721                 self\n722                 if from_field_name == RECURSIVE_RELATIONSHIP_CONSTANT\n723                 else self.opts.get_field(from_field_name)\n724             )\n725             to_field = (\n726                 self.remote_field.model._meta.pk\n727                 if to_field_name is None\n728                 else self.remote_field.model._meta.get_field(to_field_name)\n729             )\n730             related_fields.append((from_field, to_field))\n731         return related_fields\n732 \n733     @cached_property\n734     def related_fields(self):\n735         return self.resolve_related_fields()\n736 \n737     @cached_property\n738     def reverse_related_fields(self):\n739         return [(rhs_field, lhs_field) for lhs_field, rhs_field in self.related_fields]\n740 \n741     @cached_property\n742     def local_related_fields(self):\n743         return tuple(lhs_field for lhs_field, rhs_field in self.related_fields)\n744 \n745     @cached_property\n746     def foreign_related_fields(self):\n747         return tuple(\n748             rhs_field for lhs_field, rhs_field in self.related_fields if rhs_field\n749         )\n750 \n751     def get_local_related_value(self, instance):\n752         return self.get_instance_value_for_fields(instance, self.local_related_fields)\n753 \n754     def get_foreign_related_value(self, instance):\n755         return self.get_instance_value_for_fields(instance, self.foreign_related_fields)\n756 \n757     @staticmethod\n758     def get_instance_value_for_fields(instance, fields):\n759         ret = []\n760         opts = instance._meta\n761         for field in fields:\n762             # Gotcha: in some cases (like fixture loading) a model can have\n763             # different values in parent_ptr_id and parent's id. So, use\n764             # instance.pk (that is, parent_ptr_id) when asked for instance.id.\n765             if field.primary_key:\n766                 possible_parent_link = opts.get_ancestor_link(field.model)\n767                 if (\n768                     not possible_parent_link\n769                     or possible_parent_link.primary_key\n770                     or possible_parent_link.model._meta.abstract\n771                 ):\n772                     ret.append(instance.pk)\n773                     continue\n774             ret.append(getattr(instance, field.attname))\n775         return tuple(ret)\n776 \n777     def get_attname_column(self):\n778         attname, column = super().get_attname_column()\n779         return attname, None\n780 \n781     def get_joining_columns(self, reverse_join=False):\n782         source = self.reverse_related_fields if reverse_join else self.related_fields\n783         return tuple(\n784             (lhs_field.column, rhs_field.column) for lhs_field, rhs_field in source\n785         )\n786 \n787     def get_reverse_joining_columns(self):\n788         return self.get_joining_columns(reverse_join=True)\n789 \n790     def get_extra_descriptor_filter(self, instance):\n791         \"\"\"\n792         Return an extra filter condition for related object fetching when\n793         user does 'instance.fieldname', that is the extra filter is used in\n794         the descriptor of the field.\n795 \n796         The filter should be either a dict usable in .filter(**kwargs) call or\n797         a Q-object. The condition will be ANDed together with the relation's\n798         joining columns.\n799 \n800         A parallel method is get_extra_restriction() which is used in\n801         JOIN and subquery conditions.\n802         \"\"\"\n803         return {}\n804 \n805     def get_extra_restriction(self, alias, related_alias):\n806         \"\"\"\n807         Return a pair condition used for joining and subquery pushdown. The\n808         condition is something that responds to as_sql(compiler, connection)\n809         method.\n810 \n811         Note that currently referring both the 'alias' and 'related_alias'\n812         will not work in some conditions, like subquery pushdown.\n813 \n814         A parallel method is get_extra_descriptor_filter() which is used in\n815         instance.fieldname related object fetching.\n816         \"\"\"\n817         return None\n818 \n819     def get_path_info(self, filtered_relation=None):\n820         \"\"\"Get path from this field to the related model.\"\"\"\n821         opts = self.remote_field.model._meta\n822         from_opts = self.model._meta\n823         return [\n824             PathInfo(\n825                 from_opts=from_opts,\n826                 to_opts=opts,\n827                 target_fields=self.foreign_related_fields,\n828                 join_field=self,\n829                 m2m=False,\n830                 direct=True,\n831                 filtered_relation=filtered_relation,\n832             )\n833         ]\n834 \n835     @cached_property\n836     def path_infos(self):\n837         return self.get_path_info()\n838 \n839     def get_reverse_path_info(self, filtered_relation=None):\n840         \"\"\"Get path from the related model to this field's model.\"\"\"\n841         opts = self.model._meta\n842         from_opts = self.remote_field.model._meta\n843         return [\n844             PathInfo(\n845                 from_opts=from_opts,\n846                 to_opts=opts,\n847                 target_fields=(opts.pk,),\n848                 join_field=self.remote_field,\n849                 m2m=not self.unique,\n850                 direct=False,\n851                 filtered_relation=filtered_relation,\n852             )\n853         ]\n854 \n855     @cached_property\n856     def reverse_path_infos(self):\n857         return self.get_reverse_path_info()\n858 \n859     @classmethod\n860     @functools.lru_cache(maxsize=None)\n861     def get_class_lookups(cls):\n862         bases = inspect.getmro(cls)\n863         bases = bases[: bases.index(ForeignObject) + 1]\n864         class_lookups = [parent.__dict__.get(\"class_lookups\", {}) for parent in bases]\n865         return cls.merge_dicts(class_lookups)\n866 \n867     def contribute_to_class(self, cls, name, private_only=False, **kwargs):\n868         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)\n869         setattr(cls, self.name, self.forward_related_accessor_class(self))\n870 \n871     def contribute_to_related_class(self, cls, related):\n872         # Internal FK's - i.e., those with a related name ending with '+' -\n873         # and swapped models don't get a related descriptor.\n874         if (\n875             not self.remote_field.is_hidden()\n876             and not related.related_model._meta.swapped\n877         ):\n878             setattr(\n879                 cls._meta.concrete_model,\n880                 related.get_accessor_name(),\n881                 self.related_accessor_class(related),\n882             )\n883             # While 'limit_choices_to' might be a callable, simply pass\n884             # it along for later - this is too early because it's still\n885             # model load time.\n886             if self.remote_field.limit_choices_to:\n887                 cls._meta.related_fkey_lookups.append(\n888                     self.remote_field.limit_choices_to\n889                 )\n890 \n891 \n892 ForeignObject.register_lookup(RelatedIn)\n893 ForeignObject.register_lookup(RelatedExact)\n894 ForeignObject.register_lookup(RelatedLessThan)\n895 ForeignObject.register_lookup(RelatedGreaterThan)\n896 ForeignObject.register_lookup(RelatedGreaterThanOrEqual)\n897 ForeignObject.register_lookup(RelatedLessThanOrEqual)\n898 ForeignObject.register_lookup(RelatedIsNull)\n899 \n900 \n901 class ForeignKey(ForeignObject):\n902     \"\"\"\n903     Provide a many-to-one relation by adding a column to the local model\n904     to hold the remote value.\n905 \n906     By default ForeignKey will target the pk of the remote model but this\n907     behavior can be changed by using the ``to_field`` argument.\n908     \"\"\"\n909 \n910     descriptor_class = ForeignKeyDeferredAttribute\n911     # Field flags\n912     many_to_many = False\n913     many_to_one = True\n914     one_to_many = False\n915     one_to_one = False\n916 \n917     rel_class = ManyToOneRel\n918 \n919     empty_strings_allowed = False\n920     default_error_messages = {\n921         \"invalid\": _(\"%(model)s instance with %(field)s %(value)r does not exist.\")\n922     }\n923     description = _(\"Foreign Key (type determined by related field)\")\n924 \n925     def __init__(\n926         self,\n927         to,\n928         on_delete,\n929         related_name=None,\n930         related_query_name=None,\n931         limit_choices_to=None,\n932         parent_link=False,\n933         to_field=None,\n934         db_constraint=True,\n935         **kwargs,\n936     ):\n937         try:\n938             to._meta.model_name\n939         except AttributeError:\n940             if not isinstance(to, str):\n941                 raise TypeError(\n942                     \"%s(%r) is invalid. First parameter to ForeignKey must be \"\n943                     \"either a model, a model name, or the string %r\"\n944                     % (\n945                         self.__class__.__name__,\n946                         to,\n947                         RECURSIVE_RELATIONSHIP_CONSTANT,\n948                     )\n949                 )\n950         else:\n951             # For backwards compatibility purposes, we need to *try* and set\n952             # the to_field during FK construction. It won't be guaranteed to\n953             # be correct until contribute_to_class is called. Refs #12190.\n954             to_field = to_field or (to._meta.pk and to._meta.pk.name)\n955         if not callable(on_delete):\n956             raise TypeError(\"on_delete must be callable.\")\n957 \n958         kwargs[\"rel\"] = self.rel_class(\n959             self,\n960             to,\n961             to_field,\n962             related_name=related_name,\n963             related_query_name=related_query_name,\n964             limit_choices_to=limit_choices_to,\n965             parent_link=parent_link,\n966             on_delete=on_delete,\n967         )\n968         kwargs.setdefault(\"db_index\", True)\n969 \n970         super().__init__(\n971             to,\n972             on_delete,\n973             related_name=related_name,\n974             related_query_name=related_query_name,\n975             limit_choices_to=limit_choices_to,\n976             from_fields=[RECURSIVE_RELATIONSHIP_CONSTANT],\n977             to_fields=[to_field],\n978             **kwargs,\n979         )\n980         self.db_constraint = db_constraint\n981 \n982     def __class_getitem__(cls, *args, **kwargs):\n983         return cls\n984 \n985     def check(self, **kwargs):\n986         return [\n987             *super().check(**kwargs),\n988             *self._check_on_delete(),\n989             *self._check_unique(),\n990         ]\n991 \n992     def _check_on_delete(self):\n993         on_delete = getattr(self.remote_field, \"on_delete\", None)\n994         if on_delete == SET_NULL and not self.null:\n995             return [\n996                 checks.Error(\n997                     \"Field specifies on_delete=SET_NULL, but cannot be null.\",\n998                     hint=(\n999                         \"Set null=True argument on the field, or change the on_delete \"\n1000                         \"rule.\"\n1001                     ),\n1002                     obj=self,\n1003                     id=\"fields.E320\",\n1004                 )\n1005             ]\n1006         elif on_delete == SET_DEFAULT and not self.has_default():\n1007             return [\n1008                 checks.Error(\n1009                     \"Field specifies on_delete=SET_DEFAULT, but has no default value.\",\n1010                     hint=\"Set a default value, or change the on_delete rule.\",\n1011                     obj=self,\n1012                     id=\"fields.E321\",\n1013                 )\n1014             ]\n1015         else:\n1016             return []\n1017 \n1018     def _check_unique(self, **kwargs):\n1019         return (\n1020             [\n1021                 checks.Warning(\n1022                     \"Setting unique=True on a ForeignKey has the same effect as using \"\n1023                     \"a OneToOneField.\",\n1024                     hint=(\n1025                         \"ForeignKey(unique=True) is usually better served by a \"\n1026                         \"OneToOneField.\"\n1027                     ),\n1028                     obj=self,\n1029                     id=\"fields.W342\",\n1030                 )\n1031             ]\n1032             if self.unique\n1033             else []\n1034         )\n1035 \n1036     def deconstruct(self):\n1037         name, path, args, kwargs = super().deconstruct()\n1038         del kwargs[\"to_fields\"]\n1039         del kwargs[\"from_fields\"]\n1040         # Handle the simpler arguments\n1041         if self.db_index:\n1042             del kwargs[\"db_index\"]\n1043         else:\n1044             kwargs[\"db_index\"] = False\n1045         if self.db_constraint is not True:\n1046             kwargs[\"db_constraint\"] = self.db_constraint\n1047         # Rel needs more work.\n1048         to_meta = getattr(self.remote_field.model, \"_meta\", None)\n1049         if self.remote_field.field_name and (\n1050             not to_meta\n1051             or (to_meta.pk and self.remote_field.field_name != to_meta.pk.name)\n1052         ):\n1053             kwargs[\"to_field\"] = self.remote_field.field_name\n1054         return name, path, args, kwargs\n1055 \n1056     def to_python(self, value):\n1057         return self.target_field.to_python(value)\n1058 \n1059     @property\n1060     def target_field(self):\n1061         return self.foreign_related_fields[0]\n1062 \n1063     def get_reverse_path_info(self, filtered_relation=None):\n1064         \"\"\"Get path from the related model to this field's model.\"\"\"\n1065         opts = self.model._meta\n1066         from_opts = self.remote_field.model._meta\n1067         return [\n1068             PathInfo(\n1069                 from_opts=from_opts,\n1070                 to_opts=opts,\n1071                 target_fields=(opts.pk,),\n1072                 join_field=self.remote_field,\n1073                 m2m=not self.unique,\n1074                 direct=False,\n1075                 filtered_relation=filtered_relation,\n1076             )\n1077         ]\n1078 \n1079     def validate(self, value, model_instance):\n1080         if self.remote_field.parent_link:\n1081             return\n1082         super().validate(value, model_instance)\n1083         if value is None:\n1084             return\n1085 \n1086         using = router.db_for_read(self.remote_field.model, instance=model_instance)\n1087         qs = self.remote_field.model._base_manager.using(using).filter(\n1088             **{self.remote_field.field_name: value}\n1089         )\n1090         qs = qs.complex_filter(self.get_limit_choices_to())\n1091         if not qs.exists():\n1092             raise exceptions.ValidationError(\n1093                 self.error_messages[\"invalid\"],\n1094                 code=\"invalid\",\n1095                 params={\n1096                     \"model\": self.remote_field.model._meta.verbose_name,\n1097                     \"pk\": value,\n1098                     \"field\": self.remote_field.field_name,\n1099                     \"value\": value,\n1100                 },  # 'pk' is included for backwards compatibility\n1101             )\n1102 \n1103     def resolve_related_fields(self):\n1104         related_fields = super().resolve_related_fields()\n1105         for from_field, to_field in related_fields:\n1106             if (\n1107                 to_field\n1108                 and to_field.model != self.remote_field.model._meta.concrete_model\n1109             ):\n1110                 raise exceptions.FieldError(\n1111                     \"'%s.%s' refers to field '%s' which is not local to model \"\n1112                     \"'%s'.\"\n1113                     % (\n1114                         self.model._meta.label,\n1115                         self.name,\n1116                         to_field.name,\n1117                         self.remote_field.model._meta.concrete_model._meta.label,\n1118                     )\n1119                 )\n1120         return related_fields\n1121 \n1122     def get_attname(self):\n1123         return \"%s_id\" % self.name\n1124 \n1125     def get_attname_column(self):\n1126         attname = self.get_attname()\n1127         column = self.db_column or attname\n1128         return attname, column\n1129 \n1130     def get_default(self):\n1131         \"\"\"Return the to_field if the default value is an object.\"\"\"\n1132         field_default = super().get_default()\n1133         if isinstance(field_default, self.remote_field.model):\n1134             return getattr(field_default, self.target_field.attname)\n1135         return field_default\n1136 \n1137     def get_db_prep_save(self, value, connection):\n1138         if value is None or (\n1139             value == \"\"\n1140             and (\n1141                 not self.target_field.empty_strings_allowed\n1142                 or connection.features.interprets_empty_strings_as_nulls\n1143             )\n1144         ):\n1145             return None\n1146         else:\n1147             return self.target_field.get_db_prep_save(value, connection=connection)\n1148 \n1149     def get_db_prep_value(self, value, connection, prepared=False):\n1150         return self.target_field.get_db_prep_value(value, connection, prepared)\n1151 \n1152     def get_prep_value(self, value):\n1153         return self.target_field.get_prep_value(value)\n1154 \n1155     def contribute_to_related_class(self, cls, related):\n1156         super().contribute_to_related_class(cls, related)\n1157         if self.remote_field.field_name is None:\n1158             self.remote_field.field_name = cls._meta.pk.name\n1159 \n1160     def formfield(self, *, using=None, **kwargs):\n1161         if isinstance(self.remote_field.model, str):\n1162             raise ValueError(\n1163                 \"Cannot create form field for %r yet, because \"\n1164                 \"its related model %r has not been loaded yet\"\n1165                 % (self.name, self.remote_field.model)\n1166             )\n1167         return super().formfield(\n1168             **{\n1169                 \"form_class\": forms.ModelChoiceField,\n1170                 \"queryset\": self.remote_field.model._default_manager.using(using),\n1171                 \"to_field_name\": self.remote_field.field_name,\n1172                 **kwargs,\n1173                 \"blank\": self.blank,\n1174             }\n1175         )\n1176 \n1177     def db_check(self, connection):\n1178         return None\n1179 \n1180     def db_type(self, connection):\n1181         return self.target_field.rel_db_type(connection=connection)\n1182 \n1183     def db_parameters(self, connection):\n1184         target_db_parameters = self.target_field.db_parameters(connection)\n1185         return {\n1186             \"type\": self.db_type(connection),\n1187             \"check\": self.db_check(connection),\n1188             \"collation\": target_db_parameters.get(\"collation\"),\n1189         }\n1190 \n1191     def convert_empty_strings(self, value, expression, connection):\n1192         if (not value) and isinstance(value, str):\n1193             return None\n1194         return value\n1195 \n1196     def get_db_converters(self, connection):\n1197         converters = super().get_db_converters(connection)\n1198         if connection.features.interprets_empty_strings_as_nulls:\n1199             converters += [self.convert_empty_strings]\n1200         return converters\n1201 \n1202     def get_col(self, alias, output_field=None):\n1203         if output_field is None:\n1204             output_field = self.target_field\n1205             while isinstance(output_field, ForeignKey):\n1206                 output_field = output_field.target_field\n1207                 if output_field is self:\n1208                     raise ValueError(\"Cannot resolve output_field.\")\n1209         return super().get_col(alias, output_field)\n1210 \n1211 \n1212 class OneToOneField(ForeignKey):\n1213     \"\"\"\n1214     A OneToOneField is essentially the same as a ForeignKey, with the exception\n1215     that it always carries a \"unique\" constraint with it and the reverse\n1216     relation always returns the object pointed to (since there will only ever\n1217     be one), rather than returning a list.\n1218     \"\"\"\n1219 \n1220     # Field flags\n1221     many_to_many = False\n1222     many_to_one = False\n1223     one_to_many = False\n1224     one_to_one = True\n1225 \n1226     related_accessor_class = ReverseOneToOneDescriptor\n1227     forward_related_accessor_class = ForwardOneToOneDescriptor\n1228     rel_class = OneToOneRel\n1229 \n1230     description = _(\"One-to-one relationship\")\n1231 \n1232     def __init__(self, to, on_delete, to_field=None, **kwargs):\n1233         kwargs[\"unique\"] = True\n1234         super().__init__(to, on_delete, to_field=to_field, **kwargs)\n1235 \n1236     def deconstruct(self):\n1237         name, path, args, kwargs = super().deconstruct()\n1238         if \"unique\" in kwargs:\n1239             del kwargs[\"unique\"]\n1240         return name, path, args, kwargs\n1241 \n1242     def formfield(self, **kwargs):\n1243         if self.remote_field.parent_link:\n1244             return None\n1245         return super().formfield(**kwargs)\n1246 \n1247     def save_form_data(self, instance, data):\n1248         if isinstance(data, self.remote_field.model):\n1249             setattr(instance, self.name, data)\n1250         else:\n1251             setattr(instance, self.attname, data)\n1252             # Remote field object must be cleared otherwise Model.save()\n1253             # will reassign attname using the related object pk.\n1254             if data is None:\n1255                 setattr(instance, self.name, data)\n1256 \n1257     def _check_unique(self, **kwargs):\n1258         # Override ForeignKey since check isn't applicable here.\n1259         return []\n1260 \n1261 \n1262 def create_many_to_many_intermediary_model(field, klass):\n1263     from django.db import models\n1264 \n1265     def set_managed(model, related, through):\n1266         through._meta.managed = model._meta.managed or related._meta.managed\n1267 \n1268     to_model = resolve_relation(klass, field.remote_field.model)\n1269     name = \"%s_%s\" % (klass._meta.object_name, field.name)\n1270     lazy_related_operation(set_managed, klass, to_model, name)\n1271 \n1272     to = make_model_tuple(to_model)[1]\n1273     from_ = klass._meta.model_name\n1274     if to == from_:\n1275         to = \"to_%s\" % to\n1276         from_ = \"from_%s\" % from_\n1277 \n1278     meta = type(\n1279         \"Meta\",\n1280         (),\n1281         {\n1282             \"db_table\": field._get_m2m_db_table(klass._meta),\n1283             \"auto_created\": klass,\n1284             \"app_label\": klass._meta.app_label,\n1285             \"db_tablespace\": klass._meta.db_tablespace,\n1286             \"unique_together\": (from_, to),\n1287             \"verbose_name\": _(\"%(from)s-%(to)s relationship\")\n1288             % {\"from\": from_, \"to\": to},\n1289             \"verbose_name_plural\": _(\"%(from)s-%(to)s relationships\")\n1290             % {\"from\": from_, \"to\": to},\n1291             \"apps\": field.model._meta.apps,\n1292         },\n1293     )\n1294     # Construct and return the new class.\n1295     return type(\n1296         name,\n1297         (models.Model,),\n1298         {\n1299             \"Meta\": meta,\n1300             \"__module__\": klass.__module__,\n1301             from_: models.ForeignKey(\n1302                 klass,\n1303                 related_name=\"%s+\" % name,\n1304                 db_tablespace=field.db_tablespace,\n1305                 db_constraint=field.remote_field.db_constraint,\n1306                 on_delete=CASCADE,\n1307             ),\n1308             to: models.ForeignKey(\n1309                 to_model,\n1310                 related_name=\"%s+\" % name,\n1311                 db_tablespace=field.db_tablespace,\n1312                 db_constraint=field.remote_field.db_constraint,\n1313                 on_delete=CASCADE,\n1314             ),\n1315         },\n1316     )\n1317 \n1318 \n1319 class ManyToManyField(RelatedField):\n1320     \"\"\"\n1321     Provide a many-to-many relation by using an intermediary model that\n1322     holds two ForeignKey fields pointed at the two sides of the relation.\n1323 \n1324     Unless a ``through`` model was provided, ManyToManyField will use the\n1325     create_many_to_many_intermediary_model factory to automatically generate\n1326     the intermediary model.\n1327     \"\"\"\n1328 \n1329     # Field flags\n1330     many_to_many = True\n1331     many_to_one = False\n1332     one_to_many = False\n1333     one_to_one = False\n1334 \n1335     rel_class = ManyToManyRel\n1336 \n1337     description = _(\"Many-to-many relationship\")\n1338 \n1339     def __init__(\n1340         self,\n1341         to,\n1342         related_name=None,\n1343         related_query_name=None,\n1344         limit_choices_to=None,\n1345         symmetrical=None,\n1346         through=None,\n1347         through_fields=None,\n1348         db_constraint=True,\n1349         db_table=None,\n1350         swappable=True,\n1351         **kwargs,\n1352     ):\n1353         try:\n1354             to._meta\n1355         except AttributeError:\n1356             if not isinstance(to, str):\n1357                 raise TypeError(\n1358                     \"%s(%r) is invalid. First parameter to ManyToManyField \"\n1359                     \"must be either a model, a model name, or the string %r\"\n1360                     % (\n1361                         self.__class__.__name__,\n1362                         to,\n1363                         RECURSIVE_RELATIONSHIP_CONSTANT,\n1364                     )\n1365                 )\n1366 \n1367         if symmetrical is None:\n1368             symmetrical = to == RECURSIVE_RELATIONSHIP_CONSTANT\n1369 \n1370         if through is not None and db_table is not None:\n1371             raise ValueError(\n1372                 \"Cannot specify a db_table if an intermediary model is used.\"\n1373             )\n1374 \n1375         kwargs[\"rel\"] = self.rel_class(\n1376             self,\n1377             to,\n1378             related_name=related_name,\n1379             related_query_name=related_query_name,\n1380             limit_choices_to=limit_choices_to,\n1381             symmetrical=symmetrical,\n1382             through=through,\n1383             through_fields=through_fields,\n1384             db_constraint=db_constraint,\n1385         )\n1386         self.has_null_arg = \"null\" in kwargs\n1387 \n1388         super().__init__(\n1389             related_name=related_name,\n1390             related_query_name=related_query_name,\n1391             limit_choices_to=limit_choices_to,\n1392             **kwargs,\n1393         )\n1394 \n1395         self.db_table = db_table\n1396         self.swappable = swappable\n1397 \n1398     def check(self, **kwargs):\n1399         return [\n1400             *super().check(**kwargs),\n1401             *self._check_unique(**kwargs),\n1402             *self._check_relationship_model(**kwargs),\n1403             *self._check_ignored_options(**kwargs),\n1404             *self._check_table_uniqueness(**kwargs),\n1405         ]\n1406 \n1407     def _check_unique(self, **kwargs):\n1408         if self.unique:\n1409             return [\n1410                 checks.Error(\n1411                     \"ManyToManyFields cannot be unique.\",\n1412                     obj=self,\n1413                     id=\"fields.E330\",\n1414                 )\n1415             ]\n1416         return []\n1417 \n1418     def _check_ignored_options(self, **kwargs):\n1419         warnings = []\n1420 \n1421         if self.has_null_arg:\n1422             warnings.append(\n1423                 checks.Warning(\n1424                     \"null has no effect on ManyToManyField.\",\n1425                     obj=self,\n1426                     id=\"fields.W340\",\n1427                 )\n1428             )\n1429 \n1430         if self._validators:\n1431             warnings.append(\n1432                 checks.Warning(\n1433                     \"ManyToManyField does not support validators.\",\n1434                     obj=self,\n1435                     id=\"fields.W341\",\n1436                 )\n1437             )\n1438         if self.remote_field.symmetrical and self._related_name:\n1439             warnings.append(\n1440                 checks.Warning(\n1441                     \"related_name has no effect on ManyToManyField \"\n1442                     'with a symmetrical relationship, e.g. to \"self\".',\n1443                     obj=self,\n1444                     id=\"fields.W345\",\n1445                 )\n1446             )\n1447 \n1448         return warnings\n1449 \n1450     def _check_relationship_model(self, from_model=None, **kwargs):\n1451         if hasattr(self.remote_field.through, \"_meta\"):\n1452             qualified_model_name = \"%s.%s\" % (\n1453                 self.remote_field.through._meta.app_label,\n1454                 self.remote_field.through.__name__,\n1455             )\n1456         else:\n1457             qualified_model_name = self.remote_field.through\n1458 \n1459         errors = []\n1460 \n1461         if self.remote_field.through not in self.opts.apps.get_models(\n1462             include_auto_created=True\n1463         ):\n1464             # The relationship model is not installed.\n1465             errors.append(\n1466                 checks.Error(\n1467                     \"Field specifies a many-to-many relation through model \"\n1468                     \"'%s', which has not been installed.\" % qualified_model_name,\n1469                     obj=self,\n1470                     id=\"fields.E331\",\n1471                 )\n1472             )\n1473 \n1474         else:\n1475             assert from_model is not None, (\n1476                 \"ManyToManyField with intermediate \"\n1477                 \"tables cannot be checked if you don't pass the model \"\n1478                 \"where the field is attached to.\"\n1479             )\n1480             # Set some useful local variables\n1481             to_model = resolve_relation(from_model, self.remote_field.model)\n1482             from_model_name = from_model._meta.object_name\n1483             if isinstance(to_model, str):\n1484                 to_model_name = to_model\n1485             else:\n1486                 to_model_name = to_model._meta.object_name\n1487             relationship_model_name = self.remote_field.through._meta.object_name\n1488             self_referential = from_model == to_model\n1489             # Count foreign keys in intermediate model\n1490             if self_referential:\n1491                 seen_self = sum(\n1492                     from_model == getattr(field.remote_field, \"model\", None)\n1493                     for field in self.remote_field.through._meta.fields\n1494                 )\n1495 \n1496                 if seen_self > 2 and not self.remote_field.through_fields:\n1497                     errors.append(\n1498                         checks.Error(\n1499                             \"The model is used as an intermediate model by \"\n1500                             \"'%s', but it has more than two foreign keys \"\n1501                             \"to '%s', which is ambiguous. You must specify \"\n1502                             \"which two foreign keys Django should use via the \"\n1503                             \"through_fields keyword argument.\"\n1504                             % (self, from_model_name),\n1505                             hint=(\n1506                                 \"Use through_fields to specify which two foreign keys \"\n1507                                 \"Django should use.\"\n1508                             ),\n1509                             obj=self.remote_field.through,\n1510                             id=\"fields.E333\",\n1511                         )\n1512                     )\n1513 \n1514             else:\n1515                 # Count foreign keys in relationship model\n1516                 seen_from = sum(\n1517                     from_model == getattr(field.remote_field, \"model\", None)\n1518                     for field in self.remote_field.through._meta.fields\n1519                 )\n1520                 seen_to = sum(\n1521                     to_model == getattr(field.remote_field, \"model\", None)\n1522                     for field in self.remote_field.through._meta.fields\n1523                 )\n1524 \n1525                 if seen_from > 1 and not self.remote_field.through_fields:\n1526                     errors.append(\n1527                         checks.Error(\n1528                             (\n1529                                 \"The model is used as an intermediate model by \"\n1530                                 \"'%s', but it has more than one foreign key \"\n1531                                 \"from '%s', which is ambiguous. You must specify \"\n1532                                 \"which foreign key Django should use via the \"\n1533                                 \"through_fields keyword argument.\"\n1534                             )\n1535                             % (self, from_model_name),\n1536                             hint=(\n1537                                 \"If you want to create a recursive relationship, \"\n1538                                 'use ManyToManyField(\"%s\", through=\"%s\").'\n1539                             )\n1540                             % (\n1541                                 RECURSIVE_RELATIONSHIP_CONSTANT,\n1542                                 relationship_model_name,\n1543                             ),\n1544                             obj=self,\n1545                             id=\"fields.E334\",\n1546                         )\n1547                     )\n1548 \n1549                 if seen_to > 1 and not self.remote_field.through_fields:\n1550                     errors.append(\n1551                         checks.Error(\n1552                             \"The model is used as an intermediate model by \"\n1553                             \"'%s', but it has more than one foreign key \"\n1554                             \"to '%s', which is ambiguous. You must specify \"\n1555                             \"which foreign key Django should use via the \"\n1556                             \"through_fields keyword argument.\" % (self, to_model_name),\n1557                             hint=(\n1558                                 \"If you want to create a recursive relationship, \"\n1559                                 'use ManyToManyField(\"%s\", through=\"%s\").'\n1560                             )\n1561                             % (\n1562                                 RECURSIVE_RELATIONSHIP_CONSTANT,\n1563                                 relationship_model_name,\n1564                             ),\n1565                             obj=self,\n1566                             id=\"fields.E335\",\n1567                         )\n1568                     )\n1569 \n1570                 if seen_from == 0 or seen_to == 0:\n1571                     errors.append(\n1572                         checks.Error(\n1573                             \"The model is used as an intermediate model by \"\n1574                             \"'%s', but it does not have a foreign key to '%s' or '%s'.\"\n1575                             % (self, from_model_name, to_model_name),\n1576                             obj=self.remote_field.through,\n1577                             id=\"fields.E336\",\n1578                         )\n1579                     )\n1580 \n1581         # Validate `through_fields`.\n1582         if self.remote_field.through_fields is not None:\n1583             # Validate that we're given an iterable of at least two items\n1584             # and that none of them is \"falsy\".\n1585             if not (\n1586                 len(self.remote_field.through_fields) >= 2\n1587                 and self.remote_field.through_fields[0]\n1588                 and self.remote_field.through_fields[1]\n1589             ):\n1590                 errors.append(\n1591                     checks.Error(\n1592                         \"Field specifies 'through_fields' but does not provide \"\n1593                         \"the names of the two link fields that should be used \"\n1594                         \"for the relation through model '%s'.\" % qualified_model_name,\n1595                         hint=(\n1596                             \"Make sure you specify 'through_fields' as \"\n1597                             \"through_fields=('field1', 'field2')\"\n1598                         ),\n1599                         obj=self,\n1600                         id=\"fields.E337\",\n1601                     )\n1602                 )\n1603 \n1604             # Validate the given through fields -- they should be actual\n1605             # fields on the through model, and also be foreign keys to the\n1606             # expected models.\n1607             else:\n1608                 assert from_model is not None, (\n1609                     \"ManyToManyField with intermediate \"\n1610                     \"tables cannot be checked if you don't pass the model \"\n1611                     \"where the field is attached to.\"\n1612                 )\n1613 \n1614                 source, through, target = (\n1615                     from_model,\n1616                     self.remote_field.through,\n1617                     self.remote_field.model,\n1618                 )\n1619                 source_field_name, target_field_name = self.remote_field.through_fields[\n1620                     :2\n1621                 ]\n1622 \n1623                 for field_name, related_model in (\n1624                     (source_field_name, source),\n1625                     (target_field_name, target),\n1626                 ):\n1627 \n1628                     possible_field_names = []\n1629                     for f in through._meta.fields:\n1630                         if (\n1631                             hasattr(f, \"remote_field\")\n1632                             and getattr(f.remote_field, \"model\", None) == related_model\n1633                         ):\n1634                             possible_field_names.append(f.name)\n1635                     if possible_field_names:\n1636                         hint = (\n1637                             \"Did you mean one of the following foreign keys to '%s': \"\n1638                             \"%s?\"\n1639                             % (\n1640                                 related_model._meta.object_name,\n1641                                 \", \".join(possible_field_names),\n1642                             )\n1643                         )\n1644                     else:\n1645                         hint = None\n1646 \n1647                     try:\n1648                         field = through._meta.get_field(field_name)\n1649                     except exceptions.FieldDoesNotExist:\n1650                         errors.append(\n1651                             checks.Error(\n1652                                 \"The intermediary model '%s' has no field '%s'.\"\n1653                                 % (qualified_model_name, field_name),\n1654                                 hint=hint,\n1655                                 obj=self,\n1656                                 id=\"fields.E338\",\n1657                             )\n1658                         )\n1659                     else:\n1660                         if not (\n1661                             hasattr(field, \"remote_field\")\n1662                             and getattr(field.remote_field, \"model\", None)\n1663                             == related_model\n1664                         ):\n1665                             errors.append(\n1666                                 checks.Error(\n1667                                     \"'%s.%s' is not a foreign key to '%s'.\"\n1668                                     % (\n1669                                         through._meta.object_name,\n1670                                         field_name,\n1671                                         related_model._meta.object_name,\n1672                                     ),\n1673                                     hint=hint,\n1674                                     obj=self,\n1675                                     id=\"fields.E339\",\n1676                                 )\n1677                             )\n1678 \n1679         return errors\n1680 \n1681     def _check_table_uniqueness(self, **kwargs):\n1682         if (\n1683             isinstance(self.remote_field.through, str)\n1684             or not self.remote_field.through._meta.managed\n1685         ):\n1686             return []\n1687         registered_tables = {\n1688             model._meta.db_table: model\n1689             for model in self.opts.apps.get_models(include_auto_created=True)\n1690             if model != self.remote_field.through and model._meta.managed\n1691         }\n1692         m2m_db_table = self.m2m_db_table()\n1693         model = registered_tables.get(m2m_db_table)\n1694         # The second condition allows multiple m2m relations on a model if\n1695         # some point to a through model that proxies another through model.\n1696         if (\n1697             model\n1698             and model._meta.concrete_model\n1699             != self.remote_field.through._meta.concrete_model\n1700         ):\n1701             if model._meta.auto_created:\n1702 \n1703                 def _get_field_name(model):\n1704                     for field in model._meta.auto_created._meta.many_to_many:\n1705                         if field.remote_field.through is model:\n1706                             return field.name\n1707 \n1708                 opts = model._meta.auto_created._meta\n1709                 clashing_obj = \"%s.%s\" % (opts.label, _get_field_name(model))\n1710             else:\n1711                 clashing_obj = model._meta.label\n1712             if settings.DATABASE_ROUTERS:\n1713                 error_class, error_id = checks.Warning, \"fields.W344\"\n1714                 error_hint = (\n1715                     \"You have configured settings.DATABASE_ROUTERS. Verify \"\n1716                     \"that the table of %r is correctly routed to a separate \"\n1717                     \"database.\" % clashing_obj\n1718                 )\n1719             else:\n1720                 error_class, error_id = checks.Error, \"fields.E340\"\n1721                 error_hint = None\n1722             return [\n1723                 error_class(\n1724                     \"The field's intermediary table '%s' clashes with the \"\n1725                     \"table name of '%s'.\" % (m2m_db_table, clashing_obj),\n1726                     obj=self,\n1727                     hint=error_hint,\n1728                     id=error_id,\n1729                 )\n1730             ]\n1731         return []\n1732 \n1733     def deconstruct(self):\n1734         name, path, args, kwargs = super().deconstruct()\n1735         # Handle the simpler arguments.\n1736         if self.db_table is not None:\n1737             kwargs[\"db_table\"] = self.db_table\n1738         if self.remote_field.db_constraint is not True:\n1739             kwargs[\"db_constraint\"] = self.remote_field.db_constraint\n1740         # Lowercase model names as they should be treated as case-insensitive.\n1741         if isinstance(self.remote_field.model, str):\n1742             if \".\" in self.remote_field.model:\n1743                 app_label, model_name = self.remote_field.model.split(\".\")\n1744                 kwargs[\"to\"] = \"%s.%s\" % (app_label, model_name.lower())\n1745             else:\n1746                 kwargs[\"to\"] = self.remote_field.model.lower()\n1747         else:\n1748             kwargs[\"to\"] = self.remote_field.model._meta.label_lower\n1749         if getattr(self.remote_field, \"through\", None) is not None:\n1750             if isinstance(self.remote_field.through, str):\n1751                 kwargs[\"through\"] = self.remote_field.through\n1752             elif not self.remote_field.through._meta.auto_created:\n1753                 kwargs[\"through\"] = self.remote_field.through._meta.label\n1754         # If swappable is True, then see if we're actually pointing to the target\n1755         # of a swap.\n1756         swappable_setting = self.swappable_setting\n1757         if swappable_setting is not None:\n1758             # If it's already a settings reference, error.\n1759             if hasattr(kwargs[\"to\"], \"setting_name\"):\n1760                 if kwargs[\"to\"].setting_name != swappable_setting:\n1761                     raise ValueError(\n1762                         \"Cannot deconstruct a ManyToManyField pointing to a \"\n1763                         \"model that is swapped in place of more than one model \"\n1764                         \"(%s and %s)\" % (kwargs[\"to\"].setting_name, swappable_setting)\n1765                     )\n1766 \n1767             kwargs[\"to\"] = SettingsReference(\n1768                 kwargs[\"to\"],\n1769                 swappable_setting,\n1770             )\n1771         return name, path, args, kwargs\n1772 \n1773     def _get_path_info(self, direct=False, filtered_relation=None):\n1774         \"\"\"Called by both direct and indirect m2m traversal.\"\"\"\n1775         int_model = self.remote_field.through\n1776         linkfield1 = int_model._meta.get_field(self.m2m_field_name())\n1777         linkfield2 = int_model._meta.get_field(self.m2m_reverse_field_name())\n1778         if direct:\n1779             join1infos = linkfield1.reverse_path_infos\n1780             if filtered_relation:\n1781                 join2infos = linkfield2.get_path_info(filtered_relation)\n1782             else:\n1783                 join2infos = linkfield2.path_infos\n1784         else:\n1785             join1infos = linkfield2.reverse_path_infos\n1786             if filtered_relation:\n1787                 join2infos = linkfield1.get_path_info(filtered_relation)\n1788             else:\n1789                 join2infos = linkfield1.path_infos\n1790         # Get join infos between the last model of join 1 and the first model\n1791         # of join 2. Assume the only reason these may differ is due to model\n1792         # inheritance.\n1793         join1_final = join1infos[-1].to_opts\n1794         join2_initial = join2infos[0].from_opts\n1795         if join1_final is join2_initial:\n1796             intermediate_infos = []\n1797         elif issubclass(join1_final.model, join2_initial.model):\n1798             intermediate_infos = join1_final.get_path_to_parent(join2_initial.model)\n1799         else:\n1800             intermediate_infos = join2_initial.get_path_from_parent(join1_final.model)\n1801 \n1802         return [*join1infos, *intermediate_infos, *join2infos]\n1803 \n1804     def get_path_info(self, filtered_relation=None):\n1805         return self._get_path_info(direct=True, filtered_relation=filtered_relation)\n1806 \n1807     @cached_property\n1808     def path_infos(self):\n1809         return self.get_path_info()\n1810 \n1811     def get_reverse_path_info(self, filtered_relation=None):\n1812         return self._get_path_info(direct=False, filtered_relation=filtered_relation)\n1813 \n1814     @cached_property\n1815     def reverse_path_infos(self):\n1816         return self.get_reverse_path_info()\n1817 \n1818     def _get_m2m_db_table(self, opts):\n1819         \"\"\"\n1820         Function that can be curried to provide the m2m table name for this\n1821         relation.\n1822         \"\"\"\n1823         if self.remote_field.through is not None:\n1824             return self.remote_field.through._meta.db_table\n1825         elif self.db_table:\n1826             return self.db_table\n1827         else:\n1828             m2m_table_name = \"%s_%s\" % (utils.strip_quotes(opts.db_table), self.name)\n1829             return utils.truncate_name(m2m_table_name, connection.ops.max_name_length())\n1830 \n1831     def _get_m2m_attr(self, related, attr):\n1832         \"\"\"\n1833         Function that can be curried to provide the source accessor or DB\n1834         column name for the m2m table.\n1835         \"\"\"\n1836         cache_attr = \"_m2m_%s_cache\" % attr\n1837         if hasattr(self, cache_attr):\n1838             return getattr(self, cache_attr)\n1839         if self.remote_field.through_fields is not None:\n1840             link_field_name = self.remote_field.through_fields[0]\n1841         else:\n1842             link_field_name = None\n1843         for f in self.remote_field.through._meta.fields:\n1844             if (\n1845                 f.is_relation\n1846                 and f.remote_field.model == related.related_model\n1847                 and (link_field_name is None or link_field_name == f.name)\n1848             ):\n1849                 setattr(self, cache_attr, getattr(f, attr))\n1850                 return getattr(self, cache_attr)\n1851 \n1852     def _get_m2m_reverse_attr(self, related, attr):\n1853         \"\"\"\n1854         Function that can be curried to provide the related accessor or DB\n1855         column name for the m2m table.\n1856         \"\"\"\n1857         cache_attr = \"_m2m_reverse_%s_cache\" % attr\n1858         if hasattr(self, cache_attr):\n1859             return getattr(self, cache_attr)\n1860         found = False\n1861         if self.remote_field.through_fields is not None:\n1862             link_field_name = self.remote_field.through_fields[1]\n1863         else:\n1864             link_field_name = None\n1865         for f in self.remote_field.through._meta.fields:\n1866             if f.is_relation and f.remote_field.model == related.model:\n1867                 if link_field_name is None and related.related_model == related.model:\n1868                     # If this is an m2m-intermediate to self,\n1869                     # the first foreign key you find will be\n1870                     # the source column. Keep searching for\n1871                     # the second foreign key.\n1872                     if found:\n1873                         setattr(self, cache_attr, getattr(f, attr))\n1874                         break\n1875                     else:\n1876                         found = True\n1877                 elif link_field_name is None or link_field_name == f.name:\n1878                     setattr(self, cache_attr, getattr(f, attr))\n1879                     break\n1880         return getattr(self, cache_attr)\n1881 \n1882     def contribute_to_class(self, cls, name, **kwargs):\n1883         # To support multiple relations to self, it's useful to have a non-None\n1884         # related name on symmetrical relations for internal reasons. The\n1885         # concept doesn't make a lot of sense externally (\"you want me to\n1886         # specify *what* on my non-reversible relation?!\"), so we set it up\n1887         # automatically. The funky name reduces the chance of an accidental\n1888         # clash.\n1889         if self.remote_field.symmetrical and (\n1890             self.remote_field.model == RECURSIVE_RELATIONSHIP_CONSTANT\n1891             or self.remote_field.model == cls._meta.object_name\n1892         ):\n1893             self.remote_field.related_name = \"%s_rel_+\" % name\n1894         elif self.remote_field.is_hidden():\n1895             # If the backwards relation is disabled, replace the original\n1896             # related_name with one generated from the m2m field name. Django\n1897             # still uses backwards relations internally and we need to avoid\n1898             # clashes between multiple m2m fields with related_name == '+'.\n1899             self.remote_field.related_name = \"_%s_%s_%s_+\" % (\n1900                 cls._meta.app_label,\n1901                 cls.__name__.lower(),\n1902                 name,\n1903             )\n1904 \n1905         super().contribute_to_class(cls, name, **kwargs)\n1906 \n1907         # The intermediate m2m model is not auto created if:\n1908         #  1) There is a manually specified intermediate, or\n1909         #  2) The class owning the m2m field is abstract.\n1910         #  3) The class owning the m2m field has been swapped out.\n1911         if not cls._meta.abstract:\n1912             if self.remote_field.through:\n1913 \n1914                 def resolve_through_model(_, model, field):\n1915                     field.remote_field.through = model\n1916 \n1917                 lazy_related_operation(\n1918                     resolve_through_model, cls, self.remote_field.through, field=self\n1919                 )\n1920             elif not cls._meta.swapped:\n1921                 self.remote_field.through = create_many_to_many_intermediary_model(\n1922                     self, cls\n1923                 )\n1924 \n1925         # Add the descriptor for the m2m relation.\n1926         setattr(cls, self.name, ManyToManyDescriptor(self.remote_field, reverse=False))\n1927 \n1928         # Set up the accessor for the m2m table name for the relation.\n1929         self.m2m_db_table = partial(self._get_m2m_db_table, cls._meta)\n1930 \n1931     def contribute_to_related_class(self, cls, related):\n1932         # Internal M2Ms (i.e., those with a related name ending with '+')\n1933         # and swapped models don't get a related descriptor.\n1934         if (\n1935             not self.remote_field.is_hidden()\n1936             and not related.related_model._meta.swapped\n1937         ):\n1938             setattr(\n1939                 cls,\n1940                 related.get_accessor_name(),\n1941                 ManyToManyDescriptor(self.remote_field, reverse=True),\n1942             )\n1943 \n1944         # Set up the accessors for the column names on the m2m table.\n1945         self.m2m_column_name = partial(self._get_m2m_attr, related, \"column\")\n1946         self.m2m_reverse_name = partial(self._get_m2m_reverse_attr, related, \"column\")\n1947 \n1948         self.m2m_field_name = partial(self._get_m2m_attr, related, \"name\")\n1949         self.m2m_reverse_field_name = partial(\n1950             self._get_m2m_reverse_attr, related, \"name\"\n1951         )\n1952 \n1953         get_m2m_rel = partial(self._get_m2m_attr, related, \"remote_field\")\n1954         self.m2m_target_field_name = lambda: get_m2m_rel().field_name\n1955         get_m2m_reverse_rel = partial(\n1956             self._get_m2m_reverse_attr, related, \"remote_field\"\n1957         )\n1958         self.m2m_reverse_target_field_name = lambda: get_m2m_reverse_rel().field_name\n1959 \n1960     def set_attributes_from_rel(self):\n1961         pass\n1962 \n1963     def value_from_object(self, obj):\n1964         return [] if obj.pk is None else list(getattr(obj, self.attname).all())\n1965 \n1966     def save_form_data(self, instance, data):\n1967         getattr(instance, self.attname).set(data)\n1968 \n1969     def formfield(self, *, using=None, **kwargs):\n1970         defaults = {\n1971             \"form_class\": forms.ModelMultipleChoiceField,\n1972             \"queryset\": self.remote_field.model._default_manager.using(using),\n1973             **kwargs,\n1974         }\n1975         # If initial is passed in, it's a list of related objects, but the\n1976         # MultipleChoiceField takes a list of IDs.\n1977         if defaults.get(\"initial\") is not None:\n1978             initial = defaults[\"initial\"]\n1979             if callable(initial):\n1980                 initial = initial()\n1981             defaults[\"initial\"] = [i.pk for i in initial]\n1982         return super().formfield(**defaults)\n1983 \n1984     def db_check(self, connection):\n1985         return None\n1986 \n1987     def db_type(self, connection):\n1988         # A ManyToManyField is not represented by a single column,\n1989         # so return None.\n1990         return None\n1991 \n1992     def db_parameters(self, connection):\n1993         return {\"type\": None, \"check\": None}\n",
        "intended_behavior": "Strengthen validation and deconstruction logic to accurately handle `ManyToManyField` pointing to 'self'. This includes ensuring the field's initialization properly sets up self-references and that deconstruction provides the correct state for migration serialization. The `_check_relationship_model` method specifically could be enhanced to ensure it validates self-referencing relationships correctly, preventing schema inconsistencies."
    }
]