[
    {
        "rel_file_path": "src/flask/json/__init__.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/pallets__flask/setup_pallets__flask__2.0/src/flask/json/__init__.py",
        "start": 42,
        "end": 56,
        "class_name": "JSONEncoder",
        "method_name": "default",
        "code": "42     def default(self, o: t.Any) -> t.Any:\n43         \"\"\"Convert ``o`` to a JSON serializable type. See\n44         :meth:`json.JSONEncoder.default`. Python does not support\n45         overriding how basic types like ``str`` or ``list`` are\n46         serialized, they are handled before this method.\n47         \"\"\"\n48         if isinstance(o, date):\n49             return http_date(o)\n50         if isinstance(o, uuid.UUID):\n51             return str(o)\n52         if dataclasses and dataclasses.is_dataclass(o):\n53             return dataclasses.asdict(o)\n54         if hasattr(o, \"__html__\"):\n55             return str(o.__html__())\n56         return super().default(o)\n",
        "intended_behavior": "The `default` method within the `JSONEncoder` class should be modified to include handling for `decimal.Decimal` types. The intended behavior is to check if the object `o` is an instance of `decimal.Decimal` and, if so, return its string representation. This adds to the existing functionality of handling specific types like dates, UUIDs, and dataclasses, ensuring that when the Flask application encounters a `Decimal` object during JSON encoding, it is serialized into a string. This string representation aligns with how `simplejson` treats `Decimal` objects and ensures compatibility with types that Flask's built-in JSON encoder does not support by default. The addition should preserve all existing functionality, extending support for `Decimal` without affecting the serialization of other supported types. The modification should take the form of a conditional check within the `default` method before falling back to the `super().default(o)` call for types not explicitly handled by this encoder."
    },
    {
        "rel_file_path": "src/flask/json/__init__.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/pallets__flask/setup_pallets__flask__2.0/src/flask/json/__init__.py",
        "start": 25,
        "end": 56,
        "class_name": "JSONEncoder",
        "method_name": null,
        "code": "25 class JSONEncoder(_json.JSONEncoder):\n26     \"\"\"The default JSON encoder. Handles extra types compared to the\n27     built-in :class:`json.JSONEncoder`.\n28 \n29     -   :class:`datetime.datetime` and :class:`datetime.date` are\n30         serialized to :rfc:`822` strings. This is the same as the HTTP\n31         date format.\n32     -   :class:`uuid.UUID` is serialized to a string.\n33     -   :class:`dataclasses.dataclass` is passed to\n34         :func:`dataclasses.asdict`.\n35     -   :class:`~markupsafe.Markup` (or any object with a ``__html__``\n36         method) will call the ``__html__`` method to get a string.\n37 \n38     Assign a subclass of this to :attr:`flask.Flask.json_encoder` or\n39     :attr:`flask.Blueprint.json_encoder` to override the default.\n40     \"\"\"\n41 \n42     def default(self, o: t.Any) -> t.Any:\n43         \"\"\"Convert ``o`` to a JSON serializable type. See\n44         :meth:`json.JSONEncoder.default`. Python does not support\n45         overriding how basic types like ``str`` or ``list`` are\n46         serialized, they are handled before this method.\n47         \"\"\"\n48         if isinstance(o, date):\n49             return http_date(o)\n50         if isinstance(o, uuid.UUID):\n51             return str(o)\n52         if dataclasses and dataclasses.is_dataclass(o):\n53             return dataclasses.asdict(o)\n54         if hasattr(o, \"__html__\"):\n55             return str(o.__html__())\n56         return super().default(o)\n",
        "intended_behavior": "This class provides additional context to the issue."
    }
]