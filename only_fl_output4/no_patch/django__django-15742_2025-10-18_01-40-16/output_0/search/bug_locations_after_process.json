[
    {
        "rel_file_path": "django/template/defaultfilters.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__4.2/django/template/defaultfilters.py",
        "start": 1,
        "end": 971,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"Default variable filters.\"\"\"\n2 import random as random_module\n3 import re\n4 import types\n5 from decimal import ROUND_HALF_UP, Context, Decimal, InvalidOperation\n6 from functools import wraps\n7 from inspect import unwrap\n8 from operator import itemgetter\n9 from pprint import pformat\n10 from urllib.parse import quote\n11 \n12 from django.utils import formats\n13 from django.utils.dateformat import format, time_format\n14 from django.utils.encoding import iri_to_uri\n15 from django.utils.html import avoid_wrapping, conditional_escape, escape, escapejs\n16 from django.utils.html import json_script as _json_script\n17 from django.utils.html import linebreaks, strip_tags\n18 from django.utils.html import urlize as _urlize\n19 from django.utils.safestring import SafeData, mark_safe\n20 from django.utils.text import Truncator, normalize_newlines, phone2numeric\n21 from django.utils.text import slugify as _slugify\n22 from django.utils.text import wrap\n23 from django.utils.timesince import timesince, timeuntil\n24 from django.utils.translation import gettext, ngettext\n25 \n26 from .base import VARIABLE_ATTRIBUTE_SEPARATOR\n27 from .library import Library\n28 \n29 register = Library()\n30 \n31 \n32 #######################\n33 # STRING DECORATOR    #\n34 #######################\n35 \n36 \n37 def stringfilter(func):\n38     \"\"\"\n39     Decorator for filters which should only receive strings. The object\n40     passed as the first positional argument will be converted to a string.\n41     \"\"\"\n42 \n43     @wraps(func)\n44     def _dec(first, *args, **kwargs):\n45         first = str(first)\n46         result = func(first, *args, **kwargs)\n47         if isinstance(first, SafeData) and getattr(unwrap(func), \"is_safe\", False):\n48             result = mark_safe(result)\n49         return result\n50 \n51     return _dec\n52 \n53 \n54 ###################\n55 # STRINGS         #\n56 ###################\n57 \n58 \n59 @register.filter(is_safe=True)\n60 @stringfilter\n61 def addslashes(value):\n62     \"\"\"\n63     Add slashes before quotes. Useful for escaping strings in CSV, for\n64     example. Less useful for escaping JavaScript; use the ``escapejs``\n65     filter instead.\n66     \"\"\"\n67     return value.replace(\"\\\\\", \"\\\\\\\\\").replace('\"', '\\\\\"').replace(\"'\", \"\\\\'\")\n68 \n69 \n70 @register.filter(is_safe=True)\n71 @stringfilter\n72 def capfirst(value):\n73     \"\"\"Capitalize the first character of the value.\"\"\"\n74     return value and value[0].upper() + value[1:]\n75 \n76 \n77 @register.filter(\"escapejs\")\n78 @stringfilter\n79 def escapejs_filter(value):\n80     \"\"\"Hex encode characters for use in JavaScript strings.\"\"\"\n81     return escapejs(value)\n82 \n83 \n84 @register.filter(is_safe=True)\n85 def json_script(value, element_id=None):\n86     \"\"\"\n87     Output value JSON-encoded, wrapped in a <script type=\"application/json\">\n88     tag (with an optional id).\n89     \"\"\"\n90     return _json_script(value, element_id)\n91 \n92 \n93 @register.filter(is_safe=True)\n94 def floatformat(text, arg=-1):\n95     \"\"\"\n96     Display a float to a specified number of decimal places.\n97 \n98     If called without an argument, display the floating point number with one\n99     decimal place -- but only if there's a decimal place to be displayed:\n100 \n101     * num1 = 34.23234\n102     * num2 = 34.00000\n103     * num3 = 34.26000\n104     * {{ num1|floatformat }} displays \"34.2\"\n105     * {{ num2|floatformat }} displays \"34\"\n106     * {{ num3|floatformat }} displays \"34.3\"\n107 \n108     If arg is positive, always display exactly arg number of decimal places:\n109 \n110     * {{ num1|floatformat:3 }} displays \"34.232\"\n111     * {{ num2|floatformat:3 }} displays \"34.000\"\n112     * {{ num3|floatformat:3 }} displays \"34.260\"\n113 \n114     If arg is negative, display arg number of decimal places -- but only if\n115     there are places to be displayed:\n116 \n117     * {{ num1|floatformat:\"-3\" }} displays \"34.232\"\n118     * {{ num2|floatformat:\"-3\" }} displays \"34\"\n119     * {{ num3|floatformat:\"-3\" }} displays \"34.260\"\n120 \n121     If arg has the 'g' suffix, force the result to be grouped by the\n122     THOUSAND_SEPARATOR for the active locale. When the active locale is\n123     en (English):\n124 \n125     * {{ 6666.6666|floatformat:\"2g\" }} displays \"6,666.67\"\n126     * {{ 10000|floatformat:\"g\" }} displays \"10,000\"\n127 \n128     If arg has the 'u' suffix, force the result to be unlocalized. When the\n129     active locale is pl (Polish):\n130 \n131     * {{ 66666.6666|floatformat:\"2\" }} displays \"66666,67\"\n132     * {{ 66666.6666|floatformat:\"2u\" }} displays \"66666.67\"\n133 \n134     If the input float is infinity or NaN, display the string representation\n135     of that value.\n136     \"\"\"\n137     force_grouping = False\n138     use_l10n = True\n139     if isinstance(arg, str):\n140         last_char = arg[-1]\n141         if arg[-2:] in {\"gu\", \"ug\"}:\n142             force_grouping = True\n143             use_l10n = False\n144             arg = arg[:-2] or -1\n145         elif last_char == \"g\":\n146             force_grouping = True\n147             arg = arg[:-1] or -1\n148         elif last_char == \"u\":\n149             use_l10n = False\n150             arg = arg[:-1] or -1\n151     try:\n152         input_val = repr(text)\n153         d = Decimal(input_val)\n154     except InvalidOperation:\n155         try:\n156             d = Decimal(str(float(text)))\n157         except (ValueError, InvalidOperation, TypeError):\n158             return \"\"\n159     try:\n160         p = int(arg)\n161     except ValueError:\n162         return input_val\n163 \n164     try:\n165         m = int(d) - d\n166     except (ValueError, OverflowError, InvalidOperation):\n167         return input_val\n168 \n169     if not m and p < 0:\n170         return mark_safe(\n171             formats.number_format(\n172                 \"%d\" % (int(d)),\n173                 0,\n174                 use_l10n=use_l10n,\n175                 force_grouping=force_grouping,\n176             )\n177         )\n178 \n179     exp = Decimal(1).scaleb(-abs(p))\n180     # Set the precision high enough to avoid an exception (#15789).\n181     tupl = d.as_tuple()\n182     units = len(tupl[1])\n183     units += -tupl[2] if m else tupl[2]\n184     prec = abs(p) + units + 1\n185 \n186     # Avoid conversion to scientific notation by accessing `sign`, `digits`,\n187     # and `exponent` from Decimal.as_tuple() directly.\n188     rounded_d = d.quantize(exp, ROUND_HALF_UP, Context(prec=prec))\n189     sign, digits, exponent = rounded_d.as_tuple()\n190     digits = [str(digit) for digit in reversed(digits)]\n191     while len(digits) <= abs(exponent):\n192         digits.append(\"0\")\n193     digits.insert(-exponent, \".\")\n194     if sign and rounded_d:\n195         digits.append(\"-\")\n196     number = \"\".join(reversed(digits))\n197     return mark_safe(\n198         formats.number_format(\n199             number,\n200             abs(p),\n201             use_l10n=use_l10n,\n202             force_grouping=force_grouping,\n203         )\n204     )\n205 \n206 \n207 @register.filter(is_safe=True)\n208 @stringfilter\n209 def iriencode(value):\n210     \"\"\"Escape an IRI value for use in a URL.\"\"\"\n211     return iri_to_uri(value)\n212 \n213 \n214 @register.filter(is_safe=True, needs_autoescape=True)\n215 @stringfilter\n216 def linenumbers(value, autoescape=True):\n217     \"\"\"Display text with line numbers.\"\"\"\n218     lines = value.split(\"\\n\")\n219     # Find the maximum width of the line count, for use with zero padding\n220     # string format command\n221     width = str(len(str(len(lines))))\n222     if not autoescape or isinstance(value, SafeData):\n223         for i, line in enumerate(lines):\n224             lines[i] = (\"%0\" + width + \"d. %s\") % (i + 1, line)\n225     else:\n226         for i, line in enumerate(lines):\n227             lines[i] = (\"%0\" + width + \"d. %s\") % (i + 1, escape(line))\n228     return mark_safe(\"\\n\".join(lines))\n229 \n230 \n231 @register.filter(is_safe=True)\n232 @stringfilter\n233 def lower(value):\n234     \"\"\"Convert a string into all lowercase.\"\"\"\n235     return value.lower()\n236 \n237 \n238 @register.filter(is_safe=False)\n239 @stringfilter\n240 def make_list(value):\n241     \"\"\"\n242     Return the value turned into a list.\n243 \n244     For an integer, it's a list of digits.\n245     For a string, it's a list of characters.\n246     \"\"\"\n247     return list(value)\n248 \n249 \n250 @register.filter(is_safe=True)\n251 @stringfilter\n252 def slugify(value):\n253     \"\"\"\n254     Convert to ASCII. Convert spaces to hyphens. Remove characters that aren't\n255     alphanumerics, underscores, or hyphens. Convert to lowercase. Also strip\n256     leading and trailing whitespace.\n257     \"\"\"\n258     return _slugify(value)\n259 \n260 \n261 @register.filter(is_safe=True)\n262 def stringformat(value, arg):\n263     \"\"\"\n264     Format the variable according to the arg, a string formatting specifier.\n265 \n266     This specifier uses Python string formatting syntax, with the exception\n267     that the leading \"%\" is dropped.\n268 \n269     See https://docs.python.org/library/stdtypes.html#printf-style-string-formatting\n270     for documentation of Python string formatting.\n271     \"\"\"\n272     if isinstance(value, tuple):\n273         value = str(value)\n274     try:\n275         return (\"%\" + str(arg)) % value\n276     except (ValueError, TypeError):\n277         return \"\"\n278 \n279 \n280 @register.filter(is_safe=True)\n281 @stringfilter\n282 def title(value):\n283     \"\"\"Convert a string into titlecase.\"\"\"\n284     t = re.sub(\"([a-z])'([A-Z])\", lambda m: m[0].lower(), value.title())\n285     return re.sub(r\"\\d([A-Z])\", lambda m: m[0].lower(), t)\n286 \n287 \n288 @register.filter(is_safe=True)\n289 @stringfilter\n290 def truncatechars(value, arg):\n291     \"\"\"Truncate a string after `arg` number of characters.\"\"\"\n292     try:\n293         length = int(arg)\n294     except ValueError:  # Invalid literal for int().\n295         return value  # Fail silently.\n296     return Truncator(value).chars(length)\n297 \n298 \n299 @register.filter(is_safe=True)\n300 @stringfilter\n301 def truncatechars_html(value, arg):\n302     \"\"\"\n303     Truncate HTML after `arg` number of chars.\n304     Preserve newlines in the HTML.\n305     \"\"\"\n306     try:\n307         length = int(arg)\n308     except ValueError:  # invalid literal for int()\n309         return value  # Fail silently.\n310     return Truncator(value).chars(length, html=True)\n311 \n312 \n313 @register.filter(is_safe=True)\n314 @stringfilter\n315 def truncatewords(value, arg):\n316     \"\"\"\n317     Truncate a string after `arg` number of words.\n318     Remove newlines within the string.\n319     \"\"\"\n320     try:\n321         length = int(arg)\n322     except ValueError:  # Invalid literal for int().\n323         return value  # Fail silently.\n324     return Truncator(value).words(length, truncate=\" \u2026\")\n325 \n326 \n327 @register.filter(is_safe=True)\n328 @stringfilter\n329 def truncatewords_html(value, arg):\n330     \"\"\"\n331     Truncate HTML after `arg` number of words.\n332     Preserve newlines in the HTML.\n333     \"\"\"\n334     try:\n335         length = int(arg)\n336     except ValueError:  # invalid literal for int()\n337         return value  # Fail silently.\n338     return Truncator(value).words(length, html=True, truncate=\" \u2026\")\n339 \n340 \n341 @register.filter(is_safe=False)\n342 @stringfilter\n343 def upper(value):\n344     \"\"\"Convert a string into all uppercase.\"\"\"\n345     return value.upper()\n346 \n347 \n348 @register.filter(is_safe=False)\n349 @stringfilter\n350 def urlencode(value, safe=None):\n351     \"\"\"\n352     Escape a value for use in a URL.\n353 \n354     The ``safe`` parameter determines the characters which should not be\n355     escaped by Python's quote() function. If not provided, use the default safe\n356     characters (but an empty string can be provided when *all* characters\n357     should be escaped).\n358     \"\"\"\n359     kwargs = {}\n360     if safe is not None:\n361         kwargs[\"safe\"] = safe\n362     return quote(value, **kwargs)\n363 \n364 \n365 @register.filter(is_safe=True, needs_autoescape=True)\n366 @stringfilter\n367 def urlize(value, autoescape=True):\n368     \"\"\"Convert URLs in plain text into clickable links.\"\"\"\n369     return mark_safe(_urlize(value, nofollow=True, autoescape=autoescape))\n370 \n371 \n372 @register.filter(is_safe=True, needs_autoescape=True)\n373 @stringfilter\n374 def urlizetrunc(value, limit, autoescape=True):\n375     \"\"\"\n376     Convert URLs into clickable links, truncating URLs to the given character\n377     limit, and adding 'rel=nofollow' attribute to discourage spamming.\n378 \n379     Argument: Length to truncate URLs to.\n380     \"\"\"\n381     return mark_safe(\n382         _urlize(value, trim_url_limit=int(limit), nofollow=True, autoescape=autoescape)\n383     )\n384 \n385 \n386 @register.filter(is_safe=False)\n387 @stringfilter\n388 def wordcount(value):\n389     \"\"\"Return the number of words.\"\"\"\n390     return len(value.split())\n391 \n392 \n393 @register.filter(is_safe=True)\n394 @stringfilter\n395 def wordwrap(value, arg):\n396     \"\"\"Wrap words at `arg` line length.\"\"\"\n397     return wrap(value, int(arg))\n398 \n399 \n400 @register.filter(is_safe=True)\n401 @stringfilter\n402 def ljust(value, arg):\n403     \"\"\"Left-align the value in a field of a given width.\"\"\"\n404     return value.ljust(int(arg))\n405 \n406 \n407 @register.filter(is_safe=True)\n408 @stringfilter\n409 def rjust(value, arg):\n410     \"\"\"Right-align the value in a field of a given width.\"\"\"\n411     return value.rjust(int(arg))\n412 \n413 \n414 @register.filter(is_safe=True)\n415 @stringfilter\n416 def center(value, arg):\n417     \"\"\"Center the value in a field of a given width.\"\"\"\n418     return value.center(int(arg))\n419 \n420 \n421 @register.filter\n422 @stringfilter\n423 def cut(value, arg):\n424     \"\"\"Remove all values of arg from the given string.\"\"\"\n425     safe = isinstance(value, SafeData)\n426     value = value.replace(arg, \"\")\n427     if safe and arg != \";\":\n428         return mark_safe(value)\n429     return value\n430 \n431 \n432 ###################\n433 # HTML STRINGS    #\n434 ###################\n435 \n436 \n437 @register.filter(\"escape\", is_safe=True)\n438 @stringfilter\n439 def escape_filter(value):\n440     \"\"\"Mark the value as a string that should be auto-escaped.\"\"\"\n441     return conditional_escape(value)\n442 \n443 \n444 @register.filter(is_safe=True)\n445 @stringfilter\n446 def force_escape(value):\n447     \"\"\"\n448     Escape a string's HTML. Return a new string containing the escaped\n449     characters (as opposed to \"escape\", which marks the content for later\n450     possible escaping).\n451     \"\"\"\n452     return escape(value)\n453 \n454 \n455 @register.filter(\"linebreaks\", is_safe=True, needs_autoescape=True)\n456 @stringfilter\n457 def linebreaks_filter(value, autoescape=True):\n458     \"\"\"\n459     Replace line breaks in plain text with appropriate HTML; a single\n460     newline becomes an HTML line break (``<br>``) and a new line\n461     followed by a blank line becomes a paragraph break (``</p>``).\n462     \"\"\"\n463     autoescape = autoescape and not isinstance(value, SafeData)\n464     return mark_safe(linebreaks(value, autoescape))\n465 \n466 \n467 @register.filter(is_safe=True, needs_autoescape=True)\n468 @stringfilter\n469 def linebreaksbr(value, autoescape=True):\n470     \"\"\"\n471     Convert all newlines in a piece of plain text to HTML line breaks\n472     (``<br>``).\n473     \"\"\"\n474     autoescape = autoescape and not isinstance(value, SafeData)\n475     value = normalize_newlines(value)\n476     if autoescape:\n477         value = escape(value)\n478     return mark_safe(value.replace(\"\\n\", \"<br>\"))\n479 \n480 \n481 @register.filter(is_safe=True)\n482 @stringfilter\n483 def safe(value):\n484     \"\"\"Mark the value as a string that should not be auto-escaped.\"\"\"\n485     return mark_safe(value)\n486 \n487 \n488 @register.filter(is_safe=True)\n489 def safeseq(value):\n490     \"\"\"\n491     A \"safe\" filter for sequences. Mark each element in the sequence,\n492     individually, as safe, after converting them to strings. Return a list\n493     with the results.\n494     \"\"\"\n495     return [mark_safe(obj) for obj in value]\n496 \n497 \n498 @register.filter(is_safe=True)\n499 @stringfilter\n500 def striptags(value):\n501     \"\"\"Strip all [X]HTML tags.\"\"\"\n502     return strip_tags(value)\n503 \n504 \n505 ###################\n506 # LISTS           #\n507 ###################\n508 \n509 \n510 def _property_resolver(arg):\n511     \"\"\"\n512     When arg is convertible to float, behave like operator.itemgetter(arg)\n513     Otherwise, chain __getitem__() and getattr().\n514 \n515     >>> _property_resolver(1)('abc')\n516     'b'\n517     >>> _property_resolver('1')('abc')\n518     Traceback (most recent call last):\n519     ...\n520     TypeError: string indices must be integers\n521     >>> class Foo:\n522     ...     a = 42\n523     ...     b = 3.14\n524     ...     c = 'Hey!'\n525     >>> _property_resolver('b')(Foo())\n526     3.14\n527     \"\"\"\n528     try:\n529         float(arg)\n530     except ValueError:\n531         if VARIABLE_ATTRIBUTE_SEPARATOR + \"_\" in arg or arg[0] == \"_\":\n532             raise AttributeError(\"Access to private variables is forbidden.\")\n533         parts = arg.split(VARIABLE_ATTRIBUTE_SEPARATOR)\n534 \n535         def resolve(value):\n536             for part in parts:\n537                 try:\n538                     value = value[part]\n539                 except (AttributeError, IndexError, KeyError, TypeError, ValueError):\n540                     value = getattr(value, part)\n541             return value\n542 \n543         return resolve\n544     else:\n545         return itemgetter(arg)\n546 \n547 \n548 @register.filter(is_safe=False)\n549 def dictsort(value, arg):\n550     \"\"\"\n551     Given a list of dicts, return that list sorted by the property given in\n552     the argument.\n553     \"\"\"\n554     try:\n555         return sorted(value, key=_property_resolver(arg))\n556     except (AttributeError, TypeError):\n557         return \"\"\n558 \n559 \n560 @register.filter(is_safe=False)\n561 def dictsortreversed(value, arg):\n562     \"\"\"\n563     Given a list of dicts, return that list sorted in reverse order by the\n564     property given in the argument.\n565     \"\"\"\n566     try:\n567         return sorted(value, key=_property_resolver(arg), reverse=True)\n568     except (AttributeError, TypeError):\n569         return \"\"\n570 \n571 \n572 @register.filter(is_safe=False)\n573 def first(value):\n574     \"\"\"Return the first item in a list.\"\"\"\n575     try:\n576         return value[0]\n577     except IndexError:\n578         return \"\"\n579 \n580 \n581 @register.filter(is_safe=True, needs_autoescape=True)\n582 def join(value, arg, autoescape=True):\n583     \"\"\"Join a list with a string, like Python's ``str.join(list)``.\"\"\"\n584     try:\n585         if autoescape:\n586             value = [conditional_escape(v) for v in value]\n587         data = conditional_escape(arg).join(value)\n588     except TypeError:  # Fail silently if arg isn't iterable.\n589         return value\n590     return mark_safe(data)\n591 \n592 \n593 @register.filter(is_safe=True)\n594 def last(value):\n595     \"\"\"Return the last item in a list.\"\"\"\n596     try:\n597         return value[-1]\n598     except IndexError:\n599         return \"\"\n600 \n601 \n602 @register.filter(is_safe=False)\n603 def length(value):\n604     \"\"\"Return the length of the value - useful for lists.\"\"\"\n605     try:\n606         return len(value)\n607     except (ValueError, TypeError):\n608         return 0\n609 \n610 \n611 @register.filter(is_safe=False)\n612 def length_is(value, arg):\n613     \"\"\"Return a boolean of whether the value's length is the argument.\"\"\"\n614     try:\n615         return len(value) == int(arg)\n616     except (ValueError, TypeError):\n617         return \"\"\n618 \n619 \n620 @register.filter(is_safe=True)\n621 def random(value):\n622     \"\"\"Return a random item from the list.\"\"\"\n623     return random_module.choice(value)\n624 \n625 \n626 @register.filter(\"slice\", is_safe=True)\n627 def slice_filter(value, arg):\n628     \"\"\"\n629     Return a slice of the list using the same syntax as Python's list slicing.\n630     \"\"\"\n631     try:\n632         bits = []\n633         for x in str(arg).split(\":\"):\n634             if not x:\n635                 bits.append(None)\n636             else:\n637                 bits.append(int(x))\n638         return value[slice(*bits)]\n639 \n640     except (ValueError, TypeError):\n641         return value  # Fail silently.\n642 \n643 \n644 @register.filter(is_safe=True, needs_autoescape=True)\n645 def unordered_list(value, autoescape=True):\n646     \"\"\"\n647     Recursively take a self-nested list and return an HTML unordered list --\n648     WITHOUT opening and closing <ul> tags.\n649 \n650     Assume the list is in the proper format. For example, if ``var`` contains:\n651     ``['States', ['Kansas', ['Lawrence', 'Topeka'], 'Illinois']]``, then\n652     ``{{ var|unordered_list }}`` returns::\n653 \n654         <li>States\n655         <ul>\n656                 <li>Kansas\n657                 <ul>\n658                         <li>Lawrence</li>\n659                         <li>Topeka</li>\n660                 </ul>\n661                 </li>\n662                 <li>Illinois</li>\n663         </ul>\n664         </li>\n665     \"\"\"\n666     if autoescape:\n667         escaper = conditional_escape\n668     else:\n669 \n670         def escaper(x):\n671             return x\n672 \n673     def walk_items(item_list):\n674         item_iterator = iter(item_list)\n675         try:\n676             item = next(item_iterator)\n677             while True:\n678                 try:\n679                     next_item = next(item_iterator)\n680                 except StopIteration:\n681                     yield item, None\n682                     break\n683                 if isinstance(next_item, (list, tuple, types.GeneratorType)):\n684                     try:\n685                         iter(next_item)\n686                     except TypeError:\n687                         pass\n688                     else:\n689                         yield item, next_item\n690                         item = next(item_iterator)\n691                         continue\n692                 yield item, None\n693                 item = next_item\n694         except StopIteration:\n695             pass\n696 \n697     def list_formatter(item_list, tabs=1):\n698         indent = \"\\t\" * tabs\n699         output = []\n700         for item, children in walk_items(item_list):\n701             sublist = \"\"\n702             if children:\n703                 sublist = \"\\n%s<ul>\\n%s\\n%s</ul>\\n%s\" % (\n704                     indent,\n705                     list_formatter(children, tabs + 1),\n706                     indent,\n707                     indent,\n708                 )\n709             output.append(\"%s<li>%s%s</li>\" % (indent, escaper(item), sublist))\n710         return \"\\n\".join(output)\n711 \n712     return mark_safe(list_formatter(value))\n713 \n714 \n715 ###################\n716 # INTEGERS        #\n717 ###################\n718 \n719 \n720 @register.filter(is_safe=False)\n721 def add(value, arg):\n722     \"\"\"Add the arg to the value.\"\"\"\n723     try:\n724         return int(value) + int(arg)\n725     except (ValueError, TypeError):\n726         try:\n727             return value + arg\n728         except Exception:\n729             return \"\"\n730 \n731 \n732 @register.filter(is_safe=False)\n733 def get_digit(value, arg):\n734     \"\"\"\n735     Given a whole number, return the requested digit of it, where 1 is the\n736     right-most digit, 2 is the second-right-most digit, etc. Return the\n737     original value for invalid input (if input or argument is not an integer,\n738     or if argument is less than 1). Otherwise, output is always an integer.\n739     \"\"\"\n740     try:\n741         arg = int(arg)\n742         value = int(value)\n743     except ValueError:\n744         return value  # Fail silently for an invalid argument\n745     if arg < 1:\n746         return value\n747     try:\n748         return int(str(value)[-arg])\n749     except IndexError:\n750         return 0\n751 \n752 \n753 ###################\n754 # DATES           #\n755 ###################\n756 \n757 \n758 @register.filter(expects_localtime=True, is_safe=False)\n759 def date(value, arg=None):\n760     \"\"\"Format a date according to the given format.\"\"\"\n761     if value in (None, \"\"):\n762         return \"\"\n763     try:\n764         return formats.date_format(value, arg)\n765     except AttributeError:\n766         try:\n767             return format(value, arg)\n768         except AttributeError:\n769             return \"\"\n770 \n771 \n772 @register.filter(expects_localtime=True, is_safe=False)\n773 def time(value, arg=None):\n774     \"\"\"Format a time according to the given format.\"\"\"\n775     if value in (None, \"\"):\n776         return \"\"\n777     try:\n778         return formats.time_format(value, arg)\n779     except (AttributeError, TypeError):\n780         try:\n781             return time_format(value, arg)\n782         except (AttributeError, TypeError):\n783             return \"\"\n784 \n785 \n786 @register.filter(\"timesince\", is_safe=False)\n787 def timesince_filter(value, arg=None):\n788     \"\"\"Format a date as the time since that date (i.e. \"4 days, 6 hours\").\"\"\"\n789     if not value:\n790         return \"\"\n791     try:\n792         if arg:\n793             return timesince(value, arg)\n794         return timesince(value)\n795     except (ValueError, TypeError):\n796         return \"\"\n797 \n798 \n799 @register.filter(\"timeuntil\", is_safe=False)\n800 def timeuntil_filter(value, arg=None):\n801     \"\"\"Format a date as the time until that date (i.e. \"4 days, 6 hours\").\"\"\"\n802     if not value:\n803         return \"\"\n804     try:\n805         return timeuntil(value, arg)\n806     except (ValueError, TypeError):\n807         return \"\"\n808 \n809 \n810 ###################\n811 # LOGIC           #\n812 ###################\n813 \n814 \n815 @register.filter(is_safe=False)\n816 def default(value, arg):\n817     \"\"\"If value is unavailable, use given default.\"\"\"\n818     return value or arg\n819 \n820 \n821 @register.filter(is_safe=False)\n822 def default_if_none(value, arg):\n823     \"\"\"If value is None, use given default.\"\"\"\n824     if value is None:\n825         return arg\n826     return value\n827 \n828 \n829 @register.filter(is_safe=False)\n830 def divisibleby(value, arg):\n831     \"\"\"Return True if the value is divisible by the argument.\"\"\"\n832     return int(value) % int(arg) == 0\n833 \n834 \n835 @register.filter(is_safe=False)\n836 def yesno(value, arg=None):\n837     \"\"\"\n838     Given a string mapping values for true, false, and (optionally) None,\n839     return one of those strings according to the value:\n840 \n841     ==========  ======================  ==================================\n842     Value       Argument                Outputs\n843     ==========  ======================  ==================================\n844     ``True``    ``\"yeah,no,maybe\"``     ``yeah``\n845     ``False``   ``\"yeah,no,maybe\"``     ``no``\n846     ``None``    ``\"yeah,no,maybe\"``     ``maybe``\n847     ``None``    ``\"yeah,no\"``           ``\"no\"`` (converts None to False\n848                                         if no mapping for None is given.\n849     ==========  ======================  ==================================\n850     \"\"\"\n851     if arg is None:\n852         # Translators: Please do not add spaces around commas.\n853         arg = gettext(\"yes,no,maybe\")\n854     bits = arg.split(\",\")\n855     if len(bits) < 2:\n856         return value  # Invalid arg.\n857     try:\n858         yes, no, maybe = bits\n859     except ValueError:\n860         # Unpack list of wrong size (no \"maybe\" value provided).\n861         yes, no, maybe = bits[0], bits[1], bits[1]\n862     if value is None:\n863         return maybe\n864     if value:\n865         return yes\n866     return no\n867 \n868 \n869 ###################\n870 # MISC            #\n871 ###################\n872 \n873 \n874 @register.filter(is_safe=True)\n875 def filesizeformat(bytes_):\n876     \"\"\"\n877     Format the value like a 'human-readable' file size (i.e. 13 KB, 4.1 MB,\n878     102 bytes, etc.).\n879     \"\"\"\n880     try:\n881         bytes_ = int(bytes_)\n882     except (TypeError, ValueError, UnicodeDecodeError):\n883         value = ngettext(\"%(size)d byte\", \"%(size)d bytes\", 0) % {\"size\": 0}\n884         return avoid_wrapping(value)\n885 \n886     def filesize_number_format(value):\n887         return formats.number_format(round(value, 1), 1)\n888 \n889     KB = 1 << 10\n890     MB = 1 << 20\n891     GB = 1 << 30\n892     TB = 1 << 40\n893     PB = 1 << 50\n894 \n895     negative = bytes_ < 0\n896     if negative:\n897         bytes_ = -bytes_  # Allow formatting of negative numbers.\n898 \n899     if bytes_ < KB:\n900         value = ngettext(\"%(size)d byte\", \"%(size)d bytes\", bytes_) % {\"size\": bytes_}\n901     elif bytes_ < MB:\n902         value = gettext(\"%s KB\") % filesize_number_format(bytes_ / KB)\n903     elif bytes_ < GB:\n904         value = gettext(\"%s MB\") % filesize_number_format(bytes_ / MB)\n905     elif bytes_ < TB:\n906         value = gettext(\"%s GB\") % filesize_number_format(bytes_ / GB)\n907     elif bytes_ < PB:\n908         value = gettext(\"%s TB\") % filesize_number_format(bytes_ / TB)\n909     else:\n910         value = gettext(\"%s PB\") % filesize_number_format(bytes_ / PB)\n911 \n912     if negative:\n913         value = \"-%s\" % value\n914     return avoid_wrapping(value)\n915 \n916 \n917 @register.filter(is_safe=False)\n918 def pluralize(value, arg=\"s\"):\n919     \"\"\"\n920     Return a plural suffix if the value is not 1, '1', or an object of\n921     length 1. By default, use 's' as the suffix:\n922 \n923     * If value is 0, vote{{ value|pluralize }} display \"votes\".\n924     * If value is 1, vote{{ value|pluralize }} display \"vote\".\n925     * If value is 2, vote{{ value|pluralize }} display \"votes\".\n926 \n927     If an argument is provided, use that string instead:\n928 \n929     * If value is 0, class{{ value|pluralize:\"es\" }} display \"classes\".\n930     * If value is 1, class{{ value|pluralize:\"es\" }} display \"class\".\n931     * If value is 2, class{{ value|pluralize:\"es\" }} display \"classes\".\n932 \n933     If the provided argument contains a comma, use the text before the comma\n934     for the singular case and the text after the comma for the plural case:\n935 \n936     * If value is 0, cand{{ value|pluralize:\"y,ies\" }} display \"candies\".\n937     * If value is 1, cand{{ value|pluralize:\"y,ies\" }} display \"candy\".\n938     * If value is 2, cand{{ value|pluralize:\"y,ies\" }} display \"candies\".\n939     \"\"\"\n940     if \",\" not in arg:\n941         arg = \",\" + arg\n942     bits = arg.split(\",\")\n943     if len(bits) > 2:\n944         return \"\"\n945     singular_suffix, plural_suffix = bits[:2]\n946 \n947     try:\n948         return singular_suffix if float(value) == 1 else plural_suffix\n949     except ValueError:  # Invalid string that's not a number.\n950         pass\n951     except TypeError:  # Value isn't a string or a number; maybe it's a list?\n952         try:\n953             return singular_suffix if len(value) == 1 else plural_suffix\n954         except TypeError:  # len() of unsized object.\n955             pass\n956     return \"\"\n957 \n958 \n959 @register.filter(\"phone2numeric\", is_safe=True)\n960 def phone2numeric_filter(value):\n961     \"\"\"Take a phone number and converts it in to its numerical equivalent.\"\"\"\n962     return phone2numeric(value)\n963 \n964 \n965 @register.filter(is_safe=True)\n966 def pprint(value):\n967     \"\"\"A wrapper around pprint.pprint -- for debugging, really.\"\"\"\n968     try:\n969         return pformat(value)\n970     except Exception as e:\n971         return \"Error in formatting: %s: %s\" % (e.__class__.__name__, e)\n",
        "intended_behavior": "The `blocktranslate` tag's handling of the `asvar` argument should correctly manage and store variables as `SafeString` instances when the context marks them safe. This ensures that when the variable is reused (e.g., in HTML attributes), it does not undergo double escaping, preserving output fidelity. This could entail adjusting the blocktranslate tag processing code to evaluate the safety of its content when `asvar` is used and ensuring the output is either a `SafeString` (when safe) or is marked appropriately to avoid re-escaping already escaped content."
    },
    {
        "rel_file_path": "django/utils/html.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__4.2/django/utils/html.py",
        "start": 18,
        "end": 27,
        "class_name": null,
        "method_name": "escape",
        "code": "18 def escape(text):\n19     \"\"\"\n20     Return the given text with ampersands, quotes and angle brackets encoded\n21     for use in HTML.\n22 \n23     Always escape input, even if it's already escaped and marked as such.\n24     This may result in double-escaping. If this is a concern, use\n25     conditional_escape() instead.\n26     \"\"\"\n27     return SafeString(html.escape(str(text)))\n",
        "intended_behavior": "While not directly buggy in relation to the issue, ensuring the usage of `escape` within the template processing (and particularly within the `blocktranslate` tag processing) respects the `SafeString` marking is crucial. The method itself provides the mechanism to escape content appropriately and returns `SafeString`, but its application in the context of `blocktranslate` and `asvar` must guarantee that this safety attribute is preserved, avoiding double escapes. This suggests the surrounding logic in template rendering that invokes `escape` needs to respect or leverage the `SafeString` mechanism more explicitly, especially post-variable substitution in `blocktranslate` usage."
    }
]