2025-10-18 00:57:00.162 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-18 00:57:05.009 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=236, output_tokens=12, cost=0.002720
2025-10-18 00:57:20.706 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=416, output_tokens=598, cost=0.022100
2025-10-18 00:57:21.887 | INFO     | registered non reproducing test 0
2025-10-18 00:57:39.994 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1787, output_tokens=849, cost=0.043340
2025-10-18 00:57:41.124 | INFO     | registered non reproducing test 1
2025-10-18 00:57:57.591 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1850, output_tokens=745, cost=0.040850
2025-10-18 00:57:58.749 | INFO     | registered non reproducing test 2
2025-10-18 00:57:58.749 | WARNING  | Failed to write a reproducer test; skipping reproducer tracing
2025-10-18 00:57:58.755 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 00:58:09.343 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=541, output_tokens=489, cost=0.020080
2025-10-18 00:58:09.355 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 00:58:12.592 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=843, output_tokens=73, cost=0.010620
2025-10-18 00:58:12.594 | DEBUG    | Extracted a valid json.
2025-10-18 00:58:12.594 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_code(\"ManyToManyField\")",
        "search_code(\"CreateModel\")",
        "search_code(\"AddField\")",
        "search_code(\"ManyToManyField(related_name='+')\")",
        "search_code(\"ManyToManyField(related_name=\")"
    ],
    "bug_locations": []
}
2025-10-18 00:58:12.781 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 00:58:12.781 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 00:58:27.281 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2022, output_tokens=700, cost=0.041220
2025-10-18 00:58:27.289 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 00:58:38.034 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2938, output_tokens=503, cost=0.044470
2025-10-18 00:58:38.039 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 00:58:45.119 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=857, output_tokens=203, cost=0.014660
2025-10-18 00:58:45.120 | DEBUG    | Extracted a valid json.
2025-10-18 00:58:45.120 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "django/db/migrations/autodetector.py",
            "class": "",
            "method": "",
            "intended_behavior": "Enhance the logic to correctly handle models with the same name across different apps especially when they reference each other through `ManyToManyField`. This includes ensuring that the `related_name` attribute does not cause conflicts during migration generation, even when set to `'+'`, which is supposed to prevent the reverse relation."
        },
        {
            "file": "django/db/models/fields/related.py",
            "class": "",
            "method": "",
            "intended_behavior": "Ensure that the `related_name='+'` or similar directives do not lead to migration errors when used in models with identical names across different applications. There might need to be a clarification or enhancement in how these models and their relationships are processed to allow for smooth migration creation."
        }
    ]
}
2025-10-18 00:58:45.134 | DEBUG    | Bug location extracted successfully: [<file>django/db/migrations/autodetector.py</file>
<class>None</class>
<method>None</method>
<code>
1 import functools
2 import re
3 from itertools import chain
4 
5 from django.conf import settings
6 from django.db import models
7 from django.db.migrations import operations
8 from django.db.migrations.migration import Migration
9 from django.db.migrations.operations.models import AlterModelOptions
10 from django.db.migrations.optimizer import MigrationOptimizer
11 from django.db.migrations.questioner import MigrationQuestioner
12 from django.db.migrations.utils import COMPILED_REGEX_TYPE, RegexObject
13 from django.utils.topological_sort import stable_topological_sort
14 
15 
16 class MigrationAutodetector:
17     """
18     Take a pair of ProjectStates and compare them to see what the first would
19     need doing to make it match the second (the second usually being the
20     project's current state).
21 
22     Note that this naturally operates on entire projects at a time,
23     as it's likely that changes interact (for example, you can't
24     add a ForeignKey without having a migration to add the table it
25     depends on first). A user interface may offer single-app usage
26     if it wishes, with the caveat that it may not always be possible.
27     """
28 
29     def __init__(self, from_state, to_state, questioner=None):
30         self.from_state = from_state
31         self.to_state = to_state
32         self.questioner = questioner or MigrationQuestioner()
33         self.existing_apps = {app for app, model in from_state.models}
34 
35     def changes(self, graph, trim_to_apps=None, convert_apps=None, migration_name=None):
36         """
37         Main entry point to produce a list of applicable changes.
38         Take a graph to base names on and an optional set of apps
39         to try and restrict to (restriction is not guaranteed)
40         """
41         changes = self._detect_changes(convert_apps, graph)
42         changes = self.arrange_for_graph(changes, graph, migration_name)
43         if trim_to_apps:
44             changes = self._trim_to_apps(changes, trim_to_apps)
45         return changes
46 
47     def deep_deconstruct(self, obj):
48         """
49         Recursive deconstruction for a field and its arguments.
50         Used for full comparison for rename/alter; sometimes a single-level
51         deconstruction will not compare correctly.
52         """
53         if isinstance(obj, list):
54             return [self.deep_deconstruct(value) for value in obj]
55         elif isinstance(obj, tuple):
56             return tuple(self.deep_deconstruct(value) for value in obj)
57         elif isinstance(obj, dict):
58             return {
59                 key: self.deep_deconstruct(value)
60                 for key, value in obj.items()
61             }
62         elif isinstance(obj, functools.partial):
63             return (obj.func, self.deep_deconstruct(obj.args), self.deep_deconstruct(obj.keywords))
64         elif isinstance(obj, COMPILED_REGEX_TYPE):
65             return RegexObject(obj)
66         elif isinstance(obj, type):
67             # If this is a type that implements 'deconstruct' as an instance method,
68             # avoid treating this as being deconstructible itself - see #22951
69             return obj
70         elif hasattr(obj, 'deconstruct'):
71             deconstructed = obj.deconstruct()
72             if isinstance(obj, models.Field):
73                 # we have a field which also returns a name
74                 deconstructed = deconstructed[1:]
75             path, args, kwargs = deconstructed
76             return (
77                 path,
78                 [self.deep_deconstruct(value) for value in args],
79                 {
80                     key: self.deep_deconstruct(value)
81                     for key, value in kwargs.items()
82                 },
83             )
84         else:
85             return obj
86 
87     def only_relation_agnostic_fields(self, fields):
88         """
89         Return a definition of the fields that ignores field names and
90         what related fields actually relate to. Used for detecting renames (as
91         the related fields change during renames).
92         """
93         fields_def = []
94         for name, field in sorted(fields.items()):
95             deconstruction = self.deep_deconstruct(field)
96             if field.remote_field and field.remote_field.model:
97                 del deconstruction[2]['to']
98             fields_def.append(deconstruction)
99         return fields_def
100 
101     def _detect_changes(self, convert_apps=None, graph=None):
102         """
103         Return a dict of migration plans which will achieve the
104         change from from_state to to_state. The dict has app labels
105         as keys and a list of migrations as values.
106 
107         The resulting migrations aren't specially named, but the names
108         do matter for dependencies inside the set.
109 
110         convert_apps is the list of apps to convert to use migrations
111         (i.e. to make initial migrations for, in the usual case)
112 
113         graph is an optional argument that, if provided, can help improve
114         dependency generation and avoid potential circular dependencies.
115         """
116         # The first phase is generating all the operations for each app
117         # and gathering them into a big per-app list.
118         # Then go through that list, order it, and split into migrations to
119         # resolve dependencies caused by M2Ms and FKs.
120         self.generated_operations = {}
121         self.altered_indexes = {}
122         self.altered_constraints = {}
123 
124         # Prepare some old/new state and model lists, separating
125         # proxy models and ignoring unmigrated apps.
126         self.old_apps = self.from_state.concrete_apps
127         self.new_apps = self.to_state.apps
128         self.old_model_keys = set()
129         self.old_proxy_keys = set()
130         self.old_unmanaged_keys = set()
131         self.new_model_keys = set()
132         self.new_proxy_keys = set()
133         self.new_unmanaged_keys = set()
134         for al, mn in self.from_state.models:
135             model = self.old_apps.get_model(al, mn)
136             if not model._meta.managed:
137                 self.old_unmanaged_keys.add((al, mn))
138             elif al not in self.from_state.real_apps:
139                 if model._meta.proxy:
140                     self.old_proxy_keys.add((al, mn))
141                 else:
142                     self.old_model_keys.add((al, mn))
143 
144         for al, mn in self.to_state.models:
145             model = self.new_apps.get_model(al, mn)
146             if not model._meta.managed:
147                 self.new_unmanaged_keys.add((al, mn))
148             elif (
149                 al not in self.from_state.real_apps or
150                 (convert_apps and al in convert_apps)
151             ):
152                 if model._meta.proxy:
153                     self.new_proxy_keys.add((al, mn))
154                 else:
155                     self.new_model_keys.add((al, mn))
156 
157         # Renames have to come first
158         self.generate_renamed_models()
159 
160         # Prepare lists of fields and generate through model map
161         self._prepare_field_lists()
162         self._generate_through_model_map()
163 
164         # Generate non-rename model operations
165         self.generate_deleted_models()
166         self.generate_created_models()
167         self.generate_deleted_proxies()
168         self.generate_created_proxies()
169         self.generate_altered_options()
170         self.generate_altered_managers()
171 
172         # Create the altered indexes and store them in self.altered_indexes.
173         # This avoids the same computation in generate_removed_indexes()
174         # and generate_added_indexes().
175         self.create_altered_indexes()
176         self.create_altered_constraints()
177         # Generate index removal operations before field is removed
178         self.generate_removed_constraints()
179         self.generate_removed_indexes()
180         # Generate field operations
181         self.generate_renamed_fields()
182         self.generate_removed_fields()
183         self.generate_added_fields()
184         self.generate_altered_fields()
185         self.generate_altered_order_with_respect_to()
186         self.generate_altered_unique_together()
187         self.generate_altered_index_together()
188         self.generate_added_indexes()
189         self.generate_added_constraints()
190         self.generate_altered_db_table()
191 
192         self._sort_migrations()
193         self._build_migration_list(graph)
194         self._optimize_migrations()
195 
196         return self.migrations
197 
198     def _prepare_field_lists(self):
199         """
200         Prepare field lists and a list of the fields that used through models
201         in the old state so dependencies can be made from the through model
202         deletion to the field that uses it.
203         """
204         self.kept_model_keys = self.old_model_keys & self.new_model_keys
205         self.kept_proxy_keys = self.old_proxy_keys & self.new_proxy_keys
206         self.kept_unmanaged_keys = self.old_unmanaged_keys & self.new_unmanaged_keys
207         self.through_users = {}
208         self.old_field_keys = {
209             (app_label, model_name, field_name)
210             for app_label, model_name in self.kept_model_keys
211             for field_name in self.from_state.models[
212                 app_label,
213                 self.renamed_models.get((app_label, model_name), model_name)
214             ].fields
215         }
216         self.new_field_keys = {
217             (app_label, model_name, field_name)
218             for app_label, model_name in self.kept_model_keys
219             for field_name in self.to_state.models[app_label, model_name].fields
220         }
221 
222     def _generate_through_model_map(self):
223         """Through model map generation."""
224         for app_label, model_name in sorted(self.old_model_keys):
225             old_model_name = self.renamed_models.get((app_label, model_name), model_name)
226             old_model_state = self.from_state.models[app_label, old_model_name]
227             for field_name in old_model_state.fields:
228                 old_field = self.old_apps.get_model(app_label, old_model_name)._meta.get_field(field_name)
229                 if (hasattr(old_field, "remote_field") and getattr(old_field.remote_field, "through", None) and
230                         not old_field.remote_field.through._meta.auto_created):
231                     through_key = (
232                         old_field.remote_field.through._meta.app_label,
233                         old_field.remote_field.through._meta.model_name,
234                     )
235                     self.through_users[through_key] = (app_label, old_model_name, field_name)
236 
237     @staticmethod
238     def _resolve_dependency(dependency):
239         """
240         Return the resolved dependency and a boolean denoting whether or not
241         it was swappable.
242         """
243         if dependency[0] != '__setting__':
244             return dependency, False
245         resolved_app_label, resolved_object_name = getattr(settings, dependency[1]).split('.')
246         return (resolved_app_label, resolved_object_name.lower()) + dependency[2:], True
247 
248     def _build_migration_list(self, graph=None):
249         """
250         Chop the lists of operations up into migrations with dependencies on
251         each other. Do this by going through an app's list of operations until
252         one is found that has an outgoing dependency that isn't in another
253         app's migration yet (hasn't been chopped off its list). Then chop off
254         the operations before it into a migration and move onto the next app.
255         If the loops completes without doing anything, there's a circular
256         dependency (which _should_ be impossible as the operations are
257         all split at this point so they can't depend and be depended on).
258         """
259         self.migrations = {}
260         num_ops = sum(len(x) for x in self.generated_operations.values())
261         chop_mode = False
262         while num_ops:
263             # On every iteration, we step through all the apps and see if there
264             # is a completed set of operations.
265             # If we find that a subset of the operations are complete we can
266             # try to chop it off from the rest and continue, but we only
267             # do this if we've already been through the list once before
268             # without any chopping and nothing has changed.
269             for app_label in sorted(self.generated_operations):
270                 chopped = []
271                 dependencies = set()
272                 for operation in list(self.generated_operations[app_label]):
273                     deps_satisfied = True
274                     operation_dependencies = set()
275                     for dep in operation._auto_deps:
276                         # Temporarily resolve the swappable dependency to
277                         # prevent circular references. While keeping the
278                         # dependency checks on the resolved model, add the
279                         # swappable dependencies.
280                         original_dep = dep
281                         dep, is_swappable_dep = self._resolve_dependency(dep)
282                         if dep[0] != app_label:
283                             # External app dependency. See if it's not yet
284                             # satisfied.
285                             for other_operation in self.generated_operations.get(dep[0], []):
286                                 if self.check_dependency(other_operation, dep):
287                                     deps_satisfied = False
288                                     break
289                             if not deps_satisfied:
290                                 break
291                             else:
292                                 if is_swappable_dep:
293                                     operation_dependencies.add((original_dep[0], original_dep[1]))
294                                 elif dep[0] in self.migrations:
295                                     operation_dependencies.add((dep[0], self.migrations[dep[0]][-1].name))
296                                 else:
297                                     # If we can't find the other app, we add a first/last dependency,
298                                     # but only if we've already been through once and checked everything
299                                     if chop_mode:
300                                         # If the app already exists, we add a dependency on the last migration,
301                                         # as we don't know which migration contains the target field.
302                                         # If it's not yet migrated or has no migrations, we use __first__
303                                         if graph and graph.leaf_nodes(dep[0]):
304                                             operation_dependencies.add(graph.leaf_nodes(dep[0])[0])
305                                         else:
306                                             operation_dependencies.add((dep[0], "__first__"))
307                                     else:
308                                         deps_satisfied = False
309                     if deps_satisfied:
310                         chopped.append(operation)
311                         dependencies.update(operation_dependencies)
312                         del self.generated_operations[app_label][0]
313                     else:
314                         break
315                 # Make a migration! Well, only if there's stuff to put in it
316                 if dependencies or chopped:
317                     if not self.generated_operations[app_label] or chop_mode:
318                         subclass = type("Migration", (Migration,), {"operations": [], "dependencies": []})
319                         instance = subclass("auto_%i" % (len(self.migrations.get(app_label, [])) + 1), app_label)
320                         instance.dependencies = list(dependencies)
321                         instance.operations = chopped
322                         instance.initial = app_label not in self.existing_apps
323                         self.migrations.setdefault(app_label, []).append(instance)
324                         chop_mode = False
325                     else:
326                         self.generated_operations[app_label] = chopped + self.generated_operations[app_label]
327             new_num_ops = sum(len(x) for x in self.generated_operations.values())
328             if new_num_ops == num_ops:
329                 if not chop_mode:
330                     chop_mode = True
331                 else:
332                     raise ValueError("Cannot resolve operation dependencies: %r" % self.generated_operations)
333             num_ops = new_num_ops
334 
335     def _sort_migrations(self):
336         """
337         Reorder to make things possible. Reordering may be needed so FKs work
338         nicely inside the same app.
339         """
340         for app_label, ops in sorted(self.generated_operations.items()):
341             # construct a dependency graph for intra-app dependencies
342             dependency_graph = {op: set() for op in ops}
343             for op in ops:
344                 for dep in op._auto_deps:
345                     # Resolve intra-app dependencies to handle circular
346                     # references involving a swappable model.
347                     dep = self._resolve_dependency(dep)[0]
348                     if dep[0] == app_label:
349                         for op2 in ops:
350                             if self.check_dependency(op2, dep):
351                                 dependency_graph[op].add(op2)
352 
353             # we use a stable sort for deterministic tests & general behavior
354             self.generated_operations[app_label] = stable_topological_sort(ops, dependency_graph)
355 
356     def _optimize_migrations(self):
357         # Add in internal dependencies among the migrations
358         for app_label, migrations in self.migrations.items():
359             for m1, m2 in zip(migrations, migrations[1:]):
360                 m2.dependencies.append((app_label, m1.name))
361 
362         # De-dupe dependencies
363         for migrations in self.migrations.values():
364             for migration in migrations:
365                 migration.dependencies = list(set(migration.dependencies))
366 
367         # Optimize migrations
368         for app_label, migrations in self.migrations.items():
369             for migration in migrations:
370                 migration.operations = MigrationOptimizer().optimize(migration.operations, app_label)
371 
372     def check_dependency(self, operation, dependency):
373         """
374         Return True if the given operation depends on the given dependency,
375         False otherwise.
376         """
377         # Created model
378         if dependency[2] is None and dependency[3] is True:
379             return (
380                 isinstance(operation, operations.CreateModel) and
381                 operation.name_lower == dependency[1].lower()
382             )
383         # Created field
384         elif dependency[2] is not None and dependency[3] is True:
385             return (
386                 (
387                     isinstance(operation, operations.CreateModel) and
388                     operation.name_lower == dependency[1].lower() and
389                     any(dependency[2] == x for x, y in operation.fields)
390                 ) or
391                 (
392                     isinstance(operation, operations.AddField) and
393                     operation.model_name_lower == dependency[1].lower() and
394                     operation.name_lower == dependency[2].lower()
395                 )
396             )
397         # Removed field
398         elif dependency[2] is not None and dependency[3] is False:
399             return (
400                 isinstance(operation, operations.RemoveField) and
401                 operation.model_name_lower == dependency[1].lower() and
402                 operation.name_lower == dependency[2].lower()
403             )
404         # Removed model
405         elif dependency[2] is None and dependency[3] is False:
406             return (
407                 isinstance(operation, operations.DeleteModel) and
408                 operation.name_lower == dependency[1].lower()
409             )
410         # Field being altered
411         elif dependency[2] is not None and dependency[3] == "alter":
412             return (
413                 isinstance(operation, operations.AlterField) and
414                 operation.model_name_lower == dependency[1].lower() and
415                 operation.name_lower == dependency[2].lower()
416             )
417         # order_with_respect_to being unset for a field
418         elif dependency[2] is not None and dependency[3] == "order_wrt_unset":
419             return (
420                 isinstance(operation, operations.AlterOrderWithRespectTo) and
421                 operation.name_lower == dependency[1].lower() and
422                 (operation.order_with_respect_to or "").lower() != dependency[2].lower()
423             )
424         # Field is removed and part of an index/unique_together
425         elif dependency[2] is not None and dependency[3] == "foo_together_change":
426             return (
427                 isinstance(operation, (operations.AlterUniqueTogether,
428                                        operations.AlterIndexTogether)) and
429                 operation.name_lower == dependency[1].lower()
430             )
431         # Unknown dependency. Raise an error.
432         else:
433             raise ValueError("Can't handle dependency %r" % (dependency,))
434 
435     def add_operation(self, app_label, operation, dependencies=None, beginning=False):
436         # Dependencies are (app_label, model_name, field_name, create/delete as True/False)
437         operation._auto_deps = dependencies or []
438         if beginning:
439             self.generated_operations.setdefault(app_label, []).insert(0, operation)
440         else:
441             self.generated_operations.setdefault(app_label, []).append(operation)
442 
443     def swappable_first_key(self, item):
444         """
445         Place potential swappable models first in lists of created models (only
446         real way to solve #22783).
447         """
448         try:
449             model = self.new_apps.get_model(item[0], item[1])
450             base_names = [base.__name__ for base in model.__bases__]
451             string_version = "%s.%s" % (item[0], item[1])
452             if (
453                 model._meta.swappable or
454                 "AbstractUser" in base_names or
455                 "AbstractBaseUser" in base_names or
456                 settings.AUTH_USER_MODEL.lower() == string_version.lower()
457             ):
458                 return ("___" + item[0], "___" + item[1])
459         except LookupError:
460             pass
461         return item
462 
463     def generate_renamed_models(self):
464         """
465         Find any renamed models, generate the operations for them, and remove
466         the old entry from the model lists. Must be run before other
467         model-level generation.
468         """
469         self.renamed_models = {}
470         self.renamed_models_rel = {}
471         added_models = self.new_model_keys - self.old_model_keys
472         for app_label, model_name in sorted(added_models):
473             model_state = self.to_state.models[app_label, model_name]
474             model_fields_def = self.only_relation_agnostic_fields(model_state.fields)
475 
476             removed_models = self.old_model_keys - self.new_model_keys
477             for rem_app_label, rem_model_name in removed_models:
478                 if rem_app_label == app_label:
479                     rem_model_state = self.from_state.models[rem_app_label, rem_model_name]
480                     rem_model_fields_def = self.only_relation_agnostic_fields(rem_model_state.fields)
481                     if model_fields_def == rem_model_fields_def:
482                         if self.questioner.ask_rename_model(rem_model_state, model_state):
483                             model_opts = self.new_apps.get_model(app_label, model_name)._meta
484                             dependencies = []
485                             for field in model_opts.get_fields():
486                                 if field.is_relation:
487                                     dependencies.extend(self._get_dependencies_for_foreign_key(field))
488                             self.add_operation(
489                                 app_label,
490                                 operations.RenameModel(
491                                     old_name=rem_model_state.name,
492                                     new_name=model_state.name,
493                                 ),
494                                 dependencies=dependencies,
495                             )
496                             self.renamed_models[app_label, model_name] = rem_model_name
497                             renamed_models_rel_key = '%s.%s' % (
498                                 rem_model_state.app_label,
499                                 rem_model_state.name_lower,
500                             )
501                             self.renamed_models_rel[renamed_models_rel_key] = '%s.%s' % (
502                                 model_state.app_label,
503                                 model_state.name_lower,
504                             )
505                             self.old_model_keys.remove((rem_app_label, rem_model_name))
506                             self.old_model_keys.add((app_label, model_name))
507                             break
508 
509     def generate_created_models(self):
510         """
511         Find all new models (both managed and unmanaged) and make create
512         operations for them as well as separate operations to create any
513         foreign key or M2M relationships (these are optimized later, if
514         possible).
515 
516         Defer any model options that refer to collections of fields that might
517         be deferred (e.g. unique_together, index_together).
518         """
519         old_keys = self.old_model_keys | self.old_unmanaged_keys
520         added_models = self.new_model_keys - old_keys
521         added_unmanaged_models = self.new_unmanaged_keys - old_keys
522         all_added_models = chain(
523             sorted(added_models, key=self.swappable_first_key, reverse=True),
524             sorted(added_unmanaged_models, key=self.swappable_first_key, reverse=True)
525         )
526         for app_label, model_name in all_added_models:
527             model_state = self.to_state.models[app_label, model_name]
528             model_opts = self.new_apps.get_model(app_label, model_name)._meta
529             # Gather related fields
530             related_fields = {}
531             primary_key_rel = None
532             for field in model_opts.local_fields:
533                 if field.remote_field:
534                     if field.remote_field.model:
535                         if field.primary_key:
536                             primary_key_rel = field.remote_field.model
537                         elif not field.remote_field.parent_link:
538                             related_fields[field.name] = field
539                     # through will be none on M2Ms on swapped-out models;
540                     # we can treat lack of through as auto_created=True, though.
541                     if (getattr(field.remote_field, "through", None) and
542                             not field.remote_field.through._meta.auto_created):
543                         related_fields[field.name] = field
544             for field in model_opts.local_many_to_many:
545                 if field.remote_field.model:
546                     related_fields[field.name] = field
547                 if getattr(field.remote_field, "through", None) and not field.remote_field.through._meta.auto_created:
548                     related_fields[field.name] = field
549             # Are there indexes/unique|index_together to defer?
550             indexes = model_state.options.pop('indexes')
551             constraints = model_state.options.pop('constraints')
552             unique_together = model_state.options.pop('unique_together', None)
553             index_together = model_state.options.pop('index_together', None)
554             order_with_respect_to = model_state.options.pop('order_with_respect_to', None)
555             # Depend on the deletion of any possible proxy version of us
556             dependencies = [
557                 (app_label, model_name, None, False),
558             ]
559             # Depend on all bases
560             for base in model_state.bases:
561                 if isinstance(base, str) and "." in base:
562                     base_app_label, base_name = base.split(".", 1)
563                     dependencies.append((base_app_label, base_name, None, True))
564                     # Depend on the removal of base fields if the new model has
565                     # a field with the same name.
566                     old_base_model_state = self.from_state.models.get((base_app_label, base_name))
567                     new_base_model_state = self.to_state.models.get((base_app_label, base_name))
568                     if old_base_model_state and new_base_model_state:
569                         removed_base_fields = set(old_base_model_state.fields).difference(
570                             new_base_model_state.fields,
571                         ).intersection(model_state.fields)
572                         for removed_base_field in removed_base_fields:
573                             dependencies.append((base_app_label, base_name, removed_base_field, False))
574             # Depend on the other end of the primary key if it's a relation
575             if primary_key_rel:
576                 dependencies.append((
577                     primary_key_rel._meta.app_label,
578                     primary_key_rel._meta.object_name,
579                     None,
580                     True
581                 ))
582             # Generate creation operation
583             self.add_operation(
584                 app_label,
585                 operations.CreateModel(
586                     name=model_state.name,
587                     fields=[d for d in model_state.fields.items() if d[0] not in related_fields],
588                     options=model_state.options,
589                     bases=model_state.bases,
590                     managers=model_state.managers,
591                 ),
592                 dependencies=dependencies,
593                 beginning=True,
594             )
595 
596             # Don't add operations which modify the database for unmanaged models
597             if not model_opts.managed:
598                 continue
599 
600             # Generate operations for each related field
601             for name, field in sorted(related_fields.items()):
602                 dependencies = self._get_dependencies_for_foreign_key(field)
603                 # Depend on our own model being created
604                 dependencies.append((app_label, model_name, None, True))
605                 # Make operation
606                 self.add_operation(
607                     app_label,
608                     operations.AddField(
609                         model_name=model_name,
610                         name=name,
611                         field=field,
612                     ),
613                     dependencies=list(set(dependencies)),
614                 )
615             # Generate other opns
616             if order_with_respect_to:
617                 self.add_operation(
618                     app_label,
619                     operations.AlterOrderWithRespectTo(
620                         name=model_name,
621                         order_with_respect_to=order_with_respect_to,
622                     ),
623                     dependencies=[
624                         (app_label, model_name, order_with_respect_to, True),
625                         (app_label, model_name, None, True),
626                     ]
627                 )
628             related_dependencies = [
629                 (app_label, model_name, name, True)
630                 for name in sorted(related_fields)
631             ]
632             related_dependencies.append((app_label, model_name, None, True))
633             for index in indexes:
634                 self.add_operation(
635                     app_label,
636                     operations.AddIndex(
637                         model_name=model_name,
638                         index=index,
639                     ),
640                     dependencies=related_dependencies,
641                 )
642             for constraint in constraints:
643                 self.add_operation(
644                     app_label,
645                     operations.AddConstraint(
646                         model_name=model_name,
647                         constraint=constraint,
648                     ),
649                     dependencies=related_dependencies,
650                 )
651             if unique_together:
652                 self.add_operation(
653                     app_label,
654                     operations.AlterUniqueTogether(
655                         name=model_name,
656                         unique_together=unique_together,
657                     ),
658                     dependencies=related_dependencies
659                 )
660             if index_together:
661                 self.add_operation(
662                     app_label,
663                     operations.AlterIndexTogether(
664                         name=model_name,
665                         index_together=index_together,
666                     ),
667                     dependencies=related_dependencies
668                 )
669             # Fix relationships if the model changed from a proxy model to a
670             # concrete model.
671             if (app_label, model_name) in self.old_proxy_keys:
672                 for related_object in model_opts.related_objects:
673                     self.add_operation(
674                         related_object.related_model._meta.app_label,
675                         operations.AlterField(
676                             model_name=related_object.related_model._meta.object_name,
677                             name=related_object.field.name,
678                             field=related_object.field,
679                         ),
680                         dependencies=[(app_label, model_name, None, True)],
681                     )
682 
683     def generate_created_proxies(self):
684         """
685         Make CreateModel statements for proxy models. Use the same statements
686         as that way there's less code duplication, but for proxy models it's
687         safe to skip all the pointless field stuff and chuck out an operation.
688         """
689         added = self.new_proxy_keys - self.old_proxy_keys
690         for app_label, model_name in sorted(added):
691             model_state = self.to_state.models[app_label, model_name]
692             assert model_state.options.get("proxy")
693             # Depend on the deletion of any possible non-proxy version of us
694             dependencies = [
695                 (app_label, model_name, None, False),
696             ]
697             # Depend on all bases
698             for base in model_state.bases:
699                 if isinstance(base, str) and "." in base:
700                     base_app_label, base_name = base.split(".", 1)
701                     dependencies.append((base_app_label, base_name, None, True))
702             # Generate creation operation
703             self.add_operation(
704                 app_label,
705                 operations.CreateModel(
706                     name=model_state.name,
707                     fields=[],
708                     options=model_state.options,
709                     bases=model_state.bases,
710                     managers=model_state.managers,
711                 ),
712                 # Depend on the deletion of any possible non-proxy version of us
713                 dependencies=dependencies,
714             )
715 
716     def generate_deleted_models(self):
717         """
718         Find all deleted models (managed and unmanaged) and make delete
719         operations for them as well as separate operations to delete any
720         foreign key or M2M relationships (these are optimized later, if
721         possible).
722 
723         Also bring forward removal of any model options that refer to
724         collections of fields - the inverse of generate_created_models().
725         """
726         new_keys = self.new_model_keys | self.new_unmanaged_keys
727         deleted_models = self.old_model_keys - new_keys
728         deleted_unmanaged_models = self.old_unmanaged_keys - new_keys
729         all_deleted_models = chain(sorted(deleted_models), sorted(deleted_unmanaged_models))
730         for app_label, model_name in all_deleted_models:
731             model_state = self.from_state.models[app_label, model_name]
732             model = self.old_apps.get_model(app_label, model_name)
733             # Gather related fields
734             related_fields = {}
735             for field in model._meta.local_fields:
736                 if field.remote_field:
737                     if field.remote_field.model:
738                         related_fields[field.name] = field
739                     # through will be none on M2Ms on swapped-out models;
740                     # we can treat lack of through as auto_created=True, though.
741                     if (getattr(field.remote_field, "through", None) and
742                             not field.remote_field.through._meta.auto_created):
743                         related_fields[field.name] = field
744             for field in model._meta.local_many_to_many:
745                 if field.remote_field.model:
746                     related_fields[field.name] = field
747                 if getattr(field.remote_field, "through", None) and not field.remote_field.through._meta.auto_created:
748                     related_fields[field.name] = field
749             # Generate option removal first
750             unique_together = model_state.options.pop('unique_together', None)
751             index_together = model_state.options.pop('index_together', None)
752             if unique_together:
753                 self.add_operation(
754                     app_label,
755                     operations.AlterUniqueTogether(
756                         name=model_name,
757                         unique_together=None,
758                     )
759                 )
760             if index_together:
761                 self.add_operation(
762                     app_label,
763                     operations.AlterIndexTogether(
764                         name=model_name,
765                         index_together=None,
766                     )
767                 )
768             # Then remove each related field
769             for name in sorted(related_fields):
770                 self.add_operation(
771                     app_label,
772                     operations.RemoveField(
773                         model_name=model_name,
774                         name=name,
775                     )
776                 )
777             # Finally, remove the model.
778             # This depends on both the removal/alteration of all incoming fields
779             # and the removal of all its own related fields, and if it's
780             # a through model the field that references it.
781             dependencies = []
782             for related_object in model._meta.related_objects:
783                 related_object_app_label = related_object.related_model._meta.app_label
784                 object_name = related_object.related_model._meta.object_name
785                 field_name = related_object.field.name
786                 dependencies.append((related_object_app_label, object_name, field_name, False))
787                 if not related_object.many_to_many:
788                     dependencies.append((related_object_app_label, object_name, field_name, "alter"))
789 
790             for name in sorted(related_fields):
791                 dependencies.append((app_label, model_name, name, False))
792             # We're referenced in another field's through=
793             through_user = self.through_users.get((app_label, model_state.name_lower))
794             if through_user:
795                 dependencies.append((through_user[0], through_user[1], through_user[2], False))
796             # Finally, make the operation, deduping any dependencies
797             self.add_operation(
798                 app_label,
799                 operations.DeleteModel(
800                     name=model_state.name,
801                 ),
802                 dependencies=list(set(dependencies)),
803             )
804 
805     def generate_deleted_proxies(self):
806         """Make DeleteModel options for proxy models."""
807         deleted = self.old_proxy_keys - self.new_proxy_keys
808         for app_label, model_name in sorted(deleted):
809             model_state = self.from_state.models[app_label, model_name]
810             assert model_state.options.get("proxy")
811             self.add_operation(
812                 app_label,
813                 operations.DeleteModel(
814                     name=model_state.name,
815                 ),
816             )
817 
818     def generate_renamed_fields(self):
819         """Work out renamed fields."""
820         self.renamed_fields = {}
821         for app_label, model_name, field_name in sorted(self.new_field_keys - self.old_field_keys):
822             old_model_name = self.renamed_models.get((app_label, model_name), model_name)
823             old_model_state = self.from_state.models[app_label, old_model_name]
824             field = self.new_apps.get_model(app_label, model_name)._meta.get_field(field_name)
825             # Scan to see if this is actually a rename!
826             field_dec = self.deep_deconstruct(field)
827             for rem_app_label, rem_model_name, rem_field_name in sorted(self.old_field_keys - self.new_field_keys):
828                 if rem_app_label == app_label and rem_model_name == model_name:
829                     old_field = old_model_state.fields[rem_field_name]
830                     old_field_dec = self.deep_deconstruct(old_field)
831                     if field.remote_field and field.remote_field.model and 'to' in old_field_dec[2]:
832                         old_rel_to = old_field_dec[2]['to']
833                         if old_rel_to in self.renamed_models_rel:
834                             old_field_dec[2]['to'] = self.renamed_models_rel[old_rel_to]
835                     old_field.set_attributes_from_name(rem_field_name)
836                     old_db_column = old_field.get_attname_column()[1]
837                     if (old_field_dec == field_dec or (
838                             # Was the field renamed and db_column equal to the
839                             # old field's column added?
840                             old_field_dec[0:2] == field_dec[0:2] and
841                             dict(old_field_dec[2], db_column=old_db_column) == field_dec[2])):
842                         if self.questioner.ask_rename(model_name, rem_field_name, field_name, field):
843                             self.add_operation(
844                                 app_label,
845                                 operations.RenameField(
846                                     model_name=model_name,
847                                     old_name=rem_field_name,
848                                     new_name=field_name,
849                                 )
850                             )
851                             self.old_field_keys.remove((rem_app_label, rem_model_name, rem_field_name))
852                             self.old_field_keys.add((app_label, model_name, field_name))
853                             self.renamed_fields[app_label, model_name, field_name] = rem_field_name
854                             break
855 
856     def generate_added_fields(self):
857         """Make AddField operations."""
858         for app_label, model_name, field_name in sorted(self.new_field_keys - self.old_field_keys):
859             self._generate_added_field(app_label, model_name, field_name)
860 
861     def _generate_added_field(self, app_label, model_name, field_name):
862         field = self.new_apps.get_model(app_label, model_name)._meta.get_field(field_name)
863         # Fields that are foreignkeys/m2ms depend on stuff
864         dependencies = []
865         if field.remote_field and field.remote_field.model:
866             dependencies.extend(self._get_dependencies_for_foreign_key(field))
867         # You can't just add NOT NULL fields with no default or fields
868         # which don't allow empty strings as default.
869         time_fields = (models.DateField, models.DateTimeField, models.TimeField)
870         preserve_default = (
871             field.null or field.has_default() or field.many_to_many or
872             (field.blank and field.empty_strings_allowed) or
873             (isinstance(field, time_fields) and field.auto_now)
874         )
875         if not preserve_default:
876             field = field.clone()
877             if isinstance(field, time_fields) and field.auto_now_add:
878                 field.default = self.questioner.ask_auto_now_add_addition(field_name, model_name)
879             else:
880                 field.default = self.questioner.ask_not_null_addition(field_name, model_name)
881         self.add_operation(
882             app_label,
883             operations.AddField(
884                 model_name=model_name,
885                 name=field_name,
886                 field=field,
887                 preserve_default=preserve_default,
888             ),
889             dependencies=dependencies,
890         )
891 
892     def generate_removed_fields(self):
893         """Make RemoveField operations."""
894         for app_label, model_name, field_name in sorted(self.old_field_keys - self.new_field_keys):
895             self._generate_removed_field(app_label, model_name, field_name)
896 
897     def _generate_removed_field(self, app_label, model_name, field_name):
898         self.add_operation(
899             app_label,
900             operations.RemoveField(
901                 model_name=model_name,
902                 name=field_name,
903             ),
904             # We might need to depend on the removal of an
905             # order_with_respect_to or index/unique_together operation;
906             # this is safely ignored if there isn't one
907             dependencies=[
908                 (app_label, model_name, field_name, "order_wrt_unset"),
909                 (app_label, model_name, field_name, "foo_together_change"),
910             ],
911         )
912 
913     def generate_altered_fields(self):
914         """
915         Make AlterField operations, or possibly RemovedField/AddField if alter
916         isn's possible.
917         """
918         for app_label, model_name, field_name in sorted(self.old_field_keys & self.new_field_keys):
919             # Did the field change?
920             old_model_name = self.renamed_models.get((app_label, model_name), model_name)
921             old_field_name = self.renamed_fields.get((app_label, model_name, field_name), field_name)
922             old_field = self.old_apps.get_model(app_label, old_model_name)._meta.get_field(old_field_name)
923             new_field = self.new_apps.get_model(app_label, model_name)._meta.get_field(field_name)
924             dependencies = []
925             # Implement any model renames on relations; these are handled by RenameModel
926             # so we need to exclude them from the comparison
927             if hasattr(new_field, "remote_field") and getattr(new_field.remote_field, "model", None):
928                 rename_key = (
929                     new_field.remote_field.model._meta.app_label,
930                     new_field.remote_field.model._meta.model_name,
931                 )
932                 if rename_key in self.renamed_models:
933                     new_field.remote_field.model = old_field.remote_field.model
934                 # Handle ForeignKey which can only have a single to_field.
935                 remote_field_name = getattr(new_field.remote_field, 'field_name', None)
936                 if remote_field_name:
937                     to_field_rename_key = rename_key + (remote_field_name,)
938                     if to_field_rename_key in self.renamed_fields:
939                         # Repoint both model and field name because to_field
940                         # inclusion in ForeignKey.deconstruct() is based on
941                         # both.
942                         new_field.remote_field.model = old_field.remote_field.model
943                         new_field.remote_field.field_name = old_field.remote_field.field_name
944                 # Handle ForeignObjects which can have multiple from_fields/to_fields.
945                 from_fields = getattr(new_field, 'from_fields', None)
946                 if from_fields:
947                     from_rename_key = (app_label, model_name)
948                     new_field.from_fields = tuple([
949                         self.renamed_fields.get(from_rename_key + (from_field,), from_field)
950                         for from_field in from_fields
951                     ])
952                     new_field.to_fields = tuple([
953                         self.renamed_fields.get(rename_key + (to_field,), to_field)
954                         for to_field in new_field.to_fields
955                     ])
956                 dependencies.extend(self._get_dependencies_for_foreign_key(new_field))
957             if hasattr(new_field, "remote_field") and getattr(new_field.remote_field, "through", None):
958                 rename_key = (
959                     new_field.remote_field.through._meta.app_label,
960                     new_field.remote_field.through._meta.model_name,
961                 )
962                 if rename_key in self.renamed_models:
963                     new_field.remote_field.through = old_field.remote_field.through
964             old_field_dec = self.deep_deconstruct(old_field)
965             new_field_dec = self.deep_deconstruct(new_field)
966             if old_field_dec != new_field_dec:
967                 both_m2m = old_field.many_to_many and new_field.many_to_many
968                 neither_m2m = not old_field.many_to_many and not new_field.many_to_many
969                 if both_m2m or neither_m2m:
970                     # Either both fields are m2m or neither is
971                     preserve_default = True
972                     if (old_field.null and not new_field.null and not new_field.has_default() and
973                             not new_field.many_to_many):
974                         field = new_field.clone()
975                         new_default = self.questioner.ask_not_null_alteration(field_name, model_name)
976                         if new_default is not models.NOT_PROVIDED:
977                             field.default = new_default
978                             preserve_default = False
979                     else:
980                         field = new_field
981                     self.add_operation(
982                         app_label,
983                         operations.AlterField(
984                             model_name=model_name,
985                             name=field_name,
986                             field=field,
987                             preserve_default=preserve_default,
988                         ),
989                         dependencies=dependencies,
990                     )
991                 else:
992                     # We cannot alter between m2m and concrete fields
993                     self._generate_removed_field(app_label, model_name, field_name)
994                     self._generate_added_field(app_label, model_name, field_name)
995 
996     def create_altered_indexes(self):
997         option_name = operations.AddIndex.option_name
998         for app_label, model_name in sorted(self.kept_model_keys):
999             old_model_name = self.renamed_models.get((app_label, model_name), model_name)
1000             old_model_state = self.from_state.models[app_label, old_model_name]
1001             new_model_state = self.to_state.models[app_label, model_name]
1002 
1003             old_indexes = old_model_state.options[option_name]
1004             new_indexes = new_model_state.options[option_name]
1005             add_idx = [idx for idx in new_indexes if idx not in old_indexes]
1006             rem_idx = [idx for idx in old_indexes if idx not in new_indexes]
1007 
1008             self.altered_indexes.update({
1009                 (app_label, model_name): {
1010                     'added_indexes': add_idx, 'removed_indexes': rem_idx,
1011                 }
1012             })
1013 
1014     def generate_added_indexes(self):
1015         for (app_label, model_name), alt_indexes in self.altered_indexes.items():
1016             for index in alt_indexes['added_indexes']:
1017                 self.add_operation(
1018                     app_label,
1019                     operations.AddIndex(
1020                         model_name=model_name,
1021                         index=index,
1022                     )
1023                 )
1024 
1025     def generate_removed_indexes(self):
1026         for (app_label, model_name), alt_indexes in self.altered_indexes.items():
1027             for index in alt_indexes['removed_indexes']:
1028                 self.add_operation(
1029                     app_label,
1030                     operations.RemoveIndex(
1031                         model_name=model_name,
1032                         name=index.name,
1033                     )
1034                 )
1035 
1036     def create_altered_constraints(self):
1037         option_name = operations.AddConstraint.option_name
1038         for app_label, model_name in sorted(self.kept_model_keys):
1039             old_model_name = self.renamed_models.get((app_label, model_name), model_name)
1040             old_model_state = self.from_state.models[app_label, old_model_name]
1041             new_model_state = self.to_state.models[app_label, model_name]
1042 
1043             old_constraints = old_model_state.options[option_name]
1044             new_constraints = new_model_state.options[option_name]
1045             add_constraints = [c for c in new_constraints if c not in old_constraints]
1046             rem_constraints = [c for c in old_constraints if c not in new_constraints]
1047 
1048             self.altered_constraints.update({
1049                 (app_label, model_name): {
1050                     'added_constraints': add_constraints, 'removed_constraints': rem_constraints,
1051                 }
1052             })
1053 
1054     def generate_added_constraints(self):
1055         for (app_label, model_name), alt_constraints in self.altered_constraints.items():
1056             for constraint in alt_constraints['added_constraints']:
1057                 self.add_operation(
1058                     app_label,
1059                     operations.AddConstraint(
1060                         model_name=model_name,
1061                         constraint=constraint,
1062                     )
1063                 )
1064 
1065     def generate_removed_constraints(self):
1066         for (app_label, model_name), alt_constraints in self.altered_constraints.items():
1067             for constraint in alt_constraints['removed_constraints']:
1068                 self.add_operation(
1069                     app_label,
1070                     operations.RemoveConstraint(
1071                         model_name=model_name,
1072                         name=constraint.name,
1073                     )
1074                 )
1075 
1076     def _get_dependencies_for_foreign_key(self, field):
1077         # Account for FKs to swappable models
1078         swappable_setting = getattr(field, 'swappable_setting', None)
1079         if swappable_setting is not None:
1080             dep_app_label = "__setting__"
1081             dep_object_name = swappable_setting
1082         else:
1083             dep_app_label = field.remote_field.model._meta.app_label
1084             dep_object_name = field.remote_field.model._meta.object_name
1085         dependencies = [(dep_app_label, dep_object_name, None, True)]
1086         if getattr(field.remote_field, "through", None) and not field.remote_field.through._meta.auto_created:
1087             dependencies.append((
1088                 field.remote_field.through._meta.app_label,
1089                 field.remote_field.through._meta.object_name,
1090                 None,
1091                 True,
1092             ))
1093         return dependencies
1094 
1095     def _generate_altered_foo_together(self, operation):
1096         option_name = operation.option_name
1097         for app_label, model_name in sorted(self.kept_model_keys):
1098             old_model_name = self.renamed_models.get((app_label, model_name), model_name)
1099             old_model_state = self.from_state.models[app_label, old_model_name]
1100             new_model_state = self.to_state.models[app_label, model_name]
1101 
1102             # We run the old version through the field renames to account for those
1103             old_value = old_model_state.options.get(option_name)
1104             old_value = {
1105                 tuple(
1106                     self.renamed_fields.get((app_label, model_name, n), n)
1107                     for n in unique
1108                 )
1109                 for unique in old_value
1110             } if old_value else set()
1111 
1112             new_value = new_model_state.options.get(option_name)
1113             new_value = set(new_value) if new_value else set()
1114 
1115             if old_value != new_value:
1116                 dependencies = []
1117                 for foo_togethers in new_value:
1118                     for field_name in foo_togethers:
1119                         field = self.new_apps.get_model(app_label, model_name)._meta.get_field(field_name)
1120                         if field.remote_field and field.remote_field.model:
1121                             dependencies.extend(self._get_dependencies_for_foreign_key(field))
1122 
1123                 self.add_operation(
1124                     app_label,
1125                     operation(
1126                         name=model_name,
1127                         **{option_name: new_value}
1128                     ),
1129                     dependencies=dependencies,
1130                 )
1131 
1132     def generate_altered_unique_together(self):
1133         self._generate_altered_foo_together(operations.AlterUniqueTogether)
1134 
1135     def generate_altered_index_together(self):
1136         self._generate_altered_foo_together(operations.AlterIndexTogether)
1137 
1138     def generate_altered_db_table(self):
1139         models_to_check = self.kept_model_keys.union(self.kept_proxy_keys, self.kept_unmanaged_keys)
1140         for app_label, model_name in sorted(models_to_check):
1141             old_model_name = self.renamed_models.get((app_label, model_name), model_name)
1142             old_model_state = self.from_state.models[app_label, old_model_name]
1143             new_model_state = self.to_state.models[app_label, model_name]
1144             old_db_table_name = old_model_state.options.get('db_table')
1145             new_db_table_name = new_model_state.options.get('db_table')
1146             if old_db_table_name != new_db_table_name:
1147                 self.add_operation(
1148                     app_label,
1149                     operations.AlterModelTable(
1150                         name=model_name,
1151                         table=new_db_table_name,
1152                     )
1153                 )
1154 
1155     def generate_altered_options(self):
1156         """
1157         Work out if any non-schema-affecting options have changed and make an
1158         operation to represent them in state changes (in case Python code in
1159         migrations needs them).
1160         """
1161         models_to_check = self.kept_model_keys.union(
1162             self.kept_proxy_keys,
1163             self.kept_unmanaged_keys,
1164             # unmanaged converted to managed
1165             self.old_unmanaged_keys & self.new_model_keys,
1166             # managed converted to unmanaged
1167             self.old_model_keys & self.new_unmanaged_keys,
1168         )
1169 
1170         for app_label, model_name in sorted(models_to_check):
1171             old_model_name = self.renamed_models.get((app_label, model_name), model_name)
1172             old_model_state = self.from_state.models[app_label, old_model_name]
1173             new_model_state = self.to_state.models[app_label, model_name]
1174             old_options = {
1175                 key: value for key, value in old_model_state.options.items()
1176                 if key in AlterModelOptions.ALTER_OPTION_KEYS
1177             }
1178             new_options = {
1179                 key: value for key, value in new_model_state.options.items()
1180                 if key in AlterModelOptions.ALTER_OPTION_KEYS
1181             }
1182             if old_options != new_options:
1183                 self.add_operation(
1184                     app_label,
1185                     operations.AlterModelOptions(
1186                         name=model_name,
1187                         options=new_options,
1188                     )
1189                 )
1190 
1191     def generate_altered_order_with_respect_to(self):
1192         for app_label, model_name in sorted(self.kept_model_keys):
1193             old_model_name = self.renamed_models.get((app_label, model_name), model_name)
1194             old_model_state = self.from_state.models[app_label, old_model_name]
1195             new_model_state = self.to_state.models[app_label, model_name]
1196             if (old_model_state.options.get("order_with_respect_to") !=
1197                     new_model_state.options.get("order_with_respect_to")):
1198                 # Make sure it comes second if we're adding
1199                 # (removal dependency is part of RemoveField)
1200                 dependencies = []
1201                 if new_model_state.options.get("order_with_respect_to"):
1202                     dependencies.append((
1203                         app_label,
1204                         model_name,
1205                         new_model_state.options["order_with_respect_to"],
1206                         True,
1207                     ))
1208                 # Actually generate the operation
1209                 self.add_operation(
1210                     app_label,
1211                     operations.AlterOrderWithRespectTo(
1212                         name=model_name,
1213                         order_with_respect_to=new_model_state.options.get('order_with_respect_to'),
1214                     ),
1215                     dependencies=dependencies,
1216                 )
1217 
1218     def generate_altered_managers(self):
1219         for app_label, model_name in sorted(self.kept_model_keys):
1220             old_model_name = self.renamed_models.get((app_label, model_name), model_name)
1221             old_model_state = self.from_state.models[app_label, old_model_name]
1222             new_model_state = self.to_state.models[app_label, model_name]
1223             if old_model_state.managers != new_model_state.managers:
1224                 self.add_operation(
1225                     app_label,
1226                     operations.AlterModelManagers(
1227                         name=model_name,
1228                         managers=new_model_state.managers,
1229                     )
1230                 )
1231 
1232     def arrange_for_graph(self, changes, graph, migration_name=None):
1233         """
1234         Take a result from changes() and a MigrationGraph, and fix the names
1235         and dependencies of the changes so they extend the graph from the leaf
1236         nodes for each app.
1237         """
1238         leaves = graph.leaf_nodes()
1239         name_map = {}
1240         for app_label, migrations in list(changes.items()):
1241             if not migrations:
1242                 continue
1243             # Find the app label's current leaf node
1244             app_leaf = None
1245             for leaf in leaves:
1246                 if leaf[0] == app_label:
1247                     app_leaf = leaf
1248                     break
1249             # Do they want an initial migration for this app?
1250             if app_leaf is None and not self.questioner.ask_initial(app_label):
1251                 # They don't.
1252                 for migration in migrations:
1253                     name_map[(app_label, migration.name)] = (app_label, "__first__")
1254                 del changes[app_label]
1255                 continue
1256             # Work out the next number in the sequence
1257             if app_leaf is None:
1258                 next_number = 1
1259             else:
1260                 next_number = (self.parse_number(app_leaf[1]) or 0) + 1
1261             # Name each migration
1262             for i, migration in enumerate(migrations):
1263                 if i == 0 and app_leaf:
1264                     migration.dependencies.append(app_leaf)
1265                 new_name_parts = ['%04i' % next_number]
1266                 if migration_name:
1267                     new_name_parts.append(migration_name)
1268                 elif i == 0 and not app_leaf:
1269                     new_name_parts.append('initial')
1270                 else:
1271                     new_name_parts.append(migration.suggest_name()[:100])
1272                 new_name = '_'.join(new_name_parts)
1273                 name_map[(app_label, migration.name)] = (app_label, new_name)
1274                 next_number += 1
1275                 migration.name = new_name
1276         # Now fix dependencies
1277         for migrations in changes.values():
1278             for migration in migrations:
1279                 migration.dependencies = [name_map.get(d, d) for d in migration.dependencies]
1280         return changes
1281 
1282     def _trim_to_apps(self, changes, app_labels):
1283         """
1284         Take changes from arrange_for_graph() and set of app labels, and return
1285         a modified set of changes which trims out as many migrations that are
1286         not in app_labels as possible. Note that some other migrations may
1287         still be present as they may be required dependencies.
1288         """
1289         # Gather other app dependencies in a first pass
1290         app_dependencies = {}
1291         for app_label, migrations in changes.items():
1292             for migration in migrations:
1293                 for dep_app_label, name in migration.dependencies:
1294                     app_dependencies.setdefault(app_label, set()).add(dep_app_label)
1295         required_apps = set(app_labels)
1296         # Keep resolving till there's no change
1297         old_required_apps = None
1298         while old_required_apps != required_apps:
1299             old_required_apps = set(required_apps)
1300             required_apps.update(*[app_dependencies.get(app_label, ()) for app_label in required_apps])
1301         # Remove all migrations that aren't needed
1302         for app_label in list(changes):
1303             if app_label not in required_apps:
1304                 del changes[app_label]
1305         return changes
1306 
1307     @classmethod
1308     def parse_number(cls, name):
1309         """
1310         Given a migration name, try to extract a number from the beginning of
1311         it. If no number is found, return None.
1312         """
1313         match = re.match(r'^\d+', name)
1314         if match:
1315             return int(match[0])
1316         return None

</code><intended_behavior>Enhance the logic to correctly handle models with the same name across different apps especially when they reference each other through `ManyToManyField`. This includes ensuring that the `related_name` attribute does not cause conflicts during migration generation, even when set to `'+'`, which is supposed to prevent the reverse relation.</intended_behavior>, <file>django/db/models/fields/related.py</file>
<class>None</class>
<method>None</method>
<code>
1 import functools
2 import inspect
3 from functools import partial
4 
5 from django import forms
6 from django.apps import apps
7 from django.conf import SettingsReference, settings
8 from django.core import checks, exceptions
9 from django.db import connection, router
10 from django.db.backends import utils
11 from django.db.models import Q
12 from django.db.models.constants import LOOKUP_SEP
13 from django.db.models.deletion import CASCADE, SET_DEFAULT, SET_NULL
14 from django.db.models.query_utils import PathInfo
15 from django.db.models.utils import make_model_tuple
16 from django.utils.functional import cached_property
17 from django.utils.translation import gettext_lazy as _
18 
19 from . import Field
20 from .mixins import FieldCacheMixin
21 from .related_descriptors import (
22     ForeignKeyDeferredAttribute, ForwardManyToOneDescriptor,
23     ForwardOneToOneDescriptor, ManyToManyDescriptor,
24     ReverseManyToOneDescriptor, ReverseOneToOneDescriptor,
25 )
26 from .related_lookups import (
27     RelatedExact, RelatedGreaterThan, RelatedGreaterThanOrEqual, RelatedIn,
28     RelatedIsNull, RelatedLessThan, RelatedLessThanOrEqual,
29 )
30 from .reverse_related import (
31     ForeignObjectRel, ManyToManyRel, ManyToOneRel, OneToOneRel,
32 )
33 
34 RECURSIVE_RELATIONSHIP_CONSTANT = 'self'
35 
36 
37 def resolve_relation(scope_model, relation):
38     """
39     Transform relation into a model or fully-qualified model string of the form
40     "app_label.ModelName", relative to scope_model.
41 
42     The relation argument can be:
43       * RECURSIVE_RELATIONSHIP_CONSTANT, i.e. the string "self", in which case
44         the model argument will be returned.
45       * A bare model name without an app_label, in which case scope_model's
46         app_label will be prepended.
47       * An "app_label.ModelName" string.
48       * A model class, which will be returned unchanged.
49     """
50     # Check for recursive relations
51     if relation == RECURSIVE_RELATIONSHIP_CONSTANT:
52         relation = scope_model
53 
54     # Look for an "app.Model" relation
55     if isinstance(relation, str):
56         if "." not in relation:
57             relation = "%s.%s" % (scope_model._meta.app_label, relation)
58 
59     return relation
60 
61 
62 def lazy_related_operation(function, model, *related_models, **kwargs):
63     """
64     Schedule `function` to be called once `model` and all `related_models`
65     have been imported and registered with the app registry. `function` will
66     be called with the newly-loaded model classes as its positional arguments,
67     plus any optional keyword arguments.
68 
69     The `model` argument must be a model class. Each subsequent positional
70     argument is another model, or a reference to another model - see
71     `resolve_relation()` for the various forms these may take. Any relative
72     references will be resolved relative to `model`.
73 
74     This is a convenience wrapper for `Apps.lazy_model_operation` - the app
75     registry model used is the one found in `model._meta.apps`.
76     """
77     models = [model] + [resolve_relation(model, rel) for rel in related_models]
78     model_keys = (make_model_tuple(m) for m in models)
79     apps = model._meta.apps
80     return apps.lazy_model_operation(partial(function, **kwargs), *model_keys)
81 
82 
83 class RelatedField(FieldCacheMixin, Field):
84     """Base class that all relational fields inherit from."""
85 
86     # Field flags
87     one_to_many = False
88     one_to_one = False
89     many_to_many = False
90     many_to_one = False
91 
92     @cached_property
93     def related_model(self):
94         # Can't cache this property until all the models are loaded.
95         apps.check_models_ready()
96         return self.remote_field.model
97 
98     def check(self, **kwargs):
99         return [
100             *super().check(**kwargs),
101             *self._check_related_name_is_valid(),
102             *self._check_related_query_name_is_valid(),
103             *self._check_relation_model_exists(),
104             *self._check_referencing_to_swapped_model(),
105             *self._check_clashes(),
106         ]
107 
108     def _check_related_name_is_valid(self):
109         import keyword
110         related_name = self.remote_field.related_name
111         if related_name is None:
112             return []
113         is_valid_id = not keyword.iskeyword(related_name) and related_name.isidentifier()
114         if not (is_valid_id or related_name.endswith('+')):
115             return [
116                 checks.Error(
117                     "The name '%s' is invalid related_name for field %s.%s" %
118                     (self.remote_field.related_name, self.model._meta.object_name,
119                      self.name),
120                     hint="Related name must be a valid Python identifier or end with a '+'",
121                     obj=self,
122                     id='fields.E306',
123                 )
124             ]
125         return []
126 
127     def _check_related_query_name_is_valid(self):
128         if self.remote_field.is_hidden():
129             return []
130         rel_query_name = self.related_query_name()
131         errors = []
132         if rel_query_name.endswith('_'):
133             errors.append(
134                 checks.Error(
135                     "Reverse query name '%s' must not end with an underscore."
136                     % rel_query_name,
137                     hint=("Add or change a related_name or related_query_name "
138                           "argument for this field."),
139                     obj=self,
140                     id='fields.E308',
141                 )
142             )
143         if LOOKUP_SEP in rel_query_name:
144             errors.append(
145                 checks.Error(
146                     "Reverse query name '%s' must not contain '%s'."
147                     % (rel_query_name, LOOKUP_SEP),
148                     hint=("Add or change a related_name or related_query_name "
149                           "argument for this field."),
150                     obj=self,
151                     id='fields.E309',
152                 )
153             )
154         return errors
155 
156     def _check_relation_model_exists(self):
157         rel_is_missing = self.remote_field.model not in self.opts.apps.get_models()
158         rel_is_string = isinstance(self.remote_field.model, str)
159         model_name = self.remote_field.model if rel_is_string else self.remote_field.model._meta.object_name
160         if rel_is_missing and (rel_is_string or not self.remote_field.model._meta.swapped):
161             return [
162                 checks.Error(
163                     "Field defines a relation with model '%s', which is either "
164                     "not installed, or is abstract." % model_name,
165                     obj=self,
166                     id='fields.E300',
167                 )
168             ]
169         return []
170 
171     def _check_referencing_to_swapped_model(self):
172         if (self.remote_field.model not in self.opts.apps.get_models() and
173                 not isinstance(self.remote_field.model, str) and
174                 self.remote_field.model._meta.swapped):
175             return [
176                 checks.Error(
177                     "Field defines a relation with the model '%s', which has "
178                     "been swapped out." % self.remote_field.model._meta.label,
179                     hint="Update the relation to point at 'settings.%s'." % self.remote_field.model._meta.swappable,
180                     obj=self,
181                     id='fields.E301',
182                 )
183             ]
184         return []
185 
186     def _check_clashes(self):
187         """Check accessor and reverse query name clashes."""
188         from django.db.models.base import ModelBase
189 
190         errors = []
191         opts = self.model._meta
192 
193         # `f.remote_field.model` may be a string instead of a model. Skip if model name is
194         # not resolved.
195         if not isinstance(self.remote_field.model, ModelBase):
196             return []
197 
198         # Consider that we are checking field `Model.foreign` and the models
199         # are:
200         #
201         #     class Target(models.Model):
202         #         model = models.IntegerField()
203         #         model_set = models.IntegerField()
204         #
205         #     class Model(models.Model):
206         #         foreign = models.ForeignKey(Target)
207         #         m2m = models.ManyToManyField(Target)
208 
209         # rel_opts.object_name == "Target"
210         rel_opts = self.remote_field.model._meta
211         # If the field doesn't install a backward relation on the target model
212         # (so `is_hidden` returns True), then there are no clashes to check
213         # and we can skip these fields.
214         rel_is_hidden = self.remote_field.is_hidden()
215         rel_name = self.remote_field.get_accessor_name()  # i. e. "model_set"
216         rel_query_name = self.related_query_name()  # i. e. "model"
217         # i.e. "app_label.Model.field".
218         field_name = '%s.%s' % (opts.label, self.name)
219 
220         # Check clashes between accessor or reverse query name of `field`
221         # and any other field name -- i.e. accessor for Model.foreign is
222         # model_set and it clashes with Target.model_set.
223         potential_clashes = rel_opts.fields + rel_opts.many_to_many
224         for clash_field in potential_clashes:
225             # i.e. "app_label.Target.model_set".
226             clash_name = '%s.%s' % (rel_opts.label, clash_field.name)
227             if not rel_is_hidden and clash_field.name == rel_name:
228                 errors.append(
229                     checks.Error(
230                         "Reverse accessor for '%s' clashes with field name '%s'." % (field_name, clash_name),
231                         hint=("Rename field '%s', or add/change a related_name "
232                               "argument to the definition for field '%s'.") % (clash_name, field_name),
233                         obj=self,
234                         id='fields.E302',
235                     )
236                 )
237 
238             if clash_field.name == rel_query_name:
239                 errors.append(
240                     checks.Error(
241                         "Reverse query name for '%s' clashes with field name '%s'." % (field_name, clash_name),
242                         hint=("Rename field '%s', or add/change a related_name "
243                               "argument to the definition for field '%s'.") % (clash_name, field_name),
244                         obj=self,
245                         id='fields.E303',
246                     )
247                 )
248 
249         # Check clashes between accessors/reverse query names of `field` and
250         # any other field accessor -- i. e. Model.foreign accessor clashes with
251         # Model.m2m accessor.
252         potential_clashes = (r for r in rel_opts.related_objects if r.field is not self)
253         for clash_field in potential_clashes:
254             # i.e. "app_label.Model.m2m".
255             clash_name = '%s.%s' % (
256                 clash_field.related_model._meta.label,
257                 clash_field.field.name,
258             )
259             if not rel_is_hidden and clash_field.get_accessor_name() == rel_name:
260                 errors.append(
261                     checks.Error(
262                         "Reverse accessor for '%s' clashes with reverse accessor for '%s'." % (field_name, clash_name),
263                         hint=("Add or change a related_name argument "
264                               "to the definition for '%s' or '%s'.") % (field_name, clash_name),
265                         obj=self,
266                         id='fields.E304',
267                     )
268                 )
269 
270             if clash_field.get_accessor_name() == rel_query_name:
271                 errors.append(
272                     checks.Error(
273                         "Reverse query name for '%s' clashes with reverse query name for '%s'."
274                         % (field_name, clash_name),
275                         hint=("Add or change a related_name argument "
276                               "to the definition for '%s' or '%s'.") % (field_name, clash_name),
277                         obj=self,
278                         id='fields.E305',
279                     )
280                 )
281 
282         return errors
283 
284     def db_type(self, connection):
285         # By default related field will not have a column as it relates to
286         # columns from another table.
287         return None
288 
289     def contribute_to_class(self, cls, name, private_only=False, **kwargs):
290 
291         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)
292 
293         self.opts = cls._meta
294 
295         if not cls._meta.abstract:
296             if self.remote_field.related_name:
297                 related_name = self.remote_field.related_name
298             else:
299                 related_name = self.opts.default_related_name
300             if related_name:
301                 related_name = related_name % {
302                     'class': cls.__name__.lower(),
303                     'model_name': cls._meta.model_name.lower(),
304                     'app_label': cls._meta.app_label.lower()
305                 }
306                 self.remote_field.related_name = related_name
307 
308             if self.remote_field.related_query_name:
309                 related_query_name = self.remote_field.related_query_name % {
310                     'class': cls.__name__.lower(),
311                     'app_label': cls._meta.app_label.lower(),
312                 }
313                 self.remote_field.related_query_name = related_query_name
314 
315             def resolve_related_class(model, related, field):
316                 field.remote_field.model = related
317                 field.do_related_class(related, model)
318             lazy_related_operation(resolve_related_class, cls, self.remote_field.model, field=self)
319 
320     def deconstruct(self):
321         name, path, args, kwargs = super().deconstruct()
322         if self.remote_field.limit_choices_to:
323             kwargs['limit_choices_to'] = self.remote_field.limit_choices_to
324         if self.remote_field.related_name is not None:
325             kwargs['related_name'] = self.remote_field.related_name
326         if self.remote_field.related_query_name is not None:
327             kwargs['related_query_name'] = self.remote_field.related_query_name
328         return name, path, args, kwargs
329 
330     def get_forward_related_filter(self, obj):
331         """
332         Return the keyword arguments that when supplied to
333         self.model.object.filter(), would select all instances related through
334         this field to the remote obj. This is used to build the querysets
335         returned by related descriptors. obj is an instance of
336         self.related_field.model.
337         """
338         return {
339             '%s__%s' % (self.name, rh_field.name): getattr(obj, rh_field.attname)
340             for _, rh_field in self.related_fields
341         }
342 
343     def get_reverse_related_filter(self, obj):
344         """
345         Complement to get_forward_related_filter(). Return the keyword
346         arguments that when passed to self.related_field.model.object.filter()
347         select all instances of self.related_field.model related through
348         this field to obj. obj is an instance of self.model.
349         """
350         base_filter = {
351             rh_field.attname: getattr(obj, lh_field.attname)
352             for lh_field, rh_field in self.related_fields
353         }
354         descriptor_filter = self.get_extra_descriptor_filter(obj)
355         base_q = Q(**base_filter)
356         if isinstance(descriptor_filter, dict):
357             return base_q & Q(**descriptor_filter)
358         elif descriptor_filter:
359             return base_q & descriptor_filter
360         return base_q
361 
362     @property
363     def swappable_setting(self):
364         """
365         Get the setting that this is powered from for swapping, or None
366         if it's not swapped in / marked with swappable=False.
367         """
368         if self.swappable:
369             # Work out string form of "to"
370             if isinstance(self.remote_field.model, str):
371                 to_string = self.remote_field.model
372             else:
373                 to_string = self.remote_field.model._meta.label
374             return apps.get_swappable_settings_name(to_string)
375         return None
376 
377     def set_attributes_from_rel(self):
378         self.name = (
379             self.name or
380             (self.remote_field.model._meta.model_name + '_' + self.remote_field.model._meta.pk.name)
381         )
382         if self.verbose_name is None:
383             self.verbose_name = self.remote_field.model._meta.verbose_name
384         self.remote_field.set_field_name()
385 
386     def do_related_class(self, other, cls):
387         self.set_attributes_from_rel()
388         self.contribute_to_related_class(other, self.remote_field)
389 
390     def get_limit_choices_to(self):
391         """
392         Return ``limit_choices_to`` for this model field.
393 
394         If it is a callable, it will be invoked and the result will be
395         returned.
396         """
397         if callable(self.remote_field.limit_choices_to):
398             return self.remote_field.limit_choices_to()
399         return self.remote_field.limit_choices_to
400 
401     def formfield(self, **kwargs):
402         """
403         Pass ``limit_choices_to`` to the field being constructed.
404 
405         Only passes it if there is a type that supports related fields.
406         This is a similar strategy used to pass the ``queryset`` to the field
407         being constructed.
408         """
409         defaults = {}
410         if hasattr(self.remote_field, 'get_related_field'):
411             # If this is a callable, do not invoke it here. Just pass
412             # it in the defaults for when the form class will later be
413             # instantiated.
414             limit_choices_to = self.remote_field.limit_choices_to
415             defaults.update({
416                 'limit_choices_to': limit_choices_to,
417             })
418         defaults.update(kwargs)
419         return super().formfield(**defaults)
420 
421     def related_query_name(self):
422         """
423         Define the name that can be used to identify this related object in a
424         table-spanning query.
425         """
426         return self.remote_field.related_query_name or self.remote_field.related_name or self.opts.model_name
427 
428     @property
429     def target_field(self):
430         """
431         When filtering against this relation, return the field on the remote
432         model against which the filtering should happen.
433         """
434         target_fields = self.get_path_info()[-1].target_fields
435         if len(target_fields) > 1:
436             raise exceptions.FieldError(
437                 "The relation has multiple target fields, but only single target field was asked for")
438         return target_fields[0]
439 
440     def get_cache_name(self):
441         return self.name
442 
443 
444 class ForeignObject(RelatedField):
445     """
446     Abstraction of the ForeignKey relation to support multi-column relations.
447     """
448 
449     # Field flags
450     many_to_many = False
451     many_to_one = True
452     one_to_many = False
453     one_to_one = False
454 
455     requires_unique_target = True
456     related_accessor_class = ReverseManyToOneDescriptor
457     forward_related_accessor_class = ForwardManyToOneDescriptor
458     rel_class = ForeignObjectRel
459 
460     def __init__(self, to, on_delete, from_fields, to_fields, rel=None, related_name=None,
461                  related_query_name=None, limit_choices_to=None, parent_link=False,
462                  swappable=True, **kwargs):
463 
464         if rel is None:
465             rel = self.rel_class(
466                 self, to,
467                 related_name=related_name,
468                 related_query_name=related_query_name,
469                 limit_choices_to=limit_choices_to,
470                 parent_link=parent_link,
471                 on_delete=on_delete,
472             )
473 
474         super().__init__(rel=rel, **kwargs)
475 
476         self.from_fields = from_fields
477         self.to_fields = to_fields
478         self.swappable = swappable
479 
480     def check(self, **kwargs):
481         return [
482             *super().check(**kwargs),
483             *self._check_to_fields_exist(),
484             *self._check_unique_target(),
485         ]
486 
487     def _check_to_fields_exist(self):
488         # Skip nonexistent models.
489         if isinstance(self.remote_field.model, str):
490             return []
491 
492         errors = []
493         for to_field in self.to_fields:
494             if to_field:
495                 try:
496                     self.remote_field.model._meta.get_field(to_field)
497                 except exceptions.FieldDoesNotExist:
498                     errors.append(
499                         checks.Error(
500                             "The to_field '%s' doesn't exist on the related "
501                             "model '%s'."
502                             % (to_field, self.remote_field.model._meta.label),
503                             obj=self,
504                             id='fields.E312',
505                         )
506                     )
507         return errors
508 
509     def _check_unique_target(self):
510         rel_is_string = isinstance(self.remote_field.model, str)
511         if rel_is_string or not self.requires_unique_target:
512             return []
513 
514         try:
515             self.foreign_related_fields
516         except exceptions.FieldDoesNotExist:
517             return []
518 
519         if not self.foreign_related_fields:
520             return []
521 
522         unique_foreign_fields = {
523             frozenset([f.name])
524             for f in self.remote_field.model._meta.get_fields()
525             if getattr(f, 'unique', False)
526         }
527         unique_foreign_fields.update({
528             frozenset(ut)
529             for ut in self.remote_field.model._meta.unique_together
530         })
531         unique_foreign_fields.update({
532             frozenset(uc.fields)
533             for uc in self.remote_field.model._meta.total_unique_constraints
534         })
535         foreign_fields = {f.name for f in self.foreign_related_fields}
536         has_unique_constraint = any(u <= foreign_fields for u in unique_foreign_fields)
537 
538         if not has_unique_constraint and len(self.foreign_related_fields) > 1:
539             field_combination = ', '.join(
540                 "'%s'" % rel_field.name for rel_field in self.foreign_related_fields
541             )
542             model_name = self.remote_field.model.__name__
543             return [
544                 checks.Error(
545                     "No subset of the fields %s on model '%s' is unique."
546                     % (field_combination, model_name),
547                     hint=(
548                         'Mark a single field as unique=True or add a set of '
549                         'fields to a unique constraint (via unique_together '
550                         'or a UniqueConstraint (without condition) in the '
551                         'model Meta.constraints).'
552                     ),
553                     obj=self,
554                     id='fields.E310',
555                 )
556             ]
557         elif not has_unique_constraint:
558             field_name = self.foreign_related_fields[0].name
559             model_name = self.remote_field.model.__name__
560             return [
561                 checks.Error(
562                     "'%s.%s' must be unique because it is referenced by "
563                     "a foreign key." % (model_name, field_name),
564                     hint=(
565                         'Add unique=True to this field or add a '
566                         'UniqueConstraint (without condition) in the model '
567                         'Meta.constraints.'
568                     ),
569                     obj=self,
570                     id='fields.E311',
571                 )
572             ]
573         else:
574             return []
575 
576     def deconstruct(self):
577         name, path, args, kwargs = super().deconstruct()
578         kwargs['on_delete'] = self.remote_field.on_delete
579         kwargs['from_fields'] = self.from_fields
580         kwargs['to_fields'] = self.to_fields
581 
582         if self.remote_field.parent_link:
583             kwargs['parent_link'] = self.remote_field.parent_link
584         if isinstance(self.remote_field.model, str):
585             if '.' in self.remote_field.model:
586                 app_label, model_name = self.remote_field.model.split('.')
587                 kwargs['to'] = '%s.%s' % (app_label, model_name.lower())
588             else:
589                 kwargs['to'] = self.remote_field.model.lower()
590         else:
591             kwargs['to'] = self.remote_field.model._meta.label_lower
592         # If swappable is True, then see if we're actually pointing to the target
593         # of a swap.
594         swappable_setting = self.swappable_setting
595         if swappable_setting is not None:
596             # If it's already a settings reference, error
597             if hasattr(kwargs['to'], "setting_name"):
598                 if kwargs['to'].setting_name != swappable_setting:
599                     raise ValueError(
600                         "Cannot deconstruct a ForeignKey pointing to a model "
601                         "that is swapped in place of more than one model (%s and %s)"
602                         % (kwargs['to'].setting_name, swappable_setting)
603                     )
604             # Set it
605             kwargs['to'] = SettingsReference(
606                 kwargs['to'],
607                 swappable_setting,
608             )
609         return name, path, args, kwargs
610 
611     def resolve_related_fields(self):
612         if not self.from_fields or len(self.from_fields) != len(self.to_fields):
613             raise ValueError('Foreign Object from and to fields must be the same non-zero length')
614         if isinstance(self.remote_field.model, str):
615             raise ValueError('Related model %r cannot be resolved' % self.remote_field.model)
616         related_fields = []
617         for index in range(len(self.from_fields)):
618             from_field_name = self.from_fields[index]
619             to_field_name = self.to_fields[index]
620             from_field = (
621                 self
622                 if from_field_name == RECURSIVE_RELATIONSHIP_CONSTANT
623                 else self.opts.get_field(from_field_name)
624             )
625             to_field = (self.remote_field.model._meta.pk if to_field_name is None
626                         else self.remote_field.model._meta.get_field(to_field_name))
627             related_fields.append((from_field, to_field))
628         return related_fields
629 
630     @cached_property
631     def related_fields(self):
632         return self.resolve_related_fields()
633 
634     @cached_property
635     def reverse_related_fields(self):
636         return [(rhs_field, lhs_field) for lhs_field, rhs_field in self.related_fields]
637 
638     @cached_property
639     def local_related_fields(self):
640         return tuple(lhs_field for lhs_field, rhs_field in self.related_fields)
641 
642     @cached_property
643     def foreign_related_fields(self):
644         return tuple(rhs_field for lhs_field, rhs_field in self.related_fields if rhs_field)
645 
646     def get_local_related_value(self, instance):
647         return self.get_instance_value_for_fields(instance, self.local_related_fields)
648 
649     def get_foreign_related_value(self, instance):
650         return self.get_instance_value_for_fields(instance, self.foreign_related_fields)
651 
652     @staticmethod
653     def get_instance_value_for_fields(instance, fields):
654         ret = []
655         opts = instance._meta
656         for field in fields:
657             # Gotcha: in some cases (like fixture loading) a model can have
658             # different values in parent_ptr_id and parent's id. So, use
659             # instance.pk (that is, parent_ptr_id) when asked for instance.id.
660             if field.primary_key:
661                 possible_parent_link = opts.get_ancestor_link(field.model)
662                 if (not possible_parent_link or
663                         possible_parent_link.primary_key or
664                         possible_parent_link.model._meta.abstract):
665                     ret.append(instance.pk)
666                     continue
667             ret.append(getattr(instance, field.attname))
668         return tuple(ret)
669 
670     def get_attname_column(self):
671         attname, column = super().get_attname_column()
672         return attname, None
673 
674     def get_joining_columns(self, reverse_join=False):
675         source = self.reverse_related_fields if reverse_join else self.related_fields
676         return tuple((lhs_field.column, rhs_field.column) for lhs_field, rhs_field in source)
677 
678     def get_reverse_joining_columns(self):
679         return self.get_joining_columns(reverse_join=True)
680 
681     def get_extra_descriptor_filter(self, instance):
682         """
683         Return an extra filter condition for related object fetching when
684         user does 'instance.fieldname', that is the extra filter is used in
685         the descriptor of the field.
686 
687         The filter should be either a dict usable in .filter(**kwargs) call or
688         a Q-object. The condition will be ANDed together with the relation's
689         joining columns.
690 
691         A parallel method is get_extra_restriction() which is used in
692         JOIN and subquery conditions.
693         """
694         return {}
695 
696     def get_extra_restriction(self, where_class, alias, related_alias):
697         """
698         Return a pair condition used for joining and subquery pushdown. The
699         condition is something that responds to as_sql(compiler, connection)
700         method.
701 
702         Note that currently referring both the 'alias' and 'related_alias'
703         will not work in some conditions, like subquery pushdown.
704 
705         A parallel method is get_extra_descriptor_filter() which is used in
706         instance.fieldname related object fetching.
707         """
708         return None
709 
710     def get_path_info(self, filtered_relation=None):
711         """Get path from this field to the related model."""
712         opts = self.remote_field.model._meta
713         from_opts = self.model._meta
714         return [PathInfo(
715             from_opts=from_opts,
716             to_opts=opts,
717             target_fields=self.foreign_related_fields,
718             join_field=self,
719             m2m=False,
720             direct=True,
721             filtered_relation=filtered_relation,
722         )]
723 
724     def get_reverse_path_info(self, filtered_relation=None):
725         """Get path from the related model to this field's model."""
726         opts = self.model._meta
727         from_opts = self.remote_field.model._meta
728         return [PathInfo(
729             from_opts=from_opts,
730             to_opts=opts,
731             target_fields=(opts.pk,),
732             join_field=self.remote_field,
733             m2m=not self.unique,
734             direct=False,
735             filtered_relation=filtered_relation,
736         )]
737 
738     @classmethod
739     @functools.lru_cache(maxsize=None)
740     def get_lookups(cls):
741         bases = inspect.getmro(cls)
742         bases = bases[:bases.index(ForeignObject) + 1]
743         class_lookups = [parent.__dict__.get('class_lookups', {}) for parent in bases]
744         return cls.merge_dicts(class_lookups)
745 
746     def contribute_to_class(self, cls, name, private_only=False, **kwargs):
747         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)
748         setattr(cls, self.name, self.forward_related_accessor_class(self))
749 
750     def contribute_to_related_class(self, cls, related):
751         # Internal FK's - i.e., those with a related name ending with '+' -
752         # and swapped models don't get a related descriptor.
753         if not self.remote_field.is_hidden() and not related.related_model._meta.swapped:
754             setattr(cls._meta.concrete_model, related.get_accessor_name(), self.related_accessor_class(related))
755             # While 'limit_choices_to' might be a callable, simply pass
756             # it along for later - this is too early because it's still
757             # model load time.
758             if self.remote_field.limit_choices_to:
759                 cls._meta.related_fkey_lookups.append(self.remote_field.limit_choices_to)
760 
761 
762 ForeignObject.register_lookup(RelatedIn)
763 ForeignObject.register_lookup(RelatedExact)
764 ForeignObject.register_lookup(RelatedLessThan)
765 ForeignObject.register_lookup(RelatedGreaterThan)
766 ForeignObject.register_lookup(RelatedGreaterThanOrEqual)
767 ForeignObject.register_lookup(RelatedLessThanOrEqual)
768 ForeignObject.register_lookup(RelatedIsNull)
769 
770 
771 class ForeignKey(ForeignObject):
772     """
773     Provide a many-to-one relation by adding a column to the local model
774     to hold the remote value.
775 
776     By default ForeignKey will target the pk of the remote model but this
777     behavior can be changed by using the ``to_field`` argument.
778     """
779     descriptor_class = ForeignKeyDeferredAttribute
780     # Field flags
781     many_to_many = False
782     many_to_one = True
783     one_to_many = False
784     one_to_one = False
785 
786     rel_class = ManyToOneRel
787 
788     empty_strings_allowed = False
789     default_error_messages = {
790         'invalid': _('%(model)s instance with %(field)s %(value)r does not exist.')
791     }
792     description = _("Foreign Key (type determined by related field)")
793 
794     def __init__(self, to, on_delete, related_name=None, related_query_name=None,
795                  limit_choices_to=None, parent_link=False, to_field=None,
796                  db_constraint=True, **kwargs):
797         try:
798             to._meta.model_name
799         except AttributeError:
800             assert isinstance(to, str), (
801                 "%s(%r) is invalid. First parameter to ForeignKey must be "
802                 "either a model, a model name, or the string %r" % (
803                     self.__class__.__name__, to,
804                     RECURSIVE_RELATIONSHIP_CONSTANT,
805                 )
806             )
807         else:
808             # For backwards compatibility purposes, we need to *try* and set
809             # the to_field during FK construction. It won't be guaranteed to
810             # be correct until contribute_to_class is called. Refs #12190.
811             to_field = to_field or (to._meta.pk and to._meta.pk.name)
812         if not callable(on_delete):
813             raise TypeError('on_delete must be callable.')
814 
815         kwargs['rel'] = self.rel_class(
816             self, to, to_field,
817             related_name=related_name,
818             related_query_name=related_query_name,
819             limit_choices_to=limit_choices_to,
820             parent_link=parent_link,
821             on_delete=on_delete,
822         )
823         kwargs.setdefault('db_index', True)
824 
825         super().__init__(
826             to,
827             on_delete,
828             from_fields=[RECURSIVE_RELATIONSHIP_CONSTANT],
829             to_fields=[to_field],
830             **kwargs,
831         )
832         self.db_constraint = db_constraint
833 
834     def check(self, **kwargs):
835         return [
836             *super().check(**kwargs),
837             *self._check_on_delete(),
838             *self._check_unique(),
839         ]
840 
841     def _check_on_delete(self):
842         on_delete = getattr(self.remote_field, 'on_delete', None)
843         if on_delete == SET_NULL and not self.null:
844             return [
845                 checks.Error(
846                     'Field specifies on_delete=SET_NULL, but cannot be null.',
847                     hint='Set null=True argument on the field, or change the on_delete rule.',
848                     obj=self,
849                     id='fields.E320',
850                 )
851             ]
852         elif on_delete == SET_DEFAULT and not self.has_default():
853             return [
854                 checks.Error(
855                     'Field specifies on_delete=SET_DEFAULT, but has no default value.',
856                     hint='Set a default value, or change the on_delete rule.',
857                     obj=self,
858                     id='fields.E321',
859                 )
860             ]
861         else:
862             return []
863 
864     def _check_unique(self, **kwargs):
865         return [
866             checks.Warning(
867                 'Setting unique=True on a ForeignKey has the same effect as using a OneToOneField.',
868                 hint='ForeignKey(unique=True) is usually better served by a OneToOneField.',
869                 obj=self,
870                 id='fields.W342',
871             )
872         ] if self.unique else []
873 
874     def deconstruct(self):
875         name, path, args, kwargs = super().deconstruct()
876         del kwargs['to_fields']
877         del kwargs['from_fields']
878         # Handle the simpler arguments
879         if self.db_index:
880             del kwargs['db_index']
881         else:
882             kwargs['db_index'] = False
883         if self.db_constraint is not True:
884             kwargs['db_constraint'] = self.db_constraint
885         # Rel needs more work.
886         to_meta = getattr(self.remote_field.model, "_meta", None)
887         if self.remote_field.field_name and (
888                 not to_meta or (to_meta.pk and self.remote_field.field_name != to_meta.pk.name)):
889             kwargs['to_field'] = self.remote_field.field_name
890         return name, path, args, kwargs
891 
892     def to_python(self, value):
893         return self.target_field.to_python(value)
894 
895     @property
896     def target_field(self):
897         return self.foreign_related_fields[0]
898 
899     def get_reverse_path_info(self, filtered_relation=None):
900         """Get path from the related model to this field's model."""
901         opts = self.model._meta
902         from_opts = self.remote_field.model._meta
903         return [PathInfo(
904             from_opts=from_opts,
905             to_opts=opts,
906             target_fields=(opts.pk,),
907             join_field=self.remote_field,
908             m2m=not self.unique,
909             direct=False,
910             filtered_relation=filtered_relation,
911         )]
912 
913     def validate(self, value, model_instance):
914         if self.remote_field.parent_link:
915             return
916         super().validate(value, model_instance)
917         if value is None:
918             return
919 
920         using = router.db_for_read(self.remote_field.model, instance=model_instance)
921         qs = self.remote_field.model._base_manager.using(using).filter(
922             **{self.remote_field.field_name: value}
923         )
924         qs = qs.complex_filter(self.get_limit_choices_to())
925         if not qs.exists():
926             raise exceptions.ValidationError(
927                 self.error_messages['invalid'],
928                 code='invalid',
929                 params={
930                     'model': self.remote_field.model._meta.verbose_name, 'pk': value,
931                     'field': self.remote_field.field_name, 'value': value,
932                 },  # 'pk' is included for backwards compatibility
933             )
934 
935     def resolve_related_fields(self):
936         related_fields = super().resolve_related_fields()
937         for from_field, to_field in related_fields:
938             if to_field and to_field.model != self.remote_field.model._meta.concrete_model:
939                 raise exceptions.FieldError(
940                     "'%s.%s' refers to field '%s' which is not local to model "
941                     "'%s'." % (
942                         self.model._meta.label,
943                         self.name,
944                         to_field.name,
945                         self.remote_field.model._meta.concrete_model._meta.label,
946                     )
947                 )
948         return related_fields
949 
950     def get_attname(self):
951         return '%s_id' % self.name
952 
953     def get_attname_column(self):
954         attname = self.get_attname()
955         column = self.db_column or attname
956         return attname, column
957 
958     def get_default(self):
959         """Return the to_field if the default value is an object."""
960         field_default = super().get_default()
961         if isinstance(field_default, self.remote_field.model):
962             return getattr(field_default, self.target_field.attname)
963         return field_default
964 
965     def get_db_prep_save(self, value, connection):
966         if value is None or (value == '' and
967                              (not self.target_field.empty_strings_allowed or
968                               connection.features.interprets_empty_strings_as_nulls)):
969             return None
970         else:
971             return self.target_field.get_db_prep_save(value, connection=connection)
972 
973     def get_db_prep_value(self, value, connection, prepared=False):
974         return self.target_field.get_db_prep_value(value, connection, prepared)
975 
976     def get_prep_value(self, value):
977         return self.target_field.get_prep_value(value)
978 
979     def contribute_to_related_class(self, cls, related):
980         super().contribute_to_related_class(cls, related)
981         if self.remote_field.field_name is None:
982             self.remote_field.field_name = cls._meta.pk.name
983 
984     def formfield(self, *, using=None, **kwargs):
985         if isinstance(self.remote_field.model, str):
986             raise ValueError("Cannot create form field for %r yet, because "
987                              "its related model %r has not been loaded yet" %
988                              (self.name, self.remote_field.model))
989         return super().formfield(**{
990             'form_class': forms.ModelChoiceField,
991             'queryset': self.remote_field.model._default_manager.using(using),
992             'to_field_name': self.remote_field.field_name,
993             **kwargs,
994             'blank': self.blank,
995         })
996 
997     def db_check(self, connection):
998         return []
999 
1000     def db_type(self, connection):
1001         return self.target_field.rel_db_type(connection=connection)
1002 
1003     def db_parameters(self, connection):
1004         return {"type": self.db_type(connection), "check": self.db_check(connection)}
1005 
1006     def convert_empty_strings(self, value, expression, connection):
1007         if (not value) and isinstance(value, str):
1008             return None
1009         return value
1010 
1011     def get_db_converters(self, connection):
1012         converters = super().get_db_converters(connection)
1013         if connection.features.interprets_empty_strings_as_nulls:
1014             converters += [self.convert_empty_strings]
1015         return converters
1016 
1017     def get_col(self, alias, output_field=None):
1018         if output_field is None:
1019             output_field = self.target_field
1020             while isinstance(output_field, ForeignKey):
1021                 output_field = output_field.target_field
1022                 if output_field is self:
1023                     raise ValueError('Cannot resolve output_field.')
1024         return super().get_col(alias, output_field)
1025 
1026 
1027 class OneToOneField(ForeignKey):
1028     """
1029     A OneToOneField is essentially the same as a ForeignKey, with the exception
1030     that it always carries a "unique" constraint with it and the reverse
1031     relation always returns the object pointed to (since there will only ever
1032     be one), rather than returning a list.
1033     """
1034 
1035     # Field flags
1036     many_to_many = False
1037     many_to_one = False
1038     one_to_many = False
1039     one_to_one = True
1040 
1041     related_accessor_class = ReverseOneToOneDescriptor
1042     forward_related_accessor_class = ForwardOneToOneDescriptor
1043     rel_class = OneToOneRel
1044 
1045     description = _("One-to-one relationship")
1046 
1047     def __init__(self, to, on_delete, to_field=None, **kwargs):
1048         kwargs['unique'] = True
1049         super().__init__(to, on_delete, to_field=to_field, **kwargs)
1050 
1051     def deconstruct(self):
1052         name, path, args, kwargs = super().deconstruct()
1053         if "unique" in kwargs:
1054             del kwargs['unique']
1055         return name, path, args, kwargs
1056 
1057     def formfield(self, **kwargs):
1058         if self.remote_field.parent_link:
1059             return None
1060         return super().formfield(**kwargs)
1061 
1062     def save_form_data(self, instance, data):
1063         if isinstance(data, self.remote_field.model):
1064             setattr(instance, self.name, data)
1065         else:
1066             setattr(instance, self.attname, data)
1067             # Remote field object must be cleared otherwise Model.save()
1068             # will reassign attname using the related object pk.
1069             if data is None:
1070                 setattr(instance, self.name, data)
1071 
1072     def _check_unique(self, **kwargs):
1073         # Override ForeignKey since check isn't applicable here.
1074         return []
1075 
1076 
1077 def create_many_to_many_intermediary_model(field, klass):
1078     from django.db import models
1079 
1080     def set_managed(model, related, through):
1081         through._meta.managed = model._meta.managed or related._meta.managed
1082 
1083     to_model = resolve_relation(klass, field.remote_field.model)
1084     name = '%s_%s' % (klass._meta.object_name, field.name)
1085     lazy_related_operation(set_managed, klass, to_model, name)
1086 
1087     to = make_model_tuple(to_model)[1]
1088     from_ = klass._meta.model_name
1089     if to == from_:
1090         to = 'to_%s' % to
1091         from_ = 'from_%s' % from_
1092 
1093     meta = type('Meta', (), {
1094         'db_table': field._get_m2m_db_table(klass._meta),
1095         'auto_created': klass,
1096         'app_label': klass._meta.app_label,
1097         'db_tablespace': klass._meta.db_tablespace,
1098         'unique_together': (from_, to),
1099         'verbose_name': _('%(from)s-%(to)s relationship') % {'from': from_, 'to': to},
1100         'verbose_name_plural': _('%(from)s-%(to)s relationships') % {'from': from_, 'to': to},
1101         'apps': field.model._meta.apps,
1102     })
1103     # Construct and return the new class.
1104     return type(name, (models.Model,), {
1105         'Meta': meta,
1106         '__module__': klass.__module__,
1107         from_: models.ForeignKey(
1108             klass,
1109             related_name='%s+' % name,
1110             db_tablespace=field.db_tablespace,
1111             db_constraint=field.remote_field.db_constraint,
1112             on_delete=CASCADE,
1113         ),
1114         to: models.ForeignKey(
1115             to_model,
1116             related_name='%s+' % name,
1117             db_tablespace=field.db_tablespace,
1118             db_constraint=field.remote_field.db_constraint,
1119             on_delete=CASCADE,
1120         )
1121     })
1122 
1123 
1124 class ManyToManyField(RelatedField):
1125     """
1126     Provide a many-to-many relation by using an intermediary model that
1127     holds two ForeignKey fields pointed at the two sides of the relation.
1128 
1129     Unless a ``through`` model was provided, ManyToManyField will use the
1130     create_many_to_many_intermediary_model factory to automatically generate
1131     the intermediary model.
1132     """
1133 
1134     # Field flags
1135     many_to_many = True
1136     many_to_one = False
1137     one_to_many = False
1138     one_to_one = False
1139 
1140     rel_class = ManyToManyRel
1141 
1142     description = _("Many-to-many relationship")
1143 
1144     def __init__(self, to, related_name=None, related_query_name=None,
1145                  limit_choices_to=None, symmetrical=None, through=None,
1146                  through_fields=None, db_constraint=True, db_table=None,
1147                  swappable=True, **kwargs):
1148         try:
1149             to._meta
1150         except AttributeError:
1151             assert isinstance(to, str), (
1152                 "%s(%r) is invalid. First parameter to ManyToManyField must be "
1153                 "either a model, a model name, or the string %r" %
1154                 (self.__class__.__name__, to, RECURSIVE_RELATIONSHIP_CONSTANT)
1155             )
1156 
1157         if symmetrical is None:
1158             symmetrical = (to == RECURSIVE_RELATIONSHIP_CONSTANT)
1159 
1160         if through is not None:
1161             assert db_table is None, (
1162                 "Cannot specify a db_table if an intermediary model is used."
1163             )
1164 
1165         kwargs['rel'] = self.rel_class(
1166             self, to,
1167             related_name=related_name,
1168             related_query_name=related_query_name,
1169             limit_choices_to=limit_choices_to,
1170             symmetrical=symmetrical,
1171             through=through,
1172             through_fields=through_fields,
1173             db_constraint=db_constraint,
1174         )
1175         self.has_null_arg = 'null' in kwargs
1176 
1177         super().__init__(**kwargs)
1178 
1179         self.db_table = db_table
1180         self.swappable = swappable
1181 
1182     def check(self, **kwargs):
1183         return [
1184             *super().check(**kwargs),
1185             *self._check_unique(**kwargs),
1186             *self._check_relationship_model(**kwargs),
1187             *self._check_ignored_options(**kwargs),
1188             *self._check_table_uniqueness(**kwargs),
1189         ]
1190 
1191     def _check_unique(self, **kwargs):
1192         if self.unique:
1193             return [
1194                 checks.Error(
1195                     'ManyToManyFields cannot be unique.',
1196                     obj=self,
1197                     id='fields.E330',
1198                 )
1199             ]
1200         return []
1201 
1202     def _check_ignored_options(self, **kwargs):
1203         warnings = []
1204 
1205         if self.has_null_arg:
1206             warnings.append(
1207                 checks.Warning(
1208                     'null has no effect on ManyToManyField.',
1209                     obj=self,
1210                     id='fields.W340',
1211                 )
1212             )
1213 
1214         if self._validators:
1215             warnings.append(
1216                 checks.Warning(
1217                     'ManyToManyField does not support validators.',
1218                     obj=self,
1219                     id='fields.W341',
1220                 )
1221             )
1222         if (self.remote_field.limit_choices_to and self.remote_field.through and
1223                 not self.remote_field.through._meta.auto_created):
1224             warnings.append(
1225                 checks.Warning(
1226                     'limit_choices_to has no effect on ManyToManyField '
1227                     'with a through model.',
1228                     obj=self,
1229                     id='fields.W343',
1230                 )
1231             )
1232 
1233         return warnings
1234 
1235     def _check_relationship_model(self, from_model=None, **kwargs):
1236         if hasattr(self.remote_field.through, '_meta'):
1237             qualified_model_name = "%s.%s" % (
1238                 self.remote_field.through._meta.app_label, self.remote_field.through.__name__)
1239         else:
1240             qualified_model_name = self.remote_field.through
1241 
1242         errors = []
1243 
1244         if self.remote_field.through not in self.opts.apps.get_models(include_auto_created=True):
1245             # The relationship model is not installed.
1246             errors.append(
1247                 checks.Error(
1248                     "Field specifies a many-to-many relation through model "
1249                     "'%s', which has not been installed." % qualified_model_name,
1250                     obj=self,
1251                     id='fields.E331',
1252                 )
1253             )
1254 
1255         else:
1256             assert from_model is not None, (
1257                 "ManyToManyField with intermediate "
1258                 "tables cannot be checked if you don't pass the model "
1259                 "where the field is attached to."
1260             )
1261             # Set some useful local variables
1262             to_model = resolve_relation(from_model, self.remote_field.model)
1263             from_model_name = from_model._meta.object_name
1264             if isinstance(to_model, str):
1265                 to_model_name = to_model
1266             else:
1267                 to_model_name = to_model._meta.object_name
1268             relationship_model_name = self.remote_field.through._meta.object_name
1269             self_referential = from_model == to_model
1270             # Count foreign keys in intermediate model
1271             if self_referential:
1272                 seen_self = sum(
1273                     from_model == getattr(field.remote_field, 'model', None)
1274                     for field in self.remote_field.through._meta.fields
1275                 )
1276 
1277                 if seen_self > 2 and not self.remote_field.through_fields:
1278                     errors.append(
1279                         checks.Error(
1280                             "The model is used as an intermediate model by "
1281                             "'%s', but it has more than two foreign keys "
1282                             "to '%s', which is ambiguous. You must specify "
1283                             "which two foreign keys Django should use via the "
1284                             "through_fields keyword argument." % (self, from_model_name),
1285                             hint="Use through_fields to specify which two foreign keys Django should use.",
1286                             obj=self.remote_field.through,
1287                             id='fields.E333',
1288                         )
1289                     )
1290 
1291             else:
1292                 # Count foreign keys in relationship model
1293                 seen_from = sum(
1294                     from_model == getattr(field.remote_field, 'model', None)
1295                     for field in self.remote_field.through._meta.fields
1296                 )
1297                 seen_to = sum(
1298                     to_model == getattr(field.remote_field, 'model', None)
1299                     for field in self.remote_field.through._meta.fields
1300                 )
1301 
1302                 if seen_from > 1 and not self.remote_field.through_fields:
1303                     errors.append(
1304                         checks.Error(
1305                             ("The model is used as an intermediate model by "
1306                              "'%s', but it has more than one foreign key "
1307                              "from '%s', which is ambiguous. You must specify "
1308                              "which foreign key Django should use via the "
1309                              "through_fields keyword argument.") % (self, from_model_name),
1310                             hint=(
1311                                 'If you want to create a recursive relationship, '
1312                                 'use ManyToManyField("%s", through="%s").'
1313                             ) % (
1314                                 RECURSIVE_RELATIONSHIP_CONSTANT,
1315                                 relationship_model_name,
1316                             ),
1317                             obj=self,
1318                             id='fields.E334',
1319                         )
1320                     )
1321 
1322                 if seen_to > 1 and not self.remote_field.through_fields:
1323                     errors.append(
1324                         checks.Error(
1325                             "The model is used as an intermediate model by "
1326                             "'%s', but it has more than one foreign key "
1327                             "to '%s', which is ambiguous. You must specify "
1328                             "which foreign key Django should use via the "
1329                             "through_fields keyword argument." % (self, to_model_name),
1330                             hint=(
1331                                 'If you want to create a recursive relationship, '
1332                                 'use ManyToManyField("%s", through="%s").'
1333                             ) % (
1334                                 RECURSIVE_RELATIONSHIP_CONSTANT,
1335                                 relationship_model_name,
1336                             ),
1337                             obj=self,
1338                             id='fields.E335',
1339                         )
1340                     )
1341 
1342                 if seen_from == 0 or seen_to == 0:
1343                     errors.append(
1344                         checks.Error(
1345                             "The model is used as an intermediate model by "
1346                             "'%s', but it does not have a foreign key to '%s' or '%s'." % (
1347                                 self, from_model_name, to_model_name
1348                             ),
1349                             obj=self.remote_field.through,
1350                             id='fields.E336',
1351                         )
1352                     )
1353 
1354         # Validate `through_fields`.
1355         if self.remote_field.through_fields is not None:
1356             # Validate that we're given an iterable of at least two items
1357             # and that none of them is "falsy".
1358             if not (len(self.remote_field.through_fields) >= 2 and
1359                     self.remote_field.through_fields[0] and self.remote_field.through_fields[1]):
1360                 errors.append(
1361                     checks.Error(
1362                         "Field specifies 'through_fields' but does not provide "
1363                         "the names of the two link fields that should be used "
1364                         "for the relation through model '%s'." % qualified_model_name,
1365                         hint="Make sure you specify 'through_fields' as through_fields=('field1', 'field2')",
1366                         obj=self,
1367                         id='fields.E337',
1368                     )
1369                 )
1370 
1371             # Validate the given through fields -- they should be actual
1372             # fields on the through model, and also be foreign keys to the
1373             # expected models.
1374             else:
1375                 assert from_model is not None, (
1376                     "ManyToManyField with intermediate "
1377                     "tables cannot be checked if you don't pass the model "
1378                     "where the field is attached to."
1379                 )
1380 
1381                 source, through, target = from_model, self.remote_field.through, self.remote_field.model
1382                 source_field_name, target_field_name = self.remote_field.through_fields[:2]
1383 
1384                 for field_name, related_model in ((source_field_name, source),
1385                                                   (target_field_name, target)):
1386 
1387                     possible_field_names = []
1388                     for f in through._meta.fields:
1389                         if hasattr(f, 'remote_field') and getattr(f.remote_field, 'model', None) == related_model:
1390                             possible_field_names.append(f.name)
1391                     if possible_field_names:
1392                         hint = "Did you mean one of the following foreign keys to '%s': %s?" % (
1393                             related_model._meta.object_name,
1394                             ', '.join(possible_field_names),
1395                         )
1396                     else:
1397                         hint = None
1398 
1399                     try:
1400                         field = through._meta.get_field(field_name)
1401                     except exceptions.FieldDoesNotExist:
1402                         errors.append(
1403                             checks.Error(
1404                                 "The intermediary model '%s' has no field '%s'."
1405                                 % (qualified_model_name, field_name),
1406                                 hint=hint,
1407                                 obj=self,
1408                                 id='fields.E338',
1409                             )
1410                         )
1411                     else:
1412                         if not (hasattr(field, 'remote_field') and
1413                                 getattr(field.remote_field, 'model', None) == related_model):
1414                             errors.append(
1415                                 checks.Error(
1416                                     "'%s.%s' is not a foreign key to '%s'." % (
1417                                         through._meta.object_name, field_name,
1418                                         related_model._meta.object_name,
1419                                     ),
1420                                     hint=hint,
1421                                     obj=self,
1422                                     id='fields.E339',
1423                                 )
1424                             )
1425 
1426         return errors
1427 
1428     def _check_table_uniqueness(self, **kwargs):
1429         if isinstance(self.remote_field.through, str) or not self.remote_field.through._meta.managed:
1430             return []
1431         registered_tables = {
1432             model._meta.db_table: model
1433             for model in self.opts.apps.get_models(include_auto_created=True)
1434             if model != self.remote_field.through and model._meta.managed
1435         }
1436         m2m_db_table = self.m2m_db_table()
1437         model = registered_tables.get(m2m_db_table)
1438         # The second condition allows multiple m2m relations on a model if
1439         # some point to a through model that proxies another through model.
1440         if model and model._meta.concrete_model != self.remote_field.through._meta.concrete_model:
1441             if model._meta.auto_created:
1442                 def _get_field_name(model):
1443                     for field in model._meta.auto_created._meta.many_to_many:
1444                         if field.remote_field.through is model:
1445                             return field.name
1446                 opts = model._meta.auto_created._meta
1447                 clashing_obj = '%s.%s' % (opts.label, _get_field_name(model))
1448             else:
1449                 clashing_obj = model._meta.label
1450             if settings.DATABASE_ROUTERS:
1451                 error_class, error_id = checks.Warning, 'fields.W344'
1452                 error_hint = (
1453                     'You have configured settings.DATABASE_ROUTERS. Verify '
1454                     'that the table of %r is correctly routed to a separate '
1455                     'database.' % clashing_obj
1456                 )
1457             else:
1458                 error_class, error_id = checks.Error, 'fields.E340'
1459                 error_hint = None
1460             return [
1461                 error_class(
1462                     "The field's intermediary table '%s' clashes with the "
1463                     "table name of '%s'." % (m2m_db_table, clashing_obj),
1464                     obj=self,
1465                     hint=error_hint,
1466                     id=error_id,
1467                 )
1468             ]
1469         return []
1470 
1471     def deconstruct(self):
1472         name, path, args, kwargs = super().deconstruct()
1473         # Handle the simpler arguments.
1474         if self.db_table is not None:
1475             kwargs['db_table'] = self.db_table
1476         if self.remote_field.db_constraint is not True:
1477             kwargs['db_constraint'] = self.remote_field.db_constraint
1478         # Rel needs more work.
1479         if isinstance(self.remote_field.model, str):
1480             kwargs['to'] = self.remote_field.model
1481         else:
1482             kwargs['to'] = self.remote_field.model._meta.label
1483         if getattr(self.remote_field, 'through', None) is not None:
1484             if isinstance(self.remote_field.through, str):
1485                 kwargs['through'] = self.remote_field.through
1486             elif not self.remote_field.through._meta.auto_created:
1487                 kwargs['through'] = self.remote_field.through._meta.label
1488         # If swappable is True, then see if we're actually pointing to the target
1489         # of a swap.
1490         swappable_setting = self.swappable_setting
1491         if swappable_setting is not None:
1492             # If it's already a settings reference, error.
1493             if hasattr(kwargs['to'], "setting_name"):
1494                 if kwargs['to'].setting_name != swappable_setting:
1495                     raise ValueError(
1496                         "Cannot deconstruct a ManyToManyField pointing to a "
1497                         "model that is swapped in place of more than one model "
1498                         "(%s and %s)" % (kwargs['to'].setting_name, swappable_setting)
1499                     )
1500 
1501             kwargs['to'] = SettingsReference(
1502                 kwargs['to'],
1503                 swappable_setting,
1504             )
1505         return name, path, args, kwargs
1506 
1507     def _get_path_info(self, direct=False, filtered_relation=None):
1508         """Called by both direct and indirect m2m traversal."""
1509         int_model = self.remote_field.through
1510         linkfield1 = int_model._meta.get_field(self.m2m_field_name())
1511         linkfield2 = int_model._meta.get_field(self.m2m_reverse_field_name())
1512         if direct:
1513             join1infos = linkfield1.get_reverse_path_info()
1514             join2infos = linkfield2.get_path_info(filtered_relation)
1515         else:
1516             join1infos = linkfield2.get_reverse_path_info()
1517             join2infos = linkfield1.get_path_info(filtered_relation)
1518 
1519         # Get join infos between the last model of join 1 and the first model
1520         # of join 2. Assume the only reason these may differ is due to model
1521         # inheritance.
1522         join1_final = join1infos[-1].to_opts
1523         join2_initial = join2infos[0].from_opts
1524         if join1_final is join2_initial:
1525             intermediate_infos = []
1526         elif issubclass(join1_final.model, join2_initial.model):
1527             intermediate_infos = join1_final.get_path_to_parent(join2_initial.model)
1528         else:
1529             intermediate_infos = join2_initial.get_path_from_parent(join1_final.model)
1530 
1531         return [*join1infos, *intermediate_infos, *join2infos]
1532 
1533     def get_path_info(self, filtered_relation=None):
1534         return self._get_path_info(direct=True, filtered_relation=filtered_relation)
1535 
1536     def get_reverse_path_info(self, filtered_relation=None):
1537         return self._get_path_info(direct=False, filtered_relation=filtered_relation)
1538 
1539     def _get_m2m_db_table(self, opts):
1540         """
1541         Function that can be curried to provide the m2m table name for this
1542         relation.
1543         """
1544         if self.remote_field.through is not None:
1545             return self.remote_field.through._meta.db_table
1546         elif self.db_table:
1547             return self.db_table
1548         else:
1549             m2m_table_name = '%s_%s' % (utils.strip_quotes(opts.db_table), self.name)
1550             return utils.truncate_name(m2m_table_name, connection.ops.max_name_length())
1551 
1552     def _get_m2m_attr(self, related, attr):
1553         """
1554         Function that can be curried to provide the source accessor or DB
1555         column name for the m2m table.
1556         """
1557         cache_attr = '_m2m_%s_cache' % attr
1558         if hasattr(self, cache_attr):
1559             return getattr(self, cache_attr)
1560         if self.remote_field.through_fields is not None:
1561             link_field_name = self.remote_field.through_fields[0]
1562         else:
1563             link_field_name = None
1564         for f in self.remote_field.through._meta.fields:
1565             if (f.is_relation and f.remote_field.model == related.related_model and
1566                     (link_field_name is None or link_field_name == f.name)):
1567                 setattr(self, cache_attr, getattr(f, attr))
1568                 return getattr(self, cache_attr)
1569 
1570     def _get_m2m_reverse_attr(self, related, attr):
1571         """
1572         Function that can be curried to provide the related accessor or DB
1573         column name for the m2m table.
1574         """
1575         cache_attr = '_m2m_reverse_%s_cache' % attr
1576         if hasattr(self, cache_attr):
1577             return getattr(self, cache_attr)
1578         found = False
1579         if self.remote_field.through_fields is not None:
1580             link_field_name = self.remote_field.through_fields[1]
1581         else:
1582             link_field_name = None
1583         for f in self.remote_field.through._meta.fields:
1584             if f.is_relation and f.remote_field.model == related.model:
1585                 if link_field_name is None and related.related_model == related.model:
1586                     # If this is an m2m-intermediate to self,
1587                     # the first foreign key you find will be
1588                     # the source column. Keep searching for
1589                     # the second foreign key.
1590                     if found:
1591                         setattr(self, cache_attr, getattr(f, attr))
1592                         break
1593                     else:
1594                         found = True
1595                 elif link_field_name is None or link_field_name == f.name:
1596                     setattr(self, cache_attr, getattr(f, attr))
1597                     break
1598         return getattr(self, cache_attr)
1599 
1600     def contribute_to_class(self, cls, name, **kwargs):
1601         # To support multiple relations to self, it's useful to have a non-None
1602         # related name on symmetrical relations for internal reasons. The
1603         # concept doesn't make a lot of sense externally ("you want me to
1604         # specify *what* on my non-reversible relation?!"), so we set it up
1605         # automatically. The funky name reduces the chance of an accidental
1606         # clash.
1607         if self.remote_field.symmetrical and (
1608             self.remote_field.model == RECURSIVE_RELATIONSHIP_CONSTANT or
1609             self.remote_field.model == cls._meta.object_name
1610         ):
1611             self.remote_field.related_name = "%s_rel_+" % name
1612         elif self.remote_field.is_hidden():
1613             # If the backwards relation is disabled, replace the original
1614             # related_name with one generated from the m2m field name. Django
1615             # still uses backwards relations internally and we need to avoid
1616             # clashes between multiple m2m fields with related_name == '+'.
1617             self.remote_field.related_name = "_%s_%s_+" % (cls.__name__.lower(), name)
1618 
1619         super().contribute_to_class(cls, name, **kwargs)
1620 
1621         # The intermediate m2m model is not auto created if:
1622         #  1) There is a manually specified intermediate, or
1623         #  2) The class owning the m2m field is abstract.
1624         #  3) The class owning the m2m field has been swapped out.
1625         if not cls._meta.abstract:
1626             if self.remote_field.through:
1627                 def resolve_through_model(_, model, field):
1628                     field.remote_field.through = model
1629                 lazy_related_operation(resolve_through_model, cls, self.remote_field.through, field=self)
1630             elif not cls._meta.swapped:
1631                 self.remote_field.through = create_many_to_many_intermediary_model(self, cls)
1632 
1633         # Add the descriptor for the m2m relation.
1634         setattr(cls, self.name, ManyToManyDescriptor(self.remote_field, reverse=False))
1635 
1636         # Set up the accessor for the m2m table name for the relation.
1637         self.m2m_db_table = partial(self._get_m2m_db_table, cls._meta)
1638 
1639     def contribute_to_related_class(self, cls, related):
1640         # Internal M2Ms (i.e., those with a related name ending with '+')
1641         # and swapped models don't get a related descriptor.
1642         if not self.remote_field.is_hidden() and not related.related_model._meta.swapped:
1643             setattr(cls, related.get_accessor_name(), ManyToManyDescriptor(self.remote_field, reverse=True))
1644 
1645         # Set up the accessors for the column names on the m2m table.
1646         self.m2m_column_name = partial(self._get_m2m_attr, related, 'column')
1647         self.m2m_reverse_name = partial(self._get_m2m_reverse_attr, related, 'column')
1648 
1649         self.m2m_field_name = partial(self._get_m2m_attr, related, 'name')
1650         self.m2m_reverse_field_name = partial(self._get_m2m_reverse_attr, related, 'name')
1651 
1652         get_m2m_rel = partial(self._get_m2m_attr, related, 'remote_field')
1653         self.m2m_target_field_name = lambda: get_m2m_rel().field_name
1654         get_m2m_reverse_rel = partial(self._get_m2m_reverse_attr, related, 'remote_field')
1655         self.m2m_reverse_target_field_name = lambda: get_m2m_reverse_rel().field_name
1656 
1657     def set_attributes_from_rel(self):
1658         pass
1659 
1660     def value_from_object(self, obj):
1661         return [] if obj.pk is None else list(getattr(obj, self.attname).all())
1662 
1663     def save_form_data(self, instance, data):
1664         getattr(instance, self.attname).set(data)
1665 
1666     def formfield(self, *, using=None, **kwargs):
1667         defaults = {
1668             'form_class': forms.ModelMultipleChoiceField,
1669             'queryset': self.remote_field.model._default_manager.using(using),
1670             **kwargs,
1671         }
1672         # If initial is passed in, it's a list of related objects, but the
1673         # MultipleChoiceField takes a list of IDs.
1674         if defaults.get('initial') is not None:
1675             initial = defaults['initial']
1676             if callable(initial):
1677                 initial = initial()
1678             defaults['initial'] = [i.pk for i in initial]
1679         return super().formfield(**defaults)
1680 
1681     def db_check(self, connection):
1682         return None
1683 
1684     def db_type(self, connection):
1685         # A ManyToManyField is not represented by a single column,
1686         # so return None.
1687         return None
1688 
1689     def db_parameters(self, connection):
1690         return {"type": None, "check": None}

</code><intended_behavior>Ensure that the `related_name='+'` or similar directives do not lead to migration errors when used in models with identical names across different applications. There might need to be a clarification or enhancement in how these models and their relationships are processed to allow for smooth migration creation.</intended_behavior>]
2025-10-18 00:58:45.135 | INFO     | Search completed. Bug locations: [<file>django/db/migrations/autodetector.py</file>
<class>None</class>
<method>None</method>
<code>
1 import functools
2 import re
3 from itertools import chain
4 
5 from django.conf import settings
6 from django.db import models
7 from django.db.migrations import operations
8 from django.db.migrations.migration import Migration
9 from django.db.migrations.operations.models import AlterModelOptions
10 from django.db.migrations.optimizer import MigrationOptimizer
11 from django.db.migrations.questioner import MigrationQuestioner
12 from django.db.migrations.utils import COMPILED_REGEX_TYPE, RegexObject
13 from django.utils.topological_sort import stable_topological_sort
14 
15 
16 class MigrationAutodetector:
17     """
18     Take a pair of ProjectStates and compare them to see what the first would
19     need doing to make it match the second (the second usually being the
20     project's current state).
21 
22     Note that this naturally operates on entire projects at a time,
23     as it's likely that changes interact (for example, you can't
24     add a ForeignKey without having a migration to add the table it
25     depends on first). A user interface may offer single-app usage
26     if it wishes, with the caveat that it may not always be possible.
27     """
28 
29     def __init__(self, from_state, to_state, questioner=None):
30         self.from_state = from_state
31         self.to_state = to_state
32         self.questioner = questioner or MigrationQuestioner()
33         self.existing_apps = {app for app, model in from_state.models}
34 
35     def changes(self, graph, trim_to_apps=None, convert_apps=None, migration_name=None):
36         """
37         Main entry point to produce a list of applicable changes.
38         Take a graph to base names on and an optional set of apps
39         to try and restrict to (restriction is not guaranteed)
40         """
41         changes = self._detect_changes(convert_apps, graph)
42         changes = self.arrange_for_graph(changes, graph, migration_name)
43         if trim_to_apps:
44             changes = self._trim_to_apps(changes, trim_to_apps)
45         return changes
46 
47     def deep_deconstruct(self, obj):
48         """
49         Recursive deconstruction for a field and its arguments.
50         Used for full comparison for rename/alter; sometimes a single-level
51         deconstruction will not compare correctly.
52         """
53         if isinstance(obj, list):
54             return [self.deep_deconstruct(value) for value in obj]
55         elif isinstance(obj, tuple):
56             return tuple(self.deep_deconstruct(value) for value in obj)
57         elif isinstance(obj, dict):
58             return {
59                 key: self.deep_deconstruct(value)
60                 for key, value in obj.items()
61             }
62         elif isinstance(obj, functools.partial):
63             return (obj.func, self.deep_deconstruct(obj.args), self.deep_deconstruct(obj.keywords))
64         elif isinstance(obj, COMPILED_REGEX_TYPE):
65             return RegexObject(obj)
66         elif isinstance(obj, type):
67             # If this is a type that implements 'deconstruct' as an instance method,
68             # avoid treating this as being deconstructible itself - see #22951
69             return obj
70         elif hasattr(obj, 'deconstruct'):
71             deconstructed = obj.deconstruct()
72             if isinstance(obj, models.Field):
73                 # we have a field which also returns a name
74                 deconstructed = deconstructed[1:]
75             path, args, kwargs = deconstructed
76             return (
77                 path,
78                 [self.deep_deconstruct(value) for value in args],
79                 {
80                     key: self.deep_deconstruct(value)
81                     for key, value in kwargs.items()
82                 },
83             )
84         else:
85             return obj
86 
87     def only_relation_agnostic_fields(self, fields):
88         """
89         Return a definition of the fields that ignores field names and
90         what related fields actually relate to. Used for detecting renames (as
91         the related fields change during renames).
92         """
93         fields_def = []
94         for name, field in sorted(fields.items()):
95             deconstruction = self.deep_deconstruct(field)
96             if field.remote_field and field.remote_field.model:
97                 del deconstruction[2]['to']
98             fields_def.append(deconstruction)
99         return fields_def
100 
101     def _detect_changes(self, convert_apps=None, graph=None):
102         """
103         Return a dict of migration plans which will achieve the
104         change from from_state to to_state. The dict has app labels
105         as keys and a list of migrations as values.
106 
107         The resulting migrations aren't specially named, but the names
108         do matter for dependencies inside the set.
109 
110         convert_apps is the list of apps to convert to use migrations
111         (i.e. to make initial migrations for, in the usual case)
112 
113         graph is an optional argument that, if provided, can help improve
114         dependency generation and avoid potential circular dependencies.
115         """
116         # The first phase is generating all the operations for each app
117         # and gathering them into a big per-app list.
118         # Then go through that list, order it, and split into migrations to
119         # resolve dependencies caused by M2Ms and FKs.
120         self.generated_operations = {}
121         self.altered_indexes = {}
122         self.altered_constraints = {}
123 
124         # Prepare some old/new state and model lists, separating
125         # proxy models and ignoring unmigrated apps.
126         self.old_apps = self.from_state.concrete_apps
127         self.new_apps = self.to_state.apps
128         self.old_model_keys = set()
129         self.old_proxy_keys = set()
130         self.old_unmanaged_keys = set()
131         self.new_model_keys = set()
132         self.new_proxy_keys = set()
133         self.new_unmanaged_keys = set()
134         for al, mn in self.from_state.models:
135             model = self.old_apps.get_model(al, mn)
136             if not model._meta.managed:
137                 self.old_unmanaged_keys.add((al, mn))
138             elif al not in self.from_state.real_apps:
139                 if model._meta.proxy:
140                     self.old_proxy_keys.add((al, mn))
141                 else:
142                     self.old_model_keys.add((al, mn))
143 
144         for al, mn in self.to_state.models:
145             model = self.new_apps.get_model(al, mn)
146             if not model._meta.managed:
147                 self.new_unmanaged_keys.add((al, mn))
148             elif (
149                 al not in self.from_state.real_apps or
150                 (convert_apps and al in convert_apps)
151             ):
152                 if model._meta.proxy:
153                     self.new_proxy_keys.add((al, mn))
154                 else:
155                     self.new_model_keys.add((al, mn))
156 
157         # Renames have to come first
158         self.generate_renamed_models()
159 
160         # Prepare lists of fields and generate through model map
161         self._prepare_field_lists()
162         self._generate_through_model_map()
163 
164         # Generate non-rename model operations
165         self.generate_deleted_models()
166         self.generate_created_models()
167         self.generate_deleted_proxies()
168         self.generate_created_proxies()
169         self.generate_altered_options()
170         self.generate_altered_managers()
171 
172         # Create the altered indexes and store them in self.altered_indexes.
173         # This avoids the same computation in generate_removed_indexes()
174         # and generate_added_indexes().
175         self.create_altered_indexes()
176         self.create_altered_constraints()
177         # Generate index removal operations before field is removed
178         self.generate_removed_constraints()
179         self.generate_removed_indexes()
180         # Generate field operations
181         self.generate_renamed_fields()
182         self.generate_removed_fields()
183         self.generate_added_fields()
184         self.generate_altered_fields()
185         self.generate_altered_order_with_respect_to()
186         self.generate_altered_unique_together()
187         self.generate_altered_index_together()
188         self.generate_added_indexes()
189         self.generate_added_constraints()
190         self.generate_altered_db_table()
191 
192         self._sort_migrations()
193         self._build_migration_list(graph)
194         self._optimize_migrations()
195 
196         return self.migrations
197 
198     def _prepare_field_lists(self):
199         """
200         Prepare field lists and a list of the fields that used through models
201         in the old state so dependencies can be made from the through model
202         deletion to the field that uses it.
203         """
204         self.kept_model_keys = self.old_model_keys & self.new_model_keys
205         self.kept_proxy_keys = self.old_proxy_keys & self.new_proxy_keys
206         self.kept_unmanaged_keys = self.old_unmanaged_keys & self.new_unmanaged_keys
207         self.through_users = {}
208         self.old_field_keys = {
209             (app_label, model_name, field_name)
210             for app_label, model_name in self.kept_model_keys
211             for field_name in self.from_state.models[
212                 app_label,
213                 self.renamed_models.get((app_label, model_name), model_name)
214             ].fields
215         }
216         self.new_field_keys = {
217             (app_label, model_name, field_name)
218             for app_label, model_name in self.kept_model_keys
219             for field_name in self.to_state.models[app_label, model_name].fields
220         }
221 
222     def _generate_through_model_map(self):
223         """Through model map generation."""
224         for app_label, model_name in sorted(self.old_model_keys):
225             old_model_name = self.renamed_models.get((app_label, model_name), model_name)
226             old_model_state = self.from_state.models[app_label, old_model_name]
227             for field_name in old_model_state.fields:
228                 old_field = self.old_apps.get_model(app_label, old_model_name)._meta.get_field(field_name)
229                 if (hasattr(old_field, "remote_field") and getattr(old_field.remote_field, "through", None) and
230                         not old_field.remote_field.through._meta.auto_created):
231                     through_key = (
232                         old_field.remote_field.through._meta.app_label,
233                         old_field.remote_field.through._meta.model_name,
234                     )
235                     self.through_users[through_key] = (app_label, old_model_name, field_name)
236 
237     @staticmethod
238     def _resolve_dependency(dependency):
239         """
240         Return the resolved dependency and a boolean denoting whether or not
241         it was swappable.
242         """
243         if dependency[0] != '__setting__':
244             return dependency, False
245         resolved_app_label, resolved_object_name = getattr(settings, dependency[1]).split('.')
246         return (resolved_app_label, resolved_object_name.lower()) + dependency[2:], True
247 
248     def _build_migration_list(self, graph=None):
249         """
250         Chop the lists of operations up into migrations with dependencies on
251         each other. Do this by going through an app's list of operations until
252         one is found that has an outgoing dependency that isn't in another
253         app's migration yet (hasn't been chopped off its list). Then chop off
254         the operations before it into a migration and move onto the next app.
255         If the loops completes without doing anything, there's a circular
256         dependency (which _should_ be impossible as the operations are
257         all split at this point so they can't depend and be depended on).
258         """
259         self.migrations = {}
260         num_ops = sum(len(x) for x in self.generated_operations.values())
261         chop_mode = False
262         while num_ops:
263             # On every iteration, we step through all the apps and see if there
264             # is a completed set of operations.
265             # If we find that a subset of the operations are complete we can
266             # try to chop it off from the rest and continue, but we only
267             # do this if we've already been through the list once before
268             # without any chopping and nothing has changed.
269             for app_label in sorted(self.generated_operations):
270                 chopped = []
271                 dependencies = set()
272                 for operation in list(self.generated_operations[app_label]):
273                     deps_satisfied = True
274                     operation_dependencies = set()
275                     for dep in operation._auto_deps:
276                         # Temporarily resolve the swappable dependency to
277                         # prevent circular references. While keeping the
278                         # dependency checks on the resolved model, add the
279                         # swappable dependencies.
280                         original_dep = dep
281                         dep, is_swappable_dep = self._resolve_dependency(dep)
282                         if dep[0] != app_label:
283                             # External app dependency. See if it's not yet
284                             # satisfied.
285                             for other_operation in self.generated_operations.get(dep[0], []):
286                                 if self.check_dependency(other_operation, dep):
287                                     deps_satisfied = False
288                                     break
289                             if not deps_satisfied:
290                                 break
291                             else:
292                                 if is_swappable_dep:
293                                     operation_dependencies.add((original_dep[0], original_dep[1]))
294                                 elif dep[0] in self.migrations:
295                                     operation_dependencies.add((dep[0], self.migrations[dep[0]][-1].name))
296                                 else:
297                                     # If we can't find the other app, we add a first/last dependency,
298                                     # but only if we've already been through once and checked everything
299                                     if chop_mode:
300                                         # If the app already exists, we add a dependency on the last migration,
301                                         # as we don't know which migration contains the target field.
302                                         # If it's not yet migrated or has no migrations, we use __first__
303                                         if graph and graph.leaf_nodes(dep[0]):
304                                             operation_dependencies.add(graph.leaf_nodes(dep[0])[0])
305                                         else:
306                                             operation_dependencies.add((dep[0], "__first__"))
307                                     else:
308                                         deps_satisfied = False
309                     if deps_satisfied:
310                         chopped.append(operation)
311                         dependencies.update(operation_dependencies)
312                         del self.generated_operations[app_label][0]
313                     else:
314                         break
315                 # Make a migration! Well, only if there's stuff to put in it
316                 if dependencies or chopped:
317                     if not self.generated_operations[app_label] or chop_mode:
318                         subclass = type("Migration", (Migration,), {"operations": [], "dependencies": []})
319                         instance = subclass("auto_%i" % (len(self.migrations.get(app_label, [])) + 1), app_label)
320                         instance.dependencies = list(dependencies)
321                         instance.operations = chopped
322                         instance.initial = app_label not in self.existing_apps
323                         self.migrations.setdefault(app_label, []).append(instance)
324                         chop_mode = False
325                     else:
326                         self.generated_operations[app_label] = chopped + self.generated_operations[app_label]
327             new_num_ops = sum(len(x) for x in self.generated_operations.values())
328             if new_num_ops == num_ops:
329                 if not chop_mode:
330                     chop_mode = True
331                 else:
332                     raise ValueError("Cannot resolve operation dependencies: %r" % self.generated_operations)
333             num_ops = new_num_ops
334 
335     def _sort_migrations(self):
336         """
337         Reorder to make things possible. Reordering may be needed so FKs work
338         nicely inside the same app.
339         """
340         for app_label, ops in sorted(self.generated_operations.items()):
341             # construct a dependency graph for intra-app dependencies
342             dependency_graph = {op: set() for op in ops}
343             for op in ops:
344                 for dep in op._auto_deps:
345                     # Resolve intra-app dependencies to handle circular
346                     # references involving a swappable model.
347                     dep = self._resolve_dependency(dep)[0]
348                     if dep[0] == app_label:
349                         for op2 in ops:
350                             if self.check_dependency(op2, dep):
351                                 dependency_graph[op].add(op2)
352 
353             # we use a stable sort for deterministic tests & general behavior
354             self.generated_operations[app_label] = stable_topological_sort(ops, dependency_graph)
355 
356     def _optimize_migrations(self):
357         # Add in internal dependencies among the migrations
358         for app_label, migrations in self.migrations.items():
359             for m1, m2 in zip(migrations, migrations[1:]):
360                 m2.dependencies.append((app_label, m1.name))
361 
362         # De-dupe dependencies
363         for migrations in self.migrations.values():
364             for migration in migrations:
365                 migration.dependencies = list(set(migration.dependencies))
366 
367         # Optimize migrations
368         for app_label, migrations in self.migrations.items():
369             for migration in migrations:
370                 migration.operations = MigrationOptimizer().optimize(migration.operations, app_label)
371 
372     def check_dependency(self, operation, dependency):
373         """
374         Return True if the given operation depends on the given dependency,
375         False otherwise.
376         """
377         # Created model
378         if dependency[2] is None and dependency[3] is True:
379             return (
380                 isinstance(operation, operations.CreateModel) and
381                 operation.name_lower == dependency[1].lower()
382             )
383         # Created field
384         elif dependency[2] is not None and dependency[3] is True:
385             return (
386                 (
387                     isinstance(operation, operations.CreateModel) and
388                     operation.name_lower == dependency[1].lower() and
389                     any(dependency[2] == x for x, y in operation.fields)
390                 ) or
391                 (
392                     isinstance(operation, operations.AddField) and
393                     operation.model_name_lower == dependency[1].lower() and
394                     operation.name_lower == dependency[2].lower()
395                 )
396             )
397         # Removed field
398         elif dependency[2] is not None and dependency[3] is False:
399             return (
400                 isinstance(operation, operations.RemoveField) and
401                 operation.model_name_lower == dependency[1].lower() and
402                 operation.name_lower == dependency[2].lower()
403             )
404         # Removed model
405         elif dependency[2] is None and dependency[3] is False:
406             return (
407                 isinstance(operation, operations.DeleteModel) and
408                 operation.name_lower == dependency[1].lower()
409             )
410         # Field being altered
411         elif dependency[2] is not None and dependency[3] == "alter":
412             return (
413                 isinstance(operation, operations.AlterField) and
414                 operation.model_name_lower == dependency[1].lower() and
415                 operation.name_lower == dependency[2].lower()
416             )
417         # order_with_respect_to being unset for a field
418         elif dependency[2] is not None and dependency[3] == "order_wrt_unset":
419             return (
420                 isinstance(operation, operations.AlterOrderWithRespectTo) and
421                 operation.name_lower == dependency[1].lower() and
422                 (operation.order_with_respect_to or "").lower() != dependency[2].lower()
423             )
424         # Field is removed and part of an index/unique_together
425         elif dependency[2] is not None and dependency[3] == "foo_together_change":
426             return (
427                 isinstance(operation, (operations.AlterUniqueTogether,
428                                        operations.AlterIndexTogether)) and
429                 operation.name_lower == dependency[1].lower()
430             )
431         # Unknown dependency. Raise an error.
432         else:
433             raise ValueError("Can't handle dependency %r" % (dependency,))
434 
435     def add_operation(self, app_label, operation, dependencies=None, beginning=False):
436         # Dependencies are (app_label, model_name, field_name, create/delete as True/False)
437         operation._auto_deps = dependencies or []
438         if beginning:
439             self.generated_operations.setdefault(app_label, []).insert(0, operation)
440         else:
441             self.generated_operations.setdefault(app_label, []).append(operation)
442 
443     def swappable_first_key(self, item):
444         """
445         Place potential swappable models first in lists of created models (only
446         real way to solve #22783).
447         """
448         try:
449             model = self.new_apps.get_model(item[0], item[1])
450             base_names = [base.__name__ for base in model.__bases__]
451             string_version = "%s.%s" % (item[0], item[1])
452             if (
453                 model._meta.swappable or
454                 "AbstractUser" in base_names or
455                 "AbstractBaseUser" in base_names or
456                 settings.AUTH_USER_MODEL.lower() == string_version.lower()
457             ):
458                 return ("___" + item[0], "___" + item[1])
459         except LookupError:
460             pass
461         return item
462 
463     def generate_renamed_models(self):
464         """
465         Find any renamed models, generate the operations for them, and remove
466         the old entry from the model lists. Must be run before other
467         model-level generation.
468         """
469         self.renamed_models = {}
470         self.renamed_models_rel = {}
471         added_models = self.new_model_keys - self.old_model_keys
472         for app_label, model_name in sorted(added_models):
473             model_state = self.to_state.models[app_label, model_name]
474             model_fields_def = self.only_relation_agnostic_fields(model_state.fields)
475 
476             removed_models = self.old_model_keys - self.new_model_keys
477             for rem_app_label, rem_model_name in removed_models:
478                 if rem_app_label == app_label:
479                     rem_model_state = self.from_state.models[rem_app_label, rem_model_name]
480                     rem_model_fields_def = self.only_relation_agnostic_fields(rem_model_state.fields)
481                     if model_fields_def == rem_model_fields_def:
482                         if self.questioner.ask_rename_model(rem_model_state, model_state):
483                             model_opts = self.new_apps.get_model(app_label, model_name)._meta
484                             dependencies = []
485                             for field in model_opts.get_fields():
486                                 if field.is_relation:
487                                     dependencies.extend(self._get_dependencies_for_foreign_key(field))
488                             self.add_operation(
489                                 app_label,
490                                 operations.RenameModel(
491                                     old_name=rem_model_state.name,
492                                     new_name=model_state.name,
493                                 ),
494                                 dependencies=dependencies,
495                             )
496                             self.renamed_models[app_label, model_name] = rem_model_name
497                             renamed_models_rel_key = '%s.%s' % (
498                                 rem_model_state.app_label,
499                                 rem_model_state.name_lower,
500                             )
501                             self.renamed_models_rel[renamed_models_rel_key] = '%s.%s' % (
502                                 model_state.app_label,
503                                 model_state.name_lower,
504                             )
505                             self.old_model_keys.remove((rem_app_label, rem_model_name))
506                             self.old_model_keys.add((app_label, model_name))
507                             break
508 
509     def generate_created_models(self):
510         """
511         Find all new models (both managed and unmanaged) and make create
512         operations for them as well as separate operations to create any
513         foreign key or M2M relationships (these are optimized later, if
514         possible).
515 
516         Defer any model options that refer to collections of fields that might
517         be deferred (e.g. unique_together, index_together).
518         """
519         old_keys = self.old_model_keys | self.old_unmanaged_keys
520         added_models = self.new_model_keys - old_keys
521         added_unmanaged_models = self.new_unmanaged_keys - old_keys
522         all_added_models = chain(
523             sorted(added_models, key=self.swappable_first_key, reverse=True),
524             sorted(added_unmanaged_models, key=self.swappable_first_key, reverse=True)
525         )
526         for app_label, model_name in all_added_models:
527             model_state = self.to_state.models[app_label, model_name]
528             model_opts = self.new_apps.get_model(app_label, model_name)._meta
529             # Gather related fields
530             related_fields = {}
531             primary_key_rel = None
532             for field in model_opts.local_fields:
533                 if field.remote_field:
534                     if field.remote_field.model:
535                         if field.primary_key:
536                             primary_key_rel = field.remote_field.model
537                         elif not field.remote_field.parent_link:
538                             related_fields[field.name] = field
539                     # through will be none on M2Ms on swapped-out models;
540                     # we can treat lack of through as auto_created=True, though.
541                     if (getattr(field.remote_field, "through", None) and
542                             not field.remote_field.through._meta.auto_created):
543                         related_fields[field.name] = field
544             for field in model_opts.local_many_to_many:
545                 if field.remote_field.model:
546                     related_fields[field.name] = field
547                 if getattr(field.remote_field, "through", None) and not field.remote_field.through._meta.auto_created:
548                     related_fields[field.name] = field
549             # Are there indexes/unique|index_together to defer?
550             indexes = model_state.options.pop('indexes')
551             constraints = model_state.options.pop('constraints')
552             unique_together = model_state.options.pop('unique_together', None)
553             index_together = model_state.options.pop('index_together', None)
554             order_with_respect_to = model_state.options.pop('order_with_respect_to', None)
555             # Depend on the deletion of any possible proxy version of us
556             dependencies = [
557                 (app_label, model_name, None, False),
558             ]
559             # Depend on all bases
560             for base in model_state.bases:
561                 if isinstance(base, str) and "." in base:
562                     base_app_label, base_name = base.split(".", 1)
563                     dependencies.append((base_app_label, base_name, None, True))
564                     # Depend on the removal of base fields if the new model has
565                     # a field with the same name.
566                     old_base_model_state = self.from_state.models.get((base_app_label, base_name))
567                     new_base_model_state = self.to_state.models.get((base_app_label, base_name))
568                     if old_base_model_state and new_base_model_state:
569                         removed_base_fields = set(old_base_model_state.fields).difference(
570                             new_base_model_state.fields,
571                         ).intersection(model_state.fields)
572                         for removed_base_field in removed_base_fields:
573                             dependencies.append((base_app_label, base_name, removed_base_field, False))
574             # Depend on the other end of the primary key if it's a relation
575             if primary_key_rel:
576                 dependencies.append((
577                     primary_key_rel._meta.app_label,
578                     primary_key_rel._meta.object_name,
579                     None,
580                     True
581                 ))
582             # Generate creation operation
583             self.add_operation(
584                 app_label,
585                 operations.CreateModel(
586                     name=model_state.name,
587                     fields=[d for d in model_state.fields.items() if d[0] not in related_fields],
588                     options=model_state.options,
589                     bases=model_state.bases,
590                     managers=model_state.managers,
591                 ),
592                 dependencies=dependencies,
593                 beginning=True,
594             )
595 
596             # Don't add operations which modify the database for unmanaged models
597             if not model_opts.managed:
598                 continue
599 
600             # Generate operations for each related field
601             for name, field in sorted(related_fields.items()):
602                 dependencies = self._get_dependencies_for_foreign_key(field)
603                 # Depend on our own model being created
604                 dependencies.append((app_label, model_name, None, True))
605                 # Make operation
606                 self.add_operation(
607                     app_label,
608                     operations.AddField(
609                         model_name=model_name,
610                         name=name,
611                         field=field,
612                     ),
613                     dependencies=list(set(dependencies)),
614                 )
615             # Generate other opns
616             if order_with_respect_to:
617                 self.add_operation(
618                     app_label,
619                     operations.AlterOrderWithRespectTo(
620                         name=model_name,
621                         order_with_respect_to=order_with_respect_to,
622                     ),
623                     dependencies=[
624                         (app_label, model_name, order_with_respect_to, True),
625                         (app_label, model_name, None, True),
626                     ]
627                 )
628             related_dependencies = [
629                 (app_label, model_name, name, True)
630                 for name in sorted(related_fields)
631             ]
632             related_dependencies.append((app_label, model_name, None, True))
633             for index in indexes:
634                 self.add_operation(
635                     app_label,
636                     operations.AddIndex(
637                         model_name=model_name,
638                         index=index,
639                     ),
640                     dependencies=related_dependencies,
641                 )
642             for constraint in constraints:
643                 self.add_operation(
644                     app_label,
645                     operations.AddConstraint(
646                         model_name=model_name,
647                         constraint=constraint,
648                     ),
649                     dependencies=related_dependencies,
650                 )
651             if unique_together:
652                 self.add_operation(
653                     app_label,
654                     operations.AlterUniqueTogether(
655                         name=model_name,
656                         unique_together=unique_together,
657                     ),
658                     dependencies=related_dependencies
659                 )
660             if index_together:
661                 self.add_operation(
662                     app_label,
663                     operations.AlterIndexTogether(
664                         name=model_name,
665                         index_together=index_together,
666                     ),
667                     dependencies=related_dependencies
668                 )
669             # Fix relationships if the model changed from a proxy model to a
670             # concrete model.
671             if (app_label, model_name) in self.old_proxy_keys:
672                 for related_object in model_opts.related_objects:
673                     self.add_operation(
674                         related_object.related_model._meta.app_label,
675                         operations.AlterField(
676                             model_name=related_object.related_model._meta.object_name,
677                             name=related_object.field.name,
678                             field=related_object.field,
679                         ),
680                         dependencies=[(app_label, model_name, None, True)],
681                     )
682 
683     def generate_created_proxies(self):
684         """
685         Make CreateModel statements for proxy models. Use the same statements
686         as that way there's less code duplication, but for proxy models it's
687         safe to skip all the pointless field stuff and chuck out an operation.
688         """
689         added = self.new_proxy_keys - self.old_proxy_keys
690         for app_label, model_name in sorted(added):
691             model_state = self.to_state.models[app_label, model_name]
692             assert model_state.options.get("proxy")
693             # Depend on the deletion of any possible non-proxy version of us
694             dependencies = [
695                 (app_label, model_name, None, False),
696             ]
697             # Depend on all bases
698             for base in model_state.bases:
699                 if isinstance(base, str) and "." in base:
700                     base_app_label, base_name = base.split(".", 1)
701                     dependencies.append((base_app_label, base_name, None, True))
702             # Generate creation operation
703             self.add_operation(
704                 app_label,
705                 operations.CreateModel(
706                     name=model_state.name,
707                     fields=[],
708                     options=model_state.options,
709                     bases=model_state.bases,
710                     managers=model_state.managers,
711                 ),
712                 # Depend on the deletion of any possible non-proxy version of us
713                 dependencies=dependencies,
714             )
715 
716     def generate_deleted_models(self):
717         """
718         Find all deleted models (managed and unmanaged) and make delete
719         operations for them as well as separate operations to delete any
720         foreign key or M2M relationships (these are optimized later, if
721         possible).
722 
723         Also bring forward removal of any model options that refer to
724         collections of fields - the inverse of generate_created_models().
725         """
726         new_keys = self.new_model_keys | self.new_unmanaged_keys
727         deleted_models = self.old_model_keys - new_keys
728         deleted_unmanaged_models = self.old_unmanaged_keys - new_keys
729         all_deleted_models = chain(sorted(deleted_models), sorted(deleted_unmanaged_models))
730         for app_label, model_name in all_deleted_models:
731             model_state = self.from_state.models[app_label, model_name]
732             model = self.old_apps.get_model(app_label, model_name)
733             # Gather related fields
734             related_fields = {}
735             for field in model._meta.local_fields:
736                 if field.remote_field:
737                     if field.remote_field.model:
738                         related_fields[field.name] = field
739                     # through will be none on M2Ms on swapped-out models;
740                     # we can treat lack of through as auto_created=True, though.
741                     if (getattr(field.remote_field, "through", None) and
742                             not field.remote_field.through._meta.auto_created):
743                         related_fields[field.name] = field
744             for field in model._meta.local_many_to_many:
745                 if field.remote_field.model:
746                     related_fields[field.name] = field
747                 if getattr(field.remote_field, "through", None) and not field.remote_field.through._meta.auto_created:
748                     related_fields[field.name] = field
749             # Generate option removal first
750             unique_together = model_state.options.pop('unique_together', None)
751             index_together = model_state.options.pop('index_together', None)
752             if unique_together:
753                 self.add_operation(
754                     app_label,
755                     operations.AlterUniqueTogether(
756                         name=model_name,
757                         unique_together=None,
758                     )
759                 )
760             if index_together:
761                 self.add_operation(
762                     app_label,
763                     operations.AlterIndexTogether(
764                         name=model_name,
765                         index_together=None,
766                     )
767                 )
768             # Then remove each related field
769             for name in sorted(related_fields):
770                 self.add_operation(
771                     app_label,
772                     operations.RemoveField(
773                         model_name=model_name,
774                         name=name,
775                     )
776                 )
777             # Finally, remove the model.
778             # This depends on both the removal/alteration of all incoming fields
779             # and the removal of all its own related fields, and if it's
780             # a through model the field that references it.
781             dependencies = []
782             for related_object in model._meta.related_objects:
783                 related_object_app_label = related_object.related_model._meta.app_label
784                 object_name = related_object.related_model._meta.object_name
785                 field_name = related_object.field.name
786                 dependencies.append((related_object_app_label, object_name, field_name, False))
787                 if not related_object.many_to_many:
788                     dependencies.append((related_object_app_label, object_name, field_name, "alter"))
789 
790             for name in sorted(related_fields):
791                 dependencies.append((app_label, model_name, name, False))
792             # We're referenced in another field's through=
793             through_user = self.through_users.get((app_label, model_state.name_lower))
794             if through_user:
795                 dependencies.append((through_user[0], through_user[1], through_user[2], False))
796             # Finally, make the operation, deduping any dependencies
797             self.add_operation(
798                 app_label,
799                 operations.DeleteModel(
800                     name=model_state.name,
801                 ),
802                 dependencies=list(set(dependencies)),
803             )
804 
805     def generate_deleted_proxies(self):
806         """Make DeleteModel options for proxy models."""
807         deleted = self.old_proxy_keys - self.new_proxy_keys
808         for app_label, model_name in sorted(deleted):
809             model_state = self.from_state.models[app_label, model_name]
810             assert model_state.options.get("proxy")
811             self.add_operation(
812                 app_label,
813                 operations.DeleteModel(
814                     name=model_state.name,
815                 ),
816             )
817 
818     def generate_renamed_fields(self):
819         """Work out renamed fields."""
820         self.renamed_fields = {}
821         for app_label, model_name, field_name in sorted(self.new_field_keys - self.old_field_keys):
822             old_model_name = self.renamed_models.get((app_label, model_name), model_name)
823             old_model_state = self.from_state.models[app_label, old_model_name]
824             field = self.new_apps.get_model(app_label, model_name)._meta.get_field(field_name)
825             # Scan to see if this is actually a rename!
826             field_dec = self.deep_deconstruct(field)
827             for rem_app_label, rem_model_name, rem_field_name in sorted(self.old_field_keys - self.new_field_keys):
828                 if rem_app_label == app_label and rem_model_name == model_name:
829                     old_field = old_model_state.fields[rem_field_name]
830                     old_field_dec = self.deep_deconstruct(old_field)
831                     if field.remote_field and field.remote_field.model and 'to' in old_field_dec[2]:
832                         old_rel_to = old_field_dec[2]['to']
833                         if old_rel_to in self.renamed_models_rel:
834                             old_field_dec[2]['to'] = self.renamed_models_rel[old_rel_to]
835                     old_field.set_attributes_from_name(rem_field_name)
836                     old_db_column = old_field.get_attname_column()[1]
837                     if (old_field_dec == field_dec or (
838                             # Was the field renamed and db_column equal to the
839                             # old field's column added?
840                             old_field_dec[0:2] == field_dec[0:2] and
841                             dict(old_field_dec[2], db_column=old_db_column) == field_dec[2])):
842                         if self.questioner.ask_rename(model_name, rem_field_name, field_name, field):
843                             self.add_operation(
844                                 app_label,
845                                 operations.RenameField(
846                                     model_name=model_name,
847                                     old_name=rem_field_name,
848                                     new_name=field_name,
849                                 )
850                             )
851                             self.old_field_keys.remove((rem_app_label, rem_model_name, rem_field_name))
852                             self.old_field_keys.add((app_label, model_name, field_name))
853                             self.renamed_fields[app_label, model_name, field_name] = rem_field_name
854                             break
855 
856     def generate_added_fields(self):
857         """Make AddField operations."""
858         for app_label, model_name, field_name in sorted(self.new_field_keys - self.old_field_keys):
859             self._generate_added_field(app_label, model_name, field_name)
860 
861     def _generate_added_field(self, app_label, model_name, field_name):
862         field = self.new_apps.get_model(app_label, model_name)._meta.get_field(field_name)
863         # Fields that are foreignkeys/m2ms depend on stuff
864         dependencies = []
865         if field.remote_field and field.remote_field.model:
866             dependencies.extend(self._get_dependencies_for_foreign_key(field))
867         # You can't just add NOT NULL fields with no default or fields
868         # which don't allow empty strings as default.
869         time_fields = (models.DateField, models.DateTimeField, models.TimeField)
870         preserve_default = (
871             field.null or field.has_default() or field.many_to_many or
872             (field.blank and field.empty_strings_allowed) or
873             (isinstance(field, time_fields) and field.auto_now)
874         )
875         if not preserve_default:
876             field = field.clone()
877             if isinstance(field, time_fields) and field.auto_now_add:
878                 field.default = self.questioner.ask_auto_now_add_addition(field_name, model_name)
879             else:
880                 field.default = self.questioner.ask_not_null_addition(field_name, model_name)
881         self.add_operation(
882             app_label,
883             operations.AddField(
884                 model_name=model_name,
885                 name=field_name,
886                 field=field,
887                 preserve_default=preserve_default,
888             ),
889             dependencies=dependencies,
890         )
891 
892     def generate_removed_fields(self):
893         """Make RemoveField operations."""
894         for app_label, model_name, field_name in sorted(self.old_field_keys - self.new_field_keys):
895             self._generate_removed_field(app_label, model_name, field_name)
896 
897     def _generate_removed_field(self, app_label, model_name, field_name):
898         self.add_operation(
899             app_label,
900             operations.RemoveField(
901                 model_name=model_name,
902                 name=field_name,
903             ),
904             # We might need to depend on the removal of an
905             # order_with_respect_to or index/unique_together operation;
906             # this is safely ignored if there isn't one
907             dependencies=[
908                 (app_label, model_name, field_name, "order_wrt_unset"),
909                 (app_label, model_name, field_name, "foo_together_change"),
910             ],
911         )
912 
913     def generate_altered_fields(self):
914         """
915         Make AlterField operations, or possibly RemovedField/AddField if alter
916         isn's possible.
917         """
918         for app_label, model_name, field_name in sorted(self.old_field_keys & self.new_field_keys):
919             # Did the field change?
920             old_model_name = self.renamed_models.get((app_label, model_name), model_name)
921             old_field_name = self.renamed_fields.get((app_label, model_name, field_name), field_name)
922             old_field = self.old_apps.get_model(app_label, old_model_name)._meta.get_field(old_field_name)
923             new_field = self.new_apps.get_model(app_label, model_name)._meta.get_field(field_name)
924             dependencies = []
925             # Implement any model renames on relations; these are handled by RenameModel
926             # so we need to exclude them from the comparison
927             if hasattr(new_field, "remote_field") and getattr(new_field.remote_field, "model", None):
928                 rename_key = (
929                     new_field.remote_field.model._meta.app_label,
930                     new_field.remote_field.model._meta.model_name,
931                 )
932                 if rename_key in self.renamed_models:
933                     new_field.remote_field.model = old_field.remote_field.model
934                 # Handle ForeignKey which can only have a single to_field.
935                 remote_field_name = getattr(new_field.remote_field, 'field_name', None)
936                 if remote_field_name:
937                     to_field_rename_key = rename_key + (remote_field_name,)
938                     if to_field_rename_key in self.renamed_fields:
939                         # Repoint both model and field name because to_field
940                         # inclusion in ForeignKey.deconstruct() is based on
941                         # both.
942                         new_field.remote_field.model = old_field.remote_field.model
943                         new_field.remote_field.field_name = old_field.remote_field.field_name
944                 # Handle ForeignObjects which can have multiple from_fields/to_fields.
945                 from_fields = getattr(new_field, 'from_fields', None)
946                 if from_fields:
947                     from_rename_key = (app_label, model_name)
948                     new_field.from_fields = tuple([
949                         self.renamed_fields.get(from_rename_key + (from_field,), from_field)
950                         for from_field in from_fields
951                     ])
952                     new_field.to_fields = tuple([
953                         self.renamed_fields.get(rename_key + (to_field,), to_field)
954                         for to_field in new_field.to_fields
955                     ])
956                 dependencies.extend(self._get_dependencies_for_foreign_key(new_field))
957             if hasattr(new_field, "remote_field") and getattr(new_field.remote_field, "through", None):
958                 rename_key = (
959                     new_field.remote_field.through._meta.app_label,
960                     new_field.remote_field.through._meta.model_name,
961                 )
962                 if rename_key in self.renamed_models:
963                     new_field.remote_field.through = old_field.remote_field.through
964             old_field_dec = self.deep_deconstruct(old_field)
965             new_field_dec = self.deep_deconstruct(new_field)
966             if old_field_dec != new_field_dec:
967                 both_m2m = old_field.many_to_many and new_field.many_to_many
968                 neither_m2m = not old_field.many_to_many and not new_field.many_to_many
969                 if both_m2m or neither_m2m:
970                     # Either both fields are m2m or neither is
971                     preserve_default = True
972                     if (old_field.null and not new_field.null and not new_field.has_default() and
973                             not new_field.many_to_many):
974                         field = new_field.clone()
975                         new_default = self.questioner.ask_not_null_alteration(field_name, model_name)
976                         if new_default is not models.NOT_PROVIDED:
977                             field.default = new_default
978                             preserve_default = False
979                     else:
980                         field = new_field
981                     self.add_operation(
982                         app_label,
983                         operations.AlterField(
984                             model_name=model_name,
985                             name=field_name,
986                             field=field,
987                             preserve_default=preserve_default,
988                         ),
989                         dependencies=dependencies,
990                     )
991                 else:
992                     # We cannot alter between m2m and concrete fields
993                     self._generate_removed_field(app_label, model_name, field_name)
994                     self._generate_added_field(app_label, model_name, field_name)
995 
996     def create_altered_indexes(self):
997         option_name = operations.AddIndex.option_name
998         for app_label, model_name in sorted(self.kept_model_keys):
999             old_model_name = self.renamed_models.get((app_label, model_name), model_name)
1000             old_model_state = self.from_state.models[app_label, old_model_name]
1001             new_model_state = self.to_state.models[app_label, model_name]
1002 
1003             old_indexes = old_model_state.options[option_name]
1004             new_indexes = new_model_state.options[option_name]
1005             add_idx = [idx for idx in new_indexes if idx not in old_indexes]
1006             rem_idx = [idx for idx in old_indexes if idx not in new_indexes]
1007 
1008             self.altered_indexes.update({
1009                 (app_label, model_name): {
1010                     'added_indexes': add_idx, 'removed_indexes': rem_idx,
1011                 }
1012             })
1013 
1014     def generate_added_indexes(self):
1015         for (app_label, model_name), alt_indexes in self.altered_indexes.items():
1016             for index in alt_indexes['added_indexes']:
1017                 self.add_operation(
1018                     app_label,
1019                     operations.AddIndex(
1020                         model_name=model_name,
1021                         index=index,
1022                     )
1023                 )
1024 
1025     def generate_removed_indexes(self):
1026         for (app_label, model_name), alt_indexes in self.altered_indexes.items():
1027             for index in alt_indexes['removed_indexes']:
1028                 self.add_operation(
1029                     app_label,
1030                     operations.RemoveIndex(
1031                         model_name=model_name,
1032                         name=index.name,
1033                     )
1034                 )
1035 
1036     def create_altered_constraints(self):
1037         option_name = operations.AddConstraint.option_name
1038         for app_label, model_name in sorted(self.kept_model_keys):
1039             old_model_name = self.renamed_models.get((app_label, model_name), model_name)
1040             old_model_state = self.from_state.models[app_label, old_model_name]
1041             new_model_state = self.to_state.models[app_label, model_name]
1042 
1043             old_constraints = old_model_state.options[option_name]
1044             new_constraints = new_model_state.options[option_name]
1045             add_constraints = [c for c in new_constraints if c not in old_constraints]
1046             rem_constraints = [c for c in old_constraints if c not in new_constraints]
1047 
1048             self.altered_constraints.update({
1049                 (app_label, model_name): {
1050                     'added_constraints': add_constraints, 'removed_constraints': rem_constraints,
1051                 }
1052             })
1053 
1054     def generate_added_constraints(self):
1055         for (app_label, model_name), alt_constraints in self.altered_constraints.items():
1056             for constraint in alt_constraints['added_constraints']:
1057                 self.add_operation(
1058                     app_label,
1059                     operations.AddConstraint(
1060                         model_name=model_name,
1061                         constraint=constraint,
1062                     )
1063                 )
1064 
1065     def generate_removed_constraints(self):
1066         for (app_label, model_name), alt_constraints in self.altered_constraints.items():
1067             for constraint in alt_constraints['removed_constraints']:
1068                 self.add_operation(
1069                     app_label,
1070                     operations.RemoveConstraint(
1071                         model_name=model_name,
1072                         name=constraint.name,
1073                     )
1074                 )
1075 
1076     def _get_dependencies_for_foreign_key(self, field):
1077         # Account for FKs to swappable models
1078         swappable_setting = getattr(field, 'swappable_setting', None)
1079         if swappable_setting is not None:
1080             dep_app_label = "__setting__"
1081             dep_object_name = swappable_setting
1082         else:
1083             dep_app_label = field.remote_field.model._meta.app_label
1084             dep_object_name = field.remote_field.model._meta.object_name
1085         dependencies = [(dep_app_label, dep_object_name, None, True)]
1086         if getattr(field.remote_field, "through", None) and not field.remote_field.through._meta.auto_created:
1087             dependencies.append((
1088                 field.remote_field.through._meta.app_label,
1089                 field.remote_field.through._meta.object_name,
1090                 None,
1091                 True,
1092             ))
1093         return dependencies
1094 
1095     def _generate_altered_foo_together(self, operation):
1096         option_name = operation.option_name
1097         for app_label, model_name in sorted(self.kept_model_keys):
1098             old_model_name = self.renamed_models.get((app_label, model_name), model_name)
1099             old_model_state = self.from_state.models[app_label, old_model_name]
1100             new_model_state = self.to_state.models[app_label, model_name]
1101 
1102             # We run the old version through the field renames to account for those
1103             old_value = old_model_state.options.get(option_name)
1104             old_value = {
1105                 tuple(
1106                     self.renamed_fields.get((app_label, model_name, n), n)
1107                     for n in unique
1108                 )
1109                 for unique in old_value
1110             } if old_value else set()
1111 
1112             new_value = new_model_state.options.get(option_name)
1113             new_value = set(new_value) if new_value else set()
1114 
1115             if old_value != new_value:
1116                 dependencies = []
1117                 for foo_togethers in new_value:
1118                     for field_name in foo_togethers:
1119                         field = self.new_apps.get_model(app_label, model_name)._meta.get_field(field_name)
1120                         if field.remote_field and field.remote_field.model:
1121                             dependencies.extend(self._get_dependencies_for_foreign_key(field))
1122 
1123                 self.add_operation(
1124                     app_label,
1125                     operation(
1126                         name=model_name,
1127                         **{option_name: new_value}
1128                     ),
1129                     dependencies=dependencies,
1130                 )
1131 
1132     def generate_altered_unique_together(self):
1133         self._generate_altered_foo_together(operations.AlterUniqueTogether)
1134 
1135     def generate_altered_index_together(self):
1136         self._generate_altered_foo_together(operations.AlterIndexTogether)
1137 
1138     def generate_altered_db_table(self):
1139         models_to_check = self.kept_model_keys.union(self.kept_proxy_keys, self.kept_unmanaged_keys)
1140         for app_label, model_name in sorted(models_to_check):
1141             old_model_name = self.renamed_models.get((app_label, model_name), model_name)
1142             old_model_state = self.from_state.models[app_label, old_model_name]
1143             new_model_state = self.to_state.models[app_label, model_name]
1144             old_db_table_name = old_model_state.options.get('db_table')
1145             new_db_table_name = new_model_state.options.get('db_table')
1146             if old_db_table_name != new_db_table_name:
1147                 self.add_operation(
1148                     app_label,
1149                     operations.AlterModelTable(
1150                         name=model_name,
1151                         table=new_db_table_name,
1152                     )
1153                 )
1154 
1155     def generate_altered_options(self):
1156         """
1157         Work out if any non-schema-affecting options have changed and make an
1158         operation to represent them in state changes (in case Python code in
1159         migrations needs them).
1160         """
1161         models_to_check = self.kept_model_keys.union(
1162             self.kept_proxy_keys,
1163             self.kept_unmanaged_keys,
1164             # unmanaged converted to managed
1165             self.old_unmanaged_keys & self.new_model_keys,
1166             # managed converted to unmanaged
1167             self.old_model_keys & self.new_unmanaged_keys,
1168         )
1169 
1170         for app_label, model_name in sorted(models_to_check):
1171             old_model_name = self.renamed_models.get((app_label, model_name), model_name)
1172             old_model_state = self.from_state.models[app_label, old_model_name]
1173             new_model_state = self.to_state.models[app_label, model_name]
1174             old_options = {
1175                 key: value for key, value in old_model_state.options.items()
1176                 if key in AlterModelOptions.ALTER_OPTION_KEYS
1177             }
1178             new_options = {
1179                 key: value for key, value in new_model_state.options.items()
1180                 if key in AlterModelOptions.ALTER_OPTION_KEYS
1181             }
1182             if old_options != new_options:
1183                 self.add_operation(
1184                     app_label,
1185                     operations.AlterModelOptions(
1186                         name=model_name,
1187                         options=new_options,
1188                     )
1189                 )
1190 
1191     def generate_altered_order_with_respect_to(self):
1192         for app_label, model_name in sorted(self.kept_model_keys):
1193             old_model_name = self.renamed_models.get((app_label, model_name), model_name)
1194             old_model_state = self.from_state.models[app_label, old_model_name]
1195             new_model_state = self.to_state.models[app_label, model_name]
1196             if (old_model_state.options.get("order_with_respect_to") !=
1197                     new_model_state.options.get("order_with_respect_to")):
1198                 # Make sure it comes second if we're adding
1199                 # (removal dependency is part of RemoveField)
1200                 dependencies = []
1201                 if new_model_state.options.get("order_with_respect_to"):
1202                     dependencies.append((
1203                         app_label,
1204                         model_name,
1205                         new_model_state.options["order_with_respect_to"],
1206                         True,
1207                     ))
1208                 # Actually generate the operation
1209                 self.add_operation(
1210                     app_label,
1211                     operations.AlterOrderWithRespectTo(
1212                         name=model_name,
1213                         order_with_respect_to=new_model_state.options.get('order_with_respect_to'),
1214                     ),
1215                     dependencies=dependencies,
1216                 )
1217 
1218     def generate_altered_managers(self):
1219         for app_label, model_name in sorted(self.kept_model_keys):
1220             old_model_name = self.renamed_models.get((app_label, model_name), model_name)
1221             old_model_state = self.from_state.models[app_label, old_model_name]
1222             new_model_state = self.to_state.models[app_label, model_name]
1223             if old_model_state.managers != new_model_state.managers:
1224                 self.add_operation(
1225                     app_label,
1226                     operations.AlterModelManagers(
1227                         name=model_name,
1228                         managers=new_model_state.managers,
1229                     )
1230                 )
1231 
1232     def arrange_for_graph(self, changes, graph, migration_name=None):
1233         """
1234         Take a result from changes() and a MigrationGraph, and fix the names
1235         and dependencies of the changes so they extend the graph from the leaf
1236         nodes for each app.
1237         """
1238         leaves = graph.leaf_nodes()
1239         name_map = {}
1240         for app_label, migrations in list(changes.items()):
1241             if not migrations:
1242                 continue
1243             # Find the app label's current leaf node
1244             app_leaf = None
1245             for leaf in leaves:
1246                 if leaf[0] == app_label:
1247                     app_leaf = leaf
1248                     break
1249             # Do they want an initial migration for this app?
1250             if app_leaf is None and not self.questioner.ask_initial(app_label):
1251                 # They don't.
1252                 for migration in migrations:
1253                     name_map[(app_label, migration.name)] = (app_label, "__first__")
1254                 del changes[app_label]
1255                 continue
1256             # Work out the next number in the sequence
1257             if app_leaf is None:
1258                 next_number = 1
1259             else:
1260                 next_number = (self.parse_number(app_leaf[1]) or 0) + 1
1261             # Name each migration
1262             for i, migration in enumerate(migrations):
1263                 if i == 0 and app_leaf:
1264                     migration.dependencies.append(app_leaf)
1265                 new_name_parts = ['%04i' % next_number]
1266                 if migration_name:
1267                     new_name_parts.append(migration_name)
1268                 elif i == 0 and not app_leaf:
1269                     new_name_parts.append('initial')
1270                 else:
1271                     new_name_parts.append(migration.suggest_name()[:100])
1272                 new_name = '_'.join(new_name_parts)
1273                 name_map[(app_label, migration.name)] = (app_label, new_name)
1274                 next_number += 1
1275                 migration.name = new_name
1276         # Now fix dependencies
1277         for migrations in changes.values():
1278             for migration in migrations:
1279                 migration.dependencies = [name_map.get(d, d) for d in migration.dependencies]
1280         return changes
1281 
1282     def _trim_to_apps(self, changes, app_labels):
1283         """
1284         Take changes from arrange_for_graph() and set of app labels, and return
1285         a modified set of changes which trims out as many migrations that are
1286         not in app_labels as possible. Note that some other migrations may
1287         still be present as they may be required dependencies.
1288         """
1289         # Gather other app dependencies in a first pass
1290         app_dependencies = {}
1291         for app_label, migrations in changes.items():
1292             for migration in migrations:
1293                 for dep_app_label, name in migration.dependencies:
1294                     app_dependencies.setdefault(app_label, set()).add(dep_app_label)
1295         required_apps = set(app_labels)
1296         # Keep resolving till there's no change
1297         old_required_apps = None
1298         while old_required_apps != required_apps:
1299             old_required_apps = set(required_apps)
1300             required_apps.update(*[app_dependencies.get(app_label, ()) for app_label in required_apps])
1301         # Remove all migrations that aren't needed
1302         for app_label in list(changes):
1303             if app_label not in required_apps:
1304                 del changes[app_label]
1305         return changes
1306 
1307     @classmethod
1308     def parse_number(cls, name):
1309         """
1310         Given a migration name, try to extract a number from the beginning of
1311         it. If no number is found, return None.
1312         """
1313         match = re.match(r'^\d+', name)
1314         if match:
1315             return int(match[0])
1316         return None

</code><intended_behavior>Enhance the logic to correctly handle models with the same name across different apps especially when they reference each other through `ManyToManyField`. This includes ensuring that the `related_name` attribute does not cause conflicts during migration generation, even when set to `'+'`, which is supposed to prevent the reverse relation.</intended_behavior>, <file>django/db/models/fields/related.py</file>
<class>None</class>
<method>None</method>
<code>
1 import functools
2 import inspect
3 from functools import partial
4 
5 from django import forms
6 from django.apps import apps
7 from django.conf import SettingsReference, settings
8 from django.core import checks, exceptions
9 from django.db import connection, router
10 from django.db.backends import utils
11 from django.db.models import Q
12 from django.db.models.constants import LOOKUP_SEP
13 from django.db.models.deletion import CASCADE, SET_DEFAULT, SET_NULL
14 from django.db.models.query_utils import PathInfo
15 from django.db.models.utils import make_model_tuple
16 from django.utils.functional import cached_property
17 from django.utils.translation import gettext_lazy as _
18 
19 from . import Field
20 from .mixins import FieldCacheMixin
21 from .related_descriptors import (
22     ForeignKeyDeferredAttribute, ForwardManyToOneDescriptor,
23     ForwardOneToOneDescriptor, ManyToManyDescriptor,
24     ReverseManyToOneDescriptor, ReverseOneToOneDescriptor,
25 )
26 from .related_lookups import (
27     RelatedExact, RelatedGreaterThan, RelatedGreaterThanOrEqual, RelatedIn,
28     RelatedIsNull, RelatedLessThan, RelatedLessThanOrEqual,
29 )
30 from .reverse_related import (
31     ForeignObjectRel, ManyToManyRel, ManyToOneRel, OneToOneRel,
32 )
33 
34 RECURSIVE_RELATIONSHIP_CONSTANT = 'self'
35 
36 
37 def resolve_relation(scope_model, relation):
38     """
39     Transform relation into a model or fully-qualified model string of the form
40     "app_label.ModelName", relative to scope_model.
41 
42     The relation argument can be:
43       * RECURSIVE_RELATIONSHIP_CONSTANT, i.e. the string "self", in which case
44         the model argument will be returned.
45       * A bare model name without an app_label, in which case scope_model's
46         app_label will be prepended.
47       * An "app_label.ModelName" string.
48       * A model class, which will be returned unchanged.
49     """
50     # Check for recursive relations
51     if relation == RECURSIVE_RELATIONSHIP_CONSTANT:
52         relation = scope_model
53 
54     # Look for an "app.Model" relation
55     if isinstance(relation, str):
56         if "." not in relation:
57             relation = "%s.%s" % (scope_model._meta.app_label, relation)
58 
59     return relation
60 
61 
62 def lazy_related_operation(function, model, *related_models, **kwargs):
63     """
64     Schedule `function` to be called once `model` and all `related_models`
65     have been imported and registered with the app registry. `function` will
66     be called with the newly-loaded model classes as its positional arguments,
67     plus any optional keyword arguments.
68 
69     The `model` argument must be a model class. Each subsequent positional
70     argument is another model, or a reference to another model - see
71     `resolve_relation()` for the various forms these may take. Any relative
72     references will be resolved relative to `model`.
73 
74     This is a convenience wrapper for `Apps.lazy_model_operation` - the app
75     registry model used is the one found in `model._meta.apps`.
76     """
77     models = [model] + [resolve_relation(model, rel) for rel in related_models]
78     model_keys = (make_model_tuple(m) for m in models)
79     apps = model._meta.apps
80     return apps.lazy_model_operation(partial(function, **kwargs), *model_keys)
81 
82 
83 class RelatedField(FieldCacheMixin, Field):
84     """Base class that all relational fields inherit from."""
85 
86     # Field flags
87     one_to_many = False
88     one_to_one = False
89     many_to_many = False
90     many_to_one = False
91 
92     @cached_property
93     def related_model(self):
94         # Can't cache this property until all the models are loaded.
95         apps.check_models_ready()
96         return self.remote_field.model
97 
98     def check(self, **kwargs):
99         return [
100             *super().check(**kwargs),
101             *self._check_related_name_is_valid(),
102             *self._check_related_query_name_is_valid(),
103             *self._check_relation_model_exists(),
104             *self._check_referencing_to_swapped_model(),
105             *self._check_clashes(),
106         ]
107 
108     def _check_related_name_is_valid(self):
109         import keyword
110         related_name = self.remote_field.related_name
111         if related_name is None:
112             return []
113         is_valid_id = not keyword.iskeyword(related_name) and related_name.isidentifier()
114         if not (is_valid_id or related_name.endswith('+')):
115             return [
116                 checks.Error(
117                     "The name '%s' is invalid related_name for field %s.%s" %
118                     (self.remote_field.related_name, self.model._meta.object_name,
119                      self.name),
120                     hint="Related name must be a valid Python identifier or end with a '+'",
121                     obj=self,
122                     id='fields.E306',
123                 )
124             ]
125         return []
126 
127     def _check_related_query_name_is_valid(self):
128         if self.remote_field.is_hidden():
129             return []
130         rel_query_name = self.related_query_name()
131         errors = []
132         if rel_query_name.endswith('_'):
133             errors.append(
134                 checks.Error(
135                     "Reverse query name '%s' must not end with an underscore."
136                     % rel_query_name,
137                     hint=("Add or change a related_name or related_query_name "
138                           "argument for this field."),
139                     obj=self,
140                     id='fields.E308',
141                 )
142             )
143         if LOOKUP_SEP in rel_query_name:
144             errors.append(
145                 checks.Error(
146                     "Reverse query name '%s' must not contain '%s'."
147                     % (rel_query_name, LOOKUP_SEP),
148                     hint=("Add or change a related_name or related_query_name "
149                           "argument for this field."),
150                     obj=self,
151                     id='fields.E309',
152                 )
153             )
154         return errors
155 
156     def _check_relation_model_exists(self):
157         rel_is_missing = self.remote_field.model not in self.opts.apps.get_models()
158         rel_is_string = isinstance(self.remote_field.model, str)
159         model_name = self.remote_field.model if rel_is_string else self.remote_field.model._meta.object_name
160         if rel_is_missing and (rel_is_string or not self.remote_field.model._meta.swapped):
161             return [
162                 checks.Error(
163                     "Field defines a relation with model '%s', which is either "
164                     "not installed, or is abstract." % model_name,
165                     obj=self,
166                     id='fields.E300',
167                 )
168             ]
169         return []
170 
171     def _check_referencing_to_swapped_model(self):
172         if (self.remote_field.model not in self.opts.apps.get_models() and
173                 not isinstance(self.remote_field.model, str) and
174                 self.remote_field.model._meta.swapped):
175             return [
176                 checks.Error(
177                     "Field defines a relation with the model '%s', which has "
178                     "been swapped out." % self.remote_field.model._meta.label,
179                     hint="Update the relation to point at 'settings.%s'." % self.remote_field.model._meta.swappable,
180                     obj=self,
181                     id='fields.E301',
182                 )
183             ]
184         return []
185 
186     def _check_clashes(self):
187         """Check accessor and reverse query name clashes."""
188         from django.db.models.base import ModelBase
189 
190         errors = []
191         opts = self.model._meta
192 
193         # `f.remote_field.model` may be a string instead of a model. Skip if model name is
194         # not resolved.
195         if not isinstance(self.remote_field.model, ModelBase):
196             return []
197 
198         # Consider that we are checking field `Model.foreign` and the models
199         # are:
200         #
201         #     class Target(models.Model):
202         #         model = models.IntegerField()
203         #         model_set = models.IntegerField()
204         #
205         #     class Model(models.Model):
206         #         foreign = models.ForeignKey(Target)
207         #         m2m = models.ManyToManyField(Target)
208 
209         # rel_opts.object_name == "Target"
210         rel_opts = self.remote_field.model._meta
211         # If the field doesn't install a backward relation on the target model
212         # (so `is_hidden` returns True), then there are no clashes to check
213         # and we can skip these fields.
214         rel_is_hidden = self.remote_field.is_hidden()
215         rel_name = self.remote_field.get_accessor_name()  # i. e. "model_set"
216         rel_query_name = self.related_query_name()  # i. e. "model"
217         # i.e. "app_label.Model.field".
218         field_name = '%s.%s' % (opts.label, self.name)
219 
220         # Check clashes between accessor or reverse query name of `field`
221         # and any other field name -- i.e. accessor for Model.foreign is
222         # model_set and it clashes with Target.model_set.
223         potential_clashes = rel_opts.fields + rel_opts.many_to_many
224         for clash_field in potential_clashes:
225             # i.e. "app_label.Target.model_set".
226             clash_name = '%s.%s' % (rel_opts.label, clash_field.name)
227             if not rel_is_hidden and clash_field.name == rel_name:
228                 errors.append(
229                     checks.Error(
230                         "Reverse accessor for '%s' clashes with field name '%s'." % (field_name, clash_name),
231                         hint=("Rename field '%s', or add/change a related_name "
232                               "argument to the definition for field '%s'.") % (clash_name, field_name),
233                         obj=self,
234                         id='fields.E302',
235                     )
236                 )
237 
238             if clash_field.name == rel_query_name:
239                 errors.append(
240                     checks.Error(
241                         "Reverse query name for '%s' clashes with field name '%s'." % (field_name, clash_name),
242                         hint=("Rename field '%s', or add/change a related_name "
243                               "argument to the definition for field '%s'.") % (clash_name, field_name),
244                         obj=self,
245                         id='fields.E303',
246                     )
247                 )
248 
249         # Check clashes between accessors/reverse query names of `field` and
250         # any other field accessor -- i. e. Model.foreign accessor clashes with
251         # Model.m2m accessor.
252         potential_clashes = (r for r in rel_opts.related_objects if r.field is not self)
253         for clash_field in potential_clashes:
254             # i.e. "app_label.Model.m2m".
255             clash_name = '%s.%s' % (
256                 clash_field.related_model._meta.label,
257                 clash_field.field.name,
258             )
259             if not rel_is_hidden and clash_field.get_accessor_name() == rel_name:
260                 errors.append(
261                     checks.Error(
262                         "Reverse accessor for '%s' clashes with reverse accessor for '%s'." % (field_name, clash_name),
263                         hint=("Add or change a related_name argument "
264                               "to the definition for '%s' or '%s'.") % (field_name, clash_name),
265                         obj=self,
266                         id='fields.E304',
267                     )
268                 )
269 
270             if clash_field.get_accessor_name() == rel_query_name:
271                 errors.append(
272                     checks.Error(
273                         "Reverse query name for '%s' clashes with reverse query name for '%s'."
274                         % (field_name, clash_name),
275                         hint=("Add or change a related_name argument "
276                               "to the definition for '%s' or '%s'.") % (field_name, clash_name),
277                         obj=self,
278                         id='fields.E305',
279                     )
280                 )
281 
282         return errors
283 
284     def db_type(self, connection):
285         # By default related field will not have a column as it relates to
286         # columns from another table.
287         return None
288 
289     def contribute_to_class(self, cls, name, private_only=False, **kwargs):
290 
291         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)
292 
293         self.opts = cls._meta
294 
295         if not cls._meta.abstract:
296             if self.remote_field.related_name:
297                 related_name = self.remote_field.related_name
298             else:
299                 related_name = self.opts.default_related_name
300             if related_name:
301                 related_name = related_name % {
302                     'class': cls.__name__.lower(),
303                     'model_name': cls._meta.model_name.lower(),
304                     'app_label': cls._meta.app_label.lower()
305                 }
306                 self.remote_field.related_name = related_name
307 
308             if self.remote_field.related_query_name:
309                 related_query_name = self.remote_field.related_query_name % {
310                     'class': cls.__name__.lower(),
311                     'app_label': cls._meta.app_label.lower(),
312                 }
313                 self.remote_field.related_query_name = related_query_name
314 
315             def resolve_related_class(model, related, field):
316                 field.remote_field.model = related
317                 field.do_related_class(related, model)
318             lazy_related_operation(resolve_related_class, cls, self.remote_field.model, field=self)
319 
320     def deconstruct(self):
321         name, path, args, kwargs = super().deconstruct()
322         if self.remote_field.limit_choices_to:
323             kwargs['limit_choices_to'] = self.remote_field.limit_choices_to
324         if self.remote_field.related_name is not None:
325             kwargs['related_name'] = self.remote_field.related_name
326         if self.remote_field.related_query_name is not None:
327             kwargs['related_query_name'] = self.remote_field.related_query_name
328         return name, path, args, kwargs
329 
330     def get_forward_related_filter(self, obj):
331         """
332         Return the keyword arguments that when supplied to
333         self.model.object.filter(), would select all instances related through
334         this field to the remote obj. This is used to build the querysets
335         returned by related descriptors. obj is an instance of
336         self.related_field.model.
337         """
338         return {
339             '%s__%s' % (self.name, rh_field.name): getattr(obj, rh_field.attname)
340             for _, rh_field in self.related_fields
341         }
342 
343     def get_reverse_related_filter(self, obj):
344         """
345         Complement to get_forward_related_filter(). Return the keyword
346         arguments that when passed to self.related_field.model.object.filter()
347         select all instances of self.related_field.model related through
348         this field to obj. obj is an instance of self.model.
349         """
350         base_filter = {
351             rh_field.attname: getattr(obj, lh_field.attname)
352             for lh_field, rh_field in self.related_fields
353         }
354         descriptor_filter = self.get_extra_descriptor_filter(obj)
355         base_q = Q(**base_filter)
356         if isinstance(descriptor_filter, dict):
357             return base_q & Q(**descriptor_filter)
358         elif descriptor_filter:
359             return base_q & descriptor_filter
360         return base_q
361 
362     @property
363     def swappable_setting(self):
364         """
365         Get the setting that this is powered from for swapping, or None
366         if it's not swapped in / marked with swappable=False.
367         """
368         if self.swappable:
369             # Work out string form of "to"
370             if isinstance(self.remote_field.model, str):
371                 to_string = self.remote_field.model
372             else:
373                 to_string = self.remote_field.model._meta.label
374             return apps.get_swappable_settings_name(to_string)
375         return None
376 
377     def set_attributes_from_rel(self):
378         self.name = (
379             self.name or
380             (self.remote_field.model._meta.model_name + '_' + self.remote_field.model._meta.pk.name)
381         )
382         if self.verbose_name is None:
383             self.verbose_name = self.remote_field.model._meta.verbose_name
384         self.remote_field.set_field_name()
385 
386     def do_related_class(self, other, cls):
387         self.set_attributes_from_rel()
388         self.contribute_to_related_class(other, self.remote_field)
389 
390     def get_limit_choices_to(self):
391         """
392         Return ``limit_choices_to`` for this model field.
393 
394         If it is a callable, it will be invoked and the result will be
395         returned.
396         """
397         if callable(self.remote_field.limit_choices_to):
398             return self.remote_field.limit_choices_to()
399         return self.remote_field.limit_choices_to
400 
401     def formfield(self, **kwargs):
402         """
403         Pass ``limit_choices_to`` to the field being constructed.
404 
405         Only passes it if there is a type that supports related fields.
406         This is a similar strategy used to pass the ``queryset`` to the field
407         being constructed.
408         """
409         defaults = {}
410         if hasattr(self.remote_field, 'get_related_field'):
411             # If this is a callable, do not invoke it here. Just pass
412             # it in the defaults for when the form class will later be
413             # instantiated.
414             limit_choices_to = self.remote_field.limit_choices_to
415             defaults.update({
416                 'limit_choices_to': limit_choices_to,
417             })
418         defaults.update(kwargs)
419         return super().formfield(**defaults)
420 
421     def related_query_name(self):
422         """
423         Define the name that can be used to identify this related object in a
424         table-spanning query.
425         """
426         return self.remote_field.related_query_name or self.remote_field.related_name or self.opts.model_name
427 
428     @property
429     def target_field(self):
430         """
431         When filtering against this relation, return the field on the remote
432         model against which the filtering should happen.
433         """
434         target_fields = self.get_path_info()[-1].target_fields
435         if len(target_fields) > 1:
436             raise exceptions.FieldError(
437                 "The relation has multiple target fields, but only single target field was asked for")
438         return target_fields[0]
439 
440     def get_cache_name(self):
441         return self.name
442 
443 
444 class ForeignObject(RelatedField):
445     """
446     Abstraction of the ForeignKey relation to support multi-column relations.
447     """
448 
449     # Field flags
450     many_to_many = False
451     many_to_one = True
452     one_to_many = False
453     one_to_one = False
454 
455     requires_unique_target = True
456     related_accessor_class = ReverseManyToOneDescriptor
457     forward_related_accessor_class = ForwardManyToOneDescriptor
458     rel_class = ForeignObjectRel
459 
460     def __init__(self, to, on_delete, from_fields, to_fields, rel=None, related_name=None,
461                  related_query_name=None, limit_choices_to=None, parent_link=False,
462                  swappable=True, **kwargs):
463 
464         if rel is None:
465             rel = self.rel_class(
466                 self, to,
467                 related_name=related_name,
468                 related_query_name=related_query_name,
469                 limit_choices_to=limit_choices_to,
470                 parent_link=parent_link,
471                 on_delete=on_delete,
472             )
473 
474         super().__init__(rel=rel, **kwargs)
475 
476         self.from_fields = from_fields
477         self.to_fields = to_fields
478         self.swappable = swappable
479 
480     def check(self, **kwargs):
481         return [
482             *super().check(**kwargs),
483             *self._check_to_fields_exist(),
484             *self._check_unique_target(),
485         ]
486 
487     def _check_to_fields_exist(self):
488         # Skip nonexistent models.
489         if isinstance(self.remote_field.model, str):
490             return []
491 
492         errors = []
493         for to_field in self.to_fields:
494             if to_field:
495                 try:
496                     self.remote_field.model._meta.get_field(to_field)
497                 except exceptions.FieldDoesNotExist:
498                     errors.append(
499                         checks.Error(
500                             "The to_field '%s' doesn't exist on the related "
501                             "model '%s'."
502                             % (to_field, self.remote_field.model._meta.label),
503                             obj=self,
504                             id='fields.E312',
505                         )
506                     )
507         return errors
508 
509     def _check_unique_target(self):
510         rel_is_string = isinstance(self.remote_field.model, str)
511         if rel_is_string or not self.requires_unique_target:
512             return []
513 
514         try:
515             self.foreign_related_fields
516         except exceptions.FieldDoesNotExist:
517             return []
518 
519         if not self.foreign_related_fields:
520             return []
521 
522         unique_foreign_fields = {
523             frozenset([f.name])
524             for f in self.remote_field.model._meta.get_fields()
525             if getattr(f, 'unique', False)
526         }
527         unique_foreign_fields.update({
528             frozenset(ut)
529             for ut in self.remote_field.model._meta.unique_together
530         })
531         unique_foreign_fields.update({
532             frozenset(uc.fields)
533             for uc in self.remote_field.model._meta.total_unique_constraints
534         })
535         foreign_fields = {f.name for f in self.foreign_related_fields}
536         has_unique_constraint = any(u <= foreign_fields for u in unique_foreign_fields)
537 
538         if not has_unique_constraint and len(self.foreign_related_fields) > 1:
539             field_combination = ', '.join(
540                 "'%s'" % rel_field.name for rel_field in self.foreign_related_fields
541             )
542             model_name = self.remote_field.model.__name__
543             return [
544                 checks.Error(
545                     "No subset of the fields %s on model '%s' is unique."
546                     % (field_combination, model_name),
547                     hint=(
548                         'Mark a single field as unique=True or add a set of '
549                         'fields to a unique constraint (via unique_together '
550                         'or a UniqueConstraint (without condition) in the '
551                         'model Meta.constraints).'
552                     ),
553                     obj=self,
554                     id='fields.E310',
555                 )
556             ]
557         elif not has_unique_constraint:
558             field_name = self.foreign_related_fields[0].name
559             model_name = self.remote_field.model.__name__
560             return [
561                 checks.Error(
562                     "'%s.%s' must be unique because it is referenced by "
563                     "a foreign key." % (model_name, field_name),
564                     hint=(
565                         'Add unique=True to this field or add a '
566                         'UniqueConstraint (without condition) in the model '
567                         'Meta.constraints.'
568                     ),
569                     obj=self,
570                     id='fields.E311',
571                 )
572             ]
573         else:
574             return []
575 
576     def deconstruct(self):
577         name, path, args, kwargs = super().deconstruct()
578         kwargs['on_delete'] = self.remote_field.on_delete
579         kwargs['from_fields'] = self.from_fields
580         kwargs['to_fields'] = self.to_fields
581 
582         if self.remote_field.parent_link:
583             kwargs['parent_link'] = self.remote_field.parent_link
584         if isinstance(self.remote_field.model, str):
585             if '.' in self.remote_field.model:
586                 app_label, model_name = self.remote_field.model.split('.')
587                 kwargs['to'] = '%s.%s' % (app_label, model_name.lower())
588             else:
589                 kwargs['to'] = self.remote_field.model.lower()
590         else:
591             kwargs['to'] = self.remote_field.model._meta.label_lower
592         # If swappable is True, then see if we're actually pointing to the target
593         # of a swap.
594         swappable_setting = self.swappable_setting
595         if swappable_setting is not None:
596             # If it's already a settings reference, error
597             if hasattr(kwargs['to'], "setting_name"):
598                 if kwargs['to'].setting_name != swappable_setting:
599                     raise ValueError(
600                         "Cannot deconstruct a ForeignKey pointing to a model "
601                         "that is swapped in place of more than one model (%s and %s)"
602                         % (kwargs['to'].setting_name, swappable_setting)
603                     )
604             # Set it
605             kwargs['to'] = SettingsReference(
606                 kwargs['to'],
607                 swappable_setting,
608             )
609         return name, path, args, kwargs
610 
611     def resolve_related_fields(self):
612         if not self.from_fields or len(self.from_fields) != len(self.to_fields):
613             raise ValueError('Foreign Object from and to fields must be the same non-zero length')
614         if isinstance(self.remote_field.model, str):
615             raise ValueError('Related model %r cannot be resolved' % self.remote_field.model)
616         related_fields = []
617         for index in range(len(self.from_fields)):
618             from_field_name = self.from_fields[index]
619             to_field_name = self.to_fields[index]
620             from_field = (
621                 self
622                 if from_field_name == RECURSIVE_RELATIONSHIP_CONSTANT
623                 else self.opts.get_field(from_field_name)
624             )
625             to_field = (self.remote_field.model._meta.pk if to_field_name is None
626                         else self.remote_field.model._meta.get_field(to_field_name))
627             related_fields.append((from_field, to_field))
628         return related_fields
629 
630     @cached_property
631     def related_fields(self):
632         return self.resolve_related_fields()
633 
634     @cached_property
635     def reverse_related_fields(self):
636         return [(rhs_field, lhs_field) for lhs_field, rhs_field in self.related_fields]
637 
638     @cached_property
639     def local_related_fields(self):
640         return tuple(lhs_field for lhs_field, rhs_field in self.related_fields)
641 
642     @cached_property
643     def foreign_related_fields(self):
644         return tuple(rhs_field for lhs_field, rhs_field in self.related_fields if rhs_field)
645 
646     def get_local_related_value(self, instance):
647         return self.get_instance_value_for_fields(instance, self.local_related_fields)
648 
649     def get_foreign_related_value(self, instance):
650         return self.get_instance_value_for_fields(instance, self.foreign_related_fields)
651 
652     @staticmethod
653     def get_instance_value_for_fields(instance, fields):
654         ret = []
655         opts = instance._meta
656         for field in fields:
657             # Gotcha: in some cases (like fixture loading) a model can have
658             # different values in parent_ptr_id and parent's id. So, use
659             # instance.pk (that is, parent_ptr_id) when asked for instance.id.
660             if field.primary_key:
661                 possible_parent_link = opts.get_ancestor_link(field.model)
662                 if (not possible_parent_link or
663                         possible_parent_link.primary_key or
664                         possible_parent_link.model._meta.abstract):
665                     ret.append(instance.pk)
666                     continue
667             ret.append(getattr(instance, field.attname))
668         return tuple(ret)
669 
670     def get_attname_column(self):
671         attname, column = super().get_attname_column()
672         return attname, None
673 
674     def get_joining_columns(self, reverse_join=False):
675         source = self.reverse_related_fields if reverse_join else self.related_fields
676         return tuple((lhs_field.column, rhs_field.column) for lhs_field, rhs_field in source)
677 
678     def get_reverse_joining_columns(self):
679         return self.get_joining_columns(reverse_join=True)
680 
681     def get_extra_descriptor_filter(self, instance):
682         """
683         Return an extra filter condition for related object fetching when
684         user does 'instance.fieldname', that is the extra filter is used in
685         the descriptor of the field.
686 
687         The filter should be either a dict usable in .filter(**kwargs) call or
688         a Q-object. The condition will be ANDed together with the relation's
689         joining columns.
690 
691         A parallel method is get_extra_restriction() which is used in
692         JOIN and subquery conditions.
693         """
694         return {}
695 
696     def get_extra_restriction(self, where_class, alias, related_alias):
697         """
698         Return a pair condition used for joining and subquery pushdown. The
699         condition is something that responds to as_sql(compiler, connection)
700         method.
701 
702         Note that currently referring both the 'alias' and 'related_alias'
703         will not work in some conditions, like subquery pushdown.
704 
705         A parallel method is get_extra_descriptor_filter() which is used in
706         instance.fieldname related object fetching.
707         """
708         return None
709 
710     def get_path_info(self, filtered_relation=None):
711         """Get path from this field to the related model."""
712         opts = self.remote_field.model._meta
713         from_opts = self.model._meta
714         return [PathInfo(
715             from_opts=from_opts,
716             to_opts=opts,
717             target_fields=self.foreign_related_fields,
718             join_field=self,
719             m2m=False,
720             direct=True,
721             filtered_relation=filtered_relation,
722         )]
723 
724     def get_reverse_path_info(self, filtered_relation=None):
725         """Get path from the related model to this field's model."""
726         opts = self.model._meta
727         from_opts = self.remote_field.model._meta
728         return [PathInfo(
729             from_opts=from_opts,
730             to_opts=opts,
731             target_fields=(opts.pk,),
732             join_field=self.remote_field,
733             m2m=not self.unique,
734             direct=False,
735             filtered_relation=filtered_relation,
736         )]
737 
738     @classmethod
739     @functools.lru_cache(maxsize=None)
740     def get_lookups(cls):
741         bases = inspect.getmro(cls)
742         bases = bases[:bases.index(ForeignObject) + 1]
743         class_lookups = [parent.__dict__.get('class_lookups', {}) for parent in bases]
744         return cls.merge_dicts(class_lookups)
745 
746     def contribute_to_class(self, cls, name, private_only=False, **kwargs):
747         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)
748         setattr(cls, self.name, self.forward_related_accessor_class(self))
749 
750     def contribute_to_related_class(self, cls, related):
751         # Internal FK's - i.e., those with a related name ending with '+' -
752         # and swapped models don't get a related descriptor.
753         if not self.remote_field.is_hidden() and not related.related_model._meta.swapped:
754             setattr(cls._meta.concrete_model, related.get_accessor_name(), self.related_accessor_class(related))
755             # While 'limit_choices_to' might be a callable, simply pass
756             # it along for later - this is too early because it's still
757             # model load time.
758             if self.remote_field.limit_choices_to:
759                 cls._meta.related_fkey_lookups.append(self.remote_field.limit_choices_to)
760 
761 
762 ForeignObject.register_lookup(RelatedIn)
763 ForeignObject.register_lookup(RelatedExact)
764 ForeignObject.register_lookup(RelatedLessThan)
765 ForeignObject.register_lookup(RelatedGreaterThan)
766 ForeignObject.register_lookup(RelatedGreaterThanOrEqual)
767 ForeignObject.register_lookup(RelatedLessThanOrEqual)
768 ForeignObject.register_lookup(RelatedIsNull)
769 
770 
771 class ForeignKey(ForeignObject):
772     """
773     Provide a many-to-one relation by adding a column to the local model
774     to hold the remote value.
775 
776     By default ForeignKey will target the pk of the remote model but this
777     behavior can be changed by using the ``to_field`` argument.
778     """
779     descriptor_class = ForeignKeyDeferredAttribute
780     # Field flags
781     many_to_many = False
782     many_to_one = True
783     one_to_many = False
784     one_to_one = False
785 
786     rel_class = ManyToOneRel
787 
788     empty_strings_allowed = False
789     default_error_messages = {
790         'invalid': _('%(model)s instance with %(field)s %(value)r does not exist.')
791     }
792     description = _("Foreign Key (type determined by related field)")
793 
794     def __init__(self, to, on_delete, related_name=None, related_query_name=None,
795                  limit_choices_to=None, parent_link=False, to_field=None,
796                  db_constraint=True, **kwargs):
797         try:
798             to._meta.model_name
799         except AttributeError:
800             assert isinstance(to, str), (
801                 "%s(%r) is invalid. First parameter to ForeignKey must be "
802                 "either a model, a model name, or the string %r" % (
803                     self.__class__.__name__, to,
804                     RECURSIVE_RELATIONSHIP_CONSTANT,
805                 )
806             )
807         else:
808             # For backwards compatibility purposes, we need to *try* and set
809             # the to_field during FK construction. It won't be guaranteed to
810             # be correct until contribute_to_class is called. Refs #12190.
811             to_field = to_field or (to._meta.pk and to._meta.pk.name)
812         if not callable(on_delete):
813             raise TypeError('on_delete must be callable.')
814 
815         kwargs['rel'] = self.rel_class(
816             self, to, to_field,
817             related_name=related_name,
818             related_query_name=related_query_name,
819             limit_choices_to=limit_choices_to,
820             parent_link=parent_link,
821             on_delete=on_delete,
822         )
823         kwargs.setdefault('db_index', True)
824 
825         super().__init__(
826             to,
827             on_delete,
828             from_fields=[RECURSIVE_RELATIONSHIP_CONSTANT],
829             to_fields=[to_field],
830             **kwargs,
831         )
832         self.db_constraint = db_constraint
833 
834     def check(self, **kwargs):
835         return [
836             *super().check(**kwargs),
837             *self._check_on_delete(),
838             *self._check_unique(),
839         ]
840 
841     def _check_on_delete(self):
842         on_delete = getattr(self.remote_field, 'on_delete', None)
843         if on_delete == SET_NULL and not self.null:
844             return [
845                 checks.Error(
846                     'Field specifies on_delete=SET_NULL, but cannot be null.',
847                     hint='Set null=True argument on the field, or change the on_delete rule.',
848                     obj=self,
849                     id='fields.E320',
850                 )
851             ]
852         elif on_delete == SET_DEFAULT and not self.has_default():
853             return [
854                 checks.Error(
855                     'Field specifies on_delete=SET_DEFAULT, but has no default value.',
856                     hint='Set a default value, or change the on_delete rule.',
857                     obj=self,
858                     id='fields.E321',
859                 )
860             ]
861         else:
862             return []
863 
864     def _check_unique(self, **kwargs):
865         return [
866             checks.Warning(
867                 'Setting unique=True on a ForeignKey has the same effect as using a OneToOneField.',
868                 hint='ForeignKey(unique=True) is usually better served by a OneToOneField.',
869                 obj=self,
870                 id='fields.W342',
871             )
872         ] if self.unique else []
873 
874     def deconstruct(self):
875         name, path, args, kwargs = super().deconstruct()
876         del kwargs['to_fields']
877         del kwargs['from_fields']
878         # Handle the simpler arguments
879         if self.db_index:
880             del kwargs['db_index']
881         else:
882             kwargs['db_index'] = False
883         if self.db_constraint is not True:
884             kwargs['db_constraint'] = self.db_constraint
885         # Rel needs more work.
886         to_meta = getattr(self.remote_field.model, "_meta", None)
887         if self.remote_field.field_name and (
888                 not to_meta or (to_meta.pk and self.remote_field.field_name != to_meta.pk.name)):
889             kwargs['to_field'] = self.remote_field.field_name
890         return name, path, args, kwargs
891 
892     def to_python(self, value):
893         return self.target_field.to_python(value)
894 
895     @property
896     def target_field(self):
897         return self.foreign_related_fields[0]
898 
899     def get_reverse_path_info(self, filtered_relation=None):
900         """Get path from the related model to this field's model."""
901         opts = self.model._meta
902         from_opts = self.remote_field.model._meta
903         return [PathInfo(
904             from_opts=from_opts,
905             to_opts=opts,
906             target_fields=(opts.pk,),
907             join_field=self.remote_field,
908             m2m=not self.unique,
909             direct=False,
910             filtered_relation=filtered_relation,
911         )]
912 
913     def validate(self, value, model_instance):
914         if self.remote_field.parent_link:
915             return
916         super().validate(value, model_instance)
917         if value is None:
918             return
919 
920         using = router.db_for_read(self.remote_field.model, instance=model_instance)
921         qs = self.remote_field.model._base_manager.using(using).filter(
922             **{self.remote_field.field_name: value}
923         )
924         qs = qs.complex_filter(self.get_limit_choices_to())
925         if not qs.exists():
926             raise exceptions.ValidationError(
927                 self.error_messages['invalid'],
928                 code='invalid',
929                 params={
930                     'model': self.remote_field.model._meta.verbose_name, 'pk': value,
931                     'field': self.remote_field.field_name, 'value': value,
932                 },  # 'pk' is included for backwards compatibility
933             )
934 
935     def resolve_related_fields(self):
936         related_fields = super().resolve_related_fields()
937         for from_field, to_field in related_fields:
938             if to_field and to_field.model != self.remote_field.model._meta.concrete_model:
939                 raise exceptions.FieldError(
940                     "'%s.%s' refers to field '%s' which is not local to model "
941                     "'%s'." % (
942                         self.model._meta.label,
943                         self.name,
944                         to_field.name,
945                         self.remote_field.model._meta.concrete_model._meta.label,
946                     )
947                 )
948         return related_fields
949 
950     def get_attname(self):
951         return '%s_id' % self.name
952 
953     def get_attname_column(self):
954         attname = self.get_attname()
955         column = self.db_column or attname
956         return attname, column
957 
958     def get_default(self):
959         """Return the to_field if the default value is an object."""
960         field_default = super().get_default()
961         if isinstance(field_default, self.remote_field.model):
962             return getattr(field_default, self.target_field.attname)
963         return field_default
964 
965     def get_db_prep_save(self, value, connection):
966         if value is None or (value == '' and
967                              (not self.target_field.empty_strings_allowed or
968                               connection.features.interprets_empty_strings_as_nulls)):
969             return None
970         else:
971             return self.target_field.get_db_prep_save(value, connection=connection)
972 
973     def get_db_prep_value(self, value, connection, prepared=False):
974         return self.target_field.get_db_prep_value(value, connection, prepared)
975 
976     def get_prep_value(self, value):
977         return self.target_field.get_prep_value(value)
978 
979     def contribute_to_related_class(self, cls, related):
980         super().contribute_to_related_class(cls, related)
981         if self.remote_field.field_name is None:
982             self.remote_field.field_name = cls._meta.pk.name
983 
984     def formfield(self, *, using=None, **kwargs):
985         if isinstance(self.remote_field.model, str):
986             raise ValueError("Cannot create form field for %r yet, because "
987                              "its related model %r has not been loaded yet" %
988                              (self.name, self.remote_field.model))
989         return super().formfield(**{
990             'form_class': forms.ModelChoiceField,
991             'queryset': self.remote_field.model._default_manager.using(using),
992             'to_field_name': self.remote_field.field_name,
993             **kwargs,
994             'blank': self.blank,
995         })
996 
997     def db_check(self, connection):
998         return []
999 
1000     def db_type(self, connection):
1001         return self.target_field.rel_db_type(connection=connection)
1002 
1003     def db_parameters(self, connection):
1004         return {"type": self.db_type(connection), "check": self.db_check(connection)}
1005 
1006     def convert_empty_strings(self, value, expression, connection):
1007         if (not value) and isinstance(value, str):
1008             return None
1009         return value
1010 
1011     def get_db_converters(self, connection):
1012         converters = super().get_db_converters(connection)
1013         if connection.features.interprets_empty_strings_as_nulls:
1014             converters += [self.convert_empty_strings]
1015         return converters
1016 
1017     def get_col(self, alias, output_field=None):
1018         if output_field is None:
1019             output_field = self.target_field
1020             while isinstance(output_field, ForeignKey):
1021                 output_field = output_field.target_field
1022                 if output_field is self:
1023                     raise ValueError('Cannot resolve output_field.')
1024         return super().get_col(alias, output_field)
1025 
1026 
1027 class OneToOneField(ForeignKey):
1028     """
1029     A OneToOneField is essentially the same as a ForeignKey, with the exception
1030     that it always carries a "unique" constraint with it and the reverse
1031     relation always returns the object pointed to (since there will only ever
1032     be one), rather than returning a list.
1033     """
1034 
1035     # Field flags
1036     many_to_many = False
1037     many_to_one = False
1038     one_to_many = False
1039     one_to_one = True
1040 
1041     related_accessor_class = ReverseOneToOneDescriptor
1042     forward_related_accessor_class = ForwardOneToOneDescriptor
1043     rel_class = OneToOneRel
1044 
1045     description = _("One-to-one relationship")
1046 
1047     def __init__(self, to, on_delete, to_field=None, **kwargs):
1048         kwargs['unique'] = True
1049         super().__init__(to, on_delete, to_field=to_field, **kwargs)
1050 
1051     def deconstruct(self):
1052         name, path, args, kwargs = super().deconstruct()
1053         if "unique" in kwargs:
1054             del kwargs['unique']
1055         return name, path, args, kwargs
1056 
1057     def formfield(self, **kwargs):
1058         if self.remote_field.parent_link:
1059             return None
1060         return super().formfield(**kwargs)
1061 
1062     def save_form_data(self, instance, data):
1063         if isinstance(data, self.remote_field.model):
1064             setattr(instance, self.name, data)
1065         else:
1066             setattr(instance, self.attname, data)
1067             # Remote field object must be cleared otherwise Model.save()
1068             # will reassign attname using the related object pk.
1069             if data is None:
1070                 setattr(instance, self.name, data)
1071 
1072     def _check_unique(self, **kwargs):
1073         # Override ForeignKey since check isn't applicable here.
1074         return []
1075 
1076 
1077 def create_many_to_many_intermediary_model(field, klass):
1078     from django.db import models
1079 
1080     def set_managed(model, related, through):
1081         through._meta.managed = model._meta.managed or related._meta.managed
1082 
1083     to_model = resolve_relation(klass, field.remote_field.model)
1084     name = '%s_%s' % (klass._meta.object_name, field.name)
1085     lazy_related_operation(set_managed, klass, to_model, name)
1086 
1087     to = make_model_tuple(to_model)[1]
1088     from_ = klass._meta.model_name
1089     if to == from_:
1090         to = 'to_%s' % to
1091         from_ = 'from_%s' % from_
1092 
1093     meta = type('Meta', (), {
1094         'db_table': field._get_m2m_db_table(klass._meta),
1095         'auto_created': klass,
1096         'app_label': klass._meta.app_label,
1097         'db_tablespace': klass._meta.db_tablespace,
1098         'unique_together': (from_, to),
1099         'verbose_name': _('%(from)s-%(to)s relationship') % {'from': from_, 'to': to},
1100         'verbose_name_plural': _('%(from)s-%(to)s relationships') % {'from': from_, 'to': to},
1101         'apps': field.model._meta.apps,
1102     })
1103     # Construct and return the new class.
1104     return type(name, (models.Model,), {
1105         'Meta': meta,
1106         '__module__': klass.__module__,
1107         from_: models.ForeignKey(
1108             klass,
1109             related_name='%s+' % name,
1110             db_tablespace=field.db_tablespace,
1111             db_constraint=field.remote_field.db_constraint,
1112             on_delete=CASCADE,
1113         ),
1114         to: models.ForeignKey(
1115             to_model,
1116             related_name='%s+' % name,
1117             db_tablespace=field.db_tablespace,
1118             db_constraint=field.remote_field.db_constraint,
1119             on_delete=CASCADE,
1120         )
1121     })
1122 
1123 
1124 class ManyToManyField(RelatedField):
1125     """
1126     Provide a many-to-many relation by using an intermediary model that
1127     holds two ForeignKey fields pointed at the two sides of the relation.
1128 
1129     Unless a ``through`` model was provided, ManyToManyField will use the
1130     create_many_to_many_intermediary_model factory to automatically generate
1131     the intermediary model.
1132     """
1133 
1134     # Field flags
1135     many_to_many = True
1136     many_to_one = False
1137     one_to_many = False
1138     one_to_one = False
1139 
1140     rel_class = ManyToManyRel
1141 
1142     description = _("Many-to-many relationship")
1143 
1144     def __init__(self, to, related_name=None, related_query_name=None,
1145                  limit_choices_to=None, symmetrical=None, through=None,
1146                  through_fields=None, db_constraint=True, db_table=None,
1147                  swappable=True, **kwargs):
1148         try:
1149             to._meta
1150         except AttributeError:
1151             assert isinstance(to, str), (
1152                 "%s(%r) is invalid. First parameter to ManyToManyField must be "
1153                 "either a model, a model name, or the string %r" %
1154                 (self.__class__.__name__, to, RECURSIVE_RELATIONSHIP_CONSTANT)
1155             )
1156 
1157         if symmetrical is None:
1158             symmetrical = (to == RECURSIVE_RELATIONSHIP_CONSTANT)
1159 
1160         if through is not None:
1161             assert db_table is None, (
1162                 "Cannot specify a db_table if an intermediary model is used."
1163             )
1164 
1165         kwargs['rel'] = self.rel_class(
1166             self, to,
1167             related_name=related_name,
1168             related_query_name=related_query_name,
1169             limit_choices_to=limit_choices_to,
1170             symmetrical=symmetrical,
1171             through=through,
1172             through_fields=through_fields,
1173             db_constraint=db_constraint,
1174         )
1175         self.has_null_arg = 'null' in kwargs
1176 
1177         super().__init__(**kwargs)
1178 
1179         self.db_table = db_table
1180         self.swappable = swappable
1181 
1182     def check(self, **kwargs):
1183         return [
1184             *super().check(**kwargs),
1185             *self._check_unique(**kwargs),
1186             *self._check_relationship_model(**kwargs),
1187             *self._check_ignored_options(**kwargs),
1188             *self._check_table_uniqueness(**kwargs),
1189         ]
1190 
1191     def _check_unique(self, **kwargs):
1192         if self.unique:
1193             return [
1194                 checks.Error(
1195                     'ManyToManyFields cannot be unique.',
1196                     obj=self,
1197                     id='fields.E330',
1198                 )
1199             ]
1200         return []
1201 
1202     def _check_ignored_options(self, **kwargs):
1203         warnings = []
1204 
1205         if self.has_null_arg:
1206             warnings.append(
1207                 checks.Warning(
1208                     'null has no effect on ManyToManyField.',
1209                     obj=self,
1210                     id='fields.W340',
1211                 )
1212             )
1213 
1214         if self._validators:
1215             warnings.append(
1216                 checks.Warning(
1217                     'ManyToManyField does not support validators.',
1218                     obj=self,
1219                     id='fields.W341',
1220                 )
1221             )
1222         if (self.remote_field.limit_choices_to and self.remote_field.through and
1223                 not self.remote_field.through._meta.auto_created):
1224             warnings.append(
1225                 checks.Warning(
1226                     'limit_choices_to has no effect on ManyToManyField '
1227                     'with a through model.',
1228                     obj=self,
1229                     id='fields.W343',
1230                 )
1231             )
1232 
1233         return warnings
1234 
1235     def _check_relationship_model(self, from_model=None, **kwargs):
1236         if hasattr(self.remote_field.through, '_meta'):
1237             qualified_model_name = "%s.%s" % (
1238                 self.remote_field.through._meta.app_label, self.remote_field.through.__name__)
1239         else:
1240             qualified_model_name = self.remote_field.through
1241 
1242         errors = []
1243 
1244         if self.remote_field.through not in self.opts.apps.get_models(include_auto_created=True):
1245             # The relationship model is not installed.
1246             errors.append(
1247                 checks.Error(
1248                     "Field specifies a many-to-many relation through model "
1249                     "'%s', which has not been installed." % qualified_model_name,
1250                     obj=self,
1251                     id='fields.E331',
1252                 )
1253             )
1254 
1255         else:
1256             assert from_model is not None, (
1257                 "ManyToManyField with intermediate "
1258                 "tables cannot be checked if you don't pass the model "
1259                 "where the field is attached to."
1260             )
1261             # Set some useful local variables
1262             to_model = resolve_relation(from_model, self.remote_field.model)
1263             from_model_name = from_model._meta.object_name
1264             if isinstance(to_model, str):
1265                 to_model_name = to_model
1266             else:
1267                 to_model_name = to_model._meta.object_name
1268             relationship_model_name = self.remote_field.through._meta.object_name
1269             self_referential = from_model == to_model
1270             # Count foreign keys in intermediate model
1271             if self_referential:
1272                 seen_self = sum(
1273                     from_model == getattr(field.remote_field, 'model', None)
1274                     for field in self.remote_field.through._meta.fields
1275                 )
1276 
1277                 if seen_self > 2 and not self.remote_field.through_fields:
1278                     errors.append(
1279                         checks.Error(
1280                             "The model is used as an intermediate model by "
1281                             "'%s', but it has more than two foreign keys "
1282                             "to '%s', which is ambiguous. You must specify "
1283                             "which two foreign keys Django should use via the "
1284                             "through_fields keyword argument." % (self, from_model_name),
1285                             hint="Use through_fields to specify which two foreign keys Django should use.",
1286                             obj=self.remote_field.through,
1287                             id='fields.E333',
1288                         )
1289                     )
1290 
1291             else:
1292                 # Count foreign keys in relationship model
1293                 seen_from = sum(
1294                     from_model == getattr(field.remote_field, 'model', None)
1295                     for field in self.remote_field.through._meta.fields
1296                 )
1297                 seen_to = sum(
1298                     to_model == getattr(field.remote_field, 'model', None)
1299                     for field in self.remote_field.through._meta.fields
1300                 )
1301 
1302                 if seen_from > 1 and not self.remote_field.through_fields:
1303                     errors.append(
1304                         checks.Error(
1305                             ("The model is used as an intermediate model by "
1306                              "'%s', but it has more than one foreign key "
1307                              "from '%s', which is ambiguous. You must specify "
1308                              "which foreign key Django should use via the "
1309                              "through_fields keyword argument.") % (self, from_model_name),
1310                             hint=(
1311                                 'If you want to create a recursive relationship, '
1312                                 'use ManyToManyField("%s", through="%s").'
1313                             ) % (
1314                                 RECURSIVE_RELATIONSHIP_CONSTANT,
1315                                 relationship_model_name,
1316                             ),
1317                             obj=self,
1318                             id='fields.E334',
1319                         )
1320                     )
1321 
1322                 if seen_to > 1 and not self.remote_field.through_fields:
1323                     errors.append(
1324                         checks.Error(
1325                             "The model is used as an intermediate model by "
1326                             "'%s', but it has more than one foreign key "
1327                             "to '%s', which is ambiguous. You must specify "
1328                             "which foreign key Django should use via the "
1329                             "through_fields keyword argument." % (self, to_model_name),
1330                             hint=(
1331                                 'If you want to create a recursive relationship, '
1332                                 'use ManyToManyField("%s", through="%s").'
1333                             ) % (
1334                                 RECURSIVE_RELATIONSHIP_CONSTANT,
1335                                 relationship_model_name,
1336                             ),
1337                             obj=self,
1338                             id='fields.E335',
1339                         )
1340                     )
1341 
1342                 if seen_from == 0 or seen_to == 0:
1343                     errors.append(
1344                         checks.Error(
1345                             "The model is used as an intermediate model by "
1346                             "'%s', but it does not have a foreign key to '%s' or '%s'." % (
1347                                 self, from_model_name, to_model_name
1348                             ),
1349                             obj=self.remote_field.through,
1350                             id='fields.E336',
1351                         )
1352                     )
1353 
1354         # Validate `through_fields`.
1355         if self.remote_field.through_fields is not None:
1356             # Validate that we're given an iterable of at least two items
1357             # and that none of them is "falsy".
1358             if not (len(self.remote_field.through_fields) >= 2 and
1359                     self.remote_field.through_fields[0] and self.remote_field.through_fields[1]):
1360                 errors.append(
1361                     checks.Error(
1362                         "Field specifies 'through_fields' but does not provide "
1363                         "the names of the two link fields that should be used "
1364                         "for the relation through model '%s'." % qualified_model_name,
1365                         hint="Make sure you specify 'through_fields' as through_fields=('field1', 'field2')",
1366                         obj=self,
1367                         id='fields.E337',
1368                     )
1369                 )
1370 
1371             # Validate the given through fields -- they should be actual
1372             # fields on the through model, and also be foreign keys to the
1373             # expected models.
1374             else:
1375                 assert from_model is not None, (
1376                     "ManyToManyField with intermediate "
1377                     "tables cannot be checked if you don't pass the model "
1378                     "where the field is attached to."
1379                 )
1380 
1381                 source, through, target = from_model, self.remote_field.through, self.remote_field.model
1382                 source_field_name, target_field_name = self.remote_field.through_fields[:2]
1383 
1384                 for field_name, related_model in ((source_field_name, source),
1385                                                   (target_field_name, target)):
1386 
1387                     possible_field_names = []
1388                     for f in through._meta.fields:
1389                         if hasattr(f, 'remote_field') and getattr(f.remote_field, 'model', None) == related_model:
1390                             possible_field_names.append(f.name)
1391                     if possible_field_names:
1392                         hint = "Did you mean one of the following foreign keys to '%s': %s?" % (
1393                             related_model._meta.object_name,
1394                             ', '.join(possible_field_names),
1395                         )
1396                     else:
1397                         hint = None
1398 
1399                     try:
1400                         field = through._meta.get_field(field_name)
1401                     except exceptions.FieldDoesNotExist:
1402                         errors.append(
1403                             checks.Error(
1404                                 "The intermediary model '%s' has no field '%s'."
1405                                 % (qualified_model_name, field_name),
1406                                 hint=hint,
1407                                 obj=self,
1408                                 id='fields.E338',
1409                             )
1410                         )
1411                     else:
1412                         if not (hasattr(field, 'remote_field') and
1413                                 getattr(field.remote_field, 'model', None) == related_model):
1414                             errors.append(
1415                                 checks.Error(
1416                                     "'%s.%s' is not a foreign key to '%s'." % (
1417                                         through._meta.object_name, field_name,
1418                                         related_model._meta.object_name,
1419                                     ),
1420                                     hint=hint,
1421                                     obj=self,
1422                                     id='fields.E339',
1423                                 )
1424                             )
1425 
1426         return errors
1427 
1428     def _check_table_uniqueness(self, **kwargs):
1429         if isinstance(self.remote_field.through, str) or not self.remote_field.through._meta.managed:
1430             return []
1431         registered_tables = {
1432             model._meta.db_table: model
1433             for model in self.opts.apps.get_models(include_auto_created=True)
1434             if model != self.remote_field.through and model._meta.managed
1435         }
1436         m2m_db_table = self.m2m_db_table()
1437         model = registered_tables.get(m2m_db_table)
1438         # The second condition allows multiple m2m relations on a model if
1439         # some point to a through model that proxies another through model.
1440         if model and model._meta.concrete_model != self.remote_field.through._meta.concrete_model:
1441             if model._meta.auto_created:
1442                 def _get_field_name(model):
1443                     for field in model._meta.auto_created._meta.many_to_many:
1444                         if field.remote_field.through is model:
1445                             return field.name
1446                 opts = model._meta.auto_created._meta
1447                 clashing_obj = '%s.%s' % (opts.label, _get_field_name(model))
1448             else:
1449                 clashing_obj = model._meta.label
1450             if settings.DATABASE_ROUTERS:
1451                 error_class, error_id = checks.Warning, 'fields.W344'
1452                 error_hint = (
1453                     'You have configured settings.DATABASE_ROUTERS. Verify '
1454                     'that the table of %r is correctly routed to a separate '
1455                     'database.' % clashing_obj
1456                 )
1457             else:
1458                 error_class, error_id = checks.Error, 'fields.E340'
1459                 error_hint = None
1460             return [
1461                 error_class(
1462                     "The field's intermediary table '%s' clashes with the "
1463                     "table name of '%s'." % (m2m_db_table, clashing_obj),
1464                     obj=self,
1465                     hint=error_hint,
1466                     id=error_id,
1467                 )
1468             ]
1469         return []
1470 
1471     def deconstruct(self):
1472         name, path, args, kwargs = super().deconstruct()
1473         # Handle the simpler arguments.
1474         if self.db_table is not None:
1475             kwargs['db_table'] = self.db_table
1476         if self.remote_field.db_constraint is not True:
1477             kwargs['db_constraint'] = self.remote_field.db_constraint
1478         # Rel needs more work.
1479         if isinstance(self.remote_field.model, str):
1480             kwargs['to'] = self.remote_field.model
1481         else:
1482             kwargs['to'] = self.remote_field.model._meta.label
1483         if getattr(self.remote_field, 'through', None) is not None:
1484             if isinstance(self.remote_field.through, str):
1485                 kwargs['through'] = self.remote_field.through
1486             elif not self.remote_field.through._meta.auto_created:
1487                 kwargs['through'] = self.remote_field.through._meta.label
1488         # If swappable is True, then see if we're actually pointing to the target
1489         # of a swap.
1490         swappable_setting = self.swappable_setting
1491         if swappable_setting is not None:
1492             # If it's already a settings reference, error.
1493             if hasattr(kwargs['to'], "setting_name"):
1494                 if kwargs['to'].setting_name != swappable_setting:
1495                     raise ValueError(
1496                         "Cannot deconstruct a ManyToManyField pointing to a "
1497                         "model that is swapped in place of more than one model "
1498                         "(%s and %s)" % (kwargs['to'].setting_name, swappable_setting)
1499                     )
1500 
1501             kwargs['to'] = SettingsReference(
1502                 kwargs['to'],
1503                 swappable_setting,
1504             )
1505         return name, path, args, kwargs
1506 
1507     def _get_path_info(self, direct=False, filtered_relation=None):
1508         """Called by both direct and indirect m2m traversal."""
1509         int_model = self.remote_field.through
1510         linkfield1 = int_model._meta.get_field(self.m2m_field_name())
1511         linkfield2 = int_model._meta.get_field(self.m2m_reverse_field_name())
1512         if direct:
1513             join1infos = linkfield1.get_reverse_path_info()
1514             join2infos = linkfield2.get_path_info(filtered_relation)
1515         else:
1516             join1infos = linkfield2.get_reverse_path_info()
1517             join2infos = linkfield1.get_path_info(filtered_relation)
1518 
1519         # Get join infos between the last model of join 1 and the first model
1520         # of join 2. Assume the only reason these may differ is due to model
1521         # inheritance.
1522         join1_final = join1infos[-1].to_opts
1523         join2_initial = join2infos[0].from_opts
1524         if join1_final is join2_initial:
1525             intermediate_infos = []
1526         elif issubclass(join1_final.model, join2_initial.model):
1527             intermediate_infos = join1_final.get_path_to_parent(join2_initial.model)
1528         else:
1529             intermediate_infos = join2_initial.get_path_from_parent(join1_final.model)
1530 
1531         return [*join1infos, *intermediate_infos, *join2infos]
1532 
1533     def get_path_info(self, filtered_relation=None):
1534         return self._get_path_info(direct=True, filtered_relation=filtered_relation)
1535 
1536     def get_reverse_path_info(self, filtered_relation=None):
1537         return self._get_path_info(direct=False, filtered_relation=filtered_relation)
1538 
1539     def _get_m2m_db_table(self, opts):
1540         """
1541         Function that can be curried to provide the m2m table name for this
1542         relation.
1543         """
1544         if self.remote_field.through is not None:
1545             return self.remote_field.through._meta.db_table
1546         elif self.db_table:
1547             return self.db_table
1548         else:
1549             m2m_table_name = '%s_%s' % (utils.strip_quotes(opts.db_table), self.name)
1550             return utils.truncate_name(m2m_table_name, connection.ops.max_name_length())
1551 
1552     def _get_m2m_attr(self, related, attr):
1553         """
1554         Function that can be curried to provide the source accessor or DB
1555         column name for the m2m table.
1556         """
1557         cache_attr = '_m2m_%s_cache' % attr
1558         if hasattr(self, cache_attr):
1559             return getattr(self, cache_attr)
1560         if self.remote_field.through_fields is not None:
1561             link_field_name = self.remote_field.through_fields[0]
1562         else:
1563             link_field_name = None
1564         for f in self.remote_field.through._meta.fields:
1565             if (f.is_relation and f.remote_field.model == related.related_model and
1566                     (link_field_name is None or link_field_name == f.name)):
1567                 setattr(self, cache_attr, getattr(f, attr))
1568                 return getattr(self, cache_attr)
1569 
1570     def _get_m2m_reverse_attr(self, related, attr):
1571         """
1572         Function that can be curried to provide the related accessor or DB
1573         column name for the m2m table.
1574         """
1575         cache_attr = '_m2m_reverse_%s_cache' % attr
1576         if hasattr(self, cache_attr):
1577             return getattr(self, cache_attr)
1578         found = False
1579         if self.remote_field.through_fields is not None:
1580             link_field_name = self.remote_field.through_fields[1]
1581         else:
1582             link_field_name = None
1583         for f in self.remote_field.through._meta.fields:
1584             if f.is_relation and f.remote_field.model == related.model:
1585                 if link_field_name is None and related.related_model == related.model:
1586                     # If this is an m2m-intermediate to self,
1587                     # the first foreign key you find will be
1588                     # the source column. Keep searching for
1589                     # the second foreign key.
1590                     if found:
1591                         setattr(self, cache_attr, getattr(f, attr))
1592                         break
1593                     else:
1594                         found = True
1595                 elif link_field_name is None or link_field_name == f.name:
1596                     setattr(self, cache_attr, getattr(f, attr))
1597                     break
1598         return getattr(self, cache_attr)
1599 
1600     def contribute_to_class(self, cls, name, **kwargs):
1601         # To support multiple relations to self, it's useful to have a non-None
1602         # related name on symmetrical relations for internal reasons. The
1603         # concept doesn't make a lot of sense externally ("you want me to
1604         # specify *what* on my non-reversible relation?!"), so we set it up
1605         # automatically. The funky name reduces the chance of an accidental
1606         # clash.
1607         if self.remote_field.symmetrical and (
1608             self.remote_field.model == RECURSIVE_RELATIONSHIP_CONSTANT or
1609             self.remote_field.model == cls._meta.object_name
1610         ):
1611             self.remote_field.related_name = "%s_rel_+" % name
1612         elif self.remote_field.is_hidden():
1613             # If the backwards relation is disabled, replace the original
1614             # related_name with one generated from the m2m field name. Django
1615             # still uses backwards relations internally and we need to avoid
1616             # clashes between multiple m2m fields with related_name == '+'.
1617             self.remote_field.related_name = "_%s_%s_+" % (cls.__name__.lower(), name)
1618 
1619         super().contribute_to_class(cls, name, **kwargs)
1620 
1621         # The intermediate m2m model is not auto created if:
1622         #  1) There is a manually specified intermediate, or
1623         #  2) The class owning the m2m field is abstract.
1624         #  3) The class owning the m2m field has been swapped out.
1625         if not cls._meta.abstract:
1626             if self.remote_field.through:
1627                 def resolve_through_model(_, model, field):
1628                     field.remote_field.through = model
1629                 lazy_related_operation(resolve_through_model, cls, self.remote_field.through, field=self)
1630             elif not cls._meta.swapped:
1631                 self.remote_field.through = create_many_to_many_intermediary_model(self, cls)
1632 
1633         # Add the descriptor for the m2m relation.
1634         setattr(cls, self.name, ManyToManyDescriptor(self.remote_field, reverse=False))
1635 
1636         # Set up the accessor for the m2m table name for the relation.
1637         self.m2m_db_table = partial(self._get_m2m_db_table, cls._meta)
1638 
1639     def contribute_to_related_class(self, cls, related):
1640         # Internal M2Ms (i.e., those with a related name ending with '+')
1641         # and swapped models don't get a related descriptor.
1642         if not self.remote_field.is_hidden() and not related.related_model._meta.swapped:
1643             setattr(cls, related.get_accessor_name(), ManyToManyDescriptor(self.remote_field, reverse=True))
1644 
1645         # Set up the accessors for the column names on the m2m table.
1646         self.m2m_column_name = partial(self._get_m2m_attr, related, 'column')
1647         self.m2m_reverse_name = partial(self._get_m2m_reverse_attr, related, 'column')
1648 
1649         self.m2m_field_name = partial(self._get_m2m_attr, related, 'name')
1650         self.m2m_reverse_field_name = partial(self._get_m2m_reverse_attr, related, 'name')
1651 
1652         get_m2m_rel = partial(self._get_m2m_attr, related, 'remote_field')
1653         self.m2m_target_field_name = lambda: get_m2m_rel().field_name
1654         get_m2m_reverse_rel = partial(self._get_m2m_reverse_attr, related, 'remote_field')
1655         self.m2m_reverse_target_field_name = lambda: get_m2m_reverse_rel().field_name
1656 
1657     def set_attributes_from_rel(self):
1658         pass
1659 
1660     def value_from_object(self, obj):
1661         return [] if obj.pk is None else list(getattr(obj, self.attname).all())
1662 
1663     def save_form_data(self, instance, data):
1664         getattr(instance, self.attname).set(data)
1665 
1666     def formfield(self, *, using=None, **kwargs):
1667         defaults = {
1668             'form_class': forms.ModelMultipleChoiceField,
1669             'queryset': self.remote_field.model._default_manager.using(using),
1670             **kwargs,
1671         }
1672         # If initial is passed in, it's a list of related objects, but the
1673         # MultipleChoiceField takes a list of IDs.
1674         if defaults.get('initial') is not None:
1675             initial = defaults['initial']
1676             if callable(initial):
1677                 initial = initial()
1678             defaults['initial'] = [i.pk for i in initial]
1679         return super().formfield(**defaults)
1680 
1681     def db_check(self, connection):
1682         return None
1683 
1684     def db_type(self, connection):
1685         # A ManyToManyField is not represented by a single column,
1686         # so return None.
1687         return None
1688 
1689     def db_parameters(self, connection):
1690         return {"type": None, "check": None}

</code><intended_behavior>Ensure that the `related_name='+'` or similar directives do not lead to migration errors when used in models with identical names across different applications. There might need to be a clarification or enhancement in how these models and their relationships are processed to allow for smooth migration creation.</intended_behavior>]
2025-10-18 00:58:45.135 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-18 00:58:45.136 | INFO     | Search-only: skipping patch selection
2025-10-18 00:58:45.272 | INFO     | Task django__django-13822 completed successfully.
2025-10-18 00:58:45.273 | INFO     | No patch generated. You can try running ACR again.
