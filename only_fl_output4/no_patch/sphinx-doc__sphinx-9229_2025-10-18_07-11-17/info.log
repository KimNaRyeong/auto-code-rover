2025-10-18 07:11:17.367 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-18 07:11:19.615 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1070, output_tokens=12, cost=0.011060
2025-10-18 07:11:39.369 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1250, output_tokens=921, cost=0.040130
2025-10-18 07:11:40.388 | INFO     | registered non reproducing test 0
2025-10-18 07:11:49.192 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2621, output_tokens=387, cost=0.037820
2025-10-18 07:11:50.144 | INFO     | registered non reproducing test 1
2025-10-18 07:12:09.725 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1977, output_tokens=681, cost=0.040200
2025-10-18 07:12:10.716 | INFO     | registered non reproducing test 2
2025-10-18 07:12:10.716 | WARNING  | Failed to write a reproducer test; skipping reproducer tracing
2025-10-18 07:12:10.719 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 07:12:20.393 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1367, output_tokens=397, cost=0.025580
2025-10-18 07:12:20.400 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 07:12:23.087 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=751, output_tokens=47, cost=0.008920
2025-10-18 07:12:23.088 | DEBUG    | Extracted a valid json.
2025-10-18 07:12:23.088 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_code(\"autodoc extension\")",
        "search_code(\"type alias documentation\")",
        "search_code(\"docstring processing\")"
    ],
    "bug_locations": []
}
2025-10-18 07:12:23.135 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 07:12:23.136 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 07:12:39.102 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2404, output_tokens=735, cost=0.046090
2025-10-18 07:12:39.115 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 07:12:46.355 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3355, output_tokens=295, cost=0.042400
2025-10-18 07:12:46.362 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 07:12:51.364 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=649, output_tokens=139, cost=0.010660
2025-10-18 07:12:51.365 | DEBUG    | Extracted a valid json.
2025-10-18 07:12:51.371 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "sphinx/application.py",
            "class": "Sphinx",
            "method": "add_autodocumenter",
            "intended_behavior": "The `add_autodocumenter` method should ensure that a documenter that is capable of handling type aliases is registered and used when generating documentation."
        },
        {
            "file": "sphinx/util/docstrings.py",
            "class": "",
            "method": "",
            "intended_behavior": "This utility module should ensure that docstring processing functionality properly recognizes and extracts docstrings from type aliases."
        }
    ]
}
2025-10-18 07:12:51.378 | DEBUG    | Bug location extracted successfully: [<file>sphinx/application.py</file>
<class>Sphinx</class>
<method>add_autodocumenter</method>
<code>
1093     def add_autodocumenter(self, cls: Any, override: bool = False) -> None:
1094         """Register a new documenter class for the autodoc extension.
1095 
1096         Add *cls* as a new documenter class for the :mod:`sphinx.ext.autodoc`
1097         extension.  It must be a subclass of
1098         :class:`sphinx.ext.autodoc.Documenter`.  This allows to auto-document
1099         new types of objects.  See the source of the autodoc module for
1100         examples on how to subclass :class:`Documenter`.
1101 
1102         If *override* is True, the given *cls* is forcedly installed even if
1103         a documenter having the same name is already installed.
1104 
1105         See :ref:`autodoc_ext_tutorial`.
1106 
1107         .. versionadded:: 0.6
1108         .. versionchanged:: 2.2
1109            Add *override* keyword.
1110         """
1111         logger.debug('[app] adding autodocumenter: %r', cls)
1112         from sphinx.ext.autodoc.directive import AutodocDirective
1113         self.registry.add_documenter(cls.objtype, cls)
1114         self.add_directive('auto' + cls.objtype, AutodocDirective, override=override)

</code><intended_behavior>The `add_autodocumenter` method should ensure that a documenter that is capable of handling type aliases is registered and used when generating documentation.</intended_behavior>, <file>sphinx/application.py</file>
<class>Sphinx</class>
<method>None</method>
<code>
126 class Sphinx:
127     """The main application class and extensibility interface.
128 
129     :ivar srcdir: Directory containing source.
130     :ivar confdir: Directory containing ``conf.py``.
131     :ivar doctreedir: Directory for storing pickled doctrees.
132     :ivar outdir: Directory for storing build documents.
133     """
134 
135     warningiserror: bool
136     _warncount: int
137 
138     def __init__(self, srcdir: str, confdir: Optional[str], outdir: str, doctreedir: str,
139                  buildername: str, confoverrides: Dict = None,
140                  status: IO = sys.stdout, warning: IO = sys.stderr,
141                  freshenv: bool = False, warningiserror: bool = False, tags: List[str] = None,
142                  verbosity: int = 0, parallel: int = 0, keep_going: bool = False) -> None:
143         self.phase = BuildPhase.INITIALIZATION
144         self.verbosity = verbosity
145         self.extensions: Dict[str, Extension] = {}
146         self.builder: Optional[Builder] = None
147         self.env: Optional[BuildEnvironment] = None
148         self.project: Optional[Project] = None
149         self.registry = SphinxComponentRegistry()
150 
151         # validate provided directories
152         self.srcdir = abspath(srcdir)
153         self.outdir = abspath(outdir)
154         self.doctreedir = abspath(doctreedir)
155         self.confdir = confdir
156         if self.confdir:  # confdir is optional
157             self.confdir = abspath(self.confdir)
158             if not path.isfile(path.join(self.confdir, 'conf.py')):
159                 raise ApplicationError(__("config directory doesn't contain a "
160                                           "conf.py file (%s)") % confdir)
161 
162         if not path.isdir(self.srcdir):
163             raise ApplicationError(__('Cannot find source directory (%s)') %
164                                    self.srcdir)
165 
166         if path.exists(self.outdir) and not path.isdir(self.outdir):
167             raise ApplicationError(__('Output directory (%s) is not a directory') %
168                                    self.outdir)
169 
170         if self.srcdir == self.outdir:
171             raise ApplicationError(__('Source directory and destination '
172                                       'directory cannot be identical'))
173 
174         self.parallel = parallel
175 
176         if status is None:
177             self._status: IO = StringIO()
178             self.quiet: bool = True
179         else:
180             self._status = status
181             self.quiet = False
182 
183         if warning is None:
184             self._warning: IO = StringIO()
185         else:
186             self._warning = warning
187         self._warncount = 0
188         self.keep_going = warningiserror and keep_going
189         if self.keep_going:
190             self.warningiserror = False
191         else:
192             self.warningiserror = warningiserror
193         logging.setup(self, self._status, self._warning)
194 
195         self.events = EventManager(self)
196 
197         # keep last few messages for traceback
198         # This will be filled by sphinx.util.logging.LastMessagesWriter
199         self.messagelog: deque = deque(maxlen=10)
200 
201         # say hello to the world
202         logger.info(bold(__('Running Sphinx v%s') % sphinx.__display_version__))
203 
204         # notice for parallel build on macOS and py38+
205         if sys.version_info > (3, 8) and platform.system() == 'Darwin' and parallel > 1:
206             logger.info(bold(__("For security reason, parallel mode is disabled on macOS and "
207                                 "python3.8 and above. For more details, please read "
208                                 "https://github.com/sphinx-doc/sphinx/issues/6803")))
209 
210         # status code for command-line application
211         self.statuscode = 0
212 
213         # read config
214         self.tags = Tags(tags)
215         if self.confdir is None:
216             self.config = Config({}, confoverrides or {})
217         else:
218             self.config = Config.read(self.confdir, confoverrides or {}, self.tags)
219 
220         # initialize some limited config variables before initialize i18n and loading
221         # extensions
222         self.config.pre_init_values()
223 
224         # set up translation infrastructure
225         self._init_i18n()
226 
227         # check the Sphinx version if requested
228         if self.config.needs_sphinx and self.config.needs_sphinx > sphinx.__display_version__:
229             raise VersionRequirementError(
230                 __('This project needs at least Sphinx v%s and therefore cannot '
231                    'be built with this version.') % self.config.needs_sphinx)
232 
233         # set confdir to srcdir if -C given (!= no confdir); a few pieces
234         # of code expect a confdir to be set
235         if self.confdir is None:
236             self.confdir = self.srcdir
237 
238         # load all built-in extension modules
239         for extension in builtin_extensions:
240             self.setup_extension(extension)
241 
242         # load all user-given extension modules
243         for extension in self.config.extensions:
244             self.setup_extension(extension)
245 
246         # preload builder module (before init config values)
247         self.preload_builder(buildername)
248 
249         if not path.isdir(outdir):
250             with progress_message(__('making output directory')):
251                 ensuredir(outdir)
252 
253         # the config file itself can be an extension
254         if self.config.setup:
255             prefix = __('while setting up extension %s:') % "conf.py"
256             with prefixed_warnings(prefix):
257                 if callable(self.config.setup):
258                     self.config.setup(self)
259                 else:
260                     raise ConfigError(
261                         __("'setup' as currently defined in conf.py isn't a Python callable. "
262                            "Please modify its definition to make it a callable function. "
263                            "This is needed for conf.py to behave as a Sphinx extension.")
264                     )
265 
266         # now that we know all config values, collect them from conf.py
267         self.config.init_values()
268         self.events.emit('config-inited', self.config)
269 
270         # create the project
271         self.project = Project(self.srcdir, self.config.source_suffix)
272         # create the builder
273         self.builder = self.create_builder(buildername)
274         # set up the build environment
275         self._init_env(freshenv)
276         # set up the builder
277         self._init_builder()
278 
279     def _init_i18n(self) -> None:
280         """Load translated strings from the configured localedirs if enabled in
281         the configuration.
282         """
283         if self.config.language is None:
284             self.translator, has_translation = locale.init([], None)
285         else:
286             logger.info(bold(__('loading translations [%s]... ') % self.config.language),
287                         nonl=True)
288 
289             # compile mo files if sphinx.po file in user locale directories are updated
290             repo = CatalogRepository(self.srcdir, self.config.locale_dirs,
291                                      self.config.language, self.config.source_encoding)
292             for catalog in repo.catalogs:
293                 if catalog.domain == 'sphinx' and catalog.is_outdated():
294                     catalog.write_mo(self.config.language)
295 
296             locale_dirs: List[Optional[str]] = list(repo.locale_dirs)
297             locale_dirs += [None]
298             locale_dirs += [path.join(package_dir, 'locale')]
299 
300             self.translator, has_translation = locale.init(locale_dirs, self.config.language)
301             if has_translation or self.config.language == 'en':
302                 # "en" never needs to be translated
303                 logger.info(__('done'))
304             else:
305                 logger.info(__('not available for built-in messages'))
306 
307     def _init_env(self, freshenv: bool) -> None:
308         filename = path.join(self.doctreedir, ENV_PICKLE_FILENAME)
309         if freshenv or not os.path.exists(filename):
310             self.env = BuildEnvironment()
311             self.env.setup(self)
312             self.env.find_files(self.config, self.builder)
313         else:
314             try:
315                 with progress_message(__('loading pickled environment')):
316                     with open(filename, 'rb') as f:
317                         self.env = pickle.load(f)
318                         self.env.setup(self)
319             except Exception as err:
320                 logger.info(__('failed: %s'), err)
321                 self._init_env(freshenv=True)
322 
323     def preload_builder(self, name: str) -> None:
324         self.registry.preload_builder(self, name)
325 
326     def create_builder(self, name: str) -> "Builder":
327         if name is None:
328             logger.info(__('No builder selected, using default: html'))
329             name = 'html'
330 
331         return self.registry.create_builder(self, name)
332 
333     def _init_builder(self) -> None:
334         self.builder.set_environment(self.env)
335         self.builder.init()
336         self.events.emit('builder-inited')
337 
338     # ---- main "build" method -------------------------------------------------
339 
340     def build(self, force_all: bool = False, filenames: List[str] = None) -> None:
341         self.phase = BuildPhase.READING
342         try:
343             if force_all:
344                 self.builder.compile_all_catalogs()
345                 self.builder.build_all()
346             elif filenames:
347                 self.builder.compile_specific_catalogs(filenames)
348                 self.builder.build_specific(filenames)
349             else:
350                 self.builder.compile_update_catalogs()
351                 self.builder.build_update()
352 
353             if self._warncount and self.keep_going:
354                 self.statuscode = 1
355 
356             status = (__('succeeded') if self.statuscode == 0
357                       else __('finished with problems'))
358             if self._warncount:
359                 if self.warningiserror:
360                     if self._warncount == 1:
361                         msg = __('build %s, %s warning (with warnings treated as errors).')
362                     else:
363                         msg = __('build %s, %s warnings (with warnings treated as errors).')
364                 else:
365                     if self._warncount == 1:
366                         msg = __('build %s, %s warning.')
367                     else:
368                         msg = __('build %s, %s warnings.')
369 
370                 logger.info(bold(msg % (status, self._warncount)))
371             else:
372                 logger.info(bold(__('build %s.') % status))
373 
374             if self.statuscode == 0 and self.builder.epilog:
375                 logger.info('')
376                 logger.info(self.builder.epilog % {
377                     'outdir': relpath(self.outdir),
378                     'project': self.config.project
379                 })
380         except Exception as err:
381             # delete the saved env to force a fresh build next time
382             envfile = path.join(self.doctreedir, ENV_PICKLE_FILENAME)
383             if path.isfile(envfile):
384                 os.unlink(envfile)
385             self.events.emit('build-finished', err)
386             raise
387         else:
388             self.events.emit('build-finished', None)
389         self.builder.cleanup()
390 
391     # ---- general extensibility interface -------------------------------------
392 
393     def setup_extension(self, extname: str) -> None:
394         """Import and setup a Sphinx extension module.
395 
396         Load the extension given by the module *name*.  Use this if your
397         extension needs the features provided by another extension.  No-op if
398         called twice.
399         """
400         logger.debug('[app] setting up extension: %r', extname)
401         self.registry.load_extension(self, extname)
402 
403     def require_sphinx(self, version: str) -> None:
404         """Check the Sphinx version if requested.
405 
406         Compare *version* with the version of the running Sphinx, and abort the
407         build when it is too old.
408 
409         :param version: The required version in the form of ``major.minor``.
410 
411         .. versionadded:: 1.0
412         """
413         if version > sphinx.__display_version__[:3]:
414             raise VersionRequirementError(version)
415 
416     # event interface
417     def connect(self, event: str, callback: Callable, priority: int = 500) -> int:
418         """Register *callback* to be called when *event* is emitted.
419 
420         For details on available core events and the arguments of callback
421         functions, please see :ref:`events`.
422 
423         :param event: The name of target event
424         :param callback: Callback function for the event
425         :param priority: The priority of the callback.  The callbacks will be invoked
426                          in the order of *priority* in asending.
427         :return: A listener ID.  It can be used for :meth:`disconnect`.
428 
429         .. versionchanged:: 3.0
430 
431            Support *priority*
432         """
433         listener_id = self.events.connect(event, callback, priority)
434         logger.debug('[app] connecting event %r (%d): %r [id=%s]',
435                      event, priority, callback, listener_id)
436         return listener_id
437 
438     def disconnect(self, listener_id: int) -> None:
439         """Unregister callback by *listener_id*.
440 
441         :param listener_id: A listener_id that :meth:`connect` returns
442         """
443         logger.debug('[app] disconnecting event: [id=%s]', listener_id)
444         self.events.disconnect(listener_id)
445 
446     def emit(self, event: str, *args: Any,
447              allowed_exceptions: Tuple[Type[Exception], ...] = ()) -> List:
448         """Emit *event* and pass *arguments* to the callback functions.
449 
450         Return the return values of all callbacks as a list.  Do not emit core
451         Sphinx events in extensions!
452 
453         :param event: The name of event that will be emitted
454         :param args: The arguments for the event
455         :param allowed_exceptions: The list of exceptions that are allowed in the callbacks
456 
457         .. versionchanged:: 3.1
458 
459            Added *allowed_exceptions* to specify path-through exceptions
460         """
461         return self.events.emit(event, *args, allowed_exceptions=allowed_exceptions)
462 
463     def emit_firstresult(self, event: str, *args: Any,
464                          allowed_exceptions: Tuple[Type[Exception], ...] = ()) -> Any:
465         """Emit *event* and pass *arguments* to the callback functions.
466 
467         Return the result of the first callback that doesn't return ``None``.
468 
469         :param event: The name of event that will be emitted
470         :param args: The arguments for the event
471         :param allowed_exceptions: The list of exceptions that are allowed in the callbacks
472 
473         .. versionadded:: 0.5
474         .. versionchanged:: 3.1
475 
476            Added *allowed_exceptions* to specify path-through exceptions
477         """
478         return self.events.emit_firstresult(event, *args,
479                                             allowed_exceptions=allowed_exceptions)
480 
481     # registering addon parts
482 
483     def add_builder(self, builder: Type["Builder"], override: bool = False) -> None:
484         """Register a new builder.
485 
486         :param builder: A builder class
487         :param override: If true, install the builder forcedly even if another builder
488                          is already installed as the same name
489 
490         .. versionchanged:: 1.8
491            Add *override* keyword.
492         """
493         self.registry.add_builder(builder, override=override)
494 
495     # TODO(stephenfin): Describe 'types' parameter
496     def add_config_value(self, name: str, default: Any, rebuild: Union[bool, str],
497                          types: Any = ()) -> None:
498         """Register a configuration value.
499 
500         This is necessary for Sphinx to recognize new values and set default
501         values accordingly.
502 
503 
504         :param name: The name of configuration value.  It is recommended to be prefixed
505                      with the extension name (ex. ``html_logo``, ``epub_title``)
506         :param default: The default value of the configuration.
507         :param rebuild: The condition of rebuild.  It must be one of those values:
508 
509                         * ``'env'`` if a change in the setting only takes effect when a
510                           document is parsed -- this means that the whole environment must be
511                           rebuilt.
512                         * ``'html'`` if a change in the setting needs a full rebuild of HTML
513                           documents.
514                         * ``''`` if a change in the setting will not need any special rebuild.
515         :param types: The type of configuration value.  A list of types can be specified.  For
516                       example, ``[str]`` is used to describe a configuration that takes string
517                       value.
518 
519         .. versionchanged:: 0.4
520            If the *default* value is a callable, it will be called with the
521            config object as its argument in order to get the default value.
522            This can be used to implement config values whose default depends on
523            other values.
524 
525         .. versionchanged:: 0.6
526            Changed *rebuild* from a simple boolean (equivalent to ``''`` or
527            ``'env'``) to a string.  However, booleans are still accepted and
528            converted internally.
529         """
530         logger.debug('[app] adding config value: %r', (name, default, rebuild, types))
531         if rebuild in (False, True):
532             rebuild = 'env' if rebuild else ''
533         self.config.add(name, default, rebuild, types)
534 
535     def add_event(self, name: str) -> None:
536         """Register an event called *name*.
537 
538         This is needed to be able to emit it.
539 
540         :param name: The name of the event
541         """
542         logger.debug('[app] adding event: %r', name)
543         self.events.add(name)
544 
545     def set_translator(self, name: str, translator_class: Type[nodes.NodeVisitor],
546                        override: bool = False) -> None:
547         """Register or override a Docutils translator class.
548 
549         This is used to register a custom output translator or to replace a
550         builtin translator.  This allows extensions to use custom translator
551         and define custom nodes for the translator (see :meth:`add_node`).
552 
553         :param name: The name of builder for the translator
554         :param translator_class: A translator class
555         :param override: If true, install the translator forcedly even if another translator
556                          is already installed as the same name
557 
558         .. versionadded:: 1.3
559         .. versionchanged:: 1.8
560            Add *override* keyword.
561         """
562         self.registry.add_translator(name, translator_class, override=override)
563 
564     def add_node(self, node: Type[Element], override: bool = False,
565                  **kwargs: Tuple[Callable, Optional[Callable]]) -> None:
566         """Register a Docutils node class.
567 
568         This is necessary for Docutils internals.  It may also be used in the
569         future to validate nodes in the parsed documents.
570 
571         :param node: A node class
572         :param kwargs: Visitor functions for each builder (see below)
573         :param override: If true, install the node forcedly even if another node is already
574                          installed as the same name
575 
576         Node visitor functions for the Sphinx HTML, LaTeX, text and manpage
577         writers can be given as keyword arguments: the keyword should be one or
578         more of ``'html'``, ``'latex'``, ``'text'``, ``'man'``, ``'texinfo'``
579         or any other supported translators, the value a 2-tuple of ``(visit,
580         depart)`` methods.  ``depart`` can be ``None`` if the ``visit``
581         function raises :exc:`docutils.nodes.SkipNode`.  Example:
582 
583         .. code-block:: python
584 
585            class math(docutils.nodes.Element): pass
586 
587            def visit_math_html(self, node):
588                self.body.append(self.starttag(node, 'math'))
589            def depart_math_html(self, node):
590                self.body.append('</math>')
591 
592            app.add_node(math, html=(visit_math_html, depart_math_html))
593 
594         Obviously, translators for which you don't specify visitor methods will
595         choke on the node when encountered in a document to translate.
596 
597         .. versionchanged:: 0.5
598            Added the support for keyword arguments giving visit functions.
599         """
600         logger.debug('[app] adding node: %r', (node, kwargs))
601         if not override and docutils.is_node_registered(node):
602             logger.warning(__('node class %r is already registered, '
603                               'its visitors will be overridden'),
604                            node.__name__, type='app', subtype='add_node')
605         docutils.register_node(node)
606         self.registry.add_translation_handlers(node, **kwargs)
607 
608     def add_enumerable_node(self, node: Type[Element], figtype: str,
609                             title_getter: TitleGetter = None, override: bool = False,
610                             **kwargs: Tuple[Callable, Callable]) -> None:
611         """Register a Docutils node class as a numfig target.
612 
613         Sphinx numbers the node automatically. And then the users can refer it
614         using :rst:role:`numref`.
615 
616         :param node: A node class
617         :param figtype: The type of enumerable nodes.  Each figtypes have individual numbering
618                         sequences.  As a system figtypes, ``figure``, ``table`` and
619                         ``code-block`` are defined.  It is able to add custom nodes to these
620                         default figtypes.  It is also able to define new custom figtype if new
621                         figtype is given.
622         :param title_getter: A getter function to obtain the title of node.  It takes an
623                              instance of the enumerable node, and it must return its title as
624                              string.  The title is used to the default title of references for
625                              :rst:role:`ref`.  By default, Sphinx searches
626                              ``docutils.nodes.caption`` or ``docutils.nodes.title`` from the
627                              node as a title.
628         :param kwargs: Visitor functions for each builder (same as :meth:`add_node`)
629         :param override: If true, install the node forcedly even if another node is already
630                          installed as the same name
631 
632         .. versionadded:: 1.4
633         """
634         self.registry.add_enumerable_node(node, figtype, title_getter, override=override)
635         self.add_node(node, override=override, **kwargs)
636 
637     def add_directive(self, name: str, cls: Type[Directive], override: bool = False) -> None:
638         """Register a Docutils directive.
639 
640         :param name: The name of directive
641         :param cls: A directive class
642         :param override: If true, install the directive forcedly even if another directive
643                          is already installed as the same name
644 
645         For example, a custom directive named ``my-directive`` would be added
646         like this:
647 
648         .. code-block:: python
649 
650            from docutils.parsers.rst import Directive, directives
651 
652            class MyDirective(Directive):
653                has_content = True
654                required_arguments = 1
655                optional_arguments = 0
656                final_argument_whitespace = True
657                option_spec = {
658                    'class': directives.class_option,
659                    'name': directives.unchanged,
660                }
661 
662                def run(self):
663                    ...
664 
665            def setup(app):
666                add_directive('my-directive', MyDirective)
667 
668         For more details, see `the Docutils docs
669         <http://docutils.sourceforge.net/docs/howto/rst-directives.html>`__ .
670 
671         .. versionchanged:: 0.6
672            Docutils 0.5-style directive classes are now supported.
673         .. deprecated:: 1.8
674            Docutils 0.4-style (function based) directives support is deprecated.
675         .. versionchanged:: 1.8
676            Add *override* keyword.
677         """
678         logger.debug('[app] adding directive: %r', (name, cls))
679         if not override and docutils.is_directive_registered(name):
680             logger.warning(__('directive %r is already registered, it will be overridden'),
681                            name, type='app', subtype='add_directive')
682 
683         docutils.register_directive(name, cls)
684 
685     def add_role(self, name: str, role: Any, override: bool = False) -> None:
686         """Register a Docutils role.
687 
688         :param name: The name of role
689         :param role: A role function
690         :param override: If true, install the role forcedly even if another role is already
691                          installed as the same name
692 
693         For more details about role functions, see `the Docutils docs
694         <http://docutils.sourceforge.net/docs/howto/rst-roles.html>`__ .
695 
696         .. versionchanged:: 1.8
697            Add *override* keyword.
698         """
699         logger.debug('[app] adding role: %r', (name, role))
700         if not override and docutils.is_role_registered(name):
701             logger.warning(__('role %r is already registered, it will be overridden'),
702                            name, type='app', subtype='add_role')
703         docutils.register_role(name, role)
704 
705     def add_generic_role(self, name: str, nodeclass: Any, override: bool = False) -> None:
706         """Register a generic Docutils role.
707 
708         Register a Docutils role that does nothing but wrap its contents in the
709         node given by *nodeclass*.
710 
711         If *override* is True, the given *nodeclass* is forcedly installed even if
712         a role named as *name* is already installed.
713 
714         .. versionadded:: 0.6
715         .. versionchanged:: 1.8
716            Add *override* keyword.
717         """
718         # Don't use ``roles.register_generic_role`` because it uses
719         # ``register_canonical_role``.
720         logger.debug('[app] adding generic role: %r', (name, nodeclass))
721         if not override and docutils.is_role_registered(name):
722             logger.warning(__('role %r is already registered, it will be overridden'),
723                            name, type='app', subtype='add_generic_role')
724         role = roles.GenericRole(name, nodeclass)
725         docutils.register_role(name, role)
726 
727     def add_domain(self, domain: Type[Domain], override: bool = False) -> None:
728         """Register a domain.
729 
730         :param domain: A domain class
731         :param override: If true, install the domain forcedly even if another domain
732                          is already installed as the same name
733 
734         .. versionadded:: 1.0
735         .. versionchanged:: 1.8
736            Add *override* keyword.
737         """
738         self.registry.add_domain(domain, override=override)
739 
740     def add_directive_to_domain(self, domain: str, name: str,
741                                 cls: Type[Directive], override: bool = False) -> None:
742         """Register a Docutils directive in a domain.
743 
744         Like :meth:`add_directive`, but the directive is added to the domain
745         named *domain*.
746 
747         :param domain: The name of target domain
748         :param name: A name of directive
749         :param cls: A directive class
750         :param override: If true, install the directive forcedly even if another directive
751                          is already installed as the same name
752 
753         .. versionadded:: 1.0
754         .. versionchanged:: 1.8
755            Add *override* keyword.
756         """
757         self.registry.add_directive_to_domain(domain, name, cls, override=override)
758 
759     def add_role_to_domain(self, domain: str, name: str, role: Union[RoleFunction, XRefRole],
760                            override: bool = False) -> None:
761         """Register a Docutils role in a domain.
762 
763         Like :meth:`add_role`, but the role is added to the domain named
764         *domain*.
765 
766         :param domain: The name of target domain
767         :param name: A name of role
768         :param role: A role function
769         :param override: If true, install the role forcedly even if another role is already
770                          installed as the same name
771 
772         .. versionadded:: 1.0
773         .. versionchanged:: 1.8
774            Add *override* keyword.
775         """
776         self.registry.add_role_to_domain(domain, name, role, override=override)
777 
778     def add_index_to_domain(self, domain: str, index: Type[Index], override: bool = False
779                             ) -> None:
780         """Register a custom index for a domain.
781 
782         Add a custom *index* class to the domain named *domain*.
783 
784         :param domain: The name of target domain
785         :param index: A index class
786         :param override: If true, install the index forcedly even if another index is
787                          already installed as the same name
788 
789         .. versionadded:: 1.0
790         .. versionchanged:: 1.8
791            Add *override* keyword.
792         """
793         self.registry.add_index_to_domain(domain, index)
794 
795     def add_object_type(self, directivename: str, rolename: str, indextemplate: str = '',
796                         parse_node: Callable = None, ref_nodeclass: Type[TextElement] = None,
797                         objname: str = '', doc_field_types: List = [], override: bool = False
798                         ) -> None:
799         """Register a new object type.
800 
801         This method is a very convenient way to add a new :term:`object` type
802         that can be cross-referenced.  It will do this:
803 
804         - Create a new directive (called *directivename*) for documenting an
805           object.  It will automatically add index entries if *indextemplate*
806           is nonempty; if given, it must contain exactly one instance of
807           ``%s``.  See the example below for how the template will be
808           interpreted.
809         - Create a new role (called *rolename*) to cross-reference to these
810           object descriptions.
811         - If you provide *parse_node*, it must be a function that takes a
812           string and a docutils node, and it must populate the node with
813           children parsed from the string.  It must then return the name of the
814           item to be used in cross-referencing and index entries.  See the
815           :file:`conf.py` file in the source for this documentation for an
816           example.
817         - The *objname* (if not given, will default to *directivename*) names
818           the type of object.  It is used when listing objects, e.g. in search
819           results.
820 
821         For example, if you have this call in a custom Sphinx extension::
822 
823            app.add_object_type('directive', 'dir', 'pair: %s; directive')
824 
825         you can use this markup in your documents::
826 
827            .. rst:directive:: function
828 
829               Document a function.
830 
831            <...>
832 
833            See also the :rst:dir:`function` directive.
834 
835         For the directive, an index entry will be generated as if you had prepended ::
836 
837            .. index:: pair: function; directive
838 
839         The reference node will be of class ``literal`` (so it will be rendered
840         in a proportional font, as appropriate for code) unless you give the
841         *ref_nodeclass* argument, which must be a docutils node class.  Most
842         useful are ``docutils.nodes.emphasis`` or ``docutils.nodes.strong`` --
843         you can also use ``docutils.nodes.generated`` if you want no further
844         text decoration.  If the text should be treated as literal (e.g. no
845         smart quote replacement), but not have typewriter styling, use
846         ``sphinx.addnodes.literal_emphasis`` or
847         ``sphinx.addnodes.literal_strong``.
848 
849         For the role content, you have the same syntactical possibilities as
850         for standard Sphinx roles (see :ref:`xref-syntax`).
851 
852         If *override* is True, the given object_type is forcedly installed even if
853         an object_type having the same name is already installed.
854 
855         .. versionchanged:: 1.8
856            Add *override* keyword.
857         """
858         self.registry.add_object_type(directivename, rolename, indextemplate, parse_node,
859                                       ref_nodeclass, objname, doc_field_types,
860                                       override=override)
861 
862     def add_crossref_type(self, directivename: str, rolename: str, indextemplate: str = '',
863                           ref_nodeclass: Type[TextElement] = None, objname: str = '',
864                           override: bool = False) -> None:
865         """Register a new crossref object type.
866 
867         This method is very similar to :meth:`add_object_type` except that the
868         directive it generates must be empty, and will produce no output.
869 
870         That means that you can add semantic targets to your sources, and refer
871         to them using custom roles instead of generic ones (like
872         :rst:role:`ref`).  Example call::
873 
874            app.add_crossref_type('topic', 'topic', 'single: %s',
875                                  docutils.nodes.emphasis)
876 
877         Example usage::
878 
879            .. topic:: application API
880 
881            The application API
882            -------------------
883 
884            Some random text here.
885 
886            See also :topic:`this section <application API>`.
887 
888         (Of course, the element following the ``topic`` directive needn't be a
889         section.)
890 
891         If *override* is True, the given crossref_type is forcedly installed even if
892         a crossref_type having the same name is already installed.
893 
894         .. versionchanged:: 1.8
895            Add *override* keyword.
896         """
897         self.registry.add_crossref_type(directivename, rolename,
898                                         indextemplate, ref_nodeclass, objname,
899                                         override=override)
900 
901     def add_transform(self, transform: Type[Transform]) -> None:
902         """Register a Docutils transform to be applied after parsing.
903 
904         Add the standard docutils :class:`Transform` subclass *transform* to
905         the list of transforms that are applied after Sphinx parses a reST
906         document.
907 
908         :param transform: A transform class
909 
910         .. list-table:: priority range categories for Sphinx transforms
911            :widths: 20,80
912 
913            * - Priority
914              - Main purpose in Sphinx
915            * - 0-99
916              - Fix invalid nodes by docutils. Translate a doctree.
917            * - 100-299
918              - Preparation
919            * - 300-399
920              - early
921            * - 400-699
922              - main
923            * - 700-799
924              - Post processing. Deadline to modify text and referencing.
925            * - 800-899
926              - Collect referencing and referenced nodes. Domain processing.
927            * - 900-999
928              - Finalize and clean up.
929 
930         refs: `Transform Priority Range Categories`__
931 
932         __ http://docutils.sourceforge.net/docs/ref/transforms.html#transform-priority-range-categories
933         """  # NOQA
934         self.registry.add_transform(transform)
935 
936     def add_post_transform(self, transform: Type[Transform]) -> None:
937         """Register a Docutils transform to be applied before writing.
938 
939         Add the standard docutils :class:`Transform` subclass *transform* to
940         the list of transforms that are applied before Sphinx writes a
941         document.
942 
943         :param transform: A transform class
944         """
945         self.registry.add_post_transform(transform)
946 
947     def add_js_file(self, filename: str, priority: int = 500, **kwargs: Any) -> None:
948         """Register a JavaScript file to include in the HTML output.
949 
950         Add *filename* to the list of JavaScript files that the default HTML
951         template will include in order of *priority* (ascending).  The filename
952         must be relative to the HTML static path , or a full URI with scheme.
953         If the priority of JavaScript file is the same as others, the JavaScript
954         files will be included in order of the registration.  If the keyword
955         argument ``body`` is given, its value will be added between the
956         ``<script>`` tags. Extra keyword arguments are included as attributes of
957         the ``<script>`` tag.
958 
959         Example::
960 
961             app.add_js_file('example.js')
962             # => <script src="_static/example.js"></script>
963 
964             app.add_js_file('example.js', async="async")
965             # => <script src="_static/example.js" async="async"></script>
966 
967             app.add_js_file(None, body="var myVariable = 'foo';")
968             # => <script>var myVariable = 'foo';</script>
969 
970         .. list-table:: priority range for JavaScript files
971            :widths: 20,80
972 
973            * - Priority
974              - Main purpose in Sphinx
975            * - 200
976              - default priority for built-in JavaScript files
977            * - 500
978              - default priority for extensions
979            * - 800
980              - default priority for :confval:`html_js_files`
981 
982         A JavaScript file can be added to the specific HTML page when on extension
983         calls this method on :event:`html-page-context` event.
984 
985         .. versionadded:: 0.5
986 
987         .. versionchanged:: 1.8
988            Renamed from ``app.add_javascript()``.
989            And it allows keyword arguments as attributes of script tag.
990 
991         .. versionchanged:: 3.5
992            Take priority argument.  Allow to add a JavaScript file to the specific page.
993         """
994         self.registry.add_js_file(filename, priority=priority, **kwargs)
995         if hasattr(self.builder, 'add_js_file'):
996             self.builder.add_js_file(filename, priority=priority, **kwargs)  # type: ignore
997 
998     def add_css_file(self, filename: str, priority: int = 500, **kwargs: Any) -> None:
999         """Register a stylesheet to include in the HTML output.
1000 
1001         Add *filename* to the list of CSS files that the default HTML template
1002         will include in order of *priority* (ascending).  The filename must be
1003         relative to the HTML static path, or a full URI with scheme.  If the
1004         priority of CSS file is the same as others, the CSS files will be
1005         included in order of the registration.  The keyword arguments are also
1006         accepted for attributes of ``<link>`` tag.
1007 
1008         Example::
1009 
1010             app.add_css_file('custom.css')
1011             # => <link rel="stylesheet" href="_static/custom.css" type="text/css" />
1012 
1013             app.add_css_file('print.css', media='print')
1014             # => <link rel="stylesheet" href="_static/print.css"
1015             #          type="text/css" media="print" />
1016 
1017             app.add_css_file('fancy.css', rel='alternate stylesheet', title='fancy')
1018             # => <link rel="alternate stylesheet" href="_static/fancy.css"
1019             #          type="text/css" title="fancy" />
1020 
1021         .. list-table:: priority range for CSS files
1022            :widths: 20,80
1023 
1024            * - Priority
1025              - Main purpose in Sphinx
1026            * - 200
1027              - default priority for built-in CSS files
1028            * - 500
1029              - default priority for extensions
1030            * - 800
1031              - default priority for :confval:`html_css_files`
1032 
1033         A CSS file can be added to the specific HTML page when on extension calls
1034         this method on :event:`html-page-context` event.
1035 
1036         .. versionadded:: 1.0
1037 
1038         .. versionchanged:: 1.6
1039            Optional ``alternate`` and/or ``title`` attributes can be supplied
1040            with the *alternate* (of boolean type) and *title* (a string)
1041            arguments. The default is no title and *alternate* = ``False``. For
1042            more information, refer to the `documentation
1043            <https://mdn.io/Web/CSS/Alternative_style_sheets>`__.
1044 
1045         .. versionchanged:: 1.8
1046            Renamed from ``app.add_stylesheet()``.
1047            And it allows keyword arguments as attributes of link tag.
1048 
1049         .. versionchanged:: 3.5
1050            Take priority argument.  Allow to add a CSS file to the specific page.
1051         """
1052         logger.debug('[app] adding stylesheet: %r', filename)
1053         self.registry.add_css_files(filename, priority=priority, **kwargs)
1054         if hasattr(self.builder, 'add_css_file'):
1055             self.builder.add_css_file(filename, priority=priority, **kwargs)  # type: ignore
1056 
1057     def add_latex_package(self, packagename: str, options: str = None,
1058                           after_hyperref: bool = False) -> None:
1059         r"""Register a package to include in the LaTeX source code.
1060 
1061         Add *packagename* to the list of packages that LaTeX source code will
1062         include.  If you provide *options*, it will be taken to `\usepackage`
1063         declaration.  If you set *after_hyperref* truthy, the package will be
1064         loaded after ``hyperref`` package.
1065 
1066         .. code-block:: python
1067 
1068            app.add_latex_package('mypackage')
1069            # => \usepackage{mypackage}
1070            app.add_latex_package('mypackage', 'foo,bar')
1071            # => \usepackage[foo,bar]{mypackage}
1072 
1073         .. versionadded:: 1.3
1074         .. versionadded:: 3.1
1075 
1076            *after_hyperref* option.
1077         """
1078         self.registry.add_latex_package(packagename, options, after_hyperref)
1079 
1080     def add_lexer(self, alias: str, lexer: Type[Lexer]) -> None:
1081         """Register a new lexer for source code.
1082 
1083         Use *lexer* to highlight code blocks with the given language *alias*.
1084 
1085         .. versionadded:: 0.6
1086         .. versionchanged:: 2.1
1087            Take a lexer class as an argument.  An instance of lexers are
1088            still supported until Sphinx-3.x.
1089         """
1090         logger.debug('[app] adding lexer: %r', (alias, lexer))
1091         lexer_classes[alias] = lexer
1092 
1093     def add_autodocumenter(self, cls: Any, override: bool = False) -> None:
1094         """Register a new documenter class for the autodoc extension.
1095 
1096         Add *cls* as a new documenter class for the :mod:`sphinx.ext.autodoc`
1097         extension.  It must be a subclass of
1098         :class:`sphinx.ext.autodoc.Documenter`.  This allows to auto-document
1099         new types of objects.  See the source of the autodoc module for
1100         examples on how to subclass :class:`Documenter`.
1101 
1102         If *override* is True, the given *cls* is forcedly installed even if
1103         a documenter having the same name is already installed.
1104 
1105         See :ref:`autodoc_ext_tutorial`.
1106 
1107         .. versionadded:: 0.6
1108         .. versionchanged:: 2.2
1109            Add *override* keyword.
1110         """
1111         logger.debug('[app] adding autodocumenter: %r', cls)
1112         from sphinx.ext.autodoc.directive import AutodocDirective
1113         self.registry.add_documenter(cls.objtype, cls)
1114         self.add_directive('auto' + cls.objtype, AutodocDirective, override=override)
1115 
1116     def add_autodoc_attrgetter(self, typ: Type, getter: Callable[[Any, str, Any], Any]
1117                                ) -> None:
1118         """Register a new ``getattr``-like function for the autodoc extension.
1119 
1120         Add *getter*, which must be a function with an interface compatible to
1121         the :func:`getattr` builtin, as the autodoc attribute getter for
1122         objects that are instances of *typ*.  All cases where autodoc needs to
1123         get an attribute of a type are then handled by this function instead of
1124         :func:`getattr`.
1125 
1126         .. versionadded:: 0.6
1127         """
1128         logger.debug('[app] adding autodoc attrgetter: %r', (typ, getter))
1129         self.registry.add_autodoc_attrgetter(typ, getter)
1130 
1131     def add_search_language(self, cls: Any) -> None:
1132         """Register a new language for the HTML search index.
1133 
1134         Add *cls*, which must be a subclass of
1135         :class:`sphinx.search.SearchLanguage`, as a support language for
1136         building the HTML full-text search index.  The class must have a *lang*
1137         attribute that indicates the language it should be used for.  See
1138         :confval:`html_search_language`.
1139 
1140         .. versionadded:: 1.1
1141         """
1142         logger.debug('[app] adding search language: %r', cls)
1143         from sphinx.search import SearchLanguage, languages
1144         assert issubclass(cls, SearchLanguage)
1145         languages[cls.lang] = cls
1146 
1147     def add_source_suffix(self, suffix: str, filetype: str, override: bool = False) -> None:
1148         """Register a suffix of source files.
1149 
1150         Same as :confval:`source_suffix`.  The users can override this
1151         using the setting.
1152 
1153         If *override* is True, the given *suffix* is forcedly installed even if
1154         a same suffix is already installed.
1155 
1156         .. versionadded:: 1.8
1157         """
1158         self.registry.add_source_suffix(suffix, filetype, override=override)
1159 
1160     def add_source_parser(self, parser: Type[Parser], override: bool = False) -> None:
1161         """Register a parser class.
1162 
1163         If *override* is True, the given *parser* is forcedly installed even if
1164         a parser for the same suffix is already installed.
1165 
1166         .. versionadded:: 1.4
1167         .. versionchanged:: 1.8
1168            *suffix* argument is deprecated.  It only accepts *parser* argument.
1169            Use :meth:`add_source_suffix` API to register suffix instead.
1170         .. versionchanged:: 1.8
1171            Add *override* keyword.
1172         """
1173         self.registry.add_source_parser(parser, override=override)
1174 
1175     def add_env_collector(self, collector: Type[EnvironmentCollector]) -> None:
1176         """Register an environment collector class.
1177 
1178         Refer to :ref:`collector-api`.
1179 
1180         .. versionadded:: 1.6
1181         """
1182         logger.debug('[app] adding environment collector: %r', collector)
1183         collector().enable(self)
1184 
1185     def add_html_theme(self, name: str, theme_path: str) -> None:
1186         """Register a HTML Theme.
1187 
1188         The *name* is a name of theme, and *theme_path* is a full path to the
1189         theme (refs: :ref:`distribute-your-theme`).
1190 
1191         .. versionadded:: 1.6
1192         """
1193         logger.debug('[app] adding HTML theme: %r, %r', name, theme_path)
1194         self.registry.add_html_theme(name, theme_path)
1195 
1196     def add_html_math_renderer(self, name: str,
1197                                inline_renderers: Tuple[Callable, Callable] = None,
1198                                block_renderers: Tuple[Callable, Callable] = None) -> None:
1199         """Register a math renderer for HTML.
1200 
1201         The *name* is a name of math renderer.  Both *inline_renderers* and
1202         *block_renderers* are used as visitor functions for the HTML writer:
1203         the former for inline math node (``nodes.math``), the latter for
1204         block math node (``nodes.math_block``).  Regarding visitor functions,
1205         see :meth:`add_node` for details.
1206 
1207         .. versionadded:: 1.8
1208 
1209         """
1210         self.registry.add_html_math_renderer(name, inline_renderers, block_renderers)
1211 
1212     def add_message_catalog(self, catalog: str, locale_dir: str) -> None:
1213         """Register a message catalog.
1214 
1215         :param catalog: A name of catalog
1216         :param locale_dir: The base path of message catalog
1217 
1218         For more details, see :func:`sphinx.locale.get_translation()`.
1219 
1220         .. versionadded:: 1.8
1221         """
1222         locale.init([locale_dir], self.config.language, catalog)
1223         locale.init_console(locale_dir, catalog)
1224 
1225     # ---- other methods -------------------------------------------------
1226     def is_parallel_allowed(self, typ: str) -> bool:
1227         """Check parallel processing is allowed or not.
1228 
1229         :param typ: A type of processing; ``'read'`` or ``'write'``.
1230         """
1231         if typ == 'read':
1232             attrname = 'parallel_read_safe'
1233             message_not_declared = __("the %s extension does not declare if it "
1234                                       "is safe for parallel reading, assuming "
1235                                       "it isn't - please ask the extension author "
1236                                       "to check and make it explicit")
1237             message_not_safe = __("the %s extension is not safe for parallel reading")
1238         elif typ == 'write':
1239             attrname = 'parallel_write_safe'
1240             message_not_declared = __("the %s extension does not declare if it "
1241                                       "is safe for parallel writing, assuming "
1242                                       "it isn't - please ask the extension author "
1243                                       "to check and make it explicit")
1244             message_not_safe = __("the %s extension is not safe for parallel writing")
1245         else:
1246             raise ValueError('parallel type %s is not supported' % typ)
1247 
1248         for ext in self.extensions.values():
1249             allowed = getattr(ext, attrname, None)
1250             if allowed is None:
1251                 logger.warning(message_not_declared, ext.name)
1252                 logger.warning(__('doing serial %s'), typ)
1253                 return False
1254             elif not allowed:
1255                 logger.warning(message_not_safe, ext.name)
1256                 logger.warning(__('doing serial %s'), typ)
1257                 return False
1258 
1259         return True
1260 
1261     @property
1262     def html_themes(self) -> Dict[str, str]:
1263         warnings.warn('app.html_themes is deprecated.',
1264                       RemovedInSphinx60Warning)
1265         return self.registry.html_themes

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>, <file>sphinx/util/docstrings.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2     sphinx.util.docstrings
3     ~~~~~~~~~~~~~~~~~~~~~~
4 
5     Utilities for docstring processing.
6 
7     :copyright: Copyright 2007-2021 by the Sphinx team, see AUTHORS.
8     :license: BSD, see LICENSE for details.
9 """
10 
11 import re
12 import sys
13 import warnings
14 from typing import Dict, List, Tuple
15 
16 from docutils.parsers.rst.states import Body
17 
18 from sphinx.deprecation import RemovedInSphinx50Warning, RemovedInSphinx60Warning
19 
20 field_list_item_re = re.compile(Body.patterns['field_marker'])
21 
22 
23 def separate_metadata(s: str) -> Tuple[str, Dict[str, str]]:
24     """Separate docstring into metadata and others."""
25     in_other_element = False
26     metadata: Dict[str, str] = {}
27     lines = []
28 
29     if not s:
30         return s, metadata
31 
32     for line in prepare_docstring(s):
33         if line.strip() == '':
34             in_other_element = False
35             lines.append(line)
36         else:
37             matched = field_list_item_re.match(line)
38             if matched and not in_other_element:
39                 field_name = matched.group()[1:].split(':', 1)[0]
40                 if field_name.startswith('meta '):
41                     name = field_name[5:].strip()
42                     metadata[name] = line[matched.end():].strip()
43                 else:
44                     lines.append(line)
45             else:
46                 in_other_element = True
47                 lines.append(line)
48 
49     return '\n'.join(lines), metadata
50 
51 
52 def extract_metadata(s: str) -> Dict[str, str]:
53     warnings.warn("extract_metadata() is deprecated.",
54                   RemovedInSphinx60Warning, stacklevel=2)
55 
56     docstring, metadata = separate_metadata(s)
57     return metadata
58 
59 
60 def prepare_docstring(s: str, ignore: int = None, tabsize: int = 8) -> List[str]:
61     """Convert a docstring into lines of parseable reST.  Remove common leading
62     indentation, where the indentation of a given number of lines (usually just
63     one) is ignored.
64 
65     Return the docstring as a list of lines usable for inserting into a docutils
66     ViewList (used as argument of nested_parse().)  An empty line is added to
67     act as a separator between this docstring and following content.
68     """
69     if ignore is None:
70         ignore = 1
71     else:
72         warnings.warn("The 'ignore' argument to prepare_docstring() is deprecated.",
73                       RemovedInSphinx50Warning, stacklevel=2)
74 
75     lines = s.expandtabs(tabsize).splitlines()
76     # Find minimum indentation of any non-blank lines after ignored lines.
77     margin = sys.maxsize
78     for line in lines[ignore:]:
79         content = len(line.lstrip())
80         if content:
81             indent = len(line) - content
82             margin = min(margin, indent)
83     # Remove indentation from ignored lines.
84     for i in range(ignore):
85         if i < len(lines):
86             lines[i] = lines[i].lstrip()
87     if margin < sys.maxsize:
88         for i in range(ignore, len(lines)):
89             lines[i] = lines[i][margin:]
90     # Remove any leading blank lines.
91     while lines and not lines[0]:
92         lines.pop(0)
93     # make sure there is an empty line at the end
94     if lines and lines[-1]:
95         lines.append('')
96     return lines
97 
98 
99 def prepare_commentdoc(s: str) -> List[str]:
100     """Extract documentation comment lines (starting with #:) and return them
101     as a list of lines.  Returns an empty list if there is no documentation.
102     """
103     result = []
104     lines = [line.strip() for line in s.expandtabs().splitlines()]
105     for line in lines:
106         if line.startswith('#:'):
107             line = line[2:]
108             # the first space after the comment is ignored
109             if line and line[0] == ' ':
110                 line = line[1:]
111             result.append(line)
112     if result and result[-1]:
113         result.append('')
114     return result

</code><intended_behavior>This utility module should ensure that docstring processing functionality properly recognizes and extracts docstrings from type aliases.</intended_behavior>]
2025-10-18 07:12:51.379 | INFO     | Search completed. Bug locations: [<file>sphinx/application.py</file>
<class>Sphinx</class>
<method>add_autodocumenter</method>
<code>
1093     def add_autodocumenter(self, cls: Any, override: bool = False) -> None:
1094         """Register a new documenter class for the autodoc extension.
1095 
1096         Add *cls* as a new documenter class for the :mod:`sphinx.ext.autodoc`
1097         extension.  It must be a subclass of
1098         :class:`sphinx.ext.autodoc.Documenter`.  This allows to auto-document
1099         new types of objects.  See the source of the autodoc module for
1100         examples on how to subclass :class:`Documenter`.
1101 
1102         If *override* is True, the given *cls* is forcedly installed even if
1103         a documenter having the same name is already installed.
1104 
1105         See :ref:`autodoc_ext_tutorial`.
1106 
1107         .. versionadded:: 0.6
1108         .. versionchanged:: 2.2
1109            Add *override* keyword.
1110         """
1111         logger.debug('[app] adding autodocumenter: %r', cls)
1112         from sphinx.ext.autodoc.directive import AutodocDirective
1113         self.registry.add_documenter(cls.objtype, cls)
1114         self.add_directive('auto' + cls.objtype, AutodocDirective, override=override)

</code><intended_behavior>The `add_autodocumenter` method should ensure that a documenter that is capable of handling type aliases is registered and used when generating documentation.</intended_behavior>, <file>sphinx/application.py</file>
<class>Sphinx</class>
<method>None</method>
<code>
126 class Sphinx:
127     """The main application class and extensibility interface.
128 
129     :ivar srcdir: Directory containing source.
130     :ivar confdir: Directory containing ``conf.py``.
131     :ivar doctreedir: Directory for storing pickled doctrees.
132     :ivar outdir: Directory for storing build documents.
133     """
134 
135     warningiserror: bool
136     _warncount: int
137 
138     def __init__(self, srcdir: str, confdir: Optional[str], outdir: str, doctreedir: str,
139                  buildername: str, confoverrides: Dict = None,
140                  status: IO = sys.stdout, warning: IO = sys.stderr,
141                  freshenv: bool = False, warningiserror: bool = False, tags: List[str] = None,
142                  verbosity: int = 0, parallel: int = 0, keep_going: bool = False) -> None:
143         self.phase = BuildPhase.INITIALIZATION
144         self.verbosity = verbosity
145         self.extensions: Dict[str, Extension] = {}
146         self.builder: Optional[Builder] = None
147         self.env: Optional[BuildEnvironment] = None
148         self.project: Optional[Project] = None
149         self.registry = SphinxComponentRegistry()
150 
151         # validate provided directories
152         self.srcdir = abspath(srcdir)
153         self.outdir = abspath(outdir)
154         self.doctreedir = abspath(doctreedir)
155         self.confdir = confdir
156         if self.confdir:  # confdir is optional
157             self.confdir = abspath(self.confdir)
158             if not path.isfile(path.join(self.confdir, 'conf.py')):
159                 raise ApplicationError(__("config directory doesn't contain a "
160                                           "conf.py file (%s)") % confdir)
161 
162         if not path.isdir(self.srcdir):
163             raise ApplicationError(__('Cannot find source directory (%s)') %
164                                    self.srcdir)
165 
166         if path.exists(self.outdir) and not path.isdir(self.outdir):
167             raise ApplicationError(__('Output directory (%s) is not a directory') %
168                                    self.outdir)
169 
170         if self.srcdir == self.outdir:
171             raise ApplicationError(__('Source directory and destination '
172                                       'directory cannot be identical'))
173 
174         self.parallel = parallel
175 
176         if status is None:
177             self._status: IO = StringIO()
178             self.quiet: bool = True
179         else:
180             self._status = status
181             self.quiet = False
182 
183         if warning is None:
184             self._warning: IO = StringIO()
185         else:
186             self._warning = warning
187         self._warncount = 0
188         self.keep_going = warningiserror and keep_going
189         if self.keep_going:
190             self.warningiserror = False
191         else:
192             self.warningiserror = warningiserror
193         logging.setup(self, self._status, self._warning)
194 
195         self.events = EventManager(self)
196 
197         # keep last few messages for traceback
198         # This will be filled by sphinx.util.logging.LastMessagesWriter
199         self.messagelog: deque = deque(maxlen=10)
200 
201         # say hello to the world
202         logger.info(bold(__('Running Sphinx v%s') % sphinx.__display_version__))
203 
204         # notice for parallel build on macOS and py38+
205         if sys.version_info > (3, 8) and platform.system() == 'Darwin' and parallel > 1:
206             logger.info(bold(__("For security reason, parallel mode is disabled on macOS and "
207                                 "python3.8 and above. For more details, please read "
208                                 "https://github.com/sphinx-doc/sphinx/issues/6803")))
209 
210         # status code for command-line application
211         self.statuscode = 0
212 
213         # read config
214         self.tags = Tags(tags)
215         if self.confdir is None:
216             self.config = Config({}, confoverrides or {})
217         else:
218             self.config = Config.read(self.confdir, confoverrides or {}, self.tags)
219 
220         # initialize some limited config variables before initialize i18n and loading
221         # extensions
222         self.config.pre_init_values()
223 
224         # set up translation infrastructure
225         self._init_i18n()
226 
227         # check the Sphinx version if requested
228         if self.config.needs_sphinx and self.config.needs_sphinx > sphinx.__display_version__:
229             raise VersionRequirementError(
230                 __('This project needs at least Sphinx v%s and therefore cannot '
231                    'be built with this version.') % self.config.needs_sphinx)
232 
233         # set confdir to srcdir if -C given (!= no confdir); a few pieces
234         # of code expect a confdir to be set
235         if self.confdir is None:
236             self.confdir = self.srcdir
237 
238         # load all built-in extension modules
239         for extension in builtin_extensions:
240             self.setup_extension(extension)
241 
242         # load all user-given extension modules
243         for extension in self.config.extensions:
244             self.setup_extension(extension)
245 
246         # preload builder module (before init config values)
247         self.preload_builder(buildername)
248 
249         if not path.isdir(outdir):
250             with progress_message(__('making output directory')):
251                 ensuredir(outdir)
252 
253         # the config file itself can be an extension
254         if self.config.setup:
255             prefix = __('while setting up extension %s:') % "conf.py"
256             with prefixed_warnings(prefix):
257                 if callable(self.config.setup):
258                     self.config.setup(self)
259                 else:
260                     raise ConfigError(
261                         __("'setup' as currently defined in conf.py isn't a Python callable. "
262                            "Please modify its definition to make it a callable function. "
263                            "This is needed for conf.py to behave as a Sphinx extension.")
264                     )
265 
266         # now that we know all config values, collect them from conf.py
267         self.config.init_values()
268         self.events.emit('config-inited', self.config)
269 
270         # create the project
271         self.project = Project(self.srcdir, self.config.source_suffix)
272         # create the builder
273         self.builder = self.create_builder(buildername)
274         # set up the build environment
275         self._init_env(freshenv)
276         # set up the builder
277         self._init_builder()
278 
279     def _init_i18n(self) -> None:
280         """Load translated strings from the configured localedirs if enabled in
281         the configuration.
282         """
283         if self.config.language is None:
284             self.translator, has_translation = locale.init([], None)
285         else:
286             logger.info(bold(__('loading translations [%s]... ') % self.config.language),
287                         nonl=True)
288 
289             # compile mo files if sphinx.po file in user locale directories are updated
290             repo = CatalogRepository(self.srcdir, self.config.locale_dirs,
291                                      self.config.language, self.config.source_encoding)
292             for catalog in repo.catalogs:
293                 if catalog.domain == 'sphinx' and catalog.is_outdated():
294                     catalog.write_mo(self.config.language)
295 
296             locale_dirs: List[Optional[str]] = list(repo.locale_dirs)
297             locale_dirs += [None]
298             locale_dirs += [path.join(package_dir, 'locale')]
299 
300             self.translator, has_translation = locale.init(locale_dirs, self.config.language)
301             if has_translation or self.config.language == 'en':
302                 # "en" never needs to be translated
303                 logger.info(__('done'))
304             else:
305                 logger.info(__('not available for built-in messages'))
306 
307     def _init_env(self, freshenv: bool) -> None:
308         filename = path.join(self.doctreedir, ENV_PICKLE_FILENAME)
309         if freshenv or not os.path.exists(filename):
310             self.env = BuildEnvironment()
311             self.env.setup(self)
312             self.env.find_files(self.config, self.builder)
313         else:
314             try:
315                 with progress_message(__('loading pickled environment')):
316                     with open(filename, 'rb') as f:
317                         self.env = pickle.load(f)
318                         self.env.setup(self)
319             except Exception as err:
320                 logger.info(__('failed: %s'), err)
321                 self._init_env(freshenv=True)
322 
323     def preload_builder(self, name: str) -> None:
324         self.registry.preload_builder(self, name)
325 
326     def create_builder(self, name: str) -> "Builder":
327         if name is None:
328             logger.info(__('No builder selected, using default: html'))
329             name = 'html'
330 
331         return self.registry.create_builder(self, name)
332 
333     def _init_builder(self) -> None:
334         self.builder.set_environment(self.env)
335         self.builder.init()
336         self.events.emit('builder-inited')
337 
338     # ---- main "build" method -------------------------------------------------
339 
340     def build(self, force_all: bool = False, filenames: List[str] = None) -> None:
341         self.phase = BuildPhase.READING
342         try:
343             if force_all:
344                 self.builder.compile_all_catalogs()
345                 self.builder.build_all()
346             elif filenames:
347                 self.builder.compile_specific_catalogs(filenames)
348                 self.builder.build_specific(filenames)
349             else:
350                 self.builder.compile_update_catalogs()
351                 self.builder.build_update()
352 
353             if self._warncount and self.keep_going:
354                 self.statuscode = 1
355 
356             status = (__('succeeded') if self.statuscode == 0
357                       else __('finished with problems'))
358             if self._warncount:
359                 if self.warningiserror:
360                     if self._warncount == 1:
361                         msg = __('build %s, %s warning (with warnings treated as errors).')
362                     else:
363                         msg = __('build %s, %s warnings (with warnings treated as errors).')
364                 else:
365                     if self._warncount == 1:
366                         msg = __('build %s, %s warning.')
367                     else:
368                         msg = __('build %s, %s warnings.')
369 
370                 logger.info(bold(msg % (status, self._warncount)))
371             else:
372                 logger.info(bold(__('build %s.') % status))
373 
374             if self.statuscode == 0 and self.builder.epilog:
375                 logger.info('')
376                 logger.info(self.builder.epilog % {
377                     'outdir': relpath(self.outdir),
378                     'project': self.config.project
379                 })
380         except Exception as err:
381             # delete the saved env to force a fresh build next time
382             envfile = path.join(self.doctreedir, ENV_PICKLE_FILENAME)
383             if path.isfile(envfile):
384                 os.unlink(envfile)
385             self.events.emit('build-finished', err)
386             raise
387         else:
388             self.events.emit('build-finished', None)
389         self.builder.cleanup()
390 
391     # ---- general extensibility interface -------------------------------------
392 
393     def setup_extension(self, extname: str) -> None:
394         """Import and setup a Sphinx extension module.
395 
396         Load the extension given by the module *name*.  Use this if your
397         extension needs the features provided by another extension.  No-op if
398         called twice.
399         """
400         logger.debug('[app] setting up extension: %r', extname)
401         self.registry.load_extension(self, extname)
402 
403     def require_sphinx(self, version: str) -> None:
404         """Check the Sphinx version if requested.
405 
406         Compare *version* with the version of the running Sphinx, and abort the
407         build when it is too old.
408 
409         :param version: The required version in the form of ``major.minor``.
410 
411         .. versionadded:: 1.0
412         """
413         if version > sphinx.__display_version__[:3]:
414             raise VersionRequirementError(version)
415 
416     # event interface
417     def connect(self, event: str, callback: Callable, priority: int = 500) -> int:
418         """Register *callback* to be called when *event* is emitted.
419 
420         For details on available core events and the arguments of callback
421         functions, please see :ref:`events`.
422 
423         :param event: The name of target event
424         :param callback: Callback function for the event
425         :param priority: The priority of the callback.  The callbacks will be invoked
426                          in the order of *priority* in asending.
427         :return: A listener ID.  It can be used for :meth:`disconnect`.
428 
429         .. versionchanged:: 3.0
430 
431            Support *priority*
432         """
433         listener_id = self.events.connect(event, callback, priority)
434         logger.debug('[app] connecting event %r (%d): %r [id=%s]',
435                      event, priority, callback, listener_id)
436         return listener_id
437 
438     def disconnect(self, listener_id: int) -> None:
439         """Unregister callback by *listener_id*.
440 
441         :param listener_id: A listener_id that :meth:`connect` returns
442         """
443         logger.debug('[app] disconnecting event: [id=%s]', listener_id)
444         self.events.disconnect(listener_id)
445 
446     def emit(self, event: str, *args: Any,
447              allowed_exceptions: Tuple[Type[Exception], ...] = ()) -> List:
448         """Emit *event* and pass *arguments* to the callback functions.
449 
450         Return the return values of all callbacks as a list.  Do not emit core
451         Sphinx events in extensions!
452 
453         :param event: The name of event that will be emitted
454         :param args: The arguments for the event
455         :param allowed_exceptions: The list of exceptions that are allowed in the callbacks
456 
457         .. versionchanged:: 3.1
458 
459            Added *allowed_exceptions* to specify path-through exceptions
460         """
461         return self.events.emit(event, *args, allowed_exceptions=allowed_exceptions)
462 
463     def emit_firstresult(self, event: str, *args: Any,
464                          allowed_exceptions: Tuple[Type[Exception], ...] = ()) -> Any:
465         """Emit *event* and pass *arguments* to the callback functions.
466 
467         Return the result of the first callback that doesn't return ``None``.
468 
469         :param event: The name of event that will be emitted
470         :param args: The arguments for the event
471         :param allowed_exceptions: The list of exceptions that are allowed in the callbacks
472 
473         .. versionadded:: 0.5
474         .. versionchanged:: 3.1
475 
476            Added *allowed_exceptions* to specify path-through exceptions
477         """
478         return self.events.emit_firstresult(event, *args,
479                                             allowed_exceptions=allowed_exceptions)
480 
481     # registering addon parts
482 
483     def add_builder(self, builder: Type["Builder"], override: bool = False) -> None:
484         """Register a new builder.
485 
486         :param builder: A builder class
487         :param override: If true, install the builder forcedly even if another builder
488                          is already installed as the same name
489 
490         .. versionchanged:: 1.8
491            Add *override* keyword.
492         """
493         self.registry.add_builder(builder, override=override)
494 
495     # TODO(stephenfin): Describe 'types' parameter
496     def add_config_value(self, name: str, default: Any, rebuild: Union[bool, str],
497                          types: Any = ()) -> None:
498         """Register a configuration value.
499 
500         This is necessary for Sphinx to recognize new values and set default
501         values accordingly.
502 
503 
504         :param name: The name of configuration value.  It is recommended to be prefixed
505                      with the extension name (ex. ``html_logo``, ``epub_title``)
506         :param default: The default value of the configuration.
507         :param rebuild: The condition of rebuild.  It must be one of those values:
508 
509                         * ``'env'`` if a change in the setting only takes effect when a
510                           document is parsed -- this means that the whole environment must be
511                           rebuilt.
512                         * ``'html'`` if a change in the setting needs a full rebuild of HTML
513                           documents.
514                         * ``''`` if a change in the setting will not need any special rebuild.
515         :param types: The type of configuration value.  A list of types can be specified.  For
516                       example, ``[str]`` is used to describe a configuration that takes string
517                       value.
518 
519         .. versionchanged:: 0.4
520            If the *default* value is a callable, it will be called with the
521            config object as its argument in order to get the default value.
522            This can be used to implement config values whose default depends on
523            other values.
524 
525         .. versionchanged:: 0.6
526            Changed *rebuild* from a simple boolean (equivalent to ``''`` or
527            ``'env'``) to a string.  However, booleans are still accepted and
528            converted internally.
529         """
530         logger.debug('[app] adding config value: %r', (name, default, rebuild, types))
531         if rebuild in (False, True):
532             rebuild = 'env' if rebuild else ''
533         self.config.add(name, default, rebuild, types)
534 
535     def add_event(self, name: str) -> None:
536         """Register an event called *name*.
537 
538         This is needed to be able to emit it.
539 
540         :param name: The name of the event
541         """
542         logger.debug('[app] adding event: %r', name)
543         self.events.add(name)
544 
545     def set_translator(self, name: str, translator_class: Type[nodes.NodeVisitor],
546                        override: bool = False) -> None:
547         """Register or override a Docutils translator class.
548 
549         This is used to register a custom output translator or to replace a
550         builtin translator.  This allows extensions to use custom translator
551         and define custom nodes for the translator (see :meth:`add_node`).
552 
553         :param name: The name of builder for the translator
554         :param translator_class: A translator class
555         :param override: If true, install the translator forcedly even if another translator
556                          is already installed as the same name
557 
558         .. versionadded:: 1.3
559         .. versionchanged:: 1.8
560            Add *override* keyword.
561         """
562         self.registry.add_translator(name, translator_class, override=override)
563 
564     def add_node(self, node: Type[Element], override: bool = False,
565                  **kwargs: Tuple[Callable, Optional[Callable]]) -> None:
566         """Register a Docutils node class.
567 
568         This is necessary for Docutils internals.  It may also be used in the
569         future to validate nodes in the parsed documents.
570 
571         :param node: A node class
572         :param kwargs: Visitor functions for each builder (see below)
573         :param override: If true, install the node forcedly even if another node is already
574                          installed as the same name
575 
576         Node visitor functions for the Sphinx HTML, LaTeX, text and manpage
577         writers can be given as keyword arguments: the keyword should be one or
578         more of ``'html'``, ``'latex'``, ``'text'``, ``'man'``, ``'texinfo'``
579         or any other supported translators, the value a 2-tuple of ``(visit,
580         depart)`` methods.  ``depart`` can be ``None`` if the ``visit``
581         function raises :exc:`docutils.nodes.SkipNode`.  Example:
582 
583         .. code-block:: python
584 
585            class math(docutils.nodes.Element): pass
586 
587            def visit_math_html(self, node):
588                self.body.append(self.starttag(node, 'math'))
589            def depart_math_html(self, node):
590                self.body.append('</math>')
591 
592            app.add_node(math, html=(visit_math_html, depart_math_html))
593 
594         Obviously, translators for which you don't specify visitor methods will
595         choke on the node when encountered in a document to translate.
596 
597         .. versionchanged:: 0.5
598            Added the support for keyword arguments giving visit functions.
599         """
600         logger.debug('[app] adding node: %r', (node, kwargs))
601         if not override and docutils.is_node_registered(node):
602             logger.warning(__('node class %r is already registered, '
603                               'its visitors will be overridden'),
604                            node.__name__, type='app', subtype='add_node')
605         docutils.register_node(node)
606         self.registry.add_translation_handlers(node, **kwargs)
607 
608     def add_enumerable_node(self, node: Type[Element], figtype: str,
609                             title_getter: TitleGetter = None, override: bool = False,
610                             **kwargs: Tuple[Callable, Callable]) -> None:
611         """Register a Docutils node class as a numfig target.
612 
613         Sphinx numbers the node automatically. And then the users can refer it
614         using :rst:role:`numref`.
615 
616         :param node: A node class
617         :param figtype: The type of enumerable nodes.  Each figtypes have individual numbering
618                         sequences.  As a system figtypes, ``figure``, ``table`` and
619                         ``code-block`` are defined.  It is able to add custom nodes to these
620                         default figtypes.  It is also able to define new custom figtype if new
621                         figtype is given.
622         :param title_getter: A getter function to obtain the title of node.  It takes an
623                              instance of the enumerable node, and it must return its title as
624                              string.  The title is used to the default title of references for
625                              :rst:role:`ref`.  By default, Sphinx searches
626                              ``docutils.nodes.caption`` or ``docutils.nodes.title`` from the
627                              node as a title.
628         :param kwargs: Visitor functions for each builder (same as :meth:`add_node`)
629         :param override: If true, install the node forcedly even if another node is already
630                          installed as the same name
631 
632         .. versionadded:: 1.4
633         """
634         self.registry.add_enumerable_node(node, figtype, title_getter, override=override)
635         self.add_node(node, override=override, **kwargs)
636 
637     def add_directive(self, name: str, cls: Type[Directive], override: bool = False) -> None:
638         """Register a Docutils directive.
639 
640         :param name: The name of directive
641         :param cls: A directive class
642         :param override: If true, install the directive forcedly even if another directive
643                          is already installed as the same name
644 
645         For example, a custom directive named ``my-directive`` would be added
646         like this:
647 
648         .. code-block:: python
649 
650            from docutils.parsers.rst import Directive, directives
651 
652            class MyDirective(Directive):
653                has_content = True
654                required_arguments = 1
655                optional_arguments = 0
656                final_argument_whitespace = True
657                option_spec = {
658                    'class': directives.class_option,
659                    'name': directives.unchanged,
660                }
661 
662                def run(self):
663                    ...
664 
665            def setup(app):
666                add_directive('my-directive', MyDirective)
667 
668         For more details, see `the Docutils docs
669         <http://docutils.sourceforge.net/docs/howto/rst-directives.html>`__ .
670 
671         .. versionchanged:: 0.6
672            Docutils 0.5-style directive classes are now supported.
673         .. deprecated:: 1.8
674            Docutils 0.4-style (function based) directives support is deprecated.
675         .. versionchanged:: 1.8
676            Add *override* keyword.
677         """
678         logger.debug('[app] adding directive: %r', (name, cls))
679         if not override and docutils.is_directive_registered(name):
680             logger.warning(__('directive %r is already registered, it will be overridden'),
681                            name, type='app', subtype='add_directive')
682 
683         docutils.register_directive(name, cls)
684 
685     def add_role(self, name: str, role: Any, override: bool = False) -> None:
686         """Register a Docutils role.
687 
688         :param name: The name of role
689         :param role: A role function
690         :param override: If true, install the role forcedly even if another role is already
691                          installed as the same name
692 
693         For more details about role functions, see `the Docutils docs
694         <http://docutils.sourceforge.net/docs/howto/rst-roles.html>`__ .
695 
696         .. versionchanged:: 1.8
697            Add *override* keyword.
698         """
699         logger.debug('[app] adding role: %r', (name, role))
700         if not override and docutils.is_role_registered(name):
701             logger.warning(__('role %r is already registered, it will be overridden'),
702                            name, type='app', subtype='add_role')
703         docutils.register_role(name, role)
704 
705     def add_generic_role(self, name: str, nodeclass: Any, override: bool = False) -> None:
706         """Register a generic Docutils role.
707 
708         Register a Docutils role that does nothing but wrap its contents in the
709         node given by *nodeclass*.
710 
711         If *override* is True, the given *nodeclass* is forcedly installed even if
712         a role named as *name* is already installed.
713 
714         .. versionadded:: 0.6
715         .. versionchanged:: 1.8
716            Add *override* keyword.
717         """
718         # Don't use ``roles.register_generic_role`` because it uses
719         # ``register_canonical_role``.
720         logger.debug('[app] adding generic role: %r', (name, nodeclass))
721         if not override and docutils.is_role_registered(name):
722             logger.warning(__('role %r is already registered, it will be overridden'),
723                            name, type='app', subtype='add_generic_role')
724         role = roles.GenericRole(name, nodeclass)
725         docutils.register_role(name, role)
726 
727     def add_domain(self, domain: Type[Domain], override: bool = False) -> None:
728         """Register a domain.
729 
730         :param domain: A domain class
731         :param override: If true, install the domain forcedly even if another domain
732                          is already installed as the same name
733 
734         .. versionadded:: 1.0
735         .. versionchanged:: 1.8
736            Add *override* keyword.
737         """
738         self.registry.add_domain(domain, override=override)
739 
740     def add_directive_to_domain(self, domain: str, name: str,
741                                 cls: Type[Directive], override: bool = False) -> None:
742         """Register a Docutils directive in a domain.
743 
744         Like :meth:`add_directive`, but the directive is added to the domain
745         named *domain*.
746 
747         :param domain: The name of target domain
748         :param name: A name of directive
749         :param cls: A directive class
750         :param override: If true, install the directive forcedly even if another directive
751                          is already installed as the same name
752 
753         .. versionadded:: 1.0
754         .. versionchanged:: 1.8
755            Add *override* keyword.
756         """
757         self.registry.add_directive_to_domain(domain, name, cls, override=override)
758 
759     def add_role_to_domain(self, domain: str, name: str, role: Union[RoleFunction, XRefRole],
760                            override: bool = False) -> None:
761         """Register a Docutils role in a domain.
762 
763         Like :meth:`add_role`, but the role is added to the domain named
764         *domain*.
765 
766         :param domain: The name of target domain
767         :param name: A name of role
768         :param role: A role function
769         :param override: If true, install the role forcedly even if another role is already
770                          installed as the same name
771 
772         .. versionadded:: 1.0
773         .. versionchanged:: 1.8
774            Add *override* keyword.
775         """
776         self.registry.add_role_to_domain(domain, name, role, override=override)
777 
778     def add_index_to_domain(self, domain: str, index: Type[Index], override: bool = False
779                             ) -> None:
780         """Register a custom index for a domain.
781 
782         Add a custom *index* class to the domain named *domain*.
783 
784         :param domain: The name of target domain
785         :param index: A index class
786         :param override: If true, install the index forcedly even if another index is
787                          already installed as the same name
788 
789         .. versionadded:: 1.0
790         .. versionchanged:: 1.8
791            Add *override* keyword.
792         """
793         self.registry.add_index_to_domain(domain, index)
794 
795     def add_object_type(self, directivename: str, rolename: str, indextemplate: str = '',
796                         parse_node: Callable = None, ref_nodeclass: Type[TextElement] = None,
797                         objname: str = '', doc_field_types: List = [], override: bool = False
798                         ) -> None:
799         """Register a new object type.
800 
801         This method is a very convenient way to add a new :term:`object` type
802         that can be cross-referenced.  It will do this:
803 
804         - Create a new directive (called *directivename*) for documenting an
805           object.  It will automatically add index entries if *indextemplate*
806           is nonempty; if given, it must contain exactly one instance of
807           ``%s``.  See the example below for how the template will be
808           interpreted.
809         - Create a new role (called *rolename*) to cross-reference to these
810           object descriptions.
811         - If you provide *parse_node*, it must be a function that takes a
812           string and a docutils node, and it must populate the node with
813           children parsed from the string.  It must then return the name of the
814           item to be used in cross-referencing and index entries.  See the
815           :file:`conf.py` file in the source for this documentation for an
816           example.
817         - The *objname* (if not given, will default to *directivename*) names
818           the type of object.  It is used when listing objects, e.g. in search
819           results.
820 
821         For example, if you have this call in a custom Sphinx extension::
822 
823            app.add_object_type('directive', 'dir', 'pair: %s; directive')
824 
825         you can use this markup in your documents::
826 
827            .. rst:directive:: function
828 
829               Document a function.
830 
831            <...>
832 
833            See also the :rst:dir:`function` directive.
834 
835         For the directive, an index entry will be generated as if you had prepended ::
836 
837            .. index:: pair: function; directive
838 
839         The reference node will be of class ``literal`` (so it will be rendered
840         in a proportional font, as appropriate for code) unless you give the
841         *ref_nodeclass* argument, which must be a docutils node class.  Most
842         useful are ``docutils.nodes.emphasis`` or ``docutils.nodes.strong`` --
843         you can also use ``docutils.nodes.generated`` if you want no further
844         text decoration.  If the text should be treated as literal (e.g. no
845         smart quote replacement), but not have typewriter styling, use
846         ``sphinx.addnodes.literal_emphasis`` or
847         ``sphinx.addnodes.literal_strong``.
848 
849         For the role content, you have the same syntactical possibilities as
850         for standard Sphinx roles (see :ref:`xref-syntax`).
851 
852         If *override* is True, the given object_type is forcedly installed even if
853         an object_type having the same name is already installed.
854 
855         .. versionchanged:: 1.8
856            Add *override* keyword.
857         """
858         self.registry.add_object_type(directivename, rolename, indextemplate, parse_node,
859                                       ref_nodeclass, objname, doc_field_types,
860                                       override=override)
861 
862     def add_crossref_type(self, directivename: str, rolename: str, indextemplate: str = '',
863                           ref_nodeclass: Type[TextElement] = None, objname: str = '',
864                           override: bool = False) -> None:
865         """Register a new crossref object type.
866 
867         This method is very similar to :meth:`add_object_type` except that the
868         directive it generates must be empty, and will produce no output.
869 
870         That means that you can add semantic targets to your sources, and refer
871         to them using custom roles instead of generic ones (like
872         :rst:role:`ref`).  Example call::
873 
874            app.add_crossref_type('topic', 'topic', 'single: %s',
875                                  docutils.nodes.emphasis)
876 
877         Example usage::
878 
879            .. topic:: application API
880 
881            The application API
882            -------------------
883 
884            Some random text here.
885 
886            See also :topic:`this section <application API>`.
887 
888         (Of course, the element following the ``topic`` directive needn't be a
889         section.)
890 
891         If *override* is True, the given crossref_type is forcedly installed even if
892         a crossref_type having the same name is already installed.
893 
894         .. versionchanged:: 1.8
895            Add *override* keyword.
896         """
897         self.registry.add_crossref_type(directivename, rolename,
898                                         indextemplate, ref_nodeclass, objname,
899                                         override=override)
900 
901     def add_transform(self, transform: Type[Transform]) -> None:
902         """Register a Docutils transform to be applied after parsing.
903 
904         Add the standard docutils :class:`Transform` subclass *transform* to
905         the list of transforms that are applied after Sphinx parses a reST
906         document.
907 
908         :param transform: A transform class
909 
910         .. list-table:: priority range categories for Sphinx transforms
911            :widths: 20,80
912 
913            * - Priority
914              - Main purpose in Sphinx
915            * - 0-99
916              - Fix invalid nodes by docutils. Translate a doctree.
917            * - 100-299
918              - Preparation
919            * - 300-399
920              - early
921            * - 400-699
922              - main
923            * - 700-799
924              - Post processing. Deadline to modify text and referencing.
925            * - 800-899
926              - Collect referencing and referenced nodes. Domain processing.
927            * - 900-999
928              - Finalize and clean up.
929 
930         refs: `Transform Priority Range Categories`__
931 
932         __ http://docutils.sourceforge.net/docs/ref/transforms.html#transform-priority-range-categories
933         """  # NOQA
934         self.registry.add_transform(transform)
935 
936     def add_post_transform(self, transform: Type[Transform]) -> None:
937         """Register a Docutils transform to be applied before writing.
938 
939         Add the standard docutils :class:`Transform` subclass *transform* to
940         the list of transforms that are applied before Sphinx writes a
941         document.
942 
943         :param transform: A transform class
944         """
945         self.registry.add_post_transform(transform)
946 
947     def add_js_file(self, filename: str, priority: int = 500, **kwargs: Any) -> None:
948         """Register a JavaScript file to include in the HTML output.
949 
950         Add *filename* to the list of JavaScript files that the default HTML
951         template will include in order of *priority* (ascending).  The filename
952         must be relative to the HTML static path , or a full URI with scheme.
953         If the priority of JavaScript file is the same as others, the JavaScript
954         files will be included in order of the registration.  If the keyword
955         argument ``body`` is given, its value will be added between the
956         ``<script>`` tags. Extra keyword arguments are included as attributes of
957         the ``<script>`` tag.
958 
959         Example::
960 
961             app.add_js_file('example.js')
962             # => <script src="_static/example.js"></script>
963 
964             app.add_js_file('example.js', async="async")
965             # => <script src="_static/example.js" async="async"></script>
966 
967             app.add_js_file(None, body="var myVariable = 'foo';")
968             # => <script>var myVariable = 'foo';</script>
969 
970         .. list-table:: priority range for JavaScript files
971            :widths: 20,80
972 
973            * - Priority
974              - Main purpose in Sphinx
975            * - 200
976              - default priority for built-in JavaScript files
977            * - 500
978              - default priority for extensions
979            * - 800
980              - default priority for :confval:`html_js_files`
981 
982         A JavaScript file can be added to the specific HTML page when on extension
983         calls this method on :event:`html-page-context` event.
984 
985         .. versionadded:: 0.5
986 
987         .. versionchanged:: 1.8
988            Renamed from ``app.add_javascript()``.
989            And it allows keyword arguments as attributes of script tag.
990 
991         .. versionchanged:: 3.5
992            Take priority argument.  Allow to add a JavaScript file to the specific page.
993         """
994         self.registry.add_js_file(filename, priority=priority, **kwargs)
995         if hasattr(self.builder, 'add_js_file'):
996             self.builder.add_js_file(filename, priority=priority, **kwargs)  # type: ignore
997 
998     def add_css_file(self, filename: str, priority: int = 500, **kwargs: Any) -> None:
999         """Register a stylesheet to include in the HTML output.
1000 
1001         Add *filename* to the list of CSS files that the default HTML template
1002         will include in order of *priority* (ascending).  The filename must be
1003         relative to the HTML static path, or a full URI with scheme.  If the
1004         priority of CSS file is the same as others, the CSS files will be
1005         included in order of the registration.  The keyword arguments are also
1006         accepted for attributes of ``<link>`` tag.
1007 
1008         Example::
1009 
1010             app.add_css_file('custom.css')
1011             # => <link rel="stylesheet" href="_static/custom.css" type="text/css" />
1012 
1013             app.add_css_file('print.css', media='print')
1014             # => <link rel="stylesheet" href="_static/print.css"
1015             #          type="text/css" media="print" />
1016 
1017             app.add_css_file('fancy.css', rel='alternate stylesheet', title='fancy')
1018             # => <link rel="alternate stylesheet" href="_static/fancy.css"
1019             #          type="text/css" title="fancy" />
1020 
1021         .. list-table:: priority range for CSS files
1022            :widths: 20,80
1023 
1024            * - Priority
1025              - Main purpose in Sphinx
1026            * - 200
1027              - default priority for built-in CSS files
1028            * - 500
1029              - default priority for extensions
1030            * - 800
1031              - default priority for :confval:`html_css_files`
1032 
1033         A CSS file can be added to the specific HTML page when on extension calls
1034         this method on :event:`html-page-context` event.
1035 
1036         .. versionadded:: 1.0
1037 
1038         .. versionchanged:: 1.6
1039            Optional ``alternate`` and/or ``title`` attributes can be supplied
1040            with the *alternate* (of boolean type) and *title* (a string)
1041            arguments. The default is no title and *alternate* = ``False``. For
1042            more information, refer to the `documentation
1043            <https://mdn.io/Web/CSS/Alternative_style_sheets>`__.
1044 
1045         .. versionchanged:: 1.8
1046            Renamed from ``app.add_stylesheet()``.
1047            And it allows keyword arguments as attributes of link tag.
1048 
1049         .. versionchanged:: 3.5
1050            Take priority argument.  Allow to add a CSS file to the specific page.
1051         """
1052         logger.debug('[app] adding stylesheet: %r', filename)
1053         self.registry.add_css_files(filename, priority=priority, **kwargs)
1054         if hasattr(self.builder, 'add_css_file'):
1055             self.builder.add_css_file(filename, priority=priority, **kwargs)  # type: ignore
1056 
1057     def add_latex_package(self, packagename: str, options: str = None,
1058                           after_hyperref: bool = False) -> None:
1059         r"""Register a package to include in the LaTeX source code.
1060 
1061         Add *packagename* to the list of packages that LaTeX source code will
1062         include.  If you provide *options*, it will be taken to `\usepackage`
1063         declaration.  If you set *after_hyperref* truthy, the package will be
1064         loaded after ``hyperref`` package.
1065 
1066         .. code-block:: python
1067 
1068            app.add_latex_package('mypackage')
1069            # => \usepackage{mypackage}
1070            app.add_latex_package('mypackage', 'foo,bar')
1071            # => \usepackage[foo,bar]{mypackage}
1072 
1073         .. versionadded:: 1.3
1074         .. versionadded:: 3.1
1075 
1076            *after_hyperref* option.
1077         """
1078         self.registry.add_latex_package(packagename, options, after_hyperref)
1079 
1080     def add_lexer(self, alias: str, lexer: Type[Lexer]) -> None:
1081         """Register a new lexer for source code.
1082 
1083         Use *lexer* to highlight code blocks with the given language *alias*.
1084 
1085         .. versionadded:: 0.6
1086         .. versionchanged:: 2.1
1087            Take a lexer class as an argument.  An instance of lexers are
1088            still supported until Sphinx-3.x.
1089         """
1090         logger.debug('[app] adding lexer: %r', (alias, lexer))
1091         lexer_classes[alias] = lexer
1092 
1093     def add_autodocumenter(self, cls: Any, override: bool = False) -> None:
1094         """Register a new documenter class for the autodoc extension.
1095 
1096         Add *cls* as a new documenter class for the :mod:`sphinx.ext.autodoc`
1097         extension.  It must be a subclass of
1098         :class:`sphinx.ext.autodoc.Documenter`.  This allows to auto-document
1099         new types of objects.  See the source of the autodoc module for
1100         examples on how to subclass :class:`Documenter`.
1101 
1102         If *override* is True, the given *cls* is forcedly installed even if
1103         a documenter having the same name is already installed.
1104 
1105         See :ref:`autodoc_ext_tutorial`.
1106 
1107         .. versionadded:: 0.6
1108         .. versionchanged:: 2.2
1109            Add *override* keyword.
1110         """
1111         logger.debug('[app] adding autodocumenter: %r', cls)
1112         from sphinx.ext.autodoc.directive import AutodocDirective
1113         self.registry.add_documenter(cls.objtype, cls)
1114         self.add_directive('auto' + cls.objtype, AutodocDirective, override=override)
1115 
1116     def add_autodoc_attrgetter(self, typ: Type, getter: Callable[[Any, str, Any], Any]
1117                                ) -> None:
1118         """Register a new ``getattr``-like function for the autodoc extension.
1119 
1120         Add *getter*, which must be a function with an interface compatible to
1121         the :func:`getattr` builtin, as the autodoc attribute getter for
1122         objects that are instances of *typ*.  All cases where autodoc needs to
1123         get an attribute of a type are then handled by this function instead of
1124         :func:`getattr`.
1125 
1126         .. versionadded:: 0.6
1127         """
1128         logger.debug('[app] adding autodoc attrgetter: %r', (typ, getter))
1129         self.registry.add_autodoc_attrgetter(typ, getter)
1130 
1131     def add_search_language(self, cls: Any) -> None:
1132         """Register a new language for the HTML search index.
1133 
1134         Add *cls*, which must be a subclass of
1135         :class:`sphinx.search.SearchLanguage`, as a support language for
1136         building the HTML full-text search index.  The class must have a *lang*
1137         attribute that indicates the language it should be used for.  See
1138         :confval:`html_search_language`.
1139 
1140         .. versionadded:: 1.1
1141         """
1142         logger.debug('[app] adding search language: %r', cls)
1143         from sphinx.search import SearchLanguage, languages
1144         assert issubclass(cls, SearchLanguage)
1145         languages[cls.lang] = cls
1146 
1147     def add_source_suffix(self, suffix: str, filetype: str, override: bool = False) -> None:
1148         """Register a suffix of source files.
1149 
1150         Same as :confval:`source_suffix`.  The users can override this
1151         using the setting.
1152 
1153         If *override* is True, the given *suffix* is forcedly installed even if
1154         a same suffix is already installed.
1155 
1156         .. versionadded:: 1.8
1157         """
1158         self.registry.add_source_suffix(suffix, filetype, override=override)
1159 
1160     def add_source_parser(self, parser: Type[Parser], override: bool = False) -> None:
1161         """Register a parser class.
1162 
1163         If *override* is True, the given *parser* is forcedly installed even if
1164         a parser for the same suffix is already installed.
1165 
1166         .. versionadded:: 1.4
1167         .. versionchanged:: 1.8
1168            *suffix* argument is deprecated.  It only accepts *parser* argument.
1169            Use :meth:`add_source_suffix` API to register suffix instead.
1170         .. versionchanged:: 1.8
1171            Add *override* keyword.
1172         """
1173         self.registry.add_source_parser(parser, override=override)
1174 
1175     def add_env_collector(self, collector: Type[EnvironmentCollector]) -> None:
1176         """Register an environment collector class.
1177 
1178         Refer to :ref:`collector-api`.
1179 
1180         .. versionadded:: 1.6
1181         """
1182         logger.debug('[app] adding environment collector: %r', collector)
1183         collector().enable(self)
1184 
1185     def add_html_theme(self, name: str, theme_path: str) -> None:
1186         """Register a HTML Theme.
1187 
1188         The *name* is a name of theme, and *theme_path* is a full path to the
1189         theme (refs: :ref:`distribute-your-theme`).
1190 
1191         .. versionadded:: 1.6
1192         """
1193         logger.debug('[app] adding HTML theme: %r, %r', name, theme_path)
1194         self.registry.add_html_theme(name, theme_path)
1195 
1196     def add_html_math_renderer(self, name: str,
1197                                inline_renderers: Tuple[Callable, Callable] = None,
1198                                block_renderers: Tuple[Callable, Callable] = None) -> None:
1199         """Register a math renderer for HTML.
1200 
1201         The *name* is a name of math renderer.  Both *inline_renderers* and
1202         *block_renderers* are used as visitor functions for the HTML writer:
1203         the former for inline math node (``nodes.math``), the latter for
1204         block math node (``nodes.math_block``).  Regarding visitor functions,
1205         see :meth:`add_node` for details.
1206 
1207         .. versionadded:: 1.8
1208 
1209         """
1210         self.registry.add_html_math_renderer(name, inline_renderers, block_renderers)
1211 
1212     def add_message_catalog(self, catalog: str, locale_dir: str) -> None:
1213         """Register a message catalog.
1214 
1215         :param catalog: A name of catalog
1216         :param locale_dir: The base path of message catalog
1217 
1218         For more details, see :func:`sphinx.locale.get_translation()`.
1219 
1220         .. versionadded:: 1.8
1221         """
1222         locale.init([locale_dir], self.config.language, catalog)
1223         locale.init_console(locale_dir, catalog)
1224 
1225     # ---- other methods -------------------------------------------------
1226     def is_parallel_allowed(self, typ: str) -> bool:
1227         """Check parallel processing is allowed or not.
1228 
1229         :param typ: A type of processing; ``'read'`` or ``'write'``.
1230         """
1231         if typ == 'read':
1232             attrname = 'parallel_read_safe'
1233             message_not_declared = __("the %s extension does not declare if it "
1234                                       "is safe for parallel reading, assuming "
1235                                       "it isn't - please ask the extension author "
1236                                       "to check and make it explicit")
1237             message_not_safe = __("the %s extension is not safe for parallel reading")
1238         elif typ == 'write':
1239             attrname = 'parallel_write_safe'
1240             message_not_declared = __("the %s extension does not declare if it "
1241                                       "is safe for parallel writing, assuming "
1242                                       "it isn't - please ask the extension author "
1243                                       "to check and make it explicit")
1244             message_not_safe = __("the %s extension is not safe for parallel writing")
1245         else:
1246             raise ValueError('parallel type %s is not supported' % typ)
1247 
1248         for ext in self.extensions.values():
1249             allowed = getattr(ext, attrname, None)
1250             if allowed is None:
1251                 logger.warning(message_not_declared, ext.name)
1252                 logger.warning(__('doing serial %s'), typ)
1253                 return False
1254             elif not allowed:
1255                 logger.warning(message_not_safe, ext.name)
1256                 logger.warning(__('doing serial %s'), typ)
1257                 return False
1258 
1259         return True
1260 
1261     @property
1262     def html_themes(self) -> Dict[str, str]:
1263         warnings.warn('app.html_themes is deprecated.',
1264                       RemovedInSphinx60Warning)
1265         return self.registry.html_themes

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>, <file>sphinx/util/docstrings.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2     sphinx.util.docstrings
3     ~~~~~~~~~~~~~~~~~~~~~~
4 
5     Utilities for docstring processing.
6 
7     :copyright: Copyright 2007-2021 by the Sphinx team, see AUTHORS.
8     :license: BSD, see LICENSE for details.
9 """
10 
11 import re
12 import sys
13 import warnings
14 from typing import Dict, List, Tuple
15 
16 from docutils.parsers.rst.states import Body
17 
18 from sphinx.deprecation import RemovedInSphinx50Warning, RemovedInSphinx60Warning
19 
20 field_list_item_re = re.compile(Body.patterns['field_marker'])
21 
22 
23 def separate_metadata(s: str) -> Tuple[str, Dict[str, str]]:
24     """Separate docstring into metadata and others."""
25     in_other_element = False
26     metadata: Dict[str, str] = {}
27     lines = []
28 
29     if not s:
30         return s, metadata
31 
32     for line in prepare_docstring(s):
33         if line.strip() == '':
34             in_other_element = False
35             lines.append(line)
36         else:
37             matched = field_list_item_re.match(line)
38             if matched and not in_other_element:
39                 field_name = matched.group()[1:].split(':', 1)[0]
40                 if field_name.startswith('meta '):
41                     name = field_name[5:].strip()
42                     metadata[name] = line[matched.end():].strip()
43                 else:
44                     lines.append(line)
45             else:
46                 in_other_element = True
47                 lines.append(line)
48 
49     return '\n'.join(lines), metadata
50 
51 
52 def extract_metadata(s: str) -> Dict[str, str]:
53     warnings.warn("extract_metadata() is deprecated.",
54                   RemovedInSphinx60Warning, stacklevel=2)
55 
56     docstring, metadata = separate_metadata(s)
57     return metadata
58 
59 
60 def prepare_docstring(s: str, ignore: int = None, tabsize: int = 8) -> List[str]:
61     """Convert a docstring into lines of parseable reST.  Remove common leading
62     indentation, where the indentation of a given number of lines (usually just
63     one) is ignored.
64 
65     Return the docstring as a list of lines usable for inserting into a docutils
66     ViewList (used as argument of nested_parse().)  An empty line is added to
67     act as a separator between this docstring and following content.
68     """
69     if ignore is None:
70         ignore = 1
71     else:
72         warnings.warn("The 'ignore' argument to prepare_docstring() is deprecated.",
73                       RemovedInSphinx50Warning, stacklevel=2)
74 
75     lines = s.expandtabs(tabsize).splitlines()
76     # Find minimum indentation of any non-blank lines after ignored lines.
77     margin = sys.maxsize
78     for line in lines[ignore:]:
79         content = len(line.lstrip())
80         if content:
81             indent = len(line) - content
82             margin = min(margin, indent)
83     # Remove indentation from ignored lines.
84     for i in range(ignore):
85         if i < len(lines):
86             lines[i] = lines[i].lstrip()
87     if margin < sys.maxsize:
88         for i in range(ignore, len(lines)):
89             lines[i] = lines[i][margin:]
90     # Remove any leading blank lines.
91     while lines and not lines[0]:
92         lines.pop(0)
93     # make sure there is an empty line at the end
94     if lines and lines[-1]:
95         lines.append('')
96     return lines
97 
98 
99 def prepare_commentdoc(s: str) -> List[str]:
100     """Extract documentation comment lines (starting with #:) and return them
101     as a list of lines.  Returns an empty list if there is no documentation.
102     """
103     result = []
104     lines = [line.strip() for line in s.expandtabs().splitlines()]
105     for line in lines:
106         if line.startswith('#:'):
107             line = line[2:]
108             # the first space after the comment is ignored
109             if line and line[0] == ' ':
110                 line = line[1:]
111             result.append(line)
112     if result and result[-1]:
113         result.append('')
114     return result

</code><intended_behavior>This utility module should ensure that docstring processing functionality properly recognizes and extracts docstrings from type aliases.</intended_behavior>]
2025-10-18 07:12:51.379 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-18 07:12:51.379 | INFO     | Search-only: skipping patch selection
2025-10-18 07:12:51.496 | INFO     | Task sphinx-doc__sphinx-9229 completed successfully.
2025-10-18 07:12:51.497 | INFO     | No patch generated. You can try running ACR again.
