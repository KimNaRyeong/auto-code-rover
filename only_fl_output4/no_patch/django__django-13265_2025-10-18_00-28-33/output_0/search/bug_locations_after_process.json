[
    {
        "rel_file_path": "django/db/migrations/autodetector.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.2/django/db/migrations/autodetector.py",
        "start": 1,
        "end": 1317,
        "class_name": null,
        "method_name": null,
        "code": "1 import functools\n2 import re\n3 from itertools import chain\n4 \n5 from django.conf import settings\n6 from django.db import models\n7 from django.db.migrations import operations\n8 from django.db.migrations.migration import Migration\n9 from django.db.migrations.operations.models import AlterModelOptions\n10 from django.db.migrations.optimizer import MigrationOptimizer\n11 from django.db.migrations.questioner import MigrationQuestioner\n12 from django.db.migrations.utils import COMPILED_REGEX_TYPE, RegexObject\n13 from django.utils.topological_sort import stable_topological_sort\n14 \n15 \n16 class MigrationAutodetector:\n17     \"\"\"\n18     Take a pair of ProjectStates and compare them to see what the first would\n19     need doing to make it match the second (the second usually being the\n20     project's current state).\n21 \n22     Note that this naturally operates on entire projects at a time,\n23     as it's likely that changes interact (for example, you can't\n24     add a ForeignKey without having a migration to add the table it\n25     depends on first). A user interface may offer single-app usage\n26     if it wishes, with the caveat that it may not always be possible.\n27     \"\"\"\n28 \n29     def __init__(self, from_state, to_state, questioner=None):\n30         self.from_state = from_state\n31         self.to_state = to_state\n32         self.questioner = questioner or MigrationQuestioner()\n33         self.existing_apps = {app for app, model in from_state.models}\n34 \n35     def changes(self, graph, trim_to_apps=None, convert_apps=None, migration_name=None):\n36         \"\"\"\n37         Main entry point to produce a list of applicable changes.\n38         Take a graph to base names on and an optional set of apps\n39         to try and restrict to (restriction is not guaranteed)\n40         \"\"\"\n41         changes = self._detect_changes(convert_apps, graph)\n42         changes = self.arrange_for_graph(changes, graph, migration_name)\n43         if trim_to_apps:\n44             changes = self._trim_to_apps(changes, trim_to_apps)\n45         return changes\n46 \n47     def deep_deconstruct(self, obj):\n48         \"\"\"\n49         Recursive deconstruction for a field and its arguments.\n50         Used for full comparison for rename/alter; sometimes a single-level\n51         deconstruction will not compare correctly.\n52         \"\"\"\n53         if isinstance(obj, list):\n54             return [self.deep_deconstruct(value) for value in obj]\n55         elif isinstance(obj, tuple):\n56             return tuple(self.deep_deconstruct(value) for value in obj)\n57         elif isinstance(obj, dict):\n58             return {\n59                 key: self.deep_deconstruct(value)\n60                 for key, value in obj.items()\n61             }\n62         elif isinstance(obj, functools.partial):\n63             return (obj.func, self.deep_deconstruct(obj.args), self.deep_deconstruct(obj.keywords))\n64         elif isinstance(obj, COMPILED_REGEX_TYPE):\n65             return RegexObject(obj)\n66         elif isinstance(obj, type):\n67             # If this is a type that implements 'deconstruct' as an instance method,\n68             # avoid treating this as being deconstructible itself - see #22951\n69             return obj\n70         elif hasattr(obj, 'deconstruct'):\n71             deconstructed = obj.deconstruct()\n72             if isinstance(obj, models.Field):\n73                 # we have a field which also returns a name\n74                 deconstructed = deconstructed[1:]\n75             path, args, kwargs = deconstructed\n76             return (\n77                 path,\n78                 [self.deep_deconstruct(value) for value in args],\n79                 {\n80                     key: self.deep_deconstruct(value)\n81                     for key, value in kwargs.items()\n82                 },\n83             )\n84         else:\n85             return obj\n86 \n87     def only_relation_agnostic_fields(self, fields):\n88         \"\"\"\n89         Return a definition of the fields that ignores field names and\n90         what related fields actually relate to. Used for detecting renames (as\n91         the related fields change during renames).\n92         \"\"\"\n93         fields_def = []\n94         for name, field in sorted(fields.items()):\n95             deconstruction = self.deep_deconstruct(field)\n96             if field.remote_field and field.remote_field.model:\n97                 del deconstruction[2]['to']\n98             fields_def.append(deconstruction)\n99         return fields_def\n100 \n101     def _detect_changes(self, convert_apps=None, graph=None):\n102         \"\"\"\n103         Return a dict of migration plans which will achieve the\n104         change from from_state to to_state. The dict has app labels\n105         as keys and a list of migrations as values.\n106 \n107         The resulting migrations aren't specially named, but the names\n108         do matter for dependencies inside the set.\n109 \n110         convert_apps is the list of apps to convert to use migrations\n111         (i.e. to make initial migrations for, in the usual case)\n112 \n113         graph is an optional argument that, if provided, can help improve\n114         dependency generation and avoid potential circular dependencies.\n115         \"\"\"\n116         # The first phase is generating all the operations for each app\n117         # and gathering them into a big per-app list.\n118         # Then go through that list, order it, and split into migrations to\n119         # resolve dependencies caused by M2Ms and FKs.\n120         self.generated_operations = {}\n121         self.altered_indexes = {}\n122         self.altered_constraints = {}\n123 \n124         # Prepare some old/new state and model lists, separating\n125         # proxy models and ignoring unmigrated apps.\n126         self.old_apps = self.from_state.concrete_apps\n127         self.new_apps = self.to_state.apps\n128         self.old_model_keys = set()\n129         self.old_proxy_keys = set()\n130         self.old_unmanaged_keys = set()\n131         self.new_model_keys = set()\n132         self.new_proxy_keys = set()\n133         self.new_unmanaged_keys = set()\n134         for al, mn in self.from_state.models:\n135             model = self.old_apps.get_model(al, mn)\n136             if not model._meta.managed:\n137                 self.old_unmanaged_keys.add((al, mn))\n138             elif al not in self.from_state.real_apps:\n139                 if model._meta.proxy:\n140                     self.old_proxy_keys.add((al, mn))\n141                 else:\n142                     self.old_model_keys.add((al, mn))\n143 \n144         for al, mn in self.to_state.models:\n145             model = self.new_apps.get_model(al, mn)\n146             if not model._meta.managed:\n147                 self.new_unmanaged_keys.add((al, mn))\n148             elif (\n149                 al not in self.from_state.real_apps or\n150                 (convert_apps and al in convert_apps)\n151             ):\n152                 if model._meta.proxy:\n153                     self.new_proxy_keys.add((al, mn))\n154                 else:\n155                     self.new_model_keys.add((al, mn))\n156 \n157         # Renames have to come first\n158         self.generate_renamed_models()\n159 \n160         # Prepare lists of fields and generate through model map\n161         self._prepare_field_lists()\n162         self._generate_through_model_map()\n163 \n164         # Generate non-rename model operations\n165         self.generate_deleted_models()\n166         self.generate_created_models()\n167         self.generate_deleted_proxies()\n168         self.generate_created_proxies()\n169         self.generate_altered_options()\n170         self.generate_altered_managers()\n171 \n172         # Create the altered indexes and store them in self.altered_indexes.\n173         # This avoids the same computation in generate_removed_indexes()\n174         # and generate_added_indexes().\n175         self.create_altered_indexes()\n176         self.create_altered_constraints()\n177         # Generate index removal operations before field is removed\n178         self.generate_removed_constraints()\n179         self.generate_removed_indexes()\n180         # Generate field operations\n181         self.generate_renamed_fields()\n182         self.generate_removed_fields()\n183         self.generate_added_fields()\n184         self.generate_altered_fields()\n185         self.generate_altered_unique_together()\n186         self.generate_altered_index_together()\n187         self.generate_added_indexes()\n188         self.generate_added_constraints()\n189         self.generate_altered_db_table()\n190         self.generate_altered_order_with_respect_to()\n191 \n192         self._sort_migrations()\n193         self._build_migration_list(graph)\n194         self._optimize_migrations()\n195 \n196         return self.migrations\n197 \n198     def _prepare_field_lists(self):\n199         \"\"\"\n200         Prepare field lists and a list of the fields that used through models\n201         in the old state so dependencies can be made from the through model\n202         deletion to the field that uses it.\n203         \"\"\"\n204         self.kept_model_keys = self.old_model_keys & self.new_model_keys\n205         self.kept_proxy_keys = self.old_proxy_keys & self.new_proxy_keys\n206         self.kept_unmanaged_keys = self.old_unmanaged_keys & self.new_unmanaged_keys\n207         self.through_users = {}\n208         self.old_field_keys = {\n209             (app_label, model_name, field_name)\n210             for app_label, model_name in self.kept_model_keys\n211             for field_name in self.from_state.models[\n212                 app_label,\n213                 self.renamed_models.get((app_label, model_name), model_name)\n214             ].fields\n215         }\n216         self.new_field_keys = {\n217             (app_label, model_name, field_name)\n218             for app_label, model_name in self.kept_model_keys\n219             for field_name in self.to_state.models[app_label, model_name].fields\n220         }\n221 \n222     def _generate_through_model_map(self):\n223         \"\"\"Through model map generation.\"\"\"\n224         for app_label, model_name in sorted(self.old_model_keys):\n225             old_model_name = self.renamed_models.get((app_label, model_name), model_name)\n226             old_model_state = self.from_state.models[app_label, old_model_name]\n227             for field_name in old_model_state.fields:\n228                 old_field = self.old_apps.get_model(app_label, old_model_name)._meta.get_field(field_name)\n229                 if (hasattr(old_field, \"remote_field\") and getattr(old_field.remote_field, \"through\", None) and\n230                         not old_field.remote_field.through._meta.auto_created):\n231                     through_key = (\n232                         old_field.remote_field.through._meta.app_label,\n233                         old_field.remote_field.through._meta.model_name,\n234                     )\n235                     self.through_users[through_key] = (app_label, old_model_name, field_name)\n236 \n237     @staticmethod\n238     def _resolve_dependency(dependency):\n239         \"\"\"\n240         Return the resolved dependency and a boolean denoting whether or not\n241         it was swappable.\n242         \"\"\"\n243         if dependency[0] != '__setting__':\n244             return dependency, False\n245         resolved_app_label, resolved_object_name = getattr(settings, dependency[1]).split('.')\n246         return (resolved_app_label, resolved_object_name.lower()) + dependency[2:], True\n247 \n248     def _build_migration_list(self, graph=None):\n249         \"\"\"\n250         Chop the lists of operations up into migrations with dependencies on\n251         each other. Do this by going through an app's list of operations until\n252         one is found that has an outgoing dependency that isn't in another\n253         app's migration yet (hasn't been chopped off its list). Then chop off\n254         the operations before it into a migration and move onto the next app.\n255         If the loops completes without doing anything, there's a circular\n256         dependency (which _should_ be impossible as the operations are\n257         all split at this point so they can't depend and be depended on).\n258         \"\"\"\n259         self.migrations = {}\n260         num_ops = sum(len(x) for x in self.generated_operations.values())\n261         chop_mode = False\n262         while num_ops:\n263             # On every iteration, we step through all the apps and see if there\n264             # is a completed set of operations.\n265             # If we find that a subset of the operations are complete we can\n266             # try to chop it off from the rest and continue, but we only\n267             # do this if we've already been through the list once before\n268             # without any chopping and nothing has changed.\n269             for app_label in sorted(self.generated_operations):\n270                 chopped = []\n271                 dependencies = set()\n272                 for operation in list(self.generated_operations[app_label]):\n273                     deps_satisfied = True\n274                     operation_dependencies = set()\n275                     for dep in operation._auto_deps:\n276                         # Temporarily resolve the swappable dependency to\n277                         # prevent circular references. While keeping the\n278                         # dependency checks on the resolved model, add the\n279                         # swappable dependencies.\n280                         original_dep = dep\n281                         dep, is_swappable_dep = self._resolve_dependency(dep)\n282                         if dep[0] != app_label:\n283                             # External app dependency. See if it's not yet\n284                             # satisfied.\n285                             for other_operation in self.generated_operations.get(dep[0], []):\n286                                 if self.check_dependency(other_operation, dep):\n287                                     deps_satisfied = False\n288                                     break\n289                             if not deps_satisfied:\n290                                 break\n291                             else:\n292                                 if is_swappable_dep:\n293                                     operation_dependencies.add((original_dep[0], original_dep[1]))\n294                                 elif dep[0] in self.migrations:\n295                                     operation_dependencies.add((dep[0], self.migrations[dep[0]][-1].name))\n296                                 else:\n297                                     # If we can't find the other app, we add a first/last dependency,\n298                                     # but only if we've already been through once and checked everything\n299                                     if chop_mode:\n300                                         # If the app already exists, we add a dependency on the last migration,\n301                                         # as we don't know which migration contains the target field.\n302                                         # If it's not yet migrated or has no migrations, we use __first__\n303                                         if graph and graph.leaf_nodes(dep[0]):\n304                                             operation_dependencies.add(graph.leaf_nodes(dep[0])[0])\n305                                         else:\n306                                             operation_dependencies.add((dep[0], \"__first__\"))\n307                                     else:\n308                                         deps_satisfied = False\n309                     if deps_satisfied:\n310                         chopped.append(operation)\n311                         dependencies.update(operation_dependencies)\n312                         del self.generated_operations[app_label][0]\n313                     else:\n314                         break\n315                 # Make a migration! Well, only if there's stuff to put in it\n316                 if dependencies or chopped:\n317                     if not self.generated_operations[app_label] or chop_mode:\n318                         subclass = type(\"Migration\", (Migration,), {\"operations\": [], \"dependencies\": []})\n319                         instance = subclass(\"auto_%i\" % (len(self.migrations.get(app_label, [])) + 1), app_label)\n320                         instance.dependencies = list(dependencies)\n321                         instance.operations = chopped\n322                         instance.initial = app_label not in self.existing_apps\n323                         self.migrations.setdefault(app_label, []).append(instance)\n324                         chop_mode = False\n325                     else:\n326                         self.generated_operations[app_label] = chopped + self.generated_operations[app_label]\n327             new_num_ops = sum(len(x) for x in self.generated_operations.values())\n328             if new_num_ops == num_ops:\n329                 if not chop_mode:\n330                     chop_mode = True\n331                 else:\n332                     raise ValueError(\"Cannot resolve operation dependencies: %r\" % self.generated_operations)\n333             num_ops = new_num_ops\n334 \n335     def _sort_migrations(self):\n336         \"\"\"\n337         Reorder to make things possible. Reordering may be needed so FKs work\n338         nicely inside the same app.\n339         \"\"\"\n340         for app_label, ops in sorted(self.generated_operations.items()):\n341             # construct a dependency graph for intra-app dependencies\n342             dependency_graph = {op: set() for op in ops}\n343             for op in ops:\n344                 for dep in op._auto_deps:\n345                     # Resolve intra-app dependencies to handle circular\n346                     # references involving a swappable model.\n347                     dep = self._resolve_dependency(dep)[0]\n348                     if dep[0] == app_label:\n349                         for op2 in ops:\n350                             if self.check_dependency(op2, dep):\n351                                 dependency_graph[op].add(op2)\n352 \n353             # we use a stable sort for deterministic tests & general behavior\n354             self.generated_operations[app_label] = stable_topological_sort(ops, dependency_graph)\n355 \n356     def _optimize_migrations(self):\n357         # Add in internal dependencies among the migrations\n358         for app_label, migrations in self.migrations.items():\n359             for m1, m2 in zip(migrations, migrations[1:]):\n360                 m2.dependencies.append((app_label, m1.name))\n361 \n362         # De-dupe dependencies\n363         for migrations in self.migrations.values():\n364             for migration in migrations:\n365                 migration.dependencies = list(set(migration.dependencies))\n366 \n367         # Optimize migrations\n368         for app_label, migrations in self.migrations.items():\n369             for migration in migrations:\n370                 migration.operations = MigrationOptimizer().optimize(migration.operations, app_label)\n371 \n372     def check_dependency(self, operation, dependency):\n373         \"\"\"\n374         Return True if the given operation depends on the given dependency,\n375         False otherwise.\n376         \"\"\"\n377         # Created model\n378         if dependency[2] is None and dependency[3] is True:\n379             return (\n380                 isinstance(operation, operations.CreateModel) and\n381                 operation.name_lower == dependency[1].lower()\n382             )\n383         # Created field\n384         elif dependency[2] is not None and dependency[3] is True:\n385             return (\n386                 (\n387                     isinstance(operation, operations.CreateModel) and\n388                     operation.name_lower == dependency[1].lower() and\n389                     any(dependency[2] == x for x, y in operation.fields)\n390                 ) or\n391                 (\n392                     isinstance(operation, operations.AddField) and\n393                     operation.model_name_lower == dependency[1].lower() and\n394                     operation.name_lower == dependency[2].lower()\n395                 )\n396             )\n397         # Removed field\n398         elif dependency[2] is not None and dependency[3] is False:\n399             return (\n400                 isinstance(operation, operations.RemoveField) and\n401                 operation.model_name_lower == dependency[1].lower() and\n402                 operation.name_lower == dependency[2].lower()\n403             )\n404         # Removed model\n405         elif dependency[2] is None and dependency[3] is False:\n406             return (\n407                 isinstance(operation, operations.DeleteModel) and\n408                 operation.name_lower == dependency[1].lower()\n409             )\n410         # Field being altered\n411         elif dependency[2] is not None and dependency[3] == \"alter\":\n412             return (\n413                 isinstance(operation, operations.AlterField) and\n414                 operation.model_name_lower == dependency[1].lower() and\n415                 operation.name_lower == dependency[2].lower()\n416             )\n417         # order_with_respect_to being unset for a field\n418         elif dependency[2] is not None and dependency[3] == \"order_wrt_unset\":\n419             return (\n420                 isinstance(operation, operations.AlterOrderWithRespectTo) and\n421                 operation.name_lower == dependency[1].lower() and\n422                 (operation.order_with_respect_to or \"\").lower() != dependency[2].lower()\n423             )\n424         # Field is removed and part of an index/unique_together\n425         elif dependency[2] is not None and dependency[3] == \"foo_together_change\":\n426             return (\n427                 isinstance(operation, (operations.AlterUniqueTogether,\n428                                        operations.AlterIndexTogether)) and\n429                 operation.name_lower == dependency[1].lower()\n430             )\n431         # Unknown dependency. Raise an error.\n432         else:\n433             raise ValueError(\"Can't handle dependency %r\" % (dependency,))\n434 \n435     def add_operation(self, app_label, operation, dependencies=None, beginning=False):\n436         # Dependencies are (app_label, model_name, field_name, create/delete as True/False)\n437         operation._auto_deps = dependencies or []\n438         if beginning:\n439             self.generated_operations.setdefault(app_label, []).insert(0, operation)\n440         else:\n441             self.generated_operations.setdefault(app_label, []).append(operation)\n442 \n443     def swappable_first_key(self, item):\n444         \"\"\"\n445         Place potential swappable models first in lists of created models (only\n446         real way to solve #22783).\n447         \"\"\"\n448         try:\n449             model = self.new_apps.get_model(item[0], item[1])\n450             base_names = [base.__name__ for base in model.__bases__]\n451             string_version = \"%s.%s\" % (item[0], item[1])\n452             if (\n453                 model._meta.swappable or\n454                 \"AbstractUser\" in base_names or\n455                 \"AbstractBaseUser\" in base_names or\n456                 settings.AUTH_USER_MODEL.lower() == string_version.lower()\n457             ):\n458                 return (\"___\" + item[0], \"___\" + item[1])\n459         except LookupError:\n460             pass\n461         return item\n462 \n463     def generate_renamed_models(self):\n464         \"\"\"\n465         Find any renamed models, generate the operations for them, and remove\n466         the old entry from the model lists. Must be run before other\n467         model-level generation.\n468         \"\"\"\n469         self.renamed_models = {}\n470         self.renamed_models_rel = {}\n471         added_models = self.new_model_keys - self.old_model_keys\n472         for app_label, model_name in sorted(added_models):\n473             model_state = self.to_state.models[app_label, model_name]\n474             model_fields_def = self.only_relation_agnostic_fields(model_state.fields)\n475 \n476             removed_models = self.old_model_keys - self.new_model_keys\n477             for rem_app_label, rem_model_name in removed_models:\n478                 if rem_app_label == app_label:\n479                     rem_model_state = self.from_state.models[rem_app_label, rem_model_name]\n480                     rem_model_fields_def = self.only_relation_agnostic_fields(rem_model_state.fields)\n481                     if model_fields_def == rem_model_fields_def:\n482                         if self.questioner.ask_rename_model(rem_model_state, model_state):\n483                             model_opts = self.new_apps.get_model(app_label, model_name)._meta\n484                             dependencies = []\n485                             for field in model_opts.get_fields():\n486                                 if field.is_relation:\n487                                     dependencies.extend(self._get_dependencies_for_foreign_key(field))\n488                             self.add_operation(\n489                                 app_label,\n490                                 operations.RenameModel(\n491                                     old_name=rem_model_state.name,\n492                                     new_name=model_state.name,\n493                                 ),\n494                                 dependencies=dependencies,\n495                             )\n496                             self.renamed_models[app_label, model_name] = rem_model_name\n497                             renamed_models_rel_key = '%s.%s' % (\n498                                 rem_model_state.app_label,\n499                                 rem_model_state.name_lower,\n500                             )\n501                             self.renamed_models_rel[renamed_models_rel_key] = '%s.%s' % (\n502                                 model_state.app_label,\n503                                 model_state.name_lower,\n504                             )\n505                             self.old_model_keys.remove((rem_app_label, rem_model_name))\n506                             self.old_model_keys.add((app_label, model_name))\n507                             break\n508 \n509     def generate_created_models(self):\n510         \"\"\"\n511         Find all new models (both managed and unmanaged) and make create\n512         operations for them as well as separate operations to create any\n513         foreign key or M2M relationships (these are optimized later, if\n514         possible).\n515 \n516         Defer any model options that refer to collections of fields that might\n517         be deferred (e.g. unique_together, index_together).\n518         \"\"\"\n519         old_keys = self.old_model_keys | self.old_unmanaged_keys\n520         added_models = self.new_model_keys - old_keys\n521         added_unmanaged_models = self.new_unmanaged_keys - old_keys\n522         all_added_models = chain(\n523             sorted(added_models, key=self.swappable_first_key, reverse=True),\n524             sorted(added_unmanaged_models, key=self.swappable_first_key, reverse=True)\n525         )\n526         for app_label, model_name in all_added_models:\n527             model_state = self.to_state.models[app_label, model_name]\n528             model_opts = self.new_apps.get_model(app_label, model_name)._meta\n529             # Gather related fields\n530             related_fields = {}\n531             primary_key_rel = None\n532             for field in model_opts.local_fields:\n533                 if field.remote_field:\n534                     if field.remote_field.model:\n535                         if field.primary_key:\n536                             primary_key_rel = field.remote_field.model\n537                         elif not field.remote_field.parent_link:\n538                             related_fields[field.name] = field\n539                     # through will be none on M2Ms on swapped-out models;\n540                     # we can treat lack of through as auto_created=True, though.\n541                     if (getattr(field.remote_field, \"through\", None) and\n542                             not field.remote_field.through._meta.auto_created):\n543                         related_fields[field.name] = field\n544             for field in model_opts.local_many_to_many:\n545                 if field.remote_field.model:\n546                     related_fields[field.name] = field\n547                 if getattr(field.remote_field, \"through\", None) and not field.remote_field.through._meta.auto_created:\n548                     related_fields[field.name] = field\n549             # Are there indexes/unique|index_together to defer?\n550             indexes = model_state.options.pop('indexes')\n551             constraints = model_state.options.pop('constraints')\n552             unique_together = model_state.options.pop('unique_together', None)\n553             index_together = model_state.options.pop('index_together', None)\n554             order_with_respect_to = model_state.options.pop('order_with_respect_to', None)\n555             # Depend on the deletion of any possible proxy version of us\n556             dependencies = [\n557                 (app_label, model_name, None, False),\n558             ]\n559             # Depend on all bases\n560             for base in model_state.bases:\n561                 if isinstance(base, str) and \".\" in base:\n562                     base_app_label, base_name = base.split(\".\", 1)\n563                     dependencies.append((base_app_label, base_name, None, True))\n564                     # Depend on the removal of base fields if the new model has\n565                     # a field with the same name.\n566                     old_base_model_state = self.from_state.models.get((base_app_label, base_name))\n567                     new_base_model_state = self.to_state.models.get((base_app_label, base_name))\n568                     if old_base_model_state and new_base_model_state:\n569                         removed_base_fields = set(old_base_model_state.fields).difference(\n570                             new_base_model_state.fields,\n571                         ).intersection(model_state.fields)\n572                         for removed_base_field in removed_base_fields:\n573                             dependencies.append((base_app_label, base_name, removed_base_field, False))\n574             # Depend on the other end of the primary key if it's a relation\n575             if primary_key_rel:\n576                 dependencies.append((\n577                     primary_key_rel._meta.app_label,\n578                     primary_key_rel._meta.object_name,\n579                     None,\n580                     True\n581                 ))\n582             # Generate creation operation\n583             self.add_operation(\n584                 app_label,\n585                 operations.CreateModel(\n586                     name=model_state.name,\n587                     fields=[d for d in model_state.fields.items() if d[0] not in related_fields],\n588                     options=model_state.options,\n589                     bases=model_state.bases,\n590                     managers=model_state.managers,\n591                 ),\n592                 dependencies=dependencies,\n593                 beginning=True,\n594             )\n595 \n596             # Don't add operations which modify the database for unmanaged models\n597             if not model_opts.managed:\n598                 continue\n599 \n600             # Generate operations for each related field\n601             for name, field in sorted(related_fields.items()):\n602                 dependencies = self._get_dependencies_for_foreign_key(field)\n603                 # Depend on our own model being created\n604                 dependencies.append((app_label, model_name, None, True))\n605                 # Make operation\n606                 self.add_operation(\n607                     app_label,\n608                     operations.AddField(\n609                         model_name=model_name,\n610                         name=name,\n611                         field=field,\n612                     ),\n613                     dependencies=list(set(dependencies)),\n614                 )\n615             # Generate other opns\n616             related_dependencies = [\n617                 (app_label, model_name, name, True)\n618                 for name in sorted(related_fields)\n619             ]\n620             related_dependencies.append((app_label, model_name, None, True))\n621             for index in indexes:\n622                 self.add_operation(\n623                     app_label,\n624                     operations.AddIndex(\n625                         model_name=model_name,\n626                         index=index,\n627                     ),\n628                     dependencies=related_dependencies,\n629                 )\n630             for constraint in constraints:\n631                 self.add_operation(\n632                     app_label,\n633                     operations.AddConstraint(\n634                         model_name=model_name,\n635                         constraint=constraint,\n636                     ),\n637                     dependencies=related_dependencies,\n638                 )\n639             if unique_together:\n640                 self.add_operation(\n641                     app_label,\n642                     operations.AlterUniqueTogether(\n643                         name=model_name,\n644                         unique_together=unique_together,\n645                     ),\n646                     dependencies=related_dependencies\n647                 )\n648             if index_together:\n649                 self.add_operation(\n650                     app_label,\n651                     operations.AlterIndexTogether(\n652                         name=model_name,\n653                         index_together=index_together,\n654                     ),\n655                     dependencies=related_dependencies\n656                 )\n657             if order_with_respect_to:\n658                 self.add_operation(\n659                     app_label,\n660                     operations.AlterOrderWithRespectTo(\n661                         name=model_name,\n662                         order_with_respect_to=order_with_respect_to,\n663                     ),\n664                     dependencies=[\n665                         (app_label, model_name, order_with_respect_to, True),\n666                         (app_label, model_name, None, True),\n667                     ]\n668                 )\n669 \n670             # Fix relationships if the model changed from a proxy model to a\n671             # concrete model.\n672             if (app_label, model_name) in self.old_proxy_keys:\n673                 for related_object in model_opts.related_objects:\n674                     self.add_operation(\n675                         related_object.related_model._meta.app_label,\n676                         operations.AlterField(\n677                             model_name=related_object.related_model._meta.object_name,\n678                             name=related_object.field.name,\n679                             field=related_object.field,\n680                         ),\n681                         dependencies=[(app_label, model_name, None, True)],\n682                     )\n683 \n684     def generate_created_proxies(self):\n685         \"\"\"\n686         Make CreateModel statements for proxy models. Use the same statements\n687         as that way there's less code duplication, but for proxy models it's\n688         safe to skip all the pointless field stuff and chuck out an operation.\n689         \"\"\"\n690         added = self.new_proxy_keys - self.old_proxy_keys\n691         for app_label, model_name in sorted(added):\n692             model_state = self.to_state.models[app_label, model_name]\n693             assert model_state.options.get(\"proxy\")\n694             # Depend on the deletion of any possible non-proxy version of us\n695             dependencies = [\n696                 (app_label, model_name, None, False),\n697             ]\n698             # Depend on all bases\n699             for base in model_state.bases:\n700                 if isinstance(base, str) and \".\" in base:\n701                     base_app_label, base_name = base.split(\".\", 1)\n702                     dependencies.append((base_app_label, base_name, None, True))\n703             # Generate creation operation\n704             self.add_operation(\n705                 app_label,\n706                 operations.CreateModel(\n707                     name=model_state.name,\n708                     fields=[],\n709                     options=model_state.options,\n710                     bases=model_state.bases,\n711                     managers=model_state.managers,\n712                 ),\n713                 # Depend on the deletion of any possible non-proxy version of us\n714                 dependencies=dependencies,\n715             )\n716 \n717     def generate_deleted_models(self):\n718         \"\"\"\n719         Find all deleted models (managed and unmanaged) and make delete\n720         operations for them as well as separate operations to delete any\n721         foreign key or M2M relationships (these are optimized later, if\n722         possible).\n723 \n724         Also bring forward removal of any model options that refer to\n725         collections of fields - the inverse of generate_created_models().\n726         \"\"\"\n727         new_keys = self.new_model_keys | self.new_unmanaged_keys\n728         deleted_models = self.old_model_keys - new_keys\n729         deleted_unmanaged_models = self.old_unmanaged_keys - new_keys\n730         all_deleted_models = chain(sorted(deleted_models), sorted(deleted_unmanaged_models))\n731         for app_label, model_name in all_deleted_models:\n732             model_state = self.from_state.models[app_label, model_name]\n733             model = self.old_apps.get_model(app_label, model_name)\n734             # Gather related fields\n735             related_fields = {}\n736             for field in model._meta.local_fields:\n737                 if field.remote_field:\n738                     if field.remote_field.model:\n739                         related_fields[field.name] = field\n740                     # through will be none on M2Ms on swapped-out models;\n741                     # we can treat lack of through as auto_created=True, though.\n742                     if (getattr(field.remote_field, \"through\", None) and\n743                             not field.remote_field.through._meta.auto_created):\n744                         related_fields[field.name] = field\n745             for field in model._meta.local_many_to_many:\n746                 if field.remote_field.model:\n747                     related_fields[field.name] = field\n748                 if getattr(field.remote_field, \"through\", None) and not field.remote_field.through._meta.auto_created:\n749                     related_fields[field.name] = field\n750             # Generate option removal first\n751             unique_together = model_state.options.pop('unique_together', None)\n752             index_together = model_state.options.pop('index_together', None)\n753             if unique_together:\n754                 self.add_operation(\n755                     app_label,\n756                     operations.AlterUniqueTogether(\n757                         name=model_name,\n758                         unique_together=None,\n759                     )\n760                 )\n761             if index_together:\n762                 self.add_operation(\n763                     app_label,\n764                     operations.AlterIndexTogether(\n765                         name=model_name,\n766                         index_together=None,\n767                     )\n768                 )\n769             # Then remove each related field\n770             for name in sorted(related_fields):\n771                 self.add_operation(\n772                     app_label,\n773                     operations.RemoveField(\n774                         model_name=model_name,\n775                         name=name,\n776                     )\n777                 )\n778             # Finally, remove the model.\n779             # This depends on both the removal/alteration of all incoming fields\n780             # and the removal of all its own related fields, and if it's\n781             # a through model the field that references it.\n782             dependencies = []\n783             for related_object in model._meta.related_objects:\n784                 related_object_app_label = related_object.related_model._meta.app_label\n785                 object_name = related_object.related_model._meta.object_name\n786                 field_name = related_object.field.name\n787                 dependencies.append((related_object_app_label, object_name, field_name, False))\n788                 if not related_object.many_to_many:\n789                     dependencies.append((related_object_app_label, object_name, field_name, \"alter\"))\n790 \n791             for name in sorted(related_fields):\n792                 dependencies.append((app_label, model_name, name, False))\n793             # We're referenced in another field's through=\n794             through_user = self.through_users.get((app_label, model_state.name_lower))\n795             if through_user:\n796                 dependencies.append((through_user[0], through_user[1], through_user[2], False))\n797             # Finally, make the operation, deduping any dependencies\n798             self.add_operation(\n799                 app_label,\n800                 operations.DeleteModel(\n801                     name=model_state.name,\n802                 ),\n803                 dependencies=list(set(dependencies)),\n804             )\n805 \n806     def generate_deleted_proxies(self):\n807         \"\"\"Make DeleteModel options for proxy models.\"\"\"\n808         deleted = self.old_proxy_keys - self.new_proxy_keys\n809         for app_label, model_name in sorted(deleted):\n810             model_state = self.from_state.models[app_label, model_name]\n811             assert model_state.options.get(\"proxy\")\n812             self.add_operation(\n813                 app_label,\n814                 operations.DeleteModel(\n815                     name=model_state.name,\n816                 ),\n817             )\n818 \n819     def generate_renamed_fields(self):\n820         \"\"\"Work out renamed fields.\"\"\"\n821         self.renamed_fields = {}\n822         for app_label, model_name, field_name in sorted(self.new_field_keys - self.old_field_keys):\n823             old_model_name = self.renamed_models.get((app_label, model_name), model_name)\n824             old_model_state = self.from_state.models[app_label, old_model_name]\n825             field = self.new_apps.get_model(app_label, model_name)._meta.get_field(field_name)\n826             # Scan to see if this is actually a rename!\n827             field_dec = self.deep_deconstruct(field)\n828             for rem_app_label, rem_model_name, rem_field_name in sorted(self.old_field_keys - self.new_field_keys):\n829                 if rem_app_label == app_label and rem_model_name == model_name:\n830                     old_field = old_model_state.fields[rem_field_name]\n831                     old_field_dec = self.deep_deconstruct(old_field)\n832                     if field.remote_field and field.remote_field.model and 'to' in old_field_dec[2]:\n833                         old_rel_to = old_field_dec[2]['to']\n834                         if old_rel_to in self.renamed_models_rel:\n835                             old_field_dec[2]['to'] = self.renamed_models_rel[old_rel_to]\n836                     old_field.set_attributes_from_name(rem_field_name)\n837                     old_db_column = old_field.get_attname_column()[1]\n838                     if (old_field_dec == field_dec or (\n839                             # Was the field renamed and db_column equal to the\n840                             # old field's column added?\n841                             old_field_dec[0:2] == field_dec[0:2] and\n842                             dict(old_field_dec[2], db_column=old_db_column) == field_dec[2])):\n843                         if self.questioner.ask_rename(model_name, rem_field_name, field_name, field):\n844                             self.add_operation(\n845                                 app_label,\n846                                 operations.RenameField(\n847                                     model_name=model_name,\n848                                     old_name=rem_field_name,\n849                                     new_name=field_name,\n850                                 )\n851                             )\n852                             self.old_field_keys.remove((rem_app_label, rem_model_name, rem_field_name))\n853                             self.old_field_keys.add((app_label, model_name, field_name))\n854                             self.renamed_fields[app_label, model_name, field_name] = rem_field_name\n855                             break\n856 \n857     def generate_added_fields(self):\n858         \"\"\"Make AddField operations.\"\"\"\n859         for app_label, model_name, field_name in sorted(self.new_field_keys - self.old_field_keys):\n860             self._generate_added_field(app_label, model_name, field_name)\n861 \n862     def _generate_added_field(self, app_label, model_name, field_name):\n863         field = self.new_apps.get_model(app_label, model_name)._meta.get_field(field_name)\n864         # Fields that are foreignkeys/m2ms depend on stuff\n865         dependencies = []\n866         if field.remote_field and field.remote_field.model:\n867             dependencies.extend(self._get_dependencies_for_foreign_key(field))\n868         # You can't just add NOT NULL fields with no default or fields\n869         # which don't allow empty strings as default.\n870         time_fields = (models.DateField, models.DateTimeField, models.TimeField)\n871         preserve_default = (\n872             field.null or field.has_default() or field.many_to_many or\n873             (field.blank and field.empty_strings_allowed) or\n874             (isinstance(field, time_fields) and field.auto_now)\n875         )\n876         if not preserve_default:\n877             field = field.clone()\n878             if isinstance(field, time_fields) and field.auto_now_add:\n879                 field.default = self.questioner.ask_auto_now_add_addition(field_name, model_name)\n880             else:\n881                 field.default = self.questioner.ask_not_null_addition(field_name, model_name)\n882         self.add_operation(\n883             app_label,\n884             operations.AddField(\n885                 model_name=model_name,\n886                 name=field_name,\n887                 field=field,\n888                 preserve_default=preserve_default,\n889             ),\n890             dependencies=dependencies,\n891         )\n892 \n893     def generate_removed_fields(self):\n894         \"\"\"Make RemoveField operations.\"\"\"\n895         for app_label, model_name, field_name in sorted(self.old_field_keys - self.new_field_keys):\n896             self._generate_removed_field(app_label, model_name, field_name)\n897 \n898     def _generate_removed_field(self, app_label, model_name, field_name):\n899         self.add_operation(\n900             app_label,\n901             operations.RemoveField(\n902                 model_name=model_name,\n903                 name=field_name,\n904             ),\n905             # We might need to depend on the removal of an\n906             # order_with_respect_to or index/unique_together operation;\n907             # this is safely ignored if there isn't one\n908             dependencies=[\n909                 (app_label, model_name, field_name, \"order_wrt_unset\"),\n910                 (app_label, model_name, field_name, \"foo_together_change\"),\n911             ],\n912         )\n913 \n914     def generate_altered_fields(self):\n915         \"\"\"\n916         Make AlterField operations, or possibly RemovedField/AddField if alter\n917         isn's possible.\n918         \"\"\"\n919         for app_label, model_name, field_name in sorted(self.old_field_keys & self.new_field_keys):\n920             # Did the field change?\n921             old_model_name = self.renamed_models.get((app_label, model_name), model_name)\n922             old_field_name = self.renamed_fields.get((app_label, model_name, field_name), field_name)\n923             old_field = self.old_apps.get_model(app_label, old_model_name)._meta.get_field(old_field_name)\n924             new_field = self.new_apps.get_model(app_label, model_name)._meta.get_field(field_name)\n925             dependencies = []\n926             # Implement any model renames on relations; these are handled by RenameModel\n927             # so we need to exclude them from the comparison\n928             if hasattr(new_field, \"remote_field\") and getattr(new_field.remote_field, \"model\", None):\n929                 rename_key = (\n930                     new_field.remote_field.model._meta.app_label,\n931                     new_field.remote_field.model._meta.model_name,\n932                 )\n933                 if rename_key in self.renamed_models:\n934                     new_field.remote_field.model = old_field.remote_field.model\n935                 # Handle ForeignKey which can only have a single to_field.\n936                 remote_field_name = getattr(new_field.remote_field, 'field_name', None)\n937                 if remote_field_name:\n938                     to_field_rename_key = rename_key + (remote_field_name,)\n939                     if to_field_rename_key in self.renamed_fields:\n940                         # Repoint both model and field name because to_field\n941                         # inclusion in ForeignKey.deconstruct() is based on\n942                         # both.\n943                         new_field.remote_field.model = old_field.remote_field.model\n944                         new_field.remote_field.field_name = old_field.remote_field.field_name\n945                 # Handle ForeignObjects which can have multiple from_fields/to_fields.\n946                 from_fields = getattr(new_field, 'from_fields', None)\n947                 if from_fields:\n948                     from_rename_key = (app_label, model_name)\n949                     new_field.from_fields = tuple([\n950                         self.renamed_fields.get(from_rename_key + (from_field,), from_field)\n951                         for from_field in from_fields\n952                     ])\n953                     new_field.to_fields = tuple([\n954                         self.renamed_fields.get(rename_key + (to_field,), to_field)\n955                         for to_field in new_field.to_fields\n956                     ])\n957                 dependencies.extend(self._get_dependencies_for_foreign_key(new_field))\n958             if hasattr(new_field, \"remote_field\") and getattr(new_field.remote_field, \"through\", None):\n959                 rename_key = (\n960                     new_field.remote_field.through._meta.app_label,\n961                     new_field.remote_field.through._meta.model_name,\n962                 )\n963                 if rename_key in self.renamed_models:\n964                     new_field.remote_field.through = old_field.remote_field.through\n965             old_field_dec = self.deep_deconstruct(old_field)\n966             new_field_dec = self.deep_deconstruct(new_field)\n967             if old_field_dec != new_field_dec:\n968                 both_m2m = old_field.many_to_many and new_field.many_to_many\n969                 neither_m2m = not old_field.many_to_many and not new_field.many_to_many\n970                 if both_m2m or neither_m2m:\n971                     # Either both fields are m2m or neither is\n972                     preserve_default = True\n973                     if (old_field.null and not new_field.null and not new_field.has_default() and\n974                             not new_field.many_to_many):\n975                         field = new_field.clone()\n976                         new_default = self.questioner.ask_not_null_alteration(field_name, model_name)\n977                         if new_default is not models.NOT_PROVIDED:\n978                             field.default = new_default\n979                             preserve_default = False\n980                     else:\n981                         field = new_field\n982                     self.add_operation(\n983                         app_label,\n984                         operations.AlterField(\n985                             model_name=model_name,\n986                             name=field_name,\n987                             field=field,\n988                             preserve_default=preserve_default,\n989                         ),\n990                         dependencies=dependencies,\n991                     )\n992                 else:\n993                     # We cannot alter between m2m and concrete fields\n994                     self._generate_removed_field(app_label, model_name, field_name)\n995                     self._generate_added_field(app_label, model_name, field_name)\n996 \n997     def create_altered_indexes(self):\n998         option_name = operations.AddIndex.option_name\n999         for app_label, model_name in sorted(self.kept_model_keys):\n1000             old_model_name = self.renamed_models.get((app_label, model_name), model_name)\n1001             old_model_state = self.from_state.models[app_label, old_model_name]\n1002             new_model_state = self.to_state.models[app_label, model_name]\n1003 \n1004             old_indexes = old_model_state.options[option_name]\n1005             new_indexes = new_model_state.options[option_name]\n1006             add_idx = [idx for idx in new_indexes if idx not in old_indexes]\n1007             rem_idx = [idx for idx in old_indexes if idx not in new_indexes]\n1008 \n1009             self.altered_indexes.update({\n1010                 (app_label, model_name): {\n1011                     'added_indexes': add_idx, 'removed_indexes': rem_idx,\n1012                 }\n1013             })\n1014 \n1015     def generate_added_indexes(self):\n1016         for (app_label, model_name), alt_indexes in self.altered_indexes.items():\n1017             for index in alt_indexes['added_indexes']:\n1018                 self.add_operation(\n1019                     app_label,\n1020                     operations.AddIndex(\n1021                         model_name=model_name,\n1022                         index=index,\n1023                     )\n1024                 )\n1025 \n1026     def generate_removed_indexes(self):\n1027         for (app_label, model_name), alt_indexes in self.altered_indexes.items():\n1028             for index in alt_indexes['removed_indexes']:\n1029                 self.add_operation(\n1030                     app_label,\n1031                     operations.RemoveIndex(\n1032                         model_name=model_name,\n1033                         name=index.name,\n1034                     )\n1035                 )\n1036 \n1037     def create_altered_constraints(self):\n1038         option_name = operations.AddConstraint.option_name\n1039         for app_label, model_name in sorted(self.kept_model_keys):\n1040             old_model_name = self.renamed_models.get((app_label, model_name), model_name)\n1041             old_model_state = self.from_state.models[app_label, old_model_name]\n1042             new_model_state = self.to_state.models[app_label, model_name]\n1043 \n1044             old_constraints = old_model_state.options[option_name]\n1045             new_constraints = new_model_state.options[option_name]\n1046             add_constraints = [c for c in new_constraints if c not in old_constraints]\n1047             rem_constraints = [c for c in old_constraints if c not in new_constraints]\n1048 \n1049             self.altered_constraints.update({\n1050                 (app_label, model_name): {\n1051                     'added_constraints': add_constraints, 'removed_constraints': rem_constraints,\n1052                 }\n1053             })\n1054 \n1055     def generate_added_constraints(self):\n1056         for (app_label, model_name), alt_constraints in self.altered_constraints.items():\n1057             for constraint in alt_constraints['added_constraints']:\n1058                 self.add_operation(\n1059                     app_label,\n1060                     operations.AddConstraint(\n1061                         model_name=model_name,\n1062                         constraint=constraint,\n1063                     )\n1064                 )\n1065 \n1066     def generate_removed_constraints(self):\n1067         for (app_label, model_name), alt_constraints in self.altered_constraints.items():\n1068             for constraint in alt_constraints['removed_constraints']:\n1069                 self.add_operation(\n1070                     app_label,\n1071                     operations.RemoveConstraint(\n1072                         model_name=model_name,\n1073                         name=constraint.name,\n1074                     )\n1075                 )\n1076 \n1077     def _get_dependencies_for_foreign_key(self, field):\n1078         # Account for FKs to swappable models\n1079         swappable_setting = getattr(field, 'swappable_setting', None)\n1080         if swappable_setting is not None:\n1081             dep_app_label = \"__setting__\"\n1082             dep_object_name = swappable_setting\n1083         else:\n1084             dep_app_label = field.remote_field.model._meta.app_label\n1085             dep_object_name = field.remote_field.model._meta.object_name\n1086         dependencies = [(dep_app_label, dep_object_name, None, True)]\n1087         if getattr(field.remote_field, \"through\", None) and not field.remote_field.through._meta.auto_created:\n1088             dependencies.append((\n1089                 field.remote_field.through._meta.app_label,\n1090                 field.remote_field.through._meta.object_name,\n1091                 None,\n1092                 True,\n1093             ))\n1094         return dependencies\n1095 \n1096     def _generate_altered_foo_together(self, operation):\n1097         option_name = operation.option_name\n1098         for app_label, model_name in sorted(self.kept_model_keys):\n1099             old_model_name = self.renamed_models.get((app_label, model_name), model_name)\n1100             old_model_state = self.from_state.models[app_label, old_model_name]\n1101             new_model_state = self.to_state.models[app_label, model_name]\n1102 \n1103             # We run the old version through the field renames to account for those\n1104             old_value = old_model_state.options.get(option_name)\n1105             old_value = {\n1106                 tuple(\n1107                     self.renamed_fields.get((app_label, model_name, n), n)\n1108                     for n in unique\n1109                 )\n1110                 for unique in old_value\n1111             } if old_value else set()\n1112 \n1113             new_value = new_model_state.options.get(option_name)\n1114             new_value = set(new_value) if new_value else set()\n1115 \n1116             if old_value != new_value:\n1117                 dependencies = []\n1118                 for foo_togethers in new_value:\n1119                     for field_name in foo_togethers:\n1120                         field = self.new_apps.get_model(app_label, model_name)._meta.get_field(field_name)\n1121                         if field.remote_field and field.remote_field.model:\n1122                             dependencies.extend(self._get_dependencies_for_foreign_key(field))\n1123 \n1124                 self.add_operation(\n1125                     app_label,\n1126                     operation(\n1127                         name=model_name,\n1128                         **{option_name: new_value}\n1129                     ),\n1130                     dependencies=dependencies,\n1131                 )\n1132 \n1133     def generate_altered_unique_together(self):\n1134         self._generate_altered_foo_together(operations.AlterUniqueTogether)\n1135 \n1136     def generate_altered_index_together(self):\n1137         self._generate_altered_foo_together(operations.AlterIndexTogether)\n1138 \n1139     def generate_altered_db_table(self):\n1140         models_to_check = self.kept_model_keys.union(self.kept_proxy_keys, self.kept_unmanaged_keys)\n1141         for app_label, model_name in sorted(models_to_check):\n1142             old_model_name = self.renamed_models.get((app_label, model_name), model_name)\n1143             old_model_state = self.from_state.models[app_label, old_model_name]\n1144             new_model_state = self.to_state.models[app_label, model_name]\n1145             old_db_table_name = old_model_state.options.get('db_table')\n1146             new_db_table_name = new_model_state.options.get('db_table')\n1147             if old_db_table_name != new_db_table_name:\n1148                 self.add_operation(\n1149                     app_label,\n1150                     operations.AlterModelTable(\n1151                         name=model_name,\n1152                         table=new_db_table_name,\n1153                     )\n1154                 )\n1155 \n1156     def generate_altered_options(self):\n1157         \"\"\"\n1158         Work out if any non-schema-affecting options have changed and make an\n1159         operation to represent them in state changes (in case Python code in\n1160         migrations needs them).\n1161         \"\"\"\n1162         models_to_check = self.kept_model_keys.union(\n1163             self.kept_proxy_keys,\n1164             self.kept_unmanaged_keys,\n1165             # unmanaged converted to managed\n1166             self.old_unmanaged_keys & self.new_model_keys,\n1167             # managed converted to unmanaged\n1168             self.old_model_keys & self.new_unmanaged_keys,\n1169         )\n1170 \n1171         for app_label, model_name in sorted(models_to_check):\n1172             old_model_name = self.renamed_models.get((app_label, model_name), model_name)\n1173             old_model_state = self.from_state.models[app_label, old_model_name]\n1174             new_model_state = self.to_state.models[app_label, model_name]\n1175             old_options = {\n1176                 key: value for key, value in old_model_state.options.items()\n1177                 if key in AlterModelOptions.ALTER_OPTION_KEYS\n1178             }\n1179             new_options = {\n1180                 key: value for key, value in new_model_state.options.items()\n1181                 if key in AlterModelOptions.ALTER_OPTION_KEYS\n1182             }\n1183             if old_options != new_options:\n1184                 self.add_operation(\n1185                     app_label,\n1186                     operations.AlterModelOptions(\n1187                         name=model_name,\n1188                         options=new_options,\n1189                     )\n1190                 )\n1191 \n1192     def generate_altered_order_with_respect_to(self):\n1193         for app_label, model_name in sorted(self.kept_model_keys):\n1194             old_model_name = self.renamed_models.get((app_label, model_name), model_name)\n1195             old_model_state = self.from_state.models[app_label, old_model_name]\n1196             new_model_state = self.to_state.models[app_label, model_name]\n1197             if (old_model_state.options.get(\"order_with_respect_to\") !=\n1198                     new_model_state.options.get(\"order_with_respect_to\")):\n1199                 # Make sure it comes second if we're adding\n1200                 # (removal dependency is part of RemoveField)\n1201                 dependencies = []\n1202                 if new_model_state.options.get(\"order_with_respect_to\"):\n1203                     dependencies.append((\n1204                         app_label,\n1205                         model_name,\n1206                         new_model_state.options[\"order_with_respect_to\"],\n1207                         True,\n1208                     ))\n1209                 # Actually generate the operation\n1210                 self.add_operation(\n1211                     app_label,\n1212                     operations.AlterOrderWithRespectTo(\n1213                         name=model_name,\n1214                         order_with_respect_to=new_model_state.options.get('order_with_respect_to'),\n1215                     ),\n1216                     dependencies=dependencies,\n1217                 )\n1218 \n1219     def generate_altered_managers(self):\n1220         for app_label, model_name in sorted(self.kept_model_keys):\n1221             old_model_name = self.renamed_models.get((app_label, model_name), model_name)\n1222             old_model_state = self.from_state.models[app_label, old_model_name]\n1223             new_model_state = self.to_state.models[app_label, model_name]\n1224             if old_model_state.managers != new_model_state.managers:\n1225                 self.add_operation(\n1226                     app_label,\n1227                     operations.AlterModelManagers(\n1228                         name=model_name,\n1229                         managers=new_model_state.managers,\n1230                     )\n1231                 )\n1232 \n1233     def arrange_for_graph(self, changes, graph, migration_name=None):\n1234         \"\"\"\n1235         Take a result from changes() and a MigrationGraph, and fix the names\n1236         and dependencies of the changes so they extend the graph from the leaf\n1237         nodes for each app.\n1238         \"\"\"\n1239         leaves = graph.leaf_nodes()\n1240         name_map = {}\n1241         for app_label, migrations in list(changes.items()):\n1242             if not migrations:\n1243                 continue\n1244             # Find the app label's current leaf node\n1245             app_leaf = None\n1246             for leaf in leaves:\n1247                 if leaf[0] == app_label:\n1248                     app_leaf = leaf\n1249                     break\n1250             # Do they want an initial migration for this app?\n1251             if app_leaf is None and not self.questioner.ask_initial(app_label):\n1252                 # They don't.\n1253                 for migration in migrations:\n1254                     name_map[(app_label, migration.name)] = (app_label, \"__first__\")\n1255                 del changes[app_label]\n1256                 continue\n1257             # Work out the next number in the sequence\n1258             if app_leaf is None:\n1259                 next_number = 1\n1260             else:\n1261                 next_number = (self.parse_number(app_leaf[1]) or 0) + 1\n1262             # Name each migration\n1263             for i, migration in enumerate(migrations):\n1264                 if i == 0 and app_leaf:\n1265                     migration.dependencies.append(app_leaf)\n1266                 new_name_parts = ['%04i' % next_number]\n1267                 if migration_name:\n1268                     new_name_parts.append(migration_name)\n1269                 elif i == 0 and not app_leaf:\n1270                     new_name_parts.append('initial')\n1271                 else:\n1272                     new_name_parts.append(migration.suggest_name()[:100])\n1273                 new_name = '_'.join(new_name_parts)\n1274                 name_map[(app_label, migration.name)] = (app_label, new_name)\n1275                 next_number += 1\n1276                 migration.name = new_name\n1277         # Now fix dependencies\n1278         for migrations in changes.values():\n1279             for migration in migrations:\n1280                 migration.dependencies = [name_map.get(d, d) for d in migration.dependencies]\n1281         return changes\n1282 \n1283     def _trim_to_apps(self, changes, app_labels):\n1284         \"\"\"\n1285         Take changes from arrange_for_graph() and set of app labels, and return\n1286         a modified set of changes which trims out as many migrations that are\n1287         not in app_labels as possible. Note that some other migrations may\n1288         still be present as they may be required dependencies.\n1289         \"\"\"\n1290         # Gather other app dependencies in a first pass\n1291         app_dependencies = {}\n1292         for app_label, migrations in changes.items():\n1293             for migration in migrations:\n1294                 for dep_app_label, name in migration.dependencies:\n1295                     app_dependencies.setdefault(app_label, set()).add(dep_app_label)\n1296         required_apps = set(app_labels)\n1297         # Keep resolving till there's no change\n1298         old_required_apps = None\n1299         while old_required_apps != required_apps:\n1300             old_required_apps = set(required_apps)\n1301             required_apps.update(*[app_dependencies.get(app_label, ()) for app_label in required_apps])\n1302         # Remove all migrations that aren't needed\n1303         for app_label in list(changes):\n1304             if app_label not in required_apps:\n1305                 del changes[app_label]\n1306         return changes\n1307 \n1308     @classmethod\n1309     def parse_number(cls, name):\n1310         \"\"\"\n1311         Given a migration name, try to extract a number from the beginning of\n1312         it. If no number is found, return None.\n1313         \"\"\"\n1314         match = re.match(r'^\\d+', name)\n1315         if match:\n1316             return int(match[0])\n1317         return None\n",
        "intended_behavior": "This code should ensure the creation of the `_order` field or acknowledge its presence before generating `AddIndex` migration operations involving the `_order` field. A validation or reordering mechanism might be needed to check if `AlterOrderWithRespectTo` is declared before any `AddIndex` operation that uses the `_order` column. This could involve adjusting the migration dependency graph or adding checks during the migration operation generation phase to preserve the functionality while preventing the race condition error."
    },
    {
        "rel_file_path": "django/db/migrations/operations/models.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.2/django/db/migrations/operations/models.py",
        "start": 1,
        "end": 907,
        "class_name": null,
        "method_name": null,
        "code": "1 from django.db import models\n2 from django.db.migrations.operations.base import Operation\n3 from django.db.migrations.state import ModelState\n4 from django.db.models.options import normalize_together\n5 from django.utils.functional import cached_property\n6 \n7 from .fields import (\n8     AddField, AlterField, FieldOperation, RemoveField, RenameField,\n9 )\n10 from .utils import field_references, get_references, resolve_relation\n11 \n12 \n13 def _check_for_duplicates(arg_name, objs):\n14     used_vals = set()\n15     for val in objs:\n16         if val in used_vals:\n17             raise ValueError(\n18                 \"Found duplicate value %s in CreateModel %s argument.\" % (val, arg_name)\n19             )\n20         used_vals.add(val)\n21 \n22 \n23 class ModelOperation(Operation):\n24     def __init__(self, name):\n25         self.name = name\n26 \n27     @cached_property\n28     def name_lower(self):\n29         return self.name.lower()\n30 \n31     def references_model(self, name, app_label):\n32         return name.lower() == self.name_lower\n33 \n34     def reduce(self, operation, app_label):\n35         return (\n36             super().reduce(operation, app_label) or\n37             not operation.references_model(self.name, app_label)\n38         )\n39 \n40 \n41 class CreateModel(ModelOperation):\n42     \"\"\"Create a model's table.\"\"\"\n43 \n44     serialization_expand_args = ['fields', 'options', 'managers']\n45 \n46     def __init__(self, name, fields, options=None, bases=None, managers=None):\n47         self.fields = fields\n48         self.options = options or {}\n49         self.bases = bases or (models.Model,)\n50         self.managers = managers or []\n51         super().__init__(name)\n52         # Sanity-check that there are no duplicated field names, bases, or\n53         # manager names\n54         _check_for_duplicates('fields', (name for name, _ in self.fields))\n55         _check_for_duplicates('bases', (\n56             base._meta.label_lower if hasattr(base, '_meta') else\n57             base.lower() if isinstance(base, str) else base\n58             for base in self.bases\n59         ))\n60         _check_for_duplicates('managers', (name for name, _ in self.managers))\n61 \n62     def deconstruct(self):\n63         kwargs = {\n64             'name': self.name,\n65             'fields': self.fields,\n66         }\n67         if self.options:\n68             kwargs['options'] = self.options\n69         if self.bases and self.bases != (models.Model,):\n70             kwargs['bases'] = self.bases\n71         if self.managers and self.managers != [('objects', models.Manager())]:\n72             kwargs['managers'] = self.managers\n73         return (\n74             self.__class__.__qualname__,\n75             [],\n76             kwargs\n77         )\n78 \n79     def state_forwards(self, app_label, state):\n80         state.add_model(ModelState(\n81             app_label,\n82             self.name,\n83             list(self.fields),\n84             dict(self.options),\n85             tuple(self.bases),\n86             list(self.managers),\n87         ))\n88 \n89     def database_forwards(self, app_label, schema_editor, from_state, to_state):\n90         model = to_state.apps.get_model(app_label, self.name)\n91         if self.allow_migrate_model(schema_editor.connection.alias, model):\n92             schema_editor.create_model(model)\n93 \n94     def database_backwards(self, app_label, schema_editor, from_state, to_state):\n95         model = from_state.apps.get_model(app_label, self.name)\n96         if self.allow_migrate_model(schema_editor.connection.alias, model):\n97             schema_editor.delete_model(model)\n98 \n99     def describe(self):\n100         return \"Create %smodel %s\" % (\"proxy \" if self.options.get(\"proxy\", False) else \"\", self.name)\n101 \n102     @property\n103     def migration_name_fragment(self):\n104         return self.name_lower\n105 \n106     def references_model(self, name, app_label):\n107         name_lower = name.lower()\n108         if name_lower == self.name_lower:\n109             return True\n110 \n111         # Check we didn't inherit from the model\n112         reference_model_tuple = (app_label, name_lower)\n113         for base in self.bases:\n114             if (base is not models.Model and isinstance(base, (models.base.ModelBase, str)) and\n115                     resolve_relation(base, app_label) == reference_model_tuple):\n116                 return True\n117 \n118         # Check we have no FKs/M2Ms with it\n119         for _name, field in self.fields:\n120             if field_references((app_label, self.name_lower), field, reference_model_tuple):\n121                 return True\n122         return False\n123 \n124     def reduce(self, operation, app_label):\n125         if (isinstance(operation, DeleteModel) and\n126                 self.name_lower == operation.name_lower and\n127                 not self.options.get(\"proxy\", False)):\n128             return []\n129         elif isinstance(operation, RenameModel) and self.name_lower == operation.old_name_lower:\n130             return [\n131                 CreateModel(\n132                     operation.new_name,\n133                     fields=self.fields,\n134                     options=self.options,\n135                     bases=self.bases,\n136                     managers=self.managers,\n137                 ),\n138             ]\n139         elif isinstance(operation, AlterModelOptions) and self.name_lower == operation.name_lower:\n140             return [\n141                 CreateModel(\n142                     self.name,\n143                     fields=self.fields,\n144                     options={**self.options, **operation.options},\n145                     bases=self.bases,\n146                     managers=self.managers,\n147                 ),\n148             ]\n149         elif isinstance(operation, AlterTogetherOptionOperation) and self.name_lower == operation.name_lower:\n150             return [\n151                 CreateModel(\n152                     self.name,\n153                     fields=self.fields,\n154                     options={**self.options, **{operation.option_name: operation.option_value}},\n155                     bases=self.bases,\n156                     managers=self.managers,\n157                 ),\n158             ]\n159         elif isinstance(operation, AlterOrderWithRespectTo) and self.name_lower == operation.name_lower:\n160             return [\n161                 CreateModel(\n162                     self.name,\n163                     fields=self.fields,\n164                     options={**self.options, 'order_with_respect_to': operation.order_with_respect_to},\n165                     bases=self.bases,\n166                     managers=self.managers,\n167                 ),\n168             ]\n169         elif isinstance(operation, FieldOperation) and self.name_lower == operation.model_name_lower:\n170             if isinstance(operation, AddField):\n171                 return [\n172                     CreateModel(\n173                         self.name,\n174                         fields=self.fields + [(operation.name, operation.field)],\n175                         options=self.options,\n176                         bases=self.bases,\n177                         managers=self.managers,\n178                     ),\n179                 ]\n180             elif isinstance(operation, AlterField):\n181                 return [\n182                     CreateModel(\n183                         self.name,\n184                         fields=[\n185                             (n, operation.field if n == operation.name else v)\n186                             for n, v in self.fields\n187                         ],\n188                         options=self.options,\n189                         bases=self.bases,\n190                         managers=self.managers,\n191                     ),\n192                 ]\n193             elif isinstance(operation, RemoveField):\n194                 options = self.options.copy()\n195                 for option_name in ('unique_together', 'index_together'):\n196                     option = options.pop(option_name, None)\n197                     if option:\n198                         option = set(filter(bool, (\n199                             tuple(f for f in fields if f != operation.name_lower) for fields in option\n200                         )))\n201                         if option:\n202                             options[option_name] = option\n203                 order_with_respect_to = options.get('order_with_respect_to')\n204                 if order_with_respect_to == operation.name_lower:\n205                     del options['order_with_respect_to']\n206                 return [\n207                     CreateModel(\n208                         self.name,\n209                         fields=[\n210                             (n, v)\n211                             for n, v in self.fields\n212                             if n.lower() != operation.name_lower\n213                         ],\n214                         options=options,\n215                         bases=self.bases,\n216                         managers=self.managers,\n217                     ),\n218                 ]\n219             elif isinstance(operation, RenameField):\n220                 options = self.options.copy()\n221                 for option_name in ('unique_together', 'index_together'):\n222                     option = options.get(option_name)\n223                     if option:\n224                         options[option_name] = {\n225                             tuple(operation.new_name if f == operation.old_name else f for f in fields)\n226                             for fields in option\n227                         }\n228                 order_with_respect_to = options.get('order_with_respect_to')\n229                 if order_with_respect_to == operation.old_name:\n230                     options['order_with_respect_to'] = operation.new_name\n231                 return [\n232                     CreateModel(\n233                         self.name,\n234                         fields=[\n235                             (operation.new_name if n == operation.old_name else n, v)\n236                             for n, v in self.fields\n237                         ],\n238                         options=options,\n239                         bases=self.bases,\n240                         managers=self.managers,\n241                     ),\n242                 ]\n243         return super().reduce(operation, app_label)\n244 \n245 \n246 class DeleteModel(ModelOperation):\n247     \"\"\"Drop a model's table.\"\"\"\n248 \n249     def deconstruct(self):\n250         kwargs = {\n251             'name': self.name,\n252         }\n253         return (\n254             self.__class__.__qualname__,\n255             [],\n256             kwargs\n257         )\n258 \n259     def state_forwards(self, app_label, state):\n260         state.remove_model(app_label, self.name_lower)\n261 \n262     def database_forwards(self, app_label, schema_editor, from_state, to_state):\n263         model = from_state.apps.get_model(app_label, self.name)\n264         if self.allow_migrate_model(schema_editor.connection.alias, model):\n265             schema_editor.delete_model(model)\n266 \n267     def database_backwards(self, app_label, schema_editor, from_state, to_state):\n268         model = to_state.apps.get_model(app_label, self.name)\n269         if self.allow_migrate_model(schema_editor.connection.alias, model):\n270             schema_editor.create_model(model)\n271 \n272     def references_model(self, name, app_label):\n273         # The deleted model could be referencing the specified model through\n274         # related fields.\n275         return True\n276 \n277     def describe(self):\n278         return \"Delete model %s\" % self.name\n279 \n280     @property\n281     def migration_name_fragment(self):\n282         return 'delete_%s' % self.name_lower\n283 \n284 \n285 class RenameModel(ModelOperation):\n286     \"\"\"Rename a model.\"\"\"\n287 \n288     def __init__(self, old_name, new_name):\n289         self.old_name = old_name\n290         self.new_name = new_name\n291         super().__init__(old_name)\n292 \n293     @cached_property\n294     def old_name_lower(self):\n295         return self.old_name.lower()\n296 \n297     @cached_property\n298     def new_name_lower(self):\n299         return self.new_name.lower()\n300 \n301     def deconstruct(self):\n302         kwargs = {\n303             'old_name': self.old_name,\n304             'new_name': self.new_name,\n305         }\n306         return (\n307             self.__class__.__qualname__,\n308             [],\n309             kwargs\n310         )\n311 \n312     def state_forwards(self, app_label, state):\n313         # Add a new model.\n314         renamed_model = state.models[app_label, self.old_name_lower].clone()\n315         renamed_model.name = self.new_name\n316         state.models[app_label, self.new_name_lower] = renamed_model\n317         # Repoint all fields pointing to the old model to the new one.\n318         old_model_tuple = (app_label, self.old_name_lower)\n319         new_remote_model = '%s.%s' % (app_label, self.new_name)\n320         to_reload = set()\n321         for model_state, name, field, reference in get_references(state, old_model_tuple):\n322             changed_field = None\n323             if reference.to:\n324                 changed_field = field.clone()\n325                 changed_field.remote_field.model = new_remote_model\n326             if reference.through:\n327                 if changed_field is None:\n328                     changed_field = field.clone()\n329                 changed_field.remote_field.through = new_remote_model\n330             if changed_field:\n331                 model_state.fields[name] = changed_field\n332                 to_reload.add((model_state.app_label, model_state.name_lower))\n333         # Reload models related to old model before removing the old model.\n334         state.reload_models(to_reload, delay=True)\n335         # Remove the old model.\n336         state.remove_model(app_label, self.old_name_lower)\n337         state.reload_model(app_label, self.new_name_lower, delay=True)\n338 \n339     def database_forwards(self, app_label, schema_editor, from_state, to_state):\n340         new_model = to_state.apps.get_model(app_label, self.new_name)\n341         if self.allow_migrate_model(schema_editor.connection.alias, new_model):\n342             old_model = from_state.apps.get_model(app_label, self.old_name)\n343             # Move the main table\n344             schema_editor.alter_db_table(\n345                 new_model,\n346                 old_model._meta.db_table,\n347                 new_model._meta.db_table,\n348             )\n349             # Alter the fields pointing to us\n350             for related_object in old_model._meta.related_objects:\n351                 if related_object.related_model == old_model:\n352                     model = new_model\n353                     related_key = (app_label, self.new_name_lower)\n354                 else:\n355                     model = related_object.related_model\n356                     related_key = (\n357                         related_object.related_model._meta.app_label,\n358                         related_object.related_model._meta.model_name,\n359                     )\n360                 to_field = to_state.apps.get_model(\n361                     *related_key\n362                 )._meta.get_field(related_object.field.name)\n363                 schema_editor.alter_field(\n364                     model,\n365                     related_object.field,\n366                     to_field,\n367                 )\n368             # Rename M2M fields whose name is based on this model's name.\n369             fields = zip(old_model._meta.local_many_to_many, new_model._meta.local_many_to_many)\n370             for (old_field, new_field) in fields:\n371                 # Skip self-referential fields as these are renamed above.\n372                 if new_field.model == new_field.related_model or not new_field.remote_field.through._meta.auto_created:\n373                     continue\n374                 # Rename the M2M table that's based on this model's name.\n375                 old_m2m_model = old_field.remote_field.through\n376                 new_m2m_model = new_field.remote_field.through\n377                 schema_editor.alter_db_table(\n378                     new_m2m_model,\n379                     old_m2m_model._meta.db_table,\n380                     new_m2m_model._meta.db_table,\n381                 )\n382                 # Rename the column in the M2M table that's based on this\n383                 # model's name.\n384                 schema_editor.alter_field(\n385                     new_m2m_model,\n386                     old_m2m_model._meta.get_field(old_model._meta.model_name),\n387                     new_m2m_model._meta.get_field(new_model._meta.model_name),\n388                 )\n389 \n390     def database_backwards(self, app_label, schema_editor, from_state, to_state):\n391         self.new_name_lower, self.old_name_lower = self.old_name_lower, self.new_name_lower\n392         self.new_name, self.old_name = self.old_name, self.new_name\n393 \n394         self.database_forwards(app_label, schema_editor, from_state, to_state)\n395 \n396         self.new_name_lower, self.old_name_lower = self.old_name_lower, self.new_name_lower\n397         self.new_name, self.old_name = self.old_name, self.new_name\n398 \n399     def references_model(self, name, app_label):\n400         return (\n401             name.lower() == self.old_name_lower or\n402             name.lower() == self.new_name_lower\n403         )\n404 \n405     def describe(self):\n406         return \"Rename model %s to %s\" % (self.old_name, self.new_name)\n407 \n408     @property\n409     def migration_name_fragment(self):\n410         return 'rename_%s_%s' % (self.old_name_lower, self.new_name_lower)\n411 \n412     def reduce(self, operation, app_label):\n413         if (isinstance(operation, RenameModel) and\n414                 self.new_name_lower == operation.old_name_lower):\n415             return [\n416                 RenameModel(\n417                     self.old_name,\n418                     operation.new_name,\n419                 ),\n420             ]\n421         # Skip `ModelOperation.reduce` as we want to run `references_model`\n422         # against self.new_name.\n423         return (\n424             super(ModelOperation, self).reduce(operation, app_label) or\n425             not operation.references_model(self.new_name, app_label)\n426         )\n427 \n428 \n429 class ModelOptionOperation(ModelOperation):\n430     def reduce(self, operation, app_label):\n431         if isinstance(operation, (self.__class__, DeleteModel)) and self.name_lower == operation.name_lower:\n432             return [operation]\n433         return super().reduce(operation, app_label)\n434 \n435 \n436 class AlterModelTable(ModelOptionOperation):\n437     \"\"\"Rename a model's table.\"\"\"\n438 \n439     def __init__(self, name, table):\n440         self.table = table\n441         super().__init__(name)\n442 \n443     def deconstruct(self):\n444         kwargs = {\n445             'name': self.name,\n446             'table': self.table,\n447         }\n448         return (\n449             self.__class__.__qualname__,\n450             [],\n451             kwargs\n452         )\n453 \n454     def state_forwards(self, app_label, state):\n455         state.models[app_label, self.name_lower].options[\"db_table\"] = self.table\n456         state.reload_model(app_label, self.name_lower, delay=True)\n457 \n458     def database_forwards(self, app_label, schema_editor, from_state, to_state):\n459         new_model = to_state.apps.get_model(app_label, self.name)\n460         if self.allow_migrate_model(schema_editor.connection.alias, new_model):\n461             old_model = from_state.apps.get_model(app_label, self.name)\n462             schema_editor.alter_db_table(\n463                 new_model,\n464                 old_model._meta.db_table,\n465                 new_model._meta.db_table,\n466             )\n467             # Rename M2M fields whose name is based on this model's db_table\n468             for (old_field, new_field) in zip(old_model._meta.local_many_to_many, new_model._meta.local_many_to_many):\n469                 if new_field.remote_field.through._meta.auto_created:\n470                     schema_editor.alter_db_table(\n471                         new_field.remote_field.through,\n472                         old_field.remote_field.through._meta.db_table,\n473                         new_field.remote_field.through._meta.db_table,\n474                     )\n475 \n476     def database_backwards(self, app_label, schema_editor, from_state, to_state):\n477         return self.database_forwards(app_label, schema_editor, from_state, to_state)\n478 \n479     def describe(self):\n480         return \"Rename table for %s to %s\" % (\n481             self.name,\n482             self.table if self.table is not None else \"(default)\"\n483         )\n484 \n485     @property\n486     def migration_name_fragment(self):\n487         return 'alter_%s_table' % self.name_lower\n488 \n489 \n490 class AlterTogetherOptionOperation(ModelOptionOperation):\n491     option_name = None\n492 \n493     def __init__(self, name, option_value):\n494         if option_value:\n495             option_value = set(normalize_together(option_value))\n496         setattr(self, self.option_name, option_value)\n497         super().__init__(name)\n498 \n499     @cached_property\n500     def option_value(self):\n501         return getattr(self, self.option_name)\n502 \n503     def deconstruct(self):\n504         kwargs = {\n505             'name': self.name,\n506             self.option_name: self.option_value,\n507         }\n508         return (\n509             self.__class__.__qualname__,\n510             [],\n511             kwargs\n512         )\n513 \n514     def state_forwards(self, app_label, state):\n515         model_state = state.models[app_label, self.name_lower]\n516         model_state.options[self.option_name] = self.option_value\n517         state.reload_model(app_label, self.name_lower, delay=True)\n518 \n519     def database_forwards(self, app_label, schema_editor, from_state, to_state):\n520         new_model = to_state.apps.get_model(app_label, self.name)\n521         if self.allow_migrate_model(schema_editor.connection.alias, new_model):\n522             old_model = from_state.apps.get_model(app_label, self.name)\n523             alter_together = getattr(schema_editor, 'alter_%s' % self.option_name)\n524             alter_together(\n525                 new_model,\n526                 getattr(old_model._meta, self.option_name, set()),\n527                 getattr(new_model._meta, self.option_name, set()),\n528             )\n529 \n530     def database_backwards(self, app_label, schema_editor, from_state, to_state):\n531         return self.database_forwards(app_label, schema_editor, from_state, to_state)\n532 \n533     def references_field(self, model_name, name, app_label):\n534         return (\n535             self.references_model(model_name, app_label) and\n536             (\n537                 not self.option_value or\n538                 any((name in fields) for fields in self.option_value)\n539             )\n540         )\n541 \n542     def describe(self):\n543         return \"Alter %s for %s (%s constraint(s))\" % (self.option_name, self.name, len(self.option_value or ''))\n544 \n545     @property\n546     def migration_name_fragment(self):\n547         return 'alter_%s_%s' % (self.name_lower, self.option_name)\n548 \n549 \n550 class AlterUniqueTogether(AlterTogetherOptionOperation):\n551     \"\"\"\n552     Change the value of unique_together to the target one.\n553     Input value of unique_together must be a set of tuples.\n554     \"\"\"\n555     option_name = 'unique_together'\n556 \n557     def __init__(self, name, unique_together):\n558         super().__init__(name, unique_together)\n559 \n560 \n561 class AlterIndexTogether(AlterTogetherOptionOperation):\n562     \"\"\"\n563     Change the value of index_together to the target one.\n564     Input value of index_together must be a set of tuples.\n565     \"\"\"\n566     option_name = \"index_together\"\n567 \n568     def __init__(self, name, index_together):\n569         super().__init__(name, index_together)\n570 \n571 \n572 class AlterOrderWithRespectTo(ModelOptionOperation):\n573     \"\"\"Represent a change with the order_with_respect_to option.\"\"\"\n574 \n575     option_name = 'order_with_respect_to'\n576 \n577     def __init__(self, name, order_with_respect_to):\n578         self.order_with_respect_to = order_with_respect_to\n579         super().__init__(name)\n580 \n581     def deconstruct(self):\n582         kwargs = {\n583             'name': self.name,\n584             'order_with_respect_to': self.order_with_respect_to,\n585         }\n586         return (\n587             self.__class__.__qualname__,\n588             [],\n589             kwargs\n590         )\n591 \n592     def state_forwards(self, app_label, state):\n593         model_state = state.models[app_label, self.name_lower]\n594         model_state.options['order_with_respect_to'] = self.order_with_respect_to\n595         state.reload_model(app_label, self.name_lower, delay=True)\n596 \n597     def database_forwards(self, app_label, schema_editor, from_state, to_state):\n598         to_model = to_state.apps.get_model(app_label, self.name)\n599         if self.allow_migrate_model(schema_editor.connection.alias, to_model):\n600             from_model = from_state.apps.get_model(app_label, self.name)\n601             # Remove a field if we need to\n602             if from_model._meta.order_with_respect_to and not to_model._meta.order_with_respect_to:\n603                 schema_editor.remove_field(from_model, from_model._meta.get_field(\"_order\"))\n604             # Add a field if we need to (altering the column is untouched as\n605             # it's likely a rename)\n606             elif to_model._meta.order_with_respect_to and not from_model._meta.order_with_respect_to:\n607                 field = to_model._meta.get_field(\"_order\")\n608                 if not field.has_default():\n609                     field.default = 0\n610                 schema_editor.add_field(\n611                     from_model,\n612                     field,\n613                 )\n614 \n615     def database_backwards(self, app_label, schema_editor, from_state, to_state):\n616         self.database_forwards(app_label, schema_editor, from_state, to_state)\n617 \n618     def references_field(self, model_name, name, app_label):\n619         return (\n620             self.references_model(model_name, app_label) and\n621             (\n622                 self.order_with_respect_to is None or\n623                 name == self.order_with_respect_to\n624             )\n625         )\n626 \n627     def describe(self):\n628         return \"Set order_with_respect_to on %s to %s\" % (self.name, self.order_with_respect_to)\n629 \n630     @property\n631     def migration_name_fragment(self):\n632         return 'alter_%s_order_with_respect_to' % self.name_lower\n633 \n634 \n635 class AlterModelOptions(ModelOptionOperation):\n636     \"\"\"\n637     Set new model options that don't directly affect the database schema\n638     (like verbose_name, permissions, ordering). Python code in migrations\n639     may still need them.\n640     \"\"\"\n641 \n642     # Model options we want to compare and preserve in an AlterModelOptions op\n643     ALTER_OPTION_KEYS = [\n644         \"base_manager_name\",\n645         \"default_manager_name\",\n646         \"default_related_name\",\n647         \"get_latest_by\",\n648         \"managed\",\n649         \"ordering\",\n650         \"permissions\",\n651         \"default_permissions\",\n652         \"select_on_save\",\n653         \"verbose_name\",\n654         \"verbose_name_plural\",\n655     ]\n656 \n657     def __init__(self, name, options):\n658         self.options = options\n659         super().__init__(name)\n660 \n661     def deconstruct(self):\n662         kwargs = {\n663             'name': self.name,\n664             'options': self.options,\n665         }\n666         return (\n667             self.__class__.__qualname__,\n668             [],\n669             kwargs\n670         )\n671 \n672     def state_forwards(self, app_label, state):\n673         model_state = state.models[app_label, self.name_lower]\n674         model_state.options = {**model_state.options, **self.options}\n675         for key in self.ALTER_OPTION_KEYS:\n676             if key not in self.options:\n677                 model_state.options.pop(key, False)\n678         state.reload_model(app_label, self.name_lower, delay=True)\n679 \n680     def database_forwards(self, app_label, schema_editor, from_state, to_state):\n681         pass\n682 \n683     def database_backwards(self, app_label, schema_editor, from_state, to_state):\n684         pass\n685 \n686     def describe(self):\n687         return \"Change Meta options on %s\" % self.name\n688 \n689     @property\n690     def migration_name_fragment(self):\n691         return 'alter_%s_options' % self.name_lower\n692 \n693 \n694 class AlterModelManagers(ModelOptionOperation):\n695     \"\"\"Alter the model's managers.\"\"\"\n696 \n697     serialization_expand_args = ['managers']\n698 \n699     def __init__(self, name, managers):\n700         self.managers = managers\n701         super().__init__(name)\n702 \n703     def deconstruct(self):\n704         return (\n705             self.__class__.__qualname__,\n706             [self.name, self.managers],\n707             {}\n708         )\n709 \n710     def state_forwards(self, app_label, state):\n711         model_state = state.models[app_label, self.name_lower]\n712         model_state.managers = list(self.managers)\n713         state.reload_model(app_label, self.name_lower, delay=True)\n714 \n715     def database_forwards(self, app_label, schema_editor, from_state, to_state):\n716         pass\n717 \n718     def database_backwards(self, app_label, schema_editor, from_state, to_state):\n719         pass\n720 \n721     def describe(self):\n722         return \"Change managers on %s\" % self.name\n723 \n724     @property\n725     def migration_name_fragment(self):\n726         return 'alter_%s_managers' % self.name_lower\n727 \n728 \n729 class IndexOperation(Operation):\n730     option_name = 'indexes'\n731 \n732     @cached_property\n733     def model_name_lower(self):\n734         return self.model_name.lower()\n735 \n736 \n737 class AddIndex(IndexOperation):\n738     \"\"\"Add an index on a model.\"\"\"\n739 \n740     def __init__(self, model_name, index):\n741         self.model_name = model_name\n742         if not index.name:\n743             raise ValueError(\n744                 \"Indexes passed to AddIndex operations require a name \"\n745                 \"argument. %r doesn't have one.\" % index\n746             )\n747         self.index = index\n748 \n749     def state_forwards(self, app_label, state):\n750         model_state = state.models[app_label, self.model_name_lower]\n751         model_state.options[self.option_name] = [*model_state.options[self.option_name], self.index.clone()]\n752         state.reload_model(app_label, self.model_name_lower, delay=True)\n753 \n754     def database_forwards(self, app_label, schema_editor, from_state, to_state):\n755         model = to_state.apps.get_model(app_label, self.model_name)\n756         if self.allow_migrate_model(schema_editor.connection.alias, model):\n757             schema_editor.add_index(model, self.index)\n758 \n759     def database_backwards(self, app_label, schema_editor, from_state, to_state):\n760         model = from_state.apps.get_model(app_label, self.model_name)\n761         if self.allow_migrate_model(schema_editor.connection.alias, model):\n762             schema_editor.remove_index(model, self.index)\n763 \n764     def deconstruct(self):\n765         kwargs = {\n766             'model_name': self.model_name,\n767             'index': self.index,\n768         }\n769         return (\n770             self.__class__.__qualname__,\n771             [],\n772             kwargs,\n773         )\n774 \n775     def describe(self):\n776         return 'Create index %s on field(s) %s of model %s' % (\n777             self.index.name,\n778             ', '.join(self.index.fields),\n779             self.model_name,\n780         )\n781 \n782     @property\n783     def migration_name_fragment(self):\n784         return '%s_%s' % (self.model_name_lower, self.index.name.lower())\n785 \n786 \n787 class RemoveIndex(IndexOperation):\n788     \"\"\"Remove an index from a model.\"\"\"\n789 \n790     def __init__(self, model_name, name):\n791         self.model_name = model_name\n792         self.name = name\n793 \n794     def state_forwards(self, app_label, state):\n795         model_state = state.models[app_label, self.model_name_lower]\n796         indexes = model_state.options[self.option_name]\n797         model_state.options[self.option_name] = [idx for idx in indexes if idx.name != self.name]\n798         state.reload_model(app_label, self.model_name_lower, delay=True)\n799 \n800     def database_forwards(self, app_label, schema_editor, from_state, to_state):\n801         model = from_state.apps.get_model(app_label, self.model_name)\n802         if self.allow_migrate_model(schema_editor.connection.alias, model):\n803             from_model_state = from_state.models[app_label, self.model_name_lower]\n804             index = from_model_state.get_index_by_name(self.name)\n805             schema_editor.remove_index(model, index)\n806 \n807     def database_backwards(self, app_label, schema_editor, from_state, to_state):\n808         model = to_state.apps.get_model(app_label, self.model_name)\n809         if self.allow_migrate_model(schema_editor.connection.alias, model):\n810             to_model_state = to_state.models[app_label, self.model_name_lower]\n811             index = to_model_state.get_index_by_name(self.name)\n812             schema_editor.add_index(model, index)\n813 \n814     def deconstruct(self):\n815         kwargs = {\n816             'model_name': self.model_name,\n817             'name': self.name,\n818         }\n819         return (\n820             self.__class__.__qualname__,\n821             [],\n822             kwargs,\n823         )\n824 \n825     def describe(self):\n826         return 'Remove index %s from %s' % (self.name, self.model_name)\n827 \n828     @property\n829     def migration_name_fragment(self):\n830         return 'remove_%s_%s' % (self.model_name_lower, self.name.lower())\n831 \n832 \n833 class AddConstraint(IndexOperation):\n834     option_name = 'constraints'\n835 \n836     def __init__(self, model_name, constraint):\n837         self.model_name = model_name\n838         self.constraint = constraint\n839 \n840     def state_forwards(self, app_label, state):\n841         model_state = state.models[app_label, self.model_name_lower]\n842         model_state.options[self.option_name] = [*model_state.options[self.option_name], self.constraint]\n843         state.reload_model(app_label, self.model_name_lower, delay=True)\n844 \n845     def database_forwards(self, app_label, schema_editor, from_state, to_state):\n846         model = to_state.apps.get_model(app_label, self.model_name)\n847         if self.allow_migrate_model(schema_editor.connection.alias, model):\n848             schema_editor.add_constraint(model, self.constraint)\n849 \n850     def database_backwards(self, app_label, schema_editor, from_state, to_state):\n851         model = to_state.apps.get_model(app_label, self.model_name)\n852         if self.allow_migrate_model(schema_editor.connection.alias, model):\n853             schema_editor.remove_constraint(model, self.constraint)\n854 \n855     def deconstruct(self):\n856         return self.__class__.__name__, [], {\n857             'model_name': self.model_name,\n858             'constraint': self.constraint,\n859         }\n860 \n861     def describe(self):\n862         return 'Create constraint %s on model %s' % (self.constraint.name, self.model_name)\n863 \n864     @property\n865     def migration_name_fragment(self):\n866         return '%s_%s' % (self.model_name_lower, self.constraint.name.lower())\n867 \n868 \n869 class RemoveConstraint(IndexOperation):\n870     option_name = 'constraints'\n871 \n872     def __init__(self, model_name, name):\n873         self.model_name = model_name\n874         self.name = name\n875 \n876     def state_forwards(self, app_label, state):\n877         model_state = state.models[app_label, self.model_name_lower]\n878         constraints = model_state.options[self.option_name]\n879         model_state.options[self.option_name] = [c for c in constraints if c.name != self.name]\n880         state.reload_model(app_label, self.model_name_lower, delay=True)\n881 \n882     def database_forwards(self, app_label, schema_editor, from_state, to_state):\n883         model = to_state.apps.get_model(app_label, self.model_name)\n884         if self.allow_migrate_model(schema_editor.connection.alias, model):\n885             from_model_state = from_state.models[app_label, self.model_name_lower]\n886             constraint = from_model_state.get_constraint_by_name(self.name)\n887             schema_editor.remove_constraint(model, constraint)\n888 \n889     def database_backwards(self, app_label, schema_editor, from_state, to_state):\n890         model = to_state.apps.get_model(app_label, self.model_name)\n891         if self.allow_migrate_model(schema_editor.connection.alias, model):\n892             to_model_state = to_state.models[app_label, self.model_name_lower]\n893             constraint = to_model_state.get_constraint_by_name(self.name)\n894             schema_editor.add_constraint(model, constraint)\n895 \n896     def deconstruct(self):\n897         return self.__class__.__name__, [], {\n898             'model_name': self.model_name,\n899             'name': self.name,\n900         }\n901 \n902     def describe(self):\n903         return 'Remove constraint %s from model %s' % (self.name, self.model_name)\n904 \n905     @property\n906     def migration_name_fragment(self):\n907         return 'remove_%s_%s' % (self.model_name_lower, self.name.lower())\n",
        "intended_behavior": "Modification here should ensure that `AlterOrderWithRespectTo` operations are prioritized, or trigger the implicit creation of the `_order` field in a way that it's recognized as existing by the time `AddIndex` is processed. This could involve implementing a pre-check in the `AddIndex` operation that ensures dependencies like `_order` are addressed first or provide a clear error message guiding the developer to adjust the migration order manually. Additionally, documentation within the code could be updated to highlight this requirement for developers."
    }
]