2025-10-18 09:23:07.652 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-18 09:23:17.994 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=347, output_tokens=12, cost=0.003830
2025-10-18 09:23:32.676 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=527, output_tokens=617, cost=0.023780
2025-10-18 09:23:34.192 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 09:23:41.877 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=656, output_tokens=365, cost=0.017510
2025-10-18 09:23:41.886 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 09:23:44.431 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=719, output_tokens=42, cost=0.008450
2025-10-18 09:23:44.433 | DEBUG    | Extracted a valid json.
2025-10-18 09:23:44.439 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_class(\"Lambda\")",
        "search_method(\"imageset\")",
        "search_class(\"Reals\")"
    ],
    "bug_locations": []
}
2025-10-18 09:23:44.502 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 09:23:44.503 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 09:24:01.801 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2784, output_tokens=828, cost=0.052680
2025-10-18 09:24:01.819 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 09:24:11.346 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3828, output_tokens=394, cost=0.050100
2025-10-18 09:24:11.356 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 09:24:20.140 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=748, output_tokens=277, cost=0.015790
2025-10-18 09:24:20.142 | DEBUG    | Extracted a valid json.
2025-10-18 09:24:20.142 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_method_in_class(\"intersect\", \"ImageSet\")",
        "search_method_in_class(\"__contains__\", \"ImageSet\")"
    ],
    "bug_locations": [
        {
            "file": "sympy/sets/sets.py",
            "class": "",
            "method": "imageset",
            "intended_behavior": "The `imageset` function should correctly handle complex numbers, especially when creating sets involving complex numbers through lambda functions. It must ensure that the intersection with `Reals` accurately reflects only real numbers, filtering out complex numbers. Modification may be required to accurately check the nature of the output expressions (real vs. complex) and handle them appropriately during intersection operations."
        },
        {
            "file": "sympy/sets/fancysets.py",
            "class": "Reals",
            "method": "",
            "intended_behavior": "While the `Reals` class itself may not be directly modified to fix the bug, ensuring its interaction with `ImageSet` during intersection operations correctly identifies real number elements is crucial. This may involve adjusting or precisely defining how `Reals` interacts with other sets, especially `ImageSet`, to validate membership more accurately (perhaps through a more nuanced implementation within the `ImageSet` class)."
        }
    ]
}
2025-10-18 09:24:20.149 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 09:24:20.149 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 09:24:33.003 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=4384, output_tokens=627, cost=0.062650
2025-10-18 09:24:33.016 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 09:24:41.389 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=5227, output_tokens=387, cost=0.063880
2025-10-18 09:24:41.396 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 09:24:45.837 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=741, output_tokens=142, cost=0.011670
2025-10-18 09:24:45.839 | DEBUG    | Extracted a valid json.
2025-10-18 09:24:45.839 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "sympy/sets/fancysets.py",
            "class": "",
            "method": "",
            "intended_behavior": "This method should ensure that intersections between an ImageSet producing complex numbers and Reals are accurately calculated, excluding any non-real numbers from the results. This may require implementing a check within the intersection logic to explicitly determine if a given element from an ImageSet is real before including it in the result set when intersecting with Reals. Enhancing the logic to understand and simplify complex expressions better, to accurately determine their real-number status in an intersection scenario."
        }
    ]
}
2025-10-18 09:24:45.844 | DEBUG    | Bug location extracted successfully: [<file>sympy/sets/fancysets.py</file>
<class>None</class>
<method>None</method>
<code>
1 from functools import reduce
2 
3 from sympy.core.basic import Basic
4 from sympy.core.containers import Tuple
5 from sympy.core.expr import Expr
6 from sympy.core.function import Lambda
7 from sympy.core.logic import fuzzy_not, fuzzy_or, fuzzy_and
8 from sympy.core.numbers import oo
9 from sympy.core.relational import Eq, is_eq
10 from sympy.core.singleton import Singleton, S
11 from sympy.core.symbol import Dummy, symbols, Symbol
12 from sympy.core.sympify import _sympify, sympify, converter
13 from sympy.logic.boolalg import And, Or
14 from sympy.sets.sets import (Set, Interval, Union, FiniteSet,
15     ProductSet)
16 from sympy.utilities.misc import filldedent
17 from sympy.utilities.iterables import cartes
18 
19 
20 class Rationals(Set, metaclass=Singleton):
21     """
22     Represents the rational numbers. This set is also available as
23     the Singleton, S.Rationals.
24 
25     Examples
26     ========
27 
28     >>> from sympy import S
29     >>> S.Half in S.Rationals
30     True
31     >>> iterable = iter(S.Rationals)
32     >>> [next(iterable) for i in range(12)]
33     [0, 1, -1, 1/2, 2, -1/2, -2, 1/3, 3, -1/3, -3, 2/3]
34     """
35 
36     is_iterable = True
37     _inf = S.NegativeInfinity
38     _sup = S.Infinity
39     is_empty = False
40     is_finite_set = False
41 
42     def _contains(self, other):
43         if not isinstance(other, Expr):
44             return False
45         return other.is_rational
46 
47     def __iter__(self):
48         from sympy.core.numbers import igcd, Rational
49         yield S.Zero
50         yield S.One
51         yield S.NegativeOne
52         d = 2
53         while True:
54             for n in range(d):
55                 if igcd(n, d) == 1:
56                     yield Rational(n, d)
57                     yield Rational(d, n)
58                     yield Rational(-n, d)
59                     yield Rational(-d, n)
60             d += 1
61 
62     @property
63     def _boundary(self):
64         return S.Reals
65 
66 
67 class Naturals(Set, metaclass=Singleton):
68     """
69     Represents the natural numbers (or counting numbers) which are all
70     positive integers starting from 1. This set is also available as
71     the Singleton, S.Naturals.
72 
73     Examples
74     ========
75 
76     >>> from sympy import S, Interval, pprint
77     >>> 5 in S.Naturals
78     True
79     >>> iterable = iter(S.Naturals)
80     >>> next(iterable)
81     1
82     >>> next(iterable)
83     2
84     >>> next(iterable)
85     3
86     >>> pprint(S.Naturals.intersect(Interval(0, 10)))
87     {1, 2, ..., 10}
88 
89     See Also
90     ========
91 
92     Naturals0 : non-negative integers (i.e. includes 0, too)
93     Integers : also includes negative integers
94     """
95 
96     is_iterable = True
97     _inf = S.One
98     _sup = S.Infinity
99     is_empty = False
100     is_finite_set = False
101 
102     def _contains(self, other):
103         if not isinstance(other, Expr):
104             return False
105         elif other.is_positive and other.is_integer:
106             return True
107         elif other.is_integer is False or other.is_positive is False:
108             return False
109 
110     def _eval_is_subset(self, other):
111         return Range(1, oo).is_subset(other)
112 
113     def _eval_is_superset(self, other):
114         return Range(1, oo).is_superset(other)
115 
116     def __iter__(self):
117         i = self._inf
118         while True:
119             yield i
120             i = i + 1
121 
122     @property
123     def _boundary(self):
124         return self
125 
126     def as_relational(self, x):
127         from sympy.functions.elementary.integers import floor
128         return And(Eq(floor(x), x), x >= self.inf, x < oo)
129 
130 
131 class Naturals0(Naturals):
132     """Represents the whole numbers which are all the non-negative integers,
133     inclusive of zero.
134 
135     See Also
136     ========
137 
138     Naturals : positive integers; does not include 0
139     Integers : also includes the negative integers
140     """
141     _inf = S.Zero
142 
143     def _contains(self, other):
144         if not isinstance(other, Expr):
145             return S.false
146         elif other.is_integer and other.is_nonnegative:
147             return S.true
148         elif other.is_integer is False or other.is_nonnegative is False:
149             return S.false
150 
151     def _eval_is_subset(self, other):
152         return Range(oo).is_subset(other)
153 
154     def _eval_is_superset(self, other):
155         return Range(oo).is_superset(other)
156 
157 
158 class Integers(Set, metaclass=Singleton):
159     """
160     Represents all integers: positive, negative and zero. This set is also
161     available as the Singleton, S.Integers.
162 
163     Examples
164     ========
165 
166     >>> from sympy import S, Interval, pprint
167     >>> 5 in S.Naturals
168     True
169     >>> iterable = iter(S.Integers)
170     >>> next(iterable)
171     0
172     >>> next(iterable)
173     1
174     >>> next(iterable)
175     -1
176     >>> next(iterable)
177     2
178 
179     >>> pprint(S.Integers.intersect(Interval(-4, 4)))
180     {-4, -3, ..., 4}
181 
182     See Also
183     ========
184 
185     Naturals0 : non-negative integers
186     Integers : positive and negative integers and zero
187     """
188 
189     is_iterable = True
190     is_empty = False
191     is_finite_set = False
192 
193     def _contains(self, other):
194         if not isinstance(other, Expr):
195             return S.false
196         return other.is_integer
197 
198     def __iter__(self):
199         yield S.Zero
200         i = S.One
201         while True:
202             yield i
203             yield -i
204             i = i + 1
205 
206     @property
207     def _inf(self):
208         return S.NegativeInfinity
209 
210     @property
211     def _sup(self):
212         return S.Infinity
213 
214     @property
215     def _boundary(self):
216         return self
217 
218     def as_relational(self, x):
219         from sympy.functions.elementary.integers import floor
220         return And(Eq(floor(x), x), -oo < x, x < oo)
221 
222     def _eval_is_subset(self, other):
223         return Range(-oo, oo).is_subset(other)
224 
225     def _eval_is_superset(self, other):
226         return Range(-oo, oo).is_superset(other)
227 
228 
229 class Reals(Interval, metaclass=Singleton):
230     """
231     Represents all real numbers
232     from negative infinity to positive infinity,
233     including all integer, rational and irrational numbers.
234     This set is also available as the Singleton, S.Reals.
235 
236 
237     Examples
238     ========
239 
240     >>> from sympy import S, Rational, pi, I
241     >>> 5 in S.Reals
242     True
243     >>> Rational(-1, 2) in S.Reals
244     True
245     >>> pi in S.Reals
246     True
247     >>> 3*I in S.Reals
248     False
249     >>> S.Reals.contains(pi)
250     True
251 
252 
253     See Also
254     ========
255 
256     ComplexRegion
257     """
258     @property
259     def start(self):
260         return S.NegativeInfinity
261 
262     @property
263     def end(self):
264         return S.Infinity
265 
266     @property
267     def left_open(self):
268         return True
269 
270     @property
271     def right_open(self):
272         return True
273 
274     def __eq__(self, other):
275         return other == Interval(S.NegativeInfinity, S.Infinity)
276 
277     def __hash__(self):
278         return hash(Interval(S.NegativeInfinity, S.Infinity))
279 
280 
281 class ImageSet(Set):
282     """
283     Image of a set under a mathematical function. The transformation
284     must be given as a Lambda function which has as many arguments
285     as the elements of the set upon which it operates, e.g. 1 argument
286     when acting on the set of integers or 2 arguments when acting on
287     a complex region.
288 
289     This function is not normally called directly, but is called
290     from `imageset`.
291 
292 
293     Examples
294     ========
295 
296     >>> from sympy import Symbol, S, pi, Dummy, Lambda
297     >>> from sympy.sets.sets import FiniteSet, Interval
298     >>> from sympy.sets.fancysets import ImageSet
299 
300     >>> x = Symbol('x')
301     >>> N = S.Naturals
302     >>> squares = ImageSet(Lambda(x, x**2), N) # {x**2 for x in N}
303     >>> 4 in squares
304     True
305     >>> 5 in squares
306     False
307 
308     >>> FiniteSet(0, 1, 2, 3, 4, 5, 6, 7, 9, 10).intersect(squares)
309     FiniteSet(1, 4, 9)
310 
311     >>> square_iterable = iter(squares)
312     >>> for i in range(4):
313     ...     next(square_iterable)
314     1
315     4
316     9
317     16
318 
319     If you want to get value for `x` = 2, 1/2 etc. (Please check whether the
320     `x` value is in `base_set` or not before passing it as args)
321 
322     >>> squares.lamda(2)
323     4
324     >>> squares.lamda(S(1)/2)
325     1/4
326 
327     >>> n = Dummy('n')
328     >>> solutions = ImageSet(Lambda(n, n*pi), S.Integers) # solutions of sin(x) = 0
329     >>> dom = Interval(-1, 1)
330     >>> dom.intersect(solutions)
331     FiniteSet(0)
332 
333     See Also
334     ========
335 
336     sympy.sets.sets.imageset
337     """
338     def __new__(cls, flambda, *sets):
339         if not isinstance(flambda, Lambda):
340             raise ValueError('First argument must be a Lambda')
341 
342         signature = flambda.signature
343 
344         if len(signature) != len(sets):
345             raise ValueError('Incompatible signature')
346 
347         sets = [_sympify(s) for s in sets]
348 
349         if not all(isinstance(s, Set) for s in sets):
350             raise TypeError("Set arguments to ImageSet should of type Set")
351 
352         if not all(cls._check_sig(sg, st) for sg, st in zip(signature, sets)):
353             raise ValueError("Signature %s does not match sets %s" % (signature, sets))
354 
355         if flambda is S.IdentityFunction and len(sets) == 1:
356             return sets[0]
357 
358         if not set(flambda.variables) & flambda.expr.free_symbols:
359             is_empty = fuzzy_or(s.is_empty for s in sets)
360             if is_empty == True:
361                 return S.EmptySet
362             elif is_empty == False:
363                 return FiniteSet(flambda.expr)
364 
365         return Basic.__new__(cls, flambda, *sets)
366 
367     lamda = property(lambda self: self.args[0])
368     base_sets = property(lambda self: self.args[1:])
369 
370     @property
371     def base_set(self):
372         # XXX: Maybe deprecate this? It is poorly defined in handling
373         # the multivariate case...
374         sets = self.base_sets
375         if len(sets) == 1:
376             return sets[0]
377         else:
378             return ProductSet(*sets).flatten()
379 
380     @property
381     def base_pset(self):
382         return ProductSet(*self.base_sets)
383 
384     @classmethod
385     def _check_sig(cls, sig_i, set_i):
386         if sig_i.is_symbol:
387             return True
388         elif isinstance(set_i, ProductSet):
389             sets = set_i.sets
390             if len(sig_i) != len(sets):
391                 return False
392             # Recurse through the signature for nested tuples:
393             return all(cls._check_sig(ts, ps) for ts, ps in zip(sig_i, sets))
394         else:
395             # XXX: Need a better way of checking whether a set is a set of
396             # Tuples or not. For example a FiniteSet can contain Tuples
397             # but so can an ImageSet or a ConditionSet. Others like
398             # Integers, Reals etc can not contain Tuples. We could just
399             # list the possibilities here... Current code for e.g.
400             # _contains probably only works for ProductSet.
401             return True # Give the benefit of the doubt
402 
403     def __iter__(self):
404         already_seen = set()
405         for i in self.base_pset:
406             val = self.lamda(*i)
407             if val in already_seen:
408                 continue
409             else:
410                 already_seen.add(val)
411                 yield val
412 
413     def _is_multivariate(self):
414         return len(self.lamda.variables) > 1
415 
416     def _contains(self, other):
417         from sympy.solvers.solveset import _solveset_multi
418 
419         def get_symsetmap(signature, base_sets):
420             '''Attempt to get a map of symbols to base_sets'''
421             queue = list(zip(signature, base_sets))
422             symsetmap = {}
423             for sig, base_set in queue:
424                 if sig.is_symbol:
425                     symsetmap[sig] = base_set
426                 elif base_set.is_ProductSet:
427                     sets = base_set.sets
428                     if len(sig) != len(sets):
429                         raise ValueError("Incompatible signature")
430                     # Recurse
431                     queue.extend(zip(sig, sets))
432                 else:
433                     # If we get here then we have something like sig = (x, y) and
434                     # base_set = {(1, 2), (3, 4)}. For now we give up.
435                     return None
436 
437             return symsetmap
438 
439         def get_equations(expr, candidate):
440             '''Find the equations relating symbols in expr and candidate.'''
441             queue = [(expr, candidate)]
442             for e, c in queue:
443                 if not isinstance(e, Tuple):
444                     yield Eq(e, c)
445                 elif not isinstance(c, Tuple) or len(e) != len(c):
446                     yield False
447                     return
448                 else:
449                     queue.extend(zip(e, c))
450 
451         # Get the basic objects together:
452         other = _sympify(other)
453         expr = self.lamda.expr
454         sig = self.lamda.signature
455         variables = self.lamda.variables
456         base_sets = self.base_sets
457 
458         # Use dummy symbols for ImageSet parameters so they don't match
459         # anything in other
460         rep = {v: Dummy(v.name) for v in variables}
461         variables = [v.subs(rep) for v in variables]
462         sig = sig.subs(rep)
463         expr = expr.subs(rep)
464 
465         # Map the parts of other to those in the Lambda expr
466         equations = []
467         for eq in get_equations(expr, other):
468             # Unsatisfiable equation?
469             if eq is False:
470                 return False
471             equations.append(eq)
472 
473         # Map the symbols in the signature to the corresponding domains
474         symsetmap = get_symsetmap(sig, base_sets)
475         if symsetmap is None:
476             # Can't factor the base sets to a ProductSet
477             return None
478 
479         # Which of the variables in the Lambda signature need to be solved for?
480         symss = (eq.free_symbols for eq in equations)
481         variables = set(variables) & reduce(set.union, symss, set())
482 
483         # Use internal multivariate solveset
484         variables = tuple(variables)
485         base_sets = [symsetmap[v] for v in variables]
486         solnset = _solveset_multi(equations, variables, base_sets)
487         if solnset is None:
488             return None
489         return fuzzy_not(solnset.is_empty)
490 
491     @property
492     def is_iterable(self):
493         return all(s.is_iterable for s in self.base_sets)
494 
495     def doit(self, **kwargs):
496         from sympy.sets.setexpr import SetExpr
497         f = self.lamda
498         sig = f.signature
499         if len(sig) == 1 and sig[0].is_symbol and isinstance(f.expr, Expr):
500             base_set = self.base_sets[0]
501             return SetExpr(base_set)._eval_func(f).set
502         if all(s.is_FiniteSet for s in self.base_sets):
503             return FiniteSet(*(f(*a) for a in cartes(*self.base_sets)))
504         return self
505 
506 
507 class Range(Set):
508     """
509     Represents a range of integers. Can be called as Range(stop),
510     Range(start, stop), or Range(start, stop, step); when step is
511     not given it defaults to 1.
512 
513     `Range(stop)` is the same as `Range(0, stop, 1)` and the stop value
514     (juse as for Python ranges) is not included in the Range values.
515 
516         >>> from sympy import Range
517         >>> list(Range(3))
518         [0, 1, 2]
519 
520     The step can also be negative:
521 
522         >>> list(Range(10, 0, -2))
523         [10, 8, 6, 4, 2]
524 
525     The stop value is made canonical so equivalent ranges always
526     have the same args:
527 
528         >>> Range(0, 10, 3)
529         Range(0, 12, 3)
530 
531     Infinite ranges are allowed. ``oo`` and ``-oo`` are never included in the
532     set (``Range`` is always a subset of ``Integers``). If the starting point
533     is infinite, then the final value is ``stop - step``. To iterate such a
534     range, it needs to be reversed:
535 
536         >>> from sympy import oo
537         >>> r = Range(-oo, 1)
538         >>> r[-1]
539         0
540         >>> next(iter(r))
541         Traceback (most recent call last):
542         ...
543         TypeError: Cannot iterate over Range with infinite start
544         >>> next(iter(r.reversed))
545         0
546 
547     Although Range is a set (and supports the normal set
548     operations) it maintains the order of the elements and can
549     be used in contexts where `range` would be used.
550 
551         >>> from sympy import Interval
552         >>> Range(0, 10, 2).intersect(Interval(3, 7))
553         Range(4, 8, 2)
554         >>> list(_)
555         [4, 6]
556 
557     Although slicing of a Range will always return a Range -- possibly
558     empty -- an empty set will be returned from any intersection that
559     is empty:
560 
561         >>> Range(3)[:0]
562         Range(0, 0, 1)
563         >>> Range(3).intersect(Interval(4, oo))
564         EmptySet
565         >>> Range(3).intersect(Range(4, oo))
566         EmptySet
567 
568     Range will accept symbolic arguments but has very limited support
569     for doing anything other than displaying the Range:
570 
571         >>> from sympy import Symbol, pprint
572         >>> from sympy.abc import i, j, k
573         >>> Range(i, j, k).start
574         i
575         >>> Range(i, j, k).inf
576         Traceback (most recent call last):
577         ...
578         ValueError: invalid method for symbolic range
579 
580     Better success will be had when using integer symbols:
581 
582         >>> n = Symbol('n', integer=True)
583         >>> r = Range(n, n + 20, 3)
584         >>> r.inf
585         n
586         >>> pprint(r)
587         {n, n + 3, ..., n + 18}
588     """
589 
590     is_iterable = True
591 
592     def __new__(cls, *args):
593         from sympy.functions.elementary.integers import ceiling
594         if len(args) == 1:
595             if isinstance(args[0], range):
596                 raise TypeError(
597                     'use sympify(%s) to convert range to Range' % args[0])
598 
599         # expand range
600         slc = slice(*args)
601 
602         if slc.step == 0:
603             raise ValueError("step cannot be 0")
604 
605         start, stop, step = slc.start or 0, slc.stop, slc.step or 1
606         try:
607             ok = []
608             for w in (start, stop, step):
609                 w = sympify(w)
610                 if w in [S.NegativeInfinity, S.Infinity] or (
611                         w.has(Symbol) and w.is_integer != False):
612                     ok.append(w)
613                 elif not w.is_Integer:
614                     if w.is_infinite:
615                         raise ValueError('infinite symbols not allowed')
616                     raise ValueError
617                 else:
618                     ok.append(w)
619         except ValueError:
620             raise ValueError(filldedent('''
621     Finite arguments to Range must be integers; `imageset` can define
622     other cases, e.g. use `imageset(i, i/10, Range(3))` to give
623     [0, 1/10, 1/5].'''))
624         start, stop, step = ok
625 
626         null = False
627         if any(i.has(Symbol) for i in (start, stop, step)):
628             dif = stop - start
629             n = dif/step
630             if n.is_Rational:
631                 from sympy import floor
632                 if dif == 0:
633                     null = True
634                 else:  # (x, x + 5, 2) or (x, 3*x, x)
635                     n = floor(n)
636                     end = start + n*step
637                     if dif.is_Rational:  # (x, x + 5, 2)
638                         if (end - stop).is_negative:
639                             end += step
640                     else:  # (x, 3*x, x)
641                         if (end/stop - 1).is_negative:
642                             end += step
643             elif n.is_extended_negative:
644                 null = True
645             else:
646                 end = stop  # other methods like sup and reversed must fail
647         elif start.is_infinite:
648             span = step*(stop - start)
649             if span is S.NaN or span <= 0:
650                 null = True
651             elif step.is_Integer and stop.is_infinite and abs(step) != 1:
652                 raise ValueError(filldedent('''
653                     Step size must be %s in this case.''' % (1 if step > 0 else -1)))
654             else:
655                 end = stop
656         else:
657             oostep = step.is_infinite
658             if oostep:
659                 step = S.One if step > 0 else S.NegativeOne
660             n = ceiling((stop - start)/step)
661             if n <= 0:
662                 null = True
663             elif oostep:
664                 step = S.One  # make it canonical
665                 end = start + step
666             else:
667                 end = start + n*step
668         if null:
669             start = end = S.Zero
670             step = S.One
671         return Basic.__new__(cls, start, end, step)
672 
673     start = property(lambda self: self.args[0])
674     stop = property(lambda self: self.args[1])
675     step = property(lambda self: self.args[2])
676 
677     @property
678     def reversed(self):
679         """Return an equivalent Range in the opposite order.
680 
681         Examples
682         ========
683 
684         >>> from sympy import Range
685         >>> Range(10).reversed
686         Range(9, -1, -1)
687         """
688         if self.has(Symbol):
689             n = (self.stop - self.start)/self.step
690             if not n.is_extended_positive or not all(
691                     i.is_integer or i.is_infinite for i in self.args):
692                 raise ValueError('invalid method for symbolic range')
693         if self.start == self.stop:
694             return self
695         return self.func(
696             self.stop - self.step, self.start - self.step, -self.step)
697 
698     def _contains(self, other):
699         if self.start == self.stop:
700             return S.false
701         if other.is_infinite:
702             return S.false
703         if not other.is_integer:
704             return other.is_integer
705         if self.has(Symbol):
706             n = (self.stop - self.start)/self.step
707             if not n.is_extended_positive or not all(
708                     i.is_integer or i.is_infinite for i in self.args):
709                 return
710         else:
711             n = self.size
712         if self.start.is_finite:
713             ref = self.start
714         elif self.stop.is_finite:
715             ref = self.stop
716         else:  # both infinite; step is +/- 1 (enforced by __new__)
717             return S.true
718         if n == 1:
719             return Eq(other, self[0])
720         res = (ref - other) % self.step
721         if res == S.Zero:
722             if self.has(Symbol):
723                 d = Dummy('i')
724                 return self.as_relational(d).subs(d, other)
725             return And(other >= self.inf, other <= self.sup)
726         elif res.is_Integer:  # off sequence
727             return S.false
728         else:  # symbolic/unsimplified residue modulo step
729             return None
730 
731     def __iter__(self):
732         n = self.size  # validate
733         if self.start in [S.NegativeInfinity, S.Infinity]:
734             raise TypeError("Cannot iterate over Range with infinite start")
735         elif self.start != self.stop:
736             i = self.start
737             if n.is_infinite:
738                 while True:
739                     yield i
740                     i += self.step
741             else:
742                 for j in range(n):
743                     yield i
744                     i += self.step
745 
746     def __len__(self):
747         rv = self.size
748         if rv is S.Infinity:
749             raise ValueError('Use .size to get the length of an infinite Range')
750         return int(rv)
751 
752     @property
753     def size(self):
754         if self.start == self.stop:
755             return S.Zero
756         dif = self.stop - self.start
757         n = dif/self.step
758         if n.is_infinite:
759             return S.Infinity
760         if not n.is_Integer or not all(i.is_integer for i in self.args):
761             raise ValueError('invalid method for symbolic range')
762         return abs(n)
763 
764     @property
765     def is_finite_set(self):
766         if self.start.is_integer and self.stop.is_integer:
767             return True
768         return self.size.is_finite
769 
770     def __bool__(self):
771         # this only distinguishes between definite null range
772         # and non-null/unknown null; getting True doesn't mean
773         # that it actually is not null
774         b = is_eq(self.start, self.stop)
775         if b is None:
776             raise ValueError('cannot tell if Range is null or not')
777         return not bool(b)
778 
779     def __getitem__(self, i):
780         from sympy.functions.elementary.integers import ceiling
781         ooslice = "cannot slice from the end with an infinite value"
782         zerostep = "slice step cannot be zero"
783         infinite = "slicing not possible on range with infinite start"
784         # if we had to take every other element in the following
785         # oo, ..., 6, 4, 2, 0
786         # we might get oo, ..., 4, 0 or oo, ..., 6, 2
787         ambiguous = "cannot unambiguously re-stride from the end " + \
788             "with an infinite value"
789         if isinstance(i, slice):
790             if self.size.is_finite:  # validates, too
791                 if self.start == self.stop:
792                     return Range(0)
793                 start, stop, step = i.indices(self.size)
794                 n = ceiling((stop - start)/step)
795                 if n <= 0:
796                     return Range(0)
797                 canonical_stop = start + n*step
798                 end = canonical_stop - step
799                 ss = step*self.step
800                 return Range(self[start], self[end] + ss, ss)
801             else:  # infinite Range
802                 start = i.start
803                 stop = i.stop
804                 if i.step == 0:
805                     raise ValueError(zerostep)
806                 step = i.step or 1
807                 ss = step*self.step
808                 #---------------------
809                 # handle infinite Range
810                 #   i.e. Range(-oo, oo) or Range(oo, -oo, -1)
811                 # --------------------
812                 if self.start.is_infinite and self.stop.is_infinite:
813                     raise ValueError(infinite)
814                 #---------------------
815                 # handle infinite on right
816                 #   e.g. Range(0, oo) or Range(0, -oo, -1)
817                 # --------------------
818                 if self.stop.is_infinite:
819                     # start and stop are not interdependent --
820                     # they only depend on step --so we use the
821                     # equivalent reversed values
822                     return self.reversed[
823                         stop if stop is None else -stop + 1:
824                         start if start is None else -start:
825                         step].reversed
826                 #---------------------
827                 # handle infinite on the left
828                 #   e.g. Range(oo, 0, -1) or Range(-oo, 0)
829                 # --------------------
830                 # consider combinations of
831                 # start/stop {== None, < 0, == 0, > 0} and
832                 # step {< 0, > 0}
833                 if start is None:
834                     if stop is None:
835                         if step < 0:
836                             return Range(self[-1], self.start, ss)
837                         elif step > 1:
838                             raise ValueError(ambiguous)
839                         else:  # == 1
840                             return self
841                     elif stop < 0:
842                         if step < 0:
843                             return Range(self[-1], self[stop], ss)
844                         else:  # > 0
845                             return Range(self.start, self[stop], ss)
846                     elif stop == 0:
847                         if step > 0:
848                             return Range(0)
849                         else:  # < 0
850                             raise ValueError(ooslice)
851                     elif stop == 1:
852                         if step > 0:
853                             raise ValueError(ooslice)  # infinite singleton
854                         else:  # < 0
855                             raise ValueError(ooslice)
856                     else:  # > 1
857                         raise ValueError(ooslice)
858                 elif start < 0:
859                     if stop is None:
860                         if step < 0:
861                             return Range(self[start], self.start, ss)
862                         else:  # > 0
863                             return Range(self[start], self.stop, ss)
864                     elif stop < 0:
865                         return Range(self[start], self[stop], ss)
866                     elif stop == 0:
867                         if step < 0:
868                             raise ValueError(ooslice)
869                         else:  # > 0
870                             return Range(0)
871                     elif stop > 0:
872                         raise ValueError(ooslice)
873                 elif start == 0:
874                     if stop is None:
875                         if step < 0:
876                             raise ValueError(ooslice)  # infinite singleton
877                         elif step > 1:
878                             raise ValueError(ambiguous)
879                         else:  # == 1
880                             return self
881                     elif stop < 0:
882                         if step > 1:
883                             raise ValueError(ambiguous)
884                         elif step == 1:
885                             return Range(self.start, self[stop], ss)
886                         else:  # < 0
887                             return Range(0)
888                     else:  # >= 0
889                         raise ValueError(ooslice)
890                 elif start > 0:
891                     raise ValueError(ooslice)
892         else:
893             if self.start == self.stop:
894                 raise IndexError('Range index out of range')
895             if not (all(i.is_integer or i.is_infinite
896                     for i in self.args) and ((self.stop - self.start)/
897                     self.step).is_extended_positive):
898                 raise ValueError('invalid method for symbolic range')
899             if i == 0:
900                 if self.start.is_infinite:
901                     raise ValueError(ooslice)
902                 return self.start
903             if i == -1:
904                 if self.stop.is_infinite:
905                     raise ValueError(ooslice)
906                 return self.stop - self.step
907             n = self.size  # must be known for any other index
908             rv = (self.stop if i < 0 else self.start) + i*self.step
909             if rv.is_infinite:
910                 raise ValueError(ooslice)
911             if 0 <= (rv - self.start)/self.step <= n:
912                 return rv
913             raise IndexError("Range index out of range")
914 
915     @property
916     def _inf(self):
917         if not self:
918             return S.EmptySet.inf
919         if self.has(Symbol):
920             if all(i.is_integer or i.is_infinite for i in self.args):
921                 dif = self.stop - self.start
922                 if self.step.is_positive and dif.is_positive:
923                     return self.start
924                 elif self.step.is_negative and dif.is_negative:
925                     return self.stop - self.step
926             raise ValueError('invalid method for symbolic range')
927         if self.step > 0:
928             return self.start
929         else:
930             return self.stop - self.step
931 
932     @property
933     def _sup(self):
934         if not self:
935             return S.EmptySet.sup
936         if self.has(Symbol):
937             if all(i.is_integer or i.is_infinite for i in self.args):
938                 dif = self.stop - self.start
939                 if self.step.is_positive and dif.is_positive:
940                     return self.stop - self.step
941                 elif self.step.is_negative and dif.is_negative:
942                     return self.start
943             raise ValueError('invalid method for symbolic range')
944         if self.step > 0:
945             return self.stop - self.step
946         else:
947             return self.start
948 
949     @property
950     def _boundary(self):
951         return self
952 
953     def as_relational(self, x):
954         """Rewrite a Range in terms of equalities and logic operators. """
955         from sympy.core.mod import Mod
956         if self.start.is_infinite:
957             assert not self.stop.is_infinite  # by instantiation
958             a = self.reversed.start
959         else:
960             a = self.start
961         step = self.step
962         in_seq = Eq(Mod(x - a, step), 0)
963         ints = And(Eq(Mod(a, 1), 0), Eq(Mod(step, 1), 0))
964         n = (self.stop - self.start)/self.step
965         if n == 0:
966             return S.EmptySet.as_relational(x)
967         if n == 1:
968             return And(Eq(x, a), ints)
969         try:
970             a, b = self.inf, self.sup
971         except ValueError:
972             a = None
973         if a is not None:
974             range_cond = And(
975                 x > a if a.is_infinite else x >= a,
976                 x < b if b.is_infinite else x <= b)
977         else:
978             a, b = self.start, self.stop - self.step
979             range_cond = Or(
980                 And(self.step >= 1, x > a if a.is_infinite else x >= a,
981                 x < b if b.is_infinite else x <= b),
982                 And(self.step <= -1, x < a if a.is_infinite else x <= a,
983                 x > b if b.is_infinite else x >= b))
984         return And(in_seq, ints, range_cond)
985 
986 
987 converter[range] = lambda r: Range(r.start, r.stop, r.step)
988 
989 def normalize_theta_set(theta):
990     """
991     Normalize a Real Set `theta` in the Interval [0, 2*pi). It returns
992     a normalized value of theta in the Set. For Interval, a maximum of
993     one cycle [0, 2*pi], is returned i.e. for theta equal to [0, 10*pi],
994     returned normalized value would be [0, 2*pi). As of now intervals
995     with end points as non-multiples of `pi` is not supported.
996 
997     Raises
998     ======
999 
1000     NotImplementedError
1001         The algorithms for Normalizing theta Set are not yet
1002         implemented.
1003     ValueError
1004         The input is not valid, i.e. the input is not a real set.
1005     RuntimeError
1006         It is a bug, please report to the github issue tracker.
1007 
1008     Examples
1009     ========
1010 
1011     >>> from sympy.sets.fancysets import normalize_theta_set
1012     >>> from sympy import Interval, FiniteSet, pi
1013     >>> normalize_theta_set(Interval(9*pi/2, 5*pi))
1014     Interval(pi/2, pi)
1015     >>> normalize_theta_set(Interval(-3*pi/2, pi/2))
1016     Interval.Ropen(0, 2*pi)
1017     >>> normalize_theta_set(Interval(-pi/2, pi/2))
1018     Union(Interval(0, pi/2), Interval.Ropen(3*pi/2, 2*pi))
1019     >>> normalize_theta_set(Interval(-4*pi, 3*pi))
1020     Interval.Ropen(0, 2*pi)
1021     >>> normalize_theta_set(Interval(-3*pi/2, -pi/2))
1022     Interval(pi/2, 3*pi/2)
1023     >>> normalize_theta_set(FiniteSet(0, pi, 3*pi))
1024     FiniteSet(0, pi)
1025 
1026     """
1027     from sympy.functions.elementary.trigonometric import _pi_coeff as coeff
1028 
1029     if theta.is_Interval:
1030         interval_len = theta.measure
1031         # one complete circle
1032         if interval_len >= 2*S.Pi:
1033             if interval_len == 2*S.Pi and theta.left_open and theta.right_open:
1034                 k = coeff(theta.start)
1035                 return Union(Interval(0, k*S.Pi, False, True),
1036                         Interval(k*S.Pi, 2*S.Pi, True, True))
1037             return Interval(0, 2*S.Pi, False, True)
1038 
1039         k_start, k_end = coeff(theta.start), coeff(theta.end)
1040 
1041         if k_start is None or k_end is None:
1042             raise NotImplementedError("Normalizing theta without pi as coefficient is "
1043                                     "not yet implemented")
1044         new_start = k_start*S.Pi
1045         new_end = k_end*S.Pi
1046 
1047         if new_start > new_end:
1048             return Union(Interval(S.Zero, new_end, False, theta.right_open),
1049                          Interval(new_start, 2*S.Pi, theta.left_open, True))
1050         else:
1051             return Interval(new_start, new_end, theta.left_open, theta.right_open)
1052 
1053     elif theta.is_FiniteSet:
1054         new_theta = []
1055         for element in theta:
1056             k = coeff(element)
1057             if k is None:
1058                 raise NotImplementedError('Normalizing theta without pi as '
1059                                           'coefficient, is not Implemented.')
1060             else:
1061                 new_theta.append(k*S.Pi)
1062         return FiniteSet(*new_theta)
1063 
1064     elif theta.is_Union:
1065         return Union(*[normalize_theta_set(interval) for interval in theta.args])
1066 
1067     elif theta.is_subset(S.Reals):
1068         raise NotImplementedError("Normalizing theta when, it is of type %s is not "
1069                                   "implemented" % type(theta))
1070     else:
1071         raise ValueError(" %s is not a real set" % (theta))
1072 
1073 
1074 class ComplexRegion(Set):
1075     """
1076     Represents the Set of all Complex Numbers. It can represent a
1077     region of Complex Plane in both the standard forms Polar and
1078     Rectangular coordinates.
1079 
1080     * Polar Form
1081       Input is in the form of the ProductSet or Union of ProductSets
1082       of the intervals of r and theta, & use the flag polar=True.
1083 
1084     Z = {z in C | z = r*[cos(theta) + I*sin(theta)], r in [r], theta in [theta]}
1085 
1086     * Rectangular Form
1087       Input is in the form of the ProductSet or Union of ProductSets
1088       of interval of x and y the of the Complex numbers in a Plane.
1089       Default input type is in rectangular form.
1090 
1091     Z = {z in C | z = x + I*y, x in [Re(z)], y in [Im(z)]}
1092 
1093     Examples
1094     ========
1095 
1096     >>> from sympy.sets.fancysets import ComplexRegion
1097     >>> from sympy.sets import Interval
1098     >>> from sympy import S, I, Union
1099     >>> a = Interval(2, 3)
1100     >>> b = Interval(4, 6)
1101     >>> c = Interval(1, 8)
1102     >>> c1 = ComplexRegion(a*b)  # Rectangular Form
1103     >>> c1
1104     CartesianComplexRegion(ProductSet(Interval(2, 3), Interval(4, 6)))
1105 
1106     * c1 represents the rectangular region in complex plane
1107       surrounded by the coordinates (2, 4), (3, 4), (3, 6) and
1108       (2, 6), of the four vertices.
1109 
1110     >>> c2 = ComplexRegion(Union(a*b, b*c))
1111     >>> c2
1112     CartesianComplexRegion(Union(ProductSet(Interval(2, 3), Interval(4, 6)), ProductSet(Interval(4, 6), Interval(1, 8))))
1113 
1114     * c2 represents the Union of two rectangular regions in complex
1115       plane. One of them surrounded by the coordinates of c1 and
1116       other surrounded by the coordinates (4, 1), (6, 1), (6, 8) and
1117       (4, 8).
1118 
1119     >>> 2.5 + 4.5*I in c1
1120     True
1121     >>> 2.5 + 6.5*I in c1
1122     False
1123 
1124     >>> r = Interval(0, 1)
1125     >>> theta = Interval(0, 2*S.Pi)
1126     >>> c2 = ComplexRegion(r*theta, polar=True)  # Polar Form
1127     >>> c2  # unit Disk
1128     PolarComplexRegion(ProductSet(Interval(0, 1), Interval.Ropen(0, 2*pi)))
1129 
1130     * c2 represents the region in complex plane inside the
1131       Unit Disk centered at the origin.
1132 
1133     >>> 0.5 + 0.5*I in c2
1134     True
1135     >>> 1 + 2*I in c2
1136     False
1137 
1138     >>> unit_disk = ComplexRegion(Interval(0, 1)*Interval(0, 2*S.Pi), polar=True)
1139     >>> upper_half_unit_disk = ComplexRegion(Interval(0, 1)*Interval(0, S.Pi), polar=True)
1140     >>> intersection = unit_disk.intersect(upper_half_unit_disk)
1141     >>> intersection
1142     PolarComplexRegion(ProductSet(Interval(0, 1), Interval(0, pi)))
1143     >>> intersection == upper_half_unit_disk
1144     True
1145 
1146     See Also
1147     ========
1148 
1149     CartesianComplexRegion
1150     PolarComplexRegion
1151     Complexes
1152 
1153     """
1154     is_ComplexRegion = True
1155 
1156     def __new__(cls, sets, polar=False):
1157         if polar is False:
1158             return CartesianComplexRegion(sets)
1159         elif polar is True:
1160             return PolarComplexRegion(sets)
1161         else:
1162             raise ValueError("polar should be either True or False")
1163 
1164     @property
1165     def sets(self):
1166         """
1167         Return raw input sets to the self.
1168 
1169         Examples
1170         ========
1171 
1172         >>> from sympy import Interval, ComplexRegion, Union
1173         >>> a = Interval(2, 3)
1174         >>> b = Interval(4, 5)
1175         >>> c = Interval(1, 7)
1176         >>> C1 = ComplexRegion(a*b)
1177         >>> C1.sets
1178         ProductSet(Interval(2, 3), Interval(4, 5))
1179         >>> C2 = ComplexRegion(Union(a*b, b*c))
1180         >>> C2.sets
1181         Union(ProductSet(Interval(2, 3), Interval(4, 5)), ProductSet(Interval(4, 5), Interval(1, 7)))
1182 
1183         """
1184         return self.args[0]
1185 
1186     @property
1187     def psets(self):
1188         """
1189         Return a tuple of sets (ProductSets) input of the self.
1190 
1191         Examples
1192         ========
1193 
1194         >>> from sympy import Interval, ComplexRegion, Union
1195         >>> a = Interval(2, 3)
1196         >>> b = Interval(4, 5)
1197         >>> c = Interval(1, 7)
1198         >>> C1 = ComplexRegion(a*b)
1199         >>> C1.psets
1200         (ProductSet(Interval(2, 3), Interval(4, 5)),)
1201         >>> C2 = ComplexRegion(Union(a*b, b*c))
1202         >>> C2.psets
1203         (ProductSet(Interval(2, 3), Interval(4, 5)), ProductSet(Interval(4, 5), Interval(1, 7)))
1204 
1205         """
1206         if self.sets.is_ProductSet:
1207             psets = ()
1208             psets = psets + (self.sets, )
1209         else:
1210             psets = self.sets.args
1211         return psets
1212 
1213     @property
1214     def a_interval(self):
1215         """
1216         Return the union of intervals of `x` when, self is in
1217         rectangular form, or the union of intervals of `r` when
1218         self is in polar form.
1219 
1220         Examples
1221         ========
1222 
1223         >>> from sympy import Interval, ComplexRegion, Union
1224         >>> a = Interval(2, 3)
1225         >>> b = Interval(4, 5)
1226         >>> c = Interval(1, 7)
1227         >>> C1 = ComplexRegion(a*b)
1228         >>> C1.a_interval
1229         Interval(2, 3)
1230         >>> C2 = ComplexRegion(Union(a*b, b*c))
1231         >>> C2.a_interval
1232         Union(Interval(2, 3), Interval(4, 5))
1233 
1234         """
1235         a_interval = []
1236         for element in self.psets:
1237             a_interval.append(element.args[0])
1238 
1239         a_interval = Union(*a_interval)
1240         return a_interval
1241 
1242     @property
1243     def b_interval(self):
1244         """
1245         Return the union of intervals of `y` when, self is in
1246         rectangular form, or the union of intervals of `theta`
1247         when self is in polar form.
1248 
1249         Examples
1250         ========
1251 
1252         >>> from sympy import Interval, ComplexRegion, Union
1253         >>> a = Interval(2, 3)
1254         >>> b = Interval(4, 5)
1255         >>> c = Interval(1, 7)
1256         >>> C1 = ComplexRegion(a*b)
1257         >>> C1.b_interval
1258         Interval(4, 5)
1259         >>> C2 = ComplexRegion(Union(a*b, b*c))
1260         >>> C2.b_interval
1261         Interval(1, 7)
1262 
1263         """
1264         b_interval = []
1265         for element in self.psets:
1266             b_interval.append(element.args[1])
1267 
1268         b_interval = Union(*b_interval)
1269         return b_interval
1270 
1271     @property
1272     def _measure(self):
1273         """
1274         The measure of self.sets.
1275 
1276         Examples
1277         ========
1278 
1279         >>> from sympy import Interval, ComplexRegion, S
1280         >>> a, b = Interval(2, 5), Interval(4, 8)
1281         >>> c = Interval(0, 2*S.Pi)
1282         >>> c1 = ComplexRegion(a*b)
1283         >>> c1.measure
1284         12
1285         >>> c2 = ComplexRegion(a*c, polar=True)
1286         >>> c2.measure
1287         6*pi
1288 
1289         """
1290         return self.sets._measure
1291 
1292     @classmethod
1293     def from_real(cls, sets):
1294         """
1295         Converts given subset of real numbers to a complex region.
1296 
1297         Examples
1298         ========
1299 
1300         >>> from sympy import Interval, ComplexRegion
1301         >>> unit = Interval(0,1)
1302         >>> ComplexRegion.from_real(unit)
1303         CartesianComplexRegion(ProductSet(Interval(0, 1), FiniteSet(0)))
1304 
1305         """
1306         if not sets.is_subset(S.Reals):
1307             raise ValueError("sets must be a subset of the real line")
1308 
1309         return CartesianComplexRegion(sets * FiniteSet(0))
1310 
1311     def _contains(self, other):
1312         from sympy.functions import arg, Abs
1313         from sympy.core.containers import Tuple
1314         other = sympify(other)
1315         isTuple = isinstance(other, Tuple)
1316         if isTuple and len(other) != 2:
1317             raise ValueError('expecting Tuple of length 2')
1318 
1319         # If the other is not an Expression, and neither a Tuple
1320         if not isinstance(other, Expr) and not isinstance(other, Tuple):
1321             return S.false
1322         # self in rectangular form
1323         if not self.polar:
1324             re, im = other if isTuple else other.as_real_imag()
1325             return fuzzy_or(fuzzy_and([
1326                 pset.args[0]._contains(re),
1327                 pset.args[1]._contains(im)])
1328                 for pset in self.psets)
1329 
1330         # self in polar form
1331         elif self.polar:
1332             if other.is_zero:
1333                 # ignore undefined complex argument
1334                 return fuzzy_or(pset.args[0]._contains(S.Zero)
1335                     for pset in self.psets)
1336             if isTuple:
1337                 r, theta = other
1338             else:
1339                 r, theta = Abs(other), arg(other)
1340             if theta.is_real and theta.is_number:
1341                 # angles in psets are normalized to [0, 2pi)
1342                 theta %= 2*S.Pi
1343                 return fuzzy_or(fuzzy_and([
1344                     pset.args[0]._contains(r),
1345                     pset.args[1]._contains(theta)])
1346                     for pset in self.psets)
1347 
1348 
1349 class CartesianComplexRegion(ComplexRegion):
1350     """
1351     Set representing a square region of the complex plane.
1352 
1353     Z = {z in C | z = x + I*y, x in [Re(z)], y in [Im(z)]}
1354 
1355     Examples
1356     ========
1357 
1358     >>> from sympy.sets.fancysets import ComplexRegion
1359     >>> from sympy.sets.sets import Interval
1360     >>> from sympy import I
1361     >>> region = ComplexRegion(Interval(1, 3) * Interval(4, 6))
1362     >>> 2 + 5*I in region
1363     True
1364     >>> 5*I in region
1365     False
1366 
1367     See also
1368     ========
1369 
1370     ComplexRegion
1371     PolarComplexRegion
1372     Complexes
1373     """
1374 
1375     polar = False
1376     variables = symbols('x, y', cls=Dummy)
1377 
1378     def __new__(cls, sets):
1379 
1380         if sets == S.Reals*S.Reals:
1381             return S.Complexes
1382 
1383         if all(_a.is_FiniteSet for _a in sets.args) and (len(sets.args) == 2):
1384 
1385             # ** ProductSet of FiniteSets in the Complex Plane. **
1386             # For Cases like ComplexRegion({2, 4}*{3}), It
1387             # would return {2 + 3*I, 4 + 3*I}
1388 
1389             # FIXME: This should probably be handled with something like:
1390             # return ImageSet(Lambda((x, y), x+I*y), sets).rewrite(FiniteSet)
1391             complex_num = []
1392             for x in sets.args[0]:
1393                 for y in sets.args[1]:
1394                     complex_num.append(x + S.ImaginaryUnit*y)
1395             return FiniteSet(*complex_num)
1396         else:
1397             return Set.__new__(cls, sets)
1398 
1399     @property
1400     def expr(self):
1401         x, y = self.variables
1402         return x + S.ImaginaryUnit*y
1403 
1404 
1405 class PolarComplexRegion(ComplexRegion):
1406     """
1407     Set representing a polar region of the complex plane.
1408 
1409     Z = {z in C | z = r*[cos(theta) + I*sin(theta)], r in [r], theta in [theta]}
1410 
1411     Examples
1412     ========
1413 
1414     >>> from sympy.sets.fancysets import ComplexRegion, Interval
1415     >>> from sympy import oo, pi, I
1416     >>> rset = Interval(0, oo)
1417     >>> thetaset = Interval(0, pi)
1418     >>> upper_half_plane = ComplexRegion(rset * thetaset, polar=True)
1419     >>> 1 + I in upper_half_plane
1420     True
1421     >>> 1 - I in upper_half_plane
1422     False
1423 
1424     See also
1425     ========
1426 
1427     ComplexRegion
1428     CartesianComplexRegion
1429     Complexes
1430 
1431     """
1432 
1433     polar = True
1434     variables = symbols('r, theta', cls=Dummy)
1435 
1436     def __new__(cls, sets):
1437 
1438         new_sets = []
1439         # sets is Union of ProductSets
1440         if not sets.is_ProductSet:
1441             for k in sets.args:
1442                 new_sets.append(k)
1443         # sets is ProductSets
1444         else:
1445             new_sets.append(sets)
1446         # Normalize input theta
1447         for k, v in enumerate(new_sets):
1448             new_sets[k] = ProductSet(v.args[0],
1449                                      normalize_theta_set(v.args[1]))
1450         sets = Union(*new_sets)
1451         return Set.__new__(cls, sets)
1452 
1453     @property
1454     def expr(self):
1455         from sympy.functions.elementary.trigonometric import sin, cos
1456         r, theta = self.variables
1457         return r*(cos(theta) + S.ImaginaryUnit*sin(theta))
1458 
1459 
1460 class Complexes(CartesianComplexRegion, metaclass=Singleton):
1461     """
1462     The Set of all complex numbers
1463 
1464     Examples
1465     ========
1466 
1467     >>> from sympy import S, I
1468     >>> S.Complexes
1469     Complexes
1470     >>> 1 + I in S.Complexes
1471     True
1472 
1473     See also
1474     ========
1475 
1476     Reals
1477     ComplexRegion
1478 
1479     """
1480 
1481     is_empty = False
1482     is_finite_set = False
1483 
1484     # Override property from superclass since Complexes has no args
1485     @property
1486     def sets(self):
1487         return ProductSet(S.Reals, S.Reals)
1488 
1489     def __new__(cls):
1490         return Set.__new__(cls)
1491 
1492     def __str__(self):
1493         return "S.Complexes"
1494 
1495     def __repr__(self):
1496         return "S.Complexes"

</code><intended_behavior>This method should ensure that intersections between an ImageSet producing complex numbers and Reals are accurately calculated, excluding any non-real numbers from the results. This may require implementing a check within the intersection logic to explicitly determine if a given element from an ImageSet is real before including it in the result set when intersecting with Reals. Enhancing the logic to understand and simplify complex expressions better, to accurately determine their real-number status in an intersection scenario.</intended_behavior>]
2025-10-18 09:24:45.844 | INFO     | Search completed. Bug locations: [<file>sympy/sets/fancysets.py</file>
<class>None</class>
<method>None</method>
<code>
1 from functools import reduce
2 
3 from sympy.core.basic import Basic
4 from sympy.core.containers import Tuple
5 from sympy.core.expr import Expr
6 from sympy.core.function import Lambda
7 from sympy.core.logic import fuzzy_not, fuzzy_or, fuzzy_and
8 from sympy.core.numbers import oo
9 from sympy.core.relational import Eq, is_eq
10 from sympy.core.singleton import Singleton, S
11 from sympy.core.symbol import Dummy, symbols, Symbol
12 from sympy.core.sympify import _sympify, sympify, converter
13 from sympy.logic.boolalg import And, Or
14 from sympy.sets.sets import (Set, Interval, Union, FiniteSet,
15     ProductSet)
16 from sympy.utilities.misc import filldedent
17 from sympy.utilities.iterables import cartes
18 
19 
20 class Rationals(Set, metaclass=Singleton):
21     """
22     Represents the rational numbers. This set is also available as
23     the Singleton, S.Rationals.
24 
25     Examples
26     ========
27 
28     >>> from sympy import S
29     >>> S.Half in S.Rationals
30     True
31     >>> iterable = iter(S.Rationals)
32     >>> [next(iterable) for i in range(12)]
33     [0, 1, -1, 1/2, 2, -1/2, -2, 1/3, 3, -1/3, -3, 2/3]
34     """
35 
36     is_iterable = True
37     _inf = S.NegativeInfinity
38     _sup = S.Infinity
39     is_empty = False
40     is_finite_set = False
41 
42     def _contains(self, other):
43         if not isinstance(other, Expr):
44             return False
45         return other.is_rational
46 
47     def __iter__(self):
48         from sympy.core.numbers import igcd, Rational
49         yield S.Zero
50         yield S.One
51         yield S.NegativeOne
52         d = 2
53         while True:
54             for n in range(d):
55                 if igcd(n, d) == 1:
56                     yield Rational(n, d)
57                     yield Rational(d, n)
58                     yield Rational(-n, d)
59                     yield Rational(-d, n)
60             d += 1
61 
62     @property
63     def _boundary(self):
64         return S.Reals
65 
66 
67 class Naturals(Set, metaclass=Singleton):
68     """
69     Represents the natural numbers (or counting numbers) which are all
70     positive integers starting from 1. This set is also available as
71     the Singleton, S.Naturals.
72 
73     Examples
74     ========
75 
76     >>> from sympy import S, Interval, pprint
77     >>> 5 in S.Naturals
78     True
79     >>> iterable = iter(S.Naturals)
80     >>> next(iterable)
81     1
82     >>> next(iterable)
83     2
84     >>> next(iterable)
85     3
86     >>> pprint(S.Naturals.intersect(Interval(0, 10)))
87     {1, 2, ..., 10}
88 
89     See Also
90     ========
91 
92     Naturals0 : non-negative integers (i.e. includes 0, too)
93     Integers : also includes negative integers
94     """
95 
96     is_iterable = True
97     _inf = S.One
98     _sup = S.Infinity
99     is_empty = False
100     is_finite_set = False
101 
102     def _contains(self, other):
103         if not isinstance(other, Expr):
104             return False
105         elif other.is_positive and other.is_integer:
106             return True
107         elif other.is_integer is False or other.is_positive is False:
108             return False
109 
110     def _eval_is_subset(self, other):
111         return Range(1, oo).is_subset(other)
112 
113     def _eval_is_superset(self, other):
114         return Range(1, oo).is_superset(other)
115 
116     def __iter__(self):
117         i = self._inf
118         while True:
119             yield i
120             i = i + 1
121 
122     @property
123     def _boundary(self):
124         return self
125 
126     def as_relational(self, x):
127         from sympy.functions.elementary.integers import floor
128         return And(Eq(floor(x), x), x >= self.inf, x < oo)
129 
130 
131 class Naturals0(Naturals):
132     """Represents the whole numbers which are all the non-negative integers,
133     inclusive of zero.
134 
135     See Also
136     ========
137 
138     Naturals : positive integers; does not include 0
139     Integers : also includes the negative integers
140     """
141     _inf = S.Zero
142 
143     def _contains(self, other):
144         if not isinstance(other, Expr):
145             return S.false
146         elif other.is_integer and other.is_nonnegative:
147             return S.true
148         elif other.is_integer is False or other.is_nonnegative is False:
149             return S.false
150 
151     def _eval_is_subset(self, other):
152         return Range(oo).is_subset(other)
153 
154     def _eval_is_superset(self, other):
155         return Range(oo).is_superset(other)
156 
157 
158 class Integers(Set, metaclass=Singleton):
159     """
160     Represents all integers: positive, negative and zero. This set is also
161     available as the Singleton, S.Integers.
162 
163     Examples
164     ========
165 
166     >>> from sympy import S, Interval, pprint
167     >>> 5 in S.Naturals
168     True
169     >>> iterable = iter(S.Integers)
170     >>> next(iterable)
171     0
172     >>> next(iterable)
173     1
174     >>> next(iterable)
175     -1
176     >>> next(iterable)
177     2
178 
179     >>> pprint(S.Integers.intersect(Interval(-4, 4)))
180     {-4, -3, ..., 4}
181 
182     See Also
183     ========
184 
185     Naturals0 : non-negative integers
186     Integers : positive and negative integers and zero
187     """
188 
189     is_iterable = True
190     is_empty = False
191     is_finite_set = False
192 
193     def _contains(self, other):
194         if not isinstance(other, Expr):
195             return S.false
196         return other.is_integer
197 
198     def __iter__(self):
199         yield S.Zero
200         i = S.One
201         while True:
202             yield i
203             yield -i
204             i = i + 1
205 
206     @property
207     def _inf(self):
208         return S.NegativeInfinity
209 
210     @property
211     def _sup(self):
212         return S.Infinity
213 
214     @property
215     def _boundary(self):
216         return self
217 
218     def as_relational(self, x):
219         from sympy.functions.elementary.integers import floor
220         return And(Eq(floor(x), x), -oo < x, x < oo)
221 
222     def _eval_is_subset(self, other):
223         return Range(-oo, oo).is_subset(other)
224 
225     def _eval_is_superset(self, other):
226         return Range(-oo, oo).is_superset(other)
227 
228 
229 class Reals(Interval, metaclass=Singleton):
230     """
231     Represents all real numbers
232     from negative infinity to positive infinity,
233     including all integer, rational and irrational numbers.
234     This set is also available as the Singleton, S.Reals.
235 
236 
237     Examples
238     ========
239 
240     >>> from sympy import S, Rational, pi, I
241     >>> 5 in S.Reals
242     True
243     >>> Rational(-1, 2) in S.Reals
244     True
245     >>> pi in S.Reals
246     True
247     >>> 3*I in S.Reals
248     False
249     >>> S.Reals.contains(pi)
250     True
251 
252 
253     See Also
254     ========
255 
256     ComplexRegion
257     """
258     @property
259     def start(self):
260         return S.NegativeInfinity
261 
262     @property
263     def end(self):
264         return S.Infinity
265 
266     @property
267     def left_open(self):
268         return True
269 
270     @property
271     def right_open(self):
272         return True
273 
274     def __eq__(self, other):
275         return other == Interval(S.NegativeInfinity, S.Infinity)
276 
277     def __hash__(self):
278         return hash(Interval(S.NegativeInfinity, S.Infinity))
279 
280 
281 class ImageSet(Set):
282     """
283     Image of a set under a mathematical function. The transformation
284     must be given as a Lambda function which has as many arguments
285     as the elements of the set upon which it operates, e.g. 1 argument
286     when acting on the set of integers or 2 arguments when acting on
287     a complex region.
288 
289     This function is not normally called directly, but is called
290     from `imageset`.
291 
292 
293     Examples
294     ========
295 
296     >>> from sympy import Symbol, S, pi, Dummy, Lambda
297     >>> from sympy.sets.sets import FiniteSet, Interval
298     >>> from sympy.sets.fancysets import ImageSet
299 
300     >>> x = Symbol('x')
301     >>> N = S.Naturals
302     >>> squares = ImageSet(Lambda(x, x**2), N) # {x**2 for x in N}
303     >>> 4 in squares
304     True
305     >>> 5 in squares
306     False
307 
308     >>> FiniteSet(0, 1, 2, 3, 4, 5, 6, 7, 9, 10).intersect(squares)
309     FiniteSet(1, 4, 9)
310 
311     >>> square_iterable = iter(squares)
312     >>> for i in range(4):
313     ...     next(square_iterable)
314     1
315     4
316     9
317     16
318 
319     If you want to get value for `x` = 2, 1/2 etc. (Please check whether the
320     `x` value is in `base_set` or not before passing it as args)
321 
322     >>> squares.lamda(2)
323     4
324     >>> squares.lamda(S(1)/2)
325     1/4
326 
327     >>> n = Dummy('n')
328     >>> solutions = ImageSet(Lambda(n, n*pi), S.Integers) # solutions of sin(x) = 0
329     >>> dom = Interval(-1, 1)
330     >>> dom.intersect(solutions)
331     FiniteSet(0)
332 
333     See Also
334     ========
335 
336     sympy.sets.sets.imageset
337     """
338     def __new__(cls, flambda, *sets):
339         if not isinstance(flambda, Lambda):
340             raise ValueError('First argument must be a Lambda')
341 
342         signature = flambda.signature
343 
344         if len(signature) != len(sets):
345             raise ValueError('Incompatible signature')
346 
347         sets = [_sympify(s) for s in sets]
348 
349         if not all(isinstance(s, Set) for s in sets):
350             raise TypeError("Set arguments to ImageSet should of type Set")
351 
352         if not all(cls._check_sig(sg, st) for sg, st in zip(signature, sets)):
353             raise ValueError("Signature %s does not match sets %s" % (signature, sets))
354 
355         if flambda is S.IdentityFunction and len(sets) == 1:
356             return sets[0]
357 
358         if not set(flambda.variables) & flambda.expr.free_symbols:
359             is_empty = fuzzy_or(s.is_empty for s in sets)
360             if is_empty == True:
361                 return S.EmptySet
362             elif is_empty == False:
363                 return FiniteSet(flambda.expr)
364 
365         return Basic.__new__(cls, flambda, *sets)
366 
367     lamda = property(lambda self: self.args[0])
368     base_sets = property(lambda self: self.args[1:])
369 
370     @property
371     def base_set(self):
372         # XXX: Maybe deprecate this? It is poorly defined in handling
373         # the multivariate case...
374         sets = self.base_sets
375         if len(sets) == 1:
376             return sets[0]
377         else:
378             return ProductSet(*sets).flatten()
379 
380     @property
381     def base_pset(self):
382         return ProductSet(*self.base_sets)
383 
384     @classmethod
385     def _check_sig(cls, sig_i, set_i):
386         if sig_i.is_symbol:
387             return True
388         elif isinstance(set_i, ProductSet):
389             sets = set_i.sets
390             if len(sig_i) != len(sets):
391                 return False
392             # Recurse through the signature for nested tuples:
393             return all(cls._check_sig(ts, ps) for ts, ps in zip(sig_i, sets))
394         else:
395             # XXX: Need a better way of checking whether a set is a set of
396             # Tuples or not. For example a FiniteSet can contain Tuples
397             # but so can an ImageSet or a ConditionSet. Others like
398             # Integers, Reals etc can not contain Tuples. We could just
399             # list the possibilities here... Current code for e.g.
400             # _contains probably only works for ProductSet.
401             return True # Give the benefit of the doubt
402 
403     def __iter__(self):
404         already_seen = set()
405         for i in self.base_pset:
406             val = self.lamda(*i)
407             if val in already_seen:
408                 continue
409             else:
410                 already_seen.add(val)
411                 yield val
412 
413     def _is_multivariate(self):
414         return len(self.lamda.variables) > 1
415 
416     def _contains(self, other):
417         from sympy.solvers.solveset import _solveset_multi
418 
419         def get_symsetmap(signature, base_sets):
420             '''Attempt to get a map of symbols to base_sets'''
421             queue = list(zip(signature, base_sets))
422             symsetmap = {}
423             for sig, base_set in queue:
424                 if sig.is_symbol:
425                     symsetmap[sig] = base_set
426                 elif base_set.is_ProductSet:
427                     sets = base_set.sets
428                     if len(sig) != len(sets):
429                         raise ValueError("Incompatible signature")
430                     # Recurse
431                     queue.extend(zip(sig, sets))
432                 else:
433                     # If we get here then we have something like sig = (x, y) and
434                     # base_set = {(1, 2), (3, 4)}. For now we give up.
435                     return None
436 
437             return symsetmap
438 
439         def get_equations(expr, candidate):
440             '''Find the equations relating symbols in expr and candidate.'''
441             queue = [(expr, candidate)]
442             for e, c in queue:
443                 if not isinstance(e, Tuple):
444                     yield Eq(e, c)
445                 elif not isinstance(c, Tuple) or len(e) != len(c):
446                     yield False
447                     return
448                 else:
449                     queue.extend(zip(e, c))
450 
451         # Get the basic objects together:
452         other = _sympify(other)
453         expr = self.lamda.expr
454         sig = self.lamda.signature
455         variables = self.lamda.variables
456         base_sets = self.base_sets
457 
458         # Use dummy symbols for ImageSet parameters so they don't match
459         # anything in other
460         rep = {v: Dummy(v.name) for v in variables}
461         variables = [v.subs(rep) for v in variables]
462         sig = sig.subs(rep)
463         expr = expr.subs(rep)
464 
465         # Map the parts of other to those in the Lambda expr
466         equations = []
467         for eq in get_equations(expr, other):
468             # Unsatisfiable equation?
469             if eq is False:
470                 return False
471             equations.append(eq)
472 
473         # Map the symbols in the signature to the corresponding domains
474         symsetmap = get_symsetmap(sig, base_sets)
475         if symsetmap is None:
476             # Can't factor the base sets to a ProductSet
477             return None
478 
479         # Which of the variables in the Lambda signature need to be solved for?
480         symss = (eq.free_symbols for eq in equations)
481         variables = set(variables) & reduce(set.union, symss, set())
482 
483         # Use internal multivariate solveset
484         variables = tuple(variables)
485         base_sets = [symsetmap[v] for v in variables]
486         solnset = _solveset_multi(equations, variables, base_sets)
487         if solnset is None:
488             return None
489         return fuzzy_not(solnset.is_empty)
490 
491     @property
492     def is_iterable(self):
493         return all(s.is_iterable for s in self.base_sets)
494 
495     def doit(self, **kwargs):
496         from sympy.sets.setexpr import SetExpr
497         f = self.lamda
498         sig = f.signature
499         if len(sig) == 1 and sig[0].is_symbol and isinstance(f.expr, Expr):
500             base_set = self.base_sets[0]
501             return SetExpr(base_set)._eval_func(f).set
502         if all(s.is_FiniteSet for s in self.base_sets):
503             return FiniteSet(*(f(*a) for a in cartes(*self.base_sets)))
504         return self
505 
506 
507 class Range(Set):
508     """
509     Represents a range of integers. Can be called as Range(stop),
510     Range(start, stop), or Range(start, stop, step); when step is
511     not given it defaults to 1.
512 
513     `Range(stop)` is the same as `Range(0, stop, 1)` and the stop value
514     (juse as for Python ranges) is not included in the Range values.
515 
516         >>> from sympy import Range
517         >>> list(Range(3))
518         [0, 1, 2]
519 
520     The step can also be negative:
521 
522         >>> list(Range(10, 0, -2))
523         [10, 8, 6, 4, 2]
524 
525     The stop value is made canonical so equivalent ranges always
526     have the same args:
527 
528         >>> Range(0, 10, 3)
529         Range(0, 12, 3)
530 
531     Infinite ranges are allowed. ``oo`` and ``-oo`` are never included in the
532     set (``Range`` is always a subset of ``Integers``). If the starting point
533     is infinite, then the final value is ``stop - step``. To iterate such a
534     range, it needs to be reversed:
535 
536         >>> from sympy import oo
537         >>> r = Range(-oo, 1)
538         >>> r[-1]
539         0
540         >>> next(iter(r))
541         Traceback (most recent call last):
542         ...
543         TypeError: Cannot iterate over Range with infinite start
544         >>> next(iter(r.reversed))
545         0
546 
547     Although Range is a set (and supports the normal set
548     operations) it maintains the order of the elements and can
549     be used in contexts where `range` would be used.
550 
551         >>> from sympy import Interval
552         >>> Range(0, 10, 2).intersect(Interval(3, 7))
553         Range(4, 8, 2)
554         >>> list(_)
555         [4, 6]
556 
557     Although slicing of a Range will always return a Range -- possibly
558     empty -- an empty set will be returned from any intersection that
559     is empty:
560 
561         >>> Range(3)[:0]
562         Range(0, 0, 1)
563         >>> Range(3).intersect(Interval(4, oo))
564         EmptySet
565         >>> Range(3).intersect(Range(4, oo))
566         EmptySet
567 
568     Range will accept symbolic arguments but has very limited support
569     for doing anything other than displaying the Range:
570 
571         >>> from sympy import Symbol, pprint
572         >>> from sympy.abc import i, j, k
573         >>> Range(i, j, k).start
574         i
575         >>> Range(i, j, k).inf
576         Traceback (most recent call last):
577         ...
578         ValueError: invalid method for symbolic range
579 
580     Better success will be had when using integer symbols:
581 
582         >>> n = Symbol('n', integer=True)
583         >>> r = Range(n, n + 20, 3)
584         >>> r.inf
585         n
586         >>> pprint(r)
587         {n, n + 3, ..., n + 18}
588     """
589 
590     is_iterable = True
591 
592     def __new__(cls, *args):
593         from sympy.functions.elementary.integers import ceiling
594         if len(args) == 1:
595             if isinstance(args[0], range):
596                 raise TypeError(
597                     'use sympify(%s) to convert range to Range' % args[0])
598 
599         # expand range
600         slc = slice(*args)
601 
602         if slc.step == 0:
603             raise ValueError("step cannot be 0")
604 
605         start, stop, step = slc.start or 0, slc.stop, slc.step or 1
606         try:
607             ok = []
608             for w in (start, stop, step):
609                 w = sympify(w)
610                 if w in [S.NegativeInfinity, S.Infinity] or (
611                         w.has(Symbol) and w.is_integer != False):
612                     ok.append(w)
613                 elif not w.is_Integer:
614                     if w.is_infinite:
615                         raise ValueError('infinite symbols not allowed')
616                     raise ValueError
617                 else:
618                     ok.append(w)
619         except ValueError:
620             raise ValueError(filldedent('''
621     Finite arguments to Range must be integers; `imageset` can define
622     other cases, e.g. use `imageset(i, i/10, Range(3))` to give
623     [0, 1/10, 1/5].'''))
624         start, stop, step = ok
625 
626         null = False
627         if any(i.has(Symbol) for i in (start, stop, step)):
628             dif = stop - start
629             n = dif/step
630             if n.is_Rational:
631                 from sympy import floor
632                 if dif == 0:
633                     null = True
634                 else:  # (x, x + 5, 2) or (x, 3*x, x)
635                     n = floor(n)
636                     end = start + n*step
637                     if dif.is_Rational:  # (x, x + 5, 2)
638                         if (end - stop).is_negative:
639                             end += step
640                     else:  # (x, 3*x, x)
641                         if (end/stop - 1).is_negative:
642                             end += step
643             elif n.is_extended_negative:
644                 null = True
645             else:
646                 end = stop  # other methods like sup and reversed must fail
647         elif start.is_infinite:
648             span = step*(stop - start)
649             if span is S.NaN or span <= 0:
650                 null = True
651             elif step.is_Integer and stop.is_infinite and abs(step) != 1:
652                 raise ValueError(filldedent('''
653                     Step size must be %s in this case.''' % (1 if step > 0 else -1)))
654             else:
655                 end = stop
656         else:
657             oostep = step.is_infinite
658             if oostep:
659                 step = S.One if step > 0 else S.NegativeOne
660             n = ceiling((stop - start)/step)
661             if n <= 0:
662                 null = True
663             elif oostep:
664                 step = S.One  # make it canonical
665                 end = start + step
666             else:
667                 end = start + n*step
668         if null:
669             start = end = S.Zero
670             step = S.One
671         return Basic.__new__(cls, start, end, step)
672 
673     start = property(lambda self: self.args[0])
674     stop = property(lambda self: self.args[1])
675     step = property(lambda self: self.args[2])
676 
677     @property
678     def reversed(self):
679         """Return an equivalent Range in the opposite order.
680 
681         Examples
682         ========
683 
684         >>> from sympy import Range
685         >>> Range(10).reversed
686         Range(9, -1, -1)
687         """
688         if self.has(Symbol):
689             n = (self.stop - self.start)/self.step
690             if not n.is_extended_positive or not all(
691                     i.is_integer or i.is_infinite for i in self.args):
692                 raise ValueError('invalid method for symbolic range')
693         if self.start == self.stop:
694             return self
695         return self.func(
696             self.stop - self.step, self.start - self.step, -self.step)
697 
698     def _contains(self, other):
699         if self.start == self.stop:
700             return S.false
701         if other.is_infinite:
702             return S.false
703         if not other.is_integer:
704             return other.is_integer
705         if self.has(Symbol):
706             n = (self.stop - self.start)/self.step
707             if not n.is_extended_positive or not all(
708                     i.is_integer or i.is_infinite for i in self.args):
709                 return
710         else:
711             n = self.size
712         if self.start.is_finite:
713             ref = self.start
714         elif self.stop.is_finite:
715             ref = self.stop
716         else:  # both infinite; step is +/- 1 (enforced by __new__)
717             return S.true
718         if n == 1:
719             return Eq(other, self[0])
720         res = (ref - other) % self.step
721         if res == S.Zero:
722             if self.has(Symbol):
723                 d = Dummy('i')
724                 return self.as_relational(d).subs(d, other)
725             return And(other >= self.inf, other <= self.sup)
726         elif res.is_Integer:  # off sequence
727             return S.false
728         else:  # symbolic/unsimplified residue modulo step
729             return None
730 
731     def __iter__(self):
732         n = self.size  # validate
733         if self.start in [S.NegativeInfinity, S.Infinity]:
734             raise TypeError("Cannot iterate over Range with infinite start")
735         elif self.start != self.stop:
736             i = self.start
737             if n.is_infinite:
738                 while True:
739                     yield i
740                     i += self.step
741             else:
742                 for j in range(n):
743                     yield i
744                     i += self.step
745 
746     def __len__(self):
747         rv = self.size
748         if rv is S.Infinity:
749             raise ValueError('Use .size to get the length of an infinite Range')
750         return int(rv)
751 
752     @property
753     def size(self):
754         if self.start == self.stop:
755             return S.Zero
756         dif = self.stop - self.start
757         n = dif/self.step
758         if n.is_infinite:
759             return S.Infinity
760         if not n.is_Integer or not all(i.is_integer for i in self.args):
761             raise ValueError('invalid method for symbolic range')
762         return abs(n)
763 
764     @property
765     def is_finite_set(self):
766         if self.start.is_integer and self.stop.is_integer:
767             return True
768         return self.size.is_finite
769 
770     def __bool__(self):
771         # this only distinguishes between definite null range
772         # and non-null/unknown null; getting True doesn't mean
773         # that it actually is not null
774         b = is_eq(self.start, self.stop)
775         if b is None:
776             raise ValueError('cannot tell if Range is null or not')
777         return not bool(b)
778 
779     def __getitem__(self, i):
780         from sympy.functions.elementary.integers import ceiling
781         ooslice = "cannot slice from the end with an infinite value"
782         zerostep = "slice step cannot be zero"
783         infinite = "slicing not possible on range with infinite start"
784         # if we had to take every other element in the following
785         # oo, ..., 6, 4, 2, 0
786         # we might get oo, ..., 4, 0 or oo, ..., 6, 2
787         ambiguous = "cannot unambiguously re-stride from the end " + \
788             "with an infinite value"
789         if isinstance(i, slice):
790             if self.size.is_finite:  # validates, too
791                 if self.start == self.stop:
792                     return Range(0)
793                 start, stop, step = i.indices(self.size)
794                 n = ceiling((stop - start)/step)
795                 if n <= 0:
796                     return Range(0)
797                 canonical_stop = start + n*step
798                 end = canonical_stop - step
799                 ss = step*self.step
800                 return Range(self[start], self[end] + ss, ss)
801             else:  # infinite Range
802                 start = i.start
803                 stop = i.stop
804                 if i.step == 0:
805                     raise ValueError(zerostep)
806                 step = i.step or 1
807                 ss = step*self.step
808                 #---------------------
809                 # handle infinite Range
810                 #   i.e. Range(-oo, oo) or Range(oo, -oo, -1)
811                 # --------------------
812                 if self.start.is_infinite and self.stop.is_infinite:
813                     raise ValueError(infinite)
814                 #---------------------
815                 # handle infinite on right
816                 #   e.g. Range(0, oo) or Range(0, -oo, -1)
817                 # --------------------
818                 if self.stop.is_infinite:
819                     # start and stop are not interdependent --
820                     # they only depend on step --so we use the
821                     # equivalent reversed values
822                     return self.reversed[
823                         stop if stop is None else -stop + 1:
824                         start if start is None else -start:
825                         step].reversed
826                 #---------------------
827                 # handle infinite on the left
828                 #   e.g. Range(oo, 0, -1) or Range(-oo, 0)
829                 # --------------------
830                 # consider combinations of
831                 # start/stop {== None, < 0, == 0, > 0} and
832                 # step {< 0, > 0}
833                 if start is None:
834                     if stop is None:
835                         if step < 0:
836                             return Range(self[-1], self.start, ss)
837                         elif step > 1:
838                             raise ValueError(ambiguous)
839                         else:  # == 1
840                             return self
841                     elif stop < 0:
842                         if step < 0:
843                             return Range(self[-1], self[stop], ss)
844                         else:  # > 0
845                             return Range(self.start, self[stop], ss)
846                     elif stop == 0:
847                         if step > 0:
848                             return Range(0)
849                         else:  # < 0
850                             raise ValueError(ooslice)
851                     elif stop == 1:
852                         if step > 0:
853                             raise ValueError(ooslice)  # infinite singleton
854                         else:  # < 0
855                             raise ValueError(ooslice)
856                     else:  # > 1
857                         raise ValueError(ooslice)
858                 elif start < 0:
859                     if stop is None:
860                         if step < 0:
861                             return Range(self[start], self.start, ss)
862                         else:  # > 0
863                             return Range(self[start], self.stop, ss)
864                     elif stop < 0:
865                         return Range(self[start], self[stop], ss)
866                     elif stop == 0:
867                         if step < 0:
868                             raise ValueError(ooslice)
869                         else:  # > 0
870                             return Range(0)
871                     elif stop > 0:
872                         raise ValueError(ooslice)
873                 elif start == 0:
874                     if stop is None:
875                         if step < 0:
876                             raise ValueError(ooslice)  # infinite singleton
877                         elif step > 1:
878                             raise ValueError(ambiguous)
879                         else:  # == 1
880                             return self
881                     elif stop < 0:
882                         if step > 1:
883                             raise ValueError(ambiguous)
884                         elif step == 1:
885                             return Range(self.start, self[stop], ss)
886                         else:  # < 0
887                             return Range(0)
888                     else:  # >= 0
889                         raise ValueError(ooslice)
890                 elif start > 0:
891                     raise ValueError(ooslice)
892         else:
893             if self.start == self.stop:
894                 raise IndexError('Range index out of range')
895             if not (all(i.is_integer or i.is_infinite
896                     for i in self.args) and ((self.stop - self.start)/
897                     self.step).is_extended_positive):
898                 raise ValueError('invalid method for symbolic range')
899             if i == 0:
900                 if self.start.is_infinite:
901                     raise ValueError(ooslice)
902                 return self.start
903             if i == -1:
904                 if self.stop.is_infinite:
905                     raise ValueError(ooslice)
906                 return self.stop - self.step
907             n = self.size  # must be known for any other index
908             rv = (self.stop if i < 0 else self.start) + i*self.step
909             if rv.is_infinite:
910                 raise ValueError(ooslice)
911             if 0 <= (rv - self.start)/self.step <= n:
912                 return rv
913             raise IndexError("Range index out of range")
914 
915     @property
916     def _inf(self):
917         if not self:
918             return S.EmptySet.inf
919         if self.has(Symbol):
920             if all(i.is_integer or i.is_infinite for i in self.args):
921                 dif = self.stop - self.start
922                 if self.step.is_positive and dif.is_positive:
923                     return self.start
924                 elif self.step.is_negative and dif.is_negative:
925                     return self.stop - self.step
926             raise ValueError('invalid method for symbolic range')
927         if self.step > 0:
928             return self.start
929         else:
930             return self.stop - self.step
931 
932     @property
933     def _sup(self):
934         if not self:
935             return S.EmptySet.sup
936         if self.has(Symbol):
937             if all(i.is_integer or i.is_infinite for i in self.args):
938                 dif = self.stop - self.start
939                 if self.step.is_positive and dif.is_positive:
940                     return self.stop - self.step
941                 elif self.step.is_negative and dif.is_negative:
942                     return self.start
943             raise ValueError('invalid method for symbolic range')
944         if self.step > 0:
945             return self.stop - self.step
946         else:
947             return self.start
948 
949     @property
950     def _boundary(self):
951         return self
952 
953     def as_relational(self, x):
954         """Rewrite a Range in terms of equalities and logic operators. """
955         from sympy.core.mod import Mod
956         if self.start.is_infinite:
957             assert not self.stop.is_infinite  # by instantiation
958             a = self.reversed.start
959         else:
960             a = self.start
961         step = self.step
962         in_seq = Eq(Mod(x - a, step), 0)
963         ints = And(Eq(Mod(a, 1), 0), Eq(Mod(step, 1), 0))
964         n = (self.stop - self.start)/self.step
965         if n == 0:
966             return S.EmptySet.as_relational(x)
967         if n == 1:
968             return And(Eq(x, a), ints)
969         try:
970             a, b = self.inf, self.sup
971         except ValueError:
972             a = None
973         if a is not None:
974             range_cond = And(
975                 x > a if a.is_infinite else x >= a,
976                 x < b if b.is_infinite else x <= b)
977         else:
978             a, b = self.start, self.stop - self.step
979             range_cond = Or(
980                 And(self.step >= 1, x > a if a.is_infinite else x >= a,
981                 x < b if b.is_infinite else x <= b),
982                 And(self.step <= -1, x < a if a.is_infinite else x <= a,
983                 x > b if b.is_infinite else x >= b))
984         return And(in_seq, ints, range_cond)
985 
986 
987 converter[range] = lambda r: Range(r.start, r.stop, r.step)
988 
989 def normalize_theta_set(theta):
990     """
991     Normalize a Real Set `theta` in the Interval [0, 2*pi). It returns
992     a normalized value of theta in the Set. For Interval, a maximum of
993     one cycle [0, 2*pi], is returned i.e. for theta equal to [0, 10*pi],
994     returned normalized value would be [0, 2*pi). As of now intervals
995     with end points as non-multiples of `pi` is not supported.
996 
997     Raises
998     ======
999 
1000     NotImplementedError
1001         The algorithms for Normalizing theta Set are not yet
1002         implemented.
1003     ValueError
1004         The input is not valid, i.e. the input is not a real set.
1005     RuntimeError
1006         It is a bug, please report to the github issue tracker.
1007 
1008     Examples
1009     ========
1010 
1011     >>> from sympy.sets.fancysets import normalize_theta_set
1012     >>> from sympy import Interval, FiniteSet, pi
1013     >>> normalize_theta_set(Interval(9*pi/2, 5*pi))
1014     Interval(pi/2, pi)
1015     >>> normalize_theta_set(Interval(-3*pi/2, pi/2))
1016     Interval.Ropen(0, 2*pi)
1017     >>> normalize_theta_set(Interval(-pi/2, pi/2))
1018     Union(Interval(0, pi/2), Interval.Ropen(3*pi/2, 2*pi))
1019     >>> normalize_theta_set(Interval(-4*pi, 3*pi))
1020     Interval.Ropen(0, 2*pi)
1021     >>> normalize_theta_set(Interval(-3*pi/2, -pi/2))
1022     Interval(pi/2, 3*pi/2)
1023     >>> normalize_theta_set(FiniteSet(0, pi, 3*pi))
1024     FiniteSet(0, pi)
1025 
1026     """
1027     from sympy.functions.elementary.trigonometric import _pi_coeff as coeff
1028 
1029     if theta.is_Interval:
1030         interval_len = theta.measure
1031         # one complete circle
1032         if interval_len >= 2*S.Pi:
1033             if interval_len == 2*S.Pi and theta.left_open and theta.right_open:
1034                 k = coeff(theta.start)
1035                 return Union(Interval(0, k*S.Pi, False, True),
1036                         Interval(k*S.Pi, 2*S.Pi, True, True))
1037             return Interval(0, 2*S.Pi, False, True)
1038 
1039         k_start, k_end = coeff(theta.start), coeff(theta.end)
1040 
1041         if k_start is None or k_end is None:
1042             raise NotImplementedError("Normalizing theta without pi as coefficient is "
1043                                     "not yet implemented")
1044         new_start = k_start*S.Pi
1045         new_end = k_end*S.Pi
1046 
1047         if new_start > new_end:
1048             return Union(Interval(S.Zero, new_end, False, theta.right_open),
1049                          Interval(new_start, 2*S.Pi, theta.left_open, True))
1050         else:
1051             return Interval(new_start, new_end, theta.left_open, theta.right_open)
1052 
1053     elif theta.is_FiniteSet:
1054         new_theta = []
1055         for element in theta:
1056             k = coeff(element)
1057             if k is None:
1058                 raise NotImplementedError('Normalizing theta without pi as '
1059                                           'coefficient, is not Implemented.')
1060             else:
1061                 new_theta.append(k*S.Pi)
1062         return FiniteSet(*new_theta)
1063 
1064     elif theta.is_Union:
1065         return Union(*[normalize_theta_set(interval) for interval in theta.args])
1066 
1067     elif theta.is_subset(S.Reals):
1068         raise NotImplementedError("Normalizing theta when, it is of type %s is not "
1069                                   "implemented" % type(theta))
1070     else:
1071         raise ValueError(" %s is not a real set" % (theta))
1072 
1073 
1074 class ComplexRegion(Set):
1075     """
1076     Represents the Set of all Complex Numbers. It can represent a
1077     region of Complex Plane in both the standard forms Polar and
1078     Rectangular coordinates.
1079 
1080     * Polar Form
1081       Input is in the form of the ProductSet or Union of ProductSets
1082       of the intervals of r and theta, & use the flag polar=True.
1083 
1084     Z = {z in C | z = r*[cos(theta) + I*sin(theta)], r in [r], theta in [theta]}
1085 
1086     * Rectangular Form
1087       Input is in the form of the ProductSet or Union of ProductSets
1088       of interval of x and y the of the Complex numbers in a Plane.
1089       Default input type is in rectangular form.
1090 
1091     Z = {z in C | z = x + I*y, x in [Re(z)], y in [Im(z)]}
1092 
1093     Examples
1094     ========
1095 
1096     >>> from sympy.sets.fancysets import ComplexRegion
1097     >>> from sympy.sets import Interval
1098     >>> from sympy import S, I, Union
1099     >>> a = Interval(2, 3)
1100     >>> b = Interval(4, 6)
1101     >>> c = Interval(1, 8)
1102     >>> c1 = ComplexRegion(a*b)  # Rectangular Form
1103     >>> c1
1104     CartesianComplexRegion(ProductSet(Interval(2, 3), Interval(4, 6)))
1105 
1106     * c1 represents the rectangular region in complex plane
1107       surrounded by the coordinates (2, 4), (3, 4), (3, 6) and
1108       (2, 6), of the four vertices.
1109 
1110     >>> c2 = ComplexRegion(Union(a*b, b*c))
1111     >>> c2
1112     CartesianComplexRegion(Union(ProductSet(Interval(2, 3), Interval(4, 6)), ProductSet(Interval(4, 6), Interval(1, 8))))
1113 
1114     * c2 represents the Union of two rectangular regions in complex
1115       plane. One of them surrounded by the coordinates of c1 and
1116       other surrounded by the coordinates (4, 1), (6, 1), (6, 8) and
1117       (4, 8).
1118 
1119     >>> 2.5 + 4.5*I in c1
1120     True
1121     >>> 2.5 + 6.5*I in c1
1122     False
1123 
1124     >>> r = Interval(0, 1)
1125     >>> theta = Interval(0, 2*S.Pi)
1126     >>> c2 = ComplexRegion(r*theta, polar=True)  # Polar Form
1127     >>> c2  # unit Disk
1128     PolarComplexRegion(ProductSet(Interval(0, 1), Interval.Ropen(0, 2*pi)))
1129 
1130     * c2 represents the region in complex plane inside the
1131       Unit Disk centered at the origin.
1132 
1133     >>> 0.5 + 0.5*I in c2
1134     True
1135     >>> 1 + 2*I in c2
1136     False
1137 
1138     >>> unit_disk = ComplexRegion(Interval(0, 1)*Interval(0, 2*S.Pi), polar=True)
1139     >>> upper_half_unit_disk = ComplexRegion(Interval(0, 1)*Interval(0, S.Pi), polar=True)
1140     >>> intersection = unit_disk.intersect(upper_half_unit_disk)
1141     >>> intersection
1142     PolarComplexRegion(ProductSet(Interval(0, 1), Interval(0, pi)))
1143     >>> intersection == upper_half_unit_disk
1144     True
1145 
1146     See Also
1147     ========
1148 
1149     CartesianComplexRegion
1150     PolarComplexRegion
1151     Complexes
1152 
1153     """
1154     is_ComplexRegion = True
1155 
1156     def __new__(cls, sets, polar=False):
1157         if polar is False:
1158             return CartesianComplexRegion(sets)
1159         elif polar is True:
1160             return PolarComplexRegion(sets)
1161         else:
1162             raise ValueError("polar should be either True or False")
1163 
1164     @property
1165     def sets(self):
1166         """
1167         Return raw input sets to the self.
1168 
1169         Examples
1170         ========
1171 
1172         >>> from sympy import Interval, ComplexRegion, Union
1173         >>> a = Interval(2, 3)
1174         >>> b = Interval(4, 5)
1175         >>> c = Interval(1, 7)
1176         >>> C1 = ComplexRegion(a*b)
1177         >>> C1.sets
1178         ProductSet(Interval(2, 3), Interval(4, 5))
1179         >>> C2 = ComplexRegion(Union(a*b, b*c))
1180         >>> C2.sets
1181         Union(ProductSet(Interval(2, 3), Interval(4, 5)), ProductSet(Interval(4, 5), Interval(1, 7)))
1182 
1183         """
1184         return self.args[0]
1185 
1186     @property
1187     def psets(self):
1188         """
1189         Return a tuple of sets (ProductSets) input of the self.
1190 
1191         Examples
1192         ========
1193 
1194         >>> from sympy import Interval, ComplexRegion, Union
1195         >>> a = Interval(2, 3)
1196         >>> b = Interval(4, 5)
1197         >>> c = Interval(1, 7)
1198         >>> C1 = ComplexRegion(a*b)
1199         >>> C1.psets
1200         (ProductSet(Interval(2, 3), Interval(4, 5)),)
1201         >>> C2 = ComplexRegion(Union(a*b, b*c))
1202         >>> C2.psets
1203         (ProductSet(Interval(2, 3), Interval(4, 5)), ProductSet(Interval(4, 5), Interval(1, 7)))
1204 
1205         """
1206         if self.sets.is_ProductSet:
1207             psets = ()
1208             psets = psets + (self.sets, )
1209         else:
1210             psets = self.sets.args
1211         return psets
1212 
1213     @property
1214     def a_interval(self):
1215         """
1216         Return the union of intervals of `x` when, self is in
1217         rectangular form, or the union of intervals of `r` when
1218         self is in polar form.
1219 
1220         Examples
1221         ========
1222 
1223         >>> from sympy import Interval, ComplexRegion, Union
1224         >>> a = Interval(2, 3)
1225         >>> b = Interval(4, 5)
1226         >>> c = Interval(1, 7)
1227         >>> C1 = ComplexRegion(a*b)
1228         >>> C1.a_interval
1229         Interval(2, 3)
1230         >>> C2 = ComplexRegion(Union(a*b, b*c))
1231         >>> C2.a_interval
1232         Union(Interval(2, 3), Interval(4, 5))
1233 
1234         """
1235         a_interval = []
1236         for element in self.psets:
1237             a_interval.append(element.args[0])
1238 
1239         a_interval = Union(*a_interval)
1240         return a_interval
1241 
1242     @property
1243     def b_interval(self):
1244         """
1245         Return the union of intervals of `y` when, self is in
1246         rectangular form, or the union of intervals of `theta`
1247         when self is in polar form.
1248 
1249         Examples
1250         ========
1251 
1252         >>> from sympy import Interval, ComplexRegion, Union
1253         >>> a = Interval(2, 3)
1254         >>> b = Interval(4, 5)
1255         >>> c = Interval(1, 7)
1256         >>> C1 = ComplexRegion(a*b)
1257         >>> C1.b_interval
1258         Interval(4, 5)
1259         >>> C2 = ComplexRegion(Union(a*b, b*c))
1260         >>> C2.b_interval
1261         Interval(1, 7)
1262 
1263         """
1264         b_interval = []
1265         for element in self.psets:
1266             b_interval.append(element.args[1])
1267 
1268         b_interval = Union(*b_interval)
1269         return b_interval
1270 
1271     @property
1272     def _measure(self):
1273         """
1274         The measure of self.sets.
1275 
1276         Examples
1277         ========
1278 
1279         >>> from sympy import Interval, ComplexRegion, S
1280         >>> a, b = Interval(2, 5), Interval(4, 8)
1281         >>> c = Interval(0, 2*S.Pi)
1282         >>> c1 = ComplexRegion(a*b)
1283         >>> c1.measure
1284         12
1285         >>> c2 = ComplexRegion(a*c, polar=True)
1286         >>> c2.measure
1287         6*pi
1288 
1289         """
1290         return self.sets._measure
1291 
1292     @classmethod
1293     def from_real(cls, sets):
1294         """
1295         Converts given subset of real numbers to a complex region.
1296 
1297         Examples
1298         ========
1299 
1300         >>> from sympy import Interval, ComplexRegion
1301         >>> unit = Interval(0,1)
1302         >>> ComplexRegion.from_real(unit)
1303         CartesianComplexRegion(ProductSet(Interval(0, 1), FiniteSet(0)))
1304 
1305         """
1306         if not sets.is_subset(S.Reals):
1307             raise ValueError("sets must be a subset of the real line")
1308 
1309         return CartesianComplexRegion(sets * FiniteSet(0))
1310 
1311     def _contains(self, other):
1312         from sympy.functions import arg, Abs
1313         from sympy.core.containers import Tuple
1314         other = sympify(other)
1315         isTuple = isinstance(other, Tuple)
1316         if isTuple and len(other) != 2:
1317             raise ValueError('expecting Tuple of length 2')
1318 
1319         # If the other is not an Expression, and neither a Tuple
1320         if not isinstance(other, Expr) and not isinstance(other, Tuple):
1321             return S.false
1322         # self in rectangular form
1323         if not self.polar:
1324             re, im = other if isTuple else other.as_real_imag()
1325             return fuzzy_or(fuzzy_and([
1326                 pset.args[0]._contains(re),
1327                 pset.args[1]._contains(im)])
1328                 for pset in self.psets)
1329 
1330         # self in polar form
1331         elif self.polar:
1332             if other.is_zero:
1333                 # ignore undefined complex argument
1334                 return fuzzy_or(pset.args[0]._contains(S.Zero)
1335                     for pset in self.psets)
1336             if isTuple:
1337                 r, theta = other
1338             else:
1339                 r, theta = Abs(other), arg(other)
1340             if theta.is_real and theta.is_number:
1341                 # angles in psets are normalized to [0, 2pi)
1342                 theta %= 2*S.Pi
1343                 return fuzzy_or(fuzzy_and([
1344                     pset.args[0]._contains(r),
1345                     pset.args[1]._contains(theta)])
1346                     for pset in self.psets)
1347 
1348 
1349 class CartesianComplexRegion(ComplexRegion):
1350     """
1351     Set representing a square region of the complex plane.
1352 
1353     Z = {z in C | z = x + I*y, x in [Re(z)], y in [Im(z)]}
1354 
1355     Examples
1356     ========
1357 
1358     >>> from sympy.sets.fancysets import ComplexRegion
1359     >>> from sympy.sets.sets import Interval
1360     >>> from sympy import I
1361     >>> region = ComplexRegion(Interval(1, 3) * Interval(4, 6))
1362     >>> 2 + 5*I in region
1363     True
1364     >>> 5*I in region
1365     False
1366 
1367     See also
1368     ========
1369 
1370     ComplexRegion
1371     PolarComplexRegion
1372     Complexes
1373     """
1374 
1375     polar = False
1376     variables = symbols('x, y', cls=Dummy)
1377 
1378     def __new__(cls, sets):
1379 
1380         if sets == S.Reals*S.Reals:
1381             return S.Complexes
1382 
1383         if all(_a.is_FiniteSet for _a in sets.args) and (len(sets.args) == 2):
1384 
1385             # ** ProductSet of FiniteSets in the Complex Plane. **
1386             # For Cases like ComplexRegion({2, 4}*{3}), It
1387             # would return {2 + 3*I, 4 + 3*I}
1388 
1389             # FIXME: This should probably be handled with something like:
1390             # return ImageSet(Lambda((x, y), x+I*y), sets).rewrite(FiniteSet)
1391             complex_num = []
1392             for x in sets.args[0]:
1393                 for y in sets.args[1]:
1394                     complex_num.append(x + S.ImaginaryUnit*y)
1395             return FiniteSet(*complex_num)
1396         else:
1397             return Set.__new__(cls, sets)
1398 
1399     @property
1400     def expr(self):
1401         x, y = self.variables
1402         return x + S.ImaginaryUnit*y
1403 
1404 
1405 class PolarComplexRegion(ComplexRegion):
1406     """
1407     Set representing a polar region of the complex plane.
1408 
1409     Z = {z in C | z = r*[cos(theta) + I*sin(theta)], r in [r], theta in [theta]}
1410 
1411     Examples
1412     ========
1413 
1414     >>> from sympy.sets.fancysets import ComplexRegion, Interval
1415     >>> from sympy import oo, pi, I
1416     >>> rset = Interval(0, oo)
1417     >>> thetaset = Interval(0, pi)
1418     >>> upper_half_plane = ComplexRegion(rset * thetaset, polar=True)
1419     >>> 1 + I in upper_half_plane
1420     True
1421     >>> 1 - I in upper_half_plane
1422     False
1423 
1424     See also
1425     ========
1426 
1427     ComplexRegion
1428     CartesianComplexRegion
1429     Complexes
1430 
1431     """
1432 
1433     polar = True
1434     variables = symbols('r, theta', cls=Dummy)
1435 
1436     def __new__(cls, sets):
1437 
1438         new_sets = []
1439         # sets is Union of ProductSets
1440         if not sets.is_ProductSet:
1441             for k in sets.args:
1442                 new_sets.append(k)
1443         # sets is ProductSets
1444         else:
1445             new_sets.append(sets)
1446         # Normalize input theta
1447         for k, v in enumerate(new_sets):
1448             new_sets[k] = ProductSet(v.args[0],
1449                                      normalize_theta_set(v.args[1]))
1450         sets = Union(*new_sets)
1451         return Set.__new__(cls, sets)
1452 
1453     @property
1454     def expr(self):
1455         from sympy.functions.elementary.trigonometric import sin, cos
1456         r, theta = self.variables
1457         return r*(cos(theta) + S.ImaginaryUnit*sin(theta))
1458 
1459 
1460 class Complexes(CartesianComplexRegion, metaclass=Singleton):
1461     """
1462     The Set of all complex numbers
1463 
1464     Examples
1465     ========
1466 
1467     >>> from sympy import S, I
1468     >>> S.Complexes
1469     Complexes
1470     >>> 1 + I in S.Complexes
1471     True
1472 
1473     See also
1474     ========
1475 
1476     Reals
1477     ComplexRegion
1478 
1479     """
1480 
1481     is_empty = False
1482     is_finite_set = False
1483 
1484     # Override property from superclass since Complexes has no args
1485     @property
1486     def sets(self):
1487         return ProductSet(S.Reals, S.Reals)
1488 
1489     def __new__(cls):
1490         return Set.__new__(cls)
1491 
1492     def __str__(self):
1493         return "S.Complexes"
1494 
1495     def __repr__(self):
1496         return "S.Complexes"

</code><intended_behavior>This method should ensure that intersections between an ImageSet producing complex numbers and Reals are accurately calculated, excluding any non-real numbers from the results. This may require implementing a check within the intersection logic to explicitly determine if a given element from an ImageSet is real before including it in the result set when intersecting with Reals. Enhancing the logic to understand and simplify complex expressions better, to accurately determine their real-number status in an intersection scenario.</intended_behavior>]
2025-10-18 09:24:45.845 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-18 09:24:45.845 | INFO     | Search-only: skipping patch selection
2025-10-18 09:24:45.927 | INFO     | Task sympy__sympy-21596 completed successfully.
2025-10-18 09:24:45.928 | INFO     | No patch generated. You can try running ACR again.
