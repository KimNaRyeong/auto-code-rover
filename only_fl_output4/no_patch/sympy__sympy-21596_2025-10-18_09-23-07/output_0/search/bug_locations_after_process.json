[
    {
        "rel_file_path": "sympy/sets/fancysets.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sympy__sympy/setup_sympy__sympy__1.9/sympy/sets/fancysets.py",
        "start": 1,
        "end": 1496,
        "class_name": null,
        "method_name": null,
        "code": "1 from functools import reduce\n2 \n3 from sympy.core.basic import Basic\n4 from sympy.core.containers import Tuple\n5 from sympy.core.expr import Expr\n6 from sympy.core.function import Lambda\n7 from sympy.core.logic import fuzzy_not, fuzzy_or, fuzzy_and\n8 from sympy.core.numbers import oo\n9 from sympy.core.relational import Eq, is_eq\n10 from sympy.core.singleton import Singleton, S\n11 from sympy.core.symbol import Dummy, symbols, Symbol\n12 from sympy.core.sympify import _sympify, sympify, converter\n13 from sympy.logic.boolalg import And, Or\n14 from sympy.sets.sets import (Set, Interval, Union, FiniteSet,\n15     ProductSet)\n16 from sympy.utilities.misc import filldedent\n17 from sympy.utilities.iterables import cartes\n18 \n19 \n20 class Rationals(Set, metaclass=Singleton):\n21     \"\"\"\n22     Represents the rational numbers. This set is also available as\n23     the Singleton, S.Rationals.\n24 \n25     Examples\n26     ========\n27 \n28     >>> from sympy import S\n29     >>> S.Half in S.Rationals\n30     True\n31     >>> iterable = iter(S.Rationals)\n32     >>> [next(iterable) for i in range(12)]\n33     [0, 1, -1, 1/2, 2, -1/2, -2, 1/3, 3, -1/3, -3, 2/3]\n34     \"\"\"\n35 \n36     is_iterable = True\n37     _inf = S.NegativeInfinity\n38     _sup = S.Infinity\n39     is_empty = False\n40     is_finite_set = False\n41 \n42     def _contains(self, other):\n43         if not isinstance(other, Expr):\n44             return False\n45         return other.is_rational\n46 \n47     def __iter__(self):\n48         from sympy.core.numbers import igcd, Rational\n49         yield S.Zero\n50         yield S.One\n51         yield S.NegativeOne\n52         d = 2\n53         while True:\n54             for n in range(d):\n55                 if igcd(n, d) == 1:\n56                     yield Rational(n, d)\n57                     yield Rational(d, n)\n58                     yield Rational(-n, d)\n59                     yield Rational(-d, n)\n60             d += 1\n61 \n62     @property\n63     def _boundary(self):\n64         return S.Reals\n65 \n66 \n67 class Naturals(Set, metaclass=Singleton):\n68     \"\"\"\n69     Represents the natural numbers (or counting numbers) which are all\n70     positive integers starting from 1. This set is also available as\n71     the Singleton, S.Naturals.\n72 \n73     Examples\n74     ========\n75 \n76     >>> from sympy import S, Interval, pprint\n77     >>> 5 in S.Naturals\n78     True\n79     >>> iterable = iter(S.Naturals)\n80     >>> next(iterable)\n81     1\n82     >>> next(iterable)\n83     2\n84     >>> next(iterable)\n85     3\n86     >>> pprint(S.Naturals.intersect(Interval(0, 10)))\n87     {1, 2, ..., 10}\n88 \n89     See Also\n90     ========\n91 \n92     Naturals0 : non-negative integers (i.e. includes 0, too)\n93     Integers : also includes negative integers\n94     \"\"\"\n95 \n96     is_iterable = True\n97     _inf = S.One\n98     _sup = S.Infinity\n99     is_empty = False\n100     is_finite_set = False\n101 \n102     def _contains(self, other):\n103         if not isinstance(other, Expr):\n104             return False\n105         elif other.is_positive and other.is_integer:\n106             return True\n107         elif other.is_integer is False or other.is_positive is False:\n108             return False\n109 \n110     def _eval_is_subset(self, other):\n111         return Range(1, oo).is_subset(other)\n112 \n113     def _eval_is_superset(self, other):\n114         return Range(1, oo).is_superset(other)\n115 \n116     def __iter__(self):\n117         i = self._inf\n118         while True:\n119             yield i\n120             i = i + 1\n121 \n122     @property\n123     def _boundary(self):\n124         return self\n125 \n126     def as_relational(self, x):\n127         from sympy.functions.elementary.integers import floor\n128         return And(Eq(floor(x), x), x >= self.inf, x < oo)\n129 \n130 \n131 class Naturals0(Naturals):\n132     \"\"\"Represents the whole numbers which are all the non-negative integers,\n133     inclusive of zero.\n134 \n135     See Also\n136     ========\n137 \n138     Naturals : positive integers; does not include 0\n139     Integers : also includes the negative integers\n140     \"\"\"\n141     _inf = S.Zero\n142 \n143     def _contains(self, other):\n144         if not isinstance(other, Expr):\n145             return S.false\n146         elif other.is_integer and other.is_nonnegative:\n147             return S.true\n148         elif other.is_integer is False or other.is_nonnegative is False:\n149             return S.false\n150 \n151     def _eval_is_subset(self, other):\n152         return Range(oo).is_subset(other)\n153 \n154     def _eval_is_superset(self, other):\n155         return Range(oo).is_superset(other)\n156 \n157 \n158 class Integers(Set, metaclass=Singleton):\n159     \"\"\"\n160     Represents all integers: positive, negative and zero. This set is also\n161     available as the Singleton, S.Integers.\n162 \n163     Examples\n164     ========\n165 \n166     >>> from sympy import S, Interval, pprint\n167     >>> 5 in S.Naturals\n168     True\n169     >>> iterable = iter(S.Integers)\n170     >>> next(iterable)\n171     0\n172     >>> next(iterable)\n173     1\n174     >>> next(iterable)\n175     -1\n176     >>> next(iterable)\n177     2\n178 \n179     >>> pprint(S.Integers.intersect(Interval(-4, 4)))\n180     {-4, -3, ..., 4}\n181 \n182     See Also\n183     ========\n184 \n185     Naturals0 : non-negative integers\n186     Integers : positive and negative integers and zero\n187     \"\"\"\n188 \n189     is_iterable = True\n190     is_empty = False\n191     is_finite_set = False\n192 \n193     def _contains(self, other):\n194         if not isinstance(other, Expr):\n195             return S.false\n196         return other.is_integer\n197 \n198     def __iter__(self):\n199         yield S.Zero\n200         i = S.One\n201         while True:\n202             yield i\n203             yield -i\n204             i = i + 1\n205 \n206     @property\n207     def _inf(self):\n208         return S.NegativeInfinity\n209 \n210     @property\n211     def _sup(self):\n212         return S.Infinity\n213 \n214     @property\n215     def _boundary(self):\n216         return self\n217 \n218     def as_relational(self, x):\n219         from sympy.functions.elementary.integers import floor\n220         return And(Eq(floor(x), x), -oo < x, x < oo)\n221 \n222     def _eval_is_subset(self, other):\n223         return Range(-oo, oo).is_subset(other)\n224 \n225     def _eval_is_superset(self, other):\n226         return Range(-oo, oo).is_superset(other)\n227 \n228 \n229 class Reals(Interval, metaclass=Singleton):\n230     \"\"\"\n231     Represents all real numbers\n232     from negative infinity to positive infinity,\n233     including all integer, rational and irrational numbers.\n234     This set is also available as the Singleton, S.Reals.\n235 \n236 \n237     Examples\n238     ========\n239 \n240     >>> from sympy import S, Rational, pi, I\n241     >>> 5 in S.Reals\n242     True\n243     >>> Rational(-1, 2) in S.Reals\n244     True\n245     >>> pi in S.Reals\n246     True\n247     >>> 3*I in S.Reals\n248     False\n249     >>> S.Reals.contains(pi)\n250     True\n251 \n252 \n253     See Also\n254     ========\n255 \n256     ComplexRegion\n257     \"\"\"\n258     @property\n259     def start(self):\n260         return S.NegativeInfinity\n261 \n262     @property\n263     def end(self):\n264         return S.Infinity\n265 \n266     @property\n267     def left_open(self):\n268         return True\n269 \n270     @property\n271     def right_open(self):\n272         return True\n273 \n274     def __eq__(self, other):\n275         return other == Interval(S.NegativeInfinity, S.Infinity)\n276 \n277     def __hash__(self):\n278         return hash(Interval(S.NegativeInfinity, S.Infinity))\n279 \n280 \n281 class ImageSet(Set):\n282     \"\"\"\n283     Image of a set under a mathematical function. The transformation\n284     must be given as a Lambda function which has as many arguments\n285     as the elements of the set upon which it operates, e.g. 1 argument\n286     when acting on the set of integers or 2 arguments when acting on\n287     a complex region.\n288 \n289     This function is not normally called directly, but is called\n290     from `imageset`.\n291 \n292 \n293     Examples\n294     ========\n295 \n296     >>> from sympy import Symbol, S, pi, Dummy, Lambda\n297     >>> from sympy.sets.sets import FiniteSet, Interval\n298     >>> from sympy.sets.fancysets import ImageSet\n299 \n300     >>> x = Symbol('x')\n301     >>> N = S.Naturals\n302     >>> squares = ImageSet(Lambda(x, x**2), N) # {x**2 for x in N}\n303     >>> 4 in squares\n304     True\n305     >>> 5 in squares\n306     False\n307 \n308     >>> FiniteSet(0, 1, 2, 3, 4, 5, 6, 7, 9, 10).intersect(squares)\n309     FiniteSet(1, 4, 9)\n310 \n311     >>> square_iterable = iter(squares)\n312     >>> for i in range(4):\n313     ...     next(square_iterable)\n314     1\n315     4\n316     9\n317     16\n318 \n319     If you want to get value for `x` = 2, 1/2 etc. (Please check whether the\n320     `x` value is in `base_set` or not before passing it as args)\n321 \n322     >>> squares.lamda(2)\n323     4\n324     >>> squares.lamda(S(1)/2)\n325     1/4\n326 \n327     >>> n = Dummy('n')\n328     >>> solutions = ImageSet(Lambda(n, n*pi), S.Integers) # solutions of sin(x) = 0\n329     >>> dom = Interval(-1, 1)\n330     >>> dom.intersect(solutions)\n331     FiniteSet(0)\n332 \n333     See Also\n334     ========\n335 \n336     sympy.sets.sets.imageset\n337     \"\"\"\n338     def __new__(cls, flambda, *sets):\n339         if not isinstance(flambda, Lambda):\n340             raise ValueError('First argument must be a Lambda')\n341 \n342         signature = flambda.signature\n343 \n344         if len(signature) != len(sets):\n345             raise ValueError('Incompatible signature')\n346 \n347         sets = [_sympify(s) for s in sets]\n348 \n349         if not all(isinstance(s, Set) for s in sets):\n350             raise TypeError(\"Set arguments to ImageSet should of type Set\")\n351 \n352         if not all(cls._check_sig(sg, st) for sg, st in zip(signature, sets)):\n353             raise ValueError(\"Signature %s does not match sets %s\" % (signature, sets))\n354 \n355         if flambda is S.IdentityFunction and len(sets) == 1:\n356             return sets[0]\n357 \n358         if not set(flambda.variables) & flambda.expr.free_symbols:\n359             is_empty = fuzzy_or(s.is_empty for s in sets)\n360             if is_empty == True:\n361                 return S.EmptySet\n362             elif is_empty == False:\n363                 return FiniteSet(flambda.expr)\n364 \n365         return Basic.__new__(cls, flambda, *sets)\n366 \n367     lamda = property(lambda self: self.args[0])\n368     base_sets = property(lambda self: self.args[1:])\n369 \n370     @property\n371     def base_set(self):\n372         # XXX: Maybe deprecate this? It is poorly defined in handling\n373         # the multivariate case...\n374         sets = self.base_sets\n375         if len(sets) == 1:\n376             return sets[0]\n377         else:\n378             return ProductSet(*sets).flatten()\n379 \n380     @property\n381     def base_pset(self):\n382         return ProductSet(*self.base_sets)\n383 \n384     @classmethod\n385     def _check_sig(cls, sig_i, set_i):\n386         if sig_i.is_symbol:\n387             return True\n388         elif isinstance(set_i, ProductSet):\n389             sets = set_i.sets\n390             if len(sig_i) != len(sets):\n391                 return False\n392             # Recurse through the signature for nested tuples:\n393             return all(cls._check_sig(ts, ps) for ts, ps in zip(sig_i, sets))\n394         else:\n395             # XXX: Need a better way of checking whether a set is a set of\n396             # Tuples or not. For example a FiniteSet can contain Tuples\n397             # but so can an ImageSet or a ConditionSet. Others like\n398             # Integers, Reals etc can not contain Tuples. We could just\n399             # list the possibilities here... Current code for e.g.\n400             # _contains probably only works for ProductSet.\n401             return True # Give the benefit of the doubt\n402 \n403     def __iter__(self):\n404         already_seen = set()\n405         for i in self.base_pset:\n406             val = self.lamda(*i)\n407             if val in already_seen:\n408                 continue\n409             else:\n410                 already_seen.add(val)\n411                 yield val\n412 \n413     def _is_multivariate(self):\n414         return len(self.lamda.variables) > 1\n415 \n416     def _contains(self, other):\n417         from sympy.solvers.solveset import _solveset_multi\n418 \n419         def get_symsetmap(signature, base_sets):\n420             '''Attempt to get a map of symbols to base_sets'''\n421             queue = list(zip(signature, base_sets))\n422             symsetmap = {}\n423             for sig, base_set in queue:\n424                 if sig.is_symbol:\n425                     symsetmap[sig] = base_set\n426                 elif base_set.is_ProductSet:\n427                     sets = base_set.sets\n428                     if len(sig) != len(sets):\n429                         raise ValueError(\"Incompatible signature\")\n430                     # Recurse\n431                     queue.extend(zip(sig, sets))\n432                 else:\n433                     # If we get here then we have something like sig = (x, y) and\n434                     # base_set = {(1, 2), (3, 4)}. For now we give up.\n435                     return None\n436 \n437             return symsetmap\n438 \n439         def get_equations(expr, candidate):\n440             '''Find the equations relating symbols in expr and candidate.'''\n441             queue = [(expr, candidate)]\n442             for e, c in queue:\n443                 if not isinstance(e, Tuple):\n444                     yield Eq(e, c)\n445                 elif not isinstance(c, Tuple) or len(e) != len(c):\n446                     yield False\n447                     return\n448                 else:\n449                     queue.extend(zip(e, c))\n450 \n451         # Get the basic objects together:\n452         other = _sympify(other)\n453         expr = self.lamda.expr\n454         sig = self.lamda.signature\n455         variables = self.lamda.variables\n456         base_sets = self.base_sets\n457 \n458         # Use dummy symbols for ImageSet parameters so they don't match\n459         # anything in other\n460         rep = {v: Dummy(v.name) for v in variables}\n461         variables = [v.subs(rep) for v in variables]\n462         sig = sig.subs(rep)\n463         expr = expr.subs(rep)\n464 \n465         # Map the parts of other to those in the Lambda expr\n466         equations = []\n467         for eq in get_equations(expr, other):\n468             # Unsatisfiable equation?\n469             if eq is False:\n470                 return False\n471             equations.append(eq)\n472 \n473         # Map the symbols in the signature to the corresponding domains\n474         symsetmap = get_symsetmap(sig, base_sets)\n475         if symsetmap is None:\n476             # Can't factor the base sets to a ProductSet\n477             return None\n478 \n479         # Which of the variables in the Lambda signature need to be solved for?\n480         symss = (eq.free_symbols for eq in equations)\n481         variables = set(variables) & reduce(set.union, symss, set())\n482 \n483         # Use internal multivariate solveset\n484         variables = tuple(variables)\n485         base_sets = [symsetmap[v] for v in variables]\n486         solnset = _solveset_multi(equations, variables, base_sets)\n487         if solnset is None:\n488             return None\n489         return fuzzy_not(solnset.is_empty)\n490 \n491     @property\n492     def is_iterable(self):\n493         return all(s.is_iterable for s in self.base_sets)\n494 \n495     def doit(self, **kwargs):\n496         from sympy.sets.setexpr import SetExpr\n497         f = self.lamda\n498         sig = f.signature\n499         if len(sig) == 1 and sig[0].is_symbol and isinstance(f.expr, Expr):\n500             base_set = self.base_sets[0]\n501             return SetExpr(base_set)._eval_func(f).set\n502         if all(s.is_FiniteSet for s in self.base_sets):\n503             return FiniteSet(*(f(*a) for a in cartes(*self.base_sets)))\n504         return self\n505 \n506 \n507 class Range(Set):\n508     \"\"\"\n509     Represents a range of integers. Can be called as Range(stop),\n510     Range(start, stop), or Range(start, stop, step); when step is\n511     not given it defaults to 1.\n512 \n513     `Range(stop)` is the same as `Range(0, stop, 1)` and the stop value\n514     (juse as for Python ranges) is not included in the Range values.\n515 \n516         >>> from sympy import Range\n517         >>> list(Range(3))\n518         [0, 1, 2]\n519 \n520     The step can also be negative:\n521 \n522         >>> list(Range(10, 0, -2))\n523         [10, 8, 6, 4, 2]\n524 \n525     The stop value is made canonical so equivalent ranges always\n526     have the same args:\n527 \n528         >>> Range(0, 10, 3)\n529         Range(0, 12, 3)\n530 \n531     Infinite ranges are allowed. ``oo`` and ``-oo`` are never included in the\n532     set (``Range`` is always a subset of ``Integers``). If the starting point\n533     is infinite, then the final value is ``stop - step``. To iterate such a\n534     range, it needs to be reversed:\n535 \n536         >>> from sympy import oo\n537         >>> r = Range(-oo, 1)\n538         >>> r[-1]\n539         0\n540         >>> next(iter(r))\n541         Traceback (most recent call last):\n542         ...\n543         TypeError: Cannot iterate over Range with infinite start\n544         >>> next(iter(r.reversed))\n545         0\n546 \n547     Although Range is a set (and supports the normal set\n548     operations) it maintains the order of the elements and can\n549     be used in contexts where `range` would be used.\n550 \n551         >>> from sympy import Interval\n552         >>> Range(0, 10, 2).intersect(Interval(3, 7))\n553         Range(4, 8, 2)\n554         >>> list(_)\n555         [4, 6]\n556 \n557     Although slicing of a Range will always return a Range -- possibly\n558     empty -- an empty set will be returned from any intersection that\n559     is empty:\n560 \n561         >>> Range(3)[:0]\n562         Range(0, 0, 1)\n563         >>> Range(3).intersect(Interval(4, oo))\n564         EmptySet\n565         >>> Range(3).intersect(Range(4, oo))\n566         EmptySet\n567 \n568     Range will accept symbolic arguments but has very limited support\n569     for doing anything other than displaying the Range:\n570 \n571         >>> from sympy import Symbol, pprint\n572         >>> from sympy.abc import i, j, k\n573         >>> Range(i, j, k).start\n574         i\n575         >>> Range(i, j, k).inf\n576         Traceback (most recent call last):\n577         ...\n578         ValueError: invalid method for symbolic range\n579 \n580     Better success will be had when using integer symbols:\n581 \n582         >>> n = Symbol('n', integer=True)\n583         >>> r = Range(n, n + 20, 3)\n584         >>> r.inf\n585         n\n586         >>> pprint(r)\n587         {n, n + 3, ..., n + 18}\n588     \"\"\"\n589 \n590     is_iterable = True\n591 \n592     def __new__(cls, *args):\n593         from sympy.functions.elementary.integers import ceiling\n594         if len(args) == 1:\n595             if isinstance(args[0], range):\n596                 raise TypeError(\n597                     'use sympify(%s) to convert range to Range' % args[0])\n598 \n599         # expand range\n600         slc = slice(*args)\n601 \n602         if slc.step == 0:\n603             raise ValueError(\"step cannot be 0\")\n604 \n605         start, stop, step = slc.start or 0, slc.stop, slc.step or 1\n606         try:\n607             ok = []\n608             for w in (start, stop, step):\n609                 w = sympify(w)\n610                 if w in [S.NegativeInfinity, S.Infinity] or (\n611                         w.has(Symbol) and w.is_integer != False):\n612                     ok.append(w)\n613                 elif not w.is_Integer:\n614                     if w.is_infinite:\n615                         raise ValueError('infinite symbols not allowed')\n616                     raise ValueError\n617                 else:\n618                     ok.append(w)\n619         except ValueError:\n620             raise ValueError(filldedent('''\n621     Finite arguments to Range must be integers; `imageset` can define\n622     other cases, e.g. use `imageset(i, i/10, Range(3))` to give\n623     [0, 1/10, 1/5].'''))\n624         start, stop, step = ok\n625 \n626         null = False\n627         if any(i.has(Symbol) for i in (start, stop, step)):\n628             dif = stop - start\n629             n = dif/step\n630             if n.is_Rational:\n631                 from sympy import floor\n632                 if dif == 0:\n633                     null = True\n634                 else:  # (x, x + 5, 2) or (x, 3*x, x)\n635                     n = floor(n)\n636                     end = start + n*step\n637                     if dif.is_Rational:  # (x, x + 5, 2)\n638                         if (end - stop).is_negative:\n639                             end += step\n640                     else:  # (x, 3*x, x)\n641                         if (end/stop - 1).is_negative:\n642                             end += step\n643             elif n.is_extended_negative:\n644                 null = True\n645             else:\n646                 end = stop  # other methods like sup and reversed must fail\n647         elif start.is_infinite:\n648             span = step*(stop - start)\n649             if span is S.NaN or span <= 0:\n650                 null = True\n651             elif step.is_Integer and stop.is_infinite and abs(step) != 1:\n652                 raise ValueError(filldedent('''\n653                     Step size must be %s in this case.''' % (1 if step > 0 else -1)))\n654             else:\n655                 end = stop\n656         else:\n657             oostep = step.is_infinite\n658             if oostep:\n659                 step = S.One if step > 0 else S.NegativeOne\n660             n = ceiling((stop - start)/step)\n661             if n <= 0:\n662                 null = True\n663             elif oostep:\n664                 step = S.One  # make it canonical\n665                 end = start + step\n666             else:\n667                 end = start + n*step\n668         if null:\n669             start = end = S.Zero\n670             step = S.One\n671         return Basic.__new__(cls, start, end, step)\n672 \n673     start = property(lambda self: self.args[0])\n674     stop = property(lambda self: self.args[1])\n675     step = property(lambda self: self.args[2])\n676 \n677     @property\n678     def reversed(self):\n679         \"\"\"Return an equivalent Range in the opposite order.\n680 \n681         Examples\n682         ========\n683 \n684         >>> from sympy import Range\n685         >>> Range(10).reversed\n686         Range(9, -1, -1)\n687         \"\"\"\n688         if self.has(Symbol):\n689             n = (self.stop - self.start)/self.step\n690             if not n.is_extended_positive or not all(\n691                     i.is_integer or i.is_infinite for i in self.args):\n692                 raise ValueError('invalid method for symbolic range')\n693         if self.start == self.stop:\n694             return self\n695         return self.func(\n696             self.stop - self.step, self.start - self.step, -self.step)\n697 \n698     def _contains(self, other):\n699         if self.start == self.stop:\n700             return S.false\n701         if other.is_infinite:\n702             return S.false\n703         if not other.is_integer:\n704             return other.is_integer\n705         if self.has(Symbol):\n706             n = (self.stop - self.start)/self.step\n707             if not n.is_extended_positive or not all(\n708                     i.is_integer or i.is_infinite for i in self.args):\n709                 return\n710         else:\n711             n = self.size\n712         if self.start.is_finite:\n713             ref = self.start\n714         elif self.stop.is_finite:\n715             ref = self.stop\n716         else:  # both infinite; step is +/- 1 (enforced by __new__)\n717             return S.true\n718         if n == 1:\n719             return Eq(other, self[0])\n720         res = (ref - other) % self.step\n721         if res == S.Zero:\n722             if self.has(Symbol):\n723                 d = Dummy('i')\n724                 return self.as_relational(d).subs(d, other)\n725             return And(other >= self.inf, other <= self.sup)\n726         elif res.is_Integer:  # off sequence\n727             return S.false\n728         else:  # symbolic/unsimplified residue modulo step\n729             return None\n730 \n731     def __iter__(self):\n732         n = self.size  # validate\n733         if self.start in [S.NegativeInfinity, S.Infinity]:\n734             raise TypeError(\"Cannot iterate over Range with infinite start\")\n735         elif self.start != self.stop:\n736             i = self.start\n737             if n.is_infinite:\n738                 while True:\n739                     yield i\n740                     i += self.step\n741             else:\n742                 for j in range(n):\n743                     yield i\n744                     i += self.step\n745 \n746     def __len__(self):\n747         rv = self.size\n748         if rv is S.Infinity:\n749             raise ValueError('Use .size to get the length of an infinite Range')\n750         return int(rv)\n751 \n752     @property\n753     def size(self):\n754         if self.start == self.stop:\n755             return S.Zero\n756         dif = self.stop - self.start\n757         n = dif/self.step\n758         if n.is_infinite:\n759             return S.Infinity\n760         if not n.is_Integer or not all(i.is_integer for i in self.args):\n761             raise ValueError('invalid method for symbolic range')\n762         return abs(n)\n763 \n764     @property\n765     def is_finite_set(self):\n766         if self.start.is_integer and self.stop.is_integer:\n767             return True\n768         return self.size.is_finite\n769 \n770     def __bool__(self):\n771         # this only distinguishes between definite null range\n772         # and non-null/unknown null; getting True doesn't mean\n773         # that it actually is not null\n774         b = is_eq(self.start, self.stop)\n775         if b is None:\n776             raise ValueError('cannot tell if Range is null or not')\n777         return not bool(b)\n778 \n779     def __getitem__(self, i):\n780         from sympy.functions.elementary.integers import ceiling\n781         ooslice = \"cannot slice from the end with an infinite value\"\n782         zerostep = \"slice step cannot be zero\"\n783         infinite = \"slicing not possible on range with infinite start\"\n784         # if we had to take every other element in the following\n785         # oo, ..., 6, 4, 2, 0\n786         # we might get oo, ..., 4, 0 or oo, ..., 6, 2\n787         ambiguous = \"cannot unambiguously re-stride from the end \" + \\\n788             \"with an infinite value\"\n789         if isinstance(i, slice):\n790             if self.size.is_finite:  # validates, too\n791                 if self.start == self.stop:\n792                     return Range(0)\n793                 start, stop, step = i.indices(self.size)\n794                 n = ceiling((stop - start)/step)\n795                 if n <= 0:\n796                     return Range(0)\n797                 canonical_stop = start + n*step\n798                 end = canonical_stop - step\n799                 ss = step*self.step\n800                 return Range(self[start], self[end] + ss, ss)\n801             else:  # infinite Range\n802                 start = i.start\n803                 stop = i.stop\n804                 if i.step == 0:\n805                     raise ValueError(zerostep)\n806                 step = i.step or 1\n807                 ss = step*self.step\n808                 #---------------------\n809                 # handle infinite Range\n810                 #   i.e. Range(-oo, oo) or Range(oo, -oo, -1)\n811                 # --------------------\n812                 if self.start.is_infinite and self.stop.is_infinite:\n813                     raise ValueError(infinite)\n814                 #---------------------\n815                 # handle infinite on right\n816                 #   e.g. Range(0, oo) or Range(0, -oo, -1)\n817                 # --------------------\n818                 if self.stop.is_infinite:\n819                     # start and stop are not interdependent --\n820                     # they only depend on step --so we use the\n821                     # equivalent reversed values\n822                     return self.reversed[\n823                         stop if stop is None else -stop + 1:\n824                         start if start is None else -start:\n825                         step].reversed\n826                 #---------------------\n827                 # handle infinite on the left\n828                 #   e.g. Range(oo, 0, -1) or Range(-oo, 0)\n829                 # --------------------\n830                 # consider combinations of\n831                 # start/stop {== None, < 0, == 0, > 0} and\n832                 # step {< 0, > 0}\n833                 if start is None:\n834                     if stop is None:\n835                         if step < 0:\n836                             return Range(self[-1], self.start, ss)\n837                         elif step > 1:\n838                             raise ValueError(ambiguous)\n839                         else:  # == 1\n840                             return self\n841                     elif stop < 0:\n842                         if step < 0:\n843                             return Range(self[-1], self[stop], ss)\n844                         else:  # > 0\n845                             return Range(self.start, self[stop], ss)\n846                     elif stop == 0:\n847                         if step > 0:\n848                             return Range(0)\n849                         else:  # < 0\n850                             raise ValueError(ooslice)\n851                     elif stop == 1:\n852                         if step > 0:\n853                             raise ValueError(ooslice)  # infinite singleton\n854                         else:  # < 0\n855                             raise ValueError(ooslice)\n856                     else:  # > 1\n857                         raise ValueError(ooslice)\n858                 elif start < 0:\n859                     if stop is None:\n860                         if step < 0:\n861                             return Range(self[start], self.start, ss)\n862                         else:  # > 0\n863                             return Range(self[start], self.stop, ss)\n864                     elif stop < 0:\n865                         return Range(self[start], self[stop], ss)\n866                     elif stop == 0:\n867                         if step < 0:\n868                             raise ValueError(ooslice)\n869                         else:  # > 0\n870                             return Range(0)\n871                     elif stop > 0:\n872                         raise ValueError(ooslice)\n873                 elif start == 0:\n874                     if stop is None:\n875                         if step < 0:\n876                             raise ValueError(ooslice)  # infinite singleton\n877                         elif step > 1:\n878                             raise ValueError(ambiguous)\n879                         else:  # == 1\n880                             return self\n881                     elif stop < 0:\n882                         if step > 1:\n883                             raise ValueError(ambiguous)\n884                         elif step == 1:\n885                             return Range(self.start, self[stop], ss)\n886                         else:  # < 0\n887                             return Range(0)\n888                     else:  # >= 0\n889                         raise ValueError(ooslice)\n890                 elif start > 0:\n891                     raise ValueError(ooslice)\n892         else:\n893             if self.start == self.stop:\n894                 raise IndexError('Range index out of range')\n895             if not (all(i.is_integer or i.is_infinite\n896                     for i in self.args) and ((self.stop - self.start)/\n897                     self.step).is_extended_positive):\n898                 raise ValueError('invalid method for symbolic range')\n899             if i == 0:\n900                 if self.start.is_infinite:\n901                     raise ValueError(ooslice)\n902                 return self.start\n903             if i == -1:\n904                 if self.stop.is_infinite:\n905                     raise ValueError(ooslice)\n906                 return self.stop - self.step\n907             n = self.size  # must be known for any other index\n908             rv = (self.stop if i < 0 else self.start) + i*self.step\n909             if rv.is_infinite:\n910                 raise ValueError(ooslice)\n911             if 0 <= (rv - self.start)/self.step <= n:\n912                 return rv\n913             raise IndexError(\"Range index out of range\")\n914 \n915     @property\n916     def _inf(self):\n917         if not self:\n918             return S.EmptySet.inf\n919         if self.has(Symbol):\n920             if all(i.is_integer or i.is_infinite for i in self.args):\n921                 dif = self.stop - self.start\n922                 if self.step.is_positive and dif.is_positive:\n923                     return self.start\n924                 elif self.step.is_negative and dif.is_negative:\n925                     return self.stop - self.step\n926             raise ValueError('invalid method for symbolic range')\n927         if self.step > 0:\n928             return self.start\n929         else:\n930             return self.stop - self.step\n931 \n932     @property\n933     def _sup(self):\n934         if not self:\n935             return S.EmptySet.sup\n936         if self.has(Symbol):\n937             if all(i.is_integer or i.is_infinite for i in self.args):\n938                 dif = self.stop - self.start\n939                 if self.step.is_positive and dif.is_positive:\n940                     return self.stop - self.step\n941                 elif self.step.is_negative and dif.is_negative:\n942                     return self.start\n943             raise ValueError('invalid method for symbolic range')\n944         if self.step > 0:\n945             return self.stop - self.step\n946         else:\n947             return self.start\n948 \n949     @property\n950     def _boundary(self):\n951         return self\n952 \n953     def as_relational(self, x):\n954         \"\"\"Rewrite a Range in terms of equalities and logic operators. \"\"\"\n955         from sympy.core.mod import Mod\n956         if self.start.is_infinite:\n957             assert not self.stop.is_infinite  # by instantiation\n958             a = self.reversed.start\n959         else:\n960             a = self.start\n961         step = self.step\n962         in_seq = Eq(Mod(x - a, step), 0)\n963         ints = And(Eq(Mod(a, 1), 0), Eq(Mod(step, 1), 0))\n964         n = (self.stop - self.start)/self.step\n965         if n == 0:\n966             return S.EmptySet.as_relational(x)\n967         if n == 1:\n968             return And(Eq(x, a), ints)\n969         try:\n970             a, b = self.inf, self.sup\n971         except ValueError:\n972             a = None\n973         if a is not None:\n974             range_cond = And(\n975                 x > a if a.is_infinite else x >= a,\n976                 x < b if b.is_infinite else x <= b)\n977         else:\n978             a, b = self.start, self.stop - self.step\n979             range_cond = Or(\n980                 And(self.step >= 1, x > a if a.is_infinite else x >= a,\n981                 x < b if b.is_infinite else x <= b),\n982                 And(self.step <= -1, x < a if a.is_infinite else x <= a,\n983                 x > b if b.is_infinite else x >= b))\n984         return And(in_seq, ints, range_cond)\n985 \n986 \n987 converter[range] = lambda r: Range(r.start, r.stop, r.step)\n988 \n989 def normalize_theta_set(theta):\n990     \"\"\"\n991     Normalize a Real Set `theta` in the Interval [0, 2*pi). It returns\n992     a normalized value of theta in the Set. For Interval, a maximum of\n993     one cycle [0, 2*pi], is returned i.e. for theta equal to [0, 10*pi],\n994     returned normalized value would be [0, 2*pi). As of now intervals\n995     with end points as non-multiples of `pi` is not supported.\n996 \n997     Raises\n998     ======\n999 \n1000     NotImplementedError\n1001         The algorithms for Normalizing theta Set are not yet\n1002         implemented.\n1003     ValueError\n1004         The input is not valid, i.e. the input is not a real set.\n1005     RuntimeError\n1006         It is a bug, please report to the github issue tracker.\n1007 \n1008     Examples\n1009     ========\n1010 \n1011     >>> from sympy.sets.fancysets import normalize_theta_set\n1012     >>> from sympy import Interval, FiniteSet, pi\n1013     >>> normalize_theta_set(Interval(9*pi/2, 5*pi))\n1014     Interval(pi/2, pi)\n1015     >>> normalize_theta_set(Interval(-3*pi/2, pi/2))\n1016     Interval.Ropen(0, 2*pi)\n1017     >>> normalize_theta_set(Interval(-pi/2, pi/2))\n1018     Union(Interval(0, pi/2), Interval.Ropen(3*pi/2, 2*pi))\n1019     >>> normalize_theta_set(Interval(-4*pi, 3*pi))\n1020     Interval.Ropen(0, 2*pi)\n1021     >>> normalize_theta_set(Interval(-3*pi/2, -pi/2))\n1022     Interval(pi/2, 3*pi/2)\n1023     >>> normalize_theta_set(FiniteSet(0, pi, 3*pi))\n1024     FiniteSet(0, pi)\n1025 \n1026     \"\"\"\n1027     from sympy.functions.elementary.trigonometric import _pi_coeff as coeff\n1028 \n1029     if theta.is_Interval:\n1030         interval_len = theta.measure\n1031         # one complete circle\n1032         if interval_len >= 2*S.Pi:\n1033             if interval_len == 2*S.Pi and theta.left_open and theta.right_open:\n1034                 k = coeff(theta.start)\n1035                 return Union(Interval(0, k*S.Pi, False, True),\n1036                         Interval(k*S.Pi, 2*S.Pi, True, True))\n1037             return Interval(0, 2*S.Pi, False, True)\n1038 \n1039         k_start, k_end = coeff(theta.start), coeff(theta.end)\n1040 \n1041         if k_start is None or k_end is None:\n1042             raise NotImplementedError(\"Normalizing theta without pi as coefficient is \"\n1043                                     \"not yet implemented\")\n1044         new_start = k_start*S.Pi\n1045         new_end = k_end*S.Pi\n1046 \n1047         if new_start > new_end:\n1048             return Union(Interval(S.Zero, new_end, False, theta.right_open),\n1049                          Interval(new_start, 2*S.Pi, theta.left_open, True))\n1050         else:\n1051             return Interval(new_start, new_end, theta.left_open, theta.right_open)\n1052 \n1053     elif theta.is_FiniteSet:\n1054         new_theta = []\n1055         for element in theta:\n1056             k = coeff(element)\n1057             if k is None:\n1058                 raise NotImplementedError('Normalizing theta without pi as '\n1059                                           'coefficient, is not Implemented.')\n1060             else:\n1061                 new_theta.append(k*S.Pi)\n1062         return FiniteSet(*new_theta)\n1063 \n1064     elif theta.is_Union:\n1065         return Union(*[normalize_theta_set(interval) for interval in theta.args])\n1066 \n1067     elif theta.is_subset(S.Reals):\n1068         raise NotImplementedError(\"Normalizing theta when, it is of type %s is not \"\n1069                                   \"implemented\" % type(theta))\n1070     else:\n1071         raise ValueError(\" %s is not a real set\" % (theta))\n1072 \n1073 \n1074 class ComplexRegion(Set):\n1075     \"\"\"\n1076     Represents the Set of all Complex Numbers. It can represent a\n1077     region of Complex Plane in both the standard forms Polar and\n1078     Rectangular coordinates.\n1079 \n1080     * Polar Form\n1081       Input is in the form of the ProductSet or Union of ProductSets\n1082       of the intervals of r and theta, & use the flag polar=True.\n1083 \n1084     Z = {z in C | z = r*[cos(theta) + I*sin(theta)], r in [r], theta in [theta]}\n1085 \n1086     * Rectangular Form\n1087       Input is in the form of the ProductSet or Union of ProductSets\n1088       of interval of x and y the of the Complex numbers in a Plane.\n1089       Default input type is in rectangular form.\n1090 \n1091     Z = {z in C | z = x + I*y, x in [Re(z)], y in [Im(z)]}\n1092 \n1093     Examples\n1094     ========\n1095 \n1096     >>> from sympy.sets.fancysets import ComplexRegion\n1097     >>> from sympy.sets import Interval\n1098     >>> from sympy import S, I, Union\n1099     >>> a = Interval(2, 3)\n1100     >>> b = Interval(4, 6)\n1101     >>> c = Interval(1, 8)\n1102     >>> c1 = ComplexRegion(a*b)  # Rectangular Form\n1103     >>> c1\n1104     CartesianComplexRegion(ProductSet(Interval(2, 3), Interval(4, 6)))\n1105 \n1106     * c1 represents the rectangular region in complex plane\n1107       surrounded by the coordinates (2, 4), (3, 4), (3, 6) and\n1108       (2, 6), of the four vertices.\n1109 \n1110     >>> c2 = ComplexRegion(Union(a*b, b*c))\n1111     >>> c2\n1112     CartesianComplexRegion(Union(ProductSet(Interval(2, 3), Interval(4, 6)), ProductSet(Interval(4, 6), Interval(1, 8))))\n1113 \n1114     * c2 represents the Union of two rectangular regions in complex\n1115       plane. One of them surrounded by the coordinates of c1 and\n1116       other surrounded by the coordinates (4, 1), (6, 1), (6, 8) and\n1117       (4, 8).\n1118 \n1119     >>> 2.5 + 4.5*I in c1\n1120     True\n1121     >>> 2.5 + 6.5*I in c1\n1122     False\n1123 \n1124     >>> r = Interval(0, 1)\n1125     >>> theta = Interval(0, 2*S.Pi)\n1126     >>> c2 = ComplexRegion(r*theta, polar=True)  # Polar Form\n1127     >>> c2  # unit Disk\n1128     PolarComplexRegion(ProductSet(Interval(0, 1), Interval.Ropen(0, 2*pi)))\n1129 \n1130     * c2 represents the region in complex plane inside the\n1131       Unit Disk centered at the origin.\n1132 \n1133     >>> 0.5 + 0.5*I in c2\n1134     True\n1135     >>> 1 + 2*I in c2\n1136     False\n1137 \n1138     >>> unit_disk = ComplexRegion(Interval(0, 1)*Interval(0, 2*S.Pi), polar=True)\n1139     >>> upper_half_unit_disk = ComplexRegion(Interval(0, 1)*Interval(0, S.Pi), polar=True)\n1140     >>> intersection = unit_disk.intersect(upper_half_unit_disk)\n1141     >>> intersection\n1142     PolarComplexRegion(ProductSet(Interval(0, 1), Interval(0, pi)))\n1143     >>> intersection == upper_half_unit_disk\n1144     True\n1145 \n1146     See Also\n1147     ========\n1148 \n1149     CartesianComplexRegion\n1150     PolarComplexRegion\n1151     Complexes\n1152 \n1153     \"\"\"\n1154     is_ComplexRegion = True\n1155 \n1156     def __new__(cls, sets, polar=False):\n1157         if polar is False:\n1158             return CartesianComplexRegion(sets)\n1159         elif polar is True:\n1160             return PolarComplexRegion(sets)\n1161         else:\n1162             raise ValueError(\"polar should be either True or False\")\n1163 \n1164     @property\n1165     def sets(self):\n1166         \"\"\"\n1167         Return raw input sets to the self.\n1168 \n1169         Examples\n1170         ========\n1171 \n1172         >>> from sympy import Interval, ComplexRegion, Union\n1173         >>> a = Interval(2, 3)\n1174         >>> b = Interval(4, 5)\n1175         >>> c = Interval(1, 7)\n1176         >>> C1 = ComplexRegion(a*b)\n1177         >>> C1.sets\n1178         ProductSet(Interval(2, 3), Interval(4, 5))\n1179         >>> C2 = ComplexRegion(Union(a*b, b*c))\n1180         >>> C2.sets\n1181         Union(ProductSet(Interval(2, 3), Interval(4, 5)), ProductSet(Interval(4, 5), Interval(1, 7)))\n1182 \n1183         \"\"\"\n1184         return self.args[0]\n1185 \n1186     @property\n1187     def psets(self):\n1188         \"\"\"\n1189         Return a tuple of sets (ProductSets) input of the self.\n1190 \n1191         Examples\n1192         ========\n1193 \n1194         >>> from sympy import Interval, ComplexRegion, Union\n1195         >>> a = Interval(2, 3)\n1196         >>> b = Interval(4, 5)\n1197         >>> c = Interval(1, 7)\n1198         >>> C1 = ComplexRegion(a*b)\n1199         >>> C1.psets\n1200         (ProductSet(Interval(2, 3), Interval(4, 5)),)\n1201         >>> C2 = ComplexRegion(Union(a*b, b*c))\n1202         >>> C2.psets\n1203         (ProductSet(Interval(2, 3), Interval(4, 5)), ProductSet(Interval(4, 5), Interval(1, 7)))\n1204 \n1205         \"\"\"\n1206         if self.sets.is_ProductSet:\n1207             psets = ()\n1208             psets = psets + (self.sets, )\n1209         else:\n1210             psets = self.sets.args\n1211         return psets\n1212 \n1213     @property\n1214     def a_interval(self):\n1215         \"\"\"\n1216         Return the union of intervals of `x` when, self is in\n1217         rectangular form, or the union of intervals of `r` when\n1218         self is in polar form.\n1219 \n1220         Examples\n1221         ========\n1222 \n1223         >>> from sympy import Interval, ComplexRegion, Union\n1224         >>> a = Interval(2, 3)\n1225         >>> b = Interval(4, 5)\n1226         >>> c = Interval(1, 7)\n1227         >>> C1 = ComplexRegion(a*b)\n1228         >>> C1.a_interval\n1229         Interval(2, 3)\n1230         >>> C2 = ComplexRegion(Union(a*b, b*c))\n1231         >>> C2.a_interval\n1232         Union(Interval(2, 3), Interval(4, 5))\n1233 \n1234         \"\"\"\n1235         a_interval = []\n1236         for element in self.psets:\n1237             a_interval.append(element.args[0])\n1238 \n1239         a_interval = Union(*a_interval)\n1240         return a_interval\n1241 \n1242     @property\n1243     def b_interval(self):\n1244         \"\"\"\n1245         Return the union of intervals of `y` when, self is in\n1246         rectangular form, or the union of intervals of `theta`\n1247         when self is in polar form.\n1248 \n1249         Examples\n1250         ========\n1251 \n1252         >>> from sympy import Interval, ComplexRegion, Union\n1253         >>> a = Interval(2, 3)\n1254         >>> b = Interval(4, 5)\n1255         >>> c = Interval(1, 7)\n1256         >>> C1 = ComplexRegion(a*b)\n1257         >>> C1.b_interval\n1258         Interval(4, 5)\n1259         >>> C2 = ComplexRegion(Union(a*b, b*c))\n1260         >>> C2.b_interval\n1261         Interval(1, 7)\n1262 \n1263         \"\"\"\n1264         b_interval = []\n1265         for element in self.psets:\n1266             b_interval.append(element.args[1])\n1267 \n1268         b_interval = Union(*b_interval)\n1269         return b_interval\n1270 \n1271     @property\n1272     def _measure(self):\n1273         \"\"\"\n1274         The measure of self.sets.\n1275 \n1276         Examples\n1277         ========\n1278 \n1279         >>> from sympy import Interval, ComplexRegion, S\n1280         >>> a, b = Interval(2, 5), Interval(4, 8)\n1281         >>> c = Interval(0, 2*S.Pi)\n1282         >>> c1 = ComplexRegion(a*b)\n1283         >>> c1.measure\n1284         12\n1285         >>> c2 = ComplexRegion(a*c, polar=True)\n1286         >>> c2.measure\n1287         6*pi\n1288 \n1289         \"\"\"\n1290         return self.sets._measure\n1291 \n1292     @classmethod\n1293     def from_real(cls, sets):\n1294         \"\"\"\n1295         Converts given subset of real numbers to a complex region.\n1296 \n1297         Examples\n1298         ========\n1299 \n1300         >>> from sympy import Interval, ComplexRegion\n1301         >>> unit = Interval(0,1)\n1302         >>> ComplexRegion.from_real(unit)\n1303         CartesianComplexRegion(ProductSet(Interval(0, 1), FiniteSet(0)))\n1304 \n1305         \"\"\"\n1306         if not sets.is_subset(S.Reals):\n1307             raise ValueError(\"sets must be a subset of the real line\")\n1308 \n1309         return CartesianComplexRegion(sets * FiniteSet(0))\n1310 \n1311     def _contains(self, other):\n1312         from sympy.functions import arg, Abs\n1313         from sympy.core.containers import Tuple\n1314         other = sympify(other)\n1315         isTuple = isinstance(other, Tuple)\n1316         if isTuple and len(other) != 2:\n1317             raise ValueError('expecting Tuple of length 2')\n1318 \n1319         # If the other is not an Expression, and neither a Tuple\n1320         if not isinstance(other, Expr) and not isinstance(other, Tuple):\n1321             return S.false\n1322         # self in rectangular form\n1323         if not self.polar:\n1324             re, im = other if isTuple else other.as_real_imag()\n1325             return fuzzy_or(fuzzy_and([\n1326                 pset.args[0]._contains(re),\n1327                 pset.args[1]._contains(im)])\n1328                 for pset in self.psets)\n1329 \n1330         # self in polar form\n1331         elif self.polar:\n1332             if other.is_zero:\n1333                 # ignore undefined complex argument\n1334                 return fuzzy_or(pset.args[0]._contains(S.Zero)\n1335                     for pset in self.psets)\n1336             if isTuple:\n1337                 r, theta = other\n1338             else:\n1339                 r, theta = Abs(other), arg(other)\n1340             if theta.is_real and theta.is_number:\n1341                 # angles in psets are normalized to [0, 2pi)\n1342                 theta %= 2*S.Pi\n1343                 return fuzzy_or(fuzzy_and([\n1344                     pset.args[0]._contains(r),\n1345                     pset.args[1]._contains(theta)])\n1346                     for pset in self.psets)\n1347 \n1348 \n1349 class CartesianComplexRegion(ComplexRegion):\n1350     \"\"\"\n1351     Set representing a square region of the complex plane.\n1352 \n1353     Z = {z in C | z = x + I*y, x in [Re(z)], y in [Im(z)]}\n1354 \n1355     Examples\n1356     ========\n1357 \n1358     >>> from sympy.sets.fancysets import ComplexRegion\n1359     >>> from sympy.sets.sets import Interval\n1360     >>> from sympy import I\n1361     >>> region = ComplexRegion(Interval(1, 3) * Interval(4, 6))\n1362     >>> 2 + 5*I in region\n1363     True\n1364     >>> 5*I in region\n1365     False\n1366 \n1367     See also\n1368     ========\n1369 \n1370     ComplexRegion\n1371     PolarComplexRegion\n1372     Complexes\n1373     \"\"\"\n1374 \n1375     polar = False\n1376     variables = symbols('x, y', cls=Dummy)\n1377 \n1378     def __new__(cls, sets):\n1379 \n1380         if sets == S.Reals*S.Reals:\n1381             return S.Complexes\n1382 \n1383         if all(_a.is_FiniteSet for _a in sets.args) and (len(sets.args) == 2):\n1384 \n1385             # ** ProductSet of FiniteSets in the Complex Plane. **\n1386             # For Cases like ComplexRegion({2, 4}*{3}), It\n1387             # would return {2 + 3*I, 4 + 3*I}\n1388 \n1389             # FIXME: This should probably be handled with something like:\n1390             # return ImageSet(Lambda((x, y), x+I*y), sets).rewrite(FiniteSet)\n1391             complex_num = []\n1392             for x in sets.args[0]:\n1393                 for y in sets.args[1]:\n1394                     complex_num.append(x + S.ImaginaryUnit*y)\n1395             return FiniteSet(*complex_num)\n1396         else:\n1397             return Set.__new__(cls, sets)\n1398 \n1399     @property\n1400     def expr(self):\n1401         x, y = self.variables\n1402         return x + S.ImaginaryUnit*y\n1403 \n1404 \n1405 class PolarComplexRegion(ComplexRegion):\n1406     \"\"\"\n1407     Set representing a polar region of the complex plane.\n1408 \n1409     Z = {z in C | z = r*[cos(theta) + I*sin(theta)], r in [r], theta in [theta]}\n1410 \n1411     Examples\n1412     ========\n1413 \n1414     >>> from sympy.sets.fancysets import ComplexRegion, Interval\n1415     >>> from sympy import oo, pi, I\n1416     >>> rset = Interval(0, oo)\n1417     >>> thetaset = Interval(0, pi)\n1418     >>> upper_half_plane = ComplexRegion(rset * thetaset, polar=True)\n1419     >>> 1 + I in upper_half_plane\n1420     True\n1421     >>> 1 - I in upper_half_plane\n1422     False\n1423 \n1424     See also\n1425     ========\n1426 \n1427     ComplexRegion\n1428     CartesianComplexRegion\n1429     Complexes\n1430 \n1431     \"\"\"\n1432 \n1433     polar = True\n1434     variables = symbols('r, theta', cls=Dummy)\n1435 \n1436     def __new__(cls, sets):\n1437 \n1438         new_sets = []\n1439         # sets is Union of ProductSets\n1440         if not sets.is_ProductSet:\n1441             for k in sets.args:\n1442                 new_sets.append(k)\n1443         # sets is ProductSets\n1444         else:\n1445             new_sets.append(sets)\n1446         # Normalize input theta\n1447         for k, v in enumerate(new_sets):\n1448             new_sets[k] = ProductSet(v.args[0],\n1449                                      normalize_theta_set(v.args[1]))\n1450         sets = Union(*new_sets)\n1451         return Set.__new__(cls, sets)\n1452 \n1453     @property\n1454     def expr(self):\n1455         from sympy.functions.elementary.trigonometric import sin, cos\n1456         r, theta = self.variables\n1457         return r*(cos(theta) + S.ImaginaryUnit*sin(theta))\n1458 \n1459 \n1460 class Complexes(CartesianComplexRegion, metaclass=Singleton):\n1461     \"\"\"\n1462     The Set of all complex numbers\n1463 \n1464     Examples\n1465     ========\n1466 \n1467     >>> from sympy import S, I\n1468     >>> S.Complexes\n1469     Complexes\n1470     >>> 1 + I in S.Complexes\n1471     True\n1472 \n1473     See also\n1474     ========\n1475 \n1476     Reals\n1477     ComplexRegion\n1478 \n1479     \"\"\"\n1480 \n1481     is_empty = False\n1482     is_finite_set = False\n1483 \n1484     # Override property from superclass since Complexes has no args\n1485     @property\n1486     def sets(self):\n1487         return ProductSet(S.Reals, S.Reals)\n1488 \n1489     def __new__(cls):\n1490         return Set.__new__(cls)\n1491 \n1492     def __str__(self):\n1493         return \"S.Complexes\"\n1494 \n1495     def __repr__(self):\n1496         return \"S.Complexes\"\n",
        "intended_behavior": "This method should ensure that intersections between an ImageSet producing complex numbers and Reals are accurately calculated, excluding any non-real numbers from the results. This may require implementing a check within the intersection logic to explicitly determine if a given element from an ImageSet is real before including it in the result set when intersecting with Reals. Enhancing the logic to understand and simplify complex expressions better, to accurately determine their real-number status in an intersection scenario."
    }
]