2025-10-18 06:09:15.904 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-18 06:09:20.390 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=367, output_tokens=12, cost=0.004030
2025-10-18 06:09:35.759 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=547, output_tokens=631, cost=0.024400
2025-10-18 06:09:36.777 | INFO     | registered non reproducing test 0
2025-10-18 06:10:01.511 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1713, output_tokens=896, cost=0.044010
2025-10-18 06:10:19.961 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1713, output_tokens=883, cost=0.043620
2025-10-18 06:10:20.940 | INFO     | registered non reproducing test 2
2025-10-18 06:10:20.940 | WARNING  | Failed to write a reproducer test; skipping reproducer tracing
2025-10-18 06:10:20.947 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 06:10:25.712 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=671, output_tokens=198, cost=0.012650
2025-10-18 06:10:25.717 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 06:10:29.118 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=552, output_tokens=43, cost=0.006810
2025-10-18 06:10:29.119 | DEBUG    | Extracted a valid json.
2025-10-18 06:10:29.119 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_code(\"footnote\")",
        "search_code(\"rst\")",
        "search_code(\"latexpdf\")"
    ],
    "bug_locations": []
}
2025-10-18 06:10:29.538 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 06:10:29.539 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 06:10:44.102 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2909, output_tokens=620, cost=0.047690
2025-10-18 06:10:44.108 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 06:10:52.323 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3745, output_tokens=321, cost=0.047080
2025-10-18 06:10:52.326 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 06:10:59.737 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=675, output_tokens=276, cost=0.015030
2025-10-18 06:10:59.738 | DEBUG    | Extracted a valid json.
2025-10-18 06:10:59.738 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "sphinx/writers/latex.py",
            "class": "",
            "method": "",
            "intended_behavior": "This file should ensure that explicitly numbered footnotes and their references are correctly handled in a manner that preserves the numbering and hyperlinking in the LaTeX output. The fix should ensure that when a footnote is referenced multiple times, each instance creates a proper hyperlink back to the original footnote in the final PDF document. This behavior will require reviewing and potentially updating the way footnote references are translated into LaTeX, ensuring that each reference correctly points back to its corresponding footnote definition, without losing its numbering or failing to create a hyperlink."
        },
        {
            "file": "sphinx/transforms/latex/transforms.py",
            "class": "",
            "method": "",
            "intended_behavior": "In this file, the transformations related to footnotes must be revisited to ensure they accurately process multiple references to the same footnote. The processing should account for the reuse of footnote numbers in a way that does not break the hyperlink mechanism in the generated PDF. This might involve ensuring that the transform logic uniquely identifies and links each footnote reference back to its single source of definition, regardless of how many times or where the footnote is referenced within the document."
        }
    ]
}
2025-10-18 06:10:59.746 | DEBUG    | Bug location extracted successfully: [<file>sphinx/writers/latex.py</file>
<class>None</class>
<method>None</method>
<code>
1 """Custom docutils writer for LaTeX.
2 
3 Much of this code is adapted from Dave Kuhlman's "docpy" writer from his
4 docutils sandbox.
5 """
6 
7 import re
8 import warnings
9 from collections import defaultdict
10 from os import path
11 from typing import TYPE_CHECKING, Any, Dict, Iterable, List, Set, Tuple, cast
12 
13 from docutils import nodes, writers
14 from docutils.nodes import Element, Node, Text
15 
16 from sphinx import addnodes, highlighting
17 from sphinx.deprecation import RemovedInSphinx70Warning
18 from sphinx.domains import IndexEntry
19 from sphinx.domains.std import StandardDomain
20 from sphinx.errors import SphinxError
21 from sphinx.locale import _, __, admonitionlabels
22 from sphinx.util import logging, split_into, texescape
23 from sphinx.util.docutils import SphinxTranslator
24 from sphinx.util.nodes import clean_astext, get_prev_node
25 from sphinx.util.template import LaTeXRenderer
26 from sphinx.util.texescape import tex_replace_map
27 
28 try:
29     from docutils.utils.roman import toRoman
30 except ImportError:
31     # In Debian/Ubuntu, roman package is provided as roman, not as docutils.utils.roman
32     from roman import toRoman  # type: ignore
33 
34 if TYPE_CHECKING:
35     from sphinx.builders.latex import LaTeXBuilder
36     from sphinx.builders.latex.theming import Theme
37 
38 
39 logger = logging.getLogger(__name__)
40 
41 MAX_CITATION_LABEL_LENGTH = 8
42 LATEXSECTIONNAMES = ["part", "chapter", "section", "subsection",
43                      "subsubsection", "paragraph", "subparagraph"]
44 ENUMERATE_LIST_STYLE = defaultdict(lambda: r'\arabic',
45                                    {
46                                        'arabic': r'\arabic',
47                                        'loweralpha': r'\alph',
48                                        'upperalpha': r'\Alph',
49                                        'lowerroman': r'\roman',
50                                        'upperroman': r'\Roman',
51                                    })
52 
53 CR = '\n'
54 BLANKLINE = '\n\n'
55 EXTRA_RE = re.compile(r'^(.*\S)\s+\(([^()]*)\)\s*$')
56 
57 
58 class collected_footnote(nodes.footnote):
59     """Footnotes that are collected are assigned this class."""
60 
61 
62 class UnsupportedError(SphinxError):
63     category = 'Markup is unsupported in LaTeX'
64 
65 
66 class LaTeXWriter(writers.Writer):
67 
68     supported = ('sphinxlatex',)
69 
70     settings_spec = ('LaTeX writer options', '', (
71         ('Document name', ['--docname'], {'default': ''}),
72         ('Document class', ['--docclass'], {'default': 'manual'}),
73         ('Author', ['--author'], {'default': ''}),
74     ))
75     settings_defaults: Dict = {}
76 
77     output = None
78 
79     def __init__(self, builder: "LaTeXBuilder") -> None:
80         super().__init__()
81         self.builder = builder
82         self.theme: Theme = None
83 
84     def translate(self) -> None:
85         visitor = self.builder.create_translator(self.document, self.builder, self.theme)
86         self.document.walkabout(visitor)
87         self.output = cast(LaTeXTranslator, visitor).astext()
88 
89 
90 # Helper classes
91 
92 class Table:
93     """A table data"""
94 
95     def __init__(self, node: Element) -> None:
96         self.header: List[str] = []
97         self.body: List[str] = []
98         self.align = node.get('align', 'default')
99         self.classes: List[str] = node.get('classes', [])
100         self.colcount = 0
101         self.colspec: str = None
102         self.colwidths: List[int] = []
103         self.has_problematic = False
104         self.has_oldproblematic = False
105         self.has_verbatim = False
106         self.caption: List[str] = None
107         self.stubs: List[int] = []
108 
109         # current position
110         self.col = 0
111         self.row = 0
112 
113         # A dict mapping a table location to a cell_id (cell = rectangular area)
114         self.cells: Dict[Tuple[int, int], int] = defaultdict(int)
115         self.cell_id = 0  # last assigned cell_id
116 
117     def is_longtable(self) -> bool:
118         """True if and only if table uses longtable environment."""
119         return self.row > 30 or 'longtable' in self.classes
120 
121     def get_table_type(self) -> str:
122         """Returns the LaTeX environment name for the table.
123 
124         The class currently supports:
125 
126         * longtable
127         * tabular
128         * tabulary
129         """
130         if self.is_longtable():
131             return 'longtable'
132         elif self.has_verbatim:
133             return 'tabular'
134         elif self.colspec:
135             return 'tabulary'
136         elif self.has_problematic or (self.colwidths and 'colwidths-given' in self.classes):
137             return 'tabular'
138         else:
139             return 'tabulary'
140 
141     def get_colspec(self) -> str:
142         """Returns a column spec of table.
143 
144         This is what LaTeX calls the 'preamble argument' of the used table environment.
145 
146         .. note:: the ``\\X`` and ``T`` column type specifiers are defined in ``sphinx.sty``.
147         """
148         if self.colspec:
149             return self.colspec
150         elif self.colwidths and 'colwidths-given' in self.classes:
151             total = sum(self.colwidths)
152             colspecs = [r'\X{%d}{%d}' % (width, total) for width in self.colwidths]
153             return '{|%s|}' % '|'.join(colspecs) + CR
154         elif self.has_problematic:
155             return r'{|*{%d}{\X{1}{%d}|}}' % (self.colcount, self.colcount) + CR
156         elif self.get_table_type() == 'tabulary':
157             # sphinx.sty sets T to be J by default.
158             return '{|' + ('T|' * self.colcount) + '}' + CR
159         elif self.has_oldproblematic:
160             return r'{|*{%d}{\X{1}{%d}|}}' % (self.colcount, self.colcount) + CR
161         else:
162             return '{|' + ('l|' * self.colcount) + '}' + CR
163 
164     def add_cell(self, height: int, width: int) -> None:
165         """Adds a new cell to a table.
166 
167         It will be located at current position: (``self.row``, ``self.col``).
168         """
169         self.cell_id += 1
170         for col in range(width):
171             for row in range(height):
172                 assert self.cells[(self.row + row, self.col + col)] == 0
173                 self.cells[(self.row + row, self.col + col)] = self.cell_id
174 
175     def cell(self, row: int = None, col: int = None) -> "TableCell":
176         """Returns a cell object (i.e. rectangular area) containing given position.
177 
178         If no option arguments: ``row`` or ``col`` are given, the current position;
179         ``self.row`` and ``self.col`` are used to get a cell object by default.
180         """
181         try:
182             if row is None:
183                 row = self.row
184             if col is None:
185                 col = self.col
186             return TableCell(self, row, col)
187         except IndexError:
188             return None
189 
190 
191 class TableCell:
192     """Data of a cell in a table."""
193 
194     def __init__(self, table: Table, row: int, col: int) -> None:
195         if table.cells[(row, col)] == 0:
196             raise IndexError
197 
198         self.table = table
199         self.cell_id = table.cells[(row, col)]
200         self.row = row
201         self.col = col
202 
203         # adjust position for multirow/multicol cell
204         while table.cells[(self.row - 1, self.col)] == self.cell_id:
205             self.row -= 1
206         while table.cells[(self.row, self.col - 1)] == self.cell_id:
207             self.col -= 1
208 
209     @property
210     def width(self) -> int:
211         """Returns the cell width."""
212         width = 0
213         while self.table.cells[(self.row, self.col + width)] == self.cell_id:
214             width += 1
215         return width
216 
217     @property
218     def height(self) -> int:
219         """Returns the cell height."""
220         height = 0
221         while self.table.cells[(self.row + height, self.col)] == self.cell_id:
222             height += 1
223         return height
224 
225 
226 def escape_abbr(text: str) -> str:
227     """Adjust spacing after abbreviations."""
228     return re.sub(r'\.(?=\s|$)', r'.\@', text)
229 
230 
231 def rstdim_to_latexdim(width_str: str, scale: int = 100) -> str:
232     """Convert `width_str` with rst length to LaTeX length."""
233     match = re.match(r'^(\d*\.?\d*)\s*(\S*)$', width_str)
234     if not match:
235         raise ValueError
236     res = width_str
237     amount, unit = match.groups()[:2]
238     if scale == 100:
239         float(amount)  # validate amount is float
240         if unit in ('', "px"):
241             res = r"%s\sphinxpxdimen" % amount
242         elif unit == 'pt':
243             res = '%sbp' % amount  # convert to 'bp'
244         elif unit == "%":
245             res = r"%.3f\linewidth" % (float(amount) / 100.0)
246     else:
247         amount_float = float(amount) * scale / 100.0
248         if unit in ('', "px"):
249             res = r"%.5f\sphinxpxdimen" % amount_float
250         elif unit == 'pt':
251             res = '%.5fbp' % amount_float
252         elif unit == "%":
253             res = r"%.5f\linewidth" % (amount_float / 100.0)
254         else:
255             res = "%.5f%s" % (amount_float, unit)
256     return res
257 
258 
259 class LaTeXTranslator(SphinxTranslator):
260     builder: "LaTeXBuilder" = None
261 
262     secnumdepth = 2  # legacy sphinxhowto.cls uses this, whereas article.cls
263     # default is originally 3. For book/report, 2 is already LaTeX default.
264     ignore_missing_images = False
265 
266     def __init__(self, document: nodes.document, builder: "LaTeXBuilder",
267                  theme: "Theme") -> None:
268         super().__init__(document, builder)
269         self.body: List[str] = []
270         self.theme = theme
271 
272         # flags
273         self.in_title = 0
274         self.in_production_list = 0
275         self.in_footnote = 0
276         self.in_caption = 0
277         self.in_term = 0
278         self.needs_linetrimming = 0
279         self.in_minipage = 0
280         self.no_latex_floats = 0
281         self.first_document = 1
282         self.this_is_the_title = 1
283         self.literal_whitespace = 0
284         self.in_parsed_literal = 0
285         self.compact_list = 0
286         self.first_param = 0
287         self.in_desc_signature = False
288 
289         sphinxpkgoptions = []
290 
291         # sort out some elements
292         self.elements = self.builder.context.copy()
293 
294         # initial section names
295         self.sectionnames = LATEXSECTIONNAMES[:]
296         if self.theme.toplevel_sectioning == 'section':
297             self.sectionnames.remove('chapter')
298 
299         # determine top section level
300         self.top_sectionlevel = 1
301         if self.config.latex_toplevel_sectioning:
302             try:
303                 self.top_sectionlevel = \
304                     self.sectionnames.index(self.config.latex_toplevel_sectioning)
305             except ValueError:
306                 logger.warning(__('unknown %r toplevel_sectioning for class %r') %
307                                (self.config.latex_toplevel_sectioning, self.theme.docclass))
308 
309         if self.config.numfig:
310             self.numfig_secnum_depth = self.config.numfig_secnum_depth
311             if self.numfig_secnum_depth > 0:  # default is 1
312                 # numfig_secnum_depth as passed to sphinx.sty indices same names as in
313                 # LATEXSECTIONNAMES but with -1 for part, 0 for chapter, 1 for section...
314                 if len(self.sectionnames) < len(LATEXSECTIONNAMES) and \
315                    self.top_sectionlevel > 0:
316                     self.numfig_secnum_depth += self.top_sectionlevel
317                 else:
318                     self.numfig_secnum_depth += self.top_sectionlevel - 1
319                 # this (minus one) will serve as minimum to LaTeX's secnumdepth
320                 self.numfig_secnum_depth = min(self.numfig_secnum_depth,
321                                                len(LATEXSECTIONNAMES) - 1)
322                 # if passed key value is < 1 LaTeX will act as if 0; see sphinx.sty
323                 sphinxpkgoptions.append('numfigreset=%s' % self.numfig_secnum_depth)
324             else:
325                 sphinxpkgoptions.append('nonumfigreset')
326 
327         if self.config.numfig and self.config.math_numfig:
328             sphinxpkgoptions.append('mathnumfig')
329 
330         if (self.config.language not in {'en', 'ja'} and
331                 'fncychap' not in self.config.latex_elements):
332             # use Sonny style if any language specified (except English)
333             self.elements['fncychap'] = (r'\usepackage[Sonny]{fncychap}' + CR +
334                                          r'\ChNameVar{\Large\normalfont\sffamily}' + CR +
335                                          r'\ChTitleVar{\Large\normalfont\sffamily}')
336 
337         self.babel = self.builder.babel
338         if not self.babel.is_supported_language():
339             # emit warning if specified language is invalid
340             # (only emitting, nothing changed to processing)
341             logger.warning(__('no Babel option known for language %r'),
342                            self.config.language)
343 
344         minsecnumdepth = self.secnumdepth  # 2 from legacy sphinx manual/howto
345         if self.document.get('tocdepth'):
346             # reduce tocdepth if `part` or `chapter` is used for top_sectionlevel
347             #   tocdepth = -1: show only parts
348             #   tocdepth =  0: show parts and chapters
349             #   tocdepth =  1: show parts, chapters and sections
350             #   tocdepth =  2: show parts, chapters, sections and subsections
351             #   ...
352             tocdepth = self.document.get('tocdepth', 999) + self.top_sectionlevel - 2
353             if len(self.sectionnames) < len(LATEXSECTIONNAMES) and \
354                self.top_sectionlevel > 0:
355                 tocdepth += 1  # because top_sectionlevel is shifted by -1
356             if tocdepth > len(LATEXSECTIONNAMES) - 2:  # default is 5 <-> subparagraph
357                 logger.warning(__('too large :maxdepth:, ignored.'))
358                 tocdepth = len(LATEXSECTIONNAMES) - 2
359 
360             self.elements['tocdepth'] = r'\setcounter{tocdepth}{%d}' % tocdepth
361             minsecnumdepth = max(minsecnumdepth, tocdepth)
362 
363         if self.config.numfig and (self.config.numfig_secnum_depth > 0):
364             minsecnumdepth = max(minsecnumdepth, self.numfig_secnum_depth - 1)
365 
366         if minsecnumdepth > self.secnumdepth:
367             self.elements['secnumdepth'] = r'\setcounter{secnumdepth}{%d}' %\
368                                            minsecnumdepth
369 
370         contentsname = document.get('contentsname')
371         if contentsname:
372             self.elements['contentsname'] = self.babel_renewcommand(r'\contentsname',
373                                                                     contentsname)
374 
375         if self.elements['maxlistdepth']:
376             sphinxpkgoptions.append('maxlistdepth=%s' % self.elements['maxlistdepth'])
377         if sphinxpkgoptions:
378             self.elements['sphinxpkgoptions'] = '[,%s]' % ','.join(sphinxpkgoptions)
379         if self.elements['sphinxsetup']:
380             self.elements['sphinxsetup'] = (r'\sphinxsetup{%s}' % self.elements['sphinxsetup'])
381         if self.elements['extraclassoptions']:
382             self.elements['classoptions'] += ',' + \
383                                              self.elements['extraclassoptions']
384 
385         self.highlighter = highlighting.PygmentsBridge('latex', self.config.pygments_style,
386                                                        latex_engine=self.config.latex_engine)
387         self.context: List[Any] = []
388         self.descstack: List[str] = []
389         self.tables: List[Table] = []
390         self.next_table_colspec: str = None
391         self.bodystack: List[List[str]] = []
392         self.footnote_restricted: Element = None
393         self.pending_footnotes: List[nodes.footnote_reference] = []
394         self.curfilestack: List[str] = []
395         self.handled_abbrs: Set[str] = set()
396 
397     def pushbody(self, newbody: List[str]) -> None:
398         self.bodystack.append(self.body)
399         self.body = newbody
400 
401     def popbody(self) -> List[str]:
402         body = self.body
403         self.body = self.bodystack.pop()
404         return body
405 
406     def astext(self) -> str:
407         self.elements.update({
408             'body': ''.join(self.body),
409             'indices': self.generate_indices()
410         })
411         return self.render('latex.tex_t', self.elements)
412 
413     def hypertarget(self, id: str, withdoc: bool = True, anchor: bool = True) -> str:
414         if withdoc:
415             id = self.curfilestack[-1] + ':' + id
416         return (r'\phantomsection' if anchor else '') + r'\label{%s}' % self.idescape(id)
417 
418     def hypertarget_to(self, node: Element, anchor: bool = False) -> str:
419         labels = ''.join(self.hypertarget(node_id, anchor=False) for node_id in node['ids'])
420         if anchor:
421             return r'\phantomsection' + labels
422         else:
423             return labels
424 
425     def hyperlink(self, id: str) -> str:
426         return r'{\hyperref[%s]{' % self.idescape(id)
427 
428     def hyperpageref(self, id: str) -> str:
429         return r'\autopageref*{%s}' % self.idescape(id)
430 
431     def escape(self, s: str) -> str:
432         return texescape.escape(s, self.config.latex_engine)
433 
434     def idescape(self, id: str) -> str:
435         return r'\detokenize{%s}' % str(id).translate(tex_replace_map).\
436             encode('ascii', 'backslashreplace').decode('ascii').\
437             replace('\\', '_')
438 
439     def babel_renewcommand(self, command: str, definition: str) -> str:
440         if self.elements['multilingual']:
441             prefix = r'\addto\captions%s{' % self.babel.get_language()
442             suffix = '}'
443         else:  # babel is disabled (mainly for Japanese environment)
444             prefix = ''
445             suffix = ''
446 
447         return r'%s\renewcommand{%s}{%s}%s' % (prefix, command, definition, suffix) + CR
448 
449     def generate_indices(self) -> str:
450         def generate(content: List[Tuple[str, List[IndexEntry]]], collapsed: bool) -> None:
451             ret.append(r'\begin{sphinxtheindex}' + CR)
452             ret.append(r'\let\bigletter\sphinxstyleindexlettergroup' + CR)
453             for i, (letter, entries) in enumerate(content):
454                 if i > 0:
455                     ret.append(r'\indexspace' + CR)
456                 ret.append(r'\bigletter{%s}' % self.escape(letter) + CR)
457                 for entry in entries:
458                     if not entry[3]:
459                         continue
460                     ret.append(r'\item\relax\sphinxstyleindexentry{%s}' %
461                                self.encode(entry[0]))
462                     if entry[4]:
463                         # add "extra" info
464                         ret.append(r'\sphinxstyleindexextra{%s}' % self.encode(entry[4]))
465                     ret.append(r'\sphinxstyleindexpageref{%s:%s}' %
466                                (entry[2], self.idescape(entry[3])) + CR)
467             ret.append(r'\end{sphinxtheindex}' + CR)
468 
469         ret = []
470         # latex_domain_indices can be False/True or a list of index names
471         indices_config = self.config.latex_domain_indices
472         if indices_config:
473             for domain in self.builder.env.domains.values():
474                 for indexcls in domain.indices:
475                     indexname = '%s-%s' % (domain.name, indexcls.name)
476                     if isinstance(indices_config, list):
477                         if indexname not in indices_config:
478                             continue
479                     content, collapsed = indexcls(domain).generate(
480                         self.builder.docnames)
481                     if not content:
482                         continue
483                     ret.append(r'\renewcommand{\indexname}{%s}' % indexcls.localname + CR)
484                     generate(content, collapsed)
485 
486         return ''.join(ret)
487 
488     def render(self, template_name: str, variables: Dict) -> str:
489         renderer = LaTeXRenderer(latex_engine=self.config.latex_engine)
490         for template_dir in self.config.templates_path:
491             template = path.join(self.builder.confdir, template_dir,
492                                  template_name)
493             if path.exists(template):
494                 return renderer.render(template, variables)
495 
496         return renderer.render(template_name, variables)
497 
498     @property
499     def table(self) -> Table:
500         """Get current table."""
501         if self.tables:
502             return self.tables[-1]
503         else:
504             return None
505 
506     def visit_document(self, node: Element) -> None:
507         self.curfilestack.append(node.get('docname', ''))
508         if self.first_document == 1:
509             # the first document is all the regular content ...
510             self.first_document = 0
511         elif self.first_document == 0:
512             # ... and all others are the appendices
513             self.body.append(CR + r'\appendix' + CR)
514             self.first_document = -1
515         if 'docname' in node:
516             self.body.append(self.hypertarget(':doc'))
517         # "- 1" because the level is increased before the title is visited
518         self.sectionlevel = self.top_sectionlevel - 1
519 
520     def depart_document(self, node: Element) -> None:
521         pass
522 
523     def visit_start_of_file(self, node: Element) -> None:
524         self.curfilestack.append(node['docname'])
525         self.body.append(CR + r'\sphinxstepscope' + CR)
526 
527     def depart_start_of_file(self, node: Element) -> None:
528         self.curfilestack.pop()
529 
530     def visit_section(self, node: Element) -> None:
531         if not self.this_is_the_title:
532             self.sectionlevel += 1
533         self.body.append(BLANKLINE)
534 
535     def depart_section(self, node: Element) -> None:
536         self.sectionlevel = max(self.sectionlevel - 1,
537                                 self.top_sectionlevel - 1)
538 
539     def visit_problematic(self, node: Element) -> None:
540         self.body.append(r'{\color{red}\bfseries{}')
541 
542     def depart_problematic(self, node: Element) -> None:
543         self.body.append('}')
544 
545     def visit_topic(self, node: Element) -> None:
546         self.in_minipage = 1
547         self.body.append(CR + r'\begin{sphinxShadowBox}' + CR)
548 
549     def depart_topic(self, node: Element) -> None:
550         self.in_minipage = 0
551         self.body.append(r'\end{sphinxShadowBox}' + CR)
552     visit_sidebar = visit_topic
553     depart_sidebar = depart_topic
554 
555     def visit_glossary(self, node: Element) -> None:
556         pass
557 
558     def depart_glossary(self, node: Element) -> None:
559         pass
560 
561     def visit_productionlist(self, node: Element) -> None:
562         self.body.append(BLANKLINE)
563         self.body.append(r'\begin{productionlist}' + CR)
564         self.in_production_list = 1
565 
566     def depart_productionlist(self, node: Element) -> None:
567         self.body.append(r'\end{productionlist}' + BLANKLINE)
568         self.in_production_list = 0
569 
570     def visit_production(self, node: Element) -> None:
571         if node['tokenname']:
572             tn = node['tokenname']
573             self.body.append(self.hypertarget('grammar-token-' + tn))
574             self.body.append(r'\production{%s}{' % self.encode(tn))
575         else:
576             self.body.append(r'\productioncont{')
577 
578     def depart_production(self, node: Element) -> None:
579         self.body.append('}' + CR)
580 
581     def visit_transition(self, node: Element) -> None:
582         self.body.append(self.elements['transition'])
583 
584     def depart_transition(self, node: Element) -> None:
585         pass
586 
587     def visit_title(self, node: Element) -> None:
588         parent = node.parent
589         if isinstance(parent, addnodes.seealso):
590             # the environment already handles this
591             raise nodes.SkipNode
592         elif isinstance(parent, nodes.section):
593             if self.this_is_the_title:
594                 if len(node.children) != 1 and not isinstance(node.children[0],
595                                                               nodes.Text):
596                     logger.warning(__('document title is not a single Text node'),
597                                    location=node)
598                 if not self.elements['title']:
599                     # text needs to be escaped since it is inserted into
600                     # the output literally
601                     self.elements['title'] = self.escape(node.astext())
602                 self.this_is_the_title = 0
603                 raise nodes.SkipNode
604             else:
605                 short = ''
606                 if any(node.findall(nodes.image)):
607                     short = ('[%s]' % self.escape(' '.join(clean_astext(node).split())))
608 
609                 try:
610                     self.body.append(r'\%s%s{' % (self.sectionnames[self.sectionlevel], short))
611                 except IndexError:
612                     # just use "subparagraph", it's not numbered anyway
613                     self.body.append(r'\%s%s{' % (self.sectionnames[-1], short))
614                 self.context.append('}' + CR + self.hypertarget_to(node.parent))
615         elif isinstance(parent, nodes.topic):
616             self.body.append(r'\sphinxstyletopictitle{')
617             self.context.append('}' + CR)
618         elif isinstance(parent, nodes.sidebar):
619             self.body.append(r'\sphinxstylesidebartitle{')
620             self.context.append('}' + CR)
621         elif isinstance(parent, nodes.Admonition):
622             self.body.append('{')
623             self.context.append('}' + CR)
624         elif isinstance(parent, nodes.table):
625             # Redirect body output until title is finished.
626             self.pushbody([])
627         else:
628             logger.warning(__('encountered title node not in section, topic, table, '
629                               'admonition or sidebar'),
630                            location=node)
631             self.body.append(r'\sphinxstyleothertitle{')
632             self.context.append('}' + CR)
633         self.in_title = 1
634 
635     def depart_title(self, node: Element) -> None:
636         self.in_title = 0
637         if isinstance(node.parent, nodes.table):
638             self.table.caption = self.popbody()
639         else:
640             self.body.append(self.context.pop())
641 
642     def visit_subtitle(self, node: Element) -> None:
643         if isinstance(node.parent, nodes.sidebar):
644             self.body.append(r'\sphinxstylesidebarsubtitle{')
645             self.context.append('}' + CR)
646         else:
647             self.context.append('')
648 
649     def depart_subtitle(self, node: Element) -> None:
650         self.body.append(self.context.pop())
651 
652     #############################################################
653     # Domain-specific object descriptions
654     #############################################################
655 
656     # Top-level nodes for descriptions
657     ##################################
658 
659     def visit_desc(self, node: Element) -> None:
660         if self.config.latex_show_urls == 'footnote':
661             self.body.append(BLANKLINE)
662             self.body.append(r'\begin{savenotes}\begin{fulllineitems}' + CR)
663         else:
664             self.body.append(BLANKLINE)
665             self.body.append(r'\begin{fulllineitems}' + CR)
666         if self.table:
667             self.table.has_problematic = True
668 
669     def depart_desc(self, node: Element) -> None:
670         if self.in_desc_signature:
671             self.body.append(CR + r'\pysigstopsignatures')
672             self.in_desc_signature = False
673         if self.config.latex_show_urls == 'footnote':
674             self.body.append(CR + r'\end{fulllineitems}\end{savenotes}' + BLANKLINE)
675         else:
676             self.body.append(CR + r'\end{fulllineitems}' + BLANKLINE)
677 
678     def _visit_signature_line(self, node: Element) -> None:
679         for child in node:
680             if isinstance(child, addnodes.desc_parameterlist):
681                 self.body.append(CR + r'\pysiglinewithargsret{')
682                 break
683         else:
684             self.body.append(CR + r'\pysigline{')
685 
686     def _depart_signature_line(self, node: Element) -> None:
687         self.body.append('}')
688 
689     def visit_desc_signature(self, node: Element) -> None:
690         if node.parent['objtype'] != 'describe' and node['ids']:
691             hyper = self.hypertarget(node['ids'][0])
692         else:
693             hyper = ''
694         self.body.append(hyper)
695         if not self.in_desc_signature:
696             self.in_desc_signature = True
697             self.body.append(CR + r'\pysigstartsignatures')
698         if not node.get('is_multiline'):
699             self._visit_signature_line(node)
700         else:
701             self.body.append(CR + r'\pysigstartmultiline')
702 
703     def depart_desc_signature(self, node: Element) -> None:
704         if not node.get('is_multiline'):
705             self._depart_signature_line(node)
706         else:
707             self.body.append(CR + r'\pysigstopmultiline')
708 
709     def visit_desc_signature_line(self, node: Element) -> None:
710         self._visit_signature_line(node)
711 
712     def depart_desc_signature_line(self, node: Element) -> None:
713         self._depart_signature_line(node)
714 
715     def visit_desc_content(self, node: Element) -> None:
716         assert self.in_desc_signature
717         self.body.append(CR + r'\pysigstopsignatures')
718         self.in_desc_signature = False
719 
720     def depart_desc_content(self, node: Element) -> None:
721         pass
722 
723     def visit_desc_inline(self, node: Element) -> None:
724         self.body.append(r'\sphinxcode{\sphinxupquote{')
725 
726     def depart_desc_inline(self, node: Element) -> None:
727         self.body.append('}}')
728 
729     # Nodes for high-level structure in signatures
730     ##############################################
731 
732     def visit_desc_name(self, node: Element) -> None:
733         self.body.append(r'\sphinxbfcode{\sphinxupquote{')
734         self.literal_whitespace += 1
735 
736     def depart_desc_name(self, node: Element) -> None:
737         self.body.append('}}')
738         self.literal_whitespace -= 1
739 
740     def visit_desc_addname(self, node: Element) -> None:
741         self.body.append(r'\sphinxcode{\sphinxupquote{')
742         self.literal_whitespace += 1
743 
744     def depart_desc_addname(self, node: Element) -> None:
745         self.body.append('}}')
746         self.literal_whitespace -= 1
747 
748     def visit_desc_type(self, node: Element) -> None:
749         pass
750 
751     def depart_desc_type(self, node: Element) -> None:
752         pass
753 
754     def visit_desc_returns(self, node: Element) -> None:
755         self.body.append(r'{ $\rightarrow$ ')
756 
757     def depart_desc_returns(self, node: Element) -> None:
758         self.body.append(r'}')
759 
760     def visit_desc_parameterlist(self, node: Element) -> None:
761         # close name, open parameterlist
762         self.body.append('}{')
763         self.first_param = 1
764 
765     def depart_desc_parameterlist(self, node: Element) -> None:
766         # close parameterlist, open return annotation
767         self.body.append('}{')
768 
769     def visit_desc_parameter(self, node: Element) -> None:
770         if not self.first_param:
771             self.body.append(', ')
772         else:
773             self.first_param = 0
774         if not node.hasattr('noemph'):
775             self.body.append(r'\emph{')
776 
777     def depart_desc_parameter(self, node: Element) -> None:
778         if not node.hasattr('noemph'):
779             self.body.append('}')
780 
781     def visit_desc_optional(self, node: Element) -> None:
782         self.body.append(r'\sphinxoptional{')
783 
784     def depart_desc_optional(self, node: Element) -> None:
785         self.body.append('}')
786 
787     def visit_desc_annotation(self, node: Element) -> None:
788         self.body.append(r'\sphinxbfcode{\sphinxupquote{')
789 
790     def depart_desc_annotation(self, node: Element) -> None:
791         self.body.append('}}')
792 
793     ##############################################
794 
795     def visit_seealso(self, node: Element) -> None:
796         self.body.append(BLANKLINE)
797         self.body.append(r'\sphinxstrong{%s:}' % admonitionlabels['seealso'] + CR)
798         self.body.append(r'\nopagebreak' + BLANKLINE)
799 
800     def depart_seealso(self, node: Element) -> None:
801         self.body.append(BLANKLINE)
802 
803     def visit_rubric(self, node: Element) -> None:
804         if len(node) == 1 and node.astext() in ('Footnotes', _('Footnotes')):
805             raise nodes.SkipNode
806         self.body.append(r'\subsubsection*{')
807         self.context.append('}' + CR)
808         self.in_title = 1
809 
810     def depart_rubric(self, node: Element) -> None:
811         self.in_title = 0
812         self.body.append(self.context.pop())
813 
814     def visit_footnote(self, node: Element) -> None:
815         self.in_footnote += 1
816         label = cast(nodes.label, node[0])
817         if 'referred' in node:
818             self.body.append(r'\sphinxstepexplicit ')
819         if self.in_parsed_literal:
820             self.body.append(r'\begin{footnote}[%s]' % label.astext())
821         else:
822             self.body.append('%' + CR)
823             self.body.append(r'\begin{footnote}[%s]' % label.astext())
824         if 'referred' in node:
825             self.body.append(r'\phantomsection'
826                              r'\label{\thesphinxscope.%s}%%' % label.astext() + CR)
827         self.body.append(r'\sphinxAtStartFootnote' + CR)
828 
829     def depart_footnote(self, node: Element) -> None:
830         if self.in_parsed_literal:
831             self.body.append(r'\end{footnote}')
832         else:
833             self.body.append('%' + CR)
834             self.body.append(r'\end{footnote}')
835         self.in_footnote -= 1
836 
837     def visit_label(self, node: Element) -> None:
838         raise nodes.SkipNode
839 
840     def visit_tabular_col_spec(self, node: Element) -> None:
841         self.next_table_colspec = node['spec']
842         raise nodes.SkipNode
843 
844     def visit_table(self, node: Element) -> None:
845         if len(self.tables) == 1:
846             if self.table.get_table_type() == 'longtable':
847                 raise UnsupportedError(
848                     '%s:%s: longtable does not support nesting a table.' %
849                     (self.curfilestack[-1], node.line or ''))
850             else:
851                 # change type of parent table to tabular
852                 # see https://groups.google.com/d/msg/sphinx-users/7m3NeOBixeo/9LKP2B4WBQAJ
853                 self.table.has_problematic = True
854         elif len(self.tables) > 2:
855             raise UnsupportedError(
856                 '%s:%s: deeply nested tables are not implemented.' %
857                 (self.curfilestack[-1], node.line or ''))
858 
859         self.tables.append(Table(node))
860         if self.next_table_colspec:
861             self.table.colspec = '{%s}' % self.next_table_colspec + CR
862             if 'colwidths-given' in node.get('classes', []):
863                 logger.info(__('both tabularcolumns and :widths: option are given. '
864                                ':widths: is ignored.'), location=node)
865         self.next_table_colspec = None
866 
867     def depart_table(self, node: Element) -> None:
868         labels = self.hypertarget_to(node)
869         table_type = self.table.get_table_type()
870         table = self.render(table_type + '.tex_t',
871                             dict(table=self.table, labels=labels))
872         self.body.append(BLANKLINE)
873         self.body.append(table)
874         self.body.append(CR)
875 
876         self.tables.pop()
877 
878     def visit_colspec(self, node: Element) -> None:
879         self.table.colcount += 1
880         if 'colwidth' in node:
881             self.table.colwidths.append(node['colwidth'])
882         if 'stub' in node:
883             self.table.stubs.append(self.table.colcount - 1)
884 
885     def depart_colspec(self, node: Element) -> None:
886         pass
887 
888     def visit_tgroup(self, node: Element) -> None:
889         pass
890 
891     def depart_tgroup(self, node: Element) -> None:
892         pass
893 
894     def visit_thead(self, node: Element) -> None:
895         # Redirect head output until header is finished.
896         self.pushbody(self.table.header)
897 
898     def depart_thead(self, node: Element) -> None:
899         self.popbody()
900 
901     def visit_tbody(self, node: Element) -> None:
902         # Redirect body output until table is finished.
903         self.pushbody(self.table.body)
904 
905     def depart_tbody(self, node: Element) -> None:
906         self.popbody()
907 
908     def visit_row(self, node: Element) -> None:
909         self.table.col = 0
910 
911         # fill columns if the row starts with the bottom of multirow cell
912         while True:
913             cell = self.table.cell(self.table.row, self.table.col)
914             if cell is None:  # not a bottom of multirow cell
915                 break
916             else:  # a bottom of multirow cell
917                 self.table.col += cell.width
918                 if cell.col:
919                     self.body.append('&')
920                 if cell.width == 1:
921                     # insert suitable strut for equalizing row heights in given multirow
922                     self.body.append(r'\sphinxtablestrut{%d}' % cell.cell_id)
923                 else:  # use \multicolumn for wide multirow cell
924                     self.body.append(r'\multicolumn{%d}{|l|}{\sphinxtablestrut{%d}}' %
925                                      (cell.width, cell.cell_id))
926 
927     def depart_row(self, node: Element) -> None:
928         self.body.append(r'\\' + CR)
929         cells = [self.table.cell(self.table.row, i) for i in range(self.table.colcount)]
930         underlined = [cell.row + cell.height == self.table.row + 1 for cell in cells]
931         if all(underlined):
932             self.body.append(r'\hline')
933         else:
934             i = 0
935             underlined.extend([False])  # sentinel
936             while i < len(underlined):
937                 if underlined[i] is True:
938                     j = underlined[i:].index(False)
939                     self.body.append(r'\cline{%d-%d}' % (i + 1, i + j))
940                     i += j
941                 i += 1
942         self.table.row += 1
943 
944     def visit_entry(self, node: Element) -> None:
945         if self.table.col > 0:
946             self.body.append('&')
947         self.table.add_cell(node.get('morerows', 0) + 1, node.get('morecols', 0) + 1)
948         cell = self.table.cell()
949         context = ''
950         if cell.width > 1:
951             if self.config.latex_use_latex_multicolumn:
952                 if self.table.col == 0:
953                     self.body.append(r'\multicolumn{%d}{|l|}{%%' % cell.width + CR)
954                 else:
955                     self.body.append(r'\multicolumn{%d}{l|}{%%' % cell.width + CR)
956                 context = '}%' + CR
957             else:
958                 self.body.append(r'\sphinxstartmulticolumn{%d}%%' % cell.width + CR)
959                 context = r'\sphinxstopmulticolumn' + CR
960         if cell.height > 1:
961             # \sphinxmultirow 2nd arg "cell_id" will serve as id for LaTeX macros as well
962             self.body.append(r'\sphinxmultirow{%d}{%d}{%%' % (cell.height, cell.cell_id) + CR)
963             context = '}%' + CR + context
964         if cell.width > 1 or cell.height > 1:
965             self.body.append(r'\begin{varwidth}[t]{\sphinxcolwidth{%d}{%d}}'
966                              % (cell.width, self.table.colcount) + CR)
967             context = (r'\par' + CR + r'\vskip-\baselineskip'
968                        r'\vbox{\hbox{\strut}}\end{varwidth}%' + CR + context)
969             self.needs_linetrimming = 1
970         if len(list(node.findall(nodes.paragraph))) >= 2:
971             self.table.has_oldproblematic = True
972         if isinstance(node.parent.parent, nodes.thead) or (cell.col in self.table.stubs):
973             if len(node) == 1 and isinstance(node[0], nodes.paragraph) and node.astext() == '':
974                 pass
975             else:
976                 self.body.append(r'\sphinxstyletheadfamily ')
977         if self.needs_linetrimming:
978             self.pushbody([])
979         self.context.append(context)
980 
981     def depart_entry(self, node: Element) -> None:
982         if self.needs_linetrimming:
983             self.needs_linetrimming = 0
984             body = self.popbody()
985 
986             # Remove empty lines from top of merged cell
987             while body and body[0] == CR:
988                 body.pop(0)
989             self.body.extend(body)
990 
991         self.body.append(self.context.pop())
992 
993         cell = self.table.cell()
994         self.table.col += cell.width
995 
996         # fill columns if next ones are a bottom of wide-multirow cell
997         while True:
998             nextcell = self.table.cell()
999             if nextcell is None:  # not a bottom of multirow cell
1000                 break
1001             else:  # a bottom part of multirow cell
1002                 self.table.col += nextcell.width
1003                 self.body.append('&')
1004                 if nextcell.width == 1:
1005                     # insert suitable strut for equalizing row heights in multirow
1006                     # they also serve to clear colour panels which would hide the text
1007                     self.body.append(r'\sphinxtablestrut{%d}' % nextcell.cell_id)
1008                 else:
1009                     # use \multicolumn for wide multirow cell
1010                     self.body.append(r'\multicolumn{%d}{l|}{\sphinxtablestrut{%d}}' %
1011                                      (nextcell.width, nextcell.cell_id))
1012 
1013     def visit_acks(self, node: Element) -> None:
1014         # this is a list in the source, but should be rendered as a
1015         # comma-separated list here
1016         bullet_list = cast(nodes.bullet_list, node[0])
1017         list_items = cast(Iterable[nodes.list_item], bullet_list)
1018         self.body.append(BLANKLINE)
1019         self.body.append(', '.join(n.astext() for n in list_items) + '.')
1020         self.body.append(BLANKLINE)
1021         raise nodes.SkipNode
1022 
1023     def visit_bullet_list(self, node: Element) -> None:
1024         if not self.compact_list:
1025             self.body.append(r'\begin{itemize}' + CR)
1026         if self.table:
1027             self.table.has_problematic = True
1028 
1029     def depart_bullet_list(self, node: Element) -> None:
1030         if not self.compact_list:
1031             self.body.append(r'\end{itemize}' + CR)
1032 
1033     def visit_enumerated_list(self, node: Element) -> None:
1034         def get_enumtype(node: Element) -> str:
1035             enumtype = node.get('enumtype', 'arabic')
1036             if 'alpha' in enumtype and 26 < node.get('start', 0) + len(node):
1037                 # fallback to arabic if alphabet counter overflows
1038                 enumtype = 'arabic'
1039 
1040             return enumtype
1041 
1042         def get_nested_level(node: Element) -> int:
1043             if node is None:
1044                 return 0
1045             elif isinstance(node, nodes.enumerated_list):
1046                 return get_nested_level(node.parent) + 1
1047             else:
1048                 return get_nested_level(node.parent)
1049 
1050         enum = "enum%s" % toRoman(get_nested_level(node)).lower()
1051         enumnext = "enum%s" % toRoman(get_nested_level(node) + 1).lower()
1052         style = ENUMERATE_LIST_STYLE.get(get_enumtype(node))
1053         prefix = node.get('prefix', '')
1054         suffix = node.get('suffix', '.')
1055 
1056         self.body.append(r'\begin{enumerate}' + CR)
1057         self.body.append(r'\sphinxsetlistlabels{%s}{%s}{%s}{%s}{%s}%%' %
1058                          (style, enum, enumnext, prefix, suffix) + CR)
1059         if 'start' in node:
1060             self.body.append(r'\setcounter{%s}{%d}' % (enum, node['start'] - 1) + CR)
1061         if self.table:
1062             self.table.has_problematic = True
1063 
1064     def depart_enumerated_list(self, node: Element) -> None:
1065         self.body.append(r'\end{enumerate}' + CR)
1066 
1067     def visit_list_item(self, node: Element) -> None:
1068         # Append "{}" in case the next character is "[", which would break
1069         # LaTeX's list environment (no numbering and the "[" is not printed).
1070         self.body.append(r'\item {} ')
1071 
1072     def depart_list_item(self, node: Element) -> None:
1073         self.body.append(CR)
1074 
1075     def visit_definition_list(self, node: Element) -> None:
1076         self.body.append(r'\begin{description}' + CR)
1077         if self.table:
1078             self.table.has_problematic = True
1079 
1080     def depart_definition_list(self, node: Element) -> None:
1081         self.body.append(r'\end{description}' + CR)
1082 
1083     def visit_definition_list_item(self, node: Element) -> None:
1084         pass
1085 
1086     def depart_definition_list_item(self, node: Element) -> None:
1087         pass
1088 
1089     def visit_term(self, node: Element) -> None:
1090         self.in_term += 1
1091         ctx = ''
1092         if node.get('ids'):
1093             ctx = r'\phantomsection'
1094             for node_id in node['ids']:
1095                 ctx += self.hypertarget(node_id, anchor=False)
1096         ctx += r'}'
1097         self.body.append(r'\sphinxlineitem{')
1098         self.context.append(ctx)
1099 
1100     def depart_term(self, node: Element) -> None:
1101         self.body.append(self.context.pop())
1102         self.in_term -= 1
1103 
1104     def visit_classifier(self, node: Element) -> None:
1105         self.body.append('{[}')
1106 
1107     def depart_classifier(self, node: Element) -> None:
1108         self.body.append('{]}')
1109 
1110     def visit_definition(self, node: Element) -> None:
1111         pass
1112 
1113     def depart_definition(self, node: Element) -> None:
1114         self.body.append(CR)
1115 
1116     def visit_field_list(self, node: Element) -> None:
1117         self.body.append(r'\begin{quote}\begin{description}' + CR)
1118         if self.table:
1119             self.table.has_problematic = True
1120 
1121     def depart_field_list(self, node: Element) -> None:
1122         self.body.append(r'\end{description}\end{quote}' + CR)
1123 
1124     def visit_field(self, node: Element) -> None:
1125         pass
1126 
1127     def depart_field(self, node: Element) -> None:
1128         pass
1129 
1130     visit_field_name = visit_term
1131     depart_field_name = depart_term
1132 
1133     visit_field_body = visit_definition
1134     depart_field_body = depart_definition
1135 
1136     def visit_paragraph(self, node: Element) -> None:
1137         index = node.parent.index(node)
1138         if (index > 0 and isinstance(node.parent, nodes.compound) and
1139                 not isinstance(node.parent[index - 1], nodes.paragraph) and
1140                 not isinstance(node.parent[index - 1], nodes.compound)):
1141             # insert blank line, if the paragraph follows a non-paragraph node in a compound
1142             self.body.append(r'\noindent' + CR)
1143         elif index == 1 and isinstance(node.parent, (nodes.footnote, footnotetext)):
1144             # don't insert blank line, if the paragraph is second child of a footnote
1145             # (first one is label node)
1146             pass
1147         else:
1148             # the \sphinxAtStartPar is to allow hyphenation of first word of
1149             # a paragraph in narrow contexts such as in a table cell
1150             # added as two items (cf. line trimming in depart_entry())
1151             self.body.extend([CR, r'\sphinxAtStartPar' + CR])
1152 
1153     def depart_paragraph(self, node: Element) -> None:
1154         self.body.append(CR)
1155 
1156     def visit_centered(self, node: Element) -> None:
1157         self.body.append(CR + r'\begin{center}')
1158         if self.table:
1159             self.table.has_problematic = True
1160 
1161     def depart_centered(self, node: Element) -> None:
1162         self.body.append(CR + r'\end{center}')
1163 
1164     def visit_hlist(self, node: Element) -> None:
1165         self.compact_list += 1
1166         ncolumns = node['ncolumns']
1167         if self.compact_list > 1:
1168             self.body.append(r'\setlength{\multicolsep}{0pt}' + CR)
1169         self.body.append(r'\begin{multicols}{' + ncolumns + r'}\raggedright' + CR)
1170         self.body.append(r'\begin{itemize}\setlength{\itemsep}{0pt}'
1171                          r'\setlength{\parskip}{0pt}' + CR)
1172         if self.table:
1173             self.table.has_problematic = True
1174 
1175     def depart_hlist(self, node: Element) -> None:
1176         self.compact_list -= 1
1177         self.body.append(r'\end{itemize}\raggedcolumns\end{multicols}' + CR)
1178 
1179     def visit_hlistcol(self, node: Element) -> None:
1180         pass
1181 
1182     def depart_hlistcol(self, node: Element) -> None:
1183         # \columnbreak would guarantee same columns as in html output.  But
1184         # some testing with long items showed that columns may be too uneven.
1185         # And in case only of short items, the automatic column breaks should
1186         # match the ones pre-computed by the hlist() directive.
1187         # self.body.append(r'\columnbreak\n')
1188         pass
1189 
1190     def latex_image_length(self, width_str: str, scale: int = 100) -> str:
1191         try:
1192             return rstdim_to_latexdim(width_str, scale)
1193         except ValueError:
1194             logger.warning(__('dimension unit %s is invalid. Ignored.'), width_str)
1195             return None
1196 
1197     def is_inline(self, node: Element) -> bool:
1198         """Check whether a node represents an inline element."""
1199         return isinstance(node.parent, nodes.TextElement)
1200 
1201     def visit_image(self, node: Element) -> None:
1202         pre: List[str] = []  # in reverse order
1203         post: List[str] = []
1204         include_graphics_options = []
1205         has_hyperlink = isinstance(node.parent, nodes.reference)
1206         if has_hyperlink:
1207             is_inline = self.is_inline(node.parent)
1208         else:
1209             is_inline = self.is_inline(node)
1210         if 'width' in node:
1211             if 'scale' in node:
1212                 w = self.latex_image_length(node['width'], node['scale'])
1213             else:
1214                 w = self.latex_image_length(node['width'])
1215             if w:
1216                 include_graphics_options.append('width=%s' % w)
1217         if 'height' in node:
1218             if 'scale' in node:
1219                 h = self.latex_image_length(node['height'], node['scale'])
1220             else:
1221                 h = self.latex_image_length(node['height'])
1222             if h:
1223                 include_graphics_options.append('height=%s' % h)
1224         if 'scale' in node:
1225             if not include_graphics_options:
1226                 # if no "width" nor "height", \sphinxincludegraphics will fit
1227                 # to the available text width if oversized after rescaling.
1228                 include_graphics_options.append('scale=%s'
1229                                                 % (float(node['scale']) / 100.0))
1230         if 'align' in node:
1231             align_prepost = {
1232                 # By default latex aligns the top of an image.
1233                 (1, 'top'): ('', ''),
1234                 (1, 'middle'): (r'\raisebox{-0.5\height}{', '}'),
1235                 (1, 'bottom'): (r'\raisebox{-\height}{', '}'),
1236                 (0, 'center'): (r'{\hspace*{\fill}', r'\hspace*{\fill}}'),
1237                 # These 2 don't exactly do the right thing.  The image should
1238                 # be floated alongside the paragraph.  See
1239                 # https://www.w3.org/TR/html4/struct/objects.html#adef-align-IMG
1240                 (0, 'left'): ('{', r'\hspace*{\fill}}'),
1241                 (0, 'right'): (r'{\hspace*{\fill}', '}'),
1242             }
1243             try:
1244                 pre.append(align_prepost[is_inline, node['align']][0])
1245                 post.append(align_prepost[is_inline, node['align']][1])
1246             except KeyError:
1247                 pass
1248         if self.in_parsed_literal:
1249             pre.append(r'{\sphinxunactivateextrasandspace ')
1250             post.append('}')
1251         if not is_inline and not has_hyperlink:
1252             pre.append(CR + r'\noindent')
1253             post.append(CR)
1254         pre.reverse()
1255         if node['uri'] in self.builder.images:
1256             uri = self.builder.images[node['uri']]
1257         else:
1258             # missing image!
1259             if self.ignore_missing_images:
1260                 return
1261             uri = node['uri']
1262         if uri.find('://') != -1:
1263             # ignore remote images
1264             return
1265         self.body.extend(pre)
1266         options = ''
1267         if include_graphics_options:
1268             options = '[%s]' % ','.join(include_graphics_options)
1269         base, ext = path.splitext(uri)
1270         if self.in_title and base:
1271             # Lowercase tokens forcely because some fncychap themes capitalize
1272             # the options of \sphinxincludegraphics unexpectedly (ex. WIDTH=...).
1273             self.body.append(r'\lowercase{\sphinxincludegraphics%s}{{%s}%s}' %
1274                              (options, base, ext))
1275         else:
1276             self.body.append(r'\sphinxincludegraphics%s{{%s}%s}' %
1277                              (options, base, ext))
1278         self.body.extend(post)
1279 
1280     def depart_image(self, node: Element) -> None:
1281         pass
1282 
1283     def visit_figure(self, node: Element) -> None:
1284         align = self.elements['figure_align']
1285         if self.no_latex_floats:
1286             align = "H"
1287         if self.table:
1288             # TODO: support align option
1289             if 'width' in node:
1290                 length = self.latex_image_length(node['width'])
1291                 if length:
1292                     self.body.append(r'\begin{sphinxfigure-in-table}[%s]' % length + CR)
1293                     self.body.append(r'\centering' + CR)
1294             else:
1295                 self.body.append(r'\begin{sphinxfigure-in-table}' + CR)
1296                 self.body.append(r'\centering' + CR)
1297             if any(isinstance(child, nodes.caption) for child in node):
1298                 self.body.append(r'\capstart')
1299             self.context.append(r'\end{sphinxfigure-in-table}\relax' + CR)
1300         elif node.get('align', '') in ('left', 'right'):
1301             length = None
1302             if 'width' in node:
1303                 length = self.latex_image_length(node['width'])
1304             elif isinstance(node[0], nodes.image) and 'width' in node[0]:
1305                 length = self.latex_image_length(node[0]['width'])
1306             self.body.append(BLANKLINE)     # Insert a blank line to prevent infinite loop
1307                                             # https://github.com/sphinx-doc/sphinx/issues/7059
1308             self.body.append(r'\begin{wrapfigure}{%s}{%s}' %
1309                              ('r' if node['align'] == 'right' else 'l', length or '0pt') + CR)
1310             self.body.append(r'\centering')
1311             self.context.append(r'\end{wrapfigure}' + CR)
1312         elif self.in_minipage:
1313             self.body.append(CR + r'\begin{center}')
1314             self.context.append(r'\end{center}' + CR)
1315         else:
1316             self.body.append(CR + r'\begin{figure}[%s]' % align + CR)
1317             self.body.append(r'\centering' + CR)
1318             if any(isinstance(child, nodes.caption) for child in node):
1319                 self.body.append(r'\capstart' + CR)
1320             self.context.append(r'\end{figure}' + CR)
1321 
1322     def depart_figure(self, node: Element) -> None:
1323         self.body.append(self.context.pop())
1324 
1325     def visit_caption(self, node: Element) -> None:
1326         self.in_caption += 1
1327         if isinstance(node.parent, captioned_literal_block):
1328             self.body.append(r'\sphinxSetupCaptionForVerbatim{')
1329         elif self.in_minipage and isinstance(node.parent, nodes.figure):
1330             self.body.append(r'\captionof{figure}{')
1331         elif self.table and node.parent.tagname == 'figure':
1332             self.body.append(r'\sphinxfigcaption{')
1333         else:
1334             self.body.append(r'\caption{')
1335 
1336     def depart_caption(self, node: Element) -> None:
1337         self.body.append('}')
1338         if isinstance(node.parent, nodes.figure):
1339             labels = self.hypertarget_to(node.parent)
1340             self.body.append(labels)
1341         self.in_caption -= 1
1342 
1343     def visit_legend(self, node: Element) -> None:
1344         self.body.append(CR + r'\begin{sphinxlegend}')
1345 
1346     def depart_legend(self, node: Element) -> None:
1347         self.body.append(r'\end{sphinxlegend}' + CR)
1348 
1349     def visit_admonition(self, node: Element) -> None:
1350         self.body.append(CR + r'\begin{sphinxadmonition}{note}')
1351         self.no_latex_floats += 1
1352 
1353     def depart_admonition(self, node: Element) -> None:
1354         self.body.append(r'\end{sphinxadmonition}' + CR)
1355         self.no_latex_floats -= 1
1356 
1357     def _visit_named_admonition(self, node: Element) -> None:
1358         label = admonitionlabels[node.tagname]
1359         self.body.append(CR + r'\begin{sphinxadmonition}{%s}{%s:}' %
1360                          (node.tagname, label))
1361         self.no_latex_floats += 1
1362 
1363     def _depart_named_admonition(self, node: Element) -> None:
1364         self.body.append(r'\end{sphinxadmonition}' + CR)
1365         self.no_latex_floats -= 1
1366 
1367     visit_attention = _visit_named_admonition
1368     depart_attention = _depart_named_admonition
1369     visit_caution = _visit_named_admonition
1370     depart_caution = _depart_named_admonition
1371     visit_danger = _visit_named_admonition
1372     depart_danger = _depart_named_admonition
1373     visit_error = _visit_named_admonition
1374     depart_error = _depart_named_admonition
1375     visit_hint = _visit_named_admonition
1376     depart_hint = _depart_named_admonition
1377     visit_important = _visit_named_admonition
1378     depart_important = _depart_named_admonition
1379     visit_note = _visit_named_admonition
1380     depart_note = _depart_named_admonition
1381     visit_tip = _visit_named_admonition
1382     depart_tip = _depart_named_admonition
1383     visit_warning = _visit_named_admonition
1384     depart_warning = _depart_named_admonition
1385 
1386     def visit_versionmodified(self, node: Element) -> None:
1387         pass
1388 
1389     def depart_versionmodified(self, node: Element) -> None:
1390         pass
1391 
1392     def visit_target(self, node: Element) -> None:
1393         def add_target(id: str) -> None:
1394             # indexing uses standard LaTeX index markup, so the targets
1395             # will be generated differently
1396             if id.startswith('index-'):
1397                 return
1398 
1399             # equations also need no extra blank line nor hypertarget
1400             # TODO: fix this dependency on mathbase extension internals
1401             if id.startswith('equation-'):
1402                 return
1403 
1404             # insert blank line, if the target follows a paragraph node
1405             index = node.parent.index(node)
1406             if index > 0 and isinstance(node.parent[index - 1], nodes.paragraph):
1407                 self.body.append(CR)
1408 
1409             # do not generate \phantomsection in \section{}
1410             anchor = not self.in_title
1411             self.body.append(self.hypertarget(id, anchor=anchor))
1412 
1413         # skip if visitor for next node supports hyperlink
1414         next_node: Node = node
1415         while isinstance(next_node, nodes.target):
1416             next_node = next_node.next_node(ascend=True)
1417 
1418         domain = cast(StandardDomain, self.builder.env.get_domain('std'))
1419         if isinstance(next_node, HYPERLINK_SUPPORT_NODES):
1420             return
1421         elif domain.get_enumerable_node_type(next_node) and domain.get_numfig_title(next_node):
1422             return
1423 
1424         if 'refuri' in node:
1425             return
1426         if 'anonymous' in node:
1427             return
1428         if node.get('refid'):
1429             prev_node = get_prev_node(node)
1430             if isinstance(prev_node, nodes.reference) and node['refid'] == prev_node['refid']:
1431                 # a target for a hyperlink reference having alias
1432                 pass
1433             else:
1434                 add_target(node['refid'])
1435         for id in node['ids']:
1436             add_target(id)
1437 
1438     def depart_target(self, node: Element) -> None:
1439         pass
1440 
1441     def visit_attribution(self, node: Element) -> None:
1442         self.body.append(CR + r'\begin{flushright}' + CR)
1443         self.body.append('---')
1444 
1445     def depart_attribution(self, node: Element) -> None:
1446         self.body.append(CR + r'\end{flushright}' + CR)
1447 
1448     def visit_index(self, node: Element) -> None:
1449         def escape(value: str) -> str:
1450             value = self.encode(value)
1451             value = value.replace(r'\{', r'\sphinxleftcurlybrace{}')
1452             value = value.replace(r'\}', r'\sphinxrightcurlybrace{}')
1453             value = value.replace('"', '""')
1454             value = value.replace('@', '"@')
1455             value = value.replace('!', '"!')
1456             value = value.replace('|', r'\textbar{}')
1457             return value
1458 
1459         def style(string: str) -> str:
1460             match = EXTRA_RE.match(string)
1461             if match:
1462                 return match.expand(r'\\spxentry{\1}\\spxextra{\2}')
1463             else:
1464                 return r'\spxentry{%s}' % string
1465 
1466         if not node.get('inline', True):
1467             self.body.append(CR)
1468         entries = node['entries']
1469         for type, string, _tid, ismain, _key in entries:
1470             m = ''
1471             if ismain:
1472                 m = '|spxpagem'
1473             try:
1474                 if type == 'single':
1475                     try:
1476                         p1, p2 = [escape(x) for x in split_into(2, 'single', string)]
1477                         P1, P2 = style(p1), style(p2)
1478                         self.body.append(r'\index{%s@%s!%s@%s%s}' % (p1, P1, p2, P2, m))
1479                     except ValueError:
1480                         p = escape(split_into(1, 'single', string)[0])
1481                         P = style(p)
1482                         self.body.append(r'\index{%s@%s%s}' % (p, P, m))
1483                 elif type == 'pair':
1484                     p1, p2 = [escape(x) for x in split_into(2, 'pair', string)]
1485                     P1, P2 = style(p1), style(p2)
1486                     self.body.append(r'\index{%s@%s!%s@%s%s}\index{%s@%s!%s@%s%s}' %
1487                                      (p1, P1, p2, P2, m, p2, P2, p1, P1, m))
1488                 elif type == 'triple':
1489                     p1, p2, p3 = [escape(x) for x in split_into(3, 'triple', string)]
1490                     P1, P2, P3 = style(p1), style(p2), style(p3)
1491                     self.body.append(
1492                         r'\index{%s@%s!%s %s@%s %s%s}'
1493                         r'\index{%s@%s!%s, %s@%s, %s%s}'
1494                         r'\index{%s@%s!%s %s@%s %s%s}' %
1495                         (p1, P1, p2, p3, P2, P3, m,
1496                          p2, P2, p3, p1, P3, P1, m,
1497                          p3, P3, p1, p2, P1, P2, m))
1498                 elif type == 'see':
1499                     p1, p2 = [escape(x) for x in split_into(2, 'see', string)]
1500                     P1 = style(p1)
1501                     self.body.append(r'\index{%s@%s|see{%s}}' % (p1, P1, p2))
1502                 elif type == 'seealso':
1503                     p1, p2 = [escape(x) for x in split_into(2, 'seealso', string)]
1504                     P1 = style(p1)
1505                     self.body.append(r'\index{%s@%s|see{%s}}' % (p1, P1, p2))
1506                 else:
1507                     logger.warning(__('unknown index entry type %s found'), type)
1508             except ValueError as err:
1509                 logger.warning(str(err))
1510         if not node.get('inline', True):
1511             self.body.append(r'\ignorespaces ')
1512         raise nodes.SkipNode
1513 
1514     def visit_raw(self, node: Element) -> None:
1515         if not self.is_inline(node):
1516             self.body.append(CR)
1517         if 'latex' in node.get('format', '').split():
1518             self.body.append(node.astext())
1519         if not self.is_inline(node):
1520             self.body.append(CR)
1521         raise nodes.SkipNode
1522 
1523     def visit_reference(self, node: Element) -> None:
1524         if not self.in_title:
1525             for id in node.get('ids'):
1526                 anchor = not self.in_caption
1527                 self.body += self.hypertarget(id, anchor=anchor)
1528         if not self.is_inline(node):
1529             self.body.append(CR)
1530         uri = node.get('refuri', '')
1531         if not uri and node.get('refid'):
1532             uri = '%' + self.curfilestack[-1] + '#' + node['refid']
1533         if self.in_title or not uri:
1534             self.context.append('')
1535         elif uri.startswith('#'):
1536             # references to labels in the same document
1537             id = self.curfilestack[-1] + ':' + uri[1:]
1538             self.body.append(self.hyperlink(id))
1539             self.body.append(r'\emph{')
1540             if self.config.latex_show_pagerefs and not \
1541                     self.in_production_list:
1542                 self.context.append('}}} (%s)' % self.hyperpageref(id))
1543             else:
1544                 self.context.append('}}}')
1545         elif uri.startswith('%'):
1546             # references to documents or labels inside documents
1547             hashindex = uri.find('#')
1548             if hashindex == -1:
1549                 # reference to the document
1550                 id = uri[1:] + '::doc'
1551             else:
1552                 # reference to a label
1553                 id = uri[1:].replace('#', ':')
1554             self.body.append(self.hyperlink(id))
1555             if (len(node) and
1556                     isinstance(node[0], nodes.Element) and
1557                     'std-term' in node[0].get('classes', [])):
1558                 # don't add a pageref for glossary terms
1559                 self.context.append('}}}')
1560                 # mark up as termreference
1561                 self.body.append(r'\sphinxtermref{')
1562             else:
1563                 self.body.append(r'\sphinxcrossref{')
1564                 if self.config.latex_show_pagerefs and not self.in_production_list:
1565                     self.context.append('}}} (%s)' % self.hyperpageref(id))
1566                 else:
1567                     self.context.append('}}}')
1568         else:
1569             if len(node) == 1 and uri == node[0]:
1570                 if node.get('nolinkurl'):
1571                     self.body.append(r'\sphinxnolinkurl{%s}' % self.encode_uri(uri))
1572                 else:
1573                     self.body.append(r'\sphinxurl{%s}' % self.encode_uri(uri))
1574                 raise nodes.SkipNode
1575             else:
1576                 self.body.append(r'\sphinxhref{%s}{' % self.encode_uri(uri))
1577                 self.context.append('}')
1578 
1579     def depart_reference(self, node: Element) -> None:
1580         self.body.append(self.context.pop())
1581         if not self.is_inline(node):
1582             self.body.append(CR)
1583 
1584     def visit_number_reference(self, node: Element) -> None:
1585         if node.get('refid'):
1586             id = self.curfilestack[-1] + ':' + node['refid']
1587         else:
1588             id = node.get('refuri', '')[1:].replace('#', ':')
1589 
1590         title = self.escape(node.get('title', '%s')).replace(r'\%s', '%s')
1591         if r'\{name\}' in title or r'\{number\}' in title:
1592             # new style format (cf. "Fig.%{number}")
1593             title = title.replace(r'\{name\}', '{name}').replace(r'\{number\}', '{number}')
1594             text = escape_abbr(title).format(name=r'\nameref{%s}' % self.idescape(id),
1595                                              number=r'\ref{%s}' % self.idescape(id))
1596         else:
1597             # old style format (cf. "Fig.%{number}")
1598             text = escape_abbr(title) % (r'\ref{%s}' % self.idescape(id))
1599         hyperref = r'\hyperref[%s]{%s}' % (self.idescape(id), text)
1600         self.body.append(hyperref)
1601 
1602         raise nodes.SkipNode
1603 
1604     def visit_download_reference(self, node: Element) -> None:
1605         pass
1606 
1607     def depart_download_reference(self, node: Element) -> None:
1608         pass
1609 
1610     def visit_pending_xref(self, node: Element) -> None:
1611         pass
1612 
1613     def depart_pending_xref(self, node: Element) -> None:
1614         pass
1615 
1616     def visit_emphasis(self, node: Element) -> None:
1617         self.body.append(r'\sphinxstyleemphasis{')
1618 
1619     def depart_emphasis(self, node: Element) -> None:
1620         self.body.append('}')
1621 
1622     def visit_literal_emphasis(self, node: Element) -> None:
1623         self.body.append(r'\sphinxstyleliteralemphasis{\sphinxupquote{')
1624 
1625     def depart_literal_emphasis(self, node: Element) -> None:
1626         self.body.append('}}')
1627 
1628     def visit_strong(self, node: Element) -> None:
1629         self.body.append(r'\sphinxstylestrong{')
1630 
1631     def depart_strong(self, node: Element) -> None:
1632         self.body.append('}')
1633 
1634     def visit_literal_strong(self, node: Element) -> None:
1635         self.body.append(r'\sphinxstyleliteralstrong{\sphinxupquote{')
1636 
1637     def depart_literal_strong(self, node: Element) -> None:
1638         self.body.append('}}')
1639 
1640     def visit_abbreviation(self, node: Element) -> None:
1641         abbr = node.astext()
1642         self.body.append(r'\sphinxstyleabbreviation{')
1643         # spell out the explanation once
1644         if node.hasattr('explanation') and abbr not in self.handled_abbrs:
1645             self.context.append('} (%s)' % self.encode(node['explanation']))
1646             self.handled_abbrs.add(abbr)
1647         else:
1648             self.context.append('}')
1649 
1650     def depart_abbreviation(self, node: Element) -> None:
1651         self.body.append(self.context.pop())
1652 
1653     def visit_manpage(self, node: Element) -> None:
1654         return self.visit_literal_emphasis(node)
1655 
1656     def depart_manpage(self, node: Element) -> None:
1657         return self.depart_literal_emphasis(node)
1658 
1659     def visit_title_reference(self, node: Element) -> None:
1660         self.body.append(r'\sphinxtitleref{')
1661 
1662     def depart_title_reference(self, node: Element) -> None:
1663         self.body.append('}')
1664 
1665     def visit_thebibliography(self, node: Element) -> None:
1666         citations = cast(Iterable[nodes.citation], node)
1667         labels = (cast(nodes.label, citation[0]) for citation in citations)
1668         longest_label = max((label.astext() for label in labels), key=len)
1669         if len(longest_label) > MAX_CITATION_LABEL_LENGTH:
1670             # adjust max width of citation labels not to break the layout
1671             longest_label = longest_label[:MAX_CITATION_LABEL_LENGTH]
1672 
1673         self.body.append(CR + r'\begin{sphinxthebibliography}{%s}' %
1674                          self.encode(longest_label) + CR)
1675 
1676     def depart_thebibliography(self, node: Element) -> None:
1677         self.body.append(r'\end{sphinxthebibliography}' + CR)
1678 
1679     def visit_citation(self, node: Element) -> None:
1680         label = cast(nodes.label, node[0])
1681         self.body.append(r'\bibitem[%s]{%s:%s}' % (self.encode(label.astext()),
1682                                                    node['docname'], node['ids'][0]))
1683 
1684     def depart_citation(self, node: Element) -> None:
1685         pass
1686 
1687     def visit_citation_reference(self, node: Element) -> None:
1688         if self.in_title:
1689             pass
1690         else:
1691             self.body.append(r'\sphinxcite{%s:%s}' % (node['docname'], node['refname']))
1692             raise nodes.SkipNode
1693 
1694     def depart_citation_reference(self, node: Element) -> None:
1695         pass
1696 
1697     def visit_literal(self, node: Element) -> None:
1698         if self.in_title:
1699             self.body.append(r'\sphinxstyleliteralintitle{\sphinxupquote{')
1700         elif 'kbd' in node['classes']:
1701             self.body.append(r'\sphinxkeyboard{\sphinxupquote{')
1702         else:
1703             self.body.append(r'\sphinxcode{\sphinxupquote{')
1704 
1705     def depart_literal(self, node: Element) -> None:
1706         self.body.append('}}')
1707 
1708     def visit_footnote_reference(self, node: Element) -> None:
1709         raise nodes.SkipNode
1710 
1711     def visit_footnotemark(self, node: Element) -> None:
1712         self.body.append(r'\sphinxfootnotemark[')
1713 
1714     def depart_footnotemark(self, node: Element) -> None:
1715         self.body.append(']')
1716 
1717     def visit_footnotetext(self, node: Element) -> None:
1718         label = cast(nodes.label, node[0])
1719         self.body.append('%' + CR)
1720         self.body.append(r'\begin{footnotetext}[%s]'
1721                          r'\phantomsection\label{\thesphinxscope.%s}%%'
1722                          % (label.astext(), label.astext()) + CR)
1723         self.body.append(r'\sphinxAtStartFootnote' + CR)
1724 
1725     def depart_footnotetext(self, node: Element) -> None:
1726         # the \ignorespaces in particular for after table header use
1727         self.body.append('%' + CR)
1728         self.body.append(r'\end{footnotetext}\ignorespaces ')
1729 
1730     def visit_captioned_literal_block(self, node: Element) -> None:
1731         pass
1732 
1733     def depart_captioned_literal_block(self, node: Element) -> None:
1734         pass
1735 
1736     def visit_literal_block(self, node: Element) -> None:
1737         if node.rawsource != node.astext():
1738             # most probably a parsed-literal block -- don't highlight
1739             self.in_parsed_literal += 1
1740             self.body.append(r'\begin{sphinxalltt}' + CR)
1741         else:
1742             labels = self.hypertarget_to(node)
1743             if isinstance(node.parent, captioned_literal_block):
1744                 labels += self.hypertarget_to(node.parent)
1745             if labels and not self.in_footnote:
1746                 self.body.append(CR + r'\def\sphinxLiteralBlockLabel{' + labels + '}')
1747 
1748             lang = node.get('language', 'default')
1749             linenos = node.get('linenos', False)
1750             highlight_args = node.get('highlight_args', {})
1751             highlight_args['force'] = node.get('force', False)
1752             opts = self.config.highlight_options.get(lang, {})
1753 
1754             hlcode = self.highlighter.highlight_block(
1755                 node.rawsource, lang, opts=opts, linenos=linenos,
1756                 location=node, **highlight_args
1757             )
1758             if self.in_footnote:
1759                 self.body.append(CR + r'\sphinxSetupCodeBlockInFootnote')
1760                 hlcode = hlcode.replace(r'\begin{Verbatim}',
1761                                         r'\begin{sphinxVerbatim}')
1762             # if in table raise verbatim flag to avoid "tabulary" environment
1763             # and opt for sphinxVerbatimintable to handle caption & long lines
1764             elif self.table:
1765                 self.table.has_problematic = True
1766                 self.table.has_verbatim = True
1767                 hlcode = hlcode.replace(r'\begin{Verbatim}',
1768                                         r'\begin{sphinxVerbatimintable}')
1769             else:
1770                 hlcode = hlcode.replace(r'\begin{Verbatim}',
1771                                         r'\begin{sphinxVerbatim}')
1772             # get consistent trailer
1773             hlcode = hlcode.rstrip()[:-14]  # strip \end{Verbatim}
1774             if self.table and not self.in_footnote:
1775                 hlcode += r'\end{sphinxVerbatimintable}'
1776             else:
1777                 hlcode += r'\end{sphinxVerbatim}'
1778 
1779             hllines = str(highlight_args.get('hl_lines', []))[1:-1]
1780             if hllines:
1781                 self.body.append(CR + r'\fvset{hllines={, %s,}}%%' % hllines)
1782             self.body.append(CR + hlcode + CR)
1783             if hllines:
1784                 self.body.append(r'\sphinxresetverbatimhllines' + CR)
1785             raise nodes.SkipNode
1786 
1787     def depart_literal_block(self, node: Element) -> None:
1788         self.body.append(CR + r'\end{sphinxalltt}' + CR)
1789         self.in_parsed_literal -= 1
1790     visit_doctest_block = visit_literal_block
1791     depart_doctest_block = depart_literal_block
1792 
1793     def visit_line(self, node: Element) -> None:
1794         self.body.append(r'\item[] ')
1795 
1796     def depart_line(self, node: Element) -> None:
1797         self.body.append(CR)
1798 
1799     def visit_line_block(self, node: Element) -> None:
1800         if isinstance(node.parent, nodes.line_block):
1801             self.body.append(r'\item[]' + CR)
1802             self.body.append(r'\begin{DUlineblock}{\DUlineblockindent}' + CR)
1803         else:
1804             self.body.append(CR + r'\begin{DUlineblock}{0em}' + CR)
1805         if self.table:
1806             self.table.has_problematic = True
1807 
1808     def depart_line_block(self, node: Element) -> None:
1809         self.body.append(r'\end{DUlineblock}' + CR)
1810 
1811     def visit_block_quote(self, node: Element) -> None:
1812         # If the block quote contains a single object and that object
1813         # is a list, then generate a list not a block quote.
1814         # This lets us indent lists.
1815         done = 0
1816         if len(node.children) == 1:
1817             child = node.children[0]
1818             if isinstance(child, (nodes.bullet_list, nodes.enumerated_list)):
1819                 done = 1
1820         if not done:
1821             self.body.append(r'\begin{quote}' + CR)
1822             if self.table:
1823                 self.table.has_problematic = True
1824 
1825     def depart_block_quote(self, node: Element) -> None:
1826         done = 0
1827         if len(node.children) == 1:
1828             child = node.children[0]
1829             if isinstance(child, (nodes.bullet_list, nodes.enumerated_list)):
1830                 done = 1
1831         if not done:
1832             self.body.append(r'\end{quote}' + CR)
1833 
1834     # option node handling copied from docutils' latex writer
1835 
1836     def visit_option(self, node: Element) -> None:
1837         if self.context[-1]:
1838             # this is not the first option
1839             self.body.append(', ')
1840 
1841     def depart_option(self, node: Element) -> None:
1842         # flag that the first option is done.
1843         self.context[-1] += 1
1844 
1845     def visit_option_argument(self, node: Element) -> None:
1846         """The delimiter between an option and its argument."""
1847         self.body.append(node.get('delimiter', ' '))
1848 
1849     def depart_option_argument(self, node: Element) -> None:
1850         pass
1851 
1852     def visit_option_group(self, node: Element) -> None:
1853         self.body.append(r'\item [')
1854         # flag for first option
1855         self.context.append(0)
1856 
1857     def depart_option_group(self, node: Element) -> None:
1858         self.context.pop()  # the flag
1859         self.body.append('] ')
1860 
1861     def visit_option_list(self, node: Element) -> None:
1862         self.body.append(r'\begin{optionlist}{3cm}' + CR)
1863         if self.table:
1864             self.table.has_problematic = True
1865 
1866     def depart_option_list(self, node: Element) -> None:
1867         self.body.append(r'\end{optionlist}' + CR)
1868 
1869     def visit_option_list_item(self, node: Element) -> None:
1870         pass
1871 
1872     def depart_option_list_item(self, node: Element) -> None:
1873         pass
1874 
1875     def visit_option_string(self, node: Element) -> None:
1876         ostring = node.astext()
1877         self.body.append(self.encode(ostring))
1878         raise nodes.SkipNode
1879 
1880     def visit_description(self, node: Element) -> None:
1881         self.body.append(' ')
1882 
1883     def depart_description(self, node: Element) -> None:
1884         pass
1885 
1886     def visit_superscript(self, node: Element) -> None:
1887         self.body.append(r'$^{\text{')
1888 
1889     def depart_superscript(self, node: Element) -> None:
1890         self.body.append('}}$')
1891 
1892     def visit_subscript(self, node: Element) -> None:
1893         self.body.append(r'$_{\text{')
1894 
1895     def depart_subscript(self, node: Element) -> None:
1896         self.body.append('}}$')
1897 
1898     def visit_inline(self, node: Element) -> None:
1899         classes = node.get('classes', [])
1900         if classes in [['menuselection']]:
1901             self.body.append(r'\sphinxmenuselection{')
1902             self.context.append('}')
1903         elif classes in [['guilabel']]:
1904             self.body.append(r'\sphinxguilabel{')
1905             self.context.append('}')
1906         elif classes in [['accelerator']]:
1907             self.body.append(r'\sphinxaccelerator{')
1908             self.context.append('}')
1909         elif classes and not self.in_title:
1910             self.body.append(r'\DUrole{%s}{' % ','.join(classes))
1911             self.context.append('}')
1912         else:
1913             self.context.append('')
1914 
1915     def depart_inline(self, node: Element) -> None:
1916         self.body.append(self.context.pop())
1917 
1918     def visit_generated(self, node: Element) -> None:
1919         pass
1920 
1921     def depart_generated(self, node: Element) -> None:
1922         pass
1923 
1924     def visit_compound(self, node: Element) -> None:
1925         pass
1926 
1927     def depart_compound(self, node: Element) -> None:
1928         pass
1929 
1930     def visit_container(self, node: Element) -> None:
1931         classes = node.get('classes', [])
1932         for c in classes:
1933             self.body.append('\n\\begin{sphinxuseclass}{%s}' % c)
1934 
1935     def depart_container(self, node: Element) -> None:
1936         classes = node.get('classes', [])
1937         for _c in classes:
1938             self.body.append('\n\\end{sphinxuseclass}')
1939 
1940     def visit_decoration(self, node: Element) -> None:
1941         pass
1942 
1943     def depart_decoration(self, node: Element) -> None:
1944         pass
1945 
1946     # docutils-generated elements that we don't support
1947 
1948     def visit_header(self, node: Element) -> None:
1949         raise nodes.SkipNode
1950 
1951     def visit_footer(self, node: Element) -> None:
1952         raise nodes.SkipNode
1953 
1954     def visit_docinfo(self, node: Element) -> None:
1955         raise nodes.SkipNode
1956 
1957     # text handling
1958 
1959     def encode(self, text: str) -> str:
1960         text = self.escape(text)
1961         if self.literal_whitespace:
1962             # Insert a blank before the newline, to avoid
1963             # ! LaTeX Error: There's no line here to end.
1964             text = text.replace(CR, r'~\\' + CR).replace(' ', '~')
1965         return text
1966 
1967     def encode_uri(self, text: str) -> str:
1968         # TODO: it is probably wrong that this uses texescape.escape()
1969         #       this must be checked against hyperref package exact dealings
1970         #       mainly, %, #, {, } and \ need escaping via a \ escape
1971         # in \href, the tilde is allowed and must be represented literally
1972         return self.encode(text).replace(r'\textasciitilde{}', '~').\
1973             replace(r'\sphinxhyphen{}', '-').\
1974             replace(r'\textquotesingle{}', "'")
1975 
1976     def visit_Text(self, node: Text) -> None:
1977         text = self.encode(node.astext())
1978         self.body.append(text)
1979 
1980     def depart_Text(self, node: Text) -> None:
1981         pass
1982 
1983     def visit_comment(self, node: Element) -> None:
1984         raise nodes.SkipNode
1985 
1986     def visit_meta(self, node: Element) -> None:
1987         # only valid for HTML
1988         raise nodes.SkipNode
1989 
1990     def visit_system_message(self, node: Element) -> None:
1991         pass
1992 
1993     def depart_system_message(self, node: Element) -> None:
1994         self.body.append(CR)
1995 
1996     def visit_math(self, node: Element) -> None:
1997         if self.in_title:
1998             self.body.append(r'\protect\(%s\protect\)' % node.astext())
1999         else:
2000             self.body.append(r'\(%s\)' % node.astext())
2001         raise nodes.SkipNode
2002 
2003     def visit_math_block(self, node: Element) -> None:
2004         if node.get('label'):
2005             label = "equation:%s:%s" % (node['docname'], node['label'])
2006         else:
2007             label = None
2008 
2009         if node.get('nowrap'):
2010             if label:
2011                 self.body.append(r'\label{%s}' % label)
2012             self.body.append(node.astext())
2013         else:
2014             from sphinx.util.math import wrap_displaymath
2015             self.body.append(wrap_displaymath(node.astext(), label,
2016                                               self.config.math_number_all))
2017         raise nodes.SkipNode
2018 
2019     def visit_math_reference(self, node: Element) -> None:
2020         label = "equation:%s:%s" % (node['docname'], node['target'])
2021         eqref_format = self.config.math_eqref_format
2022         if eqref_format:
2023             try:
2024                 ref = r'\ref{%s}' % label
2025                 self.body.append(eqref_format.format(number=ref))
2026             except KeyError as exc:
2027                 logger.warning(__('Invalid math_eqref_format: %r'), exc,
2028                                location=node)
2029                 self.body.append(r'\eqref{%s}' % label)
2030         else:
2031             self.body.append(r'\eqref{%s}' % label)
2032 
2033     def depart_math_reference(self, node: Element) -> None:
2034         pass
2035 
2036     @property
2037     def docclasses(self) -> Tuple[str, str]:
2038         """Prepends prefix to sphinx document classes"""
2039         warnings.warn('LaTeXWriter.docclasses() is deprecated.',
2040                       RemovedInSphinx70Warning, stacklevel=2)
2041         return ('howto', 'manual')
2042 
2043 
2044 # FIXME: Workaround to avoid circular import
2045 # refs: https://github.com/sphinx-doc/sphinx/issues/5433
2046 from sphinx.builders.latex.nodes import ( # NOQA isort:skip
2047     HYPERLINK_SUPPORT_NODES, captioned_literal_block, footnotetext,
2048 )

</code><intended_behavior>This file should ensure that explicitly numbered footnotes and their references are correctly handled in a manner that preserves the numbering and hyperlinking in the LaTeX output. The fix should ensure that when a footnote is referenced multiple times, each instance creates a proper hyperlink back to the original footnote in the final PDF document. This behavior will require reviewing and potentially updating the way footnote references are translated into LaTeX, ensuring that each reference correctly points back to its corresponding footnote definition, without losing its numbering or failing to create a hyperlink.</intended_behavior>]
2025-10-18 06:10:59.747 | INFO     | Search completed. Bug locations: [<file>sphinx/writers/latex.py</file>
<class>None</class>
<method>None</method>
<code>
1 """Custom docutils writer for LaTeX.
2 
3 Much of this code is adapted from Dave Kuhlman's "docpy" writer from his
4 docutils sandbox.
5 """
6 
7 import re
8 import warnings
9 from collections import defaultdict
10 from os import path
11 from typing import TYPE_CHECKING, Any, Dict, Iterable, List, Set, Tuple, cast
12 
13 from docutils import nodes, writers
14 from docutils.nodes import Element, Node, Text
15 
16 from sphinx import addnodes, highlighting
17 from sphinx.deprecation import RemovedInSphinx70Warning
18 from sphinx.domains import IndexEntry
19 from sphinx.domains.std import StandardDomain
20 from sphinx.errors import SphinxError
21 from sphinx.locale import _, __, admonitionlabels
22 from sphinx.util import logging, split_into, texescape
23 from sphinx.util.docutils import SphinxTranslator
24 from sphinx.util.nodes import clean_astext, get_prev_node
25 from sphinx.util.template import LaTeXRenderer
26 from sphinx.util.texescape import tex_replace_map
27 
28 try:
29     from docutils.utils.roman import toRoman
30 except ImportError:
31     # In Debian/Ubuntu, roman package is provided as roman, not as docutils.utils.roman
32     from roman import toRoman  # type: ignore
33 
34 if TYPE_CHECKING:
35     from sphinx.builders.latex import LaTeXBuilder
36     from sphinx.builders.latex.theming import Theme
37 
38 
39 logger = logging.getLogger(__name__)
40 
41 MAX_CITATION_LABEL_LENGTH = 8
42 LATEXSECTIONNAMES = ["part", "chapter", "section", "subsection",
43                      "subsubsection", "paragraph", "subparagraph"]
44 ENUMERATE_LIST_STYLE = defaultdict(lambda: r'\arabic',
45                                    {
46                                        'arabic': r'\arabic',
47                                        'loweralpha': r'\alph',
48                                        'upperalpha': r'\Alph',
49                                        'lowerroman': r'\roman',
50                                        'upperroman': r'\Roman',
51                                    })
52 
53 CR = '\n'
54 BLANKLINE = '\n\n'
55 EXTRA_RE = re.compile(r'^(.*\S)\s+\(([^()]*)\)\s*$')
56 
57 
58 class collected_footnote(nodes.footnote):
59     """Footnotes that are collected are assigned this class."""
60 
61 
62 class UnsupportedError(SphinxError):
63     category = 'Markup is unsupported in LaTeX'
64 
65 
66 class LaTeXWriter(writers.Writer):
67 
68     supported = ('sphinxlatex',)
69 
70     settings_spec = ('LaTeX writer options', '', (
71         ('Document name', ['--docname'], {'default': ''}),
72         ('Document class', ['--docclass'], {'default': 'manual'}),
73         ('Author', ['--author'], {'default': ''}),
74     ))
75     settings_defaults: Dict = {}
76 
77     output = None
78 
79     def __init__(self, builder: "LaTeXBuilder") -> None:
80         super().__init__()
81         self.builder = builder
82         self.theme: Theme = None
83 
84     def translate(self) -> None:
85         visitor = self.builder.create_translator(self.document, self.builder, self.theme)
86         self.document.walkabout(visitor)
87         self.output = cast(LaTeXTranslator, visitor).astext()
88 
89 
90 # Helper classes
91 
92 class Table:
93     """A table data"""
94 
95     def __init__(self, node: Element) -> None:
96         self.header: List[str] = []
97         self.body: List[str] = []
98         self.align = node.get('align', 'default')
99         self.classes: List[str] = node.get('classes', [])
100         self.colcount = 0
101         self.colspec: str = None
102         self.colwidths: List[int] = []
103         self.has_problematic = False
104         self.has_oldproblematic = False
105         self.has_verbatim = False
106         self.caption: List[str] = None
107         self.stubs: List[int] = []
108 
109         # current position
110         self.col = 0
111         self.row = 0
112 
113         # A dict mapping a table location to a cell_id (cell = rectangular area)
114         self.cells: Dict[Tuple[int, int], int] = defaultdict(int)
115         self.cell_id = 0  # last assigned cell_id
116 
117     def is_longtable(self) -> bool:
118         """True if and only if table uses longtable environment."""
119         return self.row > 30 or 'longtable' in self.classes
120 
121     def get_table_type(self) -> str:
122         """Returns the LaTeX environment name for the table.
123 
124         The class currently supports:
125 
126         * longtable
127         * tabular
128         * tabulary
129         """
130         if self.is_longtable():
131             return 'longtable'
132         elif self.has_verbatim:
133             return 'tabular'
134         elif self.colspec:
135             return 'tabulary'
136         elif self.has_problematic or (self.colwidths and 'colwidths-given' in self.classes):
137             return 'tabular'
138         else:
139             return 'tabulary'
140 
141     def get_colspec(self) -> str:
142         """Returns a column spec of table.
143 
144         This is what LaTeX calls the 'preamble argument' of the used table environment.
145 
146         .. note:: the ``\\X`` and ``T`` column type specifiers are defined in ``sphinx.sty``.
147         """
148         if self.colspec:
149             return self.colspec
150         elif self.colwidths and 'colwidths-given' in self.classes:
151             total = sum(self.colwidths)
152             colspecs = [r'\X{%d}{%d}' % (width, total) for width in self.colwidths]
153             return '{|%s|}' % '|'.join(colspecs) + CR
154         elif self.has_problematic:
155             return r'{|*{%d}{\X{1}{%d}|}}' % (self.colcount, self.colcount) + CR
156         elif self.get_table_type() == 'tabulary':
157             # sphinx.sty sets T to be J by default.
158             return '{|' + ('T|' * self.colcount) + '}' + CR
159         elif self.has_oldproblematic:
160             return r'{|*{%d}{\X{1}{%d}|}}' % (self.colcount, self.colcount) + CR
161         else:
162             return '{|' + ('l|' * self.colcount) + '}' + CR
163 
164     def add_cell(self, height: int, width: int) -> None:
165         """Adds a new cell to a table.
166 
167         It will be located at current position: (``self.row``, ``self.col``).
168         """
169         self.cell_id += 1
170         for col in range(width):
171             for row in range(height):
172                 assert self.cells[(self.row + row, self.col + col)] == 0
173                 self.cells[(self.row + row, self.col + col)] = self.cell_id
174 
175     def cell(self, row: int = None, col: int = None) -> "TableCell":
176         """Returns a cell object (i.e. rectangular area) containing given position.
177 
178         If no option arguments: ``row`` or ``col`` are given, the current position;
179         ``self.row`` and ``self.col`` are used to get a cell object by default.
180         """
181         try:
182             if row is None:
183                 row = self.row
184             if col is None:
185                 col = self.col
186             return TableCell(self, row, col)
187         except IndexError:
188             return None
189 
190 
191 class TableCell:
192     """Data of a cell in a table."""
193 
194     def __init__(self, table: Table, row: int, col: int) -> None:
195         if table.cells[(row, col)] == 0:
196             raise IndexError
197 
198         self.table = table
199         self.cell_id = table.cells[(row, col)]
200         self.row = row
201         self.col = col
202 
203         # adjust position for multirow/multicol cell
204         while table.cells[(self.row - 1, self.col)] == self.cell_id:
205             self.row -= 1
206         while table.cells[(self.row, self.col - 1)] == self.cell_id:
207             self.col -= 1
208 
209     @property
210     def width(self) -> int:
211         """Returns the cell width."""
212         width = 0
213         while self.table.cells[(self.row, self.col + width)] == self.cell_id:
214             width += 1
215         return width
216 
217     @property
218     def height(self) -> int:
219         """Returns the cell height."""
220         height = 0
221         while self.table.cells[(self.row + height, self.col)] == self.cell_id:
222             height += 1
223         return height
224 
225 
226 def escape_abbr(text: str) -> str:
227     """Adjust spacing after abbreviations."""
228     return re.sub(r'\.(?=\s|$)', r'.\@', text)
229 
230 
231 def rstdim_to_latexdim(width_str: str, scale: int = 100) -> str:
232     """Convert `width_str` with rst length to LaTeX length."""
233     match = re.match(r'^(\d*\.?\d*)\s*(\S*)$', width_str)
234     if not match:
235         raise ValueError
236     res = width_str
237     amount, unit = match.groups()[:2]
238     if scale == 100:
239         float(amount)  # validate amount is float
240         if unit in ('', "px"):
241             res = r"%s\sphinxpxdimen" % amount
242         elif unit == 'pt':
243             res = '%sbp' % amount  # convert to 'bp'
244         elif unit == "%":
245             res = r"%.3f\linewidth" % (float(amount) / 100.0)
246     else:
247         amount_float = float(amount) * scale / 100.0
248         if unit in ('', "px"):
249             res = r"%.5f\sphinxpxdimen" % amount_float
250         elif unit == 'pt':
251             res = '%.5fbp' % amount_float
252         elif unit == "%":
253             res = r"%.5f\linewidth" % (amount_float / 100.0)
254         else:
255             res = "%.5f%s" % (amount_float, unit)
256     return res
257 
258 
259 class LaTeXTranslator(SphinxTranslator):
260     builder: "LaTeXBuilder" = None
261 
262     secnumdepth = 2  # legacy sphinxhowto.cls uses this, whereas article.cls
263     # default is originally 3. For book/report, 2 is already LaTeX default.
264     ignore_missing_images = False
265 
266     def __init__(self, document: nodes.document, builder: "LaTeXBuilder",
267                  theme: "Theme") -> None:
268         super().__init__(document, builder)
269         self.body: List[str] = []
270         self.theme = theme
271 
272         # flags
273         self.in_title = 0
274         self.in_production_list = 0
275         self.in_footnote = 0
276         self.in_caption = 0
277         self.in_term = 0
278         self.needs_linetrimming = 0
279         self.in_minipage = 0
280         self.no_latex_floats = 0
281         self.first_document = 1
282         self.this_is_the_title = 1
283         self.literal_whitespace = 0
284         self.in_parsed_literal = 0
285         self.compact_list = 0
286         self.first_param = 0
287         self.in_desc_signature = False
288 
289         sphinxpkgoptions = []
290 
291         # sort out some elements
292         self.elements = self.builder.context.copy()
293 
294         # initial section names
295         self.sectionnames = LATEXSECTIONNAMES[:]
296         if self.theme.toplevel_sectioning == 'section':
297             self.sectionnames.remove('chapter')
298 
299         # determine top section level
300         self.top_sectionlevel = 1
301         if self.config.latex_toplevel_sectioning:
302             try:
303                 self.top_sectionlevel = \
304                     self.sectionnames.index(self.config.latex_toplevel_sectioning)
305             except ValueError:
306                 logger.warning(__('unknown %r toplevel_sectioning for class %r') %
307                                (self.config.latex_toplevel_sectioning, self.theme.docclass))
308 
309         if self.config.numfig:
310             self.numfig_secnum_depth = self.config.numfig_secnum_depth
311             if self.numfig_secnum_depth > 0:  # default is 1
312                 # numfig_secnum_depth as passed to sphinx.sty indices same names as in
313                 # LATEXSECTIONNAMES but with -1 for part, 0 for chapter, 1 for section...
314                 if len(self.sectionnames) < len(LATEXSECTIONNAMES) and \
315                    self.top_sectionlevel > 0:
316                     self.numfig_secnum_depth += self.top_sectionlevel
317                 else:
318                     self.numfig_secnum_depth += self.top_sectionlevel - 1
319                 # this (minus one) will serve as minimum to LaTeX's secnumdepth
320                 self.numfig_secnum_depth = min(self.numfig_secnum_depth,
321                                                len(LATEXSECTIONNAMES) - 1)
322                 # if passed key value is < 1 LaTeX will act as if 0; see sphinx.sty
323                 sphinxpkgoptions.append('numfigreset=%s' % self.numfig_secnum_depth)
324             else:
325                 sphinxpkgoptions.append('nonumfigreset')
326 
327         if self.config.numfig and self.config.math_numfig:
328             sphinxpkgoptions.append('mathnumfig')
329 
330         if (self.config.language not in {'en', 'ja'} and
331                 'fncychap' not in self.config.latex_elements):
332             # use Sonny style if any language specified (except English)
333             self.elements['fncychap'] = (r'\usepackage[Sonny]{fncychap}' + CR +
334                                          r'\ChNameVar{\Large\normalfont\sffamily}' + CR +
335                                          r'\ChTitleVar{\Large\normalfont\sffamily}')
336 
337         self.babel = self.builder.babel
338         if not self.babel.is_supported_language():
339             # emit warning if specified language is invalid
340             # (only emitting, nothing changed to processing)
341             logger.warning(__('no Babel option known for language %r'),
342                            self.config.language)
343 
344         minsecnumdepth = self.secnumdepth  # 2 from legacy sphinx manual/howto
345         if self.document.get('tocdepth'):
346             # reduce tocdepth if `part` or `chapter` is used for top_sectionlevel
347             #   tocdepth = -1: show only parts
348             #   tocdepth =  0: show parts and chapters
349             #   tocdepth =  1: show parts, chapters and sections
350             #   tocdepth =  2: show parts, chapters, sections and subsections
351             #   ...
352             tocdepth = self.document.get('tocdepth', 999) + self.top_sectionlevel - 2
353             if len(self.sectionnames) < len(LATEXSECTIONNAMES) and \
354                self.top_sectionlevel > 0:
355                 tocdepth += 1  # because top_sectionlevel is shifted by -1
356             if tocdepth > len(LATEXSECTIONNAMES) - 2:  # default is 5 <-> subparagraph
357                 logger.warning(__('too large :maxdepth:, ignored.'))
358                 tocdepth = len(LATEXSECTIONNAMES) - 2
359 
360             self.elements['tocdepth'] = r'\setcounter{tocdepth}{%d}' % tocdepth
361             minsecnumdepth = max(minsecnumdepth, tocdepth)
362 
363         if self.config.numfig and (self.config.numfig_secnum_depth > 0):
364             minsecnumdepth = max(minsecnumdepth, self.numfig_secnum_depth - 1)
365 
366         if minsecnumdepth > self.secnumdepth:
367             self.elements['secnumdepth'] = r'\setcounter{secnumdepth}{%d}' %\
368                                            minsecnumdepth
369 
370         contentsname = document.get('contentsname')
371         if contentsname:
372             self.elements['contentsname'] = self.babel_renewcommand(r'\contentsname',
373                                                                     contentsname)
374 
375         if self.elements['maxlistdepth']:
376             sphinxpkgoptions.append('maxlistdepth=%s' % self.elements['maxlistdepth'])
377         if sphinxpkgoptions:
378             self.elements['sphinxpkgoptions'] = '[,%s]' % ','.join(sphinxpkgoptions)
379         if self.elements['sphinxsetup']:
380             self.elements['sphinxsetup'] = (r'\sphinxsetup{%s}' % self.elements['sphinxsetup'])
381         if self.elements['extraclassoptions']:
382             self.elements['classoptions'] += ',' + \
383                                              self.elements['extraclassoptions']
384 
385         self.highlighter = highlighting.PygmentsBridge('latex', self.config.pygments_style,
386                                                        latex_engine=self.config.latex_engine)
387         self.context: List[Any] = []
388         self.descstack: List[str] = []
389         self.tables: List[Table] = []
390         self.next_table_colspec: str = None
391         self.bodystack: List[List[str]] = []
392         self.footnote_restricted: Element = None
393         self.pending_footnotes: List[nodes.footnote_reference] = []
394         self.curfilestack: List[str] = []
395         self.handled_abbrs: Set[str] = set()
396 
397     def pushbody(self, newbody: List[str]) -> None:
398         self.bodystack.append(self.body)
399         self.body = newbody
400 
401     def popbody(self) -> List[str]:
402         body = self.body
403         self.body = self.bodystack.pop()
404         return body
405 
406     def astext(self) -> str:
407         self.elements.update({
408             'body': ''.join(self.body),
409             'indices': self.generate_indices()
410         })
411         return self.render('latex.tex_t', self.elements)
412 
413     def hypertarget(self, id: str, withdoc: bool = True, anchor: bool = True) -> str:
414         if withdoc:
415             id = self.curfilestack[-1] + ':' + id
416         return (r'\phantomsection' if anchor else '') + r'\label{%s}' % self.idescape(id)
417 
418     def hypertarget_to(self, node: Element, anchor: bool = False) -> str:
419         labels = ''.join(self.hypertarget(node_id, anchor=False) for node_id in node['ids'])
420         if anchor:
421             return r'\phantomsection' + labels
422         else:
423             return labels
424 
425     def hyperlink(self, id: str) -> str:
426         return r'{\hyperref[%s]{' % self.idescape(id)
427 
428     def hyperpageref(self, id: str) -> str:
429         return r'\autopageref*{%s}' % self.idescape(id)
430 
431     def escape(self, s: str) -> str:
432         return texescape.escape(s, self.config.latex_engine)
433 
434     def idescape(self, id: str) -> str:
435         return r'\detokenize{%s}' % str(id).translate(tex_replace_map).\
436             encode('ascii', 'backslashreplace').decode('ascii').\
437             replace('\\', '_')
438 
439     def babel_renewcommand(self, command: str, definition: str) -> str:
440         if self.elements['multilingual']:
441             prefix = r'\addto\captions%s{' % self.babel.get_language()
442             suffix = '}'
443         else:  # babel is disabled (mainly for Japanese environment)
444             prefix = ''
445             suffix = ''
446 
447         return r'%s\renewcommand{%s}{%s}%s' % (prefix, command, definition, suffix) + CR
448 
449     def generate_indices(self) -> str:
450         def generate(content: List[Tuple[str, List[IndexEntry]]], collapsed: bool) -> None:
451             ret.append(r'\begin{sphinxtheindex}' + CR)
452             ret.append(r'\let\bigletter\sphinxstyleindexlettergroup' + CR)
453             for i, (letter, entries) in enumerate(content):
454                 if i > 0:
455                     ret.append(r'\indexspace' + CR)
456                 ret.append(r'\bigletter{%s}' % self.escape(letter) + CR)
457                 for entry in entries:
458                     if not entry[3]:
459                         continue
460                     ret.append(r'\item\relax\sphinxstyleindexentry{%s}' %
461                                self.encode(entry[0]))
462                     if entry[4]:
463                         # add "extra" info
464                         ret.append(r'\sphinxstyleindexextra{%s}' % self.encode(entry[4]))
465                     ret.append(r'\sphinxstyleindexpageref{%s:%s}' %
466                                (entry[2], self.idescape(entry[3])) + CR)
467             ret.append(r'\end{sphinxtheindex}' + CR)
468 
469         ret = []
470         # latex_domain_indices can be False/True or a list of index names
471         indices_config = self.config.latex_domain_indices
472         if indices_config:
473             for domain in self.builder.env.domains.values():
474                 for indexcls in domain.indices:
475                     indexname = '%s-%s' % (domain.name, indexcls.name)
476                     if isinstance(indices_config, list):
477                         if indexname not in indices_config:
478                             continue
479                     content, collapsed = indexcls(domain).generate(
480                         self.builder.docnames)
481                     if not content:
482                         continue
483                     ret.append(r'\renewcommand{\indexname}{%s}' % indexcls.localname + CR)
484                     generate(content, collapsed)
485 
486         return ''.join(ret)
487 
488     def render(self, template_name: str, variables: Dict) -> str:
489         renderer = LaTeXRenderer(latex_engine=self.config.latex_engine)
490         for template_dir in self.config.templates_path:
491             template = path.join(self.builder.confdir, template_dir,
492                                  template_name)
493             if path.exists(template):
494                 return renderer.render(template, variables)
495 
496         return renderer.render(template_name, variables)
497 
498     @property
499     def table(self) -> Table:
500         """Get current table."""
501         if self.tables:
502             return self.tables[-1]
503         else:
504             return None
505 
506     def visit_document(self, node: Element) -> None:
507         self.curfilestack.append(node.get('docname', ''))
508         if self.first_document == 1:
509             # the first document is all the regular content ...
510             self.first_document = 0
511         elif self.first_document == 0:
512             # ... and all others are the appendices
513             self.body.append(CR + r'\appendix' + CR)
514             self.first_document = -1
515         if 'docname' in node:
516             self.body.append(self.hypertarget(':doc'))
517         # "- 1" because the level is increased before the title is visited
518         self.sectionlevel = self.top_sectionlevel - 1
519 
520     def depart_document(self, node: Element) -> None:
521         pass
522 
523     def visit_start_of_file(self, node: Element) -> None:
524         self.curfilestack.append(node['docname'])
525         self.body.append(CR + r'\sphinxstepscope' + CR)
526 
527     def depart_start_of_file(self, node: Element) -> None:
528         self.curfilestack.pop()
529 
530     def visit_section(self, node: Element) -> None:
531         if not self.this_is_the_title:
532             self.sectionlevel += 1
533         self.body.append(BLANKLINE)
534 
535     def depart_section(self, node: Element) -> None:
536         self.sectionlevel = max(self.sectionlevel - 1,
537                                 self.top_sectionlevel - 1)
538 
539     def visit_problematic(self, node: Element) -> None:
540         self.body.append(r'{\color{red}\bfseries{}')
541 
542     def depart_problematic(self, node: Element) -> None:
543         self.body.append('}')
544 
545     def visit_topic(self, node: Element) -> None:
546         self.in_minipage = 1
547         self.body.append(CR + r'\begin{sphinxShadowBox}' + CR)
548 
549     def depart_topic(self, node: Element) -> None:
550         self.in_minipage = 0
551         self.body.append(r'\end{sphinxShadowBox}' + CR)
552     visit_sidebar = visit_topic
553     depart_sidebar = depart_topic
554 
555     def visit_glossary(self, node: Element) -> None:
556         pass
557 
558     def depart_glossary(self, node: Element) -> None:
559         pass
560 
561     def visit_productionlist(self, node: Element) -> None:
562         self.body.append(BLANKLINE)
563         self.body.append(r'\begin{productionlist}' + CR)
564         self.in_production_list = 1
565 
566     def depart_productionlist(self, node: Element) -> None:
567         self.body.append(r'\end{productionlist}' + BLANKLINE)
568         self.in_production_list = 0
569 
570     def visit_production(self, node: Element) -> None:
571         if node['tokenname']:
572             tn = node['tokenname']
573             self.body.append(self.hypertarget('grammar-token-' + tn))
574             self.body.append(r'\production{%s}{' % self.encode(tn))
575         else:
576             self.body.append(r'\productioncont{')
577 
578     def depart_production(self, node: Element) -> None:
579         self.body.append('}' + CR)
580 
581     def visit_transition(self, node: Element) -> None:
582         self.body.append(self.elements['transition'])
583 
584     def depart_transition(self, node: Element) -> None:
585         pass
586 
587     def visit_title(self, node: Element) -> None:
588         parent = node.parent
589         if isinstance(parent, addnodes.seealso):
590             # the environment already handles this
591             raise nodes.SkipNode
592         elif isinstance(parent, nodes.section):
593             if self.this_is_the_title:
594                 if len(node.children) != 1 and not isinstance(node.children[0],
595                                                               nodes.Text):
596                     logger.warning(__('document title is not a single Text node'),
597                                    location=node)
598                 if not self.elements['title']:
599                     # text needs to be escaped since it is inserted into
600                     # the output literally
601                     self.elements['title'] = self.escape(node.astext())
602                 self.this_is_the_title = 0
603                 raise nodes.SkipNode
604             else:
605                 short = ''
606                 if any(node.findall(nodes.image)):
607                     short = ('[%s]' % self.escape(' '.join(clean_astext(node).split())))
608 
609                 try:
610                     self.body.append(r'\%s%s{' % (self.sectionnames[self.sectionlevel], short))
611                 except IndexError:
612                     # just use "subparagraph", it's not numbered anyway
613                     self.body.append(r'\%s%s{' % (self.sectionnames[-1], short))
614                 self.context.append('}' + CR + self.hypertarget_to(node.parent))
615         elif isinstance(parent, nodes.topic):
616             self.body.append(r'\sphinxstyletopictitle{')
617             self.context.append('}' + CR)
618         elif isinstance(parent, nodes.sidebar):
619             self.body.append(r'\sphinxstylesidebartitle{')
620             self.context.append('}' + CR)
621         elif isinstance(parent, nodes.Admonition):
622             self.body.append('{')
623             self.context.append('}' + CR)
624         elif isinstance(parent, nodes.table):
625             # Redirect body output until title is finished.
626             self.pushbody([])
627         else:
628             logger.warning(__('encountered title node not in section, topic, table, '
629                               'admonition or sidebar'),
630                            location=node)
631             self.body.append(r'\sphinxstyleothertitle{')
632             self.context.append('}' + CR)
633         self.in_title = 1
634 
635     def depart_title(self, node: Element) -> None:
636         self.in_title = 0
637         if isinstance(node.parent, nodes.table):
638             self.table.caption = self.popbody()
639         else:
640             self.body.append(self.context.pop())
641 
642     def visit_subtitle(self, node: Element) -> None:
643         if isinstance(node.parent, nodes.sidebar):
644             self.body.append(r'\sphinxstylesidebarsubtitle{')
645             self.context.append('}' + CR)
646         else:
647             self.context.append('')
648 
649     def depart_subtitle(self, node: Element) -> None:
650         self.body.append(self.context.pop())
651 
652     #############################################################
653     # Domain-specific object descriptions
654     #############################################################
655 
656     # Top-level nodes for descriptions
657     ##################################
658 
659     def visit_desc(self, node: Element) -> None:
660         if self.config.latex_show_urls == 'footnote':
661             self.body.append(BLANKLINE)
662             self.body.append(r'\begin{savenotes}\begin{fulllineitems}' + CR)
663         else:
664             self.body.append(BLANKLINE)
665             self.body.append(r'\begin{fulllineitems}' + CR)
666         if self.table:
667             self.table.has_problematic = True
668 
669     def depart_desc(self, node: Element) -> None:
670         if self.in_desc_signature:
671             self.body.append(CR + r'\pysigstopsignatures')
672             self.in_desc_signature = False
673         if self.config.latex_show_urls == 'footnote':
674             self.body.append(CR + r'\end{fulllineitems}\end{savenotes}' + BLANKLINE)
675         else:
676             self.body.append(CR + r'\end{fulllineitems}' + BLANKLINE)
677 
678     def _visit_signature_line(self, node: Element) -> None:
679         for child in node:
680             if isinstance(child, addnodes.desc_parameterlist):
681                 self.body.append(CR + r'\pysiglinewithargsret{')
682                 break
683         else:
684             self.body.append(CR + r'\pysigline{')
685 
686     def _depart_signature_line(self, node: Element) -> None:
687         self.body.append('}')
688 
689     def visit_desc_signature(self, node: Element) -> None:
690         if node.parent['objtype'] != 'describe' and node['ids']:
691             hyper = self.hypertarget(node['ids'][0])
692         else:
693             hyper = ''
694         self.body.append(hyper)
695         if not self.in_desc_signature:
696             self.in_desc_signature = True
697             self.body.append(CR + r'\pysigstartsignatures')
698         if not node.get('is_multiline'):
699             self._visit_signature_line(node)
700         else:
701             self.body.append(CR + r'\pysigstartmultiline')
702 
703     def depart_desc_signature(self, node: Element) -> None:
704         if not node.get('is_multiline'):
705             self._depart_signature_line(node)
706         else:
707             self.body.append(CR + r'\pysigstopmultiline')
708 
709     def visit_desc_signature_line(self, node: Element) -> None:
710         self._visit_signature_line(node)
711 
712     def depart_desc_signature_line(self, node: Element) -> None:
713         self._depart_signature_line(node)
714 
715     def visit_desc_content(self, node: Element) -> None:
716         assert self.in_desc_signature
717         self.body.append(CR + r'\pysigstopsignatures')
718         self.in_desc_signature = False
719 
720     def depart_desc_content(self, node: Element) -> None:
721         pass
722 
723     def visit_desc_inline(self, node: Element) -> None:
724         self.body.append(r'\sphinxcode{\sphinxupquote{')
725 
726     def depart_desc_inline(self, node: Element) -> None:
727         self.body.append('}}')
728 
729     # Nodes for high-level structure in signatures
730     ##############################################
731 
732     def visit_desc_name(self, node: Element) -> None:
733         self.body.append(r'\sphinxbfcode{\sphinxupquote{')
734         self.literal_whitespace += 1
735 
736     def depart_desc_name(self, node: Element) -> None:
737         self.body.append('}}')
738         self.literal_whitespace -= 1
739 
740     def visit_desc_addname(self, node: Element) -> None:
741         self.body.append(r'\sphinxcode{\sphinxupquote{')
742         self.literal_whitespace += 1
743 
744     def depart_desc_addname(self, node: Element) -> None:
745         self.body.append('}}')
746         self.literal_whitespace -= 1
747 
748     def visit_desc_type(self, node: Element) -> None:
749         pass
750 
751     def depart_desc_type(self, node: Element) -> None:
752         pass
753 
754     def visit_desc_returns(self, node: Element) -> None:
755         self.body.append(r'{ $\rightarrow$ ')
756 
757     def depart_desc_returns(self, node: Element) -> None:
758         self.body.append(r'}')
759 
760     def visit_desc_parameterlist(self, node: Element) -> None:
761         # close name, open parameterlist
762         self.body.append('}{')
763         self.first_param = 1
764 
765     def depart_desc_parameterlist(self, node: Element) -> None:
766         # close parameterlist, open return annotation
767         self.body.append('}{')
768 
769     def visit_desc_parameter(self, node: Element) -> None:
770         if not self.first_param:
771             self.body.append(', ')
772         else:
773             self.first_param = 0
774         if not node.hasattr('noemph'):
775             self.body.append(r'\emph{')
776 
777     def depart_desc_parameter(self, node: Element) -> None:
778         if not node.hasattr('noemph'):
779             self.body.append('}')
780 
781     def visit_desc_optional(self, node: Element) -> None:
782         self.body.append(r'\sphinxoptional{')
783 
784     def depart_desc_optional(self, node: Element) -> None:
785         self.body.append('}')
786 
787     def visit_desc_annotation(self, node: Element) -> None:
788         self.body.append(r'\sphinxbfcode{\sphinxupquote{')
789 
790     def depart_desc_annotation(self, node: Element) -> None:
791         self.body.append('}}')
792 
793     ##############################################
794 
795     def visit_seealso(self, node: Element) -> None:
796         self.body.append(BLANKLINE)
797         self.body.append(r'\sphinxstrong{%s:}' % admonitionlabels['seealso'] + CR)
798         self.body.append(r'\nopagebreak' + BLANKLINE)
799 
800     def depart_seealso(self, node: Element) -> None:
801         self.body.append(BLANKLINE)
802 
803     def visit_rubric(self, node: Element) -> None:
804         if len(node) == 1 and node.astext() in ('Footnotes', _('Footnotes')):
805             raise nodes.SkipNode
806         self.body.append(r'\subsubsection*{')
807         self.context.append('}' + CR)
808         self.in_title = 1
809 
810     def depart_rubric(self, node: Element) -> None:
811         self.in_title = 0
812         self.body.append(self.context.pop())
813 
814     def visit_footnote(self, node: Element) -> None:
815         self.in_footnote += 1
816         label = cast(nodes.label, node[0])
817         if 'referred' in node:
818             self.body.append(r'\sphinxstepexplicit ')
819         if self.in_parsed_literal:
820             self.body.append(r'\begin{footnote}[%s]' % label.astext())
821         else:
822             self.body.append('%' + CR)
823             self.body.append(r'\begin{footnote}[%s]' % label.astext())
824         if 'referred' in node:
825             self.body.append(r'\phantomsection'
826                              r'\label{\thesphinxscope.%s}%%' % label.astext() + CR)
827         self.body.append(r'\sphinxAtStartFootnote' + CR)
828 
829     def depart_footnote(self, node: Element) -> None:
830         if self.in_parsed_literal:
831             self.body.append(r'\end{footnote}')
832         else:
833             self.body.append('%' + CR)
834             self.body.append(r'\end{footnote}')
835         self.in_footnote -= 1
836 
837     def visit_label(self, node: Element) -> None:
838         raise nodes.SkipNode
839 
840     def visit_tabular_col_spec(self, node: Element) -> None:
841         self.next_table_colspec = node['spec']
842         raise nodes.SkipNode
843 
844     def visit_table(self, node: Element) -> None:
845         if len(self.tables) == 1:
846             if self.table.get_table_type() == 'longtable':
847                 raise UnsupportedError(
848                     '%s:%s: longtable does not support nesting a table.' %
849                     (self.curfilestack[-1], node.line or ''))
850             else:
851                 # change type of parent table to tabular
852                 # see https://groups.google.com/d/msg/sphinx-users/7m3NeOBixeo/9LKP2B4WBQAJ
853                 self.table.has_problematic = True
854         elif len(self.tables) > 2:
855             raise UnsupportedError(
856                 '%s:%s: deeply nested tables are not implemented.' %
857                 (self.curfilestack[-1], node.line or ''))
858 
859         self.tables.append(Table(node))
860         if self.next_table_colspec:
861             self.table.colspec = '{%s}' % self.next_table_colspec + CR
862             if 'colwidths-given' in node.get('classes', []):
863                 logger.info(__('both tabularcolumns and :widths: option are given. '
864                                ':widths: is ignored.'), location=node)
865         self.next_table_colspec = None
866 
867     def depart_table(self, node: Element) -> None:
868         labels = self.hypertarget_to(node)
869         table_type = self.table.get_table_type()
870         table = self.render(table_type + '.tex_t',
871                             dict(table=self.table, labels=labels))
872         self.body.append(BLANKLINE)
873         self.body.append(table)
874         self.body.append(CR)
875 
876         self.tables.pop()
877 
878     def visit_colspec(self, node: Element) -> None:
879         self.table.colcount += 1
880         if 'colwidth' in node:
881             self.table.colwidths.append(node['colwidth'])
882         if 'stub' in node:
883             self.table.stubs.append(self.table.colcount - 1)
884 
885     def depart_colspec(self, node: Element) -> None:
886         pass
887 
888     def visit_tgroup(self, node: Element) -> None:
889         pass
890 
891     def depart_tgroup(self, node: Element) -> None:
892         pass
893 
894     def visit_thead(self, node: Element) -> None:
895         # Redirect head output until header is finished.
896         self.pushbody(self.table.header)
897 
898     def depart_thead(self, node: Element) -> None:
899         self.popbody()
900 
901     def visit_tbody(self, node: Element) -> None:
902         # Redirect body output until table is finished.
903         self.pushbody(self.table.body)
904 
905     def depart_tbody(self, node: Element) -> None:
906         self.popbody()
907 
908     def visit_row(self, node: Element) -> None:
909         self.table.col = 0
910 
911         # fill columns if the row starts with the bottom of multirow cell
912         while True:
913             cell = self.table.cell(self.table.row, self.table.col)
914             if cell is None:  # not a bottom of multirow cell
915                 break
916             else:  # a bottom of multirow cell
917                 self.table.col += cell.width
918                 if cell.col:
919                     self.body.append('&')
920                 if cell.width == 1:
921                     # insert suitable strut for equalizing row heights in given multirow
922                     self.body.append(r'\sphinxtablestrut{%d}' % cell.cell_id)
923                 else:  # use \multicolumn for wide multirow cell
924                     self.body.append(r'\multicolumn{%d}{|l|}{\sphinxtablestrut{%d}}' %
925                                      (cell.width, cell.cell_id))
926 
927     def depart_row(self, node: Element) -> None:
928         self.body.append(r'\\' + CR)
929         cells = [self.table.cell(self.table.row, i) for i in range(self.table.colcount)]
930         underlined = [cell.row + cell.height == self.table.row + 1 for cell in cells]
931         if all(underlined):
932             self.body.append(r'\hline')
933         else:
934             i = 0
935             underlined.extend([False])  # sentinel
936             while i < len(underlined):
937                 if underlined[i] is True:
938                     j = underlined[i:].index(False)
939                     self.body.append(r'\cline{%d-%d}' % (i + 1, i + j))
940                     i += j
941                 i += 1
942         self.table.row += 1
943 
944     def visit_entry(self, node: Element) -> None:
945         if self.table.col > 0:
946             self.body.append('&')
947         self.table.add_cell(node.get('morerows', 0) + 1, node.get('morecols', 0) + 1)
948         cell = self.table.cell()
949         context = ''
950         if cell.width > 1:
951             if self.config.latex_use_latex_multicolumn:
952                 if self.table.col == 0:
953                     self.body.append(r'\multicolumn{%d}{|l|}{%%' % cell.width + CR)
954                 else:
955                     self.body.append(r'\multicolumn{%d}{l|}{%%' % cell.width + CR)
956                 context = '}%' + CR
957             else:
958                 self.body.append(r'\sphinxstartmulticolumn{%d}%%' % cell.width + CR)
959                 context = r'\sphinxstopmulticolumn' + CR
960         if cell.height > 1:
961             # \sphinxmultirow 2nd arg "cell_id" will serve as id for LaTeX macros as well
962             self.body.append(r'\sphinxmultirow{%d}{%d}{%%' % (cell.height, cell.cell_id) + CR)
963             context = '}%' + CR + context
964         if cell.width > 1 or cell.height > 1:
965             self.body.append(r'\begin{varwidth}[t]{\sphinxcolwidth{%d}{%d}}'
966                              % (cell.width, self.table.colcount) + CR)
967             context = (r'\par' + CR + r'\vskip-\baselineskip'
968                        r'\vbox{\hbox{\strut}}\end{varwidth}%' + CR + context)
969             self.needs_linetrimming = 1
970         if len(list(node.findall(nodes.paragraph))) >= 2:
971             self.table.has_oldproblematic = True
972         if isinstance(node.parent.parent, nodes.thead) or (cell.col in self.table.stubs):
973             if len(node) == 1 and isinstance(node[0], nodes.paragraph) and node.astext() == '':
974                 pass
975             else:
976                 self.body.append(r'\sphinxstyletheadfamily ')
977         if self.needs_linetrimming:
978             self.pushbody([])
979         self.context.append(context)
980 
981     def depart_entry(self, node: Element) -> None:
982         if self.needs_linetrimming:
983             self.needs_linetrimming = 0
984             body = self.popbody()
985 
986             # Remove empty lines from top of merged cell
987             while body and body[0] == CR:
988                 body.pop(0)
989             self.body.extend(body)
990 
991         self.body.append(self.context.pop())
992 
993         cell = self.table.cell()
994         self.table.col += cell.width
995 
996         # fill columns if next ones are a bottom of wide-multirow cell
997         while True:
998             nextcell = self.table.cell()
999             if nextcell is None:  # not a bottom of multirow cell
1000                 break
1001             else:  # a bottom part of multirow cell
1002                 self.table.col += nextcell.width
1003                 self.body.append('&')
1004                 if nextcell.width == 1:
1005                     # insert suitable strut for equalizing row heights in multirow
1006                     # they also serve to clear colour panels which would hide the text
1007                     self.body.append(r'\sphinxtablestrut{%d}' % nextcell.cell_id)
1008                 else:
1009                     # use \multicolumn for wide multirow cell
1010                     self.body.append(r'\multicolumn{%d}{l|}{\sphinxtablestrut{%d}}' %
1011                                      (nextcell.width, nextcell.cell_id))
1012 
1013     def visit_acks(self, node: Element) -> None:
1014         # this is a list in the source, but should be rendered as a
1015         # comma-separated list here
1016         bullet_list = cast(nodes.bullet_list, node[0])
1017         list_items = cast(Iterable[nodes.list_item], bullet_list)
1018         self.body.append(BLANKLINE)
1019         self.body.append(', '.join(n.astext() for n in list_items) + '.')
1020         self.body.append(BLANKLINE)
1021         raise nodes.SkipNode
1022 
1023     def visit_bullet_list(self, node: Element) -> None:
1024         if not self.compact_list:
1025             self.body.append(r'\begin{itemize}' + CR)
1026         if self.table:
1027             self.table.has_problematic = True
1028 
1029     def depart_bullet_list(self, node: Element) -> None:
1030         if not self.compact_list:
1031             self.body.append(r'\end{itemize}' + CR)
1032 
1033     def visit_enumerated_list(self, node: Element) -> None:
1034         def get_enumtype(node: Element) -> str:
1035             enumtype = node.get('enumtype', 'arabic')
1036             if 'alpha' in enumtype and 26 < node.get('start', 0) + len(node):
1037                 # fallback to arabic if alphabet counter overflows
1038                 enumtype = 'arabic'
1039 
1040             return enumtype
1041 
1042         def get_nested_level(node: Element) -> int:
1043             if node is None:
1044                 return 0
1045             elif isinstance(node, nodes.enumerated_list):
1046                 return get_nested_level(node.parent) + 1
1047             else:
1048                 return get_nested_level(node.parent)
1049 
1050         enum = "enum%s" % toRoman(get_nested_level(node)).lower()
1051         enumnext = "enum%s" % toRoman(get_nested_level(node) + 1).lower()
1052         style = ENUMERATE_LIST_STYLE.get(get_enumtype(node))
1053         prefix = node.get('prefix', '')
1054         suffix = node.get('suffix', '.')
1055 
1056         self.body.append(r'\begin{enumerate}' + CR)
1057         self.body.append(r'\sphinxsetlistlabels{%s}{%s}{%s}{%s}{%s}%%' %
1058                          (style, enum, enumnext, prefix, suffix) + CR)
1059         if 'start' in node:
1060             self.body.append(r'\setcounter{%s}{%d}' % (enum, node['start'] - 1) + CR)
1061         if self.table:
1062             self.table.has_problematic = True
1063 
1064     def depart_enumerated_list(self, node: Element) -> None:
1065         self.body.append(r'\end{enumerate}' + CR)
1066 
1067     def visit_list_item(self, node: Element) -> None:
1068         # Append "{}" in case the next character is "[", which would break
1069         # LaTeX's list environment (no numbering and the "[" is not printed).
1070         self.body.append(r'\item {} ')
1071 
1072     def depart_list_item(self, node: Element) -> None:
1073         self.body.append(CR)
1074 
1075     def visit_definition_list(self, node: Element) -> None:
1076         self.body.append(r'\begin{description}' + CR)
1077         if self.table:
1078             self.table.has_problematic = True
1079 
1080     def depart_definition_list(self, node: Element) -> None:
1081         self.body.append(r'\end{description}' + CR)
1082 
1083     def visit_definition_list_item(self, node: Element) -> None:
1084         pass
1085 
1086     def depart_definition_list_item(self, node: Element) -> None:
1087         pass
1088 
1089     def visit_term(self, node: Element) -> None:
1090         self.in_term += 1
1091         ctx = ''
1092         if node.get('ids'):
1093             ctx = r'\phantomsection'
1094             for node_id in node['ids']:
1095                 ctx += self.hypertarget(node_id, anchor=False)
1096         ctx += r'}'
1097         self.body.append(r'\sphinxlineitem{')
1098         self.context.append(ctx)
1099 
1100     def depart_term(self, node: Element) -> None:
1101         self.body.append(self.context.pop())
1102         self.in_term -= 1
1103 
1104     def visit_classifier(self, node: Element) -> None:
1105         self.body.append('{[}')
1106 
1107     def depart_classifier(self, node: Element) -> None:
1108         self.body.append('{]}')
1109 
1110     def visit_definition(self, node: Element) -> None:
1111         pass
1112 
1113     def depart_definition(self, node: Element) -> None:
1114         self.body.append(CR)
1115 
1116     def visit_field_list(self, node: Element) -> None:
1117         self.body.append(r'\begin{quote}\begin{description}' + CR)
1118         if self.table:
1119             self.table.has_problematic = True
1120 
1121     def depart_field_list(self, node: Element) -> None:
1122         self.body.append(r'\end{description}\end{quote}' + CR)
1123 
1124     def visit_field(self, node: Element) -> None:
1125         pass
1126 
1127     def depart_field(self, node: Element) -> None:
1128         pass
1129 
1130     visit_field_name = visit_term
1131     depart_field_name = depart_term
1132 
1133     visit_field_body = visit_definition
1134     depart_field_body = depart_definition
1135 
1136     def visit_paragraph(self, node: Element) -> None:
1137         index = node.parent.index(node)
1138         if (index > 0 and isinstance(node.parent, nodes.compound) and
1139                 not isinstance(node.parent[index - 1], nodes.paragraph) and
1140                 not isinstance(node.parent[index - 1], nodes.compound)):
1141             # insert blank line, if the paragraph follows a non-paragraph node in a compound
1142             self.body.append(r'\noindent' + CR)
1143         elif index == 1 and isinstance(node.parent, (nodes.footnote, footnotetext)):
1144             # don't insert blank line, if the paragraph is second child of a footnote
1145             # (first one is label node)
1146             pass
1147         else:
1148             # the \sphinxAtStartPar is to allow hyphenation of first word of
1149             # a paragraph in narrow contexts such as in a table cell
1150             # added as two items (cf. line trimming in depart_entry())
1151             self.body.extend([CR, r'\sphinxAtStartPar' + CR])
1152 
1153     def depart_paragraph(self, node: Element) -> None:
1154         self.body.append(CR)
1155 
1156     def visit_centered(self, node: Element) -> None:
1157         self.body.append(CR + r'\begin{center}')
1158         if self.table:
1159             self.table.has_problematic = True
1160 
1161     def depart_centered(self, node: Element) -> None:
1162         self.body.append(CR + r'\end{center}')
1163 
1164     def visit_hlist(self, node: Element) -> None:
1165         self.compact_list += 1
1166         ncolumns = node['ncolumns']
1167         if self.compact_list > 1:
1168             self.body.append(r'\setlength{\multicolsep}{0pt}' + CR)
1169         self.body.append(r'\begin{multicols}{' + ncolumns + r'}\raggedright' + CR)
1170         self.body.append(r'\begin{itemize}\setlength{\itemsep}{0pt}'
1171                          r'\setlength{\parskip}{0pt}' + CR)
1172         if self.table:
1173             self.table.has_problematic = True
1174 
1175     def depart_hlist(self, node: Element) -> None:
1176         self.compact_list -= 1
1177         self.body.append(r'\end{itemize}\raggedcolumns\end{multicols}' + CR)
1178 
1179     def visit_hlistcol(self, node: Element) -> None:
1180         pass
1181 
1182     def depart_hlistcol(self, node: Element) -> None:
1183         # \columnbreak would guarantee same columns as in html output.  But
1184         # some testing with long items showed that columns may be too uneven.
1185         # And in case only of short items, the automatic column breaks should
1186         # match the ones pre-computed by the hlist() directive.
1187         # self.body.append(r'\columnbreak\n')
1188         pass
1189 
1190     def latex_image_length(self, width_str: str, scale: int = 100) -> str:
1191         try:
1192             return rstdim_to_latexdim(width_str, scale)
1193         except ValueError:
1194             logger.warning(__('dimension unit %s is invalid. Ignored.'), width_str)
1195             return None
1196 
1197     def is_inline(self, node: Element) -> bool:
1198         """Check whether a node represents an inline element."""
1199         return isinstance(node.parent, nodes.TextElement)
1200 
1201     def visit_image(self, node: Element) -> None:
1202         pre: List[str] = []  # in reverse order
1203         post: List[str] = []
1204         include_graphics_options = []
1205         has_hyperlink = isinstance(node.parent, nodes.reference)
1206         if has_hyperlink:
1207             is_inline = self.is_inline(node.parent)
1208         else:
1209             is_inline = self.is_inline(node)
1210         if 'width' in node:
1211             if 'scale' in node:
1212                 w = self.latex_image_length(node['width'], node['scale'])
1213             else:
1214                 w = self.latex_image_length(node['width'])
1215             if w:
1216                 include_graphics_options.append('width=%s' % w)
1217         if 'height' in node:
1218             if 'scale' in node:
1219                 h = self.latex_image_length(node['height'], node['scale'])
1220             else:
1221                 h = self.latex_image_length(node['height'])
1222             if h:
1223                 include_graphics_options.append('height=%s' % h)
1224         if 'scale' in node:
1225             if not include_graphics_options:
1226                 # if no "width" nor "height", \sphinxincludegraphics will fit
1227                 # to the available text width if oversized after rescaling.
1228                 include_graphics_options.append('scale=%s'
1229                                                 % (float(node['scale']) / 100.0))
1230         if 'align' in node:
1231             align_prepost = {
1232                 # By default latex aligns the top of an image.
1233                 (1, 'top'): ('', ''),
1234                 (1, 'middle'): (r'\raisebox{-0.5\height}{', '}'),
1235                 (1, 'bottom'): (r'\raisebox{-\height}{', '}'),
1236                 (0, 'center'): (r'{\hspace*{\fill}', r'\hspace*{\fill}}'),
1237                 # These 2 don't exactly do the right thing.  The image should
1238                 # be floated alongside the paragraph.  See
1239                 # https://www.w3.org/TR/html4/struct/objects.html#adef-align-IMG
1240                 (0, 'left'): ('{', r'\hspace*{\fill}}'),
1241                 (0, 'right'): (r'{\hspace*{\fill}', '}'),
1242             }
1243             try:
1244                 pre.append(align_prepost[is_inline, node['align']][0])
1245                 post.append(align_prepost[is_inline, node['align']][1])
1246             except KeyError:
1247                 pass
1248         if self.in_parsed_literal:
1249             pre.append(r'{\sphinxunactivateextrasandspace ')
1250             post.append('}')
1251         if not is_inline and not has_hyperlink:
1252             pre.append(CR + r'\noindent')
1253             post.append(CR)
1254         pre.reverse()
1255         if node['uri'] in self.builder.images:
1256             uri = self.builder.images[node['uri']]
1257         else:
1258             # missing image!
1259             if self.ignore_missing_images:
1260                 return
1261             uri = node['uri']
1262         if uri.find('://') != -1:
1263             # ignore remote images
1264             return
1265         self.body.extend(pre)
1266         options = ''
1267         if include_graphics_options:
1268             options = '[%s]' % ','.join(include_graphics_options)
1269         base, ext = path.splitext(uri)
1270         if self.in_title and base:
1271             # Lowercase tokens forcely because some fncychap themes capitalize
1272             # the options of \sphinxincludegraphics unexpectedly (ex. WIDTH=...).
1273             self.body.append(r'\lowercase{\sphinxincludegraphics%s}{{%s}%s}' %
1274                              (options, base, ext))
1275         else:
1276             self.body.append(r'\sphinxincludegraphics%s{{%s}%s}' %
1277                              (options, base, ext))
1278         self.body.extend(post)
1279 
1280     def depart_image(self, node: Element) -> None:
1281         pass
1282 
1283     def visit_figure(self, node: Element) -> None:
1284         align = self.elements['figure_align']
1285         if self.no_latex_floats:
1286             align = "H"
1287         if self.table:
1288             # TODO: support align option
1289             if 'width' in node:
1290                 length = self.latex_image_length(node['width'])
1291                 if length:
1292                     self.body.append(r'\begin{sphinxfigure-in-table}[%s]' % length + CR)
1293                     self.body.append(r'\centering' + CR)
1294             else:
1295                 self.body.append(r'\begin{sphinxfigure-in-table}' + CR)
1296                 self.body.append(r'\centering' + CR)
1297             if any(isinstance(child, nodes.caption) for child in node):
1298                 self.body.append(r'\capstart')
1299             self.context.append(r'\end{sphinxfigure-in-table}\relax' + CR)
1300         elif node.get('align', '') in ('left', 'right'):
1301             length = None
1302             if 'width' in node:
1303                 length = self.latex_image_length(node['width'])
1304             elif isinstance(node[0], nodes.image) and 'width' in node[0]:
1305                 length = self.latex_image_length(node[0]['width'])
1306             self.body.append(BLANKLINE)     # Insert a blank line to prevent infinite loop
1307                                             # https://github.com/sphinx-doc/sphinx/issues/7059
1308             self.body.append(r'\begin{wrapfigure}{%s}{%s}' %
1309                              ('r' if node['align'] == 'right' else 'l', length or '0pt') + CR)
1310             self.body.append(r'\centering')
1311             self.context.append(r'\end{wrapfigure}' + CR)
1312         elif self.in_minipage:
1313             self.body.append(CR + r'\begin{center}')
1314             self.context.append(r'\end{center}' + CR)
1315         else:
1316             self.body.append(CR + r'\begin{figure}[%s]' % align + CR)
1317             self.body.append(r'\centering' + CR)
1318             if any(isinstance(child, nodes.caption) for child in node):
1319                 self.body.append(r'\capstart' + CR)
1320             self.context.append(r'\end{figure}' + CR)
1321 
1322     def depart_figure(self, node: Element) -> None:
1323         self.body.append(self.context.pop())
1324 
1325     def visit_caption(self, node: Element) -> None:
1326         self.in_caption += 1
1327         if isinstance(node.parent, captioned_literal_block):
1328             self.body.append(r'\sphinxSetupCaptionForVerbatim{')
1329         elif self.in_minipage and isinstance(node.parent, nodes.figure):
1330             self.body.append(r'\captionof{figure}{')
1331         elif self.table and node.parent.tagname == 'figure':
1332             self.body.append(r'\sphinxfigcaption{')
1333         else:
1334             self.body.append(r'\caption{')
1335 
1336     def depart_caption(self, node: Element) -> None:
1337         self.body.append('}')
1338         if isinstance(node.parent, nodes.figure):
1339             labels = self.hypertarget_to(node.parent)
1340             self.body.append(labels)
1341         self.in_caption -= 1
1342 
1343     def visit_legend(self, node: Element) -> None:
1344         self.body.append(CR + r'\begin{sphinxlegend}')
1345 
1346     def depart_legend(self, node: Element) -> None:
1347         self.body.append(r'\end{sphinxlegend}' + CR)
1348 
1349     def visit_admonition(self, node: Element) -> None:
1350         self.body.append(CR + r'\begin{sphinxadmonition}{note}')
1351         self.no_latex_floats += 1
1352 
1353     def depart_admonition(self, node: Element) -> None:
1354         self.body.append(r'\end{sphinxadmonition}' + CR)
1355         self.no_latex_floats -= 1
1356 
1357     def _visit_named_admonition(self, node: Element) -> None:
1358         label = admonitionlabels[node.tagname]
1359         self.body.append(CR + r'\begin{sphinxadmonition}{%s}{%s:}' %
1360                          (node.tagname, label))
1361         self.no_latex_floats += 1
1362 
1363     def _depart_named_admonition(self, node: Element) -> None:
1364         self.body.append(r'\end{sphinxadmonition}' + CR)
1365         self.no_latex_floats -= 1
1366 
1367     visit_attention = _visit_named_admonition
1368     depart_attention = _depart_named_admonition
1369     visit_caution = _visit_named_admonition
1370     depart_caution = _depart_named_admonition
1371     visit_danger = _visit_named_admonition
1372     depart_danger = _depart_named_admonition
1373     visit_error = _visit_named_admonition
1374     depart_error = _depart_named_admonition
1375     visit_hint = _visit_named_admonition
1376     depart_hint = _depart_named_admonition
1377     visit_important = _visit_named_admonition
1378     depart_important = _depart_named_admonition
1379     visit_note = _visit_named_admonition
1380     depart_note = _depart_named_admonition
1381     visit_tip = _visit_named_admonition
1382     depart_tip = _depart_named_admonition
1383     visit_warning = _visit_named_admonition
1384     depart_warning = _depart_named_admonition
1385 
1386     def visit_versionmodified(self, node: Element) -> None:
1387         pass
1388 
1389     def depart_versionmodified(self, node: Element) -> None:
1390         pass
1391 
1392     def visit_target(self, node: Element) -> None:
1393         def add_target(id: str) -> None:
1394             # indexing uses standard LaTeX index markup, so the targets
1395             # will be generated differently
1396             if id.startswith('index-'):
1397                 return
1398 
1399             # equations also need no extra blank line nor hypertarget
1400             # TODO: fix this dependency on mathbase extension internals
1401             if id.startswith('equation-'):
1402                 return
1403 
1404             # insert blank line, if the target follows a paragraph node
1405             index = node.parent.index(node)
1406             if index > 0 and isinstance(node.parent[index - 1], nodes.paragraph):
1407                 self.body.append(CR)
1408 
1409             # do not generate \phantomsection in \section{}
1410             anchor = not self.in_title
1411             self.body.append(self.hypertarget(id, anchor=anchor))
1412 
1413         # skip if visitor for next node supports hyperlink
1414         next_node: Node = node
1415         while isinstance(next_node, nodes.target):
1416             next_node = next_node.next_node(ascend=True)
1417 
1418         domain = cast(StandardDomain, self.builder.env.get_domain('std'))
1419         if isinstance(next_node, HYPERLINK_SUPPORT_NODES):
1420             return
1421         elif domain.get_enumerable_node_type(next_node) and domain.get_numfig_title(next_node):
1422             return
1423 
1424         if 'refuri' in node:
1425             return
1426         if 'anonymous' in node:
1427             return
1428         if node.get('refid'):
1429             prev_node = get_prev_node(node)
1430             if isinstance(prev_node, nodes.reference) and node['refid'] == prev_node['refid']:
1431                 # a target for a hyperlink reference having alias
1432                 pass
1433             else:
1434                 add_target(node['refid'])
1435         for id in node['ids']:
1436             add_target(id)
1437 
1438     def depart_target(self, node: Element) -> None:
1439         pass
1440 
1441     def visit_attribution(self, node: Element) -> None:
1442         self.body.append(CR + r'\begin{flushright}' + CR)
1443         self.body.append('---')
1444 
1445     def depart_attribution(self, node: Element) -> None:
1446         self.body.append(CR + r'\end{flushright}' + CR)
1447 
1448     def visit_index(self, node: Element) -> None:
1449         def escape(value: str) -> str:
1450             value = self.encode(value)
1451             value = value.replace(r'\{', r'\sphinxleftcurlybrace{}')
1452             value = value.replace(r'\}', r'\sphinxrightcurlybrace{}')
1453             value = value.replace('"', '""')
1454             value = value.replace('@', '"@')
1455             value = value.replace('!', '"!')
1456             value = value.replace('|', r'\textbar{}')
1457             return value
1458 
1459         def style(string: str) -> str:
1460             match = EXTRA_RE.match(string)
1461             if match:
1462                 return match.expand(r'\\spxentry{\1}\\spxextra{\2}')
1463             else:
1464                 return r'\spxentry{%s}' % string
1465 
1466         if not node.get('inline', True):
1467             self.body.append(CR)
1468         entries = node['entries']
1469         for type, string, _tid, ismain, _key in entries:
1470             m = ''
1471             if ismain:
1472                 m = '|spxpagem'
1473             try:
1474                 if type == 'single':
1475                     try:
1476                         p1, p2 = [escape(x) for x in split_into(2, 'single', string)]
1477                         P1, P2 = style(p1), style(p2)
1478                         self.body.append(r'\index{%s@%s!%s@%s%s}' % (p1, P1, p2, P2, m))
1479                     except ValueError:
1480                         p = escape(split_into(1, 'single', string)[0])
1481                         P = style(p)
1482                         self.body.append(r'\index{%s@%s%s}' % (p, P, m))
1483                 elif type == 'pair':
1484                     p1, p2 = [escape(x) for x in split_into(2, 'pair', string)]
1485                     P1, P2 = style(p1), style(p2)
1486                     self.body.append(r'\index{%s@%s!%s@%s%s}\index{%s@%s!%s@%s%s}' %
1487                                      (p1, P1, p2, P2, m, p2, P2, p1, P1, m))
1488                 elif type == 'triple':
1489                     p1, p2, p3 = [escape(x) for x in split_into(3, 'triple', string)]
1490                     P1, P2, P3 = style(p1), style(p2), style(p3)
1491                     self.body.append(
1492                         r'\index{%s@%s!%s %s@%s %s%s}'
1493                         r'\index{%s@%s!%s, %s@%s, %s%s}'
1494                         r'\index{%s@%s!%s %s@%s %s%s}' %
1495                         (p1, P1, p2, p3, P2, P3, m,
1496                          p2, P2, p3, p1, P3, P1, m,
1497                          p3, P3, p1, p2, P1, P2, m))
1498                 elif type == 'see':
1499                     p1, p2 = [escape(x) for x in split_into(2, 'see', string)]
1500                     P1 = style(p1)
1501                     self.body.append(r'\index{%s@%s|see{%s}}' % (p1, P1, p2))
1502                 elif type == 'seealso':
1503                     p1, p2 = [escape(x) for x in split_into(2, 'seealso', string)]
1504                     P1 = style(p1)
1505                     self.body.append(r'\index{%s@%s|see{%s}}' % (p1, P1, p2))
1506                 else:
1507                     logger.warning(__('unknown index entry type %s found'), type)
1508             except ValueError as err:
1509                 logger.warning(str(err))
1510         if not node.get('inline', True):
1511             self.body.append(r'\ignorespaces ')
1512         raise nodes.SkipNode
1513 
1514     def visit_raw(self, node: Element) -> None:
1515         if not self.is_inline(node):
1516             self.body.append(CR)
1517         if 'latex' in node.get('format', '').split():
1518             self.body.append(node.astext())
1519         if not self.is_inline(node):
1520             self.body.append(CR)
1521         raise nodes.SkipNode
1522 
1523     def visit_reference(self, node: Element) -> None:
1524         if not self.in_title:
1525             for id in node.get('ids'):
1526                 anchor = not self.in_caption
1527                 self.body += self.hypertarget(id, anchor=anchor)
1528         if not self.is_inline(node):
1529             self.body.append(CR)
1530         uri = node.get('refuri', '')
1531         if not uri and node.get('refid'):
1532             uri = '%' + self.curfilestack[-1] + '#' + node['refid']
1533         if self.in_title or not uri:
1534             self.context.append('')
1535         elif uri.startswith('#'):
1536             # references to labels in the same document
1537             id = self.curfilestack[-1] + ':' + uri[1:]
1538             self.body.append(self.hyperlink(id))
1539             self.body.append(r'\emph{')
1540             if self.config.latex_show_pagerefs and not \
1541                     self.in_production_list:
1542                 self.context.append('}}} (%s)' % self.hyperpageref(id))
1543             else:
1544                 self.context.append('}}}')
1545         elif uri.startswith('%'):
1546             # references to documents or labels inside documents
1547             hashindex = uri.find('#')
1548             if hashindex == -1:
1549                 # reference to the document
1550                 id = uri[1:] + '::doc'
1551             else:
1552                 # reference to a label
1553                 id = uri[1:].replace('#', ':')
1554             self.body.append(self.hyperlink(id))
1555             if (len(node) and
1556                     isinstance(node[0], nodes.Element) and
1557                     'std-term' in node[0].get('classes', [])):
1558                 # don't add a pageref for glossary terms
1559                 self.context.append('}}}')
1560                 # mark up as termreference
1561                 self.body.append(r'\sphinxtermref{')
1562             else:
1563                 self.body.append(r'\sphinxcrossref{')
1564                 if self.config.latex_show_pagerefs and not self.in_production_list:
1565                     self.context.append('}}} (%s)' % self.hyperpageref(id))
1566                 else:
1567                     self.context.append('}}}')
1568         else:
1569             if len(node) == 1 and uri == node[0]:
1570                 if node.get('nolinkurl'):
1571                     self.body.append(r'\sphinxnolinkurl{%s}' % self.encode_uri(uri))
1572                 else:
1573                     self.body.append(r'\sphinxurl{%s}' % self.encode_uri(uri))
1574                 raise nodes.SkipNode
1575             else:
1576                 self.body.append(r'\sphinxhref{%s}{' % self.encode_uri(uri))
1577                 self.context.append('}')
1578 
1579     def depart_reference(self, node: Element) -> None:
1580         self.body.append(self.context.pop())
1581         if not self.is_inline(node):
1582             self.body.append(CR)
1583 
1584     def visit_number_reference(self, node: Element) -> None:
1585         if node.get('refid'):
1586             id = self.curfilestack[-1] + ':' + node['refid']
1587         else:
1588             id = node.get('refuri', '')[1:].replace('#', ':')
1589 
1590         title = self.escape(node.get('title', '%s')).replace(r'\%s', '%s')
1591         if r'\{name\}' in title or r'\{number\}' in title:
1592             # new style format (cf. "Fig.%{number}")
1593             title = title.replace(r'\{name\}', '{name}').replace(r'\{number\}', '{number}')
1594             text = escape_abbr(title).format(name=r'\nameref{%s}' % self.idescape(id),
1595                                              number=r'\ref{%s}' % self.idescape(id))
1596         else:
1597             # old style format (cf. "Fig.%{number}")
1598             text = escape_abbr(title) % (r'\ref{%s}' % self.idescape(id))
1599         hyperref = r'\hyperref[%s]{%s}' % (self.idescape(id), text)
1600         self.body.append(hyperref)
1601 
1602         raise nodes.SkipNode
1603 
1604     def visit_download_reference(self, node: Element) -> None:
1605         pass
1606 
1607     def depart_download_reference(self, node: Element) -> None:
1608         pass
1609 
1610     def visit_pending_xref(self, node: Element) -> None:
1611         pass
1612 
1613     def depart_pending_xref(self, node: Element) -> None:
1614         pass
1615 
1616     def visit_emphasis(self, node: Element) -> None:
1617         self.body.append(r'\sphinxstyleemphasis{')
1618 
1619     def depart_emphasis(self, node: Element) -> None:
1620         self.body.append('}')
1621 
1622     def visit_literal_emphasis(self, node: Element) -> None:
1623         self.body.append(r'\sphinxstyleliteralemphasis{\sphinxupquote{')
1624 
1625     def depart_literal_emphasis(self, node: Element) -> None:
1626         self.body.append('}}')
1627 
1628     def visit_strong(self, node: Element) -> None:
1629         self.body.append(r'\sphinxstylestrong{')
1630 
1631     def depart_strong(self, node: Element) -> None:
1632         self.body.append('}')
1633 
1634     def visit_literal_strong(self, node: Element) -> None:
1635         self.body.append(r'\sphinxstyleliteralstrong{\sphinxupquote{')
1636 
1637     def depart_literal_strong(self, node: Element) -> None:
1638         self.body.append('}}')
1639 
1640     def visit_abbreviation(self, node: Element) -> None:
1641         abbr = node.astext()
1642         self.body.append(r'\sphinxstyleabbreviation{')
1643         # spell out the explanation once
1644         if node.hasattr('explanation') and abbr not in self.handled_abbrs:
1645             self.context.append('} (%s)' % self.encode(node['explanation']))
1646             self.handled_abbrs.add(abbr)
1647         else:
1648             self.context.append('}')
1649 
1650     def depart_abbreviation(self, node: Element) -> None:
1651         self.body.append(self.context.pop())
1652 
1653     def visit_manpage(self, node: Element) -> None:
1654         return self.visit_literal_emphasis(node)
1655 
1656     def depart_manpage(self, node: Element) -> None:
1657         return self.depart_literal_emphasis(node)
1658 
1659     def visit_title_reference(self, node: Element) -> None:
1660         self.body.append(r'\sphinxtitleref{')
1661 
1662     def depart_title_reference(self, node: Element) -> None:
1663         self.body.append('}')
1664 
1665     def visit_thebibliography(self, node: Element) -> None:
1666         citations = cast(Iterable[nodes.citation], node)
1667         labels = (cast(nodes.label, citation[0]) for citation in citations)
1668         longest_label = max((label.astext() for label in labels), key=len)
1669         if len(longest_label) > MAX_CITATION_LABEL_LENGTH:
1670             # adjust max width of citation labels not to break the layout
1671             longest_label = longest_label[:MAX_CITATION_LABEL_LENGTH]
1672 
1673         self.body.append(CR + r'\begin{sphinxthebibliography}{%s}' %
1674                          self.encode(longest_label) + CR)
1675 
1676     def depart_thebibliography(self, node: Element) -> None:
1677         self.body.append(r'\end{sphinxthebibliography}' + CR)
1678 
1679     def visit_citation(self, node: Element) -> None:
1680         label = cast(nodes.label, node[0])
1681         self.body.append(r'\bibitem[%s]{%s:%s}' % (self.encode(label.astext()),
1682                                                    node['docname'], node['ids'][0]))
1683 
1684     def depart_citation(self, node: Element) -> None:
1685         pass
1686 
1687     def visit_citation_reference(self, node: Element) -> None:
1688         if self.in_title:
1689             pass
1690         else:
1691             self.body.append(r'\sphinxcite{%s:%s}' % (node['docname'], node['refname']))
1692             raise nodes.SkipNode
1693 
1694     def depart_citation_reference(self, node: Element) -> None:
1695         pass
1696 
1697     def visit_literal(self, node: Element) -> None:
1698         if self.in_title:
1699             self.body.append(r'\sphinxstyleliteralintitle{\sphinxupquote{')
1700         elif 'kbd' in node['classes']:
1701             self.body.append(r'\sphinxkeyboard{\sphinxupquote{')
1702         else:
1703             self.body.append(r'\sphinxcode{\sphinxupquote{')
1704 
1705     def depart_literal(self, node: Element) -> None:
1706         self.body.append('}}')
1707 
1708     def visit_footnote_reference(self, node: Element) -> None:
1709         raise nodes.SkipNode
1710 
1711     def visit_footnotemark(self, node: Element) -> None:
1712         self.body.append(r'\sphinxfootnotemark[')
1713 
1714     def depart_footnotemark(self, node: Element) -> None:
1715         self.body.append(']')
1716 
1717     def visit_footnotetext(self, node: Element) -> None:
1718         label = cast(nodes.label, node[0])
1719         self.body.append('%' + CR)
1720         self.body.append(r'\begin{footnotetext}[%s]'
1721                          r'\phantomsection\label{\thesphinxscope.%s}%%'
1722                          % (label.astext(), label.astext()) + CR)
1723         self.body.append(r'\sphinxAtStartFootnote' + CR)
1724 
1725     def depart_footnotetext(self, node: Element) -> None:
1726         # the \ignorespaces in particular for after table header use
1727         self.body.append('%' + CR)
1728         self.body.append(r'\end{footnotetext}\ignorespaces ')
1729 
1730     def visit_captioned_literal_block(self, node: Element) -> None:
1731         pass
1732 
1733     def depart_captioned_literal_block(self, node: Element) -> None:
1734         pass
1735 
1736     def visit_literal_block(self, node: Element) -> None:
1737         if node.rawsource != node.astext():
1738             # most probably a parsed-literal block -- don't highlight
1739             self.in_parsed_literal += 1
1740             self.body.append(r'\begin{sphinxalltt}' + CR)
1741         else:
1742             labels = self.hypertarget_to(node)
1743             if isinstance(node.parent, captioned_literal_block):
1744                 labels += self.hypertarget_to(node.parent)
1745             if labels and not self.in_footnote:
1746                 self.body.append(CR + r'\def\sphinxLiteralBlockLabel{' + labels + '}')
1747 
1748             lang = node.get('language', 'default')
1749             linenos = node.get('linenos', False)
1750             highlight_args = node.get('highlight_args', {})
1751             highlight_args['force'] = node.get('force', False)
1752             opts = self.config.highlight_options.get(lang, {})
1753 
1754             hlcode = self.highlighter.highlight_block(
1755                 node.rawsource, lang, opts=opts, linenos=linenos,
1756                 location=node, **highlight_args
1757             )
1758             if self.in_footnote:
1759                 self.body.append(CR + r'\sphinxSetupCodeBlockInFootnote')
1760                 hlcode = hlcode.replace(r'\begin{Verbatim}',
1761                                         r'\begin{sphinxVerbatim}')
1762             # if in table raise verbatim flag to avoid "tabulary" environment
1763             # and opt for sphinxVerbatimintable to handle caption & long lines
1764             elif self.table:
1765                 self.table.has_problematic = True
1766                 self.table.has_verbatim = True
1767                 hlcode = hlcode.replace(r'\begin{Verbatim}',
1768                                         r'\begin{sphinxVerbatimintable}')
1769             else:
1770                 hlcode = hlcode.replace(r'\begin{Verbatim}',
1771                                         r'\begin{sphinxVerbatim}')
1772             # get consistent trailer
1773             hlcode = hlcode.rstrip()[:-14]  # strip \end{Verbatim}
1774             if self.table and not self.in_footnote:
1775                 hlcode += r'\end{sphinxVerbatimintable}'
1776             else:
1777                 hlcode += r'\end{sphinxVerbatim}'
1778 
1779             hllines = str(highlight_args.get('hl_lines', []))[1:-1]
1780             if hllines:
1781                 self.body.append(CR + r'\fvset{hllines={, %s,}}%%' % hllines)
1782             self.body.append(CR + hlcode + CR)
1783             if hllines:
1784                 self.body.append(r'\sphinxresetverbatimhllines' + CR)
1785             raise nodes.SkipNode
1786 
1787     def depart_literal_block(self, node: Element) -> None:
1788         self.body.append(CR + r'\end{sphinxalltt}' + CR)
1789         self.in_parsed_literal -= 1
1790     visit_doctest_block = visit_literal_block
1791     depart_doctest_block = depart_literal_block
1792 
1793     def visit_line(self, node: Element) -> None:
1794         self.body.append(r'\item[] ')
1795 
1796     def depart_line(self, node: Element) -> None:
1797         self.body.append(CR)
1798 
1799     def visit_line_block(self, node: Element) -> None:
1800         if isinstance(node.parent, nodes.line_block):
1801             self.body.append(r'\item[]' + CR)
1802             self.body.append(r'\begin{DUlineblock}{\DUlineblockindent}' + CR)
1803         else:
1804             self.body.append(CR + r'\begin{DUlineblock}{0em}' + CR)
1805         if self.table:
1806             self.table.has_problematic = True
1807 
1808     def depart_line_block(self, node: Element) -> None:
1809         self.body.append(r'\end{DUlineblock}' + CR)
1810 
1811     def visit_block_quote(self, node: Element) -> None:
1812         # If the block quote contains a single object and that object
1813         # is a list, then generate a list not a block quote.
1814         # This lets us indent lists.
1815         done = 0
1816         if len(node.children) == 1:
1817             child = node.children[0]
1818             if isinstance(child, (nodes.bullet_list, nodes.enumerated_list)):
1819                 done = 1
1820         if not done:
1821             self.body.append(r'\begin{quote}' + CR)
1822             if self.table:
1823                 self.table.has_problematic = True
1824 
1825     def depart_block_quote(self, node: Element) -> None:
1826         done = 0
1827         if len(node.children) == 1:
1828             child = node.children[0]
1829             if isinstance(child, (nodes.bullet_list, nodes.enumerated_list)):
1830                 done = 1
1831         if not done:
1832             self.body.append(r'\end{quote}' + CR)
1833 
1834     # option node handling copied from docutils' latex writer
1835 
1836     def visit_option(self, node: Element) -> None:
1837         if self.context[-1]:
1838             # this is not the first option
1839             self.body.append(', ')
1840 
1841     def depart_option(self, node: Element) -> None:
1842         # flag that the first option is done.
1843         self.context[-1] += 1
1844 
1845     def visit_option_argument(self, node: Element) -> None:
1846         """The delimiter between an option and its argument."""
1847         self.body.append(node.get('delimiter', ' '))
1848 
1849     def depart_option_argument(self, node: Element) -> None:
1850         pass
1851 
1852     def visit_option_group(self, node: Element) -> None:
1853         self.body.append(r'\item [')
1854         # flag for first option
1855         self.context.append(0)
1856 
1857     def depart_option_group(self, node: Element) -> None:
1858         self.context.pop()  # the flag
1859         self.body.append('] ')
1860 
1861     def visit_option_list(self, node: Element) -> None:
1862         self.body.append(r'\begin{optionlist}{3cm}' + CR)
1863         if self.table:
1864             self.table.has_problematic = True
1865 
1866     def depart_option_list(self, node: Element) -> None:
1867         self.body.append(r'\end{optionlist}' + CR)
1868 
1869     def visit_option_list_item(self, node: Element) -> None:
1870         pass
1871 
1872     def depart_option_list_item(self, node: Element) -> None:
1873         pass
1874 
1875     def visit_option_string(self, node: Element) -> None:
1876         ostring = node.astext()
1877         self.body.append(self.encode(ostring))
1878         raise nodes.SkipNode
1879 
1880     def visit_description(self, node: Element) -> None:
1881         self.body.append(' ')
1882 
1883     def depart_description(self, node: Element) -> None:
1884         pass
1885 
1886     def visit_superscript(self, node: Element) -> None:
1887         self.body.append(r'$^{\text{')
1888 
1889     def depart_superscript(self, node: Element) -> None:
1890         self.body.append('}}$')
1891 
1892     def visit_subscript(self, node: Element) -> None:
1893         self.body.append(r'$_{\text{')
1894 
1895     def depart_subscript(self, node: Element) -> None:
1896         self.body.append('}}$')
1897 
1898     def visit_inline(self, node: Element) -> None:
1899         classes = node.get('classes', [])
1900         if classes in [['menuselection']]:
1901             self.body.append(r'\sphinxmenuselection{')
1902             self.context.append('}')
1903         elif classes in [['guilabel']]:
1904             self.body.append(r'\sphinxguilabel{')
1905             self.context.append('}')
1906         elif classes in [['accelerator']]:
1907             self.body.append(r'\sphinxaccelerator{')
1908             self.context.append('}')
1909         elif classes and not self.in_title:
1910             self.body.append(r'\DUrole{%s}{' % ','.join(classes))
1911             self.context.append('}')
1912         else:
1913             self.context.append('')
1914 
1915     def depart_inline(self, node: Element) -> None:
1916         self.body.append(self.context.pop())
1917 
1918     def visit_generated(self, node: Element) -> None:
1919         pass
1920 
1921     def depart_generated(self, node: Element) -> None:
1922         pass
1923 
1924     def visit_compound(self, node: Element) -> None:
1925         pass
1926 
1927     def depart_compound(self, node: Element) -> None:
1928         pass
1929 
1930     def visit_container(self, node: Element) -> None:
1931         classes = node.get('classes', [])
1932         for c in classes:
1933             self.body.append('\n\\begin{sphinxuseclass}{%s}' % c)
1934 
1935     def depart_container(self, node: Element) -> None:
1936         classes = node.get('classes', [])
1937         for _c in classes:
1938             self.body.append('\n\\end{sphinxuseclass}')
1939 
1940     def visit_decoration(self, node: Element) -> None:
1941         pass
1942 
1943     def depart_decoration(self, node: Element) -> None:
1944         pass
1945 
1946     # docutils-generated elements that we don't support
1947 
1948     def visit_header(self, node: Element) -> None:
1949         raise nodes.SkipNode
1950 
1951     def visit_footer(self, node: Element) -> None:
1952         raise nodes.SkipNode
1953 
1954     def visit_docinfo(self, node: Element) -> None:
1955         raise nodes.SkipNode
1956 
1957     # text handling
1958 
1959     def encode(self, text: str) -> str:
1960         text = self.escape(text)
1961         if self.literal_whitespace:
1962             # Insert a blank before the newline, to avoid
1963             # ! LaTeX Error: There's no line here to end.
1964             text = text.replace(CR, r'~\\' + CR).replace(' ', '~')
1965         return text
1966 
1967     def encode_uri(self, text: str) -> str:
1968         # TODO: it is probably wrong that this uses texescape.escape()
1969         #       this must be checked against hyperref package exact dealings
1970         #       mainly, %, #, {, } and \ need escaping via a \ escape
1971         # in \href, the tilde is allowed and must be represented literally
1972         return self.encode(text).replace(r'\textasciitilde{}', '~').\
1973             replace(r'\sphinxhyphen{}', '-').\
1974             replace(r'\textquotesingle{}', "'")
1975 
1976     def visit_Text(self, node: Text) -> None:
1977         text = self.encode(node.astext())
1978         self.body.append(text)
1979 
1980     def depart_Text(self, node: Text) -> None:
1981         pass
1982 
1983     def visit_comment(self, node: Element) -> None:
1984         raise nodes.SkipNode
1985 
1986     def visit_meta(self, node: Element) -> None:
1987         # only valid for HTML
1988         raise nodes.SkipNode
1989 
1990     def visit_system_message(self, node: Element) -> None:
1991         pass
1992 
1993     def depart_system_message(self, node: Element) -> None:
1994         self.body.append(CR)
1995 
1996     def visit_math(self, node: Element) -> None:
1997         if self.in_title:
1998             self.body.append(r'\protect\(%s\protect\)' % node.astext())
1999         else:
2000             self.body.append(r'\(%s\)' % node.astext())
2001         raise nodes.SkipNode
2002 
2003     def visit_math_block(self, node: Element) -> None:
2004         if node.get('label'):
2005             label = "equation:%s:%s" % (node['docname'], node['label'])
2006         else:
2007             label = None
2008 
2009         if node.get('nowrap'):
2010             if label:
2011                 self.body.append(r'\label{%s}' % label)
2012             self.body.append(node.astext())
2013         else:
2014             from sphinx.util.math import wrap_displaymath
2015             self.body.append(wrap_displaymath(node.astext(), label,
2016                                               self.config.math_number_all))
2017         raise nodes.SkipNode
2018 
2019     def visit_math_reference(self, node: Element) -> None:
2020         label = "equation:%s:%s" % (node['docname'], node['target'])
2021         eqref_format = self.config.math_eqref_format
2022         if eqref_format:
2023             try:
2024                 ref = r'\ref{%s}' % label
2025                 self.body.append(eqref_format.format(number=ref))
2026             except KeyError as exc:
2027                 logger.warning(__('Invalid math_eqref_format: %r'), exc,
2028                                location=node)
2029                 self.body.append(r'\eqref{%s}' % label)
2030         else:
2031             self.body.append(r'\eqref{%s}' % label)
2032 
2033     def depart_math_reference(self, node: Element) -> None:
2034         pass
2035 
2036     @property
2037     def docclasses(self) -> Tuple[str, str]:
2038         """Prepends prefix to sphinx document classes"""
2039         warnings.warn('LaTeXWriter.docclasses() is deprecated.',
2040                       RemovedInSphinx70Warning, stacklevel=2)
2041         return ('howto', 'manual')
2042 
2043 
2044 # FIXME: Workaround to avoid circular import
2045 # refs: https://github.com/sphinx-doc/sphinx/issues/5433
2046 from sphinx.builders.latex.nodes import ( # NOQA isort:skip
2047     HYPERLINK_SUPPORT_NODES, captioned_literal_block, footnotetext,
2048 )

</code><intended_behavior>This file should ensure that explicitly numbered footnotes and their references are correctly handled in a manner that preserves the numbering and hyperlinking in the LaTeX output. The fix should ensure that when a footnote is referenced multiple times, each instance creates a proper hyperlink back to the original footnote in the final PDF document. This behavior will require reviewing and potentially updating the way footnote references are translated into LaTeX, ensuring that each reference correctly points back to its corresponding footnote definition, without losing its numbering or failing to create a hyperlink.</intended_behavior>]
2025-10-18 06:10:59.747 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-18 06:10:59.747 | INFO     | Search-only: skipping patch selection
2025-10-18 06:10:59.886 | INFO     | Task sphinx-doc__sphinx-10191 completed successfully.
2025-10-18 06:10:59.887 | INFO     | No patch generated. You can try running ACR again.
