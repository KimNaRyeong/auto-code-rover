[
    {
        "rel_file_path": "requests/models.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/psf__requests/setup_psf__requests__1.2/requests/models.py",
        "start": 217,
        "end": 233,
        "class_name": null,
        "method_name": "prepare",
        "code": "217     def prepare(self):\n218         \"\"\"Constructs a :class:`PreparedRequest <PreparedRequest>` for transmission and returns it.\"\"\"\n219         p = PreparedRequest()\n220 \n221         p.prepare_method(self.method)\n222         p.prepare_url(self.url, self.params)\n223         p.prepare_headers(self.headers)\n224         p.prepare_cookies(self.cookies)\n225         p.prepare_body(self.data, self.files)\n226         p.prepare_auth(self.auth, self.url)\n227         # Note that prepare_auth must be last to enable authentication schemes\n228         # such as OAuth to work on a fully prepared request.\n229 \n230         # This MUST go after prepare_auth. Authenticators could add a hook\n231         p.prepare_hooks(self.hooks)\n232 \n233         return p\n",
        "intended_behavior": "The `prepare` method should ensure that during the preparation of the body, field names in the `data` dictionary that are intended to be part of a multipart/form-data payload are correctly handled. Specifically, field names encoded as UTF-8 should not introduce Python byte literals (`b''`) into the field names within the HTTP request body."
    },
    {
        "rel_file_path": "requests/models.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/psf__requests/setup_psf__requests__1.2/requests/models.py",
        "start": 217,
        "end": 233,
        "class_name": "Request",
        "method_name": "prepare",
        "code": "217     def prepare(self):\n218         \"\"\"Constructs a :class:`PreparedRequest <PreparedRequest>` for transmission and returns it.\"\"\"\n219         p = PreparedRequest()\n220 \n221         p.prepare_method(self.method)\n222         p.prepare_url(self.url, self.params)\n223         p.prepare_headers(self.headers)\n224         p.prepare_cookies(self.cookies)\n225         p.prepare_body(self.data, self.files)\n226         p.prepare_auth(self.auth, self.url)\n227         # Note that prepare_auth must be last to enable authentication schemes\n228         # such as OAuth to work on a fully prepared request.\n229 \n230         # This MUST go after prepare_auth. Authenticators could add a hook\n231         p.prepare_hooks(self.hooks)\n232 \n233         return p\n",
        "intended_behavior": "The `prepare` method should ensure that during the preparation of the body, field names in the `data` dictionary that are intended to be part of a multipart/form-data payload are correctly handled. Specifically, field names encoded as UTF-8 should not introduce Python byte literals (`b''`) into the field names within the HTTP request body."
    },
    {
        "rel_file_path": "requests/packages/urllib3/filepost.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/psf__requests/setup_psf__requests__1.2/requests/packages/urllib3/filepost.py",
        "start": 1,
        "end": 98,
        "class_name": null,
        "method_name": null,
        "code": "1 # urllib3/filepost.py\n2 # Copyright 2008-2012 Andrey Petrov and contributors (see CONTRIBUTORS.txt)\n3 #\n4 # This module is part of urllib3 and is released under\n5 # the MIT License: http://www.opensource.org/licenses/mit-license.php\n6 \n7 import codecs\n8 import mimetypes\n9 \n10 from uuid import uuid4\n11 from io import BytesIO\n12 \n13 from .packages import six\n14 from .packages.six import b\n15 \n16 writer = codecs.lookup('utf-8')[3]\n17 \n18 \n19 def choose_boundary():\n20     \"\"\"\n21     Our embarassingly-simple replacement for mimetools.choose_boundary.\n22     \"\"\"\n23     return uuid4().hex\n24 \n25 \n26 def get_content_type(filename):\n27     return mimetypes.guess_type(filename)[0] or 'application/octet-stream'\n28 \n29 \n30 def iter_fields(fields):\n31     \"\"\"\n32     Iterate over fields.\n33 \n34     Supports list of (k, v) tuples and dicts.\n35     \"\"\"\n36     if isinstance(fields, dict):\n37         return ((k, v) for k, v in six.iteritems(fields))\n38 \n39     return ((k, v) for k, v in fields)\n40 \n41 \n42 def encode_multipart_formdata(fields, boundary=None):\n43     \"\"\"\n44     Encode a dictionary of ``fields`` using the multipart/form-data MIME format.\n45 \n46     :param fields:\n47         Dictionary of fields or list of (key, value) or (key, value, MIME type)\n48         field tuples.  The key is treated as the field name, and the value as\n49         the body of the form-data bytes. If the value is a tuple of two\n50         elements, then the first element is treated as the filename of the\n51         form-data section and a suitable MIME type is guessed based on the\n52         filename. If the value is a tuple of three elements, then the third\n53         element is treated as an explicit MIME type of the form-data section.\n54 \n55         Field names and filenames must be unicode.\n56 \n57     :param boundary:\n58         If not specified, then a random boundary will be generated using\n59         :func:`mimetools.choose_boundary`.\n60     \"\"\"\n61     body = BytesIO()\n62     if boundary is None:\n63         boundary = choose_boundary()\n64 \n65     for fieldname, value in iter_fields(fields):\n66         body.write(b('--%s\\r\\n' % (boundary)))\n67 \n68         if isinstance(value, tuple):\n69             if len(value) == 3:\n70                 filename, data, content_type = value\n71             else:\n72                 filename, data = value\n73                 content_type = get_content_type(filename)\n74             writer(body).write('Content-Disposition: form-data; name=\"%s\"; '\n75                                'filename=\"%s\"\\r\\n' % (fieldname, filename))\n76             body.write(b('Content-Type: %s\\r\\n\\r\\n' %\n77                        (content_type,)))\n78         else:\n79             data = value\n80             writer(body).write('Content-Disposition: form-data; name=\"%s\"\\r\\n'\n81                                % (fieldname))\n82             body.write(b'\\r\\n')\n83 \n84         if isinstance(data, int):\n85             data = str(data)  # Backwards compatibility\n86 \n87         if isinstance(data, six.text_type):\n88             writer(body).write(data)\n89         else:\n90             body.write(data)\n91 \n92         body.write(b'\\r\\n')\n93 \n94     body.write(b('--%s--\\r\\n' % (boundary)))\n95 \n96     content_type = str('multipart/form-data; boundary=%s' % boundary)\n97 \n98     return body.getvalue(), content_type\n",
        "intended_behavior": "The encoding process must respect original string data types and encodings to preserve field names as they are meant to be sent over the network. It should properly handle and encode Unicode strings while avoiding erroneous interpretations or transformations that would introduce Python byte literals (`b''`)."
    }
]