[
    {
        "rel_file_path": "requests/sessions.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/psf__requests/setup_psf__requests__2.12/requests/sessions.py",
        "start": 371,
        "end": 409,
        "class_name": "Session",
        "method_name": "prepare_request",
        "code": "371     def prepare_request(self, request):\n372         \"\"\"Constructs a :class:`PreparedRequest <PreparedRequest>` for\n373         transmission and returns it. The :class:`PreparedRequest` has settings\n374         merged from the :class:`Request <Request>` instance and those of the\n375         :class:`Session`.\n376 \n377         :param request: :class:`Request` instance to prepare with this\n378             session's settings.\n379         :rtype: requests.PreparedRequest\n380         \"\"\"\n381         cookies = request.cookies or {}\n382 \n383         # Bootstrap CookieJar.\n384         if not isinstance(cookies, cookielib.CookieJar):\n385             cookies = cookiejar_from_dict(cookies)\n386 \n387         # Merge with session cookies\n388         merged_cookies = merge_cookies(\n389             merge_cookies(RequestsCookieJar(), self.cookies), cookies)\n390 \n391         # Set environment's basic authentication if not explicitly set.\n392         auth = request.auth\n393         if self.trust_env and not auth and not self.auth:\n394             auth = get_netrc_auth(request.url)\n395 \n396         p = PreparedRequest()\n397         p.prepare(\n398             method=request.method.upper(),\n399             url=request.url,\n400             files=request.files,\n401             data=request.data,\n402             json=request.json,\n403             headers=merge_setting(request.headers, self.headers, dict_class=CaseInsensitiveDict),\n404             params=merge_setting(request.params, self.params),\n405             auth=merge_setting(auth, self.auth),\n406             cookies=merged_cookies,\n407             hooks=merge_hooks(request.hooks, self.hooks),\n408         )\n409         return p\n",
        "intended_behavior": "Modify or augment the prepare_request method to ensure parameters are added to URLs regardless of the scheme. This involves ensuring that the method (and any utility function it calls for URL manipulation) does not exclude non-HTTP schemes from processing. Specifically, the merging of parameters (params=merge_setting(request.params, self.params)) should apply uniformly across all URL schemes. The method should either include a check to allow certain non-standard, yet HTTP-like schemes, or implement a more robust scheme recognition process that can be customized or extended through a registry mechanism as suggested in the issue. This approach allows http+unix and similar schemes to be treated with HTTP-like parameter processing, without compromising the security considerations of excluding unknown schemes by default."
    },
    {
        "rel_file_path": "requests/sessions.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/psf__requests/setup_psf__requests__2.12/requests/sessions.py",
        "start": 283,
        "end": 715,
        "class_name": "Session",
        "method_name": null,
        "code": "283 class Session(SessionRedirectMixin):\n284     \"\"\"A Requests session.\n285 \n286     Provides cookie persistence, connection-pooling, and configuration.\n287 \n288     Basic Usage::\n289 \n290       >>> import requests\n291       >>> s = requests.Session()\n292       >>> s.get('http://httpbin.org/get')\n293       <Response [200]>\n294 \n295     Or as a context manager::\n296 \n297       >>> with requests.Session() as s:\n298       >>>     s.get('http://httpbin.org/get')\n299       <Response [200]>\n300     \"\"\"\n301 \n302     __attrs__ = [\n303         'headers', 'cookies', 'auth', 'proxies', 'hooks', 'params', 'verify',\n304         'cert', 'prefetch', 'adapters', 'stream', 'trust_env',\n305         'max_redirects',\n306     ]\n307 \n308     def __init__(self):\n309 \n310         #: A case-insensitive dictionary of headers to be sent on each\n311         #: :class:`Request <Request>` sent from this\n312         #: :class:`Session <Session>`.\n313         self.headers = default_headers()\n314 \n315         #: Default Authentication tuple or object to attach to\n316         #: :class:`Request <Request>`.\n317         self.auth = None\n318 \n319         #: Dictionary mapping protocol or protocol and host to the URL of the proxy\n320         #: (e.g. {'http': 'foo.bar:3128', 'http://host.name': 'foo.bar:4012'}) to\n321         #: be used on each :class:`Request <Request>`.\n322         self.proxies = {}\n323 \n324         #: Event-handling hooks.\n325         self.hooks = default_hooks()\n326 \n327         #: Dictionary of querystring data to attach to each\n328         #: :class:`Request <Request>`. The dictionary values may be lists for\n329         #: representing multivalued query parameters.\n330         self.params = {}\n331 \n332         #: Stream response content default.\n333         self.stream = False\n334 \n335         #: SSL Verification default.\n336         self.verify = True\n337 \n338         #: SSL client certificate default.\n339         self.cert = None\n340 \n341         #: Maximum number of redirects allowed. If the request exceeds this\n342         #: limit, a :class:`TooManyRedirects` exception is raised.\n343         #: This defaults to requests.models.DEFAULT_REDIRECT_LIMIT, which is\n344         #: 30.\n345         self.max_redirects = DEFAULT_REDIRECT_LIMIT\n346 \n347         #: Trust environment settings for proxy configuration, default\n348         #: authentication and similar.\n349         self.trust_env = True\n350 \n351         #: A CookieJar containing all currently outstanding cookies set on this\n352         #: session. By default it is a\n353         #: :class:`RequestsCookieJar <requests.cookies.RequestsCookieJar>`, but\n354         #: may be any other ``cookielib.CookieJar`` compatible object.\n355         self.cookies = cookiejar_from_dict({})\n356 \n357         # Default connection adapters.\n358         self.adapters = OrderedDict()\n359         self.mount('https://', HTTPAdapter())\n360         self.mount('http://', HTTPAdapter())\n361 \n362         # Only store 1000 redirects to prevent using infinite memory\n363         self.redirect_cache = RecentlyUsedContainer(REDIRECT_CACHE_SIZE)\n364 \n365     def __enter__(self):\n366         return self\n367 \n368     def __exit__(self, *args):\n369         self.close()\n370 \n371     def prepare_request(self, request):\n372         \"\"\"Constructs a :class:`PreparedRequest <PreparedRequest>` for\n373         transmission and returns it. The :class:`PreparedRequest` has settings\n374         merged from the :class:`Request <Request>` instance and those of the\n375         :class:`Session`.\n376 \n377         :param request: :class:`Request` instance to prepare with this\n378             session's settings.\n379         :rtype: requests.PreparedRequest\n380         \"\"\"\n381         cookies = request.cookies or {}\n382 \n383         # Bootstrap CookieJar.\n384         if not isinstance(cookies, cookielib.CookieJar):\n385             cookies = cookiejar_from_dict(cookies)\n386 \n387         # Merge with session cookies\n388         merged_cookies = merge_cookies(\n389             merge_cookies(RequestsCookieJar(), self.cookies), cookies)\n390 \n391         # Set environment's basic authentication if not explicitly set.\n392         auth = request.auth\n393         if self.trust_env and not auth and not self.auth:\n394             auth = get_netrc_auth(request.url)\n395 \n396         p = PreparedRequest()\n397         p.prepare(\n398             method=request.method.upper(),\n399             url=request.url,\n400             files=request.files,\n401             data=request.data,\n402             json=request.json,\n403             headers=merge_setting(request.headers, self.headers, dict_class=CaseInsensitiveDict),\n404             params=merge_setting(request.params, self.params),\n405             auth=merge_setting(auth, self.auth),\n406             cookies=merged_cookies,\n407             hooks=merge_hooks(request.hooks, self.hooks),\n408         )\n409         return p\n410 \n411     def request(self, method, url,\n412         params=None,\n413         data=None,\n414         headers=None,\n415         cookies=None,\n416         files=None,\n417         auth=None,\n418         timeout=None,\n419         allow_redirects=True,\n420         proxies=None,\n421         hooks=None,\n422         stream=None,\n423         verify=None,\n424         cert=None,\n425         json=None):\n426         \"\"\"Constructs a :class:`Request <Request>`, prepares it and sends it.\n427         Returns :class:`Response <Response>` object.\n428 \n429         :param method: method for the new :class:`Request` object.\n430         :param url: URL for the new :class:`Request` object.\n431         :param params: (optional) Dictionary or bytes to be sent in the query\n432             string for the :class:`Request`.\n433         :param data: (optional) Dictionary, bytes, or file-like object to send\n434             in the body of the :class:`Request`.\n435         :param json: (optional) json to send in the body of the\n436             :class:`Request`.\n437         :param headers: (optional) Dictionary of HTTP Headers to send with the\n438             :class:`Request`.\n439         :param cookies: (optional) Dict or CookieJar object to send with the\n440             :class:`Request`.\n441         :param files: (optional) Dictionary of ``'filename': file-like-objects``\n442             for multipart encoding upload.\n443         :param auth: (optional) Auth tuple or callable to enable\n444             Basic/Digest/Custom HTTP Auth.\n445         :param timeout: (optional) How long to wait for the server to send\n446             data before giving up, as a float, or a :ref:`(connect timeout,\n447             read timeout) <timeouts>` tuple.\n448         :type timeout: float or tuple\n449         :param allow_redirects: (optional) Set to True by default.\n450         :type allow_redirects: bool\n451         :param proxies: (optional) Dictionary mapping protocol or protocol and\n452             hostname to the URL of the proxy.\n453         :param stream: (optional) whether to immediately download the response\n454             content. Defaults to ``False``.\n455         :param verify: (optional) whether the SSL cert will be verified.\n456             A CA_BUNDLE path can also be provided. Defaults to ``True``.\n457         :param cert: (optional) if String, path to ssl client cert file (.pem).\n458             If Tuple, ('cert', 'key') pair.\n459         :rtype: requests.Response\n460         \"\"\"\n461         # Create the Request.\n462         req = Request(\n463             method = method.upper(),\n464             url = url,\n465             headers = headers,\n466             files = files,\n467             data = data or {},\n468             json = json,\n469             params = params or {},\n470             auth = auth,\n471             cookies = cookies,\n472             hooks = hooks,\n473         )\n474         prep = self.prepare_request(req)\n475 \n476         proxies = proxies or {}\n477 \n478         settings = self.merge_environment_settings(\n479             prep.url, proxies, stream, verify, cert\n480         )\n481 \n482         # Send the request.\n483         send_kwargs = {\n484             'timeout': timeout,\n485             'allow_redirects': allow_redirects,\n486         }\n487         send_kwargs.update(settings)\n488         resp = self.send(prep, **send_kwargs)\n489 \n490         return resp\n491 \n492     def get(self, url, **kwargs):\n493         \"\"\"Sends a GET request. Returns :class:`Response` object.\n494 \n495         :param url: URL for the new :class:`Request` object.\n496         :param \\*\\*kwargs: Optional arguments that ``request`` takes.\n497         :rtype: requests.Response\n498         \"\"\"\n499 \n500         kwargs.setdefault('allow_redirects', True)\n501         return self.request('GET', url, **kwargs)\n502 \n503     def options(self, url, **kwargs):\n504         \"\"\"Sends a OPTIONS request. Returns :class:`Response` object.\n505 \n506         :param url: URL for the new :class:`Request` object.\n507         :param \\*\\*kwargs: Optional arguments that ``request`` takes.\n508         :rtype: requests.Response\n509         \"\"\"\n510 \n511         kwargs.setdefault('allow_redirects', True)\n512         return self.request('OPTIONS', url, **kwargs)\n513 \n514     def head(self, url, **kwargs):\n515         \"\"\"Sends a HEAD request. Returns :class:`Response` object.\n516 \n517         :param url: URL for the new :class:`Request` object.\n518         :param \\*\\*kwargs: Optional arguments that ``request`` takes.\n519         :rtype: requests.Response\n520         \"\"\"\n521 \n522         kwargs.setdefault('allow_redirects', False)\n523         return self.request('HEAD', url, **kwargs)\n524 \n525     def post(self, url, data=None, json=None, **kwargs):\n526         \"\"\"Sends a POST request. Returns :class:`Response` object.\n527 \n528         :param url: URL for the new :class:`Request` object.\n529         :param data: (optional) Dictionary, bytes, or file-like object to send in the body of the :class:`Request`.\n530         :param json: (optional) json to send in the body of the :class:`Request`.\n531         :param \\*\\*kwargs: Optional arguments that ``request`` takes.\n532         :rtype: requests.Response\n533         \"\"\"\n534 \n535         return self.request('POST', url, data=data, json=json, **kwargs)\n536 \n537     def put(self, url, data=None, **kwargs):\n538         \"\"\"Sends a PUT request. Returns :class:`Response` object.\n539 \n540         :param url: URL for the new :class:`Request` object.\n541         :param data: (optional) Dictionary, bytes, or file-like object to send in the body of the :class:`Request`.\n542         :param \\*\\*kwargs: Optional arguments that ``request`` takes.\n543         :rtype: requests.Response\n544         \"\"\"\n545 \n546         return self.request('PUT', url, data=data, **kwargs)\n547 \n548     def patch(self, url, data=None, **kwargs):\n549         \"\"\"Sends a PATCH request. Returns :class:`Response` object.\n550 \n551         :param url: URL for the new :class:`Request` object.\n552         :param data: (optional) Dictionary, bytes, or file-like object to send in the body of the :class:`Request`.\n553         :param \\*\\*kwargs: Optional arguments that ``request`` takes.\n554         :rtype: requests.Response\n555         \"\"\"\n556 \n557         return self.request('PATCH', url,  data=data, **kwargs)\n558 \n559     def delete(self, url, **kwargs):\n560         \"\"\"Sends a DELETE request. Returns :class:`Response` object.\n561 \n562         :param url: URL for the new :class:`Request` object.\n563         :param \\*\\*kwargs: Optional arguments that ``request`` takes.\n564         :rtype: requests.Response\n565         \"\"\"\n566 \n567         return self.request('DELETE', url, **kwargs)\n568 \n569     def send(self, request, **kwargs):\n570         \"\"\"\n571         Send a given PreparedRequest.\n572 \n573         :rtype: requests.Response\n574         \"\"\"\n575         # Set defaults that the hooks can utilize to ensure they always have\n576         # the correct parameters to reproduce the previous request.\n577         kwargs.setdefault('stream', self.stream)\n578         kwargs.setdefault('verify', self.verify)\n579         kwargs.setdefault('cert', self.cert)\n580         kwargs.setdefault('proxies', self.proxies)\n581 \n582         # It's possible that users might accidentally send a Request object.\n583         # Guard against that specific failure case.\n584         if isinstance(request, Request):\n585             raise ValueError('You can only send PreparedRequests.')\n586 \n587         # Set up variables needed for resolve_redirects and dispatching of hooks\n588         allow_redirects = kwargs.pop('allow_redirects', True)\n589         stream = kwargs.get('stream')\n590         hooks = request.hooks\n591 \n592         # Resolve URL in redirect cache, if available.\n593         if allow_redirects:\n594             checked_urls = set()\n595             while request.url in self.redirect_cache:\n596                 checked_urls.add(request.url)\n597                 new_url = self.redirect_cache.get(request.url)\n598                 if new_url in checked_urls:\n599                     break\n600                 request.url = new_url\n601 \n602         # Get the appropriate adapter to use\n603         adapter = self.get_adapter(url=request.url)\n604 \n605         # Start time (approximately) of the request\n606         start = datetime.utcnow()\n607 \n608         # Send the request\n609         r = adapter.send(request, **kwargs)\n610 \n611         # Total elapsed time of the request (approximately)\n612         r.elapsed = datetime.utcnow() - start\n613 \n614         # Response manipulation hooks\n615         r = dispatch_hook('response', hooks, r, **kwargs)\n616 \n617         # Persist cookies\n618         if r.history:\n619 \n620             # If the hooks create history then we want those cookies too\n621             for resp in r.history:\n622                 extract_cookies_to_jar(self.cookies, resp.request, resp.raw)\n623 \n624         extract_cookies_to_jar(self.cookies, request, r.raw)\n625 \n626         # Redirect resolving generator.\n627         gen = self.resolve_redirects(r, request, **kwargs)\n628 \n629         # Resolve redirects if allowed.\n630         history = [resp for resp in gen] if allow_redirects else []\n631 \n632         # Shuffle things around if there's history.\n633         if history:\n634             # Insert the first (original) request at the start\n635             history.insert(0, r)\n636             # Get the last request made\n637             r = history.pop()\n638             r.history = history\n639 \n640         if not stream:\n641             r.content\n642 \n643         return r\n644 \n645     def merge_environment_settings(self, url, proxies, stream, verify, cert):\n646         \"\"\"\n647         Check the environment and merge it with some settings.\n648 \n649         :rtype: dict\n650         \"\"\"\n651         # Gather clues from the surrounding environment.\n652         if self.trust_env:\n653             # Set environment's proxies.\n654             env_proxies = get_environ_proxies(url) or {}\n655             for (k, v) in env_proxies.items():\n656                 proxies.setdefault(k, v)\n657 \n658             # Look for requests environment configuration and be compatible\n659             # with cURL.\n660             if verify is True or verify is None:\n661                 verify = (os.environ.get('REQUESTS_CA_BUNDLE') or\n662                           os.environ.get('CURL_CA_BUNDLE'))\n663 \n664         # Merge all the kwargs.\n665         proxies = merge_setting(proxies, self.proxies)\n666         stream = merge_setting(stream, self.stream)\n667         verify = merge_setting(verify, self.verify)\n668         cert = merge_setting(cert, self.cert)\n669 \n670         return {'verify': verify, 'proxies': proxies, 'stream': stream,\n671                 'cert': cert}\n672 \n673     def get_adapter(self, url):\n674         \"\"\"\n675         Returns the appropriate connection adapter for the given URL.\n676 \n677         :rtype: requests.adapters.BaseAdapter\n678         \"\"\"\n679         for (prefix, adapter) in self.adapters.items():\n680 \n681             if url.lower().startswith(prefix):\n682                 return adapter\n683 \n684         # Nothing matches :-/\n685         raise InvalidSchema(\"No connection adapters were found for '%s'\" % url)\n686 \n687     def close(self):\n688         \"\"\"Closes all adapters and as such the session\"\"\"\n689         for v in self.adapters.values():\n690             v.close()\n691 \n692     def mount(self, prefix, adapter):\n693         \"\"\"Registers a connection adapter to a prefix.\n694 \n695         Adapters are sorted in descending order by key length.\n696         \"\"\"\n697         self.adapters[prefix] = adapter\n698         keys_to_move = [k for k in self.adapters if len(k) < len(prefix)]\n699 \n700         for key in keys_to_move:\n701             self.adapters[key] = self.adapters.pop(key)\n702 \n703     def __getstate__(self):\n704         state = dict((attr, getattr(self, attr, None)) for attr in self.__attrs__)\n705         state['redirect_cache'] = dict(self.redirect_cache)\n706         return state\n707 \n708     def __setstate__(self, state):\n709         redirect_cache = state.pop('redirect_cache', {})\n710         for attr, value in state.items():\n711             setattr(self, attr, value)\n712 \n713         self.redirect_cache = RecentlyUsedContainer(REDIRECT_CACHE_SIZE)\n714         for redirect, to in redirect_cache.items():\n715             self.redirect_cache[redirect] = to\n",
        "intended_behavior": "This class provides additional context to the issue."
    }
]