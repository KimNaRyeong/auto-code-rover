diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py
--- a/django/db/models/expressions.py
+++ b/django/db/models/expressions.py
@@ -147,7 +147,6 @@ def __ror__(self, other):
         )
 
 
-@deconstructible
 class BaseExpression:
     """Base class for all query expressions."""
 
@@ -389,6 +388,11 @@ def select_format(self, compiler, sql, params):
             return self.output_field.select_format(compiler, sql, params)
         return sql, params
 
+
+@deconstructible
+class Expression(BaseExpression, Combinable):
+    """An expression that can be combined with other expressions."""
+
     @cached_property
     def identity(self):
         constructor_signature = inspect.signature(self.__init__)
@@ -409,7 +413,7 @@ def identity(self):
         return tuple(identity)
 
     def __eq__(self, other):
-        if not isinstance(other, BaseExpression):
+        if not isinstance(other, Expression):
             return NotImplemented
         return other.identity == self.identity
 
@@ -417,11 +421,6 @@ def __hash__(self):
         return hash(self.identity)
 
 
-class Expression(BaseExpression, Combinable):
-    """An expression that can be combined with other expressions."""
-    pass
-
-
 _connector_combinators = {
     connector: [
         (fields.IntegerField, fields.IntegerField, fields.IntegerField),
@@ -1103,7 +1102,7 @@ def get_group_by_cols(self, alias=None):
         return super().get_group_by_cols(alias)
 
 
-class Subquery(Expression):
+class Subquery(BaseExpression, Combinable):
     """
     An explicit subquery. It may contain OuterRef() references to the outer
     query which will be resolved when it is applied to that query.
@@ -1117,16 +1116,6 @@ def __init__(self, queryset, output_field=None, **extra):
         self.extra = extra
         super().__init__(output_field)
 
-    def __getstate__(self):
-        state = super().__getstate__()
-        args, kwargs = state['_constructor_args']
-        if args:
-            args = (self.query, *args[1:])
-        else:
-            kwargs['queryset'] = self.query
-        state['_constructor_args'] = args, kwargs
-        return state
-
     def get_source_expressions(self):
         return [self.query]
 
@@ -1203,6 +1192,7 @@ def select_format(self, compiler, sql, params):
         return sql, params
 
 
+@deconstructible
 class OrderBy(BaseExpression):
     template = '%(expression)s %(ordering)s'
     conditional = False
diff --git a/django/db/models/query_utils.py b/django/db/models/query_utils.py
--- a/django/db/models/query_utils.py
+++ b/django/db/models/query_utils.py
@@ -5,6 +5,7 @@
 large and/or so that they can be used by other modules without getting into
 circular import difficulties.
 """
+import copy
 import functools
 import inspect
 from collections import namedtuple
@@ -43,14 +44,11 @@ def _combine(self, other, conn):
         if not(isinstance(other, Q) or getattr(other, 'conditional', False) is True):
             raise TypeError(other)
 
-        # If the other Q() is empty, ignore it and just use `self`.
-        if not other:
+        if not self:
+            return other.copy() if hasattr(other, 'copy') else copy.copy(other)
+        elif isinstance(other, Q) and not other:
             _, args, kwargs = self.deconstruct()
             return type(self)(*args, **kwargs)
-        # Or if this Q is empty, ignore it and just use `other`.
-        elif not self:
-            _, args, kwargs = other.deconstruct()
-            return type(other)(*args, **kwargs)
 
         obj = type(self)()
         obj.connector = conn
diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py
--- a/django/db/models/sql/query.py
+++ b/django/db/models/sql/query.py
@@ -36,7 +36,6 @@
     AND, OR, ExtraWhere, NothingNode, WhereNode,
 )
 from django.utils.functional import cached_property
-from django.utils.hashable import make_hashable
 from django.utils.tree import Node
 
 __all__ = ['Query', 'RawQuery']
@@ -250,14 +249,6 @@ def base_table(self):
         for alias in self.alias_map:
             return alias
 
-    @property
-    def identity(self):
-        identity = (
-            (arg, make_hashable(value))
-            for arg, value in self.__dict__.items()
-        )
-        return (self.__class__, *identity)
-
     def __str__(self):
         """
         Return the query as a string of SQL with the parameter values
