2025-10-18 00:29:24.806 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-18 00:29:28.615 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=557, output_tokens=12, cost=0.005930
2025-10-18 00:29:43.280 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=737, output_tokens=599, cost=0.025340
2025-10-18 00:29:44.478 | INFO     | registered non reproducing test 0
2025-10-18 00:30:04.522 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1996, output_tokens=794, cost=0.043780
2025-10-18 00:30:05.730 | INFO     | registered non reproducing test 1
2025-10-18 00:30:26.506 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3016, output_tokens=851, cost=0.055690
2025-10-18 00:30:27.668 | INFO     | registered non reproducing test 2
2025-10-18 00:30:27.669 | WARNING  | Failed to write a reproducer test; skipping reproducer tracing
2025-10-18 00:30:27.671 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 00:30:38.158 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=848, output_tokens=489, cost=0.023150
2025-10-18 00:30:38.168 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 00:30:41.394 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=843, output_tokens=51, cost=0.009960
2025-10-18 00:30:41.395 | DEBUG    | Extracted a valid json.
2025-10-18 00:30:41.396 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_class(\"Bar\")",
        "search_class(\"Foo\")",
        "search_code(\"self._state\")",
        "search_method(\"deepcopy\")"
    ],
    "bug_locations": []
}
2025-10-18 00:30:41.443 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 00:30:41.443 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 00:30:57.972 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1569, output_tokens=781, cost=0.039120
2025-10-18 00:30:57.991 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 00:31:05.440 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2566, output_tokens=341, cost=0.035890
2025-10-18 00:31:05.448 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 00:31:14.040 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=695, output_tokens=350, cost=0.017450
2025-10-18 00:31:14.041 | DEBUG    | Extracted a valid json.
2025-10-18 00:31:14.041 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_code_in_file(\"self._state\", \"django/db/models/base.py\")",
        "search_code_in_file(\"fields_cache\", \"django/db/models/base.py\")"
    ],
    "bug_locations": [
        {
            "file": "django/db/models/base.py",
            "description": "This file likely contains the handling of `_state`, including how `fields_cache` is handled during the copy operation of a model instance. The issue arises in the context of copying model instances with ForeignKey fields between Django versions, specifically from 1.11.x to 2.x, where the cached FK field in `fields_cache` results in unexpected behavior during shallow copy operations (`copy.copy()`). The bug is not in the existence of `_state` management or `fields_cache` itself but in how these are cloned or not properly reset when a model instance is copied.",
            "intended_behavior": "The cloning (copying) operation should ensure that a deep copy of the model's `_state` is made, especially the `fields_cache` if present, to prevent unintended shared state between the original and the copied instance. Alternatively, if creating a deep copy of `_state` is not desired or feasible for performance reasons, a mechanism to reset or correctly update `fields_cache` in the copied object should be introduced, ensuring that changes to FK fields in the copied instance do not affect the original. Compatibility must be maintained with existing Django functionalities and expected behaviors for model instance copying. This might involve adjusting how `copy.copy()` interacts with Django model instances or providing clear documentation and recommendations for developers on how to handle deep copying of models especially concerning FK relations and cached fields."
        }
    ]
}
2025-10-18 00:31:14.072 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 00:31:14.072 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 00:31:28.542 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3468, output_tokens=672, cost=0.054840
2025-10-18 00:31:28.554 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 00:31:37.784 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=4356, output_tokens=376, cost=0.054840
2025-10-18 00:31:37.788 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 00:31:41.073 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=730, output_tokens=133, cost=0.011290
2025-10-18 00:31:41.074 | DEBUG    | Extracted a valid json.
2025-10-18 00:31:41.074 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "django/db/models/base.py",
            "class": "Model",
            "method": "",
            "intended_behavior": "The handling of the model's `_state`, especially the `fields_cache`, needs to be adjusted to ensure a correct copy mechanism. When a model instance is copied via `copy.copy()`, the `fields_cache` should either be deeply copied to the new instance or reset entirely. This ensures that any modifications to ForeignKey fields in the copied instance do not affect the original instance, maintaining the integrity of the cached relationships."
        }
    ]
}
2025-10-18 00:31:41.087 | DEBUG    | Bug location extracted successfully: [<file>django/db/models/base.py</file>
<class>Model</class>
<method>None</method>
<code>
404 class Model(metaclass=ModelBase):
405 
406     def __init__(self, *args, **kwargs):
407         # Alias some things as locals to avoid repeat global lookups
408         cls = self.__class__
409         opts = self._meta
410         _setattr = setattr
411         _DEFERRED = DEFERRED
412         if opts.abstract:
413             raise TypeError('Abstract models cannot be instantiated.')
414 
415         pre_init.send(sender=cls, args=args, kwargs=kwargs)
416 
417         # Set up the storage for instance state
418         self._state = ModelState()
419 
420         # There is a rather weird disparity here; if kwargs, it's set, then args
421         # overrides it. It should be one or the other; don't duplicate the work
422         # The reason for the kwargs check is that standard iterator passes in by
423         # args, and instantiation for iteration is 33% faster.
424         if len(args) > len(opts.concrete_fields):
425             # Daft, but matches old exception sans the err msg.
426             raise IndexError("Number of args exceeds number of fields")
427 
428         if not kwargs:
429             fields_iter = iter(opts.concrete_fields)
430             # The ordering of the zip calls matter - zip throws StopIteration
431             # when an iter throws it. So if the first iter throws it, the second
432             # is *not* consumed. We rely on this, so don't change the order
433             # without changing the logic.
434             for val, field in zip(args, fields_iter):
435                 if val is _DEFERRED:
436                     continue
437                 _setattr(self, field.attname, val)
438         else:
439             # Slower, kwargs-ready version.
440             fields_iter = iter(opts.fields)
441             for val, field in zip(args, fields_iter):
442                 if val is _DEFERRED:
443                     continue
444                 _setattr(self, field.attname, val)
445                 kwargs.pop(field.name, None)
446 
447         # Now we're left with the unprocessed fields that *must* come from
448         # keywords, or default.
449 
450         for field in fields_iter:
451             is_related_object = False
452             # Virtual field
453             if field.attname not in kwargs and field.column is None:
454                 continue
455             if kwargs:
456                 if isinstance(field.remote_field, ForeignObjectRel):
457                     try:
458                         # Assume object instance was passed in.
459                         rel_obj = kwargs.pop(field.name)
460                         is_related_object = True
461                     except KeyError:
462                         try:
463                             # Object instance wasn't passed in -- must be an ID.
464                             val = kwargs.pop(field.attname)
465                         except KeyError:
466                             val = field.get_default()
467                 else:
468                     try:
469                         val = kwargs.pop(field.attname)
470                     except KeyError:
471                         # This is done with an exception rather than the
472                         # default argument on pop because we don't want
473                         # get_default() to be evaluated, and then not used.
474                         # Refs #12057.
475                         val = field.get_default()
476             else:
477                 val = field.get_default()
478 
479             if is_related_object:
480                 # If we are passed a related instance, set it using the
481                 # field.name instead of field.attname (e.g. "user" instead of
482                 # "user_id") so that the object gets properly cached (and type
483                 # checked) by the RelatedObjectDescriptor.
484                 if rel_obj is not _DEFERRED:
485                     _setattr(self, field.name, rel_obj)
486             else:
487                 if val is not _DEFERRED:
488                     _setattr(self, field.attname, val)
489 
490         if kwargs:
491             property_names = opts._property_names
492             for prop in tuple(kwargs):
493                 try:
494                     # Any remaining kwargs must correspond to properties or
495                     # virtual fields.
496                     if prop in property_names or opts.get_field(prop):
497                         if kwargs[prop] is not _DEFERRED:
498                             _setattr(self, prop, kwargs[prop])
499                         del kwargs[prop]
500                 except (AttributeError, FieldDoesNotExist):
501                     pass
502             for kwarg in kwargs:
503                 raise TypeError("%s() got an unexpected keyword argument '%s'" % (cls.__name__, kwarg))
504         super().__init__()
505         post_init.send(sender=cls, instance=self)
506 
507     @classmethod
508     def from_db(cls, db, field_names, values):
509         if len(values) != len(cls._meta.concrete_fields):
510             values_iter = iter(values)
511             values = [
512                 next(values_iter) if f.attname in field_names else DEFERRED
513                 for f in cls._meta.concrete_fields
514             ]
515         new = cls(*values)
516         new._state.adding = False
517         new._state.db = db
518         return new
519 
520     def __repr__(self):
521         return '<%s: %s>' % (self.__class__.__name__, self)
522 
523     def __str__(self):
524         return '%s object (%s)' % (self.__class__.__name__, self.pk)
525 
526     def __eq__(self, other):
527         if not isinstance(other, Model):
528             return NotImplemented
529         if self._meta.concrete_model != other._meta.concrete_model:
530             return False
531         my_pk = self.pk
532         if my_pk is None:
533             return self is other
534         return my_pk == other.pk
535 
536     def __hash__(self):
537         if self.pk is None:
538             raise TypeError("Model instances without primary key value are unhashable")
539         return hash(self.pk)
540 
541     def __reduce__(self):
542         data = self.__getstate__()
543         data[DJANGO_VERSION_PICKLE_KEY] = django.__version__
544         class_id = self._meta.app_label, self._meta.object_name
545         return model_unpickle, (class_id,), data
546 
547     def __getstate__(self):
548         """Hook to allow choosing the attributes to pickle."""
549         return self.__dict__
550 
551     def __setstate__(self, state):
552         pickled_version = state.get(DJANGO_VERSION_PICKLE_KEY)
553         if pickled_version:
554             if pickled_version != django.__version__:
555                 warnings.warn(
556                     "Pickled model instance's Django version %s does not "
557                     "match the current version %s."
558                     % (pickled_version, django.__version__),
559                     RuntimeWarning,
560                     stacklevel=2,
561                 )
562         else:
563             warnings.warn(
564                 "Pickled model instance's Django version is not specified.",
565                 RuntimeWarning,
566                 stacklevel=2,
567             )
568         self.__dict__.update(state)
569 
570     def _get_pk_val(self, meta=None):
571         meta = meta or self._meta
572         return getattr(self, meta.pk.attname)
573 
574     def _set_pk_val(self, value):
575         for parent_link in self._meta.parents.values():
576             if parent_link and parent_link != self._meta.pk:
577                 setattr(self, parent_link.target_field.attname, value)
578         return setattr(self, self._meta.pk.attname, value)
579 
580     pk = property(_get_pk_val, _set_pk_val)
581 
582     def get_deferred_fields(self):
583         """
584         Return a set containing names of deferred fields for this instance.
585         """
586         return {
587             f.attname for f in self._meta.concrete_fields
588             if f.attname not in self.__dict__
589         }
590 
591     def refresh_from_db(self, using=None, fields=None):
592         """
593         Reload field values from the database.
594 
595         By default, the reloading happens from the database this instance was
596         loaded from, or by the read router if this instance wasn't loaded from
597         any database. The using parameter will override the default.
598 
599         Fields can be used to specify which fields to reload. The fields
600         should be an iterable of field attnames. If fields is None, then
601         all non-deferred fields are reloaded.
602 
603         When accessing deferred fields of an instance, the deferred loading
604         of the field will call this method.
605         """
606         if fields is None:
607             self._prefetched_objects_cache = {}
608         else:
609             prefetched_objects_cache = getattr(self, '_prefetched_objects_cache', ())
610             for field in fields:
611                 if field in prefetched_objects_cache:
612                     del prefetched_objects_cache[field]
613                     fields.remove(field)
614             if not fields:
615                 return
616             if any(LOOKUP_SEP in f for f in fields):
617                 raise ValueError(
618                     'Found "%s" in fields argument. Relations and transforms '
619                     'are not allowed in fields.' % LOOKUP_SEP)
620 
621         hints = {'instance': self}
622         db_instance_qs = self.__class__._base_manager.db_manager(using, hints=hints).filter(pk=self.pk)
623 
624         # Use provided fields, if not set then reload all non-deferred fields.
625         deferred_fields = self.get_deferred_fields()
626         if fields is not None:
627             fields = list(fields)
628             db_instance_qs = db_instance_qs.only(*fields)
629         elif deferred_fields:
630             fields = [f.attname for f in self._meta.concrete_fields
631                       if f.attname not in deferred_fields]
632             db_instance_qs = db_instance_qs.only(*fields)
633 
634         db_instance = db_instance_qs.get()
635         non_loaded_fields = db_instance.get_deferred_fields()
636         for field in self._meta.concrete_fields:
637             if field.attname in non_loaded_fields:
638                 # This field wasn't refreshed - skip ahead.
639                 continue
640             setattr(self, field.attname, getattr(db_instance, field.attname))
641             # Clear cached foreign keys.
642             if field.is_relation and field.is_cached(self):
643                 field.delete_cached_value(self)
644 
645         # Clear cached relations.
646         for field in self._meta.related_objects:
647             if field.is_cached(self):
648                 field.delete_cached_value(self)
649 
650         self._state.db = db_instance._state.db
651 
652     def serializable_value(self, field_name):
653         """
654         Return the value of the field name for this instance. If the field is
655         a foreign key, return the id value instead of the object. If there's
656         no Field object with this name on the model, return the model
657         attribute's value.
658 
659         Used to serialize a field's value (in the serializer, or form output,
660         for example). Normally, you would just access the attribute directly
661         and not use this method.
662         """
663         try:
664             field = self._meta.get_field(field_name)
665         except FieldDoesNotExist:
666             return getattr(self, field_name)
667         return getattr(self, field.attname)
668 
669     def save(self, force_insert=False, force_update=False, using=None,
670              update_fields=None):
671         """
672         Save the current instance. Override this in a subclass if you want to
673         control the saving process.
674 
675         The 'force_insert' and 'force_update' parameters can be used to insist
676         that the "save" must be an SQL insert or update (or equivalent for
677         non-SQL backends), respectively. Normally, they should not be set.
678         """
679         # Ensure that a model instance without a PK hasn't been assigned to
680         # a ForeignKey or OneToOneField on this model. If the field is
681         # nullable, allowing the save() would result in silent data loss.
682         for field in self._meta.concrete_fields:
683             # If the related field isn't cached, then an instance hasn't
684             # been assigned and there's no need to worry about this check.
685             if field.is_relation and field.is_cached(self):
686                 obj = getattr(self, field.name, None)
687                 if not obj:
688                     continue
689                 # A pk may have been assigned manually to a model instance not
690                 # saved to the database (or auto-generated in a case like
691                 # UUIDField), but we allow the save to proceed and rely on the
692                 # database to raise an IntegrityError if applicable. If
693                 # constraints aren't supported by the database, there's the
694                 # unavoidable risk of data corruption.
695                 if obj.pk is None:
696                     # Remove the object from a related instance cache.
697                     if not field.remote_field.multiple:
698                         field.remote_field.delete_cached_value(obj)
699                     raise ValueError(
700                         "save() prohibited to prevent data loss due to "
701                         "unsaved related object '%s'." % field.name
702                     )
703                 elif getattr(self, field.attname) is None:
704                     # Use pk from related object if it has been saved after
705                     # an assignment.
706                     setattr(self, field.attname, obj.pk)
707                 # If the relationship's pk/to_field was changed, clear the
708                 # cached relationship.
709                 if getattr(obj, field.target_field.attname) != getattr(self, field.attname):
710                     field.delete_cached_value(self)
711 
712         using = using or router.db_for_write(self.__class__, instance=self)
713         if force_insert and (force_update or update_fields):
714             raise ValueError("Cannot force both insert and updating in model saving.")
715 
716         deferred_fields = self.get_deferred_fields()
717         if update_fields is not None:
718             # If update_fields is empty, skip the save. We do also check for
719             # no-op saves later on for inheritance cases. This bailout is
720             # still needed for skipping signal sending.
721             if not update_fields:
722                 return
723 
724             update_fields = frozenset(update_fields)
725             field_names = set()
726 
727             for field in self._meta.fields:
728                 if not field.primary_key:
729                     field_names.add(field.name)
730 
731                     if field.name != field.attname:
732                         field_names.add(field.attname)
733 
734             non_model_fields = update_fields.difference(field_names)
735 
736             if non_model_fields:
737                 raise ValueError("The following fields do not exist in this "
738                                  "model or are m2m fields: %s"
739                                  % ', '.join(non_model_fields))
740 
741         # If saving to the same database, and this model is deferred, then
742         # automatically do an "update_fields" save on the loaded fields.
743         elif not force_insert and deferred_fields and using == self._state.db:
744             field_names = set()
745             for field in self._meta.concrete_fields:
746                 if not field.primary_key and not hasattr(field, 'through'):
747                     field_names.add(field.attname)
748             loaded_fields = field_names.difference(deferred_fields)
749             if loaded_fields:
750                 update_fields = frozenset(loaded_fields)
751 
752         self.save_base(using=using, force_insert=force_insert,
753                        force_update=force_update, update_fields=update_fields)
754     save.alters_data = True
755 
756     def save_base(self, raw=False, force_insert=False,
757                   force_update=False, using=None, update_fields=None):
758         """
759         Handle the parts of saving which should be done only once per save,
760         yet need to be done in raw saves, too. This includes some sanity
761         checks and signal sending.
762 
763         The 'raw' argument is telling save_base not to save any parent
764         models and not to do any changes to the values before save. This
765         is used by fixture loading.
766         """
767         using = using or router.db_for_write(self.__class__, instance=self)
768         assert not (force_insert and (force_update or update_fields))
769         assert update_fields is None or update_fields
770         cls = origin = self.__class__
771         # Skip proxies, but keep the origin as the proxy model.
772         if cls._meta.proxy:
773             cls = cls._meta.concrete_model
774         meta = cls._meta
775         if not meta.auto_created:
776             pre_save.send(
777                 sender=origin, instance=self, raw=raw, using=using,
778                 update_fields=update_fields,
779             )
780         # A transaction isn't needed if one query is issued.
781         if meta.parents:
782             context_manager = transaction.atomic(using=using, savepoint=False)
783         else:
784             context_manager = transaction.mark_for_rollback_on_error(using=using)
785         with context_manager:
786             parent_inserted = False
787             if not raw:
788                 parent_inserted = self._save_parents(cls, using, update_fields)
789             updated = self._save_table(
790                 raw, cls, force_insert or parent_inserted,
791                 force_update, using, update_fields,
792             )
793         # Store the database on which the object was saved
794         self._state.db = using
795         # Once saved, this is no longer a to-be-added instance.
796         self._state.adding = False
797 
798         # Signal that the save is complete
799         if not meta.auto_created:
800             post_save.send(
801                 sender=origin, instance=self, created=(not updated),
802                 update_fields=update_fields, raw=raw, using=using,
803             )
804 
805     save_base.alters_data = True
806 
807     def _save_parents(self, cls, using, update_fields):
808         """Save all the parents of cls using values from self."""
809         meta = cls._meta
810         inserted = False
811         for parent, field in meta.parents.items():
812             # Make sure the link fields are synced between parent and self.
813             if (field and getattr(self, parent._meta.pk.attname) is None and
814                     getattr(self, field.attname) is not None):
815                 setattr(self, parent._meta.pk.attname, getattr(self, field.attname))
816             parent_inserted = self._save_parents(cls=parent, using=using, update_fields=update_fields)
817             updated = self._save_table(
818                 cls=parent, using=using, update_fields=update_fields,
819                 force_insert=parent_inserted,
820             )
821             if not updated:
822                 inserted = True
823             # Set the parent's PK value to self.
824             if field:
825                 setattr(self, field.attname, self._get_pk_val(parent._meta))
826                 # Since we didn't have an instance of the parent handy set
827                 # attname directly, bypassing the descriptor. Invalidate
828                 # the related object cache, in case it's been accidentally
829                 # populated. A fresh instance will be re-built from the
830                 # database if necessary.
831                 if field.is_cached(self):
832                     field.delete_cached_value(self)
833         return inserted
834 
835     def _save_table(self, raw=False, cls=None, force_insert=False,
836                     force_update=False, using=None, update_fields=None):
837         """
838         Do the heavy-lifting involved in saving. Update or insert the data
839         for a single table.
840         """
841         meta = cls._meta
842         non_pks = [f for f in meta.local_concrete_fields if not f.primary_key]
843 
844         if update_fields:
845             non_pks = [f for f in non_pks
846                        if f.name in update_fields or f.attname in update_fields]
847 
848         pk_val = self._get_pk_val(meta)
849         if pk_val is None:
850             pk_val = meta.pk.get_pk_value_on_save(self)
851             setattr(self, meta.pk.attname, pk_val)
852         pk_set = pk_val is not None
853         if not pk_set and (force_update or update_fields):
854             raise ValueError("Cannot force an update in save() with no primary key.")
855         updated = False
856         # Skip an UPDATE when adding an instance and primary key has a default.
857         if (
858             not raw and
859             not force_insert and
860             self._state.adding and
861             meta.pk.default and
862             meta.pk.default is not NOT_PROVIDED
863         ):
864             force_insert = True
865         # If possible, try an UPDATE. If that doesn't update anything, do an INSERT.
866         if pk_set and not force_insert:
867             base_qs = cls._base_manager.using(using)
868             values = [(f, None, (getattr(self, f.attname) if raw else f.pre_save(self, False)))
869                       for f in non_pks]
870             forced_update = update_fields or force_update
871             updated = self._do_update(base_qs, using, pk_val, values, update_fields,
872                                       forced_update)
873             if force_update and not updated:
874                 raise DatabaseError("Forced update did not affect any rows.")
875             if update_fields and not updated:
876                 raise DatabaseError("Save with update_fields did not affect any rows.")
877         if not updated:
878             if meta.order_with_respect_to:
879                 # If this is a model with an order_with_respect_to
880                 # autopopulate the _order field
881                 field = meta.order_with_respect_to
882                 filter_args = field.get_filter_kwargs_for_object(self)
883                 self._order = cls._base_manager.using(using).filter(**filter_args).aggregate(
884                     _order__max=Coalesce(
885                         ExpressionWrapper(Max('_order') + Value(1), output_field=IntegerField()),
886                         Value(0),
887                     ),
888                 )['_order__max']
889             fields = meta.local_concrete_fields
890             if not pk_set:
891                 fields = [f for f in fields if f is not meta.auto_field]
892 
893             returning_fields = meta.db_returning_fields
894             results = self._do_insert(cls._base_manager, using, fields, returning_fields, raw)
895             if results:
896                 for value, field in zip(results[0], returning_fields):
897                     setattr(self, field.attname, value)
898         return updated
899 
900     def _do_update(self, base_qs, using, pk_val, values, update_fields, forced_update):
901         """
902         Try to update the model. Return True if the model was updated (if an
903         update query was done and a matching row was found in the DB).
904         """
905         filtered = base_qs.filter(pk=pk_val)
906         if not values:
907             # We can end up here when saving a model in inheritance chain where
908             # update_fields doesn't target any field in current model. In that
909             # case we just say the update succeeded. Another case ending up here
910             # is a model with just PK - in that case check that the PK still
911             # exists.
912             return update_fields is not None or filtered.exists()
913         if self._meta.select_on_save and not forced_update:
914             return (
915                 filtered.exists() and
916                 # It may happen that the object is deleted from the DB right after
917                 # this check, causing the subsequent UPDATE to return zero matching
918                 # rows. The same result can occur in some rare cases when the
919                 # database returns zero despite the UPDATE being executed
920                 # successfully (a row is matched and updated). In order to
921                 # distinguish these two cases, the object's existence in the
922                 # database is again checked for if the UPDATE query returns 0.
923                 (filtered._update(values) > 0 or filtered.exists())
924             )
925         return filtered._update(values) > 0
926 
927     def _do_insert(self, manager, using, fields, returning_fields, raw):
928         """
929         Do an INSERT. If returning_fields is defined then this method should
930         return the newly created data for the model.
931         """
932         return manager._insert(
933             [self], fields=fields, returning_fields=returning_fields,
934             using=using, raw=raw,
935         )
936 
937     def delete(self, using=None, keep_parents=False):
938         using = using or router.db_for_write(self.__class__, instance=self)
939         assert self.pk is not None, (
940             "%s object can't be deleted because its %s attribute is set to None." %
941             (self._meta.object_name, self._meta.pk.attname)
942         )
943 
944         collector = Collector(using=using)
945         collector.collect([self], keep_parents=keep_parents)
946         return collector.delete()
947 
948     delete.alters_data = True
949 
950     def _get_FIELD_display(self, field):
951         value = getattr(self, field.attname)
952         choices_dict = dict(make_hashable(field.flatchoices))
953         # force_str() to coerce lazy strings.
954         return force_str(choices_dict.get(make_hashable(value), value), strings_only=True)
955 
956     def _get_next_or_previous_by_FIELD(self, field, is_next, **kwargs):
957         if not self.pk:
958             raise ValueError("get_next/get_previous cannot be used on unsaved objects.")
959         op = 'gt' if is_next else 'lt'
960         order = '' if is_next else '-'
961         param = getattr(self, field.attname)
962         q = Q(**{'%s__%s' % (field.name, op): param})
963         q = q | Q(**{field.name: param, 'pk__%s' % op: self.pk})
964         qs = self.__class__._default_manager.using(self._state.db).filter(**kwargs).filter(q).order_by(
965             '%s%s' % (order, field.name), '%spk' % order
966         )
967         try:
968             return qs[0]
969         except IndexError:
970             raise self.DoesNotExist("%s matching query does not exist." % self.__class__._meta.object_name)
971 
972     def _get_next_or_previous_in_order(self, is_next):
973         cachename = "__%s_order_cache" % is_next
974         if not hasattr(self, cachename):
975             op = 'gt' if is_next else 'lt'
976             order = '_order' if is_next else '-_order'
977             order_field = self._meta.order_with_respect_to
978             filter_args = order_field.get_filter_kwargs_for_object(self)
979             obj = self.__class__._default_manager.filter(**filter_args).filter(**{
980                 '_order__%s' % op: self.__class__._default_manager.values('_order').filter(**{
981                     self._meta.pk.name: self.pk
982                 })
983             }).order_by(order)[:1].get()
984             setattr(self, cachename, obj)
985         return getattr(self, cachename)
986 
987     def prepare_database_save(self, field):
988         if self.pk is None:
989             raise ValueError("Unsaved model instance %r cannot be used in an ORM query." % self)
990         return getattr(self, field.remote_field.get_related_field().attname)
991 
992     def clean(self):
993         """
994         Hook for doing any extra model-wide validation after clean() has been
995         called on every field by self.clean_fields. Any ValidationError raised
996         by this method will not be associated with a particular field; it will
997         have a special-case association with the field defined by NON_FIELD_ERRORS.
998         """
999         pass
1000 
1001     def validate_unique(self, exclude=None):
1002         """
1003         Check unique constraints on the model and raise ValidationError if any
1004         failed.
1005         """
1006         unique_checks, date_checks = self._get_unique_checks(exclude=exclude)
1007 
1008         errors = self._perform_unique_checks(unique_checks)
1009         date_errors = self._perform_date_checks(date_checks)
1010 
1011         for k, v in date_errors.items():
1012             errors.setdefault(k, []).extend(v)
1013 
1014         if errors:
1015             raise ValidationError(errors)
1016 
1017     def _get_unique_checks(self, exclude=None):
1018         """
1019         Return a list of checks to perform. Since validate_unique() could be
1020         called from a ModelForm, some fields may have been excluded; we can't
1021         perform a unique check on a model that is missing fields involved
1022         in that check. Fields that did not validate should also be excluded,
1023         but they need to be passed in via the exclude argument.
1024         """
1025         if exclude is None:
1026             exclude = []
1027         unique_checks = []
1028 
1029         unique_togethers = [(self.__class__, self._meta.unique_together)]
1030         constraints = [(self.__class__, self._meta.total_unique_constraints)]
1031         for parent_class in self._meta.get_parent_list():
1032             if parent_class._meta.unique_together:
1033                 unique_togethers.append((parent_class, parent_class._meta.unique_together))
1034             if parent_class._meta.total_unique_constraints:
1035                 constraints.append(
1036                     (parent_class, parent_class._meta.total_unique_constraints)
1037                 )
1038 
1039         for model_class, unique_together in unique_togethers:
1040             for check in unique_together:
1041                 if not any(name in exclude for name in check):
1042                     # Add the check if the field isn't excluded.
1043                     unique_checks.append((model_class, tuple(check)))
1044 
1045         for model_class, model_constraints in constraints:
1046             for constraint in model_constraints:
1047                 if not any(name in exclude for name in constraint.fields):
1048                     unique_checks.append((model_class, constraint.fields))
1049 
1050         # These are checks for the unique_for_<date/year/month>.
1051         date_checks = []
1052 
1053         # Gather a list of checks for fields declared as unique and add them to
1054         # the list of checks.
1055 
1056         fields_with_class = [(self.__class__, self._meta.local_fields)]
1057         for parent_class in self._meta.get_parent_list():
1058             fields_with_class.append((parent_class, parent_class._meta.local_fields))
1059 
1060         for model_class, fields in fields_with_class:
1061             for f in fields:
1062                 name = f.name
1063                 if name in exclude:
1064                     continue
1065                 if f.unique:
1066                     unique_checks.append((model_class, (name,)))
1067                 if f.unique_for_date and f.unique_for_date not in exclude:
1068                     date_checks.append((model_class, 'date', name, f.unique_for_date))
1069                 if f.unique_for_year and f.unique_for_year not in exclude:
1070                     date_checks.append((model_class, 'year', name, f.unique_for_year))
1071                 if f.unique_for_month and f.unique_for_month not in exclude:
1072                     date_checks.append((model_class, 'month', name, f.unique_for_month))
1073         return unique_checks, date_checks
1074 
1075     def _perform_unique_checks(self, unique_checks):
1076         errors = {}
1077 
1078         for model_class, unique_check in unique_checks:
1079             # Try to look up an existing object with the same values as this
1080             # object's values for all the unique field.
1081 
1082             lookup_kwargs = {}
1083             for field_name in unique_check:
1084                 f = self._meta.get_field(field_name)
1085                 lookup_value = getattr(self, f.attname)
1086                 # TODO: Handle multiple backends with different feature flags.
1087                 if (lookup_value is None or
1088                         (lookup_value == '' and connection.features.interprets_empty_strings_as_nulls)):
1089                     # no value, skip the lookup
1090                     continue
1091                 if f.primary_key and not self._state.adding:
1092                     # no need to check for unique primary key when editing
1093                     continue
1094                 lookup_kwargs[str(field_name)] = lookup_value
1095 
1096             # some fields were skipped, no reason to do the check
1097             if len(unique_check) != len(lookup_kwargs):
1098                 continue
1099 
1100             qs = model_class._default_manager.filter(**lookup_kwargs)
1101 
1102             # Exclude the current object from the query if we are editing an
1103             # instance (as opposed to creating a new one)
1104             # Note that we need to use the pk as defined by model_class, not
1105             # self.pk. These can be different fields because model inheritance
1106             # allows single model to have effectively multiple primary keys.
1107             # Refs #17615.
1108             model_class_pk = self._get_pk_val(model_class._meta)
1109             if not self._state.adding and model_class_pk is not None:
1110                 qs = qs.exclude(pk=model_class_pk)
1111             if qs.exists():
1112                 if len(unique_check) == 1:
1113                     key = unique_check[0]
1114                 else:
1115                     key = NON_FIELD_ERRORS
1116                 errors.setdefault(key, []).append(self.unique_error_message(model_class, unique_check))
1117 
1118         return errors
1119 
1120     def _perform_date_checks(self, date_checks):
1121         errors = {}
1122         for model_class, lookup_type, field, unique_for in date_checks:
1123             lookup_kwargs = {}
1124             # there's a ticket to add a date lookup, we can remove this special
1125             # case if that makes it's way in
1126             date = getattr(self, unique_for)
1127             if date is None:
1128                 continue
1129             if lookup_type == 'date':
1130                 lookup_kwargs['%s__day' % unique_for] = date.day
1131                 lookup_kwargs['%s__month' % unique_for] = date.month
1132                 lookup_kwargs['%s__year' % unique_for] = date.year
1133             else:
1134                 lookup_kwargs['%s__%s' % (unique_for, lookup_type)] = getattr(date, lookup_type)
1135             lookup_kwargs[field] = getattr(self, field)
1136 
1137             qs = model_class._default_manager.filter(**lookup_kwargs)
1138             # Exclude the current object from the query if we are editing an
1139             # instance (as opposed to creating a new one)
1140             if not self._state.adding and self.pk is not None:
1141                 qs = qs.exclude(pk=self.pk)
1142 
1143             if qs.exists():
1144                 errors.setdefault(field, []).append(
1145                     self.date_error_message(lookup_type, field, unique_for)
1146                 )
1147         return errors
1148 
1149     def date_error_message(self, lookup_type, field_name, unique_for):
1150         opts = self._meta
1151         field = opts.get_field(field_name)
1152         return ValidationError(
1153             message=field.error_messages['unique_for_date'],
1154             code='unique_for_date',
1155             params={
1156                 'model': self,
1157                 'model_name': capfirst(opts.verbose_name),
1158                 'lookup_type': lookup_type,
1159                 'field': field_name,
1160                 'field_label': capfirst(field.verbose_name),
1161                 'date_field': unique_for,
1162                 'date_field_label': capfirst(opts.get_field(unique_for).verbose_name),
1163             }
1164         )
1165 
1166     def unique_error_message(self, model_class, unique_check):
1167         opts = model_class._meta
1168 
1169         params = {
1170             'model': self,
1171             'model_class': model_class,
1172             'model_name': capfirst(opts.verbose_name),
1173             'unique_check': unique_check,
1174         }
1175 
1176         # A unique field
1177         if len(unique_check) == 1:
1178             field = opts.get_field(unique_check[0])
1179             params['field_label'] = capfirst(field.verbose_name)
1180             return ValidationError(
1181                 message=field.error_messages['unique'],
1182                 code='unique',
1183                 params=params,
1184             )
1185 
1186         # unique_together
1187         else:
1188             field_labels = [capfirst(opts.get_field(f).verbose_name) for f in unique_check]
1189             params['field_labels'] = get_text_list(field_labels, _('and'))
1190             return ValidationError(
1191                 message=_("%(model_name)s with this %(field_labels)s already exists."),
1192                 code='unique_together',
1193                 params=params,
1194             )
1195 
1196     def full_clean(self, exclude=None, validate_unique=True):
1197         """
1198         Call clean_fields(), clean(), and validate_unique() on the model.
1199         Raise a ValidationError for any errors that occur.
1200         """
1201         errors = {}
1202         if exclude is None:
1203             exclude = []
1204         else:
1205             exclude = list(exclude)
1206 
1207         try:
1208             self.clean_fields(exclude=exclude)
1209         except ValidationError as e:
1210             errors = e.update_error_dict(errors)
1211 
1212         # Form.clean() is run even if other validation fails, so do the
1213         # same with Model.clean() for consistency.
1214         try:
1215             self.clean()
1216         except ValidationError as e:
1217             errors = e.update_error_dict(errors)
1218 
1219         # Run unique checks, but only for fields that passed validation.
1220         if validate_unique:
1221             for name in errors:
1222                 if name != NON_FIELD_ERRORS and name not in exclude:
1223                     exclude.append(name)
1224             try:
1225                 self.validate_unique(exclude=exclude)
1226             except ValidationError as e:
1227                 errors = e.update_error_dict(errors)
1228 
1229         if errors:
1230             raise ValidationError(errors)
1231 
1232     def clean_fields(self, exclude=None):
1233         """
1234         Clean all fields and raise a ValidationError containing a dict
1235         of all validation errors if any occur.
1236         """
1237         if exclude is None:
1238             exclude = []
1239 
1240         errors = {}
1241         for f in self._meta.fields:
1242             if f.name in exclude:
1243                 continue
1244             # Skip validation for empty fields with blank=True. The developer
1245             # is responsible for making sure they have a valid value.
1246             raw_value = getattr(self, f.attname)
1247             if f.blank and raw_value in f.empty_values:
1248                 continue
1249             try:
1250                 setattr(self, f.attname, f.clean(raw_value, self))
1251             except ValidationError as e:
1252                 errors[f.name] = e.error_list
1253 
1254         if errors:
1255             raise ValidationError(errors)
1256 
1257     @classmethod
1258     def check(cls, **kwargs):
1259         errors = [*cls._check_swappable(), *cls._check_model(), *cls._check_managers(**kwargs)]
1260         if not cls._meta.swapped:
1261             databases = kwargs.get('databases') or []
1262             errors += [
1263                 *cls._check_fields(**kwargs),
1264                 *cls._check_m2m_through_same_relationship(),
1265                 *cls._check_long_column_names(databases),
1266             ]
1267             clash_errors = (
1268                 *cls._check_id_field(),
1269                 *cls._check_field_name_clashes(),
1270                 *cls._check_model_name_db_lookup_clashes(),
1271                 *cls._check_property_name_related_field_accessor_clashes(),
1272                 *cls._check_single_primary_key(),
1273             )
1274             errors.extend(clash_errors)
1275             # If there are field name clashes, hide consequent column name
1276             # clashes.
1277             if not clash_errors:
1278                 errors.extend(cls._check_column_name_clashes())
1279             errors += [
1280                 *cls._check_index_together(),
1281                 *cls._check_unique_together(),
1282                 *cls._check_indexes(databases),
1283                 *cls._check_ordering(),
1284                 *cls._check_constraints(databases),
1285             ]
1286 
1287         return errors
1288 
1289     @classmethod
1290     def _check_swappable(cls):
1291         """Check if the swapped model exists."""
1292         errors = []
1293         if cls._meta.swapped:
1294             try:
1295                 apps.get_model(cls._meta.swapped)
1296             except ValueError:
1297                 errors.append(
1298                     checks.Error(
1299                         "'%s' is not of the form 'app_label.app_name'." % cls._meta.swappable,
1300                         id='models.E001',
1301                     )
1302                 )
1303             except LookupError:
1304                 app_label, model_name = cls._meta.swapped.split('.')
1305                 errors.append(
1306                     checks.Error(
1307                         "'%s' references '%s.%s', which has not been "
1308                         "installed, or is abstract." % (
1309                             cls._meta.swappable, app_label, model_name
1310                         ),
1311                         id='models.E002',
1312                     )
1313                 )
1314         return errors
1315 
1316     @classmethod
1317     def _check_model(cls):
1318         errors = []
1319         if cls._meta.proxy:
1320             if cls._meta.local_fields or cls._meta.local_many_to_many:
1321                 errors.append(
1322                     checks.Error(
1323                         "Proxy model '%s' contains model fields." % cls.__name__,
1324                         id='models.E017',
1325                     )
1326                 )
1327         return errors
1328 
1329     @classmethod
1330     def _check_managers(cls, **kwargs):
1331         """Perform all manager checks."""
1332         errors = []
1333         for manager in cls._meta.managers:
1334             errors.extend(manager.check(**kwargs))
1335         return errors
1336 
1337     @classmethod
1338     def _check_fields(cls, **kwargs):
1339         """Perform all field checks."""
1340         errors = []
1341         for field in cls._meta.local_fields:
1342             errors.extend(field.check(**kwargs))
1343         for field in cls._meta.local_many_to_many:
1344             errors.extend(field.check(from_model=cls, **kwargs))
1345         return errors
1346 
1347     @classmethod
1348     def _check_m2m_through_same_relationship(cls):
1349         """ Check if no relationship model is used by more than one m2m field.
1350         """
1351 
1352         errors = []
1353         seen_intermediary_signatures = []
1354 
1355         fields = cls._meta.local_many_to_many
1356 
1357         # Skip when the target model wasn't found.
1358         fields = (f for f in fields if isinstance(f.remote_field.model, ModelBase))
1359 
1360         # Skip when the relationship model wasn't found.
1361         fields = (f for f in fields if isinstance(f.remote_field.through, ModelBase))
1362 
1363         for f in fields:
1364             signature = (f.remote_field.model, cls, f.remote_field.through, f.remote_field.through_fields)
1365             if signature in seen_intermediary_signatures:
1366                 errors.append(
1367                     checks.Error(
1368                         "The model has two identical many-to-many relations "
1369                         "through the intermediate model '%s'." %
1370                         f.remote_field.through._meta.label,
1371                         obj=cls,
1372                         id='models.E003',
1373                     )
1374                 )
1375             else:
1376                 seen_intermediary_signatures.append(signature)
1377         return errors
1378 
1379     @classmethod
1380     def _check_id_field(cls):
1381         """Check if `id` field is a primary key."""
1382         fields = [f for f in cls._meta.local_fields if f.name == 'id' and f != cls._meta.pk]
1383         # fields is empty or consists of the invalid "id" field
1384         if fields and not fields[0].primary_key and cls._meta.pk.name == 'id':
1385             return [
1386                 checks.Error(
1387                     "'id' can only be used as a field name if the field also "
1388                     "sets 'primary_key=True'.",
1389                     obj=cls,
1390                     id='models.E004',
1391                 )
1392             ]
1393         else:
1394             return []
1395 
1396     @classmethod
1397     def _check_field_name_clashes(cls):
1398         """Forbid field shadowing in multi-table inheritance."""
1399         errors = []
1400         used_fields = {}  # name or attname -> field
1401 
1402         # Check that multi-inheritance doesn't cause field name shadowing.
1403         for parent in cls._meta.get_parent_list():
1404             for f in parent._meta.local_fields:
1405                 clash = used_fields.get(f.name) or used_fields.get(f.attname) or None
1406                 if clash:
1407                     errors.append(
1408                         checks.Error(
1409                             "The field '%s' from parent model "
1410                             "'%s' clashes with the field '%s' "
1411                             "from parent model '%s'." % (
1412                                 clash.name, clash.model._meta,
1413                                 f.name, f.model._meta
1414                             ),
1415                             obj=cls,
1416                             id='models.E005',
1417                         )
1418                     )
1419                 used_fields[f.name] = f
1420                 used_fields[f.attname] = f
1421 
1422         # Check that fields defined in the model don't clash with fields from
1423         # parents, including auto-generated fields like multi-table inheritance
1424         # child accessors.
1425         for parent in cls._meta.get_parent_list():
1426             for f in parent._meta.get_fields():
1427                 if f not in used_fields:
1428                     used_fields[f.name] = f
1429 
1430         for f in cls._meta.local_fields:
1431             clash = used_fields.get(f.name) or used_fields.get(f.attname) or None
1432             # Note that we may detect clash between user-defined non-unique
1433             # field "id" and automatically added unique field "id", both
1434             # defined at the same model. This special case is considered in
1435             # _check_id_field and here we ignore it.
1436             id_conflict = f.name == "id" and clash and clash.name == "id" and clash.model == cls
1437             if clash and not id_conflict:
1438                 errors.append(
1439                     checks.Error(
1440                         "The field '%s' clashes with the field '%s' "
1441                         "from model '%s'." % (
1442                             f.name, clash.name, clash.model._meta
1443                         ),
1444                         obj=f,
1445                         id='models.E006',
1446                     )
1447                 )
1448             used_fields[f.name] = f
1449             used_fields[f.attname] = f
1450 
1451         return errors
1452 
1453     @classmethod
1454     def _check_column_name_clashes(cls):
1455         # Store a list of column names which have already been used by other fields.
1456         used_column_names = []
1457         errors = []
1458 
1459         for f in cls._meta.local_fields:
1460             _, column_name = f.get_attname_column()
1461 
1462             # Ensure the column name is not already in use.
1463             if column_name and column_name in used_column_names:
1464                 errors.append(
1465                     checks.Error(
1466                         "Field '%s' has column name '%s' that is used by "
1467                         "another field." % (f.name, column_name),
1468                         hint="Specify a 'db_column' for the field.",
1469                         obj=cls,
1470                         id='models.E007'
1471                     )
1472                 )
1473             else:
1474                 used_column_names.append(column_name)
1475 
1476         return errors
1477 
1478     @classmethod
1479     def _check_model_name_db_lookup_clashes(cls):
1480         errors = []
1481         model_name = cls.__name__
1482         if model_name.startswith('_') or model_name.endswith('_'):
1483             errors.append(
1484                 checks.Error(
1485                     "The model name '%s' cannot start or end with an underscore "
1486                     "as it collides with the query lookup syntax." % model_name,
1487                     obj=cls,
1488                     id='models.E023'
1489                 )
1490             )
1491         elif LOOKUP_SEP in model_name:
1492             errors.append(
1493                 checks.Error(
1494                     "The model name '%s' cannot contain double underscores as "
1495                     "it collides with the query lookup syntax." % model_name,
1496                     obj=cls,
1497                     id='models.E024'
1498                 )
1499             )
1500         return errors
1501 
1502     @classmethod
1503     def _check_property_name_related_field_accessor_clashes(cls):
1504         errors = []
1505         property_names = cls._meta._property_names
1506         related_field_accessors = (
1507             f.get_attname() for f in cls._meta._get_fields(reverse=False)
1508             if f.is_relation and f.related_model is not None
1509         )
1510         for accessor in related_field_accessors:
1511             if accessor in property_names:
1512                 errors.append(
1513                     checks.Error(
1514                         "The property '%s' clashes with a related field "
1515                         "accessor." % accessor,
1516                         obj=cls,
1517                         id='models.E025',
1518                     )
1519                 )
1520         return errors
1521 
1522     @classmethod
1523     def _check_single_primary_key(cls):
1524         errors = []
1525         if sum(1 for f in cls._meta.local_fields if f.primary_key) > 1:
1526             errors.append(
1527                 checks.Error(
1528                     "The model cannot have more than one field with "
1529                     "'primary_key=True'.",
1530                     obj=cls,
1531                     id='models.E026',
1532                 )
1533             )
1534         return errors
1535 
1536     @classmethod
1537     def _check_index_together(cls):
1538         """Check the value of "index_together" option."""
1539         if not isinstance(cls._meta.index_together, (tuple, list)):
1540             return [
1541                 checks.Error(
1542                     "'index_together' must be a list or tuple.",
1543                     obj=cls,
1544                     id='models.E008',
1545                 )
1546             ]
1547 
1548         elif any(not isinstance(fields, (tuple, list)) for fields in cls._meta.index_together):
1549             return [
1550                 checks.Error(
1551                     "All 'index_together' elements must be lists or tuples.",
1552                     obj=cls,
1553                     id='models.E009',
1554                 )
1555             ]
1556 
1557         else:
1558             errors = []
1559             for fields in cls._meta.index_together:
1560                 errors.extend(cls._check_local_fields(fields, "index_together"))
1561             return errors
1562 
1563     @classmethod
1564     def _check_unique_together(cls):
1565         """Check the value of "unique_together" option."""
1566         if not isinstance(cls._meta.unique_together, (tuple, list)):
1567             return [
1568                 checks.Error(
1569                     "'unique_together' must be a list or tuple.",
1570                     obj=cls,
1571                     id='models.E010',
1572                 )
1573             ]
1574 
1575         elif any(not isinstance(fields, (tuple, list)) for fields in cls._meta.unique_together):
1576             return [
1577                 checks.Error(
1578                     "All 'unique_together' elements must be lists or tuples.",
1579                     obj=cls,
1580                     id='models.E011',
1581                 )
1582             ]
1583 
1584         else:
1585             errors = []
1586             for fields in cls._meta.unique_together:
1587                 errors.extend(cls._check_local_fields(fields, "unique_together"))
1588             return errors
1589 
1590     @classmethod
1591     def _check_indexes(cls, databases):
1592         """Check fields, names, and conditions of indexes."""
1593         errors = []
1594         for index in cls._meta.indexes:
1595             # Index name can't start with an underscore or a number, restricted
1596             # for cross-database compatibility with Oracle.
1597             if index.name[0] == '_' or index.name[0].isdigit():
1598                 errors.append(
1599                     checks.Error(
1600                         "The index name '%s' cannot start with an underscore "
1601                         "or a number." % index.name,
1602                         obj=cls,
1603                         id='models.E033',
1604                     ),
1605                 )
1606             if len(index.name) > index.max_name_length:
1607                 errors.append(
1608                     checks.Error(
1609                         "The index name '%s' cannot be longer than %d "
1610                         "characters." % (index.name, index.max_name_length),
1611                         obj=cls,
1612                         id='models.E034',
1613                     ),
1614                 )
1615         for db in databases:
1616             if not router.allow_migrate_model(db, cls):
1617                 continue
1618             connection = connections[db]
1619             if not (
1620                 connection.features.supports_partial_indexes or
1621                 'supports_partial_indexes' in cls._meta.required_db_features
1622             ) and any(index.condition is not None for index in cls._meta.indexes):
1623                 errors.append(
1624                     checks.Warning(
1625                         '%s does not support indexes with conditions.'
1626                         % connection.display_name,
1627                         hint=(
1628                             "Conditions will be ignored. Silence this warning "
1629                             "if you don't care about it."
1630                         ),
1631                         obj=cls,
1632                         id='models.W037',
1633                     )
1634                 )
1635             if not (
1636                 connection.features.supports_covering_indexes or
1637                 'supports_covering_indexes' in cls._meta.required_db_features
1638             ) and any(index.include for index in cls._meta.indexes):
1639                 errors.append(
1640                     checks.Warning(
1641                         '%s does not support indexes with non-key columns.'
1642                         % connection.display_name,
1643                         hint=(
1644                             "Non-key columns will be ignored. Silence this "
1645                             "warning if you don't care about it."
1646                         ),
1647                         obj=cls,
1648                         id='models.W040',
1649                     )
1650                 )
1651         fields = [field for index in cls._meta.indexes for field, _ in index.fields_orders]
1652         fields += [include for index in cls._meta.indexes for include in index.include]
1653         errors.extend(cls._check_local_fields(fields, 'indexes'))
1654         return errors
1655 
1656     @classmethod
1657     def _check_local_fields(cls, fields, option):
1658         from django.db import models
1659 
1660         # In order to avoid hitting the relation tree prematurely, we use our
1661         # own fields_map instead of using get_field()
1662         forward_fields_map = {}
1663         for field in cls._meta._get_fields(reverse=False):
1664             forward_fields_map[field.name] = field
1665             if hasattr(field, 'attname'):
1666                 forward_fields_map[field.attname] = field
1667 
1668         errors = []
1669         for field_name in fields:
1670             try:
1671                 field = forward_fields_map[field_name]
1672             except KeyError:
1673                 errors.append(
1674                     checks.Error(
1675                         "'%s' refers to the nonexistent field '%s'." % (
1676                             option, field_name,
1677                         ),
1678                         obj=cls,
1679                         id='models.E012',
1680                     )
1681                 )
1682             else:
1683                 if isinstance(field.remote_field, models.ManyToManyRel):
1684                     errors.append(
1685                         checks.Error(
1686                             "'%s' refers to a ManyToManyField '%s', but "
1687                             "ManyToManyFields are not permitted in '%s'." % (
1688                                 option, field_name, option,
1689                             ),
1690                             obj=cls,
1691                             id='models.E013',
1692                         )
1693                     )
1694                 elif field not in cls._meta.local_fields:
1695                     errors.append(
1696                         checks.Error(
1697                             "'%s' refers to field '%s' which is not local to model '%s'."
1698                             % (option, field_name, cls._meta.object_name),
1699                             hint="This issue may be caused by multi-table inheritance.",
1700                             obj=cls,
1701                             id='models.E016',
1702                         )
1703                     )
1704         return errors
1705 
1706     @classmethod
1707     def _check_ordering(cls):
1708         """
1709         Check "ordering" option -- is it a list of strings and do all fields
1710         exist?
1711         """
1712         if cls._meta._ordering_clash:
1713             return [
1714                 checks.Error(
1715                     "'ordering' and 'order_with_respect_to' cannot be used together.",
1716                     obj=cls,
1717                     id='models.E021',
1718                 ),
1719             ]
1720 
1721         if cls._meta.order_with_respect_to or not cls._meta.ordering:
1722             return []
1723 
1724         if not isinstance(cls._meta.ordering, (list, tuple)):
1725             return [
1726                 checks.Error(
1727                     "'ordering' must be a tuple or list (even if you want to order by only one field).",
1728                     obj=cls,
1729                     id='models.E014',
1730                 )
1731             ]
1732 
1733         errors = []
1734         fields = cls._meta.ordering
1735 
1736         # Skip expressions and '?' fields.
1737         fields = (f for f in fields if isinstance(f, str) and f != '?')
1738 
1739         # Convert "-field" to "field".
1740         fields = ((f[1:] if f.startswith('-') else f) for f in fields)
1741 
1742         # Separate related fields and non-related fields.
1743         _fields = []
1744         related_fields = []
1745         for f in fields:
1746             if LOOKUP_SEP in f:
1747                 related_fields.append(f)
1748             else:
1749                 _fields.append(f)
1750         fields = _fields
1751 
1752         # Check related fields.
1753         for field in related_fields:
1754             _cls = cls
1755             fld = None
1756             for part in field.split(LOOKUP_SEP):
1757                 try:
1758                     # pk is an alias that won't be found by opts.get_field.
1759                     if part == 'pk':
1760                         fld = _cls._meta.pk
1761                     else:
1762                         fld = _cls._meta.get_field(part)
1763                     if fld.is_relation:
1764                         _cls = fld.get_path_info()[-1].to_opts.model
1765                     else:
1766                         _cls = None
1767                 except (FieldDoesNotExist, AttributeError):
1768                     if fld is None or (
1769                         fld.get_transform(part) is None and fld.get_lookup(part) is None
1770                     ):
1771                         errors.append(
1772                             checks.Error(
1773                                 "'ordering' refers to the nonexistent field, "
1774                                 "related field, or lookup '%s'." % field,
1775                                 obj=cls,
1776                                 id='models.E015',
1777                             )
1778                         )
1779 
1780         # Skip ordering on pk. This is always a valid order_by field
1781         # but is an alias and therefore won't be found by opts.get_field.
1782         fields = {f for f in fields if f != 'pk'}
1783 
1784         # Check for invalid or nonexistent fields in ordering.
1785         invalid_fields = []
1786 
1787         # Any field name that is not present in field_names does not exist.
1788         # Also, ordering by m2m fields is not allowed.
1789         opts = cls._meta
1790         valid_fields = set(chain.from_iterable(
1791             (f.name, f.attname) if not (f.auto_created and not f.concrete) else (f.field.related_query_name(),)
1792             for f in chain(opts.fields, opts.related_objects)
1793         ))
1794 
1795         invalid_fields.extend(fields - valid_fields)
1796 
1797         for invalid_field in invalid_fields:
1798             errors.append(
1799                 checks.Error(
1800                     "'ordering' refers to the nonexistent field, related "
1801                     "field, or lookup '%s'." % invalid_field,
1802                     obj=cls,
1803                     id='models.E015',
1804                 )
1805             )
1806         return errors
1807 
1808     @classmethod
1809     def _check_long_column_names(cls, databases):
1810         """
1811         Check that any auto-generated column names are shorter than the limits
1812         for each database in which the model will be created.
1813         """
1814         if not databases:
1815             return []
1816         errors = []
1817         allowed_len = None
1818         db_alias = None
1819 
1820         # Find the minimum max allowed length among all specified db_aliases.
1821         for db in databases:
1822             # skip databases where the model won't be created
1823             if not router.allow_migrate_model(db, cls):
1824                 continue
1825             connection = connections[db]
1826             max_name_length = connection.ops.max_name_length()
1827             if max_name_length is None or connection.features.truncates_names:
1828                 continue
1829             else:
1830                 if allowed_len is None:
1831                     allowed_len = max_name_length
1832                     db_alias = db
1833                 elif max_name_length < allowed_len:
1834                     allowed_len = max_name_length
1835                     db_alias = db
1836 
1837         if allowed_len is None:
1838             return errors
1839 
1840         for f in cls._meta.local_fields:
1841             _, column_name = f.get_attname_column()
1842 
1843             # Check if auto-generated name for the field is too long
1844             # for the database.
1845             if f.db_column is None and column_name is not None and len(column_name) > allowed_len:
1846                 errors.append(
1847                     checks.Error(
1848                         'Autogenerated column name too long for field "%s". '
1849                         'Maximum length is "%s" for database "%s".'
1850                         % (column_name, allowed_len, db_alias),
1851                         hint="Set the column name manually using 'db_column'.",
1852                         obj=cls,
1853                         id='models.E018',
1854                     )
1855                 )
1856 
1857         for f in cls._meta.local_many_to_many:
1858             # Skip nonexistent models.
1859             if isinstance(f.remote_field.through, str):
1860                 continue
1861 
1862             # Check if auto-generated name for the M2M field is too long
1863             # for the database.
1864             for m2m in f.remote_field.through._meta.local_fields:
1865                 _, rel_name = m2m.get_attname_column()
1866                 if m2m.db_column is None and rel_name is not None and len(rel_name) > allowed_len:
1867                     errors.append(
1868                         checks.Error(
1869                             'Autogenerated column name too long for M2M field '
1870                             '"%s". Maximum length is "%s" for database "%s".'
1871                             % (rel_name, allowed_len, db_alias),
1872                             hint=(
1873                                 "Use 'through' to create a separate model for "
1874                                 "M2M and then set column_name using 'db_column'."
1875                             ),
1876                             obj=cls,
1877                             id='models.E019',
1878                         )
1879                     )
1880 
1881         return errors
1882 
1883     @classmethod
1884     def _get_expr_references(cls, expr):
1885         if isinstance(expr, Q):
1886             for child in expr.children:
1887                 if isinstance(child, tuple):
1888                     lookup, value = child
1889                     yield tuple(lookup.split(LOOKUP_SEP))
1890                     yield from cls._get_expr_references(value)
1891                 else:
1892                     yield from cls._get_expr_references(child)
1893         elif isinstance(expr, F):
1894             yield tuple(expr.name.split(LOOKUP_SEP))
1895         elif hasattr(expr, 'get_source_expressions'):
1896             for src_expr in expr.get_source_expressions():
1897                 yield from cls._get_expr_references(src_expr)
1898 
1899     @classmethod
1900     def _check_constraints(cls, databases):
1901         errors = []
1902         for db in databases:
1903             if not router.allow_migrate_model(db, cls):
1904                 continue
1905             connection = connections[db]
1906             if not (
1907                 connection.features.supports_table_check_constraints or
1908                 'supports_table_check_constraints' in cls._meta.required_db_features
1909             ) and any(
1910                 isinstance(constraint, CheckConstraint)
1911                 for constraint in cls._meta.constraints
1912             ):
1913                 errors.append(
1914                     checks.Warning(
1915                         '%s does not support check constraints.' % connection.display_name,
1916                         hint=(
1917                             "A constraint won't be created. Silence this "
1918                             "warning if you don't care about it."
1919                         ),
1920                         obj=cls,
1921                         id='models.W027',
1922                     )
1923                 )
1924             if not (
1925                 connection.features.supports_partial_indexes or
1926                 'supports_partial_indexes' in cls._meta.required_db_features
1927             ) and any(
1928                 isinstance(constraint, UniqueConstraint) and constraint.condition is not None
1929                 for constraint in cls._meta.constraints
1930             ):
1931                 errors.append(
1932                     checks.Warning(
1933                         '%s does not support unique constraints with '
1934                         'conditions.' % connection.display_name,
1935                         hint=(
1936                             "A constraint won't be created. Silence this "
1937                             "warning if you don't care about it."
1938                         ),
1939                         obj=cls,
1940                         id='models.W036',
1941                     )
1942                 )
1943             if not (
1944                 connection.features.supports_deferrable_unique_constraints or
1945                 'supports_deferrable_unique_constraints' in cls._meta.required_db_features
1946             ) and any(
1947                 isinstance(constraint, UniqueConstraint) and constraint.deferrable is not None
1948                 for constraint in cls._meta.constraints
1949             ):
1950                 errors.append(
1951                     checks.Warning(
1952                         '%s does not support deferrable unique constraints.'
1953                         % connection.display_name,
1954                         hint=(
1955                             "A constraint won't be created. Silence this "
1956                             "warning if you don't care about it."
1957                         ),
1958                         obj=cls,
1959                         id='models.W038',
1960                     )
1961                 )
1962             if not (
1963                 connection.features.supports_covering_indexes or
1964                 'supports_covering_indexes' in cls._meta.required_db_features
1965             ) and any(
1966                 isinstance(constraint, UniqueConstraint) and constraint.include
1967                 for constraint in cls._meta.constraints
1968             ):
1969                 errors.append(
1970                     checks.Warning(
1971                         '%s does not support unique constraints with non-key '
1972                         'columns.' % connection.display_name,
1973                         hint=(
1974                             "A constraint won't be created. Silence this "
1975                             "warning if you don't care about it."
1976                         ),
1977                         obj=cls,
1978                         id='models.W039',
1979                     )
1980                 )
1981             fields = set(chain.from_iterable(
1982                 (*constraint.fields, *constraint.include)
1983                 for constraint in cls._meta.constraints if isinstance(constraint, UniqueConstraint)
1984             ))
1985             references = set()
1986             for constraint in cls._meta.constraints:
1987                 if isinstance(constraint, UniqueConstraint):
1988                     if (
1989                         connection.features.supports_partial_indexes or
1990                         'supports_partial_indexes' not in cls._meta.required_db_features
1991                     ) and isinstance(constraint.condition, Q):
1992                         references.update(cls._get_expr_references(constraint.condition))
1993                 elif isinstance(constraint, CheckConstraint):
1994                     if (
1995                         connection.features.supports_table_check_constraints or
1996                         'supports_table_check_constraints' not in cls._meta.required_db_features
1997                     ) and isinstance(constraint.check, Q):
1998                         references.update(cls._get_expr_references(constraint.check))
1999             for field_name, *lookups in references:
2000                 # pk is an alias that won't be found by opts.get_field.
2001                 if field_name != 'pk':
2002                     fields.add(field_name)
2003                 if not lookups:
2004                     # If it has no lookups it cannot result in a JOIN.
2005                     continue
2006                 try:
2007                     if field_name == 'pk':
2008                         field = cls._meta.pk
2009                     else:
2010                         field = cls._meta.get_field(field_name)
2011                     if not field.is_relation or field.many_to_many or field.one_to_many:
2012                         continue
2013                 except FieldDoesNotExist:
2014                     continue
2015                 # JOIN must happen at the first lookup.
2016                 first_lookup = lookups[0]
2017                 if (
2018                     field.get_transform(first_lookup) is None and
2019                     field.get_lookup(first_lookup) is None
2020                 ):
2021                     errors.append(
2022                         checks.Error(
2023                             "'constraints' refers to the joined field '%s'."
2024                             % LOOKUP_SEP.join([field_name] + lookups),
2025                             obj=cls,
2026                             id='models.E041',
2027                         )
2028                     )
2029             errors.extend(cls._check_local_fields(fields, 'constraints'))
2030         return errors

</code><intended_behavior>The handling of the model's `_state`, especially the `fields_cache`, needs to be adjusted to ensure a correct copy mechanism. When a model instance is copied via `copy.copy()`, the `fields_cache` should either be deeply copied to the new instance or reset entirely. This ensures that any modifications to ForeignKey fields in the copied instance do not affect the original instance, maintaining the integrity of the cached relationships.</intended_behavior>]
2025-10-18 00:31:41.087 | INFO     | Search completed. Bug locations: [<file>django/db/models/base.py</file>
<class>Model</class>
<method>None</method>
<code>
404 class Model(metaclass=ModelBase):
405 
406     def __init__(self, *args, **kwargs):
407         # Alias some things as locals to avoid repeat global lookups
408         cls = self.__class__
409         opts = self._meta
410         _setattr = setattr
411         _DEFERRED = DEFERRED
412         if opts.abstract:
413             raise TypeError('Abstract models cannot be instantiated.')
414 
415         pre_init.send(sender=cls, args=args, kwargs=kwargs)
416 
417         # Set up the storage for instance state
418         self._state = ModelState()
419 
420         # There is a rather weird disparity here; if kwargs, it's set, then args
421         # overrides it. It should be one or the other; don't duplicate the work
422         # The reason for the kwargs check is that standard iterator passes in by
423         # args, and instantiation for iteration is 33% faster.
424         if len(args) > len(opts.concrete_fields):
425             # Daft, but matches old exception sans the err msg.
426             raise IndexError("Number of args exceeds number of fields")
427 
428         if not kwargs:
429             fields_iter = iter(opts.concrete_fields)
430             # The ordering of the zip calls matter - zip throws StopIteration
431             # when an iter throws it. So if the first iter throws it, the second
432             # is *not* consumed. We rely on this, so don't change the order
433             # without changing the logic.
434             for val, field in zip(args, fields_iter):
435                 if val is _DEFERRED:
436                     continue
437                 _setattr(self, field.attname, val)
438         else:
439             # Slower, kwargs-ready version.
440             fields_iter = iter(opts.fields)
441             for val, field in zip(args, fields_iter):
442                 if val is _DEFERRED:
443                     continue
444                 _setattr(self, field.attname, val)
445                 kwargs.pop(field.name, None)
446 
447         # Now we're left with the unprocessed fields that *must* come from
448         # keywords, or default.
449 
450         for field in fields_iter:
451             is_related_object = False
452             # Virtual field
453             if field.attname not in kwargs and field.column is None:
454                 continue
455             if kwargs:
456                 if isinstance(field.remote_field, ForeignObjectRel):
457                     try:
458                         # Assume object instance was passed in.
459                         rel_obj = kwargs.pop(field.name)
460                         is_related_object = True
461                     except KeyError:
462                         try:
463                             # Object instance wasn't passed in -- must be an ID.
464                             val = kwargs.pop(field.attname)
465                         except KeyError:
466                             val = field.get_default()
467                 else:
468                     try:
469                         val = kwargs.pop(field.attname)
470                     except KeyError:
471                         # This is done with an exception rather than the
472                         # default argument on pop because we don't want
473                         # get_default() to be evaluated, and then not used.
474                         # Refs #12057.
475                         val = field.get_default()
476             else:
477                 val = field.get_default()
478 
479             if is_related_object:
480                 # If we are passed a related instance, set it using the
481                 # field.name instead of field.attname (e.g. "user" instead of
482                 # "user_id") so that the object gets properly cached (and type
483                 # checked) by the RelatedObjectDescriptor.
484                 if rel_obj is not _DEFERRED:
485                     _setattr(self, field.name, rel_obj)
486             else:
487                 if val is not _DEFERRED:
488                     _setattr(self, field.attname, val)
489 
490         if kwargs:
491             property_names = opts._property_names
492             for prop in tuple(kwargs):
493                 try:
494                     # Any remaining kwargs must correspond to properties or
495                     # virtual fields.
496                     if prop in property_names or opts.get_field(prop):
497                         if kwargs[prop] is not _DEFERRED:
498                             _setattr(self, prop, kwargs[prop])
499                         del kwargs[prop]
500                 except (AttributeError, FieldDoesNotExist):
501                     pass
502             for kwarg in kwargs:
503                 raise TypeError("%s() got an unexpected keyword argument '%s'" % (cls.__name__, kwarg))
504         super().__init__()
505         post_init.send(sender=cls, instance=self)
506 
507     @classmethod
508     def from_db(cls, db, field_names, values):
509         if len(values) != len(cls._meta.concrete_fields):
510             values_iter = iter(values)
511             values = [
512                 next(values_iter) if f.attname in field_names else DEFERRED
513                 for f in cls._meta.concrete_fields
514             ]
515         new = cls(*values)
516         new._state.adding = False
517         new._state.db = db
518         return new
519 
520     def __repr__(self):
521         return '<%s: %s>' % (self.__class__.__name__, self)
522 
523     def __str__(self):
524         return '%s object (%s)' % (self.__class__.__name__, self.pk)
525 
526     def __eq__(self, other):
527         if not isinstance(other, Model):
528             return NotImplemented
529         if self._meta.concrete_model != other._meta.concrete_model:
530             return False
531         my_pk = self.pk
532         if my_pk is None:
533             return self is other
534         return my_pk == other.pk
535 
536     def __hash__(self):
537         if self.pk is None:
538             raise TypeError("Model instances without primary key value are unhashable")
539         return hash(self.pk)
540 
541     def __reduce__(self):
542         data = self.__getstate__()
543         data[DJANGO_VERSION_PICKLE_KEY] = django.__version__
544         class_id = self._meta.app_label, self._meta.object_name
545         return model_unpickle, (class_id,), data
546 
547     def __getstate__(self):
548         """Hook to allow choosing the attributes to pickle."""
549         return self.__dict__
550 
551     def __setstate__(self, state):
552         pickled_version = state.get(DJANGO_VERSION_PICKLE_KEY)
553         if pickled_version:
554             if pickled_version != django.__version__:
555                 warnings.warn(
556                     "Pickled model instance's Django version %s does not "
557                     "match the current version %s."
558                     % (pickled_version, django.__version__),
559                     RuntimeWarning,
560                     stacklevel=2,
561                 )
562         else:
563             warnings.warn(
564                 "Pickled model instance's Django version is not specified.",
565                 RuntimeWarning,
566                 stacklevel=2,
567             )
568         self.__dict__.update(state)
569 
570     def _get_pk_val(self, meta=None):
571         meta = meta or self._meta
572         return getattr(self, meta.pk.attname)
573 
574     def _set_pk_val(self, value):
575         for parent_link in self._meta.parents.values():
576             if parent_link and parent_link != self._meta.pk:
577                 setattr(self, parent_link.target_field.attname, value)
578         return setattr(self, self._meta.pk.attname, value)
579 
580     pk = property(_get_pk_val, _set_pk_val)
581 
582     def get_deferred_fields(self):
583         """
584         Return a set containing names of deferred fields for this instance.
585         """
586         return {
587             f.attname for f in self._meta.concrete_fields
588             if f.attname not in self.__dict__
589         }
590 
591     def refresh_from_db(self, using=None, fields=None):
592         """
593         Reload field values from the database.
594 
595         By default, the reloading happens from the database this instance was
596         loaded from, or by the read router if this instance wasn't loaded from
597         any database. The using parameter will override the default.
598 
599         Fields can be used to specify which fields to reload. The fields
600         should be an iterable of field attnames. If fields is None, then
601         all non-deferred fields are reloaded.
602 
603         When accessing deferred fields of an instance, the deferred loading
604         of the field will call this method.
605         """
606         if fields is None:
607             self._prefetched_objects_cache = {}
608         else:
609             prefetched_objects_cache = getattr(self, '_prefetched_objects_cache', ())
610             for field in fields:
611                 if field in prefetched_objects_cache:
612                     del prefetched_objects_cache[field]
613                     fields.remove(field)
614             if not fields:
615                 return
616             if any(LOOKUP_SEP in f for f in fields):
617                 raise ValueError(
618                     'Found "%s" in fields argument. Relations and transforms '
619                     'are not allowed in fields.' % LOOKUP_SEP)
620 
621         hints = {'instance': self}
622         db_instance_qs = self.__class__._base_manager.db_manager(using, hints=hints).filter(pk=self.pk)
623 
624         # Use provided fields, if not set then reload all non-deferred fields.
625         deferred_fields = self.get_deferred_fields()
626         if fields is not None:
627             fields = list(fields)
628             db_instance_qs = db_instance_qs.only(*fields)
629         elif deferred_fields:
630             fields = [f.attname for f in self._meta.concrete_fields
631                       if f.attname not in deferred_fields]
632             db_instance_qs = db_instance_qs.only(*fields)
633 
634         db_instance = db_instance_qs.get()
635         non_loaded_fields = db_instance.get_deferred_fields()
636         for field in self._meta.concrete_fields:
637             if field.attname in non_loaded_fields:
638                 # This field wasn't refreshed - skip ahead.
639                 continue
640             setattr(self, field.attname, getattr(db_instance, field.attname))
641             # Clear cached foreign keys.
642             if field.is_relation and field.is_cached(self):
643                 field.delete_cached_value(self)
644 
645         # Clear cached relations.
646         for field in self._meta.related_objects:
647             if field.is_cached(self):
648                 field.delete_cached_value(self)
649 
650         self._state.db = db_instance._state.db
651 
652     def serializable_value(self, field_name):
653         """
654         Return the value of the field name for this instance. If the field is
655         a foreign key, return the id value instead of the object. If there's
656         no Field object with this name on the model, return the model
657         attribute's value.
658 
659         Used to serialize a field's value (in the serializer, or form output,
660         for example). Normally, you would just access the attribute directly
661         and not use this method.
662         """
663         try:
664             field = self._meta.get_field(field_name)
665         except FieldDoesNotExist:
666             return getattr(self, field_name)
667         return getattr(self, field.attname)
668 
669     def save(self, force_insert=False, force_update=False, using=None,
670              update_fields=None):
671         """
672         Save the current instance. Override this in a subclass if you want to
673         control the saving process.
674 
675         The 'force_insert' and 'force_update' parameters can be used to insist
676         that the "save" must be an SQL insert or update (or equivalent for
677         non-SQL backends), respectively. Normally, they should not be set.
678         """
679         # Ensure that a model instance without a PK hasn't been assigned to
680         # a ForeignKey or OneToOneField on this model. If the field is
681         # nullable, allowing the save() would result in silent data loss.
682         for field in self._meta.concrete_fields:
683             # If the related field isn't cached, then an instance hasn't
684             # been assigned and there's no need to worry about this check.
685             if field.is_relation and field.is_cached(self):
686                 obj = getattr(self, field.name, None)
687                 if not obj:
688                     continue
689                 # A pk may have been assigned manually to a model instance not
690                 # saved to the database (or auto-generated in a case like
691                 # UUIDField), but we allow the save to proceed and rely on the
692                 # database to raise an IntegrityError if applicable. If
693                 # constraints aren't supported by the database, there's the
694                 # unavoidable risk of data corruption.
695                 if obj.pk is None:
696                     # Remove the object from a related instance cache.
697                     if not field.remote_field.multiple:
698                         field.remote_field.delete_cached_value(obj)
699                     raise ValueError(
700                         "save() prohibited to prevent data loss due to "
701                         "unsaved related object '%s'." % field.name
702                     )
703                 elif getattr(self, field.attname) is None:
704                     # Use pk from related object if it has been saved after
705                     # an assignment.
706                     setattr(self, field.attname, obj.pk)
707                 # If the relationship's pk/to_field was changed, clear the
708                 # cached relationship.
709                 if getattr(obj, field.target_field.attname) != getattr(self, field.attname):
710                     field.delete_cached_value(self)
711 
712         using = using or router.db_for_write(self.__class__, instance=self)
713         if force_insert and (force_update or update_fields):
714             raise ValueError("Cannot force both insert and updating in model saving.")
715 
716         deferred_fields = self.get_deferred_fields()
717         if update_fields is not None:
718             # If update_fields is empty, skip the save. We do also check for
719             # no-op saves later on for inheritance cases. This bailout is
720             # still needed for skipping signal sending.
721             if not update_fields:
722                 return
723 
724             update_fields = frozenset(update_fields)
725             field_names = set()
726 
727             for field in self._meta.fields:
728                 if not field.primary_key:
729                     field_names.add(field.name)
730 
731                     if field.name != field.attname:
732                         field_names.add(field.attname)
733 
734             non_model_fields = update_fields.difference(field_names)
735 
736             if non_model_fields:
737                 raise ValueError("The following fields do not exist in this "
738                                  "model or are m2m fields: %s"
739                                  % ', '.join(non_model_fields))
740 
741         # If saving to the same database, and this model is deferred, then
742         # automatically do an "update_fields" save on the loaded fields.
743         elif not force_insert and deferred_fields and using == self._state.db:
744             field_names = set()
745             for field in self._meta.concrete_fields:
746                 if not field.primary_key and not hasattr(field, 'through'):
747                     field_names.add(field.attname)
748             loaded_fields = field_names.difference(deferred_fields)
749             if loaded_fields:
750                 update_fields = frozenset(loaded_fields)
751 
752         self.save_base(using=using, force_insert=force_insert,
753                        force_update=force_update, update_fields=update_fields)
754     save.alters_data = True
755 
756     def save_base(self, raw=False, force_insert=False,
757                   force_update=False, using=None, update_fields=None):
758         """
759         Handle the parts of saving which should be done only once per save,
760         yet need to be done in raw saves, too. This includes some sanity
761         checks and signal sending.
762 
763         The 'raw' argument is telling save_base not to save any parent
764         models and not to do any changes to the values before save. This
765         is used by fixture loading.
766         """
767         using = using or router.db_for_write(self.__class__, instance=self)
768         assert not (force_insert and (force_update or update_fields))
769         assert update_fields is None or update_fields
770         cls = origin = self.__class__
771         # Skip proxies, but keep the origin as the proxy model.
772         if cls._meta.proxy:
773             cls = cls._meta.concrete_model
774         meta = cls._meta
775         if not meta.auto_created:
776             pre_save.send(
777                 sender=origin, instance=self, raw=raw, using=using,
778                 update_fields=update_fields,
779             )
780         # A transaction isn't needed if one query is issued.
781         if meta.parents:
782             context_manager = transaction.atomic(using=using, savepoint=False)
783         else:
784             context_manager = transaction.mark_for_rollback_on_error(using=using)
785         with context_manager:
786             parent_inserted = False
787             if not raw:
788                 parent_inserted = self._save_parents(cls, using, update_fields)
789             updated = self._save_table(
790                 raw, cls, force_insert or parent_inserted,
791                 force_update, using, update_fields,
792             )
793         # Store the database on which the object was saved
794         self._state.db = using
795         # Once saved, this is no longer a to-be-added instance.
796         self._state.adding = False
797 
798         # Signal that the save is complete
799         if not meta.auto_created:
800             post_save.send(
801                 sender=origin, instance=self, created=(not updated),
802                 update_fields=update_fields, raw=raw, using=using,
803             )
804 
805     save_base.alters_data = True
806 
807     def _save_parents(self, cls, using, update_fields):
808         """Save all the parents of cls using values from self."""
809         meta = cls._meta
810         inserted = False
811         for parent, field in meta.parents.items():
812             # Make sure the link fields are synced between parent and self.
813             if (field and getattr(self, parent._meta.pk.attname) is None and
814                     getattr(self, field.attname) is not None):
815                 setattr(self, parent._meta.pk.attname, getattr(self, field.attname))
816             parent_inserted = self._save_parents(cls=parent, using=using, update_fields=update_fields)
817             updated = self._save_table(
818                 cls=parent, using=using, update_fields=update_fields,
819                 force_insert=parent_inserted,
820             )
821             if not updated:
822                 inserted = True
823             # Set the parent's PK value to self.
824             if field:
825                 setattr(self, field.attname, self._get_pk_val(parent._meta))
826                 # Since we didn't have an instance of the parent handy set
827                 # attname directly, bypassing the descriptor. Invalidate
828                 # the related object cache, in case it's been accidentally
829                 # populated. A fresh instance will be re-built from the
830                 # database if necessary.
831                 if field.is_cached(self):
832                     field.delete_cached_value(self)
833         return inserted
834 
835     def _save_table(self, raw=False, cls=None, force_insert=False,
836                     force_update=False, using=None, update_fields=None):
837         """
838         Do the heavy-lifting involved in saving. Update or insert the data
839         for a single table.
840         """
841         meta = cls._meta
842         non_pks = [f for f in meta.local_concrete_fields if not f.primary_key]
843 
844         if update_fields:
845             non_pks = [f for f in non_pks
846                        if f.name in update_fields or f.attname in update_fields]
847 
848         pk_val = self._get_pk_val(meta)
849         if pk_val is None:
850             pk_val = meta.pk.get_pk_value_on_save(self)
851             setattr(self, meta.pk.attname, pk_val)
852         pk_set = pk_val is not None
853         if not pk_set and (force_update or update_fields):
854             raise ValueError("Cannot force an update in save() with no primary key.")
855         updated = False
856         # Skip an UPDATE when adding an instance and primary key has a default.
857         if (
858             not raw and
859             not force_insert and
860             self._state.adding and
861             meta.pk.default and
862             meta.pk.default is not NOT_PROVIDED
863         ):
864             force_insert = True
865         # If possible, try an UPDATE. If that doesn't update anything, do an INSERT.
866         if pk_set and not force_insert:
867             base_qs = cls._base_manager.using(using)
868             values = [(f, None, (getattr(self, f.attname) if raw else f.pre_save(self, False)))
869                       for f in non_pks]
870             forced_update = update_fields or force_update
871             updated = self._do_update(base_qs, using, pk_val, values, update_fields,
872                                       forced_update)
873             if force_update and not updated:
874                 raise DatabaseError("Forced update did not affect any rows.")
875             if update_fields and not updated:
876                 raise DatabaseError("Save with update_fields did not affect any rows.")
877         if not updated:
878             if meta.order_with_respect_to:
879                 # If this is a model with an order_with_respect_to
880                 # autopopulate the _order field
881                 field = meta.order_with_respect_to
882                 filter_args = field.get_filter_kwargs_for_object(self)
883                 self._order = cls._base_manager.using(using).filter(**filter_args).aggregate(
884                     _order__max=Coalesce(
885                         ExpressionWrapper(Max('_order') + Value(1), output_field=IntegerField()),
886                         Value(0),
887                     ),
888                 )['_order__max']
889             fields = meta.local_concrete_fields
890             if not pk_set:
891                 fields = [f for f in fields if f is not meta.auto_field]
892 
893             returning_fields = meta.db_returning_fields
894             results = self._do_insert(cls._base_manager, using, fields, returning_fields, raw)
895             if results:
896                 for value, field in zip(results[0], returning_fields):
897                     setattr(self, field.attname, value)
898         return updated
899 
900     def _do_update(self, base_qs, using, pk_val, values, update_fields, forced_update):
901         """
902         Try to update the model. Return True if the model was updated (if an
903         update query was done and a matching row was found in the DB).
904         """
905         filtered = base_qs.filter(pk=pk_val)
906         if not values:
907             # We can end up here when saving a model in inheritance chain where
908             # update_fields doesn't target any field in current model. In that
909             # case we just say the update succeeded. Another case ending up here
910             # is a model with just PK - in that case check that the PK still
911             # exists.
912             return update_fields is not None or filtered.exists()
913         if self._meta.select_on_save and not forced_update:
914             return (
915                 filtered.exists() and
916                 # It may happen that the object is deleted from the DB right after
917                 # this check, causing the subsequent UPDATE to return zero matching
918                 # rows. The same result can occur in some rare cases when the
919                 # database returns zero despite the UPDATE being executed
920                 # successfully (a row is matched and updated). In order to
921                 # distinguish these two cases, the object's existence in the
922                 # database is again checked for if the UPDATE query returns 0.
923                 (filtered._update(values) > 0 or filtered.exists())
924             )
925         return filtered._update(values) > 0
926 
927     def _do_insert(self, manager, using, fields, returning_fields, raw):
928         """
929         Do an INSERT. If returning_fields is defined then this method should
930         return the newly created data for the model.
931         """
932         return manager._insert(
933             [self], fields=fields, returning_fields=returning_fields,
934             using=using, raw=raw,
935         )
936 
937     def delete(self, using=None, keep_parents=False):
938         using = using or router.db_for_write(self.__class__, instance=self)
939         assert self.pk is not None, (
940             "%s object can't be deleted because its %s attribute is set to None." %
941             (self._meta.object_name, self._meta.pk.attname)
942         )
943 
944         collector = Collector(using=using)
945         collector.collect([self], keep_parents=keep_parents)
946         return collector.delete()
947 
948     delete.alters_data = True
949 
950     def _get_FIELD_display(self, field):
951         value = getattr(self, field.attname)
952         choices_dict = dict(make_hashable(field.flatchoices))
953         # force_str() to coerce lazy strings.
954         return force_str(choices_dict.get(make_hashable(value), value), strings_only=True)
955 
956     def _get_next_or_previous_by_FIELD(self, field, is_next, **kwargs):
957         if not self.pk:
958             raise ValueError("get_next/get_previous cannot be used on unsaved objects.")
959         op = 'gt' if is_next else 'lt'
960         order = '' if is_next else '-'
961         param = getattr(self, field.attname)
962         q = Q(**{'%s__%s' % (field.name, op): param})
963         q = q | Q(**{field.name: param, 'pk__%s' % op: self.pk})
964         qs = self.__class__._default_manager.using(self._state.db).filter(**kwargs).filter(q).order_by(
965             '%s%s' % (order, field.name), '%spk' % order
966         )
967         try:
968             return qs[0]
969         except IndexError:
970             raise self.DoesNotExist("%s matching query does not exist." % self.__class__._meta.object_name)
971 
972     def _get_next_or_previous_in_order(self, is_next):
973         cachename = "__%s_order_cache" % is_next
974         if not hasattr(self, cachename):
975             op = 'gt' if is_next else 'lt'
976             order = '_order' if is_next else '-_order'
977             order_field = self._meta.order_with_respect_to
978             filter_args = order_field.get_filter_kwargs_for_object(self)
979             obj = self.__class__._default_manager.filter(**filter_args).filter(**{
980                 '_order__%s' % op: self.__class__._default_manager.values('_order').filter(**{
981                     self._meta.pk.name: self.pk
982                 })
983             }).order_by(order)[:1].get()
984             setattr(self, cachename, obj)
985         return getattr(self, cachename)
986 
987     def prepare_database_save(self, field):
988         if self.pk is None:
989             raise ValueError("Unsaved model instance %r cannot be used in an ORM query." % self)
990         return getattr(self, field.remote_field.get_related_field().attname)
991 
992     def clean(self):
993         """
994         Hook for doing any extra model-wide validation after clean() has been
995         called on every field by self.clean_fields. Any ValidationError raised
996         by this method will not be associated with a particular field; it will
997         have a special-case association with the field defined by NON_FIELD_ERRORS.
998         """
999         pass
1000 
1001     def validate_unique(self, exclude=None):
1002         """
1003         Check unique constraints on the model and raise ValidationError if any
1004         failed.
1005         """
1006         unique_checks, date_checks = self._get_unique_checks(exclude=exclude)
1007 
1008         errors = self._perform_unique_checks(unique_checks)
1009         date_errors = self._perform_date_checks(date_checks)
1010 
1011         for k, v in date_errors.items():
1012             errors.setdefault(k, []).extend(v)
1013 
1014         if errors:
1015             raise ValidationError(errors)
1016 
1017     def _get_unique_checks(self, exclude=None):
1018         """
1019         Return a list of checks to perform. Since validate_unique() could be
1020         called from a ModelForm, some fields may have been excluded; we can't
1021         perform a unique check on a model that is missing fields involved
1022         in that check. Fields that did not validate should also be excluded,
1023         but they need to be passed in via the exclude argument.
1024         """
1025         if exclude is None:
1026             exclude = []
1027         unique_checks = []
1028 
1029         unique_togethers = [(self.__class__, self._meta.unique_together)]
1030         constraints = [(self.__class__, self._meta.total_unique_constraints)]
1031         for parent_class in self._meta.get_parent_list():
1032             if parent_class._meta.unique_together:
1033                 unique_togethers.append((parent_class, parent_class._meta.unique_together))
1034             if parent_class._meta.total_unique_constraints:
1035                 constraints.append(
1036                     (parent_class, parent_class._meta.total_unique_constraints)
1037                 )
1038 
1039         for model_class, unique_together in unique_togethers:
1040             for check in unique_together:
1041                 if not any(name in exclude for name in check):
1042                     # Add the check if the field isn't excluded.
1043                     unique_checks.append((model_class, tuple(check)))
1044 
1045         for model_class, model_constraints in constraints:
1046             for constraint in model_constraints:
1047                 if not any(name in exclude for name in constraint.fields):
1048                     unique_checks.append((model_class, constraint.fields))
1049 
1050         # These are checks for the unique_for_<date/year/month>.
1051         date_checks = []
1052 
1053         # Gather a list of checks for fields declared as unique and add them to
1054         # the list of checks.
1055 
1056         fields_with_class = [(self.__class__, self._meta.local_fields)]
1057         for parent_class in self._meta.get_parent_list():
1058             fields_with_class.append((parent_class, parent_class._meta.local_fields))
1059 
1060         for model_class, fields in fields_with_class:
1061             for f in fields:
1062                 name = f.name
1063                 if name in exclude:
1064                     continue
1065                 if f.unique:
1066                     unique_checks.append((model_class, (name,)))
1067                 if f.unique_for_date and f.unique_for_date not in exclude:
1068                     date_checks.append((model_class, 'date', name, f.unique_for_date))
1069                 if f.unique_for_year and f.unique_for_year not in exclude:
1070                     date_checks.append((model_class, 'year', name, f.unique_for_year))
1071                 if f.unique_for_month and f.unique_for_month not in exclude:
1072                     date_checks.append((model_class, 'month', name, f.unique_for_month))
1073         return unique_checks, date_checks
1074 
1075     def _perform_unique_checks(self, unique_checks):
1076         errors = {}
1077 
1078         for model_class, unique_check in unique_checks:
1079             # Try to look up an existing object with the same values as this
1080             # object's values for all the unique field.
1081 
1082             lookup_kwargs = {}
1083             for field_name in unique_check:
1084                 f = self._meta.get_field(field_name)
1085                 lookup_value = getattr(self, f.attname)
1086                 # TODO: Handle multiple backends with different feature flags.
1087                 if (lookup_value is None or
1088                         (lookup_value == '' and connection.features.interprets_empty_strings_as_nulls)):
1089                     # no value, skip the lookup
1090                     continue
1091                 if f.primary_key and not self._state.adding:
1092                     # no need to check for unique primary key when editing
1093                     continue
1094                 lookup_kwargs[str(field_name)] = lookup_value
1095 
1096             # some fields were skipped, no reason to do the check
1097             if len(unique_check) != len(lookup_kwargs):
1098                 continue
1099 
1100             qs = model_class._default_manager.filter(**lookup_kwargs)
1101 
1102             # Exclude the current object from the query if we are editing an
1103             # instance (as opposed to creating a new one)
1104             # Note that we need to use the pk as defined by model_class, not
1105             # self.pk. These can be different fields because model inheritance
1106             # allows single model to have effectively multiple primary keys.
1107             # Refs #17615.
1108             model_class_pk = self._get_pk_val(model_class._meta)
1109             if not self._state.adding and model_class_pk is not None:
1110                 qs = qs.exclude(pk=model_class_pk)
1111             if qs.exists():
1112                 if len(unique_check) == 1:
1113                     key = unique_check[0]
1114                 else:
1115                     key = NON_FIELD_ERRORS
1116                 errors.setdefault(key, []).append(self.unique_error_message(model_class, unique_check))
1117 
1118         return errors
1119 
1120     def _perform_date_checks(self, date_checks):
1121         errors = {}
1122         for model_class, lookup_type, field, unique_for in date_checks:
1123             lookup_kwargs = {}
1124             # there's a ticket to add a date lookup, we can remove this special
1125             # case if that makes it's way in
1126             date = getattr(self, unique_for)
1127             if date is None:
1128                 continue
1129             if lookup_type == 'date':
1130                 lookup_kwargs['%s__day' % unique_for] = date.day
1131                 lookup_kwargs['%s__month' % unique_for] = date.month
1132                 lookup_kwargs['%s__year' % unique_for] = date.year
1133             else:
1134                 lookup_kwargs['%s__%s' % (unique_for, lookup_type)] = getattr(date, lookup_type)
1135             lookup_kwargs[field] = getattr(self, field)
1136 
1137             qs = model_class._default_manager.filter(**lookup_kwargs)
1138             # Exclude the current object from the query if we are editing an
1139             # instance (as opposed to creating a new one)
1140             if not self._state.adding and self.pk is not None:
1141                 qs = qs.exclude(pk=self.pk)
1142 
1143             if qs.exists():
1144                 errors.setdefault(field, []).append(
1145                     self.date_error_message(lookup_type, field, unique_for)
1146                 )
1147         return errors
1148 
1149     def date_error_message(self, lookup_type, field_name, unique_for):
1150         opts = self._meta
1151         field = opts.get_field(field_name)
1152         return ValidationError(
1153             message=field.error_messages['unique_for_date'],
1154             code='unique_for_date',
1155             params={
1156                 'model': self,
1157                 'model_name': capfirst(opts.verbose_name),
1158                 'lookup_type': lookup_type,
1159                 'field': field_name,
1160                 'field_label': capfirst(field.verbose_name),
1161                 'date_field': unique_for,
1162                 'date_field_label': capfirst(opts.get_field(unique_for).verbose_name),
1163             }
1164         )
1165 
1166     def unique_error_message(self, model_class, unique_check):
1167         opts = model_class._meta
1168 
1169         params = {
1170             'model': self,
1171             'model_class': model_class,
1172             'model_name': capfirst(opts.verbose_name),
1173             'unique_check': unique_check,
1174         }
1175 
1176         # A unique field
1177         if len(unique_check) == 1:
1178             field = opts.get_field(unique_check[0])
1179             params['field_label'] = capfirst(field.verbose_name)
1180             return ValidationError(
1181                 message=field.error_messages['unique'],
1182                 code='unique',
1183                 params=params,
1184             )
1185 
1186         # unique_together
1187         else:
1188             field_labels = [capfirst(opts.get_field(f).verbose_name) for f in unique_check]
1189             params['field_labels'] = get_text_list(field_labels, _('and'))
1190             return ValidationError(
1191                 message=_("%(model_name)s with this %(field_labels)s already exists."),
1192                 code='unique_together',
1193                 params=params,
1194             )
1195 
1196     def full_clean(self, exclude=None, validate_unique=True):
1197         """
1198         Call clean_fields(), clean(), and validate_unique() on the model.
1199         Raise a ValidationError for any errors that occur.
1200         """
1201         errors = {}
1202         if exclude is None:
1203             exclude = []
1204         else:
1205             exclude = list(exclude)
1206 
1207         try:
1208             self.clean_fields(exclude=exclude)
1209         except ValidationError as e:
1210             errors = e.update_error_dict(errors)
1211 
1212         # Form.clean() is run even if other validation fails, so do the
1213         # same with Model.clean() for consistency.
1214         try:
1215             self.clean()
1216         except ValidationError as e:
1217             errors = e.update_error_dict(errors)
1218 
1219         # Run unique checks, but only for fields that passed validation.
1220         if validate_unique:
1221             for name in errors:
1222                 if name != NON_FIELD_ERRORS and name not in exclude:
1223                     exclude.append(name)
1224             try:
1225                 self.validate_unique(exclude=exclude)
1226             except ValidationError as e:
1227                 errors = e.update_error_dict(errors)
1228 
1229         if errors:
1230             raise ValidationError(errors)
1231 
1232     def clean_fields(self, exclude=None):
1233         """
1234         Clean all fields and raise a ValidationError containing a dict
1235         of all validation errors if any occur.
1236         """
1237         if exclude is None:
1238             exclude = []
1239 
1240         errors = {}
1241         for f in self._meta.fields:
1242             if f.name in exclude:
1243                 continue
1244             # Skip validation for empty fields with blank=True. The developer
1245             # is responsible for making sure they have a valid value.
1246             raw_value = getattr(self, f.attname)
1247             if f.blank and raw_value in f.empty_values:
1248                 continue
1249             try:
1250                 setattr(self, f.attname, f.clean(raw_value, self))
1251             except ValidationError as e:
1252                 errors[f.name] = e.error_list
1253 
1254         if errors:
1255             raise ValidationError(errors)
1256 
1257     @classmethod
1258     def check(cls, **kwargs):
1259         errors = [*cls._check_swappable(), *cls._check_model(), *cls._check_managers(**kwargs)]
1260         if not cls._meta.swapped:
1261             databases = kwargs.get('databases') or []
1262             errors += [
1263                 *cls._check_fields(**kwargs),
1264                 *cls._check_m2m_through_same_relationship(),
1265                 *cls._check_long_column_names(databases),
1266             ]
1267             clash_errors = (
1268                 *cls._check_id_field(),
1269                 *cls._check_field_name_clashes(),
1270                 *cls._check_model_name_db_lookup_clashes(),
1271                 *cls._check_property_name_related_field_accessor_clashes(),
1272                 *cls._check_single_primary_key(),
1273             )
1274             errors.extend(clash_errors)
1275             # If there are field name clashes, hide consequent column name
1276             # clashes.
1277             if not clash_errors:
1278                 errors.extend(cls._check_column_name_clashes())
1279             errors += [
1280                 *cls._check_index_together(),
1281                 *cls._check_unique_together(),
1282                 *cls._check_indexes(databases),
1283                 *cls._check_ordering(),
1284                 *cls._check_constraints(databases),
1285             ]
1286 
1287         return errors
1288 
1289     @classmethod
1290     def _check_swappable(cls):
1291         """Check if the swapped model exists."""
1292         errors = []
1293         if cls._meta.swapped:
1294             try:
1295                 apps.get_model(cls._meta.swapped)
1296             except ValueError:
1297                 errors.append(
1298                     checks.Error(
1299                         "'%s' is not of the form 'app_label.app_name'." % cls._meta.swappable,
1300                         id='models.E001',
1301                     )
1302                 )
1303             except LookupError:
1304                 app_label, model_name = cls._meta.swapped.split('.')
1305                 errors.append(
1306                     checks.Error(
1307                         "'%s' references '%s.%s', which has not been "
1308                         "installed, or is abstract." % (
1309                             cls._meta.swappable, app_label, model_name
1310                         ),
1311                         id='models.E002',
1312                     )
1313                 )
1314         return errors
1315 
1316     @classmethod
1317     def _check_model(cls):
1318         errors = []
1319         if cls._meta.proxy:
1320             if cls._meta.local_fields or cls._meta.local_many_to_many:
1321                 errors.append(
1322                     checks.Error(
1323                         "Proxy model '%s' contains model fields." % cls.__name__,
1324                         id='models.E017',
1325                     )
1326                 )
1327         return errors
1328 
1329     @classmethod
1330     def _check_managers(cls, **kwargs):
1331         """Perform all manager checks."""
1332         errors = []
1333         for manager in cls._meta.managers:
1334             errors.extend(manager.check(**kwargs))
1335         return errors
1336 
1337     @classmethod
1338     def _check_fields(cls, **kwargs):
1339         """Perform all field checks."""
1340         errors = []
1341         for field in cls._meta.local_fields:
1342             errors.extend(field.check(**kwargs))
1343         for field in cls._meta.local_many_to_many:
1344             errors.extend(field.check(from_model=cls, **kwargs))
1345         return errors
1346 
1347     @classmethod
1348     def _check_m2m_through_same_relationship(cls):
1349         """ Check if no relationship model is used by more than one m2m field.
1350         """
1351 
1352         errors = []
1353         seen_intermediary_signatures = []
1354 
1355         fields = cls._meta.local_many_to_many
1356 
1357         # Skip when the target model wasn't found.
1358         fields = (f for f in fields if isinstance(f.remote_field.model, ModelBase))
1359 
1360         # Skip when the relationship model wasn't found.
1361         fields = (f for f in fields if isinstance(f.remote_field.through, ModelBase))
1362 
1363         for f in fields:
1364             signature = (f.remote_field.model, cls, f.remote_field.through, f.remote_field.through_fields)
1365             if signature in seen_intermediary_signatures:
1366                 errors.append(
1367                     checks.Error(
1368                         "The model has two identical many-to-many relations "
1369                         "through the intermediate model '%s'." %
1370                         f.remote_field.through._meta.label,
1371                         obj=cls,
1372                         id='models.E003',
1373                     )
1374                 )
1375             else:
1376                 seen_intermediary_signatures.append(signature)
1377         return errors
1378 
1379     @classmethod
1380     def _check_id_field(cls):
1381         """Check if `id` field is a primary key."""
1382         fields = [f for f in cls._meta.local_fields if f.name == 'id' and f != cls._meta.pk]
1383         # fields is empty or consists of the invalid "id" field
1384         if fields and not fields[0].primary_key and cls._meta.pk.name == 'id':
1385             return [
1386                 checks.Error(
1387                     "'id' can only be used as a field name if the field also "
1388                     "sets 'primary_key=True'.",
1389                     obj=cls,
1390                     id='models.E004',
1391                 )
1392             ]
1393         else:
1394             return []
1395 
1396     @classmethod
1397     def _check_field_name_clashes(cls):
1398         """Forbid field shadowing in multi-table inheritance."""
1399         errors = []
1400         used_fields = {}  # name or attname -> field
1401 
1402         # Check that multi-inheritance doesn't cause field name shadowing.
1403         for parent in cls._meta.get_parent_list():
1404             for f in parent._meta.local_fields:
1405                 clash = used_fields.get(f.name) or used_fields.get(f.attname) or None
1406                 if clash:
1407                     errors.append(
1408                         checks.Error(
1409                             "The field '%s' from parent model "
1410                             "'%s' clashes with the field '%s' "
1411                             "from parent model '%s'." % (
1412                                 clash.name, clash.model._meta,
1413                                 f.name, f.model._meta
1414                             ),
1415                             obj=cls,
1416                             id='models.E005',
1417                         )
1418                     )
1419                 used_fields[f.name] = f
1420                 used_fields[f.attname] = f
1421 
1422         # Check that fields defined in the model don't clash with fields from
1423         # parents, including auto-generated fields like multi-table inheritance
1424         # child accessors.
1425         for parent in cls._meta.get_parent_list():
1426             for f in parent._meta.get_fields():
1427                 if f not in used_fields:
1428                     used_fields[f.name] = f
1429 
1430         for f in cls._meta.local_fields:
1431             clash = used_fields.get(f.name) or used_fields.get(f.attname) or None
1432             # Note that we may detect clash between user-defined non-unique
1433             # field "id" and automatically added unique field "id", both
1434             # defined at the same model. This special case is considered in
1435             # _check_id_field and here we ignore it.
1436             id_conflict = f.name == "id" and clash and clash.name == "id" and clash.model == cls
1437             if clash and not id_conflict:
1438                 errors.append(
1439                     checks.Error(
1440                         "The field '%s' clashes with the field '%s' "
1441                         "from model '%s'." % (
1442                             f.name, clash.name, clash.model._meta
1443                         ),
1444                         obj=f,
1445                         id='models.E006',
1446                     )
1447                 )
1448             used_fields[f.name] = f
1449             used_fields[f.attname] = f
1450 
1451         return errors
1452 
1453     @classmethod
1454     def _check_column_name_clashes(cls):
1455         # Store a list of column names which have already been used by other fields.
1456         used_column_names = []
1457         errors = []
1458 
1459         for f in cls._meta.local_fields:
1460             _, column_name = f.get_attname_column()
1461 
1462             # Ensure the column name is not already in use.
1463             if column_name and column_name in used_column_names:
1464                 errors.append(
1465                     checks.Error(
1466                         "Field '%s' has column name '%s' that is used by "
1467                         "another field." % (f.name, column_name),
1468                         hint="Specify a 'db_column' for the field.",
1469                         obj=cls,
1470                         id='models.E007'
1471                     )
1472                 )
1473             else:
1474                 used_column_names.append(column_name)
1475 
1476         return errors
1477 
1478     @classmethod
1479     def _check_model_name_db_lookup_clashes(cls):
1480         errors = []
1481         model_name = cls.__name__
1482         if model_name.startswith('_') or model_name.endswith('_'):
1483             errors.append(
1484                 checks.Error(
1485                     "The model name '%s' cannot start or end with an underscore "
1486                     "as it collides with the query lookup syntax." % model_name,
1487                     obj=cls,
1488                     id='models.E023'
1489                 )
1490             )
1491         elif LOOKUP_SEP in model_name:
1492             errors.append(
1493                 checks.Error(
1494                     "The model name '%s' cannot contain double underscores as "
1495                     "it collides with the query lookup syntax." % model_name,
1496                     obj=cls,
1497                     id='models.E024'
1498                 )
1499             )
1500         return errors
1501 
1502     @classmethod
1503     def _check_property_name_related_field_accessor_clashes(cls):
1504         errors = []
1505         property_names = cls._meta._property_names
1506         related_field_accessors = (
1507             f.get_attname() for f in cls._meta._get_fields(reverse=False)
1508             if f.is_relation and f.related_model is not None
1509         )
1510         for accessor in related_field_accessors:
1511             if accessor in property_names:
1512                 errors.append(
1513                     checks.Error(
1514                         "The property '%s' clashes with a related field "
1515                         "accessor." % accessor,
1516                         obj=cls,
1517                         id='models.E025',
1518                     )
1519                 )
1520         return errors
1521 
1522     @classmethod
1523     def _check_single_primary_key(cls):
1524         errors = []
1525         if sum(1 for f in cls._meta.local_fields if f.primary_key) > 1:
1526             errors.append(
1527                 checks.Error(
1528                     "The model cannot have more than one field with "
1529                     "'primary_key=True'.",
1530                     obj=cls,
1531                     id='models.E026',
1532                 )
1533             )
1534         return errors
1535 
1536     @classmethod
1537     def _check_index_together(cls):
1538         """Check the value of "index_together" option."""
1539         if not isinstance(cls._meta.index_together, (tuple, list)):
1540             return [
1541                 checks.Error(
1542                     "'index_together' must be a list or tuple.",
1543                     obj=cls,
1544                     id='models.E008',
1545                 )
1546             ]
1547 
1548         elif any(not isinstance(fields, (tuple, list)) for fields in cls._meta.index_together):
1549             return [
1550                 checks.Error(
1551                     "All 'index_together' elements must be lists or tuples.",
1552                     obj=cls,
1553                     id='models.E009',
1554                 )
1555             ]
1556 
1557         else:
1558             errors = []
1559             for fields in cls._meta.index_together:
1560                 errors.extend(cls._check_local_fields(fields, "index_together"))
1561             return errors
1562 
1563     @classmethod
1564     def _check_unique_together(cls):
1565         """Check the value of "unique_together" option."""
1566         if not isinstance(cls._meta.unique_together, (tuple, list)):
1567             return [
1568                 checks.Error(
1569                     "'unique_together' must be a list or tuple.",
1570                     obj=cls,
1571                     id='models.E010',
1572                 )
1573             ]
1574 
1575         elif any(not isinstance(fields, (tuple, list)) for fields in cls._meta.unique_together):
1576             return [
1577                 checks.Error(
1578                     "All 'unique_together' elements must be lists or tuples.",
1579                     obj=cls,
1580                     id='models.E011',
1581                 )
1582             ]
1583 
1584         else:
1585             errors = []
1586             for fields in cls._meta.unique_together:
1587                 errors.extend(cls._check_local_fields(fields, "unique_together"))
1588             return errors
1589 
1590     @classmethod
1591     def _check_indexes(cls, databases):
1592         """Check fields, names, and conditions of indexes."""
1593         errors = []
1594         for index in cls._meta.indexes:
1595             # Index name can't start with an underscore or a number, restricted
1596             # for cross-database compatibility with Oracle.
1597             if index.name[0] == '_' or index.name[0].isdigit():
1598                 errors.append(
1599                     checks.Error(
1600                         "The index name '%s' cannot start with an underscore "
1601                         "or a number." % index.name,
1602                         obj=cls,
1603                         id='models.E033',
1604                     ),
1605                 )
1606             if len(index.name) > index.max_name_length:
1607                 errors.append(
1608                     checks.Error(
1609                         "The index name '%s' cannot be longer than %d "
1610                         "characters." % (index.name, index.max_name_length),
1611                         obj=cls,
1612                         id='models.E034',
1613                     ),
1614                 )
1615         for db in databases:
1616             if not router.allow_migrate_model(db, cls):
1617                 continue
1618             connection = connections[db]
1619             if not (
1620                 connection.features.supports_partial_indexes or
1621                 'supports_partial_indexes' in cls._meta.required_db_features
1622             ) and any(index.condition is not None for index in cls._meta.indexes):
1623                 errors.append(
1624                     checks.Warning(
1625                         '%s does not support indexes with conditions.'
1626                         % connection.display_name,
1627                         hint=(
1628                             "Conditions will be ignored. Silence this warning "
1629                             "if you don't care about it."
1630                         ),
1631                         obj=cls,
1632                         id='models.W037',
1633                     )
1634                 )
1635             if not (
1636                 connection.features.supports_covering_indexes or
1637                 'supports_covering_indexes' in cls._meta.required_db_features
1638             ) and any(index.include for index in cls._meta.indexes):
1639                 errors.append(
1640                     checks.Warning(
1641                         '%s does not support indexes with non-key columns.'
1642                         % connection.display_name,
1643                         hint=(
1644                             "Non-key columns will be ignored. Silence this "
1645                             "warning if you don't care about it."
1646                         ),
1647                         obj=cls,
1648                         id='models.W040',
1649                     )
1650                 )
1651         fields = [field for index in cls._meta.indexes for field, _ in index.fields_orders]
1652         fields += [include for index in cls._meta.indexes for include in index.include]
1653         errors.extend(cls._check_local_fields(fields, 'indexes'))
1654         return errors
1655 
1656     @classmethod
1657     def _check_local_fields(cls, fields, option):
1658         from django.db import models
1659 
1660         # In order to avoid hitting the relation tree prematurely, we use our
1661         # own fields_map instead of using get_field()
1662         forward_fields_map = {}
1663         for field in cls._meta._get_fields(reverse=False):
1664             forward_fields_map[field.name] = field
1665             if hasattr(field, 'attname'):
1666                 forward_fields_map[field.attname] = field
1667 
1668         errors = []
1669         for field_name in fields:
1670             try:
1671                 field = forward_fields_map[field_name]
1672             except KeyError:
1673                 errors.append(
1674                     checks.Error(
1675                         "'%s' refers to the nonexistent field '%s'." % (
1676                             option, field_name,
1677                         ),
1678                         obj=cls,
1679                         id='models.E012',
1680                     )
1681                 )
1682             else:
1683                 if isinstance(field.remote_field, models.ManyToManyRel):
1684                     errors.append(
1685                         checks.Error(
1686                             "'%s' refers to a ManyToManyField '%s', but "
1687                             "ManyToManyFields are not permitted in '%s'." % (
1688                                 option, field_name, option,
1689                             ),
1690                             obj=cls,
1691                             id='models.E013',
1692                         )
1693                     )
1694                 elif field not in cls._meta.local_fields:
1695                     errors.append(
1696                         checks.Error(
1697                             "'%s' refers to field '%s' which is not local to model '%s'."
1698                             % (option, field_name, cls._meta.object_name),
1699                             hint="This issue may be caused by multi-table inheritance.",
1700                             obj=cls,
1701                             id='models.E016',
1702                         )
1703                     )
1704         return errors
1705 
1706     @classmethod
1707     def _check_ordering(cls):
1708         """
1709         Check "ordering" option -- is it a list of strings and do all fields
1710         exist?
1711         """
1712         if cls._meta._ordering_clash:
1713             return [
1714                 checks.Error(
1715                     "'ordering' and 'order_with_respect_to' cannot be used together.",
1716                     obj=cls,
1717                     id='models.E021',
1718                 ),
1719             ]
1720 
1721         if cls._meta.order_with_respect_to or not cls._meta.ordering:
1722             return []
1723 
1724         if not isinstance(cls._meta.ordering, (list, tuple)):
1725             return [
1726                 checks.Error(
1727                     "'ordering' must be a tuple or list (even if you want to order by only one field).",
1728                     obj=cls,
1729                     id='models.E014',
1730                 )
1731             ]
1732 
1733         errors = []
1734         fields = cls._meta.ordering
1735 
1736         # Skip expressions and '?' fields.
1737         fields = (f for f in fields if isinstance(f, str) and f != '?')
1738 
1739         # Convert "-field" to "field".
1740         fields = ((f[1:] if f.startswith('-') else f) for f in fields)
1741 
1742         # Separate related fields and non-related fields.
1743         _fields = []
1744         related_fields = []
1745         for f in fields:
1746             if LOOKUP_SEP in f:
1747                 related_fields.append(f)
1748             else:
1749                 _fields.append(f)
1750         fields = _fields
1751 
1752         # Check related fields.
1753         for field in related_fields:
1754             _cls = cls
1755             fld = None
1756             for part in field.split(LOOKUP_SEP):
1757                 try:
1758                     # pk is an alias that won't be found by opts.get_field.
1759                     if part == 'pk':
1760                         fld = _cls._meta.pk
1761                     else:
1762                         fld = _cls._meta.get_field(part)
1763                     if fld.is_relation:
1764                         _cls = fld.get_path_info()[-1].to_opts.model
1765                     else:
1766                         _cls = None
1767                 except (FieldDoesNotExist, AttributeError):
1768                     if fld is None or (
1769                         fld.get_transform(part) is None and fld.get_lookup(part) is None
1770                     ):
1771                         errors.append(
1772                             checks.Error(
1773                                 "'ordering' refers to the nonexistent field, "
1774                                 "related field, or lookup '%s'." % field,
1775                                 obj=cls,
1776                                 id='models.E015',
1777                             )
1778                         )
1779 
1780         # Skip ordering on pk. This is always a valid order_by field
1781         # but is an alias and therefore won't be found by opts.get_field.
1782         fields = {f for f in fields if f != 'pk'}
1783 
1784         # Check for invalid or nonexistent fields in ordering.
1785         invalid_fields = []
1786 
1787         # Any field name that is not present in field_names does not exist.
1788         # Also, ordering by m2m fields is not allowed.
1789         opts = cls._meta
1790         valid_fields = set(chain.from_iterable(
1791             (f.name, f.attname) if not (f.auto_created and not f.concrete) else (f.field.related_query_name(),)
1792             for f in chain(opts.fields, opts.related_objects)
1793         ))
1794 
1795         invalid_fields.extend(fields - valid_fields)
1796 
1797         for invalid_field in invalid_fields:
1798             errors.append(
1799                 checks.Error(
1800                     "'ordering' refers to the nonexistent field, related "
1801                     "field, or lookup '%s'." % invalid_field,
1802                     obj=cls,
1803                     id='models.E015',
1804                 )
1805             )
1806         return errors
1807 
1808     @classmethod
1809     def _check_long_column_names(cls, databases):
1810         """
1811         Check that any auto-generated column names are shorter than the limits
1812         for each database in which the model will be created.
1813         """
1814         if not databases:
1815             return []
1816         errors = []
1817         allowed_len = None
1818         db_alias = None
1819 
1820         # Find the minimum max allowed length among all specified db_aliases.
1821         for db in databases:
1822             # skip databases where the model won't be created
1823             if not router.allow_migrate_model(db, cls):
1824                 continue
1825             connection = connections[db]
1826             max_name_length = connection.ops.max_name_length()
1827             if max_name_length is None or connection.features.truncates_names:
1828                 continue
1829             else:
1830                 if allowed_len is None:
1831                     allowed_len = max_name_length
1832                     db_alias = db
1833                 elif max_name_length < allowed_len:
1834                     allowed_len = max_name_length
1835                     db_alias = db
1836 
1837         if allowed_len is None:
1838             return errors
1839 
1840         for f in cls._meta.local_fields:
1841             _, column_name = f.get_attname_column()
1842 
1843             # Check if auto-generated name for the field is too long
1844             # for the database.
1845             if f.db_column is None and column_name is not None and len(column_name) > allowed_len:
1846                 errors.append(
1847                     checks.Error(
1848                         'Autogenerated column name too long for field "%s". '
1849                         'Maximum length is "%s" for database "%s".'
1850                         % (column_name, allowed_len, db_alias),
1851                         hint="Set the column name manually using 'db_column'.",
1852                         obj=cls,
1853                         id='models.E018',
1854                     )
1855                 )
1856 
1857         for f in cls._meta.local_many_to_many:
1858             # Skip nonexistent models.
1859             if isinstance(f.remote_field.through, str):
1860                 continue
1861 
1862             # Check if auto-generated name for the M2M field is too long
1863             # for the database.
1864             for m2m in f.remote_field.through._meta.local_fields:
1865                 _, rel_name = m2m.get_attname_column()
1866                 if m2m.db_column is None and rel_name is not None and len(rel_name) > allowed_len:
1867                     errors.append(
1868                         checks.Error(
1869                             'Autogenerated column name too long for M2M field '
1870                             '"%s". Maximum length is "%s" for database "%s".'
1871                             % (rel_name, allowed_len, db_alias),
1872                             hint=(
1873                                 "Use 'through' to create a separate model for "
1874                                 "M2M and then set column_name using 'db_column'."
1875                             ),
1876                             obj=cls,
1877                             id='models.E019',
1878                         )
1879                     )
1880 
1881         return errors
1882 
1883     @classmethod
1884     def _get_expr_references(cls, expr):
1885         if isinstance(expr, Q):
1886             for child in expr.children:
1887                 if isinstance(child, tuple):
1888                     lookup, value = child
1889                     yield tuple(lookup.split(LOOKUP_SEP))
1890                     yield from cls._get_expr_references(value)
1891                 else:
1892                     yield from cls._get_expr_references(child)
1893         elif isinstance(expr, F):
1894             yield tuple(expr.name.split(LOOKUP_SEP))
1895         elif hasattr(expr, 'get_source_expressions'):
1896             for src_expr in expr.get_source_expressions():
1897                 yield from cls._get_expr_references(src_expr)
1898 
1899     @classmethod
1900     def _check_constraints(cls, databases):
1901         errors = []
1902         for db in databases:
1903             if not router.allow_migrate_model(db, cls):
1904                 continue
1905             connection = connections[db]
1906             if not (
1907                 connection.features.supports_table_check_constraints or
1908                 'supports_table_check_constraints' in cls._meta.required_db_features
1909             ) and any(
1910                 isinstance(constraint, CheckConstraint)
1911                 for constraint in cls._meta.constraints
1912             ):
1913                 errors.append(
1914                     checks.Warning(
1915                         '%s does not support check constraints.' % connection.display_name,
1916                         hint=(
1917                             "A constraint won't be created. Silence this "
1918                             "warning if you don't care about it."
1919                         ),
1920                         obj=cls,
1921                         id='models.W027',
1922                     )
1923                 )
1924             if not (
1925                 connection.features.supports_partial_indexes or
1926                 'supports_partial_indexes' in cls._meta.required_db_features
1927             ) and any(
1928                 isinstance(constraint, UniqueConstraint) and constraint.condition is not None
1929                 for constraint in cls._meta.constraints
1930             ):
1931                 errors.append(
1932                     checks.Warning(
1933                         '%s does not support unique constraints with '
1934                         'conditions.' % connection.display_name,
1935                         hint=(
1936                             "A constraint won't be created. Silence this "
1937                             "warning if you don't care about it."
1938                         ),
1939                         obj=cls,
1940                         id='models.W036',
1941                     )
1942                 )
1943             if not (
1944                 connection.features.supports_deferrable_unique_constraints or
1945                 'supports_deferrable_unique_constraints' in cls._meta.required_db_features
1946             ) and any(
1947                 isinstance(constraint, UniqueConstraint) and constraint.deferrable is not None
1948                 for constraint in cls._meta.constraints
1949             ):
1950                 errors.append(
1951                     checks.Warning(
1952                         '%s does not support deferrable unique constraints.'
1953                         % connection.display_name,
1954                         hint=(
1955                             "A constraint won't be created. Silence this "
1956                             "warning if you don't care about it."
1957                         ),
1958                         obj=cls,
1959                         id='models.W038',
1960                     )
1961                 )
1962             if not (
1963                 connection.features.supports_covering_indexes or
1964                 'supports_covering_indexes' in cls._meta.required_db_features
1965             ) and any(
1966                 isinstance(constraint, UniqueConstraint) and constraint.include
1967                 for constraint in cls._meta.constraints
1968             ):
1969                 errors.append(
1970                     checks.Warning(
1971                         '%s does not support unique constraints with non-key '
1972                         'columns.' % connection.display_name,
1973                         hint=(
1974                             "A constraint won't be created. Silence this "
1975                             "warning if you don't care about it."
1976                         ),
1977                         obj=cls,
1978                         id='models.W039',
1979                     )
1980                 )
1981             fields = set(chain.from_iterable(
1982                 (*constraint.fields, *constraint.include)
1983                 for constraint in cls._meta.constraints if isinstance(constraint, UniqueConstraint)
1984             ))
1985             references = set()
1986             for constraint in cls._meta.constraints:
1987                 if isinstance(constraint, UniqueConstraint):
1988                     if (
1989                         connection.features.supports_partial_indexes or
1990                         'supports_partial_indexes' not in cls._meta.required_db_features
1991                     ) and isinstance(constraint.condition, Q):
1992                         references.update(cls._get_expr_references(constraint.condition))
1993                 elif isinstance(constraint, CheckConstraint):
1994                     if (
1995                         connection.features.supports_table_check_constraints or
1996                         'supports_table_check_constraints' not in cls._meta.required_db_features
1997                     ) and isinstance(constraint.check, Q):
1998                         references.update(cls._get_expr_references(constraint.check))
1999             for field_name, *lookups in references:
2000                 # pk is an alias that won't be found by opts.get_field.
2001                 if field_name != 'pk':
2002                     fields.add(field_name)
2003                 if not lookups:
2004                     # If it has no lookups it cannot result in a JOIN.
2005                     continue
2006                 try:
2007                     if field_name == 'pk':
2008                         field = cls._meta.pk
2009                     else:
2010                         field = cls._meta.get_field(field_name)
2011                     if not field.is_relation or field.many_to_many or field.one_to_many:
2012                         continue
2013                 except FieldDoesNotExist:
2014                     continue
2015                 # JOIN must happen at the first lookup.
2016                 first_lookup = lookups[0]
2017                 if (
2018                     field.get_transform(first_lookup) is None and
2019                     field.get_lookup(first_lookup) is None
2020                 ):
2021                     errors.append(
2022                         checks.Error(
2023                             "'constraints' refers to the joined field '%s'."
2024                             % LOOKUP_SEP.join([field_name] + lookups),
2025                             obj=cls,
2026                             id='models.E041',
2027                         )
2028                     )
2029             errors.extend(cls._check_local_fields(fields, 'constraints'))
2030         return errors

</code><intended_behavior>The handling of the model's `_state`, especially the `fields_cache`, needs to be adjusted to ensure a correct copy mechanism. When a model instance is copied via `copy.copy()`, the `fields_cache` should either be deeply copied to the new instance or reset entirely. This ensures that any modifications to ForeignKey fields in the copied instance do not affect the original instance, maintaining the integrity of the cached relationships.</intended_behavior>]
2025-10-18 00:31:41.087 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-18 00:31:41.087 | INFO     | Search-only: skipping patch selection
2025-10-18 00:31:41.238 | INFO     | Task django__django-13281 completed successfully.
2025-10-18 00:31:41.238 | INFO     | No patch generated. You can try running ACR again.
