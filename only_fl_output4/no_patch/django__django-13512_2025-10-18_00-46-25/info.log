2025-10-18 00:46:25.948 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-18 00:46:29.142 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=196, output_tokens=12, cost=0.002320
2025-10-18 00:46:29.143 | INFO     | Test agent decides that the issue statement does not contain reproduction steps; skipping reproducer tracing
2025-10-18 00:46:29.147 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 00:46:37.550 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=501, output_tokens=352, cost=0.015570
2025-10-18 00:46:37.557 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 00:46:40.542 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=706, output_tokens=53, cost=0.008650
2025-10-18 00:46:40.544 | DEBUG    | Extracted a valid json.
2025-10-18 00:46:40.544 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_method(\"json.dumps\")",
        "search_code(\"JSONField\")",
        "search_code(\"class JSONField\")",
        "search_code(\"admin.py\")"
    ],
    "bug_locations": []
}
2025-10-18 00:46:40.700 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 00:46:40.701 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 00:46:57.134 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1771, output_tokens=734, cost=0.039730
2025-10-18 00:46:57.142 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 00:47:06.154 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2721, output_tokens=416, cost=0.039690
2025-10-18 00:47:06.162 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 00:47:11.179 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=770, output_tokens=188, cost=0.013340
2025-10-18 00:47:11.180 | DEBUG    | Extracted a valid json.
2025-10-18 00:47:11.186 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations":[
        {
            "file": "django/contrib/admin/utils.py", 
            "class": "", 
            "method": "", 
            "intended_behavior": "Ensure that any serialization of `JSONField` for admin purposes supports non-ASCII characters correctly. This could involve adjusting the use of `json.dumps` to include `ensure_ascii=False` and ensuring that any such change does not affect the functionality for other field types or the admin interface at large."
        }, 
        {
            "file": "django/db/models/fields/json.py", 
            "class": "", 
            "method": "", 
            "intended_behavior": "Investigate and ensure that the serialization mechanism to and from the database is Unicode-friendly and that any transformations performed before rendering in the admin interface preserve Unicode characters. Ensure compatibility across different database backends."
        }
    ]
}
2025-10-18 00:47:11.192 | DEBUG    | Bug location extracted successfully: [<file>django/contrib/admin/utils.py</file>
<class>None</class>
<method>None</method>
<code>
1 import datetime
2 import decimal
3 from collections import defaultdict
4 
5 from django.core.exceptions import FieldDoesNotExist
6 from django.db import models, router
7 from django.db.models.constants import LOOKUP_SEP
8 from django.db.models.deletion import Collector
9 from django.forms.utils import pretty_name
10 from django.urls import NoReverseMatch, reverse
11 from django.utils import formats, timezone
12 from django.utils.html import format_html
13 from django.utils.regex_helper import _lazy_re_compile
14 from django.utils.text import capfirst
15 from django.utils.translation import ngettext, override as translation_override
16 
17 QUOTE_MAP = {i: '_%02X' % i for i in b'":/_#?;@&=+$,"[]<>%\n\\'}
18 UNQUOTE_MAP = {v: chr(k) for k, v in QUOTE_MAP.items()}
19 UNQUOTE_RE = _lazy_re_compile('_(?:%s)' % '|'.join([x[1:] for x in UNQUOTE_MAP]))
20 
21 
22 class FieldIsAForeignKeyColumnName(Exception):
23     """A field is a foreign key attname, i.e. <FK>_id."""
24     pass
25 
26 
27 def lookup_needs_distinct(opts, lookup_path):
28     """
29     Return True if 'distinct()' should be used to query the given lookup path.
30     """
31     lookup_fields = lookup_path.split(LOOKUP_SEP)
32     # Go through the fields (following all relations) and look for an m2m.
33     for field_name in lookup_fields:
34         if field_name == 'pk':
35             field_name = opts.pk.name
36         try:
37             field = opts.get_field(field_name)
38         except FieldDoesNotExist:
39             # Ignore query lookups.
40             continue
41         else:
42             if hasattr(field, 'get_path_info'):
43                 # This field is a relation; update opts to follow the relation.
44                 path_info = field.get_path_info()
45                 opts = path_info[-1].to_opts
46                 if any(path.m2m for path in path_info):
47                     # This field is a m2m relation so distinct must be called.
48                     return True
49     return False
50 
51 
52 def prepare_lookup_value(key, value):
53     """
54     Return a lookup value prepared to be used in queryset filtering.
55     """
56     # if key ends with __in, split parameter into separate values
57     if key.endswith('__in'):
58         value = value.split(',')
59     # if key ends with __isnull, special case '' and the string literals 'false' and '0'
60     elif key.endswith('__isnull'):
61         value = value.lower() not in ('', 'false', '0')
62     return value
63 
64 
65 def quote(s):
66     """
67     Ensure that primary key values do not confuse the admin URLs by escaping
68     any '/', '_' and ':' and similarly problematic characters.
69     Similar to urllib.parse.quote(), except that the quoting is slightly
70     different so that it doesn't get automatically unquoted by the Web browser.
71     """
72     return s.translate(QUOTE_MAP) if isinstance(s, str) else s
73 
74 
75 def unquote(s):
76     """Undo the effects of quote()."""
77     return UNQUOTE_RE.sub(lambda m: UNQUOTE_MAP[m[0]], s)
78 
79 
80 def flatten(fields):
81     """
82     Return a list which is a single level of flattening of the original list.
83     """
84     flat = []
85     for field in fields:
86         if isinstance(field, (list, tuple)):
87             flat.extend(field)
88         else:
89             flat.append(field)
90     return flat
91 
92 
93 def flatten_fieldsets(fieldsets):
94     """Return a list of field names from an admin fieldsets structure."""
95     field_names = []
96     for name, opts in fieldsets:
97         field_names.extend(
98             flatten(opts['fields'])
99         )
100     return field_names
101 
102 
103 def get_deleted_objects(objs, request, admin_site):
104     """
105     Find all objects related to ``objs`` that should also be deleted. ``objs``
106     must be a homogeneous iterable of objects (e.g. a QuerySet).
107 
108     Return a nested list of strings suitable for display in the
109     template with the ``unordered_list`` filter.
110     """
111     try:
112         obj = objs[0]
113     except IndexError:
114         return [], {}, set(), []
115     else:
116         using = router.db_for_write(obj._meta.model)
117     collector = NestedObjects(using=using)
118     collector.collect(objs)
119     perms_needed = set()
120 
121     def format_callback(obj):
122         model = obj.__class__
123         has_admin = model in admin_site._registry
124         opts = obj._meta
125 
126         no_edit_link = '%s: %s' % (capfirst(opts.verbose_name), obj)
127 
128         if has_admin:
129             if not admin_site._registry[model].has_delete_permission(request, obj):
130                 perms_needed.add(opts.verbose_name)
131             try:
132                 admin_url = reverse('%s:%s_%s_change'
133                                     % (admin_site.name,
134                                        opts.app_label,
135                                        opts.model_name),
136                                     None, (quote(obj.pk),))
137             except NoReverseMatch:
138                 # Change url doesn't exist -- don't display link to edit
139                 return no_edit_link
140 
141             # Display a link to the admin page.
142             return format_html('{}: <a href="{}">{}</a>',
143                                capfirst(opts.verbose_name),
144                                admin_url,
145                                obj)
146         else:
147             # Don't display link to edit, because it either has no
148             # admin or is edited inline.
149             return no_edit_link
150 
151     to_delete = collector.nested(format_callback)
152 
153     protected = [format_callback(obj) for obj in collector.protected]
154     model_count = {model._meta.verbose_name_plural: len(objs) for model, objs in collector.model_objs.items()}
155 
156     return to_delete, model_count, perms_needed, protected
157 
158 
159 class NestedObjects(Collector):
160     def __init__(self, *args, **kwargs):
161         super().__init__(*args, **kwargs)
162         self.edges = {}  # {from_instance: [to_instances]}
163         self.protected = set()
164         self.model_objs = defaultdict(set)
165 
166     def add_edge(self, source, target):
167         self.edges.setdefault(source, []).append(target)
168 
169     def collect(self, objs, source=None, source_attr=None, **kwargs):
170         for obj in objs:
171             if source_attr and not source_attr.endswith('+'):
172                 related_name = source_attr % {
173                     'class': source._meta.model_name,
174                     'app_label': source._meta.app_label,
175                 }
176                 self.add_edge(getattr(obj, related_name), obj)
177             else:
178                 self.add_edge(None, obj)
179             self.model_objs[obj._meta.model].add(obj)
180         try:
181             return super().collect(objs, source_attr=source_attr, **kwargs)
182         except models.ProtectedError as e:
183             self.protected.update(e.protected_objects)
184         except models.RestrictedError as e:
185             self.protected.update(e.restricted_objects)
186 
187     def related_objects(self, related_model, related_fields, objs):
188         qs = super().related_objects(related_model, related_fields, objs)
189         return qs.select_related(*[related_field.name for related_field in related_fields])
190 
191     def _nested(self, obj, seen, format_callback):
192         if obj in seen:
193             return []
194         seen.add(obj)
195         children = []
196         for child in self.edges.get(obj, ()):
197             children.extend(self._nested(child, seen, format_callback))
198         if format_callback:
199             ret = [format_callback(obj)]
200         else:
201             ret = [obj]
202         if children:
203             ret.append(children)
204         return ret
205 
206     def nested(self, format_callback=None):
207         """
208         Return the graph as a nested list.
209         """
210         seen = set()
211         roots = []
212         for root in self.edges.get(None, ()):
213             roots.extend(self._nested(root, seen, format_callback))
214         return roots
215 
216     def can_fast_delete(self, *args, **kwargs):
217         """
218         We always want to load the objects into memory so that we can display
219         them to the user in confirm page.
220         """
221         return False
222 
223 
224 def model_format_dict(obj):
225     """
226     Return a `dict` with keys 'verbose_name' and 'verbose_name_plural',
227     typically for use with string formatting.
228 
229     `obj` may be a `Model` instance, `Model` subclass, or `QuerySet` instance.
230     """
231     if isinstance(obj, (models.Model, models.base.ModelBase)):
232         opts = obj._meta
233     elif isinstance(obj, models.query.QuerySet):
234         opts = obj.model._meta
235     else:
236         opts = obj
237     return {
238         'verbose_name': opts.verbose_name,
239         'verbose_name_plural': opts.verbose_name_plural,
240     }
241 
242 
243 def model_ngettext(obj, n=None):
244     """
245     Return the appropriate `verbose_name` or `verbose_name_plural` value for
246     `obj` depending on the count `n`.
247 
248     `obj` may be a `Model` instance, `Model` subclass, or `QuerySet` instance.
249     If `obj` is a `QuerySet` instance, `n` is optional and the length of the
250     `QuerySet` is used.
251     """
252     if isinstance(obj, models.query.QuerySet):
253         if n is None:
254             n = obj.count()
255         obj = obj.model
256     d = model_format_dict(obj)
257     singular, plural = d["verbose_name"], d["verbose_name_plural"]
258     return ngettext(singular, plural, n or 0)
259 
260 
261 def lookup_field(name, obj, model_admin=None):
262     opts = obj._meta
263     try:
264         f = _get_non_gfk_field(opts, name)
265     except (FieldDoesNotExist, FieldIsAForeignKeyColumnName):
266         # For non-field values, the value is either a method, property or
267         # returned via a callable.
268         if callable(name):
269             attr = name
270             value = attr(obj)
271         elif hasattr(model_admin, name) and name != '__str__':
272             attr = getattr(model_admin, name)
273             value = attr(obj)
274         else:
275             attr = getattr(obj, name)
276             if callable(attr):
277                 value = attr()
278             else:
279                 value = attr
280         f = None
281     else:
282         attr = None
283         value = getattr(obj, name)
284     return f, attr, value
285 
286 
287 def _get_non_gfk_field(opts, name):
288     """
289     For historical reasons, the admin app relies on GenericForeignKeys as being
290     "not found" by get_field(). This could likely be cleaned up.
291 
292     Reverse relations should also be excluded as these aren't attributes of the
293     model (rather something like `foo_set`).
294     """
295     field = opts.get_field(name)
296     if (field.is_relation and
297             # Generic foreign keys OR reverse relations
298             ((field.many_to_one and not field.related_model) or field.one_to_many)):
299         raise FieldDoesNotExist()
300 
301     # Avoid coercing <FK>_id fields to FK
302     if field.is_relation and not field.many_to_many and hasattr(field, 'attname') and field.attname == name:
303         raise FieldIsAForeignKeyColumnName()
304 
305     return field
306 
307 
308 def label_for_field(name, model, model_admin=None, return_attr=False, form=None):
309     """
310     Return a sensible label for a field name. The name can be a callable,
311     property (but not created with @property decorator), or the name of an
312     object's attribute, as well as a model field. If return_attr is True, also
313     return the resolved attribute (which could be a callable). This will be
314     None if (and only if) the name refers to a field.
315     """
316     attr = None
317     try:
318         field = _get_non_gfk_field(model._meta, name)
319         try:
320             label = field.verbose_name
321         except AttributeError:
322             # field is likely a ForeignObjectRel
323             label = field.related_model._meta.verbose_name
324     except FieldDoesNotExist:
325         if name == "__str__":
326             label = str(model._meta.verbose_name)
327             attr = str
328         else:
329             if callable(name):
330                 attr = name
331             elif hasattr(model_admin, name):
332                 attr = getattr(model_admin, name)
333             elif hasattr(model, name):
334                 attr = getattr(model, name)
335             elif form and name in form.fields:
336                 attr = form.fields[name]
337             else:
338                 message = "Unable to lookup '%s' on %s" % (name, model._meta.object_name)
339                 if model_admin:
340                     message += " or %s" % model_admin.__class__.__name__
341                 if form:
342                     message += " or %s" % form.__class__.__name__
343                 raise AttributeError(message)
344 
345             if hasattr(attr, "short_description"):
346                 label = attr.short_description
347             elif (isinstance(attr, property) and
348                   hasattr(attr, "fget") and
349                   hasattr(attr.fget, "short_description")):
350                 label = attr.fget.short_description
351             elif callable(attr):
352                 if attr.__name__ == "<lambda>":
353                     label = "--"
354                 else:
355                     label = pretty_name(attr.__name__)
356             else:
357                 label = pretty_name(name)
358     except FieldIsAForeignKeyColumnName:
359         label = pretty_name(name)
360         attr = name
361 
362     if return_attr:
363         return (label, attr)
364     else:
365         return label
366 
367 
368 def help_text_for_field(name, model):
369     help_text = ""
370     try:
371         field = _get_non_gfk_field(model._meta, name)
372     except (FieldDoesNotExist, FieldIsAForeignKeyColumnName):
373         pass
374     else:
375         if hasattr(field, 'help_text'):
376             help_text = field.help_text
377     return help_text
378 
379 
380 def display_for_field(value, field, empty_value_display):
381     from django.contrib.admin.templatetags.admin_list import _boolean_icon
382 
383     if getattr(field, 'flatchoices', None):
384         return dict(field.flatchoices).get(value, empty_value_display)
385     # BooleanField needs special-case null-handling, so it comes before the
386     # general null test.
387     elif isinstance(field, models.BooleanField):
388         return _boolean_icon(value)
389     elif value is None:
390         return empty_value_display
391     elif isinstance(field, models.DateTimeField):
392         return formats.localize(timezone.template_localtime(value))
393     elif isinstance(field, (models.DateField, models.TimeField)):
394         return formats.localize(value)
395     elif isinstance(field, models.DecimalField):
396         return formats.number_format(value, field.decimal_places)
397     elif isinstance(field, (models.IntegerField, models.FloatField)):
398         return formats.number_format(value)
399     elif isinstance(field, models.FileField) and value:
400         return format_html('<a href="{}">{}</a>', value.url, value)
401     elif isinstance(field, models.JSONField) and value:
402         try:
403             return field.get_prep_value(value)
404         except TypeError:
405             return display_for_value(value, empty_value_display)
406     else:
407         return display_for_value(value, empty_value_display)
408 
409 
410 def display_for_value(value, empty_value_display, boolean=False):
411     from django.contrib.admin.templatetags.admin_list import _boolean_icon
412 
413     if boolean:
414         return _boolean_icon(value)
415     elif value is None:
416         return empty_value_display
417     elif isinstance(value, bool):
418         return str(value)
419     elif isinstance(value, datetime.datetime):
420         return formats.localize(timezone.template_localtime(value))
421     elif isinstance(value, (datetime.date, datetime.time)):
422         return formats.localize(value)
423     elif isinstance(value, (int, decimal.Decimal, float)):
424         return formats.number_format(value)
425     elif isinstance(value, (list, tuple)):
426         return ', '.join(str(v) for v in value)
427     else:
428         return str(value)
429 
430 
431 class NotRelationField(Exception):
432     pass
433 
434 
435 def get_model_from_relation(field):
436     if hasattr(field, 'get_path_info'):
437         return field.get_path_info()[-1].to_opts.model
438     else:
439         raise NotRelationField
440 
441 
442 def reverse_field_path(model, path):
443     """ Create a reversed field path.
444 
445     E.g. Given (Order, "user__groups"),
446     return (Group, "user__order").
447 
448     Final field must be a related model, not a data field.
449     """
450     reversed_path = []
451     parent = model
452     pieces = path.split(LOOKUP_SEP)
453     for piece in pieces:
454         field = parent._meta.get_field(piece)
455         # skip trailing data field if extant:
456         if len(reversed_path) == len(pieces) - 1:  # final iteration
457             try:
458                 get_model_from_relation(field)
459             except NotRelationField:
460                 break
461 
462         # Field should point to another model
463         if field.is_relation and not (field.auto_created and not field.concrete):
464             related_name = field.related_query_name()
465             parent = field.remote_field.model
466         else:
467             related_name = field.field.name
468             parent = field.related_model
469         reversed_path.insert(0, related_name)
470     return (parent, LOOKUP_SEP.join(reversed_path))
471 
472 
473 def get_fields_from_path(model, path):
474     """ Return list of Fields given path relative to model.
475 
476     e.g. (ModelX, "user__groups__name") -> [
477         <django.db.models.fields.related.ForeignKey object at 0x...>,
478         <django.db.models.fields.related.ManyToManyField object at 0x...>,
479         <django.db.models.fields.CharField object at 0x...>,
480     ]
481     """
482     pieces = path.split(LOOKUP_SEP)
483     fields = []
484     for piece in pieces:
485         if fields:
486             parent = get_model_from_relation(fields[-1])
487         else:
488             parent = model
489         fields.append(parent._meta.get_field(piece))
490     return fields
491 
492 
493 def construct_change_message(form, formsets, add):
494     """
495     Construct a JSON structure describing changes from a changed object.
496     Translations are deactivated so that strings are stored untranslated.
497     Translation happens later on LogEntry access.
498     """
499     # Evaluating `form.changed_data` prior to disabling translations is required
500     # to avoid fields affected by localization from being included incorrectly,
501     # e.g. where date formats differ such as MM/DD/YYYY vs DD/MM/YYYY.
502     changed_data = form.changed_data
503     with translation_override(None):
504         # Deactivate translations while fetching verbose_name for form
505         # field labels and using `field_name`, if verbose_name is not provided.
506         # Translations will happen later on LogEntry access.
507         changed_field_labels = _get_changed_field_labels_from_form(form, changed_data)
508 
509     change_message = []
510     if add:
511         change_message.append({'added': {}})
512     elif form.changed_data:
513         change_message.append({'changed': {'fields': changed_field_labels}})
514     if formsets:
515         with translation_override(None):
516             for formset in formsets:
517                 for added_object in formset.new_objects:
518                     change_message.append({
519                         'added': {
520                             'name': str(added_object._meta.verbose_name),
521                             'object': str(added_object),
522                         }
523                     })
524                 for changed_object, changed_fields in formset.changed_objects:
525                     change_message.append({
526                         'changed': {
527                             'name': str(changed_object._meta.verbose_name),
528                             'object': str(changed_object),
529                             'fields': _get_changed_field_labels_from_form(formset.forms[0], changed_fields),
530                         }
531                     })
532                 for deleted_object in formset.deleted_objects:
533                     change_message.append({
534                         'deleted': {
535                             'name': str(deleted_object._meta.verbose_name),
536                             'object': str(deleted_object),
537                         }
538                     })
539     return change_message
540 
541 
542 def _get_changed_field_labels_from_form(form, changed_data):
543     changed_field_labels = []
544     for field_name in changed_data:
545         try:
546             verbose_field_name = form.fields[field_name].label or field_name
547         except KeyError:
548             verbose_field_name = field_name
549         changed_field_labels.append(str(verbose_field_name))
550     return changed_field_labels

</code><intended_behavior>Ensure that any serialization of `JSONField` for admin purposes supports non-ASCII characters correctly. This could involve adjusting the use of `json.dumps` to include `ensure_ascii=False` and ensuring that any such change does not affect the functionality for other field types or the admin interface at large.</intended_behavior>, <file>django/db/models/fields/json.py</file>
<class>None</class>
<method>None</method>
<code>
1 import json
2 
3 from django import forms
4 from django.core import checks, exceptions
5 from django.db import NotSupportedError, connections, router
6 from django.db.models import lookups
7 from django.db.models.lookups import PostgresOperatorLookup, Transform
8 from django.utils.translation import gettext_lazy as _
9 
10 from . import Field
11 from .mixins import CheckFieldDefaultMixin
12 
13 __all__ = ['JSONField']
14 
15 
16 class JSONField(CheckFieldDefaultMixin, Field):
17     empty_strings_allowed = False
18     description = _('A JSON object')
19     default_error_messages = {
20         'invalid': _('Value must be valid JSON.'),
21     }
22     _default_hint = ('dict', '{}')
23 
24     def __init__(
25         self, verbose_name=None, name=None, encoder=None, decoder=None,
26         **kwargs,
27     ):
28         if encoder and not callable(encoder):
29             raise ValueError('The encoder parameter must be a callable object.')
30         if decoder and not callable(decoder):
31             raise ValueError('The decoder parameter must be a callable object.')
32         self.encoder = encoder
33         self.decoder = decoder
34         super().__init__(verbose_name, name, **kwargs)
35 
36     def check(self, **kwargs):
37         errors = super().check(**kwargs)
38         databases = kwargs.get('databases') or []
39         errors.extend(self._check_supported(databases))
40         return errors
41 
42     def _check_supported(self, databases):
43         errors = []
44         for db in databases:
45             if not router.allow_migrate_model(db, self.model):
46                 continue
47             connection = connections[db]
48             if not (
49                 'supports_json_field' in self.model._meta.required_db_features or
50                 connection.features.supports_json_field
51             ):
52                 errors.append(
53                     checks.Error(
54                         '%s does not support JSONFields.'
55                         % connection.display_name,
56                         obj=self.model,
57                         id='fields.E180',
58                     )
59                 )
60         return errors
61 
62     def deconstruct(self):
63         name, path, args, kwargs = super().deconstruct()
64         if self.encoder is not None:
65             kwargs['encoder'] = self.encoder
66         if self.decoder is not None:
67             kwargs['decoder'] = self.decoder
68         return name, path, args, kwargs
69 
70     def from_db_value(self, value, expression, connection):
71         if value is None:
72             return value
73         try:
74             return json.loads(value, cls=self.decoder)
75         except json.JSONDecodeError:
76             return value
77 
78     def get_internal_type(self):
79         return 'JSONField'
80 
81     def get_prep_value(self, value):
82         if value is None:
83             return value
84         return json.dumps(value, cls=self.encoder)
85 
86     def get_transform(self, name):
87         transform = super().get_transform(name)
88         if transform:
89             return transform
90         return KeyTransformFactory(name)
91 
92     def validate(self, value, model_instance):
93         super().validate(value, model_instance)
94         try:
95             json.dumps(value, cls=self.encoder)
96         except TypeError:
97             raise exceptions.ValidationError(
98                 self.error_messages['invalid'],
99                 code='invalid',
100                 params={'value': value},
101             )
102 
103     def value_to_string(self, obj):
104         return self.value_from_object(obj)
105 
106     def formfield(self, **kwargs):
107         return super().formfield(**{
108             'form_class': forms.JSONField,
109             'encoder': self.encoder,
110             'decoder': self.decoder,
111             **kwargs,
112         })
113 
114 
115 def compile_json_path(key_transforms, include_root=True):
116     path = ['$'] if include_root else []
117     for key_transform in key_transforms:
118         try:
119             num = int(key_transform)
120         except ValueError:  # non-integer
121             path.append('.')
122             path.append(json.dumps(key_transform))
123         else:
124             path.append('[%s]' % num)
125     return ''.join(path)
126 
127 
128 class DataContains(PostgresOperatorLookup):
129     lookup_name = 'contains'
130     postgres_operator = '@>'
131 
132     def as_sql(self, compiler, connection):
133         if not connection.features.supports_json_field_contains:
134             raise NotSupportedError(
135                 'contains lookup is not supported on this database backend.'
136             )
137         lhs, lhs_params = self.process_lhs(compiler, connection)
138         rhs, rhs_params = self.process_rhs(compiler, connection)
139         params = tuple(lhs_params) + tuple(rhs_params)
140         return 'JSON_CONTAINS(%s, %s)' % (lhs, rhs), params
141 
142 
143 class ContainedBy(PostgresOperatorLookup):
144     lookup_name = 'contained_by'
145     postgres_operator = '<@'
146 
147     def as_sql(self, compiler, connection):
148         if not connection.features.supports_json_field_contains:
149             raise NotSupportedError(
150                 'contained_by lookup is not supported on this database backend.'
151             )
152         lhs, lhs_params = self.process_lhs(compiler, connection)
153         rhs, rhs_params = self.process_rhs(compiler, connection)
154         params = tuple(rhs_params) + tuple(lhs_params)
155         return 'JSON_CONTAINS(%s, %s)' % (rhs, lhs), params
156 
157 
158 class HasKeyLookup(PostgresOperatorLookup):
159     logical_operator = None
160 
161     def as_sql(self, compiler, connection, template=None):
162         # Process JSON path from the left-hand side.
163         if isinstance(self.lhs, KeyTransform):
164             lhs, lhs_params, lhs_key_transforms = self.lhs.preprocess_lhs(compiler, connection)
165             lhs_json_path = compile_json_path(lhs_key_transforms)
166         else:
167             lhs, lhs_params = self.process_lhs(compiler, connection)
168             lhs_json_path = '$'
169         sql = template % lhs
170         # Process JSON path from the right-hand side.
171         rhs = self.rhs
172         rhs_params = []
173         if not isinstance(rhs, (list, tuple)):
174             rhs = [rhs]
175         for key in rhs:
176             if isinstance(key, KeyTransform):
177                 *_, rhs_key_transforms = key.preprocess_lhs(compiler, connection)
178             else:
179                 rhs_key_transforms = [key]
180             rhs_params.append('%s%s' % (
181                 lhs_json_path,
182                 compile_json_path(rhs_key_transforms, include_root=False),
183             ))
184         # Add condition for each key.
185         if self.logical_operator:
186             sql = '(%s)' % self.logical_operator.join([sql] * len(rhs_params))
187         return sql, tuple(lhs_params) + tuple(rhs_params)
188 
189     def as_mysql(self, compiler, connection):
190         return self.as_sql(compiler, connection, template="JSON_CONTAINS_PATH(%s, 'one', %%s)")
191 
192     def as_oracle(self, compiler, connection):
193         sql, params = self.as_sql(compiler, connection, template="JSON_EXISTS(%s, '%%s')")
194         # Add paths directly into SQL because path expressions cannot be passed
195         # as bind variables on Oracle.
196         return sql % tuple(params), []
197 
198     def as_postgresql(self, compiler, connection):
199         if isinstance(self.rhs, KeyTransform):
200             *_, rhs_key_transforms = self.rhs.preprocess_lhs(compiler, connection)
201             for key in rhs_key_transforms[:-1]:
202                 self.lhs = KeyTransform(key, self.lhs)
203             self.rhs = rhs_key_transforms[-1]
204         return super().as_postgresql(compiler, connection)
205 
206     def as_sqlite(self, compiler, connection):
207         return self.as_sql(compiler, connection, template='JSON_TYPE(%s, %%s) IS NOT NULL')
208 
209 
210 class HasKey(HasKeyLookup):
211     lookup_name = 'has_key'
212     postgres_operator = '?'
213     prepare_rhs = False
214 
215 
216 class HasKeys(HasKeyLookup):
217     lookup_name = 'has_keys'
218     postgres_operator = '?&'
219     logical_operator = ' AND '
220 
221     def get_prep_lookup(self):
222         return [str(item) for item in self.rhs]
223 
224 
225 class HasAnyKeys(HasKeys):
226     lookup_name = 'has_any_keys'
227     postgres_operator = '?|'
228     logical_operator = ' OR '
229 
230 
231 class JSONExact(lookups.Exact):
232     can_use_none_as_rhs = True
233 
234     def process_lhs(self, compiler, connection):
235         lhs, lhs_params = super().process_lhs(compiler, connection)
236         if connection.vendor == 'sqlite':
237             rhs, rhs_params = super().process_rhs(compiler, connection)
238             if rhs == '%s' and rhs_params == [None]:
239                 # Use JSON_TYPE instead of JSON_EXTRACT for NULLs.
240                 lhs = "JSON_TYPE(%s, '$')" % lhs
241         return lhs, lhs_params
242 
243     def process_rhs(self, compiler, connection):
244         rhs, rhs_params = super().process_rhs(compiler, connection)
245         # Treat None lookup values as null.
246         if rhs == '%s' and rhs_params == [None]:
247             rhs_params = ['null']
248         if connection.vendor == 'mysql':
249             func = ["JSON_EXTRACT(%s, '$')"] * len(rhs_params)
250             rhs = rhs % tuple(func)
251         return rhs, rhs_params
252 
253 
254 JSONField.register_lookup(DataContains)
255 JSONField.register_lookup(ContainedBy)
256 JSONField.register_lookup(HasKey)
257 JSONField.register_lookup(HasKeys)
258 JSONField.register_lookup(HasAnyKeys)
259 JSONField.register_lookup(JSONExact)
260 
261 
262 class KeyTransform(Transform):
263     postgres_operator = '->'
264     postgres_nested_operator = '#>'
265 
266     def __init__(self, key_name, *args, **kwargs):
267         super().__init__(*args, **kwargs)
268         self.key_name = str(key_name)
269 
270     def preprocess_lhs(self, compiler, connection, lhs_only=False):
271         if not lhs_only:
272             key_transforms = [self.key_name]
273         previous = self.lhs
274         while isinstance(previous, KeyTransform):
275             if not lhs_only:
276                 key_transforms.insert(0, previous.key_name)
277             previous = previous.lhs
278         lhs, params = compiler.compile(previous)
279         if connection.vendor == 'oracle':
280             # Escape string-formatting.
281             key_transforms = [key.replace('%', '%%') for key in key_transforms]
282         return (lhs, params, key_transforms) if not lhs_only else (lhs, params)
283 
284     def as_mysql(self, compiler, connection):
285         lhs, params, key_transforms = self.preprocess_lhs(compiler, connection)
286         json_path = compile_json_path(key_transforms)
287         return 'JSON_EXTRACT(%s, %%s)' % lhs, tuple(params) + (json_path,)
288 
289     def as_oracle(self, compiler, connection):
290         lhs, params, key_transforms = self.preprocess_lhs(compiler, connection)
291         json_path = compile_json_path(key_transforms)
292         return (
293             "COALESCE(JSON_QUERY(%s, '%s'), JSON_VALUE(%s, '%s'))" %
294             ((lhs, json_path) * 2)
295         ), tuple(params) * 2
296 
297     def as_postgresql(self, compiler, connection):
298         lhs, params, key_transforms = self.preprocess_lhs(compiler, connection)
299         if len(key_transforms) > 1:
300             return '(%s %s %%s)' % (lhs, self.postgres_nested_operator), params + [key_transforms]
301         try:
302             lookup = int(self.key_name)
303         except ValueError:
304             lookup = self.key_name
305         return '(%s %s %%s)' % (lhs, self.postgres_operator), tuple(params) + (lookup,)
306 
307     def as_sqlite(self, compiler, connection):
308         lhs, params, key_transforms = self.preprocess_lhs(compiler, connection)
309         json_path = compile_json_path(key_transforms)
310         return 'JSON_EXTRACT(%s, %%s)' % lhs, tuple(params) + (json_path,)
311 
312 
313 class KeyTextTransform(KeyTransform):
314     postgres_operator = '->>'
315     postgres_nested_operator = '#>>'
316 
317 
318 class KeyTransformTextLookupMixin:
319     """
320     Mixin for combining with a lookup expecting a text lhs from a JSONField
321     key lookup. On PostgreSQL, make use of the ->> operator instead of casting
322     key values to text and performing the lookup on the resulting
323     representation.
324     """
325     def __init__(self, key_transform, *args, **kwargs):
326         if not isinstance(key_transform, KeyTransform):
327             raise TypeError(
328                 'Transform should be an instance of KeyTransform in order to '
329                 'use this lookup.'
330             )
331         key_text_transform = KeyTextTransform(
332             key_transform.key_name, *key_transform.source_expressions,
333             **key_transform.extra,
334         )
335         super().__init__(key_text_transform, *args, **kwargs)
336 
337 
338 class CaseInsensitiveMixin:
339     """
340     Mixin to allow case-insensitive comparison of JSON values on MySQL.
341     MySQL handles strings used in JSON context using the utf8mb4_bin collation.
342     Because utf8mb4_bin is a binary collation, comparison of JSON values is
343     case-sensitive.
344     """
345     def process_lhs(self, compiler, connection):
346         lhs, lhs_params = super().process_lhs(compiler, connection)
347         if connection.vendor == 'mysql':
348             return 'LOWER(%s)' % lhs, lhs_params
349         return lhs, lhs_params
350 
351     def process_rhs(self, compiler, connection):
352         rhs, rhs_params = super().process_rhs(compiler, connection)
353         if connection.vendor == 'mysql':
354             return 'LOWER(%s)' % rhs, rhs_params
355         return rhs, rhs_params
356 
357 
358 class KeyTransformIsNull(lookups.IsNull):
359     # key__isnull=False is the same as has_key='key'
360     def as_oracle(self, compiler, connection):
361         if not self.rhs:
362             return HasKey(self.lhs.lhs, self.lhs.key_name).as_oracle(compiler, connection)
363         return super().as_sql(compiler, connection)
364 
365     def as_sqlite(self, compiler, connection):
366         if not self.rhs:
367             return HasKey(self.lhs.lhs, self.lhs.key_name).as_sqlite(compiler, connection)
368         return super().as_sql(compiler, connection)
369 
370 
371 class KeyTransformIn(lookups.In):
372     def process_rhs(self, compiler, connection):
373         rhs, rhs_params = super().process_rhs(compiler, connection)
374         if not connection.features.has_native_json_field:
375             func = ()
376             if connection.vendor == 'oracle':
377                 func = []
378                 for value in rhs_params:
379                     value = json.loads(value)
380                     function = 'JSON_QUERY' if isinstance(value, (list, dict)) else 'JSON_VALUE'
381                     func.append("%s('%s', '$.value')" % (
382                         function,
383                         json.dumps({'value': value}),
384                     ))
385                 func = tuple(func)
386                 rhs_params = ()
387             elif connection.vendor == 'mysql' and connection.mysql_is_mariadb:
388                 func = ("JSON_UNQUOTE(JSON_EXTRACT(%s, '$'))",) * len(rhs_params)
389             elif connection.vendor in {'sqlite', 'mysql'}:
390                 func = ("JSON_EXTRACT(%s, '$')",) * len(rhs_params)
391             rhs = rhs % func
392         return rhs, rhs_params
393 
394 
395 class KeyTransformExact(JSONExact):
396     def process_lhs(self, compiler, connection):
397         lhs, lhs_params = super().process_lhs(compiler, connection)
398         if connection.vendor == 'sqlite':
399             rhs, rhs_params = super().process_rhs(compiler, connection)
400             if rhs == '%s' and rhs_params == ['null']:
401                 lhs, _ = self.lhs.preprocess_lhs(compiler, connection, lhs_only=True)
402                 lhs = 'JSON_TYPE(%s, %%s)' % lhs
403         return lhs, lhs_params
404 
405     def process_rhs(self, compiler, connection):
406         if isinstance(self.rhs, KeyTransform):
407             return super(lookups.Exact, self).process_rhs(compiler, connection)
408         rhs, rhs_params = super().process_rhs(compiler, connection)
409         if connection.vendor == 'oracle':
410             func = []
411             for value in rhs_params:
412                 value = json.loads(value)
413                 function = 'JSON_QUERY' if isinstance(value, (list, dict)) else 'JSON_VALUE'
414                 func.append("%s('%s', '$.value')" % (
415                     function,
416                     json.dumps({'value': value}),
417                 ))
418             rhs = rhs % tuple(func)
419             rhs_params = []
420         elif connection.vendor == 'sqlite':
421             func = ["JSON_EXTRACT(%s, '$')" if value != 'null' else '%s' for value in rhs_params]
422             rhs = rhs % tuple(func)
423         return rhs, rhs_params
424 
425     def as_oracle(self, compiler, connection):
426         rhs, rhs_params = super().process_rhs(compiler, connection)
427         if rhs_params == ['null']:
428             # Field has key and it's NULL.
429             has_key_expr = HasKey(self.lhs.lhs, self.lhs.key_name)
430             has_key_sql, has_key_params = has_key_expr.as_oracle(compiler, connection)
431             is_null_expr = self.lhs.get_lookup('isnull')(self.lhs, True)
432             is_null_sql, is_null_params = is_null_expr.as_sql(compiler, connection)
433             return (
434                 '%s AND %s' % (has_key_sql, is_null_sql),
435                 tuple(has_key_params) + tuple(is_null_params),
436             )
437         return super().as_sql(compiler, connection)
438 
439 
440 class KeyTransformIExact(CaseInsensitiveMixin, KeyTransformTextLookupMixin, lookups.IExact):
441     pass
442 
443 
444 class KeyTransformIContains(CaseInsensitiveMixin, KeyTransformTextLookupMixin, lookups.IContains):
445     pass
446 
447 
448 class KeyTransformStartsWith(KeyTransformTextLookupMixin, lookups.StartsWith):
449     pass
450 
451 
452 class KeyTransformIStartsWith(CaseInsensitiveMixin, KeyTransformTextLookupMixin, lookups.IStartsWith):
453     pass
454 
455 
456 class KeyTransformEndsWith(KeyTransformTextLookupMixin, lookups.EndsWith):
457     pass
458 
459 
460 class KeyTransformIEndsWith(CaseInsensitiveMixin, KeyTransformTextLookupMixin, lookups.IEndsWith):
461     pass
462 
463 
464 class KeyTransformRegex(KeyTransformTextLookupMixin, lookups.Regex):
465     pass
466 
467 
468 class KeyTransformIRegex(CaseInsensitiveMixin, KeyTransformTextLookupMixin, lookups.IRegex):
469     pass
470 
471 
472 class KeyTransformNumericLookupMixin:
473     def process_rhs(self, compiler, connection):
474         rhs, rhs_params = super().process_rhs(compiler, connection)
475         if not connection.features.has_native_json_field:
476             rhs_params = [json.loads(value) for value in rhs_params]
477         return rhs, rhs_params
478 
479 
480 class KeyTransformLt(KeyTransformNumericLookupMixin, lookups.LessThan):
481     pass
482 
483 
484 class KeyTransformLte(KeyTransformNumericLookupMixin, lookups.LessThanOrEqual):
485     pass
486 
487 
488 class KeyTransformGt(KeyTransformNumericLookupMixin, lookups.GreaterThan):
489     pass
490 
491 
492 class KeyTransformGte(KeyTransformNumericLookupMixin, lookups.GreaterThanOrEqual):
493     pass
494 
495 
496 KeyTransform.register_lookup(KeyTransformIn)
497 KeyTransform.register_lookup(KeyTransformExact)
498 KeyTransform.register_lookup(KeyTransformIExact)
499 KeyTransform.register_lookup(KeyTransformIsNull)
500 KeyTransform.register_lookup(KeyTransformIContains)
501 KeyTransform.register_lookup(KeyTransformStartsWith)
502 KeyTransform.register_lookup(KeyTransformIStartsWith)
503 KeyTransform.register_lookup(KeyTransformEndsWith)
504 KeyTransform.register_lookup(KeyTransformIEndsWith)
505 KeyTransform.register_lookup(KeyTransformRegex)
506 KeyTransform.register_lookup(KeyTransformIRegex)
507 
508 KeyTransform.register_lookup(KeyTransformLt)
509 KeyTransform.register_lookup(KeyTransformLte)
510 KeyTransform.register_lookup(KeyTransformGt)
511 KeyTransform.register_lookup(KeyTransformGte)
512 
513 
514 class KeyTransformFactory:
515 
516     def __init__(self, key_name):
517         self.key_name = key_name
518 
519     def __call__(self, *args, **kwargs):
520         return KeyTransform(self.key_name, *args, **kwargs)

</code><intended_behavior>Investigate and ensure that the serialization mechanism to and from the database is Unicode-friendly and that any transformations performed before rendering in the admin interface preserve Unicode characters. Ensure compatibility across different database backends.</intended_behavior>]
2025-10-18 00:47:11.192 | INFO     | Search completed. Bug locations: [<file>django/contrib/admin/utils.py</file>
<class>None</class>
<method>None</method>
<code>
1 import datetime
2 import decimal
3 from collections import defaultdict
4 
5 from django.core.exceptions import FieldDoesNotExist
6 from django.db import models, router
7 from django.db.models.constants import LOOKUP_SEP
8 from django.db.models.deletion import Collector
9 from django.forms.utils import pretty_name
10 from django.urls import NoReverseMatch, reverse
11 from django.utils import formats, timezone
12 from django.utils.html import format_html
13 from django.utils.regex_helper import _lazy_re_compile
14 from django.utils.text import capfirst
15 from django.utils.translation import ngettext, override as translation_override
16 
17 QUOTE_MAP = {i: '_%02X' % i for i in b'":/_#?;@&=+$,"[]<>%\n\\'}
18 UNQUOTE_MAP = {v: chr(k) for k, v in QUOTE_MAP.items()}
19 UNQUOTE_RE = _lazy_re_compile('_(?:%s)' % '|'.join([x[1:] for x in UNQUOTE_MAP]))
20 
21 
22 class FieldIsAForeignKeyColumnName(Exception):
23     """A field is a foreign key attname, i.e. <FK>_id."""
24     pass
25 
26 
27 def lookup_needs_distinct(opts, lookup_path):
28     """
29     Return True if 'distinct()' should be used to query the given lookup path.
30     """
31     lookup_fields = lookup_path.split(LOOKUP_SEP)
32     # Go through the fields (following all relations) and look for an m2m.
33     for field_name in lookup_fields:
34         if field_name == 'pk':
35             field_name = opts.pk.name
36         try:
37             field = opts.get_field(field_name)
38         except FieldDoesNotExist:
39             # Ignore query lookups.
40             continue
41         else:
42             if hasattr(field, 'get_path_info'):
43                 # This field is a relation; update opts to follow the relation.
44                 path_info = field.get_path_info()
45                 opts = path_info[-1].to_opts
46                 if any(path.m2m for path in path_info):
47                     # This field is a m2m relation so distinct must be called.
48                     return True
49     return False
50 
51 
52 def prepare_lookup_value(key, value):
53     """
54     Return a lookup value prepared to be used in queryset filtering.
55     """
56     # if key ends with __in, split parameter into separate values
57     if key.endswith('__in'):
58         value = value.split(',')
59     # if key ends with __isnull, special case '' and the string literals 'false' and '0'
60     elif key.endswith('__isnull'):
61         value = value.lower() not in ('', 'false', '0')
62     return value
63 
64 
65 def quote(s):
66     """
67     Ensure that primary key values do not confuse the admin URLs by escaping
68     any '/', '_' and ':' and similarly problematic characters.
69     Similar to urllib.parse.quote(), except that the quoting is slightly
70     different so that it doesn't get automatically unquoted by the Web browser.
71     """
72     return s.translate(QUOTE_MAP) if isinstance(s, str) else s
73 
74 
75 def unquote(s):
76     """Undo the effects of quote()."""
77     return UNQUOTE_RE.sub(lambda m: UNQUOTE_MAP[m[0]], s)
78 
79 
80 def flatten(fields):
81     """
82     Return a list which is a single level of flattening of the original list.
83     """
84     flat = []
85     for field in fields:
86         if isinstance(field, (list, tuple)):
87             flat.extend(field)
88         else:
89             flat.append(field)
90     return flat
91 
92 
93 def flatten_fieldsets(fieldsets):
94     """Return a list of field names from an admin fieldsets structure."""
95     field_names = []
96     for name, opts in fieldsets:
97         field_names.extend(
98             flatten(opts['fields'])
99         )
100     return field_names
101 
102 
103 def get_deleted_objects(objs, request, admin_site):
104     """
105     Find all objects related to ``objs`` that should also be deleted. ``objs``
106     must be a homogeneous iterable of objects (e.g. a QuerySet).
107 
108     Return a nested list of strings suitable for display in the
109     template with the ``unordered_list`` filter.
110     """
111     try:
112         obj = objs[0]
113     except IndexError:
114         return [], {}, set(), []
115     else:
116         using = router.db_for_write(obj._meta.model)
117     collector = NestedObjects(using=using)
118     collector.collect(objs)
119     perms_needed = set()
120 
121     def format_callback(obj):
122         model = obj.__class__
123         has_admin = model in admin_site._registry
124         opts = obj._meta
125 
126         no_edit_link = '%s: %s' % (capfirst(opts.verbose_name), obj)
127 
128         if has_admin:
129             if not admin_site._registry[model].has_delete_permission(request, obj):
130                 perms_needed.add(opts.verbose_name)
131             try:
132                 admin_url = reverse('%s:%s_%s_change'
133                                     % (admin_site.name,
134                                        opts.app_label,
135                                        opts.model_name),
136                                     None, (quote(obj.pk),))
137             except NoReverseMatch:
138                 # Change url doesn't exist -- don't display link to edit
139                 return no_edit_link
140 
141             # Display a link to the admin page.
142             return format_html('{}: <a href="{}">{}</a>',
143                                capfirst(opts.verbose_name),
144                                admin_url,
145                                obj)
146         else:
147             # Don't display link to edit, because it either has no
148             # admin or is edited inline.
149             return no_edit_link
150 
151     to_delete = collector.nested(format_callback)
152 
153     protected = [format_callback(obj) for obj in collector.protected]
154     model_count = {model._meta.verbose_name_plural: len(objs) for model, objs in collector.model_objs.items()}
155 
156     return to_delete, model_count, perms_needed, protected
157 
158 
159 class NestedObjects(Collector):
160     def __init__(self, *args, **kwargs):
161         super().__init__(*args, **kwargs)
162         self.edges = {}  # {from_instance: [to_instances]}
163         self.protected = set()
164         self.model_objs = defaultdict(set)
165 
166     def add_edge(self, source, target):
167         self.edges.setdefault(source, []).append(target)
168 
169     def collect(self, objs, source=None, source_attr=None, **kwargs):
170         for obj in objs:
171             if source_attr and not source_attr.endswith('+'):
172                 related_name = source_attr % {
173                     'class': source._meta.model_name,
174                     'app_label': source._meta.app_label,
175                 }
176                 self.add_edge(getattr(obj, related_name), obj)
177             else:
178                 self.add_edge(None, obj)
179             self.model_objs[obj._meta.model].add(obj)
180         try:
181             return super().collect(objs, source_attr=source_attr, **kwargs)
182         except models.ProtectedError as e:
183             self.protected.update(e.protected_objects)
184         except models.RestrictedError as e:
185             self.protected.update(e.restricted_objects)
186 
187     def related_objects(self, related_model, related_fields, objs):
188         qs = super().related_objects(related_model, related_fields, objs)
189         return qs.select_related(*[related_field.name for related_field in related_fields])
190 
191     def _nested(self, obj, seen, format_callback):
192         if obj in seen:
193             return []
194         seen.add(obj)
195         children = []
196         for child in self.edges.get(obj, ()):
197             children.extend(self._nested(child, seen, format_callback))
198         if format_callback:
199             ret = [format_callback(obj)]
200         else:
201             ret = [obj]
202         if children:
203             ret.append(children)
204         return ret
205 
206     def nested(self, format_callback=None):
207         """
208         Return the graph as a nested list.
209         """
210         seen = set()
211         roots = []
212         for root in self.edges.get(None, ()):
213             roots.extend(self._nested(root, seen, format_callback))
214         return roots
215 
216     def can_fast_delete(self, *args, **kwargs):
217         """
218         We always want to load the objects into memory so that we can display
219         them to the user in confirm page.
220         """
221         return False
222 
223 
224 def model_format_dict(obj):
225     """
226     Return a `dict` with keys 'verbose_name' and 'verbose_name_plural',
227     typically for use with string formatting.
228 
229     `obj` may be a `Model` instance, `Model` subclass, or `QuerySet` instance.
230     """
231     if isinstance(obj, (models.Model, models.base.ModelBase)):
232         opts = obj._meta
233     elif isinstance(obj, models.query.QuerySet):
234         opts = obj.model._meta
235     else:
236         opts = obj
237     return {
238         'verbose_name': opts.verbose_name,
239         'verbose_name_plural': opts.verbose_name_plural,
240     }
241 
242 
243 def model_ngettext(obj, n=None):
244     """
245     Return the appropriate `verbose_name` or `verbose_name_plural` value for
246     `obj` depending on the count `n`.
247 
248     `obj` may be a `Model` instance, `Model` subclass, or `QuerySet` instance.
249     If `obj` is a `QuerySet` instance, `n` is optional and the length of the
250     `QuerySet` is used.
251     """
252     if isinstance(obj, models.query.QuerySet):
253         if n is None:
254             n = obj.count()
255         obj = obj.model
256     d = model_format_dict(obj)
257     singular, plural = d["verbose_name"], d["verbose_name_plural"]
258     return ngettext(singular, plural, n or 0)
259 
260 
261 def lookup_field(name, obj, model_admin=None):
262     opts = obj._meta
263     try:
264         f = _get_non_gfk_field(opts, name)
265     except (FieldDoesNotExist, FieldIsAForeignKeyColumnName):
266         # For non-field values, the value is either a method, property or
267         # returned via a callable.
268         if callable(name):
269             attr = name
270             value = attr(obj)
271         elif hasattr(model_admin, name) and name != '__str__':
272             attr = getattr(model_admin, name)
273             value = attr(obj)
274         else:
275             attr = getattr(obj, name)
276             if callable(attr):
277                 value = attr()
278             else:
279                 value = attr
280         f = None
281     else:
282         attr = None
283         value = getattr(obj, name)
284     return f, attr, value
285 
286 
287 def _get_non_gfk_field(opts, name):
288     """
289     For historical reasons, the admin app relies on GenericForeignKeys as being
290     "not found" by get_field(). This could likely be cleaned up.
291 
292     Reverse relations should also be excluded as these aren't attributes of the
293     model (rather something like `foo_set`).
294     """
295     field = opts.get_field(name)
296     if (field.is_relation and
297             # Generic foreign keys OR reverse relations
298             ((field.many_to_one and not field.related_model) or field.one_to_many)):
299         raise FieldDoesNotExist()
300 
301     # Avoid coercing <FK>_id fields to FK
302     if field.is_relation and not field.many_to_many and hasattr(field, 'attname') and field.attname == name:
303         raise FieldIsAForeignKeyColumnName()
304 
305     return field
306 
307 
308 def label_for_field(name, model, model_admin=None, return_attr=False, form=None):
309     """
310     Return a sensible label for a field name. The name can be a callable,
311     property (but not created with @property decorator), or the name of an
312     object's attribute, as well as a model field. If return_attr is True, also
313     return the resolved attribute (which could be a callable). This will be
314     None if (and only if) the name refers to a field.
315     """
316     attr = None
317     try:
318         field = _get_non_gfk_field(model._meta, name)
319         try:
320             label = field.verbose_name
321         except AttributeError:
322             # field is likely a ForeignObjectRel
323             label = field.related_model._meta.verbose_name
324     except FieldDoesNotExist:
325         if name == "__str__":
326             label = str(model._meta.verbose_name)
327             attr = str
328         else:
329             if callable(name):
330                 attr = name
331             elif hasattr(model_admin, name):
332                 attr = getattr(model_admin, name)
333             elif hasattr(model, name):
334                 attr = getattr(model, name)
335             elif form and name in form.fields:
336                 attr = form.fields[name]
337             else:
338                 message = "Unable to lookup '%s' on %s" % (name, model._meta.object_name)
339                 if model_admin:
340                     message += " or %s" % model_admin.__class__.__name__
341                 if form:
342                     message += " or %s" % form.__class__.__name__
343                 raise AttributeError(message)
344 
345             if hasattr(attr, "short_description"):
346                 label = attr.short_description
347             elif (isinstance(attr, property) and
348                   hasattr(attr, "fget") and
349                   hasattr(attr.fget, "short_description")):
350                 label = attr.fget.short_description
351             elif callable(attr):
352                 if attr.__name__ == "<lambda>":
353                     label = "--"
354                 else:
355                     label = pretty_name(attr.__name__)
356             else:
357                 label = pretty_name(name)
358     except FieldIsAForeignKeyColumnName:
359         label = pretty_name(name)
360         attr = name
361 
362     if return_attr:
363         return (label, attr)
364     else:
365         return label
366 
367 
368 def help_text_for_field(name, model):
369     help_text = ""
370     try:
371         field = _get_non_gfk_field(model._meta, name)
372     except (FieldDoesNotExist, FieldIsAForeignKeyColumnName):
373         pass
374     else:
375         if hasattr(field, 'help_text'):
376             help_text = field.help_text
377     return help_text
378 
379 
380 def display_for_field(value, field, empty_value_display):
381     from django.contrib.admin.templatetags.admin_list import _boolean_icon
382 
383     if getattr(field, 'flatchoices', None):
384         return dict(field.flatchoices).get(value, empty_value_display)
385     # BooleanField needs special-case null-handling, so it comes before the
386     # general null test.
387     elif isinstance(field, models.BooleanField):
388         return _boolean_icon(value)
389     elif value is None:
390         return empty_value_display
391     elif isinstance(field, models.DateTimeField):
392         return formats.localize(timezone.template_localtime(value))
393     elif isinstance(field, (models.DateField, models.TimeField)):
394         return formats.localize(value)
395     elif isinstance(field, models.DecimalField):
396         return formats.number_format(value, field.decimal_places)
397     elif isinstance(field, (models.IntegerField, models.FloatField)):
398         return formats.number_format(value)
399     elif isinstance(field, models.FileField) and value:
400         return format_html('<a href="{}">{}</a>', value.url, value)
401     elif isinstance(field, models.JSONField) and value:
402         try:
403             return field.get_prep_value(value)
404         except TypeError:
405             return display_for_value(value, empty_value_display)
406     else:
407         return display_for_value(value, empty_value_display)
408 
409 
410 def display_for_value(value, empty_value_display, boolean=False):
411     from django.contrib.admin.templatetags.admin_list import _boolean_icon
412 
413     if boolean:
414         return _boolean_icon(value)
415     elif value is None:
416         return empty_value_display
417     elif isinstance(value, bool):
418         return str(value)
419     elif isinstance(value, datetime.datetime):
420         return formats.localize(timezone.template_localtime(value))
421     elif isinstance(value, (datetime.date, datetime.time)):
422         return formats.localize(value)
423     elif isinstance(value, (int, decimal.Decimal, float)):
424         return formats.number_format(value)
425     elif isinstance(value, (list, tuple)):
426         return ', '.join(str(v) for v in value)
427     else:
428         return str(value)
429 
430 
431 class NotRelationField(Exception):
432     pass
433 
434 
435 def get_model_from_relation(field):
436     if hasattr(field, 'get_path_info'):
437         return field.get_path_info()[-1].to_opts.model
438     else:
439         raise NotRelationField
440 
441 
442 def reverse_field_path(model, path):
443     """ Create a reversed field path.
444 
445     E.g. Given (Order, "user__groups"),
446     return (Group, "user__order").
447 
448     Final field must be a related model, not a data field.
449     """
450     reversed_path = []
451     parent = model
452     pieces = path.split(LOOKUP_SEP)
453     for piece in pieces:
454         field = parent._meta.get_field(piece)
455         # skip trailing data field if extant:
456         if len(reversed_path) == len(pieces) - 1:  # final iteration
457             try:
458                 get_model_from_relation(field)
459             except NotRelationField:
460                 break
461 
462         # Field should point to another model
463         if field.is_relation and not (field.auto_created and not field.concrete):
464             related_name = field.related_query_name()
465             parent = field.remote_field.model
466         else:
467             related_name = field.field.name
468             parent = field.related_model
469         reversed_path.insert(0, related_name)
470     return (parent, LOOKUP_SEP.join(reversed_path))
471 
472 
473 def get_fields_from_path(model, path):
474     """ Return list of Fields given path relative to model.
475 
476     e.g. (ModelX, "user__groups__name") -> [
477         <django.db.models.fields.related.ForeignKey object at 0x...>,
478         <django.db.models.fields.related.ManyToManyField object at 0x...>,
479         <django.db.models.fields.CharField object at 0x...>,
480     ]
481     """
482     pieces = path.split(LOOKUP_SEP)
483     fields = []
484     for piece in pieces:
485         if fields:
486             parent = get_model_from_relation(fields[-1])
487         else:
488             parent = model
489         fields.append(parent._meta.get_field(piece))
490     return fields
491 
492 
493 def construct_change_message(form, formsets, add):
494     """
495     Construct a JSON structure describing changes from a changed object.
496     Translations are deactivated so that strings are stored untranslated.
497     Translation happens later on LogEntry access.
498     """
499     # Evaluating `form.changed_data` prior to disabling translations is required
500     # to avoid fields affected by localization from being included incorrectly,
501     # e.g. where date formats differ such as MM/DD/YYYY vs DD/MM/YYYY.
502     changed_data = form.changed_data
503     with translation_override(None):
504         # Deactivate translations while fetching verbose_name for form
505         # field labels and using `field_name`, if verbose_name is not provided.
506         # Translations will happen later on LogEntry access.
507         changed_field_labels = _get_changed_field_labels_from_form(form, changed_data)
508 
509     change_message = []
510     if add:
511         change_message.append({'added': {}})
512     elif form.changed_data:
513         change_message.append({'changed': {'fields': changed_field_labels}})
514     if formsets:
515         with translation_override(None):
516             for formset in formsets:
517                 for added_object in formset.new_objects:
518                     change_message.append({
519                         'added': {
520                             'name': str(added_object._meta.verbose_name),
521                             'object': str(added_object),
522                         }
523                     })
524                 for changed_object, changed_fields in formset.changed_objects:
525                     change_message.append({
526                         'changed': {
527                             'name': str(changed_object._meta.verbose_name),
528                             'object': str(changed_object),
529                             'fields': _get_changed_field_labels_from_form(formset.forms[0], changed_fields),
530                         }
531                     })
532                 for deleted_object in formset.deleted_objects:
533                     change_message.append({
534                         'deleted': {
535                             'name': str(deleted_object._meta.verbose_name),
536                             'object': str(deleted_object),
537                         }
538                     })
539     return change_message
540 
541 
542 def _get_changed_field_labels_from_form(form, changed_data):
543     changed_field_labels = []
544     for field_name in changed_data:
545         try:
546             verbose_field_name = form.fields[field_name].label or field_name
547         except KeyError:
548             verbose_field_name = field_name
549         changed_field_labels.append(str(verbose_field_name))
550     return changed_field_labels

</code><intended_behavior>Ensure that any serialization of `JSONField` for admin purposes supports non-ASCII characters correctly. This could involve adjusting the use of `json.dumps` to include `ensure_ascii=False` and ensuring that any such change does not affect the functionality for other field types or the admin interface at large.</intended_behavior>, <file>django/db/models/fields/json.py</file>
<class>None</class>
<method>None</method>
<code>
1 import json
2 
3 from django import forms
4 from django.core import checks, exceptions
5 from django.db import NotSupportedError, connections, router
6 from django.db.models import lookups
7 from django.db.models.lookups import PostgresOperatorLookup, Transform
8 from django.utils.translation import gettext_lazy as _
9 
10 from . import Field
11 from .mixins import CheckFieldDefaultMixin
12 
13 __all__ = ['JSONField']
14 
15 
16 class JSONField(CheckFieldDefaultMixin, Field):
17     empty_strings_allowed = False
18     description = _('A JSON object')
19     default_error_messages = {
20         'invalid': _('Value must be valid JSON.'),
21     }
22     _default_hint = ('dict', '{}')
23 
24     def __init__(
25         self, verbose_name=None, name=None, encoder=None, decoder=None,
26         **kwargs,
27     ):
28         if encoder and not callable(encoder):
29             raise ValueError('The encoder parameter must be a callable object.')
30         if decoder and not callable(decoder):
31             raise ValueError('The decoder parameter must be a callable object.')
32         self.encoder = encoder
33         self.decoder = decoder
34         super().__init__(verbose_name, name, **kwargs)
35 
36     def check(self, **kwargs):
37         errors = super().check(**kwargs)
38         databases = kwargs.get('databases') or []
39         errors.extend(self._check_supported(databases))
40         return errors
41 
42     def _check_supported(self, databases):
43         errors = []
44         for db in databases:
45             if not router.allow_migrate_model(db, self.model):
46                 continue
47             connection = connections[db]
48             if not (
49                 'supports_json_field' in self.model._meta.required_db_features or
50                 connection.features.supports_json_field
51             ):
52                 errors.append(
53                     checks.Error(
54                         '%s does not support JSONFields.'
55                         % connection.display_name,
56                         obj=self.model,
57                         id='fields.E180',
58                     )
59                 )
60         return errors
61 
62     def deconstruct(self):
63         name, path, args, kwargs = super().deconstruct()
64         if self.encoder is not None:
65             kwargs['encoder'] = self.encoder
66         if self.decoder is not None:
67             kwargs['decoder'] = self.decoder
68         return name, path, args, kwargs
69 
70     def from_db_value(self, value, expression, connection):
71         if value is None:
72             return value
73         try:
74             return json.loads(value, cls=self.decoder)
75         except json.JSONDecodeError:
76             return value
77 
78     def get_internal_type(self):
79         return 'JSONField'
80 
81     def get_prep_value(self, value):
82         if value is None:
83             return value
84         return json.dumps(value, cls=self.encoder)
85 
86     def get_transform(self, name):
87         transform = super().get_transform(name)
88         if transform:
89             return transform
90         return KeyTransformFactory(name)
91 
92     def validate(self, value, model_instance):
93         super().validate(value, model_instance)
94         try:
95             json.dumps(value, cls=self.encoder)
96         except TypeError:
97             raise exceptions.ValidationError(
98                 self.error_messages['invalid'],
99                 code='invalid',
100                 params={'value': value},
101             )
102 
103     def value_to_string(self, obj):
104         return self.value_from_object(obj)
105 
106     def formfield(self, **kwargs):
107         return super().formfield(**{
108             'form_class': forms.JSONField,
109             'encoder': self.encoder,
110             'decoder': self.decoder,
111             **kwargs,
112         })
113 
114 
115 def compile_json_path(key_transforms, include_root=True):
116     path = ['$'] if include_root else []
117     for key_transform in key_transforms:
118         try:
119             num = int(key_transform)
120         except ValueError:  # non-integer
121             path.append('.')
122             path.append(json.dumps(key_transform))
123         else:
124             path.append('[%s]' % num)
125     return ''.join(path)
126 
127 
128 class DataContains(PostgresOperatorLookup):
129     lookup_name = 'contains'
130     postgres_operator = '@>'
131 
132     def as_sql(self, compiler, connection):
133         if not connection.features.supports_json_field_contains:
134             raise NotSupportedError(
135                 'contains lookup is not supported on this database backend.'
136             )
137         lhs, lhs_params = self.process_lhs(compiler, connection)
138         rhs, rhs_params = self.process_rhs(compiler, connection)
139         params = tuple(lhs_params) + tuple(rhs_params)
140         return 'JSON_CONTAINS(%s, %s)' % (lhs, rhs), params
141 
142 
143 class ContainedBy(PostgresOperatorLookup):
144     lookup_name = 'contained_by'
145     postgres_operator = '<@'
146 
147     def as_sql(self, compiler, connection):
148         if not connection.features.supports_json_field_contains:
149             raise NotSupportedError(
150                 'contained_by lookup is not supported on this database backend.'
151             )
152         lhs, lhs_params = self.process_lhs(compiler, connection)
153         rhs, rhs_params = self.process_rhs(compiler, connection)
154         params = tuple(rhs_params) + tuple(lhs_params)
155         return 'JSON_CONTAINS(%s, %s)' % (rhs, lhs), params
156 
157 
158 class HasKeyLookup(PostgresOperatorLookup):
159     logical_operator = None
160 
161     def as_sql(self, compiler, connection, template=None):
162         # Process JSON path from the left-hand side.
163         if isinstance(self.lhs, KeyTransform):
164             lhs, lhs_params, lhs_key_transforms = self.lhs.preprocess_lhs(compiler, connection)
165             lhs_json_path = compile_json_path(lhs_key_transforms)
166         else:
167             lhs, lhs_params = self.process_lhs(compiler, connection)
168             lhs_json_path = '$'
169         sql = template % lhs
170         # Process JSON path from the right-hand side.
171         rhs = self.rhs
172         rhs_params = []
173         if not isinstance(rhs, (list, tuple)):
174             rhs = [rhs]
175         for key in rhs:
176             if isinstance(key, KeyTransform):
177                 *_, rhs_key_transforms = key.preprocess_lhs(compiler, connection)
178             else:
179                 rhs_key_transforms = [key]
180             rhs_params.append('%s%s' % (
181                 lhs_json_path,
182                 compile_json_path(rhs_key_transforms, include_root=False),
183             ))
184         # Add condition for each key.
185         if self.logical_operator:
186             sql = '(%s)' % self.logical_operator.join([sql] * len(rhs_params))
187         return sql, tuple(lhs_params) + tuple(rhs_params)
188 
189     def as_mysql(self, compiler, connection):
190         return self.as_sql(compiler, connection, template="JSON_CONTAINS_PATH(%s, 'one', %%s)")
191 
192     def as_oracle(self, compiler, connection):
193         sql, params = self.as_sql(compiler, connection, template="JSON_EXISTS(%s, '%%s')")
194         # Add paths directly into SQL because path expressions cannot be passed
195         # as bind variables on Oracle.
196         return sql % tuple(params), []
197 
198     def as_postgresql(self, compiler, connection):
199         if isinstance(self.rhs, KeyTransform):
200             *_, rhs_key_transforms = self.rhs.preprocess_lhs(compiler, connection)
201             for key in rhs_key_transforms[:-1]:
202                 self.lhs = KeyTransform(key, self.lhs)
203             self.rhs = rhs_key_transforms[-1]
204         return super().as_postgresql(compiler, connection)
205 
206     def as_sqlite(self, compiler, connection):
207         return self.as_sql(compiler, connection, template='JSON_TYPE(%s, %%s) IS NOT NULL')
208 
209 
210 class HasKey(HasKeyLookup):
211     lookup_name = 'has_key'
212     postgres_operator = '?'
213     prepare_rhs = False
214 
215 
216 class HasKeys(HasKeyLookup):
217     lookup_name = 'has_keys'
218     postgres_operator = '?&'
219     logical_operator = ' AND '
220 
221     def get_prep_lookup(self):
222         return [str(item) for item in self.rhs]
223 
224 
225 class HasAnyKeys(HasKeys):
226     lookup_name = 'has_any_keys'
227     postgres_operator = '?|'
228     logical_operator = ' OR '
229 
230 
231 class JSONExact(lookups.Exact):
232     can_use_none_as_rhs = True
233 
234     def process_lhs(self, compiler, connection):
235         lhs, lhs_params = super().process_lhs(compiler, connection)
236         if connection.vendor == 'sqlite':
237             rhs, rhs_params = super().process_rhs(compiler, connection)
238             if rhs == '%s' and rhs_params == [None]:
239                 # Use JSON_TYPE instead of JSON_EXTRACT for NULLs.
240                 lhs = "JSON_TYPE(%s, '$')" % lhs
241         return lhs, lhs_params
242 
243     def process_rhs(self, compiler, connection):
244         rhs, rhs_params = super().process_rhs(compiler, connection)
245         # Treat None lookup values as null.
246         if rhs == '%s' and rhs_params == [None]:
247             rhs_params = ['null']
248         if connection.vendor == 'mysql':
249             func = ["JSON_EXTRACT(%s, '$')"] * len(rhs_params)
250             rhs = rhs % tuple(func)
251         return rhs, rhs_params
252 
253 
254 JSONField.register_lookup(DataContains)
255 JSONField.register_lookup(ContainedBy)
256 JSONField.register_lookup(HasKey)
257 JSONField.register_lookup(HasKeys)
258 JSONField.register_lookup(HasAnyKeys)
259 JSONField.register_lookup(JSONExact)
260 
261 
262 class KeyTransform(Transform):
263     postgres_operator = '->'
264     postgres_nested_operator = '#>'
265 
266     def __init__(self, key_name, *args, **kwargs):
267         super().__init__(*args, **kwargs)
268         self.key_name = str(key_name)
269 
270     def preprocess_lhs(self, compiler, connection, lhs_only=False):
271         if not lhs_only:
272             key_transforms = [self.key_name]
273         previous = self.lhs
274         while isinstance(previous, KeyTransform):
275             if not lhs_only:
276                 key_transforms.insert(0, previous.key_name)
277             previous = previous.lhs
278         lhs, params = compiler.compile(previous)
279         if connection.vendor == 'oracle':
280             # Escape string-formatting.
281             key_transforms = [key.replace('%', '%%') for key in key_transforms]
282         return (lhs, params, key_transforms) if not lhs_only else (lhs, params)
283 
284     def as_mysql(self, compiler, connection):
285         lhs, params, key_transforms = self.preprocess_lhs(compiler, connection)
286         json_path = compile_json_path(key_transforms)
287         return 'JSON_EXTRACT(%s, %%s)' % lhs, tuple(params) + (json_path,)
288 
289     def as_oracle(self, compiler, connection):
290         lhs, params, key_transforms = self.preprocess_lhs(compiler, connection)
291         json_path = compile_json_path(key_transforms)
292         return (
293             "COALESCE(JSON_QUERY(%s, '%s'), JSON_VALUE(%s, '%s'))" %
294             ((lhs, json_path) * 2)
295         ), tuple(params) * 2
296 
297     def as_postgresql(self, compiler, connection):
298         lhs, params, key_transforms = self.preprocess_lhs(compiler, connection)
299         if len(key_transforms) > 1:
300             return '(%s %s %%s)' % (lhs, self.postgres_nested_operator), params + [key_transforms]
301         try:
302             lookup = int(self.key_name)
303         except ValueError:
304             lookup = self.key_name
305         return '(%s %s %%s)' % (lhs, self.postgres_operator), tuple(params) + (lookup,)
306 
307     def as_sqlite(self, compiler, connection):
308         lhs, params, key_transforms = self.preprocess_lhs(compiler, connection)
309         json_path = compile_json_path(key_transforms)
310         return 'JSON_EXTRACT(%s, %%s)' % lhs, tuple(params) + (json_path,)
311 
312 
313 class KeyTextTransform(KeyTransform):
314     postgres_operator = '->>'
315     postgres_nested_operator = '#>>'
316 
317 
318 class KeyTransformTextLookupMixin:
319     """
320     Mixin for combining with a lookup expecting a text lhs from a JSONField
321     key lookup. On PostgreSQL, make use of the ->> operator instead of casting
322     key values to text and performing the lookup on the resulting
323     representation.
324     """
325     def __init__(self, key_transform, *args, **kwargs):
326         if not isinstance(key_transform, KeyTransform):
327             raise TypeError(
328                 'Transform should be an instance of KeyTransform in order to '
329                 'use this lookup.'
330             )
331         key_text_transform = KeyTextTransform(
332             key_transform.key_name, *key_transform.source_expressions,
333             **key_transform.extra,
334         )
335         super().__init__(key_text_transform, *args, **kwargs)
336 
337 
338 class CaseInsensitiveMixin:
339     """
340     Mixin to allow case-insensitive comparison of JSON values on MySQL.
341     MySQL handles strings used in JSON context using the utf8mb4_bin collation.
342     Because utf8mb4_bin is a binary collation, comparison of JSON values is
343     case-sensitive.
344     """
345     def process_lhs(self, compiler, connection):
346         lhs, lhs_params = super().process_lhs(compiler, connection)
347         if connection.vendor == 'mysql':
348             return 'LOWER(%s)' % lhs, lhs_params
349         return lhs, lhs_params
350 
351     def process_rhs(self, compiler, connection):
352         rhs, rhs_params = super().process_rhs(compiler, connection)
353         if connection.vendor == 'mysql':
354             return 'LOWER(%s)' % rhs, rhs_params
355         return rhs, rhs_params
356 
357 
358 class KeyTransformIsNull(lookups.IsNull):
359     # key__isnull=False is the same as has_key='key'
360     def as_oracle(self, compiler, connection):
361         if not self.rhs:
362             return HasKey(self.lhs.lhs, self.lhs.key_name).as_oracle(compiler, connection)
363         return super().as_sql(compiler, connection)
364 
365     def as_sqlite(self, compiler, connection):
366         if not self.rhs:
367             return HasKey(self.lhs.lhs, self.lhs.key_name).as_sqlite(compiler, connection)
368         return super().as_sql(compiler, connection)
369 
370 
371 class KeyTransformIn(lookups.In):
372     def process_rhs(self, compiler, connection):
373         rhs, rhs_params = super().process_rhs(compiler, connection)
374         if not connection.features.has_native_json_field:
375             func = ()
376             if connection.vendor == 'oracle':
377                 func = []
378                 for value in rhs_params:
379                     value = json.loads(value)
380                     function = 'JSON_QUERY' if isinstance(value, (list, dict)) else 'JSON_VALUE'
381                     func.append("%s('%s', '$.value')" % (
382                         function,
383                         json.dumps({'value': value}),
384                     ))
385                 func = tuple(func)
386                 rhs_params = ()
387             elif connection.vendor == 'mysql' and connection.mysql_is_mariadb:
388                 func = ("JSON_UNQUOTE(JSON_EXTRACT(%s, '$'))",) * len(rhs_params)
389             elif connection.vendor in {'sqlite', 'mysql'}:
390                 func = ("JSON_EXTRACT(%s, '$')",) * len(rhs_params)
391             rhs = rhs % func
392         return rhs, rhs_params
393 
394 
395 class KeyTransformExact(JSONExact):
396     def process_lhs(self, compiler, connection):
397         lhs, lhs_params = super().process_lhs(compiler, connection)
398         if connection.vendor == 'sqlite':
399             rhs, rhs_params = super().process_rhs(compiler, connection)
400             if rhs == '%s' and rhs_params == ['null']:
401                 lhs, _ = self.lhs.preprocess_lhs(compiler, connection, lhs_only=True)
402                 lhs = 'JSON_TYPE(%s, %%s)' % lhs
403         return lhs, lhs_params
404 
405     def process_rhs(self, compiler, connection):
406         if isinstance(self.rhs, KeyTransform):
407             return super(lookups.Exact, self).process_rhs(compiler, connection)
408         rhs, rhs_params = super().process_rhs(compiler, connection)
409         if connection.vendor == 'oracle':
410             func = []
411             for value in rhs_params:
412                 value = json.loads(value)
413                 function = 'JSON_QUERY' if isinstance(value, (list, dict)) else 'JSON_VALUE'
414                 func.append("%s('%s', '$.value')" % (
415                     function,
416                     json.dumps({'value': value}),
417                 ))
418             rhs = rhs % tuple(func)
419             rhs_params = []
420         elif connection.vendor == 'sqlite':
421             func = ["JSON_EXTRACT(%s, '$')" if value != 'null' else '%s' for value in rhs_params]
422             rhs = rhs % tuple(func)
423         return rhs, rhs_params
424 
425     def as_oracle(self, compiler, connection):
426         rhs, rhs_params = super().process_rhs(compiler, connection)
427         if rhs_params == ['null']:
428             # Field has key and it's NULL.
429             has_key_expr = HasKey(self.lhs.lhs, self.lhs.key_name)
430             has_key_sql, has_key_params = has_key_expr.as_oracle(compiler, connection)
431             is_null_expr = self.lhs.get_lookup('isnull')(self.lhs, True)
432             is_null_sql, is_null_params = is_null_expr.as_sql(compiler, connection)
433             return (
434                 '%s AND %s' % (has_key_sql, is_null_sql),
435                 tuple(has_key_params) + tuple(is_null_params),
436             )
437         return super().as_sql(compiler, connection)
438 
439 
440 class KeyTransformIExact(CaseInsensitiveMixin, KeyTransformTextLookupMixin, lookups.IExact):
441     pass
442 
443 
444 class KeyTransformIContains(CaseInsensitiveMixin, KeyTransformTextLookupMixin, lookups.IContains):
445     pass
446 
447 
448 class KeyTransformStartsWith(KeyTransformTextLookupMixin, lookups.StartsWith):
449     pass
450 
451 
452 class KeyTransformIStartsWith(CaseInsensitiveMixin, KeyTransformTextLookupMixin, lookups.IStartsWith):
453     pass
454 
455 
456 class KeyTransformEndsWith(KeyTransformTextLookupMixin, lookups.EndsWith):
457     pass
458 
459 
460 class KeyTransformIEndsWith(CaseInsensitiveMixin, KeyTransformTextLookupMixin, lookups.IEndsWith):
461     pass
462 
463 
464 class KeyTransformRegex(KeyTransformTextLookupMixin, lookups.Regex):
465     pass
466 
467 
468 class KeyTransformIRegex(CaseInsensitiveMixin, KeyTransformTextLookupMixin, lookups.IRegex):
469     pass
470 
471 
472 class KeyTransformNumericLookupMixin:
473     def process_rhs(self, compiler, connection):
474         rhs, rhs_params = super().process_rhs(compiler, connection)
475         if not connection.features.has_native_json_field:
476             rhs_params = [json.loads(value) for value in rhs_params]
477         return rhs, rhs_params
478 
479 
480 class KeyTransformLt(KeyTransformNumericLookupMixin, lookups.LessThan):
481     pass
482 
483 
484 class KeyTransformLte(KeyTransformNumericLookupMixin, lookups.LessThanOrEqual):
485     pass
486 
487 
488 class KeyTransformGt(KeyTransformNumericLookupMixin, lookups.GreaterThan):
489     pass
490 
491 
492 class KeyTransformGte(KeyTransformNumericLookupMixin, lookups.GreaterThanOrEqual):
493     pass
494 
495 
496 KeyTransform.register_lookup(KeyTransformIn)
497 KeyTransform.register_lookup(KeyTransformExact)
498 KeyTransform.register_lookup(KeyTransformIExact)
499 KeyTransform.register_lookup(KeyTransformIsNull)
500 KeyTransform.register_lookup(KeyTransformIContains)
501 KeyTransform.register_lookup(KeyTransformStartsWith)
502 KeyTransform.register_lookup(KeyTransformIStartsWith)
503 KeyTransform.register_lookup(KeyTransformEndsWith)
504 KeyTransform.register_lookup(KeyTransformIEndsWith)
505 KeyTransform.register_lookup(KeyTransformRegex)
506 KeyTransform.register_lookup(KeyTransformIRegex)
507 
508 KeyTransform.register_lookup(KeyTransformLt)
509 KeyTransform.register_lookup(KeyTransformLte)
510 KeyTransform.register_lookup(KeyTransformGt)
511 KeyTransform.register_lookup(KeyTransformGte)
512 
513 
514 class KeyTransformFactory:
515 
516     def __init__(self, key_name):
517         self.key_name = key_name
518 
519     def __call__(self, *args, **kwargs):
520         return KeyTransform(self.key_name, *args, **kwargs)

</code><intended_behavior>Investigate and ensure that the serialization mechanism to and from the database is Unicode-friendly and that any transformations performed before rendering in the admin interface preserve Unicode characters. Ensure compatibility across different database backends.</intended_behavior>]
2025-10-18 00:47:11.192 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-18 00:47:11.192 | INFO     | Search-only: skipping patch selection
2025-10-18 00:47:11.345 | INFO     | Task django__django-13512 completed successfully.
2025-10-18 00:47:11.346 | INFO     | No patch generated. You can try running ACR again.
