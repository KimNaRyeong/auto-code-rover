2025-10-18 06:57:01.926 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-18 06:57:05.169 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=569, output_tokens=12, cost=0.006050
2025-10-18 06:57:17.836 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=749, output_tokens=576, cost=0.024770
2025-10-18 06:57:18.833 | INFO     | registered non reproducing test 0
2025-10-18 06:57:32.079 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1598, output_tokens=645, cost=0.035330
2025-10-18 06:57:33.055 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 06:57:39.368 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=859, output_tokens=297, cost=0.017500
2025-10-18 06:57:39.371 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 06:57:41.804 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=651, output_tokens=50, cost=0.008010
2025-10-18 06:57:41.805 | DEBUG    | Extracted a valid json.
2025-10-18 06:57:41.805 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_class(\"MyGeneric\")",
        "search_class(\"MyGenericChild\")",
        "search_code(\"MyGeneric.some_type = MyGenericChild\")"
    ],
    "bug_locations": []
}
2025-10-18 06:57:41.812 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 06:57:41.812 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 06:57:51.197 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1341, output_tokens=415, cost=0.025860
2025-10-18 06:57:51.202 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 06:57:58.109 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1972, output_tokens=314, cost=0.029140
2025-10-18 06:57:58.112 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 06:58:01.152 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=668, output_tokens=14, cost=0.007100
2025-10-18 06:58:01.153 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-18 06:58:01.153 | DEBUG    | Trying to convert API calls/bug locations into json. Try 2 of 5.
2025-10-18 06:58:02.505 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=668, output_tokens=14, cost=0.007100
2025-10-18 06:58:02.506 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-18 06:58:02.507 | DEBUG    | Trying to convert API calls/bug locations into json. Try 3 of 5.
2025-10-18 06:58:04.228 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=668, output_tokens=14, cost=0.007100
2025-10-18 06:58:04.228 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-18 06:58:04.228 | DEBUG    | Trying to convert API calls/bug locations into json. Try 4 of 5.
2025-10-18 06:58:05.311 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=668, output_tokens=14, cost=0.007100
2025-10-18 06:58:05.311 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-18 06:58:05.311 | DEBUG    | Trying to convert API calls/bug locations into json. Try 5 of 5.
2025-10-18 06:58:07.997 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=668, output_tokens=14, cost=0.007100
2025-10-18 06:58:07.998 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-18 06:58:07.998 | DEBUG    | Agent proxy return the following json: None
2025-10-18 06:58:07.999 | DEBUG    | Could not extract API calls from agent search response, asking search agent to re-generate response.
2025-10-18 06:58:07.999 | DEBUG    | <Agent search> Downstream could not consume our last response. Will retry.
2025-10-18 06:58:08.000 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 06:58:20.124 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2313, output_tokens=418, cost=0.035670
2025-10-18 06:58:20.128 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 06:58:24.117 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=772, output_tokens=52, cost=0.009280
2025-10-18 06:58:24.118 | DEBUG    | Extracted a valid json.
2025-10-18 06:58:24.118 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_code(\"conf.py\")",
        "search_code(\"sphinx.ext.autodoc\")",
        "search_code(\"sphinx.ext.autosummary\")"
    ],
    "bug_locations": []
}
2025-10-18 06:58:24.204 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 06:58:24.204 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 06:58:41.956 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3603, output_tokens=759, cost=0.058800
2025-10-18 06:58:41.963 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 06:58:49.763 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=4578, output_tokens=323, cost=0.055470
2025-10-18 06:58:49.766 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 06:58:57.203 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=677, output_tokens=301, cost=0.015800
2025-10-18 06:58:57.203 | DEBUG    | Extracted a valid json.
2025-10-18 06:58:57.203 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "doc/conf.py",
            "class": "",
            "method": "",
            "intended_behavior": "This file should be reviewed and possibly adjusted to ensure it's not contributing to the Sphinx warning regarding field list formatting in doc comments. The configurations, especially those related to extensions like autodoc and autosummary, might need fine-tuning to handle doc comments for generic classes without triggering warnings. Ensure that any custom settings or extensions related to documentation parsing explicitly support or correctly handle the structuring of doc comments on attributes within generic classes. The intended behavior is to maintain existing documentation generation capabilities while eliminating the generation of formatting-related warnings."
        },
        {
            "file": "sphinx/ext/autodoc/__init__.py",
            "class": "",
            "method": "",
            "intended_behavior": "If this file or related files within the autodoc extension are contributing to the issue, they should be inspected for how they parse and render doc comments, particularly around generics and inheritance. Modifications might be needed to explicitly handle or better support doc comments on generic class attributes. This could include adjusting parsing logic to correctly interpret field lists within these contexts or providing configuration options that allow users to specify how such comments should be treated. The aim is again to preserve the functionality of automatic documentation generation while ensuring it does not misinterpret or incorrectly format comments, avoiding warnings."
        }
    ]
}
2025-10-18 06:58:57.209 | DEBUG    | Bug location extracted successfully: [<file>doc/conf.py</file>
<class>None</class>
<method>None</method>
<code>
1 # Sphinx documentation build configuration file
2 
3 import re
4 
5 import sphinx
6 
7 
8 extensions = ['sphinx.ext.autodoc', 'sphinx.ext.doctest', 'sphinx.ext.todo',
9               'sphinx.ext.autosummary', 'sphinx.ext.extlinks',
10               'sphinx.ext.intersphinx',
11               'sphinx.ext.viewcode', 'sphinx.ext.inheritance_diagram']
12 
13 master_doc = 'contents'
14 templates_path = ['_templates']
15 exclude_patterns = ['_build']
16 
17 project = 'Sphinx'
18 copyright = '2007-2020, Georg Brandl and the Sphinx team'
19 version = sphinx.__display_version__
20 release = version
21 show_authors = True
22 
23 html_theme = 'sphinx13'
24 html_theme_path = ['_themes']
25 modindex_common_prefix = ['sphinx.']
26 html_static_path = ['_static']
27 html_sidebars = {'index': ['indexsidebar.html', 'searchbox.html']}
28 html_additional_pages = {'index': 'index.html'}
29 html_use_opensearch = 'https://www.sphinx-doc.org/en/master'
30 html_baseurl = 'https://www.sphinx-doc.org/en/master/'
31 
32 htmlhelp_basename = 'Sphinxdoc'
33 
34 epub_theme = 'epub'
35 epub_basename = 'sphinx'
36 epub_author = 'Georg Brandl'
37 epub_publisher = 'http://sphinx-doc.org/'
38 epub_uid = 'web-site'
39 epub_scheme = 'url'
40 epub_identifier = epub_publisher
41 epub_pre_files = [('index.xhtml', 'Welcome')]
42 epub_post_files = [('usage/installation.xhtml', 'Installing Sphinx'),
43                    ('develop.xhtml', 'Sphinx development')]
44 epub_exclude_files = ['_static/opensearch.xml', '_static/doctools.js',
45                       '_static/jquery.js', '_static/searchtools.js',
46                       '_static/underscore.js', '_static/basic.css',
47                       '_static/language_data.js',
48                       'search.html', '_static/websupport.js']
49 epub_fix_images = False
50 epub_max_image_width = 0
51 epub_show_urls = 'inline'
52 epub_use_index = False
53 epub_guide = (('toc', 'contents.xhtml', 'Table of Contents'),)
54 epub_description = 'Sphinx documentation generator system manual'
55 
56 latex_documents = [('contents', 'sphinx.tex', 'Sphinx Documentation',
57                     'Georg Brandl', 'manual', 1)]
58 latex_logo = '_static/sphinx.png'
59 latex_elements = {
60     'fontenc': r'\usepackage[LGR,X2,T1]{fontenc}',
61     'fontpkg': r'''
62 \usepackage[sc]{mathpazo}
63 \usepackage[scaled]{helvet}
64 \usepackage{courier}
65 \substitutefont{LGR}{\rmdefault}{cmr}
66 \substitutefont{LGR}{\sfdefault}{cmss}
67 \substitutefont{LGR}{\ttdefault}{cmtt}
68 \substitutefont{X2}{\rmdefault}{cmr}
69 \substitutefont{X2}{\sfdefault}{cmss}
70 \substitutefont{X2}{\ttdefault}{cmtt}
71 ''',
72     'passoptionstopackages': '\\PassOptionsToPackage{svgnames}{xcolor}',
73     'preamble': '\\DeclareUnicodeCharacter{229E}{\\ensuremath{\\boxplus}}',
74     'fvset': '\\fvset{fontsize=auto}',
75     # fix missing index entry due to RTD doing only once pdflatex after makeindex
76     'printindex': r'''
77 \IfFileExists{\jobname.ind}
78              {\footnotesize\raggedright\printindex}
79              {\begin{sphinxtheindex}\end{sphinxtheindex}}
80 ''',
81 }
82 latex_show_urls = 'footnote'
83 latex_use_xindy = True
84 
85 autodoc_member_order = 'groupwise'
86 todo_include_todos = True
87 extlinks = {'duref': ('http://docutils.sourceforge.net/docs/ref/rst/'
88                       'restructuredtext.html#%s', ''),
89             'durole': ('http://docutils.sourceforge.net/docs/ref/rst/'
90                        'roles.html#%s', ''),
91             'dudir': ('http://docutils.sourceforge.net/docs/ref/rst/'
92                       'directives.html#%s', '')}
93 
94 man_pages = [
95     ('contents', 'sphinx-all', 'Sphinx documentation generator system manual',
96      'Georg Brandl', 1),
97     ('man/sphinx-build', 'sphinx-build', 'Sphinx documentation generator tool',
98      '', 1),
99     ('man/sphinx-quickstart', 'sphinx-quickstart', 'Sphinx documentation '
100      'template generator', '', 1),
101     ('man/sphinx-apidoc', 'sphinx-apidoc', 'Sphinx API doc generator tool',
102      '', 1),
103     ('man/sphinx-autogen', 'sphinx-autogen', 'Generate autodoc stub pages',
104      '', 1),
105 ]
106 
107 texinfo_documents = [
108     ('contents', 'sphinx', 'Sphinx Documentation', 'Georg Brandl',
109      'Sphinx', 'The Sphinx documentation builder.', 'Documentation tools',
110      1),
111 ]
112 
113 # We're not using intersphinx right now, but if we did, this would be part of
114 # the mapping:
115 intersphinx_mapping = {'python': ('https://docs.python.org/3/', None)}
116 
117 # Sphinx document translation with sphinx gettext feature uses these settings:
118 locale_dirs = ['locale/']
119 gettext_compact = False
120 
121 
122 # -- Extension interface -------------------------------------------------------
123 
124 from sphinx import addnodes  # noqa
125 
126 event_sig_re = re.compile(r'([a-zA-Z-]+)\s*\((.*)\)')
127 
128 
129 def parse_event(env, sig, signode):
130     m = event_sig_re.match(sig)
131     if not m:
132         signode += addnodes.desc_name(sig, sig)
133         return sig
134     name, args = m.groups()
135     signode += addnodes.desc_name(name, name)
136     plist = addnodes.desc_parameterlist()
137     for arg in args.split(','):
138         arg = arg.strip()
139         plist += addnodes.desc_parameter(arg, arg)
140     signode += plist
141     return name
142 
143 
144 def setup(app):
145     from sphinx.ext.autodoc import cut_lines
146     from sphinx.util.docfields import GroupedField
147     app.connect('autodoc-process-docstring', cut_lines(4, what=['module']))
148     app.add_object_type('confval', 'confval',
149                         objname='configuration value',
150                         indextemplate='pair: %s; configuration value')
151     app.add_object_type('setuptools-confval', 'setuptools-confval',
152                         objname='setuptools configuration value',
153                         indextemplate='pair: %s; setuptools configuration value')
154     fdesc = GroupedField('parameter', label='Parameters',
155                          names=['param'], can_collapse=True)
156     app.add_object_type('event', 'event', 'pair: %s; event', parse_event,
157                         doc_field_types=[fdesc])
158 
159     # workaround for RTD
160     from sphinx.util import logging
161     logger = logging.getLogger(__name__)
162     app.info = lambda *args, **kwargs: logger.info(*args, **kwargs)
163     app.warn = lambda *args, **kwargs: logger.warning(*args, **kwargs)
164     app.debug = lambda *args, **kwargs: logger.debug(*args, **kwargs)

</code><intended_behavior>This file should be reviewed and possibly adjusted to ensure it's not contributing to the Sphinx warning regarding field list formatting in doc comments. The configurations, especially those related to extensions like autodoc and autosummary, might need fine-tuning to handle doc comments for generic classes without triggering warnings. Ensure that any custom settings or extensions related to documentation parsing explicitly support or correctly handle the structuring of doc comments on attributes within generic classes. The intended behavior is to maintain existing documentation generation capabilities while eliminating the generation of formatting-related warnings.</intended_behavior>, <file>sphinx/ext/autodoc/__init__.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2     sphinx.ext.autodoc
3     ~~~~~~~~~~~~~~~~~~
4 
5     Automatically insert docstrings for functions, classes or whole modules into
6     the doctree, thus avoiding duplication between docstrings and documentation
7     for those who like elaborate docstrings.
8 
9     :copyright: Copyright 2007-2020 by the Sphinx team, see AUTHORS.
10     :license: BSD, see LICENSE for details.
11 """
12 
13 import importlib
14 import re
15 import warnings
16 from inspect import Parameter, Signature
17 from types import ModuleType
18 from typing import (
19     Any, Callable, Dict, Iterator, List, Optional, Sequence, Set, Tuple, Type, TypeVar, Union
20 )
21 from typing import get_type_hints
22 
23 from docutils.statemachine import StringList
24 
25 import sphinx
26 from sphinx.application import Sphinx
27 from sphinx.config import Config, ENUM
28 from sphinx.deprecation import RemovedInSphinx40Warning, RemovedInSphinx50Warning
29 from sphinx.environment import BuildEnvironment
30 from sphinx.ext.autodoc.importer import import_object, get_module_members, get_object_members
31 from sphinx.ext.autodoc.mock import mock
32 from sphinx.locale import _, __
33 from sphinx.pycode import ModuleAnalyzer, PycodeError
34 from sphinx.util import inspect
35 from sphinx.util import logging
36 from sphinx.util.docstrings import extract_metadata, prepare_docstring
37 from sphinx.util.inspect import (
38     evaluate_signature, getdoc, object_description, safe_getattr, stringify_signature
39 )
40 from sphinx.util.typing import stringify as stringify_typehint
41 
42 if False:
43     # For type annotation
44     from typing import Type  # NOQA # for python3.5.1
45     from sphinx.ext.autodoc.directive import DocumenterBridge
46 
47 
48 logger = logging.getLogger(__name__)
49 
50 
51 # This type isn't exposed directly in any modules, but can be found
52 # here in most Python versions
53 MethodDescriptorType = type(type.__subclasses__)
54 
55 
56 #: extended signature RE: with explicit module name separated by ::
57 py_ext_sig_re = re.compile(
58     r'''^ ([\w.]+::)?            # explicit module name
59           ([\w.]+\.)?            # module and/or class name(s)
60           (\w+)  \s*             # thing name
61           (?: \((.*)\)           # optional: arguments
62            (?:\s* -> \s* (.*))?  #           return annotation
63           )? $                   # and nothing more
64           ''', re.VERBOSE)
65 special_member_re = re.compile(r'^__\S+__$')
66 
67 
68 def identity(x: Any) -> Any:
69     return x
70 
71 
72 class _All:
73     """A special value for :*-members: that matches to any member."""
74 
75     def __contains__(self, item: Any) -> bool:
76         return True
77 
78 
79 class _Empty:
80     """A special value for :exclude-members: that never matches to any member."""
81 
82     def __contains__(self, item: Any) -> bool:
83         return False
84 
85 
86 ALL = _All()
87 EMPTY = _Empty()
88 UNINITIALIZED_ATTR = object()
89 INSTANCEATTR = object()
90 SLOTSATTR = object()
91 
92 
93 def members_option(arg: Any) -> Union[object, List[str]]:
94     """Used to convert the :members: option to auto directives."""
95     if arg is None or arg is True:
96         return ALL
97     elif arg is False:
98         return None
99     else:
100         return [x.strip() for x in arg.split(',') if x.strip()]
101 
102 
103 def members_set_option(arg: Any) -> Union[object, Set[str]]:
104     """Used to convert the :members: option to auto directives."""
105     warnings.warn("members_set_option() is deprecated.",
106                   RemovedInSphinx50Warning, stacklevel=2)
107     if arg is None:
108         return ALL
109     return {x.strip() for x in arg.split(',') if x.strip()}
110 
111 
112 def exclude_members_option(arg: Any) -> Union[object, Set[str]]:
113     """Used to convert the :exclude-members: option."""
114     if arg is None:
115         return EMPTY
116     return {x.strip() for x in arg.split(',') if x.strip()}
117 
118 
119 def inherited_members_option(arg: Any) -> Union[object, Set[str]]:
120     """Used to convert the :members: option to auto directives."""
121     if arg is None:
122         return 'object'
123     else:
124         return arg
125 
126 
127 def member_order_option(arg: Any) -> Optional[str]:
128     """Used to convert the :members: option to auto directives."""
129     if arg is None:
130         return None
131     elif arg in ('alphabetical', 'bysource', 'groupwise'):
132         return arg
133     else:
134         raise ValueError(__('invalid value for member-order option: %s') % arg)
135 
136 
137 SUPPRESS = object()
138 
139 
140 def annotation_option(arg: Any) -> Any:
141     if arg is None:
142         # suppress showing the representation of the object
143         return SUPPRESS
144     else:
145         return arg
146 
147 
148 def bool_option(arg: Any) -> bool:
149     """Used to convert flag options to auto directives.  (Instead of
150     directives.flag(), which returns None).
151     """
152     return True
153 
154 
155 def merge_special_members_option(options: Dict) -> None:
156     """Merge :special-members: option to :members: option."""
157     warnings.warn("merge_special_members_option() is deprecated.",
158                   RemovedInSphinx50Warning, stacklevel=2)
159     if 'special-members' in options and options['special-members'] is not ALL:
160         if options.get('members') is ALL:
161             pass
162         elif options.get('members'):
163             for member in options['special-members']:
164                 if member not in options['members']:
165                     options['members'].append(member)
166         else:
167             options['members'] = options['special-members']
168 
169 
170 def merge_members_option(options: Dict) -> None:
171     """Merge :*-members: option to the :members: option."""
172     if options.get('members') is ALL:
173         # merging is not needed when members: ALL
174         return
175 
176     members = options.setdefault('members', [])
177     for key in {'private-members', 'special-members'}:
178         if key in options and options[key] not in (ALL, None):
179             for member in options[key]:
180                 if member not in members:
181                     members.append(member)
182 
183 
184 # Some useful event listener factories for autodoc-process-docstring.
185 
186 def cut_lines(pre: int, post: int = 0, what: str = None) -> Callable:
187     """Return a listener that removes the first *pre* and last *post*
188     lines of every docstring.  If *what* is a sequence of strings,
189     only docstrings of a type in *what* will be processed.
190 
191     Use like this (e.g. in the ``setup()`` function of :file:`conf.py`)::
192 
193        from sphinx.ext.autodoc import cut_lines
194        app.connect('autodoc-process-docstring', cut_lines(4, what=['module']))
195 
196     This can (and should) be used in place of :confval:`automodule_skip_lines`.
197     """
198     def process(app: Sphinx, what_: str, name: str, obj: Any, options: Any, lines: List[str]
199                 ) -> None:
200         if what and what_ not in what:
201             return
202         del lines[:pre]
203         if post:
204             # remove one trailing blank line.
205             if lines and not lines[-1]:
206                 lines.pop(-1)
207             del lines[-post:]
208         # make sure there is a blank line at the end
209         if lines and lines[-1]:
210             lines.append('')
211     return process
212 
213 
214 def between(marker: str, what: Sequence[str] = None, keepempty: bool = False,
215             exclude: bool = False) -> Callable:
216     """Return a listener that either keeps, or if *exclude* is True excludes,
217     lines between lines that match the *marker* regular expression.  If no line
218     matches, the resulting docstring would be empty, so no change will be made
219     unless *keepempty* is true.
220 
221     If *what* is a sequence of strings, only docstrings of a type in *what* will
222     be processed.
223     """
224     marker_re = re.compile(marker)
225 
226     def process(app: Sphinx, what_: str, name: str, obj: Any, options: Any, lines: List[str]
227                 ) -> None:
228         if what and what_ not in what:
229             return
230         deleted = 0
231         delete = not exclude
232         orig_lines = lines[:]
233         for i, line in enumerate(orig_lines):
234             if delete:
235                 lines.pop(i - deleted)
236                 deleted += 1
237             if marker_re.match(line):
238                 delete = not delete
239                 if delete:
240                     lines.pop(i - deleted)
241                     deleted += 1
242         if not lines and not keepempty:
243             lines[:] = orig_lines
244         # make sure there is a blank line at the end
245         if lines and lines[-1]:
246             lines.append('')
247     return process
248 
249 
250 # This class is used only in ``sphinx.ext.autodoc.directive``,
251 # But we define this class here to keep compatibility (see #4538)
252 class Options(dict):
253     """A dict/attribute hybrid that returns None on nonexisting keys."""
254     def __getattr__(self, name: str) -> Any:
255         try:
256             return self[name.replace('_', '-')]
257         except KeyError:
258             return None
259 
260 
261 class Documenter:
262     """
263     A Documenter knows how to autodocument a single object type.  When
264     registered with the AutoDirective, it will be used to document objects
265     of that type when needed by autodoc.
266 
267     Its *objtype* attribute selects what auto directive it is assigned to
268     (the directive name is 'auto' + objtype), and what directive it generates
269     by default, though that can be overridden by an attribute called
270     *directivetype*.
271 
272     A Documenter has an *option_spec* that works like a docutils directive's;
273     in fact, it will be used to parse an auto directive's options that matches
274     the documenter.
275     """
276     #: name by which the directive is called (auto...) and the default
277     #: generated directive name
278     objtype = 'object'
279     #: indentation by which to indent the directive content
280     content_indent = '   '
281     #: priority if multiple documenters return True from can_document_member
282     priority = 0
283     #: order if autodoc_member_order is set to 'groupwise'
284     member_order = 0
285     #: true if the generated content may contain titles
286     titles_allowed = False
287 
288     option_spec = {'noindex': bool_option}  # type: Dict[str, Callable]
289 
290     def get_attr(self, obj: Any, name: str, *defargs: Any) -> Any:
291         """getattr() override for types such as Zope interfaces."""
292         return autodoc_attrgetter(self.env.app, obj, name, *defargs)
293 
294     @classmethod
295     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
296                             ) -> bool:
297         """Called to see if a member can be documented by this documenter."""
298         raise NotImplementedError('must be implemented in subclasses')
299 
300     def __init__(self, directive: "DocumenterBridge", name: str, indent: str = '') -> None:
301         self.directive = directive
302         self.env = directive.env    # type: BuildEnvironment
303         self.options = directive.genopt
304         self.name = name
305         self.indent = indent
306         # the module and object path within the module, and the fully
307         # qualified name (all set after resolve_name succeeds)
308         self.modname = None         # type: str
309         self.module = None          # type: ModuleType
310         self.objpath = None         # type: List[str]
311         self.fullname = None        # type: str
312         # extra signature items (arguments and return annotation,
313         # also set after resolve_name succeeds)
314         self.args = None            # type: str
315         self.retann = None          # type: str
316         # the object to document (set after import_object succeeds)
317         self.object = None          # type: Any
318         self.object_name = None     # type: str
319         # the parent/owner of the object to document
320         self.parent = None          # type: Any
321         # the module analyzer to get at attribute docs, or None
322         self.analyzer = None        # type: ModuleAnalyzer
323 
324     @property
325     def documenters(self) -> Dict[str, "Type[Documenter]"]:
326         """Returns registered Documenter classes"""
327         return self.env.app.registry.documenters
328 
329     def add_line(self, line: str, source: str, *lineno: int) -> None:
330         """Append one line of generated reST to the output."""
331         if line.strip():  # not a blank line
332             self.directive.result.append(self.indent + line, source, *lineno)
333         else:
334             self.directive.result.append('', source, *lineno)
335 
336     def resolve_name(self, modname: str, parents: Any, path: str, base: Any
337                      ) -> Tuple[str, List[str]]:
338         """Resolve the module and name of the object to document given by the
339         arguments and the current module/class.
340 
341         Must return a pair of the module name and a chain of attributes; for
342         example, it would return ``('zipfile', ['ZipFile', 'open'])`` for the
343         ``zipfile.ZipFile.open`` method.
344         """
345         raise NotImplementedError('must be implemented in subclasses')
346 
347     def parse_name(self) -> bool:
348         """Determine what module to import and what attribute to document.
349 
350         Returns True and sets *self.modname*, *self.objpath*, *self.fullname*,
351         *self.args* and *self.retann* if parsing and resolving was successful.
352         """
353         # first, parse the definition -- auto directives for classes and
354         # functions can contain a signature which is then used instead of
355         # an autogenerated one
356         try:
357             explicit_modname, path, base, args, retann = \
358                 py_ext_sig_re.match(self.name).groups()
359         except AttributeError:
360             logger.warning(__('invalid signature for auto%s (%r)') % (self.objtype, self.name),
361                            type='autodoc')
362             return False
363 
364         # support explicit module and class name separation via ::
365         if explicit_modname is not None:
366             modname = explicit_modname[:-2]
367             parents = path.rstrip('.').split('.') if path else []
368         else:
369             modname = None
370             parents = []
371 
372         with mock(self.env.config.autodoc_mock_imports):
373             self.modname, self.objpath = self.resolve_name(modname, parents, path, base)
374 
375         if not self.modname:
376             return False
377 
378         self.args = args
379         self.retann = retann
380         self.fullname = (self.modname or '') + \
381                         ('.' + '.'.join(self.objpath) if self.objpath else '')
382         return True
383 
384     def import_object(self, raiseerror: bool = False) -> bool:
385         """Import the object given by *self.modname* and *self.objpath* and set
386         it as *self.object*.
387 
388         Returns True if successful, False if an error occurred.
389         """
390         with mock(self.env.config.autodoc_mock_imports):
391             try:
392                 ret = import_object(self.modname, self.objpath, self.objtype,
393                                     attrgetter=self.get_attr,
394                                     warningiserror=self.env.config.autodoc_warningiserror)
395                 self.module, self.parent, self.object_name, self.object = ret
396                 return True
397             except ImportError as exc:
398                 if raiseerror:
399                     raise
400                 else:
401                     logger.warning(exc.args[0], type='autodoc', subtype='import_object')
402                     self.env.note_reread()
403                     return False
404 
405     def get_real_modname(self) -> str:
406         """Get the real module name of an object to document.
407 
408         It can differ from the name of the module through which the object was
409         imported.
410         """
411         return self.get_attr(self.object, '__module__', None) or self.modname
412 
413     def check_module(self) -> bool:
414         """Check if *self.object* is really defined in the module given by
415         *self.modname*.
416         """
417         if self.options.imported_members:
418             return True
419 
420         subject = inspect.unpartial(self.object)
421         modname = self.get_attr(subject, '__module__', None)
422         if modname and modname != self.modname:
423             return False
424         return True
425 
426     def format_args(self, **kwargs: Any) -> str:
427         """Format the argument signature of *self.object*.
428 
429         Should return None if the object does not have a signature.
430         """
431         return None
432 
433     def format_name(self) -> str:
434         """Format the name of *self.object*.
435 
436         This normally should be something that can be parsed by the generated
437         directive, but doesn't need to be (Sphinx will display it unparsed
438         then).
439         """
440         # normally the name doesn't contain the module (except for module
441         # directives of course)
442         return '.'.join(self.objpath) or self.modname
443 
444     def _call_format_args(self, **kwargs: Any) -> str:
445         if kwargs:
446             try:
447                 return self.format_args(**kwargs)
448             except TypeError:
449                 # avoid chaining exceptions, by putting nothing here
450                 pass
451 
452         # retry without arguments for old documenters
453         return self.format_args()
454 
455     def format_signature(self, **kwargs: Any) -> str:
456         """Format the signature (arguments and return annotation) of the object.
457 
458         Let the user process it via the ``autodoc-process-signature`` event.
459         """
460         if self.args is not None:
461             # signature given explicitly
462             args = "(%s)" % self.args
463             retann = self.retann
464         else:
465             # try to introspect the signature
466             try:
467                 retann = None
468                 args = self._call_format_args(**kwargs)
469                 if args:
470                     matched = re.match(r'^(\(.*\))\s+->\s+(.*)$', args)
471                     if matched:
472                         args = matched.group(1)
473                         retann = matched.group(2)
474             except Exception as exc:
475                 logger.warning(__('error while formatting arguments for %s: %s'),
476                                self.fullname, exc, type='autodoc')
477                 args = None
478 
479         result = self.env.events.emit_firstresult('autodoc-process-signature',
480                                                   self.objtype, self.fullname,
481                                                   self.object, self.options, args, retann)
482         if result:
483             args, retann = result
484 
485         if args is not None:
486             return args + ((' -> %s' % retann) if retann else '')
487         else:
488             return ''
489 
490     def add_directive_header(self, sig: str) -> None:
491         """Add the directive header and options to the generated content."""
492         domain = getattr(self, 'domain', 'py')
493         directive = getattr(self, 'directivetype', self.objtype)
494         name = self.format_name()
495         sourcename = self.get_sourcename()
496 
497         # one signature per line, indented by column
498         prefix = '.. %s:%s:: ' % (domain, directive)
499         for i, sig_line in enumerate(sig.split("\n")):
500             self.add_line('%s%s%s' % (prefix, name, sig_line),
501                           sourcename)
502             if i == 0:
503                 prefix = " " * len(prefix)
504 
505         if self.options.noindex:
506             self.add_line('   :noindex:', sourcename)
507         if self.objpath:
508             # Be explicit about the module, this is necessary since .. class::
509             # etc. don't support a prepended module name
510             self.add_line('   :module: %s' % self.modname, sourcename)
511 
512     def get_doc(self, encoding: str = None, ignore: int = None) -> List[List[str]]:
513         """Decode and return lines of the docstring(s) for the object."""
514         if encoding is not None:
515             warnings.warn("The 'encoding' argument to autodoc.%s.get_doc() is deprecated."
516                           % self.__class__.__name__,
517                           RemovedInSphinx40Warning, stacklevel=2)
518         if ignore is not None:
519             warnings.warn("The 'ignore' argument to autodoc.%s.get_doc() is deprecated."
520                           % self.__class__.__name__,
521                           RemovedInSphinx50Warning, stacklevel=2)
522         docstring = getdoc(self.object, self.get_attr,
523                            self.env.config.autodoc_inherit_docstrings,
524                            self.parent, self.object_name)
525         if docstring:
526             tab_width = self.directive.state.document.settings.tab_width
527             return [prepare_docstring(docstring, ignore, tab_width)]
528         return []
529 
530     def process_doc(self, docstrings: List[List[str]]) -> Iterator[str]:
531         """Let the user process the docstrings before adding them."""
532         for docstringlines in docstrings:
533             if self.env.app:
534                 # let extensions preprocess docstrings
535                 self.env.app.emit('autodoc-process-docstring',
536                                   self.objtype, self.fullname, self.object,
537                                   self.options, docstringlines)
538             yield from docstringlines
539 
540     def get_sourcename(self) -> str:
541         if self.analyzer:
542             return '%s:docstring of %s' % (self.analyzer.srcname, self.fullname)
543         return 'docstring of %s' % self.fullname
544 
545     def add_content(self, more_content: Any, no_docstring: bool = False) -> None:
546         """Add content from docstrings, attribute documentation and user."""
547         # set sourcename and add content from attribute documentation
548         sourcename = self.get_sourcename()
549         if self.analyzer:
550             attr_docs = self.analyzer.find_attr_docs()
551             if self.objpath:
552                 key = ('.'.join(self.objpath[:-1]), self.objpath[-1])
553                 if key in attr_docs:
554                     no_docstring = True
555                     # make a copy of docstring for attributes to avoid cache
556                     # the change of autodoc-process-docstring event.
557                     docstrings = [list(attr_docs[key])]
558 
559                     for i, line in enumerate(self.process_doc(docstrings)):
560                         self.add_line(line, sourcename, i)
561 
562         # add content from docstrings
563         if not no_docstring:
564             docstrings = self.get_doc()
565             if not docstrings:
566                 # append at least a dummy docstring, so that the event
567                 # autodoc-process-docstring is fired and can add some
568                 # content if desired
569                 docstrings.append([])
570             for i, line in enumerate(self.process_doc(docstrings)):
571                 self.add_line(line, sourcename, i)
572 
573         # add additional content (e.g. from document), if present
574         if more_content:
575             for line, src in zip(more_content.data, more_content.items):
576                 self.add_line(line, src[0], src[1])
577 
578     def get_object_members(self, want_all: bool) -> Tuple[bool, List[Tuple[str, Any]]]:
579         """Return `(members_check_module, members)` where `members` is a
580         list of `(membername, member)` pairs of the members of *self.object*.
581 
582         If *want_all* is True, return all members.  Else, only return those
583         members given by *self.options.members* (which may also be none).
584         """
585         members = get_object_members(self.object, self.objpath, self.get_attr, self.analyzer)
586         if not want_all:
587             if not self.options.members:
588                 return False, []
589             # specific members given
590             selected = []
591             for name in self.options.members:
592                 if name in members:
593                     selected.append((name, members[name].value))
594                 else:
595                     logger.warning(__('missing attribute %s in object %s') %
596                                    (name, self.fullname), type='autodoc')
597             return False, selected
598         elif self.options.inherited_members:
599             return False, [(m.name, m.value) for m in members.values()]
600         else:
601             return False, [(m.name, m.value) for m in members.values()
602                            if m.directly_defined]
603 
604     def filter_members(self, members: List[Tuple[str, Any]], want_all: bool
605                        ) -> List[Tuple[str, Any, bool]]:
606         """Filter the given member list.
607 
608         Members are skipped if
609 
610         - they are private (except if given explicitly or the private-members
611           option is set)
612         - they are special methods (except if given explicitly or the
613           special-members option is set)
614         - they are undocumented (except if the undoc-members option is set)
615 
616         The user can override the skipping decision by connecting to the
617         ``autodoc-skip-member`` event.
618         """
619         def is_filtered_inherited_member(name: str) -> bool:
620             if inspect.isclass(self.object):
621                 for cls in self.object.__mro__:
622                     if cls.__name__ == self.options.inherited_members and cls != self.object:
623                         # given member is a member of specified *super class*
624                         return True
625                     elif name in cls.__dict__:
626                         return False
627                     elif name in self.get_attr(cls, '__annotations__', {}):
628                         return False
629 
630             return False
631 
632         ret = []
633 
634         # search for members in source code too
635         namespace = '.'.join(self.objpath)  # will be empty for modules
636 
637         if self.analyzer:
638             attr_docs = self.analyzer.find_attr_docs()
639         else:
640             attr_docs = {}
641 
642         # process members and determine which to skip
643         for (membername, member) in members:
644             # if isattr is True, the member is documented as an attribute
645             if member is INSTANCEATTR:
646                 isattr = True
647             else:
648                 isattr = False
649 
650             doc = getdoc(member, self.get_attr, self.env.config.autodoc_inherit_docstrings,
651                          self.parent, self.object_name)
652             if not isinstance(doc, str):
653                 # Ignore non-string __doc__
654                 doc = None
655 
656             # if the member __doc__ is the same as self's __doc__, it's just
657             # inherited and therefore not the member's doc
658             cls = self.get_attr(member, '__class__', None)
659             if cls:
660                 cls_doc = self.get_attr(cls, '__doc__', None)
661                 if cls_doc == doc:
662                     doc = None
663             has_doc = bool(doc)
664 
665             metadata = extract_metadata(doc)
666             if 'private' in metadata:
667                 # consider a member private if docstring has "private" metadata
668                 isprivate = True
669             elif 'public' in metadata:
670                 # consider a member public if docstring has "public" metadata
671                 isprivate = False
672             else:
673                 isprivate = membername.startswith('_')
674 
675             keep = False
676             if safe_getattr(member, '__sphinx_mock__', False):
677                 # mocked module or object
678                 pass
679             elif self.options.exclude_members and membername in self.options.exclude_members:
680                 # remove members given by exclude-members
681                 keep = False
682             elif want_all and special_member_re.match(membername):
683                 # special __methods__
684                 if self.options.special_members and membername in self.options.special_members:
685                     if membername == '__doc__':
686                         keep = False
687                     elif is_filtered_inherited_member(membername):
688                         keep = False
689                     else:
690                         keep = has_doc or self.options.undoc_members
691                 else:
692                     keep = False
693             elif (namespace, membername) in attr_docs:
694                 if want_all and isprivate:
695                     if self.options.private_members is None:
696                         keep = False
697                     else:
698                         keep = membername in self.options.private_members
699                 else:
700                     # keep documented attributes
701                     keep = True
702                 isattr = True
703             elif want_all and isprivate:
704                 if has_doc or self.options.undoc_members:
705                     if self.options.private_members is None:
706                         keep = False
707                     elif is_filtered_inherited_member(membername):
708                         keep = False
709                     else:
710                         keep = membername in self.options.private_members
711                 else:
712                     keep = False
713             else:
714                 if self.options.members is ALL and is_filtered_inherited_member(membername):
715                     keep = False
716                 else:
717                     # ignore undocumented members if :undoc-members: is not given
718                     keep = has_doc or self.options.undoc_members
719 
720             # give the user a chance to decide whether this member
721             # should be skipped
722             if self.env.app:
723                 # let extensions preprocess docstrings
724                 try:
725                     skip_user = self.env.app.emit_firstresult(
726                         'autodoc-skip-member', self.objtype, membername, member,
727                         not keep, self.options)
728                     if skip_user is not None:
729                         keep = not skip_user
730                 except Exception as exc:
731                     logger.warning(__('autodoc: failed to determine %r to be documented, '
732                                       'the following exception was raised:\n%s'),
733                                    member, exc, type='autodoc')
734                     keep = False
735 
736             if keep:
737                 ret.append((membername, member, isattr))
738 
739         return ret
740 
741     def document_members(self, all_members: bool = False) -> None:
742         """Generate reST for member documentation.
743 
744         If *all_members* is True, do all members, else those given by
745         *self.options.members*.
746         """
747         # set current namespace for finding members
748         self.env.temp_data['autodoc:module'] = self.modname
749         if self.objpath:
750             self.env.temp_data['autodoc:class'] = self.objpath[0]
751 
752         want_all = all_members or self.options.inherited_members or \
753             self.options.members is ALL
754         # find out which members are documentable
755         members_check_module, members = self.get_object_members(want_all)
756 
757         # document non-skipped members
758         memberdocumenters = []  # type: List[Tuple[Documenter, bool]]
759         for (mname, member, isattr) in self.filter_members(members, want_all):
760             classes = [cls for cls in self.documenters.values()
761                        if cls.can_document_member(member, mname, isattr, self)]
762             if not classes:
763                 # don't know how to document this member
764                 continue
765             # prefer the documenter with the highest priority
766             classes.sort(key=lambda cls: cls.priority)
767             # give explicitly separated module name, so that members
768             # of inner classes can be documented
769             full_mname = self.modname + '::' + \
770                 '.'.join(self.objpath + [mname])
771             documenter = classes[-1](self.directive, full_mname, self.indent)
772             memberdocumenters.append((documenter, isattr))
773 
774         member_order = self.options.member_order or self.env.config.autodoc_member_order
775         memberdocumenters = self.sort_members(memberdocumenters, member_order)
776 
777         for documenter, isattr in memberdocumenters:
778             documenter.generate(
779                 all_members=True, real_modname=self.real_modname,
780                 check_module=members_check_module and not isattr)
781 
782         # reset current objects
783         self.env.temp_data['autodoc:module'] = None
784         self.env.temp_data['autodoc:class'] = None
785 
786     def sort_members(self, documenters: List[Tuple["Documenter", bool]],
787                      order: str) -> List[Tuple["Documenter", bool]]:
788         """Sort the given member list."""
789         if order == 'groupwise':
790             # sort by group; alphabetically within groups
791             documenters.sort(key=lambda e: (e[0].member_order, e[0].name))
792         elif order == 'bysource':
793             if self.analyzer:
794                 # sort by source order, by virtue of the module analyzer
795                 tagorder = self.analyzer.tagorder
796 
797                 def keyfunc(entry: Tuple[Documenter, bool]) -> int:
798                     fullname = entry[0].name.split('::')[1]
799                     return tagorder.get(fullname, len(tagorder))
800                 documenters.sort(key=keyfunc)
801             else:
802                 # Assume that member discovery order matches source order.
803                 # This is a reasonable assumption in Python 3.6 and up, where
804                 # module.__dict__ is insertion-ordered.
805                 pass
806         else:  # alphabetical
807             documenters.sort(key=lambda e: e[0].name)
808 
809         return documenters
810 
811     def generate(self, more_content: Any = None, real_modname: str = None,
812                  check_module: bool = False, all_members: bool = False) -> None:
813         """Generate reST for the object given by *self.name*, and possibly for
814         its members.
815 
816         If *more_content* is given, include that content. If *real_modname* is
817         given, use that module name to find attribute docs. If *check_module* is
818         True, only generate if the object is defined in the module name it is
819         imported from. If *all_members* is True, document all members.
820         """
821         if not self.parse_name():
822             # need a module to import
823             logger.warning(
824                 __('don\'t know which module to import for autodocumenting '
825                    '%r (try placing a "module" or "currentmodule" directive '
826                    'in the document, or giving an explicit module name)') %
827                 self.name, type='autodoc')
828             return
829 
830         # now, import the module and get object to document
831         if not self.import_object():
832             return
833 
834         # If there is no real module defined, figure out which to use.
835         # The real module is used in the module analyzer to look up the module
836         # where the attribute documentation would actually be found in.
837         # This is used for situations where you have a module that collects the
838         # functions and classes of internal submodules.
839         guess_modname = self.get_real_modname()
840         self.real_modname = real_modname or guess_modname
841 
842         # try to also get a source code analyzer for attribute docs
843         try:
844             self.analyzer = ModuleAnalyzer.for_module(self.real_modname)
845             # parse right now, to get PycodeErrors on parsing (results will
846             # be cached anyway)
847             self.analyzer.find_attr_docs()
848         except PycodeError as exc:
849             logger.debug('[autodoc] module analyzer failed: %s', exc)
850             # no source file -- e.g. for builtin and C modules
851             self.analyzer = None
852             # at least add the module.__file__ as a dependency
853             if hasattr(self.module, '__file__') and self.module.__file__:
854                 self.directive.filename_set.add(self.module.__file__)
855         else:
856             self.directive.filename_set.add(self.analyzer.srcname)
857 
858         if self.real_modname != guess_modname:
859             # Add module to dependency list if target object is defined in other module.
860             try:
861                 analyzer = ModuleAnalyzer.for_module(guess_modname)
862                 self.directive.filename_set.add(analyzer.srcname)
863             except PycodeError:
864                 pass
865 
866         # check __module__ of object (for members not given explicitly)
867         if check_module:
868             if not self.check_module():
869                 return
870 
871         sourcename = self.get_sourcename()
872 
873         # make sure that the result starts with an empty line.  This is
874         # necessary for some situations where another directive preprocesses
875         # reST and no starting newline is present
876         self.add_line('', sourcename)
877 
878         # format the object's signature, if any
879         try:
880             sig = self.format_signature()
881         except Exception as exc:
882             logger.warning(__('error while formatting signature for %s: %s'),
883                            self.fullname, exc, type='autodoc')
884             return
885 
886         # generate the directive header and options, if applicable
887         self.add_directive_header(sig)
888         self.add_line('', sourcename)
889 
890         # e.g. the module directive doesn't have content
891         self.indent += self.content_indent
892 
893         # add all content (from docstrings, attribute docs etc.)
894         self.add_content(more_content)
895 
896         # document members, if possible
897         self.document_members(all_members)
898 
899 
900 class ModuleDocumenter(Documenter):
901     """
902     Specialized Documenter subclass for modules.
903     """
904     objtype = 'module'
905     content_indent = ''
906     titles_allowed = True
907 
908     option_spec = {
909         'members': members_option, 'undoc-members': bool_option,
910         'noindex': bool_option, 'inherited-members': inherited_members_option,
911         'show-inheritance': bool_option, 'synopsis': identity,
912         'platform': identity, 'deprecated': bool_option,
913         'member-order': member_order_option, 'exclude-members': exclude_members_option,
914         'private-members': members_option, 'special-members': members_option,
915         'imported-members': bool_option, 'ignore-module-all': bool_option
916     }  # type: Dict[str, Callable]
917 
918     def __init__(self, *args: Any) -> None:
919         super().__init__(*args)
920         merge_members_option(self.options)
921         self.__all__ = None
922 
923     @classmethod
924     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
925                             ) -> bool:
926         # don't document submodules automatically
927         return False
928 
929     def resolve_name(self, modname: str, parents: Any, path: str, base: Any
930                      ) -> Tuple[str, List[str]]:
931         if modname is not None:
932             logger.warning(__('"::" in automodule name doesn\'t make sense'),
933                            type='autodoc')
934         return (path or '') + base, []
935 
936     def parse_name(self) -> bool:
937         ret = super().parse_name()
938         if self.args or self.retann:
939             logger.warning(__('signature arguments or return annotation '
940                               'given for automodule %s') % self.fullname,
941                            type='autodoc')
942         return ret
943 
944     def import_object(self, raiseerror: bool = False) -> bool:
945         def is_valid_module_all(__all__: Any) -> bool:
946             """Check the given *__all__* is valid for a module."""
947             if (isinstance(__all__, (list, tuple)) and
948                     all(isinstance(e, str) for e in __all__)):
949                 return True
950             else:
951                 return False
952 
953         ret = super().import_object(raiseerror)
954 
955         if not self.options.ignore_module_all:
956             __all__ = getattr(self.object, '__all__', None)
957             if is_valid_module_all(__all__):
958                 # valid __all__ found. copy it to self.__all__
959                 self.__all__ = __all__
960             elif __all__:
961                 # invalid __all__ found.
962                 logger.warning(__('__all__ should be a list of strings, not %r '
963                                   '(in module %s) -- ignoring __all__') %
964                                (__all__, self.fullname), type='autodoc')
965 
966         return ret
967 
968     def add_directive_header(self, sig: str) -> None:
969         Documenter.add_directive_header(self, sig)
970 
971         sourcename = self.get_sourcename()
972 
973         # add some module-specific options
974         if self.options.synopsis:
975             self.add_line('   :synopsis: ' + self.options.synopsis, sourcename)
976         if self.options.platform:
977             self.add_line('   :platform: ' + self.options.platform, sourcename)
978         if self.options.deprecated:
979             self.add_line('   :deprecated:', sourcename)
980 
981     def get_object_members(self, want_all: bool) -> Tuple[bool, List[Tuple[str, Any]]]:
982         if want_all:
983             if self.__all__:
984                 memberlist = self.__all__
985             else:
986                 # for implicit module members, check __module__ to avoid
987                 # documenting imported objects
988                 return True, get_module_members(self.object)
989         else:
990             memberlist = self.options.members or []
991         ret = []
992         for mname in memberlist:
993             try:
994                 ret.append((mname, safe_getattr(self.object, mname)))
995             except AttributeError:
996                 logger.warning(
997                     __('missing attribute mentioned in :members: or __all__: '
998                        'module %s, attribute %s') %
999                     (safe_getattr(self.object, '__name__', '???'), mname),
1000                     type='autodoc'
1001                 )
1002         return False, ret
1003 
1004     def sort_members(self, documenters: List[Tuple["Documenter", bool]],
1005                      order: str) -> List[Tuple["Documenter", bool]]:
1006         if order == 'bysource' and self.__all__:
1007             # Sort alphabetically first (for members not listed on the __all__)
1008             documenters.sort(key=lambda e: e[0].name)
1009 
1010             # Sort by __all__
1011             def keyfunc(entry: Tuple[Documenter, bool]) -> int:
1012                 name = entry[0].name.split('::')[1]
1013                 if name in self.__all__:
1014                     return self.__all__.index(name)
1015                 else:
1016                     return len(self.__all__)
1017             documenters.sort(key=keyfunc)
1018 
1019             return documenters
1020         else:
1021             return super().sort_members(documenters, order)
1022 
1023 
1024 class ModuleLevelDocumenter(Documenter):
1025     """
1026     Specialized Documenter subclass for objects on module level (functions,
1027     classes, data/constants).
1028     """
1029     def resolve_name(self, modname: str, parents: Any, path: str, base: Any
1030                      ) -> Tuple[str, List[str]]:
1031         if modname is None:
1032             if path:
1033                 modname = path.rstrip('.')
1034             else:
1035                 # if documenting a toplevel object without explicit module,
1036                 # it can be contained in another auto directive ...
1037                 modname = self.env.temp_data.get('autodoc:module')
1038                 # ... or in the scope of a module directive
1039                 if not modname:
1040                     modname = self.env.ref_context.get('py:module')
1041                 # ... else, it stays None, which means invalid
1042         return modname, parents + [base]
1043 
1044 
1045 class ClassLevelDocumenter(Documenter):
1046     """
1047     Specialized Documenter subclass for objects on class level (methods,
1048     attributes).
1049     """
1050     def resolve_name(self, modname: str, parents: Any, path: str, base: Any
1051                      ) -> Tuple[str, List[str]]:
1052         if modname is None:
1053             if path:
1054                 mod_cls = path.rstrip('.')
1055             else:
1056                 mod_cls = None
1057                 # if documenting a class-level object without path,
1058                 # there must be a current class, either from a parent
1059                 # auto directive ...
1060                 mod_cls = self.env.temp_data.get('autodoc:class')
1061                 # ... or from a class directive
1062                 if mod_cls is None:
1063                     mod_cls = self.env.ref_context.get('py:class')
1064                 # ... if still None, there's no way to know
1065                 if mod_cls is None:
1066                     return None, []
1067             modname, sep, cls = mod_cls.rpartition('.')
1068             parents = [cls]
1069             # if the module name is still missing, get it like above
1070             if not modname:
1071                 modname = self.env.temp_data.get('autodoc:module')
1072             if not modname:
1073                 modname = self.env.ref_context.get('py:module')
1074             # ... else, it stays None, which means invalid
1075         return modname, parents + [base]
1076 
1077 
1078 class DocstringSignatureMixin:
1079     """
1080     Mixin for FunctionDocumenter and MethodDocumenter to provide the
1081     feature of reading the signature from the docstring.
1082     """
1083     _new_docstrings = None  # type: List[List[str]]
1084     _signatures = None      # type: List[str]
1085 
1086     def _find_signature(self, encoding: str = None) -> Tuple[str, str]:
1087         if encoding is not None:
1088             warnings.warn("The 'encoding' argument to autodoc.%s._find_signature() is "
1089                           "deprecated." % self.__class__.__name__,
1090                           RemovedInSphinx40Warning, stacklevel=2)
1091 
1092         # candidates of the object name
1093         valid_names = [self.objpath[-1]]  # type: ignore
1094         if isinstance(self, ClassDocumenter):
1095             valid_names.append('__init__')
1096             if hasattr(self.object, '__mro__'):
1097                 valid_names.extend(cls.__name__ for cls in self.object.__mro__)
1098 
1099         docstrings = self.get_doc()
1100         self._new_docstrings = docstrings[:]
1101         self._signatures = []
1102         result = None
1103         for i, doclines in enumerate(docstrings):
1104             for j, line in enumerate(doclines):
1105                 if not line:
1106                     # no lines in docstring, no match
1107                     break
1108 
1109                 if line.endswith('\\'):
1110                     multiline = True
1111                     line = line.rstrip('\\').rstrip()
1112                 else:
1113                     multiline = False
1114 
1115                 # match first line of docstring against signature RE
1116                 match = py_ext_sig_re.match(line)
1117                 if not match:
1118                     continue
1119                 exmod, path, base, args, retann = match.groups()
1120 
1121                 # the base name must match ours
1122                 if base not in valid_names:
1123                     continue
1124 
1125                 # re-prepare docstring to ignore more leading indentation
1126                 tab_width = self.directive.state.document.settings.tab_width  # type: ignore
1127                 self._new_docstrings[i] = prepare_docstring('\n'.join(doclines[j + 1:]),
1128                                                             tabsize=tab_width)
1129 
1130                 if result is None:
1131                     # first signature
1132                     result = args, retann
1133                 else:
1134                     # subsequent signatures
1135                     self._signatures.append("(%s) -> %s" % (args, retann))
1136 
1137                 if multiline:
1138                     # the signature have multiple signatures on docstring
1139                     continue
1140                 else:
1141                     # don't look any further
1142                     break
1143 
1144             if result:
1145                 # finish the loop when signature found
1146                 break
1147 
1148         return result
1149 
1150     def get_doc(self, encoding: str = None, ignore: int = None) -> List[List[str]]:
1151         if encoding is not None:
1152             warnings.warn("The 'encoding' argument to autodoc.%s.get_doc() is deprecated."
1153                           % self.__class__.__name__,
1154                           RemovedInSphinx40Warning, stacklevel=2)
1155         if self._new_docstrings is not None:
1156             return self._new_docstrings
1157         return super().get_doc(None, ignore)  # type: ignore
1158 
1159     def format_signature(self, **kwargs: Any) -> str:
1160         if self.args is None and self.env.config.autodoc_docstring_signature:  # type: ignore
1161             # only act if a signature is not explicitly given already, and if
1162             # the feature is enabled
1163             result = self._find_signature()
1164             if result is not None:
1165                 self.args, self.retann = result
1166         sig = super().format_signature(**kwargs)  # type: ignore
1167         if self._signatures:
1168             return "\n".join([sig] + self._signatures)
1169         else:
1170             return sig
1171 
1172 
1173 class DocstringStripSignatureMixin(DocstringSignatureMixin):
1174     """
1175     Mixin for AttributeDocumenter to provide the
1176     feature of stripping any function signature from the docstring.
1177     """
1178     def format_signature(self, **kwargs: Any) -> str:
1179         if self.args is None and self.env.config.autodoc_docstring_signature:  # type: ignore
1180             # only act if a signature is not explicitly given already, and if
1181             # the feature is enabled
1182             result = self._find_signature()
1183             if result is not None:
1184                 # Discarding _args is a only difference with
1185                 # DocstringSignatureMixin.format_signature.
1186                 # Documenter.format_signature use self.args value to format.
1187                 _args, self.retann = result
1188         return super().format_signature(**kwargs)
1189 
1190 
1191 class FunctionDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type: ignore
1192     """
1193     Specialized Documenter subclass for functions.
1194     """
1195     objtype = 'function'
1196     member_order = 30
1197 
1198     @classmethod
1199     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1200                             ) -> bool:
1201         # supports functions, builtins and bound methods exported at the module level
1202         return (inspect.isfunction(member) or inspect.isbuiltin(member) or
1203                 (inspect.isroutine(member) and isinstance(parent, ModuleDocumenter)))
1204 
1205     def format_args(self, **kwargs: Any) -> str:
1206         if self.env.config.autodoc_typehints in ('none', 'description'):
1207             kwargs.setdefault('show_annotation', False)
1208 
1209         try:
1210             self.env.app.emit('autodoc-before-process-signature', self.object, False)
1211             sig = inspect.signature(self.object, follow_wrapped=True)
1212             args = stringify_signature(sig, **kwargs)
1213         except TypeError as exc:
1214             logger.warning(__("Failed to get a function signature for %s: %s"),
1215                            self.fullname, exc)
1216             return None
1217         except ValueError:
1218             args = ''
1219 
1220         if self.env.config.strip_signature_backslash:
1221             # escape backslashes for reST
1222             args = args.replace('\\', '\\\\')
1223         return args
1224 
1225     def document_members(self, all_members: bool = False) -> None:
1226         pass
1227 
1228     def add_directive_header(self, sig: str) -> None:
1229         sourcename = self.get_sourcename()
1230         super().add_directive_header(sig)
1231 
1232         if inspect.iscoroutinefunction(self.object):
1233             self.add_line('   :async:', sourcename)
1234 
1235     def format_signature(self, **kwargs: Any) -> str:
1236         sigs = []
1237         if self.analyzer and '.'.join(self.objpath) in self.analyzer.overloads:
1238             # Use signatures for overloaded functions instead of the implementation function.
1239             overloaded = True
1240         else:
1241             overloaded = False
1242             sig = super().format_signature(**kwargs)
1243             sigs.append(sig)
1244 
1245         if inspect.is_singledispatch_function(self.object):
1246             # append signature of singledispatch'ed functions
1247             for typ, func in self.object.registry.items():
1248                 if typ is object:
1249                     pass  # default implementation. skipped.
1250                 else:
1251                     self.annotate_to_first_argument(func, typ)
1252 
1253                     documenter = FunctionDocumenter(self.directive, '')
1254                     documenter.object = func
1255                     documenter.objpath = [None]
1256                     sigs.append(documenter.format_signature())
1257         if overloaded:
1258             __globals__ = safe_getattr(self.object, '__globals__', {})
1259             for overload in self.analyzer.overloads.get('.'.join(self.objpath)):
1260                 overload = evaluate_signature(overload, __globals__)
1261                 sig = stringify_signature(overload, **kwargs)
1262                 sigs.append(sig)
1263 
1264         return "\n".join(sigs)
1265 
1266     def annotate_to_first_argument(self, func: Callable, typ: Type) -> None:
1267         """Annotate type hint to the first argument of function if needed."""
1268         try:
1269             sig = inspect.signature(func)
1270         except TypeError as exc:
1271             logger.warning(__("Failed to get a function signature for %s: %s"),
1272                            self.fullname, exc)
1273             return
1274         except ValueError:
1275             return
1276 
1277         if len(sig.parameters) == 0:
1278             return
1279 
1280         params = list(sig.parameters.values())
1281         if params[0].annotation is Parameter.empty:
1282             params[0] = params[0].replace(annotation=typ)
1283             try:
1284                 func.__signature__ = sig.replace(parameters=params)  # type: ignore
1285             except TypeError:
1286                 # failed to update signature (ex. built-in or extension types)
1287                 return
1288 
1289 
1290 class SingledispatchFunctionDocumenter(FunctionDocumenter):
1291     """
1292     Used to be a specialized Documenter subclass for singledispatch'ed functions.
1293 
1294     Retained for backwards compatibility, now does the same as the FunctionDocumenter
1295     """
1296 
1297 
1298 class DecoratorDocumenter(FunctionDocumenter):
1299     """
1300     Specialized Documenter subclass for decorator functions.
1301     """
1302     objtype = 'decorator'
1303 
1304     # must be lower than FunctionDocumenter
1305     priority = -1
1306 
1307     def format_args(self, **kwargs: Any) -> Any:
1308         args = super().format_args(**kwargs)
1309         if ',' in args:
1310             return args
1311         else:
1312             return None
1313 
1314 
1315 # Types which have confusing metaclass signatures it would be best not to show.
1316 # These are listed by name, rather than storing the objects themselves, to avoid
1317 # needing to import the modules.
1318 _METACLASS_CALL_BLACKLIST = [
1319     'enum.EnumMeta.__call__',
1320 ]
1321 
1322 
1323 class ClassDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type: ignore
1324     """
1325     Specialized Documenter subclass for classes.
1326     """
1327     objtype = 'class'
1328     member_order = 20
1329     option_spec = {
1330         'members': members_option, 'undoc-members': bool_option,
1331         'noindex': bool_option, 'inherited-members': inherited_members_option,
1332         'show-inheritance': bool_option, 'member-order': member_order_option,
1333         'exclude-members': exclude_members_option,
1334         'private-members': members_option, 'special-members': members_option,
1335     }  # type: Dict[str, Callable]
1336 
1337     _signature_class = None  # type: Any
1338     _signature_method_name = None  # type: str
1339 
1340     def __init__(self, *args: Any) -> None:
1341         super().__init__(*args)
1342         merge_members_option(self.options)
1343 
1344     @classmethod
1345     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1346                             ) -> bool:
1347         return isinstance(member, type)
1348 
1349     def import_object(self, raiseerror: bool = False) -> bool:
1350         ret = super().import_object(raiseerror)
1351         # if the class is documented under another name, document it
1352         # as data/attribute
1353         if ret:
1354             if hasattr(self.object, '__name__'):
1355                 self.doc_as_attr = (self.objpath[-1] != self.object.__name__)
1356             else:
1357                 self.doc_as_attr = True
1358         return ret
1359 
1360     def _get_signature(self) -> Tuple[Optional[Any], Optional[str], Optional[Signature]]:
1361         def get_user_defined_function_or_method(obj: Any, attr: str) -> Any:
1362             """ Get the `attr` function or method from `obj`, if it is user-defined. """
1363             if inspect.is_builtin_class_method(obj, attr):
1364                 return None
1365             attr = self.get_attr(obj, attr, None)
1366             if not (inspect.ismethod(attr) or inspect.isfunction(attr)):
1367                 return None
1368             return attr
1369 
1370         # This sequence is copied from inspect._signature_from_callable.
1371         # ValueError means that no signature could be found, so we keep going.
1372 
1373         # First, let's see if it has an overloaded __call__ defined
1374         # in its metaclass
1375         call = get_user_defined_function_or_method(type(self.object), '__call__')
1376 
1377         if call is not None:
1378             if "{0.__module__}.{0.__qualname__}".format(call) in _METACLASS_CALL_BLACKLIST:
1379                 call = None
1380 
1381         if call is not None:
1382             self.env.app.emit('autodoc-before-process-signature', call, True)
1383             try:
1384                 sig = inspect.signature(call, bound_method=True)
1385                 return type(self.object), '__call__', sig
1386             except ValueError:
1387                 pass
1388 
1389         # Now we check if the 'obj' class has a '__new__' method
1390         new = get_user_defined_function_or_method(self.object, '__new__')
1391         if new is not None:
1392             self.env.app.emit('autodoc-before-process-signature', new, True)
1393             try:
1394                 sig = inspect.signature(new, bound_method=True)
1395                 return self.object, '__new__', sig
1396             except ValueError:
1397                 pass
1398 
1399         # Finally, we should have at least __init__ implemented
1400         init = get_user_defined_function_or_method(self.object, '__init__')
1401         if init is not None:
1402             self.env.app.emit('autodoc-before-process-signature', init, True)
1403             try:
1404                 sig = inspect.signature(init, bound_method=True)
1405                 return self.object, '__init__', sig
1406             except ValueError:
1407                 pass
1408 
1409         # None of the attributes are user-defined, so fall back to let inspect
1410         # handle it.
1411         # We don't know the exact method that inspect.signature will read
1412         # the signature from, so just pass the object itself to our hook.
1413         self.env.app.emit('autodoc-before-process-signature', self.object, False)
1414         try:
1415             sig = inspect.signature(self.object, bound_method=False)
1416             return None, None, sig
1417         except ValueError:
1418             pass
1419 
1420         # Still no signature: happens e.g. for old-style classes
1421         # with __init__ in C and no `__text_signature__`.
1422         return None, None, None
1423 
1424     def format_args(self, **kwargs: Any) -> str:
1425         if self.env.config.autodoc_typehints in ('none', 'description'):
1426             kwargs.setdefault('show_annotation', False)
1427 
1428         try:
1429             self._signature_class, self._signature_method_name, sig = self._get_signature()
1430         except TypeError as exc:
1431             # __signature__ attribute contained junk
1432             logger.warning(__("Failed to get a constructor signature for %s: %s"),
1433                            self.fullname, exc)
1434             return None
1435 
1436         if sig is None:
1437             return None
1438 
1439         return stringify_signature(sig, show_return_annotation=False, **kwargs)
1440 
1441     def format_signature(self, **kwargs: Any) -> str:
1442         if self.doc_as_attr:
1443             return ''
1444 
1445         sig = super().format_signature()
1446 
1447         overloaded = False
1448         qualname = None
1449         # TODO: recreate analyzer for the module of class (To be clear, owner of the method)
1450         if self._signature_class and self._signature_method_name and self.analyzer:
1451             qualname = '.'.join([self._signature_class.__qualname__,
1452                                  self._signature_method_name])
1453             if qualname in self.analyzer.overloads:
1454                 overloaded = True
1455 
1456         sigs = []
1457         if overloaded:
1458             # Use signatures for overloaded methods instead of the implementation method.
1459             method = safe_getattr(self._signature_class, self._signature_method_name, None)
1460             __globals__ = safe_getattr(method, '__globals__', {})
1461             for overload in self.analyzer.overloads.get(qualname):
1462                 overload = evaluate_signature(overload, __globals__)
1463 
1464                 parameters = list(overload.parameters.values())
1465                 overload = overload.replace(parameters=parameters[1:],
1466                                             return_annotation=Parameter.empty)
1467                 sig = stringify_signature(overload, **kwargs)
1468                 sigs.append(sig)
1469         else:
1470             sigs.append(sig)
1471 
1472         return "\n".join(sigs)
1473 
1474     def add_directive_header(self, sig: str) -> None:
1475         sourcename = self.get_sourcename()
1476 
1477         if self.doc_as_attr:
1478             self.directivetype = 'attribute'
1479         super().add_directive_header(sig)
1480 
1481         if self.analyzer and '.'.join(self.objpath) in self.analyzer.finals:
1482             self.add_line('   :final:', sourcename)
1483 
1484         # add inheritance info, if wanted
1485         if not self.doc_as_attr and self.options.show_inheritance:
1486             sourcename = self.get_sourcename()
1487             self.add_line('', sourcename)
1488             if hasattr(self.object, '__bases__') and len(self.object.__bases__):
1489                 bases = [':class:`%s`' % b.__name__
1490                          if b.__module__ in ('__builtin__', 'builtins')
1491                          else ':class:`%s.%s`' % (b.__module__, b.__qualname__)
1492                          for b in self.object.__bases__]
1493                 self.add_line('   ' + _('Bases: %s') % ', '.join(bases),
1494                               sourcename)
1495 
1496     def get_doc(self, encoding: str = None, ignore: int = None) -> List[List[str]]:
1497         if encoding is not None:
1498             warnings.warn("The 'encoding' argument to autodoc.%s.get_doc() is deprecated."
1499                           % self.__class__.__name__,
1500                           RemovedInSphinx40Warning, stacklevel=2)
1501         lines = getattr(self, '_new_docstrings', None)
1502         if lines is not None:
1503             return lines
1504 
1505         content = self.env.config.autoclass_content
1506 
1507         docstrings = []
1508         attrdocstring = self.get_attr(self.object, '__doc__', None)
1509         if attrdocstring:
1510             docstrings.append(attrdocstring)
1511 
1512         # for classes, what the "docstring" is can be controlled via a
1513         # config value; the default is only the class docstring
1514         if content in ('both', 'init'):
1515             __init__ = self.get_attr(self.object, '__init__', None)
1516             initdocstring = getdoc(__init__, self.get_attr,
1517                                    self.env.config.autodoc_inherit_docstrings,
1518                                    self.parent, self.object_name)
1519             # for new-style classes, no __init__ means default __init__
1520             if (initdocstring is not None and
1521                 (initdocstring == object.__init__.__doc__ or  # for pypy
1522                  initdocstring.strip() == object.__init__.__doc__)):  # for !pypy
1523                 initdocstring = None
1524             if not initdocstring:
1525                 # try __new__
1526                 __new__ = self.get_attr(self.object, '__new__', None)
1527                 initdocstring = getdoc(__new__, self.get_attr,
1528                                        self.env.config.autodoc_inherit_docstrings,
1529                                        self.parent, self.object_name)
1530                 # for new-style classes, no __new__ means default __new__
1531                 if (initdocstring is not None and
1532                     (initdocstring == object.__new__.__doc__ or  # for pypy
1533                      initdocstring.strip() == object.__new__.__doc__)):  # for !pypy
1534                     initdocstring = None
1535             if initdocstring:
1536                 if content == 'init':
1537                     docstrings = [initdocstring]
1538                 else:
1539                     docstrings.append(initdocstring)
1540 
1541         tab_width = self.directive.state.document.settings.tab_width
1542         return [prepare_docstring(docstring, ignore, tab_width) for docstring in docstrings]
1543 
1544     def add_content(self, more_content: Any, no_docstring: bool = False) -> None:
1545         if self.doc_as_attr:
1546             classname = safe_getattr(self.object, '__qualname__', None)
1547             if not classname:
1548                 classname = safe_getattr(self.object, '__name__', None)
1549             if classname:
1550                 module = safe_getattr(self.object, '__module__', None)
1551                 parentmodule = safe_getattr(self.parent, '__module__', None)
1552                 if module and module != parentmodule:
1553                     classname = str(module) + '.' + str(classname)
1554                 content = StringList([_('alias of :class:`%s`') % classname], source='')
1555                 super().add_content(content, no_docstring=True)
1556         else:
1557             super().add_content(more_content)
1558 
1559     def document_members(self, all_members: bool = False) -> None:
1560         if self.doc_as_attr:
1561             return
1562         super().document_members(all_members)
1563 
1564     def generate(self, more_content: Any = None, real_modname: str = None,
1565                  check_module: bool = False, all_members: bool = False) -> None:
1566         # Do not pass real_modname and use the name from the __module__
1567         # attribute of the class.
1568         # If a class gets imported into the module real_modname
1569         # the analyzer won't find the source of the class, if
1570         # it looks in real_modname.
1571         return super().generate(more_content=more_content,
1572                                 check_module=check_module,
1573                                 all_members=all_members)
1574 
1575 
1576 class ExceptionDocumenter(ClassDocumenter):
1577     """
1578     Specialized ClassDocumenter subclass for exceptions.
1579     """
1580     objtype = 'exception'
1581     member_order = 10
1582 
1583     # needs a higher priority than ClassDocumenter
1584     priority = 10
1585 
1586     @classmethod
1587     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1588                             ) -> bool:
1589         return isinstance(member, type) and issubclass(member, BaseException)
1590 
1591 
1592 class DataDocumenter(ModuleLevelDocumenter):
1593     """
1594     Specialized Documenter subclass for data items.
1595     """
1596     objtype = 'data'
1597     member_order = 40
1598     priority = -10
1599     option_spec = dict(ModuleLevelDocumenter.option_spec)
1600     option_spec["annotation"] = annotation_option
1601 
1602     @classmethod
1603     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1604                             ) -> bool:
1605         return isinstance(parent, ModuleDocumenter) and isattr
1606 
1607     def add_directive_header(self, sig: str) -> None:
1608         super().add_directive_header(sig)
1609         sourcename = self.get_sourcename()
1610         if not self.options.annotation:
1611             # obtain annotation for this data
1612             try:
1613                 annotations = get_type_hints(self.parent)
1614             except NameError:
1615                 # Failed to evaluate ForwardRef (maybe TYPE_CHECKING)
1616                 annotations = safe_getattr(self.parent, '__annotations__', {})
1617             except TypeError:
1618                 annotations = {}
1619             except KeyError:
1620                 # a broken class found (refs: https://github.com/sphinx-doc/sphinx/issues/8084)
1621                 annotations = {}
1622             except AttributeError:
1623                 # AttributeError is raised on 3.5.2 (fixed by 3.5.3)
1624                 annotations = {}
1625 
1626             if self.objpath[-1] in annotations:
1627                 objrepr = stringify_typehint(annotations.get(self.objpath[-1]))
1628                 self.add_line('   :type: ' + objrepr, sourcename)
1629             else:
1630                 key = ('.'.join(self.objpath[:-1]), self.objpath[-1])
1631                 if self.analyzer and key in self.analyzer.annotations:
1632                     self.add_line('   :type: ' + self.analyzer.annotations[key],
1633                                   sourcename)
1634 
1635             try:
1636                 if self.object is UNINITIALIZED_ATTR:
1637                     pass
1638                 else:
1639                     objrepr = object_description(self.object)
1640                     self.add_line('   :value: ' + objrepr, sourcename)
1641             except ValueError:
1642                 pass
1643         elif self.options.annotation is SUPPRESS:
1644             pass
1645         else:
1646             self.add_line('   :annotation: %s' % self.options.annotation,
1647                           sourcename)
1648 
1649     def document_members(self, all_members: bool = False) -> None:
1650         pass
1651 
1652     def get_real_modname(self) -> str:
1653         return self.get_attr(self.parent or self.object, '__module__', None) \
1654             or self.modname
1655 
1656 
1657 class DataDeclarationDocumenter(DataDocumenter):
1658     """
1659     Specialized Documenter subclass for data that cannot be imported
1660     because they are declared without initial value (refs: PEP-526).
1661     """
1662     objtype = 'datadecl'
1663     directivetype = 'data'
1664     member_order = 60
1665 
1666     # must be higher than AttributeDocumenter
1667     priority = 11
1668 
1669     @classmethod
1670     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1671                             ) -> bool:
1672         """This documents only INSTANCEATTR members."""
1673         return (isinstance(parent, ModuleDocumenter) and
1674                 isattr and
1675                 member is INSTANCEATTR)
1676 
1677     def import_object(self, raiseerror: bool = False) -> bool:
1678         """Never import anything."""
1679         # disguise as a data
1680         self.objtype = 'data'
1681         self.object = UNINITIALIZED_ATTR
1682         try:
1683             # import module to obtain type annotation
1684             self.parent = importlib.import_module(self.modname)
1685         except ImportError:
1686             pass
1687 
1688         return True
1689 
1690     def add_content(self, more_content: Any, no_docstring: bool = False) -> None:
1691         """Never try to get a docstring from the object."""
1692         super().add_content(more_content, no_docstring=True)
1693 
1694 
1695 class GenericAliasDocumenter(DataDocumenter):
1696     """
1697     Specialized Documenter subclass for GenericAliases.
1698     """
1699 
1700     objtype = 'genericalias'
1701     directivetype = 'data'
1702     priority = DataDocumenter.priority + 1
1703 
1704     @classmethod
1705     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1706                             ) -> bool:
1707         return inspect.isgenericalias(member)
1708 
1709     def add_directive_header(self, sig: str) -> None:
1710         self.options.annotation = SUPPRESS  # type: ignore
1711         super().add_directive_header(sig)
1712 
1713     def add_content(self, more_content: Any, no_docstring: bool = False) -> None:
1714         name = stringify_typehint(self.object)
1715         content = StringList([_('alias of %s') % name], source='')
1716         super().add_content(content)
1717 
1718 
1719 class TypeVarDocumenter(DataDocumenter):
1720     """
1721     Specialized Documenter subclass for TypeVars.
1722     """
1723 
1724     objtype = 'typevar'
1725     directivetype = 'data'
1726     priority = DataDocumenter.priority + 1
1727 
1728     @classmethod
1729     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1730                             ) -> bool:
1731         return isinstance(member, TypeVar) and isattr  # type: ignore
1732 
1733     def add_directive_header(self, sig: str) -> None:
1734         self.options.annotation = SUPPRESS  # type: ignore
1735         super().add_directive_header(sig)
1736 
1737     def get_doc(self, encoding: str = None, ignore: int = None) -> List[List[str]]:
1738         if ignore is not None:
1739             warnings.warn("The 'ignore' argument to autodoc.%s.get_doc() is deprecated."
1740                           % self.__class__.__name__,
1741                           RemovedInSphinx50Warning, stacklevel=2)
1742 
1743         if self.object.__doc__ != TypeVar.__doc__:
1744             return super().get_doc()
1745         else:
1746             return []
1747 
1748     def add_content(self, more_content: Any, no_docstring: bool = False) -> None:
1749         attrs = [repr(self.object.__name__)]
1750         for constraint in self.object.__constraints__:
1751             attrs.append(stringify_typehint(constraint))
1752         if self.object.__covariant__:
1753             attrs.append("covariant=True")
1754         if self.object.__contravariant__:
1755             attrs.append("contravariant=True")
1756 
1757         content = StringList([_('alias of TypeVar(%s)') % ", ".join(attrs)], source='')
1758         super().add_content(content)
1759 
1760 
1761 class MethodDocumenter(DocstringSignatureMixin, ClassLevelDocumenter):  # type: ignore
1762     """
1763     Specialized Documenter subclass for methods (normal, static and class).
1764     """
1765     objtype = 'method'
1766     directivetype = 'method'
1767     member_order = 50
1768     priority = 1  # must be more than FunctionDocumenter
1769 
1770     @classmethod
1771     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1772                             ) -> bool:
1773         return inspect.isroutine(member) and \
1774             not isinstance(parent, ModuleDocumenter)
1775 
1776     def import_object(self, raiseerror: bool = False) -> bool:
1777         ret = super().import_object(raiseerror)
1778         if not ret:
1779             return ret
1780 
1781         # to distinguish classmethod/staticmethod
1782         obj = self.parent.__dict__.get(self.object_name)
1783         if obj is None:
1784             obj = self.object
1785 
1786         if (inspect.isclassmethod(obj) or
1787                 inspect.isstaticmethod(obj, cls=self.parent, name=self.object_name)):
1788             # document class and static members before ordinary ones
1789             self.member_order = self.member_order - 1
1790 
1791         return ret
1792 
1793     def format_args(self, **kwargs: Any) -> str:
1794         if self.env.config.autodoc_typehints in ('none', 'description'):
1795             kwargs.setdefault('show_annotation', False)
1796 
1797         try:
1798             if self.object == object.__init__ and self.parent != object:
1799                 # Classes not having own __init__() method are shown as no arguments.
1800                 #
1801                 # Note: The signature of object.__init__() is (self, /, *args, **kwargs).
1802                 #       But it makes users confused.
1803                 args = '()'
1804             else:
1805                 if inspect.isstaticmethod(self.object, cls=self.parent, name=self.object_name):
1806                     self.env.app.emit('autodoc-before-process-signature', self.object, False)
1807                     sig = inspect.signature(self.object, bound_method=False)
1808                 else:
1809                     self.env.app.emit('autodoc-before-process-signature', self.object, True)
1810                     sig = inspect.signature(self.object, bound_method=True,
1811                                             follow_wrapped=True)
1812                 args = stringify_signature(sig, **kwargs)
1813         except TypeError as exc:
1814             logger.warning(__("Failed to get a method signature for %s: %s"),
1815                            self.fullname, exc)
1816             return None
1817         except ValueError:
1818             args = ''
1819 
1820         if self.env.config.strip_signature_backslash:
1821             # escape backslashes for reST
1822             args = args.replace('\\', '\\\\')
1823         return args
1824 
1825     def add_directive_header(self, sig: str) -> None:
1826         super().add_directive_header(sig)
1827 
1828         sourcename = self.get_sourcename()
1829         obj = self.parent.__dict__.get(self.object_name, self.object)
1830         if inspect.isabstractmethod(obj):
1831             self.add_line('   :abstractmethod:', sourcename)
1832         if inspect.iscoroutinefunction(obj):
1833             self.add_line('   :async:', sourcename)
1834         if inspect.isclassmethod(obj):
1835             self.add_line('   :classmethod:', sourcename)
1836         if inspect.isstaticmethod(obj, cls=self.parent, name=self.object_name):
1837             self.add_line('   :staticmethod:', sourcename)
1838         if self.analyzer and '.'.join(self.objpath) in self.analyzer.finals:
1839             self.add_line('   :final:', sourcename)
1840 
1841     def document_members(self, all_members: bool = False) -> None:
1842         pass
1843 
1844     def format_signature(self, **kwargs: Any) -> str:
1845         sigs = []
1846         if self.analyzer and '.'.join(self.objpath) in self.analyzer.overloads:
1847             # Use signatures for overloaded methods instead of the implementation method.
1848             overloaded = True
1849         else:
1850             overloaded = False
1851             sig = super().format_signature(**kwargs)
1852             sigs.append(sig)
1853 
1854         meth = self.parent.__dict__.get(self.objpath[-1])
1855         if inspect.is_singledispatch_method(meth):
1856             # append signature of singledispatch'ed functions
1857             for typ, func in meth.dispatcher.registry.items():
1858                 if typ is object:
1859                     pass  # default implementation. skipped.
1860                 else:
1861                     self.annotate_to_first_argument(func, typ)
1862 
1863                     documenter = MethodDocumenter(self.directive, '')
1864                     documenter.parent = self.parent
1865                     documenter.object = func
1866                     documenter.objpath = [None]
1867                     sigs.append(documenter.format_signature())
1868         if overloaded:
1869             __globals__ = safe_getattr(self.object, '__globals__', {})
1870             for overload in self.analyzer.overloads.get('.'.join(self.objpath)):
1871                 overload = evaluate_signature(overload, __globals__)
1872                 if not inspect.isstaticmethod(self.object, cls=self.parent,
1873                                               name=self.object_name):
1874                     parameters = list(overload.parameters.values())
1875                     overload = overload.replace(parameters=parameters[1:])
1876                 sig = stringify_signature(overload, **kwargs)
1877                 sigs.append(sig)
1878 
1879         return "\n".join(sigs)
1880 
1881     def annotate_to_first_argument(self, func: Callable, typ: Type) -> None:
1882         """Annotate type hint to the first argument of function if needed."""
1883         try:
1884             sig = inspect.signature(func)
1885         except TypeError as exc:
1886             logger.warning(__("Failed to get a method signature for %s: %s"),
1887                            self.fullname, exc)
1888             return
1889         except ValueError:
1890             return
1891         if len(sig.parameters) == 1:
1892             return
1893 
1894         params = list(sig.parameters.values())
1895         if params[1].annotation is Parameter.empty:
1896             params[1] = params[1].replace(annotation=typ)
1897             try:
1898                 func.__signature__ = sig.replace(parameters=params)  # type: ignore
1899             except TypeError:
1900                 # failed to update signature (ex. built-in or extension types)
1901                 return
1902 
1903 
1904 class SingledispatchMethodDocumenter(MethodDocumenter):
1905     """
1906     Used to be a specialized Documenter subclass for singledispatch'ed methods.
1907 
1908     Retained for backwards compatibility, now does the same as the MethodDocumenter
1909     """
1910 
1911 
1912 class AttributeDocumenter(DocstringStripSignatureMixin, ClassLevelDocumenter):  # type: ignore
1913     """
1914     Specialized Documenter subclass for attributes.
1915     """
1916     objtype = 'attribute'
1917     member_order = 60
1918     option_spec = dict(ModuleLevelDocumenter.option_spec)
1919     option_spec["annotation"] = annotation_option
1920 
1921     # must be higher than the MethodDocumenter, else it will recognize
1922     # some non-data descriptors as methods
1923     priority = 10
1924 
1925     @staticmethod
1926     def is_function_or_method(obj: Any) -> bool:
1927         return inspect.isfunction(obj) or inspect.isbuiltin(obj) or inspect.ismethod(obj)
1928 
1929     @classmethod
1930     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1931                             ) -> bool:
1932         if inspect.isattributedescriptor(member):
1933             return True
1934         elif (not isinstance(parent, ModuleDocumenter) and
1935               not inspect.isroutine(member) and
1936               not isinstance(member, type)):
1937             return True
1938         else:
1939             return False
1940 
1941     def document_members(self, all_members: bool = False) -> None:
1942         pass
1943 
1944     def isinstanceattribute(self) -> bool:
1945         """Check the subject is an instance attribute."""
1946         try:
1947             analyzer = ModuleAnalyzer.for_module(self.modname)
1948             attr_docs = analyzer.find_attr_docs()
1949             if self.objpath:
1950                 key = ('.'.join(self.objpath[:-1]), self.objpath[-1])
1951                 if key in attr_docs:
1952                     return True
1953 
1954             return False
1955         except PycodeError:
1956             return False
1957 
1958     def import_object(self, raiseerror: bool = False) -> bool:
1959         try:
1960             ret = super().import_object(raiseerror=True)
1961             if inspect.isenumattribute(self.object):
1962                 self.object = self.object.value
1963             if inspect.isattributedescriptor(self.object):
1964                 self._datadescriptor = True
1965             else:
1966                 # if it's not a data descriptor
1967                 self._datadescriptor = False
1968         except ImportError as exc:
1969             if self.isinstanceattribute():
1970                 self.object = INSTANCEATTR
1971                 self._datadescriptor = False
1972                 ret = True
1973             elif raiseerror:
1974                 raise
1975             else:
1976                 logger.warning(exc.args[0], type='autodoc', subtype='import_object')
1977                 self.env.note_reread()
1978                 ret = False
1979 
1980         return ret
1981 
1982     def get_real_modname(self) -> str:
1983         return self.get_attr(self.parent or self.object, '__module__', None) \
1984             or self.modname
1985 
1986     def add_directive_header(self, sig: str) -> None:
1987         super().add_directive_header(sig)
1988         sourcename = self.get_sourcename()
1989         if not self.options.annotation:
1990             # obtain type annotation for this attribute
1991             try:
1992                 annotations = get_type_hints(self.parent)
1993             except NameError:
1994                 # Failed to evaluate ForwardRef (maybe TYPE_CHECKING)
1995                 annotations = safe_getattr(self.parent, '__annotations__', {})
1996             except TypeError:
1997                 annotations = {}
1998             except KeyError:
1999                 # a broken class found (refs: https://github.com/sphinx-doc/sphinx/issues/8084)
2000                 annotations = {}
2001             except AttributeError:
2002                 # AttributeError is raised on 3.5.2 (fixed by 3.5.3)
2003                 annotations = {}
2004 
2005             if self.objpath[-1] in annotations:
2006                 objrepr = stringify_typehint(annotations.get(self.objpath[-1]))
2007                 self.add_line('   :type: ' + objrepr, sourcename)
2008             else:
2009                 key = ('.'.join(self.objpath[:-1]), self.objpath[-1])
2010                 if self.analyzer and key in self.analyzer.annotations:
2011                     self.add_line('   :type: ' + self.analyzer.annotations[key],
2012                                   sourcename)
2013 
2014             # data descriptors do not have useful values
2015             if not self._datadescriptor:
2016                 try:
2017                     if self.object is INSTANCEATTR:
2018                         pass
2019                     else:
2020                         objrepr = object_description(self.object)
2021                         self.add_line('   :value: ' + objrepr, sourcename)
2022                 except ValueError:
2023                     pass
2024         elif self.options.annotation is SUPPRESS:
2025             pass
2026         else:
2027             self.add_line('   :annotation: %s' % self.options.annotation, sourcename)
2028 
2029     def get_doc(self, encoding: str = None, ignore: int = None) -> List[List[str]]:
2030         try:
2031             # Disable `autodoc_inherit_docstring` temporarily to avoid to obtain
2032             # a docstring from the value which descriptor returns unexpectedly.
2033             # ref: https://github.com/sphinx-doc/sphinx/issues/7805
2034             orig = self.env.config.autodoc_inherit_docstrings
2035             self.env.config.autodoc_inherit_docstrings = False  # type: ignore
2036             return super().get_doc(encoding, ignore)
2037         finally:
2038             self.env.config.autodoc_inherit_docstrings = orig  # type: ignore
2039 
2040     def add_content(self, more_content: Any, no_docstring: bool = False) -> None:
2041         if not self._datadescriptor:
2042             # if it's not a data descriptor, its docstring is very probably the
2043             # wrong thing to display
2044             no_docstring = True
2045         super().add_content(more_content, no_docstring)
2046 
2047 
2048 class PropertyDocumenter(DocstringStripSignatureMixin, ClassLevelDocumenter):  # type: ignore
2049     """
2050     Specialized Documenter subclass for properties.
2051     """
2052     objtype = 'property'
2053     directivetype = 'method'
2054     member_order = 60
2055 
2056     # before AttributeDocumenter
2057     priority = AttributeDocumenter.priority + 1
2058 
2059     @classmethod
2060     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
2061                             ) -> bool:
2062         return inspect.isproperty(member) and isinstance(parent, ClassDocumenter)
2063 
2064     def document_members(self, all_members: bool = False) -> None:
2065         pass
2066 
2067     def get_real_modname(self) -> str:
2068         return self.get_attr(self.parent or self.object, '__module__', None) \
2069             or self.modname
2070 
2071     def add_directive_header(self, sig: str) -> None:
2072         super().add_directive_header(sig)
2073         sourcename = self.get_sourcename()
2074         if inspect.isabstractmethod(self.object):
2075             self.add_line('   :abstractmethod:', sourcename)
2076         self.add_line('   :property:', sourcename)
2077 
2078 
2079 class InstanceAttributeDocumenter(AttributeDocumenter):
2080     """
2081     Specialized Documenter subclass for attributes that cannot be imported
2082     because they are instance attributes (e.g. assigned in __init__).
2083     """
2084     objtype = 'instanceattribute'
2085     directivetype = 'attribute'
2086     member_order = 60
2087 
2088     # must be higher than AttributeDocumenter
2089     priority = 11
2090 
2091     @classmethod
2092     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
2093                             ) -> bool:
2094         """This documents only INSTANCEATTR members."""
2095         return (not isinstance(parent, ModuleDocumenter) and
2096                 isattr and
2097                 member is INSTANCEATTR)
2098 
2099     def import_parent(self) -> Any:
2100         try:
2101             parent = importlib.import_module(self.modname)
2102             for name in self.objpath[:-1]:
2103                 parent = self.get_attr(parent, name)
2104 
2105             return parent
2106         except (ImportError, AttributeError):
2107             return None
2108 
2109     def import_object(self, raiseerror: bool = False) -> bool:
2110         """Never import anything."""
2111         # disguise as an attribute
2112         self.objtype = 'attribute'
2113         self.object = INSTANCEATTR
2114         self.parent = self.import_parent()
2115         self._datadescriptor = False
2116         return True
2117 
2118     def add_content(self, more_content: Any, no_docstring: bool = False) -> None:
2119         """Never try to get a docstring from the object."""
2120         super().add_content(more_content, no_docstring=True)
2121 
2122 
2123 class SlotsAttributeDocumenter(AttributeDocumenter):
2124     """
2125     Specialized Documenter subclass for attributes that cannot be imported
2126     because they are attributes in __slots__.
2127     """
2128     objtype = 'slotsattribute'
2129     directivetype = 'attribute'
2130     member_order = 60
2131 
2132     # must be higher than AttributeDocumenter
2133     priority = 11
2134 
2135     @classmethod
2136     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
2137                             ) -> bool:
2138         """This documents only SLOTSATTR members."""
2139         return member is SLOTSATTR
2140 
2141     def import_object(self, raiseerror: bool = False) -> bool:
2142         """Never import anything."""
2143         # disguise as an attribute
2144         self.objtype = 'attribute'
2145         self._datadescriptor = True
2146 
2147         with mock(self.env.config.autodoc_mock_imports):
2148             try:
2149                 ret = import_object(self.modname, self.objpath[:-1], 'class',
2150                                     attrgetter=self.get_attr,
2151                                     warningiserror=self.env.config.autodoc_warningiserror)
2152                 self.module, _, _, self.parent = ret
2153                 return True
2154             except ImportError as exc:
2155                 if raiseerror:
2156                     raise
2157                 else:
2158                     logger.warning(exc.args[0], type='autodoc', subtype='import_object')
2159                     self.env.note_reread()
2160                     return False
2161 
2162     def get_doc(self, encoding: str = None, ignore: int = None) -> List[List[str]]:
2163         """Decode and return lines of the docstring(s) for the object."""
2164         if ignore is not None:
2165             warnings.warn("The 'ignore' argument to autodoc.%s.get_doc() is deprecated."
2166                           % self.__class__.__name__,
2167                           RemovedInSphinx50Warning, stacklevel=2)
2168         name = self.objpath[-1]
2169         __slots__ = safe_getattr(self.parent, '__slots__', [])
2170         if isinstance(__slots__, dict) and isinstance(__slots__.get(name), str):
2171             docstring = prepare_docstring(__slots__[name])
2172             return [docstring]
2173         else:
2174             return []
2175 
2176 
2177 def get_documenters(app: Sphinx) -> Dict[str, "Type[Documenter]"]:
2178     """Returns registered Documenter classes"""
2179     warnings.warn("get_documenters() is deprecated.", RemovedInSphinx50Warning, stacklevel=2)
2180     return app.registry.documenters
2181 
2182 
2183 def autodoc_attrgetter(app: Sphinx, obj: Any, name: str, *defargs: Any) -> Any:
2184     """Alternative getattr() for types"""
2185     for typ, func in app.registry.autodoc_attrgettrs.items():
2186         if isinstance(obj, typ):
2187             return func(obj, name, *defargs)
2188 
2189     return safe_getattr(obj, name, *defargs)
2190 
2191 
2192 def migrate_autodoc_member_order(app: Sphinx, config: Config) -> None:
2193     if config.autodoc_member_order == 'alphabetic':
2194         # RemovedInSphinx50Warning
2195         logger.warning(__('autodoc_member_order now accepts "alphabetical" '
2196                           'instead of "alphabetic". Please update your setting.'))
2197         config.autodoc_member_order = 'alphabetical'  # type: ignore
2198 
2199 
2200 def setup(app: Sphinx) -> Dict[str, Any]:
2201     app.add_autodocumenter(ModuleDocumenter)
2202     app.add_autodocumenter(ClassDocumenter)
2203     app.add_autodocumenter(ExceptionDocumenter)
2204     app.add_autodocumenter(DataDocumenter)
2205     app.add_autodocumenter(DataDeclarationDocumenter)
2206     app.add_autodocumenter(GenericAliasDocumenter)
2207     app.add_autodocumenter(TypeVarDocumenter)
2208     app.add_autodocumenter(FunctionDocumenter)
2209     app.add_autodocumenter(DecoratorDocumenter)
2210     app.add_autodocumenter(MethodDocumenter)
2211     app.add_autodocumenter(AttributeDocumenter)
2212     app.add_autodocumenter(PropertyDocumenter)
2213     app.add_autodocumenter(InstanceAttributeDocumenter)
2214     app.add_autodocumenter(SlotsAttributeDocumenter)
2215 
2216     app.add_config_value('autoclass_content', 'class', True, ENUM('both', 'class', 'init'))
2217     app.add_config_value('autodoc_member_order', 'alphabetical', True,
2218                          ENUM('alphabetic', 'alphabetical', 'bysource', 'groupwise'))
2219     app.add_config_value('autodoc_default_options', {}, True)
2220     app.add_config_value('autodoc_docstring_signature', True, True)
2221     app.add_config_value('autodoc_mock_imports', [], True)
2222     app.add_config_value('autodoc_typehints', "signature", True,
2223                          ENUM("signature", "description", "none"))
2224     app.add_config_value('autodoc_warningiserror', True, True)
2225     app.add_config_value('autodoc_inherit_docstrings', True, True)
2226     app.add_event('autodoc-before-process-signature')
2227     app.add_event('autodoc-process-docstring')
2228     app.add_event('autodoc-process-signature')
2229     app.add_event('autodoc-skip-member')
2230 
2231     app.connect('config-inited', migrate_autodoc_member_order, priority=800)
2232 
2233     app.setup_extension('sphinx.ext.autodoc.type_comment')
2234     app.setup_extension('sphinx.ext.autodoc.typehints')
2235 
2236     return {'version': sphinx.__display_version__, 'parallel_read_safe': True}

</code><intended_behavior>If this file or related files within the autodoc extension are contributing to the issue, they should be inspected for how they parse and render doc comments, particularly around generics and inheritance. Modifications might be needed to explicitly handle or better support doc comments on generic class attributes. This could include adjusting parsing logic to correctly interpret field lists within these contexts or providing configuration options that allow users to specify how such comments should be treated. The aim is again to preserve the functionality of automatic documentation generation while ensuring it does not misinterpret or incorrectly format comments, avoiding warnings.</intended_behavior>]
2025-10-18 06:58:57.209 | INFO     | Search completed. Bug locations: [<file>doc/conf.py</file>
<class>None</class>
<method>None</method>
<code>
1 # Sphinx documentation build configuration file
2 
3 import re
4 
5 import sphinx
6 
7 
8 extensions = ['sphinx.ext.autodoc', 'sphinx.ext.doctest', 'sphinx.ext.todo',
9               'sphinx.ext.autosummary', 'sphinx.ext.extlinks',
10               'sphinx.ext.intersphinx',
11               'sphinx.ext.viewcode', 'sphinx.ext.inheritance_diagram']
12 
13 master_doc = 'contents'
14 templates_path = ['_templates']
15 exclude_patterns = ['_build']
16 
17 project = 'Sphinx'
18 copyright = '2007-2020, Georg Brandl and the Sphinx team'
19 version = sphinx.__display_version__
20 release = version
21 show_authors = True
22 
23 html_theme = 'sphinx13'
24 html_theme_path = ['_themes']
25 modindex_common_prefix = ['sphinx.']
26 html_static_path = ['_static']
27 html_sidebars = {'index': ['indexsidebar.html', 'searchbox.html']}
28 html_additional_pages = {'index': 'index.html'}
29 html_use_opensearch = 'https://www.sphinx-doc.org/en/master'
30 html_baseurl = 'https://www.sphinx-doc.org/en/master/'
31 
32 htmlhelp_basename = 'Sphinxdoc'
33 
34 epub_theme = 'epub'
35 epub_basename = 'sphinx'
36 epub_author = 'Georg Brandl'
37 epub_publisher = 'http://sphinx-doc.org/'
38 epub_uid = 'web-site'
39 epub_scheme = 'url'
40 epub_identifier = epub_publisher
41 epub_pre_files = [('index.xhtml', 'Welcome')]
42 epub_post_files = [('usage/installation.xhtml', 'Installing Sphinx'),
43                    ('develop.xhtml', 'Sphinx development')]
44 epub_exclude_files = ['_static/opensearch.xml', '_static/doctools.js',
45                       '_static/jquery.js', '_static/searchtools.js',
46                       '_static/underscore.js', '_static/basic.css',
47                       '_static/language_data.js',
48                       'search.html', '_static/websupport.js']
49 epub_fix_images = False
50 epub_max_image_width = 0
51 epub_show_urls = 'inline'
52 epub_use_index = False
53 epub_guide = (('toc', 'contents.xhtml', 'Table of Contents'),)
54 epub_description = 'Sphinx documentation generator system manual'
55 
56 latex_documents = [('contents', 'sphinx.tex', 'Sphinx Documentation',
57                     'Georg Brandl', 'manual', 1)]
58 latex_logo = '_static/sphinx.png'
59 latex_elements = {
60     'fontenc': r'\usepackage[LGR,X2,T1]{fontenc}',
61     'fontpkg': r'''
62 \usepackage[sc]{mathpazo}
63 \usepackage[scaled]{helvet}
64 \usepackage{courier}
65 \substitutefont{LGR}{\rmdefault}{cmr}
66 \substitutefont{LGR}{\sfdefault}{cmss}
67 \substitutefont{LGR}{\ttdefault}{cmtt}
68 \substitutefont{X2}{\rmdefault}{cmr}
69 \substitutefont{X2}{\sfdefault}{cmss}
70 \substitutefont{X2}{\ttdefault}{cmtt}
71 ''',
72     'passoptionstopackages': '\\PassOptionsToPackage{svgnames}{xcolor}',
73     'preamble': '\\DeclareUnicodeCharacter{229E}{\\ensuremath{\\boxplus}}',
74     'fvset': '\\fvset{fontsize=auto}',
75     # fix missing index entry due to RTD doing only once pdflatex after makeindex
76     'printindex': r'''
77 \IfFileExists{\jobname.ind}
78              {\footnotesize\raggedright\printindex}
79              {\begin{sphinxtheindex}\end{sphinxtheindex}}
80 ''',
81 }
82 latex_show_urls = 'footnote'
83 latex_use_xindy = True
84 
85 autodoc_member_order = 'groupwise'
86 todo_include_todos = True
87 extlinks = {'duref': ('http://docutils.sourceforge.net/docs/ref/rst/'
88                       'restructuredtext.html#%s', ''),
89             'durole': ('http://docutils.sourceforge.net/docs/ref/rst/'
90                        'roles.html#%s', ''),
91             'dudir': ('http://docutils.sourceforge.net/docs/ref/rst/'
92                       'directives.html#%s', '')}
93 
94 man_pages = [
95     ('contents', 'sphinx-all', 'Sphinx documentation generator system manual',
96      'Georg Brandl', 1),
97     ('man/sphinx-build', 'sphinx-build', 'Sphinx documentation generator tool',
98      '', 1),
99     ('man/sphinx-quickstart', 'sphinx-quickstart', 'Sphinx documentation '
100      'template generator', '', 1),
101     ('man/sphinx-apidoc', 'sphinx-apidoc', 'Sphinx API doc generator tool',
102      '', 1),
103     ('man/sphinx-autogen', 'sphinx-autogen', 'Generate autodoc stub pages',
104      '', 1),
105 ]
106 
107 texinfo_documents = [
108     ('contents', 'sphinx', 'Sphinx Documentation', 'Georg Brandl',
109      'Sphinx', 'The Sphinx documentation builder.', 'Documentation tools',
110      1),
111 ]
112 
113 # We're not using intersphinx right now, but if we did, this would be part of
114 # the mapping:
115 intersphinx_mapping = {'python': ('https://docs.python.org/3/', None)}
116 
117 # Sphinx document translation with sphinx gettext feature uses these settings:
118 locale_dirs = ['locale/']
119 gettext_compact = False
120 
121 
122 # -- Extension interface -------------------------------------------------------
123 
124 from sphinx import addnodes  # noqa
125 
126 event_sig_re = re.compile(r'([a-zA-Z-]+)\s*\((.*)\)')
127 
128 
129 def parse_event(env, sig, signode):
130     m = event_sig_re.match(sig)
131     if not m:
132         signode += addnodes.desc_name(sig, sig)
133         return sig
134     name, args = m.groups()
135     signode += addnodes.desc_name(name, name)
136     plist = addnodes.desc_parameterlist()
137     for arg in args.split(','):
138         arg = arg.strip()
139         plist += addnodes.desc_parameter(arg, arg)
140     signode += plist
141     return name
142 
143 
144 def setup(app):
145     from sphinx.ext.autodoc import cut_lines
146     from sphinx.util.docfields import GroupedField
147     app.connect('autodoc-process-docstring', cut_lines(4, what=['module']))
148     app.add_object_type('confval', 'confval',
149                         objname='configuration value',
150                         indextemplate='pair: %s; configuration value')
151     app.add_object_type('setuptools-confval', 'setuptools-confval',
152                         objname='setuptools configuration value',
153                         indextemplate='pair: %s; setuptools configuration value')
154     fdesc = GroupedField('parameter', label='Parameters',
155                          names=['param'], can_collapse=True)
156     app.add_object_type('event', 'event', 'pair: %s; event', parse_event,
157                         doc_field_types=[fdesc])
158 
159     # workaround for RTD
160     from sphinx.util import logging
161     logger = logging.getLogger(__name__)
162     app.info = lambda *args, **kwargs: logger.info(*args, **kwargs)
163     app.warn = lambda *args, **kwargs: logger.warning(*args, **kwargs)
164     app.debug = lambda *args, **kwargs: logger.debug(*args, **kwargs)

</code><intended_behavior>This file should be reviewed and possibly adjusted to ensure it's not contributing to the Sphinx warning regarding field list formatting in doc comments. The configurations, especially those related to extensions like autodoc and autosummary, might need fine-tuning to handle doc comments for generic classes without triggering warnings. Ensure that any custom settings or extensions related to documentation parsing explicitly support or correctly handle the structuring of doc comments on attributes within generic classes. The intended behavior is to maintain existing documentation generation capabilities while eliminating the generation of formatting-related warnings.</intended_behavior>, <file>sphinx/ext/autodoc/__init__.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2     sphinx.ext.autodoc
3     ~~~~~~~~~~~~~~~~~~
4 
5     Automatically insert docstrings for functions, classes or whole modules into
6     the doctree, thus avoiding duplication between docstrings and documentation
7     for those who like elaborate docstrings.
8 
9     :copyright: Copyright 2007-2020 by the Sphinx team, see AUTHORS.
10     :license: BSD, see LICENSE for details.
11 """
12 
13 import importlib
14 import re
15 import warnings
16 from inspect import Parameter, Signature
17 from types import ModuleType
18 from typing import (
19     Any, Callable, Dict, Iterator, List, Optional, Sequence, Set, Tuple, Type, TypeVar, Union
20 )
21 from typing import get_type_hints
22 
23 from docutils.statemachine import StringList
24 
25 import sphinx
26 from sphinx.application import Sphinx
27 from sphinx.config import Config, ENUM
28 from sphinx.deprecation import RemovedInSphinx40Warning, RemovedInSphinx50Warning
29 from sphinx.environment import BuildEnvironment
30 from sphinx.ext.autodoc.importer import import_object, get_module_members, get_object_members
31 from sphinx.ext.autodoc.mock import mock
32 from sphinx.locale import _, __
33 from sphinx.pycode import ModuleAnalyzer, PycodeError
34 from sphinx.util import inspect
35 from sphinx.util import logging
36 from sphinx.util.docstrings import extract_metadata, prepare_docstring
37 from sphinx.util.inspect import (
38     evaluate_signature, getdoc, object_description, safe_getattr, stringify_signature
39 )
40 from sphinx.util.typing import stringify as stringify_typehint
41 
42 if False:
43     # For type annotation
44     from typing import Type  # NOQA # for python3.5.1
45     from sphinx.ext.autodoc.directive import DocumenterBridge
46 
47 
48 logger = logging.getLogger(__name__)
49 
50 
51 # This type isn't exposed directly in any modules, but can be found
52 # here in most Python versions
53 MethodDescriptorType = type(type.__subclasses__)
54 
55 
56 #: extended signature RE: with explicit module name separated by ::
57 py_ext_sig_re = re.compile(
58     r'''^ ([\w.]+::)?            # explicit module name
59           ([\w.]+\.)?            # module and/or class name(s)
60           (\w+)  \s*             # thing name
61           (?: \((.*)\)           # optional: arguments
62            (?:\s* -> \s* (.*))?  #           return annotation
63           )? $                   # and nothing more
64           ''', re.VERBOSE)
65 special_member_re = re.compile(r'^__\S+__$')
66 
67 
68 def identity(x: Any) -> Any:
69     return x
70 
71 
72 class _All:
73     """A special value for :*-members: that matches to any member."""
74 
75     def __contains__(self, item: Any) -> bool:
76         return True
77 
78 
79 class _Empty:
80     """A special value for :exclude-members: that never matches to any member."""
81 
82     def __contains__(self, item: Any) -> bool:
83         return False
84 
85 
86 ALL = _All()
87 EMPTY = _Empty()
88 UNINITIALIZED_ATTR = object()
89 INSTANCEATTR = object()
90 SLOTSATTR = object()
91 
92 
93 def members_option(arg: Any) -> Union[object, List[str]]:
94     """Used to convert the :members: option to auto directives."""
95     if arg is None or arg is True:
96         return ALL
97     elif arg is False:
98         return None
99     else:
100         return [x.strip() for x in arg.split(',') if x.strip()]
101 
102 
103 def members_set_option(arg: Any) -> Union[object, Set[str]]:
104     """Used to convert the :members: option to auto directives."""
105     warnings.warn("members_set_option() is deprecated.",
106                   RemovedInSphinx50Warning, stacklevel=2)
107     if arg is None:
108         return ALL
109     return {x.strip() for x in arg.split(',') if x.strip()}
110 
111 
112 def exclude_members_option(arg: Any) -> Union[object, Set[str]]:
113     """Used to convert the :exclude-members: option."""
114     if arg is None:
115         return EMPTY
116     return {x.strip() for x in arg.split(',') if x.strip()}
117 
118 
119 def inherited_members_option(arg: Any) -> Union[object, Set[str]]:
120     """Used to convert the :members: option to auto directives."""
121     if arg is None:
122         return 'object'
123     else:
124         return arg
125 
126 
127 def member_order_option(arg: Any) -> Optional[str]:
128     """Used to convert the :members: option to auto directives."""
129     if arg is None:
130         return None
131     elif arg in ('alphabetical', 'bysource', 'groupwise'):
132         return arg
133     else:
134         raise ValueError(__('invalid value for member-order option: %s') % arg)
135 
136 
137 SUPPRESS = object()
138 
139 
140 def annotation_option(arg: Any) -> Any:
141     if arg is None:
142         # suppress showing the representation of the object
143         return SUPPRESS
144     else:
145         return arg
146 
147 
148 def bool_option(arg: Any) -> bool:
149     """Used to convert flag options to auto directives.  (Instead of
150     directives.flag(), which returns None).
151     """
152     return True
153 
154 
155 def merge_special_members_option(options: Dict) -> None:
156     """Merge :special-members: option to :members: option."""
157     warnings.warn("merge_special_members_option() is deprecated.",
158                   RemovedInSphinx50Warning, stacklevel=2)
159     if 'special-members' in options and options['special-members'] is not ALL:
160         if options.get('members') is ALL:
161             pass
162         elif options.get('members'):
163             for member in options['special-members']:
164                 if member not in options['members']:
165                     options['members'].append(member)
166         else:
167             options['members'] = options['special-members']
168 
169 
170 def merge_members_option(options: Dict) -> None:
171     """Merge :*-members: option to the :members: option."""
172     if options.get('members') is ALL:
173         # merging is not needed when members: ALL
174         return
175 
176     members = options.setdefault('members', [])
177     for key in {'private-members', 'special-members'}:
178         if key in options and options[key] not in (ALL, None):
179             for member in options[key]:
180                 if member not in members:
181                     members.append(member)
182 
183 
184 # Some useful event listener factories for autodoc-process-docstring.
185 
186 def cut_lines(pre: int, post: int = 0, what: str = None) -> Callable:
187     """Return a listener that removes the first *pre* and last *post*
188     lines of every docstring.  If *what* is a sequence of strings,
189     only docstrings of a type in *what* will be processed.
190 
191     Use like this (e.g. in the ``setup()`` function of :file:`conf.py`)::
192 
193        from sphinx.ext.autodoc import cut_lines
194        app.connect('autodoc-process-docstring', cut_lines(4, what=['module']))
195 
196     This can (and should) be used in place of :confval:`automodule_skip_lines`.
197     """
198     def process(app: Sphinx, what_: str, name: str, obj: Any, options: Any, lines: List[str]
199                 ) -> None:
200         if what and what_ not in what:
201             return
202         del lines[:pre]
203         if post:
204             # remove one trailing blank line.
205             if lines and not lines[-1]:
206                 lines.pop(-1)
207             del lines[-post:]
208         # make sure there is a blank line at the end
209         if lines and lines[-1]:
210             lines.append('')
211     return process
212 
213 
214 def between(marker: str, what: Sequence[str] = None, keepempty: bool = False,
215             exclude: bool = False) -> Callable:
216     """Return a listener that either keeps, or if *exclude* is True excludes,
217     lines between lines that match the *marker* regular expression.  If no line
218     matches, the resulting docstring would be empty, so no change will be made
219     unless *keepempty* is true.
220 
221     If *what* is a sequence of strings, only docstrings of a type in *what* will
222     be processed.
223     """
224     marker_re = re.compile(marker)
225 
226     def process(app: Sphinx, what_: str, name: str, obj: Any, options: Any, lines: List[str]
227                 ) -> None:
228         if what and what_ not in what:
229             return
230         deleted = 0
231         delete = not exclude
232         orig_lines = lines[:]
233         for i, line in enumerate(orig_lines):
234             if delete:
235                 lines.pop(i - deleted)
236                 deleted += 1
237             if marker_re.match(line):
238                 delete = not delete
239                 if delete:
240                     lines.pop(i - deleted)
241                     deleted += 1
242         if not lines and not keepempty:
243             lines[:] = orig_lines
244         # make sure there is a blank line at the end
245         if lines and lines[-1]:
246             lines.append('')
247     return process
248 
249 
250 # This class is used only in ``sphinx.ext.autodoc.directive``,
251 # But we define this class here to keep compatibility (see #4538)
252 class Options(dict):
253     """A dict/attribute hybrid that returns None on nonexisting keys."""
254     def __getattr__(self, name: str) -> Any:
255         try:
256             return self[name.replace('_', '-')]
257         except KeyError:
258             return None
259 
260 
261 class Documenter:
262     """
263     A Documenter knows how to autodocument a single object type.  When
264     registered with the AutoDirective, it will be used to document objects
265     of that type when needed by autodoc.
266 
267     Its *objtype* attribute selects what auto directive it is assigned to
268     (the directive name is 'auto' + objtype), and what directive it generates
269     by default, though that can be overridden by an attribute called
270     *directivetype*.
271 
272     A Documenter has an *option_spec* that works like a docutils directive's;
273     in fact, it will be used to parse an auto directive's options that matches
274     the documenter.
275     """
276     #: name by which the directive is called (auto...) and the default
277     #: generated directive name
278     objtype = 'object'
279     #: indentation by which to indent the directive content
280     content_indent = '   '
281     #: priority if multiple documenters return True from can_document_member
282     priority = 0
283     #: order if autodoc_member_order is set to 'groupwise'
284     member_order = 0
285     #: true if the generated content may contain titles
286     titles_allowed = False
287 
288     option_spec = {'noindex': bool_option}  # type: Dict[str, Callable]
289 
290     def get_attr(self, obj: Any, name: str, *defargs: Any) -> Any:
291         """getattr() override for types such as Zope interfaces."""
292         return autodoc_attrgetter(self.env.app, obj, name, *defargs)
293 
294     @classmethod
295     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
296                             ) -> bool:
297         """Called to see if a member can be documented by this documenter."""
298         raise NotImplementedError('must be implemented in subclasses')
299 
300     def __init__(self, directive: "DocumenterBridge", name: str, indent: str = '') -> None:
301         self.directive = directive
302         self.env = directive.env    # type: BuildEnvironment
303         self.options = directive.genopt
304         self.name = name
305         self.indent = indent
306         # the module and object path within the module, and the fully
307         # qualified name (all set after resolve_name succeeds)
308         self.modname = None         # type: str
309         self.module = None          # type: ModuleType
310         self.objpath = None         # type: List[str]
311         self.fullname = None        # type: str
312         # extra signature items (arguments and return annotation,
313         # also set after resolve_name succeeds)
314         self.args = None            # type: str
315         self.retann = None          # type: str
316         # the object to document (set after import_object succeeds)
317         self.object = None          # type: Any
318         self.object_name = None     # type: str
319         # the parent/owner of the object to document
320         self.parent = None          # type: Any
321         # the module analyzer to get at attribute docs, or None
322         self.analyzer = None        # type: ModuleAnalyzer
323 
324     @property
325     def documenters(self) -> Dict[str, "Type[Documenter]"]:
326         """Returns registered Documenter classes"""
327         return self.env.app.registry.documenters
328 
329     def add_line(self, line: str, source: str, *lineno: int) -> None:
330         """Append one line of generated reST to the output."""
331         if line.strip():  # not a blank line
332             self.directive.result.append(self.indent + line, source, *lineno)
333         else:
334             self.directive.result.append('', source, *lineno)
335 
336     def resolve_name(self, modname: str, parents: Any, path: str, base: Any
337                      ) -> Tuple[str, List[str]]:
338         """Resolve the module and name of the object to document given by the
339         arguments and the current module/class.
340 
341         Must return a pair of the module name and a chain of attributes; for
342         example, it would return ``('zipfile', ['ZipFile', 'open'])`` for the
343         ``zipfile.ZipFile.open`` method.
344         """
345         raise NotImplementedError('must be implemented in subclasses')
346 
347     def parse_name(self) -> bool:
348         """Determine what module to import and what attribute to document.
349 
350         Returns True and sets *self.modname*, *self.objpath*, *self.fullname*,
351         *self.args* and *self.retann* if parsing and resolving was successful.
352         """
353         # first, parse the definition -- auto directives for classes and
354         # functions can contain a signature which is then used instead of
355         # an autogenerated one
356         try:
357             explicit_modname, path, base, args, retann = \
358                 py_ext_sig_re.match(self.name).groups()
359         except AttributeError:
360             logger.warning(__('invalid signature for auto%s (%r)') % (self.objtype, self.name),
361                            type='autodoc')
362             return False
363 
364         # support explicit module and class name separation via ::
365         if explicit_modname is not None:
366             modname = explicit_modname[:-2]
367             parents = path.rstrip('.').split('.') if path else []
368         else:
369             modname = None
370             parents = []
371 
372         with mock(self.env.config.autodoc_mock_imports):
373             self.modname, self.objpath = self.resolve_name(modname, parents, path, base)
374 
375         if not self.modname:
376             return False
377 
378         self.args = args
379         self.retann = retann
380         self.fullname = (self.modname or '') + \
381                         ('.' + '.'.join(self.objpath) if self.objpath else '')
382         return True
383 
384     def import_object(self, raiseerror: bool = False) -> bool:
385         """Import the object given by *self.modname* and *self.objpath* and set
386         it as *self.object*.
387 
388         Returns True if successful, False if an error occurred.
389         """
390         with mock(self.env.config.autodoc_mock_imports):
391             try:
392                 ret = import_object(self.modname, self.objpath, self.objtype,
393                                     attrgetter=self.get_attr,
394                                     warningiserror=self.env.config.autodoc_warningiserror)
395                 self.module, self.parent, self.object_name, self.object = ret
396                 return True
397             except ImportError as exc:
398                 if raiseerror:
399                     raise
400                 else:
401                     logger.warning(exc.args[0], type='autodoc', subtype='import_object')
402                     self.env.note_reread()
403                     return False
404 
405     def get_real_modname(self) -> str:
406         """Get the real module name of an object to document.
407 
408         It can differ from the name of the module through which the object was
409         imported.
410         """
411         return self.get_attr(self.object, '__module__', None) or self.modname
412 
413     def check_module(self) -> bool:
414         """Check if *self.object* is really defined in the module given by
415         *self.modname*.
416         """
417         if self.options.imported_members:
418             return True
419 
420         subject = inspect.unpartial(self.object)
421         modname = self.get_attr(subject, '__module__', None)
422         if modname and modname != self.modname:
423             return False
424         return True
425 
426     def format_args(self, **kwargs: Any) -> str:
427         """Format the argument signature of *self.object*.
428 
429         Should return None if the object does not have a signature.
430         """
431         return None
432 
433     def format_name(self) -> str:
434         """Format the name of *self.object*.
435 
436         This normally should be something that can be parsed by the generated
437         directive, but doesn't need to be (Sphinx will display it unparsed
438         then).
439         """
440         # normally the name doesn't contain the module (except for module
441         # directives of course)
442         return '.'.join(self.objpath) or self.modname
443 
444     def _call_format_args(self, **kwargs: Any) -> str:
445         if kwargs:
446             try:
447                 return self.format_args(**kwargs)
448             except TypeError:
449                 # avoid chaining exceptions, by putting nothing here
450                 pass
451 
452         # retry without arguments for old documenters
453         return self.format_args()
454 
455     def format_signature(self, **kwargs: Any) -> str:
456         """Format the signature (arguments and return annotation) of the object.
457 
458         Let the user process it via the ``autodoc-process-signature`` event.
459         """
460         if self.args is not None:
461             # signature given explicitly
462             args = "(%s)" % self.args
463             retann = self.retann
464         else:
465             # try to introspect the signature
466             try:
467                 retann = None
468                 args = self._call_format_args(**kwargs)
469                 if args:
470                     matched = re.match(r'^(\(.*\))\s+->\s+(.*)$', args)
471                     if matched:
472                         args = matched.group(1)
473                         retann = matched.group(2)
474             except Exception as exc:
475                 logger.warning(__('error while formatting arguments for %s: %s'),
476                                self.fullname, exc, type='autodoc')
477                 args = None
478 
479         result = self.env.events.emit_firstresult('autodoc-process-signature',
480                                                   self.objtype, self.fullname,
481                                                   self.object, self.options, args, retann)
482         if result:
483             args, retann = result
484 
485         if args is not None:
486             return args + ((' -> %s' % retann) if retann else '')
487         else:
488             return ''
489 
490     def add_directive_header(self, sig: str) -> None:
491         """Add the directive header and options to the generated content."""
492         domain = getattr(self, 'domain', 'py')
493         directive = getattr(self, 'directivetype', self.objtype)
494         name = self.format_name()
495         sourcename = self.get_sourcename()
496 
497         # one signature per line, indented by column
498         prefix = '.. %s:%s:: ' % (domain, directive)
499         for i, sig_line in enumerate(sig.split("\n")):
500             self.add_line('%s%s%s' % (prefix, name, sig_line),
501                           sourcename)
502             if i == 0:
503                 prefix = " " * len(prefix)
504 
505         if self.options.noindex:
506             self.add_line('   :noindex:', sourcename)
507         if self.objpath:
508             # Be explicit about the module, this is necessary since .. class::
509             # etc. don't support a prepended module name
510             self.add_line('   :module: %s' % self.modname, sourcename)
511 
512     def get_doc(self, encoding: str = None, ignore: int = None) -> List[List[str]]:
513         """Decode and return lines of the docstring(s) for the object."""
514         if encoding is not None:
515             warnings.warn("The 'encoding' argument to autodoc.%s.get_doc() is deprecated."
516                           % self.__class__.__name__,
517                           RemovedInSphinx40Warning, stacklevel=2)
518         if ignore is not None:
519             warnings.warn("The 'ignore' argument to autodoc.%s.get_doc() is deprecated."
520                           % self.__class__.__name__,
521                           RemovedInSphinx50Warning, stacklevel=2)
522         docstring = getdoc(self.object, self.get_attr,
523                            self.env.config.autodoc_inherit_docstrings,
524                            self.parent, self.object_name)
525         if docstring:
526             tab_width = self.directive.state.document.settings.tab_width
527             return [prepare_docstring(docstring, ignore, tab_width)]
528         return []
529 
530     def process_doc(self, docstrings: List[List[str]]) -> Iterator[str]:
531         """Let the user process the docstrings before adding them."""
532         for docstringlines in docstrings:
533             if self.env.app:
534                 # let extensions preprocess docstrings
535                 self.env.app.emit('autodoc-process-docstring',
536                                   self.objtype, self.fullname, self.object,
537                                   self.options, docstringlines)
538             yield from docstringlines
539 
540     def get_sourcename(self) -> str:
541         if self.analyzer:
542             return '%s:docstring of %s' % (self.analyzer.srcname, self.fullname)
543         return 'docstring of %s' % self.fullname
544 
545     def add_content(self, more_content: Any, no_docstring: bool = False) -> None:
546         """Add content from docstrings, attribute documentation and user."""
547         # set sourcename and add content from attribute documentation
548         sourcename = self.get_sourcename()
549         if self.analyzer:
550             attr_docs = self.analyzer.find_attr_docs()
551             if self.objpath:
552                 key = ('.'.join(self.objpath[:-1]), self.objpath[-1])
553                 if key in attr_docs:
554                     no_docstring = True
555                     # make a copy of docstring for attributes to avoid cache
556                     # the change of autodoc-process-docstring event.
557                     docstrings = [list(attr_docs[key])]
558 
559                     for i, line in enumerate(self.process_doc(docstrings)):
560                         self.add_line(line, sourcename, i)
561 
562         # add content from docstrings
563         if not no_docstring:
564             docstrings = self.get_doc()
565             if not docstrings:
566                 # append at least a dummy docstring, so that the event
567                 # autodoc-process-docstring is fired and can add some
568                 # content if desired
569                 docstrings.append([])
570             for i, line in enumerate(self.process_doc(docstrings)):
571                 self.add_line(line, sourcename, i)
572 
573         # add additional content (e.g. from document), if present
574         if more_content:
575             for line, src in zip(more_content.data, more_content.items):
576                 self.add_line(line, src[0], src[1])
577 
578     def get_object_members(self, want_all: bool) -> Tuple[bool, List[Tuple[str, Any]]]:
579         """Return `(members_check_module, members)` where `members` is a
580         list of `(membername, member)` pairs of the members of *self.object*.
581 
582         If *want_all* is True, return all members.  Else, only return those
583         members given by *self.options.members* (which may also be none).
584         """
585         members = get_object_members(self.object, self.objpath, self.get_attr, self.analyzer)
586         if not want_all:
587             if not self.options.members:
588                 return False, []
589             # specific members given
590             selected = []
591             for name in self.options.members:
592                 if name in members:
593                     selected.append((name, members[name].value))
594                 else:
595                     logger.warning(__('missing attribute %s in object %s') %
596                                    (name, self.fullname), type='autodoc')
597             return False, selected
598         elif self.options.inherited_members:
599             return False, [(m.name, m.value) for m in members.values()]
600         else:
601             return False, [(m.name, m.value) for m in members.values()
602                            if m.directly_defined]
603 
604     def filter_members(self, members: List[Tuple[str, Any]], want_all: bool
605                        ) -> List[Tuple[str, Any, bool]]:
606         """Filter the given member list.
607 
608         Members are skipped if
609 
610         - they are private (except if given explicitly or the private-members
611           option is set)
612         - they are special methods (except if given explicitly or the
613           special-members option is set)
614         - they are undocumented (except if the undoc-members option is set)
615 
616         The user can override the skipping decision by connecting to the
617         ``autodoc-skip-member`` event.
618         """
619         def is_filtered_inherited_member(name: str) -> bool:
620             if inspect.isclass(self.object):
621                 for cls in self.object.__mro__:
622                     if cls.__name__ == self.options.inherited_members and cls != self.object:
623                         # given member is a member of specified *super class*
624                         return True
625                     elif name in cls.__dict__:
626                         return False
627                     elif name in self.get_attr(cls, '__annotations__', {}):
628                         return False
629 
630             return False
631 
632         ret = []
633 
634         # search for members in source code too
635         namespace = '.'.join(self.objpath)  # will be empty for modules
636 
637         if self.analyzer:
638             attr_docs = self.analyzer.find_attr_docs()
639         else:
640             attr_docs = {}
641 
642         # process members and determine which to skip
643         for (membername, member) in members:
644             # if isattr is True, the member is documented as an attribute
645             if member is INSTANCEATTR:
646                 isattr = True
647             else:
648                 isattr = False
649 
650             doc = getdoc(member, self.get_attr, self.env.config.autodoc_inherit_docstrings,
651                          self.parent, self.object_name)
652             if not isinstance(doc, str):
653                 # Ignore non-string __doc__
654                 doc = None
655 
656             # if the member __doc__ is the same as self's __doc__, it's just
657             # inherited and therefore not the member's doc
658             cls = self.get_attr(member, '__class__', None)
659             if cls:
660                 cls_doc = self.get_attr(cls, '__doc__', None)
661                 if cls_doc == doc:
662                     doc = None
663             has_doc = bool(doc)
664 
665             metadata = extract_metadata(doc)
666             if 'private' in metadata:
667                 # consider a member private if docstring has "private" metadata
668                 isprivate = True
669             elif 'public' in metadata:
670                 # consider a member public if docstring has "public" metadata
671                 isprivate = False
672             else:
673                 isprivate = membername.startswith('_')
674 
675             keep = False
676             if safe_getattr(member, '__sphinx_mock__', False):
677                 # mocked module or object
678                 pass
679             elif self.options.exclude_members and membername in self.options.exclude_members:
680                 # remove members given by exclude-members
681                 keep = False
682             elif want_all and special_member_re.match(membername):
683                 # special __methods__
684                 if self.options.special_members and membername in self.options.special_members:
685                     if membername == '__doc__':
686                         keep = False
687                     elif is_filtered_inherited_member(membername):
688                         keep = False
689                     else:
690                         keep = has_doc or self.options.undoc_members
691                 else:
692                     keep = False
693             elif (namespace, membername) in attr_docs:
694                 if want_all and isprivate:
695                     if self.options.private_members is None:
696                         keep = False
697                     else:
698                         keep = membername in self.options.private_members
699                 else:
700                     # keep documented attributes
701                     keep = True
702                 isattr = True
703             elif want_all and isprivate:
704                 if has_doc or self.options.undoc_members:
705                     if self.options.private_members is None:
706                         keep = False
707                     elif is_filtered_inherited_member(membername):
708                         keep = False
709                     else:
710                         keep = membername in self.options.private_members
711                 else:
712                     keep = False
713             else:
714                 if self.options.members is ALL and is_filtered_inherited_member(membername):
715                     keep = False
716                 else:
717                     # ignore undocumented members if :undoc-members: is not given
718                     keep = has_doc or self.options.undoc_members
719 
720             # give the user a chance to decide whether this member
721             # should be skipped
722             if self.env.app:
723                 # let extensions preprocess docstrings
724                 try:
725                     skip_user = self.env.app.emit_firstresult(
726                         'autodoc-skip-member', self.objtype, membername, member,
727                         not keep, self.options)
728                     if skip_user is not None:
729                         keep = not skip_user
730                 except Exception as exc:
731                     logger.warning(__('autodoc: failed to determine %r to be documented, '
732                                       'the following exception was raised:\n%s'),
733                                    member, exc, type='autodoc')
734                     keep = False
735 
736             if keep:
737                 ret.append((membername, member, isattr))
738 
739         return ret
740 
741     def document_members(self, all_members: bool = False) -> None:
742         """Generate reST for member documentation.
743 
744         If *all_members* is True, do all members, else those given by
745         *self.options.members*.
746         """
747         # set current namespace for finding members
748         self.env.temp_data['autodoc:module'] = self.modname
749         if self.objpath:
750             self.env.temp_data['autodoc:class'] = self.objpath[0]
751 
752         want_all = all_members or self.options.inherited_members or \
753             self.options.members is ALL
754         # find out which members are documentable
755         members_check_module, members = self.get_object_members(want_all)
756 
757         # document non-skipped members
758         memberdocumenters = []  # type: List[Tuple[Documenter, bool]]
759         for (mname, member, isattr) in self.filter_members(members, want_all):
760             classes = [cls for cls in self.documenters.values()
761                        if cls.can_document_member(member, mname, isattr, self)]
762             if not classes:
763                 # don't know how to document this member
764                 continue
765             # prefer the documenter with the highest priority
766             classes.sort(key=lambda cls: cls.priority)
767             # give explicitly separated module name, so that members
768             # of inner classes can be documented
769             full_mname = self.modname + '::' + \
770                 '.'.join(self.objpath + [mname])
771             documenter = classes[-1](self.directive, full_mname, self.indent)
772             memberdocumenters.append((documenter, isattr))
773 
774         member_order = self.options.member_order or self.env.config.autodoc_member_order
775         memberdocumenters = self.sort_members(memberdocumenters, member_order)
776 
777         for documenter, isattr in memberdocumenters:
778             documenter.generate(
779                 all_members=True, real_modname=self.real_modname,
780                 check_module=members_check_module and not isattr)
781 
782         # reset current objects
783         self.env.temp_data['autodoc:module'] = None
784         self.env.temp_data['autodoc:class'] = None
785 
786     def sort_members(self, documenters: List[Tuple["Documenter", bool]],
787                      order: str) -> List[Tuple["Documenter", bool]]:
788         """Sort the given member list."""
789         if order == 'groupwise':
790             # sort by group; alphabetically within groups
791             documenters.sort(key=lambda e: (e[0].member_order, e[0].name))
792         elif order == 'bysource':
793             if self.analyzer:
794                 # sort by source order, by virtue of the module analyzer
795                 tagorder = self.analyzer.tagorder
796 
797                 def keyfunc(entry: Tuple[Documenter, bool]) -> int:
798                     fullname = entry[0].name.split('::')[1]
799                     return tagorder.get(fullname, len(tagorder))
800                 documenters.sort(key=keyfunc)
801             else:
802                 # Assume that member discovery order matches source order.
803                 # This is a reasonable assumption in Python 3.6 and up, where
804                 # module.__dict__ is insertion-ordered.
805                 pass
806         else:  # alphabetical
807             documenters.sort(key=lambda e: e[0].name)
808 
809         return documenters
810 
811     def generate(self, more_content: Any = None, real_modname: str = None,
812                  check_module: bool = False, all_members: bool = False) -> None:
813         """Generate reST for the object given by *self.name*, and possibly for
814         its members.
815 
816         If *more_content* is given, include that content. If *real_modname* is
817         given, use that module name to find attribute docs. If *check_module* is
818         True, only generate if the object is defined in the module name it is
819         imported from. If *all_members* is True, document all members.
820         """
821         if not self.parse_name():
822             # need a module to import
823             logger.warning(
824                 __('don\'t know which module to import for autodocumenting '
825                    '%r (try placing a "module" or "currentmodule" directive '
826                    'in the document, or giving an explicit module name)') %
827                 self.name, type='autodoc')
828             return
829 
830         # now, import the module and get object to document
831         if not self.import_object():
832             return
833 
834         # If there is no real module defined, figure out which to use.
835         # The real module is used in the module analyzer to look up the module
836         # where the attribute documentation would actually be found in.
837         # This is used for situations where you have a module that collects the
838         # functions and classes of internal submodules.
839         guess_modname = self.get_real_modname()
840         self.real_modname = real_modname or guess_modname
841 
842         # try to also get a source code analyzer for attribute docs
843         try:
844             self.analyzer = ModuleAnalyzer.for_module(self.real_modname)
845             # parse right now, to get PycodeErrors on parsing (results will
846             # be cached anyway)
847             self.analyzer.find_attr_docs()
848         except PycodeError as exc:
849             logger.debug('[autodoc] module analyzer failed: %s', exc)
850             # no source file -- e.g. for builtin and C modules
851             self.analyzer = None
852             # at least add the module.__file__ as a dependency
853             if hasattr(self.module, '__file__') and self.module.__file__:
854                 self.directive.filename_set.add(self.module.__file__)
855         else:
856             self.directive.filename_set.add(self.analyzer.srcname)
857 
858         if self.real_modname != guess_modname:
859             # Add module to dependency list if target object is defined in other module.
860             try:
861                 analyzer = ModuleAnalyzer.for_module(guess_modname)
862                 self.directive.filename_set.add(analyzer.srcname)
863             except PycodeError:
864                 pass
865 
866         # check __module__ of object (for members not given explicitly)
867         if check_module:
868             if not self.check_module():
869                 return
870 
871         sourcename = self.get_sourcename()
872 
873         # make sure that the result starts with an empty line.  This is
874         # necessary for some situations where another directive preprocesses
875         # reST and no starting newline is present
876         self.add_line('', sourcename)
877 
878         # format the object's signature, if any
879         try:
880             sig = self.format_signature()
881         except Exception as exc:
882             logger.warning(__('error while formatting signature for %s: %s'),
883                            self.fullname, exc, type='autodoc')
884             return
885 
886         # generate the directive header and options, if applicable
887         self.add_directive_header(sig)
888         self.add_line('', sourcename)
889 
890         # e.g. the module directive doesn't have content
891         self.indent += self.content_indent
892 
893         # add all content (from docstrings, attribute docs etc.)
894         self.add_content(more_content)
895 
896         # document members, if possible
897         self.document_members(all_members)
898 
899 
900 class ModuleDocumenter(Documenter):
901     """
902     Specialized Documenter subclass for modules.
903     """
904     objtype = 'module'
905     content_indent = ''
906     titles_allowed = True
907 
908     option_spec = {
909         'members': members_option, 'undoc-members': bool_option,
910         'noindex': bool_option, 'inherited-members': inherited_members_option,
911         'show-inheritance': bool_option, 'synopsis': identity,
912         'platform': identity, 'deprecated': bool_option,
913         'member-order': member_order_option, 'exclude-members': exclude_members_option,
914         'private-members': members_option, 'special-members': members_option,
915         'imported-members': bool_option, 'ignore-module-all': bool_option
916     }  # type: Dict[str, Callable]
917 
918     def __init__(self, *args: Any) -> None:
919         super().__init__(*args)
920         merge_members_option(self.options)
921         self.__all__ = None
922 
923     @classmethod
924     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
925                             ) -> bool:
926         # don't document submodules automatically
927         return False
928 
929     def resolve_name(self, modname: str, parents: Any, path: str, base: Any
930                      ) -> Tuple[str, List[str]]:
931         if modname is not None:
932             logger.warning(__('"::" in automodule name doesn\'t make sense'),
933                            type='autodoc')
934         return (path or '') + base, []
935 
936     def parse_name(self) -> bool:
937         ret = super().parse_name()
938         if self.args or self.retann:
939             logger.warning(__('signature arguments or return annotation '
940                               'given for automodule %s') % self.fullname,
941                            type='autodoc')
942         return ret
943 
944     def import_object(self, raiseerror: bool = False) -> bool:
945         def is_valid_module_all(__all__: Any) -> bool:
946             """Check the given *__all__* is valid for a module."""
947             if (isinstance(__all__, (list, tuple)) and
948                     all(isinstance(e, str) for e in __all__)):
949                 return True
950             else:
951                 return False
952 
953         ret = super().import_object(raiseerror)
954 
955         if not self.options.ignore_module_all:
956             __all__ = getattr(self.object, '__all__', None)
957             if is_valid_module_all(__all__):
958                 # valid __all__ found. copy it to self.__all__
959                 self.__all__ = __all__
960             elif __all__:
961                 # invalid __all__ found.
962                 logger.warning(__('__all__ should be a list of strings, not %r '
963                                   '(in module %s) -- ignoring __all__') %
964                                (__all__, self.fullname), type='autodoc')
965 
966         return ret
967 
968     def add_directive_header(self, sig: str) -> None:
969         Documenter.add_directive_header(self, sig)
970 
971         sourcename = self.get_sourcename()
972 
973         # add some module-specific options
974         if self.options.synopsis:
975             self.add_line('   :synopsis: ' + self.options.synopsis, sourcename)
976         if self.options.platform:
977             self.add_line('   :platform: ' + self.options.platform, sourcename)
978         if self.options.deprecated:
979             self.add_line('   :deprecated:', sourcename)
980 
981     def get_object_members(self, want_all: bool) -> Tuple[bool, List[Tuple[str, Any]]]:
982         if want_all:
983             if self.__all__:
984                 memberlist = self.__all__
985             else:
986                 # for implicit module members, check __module__ to avoid
987                 # documenting imported objects
988                 return True, get_module_members(self.object)
989         else:
990             memberlist = self.options.members or []
991         ret = []
992         for mname in memberlist:
993             try:
994                 ret.append((mname, safe_getattr(self.object, mname)))
995             except AttributeError:
996                 logger.warning(
997                     __('missing attribute mentioned in :members: or __all__: '
998                        'module %s, attribute %s') %
999                     (safe_getattr(self.object, '__name__', '???'), mname),
1000                     type='autodoc'
1001                 )
1002         return False, ret
1003 
1004     def sort_members(self, documenters: List[Tuple["Documenter", bool]],
1005                      order: str) -> List[Tuple["Documenter", bool]]:
1006         if order == 'bysource' and self.__all__:
1007             # Sort alphabetically first (for members not listed on the __all__)
1008             documenters.sort(key=lambda e: e[0].name)
1009 
1010             # Sort by __all__
1011             def keyfunc(entry: Tuple[Documenter, bool]) -> int:
1012                 name = entry[0].name.split('::')[1]
1013                 if name in self.__all__:
1014                     return self.__all__.index(name)
1015                 else:
1016                     return len(self.__all__)
1017             documenters.sort(key=keyfunc)
1018 
1019             return documenters
1020         else:
1021             return super().sort_members(documenters, order)
1022 
1023 
1024 class ModuleLevelDocumenter(Documenter):
1025     """
1026     Specialized Documenter subclass for objects on module level (functions,
1027     classes, data/constants).
1028     """
1029     def resolve_name(self, modname: str, parents: Any, path: str, base: Any
1030                      ) -> Tuple[str, List[str]]:
1031         if modname is None:
1032             if path:
1033                 modname = path.rstrip('.')
1034             else:
1035                 # if documenting a toplevel object without explicit module,
1036                 # it can be contained in another auto directive ...
1037                 modname = self.env.temp_data.get('autodoc:module')
1038                 # ... or in the scope of a module directive
1039                 if not modname:
1040                     modname = self.env.ref_context.get('py:module')
1041                 # ... else, it stays None, which means invalid
1042         return modname, parents + [base]
1043 
1044 
1045 class ClassLevelDocumenter(Documenter):
1046     """
1047     Specialized Documenter subclass for objects on class level (methods,
1048     attributes).
1049     """
1050     def resolve_name(self, modname: str, parents: Any, path: str, base: Any
1051                      ) -> Tuple[str, List[str]]:
1052         if modname is None:
1053             if path:
1054                 mod_cls = path.rstrip('.')
1055             else:
1056                 mod_cls = None
1057                 # if documenting a class-level object without path,
1058                 # there must be a current class, either from a parent
1059                 # auto directive ...
1060                 mod_cls = self.env.temp_data.get('autodoc:class')
1061                 # ... or from a class directive
1062                 if mod_cls is None:
1063                     mod_cls = self.env.ref_context.get('py:class')
1064                 # ... if still None, there's no way to know
1065                 if mod_cls is None:
1066                     return None, []
1067             modname, sep, cls = mod_cls.rpartition('.')
1068             parents = [cls]
1069             # if the module name is still missing, get it like above
1070             if not modname:
1071                 modname = self.env.temp_data.get('autodoc:module')
1072             if not modname:
1073                 modname = self.env.ref_context.get('py:module')
1074             # ... else, it stays None, which means invalid
1075         return modname, parents + [base]
1076 
1077 
1078 class DocstringSignatureMixin:
1079     """
1080     Mixin for FunctionDocumenter and MethodDocumenter to provide the
1081     feature of reading the signature from the docstring.
1082     """
1083     _new_docstrings = None  # type: List[List[str]]
1084     _signatures = None      # type: List[str]
1085 
1086     def _find_signature(self, encoding: str = None) -> Tuple[str, str]:
1087         if encoding is not None:
1088             warnings.warn("The 'encoding' argument to autodoc.%s._find_signature() is "
1089                           "deprecated." % self.__class__.__name__,
1090                           RemovedInSphinx40Warning, stacklevel=2)
1091 
1092         # candidates of the object name
1093         valid_names = [self.objpath[-1]]  # type: ignore
1094         if isinstance(self, ClassDocumenter):
1095             valid_names.append('__init__')
1096             if hasattr(self.object, '__mro__'):
1097                 valid_names.extend(cls.__name__ for cls in self.object.__mro__)
1098 
1099         docstrings = self.get_doc()
1100         self._new_docstrings = docstrings[:]
1101         self._signatures = []
1102         result = None
1103         for i, doclines in enumerate(docstrings):
1104             for j, line in enumerate(doclines):
1105                 if not line:
1106                     # no lines in docstring, no match
1107                     break
1108 
1109                 if line.endswith('\\'):
1110                     multiline = True
1111                     line = line.rstrip('\\').rstrip()
1112                 else:
1113                     multiline = False
1114 
1115                 # match first line of docstring against signature RE
1116                 match = py_ext_sig_re.match(line)
1117                 if not match:
1118                     continue
1119                 exmod, path, base, args, retann = match.groups()
1120 
1121                 # the base name must match ours
1122                 if base not in valid_names:
1123                     continue
1124 
1125                 # re-prepare docstring to ignore more leading indentation
1126                 tab_width = self.directive.state.document.settings.tab_width  # type: ignore
1127                 self._new_docstrings[i] = prepare_docstring('\n'.join(doclines[j + 1:]),
1128                                                             tabsize=tab_width)
1129 
1130                 if result is None:
1131                     # first signature
1132                     result = args, retann
1133                 else:
1134                     # subsequent signatures
1135                     self._signatures.append("(%s) -> %s" % (args, retann))
1136 
1137                 if multiline:
1138                     # the signature have multiple signatures on docstring
1139                     continue
1140                 else:
1141                     # don't look any further
1142                     break
1143 
1144             if result:
1145                 # finish the loop when signature found
1146                 break
1147 
1148         return result
1149 
1150     def get_doc(self, encoding: str = None, ignore: int = None) -> List[List[str]]:
1151         if encoding is not None:
1152             warnings.warn("The 'encoding' argument to autodoc.%s.get_doc() is deprecated."
1153                           % self.__class__.__name__,
1154                           RemovedInSphinx40Warning, stacklevel=2)
1155         if self._new_docstrings is not None:
1156             return self._new_docstrings
1157         return super().get_doc(None, ignore)  # type: ignore
1158 
1159     def format_signature(self, **kwargs: Any) -> str:
1160         if self.args is None and self.env.config.autodoc_docstring_signature:  # type: ignore
1161             # only act if a signature is not explicitly given already, and if
1162             # the feature is enabled
1163             result = self._find_signature()
1164             if result is not None:
1165                 self.args, self.retann = result
1166         sig = super().format_signature(**kwargs)  # type: ignore
1167         if self._signatures:
1168             return "\n".join([sig] + self._signatures)
1169         else:
1170             return sig
1171 
1172 
1173 class DocstringStripSignatureMixin(DocstringSignatureMixin):
1174     """
1175     Mixin for AttributeDocumenter to provide the
1176     feature of stripping any function signature from the docstring.
1177     """
1178     def format_signature(self, **kwargs: Any) -> str:
1179         if self.args is None and self.env.config.autodoc_docstring_signature:  # type: ignore
1180             # only act if a signature is not explicitly given already, and if
1181             # the feature is enabled
1182             result = self._find_signature()
1183             if result is not None:
1184                 # Discarding _args is a only difference with
1185                 # DocstringSignatureMixin.format_signature.
1186                 # Documenter.format_signature use self.args value to format.
1187                 _args, self.retann = result
1188         return super().format_signature(**kwargs)
1189 
1190 
1191 class FunctionDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type: ignore
1192     """
1193     Specialized Documenter subclass for functions.
1194     """
1195     objtype = 'function'
1196     member_order = 30
1197 
1198     @classmethod
1199     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1200                             ) -> bool:
1201         # supports functions, builtins and bound methods exported at the module level
1202         return (inspect.isfunction(member) or inspect.isbuiltin(member) or
1203                 (inspect.isroutine(member) and isinstance(parent, ModuleDocumenter)))
1204 
1205     def format_args(self, **kwargs: Any) -> str:
1206         if self.env.config.autodoc_typehints in ('none', 'description'):
1207             kwargs.setdefault('show_annotation', False)
1208 
1209         try:
1210             self.env.app.emit('autodoc-before-process-signature', self.object, False)
1211             sig = inspect.signature(self.object, follow_wrapped=True)
1212             args = stringify_signature(sig, **kwargs)
1213         except TypeError as exc:
1214             logger.warning(__("Failed to get a function signature for %s: %s"),
1215                            self.fullname, exc)
1216             return None
1217         except ValueError:
1218             args = ''
1219 
1220         if self.env.config.strip_signature_backslash:
1221             # escape backslashes for reST
1222             args = args.replace('\\', '\\\\')
1223         return args
1224 
1225     def document_members(self, all_members: bool = False) -> None:
1226         pass
1227 
1228     def add_directive_header(self, sig: str) -> None:
1229         sourcename = self.get_sourcename()
1230         super().add_directive_header(sig)
1231 
1232         if inspect.iscoroutinefunction(self.object):
1233             self.add_line('   :async:', sourcename)
1234 
1235     def format_signature(self, **kwargs: Any) -> str:
1236         sigs = []
1237         if self.analyzer and '.'.join(self.objpath) in self.analyzer.overloads:
1238             # Use signatures for overloaded functions instead of the implementation function.
1239             overloaded = True
1240         else:
1241             overloaded = False
1242             sig = super().format_signature(**kwargs)
1243             sigs.append(sig)
1244 
1245         if inspect.is_singledispatch_function(self.object):
1246             # append signature of singledispatch'ed functions
1247             for typ, func in self.object.registry.items():
1248                 if typ is object:
1249                     pass  # default implementation. skipped.
1250                 else:
1251                     self.annotate_to_first_argument(func, typ)
1252 
1253                     documenter = FunctionDocumenter(self.directive, '')
1254                     documenter.object = func
1255                     documenter.objpath = [None]
1256                     sigs.append(documenter.format_signature())
1257         if overloaded:
1258             __globals__ = safe_getattr(self.object, '__globals__', {})
1259             for overload in self.analyzer.overloads.get('.'.join(self.objpath)):
1260                 overload = evaluate_signature(overload, __globals__)
1261                 sig = stringify_signature(overload, **kwargs)
1262                 sigs.append(sig)
1263 
1264         return "\n".join(sigs)
1265 
1266     def annotate_to_first_argument(self, func: Callable, typ: Type) -> None:
1267         """Annotate type hint to the first argument of function if needed."""
1268         try:
1269             sig = inspect.signature(func)
1270         except TypeError as exc:
1271             logger.warning(__("Failed to get a function signature for %s: %s"),
1272                            self.fullname, exc)
1273             return
1274         except ValueError:
1275             return
1276 
1277         if len(sig.parameters) == 0:
1278             return
1279 
1280         params = list(sig.parameters.values())
1281         if params[0].annotation is Parameter.empty:
1282             params[0] = params[0].replace(annotation=typ)
1283             try:
1284                 func.__signature__ = sig.replace(parameters=params)  # type: ignore
1285             except TypeError:
1286                 # failed to update signature (ex. built-in or extension types)
1287                 return
1288 
1289 
1290 class SingledispatchFunctionDocumenter(FunctionDocumenter):
1291     """
1292     Used to be a specialized Documenter subclass for singledispatch'ed functions.
1293 
1294     Retained for backwards compatibility, now does the same as the FunctionDocumenter
1295     """
1296 
1297 
1298 class DecoratorDocumenter(FunctionDocumenter):
1299     """
1300     Specialized Documenter subclass for decorator functions.
1301     """
1302     objtype = 'decorator'
1303 
1304     # must be lower than FunctionDocumenter
1305     priority = -1
1306 
1307     def format_args(self, **kwargs: Any) -> Any:
1308         args = super().format_args(**kwargs)
1309         if ',' in args:
1310             return args
1311         else:
1312             return None
1313 
1314 
1315 # Types which have confusing metaclass signatures it would be best not to show.
1316 # These are listed by name, rather than storing the objects themselves, to avoid
1317 # needing to import the modules.
1318 _METACLASS_CALL_BLACKLIST = [
1319     'enum.EnumMeta.__call__',
1320 ]
1321 
1322 
1323 class ClassDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type: ignore
1324     """
1325     Specialized Documenter subclass for classes.
1326     """
1327     objtype = 'class'
1328     member_order = 20
1329     option_spec = {
1330         'members': members_option, 'undoc-members': bool_option,
1331         'noindex': bool_option, 'inherited-members': inherited_members_option,
1332         'show-inheritance': bool_option, 'member-order': member_order_option,
1333         'exclude-members': exclude_members_option,
1334         'private-members': members_option, 'special-members': members_option,
1335     }  # type: Dict[str, Callable]
1336 
1337     _signature_class = None  # type: Any
1338     _signature_method_name = None  # type: str
1339 
1340     def __init__(self, *args: Any) -> None:
1341         super().__init__(*args)
1342         merge_members_option(self.options)
1343 
1344     @classmethod
1345     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1346                             ) -> bool:
1347         return isinstance(member, type)
1348 
1349     def import_object(self, raiseerror: bool = False) -> bool:
1350         ret = super().import_object(raiseerror)
1351         # if the class is documented under another name, document it
1352         # as data/attribute
1353         if ret:
1354             if hasattr(self.object, '__name__'):
1355                 self.doc_as_attr = (self.objpath[-1] != self.object.__name__)
1356             else:
1357                 self.doc_as_attr = True
1358         return ret
1359 
1360     def _get_signature(self) -> Tuple[Optional[Any], Optional[str], Optional[Signature]]:
1361         def get_user_defined_function_or_method(obj: Any, attr: str) -> Any:
1362             """ Get the `attr` function or method from `obj`, if it is user-defined. """
1363             if inspect.is_builtin_class_method(obj, attr):
1364                 return None
1365             attr = self.get_attr(obj, attr, None)
1366             if not (inspect.ismethod(attr) or inspect.isfunction(attr)):
1367                 return None
1368             return attr
1369 
1370         # This sequence is copied from inspect._signature_from_callable.
1371         # ValueError means that no signature could be found, so we keep going.
1372 
1373         # First, let's see if it has an overloaded __call__ defined
1374         # in its metaclass
1375         call = get_user_defined_function_or_method(type(self.object), '__call__')
1376 
1377         if call is not None:
1378             if "{0.__module__}.{0.__qualname__}".format(call) in _METACLASS_CALL_BLACKLIST:
1379                 call = None
1380 
1381         if call is not None:
1382             self.env.app.emit('autodoc-before-process-signature', call, True)
1383             try:
1384                 sig = inspect.signature(call, bound_method=True)
1385                 return type(self.object), '__call__', sig
1386             except ValueError:
1387                 pass
1388 
1389         # Now we check if the 'obj' class has a '__new__' method
1390         new = get_user_defined_function_or_method(self.object, '__new__')
1391         if new is not None:
1392             self.env.app.emit('autodoc-before-process-signature', new, True)
1393             try:
1394                 sig = inspect.signature(new, bound_method=True)
1395                 return self.object, '__new__', sig
1396             except ValueError:
1397                 pass
1398 
1399         # Finally, we should have at least __init__ implemented
1400         init = get_user_defined_function_or_method(self.object, '__init__')
1401         if init is not None:
1402             self.env.app.emit('autodoc-before-process-signature', init, True)
1403             try:
1404                 sig = inspect.signature(init, bound_method=True)
1405                 return self.object, '__init__', sig
1406             except ValueError:
1407                 pass
1408 
1409         # None of the attributes are user-defined, so fall back to let inspect
1410         # handle it.
1411         # We don't know the exact method that inspect.signature will read
1412         # the signature from, so just pass the object itself to our hook.
1413         self.env.app.emit('autodoc-before-process-signature', self.object, False)
1414         try:
1415             sig = inspect.signature(self.object, bound_method=False)
1416             return None, None, sig
1417         except ValueError:
1418             pass
1419 
1420         # Still no signature: happens e.g. for old-style classes
1421         # with __init__ in C and no `__text_signature__`.
1422         return None, None, None
1423 
1424     def format_args(self, **kwargs: Any) -> str:
1425         if self.env.config.autodoc_typehints in ('none', 'description'):
1426             kwargs.setdefault('show_annotation', False)
1427 
1428         try:
1429             self._signature_class, self._signature_method_name, sig = self._get_signature()
1430         except TypeError as exc:
1431             # __signature__ attribute contained junk
1432             logger.warning(__("Failed to get a constructor signature for %s: %s"),
1433                            self.fullname, exc)
1434             return None
1435 
1436         if sig is None:
1437             return None
1438 
1439         return stringify_signature(sig, show_return_annotation=False, **kwargs)
1440 
1441     def format_signature(self, **kwargs: Any) -> str:
1442         if self.doc_as_attr:
1443             return ''
1444 
1445         sig = super().format_signature()
1446 
1447         overloaded = False
1448         qualname = None
1449         # TODO: recreate analyzer for the module of class (To be clear, owner of the method)
1450         if self._signature_class and self._signature_method_name and self.analyzer:
1451             qualname = '.'.join([self._signature_class.__qualname__,
1452                                  self._signature_method_name])
1453             if qualname in self.analyzer.overloads:
1454                 overloaded = True
1455 
1456         sigs = []
1457         if overloaded:
1458             # Use signatures for overloaded methods instead of the implementation method.
1459             method = safe_getattr(self._signature_class, self._signature_method_name, None)
1460             __globals__ = safe_getattr(method, '__globals__', {})
1461             for overload in self.analyzer.overloads.get(qualname):
1462                 overload = evaluate_signature(overload, __globals__)
1463 
1464                 parameters = list(overload.parameters.values())
1465                 overload = overload.replace(parameters=parameters[1:],
1466                                             return_annotation=Parameter.empty)
1467                 sig = stringify_signature(overload, **kwargs)
1468                 sigs.append(sig)
1469         else:
1470             sigs.append(sig)
1471 
1472         return "\n".join(sigs)
1473 
1474     def add_directive_header(self, sig: str) -> None:
1475         sourcename = self.get_sourcename()
1476 
1477         if self.doc_as_attr:
1478             self.directivetype = 'attribute'
1479         super().add_directive_header(sig)
1480 
1481         if self.analyzer and '.'.join(self.objpath) in self.analyzer.finals:
1482             self.add_line('   :final:', sourcename)
1483 
1484         # add inheritance info, if wanted
1485         if not self.doc_as_attr and self.options.show_inheritance:
1486             sourcename = self.get_sourcename()
1487             self.add_line('', sourcename)
1488             if hasattr(self.object, '__bases__') and len(self.object.__bases__):
1489                 bases = [':class:`%s`' % b.__name__
1490                          if b.__module__ in ('__builtin__', 'builtins')
1491                          else ':class:`%s.%s`' % (b.__module__, b.__qualname__)
1492                          for b in self.object.__bases__]
1493                 self.add_line('   ' + _('Bases: %s') % ', '.join(bases),
1494                               sourcename)
1495 
1496     def get_doc(self, encoding: str = None, ignore: int = None) -> List[List[str]]:
1497         if encoding is not None:
1498             warnings.warn("The 'encoding' argument to autodoc.%s.get_doc() is deprecated."
1499                           % self.__class__.__name__,
1500                           RemovedInSphinx40Warning, stacklevel=2)
1501         lines = getattr(self, '_new_docstrings', None)
1502         if lines is not None:
1503             return lines
1504 
1505         content = self.env.config.autoclass_content
1506 
1507         docstrings = []
1508         attrdocstring = self.get_attr(self.object, '__doc__', None)
1509         if attrdocstring:
1510             docstrings.append(attrdocstring)
1511 
1512         # for classes, what the "docstring" is can be controlled via a
1513         # config value; the default is only the class docstring
1514         if content in ('both', 'init'):
1515             __init__ = self.get_attr(self.object, '__init__', None)
1516             initdocstring = getdoc(__init__, self.get_attr,
1517                                    self.env.config.autodoc_inherit_docstrings,
1518                                    self.parent, self.object_name)
1519             # for new-style classes, no __init__ means default __init__
1520             if (initdocstring is not None and
1521                 (initdocstring == object.__init__.__doc__ or  # for pypy
1522                  initdocstring.strip() == object.__init__.__doc__)):  # for !pypy
1523                 initdocstring = None
1524             if not initdocstring:
1525                 # try __new__
1526                 __new__ = self.get_attr(self.object, '__new__', None)
1527                 initdocstring = getdoc(__new__, self.get_attr,
1528                                        self.env.config.autodoc_inherit_docstrings,
1529                                        self.parent, self.object_name)
1530                 # for new-style classes, no __new__ means default __new__
1531                 if (initdocstring is not None and
1532                     (initdocstring == object.__new__.__doc__ or  # for pypy
1533                      initdocstring.strip() == object.__new__.__doc__)):  # for !pypy
1534                     initdocstring = None
1535             if initdocstring:
1536                 if content == 'init':
1537                     docstrings = [initdocstring]
1538                 else:
1539                     docstrings.append(initdocstring)
1540 
1541         tab_width = self.directive.state.document.settings.tab_width
1542         return [prepare_docstring(docstring, ignore, tab_width) for docstring in docstrings]
1543 
1544     def add_content(self, more_content: Any, no_docstring: bool = False) -> None:
1545         if self.doc_as_attr:
1546             classname = safe_getattr(self.object, '__qualname__', None)
1547             if not classname:
1548                 classname = safe_getattr(self.object, '__name__', None)
1549             if classname:
1550                 module = safe_getattr(self.object, '__module__', None)
1551                 parentmodule = safe_getattr(self.parent, '__module__', None)
1552                 if module and module != parentmodule:
1553                     classname = str(module) + '.' + str(classname)
1554                 content = StringList([_('alias of :class:`%s`') % classname], source='')
1555                 super().add_content(content, no_docstring=True)
1556         else:
1557             super().add_content(more_content)
1558 
1559     def document_members(self, all_members: bool = False) -> None:
1560         if self.doc_as_attr:
1561             return
1562         super().document_members(all_members)
1563 
1564     def generate(self, more_content: Any = None, real_modname: str = None,
1565                  check_module: bool = False, all_members: bool = False) -> None:
1566         # Do not pass real_modname and use the name from the __module__
1567         # attribute of the class.
1568         # If a class gets imported into the module real_modname
1569         # the analyzer won't find the source of the class, if
1570         # it looks in real_modname.
1571         return super().generate(more_content=more_content,
1572                                 check_module=check_module,
1573                                 all_members=all_members)
1574 
1575 
1576 class ExceptionDocumenter(ClassDocumenter):
1577     """
1578     Specialized ClassDocumenter subclass for exceptions.
1579     """
1580     objtype = 'exception'
1581     member_order = 10
1582 
1583     # needs a higher priority than ClassDocumenter
1584     priority = 10
1585 
1586     @classmethod
1587     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1588                             ) -> bool:
1589         return isinstance(member, type) and issubclass(member, BaseException)
1590 
1591 
1592 class DataDocumenter(ModuleLevelDocumenter):
1593     """
1594     Specialized Documenter subclass for data items.
1595     """
1596     objtype = 'data'
1597     member_order = 40
1598     priority = -10
1599     option_spec = dict(ModuleLevelDocumenter.option_spec)
1600     option_spec["annotation"] = annotation_option
1601 
1602     @classmethod
1603     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1604                             ) -> bool:
1605         return isinstance(parent, ModuleDocumenter) and isattr
1606 
1607     def add_directive_header(self, sig: str) -> None:
1608         super().add_directive_header(sig)
1609         sourcename = self.get_sourcename()
1610         if not self.options.annotation:
1611             # obtain annotation for this data
1612             try:
1613                 annotations = get_type_hints(self.parent)
1614             except NameError:
1615                 # Failed to evaluate ForwardRef (maybe TYPE_CHECKING)
1616                 annotations = safe_getattr(self.parent, '__annotations__', {})
1617             except TypeError:
1618                 annotations = {}
1619             except KeyError:
1620                 # a broken class found (refs: https://github.com/sphinx-doc/sphinx/issues/8084)
1621                 annotations = {}
1622             except AttributeError:
1623                 # AttributeError is raised on 3.5.2 (fixed by 3.5.3)
1624                 annotations = {}
1625 
1626             if self.objpath[-1] in annotations:
1627                 objrepr = stringify_typehint(annotations.get(self.objpath[-1]))
1628                 self.add_line('   :type: ' + objrepr, sourcename)
1629             else:
1630                 key = ('.'.join(self.objpath[:-1]), self.objpath[-1])
1631                 if self.analyzer and key in self.analyzer.annotations:
1632                     self.add_line('   :type: ' + self.analyzer.annotations[key],
1633                                   sourcename)
1634 
1635             try:
1636                 if self.object is UNINITIALIZED_ATTR:
1637                     pass
1638                 else:
1639                     objrepr = object_description(self.object)
1640                     self.add_line('   :value: ' + objrepr, sourcename)
1641             except ValueError:
1642                 pass
1643         elif self.options.annotation is SUPPRESS:
1644             pass
1645         else:
1646             self.add_line('   :annotation: %s' % self.options.annotation,
1647                           sourcename)
1648 
1649     def document_members(self, all_members: bool = False) -> None:
1650         pass
1651 
1652     def get_real_modname(self) -> str:
1653         return self.get_attr(self.parent or self.object, '__module__', None) \
1654             or self.modname
1655 
1656 
1657 class DataDeclarationDocumenter(DataDocumenter):
1658     """
1659     Specialized Documenter subclass for data that cannot be imported
1660     because they are declared without initial value (refs: PEP-526).
1661     """
1662     objtype = 'datadecl'
1663     directivetype = 'data'
1664     member_order = 60
1665 
1666     # must be higher than AttributeDocumenter
1667     priority = 11
1668 
1669     @classmethod
1670     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1671                             ) -> bool:
1672         """This documents only INSTANCEATTR members."""
1673         return (isinstance(parent, ModuleDocumenter) and
1674                 isattr and
1675                 member is INSTANCEATTR)
1676 
1677     def import_object(self, raiseerror: bool = False) -> bool:
1678         """Never import anything."""
1679         # disguise as a data
1680         self.objtype = 'data'
1681         self.object = UNINITIALIZED_ATTR
1682         try:
1683             # import module to obtain type annotation
1684             self.parent = importlib.import_module(self.modname)
1685         except ImportError:
1686             pass
1687 
1688         return True
1689 
1690     def add_content(self, more_content: Any, no_docstring: bool = False) -> None:
1691         """Never try to get a docstring from the object."""
1692         super().add_content(more_content, no_docstring=True)
1693 
1694 
1695 class GenericAliasDocumenter(DataDocumenter):
1696     """
1697     Specialized Documenter subclass for GenericAliases.
1698     """
1699 
1700     objtype = 'genericalias'
1701     directivetype = 'data'
1702     priority = DataDocumenter.priority + 1
1703 
1704     @classmethod
1705     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1706                             ) -> bool:
1707         return inspect.isgenericalias(member)
1708 
1709     def add_directive_header(self, sig: str) -> None:
1710         self.options.annotation = SUPPRESS  # type: ignore
1711         super().add_directive_header(sig)
1712 
1713     def add_content(self, more_content: Any, no_docstring: bool = False) -> None:
1714         name = stringify_typehint(self.object)
1715         content = StringList([_('alias of %s') % name], source='')
1716         super().add_content(content)
1717 
1718 
1719 class TypeVarDocumenter(DataDocumenter):
1720     """
1721     Specialized Documenter subclass for TypeVars.
1722     """
1723 
1724     objtype = 'typevar'
1725     directivetype = 'data'
1726     priority = DataDocumenter.priority + 1
1727 
1728     @classmethod
1729     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1730                             ) -> bool:
1731         return isinstance(member, TypeVar) and isattr  # type: ignore
1732 
1733     def add_directive_header(self, sig: str) -> None:
1734         self.options.annotation = SUPPRESS  # type: ignore
1735         super().add_directive_header(sig)
1736 
1737     def get_doc(self, encoding: str = None, ignore: int = None) -> List[List[str]]:
1738         if ignore is not None:
1739             warnings.warn("The 'ignore' argument to autodoc.%s.get_doc() is deprecated."
1740                           % self.__class__.__name__,
1741                           RemovedInSphinx50Warning, stacklevel=2)
1742 
1743         if self.object.__doc__ != TypeVar.__doc__:
1744             return super().get_doc()
1745         else:
1746             return []
1747 
1748     def add_content(self, more_content: Any, no_docstring: bool = False) -> None:
1749         attrs = [repr(self.object.__name__)]
1750         for constraint in self.object.__constraints__:
1751             attrs.append(stringify_typehint(constraint))
1752         if self.object.__covariant__:
1753             attrs.append("covariant=True")
1754         if self.object.__contravariant__:
1755             attrs.append("contravariant=True")
1756 
1757         content = StringList([_('alias of TypeVar(%s)') % ", ".join(attrs)], source='')
1758         super().add_content(content)
1759 
1760 
1761 class MethodDocumenter(DocstringSignatureMixin, ClassLevelDocumenter):  # type: ignore
1762     """
1763     Specialized Documenter subclass for methods (normal, static and class).
1764     """
1765     objtype = 'method'
1766     directivetype = 'method'
1767     member_order = 50
1768     priority = 1  # must be more than FunctionDocumenter
1769 
1770     @classmethod
1771     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1772                             ) -> bool:
1773         return inspect.isroutine(member) and \
1774             not isinstance(parent, ModuleDocumenter)
1775 
1776     def import_object(self, raiseerror: bool = False) -> bool:
1777         ret = super().import_object(raiseerror)
1778         if not ret:
1779             return ret
1780 
1781         # to distinguish classmethod/staticmethod
1782         obj = self.parent.__dict__.get(self.object_name)
1783         if obj is None:
1784             obj = self.object
1785 
1786         if (inspect.isclassmethod(obj) or
1787                 inspect.isstaticmethod(obj, cls=self.parent, name=self.object_name)):
1788             # document class and static members before ordinary ones
1789             self.member_order = self.member_order - 1
1790 
1791         return ret
1792 
1793     def format_args(self, **kwargs: Any) -> str:
1794         if self.env.config.autodoc_typehints in ('none', 'description'):
1795             kwargs.setdefault('show_annotation', False)
1796 
1797         try:
1798             if self.object == object.__init__ and self.parent != object:
1799                 # Classes not having own __init__() method are shown as no arguments.
1800                 #
1801                 # Note: The signature of object.__init__() is (self, /, *args, **kwargs).
1802                 #       But it makes users confused.
1803                 args = '()'
1804             else:
1805                 if inspect.isstaticmethod(self.object, cls=self.parent, name=self.object_name):
1806                     self.env.app.emit('autodoc-before-process-signature', self.object, False)
1807                     sig = inspect.signature(self.object, bound_method=False)
1808                 else:
1809                     self.env.app.emit('autodoc-before-process-signature', self.object, True)
1810                     sig = inspect.signature(self.object, bound_method=True,
1811                                             follow_wrapped=True)
1812                 args = stringify_signature(sig, **kwargs)
1813         except TypeError as exc:
1814             logger.warning(__("Failed to get a method signature for %s: %s"),
1815                            self.fullname, exc)
1816             return None
1817         except ValueError:
1818             args = ''
1819 
1820         if self.env.config.strip_signature_backslash:
1821             # escape backslashes for reST
1822             args = args.replace('\\', '\\\\')
1823         return args
1824 
1825     def add_directive_header(self, sig: str) -> None:
1826         super().add_directive_header(sig)
1827 
1828         sourcename = self.get_sourcename()
1829         obj = self.parent.__dict__.get(self.object_name, self.object)
1830         if inspect.isabstractmethod(obj):
1831             self.add_line('   :abstractmethod:', sourcename)
1832         if inspect.iscoroutinefunction(obj):
1833             self.add_line('   :async:', sourcename)
1834         if inspect.isclassmethod(obj):
1835             self.add_line('   :classmethod:', sourcename)
1836         if inspect.isstaticmethod(obj, cls=self.parent, name=self.object_name):
1837             self.add_line('   :staticmethod:', sourcename)
1838         if self.analyzer and '.'.join(self.objpath) in self.analyzer.finals:
1839             self.add_line('   :final:', sourcename)
1840 
1841     def document_members(self, all_members: bool = False) -> None:
1842         pass
1843 
1844     def format_signature(self, **kwargs: Any) -> str:
1845         sigs = []
1846         if self.analyzer and '.'.join(self.objpath) in self.analyzer.overloads:
1847             # Use signatures for overloaded methods instead of the implementation method.
1848             overloaded = True
1849         else:
1850             overloaded = False
1851             sig = super().format_signature(**kwargs)
1852             sigs.append(sig)
1853 
1854         meth = self.parent.__dict__.get(self.objpath[-1])
1855         if inspect.is_singledispatch_method(meth):
1856             # append signature of singledispatch'ed functions
1857             for typ, func in meth.dispatcher.registry.items():
1858                 if typ is object:
1859                     pass  # default implementation. skipped.
1860                 else:
1861                     self.annotate_to_first_argument(func, typ)
1862 
1863                     documenter = MethodDocumenter(self.directive, '')
1864                     documenter.parent = self.parent
1865                     documenter.object = func
1866                     documenter.objpath = [None]
1867                     sigs.append(documenter.format_signature())
1868         if overloaded:
1869             __globals__ = safe_getattr(self.object, '__globals__', {})
1870             for overload in self.analyzer.overloads.get('.'.join(self.objpath)):
1871                 overload = evaluate_signature(overload, __globals__)
1872                 if not inspect.isstaticmethod(self.object, cls=self.parent,
1873                                               name=self.object_name):
1874                     parameters = list(overload.parameters.values())
1875                     overload = overload.replace(parameters=parameters[1:])
1876                 sig = stringify_signature(overload, **kwargs)
1877                 sigs.append(sig)
1878 
1879         return "\n".join(sigs)
1880 
1881     def annotate_to_first_argument(self, func: Callable, typ: Type) -> None:
1882         """Annotate type hint to the first argument of function if needed."""
1883         try:
1884             sig = inspect.signature(func)
1885         except TypeError as exc:
1886             logger.warning(__("Failed to get a method signature for %s: %s"),
1887                            self.fullname, exc)
1888             return
1889         except ValueError:
1890             return
1891         if len(sig.parameters) == 1:
1892             return
1893 
1894         params = list(sig.parameters.values())
1895         if params[1].annotation is Parameter.empty:
1896             params[1] = params[1].replace(annotation=typ)
1897             try:
1898                 func.__signature__ = sig.replace(parameters=params)  # type: ignore
1899             except TypeError:
1900                 # failed to update signature (ex. built-in or extension types)
1901                 return
1902 
1903 
1904 class SingledispatchMethodDocumenter(MethodDocumenter):
1905     """
1906     Used to be a specialized Documenter subclass for singledispatch'ed methods.
1907 
1908     Retained for backwards compatibility, now does the same as the MethodDocumenter
1909     """
1910 
1911 
1912 class AttributeDocumenter(DocstringStripSignatureMixin, ClassLevelDocumenter):  # type: ignore
1913     """
1914     Specialized Documenter subclass for attributes.
1915     """
1916     objtype = 'attribute'
1917     member_order = 60
1918     option_spec = dict(ModuleLevelDocumenter.option_spec)
1919     option_spec["annotation"] = annotation_option
1920 
1921     # must be higher than the MethodDocumenter, else it will recognize
1922     # some non-data descriptors as methods
1923     priority = 10
1924 
1925     @staticmethod
1926     def is_function_or_method(obj: Any) -> bool:
1927         return inspect.isfunction(obj) or inspect.isbuiltin(obj) or inspect.ismethod(obj)
1928 
1929     @classmethod
1930     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1931                             ) -> bool:
1932         if inspect.isattributedescriptor(member):
1933             return True
1934         elif (not isinstance(parent, ModuleDocumenter) and
1935               not inspect.isroutine(member) and
1936               not isinstance(member, type)):
1937             return True
1938         else:
1939             return False
1940 
1941     def document_members(self, all_members: bool = False) -> None:
1942         pass
1943 
1944     def isinstanceattribute(self) -> bool:
1945         """Check the subject is an instance attribute."""
1946         try:
1947             analyzer = ModuleAnalyzer.for_module(self.modname)
1948             attr_docs = analyzer.find_attr_docs()
1949             if self.objpath:
1950                 key = ('.'.join(self.objpath[:-1]), self.objpath[-1])
1951                 if key in attr_docs:
1952                     return True
1953 
1954             return False
1955         except PycodeError:
1956             return False
1957 
1958     def import_object(self, raiseerror: bool = False) -> bool:
1959         try:
1960             ret = super().import_object(raiseerror=True)
1961             if inspect.isenumattribute(self.object):
1962                 self.object = self.object.value
1963             if inspect.isattributedescriptor(self.object):
1964                 self._datadescriptor = True
1965             else:
1966                 # if it's not a data descriptor
1967                 self._datadescriptor = False
1968         except ImportError as exc:
1969             if self.isinstanceattribute():
1970                 self.object = INSTANCEATTR
1971                 self._datadescriptor = False
1972                 ret = True
1973             elif raiseerror:
1974                 raise
1975             else:
1976                 logger.warning(exc.args[0], type='autodoc', subtype='import_object')
1977                 self.env.note_reread()
1978                 ret = False
1979 
1980         return ret
1981 
1982     def get_real_modname(self) -> str:
1983         return self.get_attr(self.parent or self.object, '__module__', None) \
1984             or self.modname
1985 
1986     def add_directive_header(self, sig: str) -> None:
1987         super().add_directive_header(sig)
1988         sourcename = self.get_sourcename()
1989         if not self.options.annotation:
1990             # obtain type annotation for this attribute
1991             try:
1992                 annotations = get_type_hints(self.parent)
1993             except NameError:
1994                 # Failed to evaluate ForwardRef (maybe TYPE_CHECKING)
1995                 annotations = safe_getattr(self.parent, '__annotations__', {})
1996             except TypeError:
1997                 annotations = {}
1998             except KeyError:
1999                 # a broken class found (refs: https://github.com/sphinx-doc/sphinx/issues/8084)
2000                 annotations = {}
2001             except AttributeError:
2002                 # AttributeError is raised on 3.5.2 (fixed by 3.5.3)
2003                 annotations = {}
2004 
2005             if self.objpath[-1] in annotations:
2006                 objrepr = stringify_typehint(annotations.get(self.objpath[-1]))
2007                 self.add_line('   :type: ' + objrepr, sourcename)
2008             else:
2009                 key = ('.'.join(self.objpath[:-1]), self.objpath[-1])
2010                 if self.analyzer and key in self.analyzer.annotations:
2011                     self.add_line('   :type: ' + self.analyzer.annotations[key],
2012                                   sourcename)
2013 
2014             # data descriptors do not have useful values
2015             if not self._datadescriptor:
2016                 try:
2017                     if self.object is INSTANCEATTR:
2018                         pass
2019                     else:
2020                         objrepr = object_description(self.object)
2021                         self.add_line('   :value: ' + objrepr, sourcename)
2022                 except ValueError:
2023                     pass
2024         elif self.options.annotation is SUPPRESS:
2025             pass
2026         else:
2027             self.add_line('   :annotation: %s' % self.options.annotation, sourcename)
2028 
2029     def get_doc(self, encoding: str = None, ignore: int = None) -> List[List[str]]:
2030         try:
2031             # Disable `autodoc_inherit_docstring` temporarily to avoid to obtain
2032             # a docstring from the value which descriptor returns unexpectedly.
2033             # ref: https://github.com/sphinx-doc/sphinx/issues/7805
2034             orig = self.env.config.autodoc_inherit_docstrings
2035             self.env.config.autodoc_inherit_docstrings = False  # type: ignore
2036             return super().get_doc(encoding, ignore)
2037         finally:
2038             self.env.config.autodoc_inherit_docstrings = orig  # type: ignore
2039 
2040     def add_content(self, more_content: Any, no_docstring: bool = False) -> None:
2041         if not self._datadescriptor:
2042             # if it's not a data descriptor, its docstring is very probably the
2043             # wrong thing to display
2044             no_docstring = True
2045         super().add_content(more_content, no_docstring)
2046 
2047 
2048 class PropertyDocumenter(DocstringStripSignatureMixin, ClassLevelDocumenter):  # type: ignore
2049     """
2050     Specialized Documenter subclass for properties.
2051     """
2052     objtype = 'property'
2053     directivetype = 'method'
2054     member_order = 60
2055 
2056     # before AttributeDocumenter
2057     priority = AttributeDocumenter.priority + 1
2058 
2059     @classmethod
2060     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
2061                             ) -> bool:
2062         return inspect.isproperty(member) and isinstance(parent, ClassDocumenter)
2063 
2064     def document_members(self, all_members: bool = False) -> None:
2065         pass
2066 
2067     def get_real_modname(self) -> str:
2068         return self.get_attr(self.parent or self.object, '__module__', None) \
2069             or self.modname
2070 
2071     def add_directive_header(self, sig: str) -> None:
2072         super().add_directive_header(sig)
2073         sourcename = self.get_sourcename()
2074         if inspect.isabstractmethod(self.object):
2075             self.add_line('   :abstractmethod:', sourcename)
2076         self.add_line('   :property:', sourcename)
2077 
2078 
2079 class InstanceAttributeDocumenter(AttributeDocumenter):
2080     """
2081     Specialized Documenter subclass for attributes that cannot be imported
2082     because they are instance attributes (e.g. assigned in __init__).
2083     """
2084     objtype = 'instanceattribute'
2085     directivetype = 'attribute'
2086     member_order = 60
2087 
2088     # must be higher than AttributeDocumenter
2089     priority = 11
2090 
2091     @classmethod
2092     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
2093                             ) -> bool:
2094         """This documents only INSTANCEATTR members."""
2095         return (not isinstance(parent, ModuleDocumenter) and
2096                 isattr and
2097                 member is INSTANCEATTR)
2098 
2099     def import_parent(self) -> Any:
2100         try:
2101             parent = importlib.import_module(self.modname)
2102             for name in self.objpath[:-1]:
2103                 parent = self.get_attr(parent, name)
2104 
2105             return parent
2106         except (ImportError, AttributeError):
2107             return None
2108 
2109     def import_object(self, raiseerror: bool = False) -> bool:
2110         """Never import anything."""
2111         # disguise as an attribute
2112         self.objtype = 'attribute'
2113         self.object = INSTANCEATTR
2114         self.parent = self.import_parent()
2115         self._datadescriptor = False
2116         return True
2117 
2118     def add_content(self, more_content: Any, no_docstring: bool = False) -> None:
2119         """Never try to get a docstring from the object."""
2120         super().add_content(more_content, no_docstring=True)
2121 
2122 
2123 class SlotsAttributeDocumenter(AttributeDocumenter):
2124     """
2125     Specialized Documenter subclass for attributes that cannot be imported
2126     because they are attributes in __slots__.
2127     """
2128     objtype = 'slotsattribute'
2129     directivetype = 'attribute'
2130     member_order = 60
2131 
2132     # must be higher than AttributeDocumenter
2133     priority = 11
2134 
2135     @classmethod
2136     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
2137                             ) -> bool:
2138         """This documents only SLOTSATTR members."""
2139         return member is SLOTSATTR
2140 
2141     def import_object(self, raiseerror: bool = False) -> bool:
2142         """Never import anything."""
2143         # disguise as an attribute
2144         self.objtype = 'attribute'
2145         self._datadescriptor = True
2146 
2147         with mock(self.env.config.autodoc_mock_imports):
2148             try:
2149                 ret = import_object(self.modname, self.objpath[:-1], 'class',
2150                                     attrgetter=self.get_attr,
2151                                     warningiserror=self.env.config.autodoc_warningiserror)
2152                 self.module, _, _, self.parent = ret
2153                 return True
2154             except ImportError as exc:
2155                 if raiseerror:
2156                     raise
2157                 else:
2158                     logger.warning(exc.args[0], type='autodoc', subtype='import_object')
2159                     self.env.note_reread()
2160                     return False
2161 
2162     def get_doc(self, encoding: str = None, ignore: int = None) -> List[List[str]]:
2163         """Decode and return lines of the docstring(s) for the object."""
2164         if ignore is not None:
2165             warnings.warn("The 'ignore' argument to autodoc.%s.get_doc() is deprecated."
2166                           % self.__class__.__name__,
2167                           RemovedInSphinx50Warning, stacklevel=2)
2168         name = self.objpath[-1]
2169         __slots__ = safe_getattr(self.parent, '__slots__', [])
2170         if isinstance(__slots__, dict) and isinstance(__slots__.get(name), str):
2171             docstring = prepare_docstring(__slots__[name])
2172             return [docstring]
2173         else:
2174             return []
2175 
2176 
2177 def get_documenters(app: Sphinx) -> Dict[str, "Type[Documenter]"]:
2178     """Returns registered Documenter classes"""
2179     warnings.warn("get_documenters() is deprecated.", RemovedInSphinx50Warning, stacklevel=2)
2180     return app.registry.documenters
2181 
2182 
2183 def autodoc_attrgetter(app: Sphinx, obj: Any, name: str, *defargs: Any) -> Any:
2184     """Alternative getattr() for types"""
2185     for typ, func in app.registry.autodoc_attrgettrs.items():
2186         if isinstance(obj, typ):
2187             return func(obj, name, *defargs)
2188 
2189     return safe_getattr(obj, name, *defargs)
2190 
2191 
2192 def migrate_autodoc_member_order(app: Sphinx, config: Config) -> None:
2193     if config.autodoc_member_order == 'alphabetic':
2194         # RemovedInSphinx50Warning
2195         logger.warning(__('autodoc_member_order now accepts "alphabetical" '
2196                           'instead of "alphabetic". Please update your setting.'))
2197         config.autodoc_member_order = 'alphabetical'  # type: ignore
2198 
2199 
2200 def setup(app: Sphinx) -> Dict[str, Any]:
2201     app.add_autodocumenter(ModuleDocumenter)
2202     app.add_autodocumenter(ClassDocumenter)
2203     app.add_autodocumenter(ExceptionDocumenter)
2204     app.add_autodocumenter(DataDocumenter)
2205     app.add_autodocumenter(DataDeclarationDocumenter)
2206     app.add_autodocumenter(GenericAliasDocumenter)
2207     app.add_autodocumenter(TypeVarDocumenter)
2208     app.add_autodocumenter(FunctionDocumenter)
2209     app.add_autodocumenter(DecoratorDocumenter)
2210     app.add_autodocumenter(MethodDocumenter)
2211     app.add_autodocumenter(AttributeDocumenter)
2212     app.add_autodocumenter(PropertyDocumenter)
2213     app.add_autodocumenter(InstanceAttributeDocumenter)
2214     app.add_autodocumenter(SlotsAttributeDocumenter)
2215 
2216     app.add_config_value('autoclass_content', 'class', True, ENUM('both', 'class', 'init'))
2217     app.add_config_value('autodoc_member_order', 'alphabetical', True,
2218                          ENUM('alphabetic', 'alphabetical', 'bysource', 'groupwise'))
2219     app.add_config_value('autodoc_default_options', {}, True)
2220     app.add_config_value('autodoc_docstring_signature', True, True)
2221     app.add_config_value('autodoc_mock_imports', [], True)
2222     app.add_config_value('autodoc_typehints', "signature", True,
2223                          ENUM("signature", "description", "none"))
2224     app.add_config_value('autodoc_warningiserror', True, True)
2225     app.add_config_value('autodoc_inherit_docstrings', True, True)
2226     app.add_event('autodoc-before-process-signature')
2227     app.add_event('autodoc-process-docstring')
2228     app.add_event('autodoc-process-signature')
2229     app.add_event('autodoc-skip-member')
2230 
2231     app.connect('config-inited', migrate_autodoc_member_order, priority=800)
2232 
2233     app.setup_extension('sphinx.ext.autodoc.type_comment')
2234     app.setup_extension('sphinx.ext.autodoc.typehints')
2235 
2236     return {'version': sphinx.__display_version__, 'parallel_read_safe': True}

</code><intended_behavior>If this file or related files within the autodoc extension are contributing to the issue, they should be inspected for how they parse and render doc comments, particularly around generics and inheritance. Modifications might be needed to explicitly handle or better support doc comments on generic class attributes. This could include adjusting parsing logic to correctly interpret field lists within these contexts or providing configuration options that allow users to specify how such comments should be treated. The aim is again to preserve the functionality of automatic documentation generation while ensuring it does not misinterpret or incorrectly format comments, avoiding warnings.</intended_behavior>]
2025-10-18 06:58:57.209 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-18 06:58:57.209 | INFO     | Search-only: skipping patch selection
2025-10-18 06:58:57.327 | INFO     | Task sphinx-doc__sphinx-8202 completed successfully.
2025-10-18 06:58:57.328 | INFO     | No patch generated. You can try running ACR again.
