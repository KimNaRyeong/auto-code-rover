[
    {
        "rel_file_path": "django/conf/__init__.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.0/django/conf/__init__.py",
        "start": 97,
        "end": 108,
        "class_name": "LazySettings",
        "method_name": "configure",
        "code": "97     def configure(self, default_settings=global_settings, **options):\n98         \"\"\"\n99         Called to manually configure the settings. The 'default_settings'\n100         parameter sets where to retrieve any unspecified values from (its\n101         argument must support attribute access (__getattr__)).\n102         \"\"\"\n103         if self._wrapped is not empty:\n104             raise RuntimeError('Settings already configured.')\n105         holder = UserSettingsHolder(default_settings)\n106         for name, value in options.items():\n107             setattr(holder, name, value)\n108         self._wrapped = holder\n",
        "intended_behavior": "Modify this method to iterate through the **options argument and check if each setting name (key in options.items()) is uppercase. If a key is not uppercase, the method should either raise a ValueError indicating that only uppercase settings are allowed or silently skip setting these improperly named settings. This enforces the documented convention that settings should be uppercase. The existing functionality for setting custom settings via this method is preserved, except that it now validates the case of setting names."
    },
    {
        "rel_file_path": "django/conf/__init__.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.0/django/conf/__init__.py",
        "start": 42,
        "end": 127,
        "class_name": "LazySettings",
        "method_name": null,
        "code": "42 class LazySettings(LazyObject):\n43     \"\"\"\n44     A lazy proxy for either global Django settings or a custom settings object.\n45     The user can manually configure settings prior to using them. Otherwise,\n46     Django uses the settings module pointed to by DJANGO_SETTINGS_MODULE.\n47     \"\"\"\n48     def _setup(self, name=None):\n49         \"\"\"\n50         Load the settings module pointed to by the environment variable. This\n51         is used the first time settings are needed, if the user hasn't\n52         configured settings manually.\n53         \"\"\"\n54         settings_module = os.environ.get(ENVIRONMENT_VARIABLE)\n55         if not settings_module:\n56             desc = (\"setting %s\" % name) if name else \"settings\"\n57             raise ImproperlyConfigured(\n58                 \"Requested %s, but settings are not configured. \"\n59                 \"You must either define the environment variable %s \"\n60                 \"or call settings.configure() before accessing settings.\"\n61                 % (desc, ENVIRONMENT_VARIABLE))\n62 \n63         self._wrapped = Settings(settings_module)\n64 \n65     def __repr__(self):\n66         # Hardcode the class name as otherwise it yields 'Settings'.\n67         if self._wrapped is empty:\n68             return '<LazySettings [Unevaluated]>'\n69         return '<LazySettings \"%(settings_module)s\">' % {\n70             'settings_module': self._wrapped.SETTINGS_MODULE,\n71         }\n72 \n73     def __getattr__(self, name):\n74         \"\"\"Return the value of a setting and cache it in self.__dict__.\"\"\"\n75         if self._wrapped is empty:\n76             self._setup(name)\n77         val = getattr(self._wrapped, name)\n78         self.__dict__[name] = val\n79         return val\n80 \n81     def __setattr__(self, name, value):\n82         \"\"\"\n83         Set the value of setting. Clear all cached values if _wrapped changes\n84         (@override_settings does this) or clear single values when set.\n85         \"\"\"\n86         if name == '_wrapped':\n87             self.__dict__.clear()\n88         else:\n89             self.__dict__.pop(name, None)\n90         super().__setattr__(name, value)\n91 \n92     def __delattr__(self, name):\n93         \"\"\"Delete a setting and clear it from cache if needed.\"\"\"\n94         super().__delattr__(name)\n95         self.__dict__.pop(name, None)\n96 \n97     def configure(self, default_settings=global_settings, **options):\n98         \"\"\"\n99         Called to manually configure the settings. The 'default_settings'\n100         parameter sets where to retrieve any unspecified values from (its\n101         argument must support attribute access (__getattr__)).\n102         \"\"\"\n103         if self._wrapped is not empty:\n104             raise RuntimeError('Settings already configured.')\n105         holder = UserSettingsHolder(default_settings)\n106         for name, value in options.items():\n107             setattr(holder, name, value)\n108         self._wrapped = holder\n109 \n110     @property\n111     def configured(self):\n112         \"\"\"Return True if the settings have already been configured.\"\"\"\n113         return self._wrapped is not empty\n114 \n115     @property\n116     def FILE_CHARSET(self):\n117         stack = traceback.extract_stack()\n118         # Show a warning if the setting is used outside of Django.\n119         # Stack index: -1 this line, -2 the caller.\n120         filename, _line_number, _function_name, _text = stack[-2]\n121         if not filename.startswith(os.path.dirname(django.__file__)):\n122             warnings.warn(\n123                 FILE_CHARSET_DEPRECATED_MSG,\n124                 RemovedInDjango31Warning,\n125                 stacklevel=2,\n126             )\n127         return self.__getattr__('FILE_CHARSET')\n",
        "intended_behavior": "This class provides additional context to the issue."
    }
]